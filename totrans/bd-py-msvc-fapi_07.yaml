- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Securing the REST APIs
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护REST API
- en: Building microservices means exposing the entire application to the worldwide
    web. For every request-response transaction, the client accesses the endpoint
    of the API publicly, which poses potential risks to the application. Unlike web-based
    applications, API services have weak mechanisms to manage user access using login
    controls. Thus, this chapter will provide several ways to protect the API services
    created using the FastAPI framework.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 构建微服务意味着将整个应用程序暴露给全球互联网。对于每一次请求-响应事务，客户端都会公开访问API的端点，这对应用程序构成了潜在风险。与基于Web的应用程序不同，API服务在管理用户访问方面具有较弱的控制机制。因此，本章将提供几种保护使用FastAPI框架创建的API服务的方法。
- en: There is no such thing as perfect security. The main goal is to establish policies
    and solutions related to the *confidentiality*, *integrity*, and *availability*
    of these services. The *confidentiality policy* requires tokens, encryption and
    decryption, and certificates as mechanisms to make some APIs private. On the other
    hand, the *integrity policy* involves maintaining the data exchange as authentic,
    accurate, and reliable by using a "state" and hashed codes during the authentication
    and authorization process. The *availability policy* means protecting the endpoint
    access from DoS attacks, phishing, and timing attacks using reliable tools and
    Python modules. Overall, these three aspects of the security model are the essential
    elements to consider when building security solutions for our microservices.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 没有绝对的安全。主要目标是建立与这些服务的*机密性*、*完整性*和*可用性*相关的政策和解决方案。*机密性政策*需要使用令牌、加密和解密以及证书作为机制来使某些API私有化。另一方面，*完整性政策*涉及在认证和授权过程中使用“状态”和散列码来维护数据交换的真实性、准确性和可靠性。*可用性政策*意味着使用可靠的工具和Python模块来保护端点访问，防止DoS攻击、钓鱼攻击和时间攻击。总的来说，安全模型这三个方面是构建微服务安全解决方案时必须考虑的基本要素。
- en: 'Although FastAPI has no built-in security framework, it supports different
    authentication modes such as *Basic* and *Digest*. It also has built-in modules
    that implement security specifications such as *OAuth2*, *OpenID*, and *OpenAPI*.
    The following main topics will be covered in this chapter to explain and illustrate
    the concepts and solutions for securing our FastAPI services:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管FastAPI没有内置的安全框架，但它支持不同的认证模式，如*基本*和*摘要*。它还内置了实现安全规范（如*OAuth2*、*OpenID*和*OpenAPI*）的模块。本章将涵盖以下主要主题，以解释和说明确保我们的FastAPI服务概念和解决方案：
- en: Implementing Basic and Digest authentication
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现基本和摘要认证
- en: Implementing password-based authentication
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现基于密码的认证
- en: Applying JWTs
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用JWT
- en: Creating scope-based authorization
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建基于范围的授权
- en: Building the authorization code flow
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建授权代码流
- en: Applying the OpenID Connect specification
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用OpenID Connect规范
- en: Using built-in middleware for authentication
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用内置中间件进行认证
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The software prototype for this chapter is a *secure online auction system*
    designed to manage online bidding on various items auctioned by its registered
    users. The system can bid on any items based within a price range and even declare
    those who won the bidding. The system needs to secure some sensitive transactions
    to avoid data breaches and biased results. The prototype will be using *SQLAlchemy*
    as the ORM for managing data. There will be 10 versions of our prototype and each
    will showcase a different authentication scheme. All 10 of these projects (`ch07a`
    to `ch07j`) can be found here: [https://github.com/PacktPublishing/Building-Python-Microservices-with-FastAPI](https://github.com/PacktPublishing/Building-Python-Microservices-with-FastAPI).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的软件原型是一个*安全的在线拍卖系统*，旨在管理其注册用户拍卖的各种物品的在线竞标。系统可以在价格范围内对任何物品进行竞标，甚至宣布竞标胜利者。系统需要保护一些敏感交易，以避免数据泄露和结果偏差。原型将使用*SQLAlchemy*作为ORM来管理数据。将有10个版本的我们的原型，每个原型将展示不同的认证方案。所有10个这些项目（`ch07a`到`ch07j`）都可以在这里找到：[https://github.com/PacktPublishing/Building-Python-Microservices-with-FastAPI](https://github.com/PacktPublishing/Building-Python-Microservices-with-FastAPI)。
- en: Implementing Basic and Digest authentication
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现基本和摘要认证
- en: The Basic and Digest authentication schemes are the easiest authentication solutions
    that we can use to secure API endpoints. Both schemes are alternative authentication
    mechanisms that can be applied to small and low-risk applications without requiring
    complex configuration and coding. Let us now use these schemes to secure our prototype.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 基本认证和摘要认证方案是我们可以使用来保护API端点的最简单认证解决方案。这两种方案都是可以作为替代认证机制应用于小型和低风险应用，而不需要复杂的配置和编码。现在让我们使用这些方案来保护我们的原型。
- en: Using Basic authentication
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用基本认证
- en: The most straightforward way to secure the API endpoint is the *Basic authentication*
    approach. However, this authentication mechanism must not be applied to high-risk
    applications because the credentials, commonly a username and password, sent from
    the client to the security scheme provider are in the *Base64-encoded* format,
    which is vulnerable to many attacks such as *brute force*, *timing attacks*, and
    *sniffing*. Base64 is not an encryption algorithm but simply a way of representing
    the credentials in *ciphertext* format.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 保护API端点最直接的方法是*基本认证*方法。然而，这种认证机制不应应用于高风险应用，因为从客户端发送到安全方案提供者的凭据，通常是一个用户名和密码，是以*Base64编码*格式发送的，容易受到许多攻击，如*暴力破解*、*时间攻击*和*嗅探*。Base64不是一个加密算法，而是一种将凭据表示为*密文格式*的方法。
- en: Applying HttpBasic and HttpBasicCredentials
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 应用HttpBasic和HttpBasicCredentials
- en: 'The prototype, `ch07a`, uses the Basic authentication mode to secure its administration
    and bidding and auctioning transactions. Its implementation in the `/security/secure.py`
    module is shown in the following code:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 原型`ch07a`使用基本认证模式来确保其管理和投标及拍卖交易的安全。其在`/security/secure.py`模块中的实现如下所示：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The FastAPI framework supports different authentication modes and specifications
    through its `fastapi.security` module. To pursue the *Basic* authentication scheme,
    we need to instantiate the `HTTPBasic` class of the module and inject it into
    each API service to secure the endpoint access. The `http_basic` instance, once
    injected into the API services, causes the browser to pop up a login form, through
    which we type the `username` and `password` credentials. Logging in will trigger
    the browser to send a header with the credentials to the application. If the application
    encounters a problem with receiving it, the `HTTPBasic` scheme will throw an *HTTP
    status code 401* with an *"Unauthorized"* message. If there are no errors in the
    form handling, the application must receive a `WWW-Authenticate` header with a
    `Basic` value and an optional `realm` parameter.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: FastAPI框架通过其`fastapi.security`模块支持不同的认证模式和规范。为了追求*基本*认证方案，我们需要实例化模块中的`HTTPBasic`类并将其注入到每个API服务中，以保护端点访问。一旦`http_basic`实例被注入到API服务中，就会导致浏览器弹出登录表单，通过该表单我们输入`用户名`和`密码`凭据。登录将触发浏览器向应用程序发送包含凭据的头部信息。如果应用程序在接收凭据时遇到问题，`HTTPBasic`方案将抛出*HTTP状态码401*并带有*"未经授权"*的消息。如果没有表单处理错误，应用程序必须接收到一个带有`Basic`值和可选的`realm`参数的`WWW-Authenticate`头部。
- en: On the other hand, the `/ch07/login` service will call the `authentication()`method
    to verify whether the browser credentials are authentic and correct. We need to
    be very careful in accepting user credentials from browsers since they are prone
    to various attacks. First, we can require endpoint users to use an *email address*
    as their username and require long passwords with a combination of different characters,
    numbers, and symbols. All stored passwords must be encoded using the most reliable
    encryption tools, such as the `CryptContext` class from the `passlib` module.
    The `passlib` extension provides more secured hashing algorithms than any Python
    encryption module. Our application uses `SHA256` and `MD5` hashing algorithms
    instead of the recommended `bcrypt`, which is slower and prone to attacks.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`/ch07/login`服务将调用`authentication()`方法来验证浏览器凭据是否真实且正确。在从浏览器接受用户凭据时，我们需要非常小心，因为它们容易受到各种攻击。首先，我们可以要求端点用户使用*电子邮件地址*作为用户名，并要求使用不同字符、数字和符号组合的长密码。所有存储的密码都必须使用最可靠的加密工具进行编码，例如`passlib`模块中的`CryptContext`类。`passlib`扩展提供了比任何Python加密模块更安全的哈希算法。我们的应用程序使用`SHA256`和`MD5`哈希算法，而不是推荐的`bcrypt`，因为`bcrypt`速度较慢且容易受到攻击。
- en: Second, we can avoid storing the credentials in the source code and use database
    storage or a`.env` file instead. The `authenticate()` method checks the credentials
    against the `Login` database record provided by the API service for correctness.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们可以避免在源代码中存储凭证，而是使用数据库存储或 `.env` 文件。`authenticate()` 方法将凭证与 API 服务提供的 `Login`
    数据库记录进行核对以确保正确性。
- en: 'Lastly, always use the `compare_digest()` from the `secret` module when comparing
    credentials from the browser with the `Login` credentials stored in the database.
    This function randomly compares two strings while guarding the operation against
    timing attacks. A *timing attack* is a kind of attack that compromises the crypto-algorithm
    execution, which happens when there is a linear comparison of strings in the system:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，始终在比较来自浏览器的凭证与数据库中存储的 `Login` 凭证时使用 `secret` 模块中的 `compare_digest()`。此函数在随机比较两个字符串的同时，保护操作免受时间攻击。时间攻击是一种攻击方式，它破坏了加密算法的执行，这发生在系统中对字符串进行线性比较时：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Our `authenticate()` method has all the needed requirements to help reduce attacks
    from outside factors. But the ultimate solution to secure Basic authentication
    is to install and configure a *Transport Layer Security* (*TLS*) (or *HTTPS*,
    or *SSL*) connection for the application.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `authenticate()` 方法具有所有必要的功能，有助于减少来自外部因素的攻击。但确保基本认证安全性的最终解决方案是为应用程序安装和配置
    *传输层安全性* (*TLS*)（或 *HTTPS*，或 *SSL*）连接。
- en: 'Now, we need to implement a `/ch07/login` endpoint to apply the *Basic* authentication
    scheme. The `http_basic` instance is injected into this API service to extract
    `HTTPBasicCredentials`, which is the object that contains the *username* and *password*
    details from the browser. This service is also the one that calls the `authenticate()`
    method to check the user credentials. If the method returns a `False` value, the
    service will raise an *HTTP status code 400* with an *"Incorrect credentials"*
    message:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要实现一个 `/ch07/login` 端点以应用 *基本* 认证方案。`http_basic` 实例被注入到这个 API 服务中，用于提取
    `HTTPBasicCredentials`，这是一个包含从浏览器中获取的 *用户名* 和 *密码* 详细信息的对象。此服务也是调用 `authenticate()`
    方法来检查用户凭证的服务。如果该方法返回一个 `False` 值，服务将抛出一个 *HTTP 状态码 400* 并带有 *"凭证错误"* 的消息：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Each endpoint of the *online auction system* must have the injected `http_basic`
    instance to secure it from public access. For instance, the cited `list_all_login()`
    service can only return a list of all users if the user is an authenticated one.
    By the way, there is no reliable procedure to log off using *Basic* authentication.
    If the `WWW-Authenticate` header has been issued and recognized by the browser,
    we will seldom see the login form of the browser pop up.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '*在线拍卖系统* 的每个端点都必须注入 `http_basic` 实例以防止公共访问。例如，引用的 `list_all_login()` 服务只能返回所有用户的列表，如果用户是经过认证的。顺便说一下，没有可靠的方法使用
    *基本* 认证注销。如果 `WWW-Authenticate` 标头已被浏览器发出并识别，我们很少会看到浏览器登录表单弹出。'
- en: Executing the login transaction
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 执行登录事务
- en: 'We can use either the `curl` command or the browser to perform the `/ch07/login`
    transaction. But to highlight the support of FastAPI, we will be using its OpenAPI
    dashboard to run `/ch07/login`. After accessing `http://localhost:8000/docs` on
    the browser, locate the `/ch07/login` GET transaction and click the **Try it out**
    button. The browser’s login form, as shown in *Figure 7.1*, will pop up after
    clicking the button:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `curl` 命令或浏览器来执行 `/ch07/login` 事务。但为了突出 FastAPI 的支持，我们将使用其 OpenAPI 仪表板来运行
    `/ch07/login`。在浏览器上访问 `http://localhost:8000/docs` 后，定位到 `/ch07/login` GET 事务并点击
    **尝试它** 按钮。点击按钮后，浏览器登录表单，如 *图 7.1* 所示，将弹出：
- en: '![Figure 7.1 – The browser’s login form'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.1 – 浏览器的登录表单'
- en: '](img/Figure_7.01_B17975.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.01_B17975.jpg)'
- en: Figure 7.1 – The browser’s login form
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.1 – 浏览器的登录表单
- en: 'After the `/ch07/signup/add` and `/ch07/approve/signup` to add the user credentials
    you want to test. Remember that all stored passwords are encrypted. *Figure 7.2*
    shows how `/ch07/login` will output the user’s `Login` record after the authentication
    process finds that the user credentials are valid:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `/ch07/signup/add` 和 `/ch07/approve/signup` 后添加您想要测试的用户凭证。请记住，所有存储的密码都是加密的。*图
    7.2* 展示了在认证过程发现用户凭证有效后，`/ch07/login` 将如何输出用户的 `登录` 记录：
- en: '![Figure 7.2 – The /login response'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.2 – /login 响应'
- en: '](img/Figure_7.02_B17975.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.02_B17975.jpg)'
- en: Figure 7.2 – The /login response
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.2 – /login 响应
- en: 'Now that the user is authenticated, run `/ch07/login/users/list` through the
    OpenAPI dashboard to retrieve the list of login details. The `uvicorn` server
    log will show the following log message:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在用户已经认证，通过 OpenAPI 控制台运行 `/ch07/login/users/list` 来检索登录详情。`uvicorn` 服务器日志将显示以下日志信息：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This means that the user is authorized to run the endpoint. Now, let us apply
    the Digest authentication scheme to our prototype.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着用户有权运行该端点。现在，让我们将 Digest 认证方案应用到我们的原型中。
- en: Using Digest authentication
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Digest 认证
- en: Digest authentication is more secure than the Basic scheme because the former
    needs to hash the user credentials first before sending the hashed version to
    the application. Digest authentication in FastAPI does not include an automatic
    encryption process of user credentials using the default *MD5* encryption. It
    is an authentication scheme that stores credentials in a `.env` or `.config` property
    file and creates a hashed string value for these credentials before the authentication.
    The `ch07b` project applies the Digest authentication scheme to secure the bidding
    and auctioning transactions.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Digest 认证比基本方案更安全，因为前者需要在发送到应用程序的哈希版本之前先对用户凭据进行哈希处理。FastAPI 中的 Digest 认证不包括使用默认
    *MD5* 加密的自动加密用户凭据的过程。它是一种将凭据存储在 `.env` 或 `.config` 属性文件中，并在认证之前为这些凭据创建哈希字符串值的认证方案。`ch07b`
    项目应用 Digest 认证方案以保护投标和拍卖交易。
- en: Generating the hashed credentials
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 生成哈希凭据
- en: 'So, before we start the implementation, we first need to create a custom utility
    script, `generate_hash.py`, that generates a digest in binary form using Base64
    encoding. The script must have the following code:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在我们开始实现之前，我们首先需要创建一个自定义实用脚本 `generate_hash.py`，该脚本使用 Base64 编码生成二进制的摘要。该脚本必须包含以下代码：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `urlsafe_b64encode()` function from the `base64` module creates a digest
    in binary format from the `username:password` credential format. After running
    the script, we save the digest value anywhere safe, but not in the source code.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`base64` 模块中的 `urlsafe_b64encode()` 函数从 `username:password` 凭据格式创建一个二进制的摘要。在运行脚本后，我们将摘要值保存在任何安全的地方，但不能在源代码中。'
- en: Passing the user credentials
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 传递用户凭据
- en: 'Aside from the digest, we also need to save the user credentials for the Digest
    scheme provider later. Unlike the standard Digest authentication procedure, where
    the user negotiates with the browser, FastAPI requires storing the user credentials
    in a`.env` or `.config` file inside our application to be retrieved by the authentication
    process. In the `ch07b` project, we save the username and password inside the
    `.config` file, in this manner:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 除了摘要之外，我们还需要保存 Digest 方案提供者的用户凭据，以便稍后使用。与标准 Digest 认证过程不同，在该过程中用户与浏览器协商，FastAPI
    需要将用户凭据存储在我们的应用程序内的 `.env` 或 `.config` 文件中，以便在认证过程中检索。在 `ch07b` 项目中，我们将用户名和密码保存在
    `.config` 文件中，如下所示：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Then, we create a parser through the `ConfigParser` utility to extract the
    following details from the `.config` file and build a `dict` out of the serialized
    user details. The following `build_map()` is an example of the parser implementation:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们通过 `ConfigParser` 工具创建一个解析器，从 `.config` 文件中提取以下详细信息，并使用序列化的用户详情构建一个 `dict`。以下
    `build_map()` 是解析器实现的示例：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Using HTTPDigest and HTTPAuthorizationCredentials
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 HTTPDigest 和 HTTPAuthorizationCredentials
- en: 'The FastAPI framework has an `HTTPDigest` from its `fastapi.security` module
    that implements a Digest authentication scheme with a different approach to managing
    user credentials and generating the digest. Unlike in Basic authentication, the
    `HTTPDigest` authentication process happens at the `APIRouter` level. We inject
    the following `authenticate()`dependable into the API services through the HTTP
    operator, including `/login`, where the authentication starts:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: FastAPI 框架在其 `fastapi.security` 模块中有一个 `HTTPDigest`，它以不同的方式管理用户凭据并生成摘要，实现了 Digest
    认证方案。与基本认证不同，`HTTPDigest` 认证过程发生在 `APIRouter` 层级。我们通过 HTTP 操作将以下 `authenticate()`
    可依赖项注入到 API 服务中，包括 `/login`，认证从这里开始：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `authenticate()` method is where the `http_digest` is injected to extract
    the `HTTPAuthorizationCredentials` that contains the digest byte value. After
    extraction, it checks whether the digest matches the credentials saved in the
    `.config` file. We also use `compare_digest` to compare `hashed_credentials` from
    the header and the Base64-encoded credentials from the `.config` file.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`authenticate()`方法是将`http_digest`注入到提取包含摘要字节的`HTTPAuthorizationCredentials`的地方。提取后，它会检查摘要是否与保存在`.config`文件中的凭证匹配。我们还使用`compare_digest`来比较来自头部的`hashed_credentials`和来自`.config`文件的Base64编码的凭证。'
- en: Executing the login transaction
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 执行登录事务
- en: 'After implementing the `authenticate()` method, we inject it into the API services,
    not in the method parameter, but in its HTTP operator. Notice that the `http_digest`
    object is not injected directly into the API services, unlike in the *Basic* authentication
    scheme. The following implementation shows how the `authenticate()` dependable
    is applied to secure all the crucial endpoints of the application:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现`authenticate()`方法后，我们将它注入到API服务中，不是在方法参数中，而是在其HTTP操作符中。请注意，与*基本*认证方案不同，`http_digest`对象不是直接注入到API服务中的。以下实现展示了如何将`authenticate()`方法应用于保护应用程序的所有关键端点：
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Since the Digest authentication scheme behaves like the *OpenID authentication*,
    we will be using the `curl` command to run `/ch07/login`. The crucial part of
    the command is the issuance of the `Authorization` header with the value containing
    the Base64-encoded `username:password` digest generated by the `generate_hash.py`
    script we executed beforehand. The following `curl` command is the correct way
    of logging into our FastAPI application that uses the Digest authentication scheme:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 由于摘要认证方案的行为类似于*OpenID认证*，我们将使用`curl`命令运行`/ch07/login`。命令的关键部分是发出包含由我们之前执行的`generate_hash.py`脚本生成的Base64编码的`username:password`摘要值的`Authorization`头。以下`curl`命令是正确登录我们使用摘要认证方案的FastAPI应用程序的方法：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We also use the same command to run the rest of the secured API services.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也使用相同的命令来运行其他受保护的API服务。
- en: Most enterprise applications nowadays seldom use Basic and Digest authentication
    schemes because of their vulnerability to many attacks. More than that, both authentication
    schemes require sending credentials to the secured API services, which is also
    another risk. Moreover, at the time of writing, FastAPI does not yet fully support
    the standard Digest authentication, which is also a disadvantage to other applications
    that need the standard one. So, let us now explore the solution to secure API
    endpoints using the *OAuth 2.0 specification*.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，大多数企业应用程序很少使用基本和摘要认证方案，因为它们容易受到许多攻击。不仅如此，这两种认证方案都需要将凭证发送到受保护的API服务，这也是另一个风险。此外，在撰写本文时，FastAPI尚未完全支持标准的摘要认证，这对需要标准认证的其他应用程序来说也是一个劣势。因此，现在让我们来探讨使用*OAuth
    2.0规范*来保护API端点的解决方案。
- en: Implementing password-based authentication
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现基于密码的认证
- en: The *OAuth 2.0 specification*, or OAuth2, is the most preferred solution for
    authenticating API endpoint access. The OAuth2 authorization framework defines
    the four authorization flows, which are *implicit*, *client credentials*, *authorization
    code*, and *resource password flows*. The first three of these can be used with
    third-party authentication providers, which will authorize the access of the API
    endpoints. In the FastAPI platform, the resource password flow can be customized
    and implemented within the application to carry out the authentication procedure.
    Let us now explore how FastAPI supports the OAuth2 specification.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '*OAuth 2.0规范*，或称OAuth2，是认证API端点访问最首选的解决方案。OAuth2授权框架定义了四种授权流程，分别是*隐式*、*客户端凭证*、*授权码*和*资源密码流程*。这三种流程可以与第三方认证提供商一起使用，以授权访问API端点。在FastAPI平台上，资源密码流程可以在应用程序内部自定义和实现，以执行认证过程。现在让我们来探讨FastAPI如何支持OAuth2规范。'
- en: Installing the python-multipart module
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装python-multipart模块
- en: 'Since OAuth2 authentication will not be possible without a form handling procedure,
    we need to install the `python-multipart` module before pursuing the implementation
    part. We can run the following command to install the extension:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 由于没有表单处理程序，OAuth2认证将无法进行，因此我们需要在继续实施部分之前安装`python-multipart`模块。我们可以运行以下命令来安装扩展：
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Using OAuth2PasswordBearer and OAuth2PasswordRequestForm
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用OAuth2PasswordBearer和OAuth2PasswordRequestForm
- en: The FastAPI framework fully supports OAuth2, especially the password flow type
    of the OAuth2 specification. Its `fastapi.security` module has an `OAuth2PasswordBearer`
    that serves as the provider for password-based authentication. It also has `OAuth2PasswordRequestForm`,
    which can declare a form body with required parameters, `username` and `password`,
    and some optional ones such as `scope`, `grant_type`, `client_id`, and `client_secret`.
    This class is directly injected into the `/ch07/login` API endpoint to extract
    all the parameter values from the browser’s login form. But it is always an option
    to use `Form(…)` to capture all the individual parameters.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: FastAPI 框架完全支持 OAuth2，特别是 OAuth2 规范的密码流类型。它的 `fastapi.security` 模块有一个 `OAuth2PasswordBearer`，作为基于密码认证的提供者。它还有一个
    `OAuth2PasswordRequestForm`，可以声明一个包含所需参数（`username` 和 `password`）和一些可选参数（如 `scope`、`grant_type`、`client_id`
    和 `client_secret`）的表单体。此类直接注入到 `/ch07/login` API 端点以从浏览器登录表单中提取所有参数值。但始终可以选择使用
    `Form(…)` 来捕获所有单个参数。
- en: 'So, let us start the solution by creating the `OAuth2PasswordBearer` to be
    injected into a custom function dependency that will validate the user credentials.
    The following implementation shows that `get_current_user()` is the injectable
    function in our new application, `ch07c`, which utilizes the `oath2_scheme` injectable
    to extract a `token`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们通过创建要注入到自定义函数依赖项中的 `OAuth2PasswordBearer` 来开始解决方案，该依赖项将验证用户凭据。以下实现显示 `get_current_user()`
    是我们新应用程序 `ch07c` 中的可注入函数，它利用 `oath2_scheme` 可注入项提取 `token`：
- en: '[PRE11]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: For the resource password flow, injecting `oauth2_scheme` will return a `username`
    as a token. `get_current_user()` will check whether that username belongs to a
    valid user account stored in the database.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 对于资源密码流，注入 `oauth2_scheme` 将返回一个作为 token 的 `username`。`get_current_user()` 将检查该用户名是否属于存储在数据库中的有效用户账户。
- en: Executing the login transaction
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行登录事务
- en: 'In this authentication scheme, `/ch07/login/token` is also the `tokenUrl` parameter
    of `OAuth2PasswordBearer`. The `tokenUrl` parameter is required for password-based
    OAuth2 authentication because this is the endpoint service that will capture the
    user credentials from the browser’s login form. `OAuth2PasswordRequestForm` is
    injected into `/cho07/login/token` to retrieve the `username`, `password`, and
    `grant_type` parameters of the unauthenticated user. These three parameters are
    the essential requirements to invoke `/ch07/login/token` for *token* generation.
    This dependency is shown in the following implementation of the login API service:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在此认证方案中，`/ch07/login/token` 也是 `OAuth2PasswordBearer` 的 `tokenUrl` 参数。`tokenUrl`
    参数对于基于密码的 OAuth2 认证是必需的，因为这是从浏览器登录表单中捕获用户凭据的端点服务。`OAuth2PasswordRequestForm` 注入到
    `/cho07/login/token` 中以检索未认证用户的 `username`、`password` 和 `grant_type` 参数。这三个参数是调用
    `/ch07/login/token` 以生成 *token* 的基本要求。这种依赖关系在以下登录 API 服务的实现中显示：
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Aside from verifying from the database, the `login()` service will also check
    whether the `password` value matches the encrypted passphrase from the queried
    `account`. If all the verification succeeds, `/ch07/login/token` must return a
    JSON object with the required properties, `access_token` and `token_type`. The
    `access_token` property must have the `username` value, and `token_type` the `"bearer"`
    value.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 除了从数据库验证之外，`login()` 服务还将检查 `password` 值是否与从查询的 `account` 中检索到的加密密码匹配。如果所有验证都成功，则
    `/ch07/login/token` 必须返回一个包含所需属性 `access_token` 和 `token_type` 的 JSON 对象。`access_token`
    属性必须具有 `username` 值，而 `token_type` 必须是 `"bearer"` 值。
- en: 'Instead of creating a custom frontend for the login form, we will be utilizing
    the OAuth2 form provided by OpenAPI in the framework. We just click the **Authorize**
    button on the upper-right-hand side of the OpenAPI dashboard, as shown in *Figure
    7.3*:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将利用框架中 OpenAPI 提供的 OAuth2 表单来代替创建自定义的前端登录表单。我们只需在 OpenAPI 仪表板的右上角点击 **授权**
    按钮，如 *图 7.3* 所示：
- en: '![Figure 7.3 – The Authorize button'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.3 – 授权按钮'
- en: '](img/Figure_7.03_B17975.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.03_B17975.jpg)'
- en: Figure 7.3 – The Authorize button
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.3 – 授权按钮
- en: 'The button will trigger a built-in login form to pop up, shown in *Figure 7.4*,
    which we can use to test our solution:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 该按钮将触发一个内置的登录表单弹出，如 *图 7.4* 所示，我们可以使用它来测试我们的解决方案：
- en: '![Figure 7.4 – The OAuth2 login form'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.4 – OAuth2 登录表单'
- en: '](img/Figure_7.04_B17975.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.04_B17975.jpg)'
- en: Figure 7.4 – The OAuth2 login form
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.4 – OAuth2 登录表单
- en: 'Everything is fine if the OAuth2 login form detects the correct `tokenURL`
    specified in the `OAuth2PasswordBearer` instantiation. The OAuth2 flow or `grant_type`
    indicated in the login form must be `"password"`. After logging the verified credential,
    the form’s **Authorize** button will redirect the user to an authorization form,
    shown in *Figure 7.5*, which will prompt the user to log out or proceed with the
    authenticated access:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果OAuth2登录表单检测到在`OAuth2PasswordBearer`实例化中指定的正确`tokenURL`，则一切正常。登录表单中指示的OAuth2流程或`grant_type`必须是`"password"`。在记录验证凭证后，表单的**授权**按钮将重定向用户到如*图7.5*所示的授权表单，该表单将提示用户注销或继续进行经过认证的访问：
- en: '![Figure 7.5 – The authorization form](img/Figure_7.05_B17975.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图7.5 – 授权表单](img/Figure_7.05_B17975.jpg)'
- en: Figure 7.5 – The authorization form
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.5 – 授权表单
- en: 'Generally, the OAuth2 specification recognizes two client or application types:
    *confidential* and *public* clients. The confidential clients utilize authentication
    servers for security, such as in this *online auction system* that uses the FastAPI
    server through the OpenAPI platform. In its setup, it is not mandatory to provide
    the `client_id` and `client_secret` values to the login form since the server
    will generate these parameters during the authentication process. But unfortunately,
    these values are not revealed to the client, as shown in *Figure 7.5*. On the
    other hand, the public clients do not have any means to generate and use client
    secrets as in typical web-based and mobile applications. Therefore, these applications
    must include `client_id`, `client_secret`, and other required parameters during
    login.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，OAuth2规范认可两种客户端或应用程序类型：*机密*和*公开*客户端。机密客户端使用认证服务器进行安全，例如在这个使用OpenAPI平台通过FastAPI服务器进行的*在线拍卖系统*中。在其设置中，不需要向登录表单提供`client_id`和`client_secret`值，因为服务器将在认证过程中生成这些参数。但不幸的是，这些值并未向客户端透露，如*图7.5*所示。另一方面，公开客户端没有生成和使用客户端密钥的手段，就像典型的基于Web和移动应用程序一样。因此，这些应用程序必须在登录时包含`client_id`、`client_secret`和其他所需参数。
- en: Securing the endpoints
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保护端点
- en: 'To secure the API endpoints, we need to inject the `get_current_user()` method
    into each API service method. The following is an implementation of a secured
    `add_auction()` service that utilizes the `get_current_user()` method:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 要保护API端点，我们需要将`get_current_user()`方法注入到每个API服务方法中。以下是一个使用`get_current_user()`方法的受保护`add_auction()`服务实现的示例：
- en: '[PRE13]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `get_current_user()` injectable will return a valid `Login` account if
    the access is allowed. Moreover, you will notice that all padlock icons of the
    secured API endpoints that include `/ch07/auctions/add`, shown in *Figure 7.6*,
    are closed. This indicates that they are ready to be executed since the user is
    already an authenticated one:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果允许访问，`get_current_user()`注入方法将返回一个有效的`Login`账户。此外，您会注意到所有包含`/ch07/auctions/add`的受保护API端点的锁形图标，如*图7.6*所示，都是关闭的。这表明它们已经准备好执行，因为用户已经是一个经过认证的用户：
- en: '![Figure 7.6 – An OpenAPI dashboard showing secured APIs'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.6 – 展示受保护API的OpenAPI仪表板'
- en: '](img/Figure_7.06_B17975.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.06_B17975.jpg)'
- en: Figure 7.6 – An OpenAPI dashboard showing secured APIs
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.6 – 展示受保护API的OpenAPI仪表板
- en: This solution is a problem for an open network setup, for instance, because
    the token used is a password. This setup allows attackers to easily forge or modify
    the token during its transmission from the issuer to the client. One way to protect
    the token is to use a **JSON Web Token** (**JWT**).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这种解决方案对于开放网络设置来说是一个问题，例如，因为使用的令牌是一个密码。这种设置允许攻击者轻松地在发行者向客户端传输令牌期间伪造或修改令牌。保护令牌的一种方法是用**JSON
    Web Token**（JWT）。
- en: Applying JWTs
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用JWT
- en: JWT is an open source standard used to define a solution for sending any information
    during the authentication and authorization between issuers and clients. Its goal
    is to generate `access_token` properties that are digitally signed, URL-safe,
    and always verifiable by the client. However, it is not perfectly safe because
    anyone can decode the token if needed. Thus, it is advisable not to include all
    the valuable and confidential information in the token string. A JWT is an effective
    way of providing OAuth2 and OpenID specifications with more reliable tokens than
    passwords.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: JWT是一个开源标准，用于定义在发行者和客户端之间进行身份验证和授权过程中发送任何信息的解决方案。其目标是生成数字签名、URL安全且始终可由客户端验证的`access_token`属性。然而，它并不完全安全，因为任何人如果需要都可以解码令牌。因此，建议不要在令牌字符串中包含所有有价值且机密的信息。JWT是提供比密码更可靠令牌的有效方式，用于OAuth2和OpenID规范。
- en: Generating the secret key
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成密钥
- en: 'But before we start building the authentication scheme, we first need to generate
    a *secret key*, which is an essential element in creating the *signature*. The
    JWT has a `ssh` or `openssl` is the appropriate utility to generate this long
    and randomized key. Here, in `ch07d`, we run the following `openssl` command from
    a GIT tool or any SSL generator to create the key:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 但在我们开始构建认证方案之前，我们首先需要生成一个`*secret key*`，这是创建`*signature*`的一个基本元素。JWT有一个`ssh`或`openssl`是生成这个长且随机化的密钥的适当工具。在这里，在`ch07d`中，我们从GIT工具或任何SSL生成器运行以下`openssl`命令来创建密钥：
- en: '[PRE14]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Creating the access_token
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建access_token
- en: 'In the `ch07d` project, we will store the *secret key* and *algorithm type*
    in some reference variables in its `/security/secure.py` module script. These
    variables are used by the JWT-encoding procedure to generate the token, as shown
    in the following code:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ch07d`项目中，我们将在其`/security/secure.py`模块脚本中的某些引用变量中存储`*secret key*`和`*algorithm
    type*`。这些变量由JWT编码过程用于生成令牌，如下面的代码所示：
- en: '[PRE15]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Within the JWT Python extension, we chose the `python-jose` module to generate
    the token because it is reliable and has additional cryptographic functions that
    can sign complex data content. Install this module first using the `pip` command
    before using it.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在JWT Python扩展中，我们选择了`python-jose`模块来生成令牌，因为它可靠并且具有额外的加密功能，可以签名复杂的数据内容。在使用它之前，请先使用`pip`命令安装此模块。
- en: So now, the `/ch07/login/token` endpoint will invoke the `create_access_token()`
    method to request the JWT. The *login* service will provide the data, usually
    `username`, to comprise the payload portion of the token. Since the JWT must be
    short-lived, the process must update the `expire` portion of the payload to some
    `datetime` value in minutes or seconds suited to the application.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在`/ch07/login/token`端点将调用`create_access_token()`方法来请求JWT。*login*服务将提供数据，通常是`username`，以构成令牌的有效负载部分。由于JWT必须是短暂的，这个过程必须更新有效负载的`expire`部分为几分钟或几秒钟的`datetime`值，适合应用程序。
- en: Creating the login transaction
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建登录事务
- en: 'The implementation of the *login* service is similar to the previous password-based
    OAuth2 authentication, except that this version has a `create_access_token()`
    call for the JWT generation to replace the password credential. The following
    script shows the `/ch07/login/token` service of the `ch07d` project:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`*login*`服务的实现与之前的基于密码的OAuth2认证类似，但这个版本有一个用于JWT生成的`create_access_token()`调用，以替换密码凭据。以下脚本显示了`ch07d`项目的`/ch07/login/token`服务：'
- en: '[PRE16]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The endpoint should still return `access_token` and `token_type` since this
    is still a password-based OAuth2 authentication, which retrieves the user credentials
    from `OAuth2PasswordRequestForm`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 端点仍然应该返回`access_token`和`token_type`，因为这仍然是基于密码的OAuth2认证，它从`OAuth2PasswordRequestForm`检索用户凭据。
- en: Accessing the secured endpoints
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问受保护的端点
- en: 'As with the previous OAuth2 schemes, we need to inject `get_current_user()`into
    every API service to impose security and restrict access. The injected `OAuthPasswordBearer`
    instance will return the JWT for payload extraction using the JOSE decoders with
    the specified decoding algorithm. If the token is tampered with, modified, or
    expired, the method will throw an change to - exception. Otherwise, we need to
    continue the payload data extraction, retrieve the username, and store that in
    an `@dataclass` instance, such as `TokenData`. Then, the username will undergo
    further verification, such as checking the database for a `Login` account with
    that username. The following snippet shows this decoding process, found in the
    `/security/secure.py` module of the `ch07d` project:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的OAuth2方案一样，我们需要将`get_current_user()`注入到每个API服务中，以实施安全和限制访问。注入的`OAuthPasswordBearer`实例将使用指定的解码算法通过JOSE解码器返回JWT以提取有效负载。如果令牌被篡改、修改或过期，该方法将抛出异常。否则，我们需要继续提取有效负载数据，检索用户名，并将其存储在`@dataclass`实例中，例如`TokenData`。然后，用户名将进行进一步的验证，例如检查数据库中是否有该用户名的`Login`账户。以下代码片段显示了此解码过程，位于`ch07d`项目的`/security/secure.py`模块中：
- en: '[PRE17]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '`get_current_user()` must be injected into each service implementation to restrict
    access from users. But this time, the method will not only verify the credentials
    but also perform *JWT payload decoding*. The next step is adding *user authorization*
    to the OAuth2 solution.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_current_user()`必须注入到每个服务实现中，以限制用户访问。但这次，该方法不仅会验证凭据，还会执行*JWT有效负载解码*。下一步是向OAuth2解决方案添加*用户授权*。'
- en: Creating scope-based authorization
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建基于范围的授权
- en: FastAPI fully supports *scope-based authentication*, which uses the `scopes`
    parameter of the OAuth2 protocol to specify which endpoints are accessible to
    a group of users. A `scopes` parameter is a kind of permission placed in a token
    to provide additional fine-grained restrictions to users. In this version of the
    project, `ch07e`, we will be showcasing OAuth2 password-based authentication with
    user authorization.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: FastAPI完全支持基于*作用域的认证*，它使用OAuth2协议的`scopes`参数来指定哪些端点可供一组用户访问。`scopes`参数是一种放置在令牌中的权限，为用户提供额外的细粒度限制。在这个项目版本`ch07e`中，我们将展示基于OAuth2密码的认证和用户授权。
- en: Customizing the OAuth2 class
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义OAuth2类
- en: 'First, we need to create a custom class that inherits the properties of the
    `OAuth2` API class from the `fastapi.security` module to include the `scopes`
    parameter or "role" options in the user credentials. The following is the `OAuth2PasswordBearerScopes`
    class, a custom OAuth2 class that will implement the authentication flow with
    authorization:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要创建一个自定义类，该类继承自`fastapi.security`模块中的`OAuth2` API类的属性，以在用户凭证中包含`scopes`参数或“角色”选项。以下是一个自定义OAuth2类`OAuth2PasswordBearerScopes`，它将实现带有授权的认证流程：
- en: '[PRE18]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This `OAuth2PasswordBearerScopes` class requires two constructor parameters,
    `tokenUrl` and `scopes`, to pursue an auth flow. `OAuthFlowsModel` defines the
    `scopes` parameter as part of the user credentials for authentication using the
    `Authorization` header.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`OAuth2PasswordBearerScopes`类需要两个构造函数参数，`tokenUrl`和`scopes`，以实现认证流程。`OAuthFlowsModel`将`scopes`参数定义为使用`Authorization`头进行认证的用户凭证的一部分。
- en: Building the permission dictionary
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建权限字典
- en: 'Before we proceed with the auth implementation, we need to first build the
    `scopes` parameters that the OAuth2 scheme will be applying during authentication.
    This setup is part of the `OAuth2PasswordBearerScopes` instantiation, where we
    assign these parameters to its `scopes` parameter. The following script shows
    how all the custom-defined user scopes are saved in a *dictionary*, with the *keys*
    as the scope names and the *values* as their corresponding descriptions:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进行身份验证实现之前，我们需要首先构建OAuth2方案在身份验证过程中将应用的作用域参数。这个设置是`OAuth2PasswordBearerScopes`实例化的一部分，我们将这些参数分配给其`scopes`参数。以下脚本展示了如何将所有自定义定义的用户作用域保存到一个*字典*中，其中*键*是作用域名称，*值*是对应的描述：
- en: '[PRE19]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: There is no feasible way to directly connect the `OAuth2PasswordBearerScopes`
    class to the database for the dynamic lookup of permission sets during the implementation
    of this project. The only solution is to statically store all these authorization
    "roles" directly into the constructor of `OAuth2PasswordBearerScopes`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现这个项目的过程中，没有直接将`OAuth2PasswordBearerScopes`类连接到数据库以动态查找权限集的可行方法。唯一的解决方案是将所有这些授权“角色”直接静态存储到`OAuth2PasswordBearerScopes`构造函数中。
- en: Implementing the login transaction
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现登录事务
- en: 'All the scopes will be added to the OAuth2 form login as an option and will
    be part of the user’s login credentials. The following implementation of `/ch07/login/token`
    in this new `ch07e` project shows how to retrieve the scope parameter(s) and the
    credentials from `OAuth2PasswordRequestForm`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 所有作用域都将作为选项添加到OAuth2表单登录中，并成为用户登录凭证的一部分。以下是在这个新的`ch07e`项目中实现`/ch07/login/token`的示例，展示了如何从`OAuth2PasswordRequestForm`中检索作用域参数和凭证：
- en: '[PRE20]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The selected scopes are stored in a list, such as `['user', 'admin_read', 'admin_write',
    'bidder_write']`, which means that a user has *user*, *administrator (write)*,
    *administrator (read)*, and *bidder (write)* permissions. `create_access_token()`
    will include this list of scopes or "roles" as part of the *payload*, which will
    be decoded and extracted by `get_current_valid_user()` through the `get_current_user()`
    injectable. By the way, `get_current_valid_user()` secures every API from the
    user access by applying the authentication scheme.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 被选中的作用域存储在一个列表中，例如`['user', 'admin_read', 'admin_write', 'bidder_write']`，这意味着一个用户拥有*用户*、*管理员（写）*、*管理员（读）*和*竞标者（写）*权限。`create_access_token()`将包括这个作用域列表或“角色”作为*负载*的一部分，该负载将通过`get_current_valid_user()`通过`get_current_user()`注入器进行解码和提取。顺便说一下，`get_current_valid_user()`通过应用身份验证方案来确保每个API免受用户访问。
- en: Applying the scopes to endpoints
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将作用域应用于端点
- en: 'The `Security` API from the `fastapi` module replaces the `Depends` class in
    injecting the `get_current_valid_user()` because of its capability to assign scopes
    to each API service, aside from its capability to perform DI. It has the `scopes`
    attribute, where a list of valid scope parameters is defined that restricts the
    user from access. For instance, the following `update_profile()` service is accessible
    only to users whose scopes contain the `bidder_write` and `buyer_write` roles:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 来自`fastapi`模块的`Security` API替换了注入`get_current_valid_user()`时的`Depends`类，因为它除了具有执行依赖注入的能力外，还能为每个API服务分配权限。它有一个`scopes`属性，其中定义了一个有效权限参数列表，限制了用户的访问。例如，以下`update_profile()`服务仅对包含`bidder_write`和`buyer_write`角色的用户可访问：
- en: '[PRE21]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, the following code snippet shows the implementation of the `get_current_valid_user()`
    injected into every API service by `Security`:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，以下代码片段展示了由`Security`注入到每个API服务中的`get_current_valid_user()`的实现：
- en: '[PRE22]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This method relies on `get_current_user()` when it comes to JWT payload decoding,
    credential validation, and user scope verification. The user must at least have
    the `user` scope for the authorization process to proceed. The `Security` class
    is responsible for injecting `get_current_user()` into `get_current_valid_user()`
    together with the default `user` scope. Here is the implementation of the `get_current_user()`
    method:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到JWT有效载荷解码、凭证验证和用户权限验证时，此方法依赖于`get_current_user()`。用户至少必须拥有`user`权限，授权过程才能继续。`Security`类负责将`get_current_user()`注入到`get_current_valid_user()`中，并附带默认的`user`权限。以下是`get_current_user()`方法的实现：
- en: '[PRE23]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `SecurityScopes` class of the given `get_current_user()` extracts the scopes
    assigned to the API service that the user is trying to access. It has a `scope`
    instance variable that contains all these scope parameters of the API. On the
    other hand, `token_scopes` carries all the scopes or "roles" of the user extracted
    from the decoded JWT payload. `get_current_user()` traverses the API scopes in
    `SecurityScopes` to check whether all of them appear in the `token_scopes` of
    the user. If `True`, `get_current_user()` authenticates and authorizes the user
    to access the API service. Otherwise, it throws an change to - exception. The
    purpose of `TokenData` is to manage the scope parameters from the `token_scopes`
    payload value and the username.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 给定的`get_current_user()`函数中的`SecurityScopes`类提取了用户试图访问的API服务分配的权限范围。它有一个包含所有这些API权限参数的`scope`实例变量。另一方面，`token_scopes`携带从解码的JWT有效载荷中提取的所有权限或“角色”。`get_current_user()`遍历`SecurityScopes`中的API权限，以检查它们是否全部出现在用户的`token_scopes`中。如果是，`get_current_user()`将验证并授权用户访问API服务。否则，它将抛出一个异常。`TokenData`的目的在于管理来自`token_scopes`有效载荷值和用户名的权限参数。
- en: The next type of OAuth2 authentication scheme that FastAPI can support is the
    authorization code flow approach.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: FastAPI可以支持的下一类OAuth2认证方案是授权码流方法。
- en: Building the authorization code flow
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建授权码流
- en: If the application is a *public* type and there is no authorization server to
    process the `client_id` parameter, the `client_secret` parameter, and other related
    parameters, this OAuth2 authorization code flow approach is appropriate to use.
    In this scheme, the client creates an authorization request for a short-lived
    *authorization code* from an `authorizationUrl`. The client will then ask for
    the token from `tokenUrl` in exchange for the generated code. In this discussion,
    we will be showcasing another version of our *online auction system* that will
    use the OAuth2 *authorization code flow s*cheme.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用程序是*公开*类型，并且没有授权服务器来处理`client_id`参数、`client_secret`参数和其他相关参数，那么使用OAuth2授权码流方法是很合适的。在这个方案中，客户端将从`authorizationUrl`创建一个短生命周期的授权请求，以获取一个授权码。然后客户端将使用生成的代码从`tokenUrl`请求令牌。在这个讨论中，我们将展示我们*在线拍卖系统*的另一个版本，该版本将使用OAuth2授权码流方案。
- en: Applying OAuth2AuthorizationCodeBearer
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用OAuth2AuthorizationCodeBearer
- en: 'The `OAuth2AuthorizationCodeBearer` class is a class from the `fastapi.security`
    module that builds the authorization code flow. Its constructor requires `authorizationUrl`,
    `tokenUrl`, and the optional `scopes` before instantiation. The following code
    shows how this API class is created before its injection into the `get_current_user()`
    method:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`OAuth2AuthorizationCodeBearer`类是`fastapi.security`模块中的一个类，用于构建授权码流。它的构造函数在实例化之前需要`authorizationUrl`、`tokenUrl`和可选的`scopes`。以下代码展示了如何创建这个API类，并在将其注入到`get_current_user()`方法之前：'
- en: '[PRE24]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The two endpoints, `authorizationUrl` and `tokenUrl`, are crucial parameters
    in the authentication and authorization process of this scheme. Unlike the previous
    solutions, we will not rely on the authorization server when generating `access_token`.
    Instead, we will be implementing an `authorizationUrl` endpoint that will capture
    essential parameters from the client that will comprise the authorization request
    for `access_token` generation. The `client_secret` parameter will always remain
    unexposed to the client.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个端点，`authorizationUrl` 和 `tokenUrl`，是本方案认证和授权过程中的关键参数。与之前的解决方案不同，我们在生成 `access_token`
    时不会依赖于授权服务器。相反，我们将实现一个 `authorizationUrl` 端点，该端点将捕获来自客户端的基本参数，这些参数将构成生成 `access_token`
    的授权请求。`client_secret` 参数始终不会被暴露给客户端。
- en: Implementing the authorization request
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实施授权请求
- en: 'In the previous schemes, the `/ch07/login/` token or the `tokenUrl` endpoint
    is always the redirection point after a login transaction. But this time, the
    user will be forwarded to the custom `/ch07/oauth2/authorize` or the `authorizationUrl`
    endpoint for *auth code* generation. Query parameters such as `response_type`,
    `client_id`, `redirect_uri`, `scope`, and `state` are the essential inputs to
    the `authorizationUrl` service. The following code from the `/security/secure.py`
    module of the `ch07f` project will showcase the implementation of the `authorizationUrl`
    transaction:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的方案中，`/ch07/login/` 令牌或 `tokenUrl` 端点总是在登录事务之后成为重定向点。但这次，用户将被转发到自定义的 `/ch07/oauth2/authorize`
    或 `authorizationUrl` 端点以生成 *认证码*。查询参数如 `response_type`、`client_id`、`redirect_uri`、`scope`
    和 `state` 是 `authorizationUrl` 服务的必要输入。以下代码来自 `ch07f` 项目的 `/security/secure.py`
    模块，将展示 `authorizationUrl` 事务的实现：
- en: '[PRE25]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'These are the query parameters needed by the `authorizationUrl` transaction:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是 `authorizationUrl` 事务所需的查询参数：
- en: '`response_type`: Custom-generated authorization code'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`response_type`: 自定义生成的授权码'
- en: '`client_id`: The public identifier of the app, such as `username`'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`client_id`: 应用程序的公共标识符，例如 `username`'
- en: '`redirect_uri`: The server default URI or a custom endpoint designed to redirect
    the user back to the application'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`redirect_uri`: 服务器默认 URI 或一个自定义端点，用于将用户重定向回应用程序'
- en: '`scope`: A scope parameter(s) string, separated by spaces if at least two parameters
    are involved'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scope`: 范围参数字符串，如果涉及至少两个参数，则由空格分隔'
- en: '`state`: An arbitrary string value that determines the state of the request'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`state`: 一个任意的字符串值，用于确定请求的状态'
- en: The `redirect_uri` parameter is the destination point where the authentication
    and authorization processes will occur together with these query parameters.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`redirect_uri` 参数是认证和授权过程将发生的目的点，这些查询参数将一起使用。'
- en: The generation of `auth_code` is one of the crucial tasks of the `authorizationUrl`
    transaction, including the authentication process. The *auth code* indicates an
    ID for the authentication process and is usually unique from all other authentication.
    There are many ways to generate the code, but in our app, it is simply the combination
    of user credentials. Conventionally, `auth_code` needs to be encrypted because
    it comprises the user credentials, scope, and other request-related details.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`auth_code` 的生成是 `authorizationUrl` 事务的关键任务之一，包括认证过程。*认证码*表示认证过程的 ID，通常与其他所有认证都不同。有许多生成代码的方法，但在我们的应用程序中，它只是用户凭证的组合。传统上，`auth_code`
    需要加密，因为它包含了用户凭证、范围和其他请求相关细节。'
- en: If the user is valid, the `authorizationUrl` transaction will redirect the user
    to the `redirect_uri` parameter, back to the FastAPI layer, with the `auth_code`,
    `grant_type`, and `state` parameters, and the `redirect_uri` parameter itself.
    The `grant_type` and `redirect_uri` parameters are optional only if the application
    does not require them. This response will invoke the `tokenUrl` endpoint, which
    happens to be the `redirectURL` parameter, to pursue the continuation of the authentication
    process with scoped-based authorization.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户有效，`authorizationUrl` 事务将重定向用户到 `redirect_uri` 参数，回到 FastAPI 层，并带有 `auth_code`、`grant_type`
    和 `state` 参数，以及 `redirect_uri` 参数本身。`grant_type` 和 `redirect_uri` 参数只有在应用程序不需要它们时才是可选的。此响应将调用
    `tokenUrl` 端点，该端点恰好是 `redirectURL` 参数，以继续基于范围的授权的认证过程。
- en: Implementing the authorization code response
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实施授权码响应
- en: 'The `/ch07/login/token` service, or `tokenUrl`, must have the `Form(…)` parameter
    to capture the `code`, `grant_type`, and `redirect_uri` parameters from the `authorizationUrl`
    transaction instead of `OAuth2PasswordRequestForm`. The following code snippet
    shows its implementation:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`/ch07/login/token` 服务，或 `tokenUrl`，必须具有 `Form(…)` 参数来捕获 `authorizationUrl`
    事务中的 `code`、`grant_type` 和 `redirect_uri` 参数，而不是 `OAuth2PasswordRequestForm`。以下代码片段显示了其实现：'
- en: '[PRE26]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The only response data sent by `authorizationUrl` that is not accessible by
    `tokenUrl` is the `state` parameter. One workaround is to declare the `state`
    variable in `authorizationURL` as a `global` one to make it accessible anywhere.
    The `state` variable is part of the JSON response of the service, which the API
    authentication requires. Likewise, `tokenUrl` has no access to the user credentials
    but parsing `auth_code` is a possible way to derive the username, password, and
    scopes.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`authorizationUrl` 发送的响应数据中，只有 `state` 参数是 `tokenUrl` 无法访问的。一种解决方案是在 `authorizationURL`
    中将 `state` 变量声明为 `global`，使其在任何地方都可以访问。`state` 变量是服务 JSON 响应的一部分，API 认证需要它。同样，`tokenUrl`
    无法访问用户凭据，但解析 `auth_code` 是推导用户名、密码和作用域的可能方法。'
- en: If the user is valid, `tokenUrl` must submit the JSON data containing `access_token`,
    `expires_in`, `token_type`, `userid`, and `state` to proceed with the authentication
    scheme.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户有效，`tokenUrl` 必须提交包含 `access_token`、`expires_in`、`token_type`、`userid` 和
    `state` 的 JSON 数据，以继续进行认证方案。
- en: This authorization code flow scheme provides the baseline protocol for the *OpenID
    Connect* authentication. Various identity and access management solutions, such
    as *Okta*, *Auth0*, and *Keycloak*, apply the authorization requests and responses
    involving response_type code. The next topic will highlight the FastAPI's support
    of the OpenID Connect specification.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 此授权代码流方案为 *OpenID Connect* 认证提供了基本协议。各种身份和访问管理解决方案，如 *Okta*、*Auth0* 和 *Keycloak*，应用涉及响应_type
    代码的授权请求和响应。下一个主题将强调 FastAPI 对 OpenID Connect 规范的支持。
- en: Applying the OpenID Connect specification
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用 OpenID Connect 规范
- en: There are three *online auction* projects created to impose the *OAuth2 OpenID
    Connect* authentication scheme. All these projects use third-party tools to perform
    authentication and authorization procedures. The `ch07g` project uses *Auth0*,
    `ch07h` uses *Okta*, and `ch07i` applies a *Keycloak* policy in authenticating
    client access to the API services. Let us first highlight Keycloak’s support for
    the OpenID Connect protocol.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 已创建了三个 *在线拍卖* 项目，以实施 *OAuth2 OpenID Connect* 认证方案。所有这些项目都使用第三方工具执行认证和授权流程。`ch07g`
    项目使用 *Auth0*，`ch07h` 使用 *Okta*，而 `ch07i` 在认证客户端访问 API 服务时应用了 *Keycloak* 政策。让我们首先强调
    Keycloak 对 OpenID Connect 协议的支持。
- en: Using HTTPBearer
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 HTTPBearer
- en: The `HTTPBearer` class is a utility class from the `fastapi.security` module
    that provides an authorization scheme that relies directly on the authorization
    header with the `Bearer` tokens. Unlike the other OAuth2 schemes, this requires
    the generation of an `access_token` on the *Keycloak* side before running the
    authentication server. At this point, the framework has no straightforward way
    of accessing the credentials and the `access_token` from Keycloak’s identity provider.
    To utilize this class, we only need to instantiate it without any constructor
    parameters.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`HTTPBearer` 类是 `fastapi.security` 模块中的一个实用工具类，它提供了一个依赖于带有 `Bearer` 令牌的授权头的授权方案。与其他
    OAuth2 方案不同，这需要在运行认证服务器之前在 *Keycloak* 端生成 `access_token`。在此阶段，框架没有直接访问凭证和 `access_token`
    的简单方法。要使用此类，我们只需要实例化它，无需任何构造函数参数。'
- en: Installing and configuring the Keycloak environment
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装和配置 Keycloak 环境
- en: 'Keycloak is a Java-based application that we can download from the following
    link: [https://www.keycloak.org/downloads](https://www.keycloak.org/downloads).
    After downloading, we can unzip its content to any directory. But before running
    it, we need to install at least the Java 12 SDK on our development machine. Once
    you have completed the setup, run its `bin\standalone.bat` or `bin\standalone.sh`
    on the console and then open `http://localhost:8080` on the browser. Afterward,
    create an administration account to set up the *realm*, *clients*, *users*, and
    *scopes*.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: Keycloak 是一个基于 Java 的应用程序，我们可以从以下链接下载：[https://www.keycloak.org/downloads](https://www.keycloak.org/downloads)。下载后，我们可以将其内容解压缩到任何目录。但在运行之前，我们需要在我们的开发机器上至少安装
    Java 12 SDK。一旦完成设置，请在控制台运行其 `bin\standalone.bat` 或 `bin\standalone.sh`，然后在浏览器中打开
    `http://localhost:8080`。之后，创建一个管理账户来设置 *realm*、*clients*、*users* 和 *scopes*。
- en: Setting the Keycloak realm and clients
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置Keycloak领域和客户端
- en: 'A Keycloak *realm* is an object that encompasses all the clients together with
    their *credentials*, *scopes*, and *roles*. The first step before creating the
    user profiles is to build a realm, as shown in *Figure 7.7*:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: Keycloak的 *领域* 是一个对象，它包含所有客户端及其 *凭证*、*作用域* 和 *角色*。在创建用户配置文件之前的第一步是构建一个领域，如图7.7所示：
- en: '![Figure 7.7 - Creating a Keycloak realm](img/Figure_7.07_B17975.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![图7.7 - 创建Keycloak领域](img/Figure_7.07_B17975.jpg)'
- en: Figure 7.7 - Creating a Keycloak realm
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.7 - 创建Keycloak领域
- en: 'After the realm, the Keycloak *client*, which manages the user profiles and
    credentials, is the next priority. It is created on the **Configure** | **Clients**
    panel, as shown:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在领域之后，Keycloak的 *客户端*，它管理用户配置文件和凭证，是下一个优先级。它是在**配置** | **客户端**面板上创建的，如图所示：
- en: '![Figure 7.8 – Creating the Keycloak clients'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.8 – 创建Keycloak客户端'
- en: '](img/Figure_7.08_B17975.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.08_B17975.jpg)'
- en: Figure 7.8 – Creating the Keycloak clients
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.8 – 创建Keycloak客户端
- en: 'After creating the clients, we need to edit each Client profile to input the
    following details:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建客户端后，我们需要编辑每个客户端配置文件以输入以下详细信息：
- en: Its access type must be `confidential`
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其访问类型必须是 `confidential`
- en: '`Authorization Enabled` is turned `ON`'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`授权启用`已开启'
- en: Provide values for `Root URL`, `Base URL`, and `Admin URL`, which all refer
    to the `http://localhost:8000` of the API service application
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供以下值：`根URL`、`基本URL` 和 `管理URL`，它们都指向API服务应用程序的 `http://localhost:8000`
- en: Specify a `Valid Redirect URI` endpoint, or we can just assign `http://localhost:8080/*`
    if we have no specific custom endpoint
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定一个 `有效的重定向URI` 端点，或者如果我们没有特定的自定义端点，我们可以直接分配 `http://localhost:8080/*`
- en: In `Advanced Settings`, set `Access Token Lifespan` (e.g., 15 minutes)
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `高级设置` 中，设置 `访问令牌有效期`（例如，15分钟）
- en: Under `Authentication Flow Overrides`, set `Browser Flow` to `browser` and `Direct
    Grant Flow` to `direct grant`.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `身份验证流程覆盖` 下，将 `浏览器流程` 设置为 `browser`，将 `直接授权流程` 设置为 `direct grant`。
- en: In the `client_secret` value is located. After the setup, we can now assign
    users to the clients.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `client_secret` 值所在的位置。设置完成后，我们现在可以将用户分配给客户端。
- en: Creating users and user roles
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建用户和用户角色
- en: 'First, we create *roles* on the **Configure | Roles** panel, in preparation
    for user assignment later. *Figure 7.9* shows three user roles that will handle
    the application’s *administration*, *auctioning*, and *bidding* tasks:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们在**配置 | 角色**面板上创建 *角色*，为稍后的用户分配做准备。图7.9显示了将处理应用程序的 *管理*、*拍卖* 和 *竞标* 任务的三个用户角色：
- en: '![Figure 7.9 – Creating user roles'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.9 – 创建用户角色'
- en: '](img/Figure_7.09_B17975.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.09_B17975.jpg)'
- en: Figure 7.9 – Creating user roles
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.9 – 创建用户角色
- en: 'After creating the roles, we need to build the list of users on the **Manage
    | U****sers** panel. *Figure 7.10* shows the three created users, each with the
    mapped roles:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 创建角色后，我们需要在**管理 | 用户**面板上构建用户列表。图7.10显示了三个创建的用户，每个用户都分配了相应的角色：
- en: '![Figure 7.10 – Creating client users'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.10 – 创建客户端用户'
- en: '](img/Figure_7.10_B17975.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.10_B17975.jpg)'
- en: Figure 7.10 – Creating client users
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.10 – 创建客户端用户
- en: 'To provide users with their roles, we need to click the `joey_admin` has the
    `auc_admin_role` role, authorizing the user to do the administrative tasks for
    the app. By the way, do not forget to create a password for each user on the **Credentials**panel:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 为了为用户提供其角色，我们需要点击 `joey_admin` 具有具有 `auc_admin_role` 角色的权限，授权用户执行应用程序的行政任务。顺便说一句，不要忘记在**凭证**面板为每个用户创建密码：
- en: '![Figure 7.11 – Mapping user roles'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.11 – 映射用户角色'
- en: '](img/Figure_7.11_B17975.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.11_B17975.jpg)'
- en: Figure 7.11 – Mapping user roles
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.11 – 映射用户角色
- en: Assigning roles to clients
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将角色分配给客户端
- en: 'Aside from user roles, clients can also have assigned roles. A *client role*
    defines the type of users a client must have under its coverage. It also provides
    the client’s boundary when accessing the API services. *Figure 7.12* shows `auc_admin`
    with an `admin` role:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 除了用户角色外，客户端还可以分配角色。一个 *客户端角色* 定义了客户端在其范围内必须拥有的用户类型。它还提供了客户端访问API服务的边界。图7.12显示了具有
    `admin` 角色的 `auc_admin`：
- en: '![Figure 7.12 – Creating client roles](img/Figure_7.12_B17975.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![图7.12 – 创建客户端角色](img/Figure_7.12_B17975.jpg)'
- en: Figure 7.12 – Creating client roles
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.12 – 创建客户端角色
- en: 'Then, we need to return to the `joey_admin` has the `admin` role because the
    `auc_admin` role was added to its profile. All users with the `auc_admin` client
    added to their setup have *admin* access to the app, including `joey_admin`:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要返回到 `joey_admin` 具有具有 `admin` 角色的配置，因为 `auc_admin` 角色已被添加到其配置文件中。所有将
    `auc_admin` 客户端添加到其设置的用户的用户都具有应用程序的 *管理员* 访问权限，包括 `joey_admin`：
- en: '![Figure 7.13 – Mapping client roles to users](img/Figure_7.13_B17975.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.13 – 将客户端角色映射到用户](img/Figure_7.13_B17975.jpg)'
- en: Figure 7.13 – Mapping client roles to users
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.13 – 将客户端角色映射到用户
- en: Creating user permissions through scopes
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过作用域创建用户权限
- en: 'To assign permission to each client, we need to create *client scopes* on the
    `Audience`-type token mapper. *Figure 7.14* shows the `admin:read` and `admin:write`
    scopes for the `auc_admin` client, `auction:read` and `auction:write` for `auc_customer`,
    and `bidder:write` and `bidder:read` for `auc_bidder`:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 为了为每个客户端分配权限，我们需要在 `Audience` 类型的令牌映射器上创建 *客户端作用域*。*图 7.14* 显示了 `auc_admin`
    客户端的 `admin:read` 和 `admin:write` 作用域，`auc_customer` 的 `auction:read` 和 `auction:write`，以及
    `auc_bidder` 的 `bidder:write` 和 `bidder:read`：
- en: '![Figure 7.14 – Creating the client scopes'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.14 – 创建客户端作用域'
- en: '](img/Figure_7.14_B17975.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.14_B17975.jpg)'
- en: Figure 7.14 – Creating the client scopes
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.14 – 创建客户端作用域
- en: These *client scopes* are essential details within the `Security` injection
    for each API service if *scope-based authorization* is part of the scheme.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这些 *客户端作用域* 是每个 API 服务 `Security` 注入中的关键细节，如果 *基于作用域的授权* 是方案的一部分。
- en: Integrating Keycloak with FastAPI
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将 Keycloak 与 FastAPI 集成
- en: Since the FastAPI application cannot directly access the Keycloak client credentials
    for authentication, the application has a `login_keycloak()` service to redirect
    the user to the *AuctionRealm URI*, our custom `authorizationUrl` in Keycloak.
    The URI is `/auth/realms/AuctionRealm/protocol/openid-connect/auth`. First, access
    `http://localhost:8080/auth/realms/AuctionRealm/account/` to log in using the
    authorized user credentials, such as `joey_admin`, before invoking the `login_keycloak()`
    service.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 FastAPI 应用程序无法直接访问 Keycloak 客户端凭证进行身份验证，应用程序有一个 `login_keycloak()` 服务来将用户重定向到
    *AuctionRealm URI*，我们自定义的 Keycloak 中的 `authorizationUrl`。该 URI 是 `/auth/realms/AuctionRealm/protocol/openid-connect/auth`。首先，访问
    `http://localhost:8080/auth/realms/AuctionRealm/account/` 使用授权用户凭证（如 `joey_admin`）登录，然后再调用
    `login_keycloak()` 服务。
- en: 'Now, the redirection must include `client_id`, as with the `auc_admin` client,
    and the custom callback handler called `redirect_uri`. All the Keycloak realm
    details must be in the `.config` property file. The following code shows the implementation
    of the `login_keycloak()` service:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，重定向必须包含 `client_id`，就像 `auc_admin` 客户端一样，以及名为 `redirect_uri` 的自定义回调处理程序。所有
    Keycloak 实体详情都必须在 `.config` 属性文件中。以下代码显示了 `login_keycloak()` 服务的实现：
- en: '[PRE27]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'A *state* is part of `login_keycloak()`’s response for the callback method
    to verify the authentication, a similar approach we had in utilizing `OAuth2AuthorizationCodeBearer`.
    The service used the `hashlib` module to generate a randomized hash string value
    for the state using the *SHA256* encryption algorithm. On the other hand, Keycloak’s
    *AuctionRealm URI* must return a JSON result as follows:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '*状态* 是 `login_keycloak()` 回调方法的响应的一部分，用于验证身份验证，这与我们在利用 `OAuth2AuthorizationCodeBearer`
    时的方法类似。该服务使用 `hashlib` 模块通过 *SHA256* 加密算法生成一个随机的哈希字符串值作为状态。另一方面，Keycloak 的 *AuctionRealm
    URI* 必须返回以下 JSON 结果：'
- en: '[PRE28]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This contains the essential credentials, such as `access_token`, `expires_in`,
    `session_state`, and `scope`.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这包含基本凭证，例如 `access_token`、`expires_in`、`session_state` 和 `scope`。
- en: Implementing the token verification
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现令牌验证
- en: 'The application’s `HTTPBearer` needs `access_token` to pursue the client-side
    authentication. On the OpenAPI dashboard, we click the `access_token` value provided
    by Keycloak’s `authorizationUrl`. After the successful authentication, `get_current_user()`
    will verify the access to each API endpoint based on the credentials extracted
    from `access_token`. The following code highlights the `get_current_user()`, `which`
    builds the user credentials from Keycloak’s *token* using the `PyJWT` utility
    and algorithms such as `RSAAlgorithm`:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的 `HTTPBearer` 需要 `access_token` 来进行客户端身份验证。在 OpenAPI 仪表板上，我们点击 Keycloak
    的 `authorizationUrl` 提供的 `access_token` 值。在身份验证成功后，`get_current_user()` 将根据从 `access_token`
    中提取的凭证验证对每个 API 端点的访问。以下代码突出了 `get_current_user()`，它使用 `PyJWT` 工具和算法（如 `RSAAlgorithm`）从
    Keycloak 的 *token* 中构建用户凭证：
- en: '[PRE29]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Install the `PyJWT` module first to utilize the needed encoders and decoder
    functions. The `jwt` module has `RSAAlgorithm`, `which` can help decode the rsa_key
    from the token with some options disabled, such as the verification of the client’s
    `audience`.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '首先安装 `PyJWT` 模块以利用所需的编码和解码函数。`jwt` 模块有 `RSAAlgorithm`，它可以帮助使用一些选项禁用（如客户端 `audience`
    的验证）从令牌中解码 rsa_key。 '
- en: Integrating Auth0 with FastAPI
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将 Auth0 与 FastAPI 集成
- en: '*Auth0* can also be a third-party authentication provider that can authenticate
    and authorize access to the API endpoints of our app. But first, we need to sign
    up for an account at [https://auth0.com/](https://auth0.com/).'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '*Auth0*也可以是一个第三方认证提供者，它可以认证并授权访问我们应用程序的API端点。但首先，我们需要在[https://auth0.com/](https://auth0.com/)注册一个账户。'
- en: 'After signing up for an account, create an Auth0 application to derive **Domain**,
    **Client ID**, and **Client Secret**, and configure some URI- and token-related
    details. *Figure 7.15* shows the dashboard that creates the Auth0 application:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在注册账户后，创建一个Auth0应用程序以获取**域名**、**客户端ID**和**客户端密钥**，并配置一些URI和令牌相关的细节。*图7.15*显示了创建Auth0应用程序的仪表板：
- en: '![Figure 7.15 – Creating the Auth0 application'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.15 – 创建Auth0应用程序'
- en: '](img/Figure_7.15_B17975.jpg)'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.15_B17975.jpg)'
- en: Figure 7.15 – Creating the Auth0 application
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.15 – 创建Auth0应用程序
- en: The Auth0 application also has the generated *Audience API* URI that the client-side
    authentication needs. On the other hand, part of the authentication parameters
    is the *issuer*, which we can derive from the `/oauth/token` service that generates
    the `auth_token` once requested, similar to the Keycloak’s realm. We place all
    these Auth0 details in the `.config` file, including the `PyJWT` algorithm for
    decoding `auth_token`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: Auth0应用程序还有一个客户端认证所需的生成*受众API* URI。另一方面，认证参数的一部分是*发行者*，我们可以从生成`auth_token`的`/oauth/token`服务中获取，类似于Keycloak的领域。我们将所有这些Auth0详细信息放在`.config`文件中，包括用于解码`auth_token`的`PyJWT`算法。
- en: '`ch07g` has its own version of `get_current_user()` that processes the *payload*
    for API authentication and authorization from the Auth0 details in the `.config`
    file. But first, the `HTTPBearer` class needs the `auth_token` value and gets
    it by running the following `tokenURL` of our Auth0 application, *AuctionApp*:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`ch07g`有其自己的`get_current_user()`版本，该版本处理来自`.config`文件中Auth0详细信息的API认证和授权的*负载*。但首先，`HTTPBearer`类需要`auth_token`值，并通过运行以下我们的Auth0应用程序*AuctionApp*的`tokenURL`来获取它：'
- en: '[PRE30]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Integrating Okta with FastAPI
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将Okta集成到FastAPI中
- en: 'Some of the processes performed in Auth0 are also found in Okta’s procedures
    when extracting the `ch07h` project has these details stored in the `app.env`
    file to be retrieved by its `get_current_user()` for the payload generation. But
    then again, the `HTTPBearer` class needs an `auth_token` from executing the following
    Okta’s `tokenURL`, based on the account’s issuer:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在Auth0中执行的一些过程也出现在Okta的程序中，当从`ch07h`项目中提取时，这些详细信息存储在`app.env`文件中，由其`get_current_user()`用于生成负载。但再次强调，`HTTPBearer`类需要从基于账户发行者的以下Okta的`tokenURL`执行中获取`auth_token`：
- en: '[PRE31]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Aside from the Basic, Digest, OAuth2, and OpenID Connect authentication schemes,
    FastAPI can utilize some built-in middlewares to help secure API endpoints. Let
    us now determine whether these middlewares can provide a custom authentication
    process.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 除了基本、摘要、OAuth2和OpenID Connect认证方案之外，FastAPI可以利用一些内置中间件来帮助保护API端点。现在让我们确定这些中间件是否可以提供自定义认证过程。
- en: Using built-in middlewares for authentication
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用内置中间件进行认证
- en: 'FastAPI can use Starlette middleware such as `AuthenticationMiddleware` to
    implement any custom authentication. It needs `AuthenticationBackend` to implement
    the scheme for our app’s security model. The following custom `AuthenticationBackend`
    checks whether the `Authorization` credential is a `Bearer` class and verifies
    whether the `username` token is equivalent to a fixed username credential provided
    by the middleware:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: FastAPI可以使用Starlette中间件，如`AuthenticationMiddleware`，来实现任何自定义认证。它需要一个`AuthenticationBackend`来实现我们应用程序安全模型的方案。以下自定义的`AuthenticationBackend`检查`Authorization`凭证是否是`Bearer`类，并验证`username`令牌是否与中间件提供的固定用户名凭证等效：
- en: '[PRE32]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Activating this `UsernameAuthBackend` means injecting it into the FastAPI constructor
    in `main.py` with `AuthenticationMiddleware`. It also needs the designated `username`
    for its authentication process to work. The following snippet shows how to activate
    the whole authentication scheme in the `main.py` file:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 激活这个`UsernameAuthBackend`意味着将其注入到`main.py`中的FastAPI构造函数中，使用`AuthenticationMiddleware`。它还需要指定的`username`才能使其认证过程正常工作。以下代码片段显示了如何在`main.py`文件中激活整个认证方案：
- en: '[PRE33]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Injecting FastAPI’s `Request` is the first step in applying the authentication
    scheme. Then, we decorate each API with `@requires("authenticated")` after the
    `@router` decorator. We can extend the `UsernameAuthBackend` process further by
    adding JWT encoding and decoding, encryption, or custom roles-based authorization.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 将 FastAPI 的 `Request` 注入是应用认证方案的第一步。然后，我们在 `@router` 装饰器之后，用 `@requires("authenticated")`
    装饰每个 API。我们可以通过添加 JWT 编码和解码、加密或基于角色的自定义授权来进一步扩展 `UsernameAuthBackend` 的处理过程。
- en: Summary
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Securing any applications is always the main priority in producing quality software.
    We always choose frameworks that support reliable and credible security solutions,
    and that can at least prevent malicious attacks from the outside environment.
    Although we know for a fact that a perfect security model is a myth, we always
    develop security solutions that can cope with the threats we know.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 保护任何应用程序始终是生产高质量软件时的主要优先事项。我们总是选择支持可靠和可信安全解决方案的框架，并且至少可以防止外部环境中的恶意攻击。尽管我们知道完美的安全模型是一个神话，但我们总是开发能够应对我们所知威胁的安全解决方案。
- en: FastAPI is one of the API frameworks that has built-in support for many popular
    authentication processes, from Basic to the OpenID Connect specification. It fully
    supports all effective OAuth2 authentication schemes and is even open to further
    customization of its security APIs.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: FastAPI 是具有内置支持许多流行认证过程的 API 框架之一，从基本认证到 OpenID Connect 规范。它完全支持所有有效的 OAuth2
    认证方案，并且甚至允许进一步自定义其安全 API。
- en: Although it has no direct support for the OpenID Connect specification, it can
    still integrate seamlessly with different popular identities and user management
    systems, such as Auth0, Okta, and Keycloak. This framework may still surprise
    us with many security utilities and classes in the future that we can apply to
    build scalable microservice applications.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它没有直接支持 OpenID Connect 规范，但它仍然可以无缝集成到不同的流行身份和用户管理系统，例如 Auth0、Okta 和 Keycloak。这个框架未来可能会给我们带来许多安全实用工具和类，我们可以将这些工具应用于构建可扩展的微服务应用。
- en: The next chapter will focus on topics regarding non-blocking API services, events,
    and message-driven transactions.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将重点介绍关于非阻塞 API 服务、事件和消息驱动事务的主题。
