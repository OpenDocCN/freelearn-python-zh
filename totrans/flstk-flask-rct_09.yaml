- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: API Development and Documentation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **application programming interface** (**API**) is core to many technologies
    developers use to deal with data and facilitate communication between different
    systems. API-enabled digital business models are fast-growing. The need for experienced
    developers to build innovative enterprise solutions is equally on the rise.
  prefs: []
  type: TYPE_NORMAL
- en: The API economy is evolving into a new business model for sustainable business
    growth with a ton of opportunities for business owners and smart executives. If
    there were ever a time to be a developer, it would be now, with the plethora of
    public APIs and valuable commercial APIs that can make application development
    and deployment achievable with less effort.
  prefs: []
  type: TYPE_NORMAL
- en: Previously in this book, we discussed how databases and data modeling can be
    used to effectively store and retrieve application data as required. This chapter
    presents the opportunity to dive into the heart of backend development and leverage
    API technology to enable seamless communication between the various client applications
    and backend services.
  prefs: []
  type: TYPE_NORMAL
- en: You will learn about API design and development in Flask web applications. We
    will touch on common API terminologies to take your understanding of API design
    to a higher-than-average level. You will learn the REST API best practices and
    how to implement database CRUD operations in Flask and SQLAlchemy.
  prefs: []
  type: TYPE_NORMAL
- en: By the time we wrap up this chapter, you will have harnessed a better understanding
    of RESTful API architecture and how to design and implement a RESTful API in Flask
    web applications. You will have acquired an improved understanding of endpoint
    and payload structure to deal with data efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: Eventually, you will be able to build Flask web applications that can handle
    HTTP requests and responses. You will be able to use Flask’s SQLAlchemy extension
    to interact with a database and perform CRUD operations.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you will test some of the API endpoints and write clear and concise
    documentation for the implemented API endpoints using Postman.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What is an API?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why use an API in web development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Endpoint and payload anatomy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding HTTP requests/responses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding HTTP status codes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: REST API design principles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a REST API in Flask applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API interaction with a database via CRUD operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API documentation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The complete code for this chapter is available on GitHub at: [https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter09](https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter09).'
  prefs: []
  type: TYPE_NORMAL
- en: What is an API?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**API** stands for **application programming interface**. On the surface, an
    API seems like another piece of technical jargon coined to make learning application
    development difficult. This is not the case. An API’s core purpose is to facilitate
    communication between different systems based on an agreed set of rules, methods,
    and protocols.'
  prefs: []
  type: TYPE_NORMAL
- en: In the context of web applications, an API helps omnichannel frontend applications
    to communicate with backend services. The growing demand for digital services
    is fueling innovative ideas from business organizations to make their digital
    assets available through the design and implementation of APIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a developer, you are going to spend a great chunk of your time developing
    solutions that are API-driven. Knowing how to design and implement API solutions
    increases your skill capital and value to your employer. Broadly speaking, there
    are two types of APIs: **private APIs** and **public APIs**.'
  prefs: []
  type: TYPE_NORMAL
- en: Private APIs are sometimes called internal APIs. A private API describes an
    open architecture interface that allows developers working within an organization
    to have access to critical organization data. With an API, it becomes easy to
    automate business processes and manage information flow between various business
    units.
  prefs: []
  type: TYPE_NORMAL
- en: Private APIs allow businesses to develop in-house solutions efficiently with
    the help of existing reuseable platforms. For instance, you can broaden the scope
    of your frontend applications from web applications to mobile applications, leveraging
    the same backend services.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, public APIs describe a standardized interface that allows
    developers external to an organization to have programmable access to an organization’s
    data and services meant for public consumption. This set of interfaces allows
    developers to build new applications or add more functionality to their applications
    without reinventing the wheel. In this age, quite a huge number of public APIs
    are available for developers’ learning purposes and are a smart way to develop
    innovative solutions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following GitHub link describes some of the public APIs you can leverage:
    [https://github.com/public-apis/public-apis](https://github.com/public-apis/public-apis).
    Platforms such as Google, Twitter, Facebook, and Spotify allow developers to access
    the platform’s data through APIs. With this, developers are able to build on-demand
    services and products.'
  prefs: []
  type: TYPE_NORMAL
- en: In addition, other forms of APIs are **Simple Object Access Protocol** (**SOAP**),
    **JavaScript Object Notation-Remote Procedure Call** (**JSON-RPC**), **Extensible
    Markup Language-Remote Procedure Call** (**XML-RPC**), and **Representational
    State Transfer** (**REST**). These sets of rules, protocols, and specifications
    describe how different systems can communicate over a network. While JSON-RPC
    and REST can be used together, exploring this integration is not within the scope
    of this book.
  prefs: []
  type: TYPE_NORMAL
- en: The next part of this book will examine why APIs have emerged as a key technology
    for businesses and developers, and how they are transforming the way software,
    tools, and digital services are built and consumed.
  prefs: []
  type: TYPE_NORMAL
- en: Why use an API in web development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'APIs are an integral part of modern web application development. You will rarely
    come across a data-driven web app without some form of API implementation. The
    reason why APIs are so popular is not difficult to see. APIs enable seamless integration,
    collaboration, and innovation by providing standardized ways to facilitate efficient
    resource sharing across diverse applications and systems. The following are some
    of the benefits of the use of APIs in web development:'
  prefs: []
  type: TYPE_NORMAL
- en: APIs allow separate systems to interact, bridging communication gaps between
    different components of web applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API-driven development enables access to third-party data and services, fostering
    innovative solutions and reducing development time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: APIs provide a secure and scalable means of sharing information for developers
    and end users
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API-centric development reduces software development time by leveraging existing
    APIs and avoiding reinventing the wheel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: APIs have substantial financial potential, as exemplified by the significant
    revenue generated by Google Maps and Twilio through API access
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In healthcare, API-driven web applications facilitate the access and management
    of critical health data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: APIs are valuable in the travel and tourism industry for accessing real-time
    flight booking information and finding the best prices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: APIs play a vital role in e-commerce by integrating payment solutions and enabling
    seamless transactions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API abstraction allows developers to build secure web applications with controlled
    data exposure and secure architecture design
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we will briefly explore endpoint and payload structure to understand how
    to define clear and logical paths for accessing resources in API design and ensure
    a proper data structure for the effective communication of information between
    the client and server.
  prefs: []
  type: TYPE_NORMAL
- en: Endpoint and payload anatomy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Endpoints and payloads are a crucial part of any API component. Endpoints facilitate
    access to resources on a server through the use of well-defined routes or URLs.
    Endpoints usually act as the actual point at which data exchange occurs between
    two disparate applications in a client-server environment. Payloads allow us to
    send data along with a request or a response. We will discuss more on payloads
    in a jiffy.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start by examining the structure of an endpoint and the rules guiding
    endpoints set up in a REST API.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the endpoint structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Endpoint structures allow you to logically organize the resources of your application.
    We are going to start with a `venue` resource in exploring endpoint structure.
    Data is usually represented as resources in a REST API. You can define an endpoint
    for a `venues` collection with a `venue` resource following the use of the `collection/resource`
    path convention.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The `venue` resource represents an object or data structure accessible via a
    unique URL endpoint that allows clients to retrieve, create, update, or delete
    information about the venue.
  prefs: []
  type: TYPE_NORMAL
- en: One of the primary goals of an API designer is to clearly model data as a resource
    that other developers can use in their applications.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, `https://example.com:5000/api/v1/venues` is a whole path that
    leads to the `venue` resource on an API server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s go through the structure of the path:'
  prefs: []
  type: TYPE_NORMAL
- en: '`https`: Secured protocol'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`example.com`: Domain name'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`500`: Port number'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/``api/v1/venues`: Endpoint'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/api/` represents the entry point of an API endpoint, `/v1/` represents the
    version number of the API, and `/venues` represents the resource'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can perform the following API operations on the endpoint based on the HTTP
    methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GET` `/api/v1/venues`: Returns a list of all the venues'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GET` `/api/v1/venues/id`: Retrieves a single venue identified with `id`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`POST` `/api/v1/venues/`: Creates a venue resource'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UPDATE` `/api/v1/venues/id`: Updates a single venue identified with `id`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DELETE` `/api/v1/venues/id`: Deletes a single venue identified with `id`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s retrieve information about venues using the appropriate HTTP methods.
    The `/api/v1/venues` URL endpoint is used to get an overview of all available
    venues and their associated information from the data source. The response will
    be in JSON format, providing a structured representation of the venue data.
  prefs: []
  type: TYPE_NORMAL
- en: For example, let’s examine a venue resource request and expected response in
    JSON format.
  prefs: []
  type: TYPE_NORMAL
- en: 'With `GET` `/api/v1/venues`, the expected response in JSON format will be a
    list of all available venues:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'With `GET` `/api/v1/venues/2`, the expected response in JSON format will be
    a specific venue resource with `id` `2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'With `POST` `/api/v1/venues`, the expected response in JSON format will be
    an added venue resource with the returned `id` `3`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'With `UPDATE` `/api/v1/venues/3`, the expected response in JSON will be an
    updated venue resource with `id` `3`; the new value of the `name` property is
    now `Conference Hall`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'With `DELETE` `/api/v1/venues/3`, the expected response in JSON will be a deleted
    resource venue with `id` `3`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The preceding JSON response messages depict endpoint data representation based
    on the requests to the server. The `/api/v1/venues` RESTful API endpoints with
    `GET` will return a list of available venues, `GET /api/v1/venues/2` will return
    a specific venue with `id` `2`, `POST /api/v1/venues` will add a new venue and
    return its `id`, `UPDATE /api/v1/venues/3` will update the venue with `id 3` and
    return the updated resource, and `DELETE /api/v1/venues/3` will delete the venue
    with `id` `3`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will examine some of the golden rules to adhere to while designing
    endpoints. With these principles, you will be able to design a more intuitive
    and user-friendly RESTful API that will reduce the time and effort required to
    develop and maintain applications that use the API.
  prefs: []
  type: TYPE_NORMAL
- en: API endpoint best practices
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are principles guiding the design of a good API endpoint and by extension
    API development. We will briefly examine the following golden rules for designing
    API endpoints your team members or other developers can relate to:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/venues` endpoint, the noun `venues` explains what the resource is all about:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`https://example.com/api/v1/venues`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`https://example.com/api/v1/get_all_venues`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`venues` case, you can see that we used `/venues` to describe the collection,
    for example, `https://example.com/api/v1/venues/2`, where `id=2`, refers to a
    specific resource in the collection:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`https://example.com/api/v1/venues`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`https://example.com/api/v1/venue`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`collection/resource/collection` structure, the endpoint URL starts with the
    collection name, followed by the resource name, and then another collection name
    if applicable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, in the case of a `speaker` resource, which may have a collection
    of `papers`, the recommended endpoint URL would be something like `/speakers/2/papers`,
    where `speakers` is the collection name, `2` is the ID of a specific speaker resource,
    and `papers` is the collection of papers associated with this particular speaker:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`https://example.com/api/v1/speakers/2/papers`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`https://example.com/api/v1/speakers/2/papers/8/reviews`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`https://example.com/api/v1/speakers/2/papers/8/reviews` violates the recommended
    structure by including another collection name, `reviews`, after `papers`. This
    structure implies that `reviews` is a sub-collection of `papers`, which contradicts
    the rule of the `collection/resource/collection` pattern. Instead, we can treat
    them as separate resources with their own endpoints.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Take the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GET /api/v1/speakers/2/papers`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GET /api/v1/papers/8/reviews`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By separating the endpoints, it becomes clearer that reviews are related to
    papers, rather than being nested within the `papers` collection.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will explore the structure of the payload and examine its role within
    this context.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the payload structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The payload contains the actual data that the API is designed to work with.
    In this section, you will understand the data format that is sent and received
    by an API. You will learn how the payload is structured, including the keys and
    values that are used to represent the data.
  prefs: []
  type: TYPE_NORMAL
- en: With this understanding of the payload structure, you will be able to work with
    more complex APIs and handle larger amounts of data. As discussed earlier, an
    API provides an interface for the exchange of data between web services. The data
    in question for interacting, communicating, or sharing is the payload.
  prefs: []
  type: TYPE_NORMAL
- en: 'The payload is the data of interest between various web applications that want
    to exchange information. Technically, this is the body of the HTTP request and
    response in client-server communication. In an API ecosystem, when a client makes
    a request, in the body of the request is the data, which essentially consists
    of two parts: the header/overhead and the payload.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The header is used to describe the source or destination of the data in transit.
    The payload comes in different flavors: JSON or XML. The payloads are recognizable
    with the use of curly braces, `{}`. We will focus on the JSON format of the payload
    in this book.'
  prefs: []
  type: TYPE_NORMAL
- en: We are choosing JSON format because JSON is easy to read and understand, easy
    to parse in most programming languages, supports complex data structures, is platform-independent,
    and uses minimal syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s describe a typical structure of a payload with examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a payload that a client sends to the server (the *API* *request*
    payload):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Note the following in the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: The payload is indicated with data within curly braces, and it explains the
    information we want to send to the `/venues` API endpoint using the `POST` HTTP
    method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `"Content-Type: application/json"` request header describes the JSON data
    type of the request body'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The client also describes the response format it expects from the server with
    `Accept: application/json`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For a server-returned payload (*OK response* payload from the server), we have
    the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Note the following in the preceding snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '`OK` and the content data within curly braces are the payloads.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can see that the server complied with the `Content-Type: application/json`
    the client is expecting to receive.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The JSON payload is enclosed in curly braces, `{}`, and consists of two key-value
    pairs:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"responseType": "Ok"`: This key-value pair indicates that the API successfully
    processed the request and returned a response. The `"responseType"` key has a
    value of `"Ok"`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"data": { "id": 3, "name": "Conference Hall" }`: This key-value pair contains
    the actual data being returned by the API. The `"data"` key has a value of an
    object that contains information about the venue with ID `3`. In this case, the
    venue name is `"``Conference Hall"`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The payloads in the preceding code are `"responseType": "Failed"` and `"message":
    "``Not found"`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Endpoints and payloads are essential parts of API development. You need to design
    API endpoints that are concise and intuitive to clearly communicate your intentions
    to developers who may want to interact with your API data services.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will deepen the knowledge stacks and glance through HTTP requests/responses.
    When building web applications, it’s essential to have a good understanding of
    how HTTP requests and responses work.
  prefs: []
  type: TYPE_NORMAL
- en: These are the building blocks of communication between clients and servers,
    and knowing how to work with them is crucial for building effective and efficient
    web applications.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding HTTP requests/responses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To successfully work with APIs, you need to have an understanding of HTTP requests/responses.
    So, let’s unmask the structure of HTTP requests and responses.
  prefs: []
  type: TYPE_NORMAL
- en: Request line
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Every HTTP request begins with the request line. This comprises the HTTP method,
    the requested resource, and the HTTP protocol version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In this instance, `GET` is the HTTP method, `/api/v1/venues` is the path to
    the resource requested, and `HTTP 1.1` is the protocol and version used.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dive deeper into HTTP methods to understand how developers use different
    HTTP methods to specify the type of action they want to perform when making requests
    to the web servers.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'HTTP methods indicate the action that the client intends to perform on the
    web server resource. Commonly used HTTP methods are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GET`: The client requests a resource on the web server'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`POST`: The client submits data to a resource on the web server'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PUT`: The client replaces a resource on the web server'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DELETE`: The client deletes a resource on the web server'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s take a glance through the request headers.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP request headers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: HTTP headers play a critical role in facilitating communication between the
    client and server during an HTTP request or response. They allow both parties
    to include additional information alongside the primary data being transferred,
    such as metadata, authentication credentials, or caching directives.
  prefs: []
  type: TYPE_NORMAL
- en: Headers act as a placeholder for payloads and provide crucial context and metadata
    to both the client and server. For example, they can convey information about
    the content type, language, encoding, and size of the data being transferred.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, headers can provide details about the client’s capabilities and
    preferences, such as the type of browser being used or the preferred language
    for content delivery. HTTP request headers come immediately after the request
    line.
  prefs: []
  type: TYPE_NORMAL
- en: 'Common headers are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`www.packtpub.com/`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Host` header specifies the host of the server and indicates where the resource
    is requested from.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`"Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:107.0)` `Gecko/20100101 Firefox/107.0"`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `User-Agent` header tells the web server of the application that is making
    the HTTP request. It usually consists of the operating system (such as Windows,
    Mac, or Linux), version, and application vendor.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`"text/html,application/xhtml+xml,application/xml;q=0.9,ima` `ge/avif,image/webp,*/*;q=0.8"`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Accept` header tells the web server what type of content the client will
    accept as the response.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`en-US,en;q=0.5`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Accept-Language` header indicates the language.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`text/html; charset=UTF-8`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Content-type` header indicates the type of content being transmitted in
    the request body.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Next, we will examine the request body.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP request body
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In HTTP, the request body refers to the additional data that is sent along with
    an HTTP request message, typically in the form of a payload. Unlike HTTP headers,
    which provide metadata about the request or response, the request body contains
    the actual data that the client is sending to the server. The request body can
    contain various types of data, including form data, JSON, XML, binary data, or
    text.
  prefs: []
  type: TYPE_NORMAL
- en: For example, when submitting a web form, the data entered by the user is typically
    sent as part of the request body. Similarly, when uploading a file or sending
    an API request, the data being transmitted is often included in the request body.
    The format and structure of the request body depend on the content type specified
    in the request headers.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, if the content type is set to `application/json`, the request
    body must be a valid JSON object. If the content type is `multipart/form-data`,
    the request body may include multiple parts, each containing different types of
    data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following shows an HTTP request that uses the `POST` method to submit data
    to a web server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The request includes a request body in JSON format, which contains a key-value
    pair and an array. The key has a value of `"value"`, and the array contains two
    string values, `"value3"` and `"value4"`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following shows an HTTP request that uses the `PUT` method to update data
    on a web server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The request includes a request body in JSON format, which contains a key-value
    pair. The key has a value of `"value"`, and this data is intended to update the
    resource at the specified endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will consider HTTP responses. HTTP responses are the server’s way of
    communicating with the client in response to an HTTP request.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP responses
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Understanding the various HTTP status codes and the information included in
    HTTP responses is essential for building robust and effective web applications.
    After the web server has processed an HTTP request, it is expected to send an
    HTTP response to the client.
  prefs: []
  type: TYPE_NORMAL
- en: 'The initial line of the response contains the status, which indicates whether
    the request was successful or unsuccessful due to an error. This status line provides
    critical feedback to the client about the outcome of the request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The HTTP response begins with the HTTP protocol version, followed by the status
    code, and a reason message. The reason message is a textual representation of
    the status code. In the upcoming *Understanding HTTP status codes* section, we
    will delve into the topic of status codes in detail.
  prefs: []
  type: TYPE_NORMAL
- en: We will now begin discussing the response headers.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP response headers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In HTTP, response headers provide additional information about the response
    message sent by the server. While the status code in the initial line of an HTTP
    response provides essential information about the outcome of the request, response
    headers can provide additional metadata about the response, such as the content
    type, cache settings, and server type.
  prefs: []
  type: TYPE_NORMAL
- en: Response headers are typically used to provide the client with information that
    can help optimize the rendering and processing of the response, such as specifying
    the character encoding or content length. Response headers can also be used to
    control the behavior of the client, such as setting caching parameters or enabling
    **cross-origin resource sharing** (**CORS**) for API requests.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP response headers are sent by the server in the response message, immediately
    following the status line. The headers consist of one or more lines, each with
    a header field name and a value, separated by a colon. Some common response headers
    include `Content-Type`, `Content-Length`, `Cache-Control`, `Server`, and `Set-Cookie`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of an HTTP response header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Considering the preceding code block, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The `Date` header specifies the date and time at which the HTTP response was
    generated
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Server` header describes the web server software used to generate the response
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `Content-Type` header describes the media type of the resource returned:
    in this case, HTML'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we will discuss the HTTP response body.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP response body
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The response body refers to the data sent by the server in response to an HTTP
    request. While the response headers provide metadata about the response, the response
    body contains the actual data that the client requested, such as HTML, JSON, XML,
    or binary data.
  prefs: []
  type: TYPE_NORMAL
- en: The structure and content of the response body depend on the nature of the request
    and the format of the requested data. For example, a request for a web page might
    receive an HTML response body containing the markup and content of the page, while
    a request for data from an API might receive a JSON response body containing the
    requested data.
  prefs: []
  type: TYPE_NORMAL
- en: 'In HTTP, the response body may contain content in certain situations, such
    as when the server responds with a status code of `200`, which indicates that
    the request was successful and that the server is returning content. In other
    cases, when the server responds with a status code of `204`, it indicates that
    the request was successful but that there is no content to return, so the response
    body may be empty:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Having discussed HTTP requests and responses, we will now begin discussing the
    various commonly used HTTP status codes.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding HTTP status codes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: HTTP status codes are three-digit numbers sent by a server in response to an
    HTTP request. These codes provide feedback to the client about the outcome of
    the request and help identify any issues that may have occurred during the transaction.
    The first digit of an HTTP status code indicates the category of the responses,
    which could be `Informational`, `Successful`, `Redirection`, `Client Error`, or
    `Server Error`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The common status codes you’ll encounter for each category are listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`1XX Informational`'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Status Code** | **Description** | **Reason** |'
  prefs: []
  type: TYPE_TB
- en: '| `100` | This code indicates an interim response from the web server informing
    the client to continue the request or ignore the response if the request has already
    been processed | Continue |'
  prefs: []
  type: TYPE_TB
- en: '`2XX Successful`'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Status Code** | **Description** | **Reason** |'
  prefs: []
  type: TYPE_TB
- en: '| `200` | This code indicates the server successfully processed the request.
    | `OK` |'
  prefs: []
  type: TYPE_TB
- en: '| `201` | This code indicates the server successfully processed the request
    and a resource was created. | `Created` |'
  prefs: []
  type: TYPE_TB
- en: '| `202` | This code indicates the request has been received but the processing
    has not yet been completed. | `Accepted` |'
  prefs: []
  type: TYPE_TB
- en: '| `204` | The code indicates the server successfully processed the request
    but is not returning any content. | `No content` |'
  prefs: []
  type: TYPE_TB
- en: '`3XX Redirection`'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Status Code** | **Description** | **Reason** |'
  prefs: []
  type: TYPE_TB
- en: '| `301` | This code indicates that the request and all future requests should
    be sent to the new location in the response header | `Moved Permanently` |'
  prefs: []
  type: TYPE_TB
- en: '| `302` | This code indicates the request should be sent temporarily to the
    new location in the response header | `Found` |'
  prefs: []
  type: TYPE_TB
- en: '`4XX` `Client Error`'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Status Code** | **Description** | **Reason** |'
  prefs: []
  type: TYPE_TB
- en: '| `400` | This code indicates that the server cannot process the request due
    to a perceived client error. | `Bad Request` |'
  prefs: []
  type: TYPE_TB
- en: '| `401` | This code indicates that the client making the request is unauthorized
    and should be authenticated. | `Unauthorized` |'
  prefs: []
  type: TYPE_TB
- en: '| `403` | This code indicates that the client making the request does not have
    the right to access the content; they are unauthorized and should obtain the right
    to access the resource. | `Forbidden` |'
  prefs: []
  type: TYPE_TB
- en: '| `404` | This code indicates that the web server did not find the requested
    resource. | `Not Found` |'
  prefs: []
  type: TYPE_TB
- en: '| `405` | This code indicates that the web server knows the method but the
    targeted resource does not support the HTTP method used. | `Method` `Not Allowed`
    |'
  prefs: []
  type: TYPE_TB
- en: '`5XX` `Server Error`'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Status Code** | **Description** | **Reason** |'
  prefs: []
  type: TYPE_TB
- en: '| `500` | This code indicates that the web server has encountered an unexpected
    error while processing the request. | `Internal` `Server Error` |'
  prefs: []
  type: TYPE_TB
- en: '| `502` | This code indicates that the web server, while acting as a gateway
    to get a response, received an invalid response from the application server. |
    `Bad Gateway` |'
  prefs: []
  type: TYPE_TB
- en: '| `503` | This code indicates that the web server is unavailable to process
    the request. | `Service Unavailable` |'
  prefs: []
  type: TYPE_TB
- en: Before we explore how to implement a REST API in Flask web applications, it’s
    important to grasp the underlying principles of RESTful API design. By understanding
    these fundamentals, we can ensure that our API is designed in a way that is intuitive,
    user-friendly, and efficient. So, let’s take a closer look at the key principles
    that underpin RESTful API design.
  prefs: []
  type: TYPE_NORMAL
- en: REST API design principles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: REST API, or RESTful API, describes an API that conforms to the REST architectural
    style using an HTTP-based interface for network communication. An API in its simplest
    form defines a set of rules that disparate systems or applications need to conform
    to in order to exchange data.
  prefs: []
  type: TYPE_NORMAL
- en: Dr. Roy Fielding, in the year 2000, presented a dissertation ([https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm](https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm))
    that described a novel design approach that API designers are expected to follow
    in building applications that can stand the test of time in addition to being
    secure. In order to develop a RESTful system, there are architectural constraints
    that are worth keeping in mind.
  prefs: []
  type: TYPE_NORMAL
- en: We will examine those REST principles, such as *client-server*, *statelessness*,
    *caching*, *uniform interface*, *layered system*, and *code on demand*, to conform
    to a REST style guide.
  prefs: []
  type: TYPE_NORMAL
- en: Client-server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The REST API architecture encourages client and server communication. The client
    sends a network request to the server, while the server can only send a response
    back to the client. RESTful APIs ensure all communications start from clients,
    who then wait for a response from the server.
  prefs: []
  type: TYPE_NORMAL
- en: RESTful APIs enforce the separation of concerns between the client applications
    and server, thus making the interaction smooth and independent. Owing to the separation
    of concerns, web application designs are not tightly coupled as the client and
    server can scale without inadvertently impacting the overall application architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Separation of concerns is a design principle that aims to separate a system
    into distinct, independent parts, with each part responsible for a specific task
    or functionality. This design principle is commonly applied in software engineering
    and programming, including in the design of REST APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Statelessness
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Conforming to REST API design constraints requires all network requests to be
    stateless. Statelessness means a server is not expected to remember past network
    requests. Technically, the statelessness of a network request encourages independent
    interaction between the client and server.
  prefs: []
  type: TYPE_NORMAL
- en: Every request from a client to a server is expected to contain all of the important
    information required to understand and fulfill the request. Statelessness invariably
    improves performance as the server does not need to store or remember previous
    requests. In addition, with a stateless state in RESTful application design, the
    architecture is simple to set up, scalable, and reliable.
  prefs: []
  type: TYPE_NORMAL
- en: Caching
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: RESTful APIs are designed with caching in mind. Caching is the process of storing
    frequently used data in a temporary location in order to reduce the time and resources
    required to access it. The caching principle in REST API ensures that network
    information contained within a response to a request be declared implicitly or
    explicitly as cacheable or non-cacheable.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, if a response is cacheable, the client will reuse the cached response
    data for similar subsequent requests. Caching improves the efficiency of server
    resources and reduces bandwidth usage while decreasing the loading time of a site
    page.
  prefs: []
  type: TYPE_NORMAL
- en: Uniform interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A uniform interface is another design constraint that REST API designers need
    to implement. The REST API architectural style states that the REST API should
    have a single communication protocol and a standardized data format. Regardless
    of the system’s environment, applications and servers, a uniform interface facilitates
    smooth interaction.
  prefs: []
  type: TYPE_NORMAL
- en: A uniform interface encourages the ease of evolvability of each system component
    and provides a common framework for any client application to communicate with
    a REST API.
  prefs: []
  type: TYPE_NORMAL
- en: 'REST APIs adopt HTTP as a communication protocol for client-server interaction.
    With HTTP, the client sends a request in a specific format, such as JSON or XML.
    Let’s take a look at a sample request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This REST API request contains two major components – `GET` and the URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GET` is one of the HTTP methods. The `GET` method specifies the action the
    client wants to make on the server resource. There are four commonly used HTTP
    requests a client uses to make a request:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GET`: To retrieve a resource'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`POST`: To create a new resource'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PUT`/`PATCH`: To update or edit an existing resource'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DELETE`: To delete a resource'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The URL part contains the uniform resource identifier that specifies the resource
    of interest. In this case, we are interested in the `venues` resource. So, we
    issued an HTTP `GET` request to look up the location of that resource.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Furthermore, the URL is also sometimes called an endpoint. The endpoint represents
    the location where the API actually interacts with the client, the point at which
    data exchange takes place.
  prefs: []
  type: TYPE_NORMAL
- en: The client-server interaction proceeds with the host receiving and validating
    the `GET` request. The response data is returned from the target resource (`/api/v1/venues`).
    The returned data format is often in the form of JSON or the expected response
    format as specified by the client. JSON allows us to have standardized structured
    data to display the contents of the target resource.
  prefs: []
  type: TYPE_NORMAL
- en: Layered system
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Modern web applications are composed of layered architectures. The client-server
    system could have multiple layers of servers/services each with its own responsibility,
    such as load balancing, security, and caching layers. The REST API design principle
    encourages an implementation in which the layers of systems that may exist do
    not alter the natural behaviors of client-server interaction.
  prefs: []
  type: TYPE_NORMAL
- en: With this constraint, any change or modification in the inner systems/servers
    will have zero effect on the format of the HTTP-based request and response model.
    A layered system enforces a clear separation of concerns and improves scalability
    as the client and server are highly independent and can grow at scale.
  prefs: []
  type: TYPE_NORMAL
- en: Code on demand (optional)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Code on demand is an optional constraint in RESTful API design, which allows
    the server to send executable code to the client in response to a request. This
    code can be in the form of scripts, applets, or other executable files, and can
    be used to extend the functionality of the client.
  prefs: []
  type: TYPE_NORMAL
- en: The code-on-demand constraint is optional because it is not always necessary
    or desirable for an API to provide executable code to clients. In many cases,
    RESTful APIs simply provide data or resources that can be consumed by client applications
    without the need for executable code.
  prefs: []
  type: TYPE_NORMAL
- en: However, in some cases, code on demand can be useful for providing additional
    functionality to clients, such as data processing, filtering, or visualization.
    For example, a RESTful API for data analysis could provide executable code to
    the client for performing complex calculations or generating visualizations based
    on the data.
  prefs: []
  type: TYPE_NORMAL
- en: The REST API can send code such as JavaScript code to the client application
    for execution. This optional feature of code on demand allows API designers to
    further customize the API’s functionality with the ability to increase the flexibility
    of the API to deliver required business solutions.
  prefs: []
  type: TYPE_NORMAL
- en: The previously mentioned design principles of REST API ensure developers are
    able to build solutions based on architectural styles that are widely acceptable
    in the software development industry.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, Dr. Roy Fielding once summarized the essence of the RESTful API design
    principle and the overall goal in software development as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '“REST is software design on the scale of decades: every detail is intended
    to promote software longevity and independent evolution.'
  prefs: []
  type: TYPE_NORMAL
- en: Many of the constraints are directly opposed to short-term efficiency. Unfortunately,
    people are fairly good at short-term design, and usually awful at long-term design.
    Most don’t think they need to design past the current release. There are more
    than a few software methodologies that portray any long-term thinking as wrong-headed,
    ivory tower design (which it can be if it isn’t motivated by real requirements).”
  prefs: []
  type: TYPE_NORMAL
- en: '[https://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven](https://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven)'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will delve into the practical implementation of a REST API within a
    Flask web application.
  prefs: []
  type: TYPE_NORMAL
- en: Learning how to implement a REST API in a Flask application is a valuable skill
    for developers who want to build web applications that can be accessed and consumed
    by other applications or services.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a REST API in a Flask application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Flask, as a popular Python web framework, provides developers with a flexible
    and lightweight solution for building web applications. With Flask, you can easily
    create and manage RESTful APIs. The process of implementing a REST API in a Flask
    application is simple.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a REST API in a Flask application involves defining API endpoints,
    request handlers, and data models, and possibly connecting to a database. In this
    section, we are going to design a REST API service using Flask that a React frontend
    application can consume.
  prefs: []
  type: TYPE_NORMAL
- en: We will follow a simple process of defining the resources expected in the *Bizza*
    application, following which we will define the URLs (endpoints) that would be
    used to access the resources. In addition, we will use Flask’s routing system
    to map each endpoint to a specific function in the application.
  prefs: []
  type: TYPE_NORMAL
- en: Each function should handle the HTTP request, interact with the database (if
    necessary), and return an appropriate response. Finally, we will implement data
    serialization to serialize and deserialize data between Python objects and JSON.
    This ensures that the API can establish communication with clients using a standardized
    format.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will begin the discussion of implementing a REST API with the concept
    of defining the application resources.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the application resources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will start by defining the resources needed to create a conference web application
    that can handle all aspects of an event, from scheduling and registration to sponsorship
    management. The following resources are thus defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Attendees`: The people who are attending the conference'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Speakers`: The people who are giving presentations at the conference'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Schedules`: The schedules of the conference, including the start and end times
    of each session'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Presentations`: The speakers’ areas of interest and subject matter for the
    conference'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Users`: The users of the event management system, including attendees, speakers,
    and organizers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Userextras`: Additional information about the users attending the event, such
    as dietary preferences or accessibility needs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Venues`: The venues where the event or conference is being held, including
    information about the location, capacity, and amenities'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Sessions`: The individual sessions or talks within the conference, including
    information about the speaker, topic, and time'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Sponsors`: The organizations or companies sponsoring the event, including
    information about their level of sponsorship, logo, and contact details'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we will define the API endpoints. In order to implement a functional REST
    API, it is necessary to define the API endpoints clearly.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the API endpoints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Defining the API endpoints is a crucial step in implementing a REST API. These
    endpoints allow you to perform various operations on the resources of the conference
    web application, such as creating, reading, updating, and deleting records. We
    are defining the endpoints based on the resources specified in the preceding section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the specific endpoints and HTTP methods used are listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Users`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GET` `/users`: Retrieves a list of all users'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GET` `/users/{id}`: Retrieves information about a specific user'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`POST` `/users`: Creates a new user'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PUT` `/users/{id}`: Updates information about a specific user'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DELETE` `/users/{id}`: Deletes a specific user'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Userextras`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GET` `/userextras`: Retrieves a list of all `userextras`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GET` `/userextras/{id}`: Retrieves information about a specific `userextra`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`POST` `/userextras`: Creates a new `userextra`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PUT` `/userextras/{id}`: Updates information about a specific `userextra`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DELETE` `/userextras/{id}`: Deletes a specific `userextra`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Attendees`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GET` `/attendees`: Retrieves a list of all attendees'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GET` `/attendees/{id}`: Retrieves information about a specific attendee'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`POST` `/attendees`: Creates a new attendee'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PUT` `/attendees/{id}`: Updates information about a specific attendee'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DELETE` `/attendees/{id}`: Deletes a specific attendee'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Speakers`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GET` `/speakers`: Retrieves a list of all speakers'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GET` `/speakers/{id}`: Retrieves information about a specific speaker'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`POST` `/speakers`: Creates a new speaker'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PUT` `/speakers/{id}`: Updates information about a specific speaker'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DELETE` `/speakers/{id}`: Deletes a specific speaker'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Schedules`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GET` `/schedules`: Retrieves a list of all schedules'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GET` `/schedules/{id}`: Retrieves information about a specific schedule'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`POST` `/schedules`: Creates a new schedule'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PUT` `/schedules/{id}`: Updates information about a specific schedule'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DELETE` `/schedules/{id}`: Deletes a specific schedule'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Presentations`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GET` `/presentations`: Retrieves a list of all presentations'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GET` `/presentations/{id}`: Retrieves information about a specific presentation'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`POST` `/presentations`: Creates a new presentation'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PUT` `/presentations/{id}`: Updates information about a specific presentation'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DELETE` `/presentations/{id}`: Deletes a specific presentation'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Venues`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GET` `/venues`: Retrieves a list of all venues'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GET` `/venues/{id}`: Retrieves information about a specific venue'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`POST` `/venues`: Creates a new venue'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PUT` `/venues/{id}`: Updates information about a specific venue'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DELETE` `/venues/{id}`: Deletes a specific venue'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Sessions`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GET` `/sessions`: Retrieves a list of all sessions'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GET` `/sessions/{id}`: Retrieves information about a specific session'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`POST` `/sessions`: Creates a new session'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PUT` `/sessions/{id}`: Updates information about a specific session'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DELETE` `/sessions/{id}`: Deletes a specific session'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Sponsors`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GET` `/sponsors`: Retrieves a list of all sponsors'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GET` `/sponsors/{id}`: Retrieves information about a specific sponsor'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`POST` `/sponsors`: Creates a new sponsor'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PUT` `/sponsors/{id}`: Updates information about a specific sponsor'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DELETE` `/sponsors/{id}`: Deletes a specific sponsor'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Once the API endpoints have been defined, the next step is to implement them
    in the Flask application.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start digging!
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the API endpoints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Implementing the API endpoints is a critical step in developing a RESTful API.
    This is where all the juicy bits come together to form the heart and soul of your
    REST API. API endpoints define the functionality and behavior of the API, specifying
    the methods that can be used to access the API’s resources.
  prefs: []
  type: TYPE_NORMAL
- en: In a Flask application, implementing the API endpoints involves mapping the
    URLs to the relevant functions, defining the HTTP methods, and writing the Flask
    view functions that will handle the requests and generate responses. In addition,
    it is necessary to specify the request and response formats to be used to communicate
    with the API.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will explore the process of implementing API endpoints in
    a Flask application. Let’s start by creating a simple endpoint that returns a
    text-based welcome message from the API server.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the backend development environment, inside `bizza/backend/`, activate the
    virtual environment in the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Use the following** **on Windows**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Use the following** **on Mac/Linux**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you are having issues activating your virtual environment, check *Setting
    up the development environment with Flask* in [*Chapter 1*](B18554_01.xhtml#_idTextAnchor014).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, update `app.py` with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This is what is happening in the preceding code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: We import the `Flask` class from the `flask` package.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We then create an instance of the `Flask` class and name it `app`. Then, we
    pass in a `__name__` variable as an argument that references the current module
    name. This is needed for the internal working of Flask for path discovery.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use a `@route()` Flask decorator to tell Flask to implement the `index()` view
    function when a user accesses the URL `"/"` (index URL). A decorator in Python
    is simply a way of adding extra functionality to functions without explicitly
    altering the method behavior.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This view function returns the message `Welcome to Bizza REST API server` to
    the browser. So, essentially, the decorator is capable of modifying the `index()`
    view function to return a value in the form of an HTTP response, which can then
    be displayed by the client using the desired data presentation format. In this
    case, `text/html` was returned.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the conditional part of the code becomes true, that is, `app.py` is the main
    program, then it runs the module. In this way, Python prevents the accidental
    or unintentional running of an imported module.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can test the endpoint with `curl` by entering the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 9.1 – Screenshot showing \uFEFFthe HTTP response from localhost](img/Figure_9.1_B18554.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 9.1 – Screenshot showing the HTTP response from localhost
  prefs: []
  type: TYPE_NORMAL
- en: JSONifying response data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Jsonifying response data refers to the process of converting a Python data structure
    into a JSON string that can be returned as a response from an API endpoint. JSON
    is a lightweight data-interchange format that is easy to read and write, making
    it a popular choice for web APIs.
  prefs: []
  type: TYPE_NORMAL
- en: By jsonifying response data, the data can be easily transmitted over HTTP and
    used by other systems and programming languages. This is because JSON is a language-independent
    data format that can be parsed and generated by many programming languages.
  prefs: []
  type: TYPE_NORMAL
- en: JSON also supports complex data structures such as arrays and objects, making
    it a flexible format for transferring data between systems. In a Flask application,
    the *jsonify* function can be used to convert Python data structures into JSON
    format.
  prefs: []
  type: TYPE_NORMAL
- en: This function takes the data as an argument and returns a Flask response object
    with the JSON data and the appropriate `Content-Type` header, indicating that
    the data is in JSON format. By returning JSON-formatted responses from API endpoints,
    clients can easily consume and use the data in their applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see that `content-type` in the preceding code is `text/html`; now,
    let’s return a serialized JSON format since moving forward, that will be the preferred
    data exchange format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we added another endpoint and decorated it with `@route("/api/v1/venues")`.
    So, we are telling Flask to implement the functionality of the view function attached
    to the decorator.
  prefs: []
  type: TYPE_NORMAL
- en: In order to retrieve the JSON format response, we invoke `jsonify()` in the
    `Flask` package using `from flask import Flask, jsonify` and pass Python dictionary
    data into it, which then gets converted into a serializable JSON format.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can test the endpoint with `curl` by entering the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 9.2 – Screenshot showing \uFEFFthe venues endpoint\uFEFF being tested](img/Figure_9.2_B18554.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 9.2 – Screenshot showing the venues endpoint being tested
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will begin to enhance the endpoint functionality by incorporating query
    parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Adding query parameters to endpoints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Query parameters are additional information we can pass along with the request
    to the server to allow some processing of the request. With query parameters,
    we are able to present dynamic content to application users.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, this is an ordinary URL endpoint without a query parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can add a query parameter to the URL by adding a `?` at the end of
    the URL followed by a key-value pair. Let’s add a query parameter to the preceding
    URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Let’s implement a simple query parameter in a Flask application for a better
    illustration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following snippet to the `app.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Note the following in the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: We are creating a new endpoint with the URL `/``api/v1/speakers/` resource.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are using a `request` object from the Flask package.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are then defining a view function, `speakers()`, to handle requests to the
    endpoint.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `request` object is used to allow a client to send data to the server and
    other endpoint request operations. We have `request.args` for handling URL data,
    `request.form` for extracting form data, and `request.json` for handling JSON
    data. Here, we will use `request.args` to extract key-value pairs in the URL to
    process URL data at the server end.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `firstname` and `lastname` variables store the data values extracted from
    the URL.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, we perform a simple check to find out whether query parameters are present
    in the URL. In the production code, you are expected to perform a comprehensive
    check on what the users are sending to the server. This is for demonstration purposes.
    We return JSONified data if query parameters are present. Otherwise, the message
    `"No query parameters in the url"` is sent as output.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Testing the endpoint with query parameters, for instance, `http://localhost:5000/api/v1/speakers?firstname=Jim&lastname=Hunt`,
    provides the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 9.3 – Screenshot testing with \uFEFFa query parameter](img/Figure_9.3_B18554.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 9.3 – Screenshot testing with a query parameter
  prefs: []
  type: TYPE_NORMAL
- en: 'Testing the `http://localhost:5000/api/v1/speakers?` endpoint without query
    parameters provides the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 9.4 – Screenshot testing without \uFEFFa query parameter](img/Figure_9.4_B18554.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 9.4 – Screenshot testing without a query parameter
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s check how you can pass variables to an endpoint. This is also useful
    in dynamically modifying the server-side processing in your application.
  prefs: []
  type: TYPE_NORMAL
- en: Passing variables to an endpoint
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the ways to provide input to an endpoint is by passing variables to the
    URL path in the API endpoint, allowing for the provision of specific information.
    This technique is commonly used when the input is required to identify a specific
    resource or object, such as an ID number or username.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a Flask application, variables can be included in the URL path by enclosing
    them in angled brackets (`<>`) in the endpoint URL definition. For example, to
    define an endpoint that takes a speaker ID as input, the URL could be defined
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the `get_speaker` function takes a `speaker_id` argument,
    which corresponds to the variable included in the URL path. When a request is
    made to the `/speakers/123` endpoint, the `get_speaker` function is called with
    `speaker_id=123`.
  prefs: []
  type: TYPE_NORMAL
- en: Passing variables to an endpoint is a useful technique for providing input to
    an API endpoint and is commonly used in RESTful API design.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will take our REST API in Flask application a step further. We will
    perform CRUD operations on a database using PostgreSQL.
  prefs: []
  type: TYPE_NORMAL
- en: API interaction with a database via CRUD operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In most web application projects, it is common to work with databases for the
    purpose of persistent data storage. You won’t be hardcoding plain text into your
    REST API, unless you are that person who tries to boil the ocean.
  prefs: []
  type: TYPE_NORMAL
- en: '`GET`, `POST`, `PUT/PATCH`, and `DELETE` – which further describes and facilitates
    the interaction with the database.'
  prefs: []
  type: TYPE_NORMAL
- en: In a full stack web application, you expect your users to able to create a resource
    (`POST` or `PUT` if it is an existing resource), read a resource (`GET`), update
    a resource (`PUT`/`PATCH`), and delete a resource (`DELETE`). In this section,
    we will work with a simple `venue` resource with the following endpoints, and
    the HTTP operations we will perform on them are CRUD.
  prefs: []
  type: TYPE_NORMAL
- en: All the code for the endpoint’s implementation will be hosted in the GitHub
    repository of this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s jump-start the CRUD operation by describing the endpoints we are using:'
  prefs: []
  type: TYPE_NORMAL
- en: '`POST` `/api/v1/venues/`: Creates a `venue` resource'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GET` `/api/v1/venues`: Returns a list of all the venues'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GET` `/api/v1/venues/id`: Retrieves a single venue identified with `id`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PUT` `/api/v1/venues/id`: Updates a single venue identified with `id`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DELETE` `/api/v1/venues/id`: Deletes a single venue identified with `id`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The preceding endpoints are clear with regard to their intentions. But before
    we start fleshing out the endpoints, let’s discuss the necessary dependencies
    and be sure we can connect with the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activate the virtual environment: always remember you are working in a virtual
    environment to contain your project dependencies. Then, inside `bizza/backend`,
    update the `app.py` file with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, we imported the `Flask` and `SQLAlchemy` modules.
    Then, the `app = Flask(__name__)` line created an instance of the Flask application.
    The `__name__` argument represents the name of the current module.
  prefs: []
  type: TYPE_NORMAL
- en: The `Flask` API comes with some configuration settings that we can modify. The
    `config` object is in the form of a Python dictionary. We are able to set the
    database URI with `app.config['SQLALCHEMY_DATABASE_URI']` and disable the SQLAlchemy
    operation notification setting with `app.config['SQLALCHEMY_TRACK_MODIFICATIONS']
    =` `False`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In `app.config['SQLALCHEMY_DATABASE_URI'] = 'postgresql://<username>:<password>@localhost:5432/<database_name>'`,
    change `<username>` and `<password>` to your appropriate database credentials.
  prefs: []
  type: TYPE_NORMAL
- en: With `db = SQLAlchemy(app)`, we created the `SQLAlchemy` instance, which accepts
    the `Flask` instance as an argument.
  prefs: []
  type: TYPE_NORMAL
- en: With this set, let’s define the model class and create the venue table in the
    database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `Venue` class model, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the command terminal and enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command brings `db`, an `SQLAlchmy` instance, and the `Venue`
    class model into scope.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command creates the `venues` table from the `Venue` class model.
    Alternatively, you can run a migration command as done previously to create the
    table.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, verify the table creation with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The following screenshot shows the terminal commands to show the creation of
    the `venues` table.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.5 – Screenshot showing commands in flask shell](img/Figure_9.5_B18554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.5 – Screenshot showing commands in flask shell
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the database and v`enues` table up and running, let’s start
    to define the endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a venue resource
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s define the `/venues` endpoint in `app.py` and use it to post entries to
    the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'The endpoint for creating a new venue is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The `jsonify` and `request` methods are imported from Flask.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `@app.route()` decorator has the URL to the `'/api/v1/venues'` endpoint
    with the HTTP `POST` method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `add_venue()` function is invoked once there is a `POST` request.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We test to make sure `request.method == '``POST'`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We test to ensure the new venue name is not already in the database. If the
    added name is already in the database, the message `"Venue name already exist"`
    is sent back as a `json` message with status code `409-` `content conflict`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the preceding step fails, we proceed to add to the database session with
    `db.session.add(new_venue)`. At this point, the entry is not fully added to the
    database but added to the database session. We need one more step to commit it
    to the database, which is `db.session.commit()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Jsonify()` is an in-built Flask function that returns a JSON-serialized response
    object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returning lists of venues
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following is the endpoint to retrieve all the venues in the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The `GET` request method is invoked
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Venue.query.all()` is a query from `SQLAlchemy` to retrieve all the venues'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `jsonify` response object output results in a `200` status code, and if
    it fails, a `"No venue record found"` message is displayed with status code `404`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returning a single venue resource
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following is an endpoint to return a single venue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we are doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The `GET` request method is invoked
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Venue.query.filter(Venue.id == id).first()` retrieves the first record with
    the ID supplied as an argument to `retrieve_venue()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the ID is present, the `jsonify` response object output results in a `200`
    status code, and if it fails, the `"Record id not found"` message is displayed
    with status code `404`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating a single venue resource
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following is an endpoint to modify venue information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we are doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The `PUT` request method is invoked to update a single resource
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We try to check for the existence of the record `id`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the record is present, we update it with `venue.name = name`, then commit
    the session
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the ID information is updated, the `jsonify` response object output results
    in a `200` status code, and if it fails, the `"Venue record not found"` message
    is displayed with status code `404`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deleting a single venue resource
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following is an endpoint to delete a venue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we are doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The `DELETE` request method is invoked to delete a single resource
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We try to check for the existence of the record `id`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the record is present, we delete it, then commit the session
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the ID information is deleted, the `jsonify` response object output results
    in a `202` status code, and if it fails, a `"That venue does not exist"` message
    is displayed with status code `404`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The following GitHub link contains the complete code for the `venue` CRUD operation
    in `app.py` -[https://github.com/PacktPublishing/Full-Stack-Flask-and-React/blob/main/Chapter09/05/bizza/backend/app.py](https://github.com/PacktPublishing/Full-Stack-Flask-and-React/blob/main/Chapter09/05/bizza/backend/app.py).
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will examine the concept of API documentation and deep-dive into its
    importance and how to make use of the Postman tool to document your API endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: API documentation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Have you ever tried to assemble a piece of equipment you bought from a store
    without looking through the manual? There is a high probability you will have
    done so deliberately. You smartly think it will be easy to put together, and most
    times, you get burned in this process of trial and error and eventually mess things
    up.
  prefs: []
  type: TYPE_NORMAL
- en: Manuals are a good resource meant to ease you through a product’s features and
    functionality. API documentation is no different from manuals for guidance, a
    set of instructions, references, or even tutorial materials that can enhance developers’
    understanding of your API.
  prefs: []
  type: TYPE_NORMAL
- en: Why is API documentation a critical component of your API? We will examine a
    few reasons and dive into using the Postman client tool to document your API so
    that other developers can understand what it is all about and how to use it. We
    will use a very simplistic case study with the `venues` CRUD operation we examined
    in the preceding section.
  prefs: []
  type: TYPE_NORMAL
- en: In a production-ready API product, you are expected to provide more detailed
    information about your API in your documentation. You are to write up a technical
    instructional guide that will make consuming your API services a walk in the park.
    You would also want to include tutorials, clear references, and sample code that
    can help developers with easy integration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s examine the reasons why you would want to come up with clear documentation
    for your API:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Enhanced developer experience**: API documentation opens up a way to provide
    quick-start guides, references, and case studies for developers who want to be
    productive and consume third-party data to improve their software product offerings.
    Therefore, well-thought-out API documentation helps developers to understand the
    best approach to implementing your API data points to solve their problems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: High-quality and useful API documentation means developers are going to easily
    understand how to implement your API and thus will increase their overall emotional
    attachment to your API product. Stripe, PayPal, Spotify, Twilio, and Paystack
    are good examples of popular commercial APIs with awesome documentation.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Decreased onboarding time**: Comprehensive documentation allows even an entry-level
    developer to quickly know how to implement your API endpoints and methods and
    handle requests and responses seamlessly without assistance from other developers.
    This will save time and costs for the business and improve the API adoption rate.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Adherence to API objectives**: Documentation allows API designers and consumers
    to have a common ground on API specs and the problem it aims to solve without
    ambiguity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we will use Postman to test and document a RESTful API.
  prefs: []
  type: TYPE_NORMAL
- en: Testing and documenting with Postman
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Postman is an advanced API platform that provides a range of features to simplify
    the development, testing, and utilization of APIs. Postman offers a user-friendly
    interface for testing API endpoints, generating API documentation, and collaborating
    on API-related operations.
  prefs: []
  type: TYPE_NORMAL
- en: To begin using Postman, you can download and install the application on your
    local machine. Visit the official Postman website at [https://www.postman.com/downloads](https://www.postman.com/downloads)
    to access the download page. From there, you can choose the appropriate version
    for your operating system and follow the installation instructions.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have Postman installed, you can leverage the power of Postman to document
    RESTful API endpoints, execute requests, analyze responses, and perform comprehensive
    testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s leverage `venues` on the collections and generate API documentation that
    tells other developers how to make requests and describe the response to expect:'
  prefs: []
  type: TYPE_NORMAL
- en: On your computer, start Postman and create a collection. Click on the **Collections**
    tab on the left sidebar of the Postman interface; if it’s not visible, you can
    click on the three horizontal lines in the top-left corner to expand the sidebar.
    In the dialog box, enter a name for your collection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.6 – Screenshot showing the creation of a collection in Postman](img/Figure_9.6_B18554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.6 – Screenshot showing the creation of a collection in Postman
  prefs: []
  type: TYPE_NORMAL
- en: 'After creating a collection, create a new request. Within the collection, click
    on the **New** button located in the top-left corner of the interface. A drop-down
    menu will appear:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.7 – Screenshot showing how to add an HTTP request](img/Figure_9.7_B18554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.7 – Screenshot showing how to add an HTTP request
  prefs: []
  type: TYPE_NORMAL
- en: Select the request type from the drop-down menu. To post data to the server,
    select `localhost:5000/api/v1/venues`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select the **Body** tab, then **raw**, and finally select the **JSON** tab
    from the dropdown. This will allow you to send the data to the server in JSON
    format. In this case, we send the following data to the backend server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The following screenshot shows how you can use Postman to test endpoints.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.8 – Screenshot showing sending data to the backend](img/Figure_9.8_B18554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.8 – Screenshot showing sending data to the backend
  prefs: []
  type: TYPE_NORMAL
- en: Send the request once you have configured the request. Click on the `POST` request
    will fail.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After sending the request, Postman will display the response received from the
    server. You can see the response content, status code, headers, and other relevant
    information in the response panel. The following screenshot shows the response
    data.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.9 – Screenshot showing server response to a POST request](img/Figure_9.9_B18554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.9 – Screenshot showing server response to a POST request
  prefs: []
  type: TYPE_NORMAL
- en: Repeat the preceding steps for each request in your collection, choosing appropriate
    request types and providing descriptions, parameter details, the request payload,
    and the response format as needed.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have tested all the endpoints, right-click on the collection name and
    click on **View Documentation**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This takes you to where you can customize your API documentation further. You
    can add details such as the API description, stating a brief overview of the API,
    including its purpose, functionality, and any relevant background information.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Also, you can specify the base URL of the API, including the protocol (HTTP/HTTPS)
    and the domain name. If the API requires authentication, explain the authentication
    mechanism(s) supported (for example, API key, OAuth, or JWT) and provide instructions
    on how to authenticate requests.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Depending on the requirements of your API, you can document each endpoint exposed
    by the API. For each endpoint, you may include the following information:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Endpoint URL**: Provides the URL pattern for the endpoint, including any
    required path parameters.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GET`, `POST`, `PUT`, `DELETE`, and so on).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Request parameters**: Specifies any query parameters, request headers, or
    request body parameters required by the endpoint. Include the parameter name,
    type, description, and whether it is required or optional.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Response format**: Describes the format of the response returned by the endpoint
    (for example, JSON or XML).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`200 OK`, `400 Bad Request`, or `401 Unauthorized`).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Response body**: Provides an example of the response body returned by the
    endpoint, including all relevant fields and their descriptions.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Error handling**: Explains how errors are handled by the API and provides
    examples of error responses.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Lastly, you can now publish your API documentation to share with the public.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.10 – Screenshot showing how you publish your API documentation](img/Figure_9.10_B18554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.10 – Screenshot showing how you publish your API documentation
  prefs: []
  type: TYPE_NORMAL
- en: You can read up on the further customization of the published documentation
    in the Postman documentation as it is possible to convert it into HTML and host
    it on your own server. The link to the generated API documentation is https://documenter.getpostman.com/view/4242057/2s93sjUoYX.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored API development in Flask applications. We started
    by understanding what an API is all about and why businesses and developers are
    creating and consuming APIs to drive their data access. We took things further
    by taking a quick run through common terminologies developers come across when
    implementing the API design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we unmasked the structure of endpoints and payloads, recognizing that
    designing routes and exchanging data form the foundational elements of API development.
    In addition, we critically examined the design principles guiding RESTful API
    development. We discussed how understanding the REST API design principles enhances
    best practices in API design and development. Also, we discussed the implementation
    of the REST API and how we can connect API backend services with a database in
    a Flask application.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we discussed API testing and documentation with Postman. In API design
    and development, we recognized how testing and documenting endpoints is crucial
    to building stable and usable web applications.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to bridge the frontend and backend functionalities
    and experience the full stack nature of React and Flask.
  prefs: []
  type: TYPE_NORMAL
