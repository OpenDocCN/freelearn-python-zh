- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: API Development and Documentation
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API 开发和文档
- en: The **application programming interface** (**API**) is core to many technologies
    developers use to deal with data and facilitate communication between different
    systems. API-enabled digital business models are fast-growing. The need for experienced
    developers to build innovative enterprise solutions is equally on the rise.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**应用程序编程接口**（**API**）是许多开发者用来处理数据和促进不同系统间通信的技术核心。API 启用的数字商业模式正在快速发展。对有经验的开发者来说，构建创新企业解决方案的需求也在不断上升。'
- en: The API economy is evolving into a new business model for sustainable business
    growth with a ton of opportunities for business owners and smart executives. If
    there were ever a time to be a developer, it would be now, with the plethora of
    public APIs and valuable commercial APIs that can make application development
    and deployment achievable with less effort.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: API 经济正在演变成为一种新的可持续业务增长商业模式，为商业主和明智的执行者提供了大量机会。如果曾经有成为开发者的时机，那就是现在，因为公共 API
    和有价值的商业 API 如此之多，它们可以使得应用开发和部署变得更容易实现。
- en: Previously in this book, we discussed how databases and data modeling can be
    used to effectively store and retrieve application data as required. This chapter
    presents the opportunity to dive into the heart of backend development and leverage
    API technology to enable seamless communication between the various client applications
    and backend services.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的前面部分，我们讨论了如何使用数据库和数据建模来有效地存储和检索所需的应用数据。本章提供了深入后端开发的机会，利用 API 技术实现各种客户端应用程序和后端服务之间的无缝通信。
- en: You will learn about API design and development in Flask web applications. We
    will touch on common API terminologies to take your understanding of API design
    to a higher-than-average level. You will learn the REST API best practices and
    how to implement database CRUD operations in Flask and SQLAlchemy.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 你将学习在 Flask Web 应用程序中进行 API 设计和开发。我们将涉及常见的 API 术语，以提升你对 API 设计的理解水平。你将学习 REST
    API 最佳实践以及如何在 Flask 和 SQLAlchemy 中实现数据库 CRUD 操作。
- en: By the time we wrap up this chapter, you will have harnessed a better understanding
    of RESTful API architecture and how to design and implement a RESTful API in Flask
    web applications. You will have acquired an improved understanding of endpoint
    and payload structure to deal with data efficiently.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 到我们结束本章时，你将更好地理解 RESTful API 架构以及如何在 Flask Web 应用程序中设计和实现 RESTful API。你将获得对端点和有效载荷结构的改进理解，以便有效地处理数据。
- en: Eventually, you will be able to build Flask web applications that can handle
    HTTP requests and responses. You will be able to use Flask’s SQLAlchemy extension
    to interact with a database and perform CRUD operations.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，你将能够构建能够处理 HTTP 请求和响应的 Flask Web 应用程序。你将能够使用 Flask 的 SQLAlchemy 扩展与数据库交互并执行
    CRUD 操作。
- en: Finally, you will test some of the API endpoints and write clear and concise
    documentation for the implemented API endpoints using Postman.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你将测试一些 API 端点，并使用 Postman 编写清晰简洁的实现 API 端点的文档。
- en: 'In this chapter, we’ll be covering the following topics:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: What is an API?
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是 API？
- en: Why use an API in web development
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么在 Web 开发中使用 API
- en: Endpoint and payload anatomy
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 端点和有效载荷结构
- en: Understanding HTTP requests/responses
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 HTTP 请求/响应
- en: Understanding HTTP status codes
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 HTTP 状态码
- en: REST API design principles
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: REST API 设计原则
- en: Implementing a REST API in Flask applications
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Flask 应用程序中实现 REST API
- en: API interaction with a database via CRUD operations
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 CRUD 操作与数据库进行 API 交互
- en: API documentation
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API 文档
- en: Technical requirements
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The complete code for this chapter is available on GitHub at: [https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter09](https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter09).'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的完整代码可在 GitHub 上找到：[https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter09](https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter09).
- en: What is an API?
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是 API？
- en: '**API** stands for **application programming interface**. On the surface, an
    API seems like another piece of technical jargon coined to make learning application
    development difficult. This is not the case. An API’s core purpose is to facilitate
    communication between different systems based on an agreed set of rules, methods,
    and protocols.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**API** 代表 **应用程序编程接口**。表面上，API 似乎是一种新的技术术语，旨在使学习应用开发变得困难。事实并非如此。API 的核心目的是根据一套约定的规则、方法和协议，促进不同系统之间的通信。'
- en: In the context of web applications, an API helps omnichannel frontend applications
    to communicate with backend services. The growing demand for digital services
    is fueling innovative ideas from business organizations to make their digital
    assets available through the design and implementation of APIs.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在Web应用程序的背景下，API帮助全渠道前端应用程序与后端服务进行通信。对数字服务的不断需求正在推动企业组织产生创新想法，通过设计和实现API使他们的数字资产可用。
- en: 'As a developer, you are going to spend a great chunk of your time developing
    solutions that are API-driven. Knowing how to design and implement API solutions
    increases your skill capital and value to your employer. Broadly speaking, there
    are two types of APIs: **private APIs** and **public APIs**.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一名开发者，你将花费大量时间开发以API驱动的解决方案。了解如何设计和实现API解决方案可以增加你的技能资本和对你雇主的价值。总的来说，有两种类型的API：**私有API**和**公共API**。
- en: Private APIs are sometimes called internal APIs. A private API describes an
    open architecture interface that allows developers working within an organization
    to have access to critical organization data. With an API, it becomes easy to
    automate business processes and manage information flow between various business
    units.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 私有API有时被称为内部API。私有API描述了一个开放架构接口，允许组织内部的开发者访问关键组织数据。有了API，自动化业务流程和管理各个业务单位之间的信息流变得容易。
- en: Private APIs allow businesses to develop in-house solutions efficiently with
    the help of existing reuseable platforms. For instance, you can broaden the scope
    of your frontend applications from web applications to mobile applications, leveraging
    the same backend services.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 私有API允许企业利用现有的可重用平台高效地开发内部解决方案。例如，你可以通过利用相同的后端服务，将你的前端应用程序的范围从Web应用程序扩展到移动应用程序。
- en: On the other hand, public APIs describe a standardized interface that allows
    developers external to an organization to have programmable access to an organization’s
    data and services meant for public consumption. This set of interfaces allows
    developers to build new applications or add more functionality to their applications
    without reinventing the wheel. In this age, quite a huge number of public APIs
    are available for developers’ learning purposes and are a smart way to develop
    innovative solutions.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，公共API描述了一个标准化的接口，允许组织外部的开发者以编程方式访问组织的数据和服务，这些数据和服务是为公众消费而设计的。这一套接口允许开发者构建新的应用程序或为他们的应用程序添加更多功能，而无需重新发明轮子。在这个时代，大量的公共API可供开发者学习，并且是开发创新解决方案的明智方式。
- en: 'The following GitHub link describes some of the public APIs you can leverage:
    [https://github.com/public-apis/public-apis](https://github.com/public-apis/public-apis).
    Platforms such as Google, Twitter, Facebook, and Spotify allow developers to access
    the platform’s data through APIs. With this, developers are able to build on-demand
    services and products.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 以下GitHub链接描述了一些你可以利用的公共API：[https://github.com/public-apis/public-apis](https://github.com/public-apis/public-apis)。例如，Google、Twitter、Facebook和Spotify等平台允许开发者通过API访问平台的数据。有了这个，开发者能够构建按需服务和产品。
- en: In addition, other forms of APIs are **Simple Object Access Protocol** (**SOAP**),
    **JavaScript Object Notation-Remote Procedure Call** (**JSON-RPC**), **Extensible
    Markup Language-Remote Procedure Call** (**XML-RPC**), and **Representational
    State Transfer** (**REST**). These sets of rules, protocols, and specifications
    describe how different systems can communicate over a network. While JSON-RPC
    and REST can be used together, exploring this integration is not within the scope
    of this book.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，其他形式的API包括**简单对象访问协议**（**SOAP**）、**JavaScript对象表示法-远程过程调用**（**JSON-RPC**）、**可扩展标记语言-远程过程调用**（**XML-RPC**）和**表征状态转移**（**REST**）。这些规则、协议和规范描述了不同的系统如何通过网络进行通信。虽然JSON-RPC和REST可以一起使用，但探索这种集成超出了本书的范围。
- en: The next part of this book will examine why APIs have emerged as a key technology
    for businesses and developers, and how they are transforming the way software,
    tools, and digital services are built and consumed.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 本书下一部分将探讨为什么API已成为企业和开发者关键技术的关键，以及它们是如何改变软件、工具和数字服务的构建和消费方式的。
- en: Why use an API in web development
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么在Web开发中使用API
- en: 'APIs are an integral part of modern web application development. You will rarely
    come across a data-driven web app without some form of API implementation. The
    reason why APIs are so popular is not difficult to see. APIs enable seamless integration,
    collaboration, and innovation by providing standardized ways to facilitate efficient
    resource sharing across diverse applications and systems. The following are some
    of the benefits of the use of APIs in web development:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: API是现代网络应用开发的一个组成部分。你很少会遇到一个没有某种形式API实现的以数据驱动的网络应用。API之所以如此受欢迎，原因并不难理解。API通过提供标准化的方式，促进了跨不同应用和系统之间高效资源共享的集成、协作和创新。以下是使用API进行网络开发的一些好处：
- en: APIs allow separate systems to interact, bridging communication gaps between
    different components of web applications
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API允许不同的系统进行交互，弥合网络应用不同组件之间的通信差距
- en: API-driven development enables access to third-party data and services, fostering
    innovative solutions and reducing development time
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以API驱动的开发可以访问第三方数据和服务的，促进创新解决方案并减少开发时间
- en: APIs provide a secure and scalable means of sharing information for developers
    and end users
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API为开发人员和最终用户提供了安全且可扩展的信息共享方式
- en: API-centric development reduces software development time by leveraging existing
    APIs and avoiding reinventing the wheel
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以API为中心的开发通过利用现有API并避免重复造轮子来减少软件开发时间
- en: APIs have substantial financial potential, as exemplified by the significant
    revenue generated by Google Maps and Twilio through API access
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API具有巨大的财务潜力，正如谷歌地图和Twilio通过API访问产生的显著收入所证明的那样
- en: In healthcare, API-driven web applications facilitate the access and management
    of critical health data
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在医疗保健领域，以API驱动的网络应用促进了关键健康数据的访问和管理
- en: APIs are valuable in the travel and tourism industry for accessing real-time
    flight booking information and finding the best prices
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API在旅游和旅游业中非常有价值，可以获取实时航班预订信息并找到最佳价格
- en: APIs play a vital role in e-commerce by integrating payment solutions and enabling
    seamless transactions
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API通过集成支付解决方案并实现无缝交易在电子商务中发挥着至关重要的作用
- en: API abstraction allows developers to build secure web applications with controlled
    data exposure and secure architecture design
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API抽象允许开发者构建具有受控数据暴露和安全的架构设计的网络应用
- en: Next, we will briefly explore endpoint and payload structure to understand how
    to define clear and logical paths for accessing resources in API design and ensure
    a proper data structure for the effective communication of information between
    the client and server.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将简要探讨端点和有效载荷结构，以了解如何在API设计中定义清晰和逻辑的路径来访问资源，并确保客户端和服务器之间有效信息交流的数据结构。
- en: Endpoint and payload anatomy
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 端点和有效载荷解剖
- en: Endpoints and payloads are a crucial part of any API component. Endpoints facilitate
    access to resources on a server through the use of well-defined routes or URLs.
    Endpoints usually act as the actual point at which data exchange occurs between
    two disparate applications in a client-server environment. Payloads allow us to
    send data along with a request or a response. We will discuss more on payloads
    in a jiffy.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 端点和有效载荷是任何API组件的关键部分。端点通过使用定义良好的路由或URL来促进服务器上资源的访问。在客户端-服务器环境中，端点通常充当两个不同应用之间数据交换的实际点。有效载荷允许我们在请求或响应中发送数据。我们将在稍后讨论更多关于有效载荷的内容。
- en: Let’s start by examining the structure of an endpoint and the rules guiding
    endpoints set up in a REST API.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从检查端点结构以及指导REST API中端点设置的规则开始。
- en: Understanding the endpoint structure
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解端点结构
- en: Endpoint structures allow you to logically organize the resources of your application.
    We are going to start with a `venue` resource in exploring endpoint structure.
    Data is usually represented as resources in a REST API. You can define an endpoint
    for a `venues` collection with a `venue` resource following the use of the `collection/resource`
    path convention.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 端点结构允许你逻辑地组织应用程序的资源。我们将从探索端点结构中的`venue`资源开始。在REST API中，数据通常表示为资源。你可以定义一个`venues`集合的端点，使用`collection/resource`路径约定后跟随一个`venue`资源。
- en: Note
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `venue` resource represents an object or data structure accessible via a
    unique URL endpoint that allows clients to retrieve, create, update, or delete
    information about the venue.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`venue`资源代表一个可以通过唯一的URL端点访问的对象或数据结构，允许客户端检索、创建、更新或删除有关场所的信息。'
- en: One of the primary goals of an API designer is to clearly model data as a resource
    that other developers can use in their applications.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: API 设计者的一个主要目标是将数据清晰建模为资源，其他开发者可以在他们的应用程序中使用。
- en: For instance, `https://example.com:5000/api/v1/venues` is a whole path that
    leads to the `venue` resource on an API server.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`https://example.com:5000/api/v1/venues` 是一个完整的路径，它指向 API 服务器上的 `venue` 资源。
- en: 'Let’s go through the structure of the path:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过路径的结构来了解：
- en: '`https`: Secured protocol'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`https`: 安全协议'
- en: '`example.com`: Domain name'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`example.com`：域名'
- en: '`500`: Port number'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`500`：端口号'
- en: '`/``api/v1/venues`: Endpoint'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/api/v1/venues`：端点'
- en: '`/api/` represents the entry point of an API endpoint, `/v1/` represents the
    version number of the API, and `/venues` represents the resource'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`/api/` 代表 API 端点的入口点，`/v1/` 代表 API 的版本号，`/venues` 代表资源'
- en: 'We can perform the following API operations on the endpoint based on the HTTP
    methods:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以根据 HTTP 方法在端点上执行以下 API 操作：
- en: '`GET` `/api/v1/venues`: Returns a list of all the venues'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET` `/api/v1/venues`：返回所有场所的列表'
- en: '`GET` `/api/v1/venues/id`: Retrieves a single venue identified with `id`'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET` `/api/v1/venues/id`：检索由 `id` 标识的单个场所'
- en: '`POST` `/api/v1/venues/`: Creates a venue resource'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST` `/api/v1/venues/`：创建场所资源'
- en: '`UPDATE` `/api/v1/venues/id`: Updates a single venue identified with `id`'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UPDATE` `/api/v1/venues/id`：更新由 `id` 标识的单个场所'
- en: '`DELETE` `/api/v1/venues/id`: Deletes a single venue identified with `id`'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DELETE` `/api/v1/venues/id`：删除由 `id` 标识的单个场所'
- en: Let’s retrieve information about venues using the appropriate HTTP methods.
    The `/api/v1/venues` URL endpoint is used to get an overview of all available
    venues and their associated information from the data source. The response will
    be in JSON format, providing a structured representation of the venue data.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用适当的 HTTP 方法检索有关场所的信息。`/api/v1/venues` URL 端点用于从数据源获取所有可用场所及其相关信息的概述。响应将以
    JSON 格式提供，以结构化的方式表示场所数据。
- en: For example, let’s examine a venue resource request and expected response in
    JSON format.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们检查一个场所资源请求和预期的 JSON 格式响应。
- en: 'With `GET` `/api/v1/venues`, the expected response in JSON format will be a
    list of all available venues:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `GET` `/api/v1/venues`，预期的 JSON 格式响应将是一个所有可用场所的列表：
- en: '[PRE0]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'With `GET` `/api/v1/venues/2`, the expected response in JSON format will be
    a specific venue resource with `id` `2`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `GET` `/api/v1/venues/2`，预期的 JSON 格式响应将是一个具有 `id` `2` 的特定场所资源：
- en: '[PRE1]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'With `POST` `/api/v1/venues`, the expected response in JSON format will be
    an added venue resource with the returned `id` `3`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `POST` `/api/v1/venues`，预期的 JSON 格式响应将是一个添加的场所资源，其返回的 `id` 为 `3`：
- en: '[PRE2]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'With `UPDATE` `/api/v1/venues/3`, the expected response in JSON will be an
    updated venue resource with `id` `3`; the new value of the `name` property is
    now `Conference Hall`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `UPDATE` `/api/v1/venues/3`，预期的 JSON 格式响应将是一个更新后的场所资源，其 `id` 为 `3`；`name`
    属性的新值现在是 `Conference Hall`：
- en: '[PRE3]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'With `DELETE` `/api/v1/venues/3`, the expected response in JSON will be a deleted
    resource venue with `id` `3`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `DELETE` `/api/v1/venues/3`，预期的 JSON 格式响应将是一个已删除的资源场所，其 `id` 为 `3`：
- en: '[PRE4]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The preceding JSON response messages depict endpoint data representation based
    on the requests to the server. The `/api/v1/venues` RESTful API endpoints with
    `GET` will return a list of available venues, `GET /api/v1/venues/2` will return
    a specific venue with `id` `2`, `POST /api/v1/venues` will add a new venue and
    return its `id`, `UPDATE /api/v1/venues/3` will update the venue with `id 3` and
    return the updated resource, and `DELETE /api/v1/venues/3` will delete the venue
    with `id` `3`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的 JSON 响应消息描述了基于对服务器的请求的端点数据表示。使用 `GET` 的 `/api/v1/venues` RESTful API 端点将返回可用场所的列表，`GET
    /api/v1/venues/2` 将返回具有 `id` `2` 的特定场所，`POST /api/v1/venues` 将添加一个新的场所并返回其 `id`，`UPDATE
    /api/v1/venues/3` 将更新 `id 3` 的场所并返回更新后的资源，而 `DELETE /api/v1/venues/3` 将删除 `id`
    `3` 的场所。
- en: Next, we will examine some of the golden rules to adhere to while designing
    endpoints. With these principles, you will be able to design a more intuitive
    and user-friendly RESTful API that will reduce the time and effort required to
    develop and maintain applications that use the API.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将检查在设计端点时需要遵守的一些黄金法则。有了这些原则，您将能够设计出更直观、用户友好的 RESTful API，这将减少开发和使用 API
    的应用程序所需的时间和精力。
- en: API endpoint best practices
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: API 端点最佳实践
- en: 'There are principles guiding the design of a good API endpoint and by extension
    API development. We will briefly examine the following golden rules for designing
    API endpoints your team members or other developers can relate to:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 设计一个好的API端点有指导原则，这些原则也适用于API开发。我们将简要探讨以下设计API端点的黄金法则，这些法则可以让团队成员或其他开发者产生共鸣：
- en: '`/venues` endpoint, the noun `venues` explains what the resource is all about:'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/venues`端点，名词`venues`解释了资源的相关内容：'
- en: '`https://example.com/api/v1/venues`'
  id: totrans-81
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`https://example.com/api/v1/venues`'
- en: '`https://example.com/api/v1/get_all_venues`'
  id: totrans-82
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`https://example.com/api/v1/get_all_venues`'
- en: '`venues` case, you can see that we used `/venues` to describe the collection,
    for example, `https://example.com/api/v1/venues/2`, where `id=2`, refers to a
    specific resource in the collection:'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`venues`案例中，您可以看到我们使用了`/venues`来描述集合，例如，`https://example.com/api/v1/venues/2`，其中`id=2`，指的是集合中的特定资源：
- en: '`https://example.com/api/v1/venues`'
  id: totrans-84
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`https://example.com/api/v1/venues`'
- en: '`https://example.com/api/v1/venue`'
  id: totrans-85
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`https://example.com/api/v1/venue`'
- en: '`collection/resource/collection` structure, the endpoint URL starts with the
    collection name, followed by the resource name, and then another collection name
    if applicable.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`collection/resource/collection`结构中，端点URL以集合名称开头，接着是资源名称，如果适用，然后是另一个集合名称。'
- en: 'For example, in the case of a `speaker` resource, which may have a collection
    of `papers`, the recommended endpoint URL would be something like `/speakers/2/papers`,
    where `speakers` is the collection name, `2` is the ID of a specific speaker resource,
    and `papers` is the collection of papers associated with this particular speaker:'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，对于一个可能包含一系列论文的`speaker`资源，推荐的端点URL可能类似于`/speakers/2/papers`，其中`speakers`是集合名称，`2`是特定演讲者资源的ID，而`papers`是与该特定演讲者关联的论文集合：
- en: '`https://example.com/api/v1/speakers/2/papers`'
  id: totrans-88
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`https://example.com/api/v1/speakers/2/papers`'
- en: '`https://example.com/api/v1/speakers/2/papers/8/reviews`'
  id: totrans-89
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`https://example.com/api/v1/speakers/2/papers/8/reviews`'
- en: '`https://example.com/api/v1/speakers/2/papers/8/reviews` violates the recommended
    structure by including another collection name, `reviews`, after `papers`. This
    structure implies that `reviews` is a sub-collection of `papers`, which contradicts
    the rule of the `collection/resource/collection` pattern. Instead, we can treat
    them as separate resources with their own endpoints.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`https://example.com/api/v1/speakers/2/papers/8/reviews`违反了推荐的结构，在`papers`之后包含了另一个集合名称`reviews`。这种结构暗示`reviews`是`papers`的子集合，这与`collection/resource/collection`模式的规则相矛盾。相反，我们可以将它们视为具有自己端点的独立资源。'
- en: 'Take the following example:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例：
- en: '`GET /api/v1/speakers/2/papers`'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET /api/v1/speakers/2/papers`'
- en: '`GET /api/v1/papers/8/reviews`'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET /api/v1/papers/8/reviews`'
- en: By separating the endpoints, it becomes clearer that reviews are related to
    papers, rather than being nested within the `papers` collection.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 通过分离端点，可以更清楚地看出评论与论文相关，而不是嵌套在`papers`集合中。
- en: Next, we will explore the structure of the payload and examine its role within
    this context.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨负载数据的结构，并检查其在当前上下文中的作用。
- en: Understanding the payload structure
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解负载数据结构
- en: The payload contains the actual data that the API is designed to work with.
    In this section, you will understand the data format that is sent and received
    by an API. You will learn how the payload is structured, including the keys and
    values that are used to represent the data.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 负载数据包含API设计用于处理的实际数据。在本节中，您将了解API发送和接收的数据格式。您将学习如何构建负载数据，包括用于表示数据的键和值。
- en: With this understanding of the payload structure, you will be able to work with
    more complex APIs and handle larger amounts of data. As discussed earlier, an
    API provides an interface for the exchange of data between web services. The data
    in question for interacting, communicating, or sharing is the payload.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 通过理解负载数据结构，您将能够处理更复杂的API并处理更大的数据量。如前所述，API提供了在Web服务之间交换数据的方式。在交互、通信或共享数据时，所涉及的数据是负载数据。
- en: 'The payload is the data of interest between various web applications that want
    to exchange information. Technically, this is the body of the HTTP request and
    response in client-server communication. In an API ecosystem, when a client makes
    a request, in the body of the request is the data, which essentially consists
    of two parts: the header/overhead and the payload.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 负载数据是希望交换信息的各种Web应用程序之间的数据。技术上讲，这是客户端-服务器通信中HTTP请求和响应的主体。在API生态系统中，当客户端发起请求时，请求的主体中包含数据，这本质上由两部分组成：头部/开销和负载数据。
- en: 'The header is used to describe the source or destination of the data in transit.
    The payload comes in different flavors: JSON or XML. The payloads are recognizable
    with the use of curly braces, `{}`. We will focus on the JSON format of the payload
    in this book.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 标头用于描述传输中的数据源或目的地。有效负载有不同的风味：JSON或XML。有效负载通过使用花括号`{}`来识别。在这本书中，我们将重点关注有效负载的JSON格式。
- en: We are choosing JSON format because JSON is easy to read and understand, easy
    to parse in most programming languages, supports complex data structures, is platform-independent,
    and uses minimal syntax.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择JSON格式，因为JSON易于阅读和理解，在大多数编程语言中易于解析，支持复杂的数据结构，是平台无关的，并且使用最少的语法。
- en: Let’s describe a typical structure of a payload with examples.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过示例描述一个典型有效负载的结构。
- en: 'The following is a payload that a client sends to the server (the *API* *request*
    payload):'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个客户端发送给服务器的有效负载（*API* *请求*有效负载）：
- en: '[PRE5]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Note the following in the preceding code:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 注意以下代码中的内容：
- en: The payload is indicated with data within curly braces, and it explains the
    information we want to send to the `/venues` API endpoint using the `POST` HTTP
    method
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有效负载由花括号内的数据表示，并解释了我们要使用`POST`HTTP方法发送到`/venues`API端点的信息。
- en: 'The `"Content-Type: application/json"` request header describes the JSON data
    type of the request body'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"Content-Type: application/json"`请求头描述了请求体的JSON数据类型。'
- en: 'The client also describes the response format it expects from the server with
    `Accept: application/json`'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '客户端还使用`Accept: application/json`描述它从服务器期望接收的响应格式。'
- en: 'For a server-returned payload (*OK response* payload from the server), we have
    the following:'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于服务器返回的有效负载（来自服务器的*OK响应*有效负载），我们有以下内容：
- en: '[PRE6]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Note the following in the preceding snippet:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 注意以下代码片段中的内容：
- en: '`OK` and the content data within curly braces are the payloads.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OK`和花括号内的内容数据是有效负载。'
- en: 'You can see that the server complied with the `Content-Type: application/json`
    the client is expecting to receive.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '您可以看到服务器遵守了客户端期望接收的`Content-Type: application/json`。'
- en: 'The JSON payload is enclosed in curly braces, `{}`, and consists of two key-value
    pairs:'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSON有效负载用花括号`{}`括起来，由两个键值对组成：
- en: '`"responseType": "Ok"`: This key-value pair indicates that the API successfully
    processed the request and returned a response. The `"responseType"` key has a
    value of `"Ok"`.'
  id: totrans-115
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"responseType": "Ok"`：这个键值对表示API成功处理了请求并返回了响应。`"responseType"`键的值是`"Ok"`。'
- en: '`"data": { "id": 3, "name": "Conference Hall" }`: This key-value pair contains
    the actual data being returned by the API. The `"data"` key has a value of an
    object that contains information about the venue with ID `3`. In this case, the
    venue name is `"``Conference Hall"`.'
  id: totrans-116
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"data": { "id": 3, "name": "Conference Hall" }`：这个键值对包含API实际返回的实际数据。`"data"`键的值是一个包含有关ID为`3`的场所信息的对象。在这种情况下，场所名称是`"Conference
    Hall"`。'
- en: '[PRE7]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The payloads in the preceding code are `"responseType": "Failed"` and `"message":
    "``Not found"`.'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '上述代码中的有效负载是`"responseType": "Failed"`和`"message": "``Not found"`。'
- en: Endpoints and payloads are essential parts of API development. You need to design
    API endpoints that are concise and intuitive to clearly communicate your intentions
    to developers who may want to interact with your API data services.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 端点和有效负载是API开发的重要组成部分。您需要设计简洁直观的API端点，以便清楚地传达您的意图给可能希望与您的API数据服务交互的开发者。
- en: Now, we will deepen the knowledge stacks and glance through HTTP requests/responses.
    When building web applications, it’s essential to have a good understanding of
    how HTTP requests and responses work.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将深化知识体系，快速浏览HTTP请求/响应。在构建Web应用时，了解HTTP请求和响应的工作方式至关重要。
- en: These are the building blocks of communication between clients and servers,
    and knowing how to work with them is crucial for building effective and efficient
    web applications.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是客户端和服务器之间通信的构建块，了解如何使用它们对于构建有效和高效的Web应用至关重要。
- en: Understanding HTTP requests/responses
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解HTTP请求/响应
- en: To successfully work with APIs, you need to have an understanding of HTTP requests/responses.
    So, let’s unmask the structure of HTTP requests and responses.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 要成功与API一起工作，您需要了解HTTP请求/响应。因此，让我们揭开HTTP请求和响应的结构。
- en: Request line
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 请求行
- en: 'Every HTTP request begins with the request line. This comprises the HTTP method,
    the requested resource, and the HTTP protocol version:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 每个HTTP请求都以请求行开始。这包括HTTP方法、请求的资源以及HTTP协议版本：
- en: '[PRE8]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this instance, `GET` is the HTTP method, `/api/v1/venues` is the path to
    the resource requested, and `HTTP 1.1` is the protocol and version used.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`GET` 是 HTTP 方法，`/api/v1/venues` 是请求资源的路径，`HTTP 1.1` 是使用的协议和版本。
- en: Let’s dive deeper into HTTP methods to understand how developers use different
    HTTP methods to specify the type of action they want to perform when making requests
    to the web servers.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进一步深入了解 HTTP 方法，以了解开发人员如何使用不同的 HTTP 方法来指定他们在向 Web 服务器发出请求时想要执行的操作类型。
- en: HTTP methods
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: HTTP 方法
- en: 'HTTP methods indicate the action that the client intends to perform on the
    web server resource. Commonly used HTTP methods are the following:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 方法指示客户端打算在 Web 服务器资源上执行的操作。常用的 HTTP 方法如下：
- en: '`GET`: The client requests a resource on the web server'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET`：客户端请求 Web 服务器上的资源'
- en: '`POST`: The client submits data to a resource on the web server'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST`：客户端向 Web 服务器上的资源提交数据'
- en: '`PUT`: The client replaces a resource on the web server'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PUT`：客户端替换 Web 服务器上的资源'
- en: '`DELETE`: The client deletes a resource on the web server'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DELETE`：客户端删除 Web 服务器上的资源'
- en: Let’s take a glance through the request headers.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速浏览一下请求头。
- en: HTTP request headers
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: HTTP 请求头部
- en: HTTP headers play a critical role in facilitating communication between the
    client and server during an HTTP request or response. They allow both parties
    to include additional information alongside the primary data being transferred,
    such as metadata, authentication credentials, or caching directives.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 头部在 HTTP 请求或响应期间促进客户端和服务器之间的通信中起着关键作用。它们允许双方在传输主要数据的同时包含附加信息，例如元数据、身份验证凭据或缓存指令。
- en: Headers act as a placeholder for payloads and provide crucial context and metadata
    to both the client and server. For example, they can convey information about
    the content type, language, encoding, and size of the data being transferred.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 头部充当有效载荷的占位符，并为客户端和服务器提供关键上下文和元数据。例如，它们可以传达有关正在传输的数据的内容类型、语言、编码和大小等信息。
- en: Additionally, headers can provide details about the client’s capabilities and
    preferences, such as the type of browser being used or the preferred language
    for content delivery. HTTP request headers come immediately after the request
    line.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，头信息还可以提供有关客户端能力和偏好的详细信息，例如正在使用的浏览器类型或内容交付的首选语言。HTTP 请求头紧随请求行之后。
- en: 'Common headers are the following:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 常见的头部如下：
- en: '`www.packtpub.com/`'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`www.packtpub.com/`'
- en: The `Host` header specifies the host of the server and indicates where the resource
    is requested from.
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Host` 头部指定服务器的主机，并指示从哪里请求资源。'
- en: '`"Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:107.0)` `Gecko/20100101 Firefox/107.0"`'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:107.0)` `Gecko/20100101 Firefox/107.0"`'
- en: The `User-Agent` header tells the web server of the application that is making
    the HTTP request. It usually consists of the operating system (such as Windows,
    Mac, or Linux), version, and application vendor.
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`User-Agent` 头部告诉 Web 服务器正在发出 HTTP 请求的应用程序。它通常由操作系统（如 Windows、Mac 或 Linux）、版本和应用供应商组成。'
- en: '`"text/html,application/xhtml+xml,application/xml;q=0.9,ima` `ge/avif,image/webp,*/*;q=0.8"`'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"text/html,application/xhtml+xml,application/xml;q=0.9,ima` `ge/avif,image/webp,*/*;q=0.8"`'
- en: The `Accept` header tells the web server what type of content the client will
    accept as the response.
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Accept` 头部告诉 Web 服务器客户端可以接受哪种类型的内容作为响应。'
- en: '`en-US,en;q=0.5`'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`en-US,en;q=0.5`'
- en: The `Accept-Language` header indicates the language.
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Accept-Language` 头部指示语言。'
- en: '`text/html; charset=UTF-8`'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`text/html; charset=UTF-8`'
- en: The `Content-type` header indicates the type of content being transmitted in
    the request body.
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Content-type` 头部指示请求体中传输的内容类型。'
- en: Next, we will examine the request body.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将检查请求体。
- en: HTTP request body
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: HTTP 请求体
- en: In HTTP, the request body refers to the additional data that is sent along with
    an HTTP request message, typically in the form of a payload. Unlike HTTP headers,
    which provide metadata about the request or response, the request body contains
    the actual data that the client is sending to the server. The request body can
    contain various types of data, including form data, JSON, XML, binary data, or
    text.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在 HTTP 中，请求体指的是与 HTTP 请求消息一起发送的附加数据，通常以有效载荷的形式。与提供请求或响应元数据的 HTTP 头部不同，请求体包含客户端发送给服务器的实际数据。请求体可以包含各种类型的数据，包括表单数据、JSON、XML、二进制数据或文本。
- en: For example, when submitting a web form, the data entered by the user is typically
    sent as part of the request body. Similarly, when uploading a file or sending
    an API request, the data being transmitted is often included in the request body.
    The format and structure of the request body depend on the content type specified
    in the request headers.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当提交网页表单时，用户输入的数据通常作为请求体的一部分发送。同样，当上传文件或发送API请求时，正在传输的数据通常包含在请求体中。请求体的格式和结构取决于请求头中指定的内容类型。
- en: For instance, if the content type is set to `application/json`, the request
    body must be a valid JSON object. If the content type is `multipart/form-data`,
    the request body may include multiple parts, each containing different types of
    data.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果内容类型设置为`application/json`，则请求体必须是一个有效的JSON对象。如果内容类型为`multipart/form-data`，则请求体可能包含多个部分，每个部分包含不同类型的数据。
- en: 'The following shows an HTTP request that uses the `POST` method to submit data
    to a web server:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个使用`POST`方法向Web服务器提交数据的HTTP请求示例：
- en: '[PRE9]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The request includes a request body in JSON format, which contains a key-value
    pair and an array. The key has a value of `"value"`, and the array contains two
    string values, `"value3"` and `"value4"`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 请求包含一个JSON格式的请求体，其中包含一个键值对和一个数组。键的值为`"value"`，数组包含两个字符串值，`"value3"`和`"value4"`。
- en: 'The following shows an HTTP request that uses the `PUT` method to update data
    on a web server:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个使用`PUT`方法更新Web服务器上数据的HTTP请求示例：
- en: '[PRE10]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The request includes a request body in JSON format, which contains a key-value
    pair. The key has a value of `"value"`, and this data is intended to update the
    resource at the specified endpoint.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 请求包含一个JSON格式的请求体，其中包含一个键值对。键的值为`"value"`，这些数据旨在更新指定端点的资源。
- en: Next, we will consider HTTP responses. HTTP responses are the server’s way of
    communicating with the client in response to an HTTP request.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将考虑HTTP响应。HTTP响应是服务器对HTTP请求的响应方式。
- en: HTTP responses
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTTP响应
- en: Understanding the various HTTP status codes and the information included in
    HTTP responses is essential for building robust and effective web applications.
    After the web server has processed an HTTP request, it is expected to send an
    HTTP response to the client.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 理解各种HTTP状态码和HTTP响应中包含的信息对于构建健壮和有效的Web应用至关重要。在Web服务器处理完HTTP请求后，它应向客户端发送HTTP响应。
- en: 'The initial line of the response contains the status, which indicates whether
    the request was successful or unsuccessful due to an error. This status line provides
    critical feedback to the client about the outcome of the request:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 响应的第一行包含状态，它指示请求是否成功或由于错误而失败。此状态行向客户端提供了关于请求结果的宝贵反馈：
- en: '[PRE11]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The HTTP response begins with the HTTP protocol version, followed by the status
    code, and a reason message. The reason message is a textual representation of
    the status code. In the upcoming *Understanding HTTP status codes* section, we
    will delve into the topic of status codes in detail.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP响应以HTTP协议版本开始，接着是状态码，然后是原因消息。原因消息是状态码的文本表示。在即将到来的*理解HTTP状态码*部分，我们将详细探讨状态码的主题。
- en: We will now begin discussing the response headers.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将开始讨论响应头。
- en: HTTP response headers
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: HTTP响应头
- en: In HTTP, response headers provide additional information about the response
    message sent by the server. While the status code in the initial line of an HTTP
    response provides essential information about the outcome of the request, response
    headers can provide additional metadata about the response, such as the content
    type, cache settings, and server type.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在HTTP中，响应头提供了关于服务器发送的响应消息的额外信息。虽然HTTP响应初始行中的状态码提供了关于请求结果的基本信息，但响应头可以提供关于响应的额外元数据，例如内容类型、缓存设置和服务器类型。
- en: Response headers are typically used to provide the client with information that
    can help optimize the rendering and processing of the response, such as specifying
    the character encoding or content length. Response headers can also be used to
    control the behavior of the client, such as setting caching parameters or enabling
    **cross-origin resource sharing** (**CORS**) for API requests.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 响应头通常用于向客户端提供有助于优化响应渲染和处理的信息，例如指定字符编码或内容长度。响应头还可以用于控制客户端的行为，例如设置缓存参数或为API请求启用**跨源资源共享**（**CORS**）。
- en: HTTP response headers are sent by the server in the response message, immediately
    following the status line. The headers consist of one or more lines, each with
    a header field name and a value, separated by a colon. Some common response headers
    include `Content-Type`, `Content-Length`, `Cache-Control`, `Server`, and `Set-Cookie`.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 响应头由服务器在响应消息中发送，紧随状态行之后。头由一行或多行组成，每行包含一个头字段名和一个值，由冒号分隔。一些常见的响应头包括 `Content-Type`、`Content-Length`、`Cache-Control`、`Server`
    和 `Set-Cookie`。
- en: 'The following is an example of an HTTP response header:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个 HTTP 响应头的示例：
- en: '[PRE12]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Considering the preceding code block, we have the following:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到前面的代码块，我们有以下内容：
- en: The `Date` header specifies the date and time at which the HTTP response was
    generated
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Date` 头指定了 HTTP 响应生成的日期和时间'
- en: The `Server` header describes the web server software used to generate the response
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Server` 头描述了用于生成响应的 Web 服务器软件'
- en: 'The `Content-Type` header describes the media type of the resource returned:
    in this case, HTML'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Content-Type` 头描述了返回资源的媒体类型：在这种情况下，HTML'
- en: Next, we will discuss the HTTP response body.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论 HTTP 响应体。
- en: HTTP response body
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: HTTP 响应体
- en: The response body refers to the data sent by the server in response to an HTTP
    request. While the response headers provide metadata about the response, the response
    body contains the actual data that the client requested, such as HTML, JSON, XML,
    or binary data.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 响应体指的是服务器在响应 HTTP 请求时发送的数据。虽然响应头提供了关于响应的元数据，但响应体包含客户端请求的实际数据，例如 HTML、JSON、XML
    或二进制数据。
- en: The structure and content of the response body depend on the nature of the request
    and the format of the requested data. For example, a request for a web page might
    receive an HTML response body containing the markup and content of the page, while
    a request for data from an API might receive a JSON response body containing the
    requested data.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 响应体的结构和内容取决于请求的性质和请求数据的格式。例如，对网页的请求可能会收到包含页面标记和内容的 HTML 响应体，而对 API 数据的请求可能会收到包含请求数据的
    JSON 响应体。
- en: 'In HTTP, the response body may contain content in certain situations, such
    as when the server responds with a status code of `200`, which indicates that
    the request was successful and that the server is returning content. In other
    cases, when the server responds with a status code of `204`, it indicates that
    the request was successful but that there is no content to return, so the response
    body may be empty:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在 HTTP 中，响应体可能在某些情况下包含内容，例如当服务器以状态码 `200` 响应时，这表示请求成功，服务器正在返回内容。在其他情况下，当服务器以状态码
    `204` 响应时，它表示请求成功，但没有内容返回，因此响应体可能为空：
- en: '[PRE13]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Having discussed HTTP requests and responses, we will now begin discussing the
    various commonly used HTTP status codes.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论了 HTTP 请求和响应之后，我们现在将开始讨论各种常用的 HTTP 状态码。
- en: Understanding HTTP status codes
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 HTTP 状态码
- en: HTTP status codes are three-digit numbers sent by a server in response to an
    HTTP request. These codes provide feedback to the client about the outcome of
    the request and help identify any issues that may have occurred during the transaction.
    The first digit of an HTTP status code indicates the category of the responses,
    which could be `Informational`, `Successful`, `Redirection`, `Client Error`, or
    `Server Error`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 状态码是服务器在响应 HTTP 请求时发送的三位数。这些代码向客户端提供有关请求结果的反馈，并帮助识别在事务过程中可能发生的任何问题。HTTP
    状态码的第一个数字表示响应的类别，可能是 `Informational`、`Successful`、`Redirection`、`Client Error`
    或 `Server Error`。
- en: 'The common status codes you’ll encounter for each category are listed as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 每个类别中你可能会遇到的常见状态码如下所示：
- en: '`1XX Informational`'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`1XX 信息性`'
- en: '| **Status Code** | **Description** | **Reason** |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| **状态码** | **描述** | **原因** |'
- en: '| `100` | This code indicates an interim response from the web server informing
    the client to continue the request or ignore the response if the request has already
    been processed | Continue |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| `100` | 此代码表示 Web 服务器向客户端发送的临时响应，告知客户端继续请求或如果请求已被处理则忽略响应。 | `继续` |'
- en: '`2XX Successful`'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`2XX 成功`'
- en: '| **Status Code** | **Description** | **Reason** |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| **状态码** | **描述** | **原因** |'
- en: '| `200` | This code indicates the server successfully processed the request.
    | `OK` |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| `200` | 此代码表示服务器成功处理了请求。 | `OK` |'
- en: '| `201` | This code indicates the server successfully processed the request
    and a resource was created. | `Created` |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| `201` | 此代码表示服务器成功处理了请求并创建了资源。 | `已创建` |'
- en: '| `202` | This code indicates the request has been received but the processing
    has not yet been completed. | `Accepted` |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| `202` | 此代码表示请求已接收，但处理尚未完成。 | `已接受` |'
- en: '| `204` | The code indicates the server successfully processed the request
    but is not returning any content. | `No content` |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| `204` | 此代码表示服务器成功处理了请求，但没有返回任何内容。 | `无内容` |'
- en: '`3XX Redirection`'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`3XX 重定向`'
- en: '| **Status Code** | **Description** | **Reason** |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| **状态码** | **描述** | **原因** |'
- en: '| `301` | This code indicates that the request and all future requests should
    be sent to the new location in the response header | `Moved Permanently` |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| `301` | 此代码表示请求以及所有未来的请求都应该发送到响应头中的新位置。 | `永久移动` |'
- en: '| `302` | This code indicates the request should be sent temporarily to the
    new location in the response header | `Found` |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| `302` | 此代码表示请求应暂时发送到响应头中的新位置。 | `找到` |'
- en: '`4XX` `Client Error`'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`4XX` `客户端错误`'
- en: '| **Status Code** | **Description** | **Reason** |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| **状态码** | **描述** | **原因** |'
- en: '| `400` | This code indicates that the server cannot process the request due
    to a perceived client error. | `Bad Request` |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| `400` | 此代码表示服务器无法处理请求，因为客户端存在错误。 | `错误请求` |'
- en: '| `401` | This code indicates that the client making the request is unauthorized
    and should be authenticated. | `Unauthorized` |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| `401` | 此代码表示发起请求的客户端未经授权，应进行认证。 | `未经授权` |'
- en: '| `403` | This code indicates that the client making the request does not have
    the right to access the content; they are unauthorized and should obtain the right
    to access the resource. | `Forbidden` |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| `403` | 此代码表示发起请求的客户端没有访问内容的权限；他们未经授权，应获得访问资源的权限。 | `禁止访问` |'
- en: '| `404` | This code indicates that the web server did not find the requested
    resource. | `Not Found` |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| `404` | 此代码表示网络服务器未找到请求的资源。 | `未找到` |'
- en: '| `405` | This code indicates that the web server knows the method but the
    targeted resource does not support the HTTP method used. | `Method` `Not Allowed`
    |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| `405` | 此代码表示网络服务器知道方法，但目标资源不支持使用的 HTTP 方法。 | `方法不允许` |'
- en: '`5XX` `Server Error`'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`5XX` `服务器错误`'
- en: '| **Status Code** | **Description** | **Reason** |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| **状态码** | **描述** | **原因** |'
- en: '| `500` | This code indicates that the web server has encountered an unexpected
    error while processing the request. | `Internal` `Server Error` |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| `500` | 此代码表示在处理请求时，网络服务器遇到了意外错误。 | `内部服务器错误` |'
- en: '| `502` | This code indicates that the web server, while acting as a gateway
    to get a response, received an invalid response from the application server. |
    `Bad Gateway` |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| `502` | 此代码表示在作为获取响应的网关时，网络服务器从应用程序服务器接收到了无效的响应。 | `不良网关` |'
- en: '| `503` | This code indicates that the web server is unavailable to process
    the request. | `Service Unavailable` |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| `503` | 此代码表示网络服务器无法处理请求。 | `服务不可用` |'
- en: Before we explore how to implement a REST API in Flask web applications, it’s
    important to grasp the underlying principles of RESTful API design. By understanding
    these fundamentals, we can ensure that our API is designed in a way that is intuitive,
    user-friendly, and efficient. So, let’s take a closer look at the key principles
    that underpin RESTful API design.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们探讨如何在 Flask 网络应用程序中实现 REST API 之前，理解 RESTful API 设计的基本原则非常重要。通过理解这些基本原则，我们可以确保我们的
    API 设计得直观、用户友好且高效。因此，让我们更深入地了解支撑 RESTful API 设计的关键原则。
- en: REST API design principles
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: REST API 设计原则
- en: REST API, or RESTful API, describes an API that conforms to the REST architectural
    style using an HTTP-based interface for network communication. An API in its simplest
    form defines a set of rules that disparate systems or applications need to conform
    to in order to exchange data.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: REST API，或 RESTful API，描述了一个符合 REST 架构风格的 API，它使用基于 HTTP 的接口进行网络通信。API 在其最简单的形式中定义了一组规则，不同的系统或应用程序需要遵守这些规则以交换数据。
- en: Dr. Roy Fielding, in the year 2000, presented a dissertation ([https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm](https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm))
    that described a novel design approach that API designers are expected to follow
    in building applications that can stand the test of time in addition to being
    secure. In order to develop a RESTful system, there are architectural constraints
    that are worth keeping in mind.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 罗伊·菲尔丁博士在2000年提出了一篇论文([https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm](https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm))，描述了一种新颖的设计方法，API设计者预期在构建能够经受时间考验且安全的应用程序时遵循。为了开发RESTful系统，有一些值得注意的架构约束。
- en: We will examine those REST principles, such as *client-server*, *statelessness*,
    *caching*, *uniform interface*, *layered system*, and *code on demand*, to conform
    to a REST style guide.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将检查那些REST原则，例如*客户端-服务器*、*无状态性*、*缓存*、*统一接口*、*分层系统*和*按需代码*，以符合REST风格指南。
- en: Client-server
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 客户端-服务器
- en: The REST API architecture encourages client and server communication. The client
    sends a network request to the server, while the server can only send a response
    back to the client. RESTful APIs ensure all communications start from clients,
    who then wait for a response from the server.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: REST API架构鼓励客户端和服务器之间的通信。客户端向服务器发送网络请求，而服务器只能向客户端发送响应。RESTful API确保所有通信都从客户端开始，然后客户端等待服务器的响应。
- en: RESTful APIs enforce the separation of concerns between the client applications
    and server, thus making the interaction smooth and independent. Owing to the separation
    of concerns, web application designs are not tightly coupled as the client and
    server can scale without inadvertently impacting the overall application architecture.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: RESTful API强制执行客户端应用程序和服务器之间的关注点分离，从而使得交互流畅且独立。由于关注点分离，Web应用程序设计不是紧密耦合的，因为客户端和服务器可以独立扩展，而不会无意中影响整体应用程序架构。
- en: Note
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Separation of concerns is a design principle that aims to separate a system
    into distinct, independent parts, with each part responsible for a specific task
    or functionality. This design principle is commonly applied in software engineering
    and programming, including in the design of REST APIs.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 关注点分离是一种设计原则，旨在将系统划分为不同的、独立的部分，每个部分负责特定的任务或功能。这个设计原则在软件工程和编程中普遍应用，包括REST API的设计。
- en: Statelessness
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无状态性
- en: Conforming to REST API design constraints requires all network requests to be
    stateless. Statelessness means a server is not expected to remember past network
    requests. Technically, the statelessness of a network request encourages independent
    interaction between the client and server.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 符合REST API设计约束要求所有网络请求都必须是无状态的。无状态性意味着服务器不期望记住过去的网络请求。技术上，网络请求的无状态性鼓励客户端和服务器之间独立的交互。
- en: Every request from a client to a server is expected to contain all of the important
    information required to understand and fulfill the request. Statelessness invariably
    improves performance as the server does not need to store or remember previous
    requests. In addition, with a stateless state in RESTful application design, the
    architecture is simple to set up, scalable, and reliable.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 每个客户端向服务器发出的请求都应包含理解并满足该请求所需的所有重要信息。无状态性总是能提高性能，因为服务器不需要存储或记住之前的请求。此外，在RESTful应用程序设计中，无状态状态使得架构简单易设，可扩展且可靠。
- en: Caching
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缓存
- en: RESTful APIs are designed with caching in mind. Caching is the process of storing
    frequently used data in a temporary location in order to reduce the time and resources
    required to access it. The caching principle in REST API ensures that network
    information contained within a response to a request be declared implicitly or
    explicitly as cacheable or non-cacheable.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: RESTful API在设计时考虑了缓存。缓存是将频繁使用的数据存储在临时位置的过程，以减少访问它所需的时间和资源。REST API中的缓存原则确保对请求的响应中包含的网络信息被隐式或显式地声明为可缓存或不可缓存。
- en: For instance, if a response is cacheable, the client will reuse the cached response
    data for similar subsequent requests. Caching improves the efficiency of server
    resources and reduces bandwidth usage while decreasing the loading time of a site
    page.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果响应是可缓存的，客户端将重用缓存的响应数据来处理类似的后续请求。缓存提高了服务器资源的效率，减少了带宽使用，同时降低了网站页面的加载时间。
- en: Uniform interface
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 统一接口
- en: A uniform interface is another design constraint that REST API designers need
    to implement. The REST API architectural style states that the REST API should
    have a single communication protocol and a standardized data format. Regardless
    of the system’s environment, applications and servers, a uniform interface facilitates
    smooth interaction.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 统一接口是REST API设计者需要实现的设计约束之一。REST API架构风格指出，REST API应具有单一的通信协议和标准化的数据格式。无论系统环境如何，应用程序和服务器，统一接口都便于顺畅的交互。
- en: A uniform interface encourages the ease of evolvability of each system component
    and provides a common framework for any client application to communicate with
    a REST API.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 统一接口鼓励每个系统组件的易于可扩展性，并为任何客户端应用程序与REST API通信提供了一个通用框架。
- en: 'REST APIs adopt HTTP as a communication protocol for client-server interaction.
    With HTTP, the client sends a request in a specific format, such as JSON or XML.
    Let’s take a look at a sample request:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: REST API采用HTTP作为客户端-服务器交互的通信协议。使用HTTP，客户端以特定格式发送请求，如JSON或XML。让我们看看一个示例请求：
- en: '[PRE14]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This REST API request contains two major components – `GET` and the URL:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 此REST API请求包含两个主要组件——`GET`和URL：
- en: '`GET` is one of the HTTP methods. The `GET` method specifies the action the
    client wants to make on the server resource. There are four commonly used HTTP
    requests a client uses to make a request:'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET`是HTTP方法之一。`GET`方法指定客户端想要在服务器资源上执行的操作。客户端通常使用四种常用的HTTP请求来发起请求：'
- en: '`GET`: To retrieve a resource'
  id: totrans-237
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET`：用于检索资源'
- en: '`POST`: To create a new resource'
  id: totrans-238
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST`：用于创建新资源'
- en: '`PUT`/`PATCH`: To update or edit an existing resource'
  id: totrans-239
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PUT`/`PATCH`：用于更新或编辑现有资源'
- en: '`DELETE`: To delete a resource'
  id: totrans-240
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DELETE`：用于删除资源'
- en: The URL part contains the uniform resource identifier that specifies the resource
    of interest. In this case, we are interested in the `venues` resource. So, we
    issued an HTTP `GET` request to look up the location of that resource.
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: URL部分包含统一资源标识符，指定了感兴趣的资源。在这种情况下，我们感兴趣的是`venues`资源。因此，我们发出一个HTTP `GET`请求来查找该资源的位置。
- en: Furthermore, the URL is also sometimes called an endpoint. The endpoint represents
    the location where the API actually interacts with the client, the point at which
    data exchange takes place.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，URL有时也被称为端点。端点表示API实际与客户端交互的位置，数据交换发生的地方。
- en: The client-server interaction proceeds with the host receiving and validating
    the `GET` request. The response data is returned from the target resource (`/api/v1/venues`).
    The returned data format is often in the form of JSON or the expected response
    format as specified by the client. JSON allows us to have standardized structured
    data to display the contents of the target resource.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端-服务器交互从主机接收和验证`GET`请求开始。响应数据从目标资源（`/api/v1/venues`）返回。返回的数据格式通常是JSON或客户端指定的预期响应格式。JSON允许我们拥有标准化的结构化数据来显示目标资源的内容。
- en: Layered system
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分层系统
- en: Modern web applications are composed of layered architectures. The client-server
    system could have multiple layers of servers/services each with its own responsibility,
    such as load balancing, security, and caching layers. The REST API design principle
    encourages an implementation in which the layers of systems that may exist do
    not alter the natural behaviors of client-server interaction.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现代Web应用程序由分层架构组成。客户端-服务器系统可能包含多个层的服务器/服务，每个都有自己的责任，例如负载均衡、安全和缓存层。REST API设计原则鼓励实现，其中可能存在的系统层不会改变客户端-服务器交互的自然行为。
- en: With this constraint, any change or modification in the inner systems/servers
    will have zero effect on the format of the HTTP-based request and response model.
    A layered system enforces a clear separation of concerns and improves scalability
    as the client and server are highly independent and can grow at scale.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在此约束下，内部系统/服务器中的任何更改或修改都不会对基于HTTP的请求和响应模型的格式产生影响。分层系统强制执行关注点的清晰分离，并随着客户端和服务器的高度独立性和可扩展性而提高。
- en: Code on demand (optional)
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 需求代码（可选）
- en: Code on demand is an optional constraint in RESTful API design, which allows
    the server to send executable code to the client in response to a request. This
    code can be in the form of scripts, applets, or other executable files, and can
    be used to extend the functionality of the client.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 需求代码是RESTful API设计中的一个可选约束，允许服务器在响应请求时向客户端发送可执行代码。这些代码可以是脚本、小程序或其他可执行文件，并可用于扩展客户端的功能。
- en: The code-on-demand constraint is optional because it is not always necessary
    or desirable for an API to provide executable code to clients. In many cases,
    RESTful APIs simply provide data or resources that can be consumed by client applications
    without the need for executable code.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 按需提供代码的约束是可选的，因为并非总是有必要或期望 API 向客户端提供可执行代码。在许多情况下，RESTful API 仅提供数据或资源，这些数据或资源可以被客户端应用程序消费，而不需要可执行代码。
- en: However, in some cases, code on demand can be useful for providing additional
    functionality to clients, such as data processing, filtering, or visualization.
    For example, a RESTful API for data analysis could provide executable code to
    the client for performing complex calculations or generating visualizations based
    on the data.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在某些情况下，按需提供代码对于向客户端提供额外功能是有用的，例如数据处理、过滤或可视化。例如，用于数据分析的 RESTful API 可以向客户端提供可执行代码，以执行复杂计算或基于数据生成可视化。
- en: The REST API can send code such as JavaScript code to the client application
    for execution. This optional feature of code on demand allows API designers to
    further customize the API’s functionality with the ability to increase the flexibility
    of the API to deliver required business solutions.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: REST API 可以发送代码，如 JavaScript 代码，到客户端应用程序执行。这种按需提供代码的可选功能允许 API 设计者通过增加 API 交付所需业务解决方案的灵活性来进一步定制
    API 的功能。
- en: The previously mentioned design principles of REST API ensure developers are
    able to build solutions based on architectural styles that are widely acceptable
    in the software development industry.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 之前提到的 REST API 设计原则确保开发者能够基于在软件开发行业中广泛接受的架构风格构建解决方案。
- en: 'Lastly, Dr. Roy Fielding once summarized the essence of the RESTful API design
    principle and the overall goal in software development as follows:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Roy Fielding 博士曾如下总结 RESTful API 设计原则和软件开发的整体目标：
- en: '“REST is software design on the scale of decades: every detail is intended
    to promote software longevity and independent evolution.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: “REST 是数十年的软件设计：每个细节都是为了促进软件的长期性和独立进化。”
- en: Many of the constraints are directly opposed to short-term efficiency. Unfortunately,
    people are fairly good at short-term design, and usually awful at long-term design.
    Most don’t think they need to design past the current release. There are more
    than a few software methodologies that portray any long-term thinking as wrong-headed,
    ivory tower design (which it can be if it isn’t motivated by real requirements).”
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 许多约束直接与短期效率相矛盾。遗憾的是，人们通常擅长短期设计，而通常在长期设计方面表现糟糕。大多数人认为他们不需要设计超出当前版本。有许多软件开发方法将任何长期思考描绘为错误的方向，或者是不切实际的象牙塔设计（如果它不是由真实需求驱动的，它确实可以是）。”
- en: '[https://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven](https://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven)'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven](https://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven)'
- en: Next, we will delve into the practical implementation of a REST API within a
    Flask web application.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将深入探讨在 Flask Web 应用程序中实现 REST API 的实际操作。
- en: Learning how to implement a REST API in a Flask application is a valuable skill
    for developers who want to build web applications that can be accessed and consumed
    by other applications or services.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 学习如何在 Flask 应用程序中实现 REST API 是希望构建可以被其他应用程序或服务访问和消费的 Web 应用程序的开发者的一项宝贵技能。
- en: Implementing a REST API in a Flask application
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Flask 应用程序中实现 REST API
- en: Flask, as a popular Python web framework, provides developers with a flexible
    and lightweight solution for building web applications. With Flask, you can easily
    create and manage RESTful APIs. The process of implementing a REST API in a Flask
    application is simple.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: Flask 作为流行的 Python 网络框架，为开发者提供了构建 Web 应用程序的灵活和轻量级解决方案。使用 Flask，你可以轻松创建和管理 RESTful
    API。在 Flask 应用程序中实现 REST API 的过程很简单。
- en: Implementing a REST API in a Flask application involves defining API endpoints,
    request handlers, and data models, and possibly connecting to a database. In this
    section, we are going to design a REST API service using Flask that a React frontend
    application can consume.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Flask 应用程序中实现 REST API 涉及定义 API 端点、请求处理程序和数据模型，以及可能连接到数据库。在本节中，我们将使用 Flask
    设计一个 REST API 服务，该服务可以被 React 前端应用程序消费。
- en: We will follow a simple process of defining the resources expected in the *Bizza*
    application, following which we will define the URLs (endpoints) that would be
    used to access the resources. In addition, we will use Flask’s routing system
    to map each endpoint to a specific function in the application.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将遵循一个简单的定义资源的过程，在*Bizza*应用程序中预期的资源，然后定义用于访问资源的URL（端点）。此外，我们将使用Flask的路由系统将每个端点映射到应用程序中的特定函数。
- en: Each function should handle the HTTP request, interact with the database (if
    necessary), and return an appropriate response. Finally, we will implement data
    serialization to serialize and deserialize data between Python objects and JSON.
    This ensures that the API can establish communication with clients using a standardized
    format.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 每个函数应处理HTTP请求，与数据库（如有必要）交互，并返回适当的响应。最后，我们将实现数据序列化，以在Python对象和JSON之间进行序列化和反序列化。这确保了API可以使用标准格式与客户端建立通信。
- en: Next, we will begin the discussion of implementing a REST API with the concept
    of defining the application resources.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将开始讨论使用定义应用程序资源的概念来实现REST API。
- en: Defining the application resources
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义应用程序资源
- en: 'We will start by defining the resources needed to create a conference web application
    that can handle all aspects of an event, from scheduling and registration to sponsorship
    management. The following resources are thus defined:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先定义创建一个能够处理活动所有方面的会议Web应用程序所需的资源，从安排和注册到赞助管理。因此，以下资源被定义：
- en: '`Attendees`: The people who are attending the conference'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Attendees`: 参加会议的人'
- en: '`Speakers`: The people who are giving presentations at the conference'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Speakers`: 在会议上进行演讲的人'
- en: '`Schedules`: The schedules of the conference, including the start and end times
    of each session'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Schedules`: 会议的日程安排，包括每个会议的开始和结束时间'
- en: '`Presentations`: The speakers’ areas of interest and subject matter for the
    conference'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Presentations`: 会议演讲者的兴趣领域和主题'
- en: '`Users`: The users of the event management system, including attendees, speakers,
    and organizers'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Users`: 事件管理系统中的用户，包括与会者、演讲者和组织者'
- en: '`Userextras`: Additional information about the users attending the event, such
    as dietary preferences or accessibility needs'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Userextras`: 关于参加活动的用户的附加信息，例如饮食偏好或无障碍需求'
- en: '`Venues`: The venues where the event or conference is being held, including
    information about the location, capacity, and amenities'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Venues`: 活动或会议的举办地点，包括位置、容量和设施信息'
- en: '`Sessions`: The individual sessions or talks within the conference, including
    information about the speaker, topic, and time'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Sessions`: 会议中的单个会议或演讲，包括演讲者、主题和时间'
- en: '`Sponsors`: The organizations or companies sponsoring the event, including
    information about their level of sponsorship, logo, and contact details'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Sponsors`: 赞助该活动的组织或公司，包括其赞助级别、标志和联系信息'
- en: Next, we will define the API endpoints. In order to implement a functional REST
    API, it is necessary to define the API endpoints clearly.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将定义API端点。为了实现一个功能性的REST API，有必要明确地定义API端点。
- en: Defining the API endpoints
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义API端点
- en: Defining the API endpoints is a crucial step in implementing a REST API. These
    endpoints allow you to perform various operations on the resources of the conference
    web application, such as creating, reading, updating, and deleting records. We
    are defining the endpoints based on the resources specified in the preceding section.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 定义API端点是实现REST API的关键步骤。这些端点允许您对会议Web应用程序的资源执行各种操作，例如创建、读取、更新和删除记录。我们根据前述章节中指定的资源来定义端点。
- en: 'Now, the specific endpoints and HTTP methods used are listed as follows:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，具体端点和使用的HTTP方法如下所示：
- en: '`Users`:'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Users`:'
- en: '`GET` `/users`: Retrieves a list of all users'
  id: totrans-281
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET` `/users`: 获取所有用户的列表'
- en: '`GET` `/users/{id}`: Retrieves information about a specific user'
  id: totrans-282
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET` `/users/{id}`: 获取特定用户的信息'
- en: '`POST` `/users`: Creates a new user'
  id: totrans-283
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST` `/users`: 创建新用户'
- en: '`PUT` `/users/{id}`: Updates information about a specific user'
  id: totrans-284
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PUT` `/users/{id}`: 更新特定用户的信息'
- en: '`DELETE` `/users/{id}`: Deletes a specific user'
  id: totrans-285
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DELETE` `/users/{id}`: 删除特定用户'
- en: '`Userextras`:'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Userextras`: 关于参加活动的用户的附加信息，例如饮食偏好或无障碍需求'
- en: '`GET` `/userextras`: Retrieves a list of all `userextras`'
  id: totrans-287
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET` `/userextras`: 获取所有`userextras`的列表'
- en: '`GET` `/userextras/{id}`: Retrieves information about a specific `userextra`'
  id: totrans-288
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET` `/userextras/{id}`: 获取特定`userextra`的信息'
- en: '`POST` `/userextras`: Creates a new `userextra`'
  id: totrans-289
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST` `/userextras`: 创建新的`userextra`'
- en: '`PUT` `/userextras/{id}`: Updates information about a specific `userextra`'
  id: totrans-290
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PUT` `/userextras/{id}`: 更新特定 `userextra` 的信息'
- en: '`DELETE` `/userextras/{id}`: Deletes a specific `userextra`'
  id: totrans-291
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DELETE` `/userextras/{id}`: 删除特定 `userextra`'
- en: '`Attendees`:'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Attendees`:'
- en: '`GET` `/attendees`: Retrieves a list of all attendees'
  id: totrans-293
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET` `/attendees`: 获取所有参会者的列表'
- en: '`GET` `/attendees/{id}`: Retrieves information about a specific attendee'
  id: totrans-294
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET` `/attendees/{id}`: 获取特定参会者的信息'
- en: '`POST` `/attendees`: Creates a new attendee'
  id: totrans-295
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST` `/attendees`: 创建新的参会者'
- en: '`PUT` `/attendees/{id}`: Updates information about a specific attendee'
  id: totrans-296
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PUT` `/attendees/{id}`: 更新特定参会者的信息'
- en: '`DELETE` `/attendees/{id}`: Deletes a specific attendee'
  id: totrans-297
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DELETE` `/attendees/{id}`: 删除特定参会者'
- en: '`Speakers`:'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Speakers`:'
- en: '`GET` `/speakers`: Retrieves a list of all speakers'
  id: totrans-299
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET` `/speakers`: 获取所有演讲者的列表'
- en: '`GET` `/speakers/{id}`: Retrieves information about a specific speaker'
  id: totrans-300
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET` `/speakers/{id}`: 获取特定演讲者的信息'
- en: '`POST` `/speakers`: Creates a new speaker'
  id: totrans-301
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST` `/speakers`: 创建新的演讲者'
- en: '`PUT` `/speakers/{id}`: Updates information about a specific speaker'
  id: totrans-302
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PUT` `/speakers/{id}`: 更新特定演讲者的信息'
- en: '`DELETE` `/speakers/{id}`: Deletes a specific speaker'
  id: totrans-303
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DELETE` `/speakers/{id}`: 删除特定演讲者'
- en: '`Schedules`:'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Schedules`:'
- en: '`GET` `/schedules`: Retrieves a list of all schedules'
  id: totrans-305
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET` `/schedules`: 获取所有日程的列表'
- en: '`GET` `/schedules/{id}`: Retrieves information about a specific schedule'
  id: totrans-306
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET` `/schedules/{id}`: 获取特定日程的信息'
- en: '`POST` `/schedules`: Creates a new schedule'
  id: totrans-307
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST` `/schedules`: 创建新的日程'
- en: '`PUT` `/schedules/{id}`: Updates information about a specific schedule'
  id: totrans-308
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PUT` `/schedules/{id}`: 更新特定日程的信息'
- en: '`DELETE` `/schedules/{id}`: Deletes a specific schedule'
  id: totrans-309
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DELETE` `/schedules/{id}`: 删除特定日程'
- en: '`Presentations`:'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Presentations`:'
- en: '`GET` `/presentations`: Retrieves a list of all presentations'
  id: totrans-311
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET` `/presentations`: 获取所有演示文稿的列表'
- en: '`GET` `/presentations/{id}`: Retrieves information about a specific presentation'
  id: totrans-312
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET` `/presentations/{id}`: 获取特定演示文稿的信息'
- en: '`POST` `/presentations`: Creates a new presentation'
  id: totrans-313
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST` `/presentations`: 创建新的演示文稿'
- en: '`PUT` `/presentations/{id}`: Updates information about a specific presentation'
  id: totrans-314
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PUT` `/presentations/{id}`: 更新特定演示文稿的信息'
- en: '`DELETE` `/presentations/{id}`: Deletes a specific presentation'
  id: totrans-315
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DELETE` `/presentations/{id}`: 删除特定演示文稿'
- en: '`Venues`:'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Venues`:'
- en: '`GET` `/venues`: Retrieves a list of all venues'
  id: totrans-317
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET` `/venues`: 获取所有场馆的列表'
- en: '`GET` `/venues/{id}`: Retrieves information about a specific venue'
  id: totrans-318
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET` `/venues/{id}`: 获取特定场馆的信息'
- en: '`POST` `/venues`: Creates a new venue'
  id: totrans-319
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST` `/venues`: 创建新的场馆'
- en: '`PUT` `/venues/{id}`: Updates information about a specific venue'
  id: totrans-320
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PUT` `/venues/{id}`: 更新特定场馆的信息'
- en: '`DELETE` `/venues/{id}`: Deletes a specific venue'
  id: totrans-321
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DELETE` `/venues/{id}`: 删除特定场馆'
- en: '`Sessions`:'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Sessions`:'
- en: '`GET` `/sessions`: Retrieves a list of all sessions'
  id: totrans-323
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET` `/sessions`: 获取所有会议的列表'
- en: '`GET` `/sessions/{id}`: Retrieves information about a specific session'
  id: totrans-324
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET` `/sessions/{id}`: 获取特定会议的信息'
- en: '`POST` `/sessions`: Creates a new session'
  id: totrans-325
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST` `/sessions`: 创建新的会议'
- en: '`PUT` `/sessions/{id}`: Updates information about a specific session'
  id: totrans-326
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PUT` `/sessions/{id}`: 更新特定会议的信息'
- en: '`DELETE` `/sessions/{id}`: Deletes a specific session'
  id: totrans-327
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DELETE` `/sessions/{id}`: 删除特定会议'
- en: '`Sponsors`:'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Sponsors`:'
- en: '`GET` `/sponsors`: Retrieves a list of all sponsors'
  id: totrans-329
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET` `/sponsors`: 获取所有赞助商的列表'
- en: '`GET` `/sponsors/{id}`: Retrieves information about a specific sponsor'
  id: totrans-330
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET` `/sponsors/{id}`: 获取特定赞助商的信息'
- en: '`POST` `/sponsors`: Creates a new sponsor'
  id: totrans-331
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST` `/sponsors`: 创建新的赞助商'
- en: '`PUT` `/sponsors/{id}`: Updates information about a specific sponsor'
  id: totrans-332
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PUT` `/sponsors/{id}`: 更新特定赞助商的信息'
- en: '`DELETE` `/sponsors/{id}`: Deletes a specific sponsor'
  id: totrans-333
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DELETE` `/sponsors/{id}`: 删除特定赞助商'
- en: Once the API endpoints have been defined, the next step is to implement them
    in the Flask application.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦定义了API端点，下一步就是在Flask应用程序中实现它们。
- en: Let’s start digging!
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始挖掘吧！
- en: Implementing the API endpoints
  id: totrans-336
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现API端点
- en: Implementing the API endpoints is a critical step in developing a RESTful API.
    This is where all the juicy bits come together to form the heart and soul of your
    REST API. API endpoints define the functionality and behavior of the API, specifying
    the methods that can be used to access the API’s resources.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 实现API端点是开发RESTful API的关键步骤。这是所有精彩的部分汇聚在一起，形成您REST API的核心和灵魂。API端点定义了API的功能和行为，指定了可以用来访问API资源的各种方法。
- en: In a Flask application, implementing the API endpoints involves mapping the
    URLs to the relevant functions, defining the HTTP methods, and writing the Flask
    view functions that will handle the requests and generate responses. In addition,
    it is necessary to specify the request and response formats to be used to communicate
    with the API.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在Flask应用程序中，实现API端点涉及将URL映射到相关函数，定义HTTP方法，并编写将处理请求并生成响应的Flask视图函数。此外，还需要指定用于与API通信的请求和响应格式。
- en: In this section, we will explore the process of implementing API endpoints in
    a Flask application. Let’s start by creating a simple endpoint that returns a
    text-based welcome message from the API server.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨在Flask应用程序中实现API端点的过程。让我们从创建一个简单的端点开始，该端点从API服务器返回基于文本的欢迎消息。
- en: 'In the backend development environment, inside `bizza/backend/`, activate the
    virtual environment in the terminal:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在后端开发环境中，在`bizza/backend/`内部，在终端中激活虚拟环境：
- en: '**Use the following** **on Windows**:'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在Windows上使用以下内容**：'
- en: '[PRE15]'
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '**Use the following** **on Mac/Linux**:'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在Mac/Linux上使用以下内容**：'
- en: '[PRE16]'
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If you are having issues activating your virtual environment, check *Setting
    up the development environment with Flask* in [*Chapter 1*](B18554_01.xhtml#_idTextAnchor014).
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在激活虚拟环境时遇到问题，请检查[*第1章*](B18554_01.xhtml#_idTextAnchor014)中的*使用Flask设置开发环境*。
- en: 'Now, update `app.py` with the following code:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用以下代码更新`app.py`：
- en: '[PRE17]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This is what is happening in the preceding code snippet:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是前面代码片段中发生的事情：
- en: We import the `Flask` class from the `flask` package.
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们从`flask`包中导入`Flask`类。
- en: We then create an instance of the `Flask` class and name it `app`. Then, we
    pass in a `__name__` variable as an argument that references the current module
    name. This is needed for the internal working of Flask for path discovery.
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们创建`Flask`类的实例，并将其命名为`app`。然后，我们将一个`__name__`变量作为参数传递，该变量引用当前模块名称。这是Flask内部工作所需的，用于路径发现。
- en: Use a `@route()` Flask decorator to tell Flask to implement the `index()` view
    function when a user accesses the URL `"/"` (index URL). A decorator in Python
    is simply a way of adding extra functionality to functions without explicitly
    altering the method behavior.
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`@route()` Flask装饰器告诉Flask，当用户访问URL`"/"`（索引URL）时，实现`index()`视图函数。Python中的装饰器简单地说是一种向函数添加额外功能的方法，而无需显式更改方法行为。
- en: This view function returns the message `Welcome to Bizza REST API server` to
    the browser. So, essentially, the decorator is capable of modifying the `index()`
    view function to return a value in the form of an HTTP response, which can then
    be displayed by the client using the desired data presentation format. In this
    case, `text/html` was returned.
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个视图函数向浏览器返回消息`欢迎使用Bizza REST API服务器`。因此，本质上，装饰器能够修改`index()`视图函数，以返回HTTP响应形式的价值，然后客户端可以使用所需的数据表示格式显示它。在这种情况下，返回了`text/html`。
- en: If the conditional part of the code becomes true, that is, `app.py` is the main
    program, then it runs the module. In this way, Python prevents the accidental
    or unintentional running of an imported module.
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果代码的条件部分变为真，即`app.py`是主程序，那么它将运行该模块。这样，Python可以防止意外或无意中运行导入的模块。
- en: 'We can test the endpoint with `curl` by entering the following command:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过输入以下命令使用`curl`测试端点：
- en: '[PRE18]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We get the following output:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到以下输出：
- en: "![Figure 9.1 – Screenshot showing \uFEFFthe HTTP response from localhost](img/Figure_9.1_B18554.jpg)"
  id: totrans-357
  prefs: []
  type: TYPE_IMG
  zh: '![图9.1 – 展示来自localhost的HTTP响应](img/Figure_9.1_B18554.jpg)'
- en: Figure 9.1 – Screenshot showing the HTTP response from localhost
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1 – 展示来自localhost的HTTP响应的屏幕截图
- en: JSONifying response data
  id: totrans-359
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JSON化响应数据
- en: Jsonifying response data refers to the process of converting a Python data structure
    into a JSON string that can be returned as a response from an API endpoint. JSON
    is a lightweight data-interchange format that is easy to read and write, making
    it a popular choice for web APIs.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: JSON化响应数据是指将Python数据结构转换为JSON字符串的过程，该字符串可以作为API端点的响应返回。JSON是一种轻量级的数据交换格式，易于阅读和编写，因此它是Web
    API的流行选择。
- en: By jsonifying response data, the data can be easily transmitted over HTTP and
    used by other systems and programming languages. This is because JSON is a language-independent
    data format that can be parsed and generated by many programming languages.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将响应数据JSON化，数据可以轻松地通过HTTP传输并被其他系统和编程语言使用。这是因为JSON是一种语言无关的数据格式，许多编程语言都可以解析和生成它。
- en: JSON also supports complex data structures such as arrays and objects, making
    it a flexible format for transferring data between systems. In a Flask application,
    the *jsonify* function can be used to convert Python data structures into JSON
    format.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: JSON 还支持复杂的数据结构，如数组和对象，使其成为系统间传输数据的灵活格式。在 Flask 应用程序中，可以使用 `jsonify` 函数将 Python
    数据结构转换为 JSON 格式。
- en: This function takes the data as an argument and returns a Flask response object
    with the JSON data and the appropriate `Content-Type` header, indicating that
    the data is in JSON format. By returning JSON-formatted responses from API endpoints,
    clients can easily consume and use the data in their applications.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数接受数据作为参数，并返回一个包含 JSON 数据和适当的 `Content-Type` 标头的 Flask 响应对象，指示数据为 JSON 格式。通过从
    API 端点返回 JSON 格式的响应，客户端可以轻松地消费和使用数据。
- en: 'You can see that `content-type` in the preceding code is `text/html`; now,
    let’s return a serialized JSON format since moving forward, that will be the preferred
    data exchange format:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，前面的代码中的 `content-type` 是 `text/html`；现在，让我们返回一个序列化的 JSON 格式，因为从现在开始，那将是首选的数据交换格式：
- en: '[PRE19]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the preceding code, we added another endpoint and decorated it with `@route("/api/v1/venues")`.
    So, we are telling Flask to implement the functionality of the view function attached
    to the decorator.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们添加了另一个端点，并用 `@route("/api/v1/venues")` 装饰它。因此，我们告诉 Flask 实现装饰器附加的视图函数的功能。
- en: In order to retrieve the JSON format response, we invoke `jsonify()` in the
    `Flask` package using `from flask import Flask, jsonify` and pass Python dictionary
    data into it, which then gets converted into a serializable JSON format.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检索 JSON 格式的响应，我们使用 `from flask import Flask, jsonify` 在 `Flask` 包中调用 `jsonify()`，并将
    Python 字典数据传递给它，然后它被转换成可序列化的 JSON 格式。
- en: 'We can test the endpoint with `curl` by entering the following command:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `curl` 测试端点，通过输入以下命令：
- en: '[PRE20]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We get the following output:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到以下输出：
- en: "![Figure 9.2 – Screenshot showing \uFEFFthe venues endpoint\uFEFF being tested](img/Figure_9.2_B18554.jpg)"
  id: totrans-371
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.2 – 展示正在测试的端点](img/Figure_9.2_B18554.jpg)'
- en: Figure 9.2 – Screenshot showing the venues endpoint being tested
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.2 – 展示正在测试的端点
- en: Next, we will begin to enhance the endpoint functionality by incorporating query
    parameters.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将通过结合查询参数来增强端点功能。
- en: Adding query parameters to endpoints
  id: totrans-374
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向端点添加查询参数
- en: Query parameters are additional information we can pass along with the request
    to the server to allow some processing of the request. With query parameters,
    we are able to present dynamic content to application users.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 查询参数是我们可以与请求一起传递到服务器以允许某些请求处理的附加信息。有了查询参数，我们能够向应用程序用户展示动态内容。
- en: 'For instance, this is an ordinary URL endpoint without a query parameter:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这是一个没有查询参数的普通 URL 端点：
- en: '[PRE21]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, you can add a query parameter to the URL by adding a `?` at the end of
    the URL followed by a key-value pair. Let’s add a query parameter to the preceding
    URL:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以在 URL 的末尾添加一个 `?` 符号，后面跟着一个键值对，来向 URL 添加一个查询参数。让我们向前面的 URL 添加一个查询参数：
- en: '[PRE22]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Let’s implement a simple query parameter in a Flask application for a better
    illustration.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 Flask 应用程序中实现一个简单的查询参数，以更好地说明。
- en: 'Add the following snippet to the `app.py` file:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下片段添加到 `app.py` 文件中：
- en: '[PRE23]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Note the following in the preceding code:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 注意以下代码中的以下几点：
- en: We are creating a new endpoint with the URL `/``api/v1/speakers/` resource.
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们正在创建一个新的端点，其 URL 为 `/api/v1/speakers/` 资源。
- en: We are using a `request` object from the Flask package.
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用 Flask 包中的 `request` 对象。
- en: We are then defining a view function, `speakers()`, to handle requests to the
    endpoint.
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们定义了一个视图函数 `speakers()` 来处理对端点的请求。
- en: The `request` object is used to allow a client to send data to the server and
    other endpoint request operations. We have `request.args` for handling URL data,
    `request.form` for extracting form data, and `request.json` for handling JSON
    data. Here, we will use `request.args` to extract key-value pairs in the URL to
    process URL data at the server end.
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`request` 对象用于允许客户端向服务器发送数据以及执行其他端点请求操作。我们使用 `request.args` 来处理 URL 数据，`request.form`
    来提取表单数据，以及 `request.json` 来处理 JSON 数据。在这里，我们将使用 `request.args` 来提取 URL 中的键值对，以便在服务器端处理
    URL 数据。'
- en: The `firstname` and `lastname` variables store the data values extracted from
    the URL.
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`firstname` 和 `lastname` 变量存储从 URL 中提取的数据值。'
- en: Then, we perform a simple check to find out whether query parameters are present
    in the URL. In the production code, you are expected to perform a comprehensive
    check on what the users are sending to the server. This is for demonstration purposes.
    We return JSONified data if query parameters are present. Otherwise, the message
    `"No query parameters in the url"` is sent as output.
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们执行一个简单的检查，以确定 URL 中是否存在查询参数。在生产代码中，你预计将对用户发送到服务器的数据进行全面检查。这只是为了演示目的。如果存在查询参数，我们返回
    JSON 化的数据。否则，输出消息为 `"No query parameters in the url"`。
- en: 'Testing the endpoint with query parameters, for instance, `http://localhost:5000/api/v1/speakers?firstname=Jim&lastname=Hunt`,
    provides the following output:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 测试带有查询参数的端点，例如，`http://localhost:5000/api/v1/speakers?firstname=Jim&lastname=Hunt`，会得到以下输出：
- en: "![Figure 9.3 – Screenshot testing with \uFEFFa query parameter](img/Figure_9.3_B18554.jpg)"
  id: totrans-391
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.3 – 带查询参数的测试截图](img/Figure_9.3_B18554.jpg)'
- en: Figure 9.3 – Screenshot testing with a query parameter
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.3 – 带查询参数的测试截图
- en: 'Testing the `http://localhost:5000/api/v1/speakers?` endpoint without query
    parameters provides the following output:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 在不提供查询参数的情况下测试 `http://localhost:5000/api/v1/speakers?` 端点，会得到以下输出：
- en: "![Figure 9.4 – Screenshot testing without \uFEFFa query parameter](img/Figure_9.4_B18554.jpg)"
  id: totrans-394
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.4 – 不带查询参数的测试截图](img/Figure_9.4_B18554.jpg)'
- en: Figure 9.4 – Screenshot testing without a query parameter
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.4 – 不带查询参数的测试截图
- en: Now, let’s check how you can pass variables to an endpoint. This is also useful
    in dynamically modifying the server-side processing in your application.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们检查如何将变量传递到端点。这也有助于在应用程序中动态修改服务器端处理。
- en: Passing variables to an endpoint
  id: totrans-397
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将变量传递到端点
- en: One of the ways to provide input to an endpoint is by passing variables to the
    URL path in the API endpoint, allowing for the provision of specific information.
    This technique is commonly used when the input is required to identify a specific
    resource or object, such as an ID number or username.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 向端点提供输入的一种方法是通过在 API 端点的 URL 路径中传递变量，从而提供特定信息。当需要输入来识别特定资源或对象时，例如 ID 号或用户名，这种技术通常被使用。
- en: 'In a Flask application, variables can be included in the URL path by enclosing
    them in angled brackets (`<>`) in the endpoint URL definition. For example, to
    define an endpoint that takes a speaker ID as input, the URL could be defined
    as follows:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Flask 应用程序中，可以通过在端点 URL 定义中将变量括在尖括号 (`<>`) 中来将变量包含在 URL 路径中。例如，为了定义一个接受演讲者
    ID 作为输入的端点，URL 可以定义如下：
- en: '[PRE24]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the preceding example, the `get_speaker` function takes a `speaker_id` argument,
    which corresponds to the variable included in the URL path. When a request is
    made to the `/speakers/123` endpoint, the `get_speaker` function is called with
    `speaker_id=123`.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，`get_speaker` 函数接受一个 `speaker_id` 参数，它对应于 URL 路径中包含的变量。当请求 `/speakers/123`
    端点时，`get_speaker` 函数会以 `speaker_id=123` 被调用。
- en: Passing variables to an endpoint is a useful technique for providing input to
    an API endpoint and is commonly used in RESTful API design.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 将变量传递到端点是一种向 API 端点提供输入的有用技术，并且在 RESTful API 设计中常用。
- en: Next, we will take our REST API in Flask application a step further. We will
    perform CRUD operations on a database using PostgreSQL.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将进一步扩展我们的 Flask 应用程序中的 REST API。我们将使用 PostgreSQL 数据库执行 CRUD 操作。
- en: API interaction with a database via CRUD operations
  id: totrans-404
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过 CRUD 操作与数据库进行 API 交互
- en: In most web application projects, it is common to work with databases for the
    purpose of persistent data storage. You won’t be hardcoding plain text into your
    REST API, unless you are that person who tries to boil the ocean.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数 Web 应用程序项目中，为了持久化数据存储，通常需要与数据库一起工作。你不会将纯文本硬编码到你的 REST API 中，除非你是那个试图煮海的人。
- en: '`GET`, `POST`, `PUT/PATCH`, and `DELETE` – which further describes and facilitates
    the interaction with the database.'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: '`GET`、`POST`、`PUT/PATCH` 和 `DELETE` – 这些进一步描述并简化了与数据库的交互。'
- en: In a full stack web application, you expect your users to able to create a resource
    (`POST` or `PUT` if it is an existing resource), read a resource (`GET`), update
    a resource (`PUT`/`PATCH`), and delete a resource (`DELETE`). In this section,
    we will work with a simple `venue` resource with the following endpoints, and
    the HTTP operations we will perform on them are CRUD.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个全栈 Web 应用程序中，你期望你的用户能够创建一个资源（如果是现有资源，则为 `POST` 或 `PUT`），读取一个资源（`GET`），更新一个资源（`PUT`/`PATCH`），以及删除一个资源（`DELETE`）。在本节中，我们将使用一个简单的
    `venue` 资源，以下是其端点，以及我们将对其执行的 HTTP 操作是 CRUD。
- en: All the code for the endpoint’s implementation will be hosted in the GitHub
    repository of this book.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 端点实现的所有代码都将托管在这本书的 GitHub 仓库中。
- en: 'Let’s jump-start the CRUD operation by describing the endpoints we are using:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过描述我们使用的端点来启动 CRUD 操作：
- en: '`POST` `/api/v1/venues/`: Creates a `venue` resource'
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST` `/api/v1/venues/`：创建一个 `venue` 资源'
- en: '`GET` `/api/v1/venues`: Returns a list of all the venues'
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET` `/api/v1/venues`：返回所有场馆的列表'
- en: '`GET` `/api/v1/venues/id`: Retrieves a single venue identified with `id`'
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET` `/api/v1/venues/id`：检索由 `id` 标识的单个场馆'
- en: '`PUT` `/api/v1/venues/id`: Updates a single venue identified with `id`'
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PUT` `/api/v1/venues/id`：更新由 `id` 标识的单个场馆'
- en: '`DELETE` `/api/v1/venues/id`: Deletes a single venue identified with `id`'
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DELETE` `/api/v1/venues/id`：删除由 `id` 标识的单个场馆'
- en: The preceding endpoints are clear with regard to their intentions. But before
    we start fleshing out the endpoints, let’s discuss the necessary dependencies
    and be sure we can connect with the database.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的端点在意图上很清晰。但在我们开始具体化端点之前，让我们讨论必要的依赖项并确保我们可以连接到数据库。
- en: 'Activate the virtual environment: always remember you are working in a virtual
    environment to contain your project dependencies. Then, inside `bizza/backend`,
    update the `app.py` file with the following code:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 激活虚拟环境：始终记住你在一个虚拟环境中工作以包含你的项目依赖项。然后，在 `bizza/backend` 内部，使用以下代码更新 `app.py` 文件：
- en: '[PRE25]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the preceding code snippet, we imported the `Flask` and `SQLAlchemy` modules.
    Then, the `app = Flask(__name__)` line created an instance of the Flask application.
    The `__name__` argument represents the name of the current module.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们导入了 `Flask` 和 `SQLAlchemy` 模块。然后，`app = Flask(__name__)` 行创建了一个
    Flask 应用程序实例。`__name__` 参数代表当前模块的名称。
- en: The `Flask` API comes with some configuration settings that we can modify. The
    `config` object is in the form of a Python dictionary. We are able to set the
    database URI with `app.config['SQLALCHEMY_DATABASE_URI']` and disable the SQLAlchemy
    operation notification setting with `app.config['SQLALCHEMY_TRACK_MODIFICATIONS']
    =` `False`.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: '`Flask` API 随带一些我们可以修改的配置设置。`config` 对象是以 Python 字典的形式存在的。我们可以使用 `app.config[''SQLALCHEMY_DATABASE_URI'']`
    来设置数据库 URI，并使用 `app.config[''SQLALCHEMY_TRACK_MODIFICATIONS''] = False` 来禁用 SQLAlchemy
    操作通知设置。'
- en: Note
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In `app.config['SQLALCHEMY_DATABASE_URI'] = 'postgresql://<username>:<password>@localhost:5432/<database_name>'`,
    change `<username>` and `<password>` to your appropriate database credentials.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `app.config['SQLALCHEMY_DATABASE_URI'] = 'postgresql://<username>:<password>@localhost:5432/<database_name>'`
    中，将 `<username>` 和 `<password>` 更改为您适当的数据库凭据。
- en: With `db = SQLAlchemy(app)`, we created the `SQLAlchemy` instance, which accepts
    the `Flask` instance as an argument.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `db = SQLAlchemy(app)`，我们创建了 `SQLAlchemy` 实例，它接受 `Flask` 实例作为参数。
- en: With this set, let’s define the model class and create the venue table in the
    database.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 设置完成后，让我们定义模型类并在数据库中创建 venue 表。
- en: 'Create the `Venue` class model, as follows:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 `Venue` 类模型，如下所示：
- en: '[PRE26]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Open the command terminal and enter the following:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 打开命令终端并输入以下内容：
- en: '[PRE27]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Then, enter the following:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，输入以下内容：
- en: '[PRE28]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The preceding command brings `db`, an `SQLAlchmy` instance, and the `Venue`
    class model into scope.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令将 `db`，一个 `SQLAlchmy` 实例，以及 `Venue` 类模型引入作用域。
- en: 'Now, enter the following:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，输入以下内容：
- en: '[PRE29]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The preceding command creates the `venues` table from the `Venue` class model.
    Alternatively, you can run a migration command as done previously to create the
    table.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令从 `Venue` 类模型创建了 `venues` 表。或者，你可以像之前那样运行迁移命令来创建表。
- en: 'Finally, verify the table creation with the following:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用以下内容验证表创建：
- en: '[PRE30]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The following screenshot shows the terminal commands to show the creation of
    the `venues` table.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了终端命令以显示 `venues` 表的创建。
- en: '![Figure 9.5 – Screenshot showing commands in flask shell](img/Figure_9.5_B18554.jpg)'
  id: totrans-437
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.5 – 显示 Flask shell 中命令的屏幕截图](img/Figure_9.5_B18554.jpg)'
- en: Figure 9.5 – Screenshot showing commands in flask shell
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.5 – 显示 Flask shell 中命令的屏幕截图
- en: Now that we have the database and v`enues` table up and running, let’s start
    to define the endpoints.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了数据库和 venues 表，让我们开始定义端点。
- en: Creating a venue resource
  id: totrans-440
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建场馆资源
- en: Let’s define the `/venues` endpoint in `app.py` and use it to post entries to
    the database.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 `app.py` 中定义 `/venues` 端点并使用它向数据库中发布条目。
- en: 'The endpoint for creating a new venue is as follows:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 创建新场馆的端点如下：
- en: '[PRE31]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In the preceding code, we have the following:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们有以下内容：
- en: The `jsonify` and `request` methods are imported from Flask.
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jsonify` 和 `request` 方法是从 Flask 导入的。'
- en: The `@app.route()` decorator has the URL to the `'/api/v1/venues'` endpoint
    with the HTTP `POST` method.
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@app.route()` 装饰器具有指向 `''/api/v1/venues''` 端点的 URL，并使用 HTTP `POST` 方法。'
- en: The `add_venue()` function is invoked once there is a `POST` request.
  id: totrans-447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当有 `POST` 请求时，会调用 `add_venue()` 函数。
- en: We test to make sure `request.method == '``POST'`.
  id: totrans-448
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们测试以确保 `request.method == 'POST'`。
- en: We test to ensure the new venue name is not already in the database. If the
    added name is already in the database, the message `"Venue name already exist"`
    is sent back as a `json` message with status code `409-` `content conflict`.
  id: totrans-449
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们进行测试以确保新的场馆名称尚未存在于数据库中。如果添加的名称已在数据库中，则返回包含状态码 `409-` `content conflict` 的
    `"Venue name already exist"` 消息作为 `json` 消息。
- en: If the preceding step fails, we proceed to add to the database session with
    `db.session.add(new_venue)`. At this point, the entry is not fully added to the
    database but added to the database session. We need one more step to commit it
    to the database, which is `db.session.commit()`.
  id: totrans-450
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果前面的步骤失败，我们使用 `db.session.add(new_venue)` 将其添加到数据库会话中。此时，条目尚未完全添加到数据库，而是添加到数据库会话中。我们需要再进行一步提交到数据库，即
    `db.session.commit()`。
- en: '`Jsonify()` is an in-built Flask function that returns a JSON-serialized response
    object.'
  id: totrans-451
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Jsonify()` 是 Flask 内置的函数，它返回一个 JSON 序列化的响应对象。'
- en: Returning lists of venues
  id: totrans-452
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 返回场馆列表
- en: 'The following is the endpoint to retrieve all the venues in the database:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是从数据库中检索所有场馆的端点：
- en: '[PRE32]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In the preceding code, we have the following:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们有以下内容：
- en: The `GET` request method is invoked
  id: totrans-456
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用 `GET` 请求方法
- en: '`Venue.query.all()` is a query from `SQLAlchemy` to retrieve all the venues'
  id: totrans-457
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Venue.query.all()` 是从 `SQLAlchemy` 查询以检索所有场馆'
- en: The `jsonify` response object output results in a `200` status code, and if
    it fails, a `"No venue record found"` message is displayed with status code `404`
  id: totrans-458
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jsonify` 响应对象输出结果为 `200` 状态码，如果失败，则显示 `"No venue record found"` 消息，状态码为 `404`'
- en: Returning a single venue resource
  id: totrans-459
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 返回单个场馆资源
- en: 'The following is an endpoint to return a single venue:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个用于返回单个场馆的端点：
- en: '[PRE33]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In the preceding code, we are doing the following:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们执行以下操作：
- en: The `GET` request method is invoked
  id: totrans-463
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用 `GET` 请求方法
- en: '`Venue.query.filter(Venue.id == id).first()` retrieves the first record with
    the ID supplied as an argument to `retrieve_venue()`'
  id: totrans-464
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Venue.query.filter(Venue.id == id).first()` 使用 `retrieve_venue()` 函数提供的参数检索具有指定
    ID 的第一条记录'
- en: If the ID is present, the `jsonify` response object output results in a `200`
    status code, and if it fails, the `"Record id not found"` message is displayed
    with status code `404`
  id: totrans-465
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 ID 存在，`jsonify` 响应对象输出结果为 `200` 状态码，如果失败，则显示 `"Record id not found"` 消息，状态码为
    `404`
- en: Updating a single venue resource
  id: totrans-466
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新单个场馆资源
- en: 'The following is an endpoint to modify venue information:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个用于修改场馆信息的端点：
- en: '[PRE34]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In the preceding code, we are doing the following:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们执行以下操作：
- en: The `PUT` request method is invoked to update a single resource
  id: totrans-470
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `PUT` 请求方法调用以更新单个资源
- en: We try to check for the existence of the record `id`
  id: totrans-471
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们尝试检查记录 `id` 的存在性
- en: If the record is present, we update it with `venue.name = name`, then commit
    the session
  id: totrans-472
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果记录存在，我们使用 `venue.name = name` 更新它，然后提交会话
- en: If the ID information is updated, the `jsonify` response object output results
    in a `200` status code, and if it fails, the `"Venue record not found"` message
    is displayed with status code `404`
  id: totrans-473
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 ID 信息已更新，`jsonify` 响应对象输出结果为 `200` 状态码，如果失败，则显示 `"Venue record not found"`
    消息，状态码为 `404`
- en: Deleting a single venue resource
  id: totrans-474
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 删除单个场馆资源
- en: 'The following is an endpoint to delete a venue:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个用于删除场馆的端点：
- en: '[PRE35]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In the preceding code, we are doing the following:'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们执行以下操作：
- en: The `DELETE` request method is invoked to delete a single resource
  id: totrans-478
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `DELETE` 请求方法调用以删除单个资源
- en: We try to check for the existence of the record `id`
  id: totrans-479
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们尝试检查记录 `id` 的存在性
- en: If the record is present, we delete it, then commit the session
  id: totrans-480
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果记录存在，我们删除它，然后提交会话
- en: If the ID information is deleted, the `jsonify` response object output results
    in a `202` status code, and if it fails, a `"That venue does not exist"` message
    is displayed with status code `404`
  id: totrans-481
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果删除了 ID 信息，`jsonify` 响应对象输出结果为 `202` 状态码，如果失败，则显示 `"That venue does not exist"`
    消息，状态码为 `404`
- en: The following GitHub link contains the complete code for the `venue` CRUD operation
    in `app.py` -[https://github.com/PacktPublishing/Full-Stack-Flask-and-React/blob/main/Chapter09/05/bizza/backend/app.py](https://github.com/PacktPublishing/Full-Stack-Flask-and-React/blob/main/Chapter09/05/bizza/backend/app.py).
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 以下GitHub链接包含了`app.py`中`venue` CRUD操作的完整代码 - [https://github.com/PacktPublishing/Full-Stack-Flask-and-React/blob/main/Chapter09/05/bizza/backend/app.py](https://github.com/PacktPublishing/Full-Stack-Flask-and-React/blob/main/Chapter09/05/bizza/backend/app.py)。
- en: Next, we will examine the concept of API documentation and deep-dive into its
    importance and how to make use of the Postman tool to document your API endpoint.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨API文档的概念，并深入探讨其重要性以及如何使用Postman工具来记录您的API端点。
- en: API documentation
  id: totrans-484
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API文档
- en: Have you ever tried to assemble a piece of equipment you bought from a store
    without looking through the manual? There is a high probability you will have
    done so deliberately. You smartly think it will be easy to put together, and most
    times, you get burned in this process of trial and error and eventually mess things
    up.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 您是否曾经尝试过在没有查看说明书的情况下组装从商店购买的设备？有很大可能性您是故意这样做的。您聪明地认为这会很容易组装，而大多数时候，您在这个过程中会经历试错，最终弄糟事情。
- en: Manuals are a good resource meant to ease you through a product’s features and
    functionality. API documentation is no different from manuals for guidance, a
    set of instructions, references, or even tutorial materials that can enhance developers’
    understanding of your API.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 说明书是一种很好的资源，旨在帮助您了解产品的功能和特性。API文档与说明书在指导方面并无不同，它是一套指令、参考资料，甚至是教程材料，可以增强开发者对您的API的理解。
- en: Why is API documentation a critical component of your API? We will examine a
    few reasons and dive into using the Postman client tool to document your API so
    that other developers can understand what it is all about and how to use it. We
    will use a very simplistic case study with the `venues` CRUD operation we examined
    in the preceding section.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么API文档是您API的一个关键组成部分？我们将探讨几个原因，并深入探讨如何使用Postman客户端工具来记录您的API，以便其他开发者可以理解其全部内容以及如何使用它。我们将使用前一个部分中我们考察的`venues`
    CRUD操作作为一个非常简单的案例研究。
- en: In a production-ready API product, you are expected to provide more detailed
    information about your API in your documentation. You are to write up a technical
    instructional guide that will make consuming your API services a walk in the park.
    You would also want to include tutorials, clear references, and sample code that
    can help developers with easy integration.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个生产就绪的API产品中，您预计在文档中提供更多关于您的API的详细信息。您需要编写一份技术指导手册，使使用您的API服务变得轻而易举。您还希望包括教程、清晰的参考和示例代码，以帮助开发者轻松集成。
- en: 'Let’s examine the reasons why you would want to come up with clear documentation
    for your API:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考察一下您为什么想要为您的API制定清晰的文档：
- en: '**Enhanced developer experience**: API documentation opens up a way to provide
    quick-start guides, references, and case studies for developers who want to be
    productive and consume third-party data to improve their software product offerings.
    Therefore, well-thought-out API documentation helps developers to understand the
    best approach to implementing your API data points to solve their problems.'
  id: totrans-490
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**增强开发者体验**：API文档为提供快速入门指南、参考资料和案例研究开辟了途径，这些指南和资料可以帮助开发者提高生产力，并使用第三方数据来改善他们的软件产品。因此，精心设计的API文档有助于开发者了解实现您的API数据点的最佳方法，以解决他们的问题。'
- en: High-quality and useful API documentation means developers are going to easily
    understand how to implement your API and thus will increase their overall emotional
    attachment to your API product. Stripe, PayPal, Spotify, Twilio, and Paystack
    are good examples of popular commercial APIs with awesome documentation.
  id: totrans-491
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 高质量和有用的API文档意味着开发者将很容易理解如何实现您的API，从而增加他们对您的API产品的整体情感依恋。Stripe、PayPal、Spotify、Twilio和Paystack是具有出色文档的流行商业API的例子。
- en: '**Decreased onboarding time**: Comprehensive documentation allows even an entry-level
    developer to quickly know how to implement your API endpoints and methods and
    handle requests and responses seamlessly without assistance from other developers.
    This will save time and costs for the business and improve the API adoption rate.'
  id: totrans-492
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缩短入职时间**：全面的文档允许即使是初级开发者也能快速了解如何实现您的API端点和方法，以及如何无缝处理请求和响应，而无需其他开发者的协助。这将节省业务的时间和成本，并提高API的采用率。'
- en: '**Adherence to API objectives**: Documentation allows API designers and consumers
    to have a common ground on API specs and the problem it aims to solve without
    ambiguity.'
  id: totrans-493
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**遵守API目标**：文档允许API设计者和消费者在API规范及其旨在解决的问题上有一个共同的基础，避免歧义。'
- en: Next, we will use Postman to test and document a RESTful API.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用Postman来测试和记录RESTful API。
- en: Testing and documenting with Postman
  id: totrans-495
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Postman进行测试和记录
- en: Postman is an advanced API platform that provides a range of features to simplify
    the development, testing, and utilization of APIs. Postman offers a user-friendly
    interface for testing API endpoints, generating API documentation, and collaborating
    on API-related operations.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: Postman是一个高级API平台，提供了一系列功能来简化API的开发、测试和利用。Postman提供了一个用户友好的界面来测试API端点、生成API文档以及协作进行API相关操作。
- en: To begin using Postman, you can download and install the application on your
    local machine. Visit the official Postman website at [https://www.postman.com/downloads](https://www.postman.com/downloads)
    to access the download page. From there, you can choose the appropriate version
    for your operating system and follow the installation instructions.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用Postman，您可以在本地计算机上下载并安装应用程序。访问Postman官方网站[https://www.postman.com/downloads](https://www.postman.com/downloads)以访问下载页面。从那里，您可以选择适合您操作系统的适当版本并遵循安装说明。
- en: Once you have Postman installed, you can leverage the power of Postman to document
    RESTful API endpoints, execute requests, analyze responses, and perform comprehensive
    testing.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 在您安装了Postman之后，您可以利用Postman的力量来记录RESTful API端点、执行请求、分析响应以及进行全面的测试。
- en: 'Let’s leverage `venues` on the collections and generate API documentation that
    tells other developers how to make requests and describe the response to expect:'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们利用集合中的`venues`生成API文档，告诉其他开发者如何进行请求以及预期的响应描述：
- en: On your computer, start Postman and create a collection. Click on the **Collections**
    tab on the left sidebar of the Postman interface; if it’s not visible, you can
    click on the three horizontal lines in the top-left corner to expand the sidebar.
    In the dialog box, enter a name for your collection.
  id: totrans-500
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的计算机上启动Postman并创建一个集合。点击Postman界面上左侧侧边栏的**集合**标签；如果不可见，您可以在界面左上角点击三个水平线以展开侧边栏。在对话框中，输入您的集合名称。
- en: '![Figure 9.6 – Screenshot showing the creation of a collection in Postman](img/Figure_9.6_B18554.jpg)'
  id: totrans-501
  prefs: []
  type: TYPE_IMG
  zh: '![图9.6 – 展示在Postman中创建集合的屏幕截图](img/Figure_9.6_B18554.jpg)'
- en: Figure 9.6 – Screenshot showing the creation of a collection in Postman
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.6 – 展示在Postman中创建集合的屏幕截图
- en: 'After creating a collection, create a new request. Within the collection, click
    on the **New** button located in the top-left corner of the interface. A drop-down
    menu will appear:'
  id: totrans-503
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建集合后，创建一个新的请求。在集合内，点击界面左上角的**新建**按钮。将出现一个下拉菜单：
- en: '![Figure 9.7 – Screenshot showing how to add an HTTP request](img/Figure_9.7_B18554.jpg)'
  id: totrans-504
  prefs: []
  type: TYPE_IMG
  zh: '![图9.7 – 展示如何添加HTTP请求的屏幕截图](img/Figure_9.7_B18554.jpg)'
- en: Figure 9.7 – Screenshot showing how to add an HTTP request
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.7 – 展示如何添加HTTP请求的屏幕截图
- en: Select the request type from the drop-down menu. To post data to the server,
    select `localhost:5000/api/v1/venues`.
  id: totrans-506
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从下拉菜单中选择请求类型。要将数据发布到服务器，选择`localhost:5000/api/v1/venues`。
- en: 'Select the **Body** tab, then **raw**, and finally select the **JSON** tab
    from the dropdown. This will allow you to send the data to the server in JSON
    format. In this case, we send the following data to the backend server:'
  id: totrans-507
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**主体**标签，然后选择**原始**，最后从下拉菜单中选择**JSON**标签。这将允许您以JSON格式将数据发送到服务器。在这种情况下，我们将以下数据发送到后端服务器：
- en: '[PRE36]'
  id: totrans-508
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The following screenshot shows how you can use Postman to test endpoints.
  id: totrans-509
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了如何使用Postman测试端点。
- en: '![Figure 9.8 – Screenshot showing sending data to the backend](img/Figure_9.8_B18554.jpg)'
  id: totrans-510
  prefs: []
  type: TYPE_IMG
  zh: '![图9.8 – 展示向后端发送数据的屏幕截图](img/Figure_9.8_B18554.jpg)'
- en: Figure 9.8 – Screenshot showing sending data to the backend
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.8 – 展示向后端发送数据的屏幕截图
- en: Send the request once you have configured the request. Click on the `POST` request
    will fail.
  id: totrans-512
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在配置请求后发送请求。点击`POST`请求将失败。
- en: After sending the request, Postman will display the response received from the
    server. You can see the response content, status code, headers, and other relevant
    information in the response panel. The following screenshot shows the response
    data.
  id: totrans-513
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 发送请求后，Postman将显示从服务器收到的响应。您可以在响应面板中看到响应内容、状态码、头部和其他相关信息。以下屏幕截图显示了响应数据。
- en: '![Figure 9.9 – Screenshot showing server response to a POST request](img/Figure_9.9_B18554.jpg)'
  id: totrans-514
  prefs: []
  type: TYPE_IMG
  zh: '![图9.9 – 展示服务器对POST请求的响应的屏幕截图](img/Figure_9.9_B18554.jpg)'
- en: Figure 9.9 – Screenshot showing server response to a POST request
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.9 – 展示服务器对POST请求的响应的屏幕截图
- en: Repeat the preceding steps for each request in your collection, choosing appropriate
    request types and providing descriptions, parameter details, the request payload,
    and the response format as needed.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 对您集合中的每个请求重复前面的步骤，选择适当的请求类型，并提供描述、参数细节、请求负载和响应格式（如有需要）。
- en: Once you have tested all the endpoints, right-click on the collection name and
    click on **View Documentation**.
  id: totrans-517
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦您测试了所有端点，右键单击集合名称，然后单击**查看文档**。
- en: This takes you to where you can customize your API documentation further. You
    can add details such as the API description, stating a brief overview of the API,
    including its purpose, functionality, and any relevant background information.
  id: totrans-518
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将带您进入可以进一步自定义API文档的地方。您可以添加有关API的详细信息，例如，说明API的简要概述，包括其目的、功能以及任何相关的背景信息。
- en: Also, you can specify the base URL of the API, including the protocol (HTTP/HTTPS)
    and the domain name. If the API requires authentication, explain the authentication
    mechanism(s) supported (for example, API key, OAuth, or JWT) and provide instructions
    on how to authenticate requests.
  id: totrans-519
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此外，您还可以指定API的基本URL，包括协议（HTTP/HTTPS）和域名。如果API需要身份验证，请解释支持的认证机制（例如，API密钥、OAuth或JWT）并提供如何进行身份验证的说明。
- en: 'Depending on the requirements of your API, you can document each endpoint exposed
    by the API. For each endpoint, you may include the following information:'
  id: totrans-520
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 根据您API的要求，您可以记录API公开的每个端点。对于每个端点，您可能包括以下信息：
- en: '**Endpoint URL**: Provides the URL pattern for the endpoint, including any
    required path parameters.'
  id: totrans-521
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**端点URL**：提供端点的URL模式，包括任何必需的路径参数。'
- en: '`GET`, `POST`, `PUT`, `DELETE`, and so on).'
  id: totrans-522
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET`、`POST`、`PUT`、`DELETE`等）。'
- en: '**Request parameters**: Specifies any query parameters, request headers, or
    request body parameters required by the endpoint. Include the parameter name,
    type, description, and whether it is required or optional.'
  id: totrans-523
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**请求参数**：指定端点所需的任何查询参数、请求头或请求体参数。包括参数名称、类型、描述以及是否为必需或可选。'
- en: '**Response format**: Describes the format of the response returned by the endpoint
    (for example, JSON or XML).'
  id: totrans-524
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**响应格式**：描述端点返回的响应格式（例如，JSON或XML）。'
- en: '`200 OK`, `400 Bad Request`, or `401 Unauthorized`).'
  id: totrans-525
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`200 OK`、`400 Bad Request`或`401 Unauthorized`）。'
- en: '**Response body**: Provides an example of the response body returned by the
    endpoint, including all relevant fields and their descriptions.'
  id: totrans-526
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**响应体**：提供端点返回的响应体的示例，包括所有相关字段及其描述。'
- en: '**Error handling**: Explains how errors are handled by the API and provides
    examples of error responses.'
  id: totrans-527
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**错误处理**：解释API如何处理错误，并提供错误响应的示例。'
- en: Lastly, you can now publish your API documentation to share with the public.
  id: totrans-528
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，您现在可以将API文档发布到公共领域。
- en: '![Figure 9.10 – Screenshot showing how you publish your API documentation](img/Figure_9.10_B18554.jpg)'
  id: totrans-529
  prefs: []
  type: TYPE_IMG
  zh: '![图9.10 – 展示如何发布API文档的屏幕截图](img/Figure_9.10_B18554.jpg)'
- en: Figure 9.10 – Screenshot showing how you publish your API documentation
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.10 – 展示如何发布API文档的屏幕截图
- en: You can read up on the further customization of the published documentation
    in the Postman documentation as it is possible to convert it into HTML and host
    it on your own server. The link to the generated API documentation is https://documenter.getpostman.com/view/4242057/2s93sjUoYX.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在Postman文档中了解有关发布文档的进一步自定义，因为您可以将其转换为HTML并在自己的服务器上托管。生成的API文档链接为https://documenter.getpostman.com/view/4242057/2s93sjUoYX。
- en: Summary
  id: totrans-532
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored API development in Flask applications. We started
    by understanding what an API is all about and why businesses and developers are
    creating and consuming APIs to drive their data access. We took things further
    by taking a quick run through common terminologies developers come across when
    implementing the API design pattern.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了Flask应用程序中的API开发。我们首先了解API是什么以及为什么企业和开发者创建和消费API来驱动他们的数据访问。我们通过快速浏览开发者实现API设计模式时遇到的常见术语来进一步探讨。
- en: Then, we unmasked the structure of endpoints and payloads, recognizing that
    designing routes and exchanging data form the foundational elements of API development.
    In addition, we critically examined the design principles guiding RESTful API
    development. We discussed how understanding the REST API design principles enhances
    best practices in API design and development. Also, we discussed the implementation
    of the REST API and how we can connect API backend services with a database in
    a Flask application.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们揭示了端点和负载的结构，认识到设计路由和交换数据是API开发的基础元素。此外，我们批判性地审视了指导RESTful API开发的原理。我们讨论了理解REST
    API设计原理如何提升API设计和开发中的最佳实践。同时，我们还讨论了REST API的实现以及如何在Flask应用程序中将API后端服务与数据库连接起来。
- en: Finally, we discussed API testing and documentation with Postman. In API design
    and development, we recognized how testing and documenting endpoints is crucial
    to building stable and usable web applications.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们讨论了使用Postman进行API测试和文档。在API设计和开发中，我们认识到测试和记录端点对于构建稳定且可用的Web应用至关重要。
- en: In the next chapter, we are going to bridge the frontend and backend functionalities
    and experience the full stack nature of React and Flask.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将连接前端和后端功能，体验React和Flask的全栈特性。
