- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Third-Party Services Integration with FastAPI and Beanie
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After learning about the tools that compose the FARM stack, you will see them
    combined in a more complex setting in this chapter. You will build on your knowledge
    of Pydantic and FastAPI to learn about **Beanie,** one of the most popular MongoDB
    **Object-Document Mappers** (**ODMs**), and how it can make your code more efficient
    and enhance your developer experience.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you will see how the stack’s flexibility is useful when you need to
    extend your application with external, third-party functionality. In this chapter,
    you will add a fully AI-based salesperson assistant that will make use of OpenAI
    to create catchy car descriptions, and then you will use the **Resend** API service
    to send automated emails.
  prefs: []
  type: TYPE_NORMAL
- en: These functionalities are becoming more and more central to web application
    requirements in the modern web, and through this chapter, you will see how the
    right set of tools can make application development more efficient.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will walk you through the following tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: Installing and using Beanie – a Python MongoDB ODM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning about the basic Beanie features (connections, CRUD operations, and
    aggregations)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using FastAPI’s background tasks to handle long-running processes while maintaining
    the responsiveness of the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Programmatically sending emails from an application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating OpenAI’s ChatGPT (or any other **Large Language** **Model** (**LLM**))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The technical requirements for this chapter are similar to the requirements
    in the chapters in which we created backends with FastAPI, with the addition of
    a couple of libraries and services for the email-sending functionality and AI
    integration:'
  prefs: []
  type: TYPE_NORMAL
- en: Python 3.11.7 or higher
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visual Studio Code with the Python extensions set up (same as in [*Chapter 3*](B22406_03.xhtml#_idTextAnchor051))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An account on MongoDB Atlas
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An account on Render.com (if you wish to deploy the FastAPI backend)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An OpenAI account with API access, or a free, locally run LLM such as Llama
    2 or Llama 3 in case you do not want to deploy the app and incur costs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Netlify account (free tier)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We strongly recommend starting with the free (or cheapest) tiers of the previous
    accounts and making sure that you feel comfortable within these environments.
  prefs: []
  type: TYPE_NORMAL
- en: With the technical requirements out of the way, let’s discuss the project you
    will build throughout this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Project outline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Staying with the situation that you operate a (small) used car sales agency,
    the requirements are somewhat similar to the ones in the previous chapters. You
    will build a backend for a web app that displays information and pictures of cars
    that are for sale. Unlike the previous chapters, now you will use an ODM, and
    you will include email sending and OpenAI integration, which will be handled by
    FastAPI’s background tasks.
  prefs: []
  type: TYPE_NORMAL
- en: The car data model will be handled by Pydantic and Beanie. The application will
    need authenticated users and, while you will use `iron-session`.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you will integrate an LLM API (in this case, OpenAI) to help create
    useful car model descriptions, list the pros and cons of the newly inserted car
    model for the marketing pages, and send tailored emails to specified recipients
    on every new car ad insertion.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: LLMs are machine learning systems designed specifically to generate and understand
    human language. Trained on huge datasets, they are able to perform efficiently
    on tasks such as text summarization and generation, translation, and image generation.
    In the last couple of years, LLMs have gained popularity and adoption, and their
    fields of implementation will only grow over time.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, you will learn how to create a backend with FastAPI and
    Beanie and how to integrate OpenAI and email-sending functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Building the backend with FastAPI and Beanie
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For simplicity’s sake and to make the application as illustrative as possible,
    the API that you will build in this chapter will not differ too much from the
    one built in [*Chapter 7*](B22406_07.xhtml#_idTextAnchor118), *Building a Backend
    with FastAPI*. This way, you will be able to naturally pick up the main differences
    in the approaches of using Motor (or PyMongo) directly and the Beanie ODM.
  prefs: []
  type: TYPE_NORMAL
- en: '**Object-Relational Mappers** (**ORMs**) and **ODMs** are tools whose main
    purpose is to abstract the underlying database (whether it’s a relational or non-relational
    database) and facilitate the development process. Some famous Python examples
    include the **Django ORM** and **SQLAlchemy**—two proven and battle-tested solutions—as
    well as **SQLModel**, which was created by the creator of FastAPI and tightly
    integrated into the FastAPI/Pydantic world.'
  prefs: []
  type: TYPE_NORMAL
- en: Two modern ODMs that are gaining traction and popularity among the Python and
    MongoDB community are **Beanie** ([https://beanie-odm.dev/](https://beanie-odm.dev/))
    and **Odmantic** ([https://art049.github.io/odmantic/](https://art049.github.io/odmantic/)).
    In this project, you will be working with the more mature and older one of the
    two—the Beanie ODM.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to the Beanie ODM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Beanie is one of the most popular MongoDB ODMs for Python. ODMs are a programming
    technique that allows developers to work directly with classes (Python classes
    in our case) representing NoSQL documents. When using Beanie, each MongoDB collection
    is mapped to a corresponding document class that allows you to retrieve or aggregate
    data and perform CRUD operations, saving time by removing the necessity of boilerplate
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Beanie also handles MongoDB’s `ObjectId` type elegantly, and since its document
    class is based on Pydantic, you get to use all of the powerful validation and
    parsing features of Pydantic right out of the box.
  prefs: []
  type: TYPE_NORMAL
- en: 'In brief, some of Beanie’s salient features include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous, based on the Motor driver and ideal for performant FastAPI apps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Based on Pydantic and compatible with Pydantic version 2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Schema-based, with seamless handling of `ObjectId` string conversions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simple CRUD operations, as well as support for MongoDB’s powerful aggregation
    framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the following section, you will begin creating a Beanie-powered application
    through which you will learn some features of the ODM.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Beanie application
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You will learn how to use Beanie by creating a new application and exploring
    the functionality provided by the ODM—connecting to a database, mapping collections
    to document classes, and performing CRUD operations on the documents.
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin the project and scaffold the FastAPI application, perform the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new folder (`chapter9`) and a virtual environment with the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Activate the virtual environment with the following command (for Linux or Mac):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Or, for a Windows system, use the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Activate it and lay out an initial `requirements.txt` file with the following
    packages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Install the required packages by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you look closely at the `requirements.txt` file you will notice that you
    are installing a new package—`fastapi-cors`—that is useful for managing the `.env`
    file and then create a `.gitignore` file with the following content:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After getting the basic packages and settings ready, you will now create the
    models with Beanie.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the models with Beanie
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before scaffolding the main FastAPI application, you will learn how Beanie
    handles data models. As mentioned earlier, Beanie’s `Document` class represents
    documents that will eventually be saved into a MongoDB database, and these models
    inherit Beanie’s `Document` class, which itself is a Pydantic’s `BaseModel`-based
    class. As stated on the Beanie website: "The `Document` class in Beanie is responsible
    for mapping and handling the data from the collection. It is inherited from the
    `BaseModel` Pydantic class, so it follows the same data typing and parsing behavior."
    ([https://beanie-odm.dev/tutorial/defining-a-document/](https://beanie-odm.dev/tutorial/defining-a-document/))'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s begin creating the models, bearing in mind that the file will also contain
    several pure Pydantic models for validation of inputs and outputs (not all models
    will be Beanie-based, only the ones that map documents in collections):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file named `models.py` in the root of the directory, and import the
    necessary modules:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The only new import in this code is from Beanie: you are importing the `Document`
    class—the workhorse of Beanie for working with data—as well as `Link` (needed
    for referencing data, since you will not be embedding user data in car documents
    but referencing the users) and `PydanticObjectId`—a field type representing `ObjectId`
    compatible with Pydantic.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Continue working on the `models.py` file and create the base user model:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `User` model inherits from the Beanie `Document` class instead of the `BaseModel`
    class of Pydantic, but the rest is largely the same. In fact, the `Document` class
    is based on the `BaseModel` class and inherits its functionality—you were able
    to use a Pydantic field with the default factory for creating the `datetime` type.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Then, you used the `Settings` class to specify the name of the collection that
    will be used in MongoDB. This class is quite powerful and allows setting caching,
    indexing, validations upon saving, and much more, as you can see on the documentation
    page: [https://beanie-odm.dev/tutorial/defining-a-document/#settings](https://beanie-odm.dev/tutorial/defining-a-document/#settings).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Continuing with the same `models.py` file, you will now provide a couple of
    Pydantic models used for specific purposes: registering a new user, logging the
    user in, and providing information about the current user:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The previous code should feel familiar as it is completely based on Pydantic,
    so define the document model for the cars:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The Beanie document model contains all the fields that you have used throughout
    the book, and a couple of new ones: two lists of strings that will include small
    text snippets of pros and cons for each car model—something along the lines of
    *c**ompact and easy to park*. Also, the car description is intentionally left
    blank—these fields will be populated later, in a background task, by an OpenAI
    chat-completion prompt.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The interesting part of this model is the `user` part: the `Link` field type
    provides a direct link to the user. You can check the documentation to see what
    is possible with Beanie relations and what the current limitations are: [https://beanie-odm.dev/tutorial/relations/](https://beanie-odm.dev/tutorial/relations/).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Beanie manages relationships through links in the respective fields, and at
    the time of writing, only top-level fields are supported. Links to related documents
    can be links, optional links, and lists of links, as well as backward links.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Backward links are reverse relationships: if an object called `House` has a
    link to an owner—a `Person` object, for instance—then that `Person` object can
    have a backward link to all the houses that they own, through a backlink.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, add an `UpdateCar` Pydantic model that will be used for updating cars:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that you haven’t defined almost any validation on the fields—this is
    done only to save some space and simplify the model. Since Beanie is based on
    Pydantic, it can count on the full functionality of Pydantic and, thus, implement
    complex and powerful validations.
  prefs: []
  type: TYPE_NORMAL
- en: With the models now defined, you can proceed to connect to the MongoDB database.
    It is important to have the models defined upfront, as their names will be fed
    to the Beanie initialization code, as you will see in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to the MongoDB database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Beanie ODM uses the `pydantic-settings` and its `BasicSettings` class for
    easy access to the environment variables inside your application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The process is very similar to the one used in [*Chapter 7*](B22406_07.xhtml#_idTextAnchor118),
    *Building a Backend* *with FastAPI*:'
  prefs: []
  type: TYPE_NORMAL
- en: Environment variables are stored in the `.``env` file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pydantic-settings` is used to read the environment variables and create a
    settings object (through the `config.py` file).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These settings, together with the models, are used to initialize the database
    connection to Atlas.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To create the database connection and use the models, perform the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Define the configuration and environment variables by using `pydantic-settings`.
    Since you need the settings *before* initializing the database connection, and
    they are read from the environment, populate the `.env` file that will host the
    environment variables, which are then going to be read through the `config.py`
    file and instantiated into a settings object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `.env` file should contain the following entries:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You will set up the OpenAI and Resend API keys later, but for now, you can
    insert the other values for MongoDB Atlas and the `config.py`. Open the `config.py`
    file and create the `BaseConfig` class for reading the environment values and
    easy overriding of these values, based on the desired configuration:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The differences in connecting to a MongoDB database with Beanie compared to
    plain Motor-based connections become apparent in the `database.py` file that you
    will create in the same root directory and populate with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The initialization code is highlighted: the async `init_beanie` function needs
    the Motor client and the document models.'
  prefs: []
  type: TYPE_NORMAL
- en: With the models defined and the database connection in place, you will now begin
    crafting the FastAPI application and the routers.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the FastAPI application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All the necessary pieces are ready, and now that you have the connection to
    the MongoDB database ready, you can start building the application. Use the freshly
    created `database.py` file for connecting to your MongoDB instance and wrap it
    into the lifespan context manager to ensure that the application connects when
    started and that the connection is deleted on shutdown.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create the main FastAPI application file (`app.py`), perform the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `app.py` file in the root directory, which will be very similar
    to the one created in [*Chapter 7*](B22406_07.xhtml#_idTextAnchor118), *Building
    a Backend* *with FastAPI*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The connection initialization code is nested inside a lifespan event, like
    the previously used solution with Motor, while the rest of the code is just the
    inclusion of the routers that you will be creating soon and a root endpoint:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you have installed a recent version of FastAPI (0.111 or later) that installs
    the `fastapi-cli` package, you can now start the development FastAPI server with
    the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Alternatively, you can use the following standard code line:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding code uses the new `fastapi-cli` package for easier development
    ([https://fastapi.tiangolo.com/fastapi-cli/](https://fastapi.tiangolo.com/fastapi-cli/)).
    `fastapi-cors` will provide a new endpoint called “health check.” If you try it
    out, you will see the environment variables related to CORS (`ALLOWED_CREDENTIALS`,
    `ALLOWED_METHODS`, `ALLOWED_ORIGINS`, and others), and they are now settable through
    the `.``env` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The FastAPI main application is now ready, but it needs two routers: one for
    users and one for cars, as well as the authentication logic. First, you will handle
    the authentication class along with the `users` router.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating the APIRouter class for the users and the authentication class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The authentication class will encapsulate the authentication logic, similar
    to the one shown in [*Chapter 6*](B22406_06.xhtml#_idTextAnchor105), *Authentication
    and Authorization*, and create the accompanying **APIRouter** for managing users—registration,
    logging in, and verification.
  prefs: []
  type: TYPE_NORMAL
- en: The `authentication.py` file will be identical to the previously used one for
    simplicity’s sake. The `authentication.py` file, located in the root of the project,
    contains the encoding and decoding JWT logic, the password encryption, and the
    dependency injection, as shown in [*Chapter 7*](B22406_07.xhtml#_idTextAnchor118),
    *Building a Backend* *with FastAPI*.
  prefs: []
  type: TYPE_NORMAL
- en: 'We provide the file contents here, for your convenience:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The `user.py` router will be placed in the `/routers` folder, and it will expose
    three endpoints: for registering new users, for logging users in, and for verifying
    the user—given a `Bearer` token in the header. This last route is optional, as
    you will not use it directly in the next chapter (on Next.js) since we are opting
    for a simple cookie-based solution.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To create the API router for users, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `routers/user.py` file and populate it to create the router for the
    users. This router is again similar to the Motor version, and it shares the same
    logic, but some differences are highlighted in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The router showcases some of Beanie’s features: the direct querying of the
    `User` model (the `users` collection) with a MongoDB query, and the simple async
    creation of a new instance if the checks for existing users pass. In this case,
    you have two conditions: the username and the email must be available (not present
    in the collection). The querying syntax of Beanie is very intuitive: [https://beanie-odm.dev/tutorial/finding-documents/](https://beanie-odm.dev/tutorial/finding-documents/).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create the login route in the `user.py` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The login functionality uses the `find_one` MongoDB method, which is available
    in Beanie.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, add the `/me` route, for verifying the logged-in user. This method
    uses the `get` method, which accepts an `ObjectId`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This completes the `users.py` APIRouter, which uses several Beanie querying
    methods. Now, you will create the `Car` router with Beanie ODM.
  prefs: []
  type: TYPE_NORMAL
- en: The Car APIRouter
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Similar to what you have accomplished in the previous chapters, the `Cars`
    router will be in charge of performing some CRUD operations. For simplicity, you
    will implement only partial updates of the car instances: you will be able to
    update the fields defined in the `UpdateCar` model. Since the description and
    the lists of pros and cons will initially be empty, they need to be able to be
    updated later (by a call to OpenAI’s API).'
  prefs: []
  type: TYPE_NORMAL
- en: 'To create the `Cars` router, in the `/routers` folder and the `cars.py` file,
    perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Begin by creating a `/routers/cars.py` file and list the initial imports (there
    will be some more added later, when you start implementing background tasks):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'These imports are similar to the ones used when working with Motor directly;
    the main difference is the Beanie imports: `PydanticObjectId` (for handling ObjectIds
    with Pydantic) and `WriteRules`, which will enable the relationship of `Car` and
    `User` to be written to the MongoDB database as a reference.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Continuing with the file, you can now instantiate the authentication handler
    (`auth_handler`) class, the settings, and the router, as well as the Cloudinary
    configuration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After having the necessary settings and authentication ready, you can create
    the first route—the `GET` handler, which in this case simply retrieves all the
    cars in the database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the `GET` method for getting one car instance by its ID:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This implementation is also simple—it uses the `get()` shortcut to query the
    collection by `ObjectId`, which is elegantly handled by Beanie.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The method for creating the new car instances is a bit more complex, but not
    too heavy. Since you are uploading an image (a file), you are using form data
    instead of JSON and the endpoint must upload the image to Cloudinary, obtain an
    image URL from Cloudinary, and only then insert it into the MongoDB database along
    with the other data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The route for creating new resources uses the Beanie methods for getting a user
    by the ID (provided in the `Bearer` token in the header) and the `insert()` method
    for inserting a new car.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Finally, `link_rule` allows you to save the salesperson’s ID ([https://beanie-odm.dev/tutorial/relations/](https://beanie-odm.dev/tutorial/relations/)).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The `update` method is similar to its Motor counterpart, and it could be easily
    incorporated into a dashboard to update or delete car model adverts:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Once again, you only update the fields that are provided in the request, using
    the Pydantic `model_dump` method to verify which fields are actually provided,
    leaving the other ones (which are `null` or `None`, in Python terminology) unaltered.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the `delete` method, you only need to provide the selected document and
    invoke the `delete()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You have now completed your API routers, and you are ready to implement some
    more advanced functionality, which FastAPI and the FARM stack in general make
    a quick and fun task. Before being able to use the routers, however, you will
    need to import them into the `app.py` file. Open the `app.py` file and modify
    the imports at the top, adding the routers and aliasing them as cars and users:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, integrate them in the application by modifying the same `app.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: With the routers hooked up, you will integrate a simple, yet functional, AI
    assistant that will provide marketing information about the newly inserted cars,
    and automatically send emails to the salespersons, to a list of customers, or
    to a group of subscribers.
  prefs: []
  type: TYPE_NORMAL
- en: Background tasks with FastAPI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the most interesting features of FastAPI is how it handles background
    tasks—functions that should be run asynchronously after the response has already
    been sent to the client.
  prefs: []
  type: TYPE_NORMAL
- en: There are many use cases for background tasks. Any operation that could potentially
    take some time, such as waiting for an external API call to return a response,
    sending emails, or creating a complex document based on data processing in the
    endpoint, is a potential candidate for a background task. In all these cases,
    it would be bad practice and lead to a horrible user experience to just let the
    application hang while waiting for the result. Instead, these tasks are handed
    to the background to be processed while the response is returned immediately.
  prefs: []
  type: TYPE_NORMAL
- en: While very useful for simple tasks, background tasks shouldn’t be used for processes
    that require significant processing power and/or multitasking. In this case, a
    more robust tool such as **Celery** ([https://docs.celeryq.dev/](https://docs.celeryq.dev/))
    might be the best solution. Celery is a Python task queue framework that distributes
    work across threads or different machines.
  prefs: []
  type: TYPE_NORMAL
- en: FastAPI defines a class called `BackgroundTasks`, inherited from the **Starlette**
    web framework, which works simply and intuitively, as you will see in the following
    section when you use it to plug external services into your FastAPI application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before using background tasks for interfacing with third-party services, create
    a very simple task for demonstration purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file called `background.py` in the root of the project and populate
    it with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This function is very simple—it sleeps for five seconds and then prints a message
    on the console.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The syntax for integrating the task into an endpoint will be shown in the following
    API router.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Open the `/routers/user.py` file because you will attach this simple background
    task to the `login` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This function could also perform some logging or some more complex and time-consuming
    operations that would block the response until completion, but in this case, a
    simple `print` statement will be used.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'At the top of the file, import the background tasks and modify only the `login`
    endpoint in the following way:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can navigate to the address of the interactive documentation (127.0.0.1:8000/docs)
    and try to log in.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If you have also installed HTTPie, you can leave one terminal running the FastAPI
    application in development mode, open another terminal, and issue a login POST
    request, making sure to use the correct username and password of a user that you
    have created before. For example, the following command tests logging in for the
    user `tanja`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you look at the first terminal, you will see the following message after
    five seconds:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You have just created a straightforward, but potentially useful, background
    task and learned the syntax.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, you will create two background tasks that will create a
    new car description using OpenAI’s API and email the logged-in user—the user that
    inserted the car—with the description and the car data.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating OpenAI with FastAPI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: LLMs have been the buzzword in the last couple of years and they have been dominating
    the web development discourse, and it is becoming hard to find successful applications
    that aren’t using some form of LLM integration. Modern applications make use of
    image, text, and audio processing, and they might provide an edge to your next
    web application as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'In your car-selling and advertising application, you are going to use one of
    the simplest features of a behemoth such as OpenAI—the task at hand is to make
    things a bit easier on the salespersons and provide them a baseline marketing
    line for each new car that gets put on sale:'
  prefs: []
  type: TYPE_NORMAL
- en: 'After having obtained the OpenAI key and setting your environment variable,
    modify the `background.py` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can easily swap OpenAI for another LLM, such as **Google Gemini**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is one way to create a prompt for generating car data, but you
    will probably want to get more creative or conservative in the descriptions provided
    by OpenAI, depending on your case:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that the prompt is ready to be generated, it is time to perform a call
    to the OpenAI API. Please always refer to the latest OpenAI API documentation
    ([https://platform.openai.com/docs/overview](https://platform.openai.com/docs/overview)),
    as it is subject to frequent modifications. Currently, at the time of writing,
    the following code demonstrates the way to communicate with the API, which you
    should paste into your `background.py` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding code makes a call to the OpenAI client through the chat completion
    method. You have selected a model (`gpt-4`), started the `messages` array, and
    set `max_tokens` and `temperature`. Again, for all the parameter settings, refer
    to the latest OpenAI documentation. In this case, you are limiting the number
    of tokens to 500 and setting the temperature to `0.2` (this quantity impacts the
    “creativity” and the “conservativeness” of the responses).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'After receiving the response from OpenAI, you parsed the JSON content (`car_info`)
    into a Python dictionary containing the desired keys: description (text) and two
    arrays of strings (pros and cons). Armed with this newly generated data, you performed
    a MongoDB update (through Beanie) that selects all the cars that match the brand,
    the make, and the production year, and you set their description, pros, and cons
    to the data returned by OpenAI. In case of an error, we simply display the error.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now plug the background task into the `POST` endpoint. Open the `/routers/cars.py`
    file and import the newly created background function at the top:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The rest of the code will remain unaltered; you are only modifying the `POST`
    endpoint:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This could be performed in a much more granular way: you could await the generated
    ID of the newly inserted car and update only that particular instance. The function
    also lacks some basic validation for cases in which the provided car brand and
    make don’t exist, or in cases in which OpenAI doesn’t provide a valid response.
    The point is that the endpoint function returns the response immediately—that
    is, almost immediately, after performing the MongoDB insertion, and the description
    and the two arrays are updated later.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you try to rerun the development server and insert a car, you should see
    the newly created document (in Compass or Atlas) and, after a couple of seconds,
    the document will be updated with the initially empty fields: `description`, `pros`,
    and `cons`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can imagine different scenarios that could be covered by this functionality:
    maybe the car description needs to be approved by a human being and then the advert
    is set to be published (by adding a published Boolean variable), maybe you want
    to send the email to all the registered users, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: The next section will take this background job a bit further and show you how
    you can quickly integrate emails into your application.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating emails into FastAPI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the most frequent requirements of modern web applications is sending
    automated emails. Today, there are numerous options for sending emails, and two
    of the most popular options are **Mailgun** and **SendGrid** by Twilio.
  prefs: []
  type: TYPE_NORMAL
- en: Through this application, you will learn how to set up email functionality using
    a relatively new service called **Resend**. Their API-centric approach is very
    developer-friendly and easy to start with.
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to the Resend home page ([https://resend.com](https://resend.com))
    and create a free account. After logging in, navigate to the `FARMstack`. The
    key will be visible only once, so make sure to copy it and store it in the `.``env`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps to add Resend functionality to your application:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the `resend` package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After installing the `resend` package, update the `background.py` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Update the `create_description` function to send a message once the response
    is returned from OpenAI:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The recipient email should be the same email that you have signed up with Resend
    as it will be the only option until you register and verify your domain, but more
    than enough for development and testing purposes: [https://resend.com/docs/knowledge-base/](https://resend.com/docs/knowledge-base/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `resend` package makes sending emails simple—you just perform a single
    call to the `resend.Emails.Send` function and define the parameters. In your case,
    the parameters are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`to` – a list of recipient emails.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`from` – the email address of the sender. In this case, you will leave the
    default provided by Resend, but later on, you will replace it with your own domain
    address.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`subject` – the subject of the email.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`html` – the HTML content of the email.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The parameters are fed to the `resend.Email.send()` function as a dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: The email HTML in this app is constructed directly from an `f-string` in Python,
    but you could always resort to more sophisticated and complex solutions with **Jinja2**
    (for a purely Python solution, since the backend is written in Python) or use
    React Email by Resend ([https://react.email/](https://react.email/)). Jinja2 is
    arguably the most popular Python HTML templating engine, and it is used by the
    Flask web framework, while React Email provides React-based email templates.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Please refer to [*Chapter 7*](B22406_07.xhtml#_idTextAnchor118), *Building
    a Backend with FastAPI,* on deploying your backend to Render.com. The procedure
    will remain largely unchanged: just keep track of the environment variables and
    make sure to add the newly created ones (the OpenAI and Render keys). Alternatively,
    you can run the backend from this chapter in order to use it in the next chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned the basics of Beanie, a popular ODM library for
    MongoDB, built on top of Motor and Pydantic. You learned how to define models
    and define Beanie documents that map to MongoDB collections and how to query and
    perform CRUD operations with the ODM.
  prefs: []
  type: TYPE_NORMAL
- en: You built another FastAPI application in which you integrated third-party services
    with the help of background tasks, which is a FastAPI feature that allows slow-
    and long-running tasks to be executed in the background, while maintaining the
    app’s responsiveness.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter also covered integrating the most popular AI service, ChatGPT,
    into your applications, providing intelligent additional data about your newly
    inserted entities. Finally, you learned how to implement a simple email-sending
    solution, which is common in many web applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, you will dive into the most popular and advanced web framework
    based on React.js: **Next.js**. You will learn the basics of the latest version
    of Next.js (14) and discover the most important features that set it apart from
    other frontend or even full stack solutions.'
  prefs: []
  type: TYPE_NORMAL
