<html><head></head><body><div class="chapter" title="Chapter&#xA0;5.&#xA0;Adding Controls &#x2013; Scripting for Rigging"><div class="titlepage"><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Adding Controls – Scripting for Rigging</h1></div></div></div><p>This chapter will cover how to use Python to build rigs by:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Creating skeletons with script</li><li class="listitem" style="list-style-type: disc">Setting up set-driven key relationships with script</li><li class="listitem" style="list-style-type: disc">Adding custom attributes and locking and hiding attributes</li><li class="listitem" style="list-style-type: disc">Setting up inverse kinematics (IK) with script</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec40"/>Introduction</h1></div></div></div><p>Once you've created your model, laid out the UVs, and set up the shading networks, you'll still need to build controls into it if you want it to move. In this chapter, we'll be looking at how to do that with scripts.</p><p>We'll be looking at how to use Python to automate tasks related to rigging. Rigging is already one of the more technical aspects of 3D animation, and as such lends itself quite well to a script-based approach.</p></div></div>
<div class="section" title="Creating skeletons with script"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec41"/>Creating skeletons with script</h1></div></div></div><p>In this <a id="id187" class="indexterm"/>example, we'll be looking at how to create skeletons with script. We'll<a id="id188" class="indexterm"/> create two examples, one simple chain of bones and one branching set, similar to what you might want for a creature's hand.</p><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec106"/>How to do it...</h2></div></div></div><p>Create a new file and add the following code:</p><div class="informalexample"><pre class="programlisting">def createSimpleSkeleton(joints):
    '''
    Creates a simple skeleton as a single chain of bones
    ARGS:
        joints- the number of bones to create
    '''


    cmds.select(clear=True)

    bones = []
    pos = [0, 0, 0]

    for i in range(0, joints):
        pos[1] = i * 5
        bones.append(cmds.joint(p=pos))

    cmds.select(bones[0], replace=True)


def createHand(fingers, joints):
    '''
    Creates a set of 'fingers', each with a set number of joints
    ARGS:
        fingers- the number of joint chains to create
        joints- the number of bones per finger
    '''


    cmds.select(clear=True)

    baseJoint = cmds.joint(name='wrist', p=(0,0,0))

    fingerSpacing = 2
    palmLen = 4
    jointLen = 2

    for i in range(0, fingers):
        cmds.select(baseJoint, replace=True)
        pos = [0, palmLen, 0]

        pos[0] = (i * fingerSpacing) - ((fingers-1) * fingerSpacing)/2

        cmds.joint(name='finger{0}base'.format(i+1), p=pos)

        for j in range(0, joints):
            cmds.joint(name='finger{0}joint{1}'.format((i+1),(j+1)), relative=True, p=(0,jointLen, 0))

    cmds.select(baseJoint, replace=True)


createSimpleSkeleton(5)
createHand(5, 3)</pre></div><p>Run<a id="id189" class="indexterm"/> this code, and you'll see two separate networks of bones, both centered at the origin—one that is a straight vertical chain of five bones and one that <a id="id190" class="indexterm"/>approximates a hand (five fingers with three joints each).</p><p>The end result should look something like the following (shown after moving the two skeletons apart).</p><div class="mediaobject"><img src="graphics/4657_05_01.jpg" alt="How to do it..."/></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec107"/>How it works...</h2></div></div></div><p>We'll start with the <code class="literal">createSimpleSkeleton</code> command. Note that we start the function with a triple-quoted comment:</p><div class="informalexample"><pre class="programlisting">def createSimpleSkeleton(joints):
    '''
    Creates a simple skeleton as a single chain of bones
    ARGS:
        joints- the number of bones to create
    '''</pre></div><p>By placing a comment as the very first thing in the function definition, Python will recognize it as a <span class="emphasis"><em>docstring</em></span>.</p><p>Docstrings <a id="id191" class="indexterm"/>are a great way to provide documentation to the end user about what your code does and how it should be used. If you've added <a id="id192" class="indexterm"/>docstrings to your functions, the user will be able to view them with the help command. For example, let's say we have a file named <code class="literal">myFunctions.py</code> with a handful of functions, and we start the first one in the following manner:</p><div class="informalexample"><pre class="programlisting">def functionOne():
    """Description of function one"""</pre></div><p>The user could use the following command to view our description for functionOne:</p><div class="informalexample"><pre class="programlisting">help(myFunctions.functionOne)</pre></div><p>Note the use of dot syntax to specify first the module (Python treats all files as modules) then the specific function within it. Also note that there aren't any parentheses after the name of the function; that's because we're not calling the function. Instead, we're passing the function into the help command, which will cause Python to output the docstring for that function, if one exists.</p><p>Docstrings can also be used to provide documentation for classes and modules. In either case, make sure that the docstring is the first thing to appear in the class, function, or file, either directly after "def [functionName]", as we've done here, after "class [className]:" (for classes), or at the top of the file (for modules).</p><p>When adding docstrings, it's generally a good practice to describe each of the inputs to the function and what they signify. In this case, our function has a single input, which will specify the number of bones to create.</p><p>Now that we've properly documented our code, it's time to actually make some bones. The bulk of the work is done using the joint tool to create a new bone using the position/p flag to specify where it should go, as follows:</p><div class="informalexample"><pre class="programlisting">cmds.joint(position=(1, 1, 1))</pre></div><p>In our first example, we make things slightly easier on ourselves by creating an array to hold the position of the bones and passing that in to each successive call to the joint command. This way, we can easily just modify the Y position of the joints that we create, while keeping the X and Z coordinates the same to produce a vertical chain of bones:</p><div class="informalexample"><pre class="programlisting">    pos = [0, 0, 0]</pre></div><p>We also create an array to hold the output of the joint command after each bone is created in order to allow us to take further actions on the bones once they've been created:</p><div class="informalexample"><pre class="programlisting">    bones = []</pre></div><p>Once we have both of those, we simply run through a loop, changing the second element of our pos array to alter the Y-value and creating a new joint:</p><div class="informalexample"><pre class="programlisting">    for i in range(0, joints):
        pos[1] = i * 5
        bones.append(cmds.joint(p=pos))</pre></div><p>The <a id="id193" class="indexterm"/>most <a id="id194" class="indexterm"/>notable thing about the this is what we're <span class="emphasis"><em>not</em></span> doing. Note that this code merely creates bones; it does nothing to explicitly create any sort of hierarchy between them. Nevertheless, the preceding code will result in a proper chain of bones, with each one a child of the previous bone.</p><p>This is due to the fact that, when creating bones, Maya will automatically make any newly created joint a child of the currently selected object, if that object happens to be a joint. That, combined with the fact that all of Maya's commands that result in the creation of a new object leave that new object selected means that, as we build up the chain of joints, Maya automatically connects them into the proper hierarchy. This also explains why the first line of the function was:</p><div class="informalexample"><pre class="programlisting">cmds.select(clear=True)</pre></div><p>This ensured that nothing was selected. When creating new joint networks, it is always good to make sure that your selection is clear before starting; otherwise, you may end up with connections that you don't want.</p><p>Now that we've looked at making a simple chain of bones, we'll move on to a slightly more complex example in the <code class="literal">createHand</code> function. Once again, we'll add a docstring at the start of the function to properly document the inputs to the function and the effects of each:</p><div class="informalexample"><pre class="programlisting">def createHand(fingers, joints):
    '''
    Creates a set of 'fingers', each with a set number of joints
    ARGS:
        fingers- the number of joint chains to create
        joints- the number of bones per finger
    '''</pre></div><p>We start by creating a single joint to be the root bone and saving it in the <code class="literal">baseJoint</code> variable, so we can easily refer to it again later.</p><div class="informalexample"><pre class="programlisting">baseJoint = cmds.joint(name='wrist', p=(0,0,0))</pre></div><p>We'll also make sure to give our new bone a sensible name. In this case, we'll use "wrist" since it will be serving as the parent bone for all of our fingers. You might be wondering why we're setting the name <span class="emphasis"><em>and</em></span> storing the result into a variable. That is necessary in order to avoid problems if there is already something named "wrist" in our scene. If there <span class="emphasis"><em>is</em></span> something named "wrist", then Maya would append a number onto the name of the newly created bone, resulting in something like "wrist1". If we later tried to do something to "wrist", we would end up affecting a different object. So, we have to do two things; we'll store the output of the joint command into a variable so that we can refer to it later <span class="emphasis"><em>and</em></span> we give it a name so that it's nicer to work with.</p><p>Having all <a id="id195" class="indexterm"/>of the bones in your rig named "jointX" is a great way to make things unnecessarily confusing, so always be sure to give your bones proper names; just don't trust those names to always be unique.</p><p>Now that we <a id="id196" class="indexterm"/>have our base bone, we create a few variables to control the layout of the "hand"—one for the length of the palm, one for the length of each finger joint, and one for the gap between each finger.</p><div class="mediaobject"><img src="graphics/4657_05_02.jpg" alt="How it works..."/></div><p>Now we're ready to create each finger. We start each pass through the loop by first selecting the baseJoint bone. That's all we need to do in order to make sure that we have the proper hierarchy, with each finger having a separate chain and each chain being parented to the base joint.</p><p>We start each finger with a joint that is palmLen units above the base joint. The horizontal spacing is a little more involved and requires some explanation. We have the following code:</p><div class="informalexample"><pre class="programlisting">pos[0] = (i * fingerSpacing) - ((fingers-1) * fingerSpacing)/2</pre></div><p>There are two parts to the preceding code:</p><div class="informalexample"><pre class="programlisting">(i * fingerSpacing)</pre></div><p>This will ensure that the fingers are spaced out horizontally by the proper amount, but if we left it at that, we would have all of the fingers to the right of the wrist. To fix this, we need to <a id="id197" class="indexterm"/>move <a id="id198" class="indexterm"/>all of our positions to the left by one half of the total width. The total width is equal to our fingerSpacing variable multiplied by the number of gaps between the fingers. Since the number of gaps is equal to the number of fingers, minus one, we have:</p><div class="informalexample"><pre class="programlisting">((fingers-1) * fingerSpacing)/2</pre></div><p>Subtracting the second part from the first will keep the finger-to-finger spacing the same, but will move everything such that the fingers are centered over the based joint.</p><p>Now that we have the proper position for the base of our "finger", we create the first joint, as follows:</p><div class="informalexample"><pre class="programlisting">cmds.joint(name='finger{0}base'.format(i+1), p=pos)</pre></div><p>Note that we use the string format command to build up the name of the joint from some literals and the number of the finger we're on at the moment (adding one so that the first finger is a more readable "1" instead of "0"). This will give us joints named along the lines of "finger1base", "finger2base", and so on. We'll do something similar with the successive joints to name them with both the name of the finger and the name of the joint ("finger1joint1", for example).</p><p>Once we've started the finger, we run through another loop to create each of the finger joints:</p><div class="informalexample"><pre class="programlisting">        for j in range(0, joints):
            cmds.joint(name='finger{0}joint{1}'.format((i+1),(j+1)), relative=True, p=(0,jointLen, 0))</pre></div><p>Note that there's one small difference with this, in that we're passing what appears to be the same position in to the joint command. That still works because we're also using the <code class="literal">relative</code> command, which will cause Maya to position the new bone relative to its immediate parent. In this case, this means that each new bone will be created <code class="literal">jointLen</code> units above the previous one.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec108"/>There's more...</h2></div></div></div><p>In order to create branching skeletons, it is necessary to change the currently selected bone before creating child bones. In the preceding example, we did that directly, by explicitly selecting our base joint again before starting each new branch.</p><p>That's not the only way though you can also use the <code class="literal">pickWalk</code> command. The <code class="literal">pickWalk</code> command operates on the current selection and allows you to move around its hierarchy. To use the command, you have to specify a direction—up, down, left, or right. The most useful options are up, which will change the selection to be the parent of the currently selected <a id="id199" class="indexterm"/>node, and down, which will change the selection to a child of the currently selected node (assuming it has children). So, another option to create a branching network of joints would be </p><p>to import maya.cmds as cmds, as follows:</p><div class="informalexample"><pre class="programlisting">cmds.joint(p=(0,0,0))
cmds.joint(p=(-5, 5, 0))
cmds.pickWalk(direction="Up")
cmds.joint(p=(5, 5, 0))</pre></div><p>The first<a id="id200" class="indexterm"/> two lines create a base bone and add a child bone one unit up and to the left. Then, the <code class="literal">pickWalk</code> command is used to move the selection back to the base joint before creating a third bone.</p><p>The results of creating three bones in sequence. The left image indicates what happens if pickWalk is used to move back up the hierarchy after creating the second, and the right image indicates what happens if pickWalk is omitted.</p><div class="mediaobject"><img src="graphics/4657_05_03.jpg" alt="There's more..."/></div></div></div>
<div class="section" title="Setting up set-driven key relationships with script"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec42"/>Setting up set-driven key relationships with script</h1></div></div></div><p>A <a id="id201" class="indexterm"/>great deal of rigging is nothing more than setting up connections between attributes. Sometimes, those connections can be very direct, such as making sure that two joints are always in exactly the same position in world space, but in other times, something other than a direct one-to-one mapping is called for.</p><p>There are a few different ways to connect attributes in non-linear ways, including using Maya's set-driven key capability to map one arbitrary range of an attribute onto a different arbitrary range of another. In this example, we'll be looking at how to set that up with scripting.</p><p>Our example<a id="id202" class="indexterm"/> will set up the "Hello World" equivalent for using a set-driven key, a finger that curls all of its joints smoothly at the same time, allowing the animator to keyframe a single attribute per finger instead of three (or possibly even more).</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec109"/>Getting ready</h2></div></div></div><p>For this example, you'll want to have a simple chain of at least three bones. The output of the script will cause all of the bones downstream from the selected bone to rotate when the parent bone (the knuckle) is rotated. Either create a simple chain of bones, or use the output from this chapter's example on bone creation.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec110"/>How to do it...</h2></div></div></div><p>Create a new script and enter the following code:</p><div class="informalexample"><pre class="programlisting">import maya.cmds as cmds


def setDrivenKeys():
    objs = cmds.ls(selection=True)
    baseJoint = objs[0]

    driver = baseJoint + ".rotateZ"

    children = cmds. listRelatives(children=True, allDescendents=True)

    for bone in children:
        driven = bone + ".rotateZ"

        cmds.setAttr(driver, 0)
        cmds.setDrivenKeyframe(driven, cd=driver, value=0, driverValue=0)
        
        cmds.setAttr(driver, 30)
        cmds.setDrivenKeyframe(driven, cd=driver, value=30, driverValue=30)


    cmds.setAttr(driver, 0)
    

setDrivenKeys()</pre></div><p>Once you have the script ready, select the "knuckle" bone and run it. Then, try rotating the knuckle<a id="id203" class="indexterm"/> bone around the <span class="emphasis"><em>z</em></span> axis. You should see all of the bones downstream from the knuckle rotate as well:</p><p>[fig setDrivenKey_1]</p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec111"/>How it works...</h2></div></div></div><p>There are two main aspects to the script—the actual set-driven key setup and some code to walk down the chain of bones.</p><p>First off, we start by grabbing the currently selected object, as we've done in the past.</p><div class="informalexample"><pre class="programlisting">objs = cmds.ls(selection=True)
baseJoint = objs[0]</pre></div><p>We store the selected object to a variable (baseJoint) so that we can easily refer to it later. We'll also want an easy way to refer to the driver attribute, in this case, the Z-rotation of the base bone, so we store that to a variable as well.</p><div class="informalexample"><pre class="programlisting">driver = baseJoint + ".rotateZ"</pre></div><p>Now we're ready to start stepping through our chain of bones. To do this, we'll need to first grab a list of all of the downstream bones from the selected joint. We can do that using the <code class="literal">listRelatives</code> command with the children flag. Normally, that would only use the direct children of the given node, but if we also set the <code class="literal">allDescendents</code> flag to True, we will be given the full list of children, grandchildren, and so on down the entire hierarchy:</p><div class="informalexample"><pre class="programlisting">    children = cmds.listRelatives(children=True, allDescendents=True)</pre></div><p>Now that we have a list of all of the nodes that are children of the selected node (in this case, our base joint), we're ready to step through the list and set up a set-driven key relationship on each. To do this, we'll use the <code class="literal">setDrivenKeyframe</code> command.</p><p>In each iteration through our loop, we'll:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Set our <code class="literal">driven</code> variable to the proper attribute (bone + ".rotateZ").</li><li class="listitem">Set the value of our driven attribute using setAttr to its minimum value.</li><li class="listitem">Use the <code class="literal">setDrivenKeyframe</code> command to link the two attributes.</li><li class="listitem">Repeat steps 2 and 3 to set the maximum values.</li></ol></div><p>The <code class="literal">setDrivenKeyframe</code> command is fairly straightforward, requiring that we pass in the driver attribute, the driven attribute, and the values for each. In both cases, the attributes in question need to be the full name (node name, ".", and attribute name). So, to set it up so that our driven attribute is at 0 when our driver attribute is at -10, we could use the following:</p><div class="informalexample"><pre class="programlisting">cmds.setDrivenKeyframe(driven, cd=driver, value=-10, driverValue=0)</pre></div><p>This<a id="id204" class="indexterm"/> should be enough to get the results we want, but the command can often fail unless the driver value is explicitly set beforehand. That's why, we use <code class="literal">setAttr</code> before calling <code class="literal">setDrivenKeyframe</code>.</p><p>The <code class="literal">setAttr</code> command is a real workhorse, and it is the one that you're likely to use in a great deal of different scenarios. Luckily, it's also very easy to use; just call it and pass in first the attribute you're setting, then the value to which you want to set it, as in:</p><div class="informalexample"><pre class="programlisting">cmds.setAttr(driver, 30)</pre></div><p>Once we've set at least two keys on each bone, we'll have a proper set-driven key relationship. Putting this all together gives us the following loop:</p><div class="informalexample"><pre class="programlisting">    for bone in children:
        driven = bone + ".rotateZ"

        cmds.setAttr(driver, 0)
        cmds.setDrivenKeyframe(driven, cd=driver, value=0, driverValue=0)
        
        cmds.setAttr(driver, 30)
        cmds.setDrivenKeyframe(driven, cd=driver, value=30, driverValue=30)</pre></div><p>Finally, we'll finish off the script with a little bit of cleanup to ensure that we leave things as we found them. In this case, it means setting the driver value back to zero.</p><div class="informalexample"><pre class="programlisting">cmds.setAttr(driver, 0) </pre></div></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec112"/>There's more...</h2></div></div></div><p>In the preceding example, we used only two keyframes, but you can certainly have more than two points on the graph relating the driven variable to the driver if you wanted to have a more non-linear relationship between the attributes. For example, if we wanted to have the driven variable change at a greater rate during the last third of the range, we could do something like the following:</p><div class="informalexample"><pre class="programlisting">    cmds.setAttr(driver, 0)
    cmds.setDrivenKeyframe(driven, cd=driver, v=0, dr=0)
    
    cmds.setAttr(driver, 20)
    cmds.setDrivenKeyframe(driven, cd=driver, v=20, dr=10)

    cmds.setAttr(driver, 30)
    cmds.setDrivenKeyframe(driven, cd=driver, v=30, dr=30)</pre></div><p>In this code, the first twenty units of change in the driver (0–20) would result in only 10 units of change in the driven (0–10), but the last 10 units of change in the driver (20–30) would drive a 20-unit change in the driven attribute.</p><p>Another <a id="id205" class="indexterm"/>thing you might want to consider is what kind of curve you want to create. Each of the keyframes added with <code class="literal">setDrivenKeyframe</code> can be given its own tangent types, for both the input and output. To do it, set either the <code class="literal">inTangentType</code> or <code class="literal">outTangentType</code> when calling the function. In either case, you'll want to give it a string representing the tangent type you want.</p><p>So, if we wanted to have linear tangents for both the input and output of a new driven keyframe, we could do the following:</p><div class="informalexample"><pre class="programlisting">cmds.setDrivenKeyframe(driven, cd=driver, v=30, dr=30, inTangentType="linear", outTangentType="linear")</pre></div><p>For a full list of the allowed options, consult the documentation for the <code class="literal">setDrivenKe</code>
<code class="literal">yframe</code> command.</p></div></div>
<div class="section" title="Adding custom attributes and locking and hiding attributes"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec43"/>Adding custom attributes and locking and hiding attributes</h1></div></div></div><p>As you <a id="id206" class="indexterm"/>build up the rig for a model, it is often helpful to create custom attributes so that you can link things to <code class="literal">forefingerRight.curl</code> (for example), instead of <code class="literal">forefingerRight.rotateZ</code>. Not only will that make your rigs a great deal easier to understand, but it also allows you to tie actions of the rig to values that are completely independent of any built-in affects such as rotation or translation.</p><p>Just as there<a id="id207" class="indexterm"/> are sometimes attributes that you will want to add to a given node, there are often attributes on a node that you know you'll never want to animate. Locking such attributes and hiding them in the channel box is another way to make your rigs easier to work with.</p><p>In this example, we'll be looking <a id="id208" class="indexterm"/>at how to do both things—adding new, custom attributes to a node and hiding undesirable or unimportant attributes from view. More specifically, we'll be hiding the rotation and scale attributes and adding some attributes of the sort that you might want in order to animate a facial rig.</p><p>Here's a screenshot of the channel box both before and after the example script is run:</p><div class="mediaobject"><img src="graphics/4657_05_04.jpg" alt="Adding custom attributes and locking and hiding attributes"/></div><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec113"/>Getting ready</h2></div></div></div><p>Before <a id="id209" class="indexterm"/>adding to or altering the attributes on a node, it's important to determine exactly what you need. In this case, we'll be setting things up in a way similar to<a id="id210" class="indexterm"/> what we might want for control of a facial rig. This means for the node itself, we'll likely want to be able to change its position, but not the rotation or scale.</p><p>We'll also want <a id="id211" class="indexterm"/>to add several different attributes to control the parts of our rig. These will naturally vary from rig to rig, but in all cases, it's necessary to think about what kind of data we need for each. For the sake of the example, let's say that we want the following controls:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A "blink" attribute, which will cause both eyelids to close and open.</li><li class="listitem" style="list-style-type: disc">An "IK/FK" switch control for each of the legs that can switch between IK and FK controls</li></ul></div><p>For each of these, we'll need to think about what kind of data we need. For the blink attribute, we want a number that can vary smoothly from one value (representing fully open) to another (representing fully closed). For that, we'll need a decimal number.</p><p>For the IK/FK switch, we could approach it in two different ways. We could have a value that represents whether IK is on, with "off" meaning that FK is currently being used. For that, we would want to use a simple on/off value. Alternatively, we could implement our IK/FK switch<a id="id212" class="indexterm"/> as a <a id="id213" class="indexterm"/>dropdown of options. That <a id="id214" class="indexterm"/>would likely be a better and more user-friendly way to go. In this example, we'll be implementing both approaches for the sake of completeness.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec114"/>How to do it...</h2></div></div></div><p>Create a new file and add the following code:</p><div class="informalexample"><pre class="programlisting">def addCustomAttributes():

    objs = cmds.ls(selection=True)
    cmds.addAttr(objs[0], shortName="blink", longName="blink", defaultValue=0, minValue=-1, maxValue=1, keyable=True)
    
    cmds.addAttr(objs[0], shortName="ikfkR", longName="ikfkRight", attributeType="bool", keyable=True)
    cmds.addAttr(objs[0], shortName="ikfkL", longName="ikfkLeft", attributeType="enum", enumName="IK:FK", keyable=True)

    cmds.setAttr(objs[0]+".rotateX", edit=True, lock=True, keyable=False, channelBox=False)

    for att in ['rotateY','rotateZ','scaleX','scaleY','scaleZ']:
        lockAndHide(objs[0], att)

def lockAndHide(obj, att):

    fullAttributeName = obj + '.' + att

    cmds.setAttr(fullAttributeName, edit=True, lock=True, keyable=False, channelBox=False)


setup()
addCustomAttributes()</pre></div><p>Select an object and run the preceding script, making sure that you have the channel box visible when you do so. You should see the rotation and scale attributes disappear and the new attributes appear.</p></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec115"/>How it works...</h2></div></div></div><p>First off, we grab the currently selected object, just as we've done in the past. Once we've done that, we start by adding the blink attribute with the following:</p><div class="informalexample"><pre class="programlisting">cmds.addAttr(objs[0], shortName="blink", longName="blink", defaultValue=0, minValue=-1, maxValue=1, keyable=True)</pre></div><p>This is a <a id="id215" class="indexterm"/>fairly involved command, but the general idea is that we specify the following for each attribute we want to add:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The name</li><li class="listitem" style="list-style-type: disc">The type of attribute</li><li class="listitem" style="list-style-type: disc">Any additional information that the specific type of attribute requires</li></ul></div><p>The <a id="id216" class="indexterm"/>names of attributes come in two flavors—the short name and the long name. You have to specify at least one of those to have the command work, but it's generally a good idea to specify both. In this case, "blink" is sufficiently short to use it for both the short and long versions.</p><p>If we don't <a id="id217" class="indexterm"/>directly specify the type of attribute we're creating, Maya will default to a numerical type, which happens to be exactly what we want for the blink attribute. Since a "blink" attribute has a natural upper and lower bound (since eyelids open by a finite amount), it also makes sense to give our attribute minimum and maximum values, with the default being in between. Here, we're using -1 and 1 for the minimum and maximum, which is fairly standard.</p><p>Finally, in order to ensure that our new attribute shows up in the channel box, we need to make sure that we set the <code class="literal">keyable</code> flag to true.</p><p>Next up is our simple on/off version of the IK/FK switch. For this, we'll be using a Boolean type. For non-numeric types, we'll need to use the <code class="literal">attributeType</code> flag with the appropriate value (in this case, "bool"). We still specify the short and long names, and use the <code class="literal">keyable</code> flag to make it appear in the channel box:</p><div class="informalexample"><pre class="programlisting">cmds.addAttr(objs[0], shortName="ikfkR", longName="ikfkRight", attributeType="bool", keyable=True)</pre></div><p>The resulting attribute will accept values of either 0 or 1, but will display them as "off" or "on" (respectfully) in the channel box.</p><p>For our final attribute, we'll create one with two possible states, either "IK" or "FK", presented to the user as a drop-down list. For that, we'll create an attribute of type "enum" (short for "enumerated list"). We'll also need to specify the specific options that we want with the <code class="literal">enumName</code> flag. The <code class="literal">enumName</code> flag expects a string containing one or more options, all separated with colons.</p><p>So, in order to have "IK" and "FK" options, we'll want the value of our <code class="literal">enumName</code> flag to be "IK:FK". Putting this all together gives us:</p><div class="informalexample"><pre class="programlisting">cmds.addAttr(objs[0], shortName="ikfkL", longName="ikfkLeft", attributeType="enum", enumName="IK:FK", keyable=True)</pre></div><p>Note that, in <a id="id218" class="indexterm"/>order to actually hook our new attribute up to anything, it's important to know what the actual values of each option are. By default, the first<a id="id219" class="indexterm"/> option will have a value of 0, with each successive option increasing by one. So, in this case, "IK" will correspond to 0 and "FK" will correspond to 1. If <a id="id220" class="indexterm"/>you want to have specific numerical values for specific options, that's also possible. For example, if we wanted "IK" to correspond to 5 and "FK" to 23, we could do that with the following:</p><div class="informalexample"><pre class="programlisting">cmds.addAttr(objs[0], longName="ikCustomVals", attributeType="enum", enumName="IK=5:FK=23", keyable=True)</pre></div><p>At this point, we're all done adding attributes and can move on to hiding the ones we don't want—the rotation and scale attributes. We'll want to do three separate things to properly hide each attribute, namely:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Lock the attribute so that its value cannot be changed.</li><li class="listitem">Set the attribute to not be keyable.</li><li class="listitem">Set the attribute to not appear in the channel box.</li></ol></div><p>All of these can be accomplished with the <code class="literal">setAttr</code> command, used in the edit mode, as in:</p><div class="informalexample"><pre class="programlisting">cmds.setAttr(objs[0]+".rotateX", edit=True, lock=True, keyable=False, channelBox=False)</pre></div><p>Note that the first thing we pass in to setAttr is the full name of the attribute (object name and attribute name, joined by a "."). That can be a little tedious to do each time though, so we create a function that accepts the object and attribute name, and locks and hides it.</p><div class="informalexample"><pre class="programlisting">def lockAndHide(obj, att):

    fullAttributeName = obj + '.' + att
    cmds.setAttr(fullAttributeName, edit=True, lock=True, keyable=False, channelBox=False)</pre></div><p>We can then use a bit of Python's built-in functionality to make it even easier to lock a list of attributes by iterating over a list of attribute names and passing them to our <code class="literal">lockAndHide</code> function, as follows:</p><div class="informalexample"><pre class="programlisting">for att in ['rotateY','rotateZ','scaleX','scaleY','scaleZ']:
    lockAndHide(objs[0], att)</pre></div><p>In this case, Python's approach to for loops (iterating over a list) makes things very straightforward, indeed.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec116"/>There's more...</h2></div></div></div><p>If you look <a id="id221" class="indexterm"/>at the documentation for the <code class="literal">addAttr</code> command, you'll see that there is an extensive list of attribute types. Don't let the length of that list scare you; the vast majority of attributes you're likely to want to add can be implemented as the default (double) type with the appropriate minimum and maximum values.  "Double" in this context is short for "double precision" meaning a decimal value that uses twice the number of bytes as a typical float.</p><p>While the several different flavors of integer and floating-point numeric values aren't likely to make much of a difference in your scripts, a few of the more esoteric types may come in handy.</p><p>One thing you <a id="id222" class="indexterm"/>might find useful is the ability to add a color attribute to a node. Adding a color requires adding a compound attribute, which is a little bit more involved <a id="id223" class="indexterm"/>than what we've seen so far. First, you need to add an attribute to serve as the parent, then you'll need to add successive child attributes, of the same type and of the right number as the parent attribute's type.</p><p>For a color, we'll need to use an attribute type with three values for the parent, such as "float3". We'll also want to set the <code class="literal">usedAsColor</code> flag to true so that it is properly recognized as a color by Maya.</p><div class="informalexample"><pre class="programlisting">cmds.addAttr(objs[0], longName='colorTest', attributeType='float3', usedAsColor=True)</pre></div><p>Once we've done that, we can add attributes for each component of the parent attribute (in this case, values for the red, green, and blue components). Note the use of the parent flag to properly tie the new attributes to our "colorTest" group:</p><div class="informalexample"><pre class="programlisting">    cmds.addAttr(objs[0], longName='colorR', attributeType='float', parent='colorTest' )
    cmds.addAttr(objs[0], longName='colorG', attributeType='float', parent='colorTest' )
    cmds.addAttr(objs[0], longName='colorB', attributeType='float', parent='colorTest' )</pre></div><p>Note that some types of attributes won't display in the channel box. To see such attributes, select the node they've been added to, open the attribute editor, and expand the "extra attributes" tab.</p><div class="mediaobject"><img src="graphics/4657_05_05.jpg" alt="There's more..."/></div></div></div>
<div class="section" title="Setting up inverse kinematics (IK) with script"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec44"/>Setting up inverse kinematics (IK) with script</h1></div></div></div><p>While it <a id="id224" class="indexterm"/>is very likely that any given model will require at least some custom rigging work, it can often be helpful to automate the setup of common subcomponents that occur frequently in many different rigs. In this example, we'll be doing just that and setting up a simple inverse kinematics (IK) system with code.</p><p>Although our example will be simple, it will still demonstrate a common issue—the need to accurately position joints to match the specific proportions of a model. As such, the script will have the following two distinct parts:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A preliminary step, where we create locators representing where the various joints will be created.</li><li class="listitem" style="list-style-type: disc">A secondary step, where we build a skeleton and set up its attributes based on the position of the locators.</li></ul></div><p>By breaking the script into two parts, we allow the user to alter the positions of the locators after they've been created, but before the actual skeleton has been set up. This tends to be a much more effective way to match rigs to characters, and there can also be a great way to solicit input from the user for other kinds of tasks as well.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec117"/>Getting ready</h2></div></div></div><p>While you<a id="id225" class="indexterm"/> running the example script doesn't require having a suitable model, you might enjoy it more if you have a bipedal model to fit the joints we'll be creating to.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec118"/>How to do it...</h2></div></div></div><p>Create a new script and add the following code:</p><div class="informalexample"><pre class="programlisting">import maya.cmds as cmds

def showUI():
    myWin = cmds.window(title="IK Rig", widthHeight=(200, 200))
    cmds.columnLayout()
    cmds.button(label="Make Locators", command=makeLocators, width=200)
    cmds.button(label="Setup IK", command=setupIK, width=200)
    
    cmds.showWindow(myWin)


def makeLocators(args):
    global hipLoc
    global kneeLoc
    global ankleLoc
    global footLoc

    hipLoc = cmds.spaceLocator(name="HipLoc")
    kneeLoc = cmds.spaceLocator(name="KneeLoc")
    ankleLoc = cmds.spaceLocator(name="AnkleLoc")
    footLoc = cmds.spaceLocator(name="FootLoc")

    cmds.xform(kneeLoc, absolute=True, translation=(0, 5, 0))
    cmds.xform(hipLoc, absolute=True, translation=(0, 10, 0))
    cmds.xform(footLoc, absolute=True, translation=(2, 0, 0))

def setupIK(args):
    global hipLoc
    global kneeLoc
    global ankleLoc
    global footLoc

    cmds.select(clear=True)

    pos = cmds.xform(hipLoc, query=True, translation=True, worldSpace=True)
    hipJoint = cmds.joint(position=pos)

    pos = cmds.xform(kneeLoc, query=True, translation=True, worldSpace=True)
    kneeJoint = cmds.joint(position=pos)

    pos = cmds.xform(ankleLoc, query=True, translation=True, worldSpace=True)
    ankleJoint = cmds.joint(position=pos)

    pos = cmds.xform(footLoc, query=True, translation=True, worldSpace=True)
    footJoint = cmds.joint(position=pos)

    cmds.ikHandle(startJoint=hipJoint, endEffector=ankleJoint)

showUI()</pre></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec119"/>How it works...</h2></div></div></div><p>Since this <a id="id226" class="indexterm"/>script requires two separate parts, we'll need to implement a simple UI in order to allow the user to run the first part, alter the positions of the locators, and invoke the second. The UI isn't anything complicated, but just two buttons, and should look familiar if you've worked through any of the examples in <a class="link" href="ch02.html" title="Chapter 2. Creating User Interfaces">Chapter 2</a>, <span class="emphasis"><em>Creating User Interfaces</em></span>. We simply create a window, add a layout, and add one button for each of the steps of our script. We have the following code:</p><div class="informalexample"><pre class="programlisting">def showUI():
    myWin = cmds.window(title="IK Rig", widthHeight=(200, 200))
    cmds.columnLayout()
    cmds.button(label="Make Locators", command=makeLocators, width=200)
    cmds.button(label="Setup IK", command=setupIK, width=200)
    
    cmds.showWindow(myWin)</pre></div><p>The things start to get interesting in the <code class="literal">makeLocators</code> function, which will create four locator objects in a default layout. Before creating the locators, we'll create four global variables so that we can store references to them for later use. The <code class="literal">global</code> keyword tells Python that these variables should be treated as global in scope, meaning that they will be available beyond the immediate, local scope (in this case, the <code class="literal">makeLocators</code> function). Later on, we'll invoke the global variables again from within our second function (the <code class="literal">setupIK</code> function) in order to refer to the locators we're about to create:</p><div class="informalexample"><pre class="programlisting">    global hipLoc
    global kneeLoc
    global ankleLoc
    global footLoc</pre></div><p>Now we're ready to create the locators. Locators are especially useful for rigging because they provide a bare-bones transform node that is nonrenderable, but easily selectable in Maya's interface.</p><p>To make a locator, we can use the <code class="literal">spaceLocator</code> command. We'll use the name flag to set the name of created locator, but this is mainly just to make things nice for the end user.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip05"/>Tip</h3><p>Although it is sometimes nice to give created nodes names, you should never rely on those names for later reference, as there's no guarantee that the name you specify is the name that the object will end up with. If you name something <code class="literal">myObject</code>, but there's already a node in your scene by that name, Maya will force the newly created object to be named <code class="literal">myObject1</code>, and any code that you wrote referencing <code class="literal">myObject</code> would be pointed at the wrong thing. Never, ever, trust names in Maya; instead store the output of commands that create nodes to variables and use those variables to refer to the created objects.</p></div></div><p>We'll <a id="id227" class="indexterm"/>create four locators in total, one each for the hip, knee, ankle, and toe of a simple leg. The output of each of our calls to the <code class="literal">spaceLocator</code> command is saved to one of our global variables:</p><div class="informalexample"><pre class="programlisting">    hipLoc = cmds.spaceLocator(name="HipLoc")
    kneeLoc = cmds.spaceLocator(name="KneeLoc")
    ankleLoc = cmds.spaceLocator(name="AnkleLoc")
    footLoc = cmds.spaceLocator(name="FootLoc")</pre></div><p>If you look at the documentation for the <code class="literal">spaceLocator</code> command, you'll see that there is a <code class="literal">position</code> flag that can be used to set the position of the created locator. However, note that we're not using that flag in the previous code. This's because while the locator will appear to be at the specified position, the pivot point for the locator will remain at the origin. Since we're creating the locators specifically to use them to grab positions in world space, which makes things difficult for us.</p><p>There's an easy workaround, though we'll just leave the position unspecified, which will cause both the locator and its pivot to be at the origin, then use the <code class="literal">xform</code> (short for "transform") command to set the position of each locator to a reasonable starting position. This ends up looking like the following:</p><div class="informalexample"><pre class="programlisting">cmds.xform(kneeLoc, absolute=True, translation=(0, 5, 0))
cmds.xform(hipLoc, absolute=True, translation=(0, 10, 0))
cmds.xform(footLoc, absolute=True, translation=(2, 0, 0))</pre></div><p>The <code class="literal">xform</code> command <a id="id228" class="indexterm"/>can be used in several different ways, all related to querying or altering the transform (position, rotation, and scale) values of nodes. In this case, we're using it to set the translation of the locators to set values. We also set the absolute flag to true to indicate that the values represent where the locator should be moved to in absolute coordinates (as opposed to a relative displacement from its current position).</p><p>We move the hip joint up a bit, the knee joint up half as far, and the foot (toe) joint forward a bit on the <span class="emphasis"><em>x</em></span> axis. The ankle joint is left at the origin.</p><div class="mediaobject"><img src="graphics/4657_05_06.jpg" alt="How it works..."/></div><p>Once we've set up the necessary locators, the user can then adjust their position to better match the specifics of the model to which the joints will be applied. Once that's been done, we can move on to creating joints and setting up the IK system, which we handle in the <code class="literal">setupIK</code> function.</p><p>First off, we need to invoke our global variables so that we can grab the positions of the locators and create bones at the positions of each one. We also clear out our selection, just to be on the safe side. We're about to create bones and we don't want our newly created joints to be children of any joints that might be selected when the user runs this part of the script. Once again, we use the global keyword to specify that we mean the variables that are in global scope instead of local variables:</p><div class="informalexample"><pre class="programlisting">    global hipLoc
    global kneeLoc
    global ankleLoc
    global footLoc

    cmds.select(clear=True)</pre></div><p>Once <a id="id229" class="indexterm"/>we've done all this, we're ready to make the bones. For each bone, we'll need to first determine the world-space position of each of our locators, which we can do with the <code class="literal">xform</code> command. By calling xform in the query mode, we'll retrieve, rather than set, the position of our locators. We'll also make sure to set the <code class="literal">worldSpace</code> flag to true to get the true (world space) position of the locators, rather than their local position.</p><p>We'll start with the hip locator and work our way down our list of locators, grabbing each one's location and feeding it into the <code class="literal">joint</code> command to create the bone:</p><div class="informalexample"><pre class="programlisting">    pos = cmds.xform(hipLoc, query=True, translation=True, worldSpace=True)
    hipJoint = cmds.joint(name="hipBone", position=pos)

    pos = cmds.xform(kneeLoc, query=True, translation=True, worldSpace=True)
    kneeJoint = cmds.joint(name="kneeBone",position=pos)

    pos = cmds.xform(ankleLoc, query=True, translation=True, worldSpace=True)
    ankleJoint = cmds.joint(name="akleBone", position=pos)

    pos = cmds.xform(footLoc, query=True, translation=True, worldSpace=True)
    footJoint = cmds.joint(name="footBone", position=pos)</pre></div><p>Once again, we rely on Maya's default behavior of automatically connecting joints to build the skeleton. Once all the joints have been created, we can finally create the IK system.</p><p>Setting up IK is actually really straightforward; all we have to do it to call the <code class="literal">ikHandle</code> command and specify the appropriate start and end joints with the <code class="literal">startJoint</code> and <code class="literal">endEffector</code> flags. In our case, we'll want the IK system to run from the hip to the ankle. Translating that into code ends up looking like the following:</p><div class="informalexample"><pre class="programlisting">cmds.ikHandle(startJoint=hipJoint, endEffector=ankleJoint)</pre></div><p>Once we've done this, we'll be left with a brand new IK system.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec120"/>There's more...</h2></div></div></div><p>Although this example covers the basics of creating a joint chain from locators and adding an IK handle, there are a number of additional things needed to finish it off. To set up a real IK system, you'll likely want to constrain the behavior of each of the joints in the chain (knee joints, for example, should only rotate around a single axis).</p><p>Properly <a id="id230" class="indexterm"/>constraining the joints in an IK system generally involves at least two things—locking attributes that shouldn't rotate at all and setting limits on the axes that <span class="emphasis"><em>should</em></span> rotate so that a joint that should be a knee doesn't bend in the wrong direction.</p><p>To prevent a joint from rotating at all around a given axis, we can set the relevant <code class="literal">jointType</code> attribute to 0 to completely disable rotation around that axis. For example, if we wanted to make sure that our knee joint is prevented from rotating around either the <span class="emphasis"><em>x</em></span> or <span class="emphasis"><em>y</em></span> axes, we could do the following:</p><div class="informalexample"><pre class="programlisting">    cmds.setAttr(kneeJoint + ".jointTypeX", 0)
    cmds.setAttr(kneeJoint + ".jointTypeY", 0)</pre></div><p>This will completely prevent any rotation around the <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>y</em></span> axes. For the remaining axis (<span class="emphasis"><em>z</em></span>, in this case), we would likely want to limit the rotation to a specific range. For this, we could use the <code class="literal">transformLimits</code> command, which will allow us to set minimum and maximum values for rotation.</p><p>To make use of the <code class="literal">transformLimits</code> command, we'll need to not only specify the specific minimum and maximums, but we'll also need to enable the limits. This is similar to what one sees when setting joint limits in the attribute editor, that is, the values for the minimums and maximums don't actually apply unless you've <span class="emphasis"><em>also</em></span> clicked the checkboxes to enable limits.</p><p>Let's say that we wanted the knee to only rotate from -90 to 0 degrees. We could set that up with the following line of code:</p><div class="informalexample"><pre class="programlisting">    cmds.transformLimits(kneeJoint, rotationZ=(-90, 0), enableRotationZ=(1,1))</pre></div><p>The <code class="literal">rotationZ</code> flag in the preceding code is used to set the minimum and maximum values for the given node. The <code class="literal">enableRotationZ</code> is somewhat confusingly named, in that it really controls the setting of rotation <span class="emphasis"><em>limits</em></span>. So, passing (1, 1) into <code class="literal">enableRotationZ</code> means that we're enabling limits for both the minimum and maximum values. If we wanted to only have a minimum (but no maximum) value, we could do the following instead:</p><div class="informalexample"><pre class="programlisting">    cmds.transformLimits(kneeJoint, rotationZ=(-90, 0), enableRotationZ=(1,0))</pre></div><p>In the preceding code, the (1,0) passed to <code class="literal">enableRotationZ</code> would both enable a minimum limit and disable the maximum.</p></div></div></body></html>