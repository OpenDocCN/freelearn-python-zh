- en: Designing for High Performance
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为高性能设计
- en: In the earlier chapters, we learned how to use the vast array of tools available
    in Python's standard library and third-party packages to assess and improve the
    performance of Python applications. In this chapter, we will provide some general
    guidelines on how to approach different kinds of applications as well as illustrate
    some good practices that are commonly adopted by several Python projects.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们学习了如何使用 Python 标准库和第三方包中可用的各种工具来评估和改进 Python 应用程序的性能。在本章中，我们将提供一些关于如何处理不同类型应用程序的一般性指南，并展示一些被多个
    Python 项目普遍采用的优秀实践。
- en: 'In this chapter, we will learn the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习以下内容：
- en: Picking the right performance technique for generic, number crunching, and big
    data applications
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为通用、数值计算和大数据应用选择正确的性能技术
- en: Structuring a Python project
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构化 Python 项目
- en: Isolating Python installations with virtual environments and containerization
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用虚拟环境和容器化隔离 Python 安装
- en: Setting up continuous integration with Travis CI
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Travis CI 设置持续集成
- en: Choosing a suitable strategy
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择合适的策略
- en: Many packages are available for improving the performance of programs, but how
    do we determine the best optimization strategy for our program? A variety of factors
    dictate the decision on which method to use. In this section, we will try to answer
    this question as comprehensively as possible, based on broad application categories.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 许多软件包可用于提高程序的性能，但我们如何确定我们程序的最佳优化策略？多种因素决定了使用哪种方法的决策。在本节中，我们将尽可能全面地回答这个问题，基于广泛的应用类别。
- en: The first aspect to take into consideration is the type of application. Python
    is a language that serves multiple and very diverse communities that span web
    services, system scripting, games, machine learning, and much more. Those different
    applications will require optimization efforts for different parts of the program.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要考虑的是应用程序的类型。Python 是一种服务于多个非常多样化的社区的语言，这些社区包括网络服务、系统脚本、游戏、机器学习等等。这些不同的应用程序将需要对程序的不同部分进行优化努力。
- en: For example, a web service can be optimized to have a very short response time.
    Also, it has to be able to answer as many requests as possible using as little
    resources as possible (that is, it will try to achieve lower latency), while numerical
    code may require weeks to run. It's important to improve the amount of data the
    system may process, even if there's a significant start up overhead (in this case,
    we are interested in throughput).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个网络服务可以被优化以拥有非常短的反应时间。同时，它必须能够尽可能少地使用资源来回答尽可能多的请求（也就是说，它将尝试实现更低的延迟），而数值代码可能需要几周时间才能运行。即使有显著的启动开销（在这种情况下，我们感兴趣的是吞吐量），提高系统可能处理的数据量也很重要。
- en: Another aspect is the platform and architecture we are developing for. While
    Python has support for a lot of platforms and architectures, many of the third-party
    libraries may have limited support for certain platforms, especially when dealing
    with packages that bind into C extensions. For this reason, it's necessary to
    check the availability of libraries for the target platforms and architectures.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个方面是我们正在开发的平台和架构。虽然 Python 支持许多平台和架构，但许多第三方库可能对某些平台的支持有限，尤其是在处理绑定到 C 扩展的包时。因此，有必要检查目标平台和架构上库的可用性。
- en: Also, some architectures, such as embedded systems and small devices, may have
    severe CPU and memory restrictions. This is an important factor to take into consideration
    as, for instance, some techniques (such as multiprocessing) may consume too much
    memory or require the execution of additional software.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，一些架构，如嵌入式系统和小型设备，可能存在严重的 CPU 和内存限制。这是一个需要考虑的重要因素，例如，一些技术（如多进程）可能会消耗太多内存或需要执行额外的软件。
- en: Finally, the business requirements are equally important. Many times, software
    products require fast iterations and the ability to change the code quickly. Generally
    speaking, you want to keep your software stack as minimal as possible so that
    modification, testing, deployment, and introducing additional platform support
    becomes easy and feasible in a short period of time. This also applies to the
    team--installing the software stack and starting the development should be as
    smooth as possible. For this reason, one should generally prefer pure Python libraries
    over extensions, with the possible exception of solid, battle-tested libraries,
    such as NumPy. Additionally, various business aspects will help determine which
    operations need to be optimized first (always remember that *premature optimization
    is the root of all evil*).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，业务需求同样重要。很多时候，软件产品需要快速迭代和快速更改代码的能力。一般来说，您希望将软件栈保持尽可能简单，以便修改、测试、部署以及引入额外的平台支持在短时间内变得容易且可行。这也适用于团队——安装软件栈和开始开发应该尽可能顺利。因此，通常应优先选择纯Python库而不是扩展，除非是经过良好测试的库，如NumPy。此外，各种业务方面将有助于确定哪些操作需要首先优化（始终记住，*过早优化是万恶之源*）。
- en: Generic applications
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通用应用程序
- en: Generic applications, such as web apps or mobile app backends, usually involve
    calls to remote services and databases. For such cases, it can be useful to take
    advantage of asynchronous frameworks, such as the ones presented in [Chapter 6](2b46e5c0-5308-4073-b1c6-4232a881b39f.xhtml),
    *Implementing Concurrency*; this will improve application logic, system design,
    responsiveness and, also, it will simplify the handling of network failures.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 通用应用程序，例如Web应用程序或移动应用程序后端，通常涉及对远程服务和数据库的调用。对于此类情况，利用异步框架可能很有用，例如在第6章中介绍的框架，*实现并发*；这将提高应用程序逻辑、系统设计、响应性，并且，它还将简化网络故障的处理。
- en: Use of asynchronous programming also makes it easier to implement and use microservices.
    A **microservice**, although there is no standard definition, can be thought of
    as a remote service that focuses on a specific aspect of the application (for
    example, authentication).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 异步编程的使用也使得实现和使用微服务变得更加容易。虽然没有标准定义，但可以将**微服务**视为专注于应用程序特定方面（例如，认证）的远程服务。
- en: The idea behind microservices is that you can build an application by composing
    different microservices that communicate through a simple protocol (such as gRPC,
    REST calls, or through a dedicated message queue). This architecture is in contrast
    with a monolithic application where all the services are handled by the same Python
    process.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务的理念是您可以通过组合通过简单协议（例如gRPC、REST调用或通过专用消息队列）通信的不同微服务来构建应用程序。这种架构与所有服务都由同一Python进程处理的单体应用程序形成对比。
- en: Advantages of microservices include strong decoupling of different parts of
    the application. Small, simple services can be implemented and maintained by different
    teams as well as be updated and deployed at different times. This also allows
    microservices to be easily replicated so that they can handle more users. Additionally,
    since the communication is done through a simple protocol, microservices can be
    implemented in a different language that can be more appropriate than Python for
    the specific application.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务的优势包括应用程序不同部分之间的强解耦。小型、简单的服务可以由不同的团队实现和维护，并且可以在不同时间更新和部署。这也使得微服务可以轻松复制，以便处理更多用户。此外，由于通信是通过简单的协议进行的，因此微服务可以用更适合特定应用程序的语言实现。
- en: If the performance of a service is not satisfactory, the application can often
    be executed on a different Python interpreter, such as PyPy (provided that all
    the third-party extensions are compatible) to achieve sufficient speed gains.
    Otherwise, algorithmic strategies as well as porting bottlenecks to Cython is
    generally sufficient to achieve satisfactory performance.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果服务的性能不满意，应用程序通常可以在不同的Python解释器上执行，例如PyPy（前提是所有第三方扩展都兼容）以实现足够的速度提升。否则，算法策略以及将瓶颈迁移到Cython通常足以实现令人满意的表现。
- en: Numerical code
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数值代码
- en: If your goal is to write numerical code, an excellent strategy is to start directly
    with a NumPy implementation. Using NumPy is a safe bet because it is available
    and tested on many platforms and, as we have seen in the earlier chapters, many
    other packages treat NumPy arrays as first-class citizens.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的目标是编写数值代码，一个很好的策略是直接从 NumPy 实现开始。使用 NumPy 是一个安全的赌注，因为它在许多平台上都可用且经过测试，并且，如我们在前面的章节中看到的，许多其他包将
    NumPy 数组视为一等公民。
- en: When properly written (such as by taking advantage of broadcasting and other
    techniques we learned in [Chapter 2](68a7c14e-5270-49a5-862e-96cf59cddf60.xhtml),
    *Pure Python Optimizations*), NumPy performance is already quite close to the
    native performance achievable by C code, and won't require further optimization.
    That said, certain algorithms are hard to express efficiently using NumPy's data
    structures and methods. When this happens, two very good options can be, for example,
    Numba or Cython.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当正确编写时（例如，通过利用我们在第 2 章中学习的广播和其他技术，*纯 Python 优化*），NumPy 的性能已经非常接近由 C 代码实现的本地性能，并且不需要进一步优化。尽管如此，某些算法使用
    NumPy 的数据结构和方法难以高效表达。当这种情况发生时，两个非常好的选择可以是 Numba 或 Cython。
- en: Cython is a very mature tool used intensely by many important projects, such
    as `scipy` and `scikit-learn`. Cython code, with its explicit, static type declarations,
    makes it very understandable, and most Python programmers will have no problem
    picking up its familiar syntax. Additionally, the absence of "magic" and good
    inspection tools make it easy for the programmer to predict its performance and
    have educated guesses as to what to change to achieve maximum performance.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Cython 是一个非常成熟的工具，被许多重要项目广泛使用，例如 `scipy` 和 `scikit-learn`。Cython 代码通过其明确的静态类型声明，使其非常易于理解，大多数
    Python 程序员都不会在掌握其熟悉的语法上遇到问题。此外，没有“魔法”和良好的检查工具使得程序员可以轻松预测其性能，并对如何进行更改以实现最佳性能做出有根据的猜测。
- en: Cython, however, has some drawbacks. Cython code needs to be compiled before
    it can be executed, thus breaking the convenience of the Python edit-run cycle.
    This also requires the availability of a compatible C compiler for the target
    platform.  This also complicates distribution and deployment, as multiple platforms,
    architectures, configurations, and compilers need to be tested for every target.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Cython 也有一些缺点。Cython 代码在执行之前需要编译，这打破了 Python 编辑-运行周期的便利性。这也要求目标平台上有兼容的 C
    编译器。这还使得分发和部署变得复杂，因为需要为每个目标平台测试多个平台、架构、配置和编译器。
- en: On the other hand, Numba API requires only the definition of pure-Python functions,
    which get compiled on the fly, maintaining the fast Python edit-run cycle. In
    general, Numba requires a LLVM toolchain installation to be available on the target
    platform. Note that, as of version 0.30, there is some limited support for **Ahead-Of-Time**
    (**AOT**) compilation of Numba functions so that Numba-compiled functions can
    be packaged and deployed without requiring a Numba and LLVM installation.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，Numba API 只需要定义纯 Python 函数，这些函数会即时编译，保持快速的 Python 编辑-运行周期。一般来说，Numba 需要在目标平台上安装
    LLVM 工具链。请注意，截至版本 0.30，Numba 函数的**即时编译**（**AOT**）有一些有限的支持，这样 Numba 编译的函数就可以打包和部署，而无需安装
    Numba 和 LLVM。
- en: Note that both Numba and Cython are usually available pre-packaged with all
    of their dependencies (including compilers) on the default channels of the conda
    package manager. Therefore, deployment of Cython can be greatly simplified on
    the platforms where the conda package manager is available.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Numba 和 Cython 通常都预包装了所有依赖项（包括编译器），可以在 conda 包管理器的默认通道中找到。因此，在 conda 包管理器可用的平台上，Cython
    的部署可以大大简化。
- en: What if Cython and Numba are still not enough? While this is generally not required,
    an additional strategy would be to implement a pure C module (which can be further
    optimized using compiler flags or hand-tuning) and use it from a Python module
    using either the `cffi` package ([https://cffi.readthedocs.io/en/latest/](https://cffi.readthedocs.io/en/latest/))
    or Cython.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 Cython 和 Numba 仍然不够用怎么办？虽然这通常不是必需的，但另一种策略是实现一个纯 C 模块（可以使用编译器标志或手动调整进行进一步优化），然后使用
    `cffi` 包（[https://cffi.readthedocs.io/en/latest/](https://cffi.readthedocs.io/en/latest/))
    或 Cython 从 Python 模块中调用它。
- en: Using NumPy, Numba, and Cython is a very effective strategy to obtain near-optimal
    performance on serial codes. For many applications, serial codes are certainly
    enough and, even if the ultimate plan is to have a parallel algorithm, it’s still
    very worthy working on a serial reference implementation for debugging purposes
    and because a serial implementation is likely to be faster on small datasets.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 NumPy、Numba 和 Cython 是在串行代码上获得近似最优性能的有效策略。对于许多应用来说，串行代码当然足够了，即使最终计划是拥有并行算法，仍然非常值得为调试目的而工作在串行参考实现上，因为串行实现在小数据集上可能更快。
- en: Parallel implementations vary considerably in complexity depending on the particular
    application. In many cases, the program can be easily expressed as a series of
    independent calculations followed by some sort of *aggregation* and is parallelizable
    using simple process-based interfaces, such as `multiprocessing.Pool` or `ProcessPoolExecutor`,
    which have the advantage of being able to execute generic Python code in parallel
    without much trouble.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 并行实现根据特定应用的复杂性有很大差异。在许多情况下，程序可以很容易地表示为一系列独立的计算，随后进行某种形式的*聚合*，并可以使用简单的基于进程的接口进行并行化，例如
    `multiprocessing.Pool` 或 `ProcessPoolExecutor`，这些接口的优点是能够在不费太多周折的情况下并行执行通用 Python
    代码。
- en: To avoid the time and memory overhead of starting multiple processes, one can
    use threads. NumPy functions typically release the GIL and are good candidates
    for thread-base parallelization. Additionally, Cython and Numba provide special `nogil` statements
    as well as automatic parallelization, which makes them suitable for simple, lightweight
    parallelization.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免启动多个进程的时间和内存开销，可以使用线程。NumPy 函数通常释放 GIL，是线程并行化的良好候选者。此外，Cython 和 Numba 提供特殊的
    `nogil` 语句以及自动并行化，这使得它们适合简单的、轻量级的并行化。
- en: For more complex use cases, you may have to change the algorithm significantly.
    In those cases, Dask arrays are a decent option, which provide an almost-drop-in
    replacement for standard NumPy. Dask has the further advantage of operating very
    transparently and is easy to tweak.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更复杂的用例，你可能需要显著改变算法。在这些情况下，Dask 数组是一个不错的选择，它们几乎可以无缝替换标准的 NumPy。Dask 的进一步优势是操作非常透明，并且易于调整。
- en: Specialized applications that make intensive use of linear algebra routines
    (such as deep learning and computer graphics) may benefit from packages such as
    Theano and Tensorflow, which are capable of highly performant and automatic parallelization
    with built-in GPU support.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 专门的应用程序，如深度学习和计算机图形学，它们大量使用线性代数例程，可能从 Theano 和 Tensorflow 等软件包中受益，这些软件包能够实现高度性能的自动并行化，并内置
    GPU 支持。
- en: Finally, `mpi4py` usage can be used for deploying parallel python scripts on
    a MPI-based supercomputer (commonly available for researchers in universities).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，可以使用 `mpi4py` 在基于 MPI 的超级计算机上部署并行 Python 脚本（通常大学的研究人员可以访问）。
- en: Big data
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 大数据
- en: Large datasets (typically larger than 1 TB) are becoming increasingly common
    and a lot of resources have been invested in developing technologies capable of
    collecting, storing, and analyzing them. Typically, the choice of which framework
    to use is bound to how the data is stored in the first place.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 大型数据集（通常大于 1 TB）变得越来越普遍，大量资源已经投入到了开发能够收集、存储和分析这些数据的技术中。通常，选择使用哪个框架取决于数据最初是如何存储的。
- en: Many times, even if the complete dataset doesn't fit in a single machine, it
    is still possible to devise strategies to extract the answers without having to
    probe the whole dataset. For example, it is quite often possible to answer questions
    by extracting a small, interesting subset of data that can be easily loaded in
    memory and analyzed with highly convenient and performant libraries, such as Pandas.
    By filtering or randomly sampling data points, one can often find a good enough
    answer to a business question without having to resort to big data tools.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 许多时候，即使完整的数据集不适合单个机器，仍然可以制定策略来提取答案，而无需探测整个数据集。例如，经常可以通过提取一个小的、有趣的数据子集来回答问题，这些数据子集可以轻松加载到内存中，并使用高度方便和高效的库（如
    Pandas）进行分析。通过过滤或随机采样数据点，通常可以找到足够好的答案来回答业务问题，而无需求助于大数据工具。
- en: If the bulk of the company's software is written in Python, and you have the
    freedom to decide your software stack, it would make sense to use Dask distributed.
    The software package has a very simple setup and is tightly integrated with the
    Python ecosystem. Using something such as Dask `array` and `DataFrame`, it's very
    easy to scale your already-existing Python algorithms by adapting NumPy and Pandas
    code.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果公司的软件主体是用 Python 编写的，并且你有自由选择软件栈的权限，那么使用 Dask 分布式是有意义的。这个软件包的设置非常简单，并且与 Python
    生态系统紧密集成。使用 Dask 的 `array` 和 `DataFrame`，通过适配 NumPy 和 Pandas 代码，可以非常容易地扩展你现有的
    Python 算法。
- en: Quite often, some companies may have already set up a Spark cluster. In this
    case, PySpark is the optimal choice, and the use of SparkSQL is encouraged for
    higher performance. One of the Spark advantages is that it allows the use of other
    languages, such as Scala and Java.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 很常见，一些公司可能已经设置了一个 Spark 集群。在这种情况下，PySpark 是最佳选择，并且鼓励使用 SparkSQL 以获得更高的性能。Spark
    的一个优点是它允许使用其他语言，例如 Scala 和 Java。
- en: Organizing your source code
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组织你的源代码
- en: The repository structure of a typical Python project consists, at a minimum,
    of a directory containing a `README.md` file, a Python module or package containing
    the source code for the application or library, and a `setup.py` file. Projects
    may also adopt different conventions to comply with company policies or specific
    frameworks in use. In this section, we will illustrate some common practices that
    are commonly found in community-driven Python projects which can include some
    of the tools we illustrated in the earlier chapters.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的 Python 项目的仓库结构至少包括一个包含 `README.md` 文件的目录、一个包含应用程序或库源代码的 Python 模块或包，以及一个
    `setup.py` 文件。项目可能采用不同的约定来遵守公司政策或使用的特定框架。在本节中，我们将说明一些在社区驱动的 Python 项目中常见的实践，这些实践可能包括我们在前面章节中介绍的一些工具。
- en: 'A typical directory structure for a Python project named  `myapp` can look
    like this. Now, we will elucidate the role of each file and directory:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 一个名为 `myapp` 的 Python 项目的典型目录结构可以看起来像这样。现在，我们将阐述每个文件和目录的作用：
- en: '[PRE0]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`README.md` is a text file that contains general information about the software,
    such as project scope, installation, a quick start, and useful links. If the software
    is released to the public, a `LICENSE` file is used to specify terms and conditions
    for its usage.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`README.md` 是一个包含有关软件的一般信息的文本文件，例如项目范围、安装、快速入门和有用的链接。如果软件公开发布，则使用 `LICENSE`
    文件来指定其使用的条款和条件。'
- en: Python software is commonly packaged using the `setuptools` library in a `setup.py`
    file. As we have seen in the earlier chapters, `setup.py` is also an effective
    way to compile and distribute Cython code.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Python 软件通常使用 `setup.py` 文件中的 `setuptools` 库进行打包。正如我们在前面的章节中看到的，`setup.py` 也是编译和分发
    Cython 代码的有效方式。
- en: The `myapp` package contains the source code for the application, including
    Cython modules. Sometimes, it's convenient to maintain pure-Python implementations
    besides their Cython-optimized counterparts. Commonly, the Cython version of a
    module is named with a c prefix (such as `cmodule1.pyx` in the preceding example).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`myapp` 包包含应用程序的源代码，包括 Cython 模块。有时，除了它们的 Cython 优化版本之外，维护纯 Python 实现也很方便。通常，模块的
    Cython 版本以 c 前缀命名（例如，前一个示例中的 `cmodule1.pyx`）。'
- en: If the external `.c` and `.h` files are needed, those are usually stored under
    an additional `src/` directory placed in the top-level (`myapp`) project directory.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要外部 `.c` 和 `.h` 文件，这些文件通常存储在顶级（`myapp`）项目目录下的一个额外的 `src/` 目录中。
- en: The `tests/` directory contains testing code for application (usually in the
    form of unit tests), which can be run using a test runner, such as `unittest`
    or `pytest`. However, some projects prefer to place the `tests/` directory inside
    the `myapp` package. Since high-performance code is tweaked and rewritten continuously,
    having a solid test suite is crucial to spot bugs as early as possible and to
    improve the developer experience by shortening the test-edit-run cycle.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`tests/` 目录包含应用程序的测试代码（通常以单元测试的形式），可以使用测试运行器（如 `unittest` 或 `pytest`）运行。然而，一些项目更喜欢将
    `tests/` 目录放置在 `myapp` 包内部。由于高性能代码是持续调整和重写的，因此拥有一个可靠的测试套件对于尽早发现错误和通过缩短测试-编辑-运行周期来提高开发者体验至关重要。'
- en: Benchmarks can be placed in the `benchmarks` directory; the advantage of having
    benchmarks separated from tests is that benchmarks can potentially take more time
    to execute. Benchmarks can also be run on a build server (see the *Continuous
    integration* section) as a simple mean to compare the performance of versions.
    While benchmarks usually take longer to run than unit tests, it's best to keep
    their execution as short as possible to avoid waste of resources.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 基准测试可以放在`benchmarks`目录中；将基准测试与测试分离的优势在于，基准测试可能需要更多的时间来执行。基准测试也可以在构建服务器上运行（见*持续集成*部分），作为一种简单的方法来比较不同版本的性能。虽然基准测试通常比单元测试运行时间更长，但最好将它们的执行时间尽可能缩短，以避免资源浪费。
- en: Finally, the `docs/` directory contains user and developer documentation and
    API references. This usually also includes configuration files for documentation
    tools, such as `sphinx`. Other tools and scripts can be placed in the `tools/`
    directory.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`docs/`目录包含用户和开发者文档以及API参考。这通常还包括文档工具的配置文件，例如`sphinx`。其他工具和脚本可以放在`tools/`目录中。
- en: Isolation, virtual environments, and containers
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 隔离、虚拟环境和容器
- en: The importance of having isolated environments for code testing and execution
    becomes quite apparent by noticing what happens when you ask a friend to run one
    of your Python scripts. What happens is that you provide instructions to install
    Python version X and dependent packages `Y`, `X`, and ask them to copy and execute
    the script on their machine.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码测试和执行时拥有隔离环境的重要性，通过观察当你请求朋友运行你的一个Python脚本时会发生什么，就会变得非常明显。发生的情况是，你提供安装Python版本X及其依赖包`Y`、`X`的指令，并要求他们在自己的机器上复制并执行该脚本。
- en: In many cases, your friend will proceed and download Python for its platform
    as well as the dependent libraries and try to execute the script. However, it
    can happen (more often than not) that the script will fail because either their
    computer has a different operating system than yours, or the installed libraries
    are not the same version as the one you installed on your machine. At other times,
    there can be previous installations that are improperly removed and will cause
    hard-to-debug conflicts and a lot of frustration.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，你的朋友会继续操作，为其平台下载Python以及依赖库，并尝试执行脚本。然而，可能会发生（很多时候都会发生）脚本会失败，因为他们的计算机操作系统与你不同，或者安装的库版本与你机器上安装的版本不同。在其他时候，可能会有不正确删除的先前安装，这会导致难以调试的冲突和很多挫败感。
- en: A very easy way to avoid this scenario is to use virtual environments. Virtual
    environments are used to create and manage several Python installations by isolating
    Python, related executables, and third-party packages. Since Python's 3.3 version,
    the standard library includes the `venv` module (previously known as **virtualenv**),
    which is a tool designed to create and manage simple isolated environments. Python
    packages in `venv`-based virtual environments can be installed using `setup.py`
    files or through `pip`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 避免这种情况的一个非常简单的方法是使用虚拟环境。虚拟环境通过隔离Python、相关可执行文件和第三方包来创建和管理多个Python安装。自Python
    3.3版本以来，标准库包括了`venv`模块（之前称为**virtualenv**），这是一个用于创建和管理简单隔离环境的工具。基于`venv`的虚拟环境中的Python包可以使用`setup.py`文件或通过`pip`进行安装。
- en: Providing exact and specific library versions is crucial when dealing with high-performance
    code. Libraries evolve all the time between releases and changes in the algorithms
    may dramatically affect the performance. For instance, popular libraries, such
    as `scipy` and `scikit-learn`, often port some of their codes and data structures
    to Cython, so it's really important that the user installs the correct version
    for optimal performance.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理高性能代码时，提供精确和具体的库版本至关重要。库在发布之间不断进化，算法的变化可能会显著影响性能。例如，流行的库，如`scipy`和`scikit-learn`，通常会将其部分代码和数据结构移植到Cython，因此用户安装正确的版本以获得最佳性能非常重要。
- en: Using conda environments
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用conda环境
- en: Most of the time, using `venv` is a fine choice. However, when writing high-performance
    code, it often happens that some high-performance libraries also require non-Python
    software to be installed. This typically involves additional setting up of compilers
    and high-performance native libraries (in C, C++, or Fortran) to which Python
    packages link. As `venv` and `pip` are designed to deal with Python packages only,
    this scenario is poorly supported by these tools.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，使用`venv`是一个不错的选择。然而，当编写高性能代码时，通常会发生一些高性能库也需要安装非Python软件的情况。这通常涉及额外的设置编译器和高性能本地库（在C、C++或Fortran中），Python软件包会链接到这些库。由于`venv`和`pip`旨在仅处理Python软件包，因此这些工具对这种场景的支持不佳。
- en: 'The `conda` package manager was created specifically to handle such cases.
    Creating a virtual environment with conda can be done using the `conda create`
    command. The command takes a `-n` argument (`-n` stands for `--name`) that specifies
    an identifier for the newly created environment and the packages we intend to
    install. If we wish to create an environment that uses python version `3.5` and
    the latest version of NumPy, we use the following command:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`conda`软件包管理器是专门为处理此类情况而创建的。可以使用`conda create`命令创建虚拟环境。该命令接受`-n`参数（`-n`代表`--name`），用于指定新创建的环境和我们要安装的软件包。如果我们想创建一个使用Python版本`3.5`和最新版NumPy的环境，我们可以使用以下命令：'
- en: '[PRE1]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Conda will take care of fetching the relative packages from their repositories
    and placing them in an isolated Python installation. To enable the virtual environment,
    you can use the `source activate` command:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Conda将负责从其存储库获取相关软件包并将它们放置在隔离的Python安装中。要启用虚拟环境，可以使用`source activate`命令：
- en: '[PRE2]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'After executing this command, the default Python interpreter will be switched
    to the version we specified earlier. You can easily verify the location of your
    Python executable using the `which` command, which returns the full path of the
    executable:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此命令后，默认Python解释器将切换到我们之前指定的版本。你可以使用`which`命令轻松验证Python可执行文件的位置，该命令返回可执行文件的全路径：
- en: '[PRE3]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: At this point, you are free to add, remove, and modify packages in the virtual
    environment without affecting the global Python installation. Further packages
    can be installed using the `conda install <package name>` command or through `pip`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你可以自由地在虚拟环境中添加、删除和修改软件包，而不会影响全局Python安装。可以使用`conda install <package name>`命令或通过`pip`安装更多软件包。
- en: The beauty of virtual environments is that you can install or compile any software
    you want in a well-isolated fashion. This means that if, for some reason, your
    environment gets corrupted, you can scratch it and start from zero.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟环境的优点在于，你可以以良好的隔离方式安装或编译你想要的任何软件。这意味着，如果由于某种原因，你的环境被损坏，你可以将其擦除并从头开始。
- en: 'To remove the `myenv` environment, you first need to deactivate it, and then
    use the `conda env remove` command, as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除`myenv`环境，首先需要将其停用，然后使用`conda env remove`命令，如下所示：
- en: '[PRE4]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'What if a package is not available on the standard `conda` repositories? One
    option is to look whether it is available in the `conda-forge` community channel.
    To search for a package in `conda-forge`, you can add the `-c` option (which stands
    for `--channel`) to the `conda search` command:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果软件包在标准`conda`存储库中不可用怎么办？一个选项是查看它是否在`conda-forge`社区频道中可用。要搜索`conda-forge`中的软件包，可以在`conda
    search`命令中添加`-c`选项（代表`--channel`）：
- en: '[PRE5]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The command will list a series of packages and versions available that match
    the `scipy` query string. Another option is to search for the package in the public
    channels hosted on **Anaconda Cloud**. The command-line client for Anaconda Cloud
    can be downloaded by installing the `anaconda-client` package:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令将列出与`scipy`查询字符串匹配的一系列软件包和版本。另一个选项是在**Anaconda Cloud**上托管公共频道中搜索该软件包。可以通过安装`anaconda-client`软件包来下载Anaconda
    Cloud的命令行客户端：
- en: '[PRE6]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Once the client is installed, you can use the `anaconda` command-line client
    to search for packages. In the following example, we demonstrate how to look for
    the `chemview` package:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端安装完成后，你可以使用`anaconda`命令行客户端来搜索软件包。在以下示例中，我们演示了如何查找`chemview`软件包：
- en: '[PRE7]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Installation can then be easily performed by specifying the appropriate channel
    with the `-c` option:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，可以通过指定适当的频道（使用`-c`选项）轻松执行安装：
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Virtualization and Containers
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 虚拟化和容器
- en: Virtualization has been around for a long time as a way to run multiple operating
    systems on the same machine in order to better utilize physical resources.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟化作为一种在同一台机器上运行多个操作系统以更好地利用物理资源的方法，已经存在很长时间了。
- en: One way to achieve virtualization is to employ a *virtual machine*. Virtual
    machines work by creating virtual hardware resources, such as CPU, memory, and
    devices, and use those to install and run multiple operating systems on the same
    machine. Virtualization can be accomplished by installing a hypervisor application
    on top of an operating system (called *host*). The hypervisor is capable of creating,
    managing, and monitoring virtual machines and their respective operating systems
    (called *guests*).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 实现虚拟化的一种方法是通过使用*虚拟机*。虚拟机通过创建虚拟硬件资源，例如CPU、内存和设备，并使用这些资源在同一台机器上安装和运行多个操作系统。通过在操作系统（称为*宿主*）上安装虚拟化软件（称为*管理程序*），可以实现虚拟化。管理程序能够创建、管理和监控虚拟机及其相应的操作系统（称为*客户机*）。
- en: It's important to note that virtual environments, despite their name, have nothing
    to do with virtual machines. A virtual environment is Python-specific and works
    by setting up different Python interpreters through shell scripts.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，尽管名为虚拟环境，但它们与虚拟机无关。虚拟环境是Python特定的，通过shell脚本设置不同的Python解释器来实现。
- en: Containers are a way to isolate an application by creating an environment separated
    from the host operating system and contain only the necessary dependencies. Containers
    are an operating system feature that allows you to share the hardware resources
    (provided by the operating system kernel) for multiple instances. A container
    is different from a virtual machine because it does not abstract hardware resources,
    but merely shares the operating system's kernel.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 容器是一种通过创建与宿主操作系统分离的环境并仅包含必要依赖项来隔离应用程序的方法。容器是操作系统功能，允许您共享由操作系统内核提供的硬件资源（多个实例）。与虚拟机不同，容器并不抽象硬件资源，而只是共享操作系统的内核。
- en: Containers are very efficient at utilizing hardware resources as those are accessed
    natively through the kernel. For this reason, they are an excellent solution for
    high-performance applications. They are also fast to create and destroy and can
    be used to quickly test an application in isolation. Containers are also used
    to simplify deployments (especially microservices) and to develop build servers,
    such as the ones we mentioned in the preceding section.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 容器在利用硬件资源方面非常高效，因为它们通过内核直接访问。因此，它们是高性能应用的绝佳解决方案。它们也易于创建和销毁，可以快速在隔离环境中测试应用程序。容器还用于简化部署（尤其是微服务）以及开发构建服务器，如前文所述。
- en: In [Chapter 8](95fc6212-c0ee-4dee-8d8a-56dc57fb6c97.xhtml), *Distributed Processing*,
    we used **docker** to easily set up a PySpark installation. Docker is one of the
    most popular containerization solutions available today. The best way to install
    docker is by following the instructions on the official website ([https://www.docker.com/](https://www.docker.com/)).
    After installation, it is possible to easily create and manage containers using
    the docker command-line interface.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](95fc6212-c0ee-4dee-8d8a-56dc57fb6c97.xhtml)“分布式处理”中，我们使用了**docker**来轻松设置PySpark安装。Docker是目前最受欢迎的容器化解决方案之一。安装Docker的最佳方式是遵循官方网站上的说明（[https://www.docker.com/](https://www.docker.com/)）。安装后，可以使用docker命令行界面轻松创建和管理容器。
- en: 'You can start a new container by using the `docker run` command. In the following
    example, we will demonstrate how to use `docker run` to execute a shell session
    in an Ubuntu 16.04 container. To do this, we will need to specify the following
    arguments:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`docker run`命令启动一个新的容器。在下面的示例中，我们将演示如何使用`docker run`在Ubuntu 16.04容器中执行shell会话。为此，我们需要指定以下参数：
- en: '`-i` specifies that we are trying to start an interactive session. It is also
    possible to execute individual docker commands without interactivity (for example,
    when starting a web server).'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-i`指定我们正在尝试启动一个交互式会话。也可以在不交互的情况下执行单个docker命令（例如，当启动Web服务器时）。'
- en: '`-t <image name>` specifies which system image to use. In the following example,
    we use the `ubuntu:16.04` image.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-t <image name>`指定要使用哪个系统镜像。在下面的示例中，我们使用`ubuntu:16.04`镜像。'
- en: '` /bin/bash`, which is the command to run inside the container, demonstrated
    as follows:'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '` /bin/bash`，这是在容器内运行的命令，如下所示：'
- en: '[PRE9]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This command will immediately take us into a separate, isolated shell where
    we can play around with the system and install software without touching the host
    operating system. Using a container is a very good way to test installations and
    deployments on different Linux flavors. After we are done with the interactive
    shell, we can type the `exit` command to return to the host system.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将立即带我们进入一个独立的、隔离的 shell，我们可以在其中与系统互动并安装软件，而不会触及主机操作系统。使用容器是测试不同 Linux 发行版上的安装和部署的非常好的方法。在完成交互式
    shell 的工作后，我们可以输入 `exit` 命令返回到主机系统。
- en: In the last chapter, we also made use of the port and detach options, `-p` and
    `-d`, to run the executable `pyspark`. The `-d` option simply asks Docker to run
    the command in the background. The `-p <host_port>:<guest_port>` option was, instead,
    necessary to map a network port of the host operating system to the guest system;
    without this option, the Jupyter Notebook would not have been reachable from a
    browser running in the host system.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们也使用了端口和分离选项 `-p` 和 `-d` 来运行可执行文件 `pyspark`。`-d` 选项只是要求 Docker 在后台运行命令。而
    `-p <host_port>:<guest_port>` 选项则是必要的，用于将主机操作系统的网络端口映射到客户系统；没有这个选项，Jupyter Notebook
    就无法从运行在主机系统中的浏览器访问。
- en: 'We can monitor the status of the containers with `docker ps`, as shown in the
    following snippet. The `-a` option (which stands for *all*) serves to output information
    about all the containers, whether they are currently running or not:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `docker ps` 监控容器的状态，如下面的片段所示。`-a` 选项（代表 *all*）用于输出有关所有容器的信息，无论它们当前是否正在运行：
- en: '[PRE10]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The information provided by `docker ps` includes a hexadecimal identifier, `585f53e77ce9`,
    as well as a human readable name, `pensive_hamilton`, both of which can be used
    to specify the container in other docker commands. It also includes additional
    information about the command executed, creation time, and the execution's current
    status.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker ps` 提供的信息包括一个十六进制标识符 `585f53e77ce9` 以及一个可读名称 `pensive_hamilton`，这两个都可以用于在其他
    Docker 命令中指定容器。它还包括有关执行命令、创建时间和执行当前状态的其他信息。'
- en: 'You can resume the execution of an exited container using the `docker start`
    command. To gain shell access to the container, you can use `docker attach`. Both
    these commands can be followed by either the container ID or its human readable
    name:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `docker start` 命令恢复已退出的容器的执行。要获取对容器的 shell 访问权限，您可以使用 `docker attach`。这两个命令都可以跟容器
    ID 或其可读名称：
- en: '[PRE11]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'A container can be easily removed using the `docker run` command followed by
    a container identifier:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `docker run` 命令后跟容器标识符轻松地删除容器：
- en: '[PRE12]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As you can see, you are free to execute commands, run, stop, and resume containers
    as needed, in less than a second. Using docker containers interactively is a great
    way to test things out and play with new packages without disturbing the host
    operating system. Since you can run many containers at the same time, docker can
    also be used to simulate a distributed system (for testing and learning purposes)
    without having to own an expensive computing cluster.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，您可以在不到一秒的时间内自由执行命令、运行、停止和恢复容器。使用 Docker 容器进行交互式操作是测试新包和进行实验的好方法，而不会干扰主机操作系统。由于您可以同时运行多个容器，Docker
    还可以用来模拟分布式系统（用于测试和学习目的），而无需拥有昂贵的计算集群。
- en: Docker also allows you to create your own system images, which is useful for
    distribution, testing, deployment, and documentation purposes. This will be the
    topic of the next subsection.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 还允许您创建自己的系统镜像，这对于分发、测试、部署和文档用途非常有用。这将是下一小节的主题。
- en: Creating docker images
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 Docker 镜像
- en: Docker images are ready-to-use, pre-configured systems. The `docker run` command
    can be used to access and install the docker images available on the **DockerHub**
    ([https://hub.docker.com/](https://hub.docker.com/)), a web service where package
    maintainers upload ready-to-use images to test and deploy various applications.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 镜像是现成的、预配置的系统。可以使用 `docker run` 命令访问和安装可在 **DockerHub** ([https://hub.docker.com/](https://hub.docker.com/))
    上找到的 Docker 镜像，这是一个维护者上传现成镜像以测试和部署各种应用程序的在线服务。
- en: 'One way to create a docker image is by using the `docker commit` command on
    an existing container. The docker commit command takes a container reference and
    the output image names as arguments:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 Docker 镜像的一种方法是在现有的容器上使用 `docker commit` 命令。`docker commit` 命令接受容器引用和输出镜像名称作为参数：
- en: '[PRE13]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Using this method is useful to save snapshots of a certain container but, if
    the image is removed from the system, the steps to recreate the image are lost
    as well.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法可以保存特定容器的快照，但如果图像从系统中删除，重新创建图像的步骤也会丢失。
- en: A better way to create an image is to build it using a **Dockerfile**. A Dockerfile
    is a text file that provides instructions on how to build an image starting from
    another image. As an example, we will illustrate the contents of the Dockerfile
    we used in the last chapter to set up PySpark with Jupyter notebook support. The
    complete file is reported here.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 创建图像的更好方法是使用**Dockerfile**构建。Dockerfile是一个文本文件，它提供了从另一个图像开始构建图像的指令。例如，我们将展示我们在上一章中用于设置带有Jupyter笔记本支持的PySpark的Dockerfile的内容。完整的文件如下所示。
- en: Each Dockerfile needs a starting image, which can be declared with the `FROM`
    command. In our case, the starting image is `jupyter/scipy-notebook`, which is
    available through DockerHub ([https://hub.docker.com/r/jupyter/scipy-notebook/](https://hub.docker.com/r/jupyter/scipy-notebook/)).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Dockerfile都需要一个起始图像，可以使用`FROM`命令声明。在我们的例子中，起始图像是`jupyter/scipy-notebook`，它可以通过DockerHub
    ([https://hub.docker.com/r/jupyter/scipy-notebook/](https://hub.docker.com/r/jupyter/scipy-notebook/))获取。
- en: 'Once we have defined our starting image, we can start issuing shell commands
    to install packages and perform other configurations using a series of `RUN` and
    `ENV` commands. In the following example, you can recognize installation of Java
    Runtime Environment (`openjdk-7-jre-headless`) as well as downloading Spark and
    setting up relevant environment variables. The `USER` instructions can be used to
    specify which user executes the subsequent commands:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们定义了起始图像，我们就可以开始使用一系列`RUN`和`ENV`命令来发出shell命令，安装包和执行其他配置。在下面的示例中，你可以识别出Java运行时环境（`openjdk-7-jre-headless`）的安装，以及下载Spark和设置相关环境变量。`USER`指令可以用来指定执行后续命令的用户：
- en: '[PRE14]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Dockerfiles can be used to create images using the following command from the
    directory where the Dockerfile is located. The `-t` option can be used to specify
    the tag that will be used to store the image. With the following line, we can
    create the image named `pyspark` from the preceding Dockerfile:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下命令从Dockerfile所在的目录创建图像。`-t`选项可以用来指定存储图像时使用的标签。以下行可以创建名为`pyspark`的图像，该图像来自前面的Dockerfile：
- en: '[PRE15]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The command will automatically retrieve the starting image, `jupyter/scipy-notebook`,
    and produce a new image, named `pyspark`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 命令将自动检索起始图像`jupyter/scipy-notebook`，并生成一个新图像，命名为`pyspark`。
- en: Continuous integration
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持续集成
- en: Continuous integration is a great way to ensure that the application stays bug-free
    at every development iteration. The main idea behind continuous integration is
    to run the test suite for the project very frequently, usually on a separate build
    server that pulls the code directly from the main project repository.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 持续集成是确保应用程序在每次开发迭代中保持无错误的好方法。持续集成背后的主要思想是频繁地运行项目的测试套件，通常在一个单独的构建服务器上，该服务器直接从主项目仓库拉取代码。
- en: Setting up a build server can be accomplished by manually setting up software such
    as Jenkins ([https://jenkins.io/](https://jenkins.io/)), Buildbot ([http://buildbot.net/](http://buildbot.net/)),
    and Drone ([https://github.com/drone/drone](https://github.com/drone/drone)) on
    a machine. This a convenient and cheap solution, especially for small teams and
    private projects.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在机器上手动设置Jenkins ([https://jenkins.io/](https://jenkins.io/))、Buildbot ([http://buildbot.net/](http://buildbot.net/))和Drone
    ([https://github.com/drone/drone](https://github.com/drone/drone))等软件来设置构建服务器可以完成。这是一个方便且成本低的解决方案，特别是对于小型团队和私人项目。
- en: Most open source projects take advantage of Travis CI ([https://travis-ci.org/](https://travis-ci.org/)),
    a service capable of building and testing your code automatically from your repository
    because it's tightly integrated with GitHub. As of today, Travis CI provides a
    free plan for open source projects. Many open source Python projects take advantage
    of Travis CI to ensure that the programs run correctly on multiple Python versions
    and platforms.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数开源项目都利用了Travis CI ([https://travis-ci.org/](https://travis-ci.org/))，这是一个能够从你的仓库自动构建和测试你的代码的服务，因为它与GitHub紧密集成。截至今天，Travis
    CI为开源项目提供免费计划。许多开源Python项目利用Travis CI来确保程序在多个Python版本和平台上正确运行。
- en: Travis CI can be set up easily from a GitHub repository by including a `.travis.yml`
    file containing the build instruction for the project and activating the builds
    on the Travis CI website ([https://travis-ci.org/](https://travis-ci.org/)) after
    registering an account.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 通过包含一个包含项目构建说明的 `.travis.yml` 文件，并注册账户后激活 Travis CI 网站上的构建（[https://travis-ci.org/](https://travis-ci.org/)），可以从
    GitHub 仓库轻松设置 Travis CI。
- en: An example `.travis.yml` for a high performance application is illustrated here.
    The file contains instructions to build and run the software that are specified
    using a few sections written in YAML syntax.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这里展示了一个高性能应用的 `.travis.yml` 示例。该文件包含使用 YAML 语法编写的几个部分，用于指定构建和运行软件的说明。
- en: The `python` section specifies which Python versions to use. The `install` section
    will download and set up conda for testing, installing dependencies, and setting
    up the project. While this step is not necessary (one can use `pip` instead),
    conda is a great package manager for high-performance applications as it contains
    useful native packages.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`python` 部分指定了要使用的 Python 版本。`install` 部分将下载并设置 conda 以进行测试、安装依赖项和设置项目。虽然这一步不是必需的（可以使用
    `pip` 代替），但 conda 是高性能应用的优秀包管理器，因为它包含有用的本地包。'
- en: 'The `script` section contains the code needed to test the code. In this example,
    we limit ourselves to run our tests and benchmarks:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`script` 部分包含测试代码所需的代码。在这个例子中，我们限制自己只运行测试和基准测试：'
- en: '[PRE16]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Every time new code is pushed (as well as other configurable events) to the
    GitHub repository, Travis CI will spin up a container, install dependencies, and
    run the test suite. Using Travis CI in open source projects is a great practice
    as it is a form of constant feedback about the status of the project and also
    provides up-to-date installation instructions through a continuously tested `.travis.yml`
    file.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 每次将新代码推送到 GitHub 仓库（以及其他可配置的事件）时，Travis CI 将启动一个容器，安装依赖项，并运行测试套件。在开源项目中使用 Travis
    CI 是一种很好的实践，因为它是对项目状态的一种持续反馈，同时也通过持续测试的 `.travis.yml` 文件提供最新的安装说明。
- en: Summary
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Deciding on a strategy to optimize your software is a complex and delicate task that
    depends on the application type, target platforms, and business requirements.
    In this chapter, we provided some guidelines to help you think and choose an appropriate
    software stack for your own applications.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 决定优化软件的策略是一个复杂且微妙的工作，它取决于应用程序类型、目标平台和业务需求。在本章中，我们提供了一些指导方针，以帮助你思考和选择适合你自己的应用程序的适当软件堆栈。
- en: High-performance numerical applications sometimes require managing installation
    and deployment of third-party packages that may require handling of external tools
    and native extensions. In this chapter, we saw how to structure your Python project,
    including tests, benchmarks, documentation, Cython modules, and C extensions.
    Also, we introduced the continuous integration service Travis CI, which can be
    used to enable continuous testing for your projects hosted on GitHub.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 高性能数值应用有时需要管理第三方包的安装和部署，这些包可能需要处理外部工具和本地扩展。在本章中，我们介绍了如何构建你的 Python 项目，包括测试、基准测试、文档、Cython
    模块和 C 扩展。此外，我们还介绍了持续集成服务 Travis CI，它可以用于为托管在 GitHub 上的项目启用持续测试。
- en: Finally, we also learned about virtual environments and docker containers that
    can be used to test applications in isolation and to greatly simplify deployments
    and ensure that multiple developers have access to the same platform.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还学习了可以使用虚拟环境和 docker 容器来测试应用程序，这可以极大地简化部署并确保多个开发者可以访问相同的平台。
