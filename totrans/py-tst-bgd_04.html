<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Breaking Tight Coupling by using Mock Objects</h1></div></div></div><p>
<em>Several times in the previous chapters, we've run across cases where we needed to go out of our way to make sure that units didn't contaminate each others' tests. Now we're going to look at a formalization of how to handle those situations—mock objects—and also at a specific mock object toolkit called Python Mocker.<a class="indexterm" id="id139"/>
</em>
</p><p>In this chapter, we shall:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Examine the ideas of mock objects in general</li><li class="listitem" style="list-style-type: disc">Learn how to use Python Mocker</li><li class="listitem" style="list-style-type: disc">Learn how to mock the "self" parameter of a method</li></ul></div><p>So let's get on with it!</p><div><div><div><div><h1 class="title"><a id="ch04lvl1sec33"/>Installing Python Mocker</h1></div></div></div><a class="indexterm" id="id140"/><a class="indexterm" id="id141"/><p>For the first time, we're using a tool that isn't included in the standard Python distribution. That means that we need to download and install it.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec34"/>Time for action – installing Python Mocker</h1></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">At the time of this writing, Python Mocker's home page is located at <a class="ulink" href="http://labix.org/mocker">http://labix.org/mocker</a>, while its downloads are hosted at <a class="ulink" href="https://launchpad.net/mocker/+download">https://launchpad.net/mocker/+download</a>. Go ahead and download the newest version, and we'll see about installing it.</li><li class="listitem">The first thing that needs to be done is to unzip the downloaded file. It's a <code class="literal">.tar.bz2</code>, which should just work for Unix, Linux, or OSX users. Windows users will need a third-party program (7-Zip works well: <a class="ulink" href="http://www.7-zip.org/">http://www.7-zip.org/</a>) to uncompress the archive. Store the uncompressed file in some temporary location.</li><li class="listitem">Once you have the files unzipped somewhere, go to that location via the command line. Now, to do this next step, you either need to be allowed to write files into your Python installation's site-packages directory (which you are, if you're the one who installed Python in the first place) or you need to be using Python version 2.6 or higher.</li><li class="listitem">If you can write to site-packages, type <div><pre class="programlisting">
<strong>$ python setup.py install </strong>
</pre></div></li><li class="listitem">If you can't write to site-packages, but you're using Python 2.6 or higher, type <div><pre class="programlisting">
<strong>$ python setup.py install --user</strong>
<a class="indexterm" id="id142"/>
<a class="indexterm" id="id143"/>
</pre></div></li></ol></div><div><div><h3 class="title"><a id="note12"/>Note</h3><a class="indexterm" id="id144"/><p>Sometimes, a tool called <code class="literal">easy_install</code> can simplify the installation process of Python modules and packages. If you want to give it a try, download and install <code class="literal">setuptools</code> from <a class="ulink" href="http://pypi.python.org/pypi/setuptools">http://pypi.python.org/pypi/setuptools</a>, according to the directions on that page, and then run the command <code class="literal">easy_install mocker</code>. Once that command is done, you should be ready to use Nose.</p></div></div><p>Once you have successfully run the installer, Python Mocker is ready for use.</p></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec35"/>The idea of a mock object</h1></div></div></div><a class="indexterm" id="id145"/><p>"Mock" in this sense means "imitation," and that's exactly what a mock object does. Mock objects imitate the real objects that make up your program, without actually being those objects or relying on them in any way.</p><p>Instead of doing whatever the real object would do, a mock object performs predefined simple operations that <em>look like what the real object should do</em>. That means its methods return appropriate values (which you told it to return) or raise appropriate exceptions (which you told it to raise). A mock object is like a mockingbird; imitating the calls of other birds without comprehending them.</p><a class="indexterm" id="id146"/><p>We've already used one mock object in our earlier work when we replaced <code class="literal">time.time</code> with an object (in Python, functions are objects) that returned an increasing series of numbers. The mock object was like <code class="literal">time.time</code>, except that it always returned the same series of numbers, no matter when we ran our test or how fast the computer was that we ran it on. In other words, it decoupled our test from an external variable.</p><p>That's what mock objects are all about: decoupling tests from external variables. Sometimes those variables are things like the external time or processor speed, but usually the variables are the behavior of other units.<a class="indexterm" id="id147"/>
</p></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec36"/>Python Mocker</h1></div></div></div><a class="indexterm" id="id148"/><p>The idea is pretty straightforward, but one look at that mock version of <code class="literal">time.time</code> from the previous chapter shows that creating mock objects without using a toolkit of some sort can be a dense and annoying process, and can interfere with the readability of your tests. This is where Python Mocker (or any of several other mock object toolkits, depending on preference) comes in.</p></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec37"/>Time for action – exploring the basics of Mocker </h1></div></div></div><a class="indexterm" id="id149"/><a class="indexterm" id="id150"/><p>We'll walk through some of the simplest—and most useful—features of Mocker. To do that, we'll write tests that describe a class representing a specific mathematical operation (multiplication) which can be applied to the values of arbitrary other mathematical operation objects. In other words, we'll work on the guts of a spreadsheet program (or something similar).</p><p>We're going to use Mocker to create mock objects to stand in place of the real operation objects.<a class="indexterm" id="id151"/>
<a class="indexterm" id="id152"/>
</p><div><ol class="orderedlist arabic"><li class="listitem">Create up a text file to hold the tests, and add the following at the beginning (assuming that all the mathematical operations will be defined in a module called <code class="literal">operations</code>):<div><pre class="programlisting">&gt;&gt;&gt; from mocker import Mocker
&gt;&gt;&gt; import operations</pre></div></li><li class="listitem">We've decided that every mathematical operation class should have a constructor accepting the objects representing the new object's operands. It should also have an evaluate function that accepts a dictionary of variable bindings as its parameter and returns a number as the result. We can write the tests for the constructor fairly easily, so we do that first (Note that we've included some explanation in the test file, which is always a good idea):<div><pre class="programlisting">We're going to test out the constructor for the multiply operation, first. Since all that the constructor has to do is record all of the operands, this is straightforward.

&gt;&gt;&gt; mocker = Mocker()
&gt;&gt;&gt; p1 = mocker.mock()
&gt;&gt;&gt; p2 = mocker.mock()
&gt;&gt;&gt; mocker.replay()
&gt;&gt;&gt; m = operations.multiply(p1, p2)
&gt;&gt;&gt; m.operands == (p1, p2)
True
&gt;&gt;&gt; mocker.restore()
&gt;&gt;&gt; mocker.verify()</pre></div></li><li class="listitem"><a class="indexterm" id="id153"/>The tests for the <code class="literal">evaluate</code> method are somewhat more complicated, because there are several things we need to test. This is also where we start seeing the real advantages of Mocker:<div><pre class="programlisting">Now we're going to check the evaluate method for the multiply operation. It should raise a ValueError if there are less than two operands, it should call the evaluate methods of all operations that are operands of the multiply, and of course it should return the correct value.

&gt;&gt;&gt; mocker = Mocker()
&gt;&gt;&gt; p1 = mocker.mock()
<strong>&gt;&gt;&gt; p1.evaluate({}) #doctest: +ELLIPSIS</strong>
&lt;mocker.Mock object at ...&gt;
<strong>&gt;&gt;&gt; mocker.result(97.43)</strong>

&gt;&gt;&gt; mocker.replay()

&gt;&gt;&gt; m = operations.multiply(p1)
&gt;&gt;&gt; m.evaluate({})
Traceback (most recent call last):
ValueError: multiply without at least two operands is meaningless

&gt;&gt;&gt; mocker.restore()
&gt;&gt;&gt; mocker.verify()
<a class="indexterm" id="id154"/>
&gt;&gt;&gt; mocker = Mocker()
&gt;&gt;&gt; p1 = mocker.mock()
<a class="indexterm" id="id155"/>
<a class="indexterm" id="id156"/>
<strong>&gt;&gt;&gt; p1.evaluate({}) #doctest: +ELLIPSIS</strong>
&lt;mocker.Mock object at ...&gt;
<strong>&gt;&gt;&gt; mocker.result(97.43)</strong>
&gt;&gt;&gt; p2 = mocker.mock()
<strong>&gt;&gt;&gt; p2.evaluate({}) #doctest: +ELLIPSIS</strong>
&lt;mocker.Mock object at ...&gt;
<strong>&gt;&gt;&gt; mocker.result(-16.25)</strong>

&gt;&gt;&gt; mocker.replay()

&gt;&gt;&gt; m = operations.multiply(p1, p2)
&gt;&gt;&gt; round(m.evaluate({}), 2)
-1583.24

&gt;&gt;&gt; mocker.restore()
&gt;&gt;&gt; mocker.verify()</pre></div></li><li class="listitem">If we run the tests now, we get a list of failed tests. Most of them are due to Mocker being unable to import the <a class="indexterm" id="id157"/><code class="literal">operations</code> module, but the bottom of the list should look like this: <a class="indexterm" id="id158"/><a class="indexterm" id="id159"/><div><img alt="Time for action – exploring the basics of Mocker" src="img/8846_04_01.jpg"/></div></li><li class="listitem"><a class="indexterm" id="id160"/>Finally, we'll write some code in the <code class="literal">operations</code> module that passes these tests, producing the following:<div><pre class="programlisting">class multiply:
    def __init__(self, *operands):
        self.operands = operands

    def evaluate(self, bindings):
        vals = [x.evaluate(bindings) for x in self.operands]
        if len(vals) &lt; 2:
            raise ValueError('multiply without at least two '                     
                             'operands is meaningless')

        result = 1.0
        for val in vals:
            result *= val
        return result</pre></div></li><li class="listitem">Now when we run the tests, none of them should fail.</li></ol></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec52"/>
<em>
<a class="indexterm" id="id161"/>
<a class="indexterm" id="id162"/>What just happened?
</em>
</h2></div></div></div><p>The difficulty in writing the tests for something like this comes(as it often does) from the need to decouple the multiplication class from all of the other mathematical operation classes, so that the results of the multiplication test only depend on whether multiplication works correctly.</p><p>We addressed this problem by using the Mocker framework for mock objects. The way Mocker works is that you first create an object representing the mocking context, by doing something such as <code class="literal">mocker = Mocker()</code>. The mocking context will help you create mock objects, and it will store information about how you expect them to be used. Additionally, it can help you temporarily replace library objects with mocks (like we've previously done with <code class="literal">time.time</code>) and restore the real objects to their places when you're done. We'll see more about doing that in a little while.</p><p><a class="indexterm" id="id163"/>Once you have a mocking context, you create a mock object by calling its <code class="literal">mock</code> method, and then you demonstrate how you expect the mock objects to be used. The mocking context records your demonstration, so later on when you call its <a class="indexterm" id="id164"/><code class="literal">replay</code> method it knows what usage to expect for each object and how it should respond. Your tests (which use the mock objects instead of the real objects that they imitate), go after the call to <code class="literal">replay</code>.</p><p><a class="indexterm" id="id165"/>Finally, after test code has been run, you call the mocking context's <code class="literal">restore</code> method to undo any replacements of library objects, and then <code class="literal">verify</code> to check that the actual usage of the mocks was as expected.</p><p>Our first use of Mocker was straightforward. We tested our constructor, which is specified to be extremely simple. It's not supposed to do anything with its parameters, aside from store them away for later. Did we gain anything at all by using Mocker to create mock objects to use as the parameters, when the parameters aren't even supposed to do anything? In fact, we did. Since we didn't tell Mocker to expect any interactions with the mock objects, it will report nearly any usage of the parameters (storing them doesn't count, because storing them isn't actually interacting with them) as errors during <a class="indexterm" id="id166"/>the <code class="literal">verify</code> step. When we call <code class="literal">mocker.verify()</code>, Mocker looks back at how the parameters were really used and reports a failure if our constructor tried to perform some action on them. It's another way to embed our expectations into our tests.</p><p>We used Mocker twice more, except in those later uses we told Mocker to expect a call to <a class="indexterm" id="id167"/>an <code class="literal">evaluate</code> method on the mock objects (i.e. <code class="literal">p1</code> and <code class="literal">p2</code>), and to expect an empty dictionary as the parameter to each of the mock objects' <code class="literal">evaluate</code> call. For each call we told it to expect, we also told it that its response should be to return a specific floating point number. Not coincidentally, that mimics the behavior of an operation object, and we can use the mocks in our tests of <code class="literal">multiply.evaluate</code>.</p><a class="indexterm" id="id168"/><p>If <code class="literal">multiply.evaluate</code> hadn't called the <code class="literal">evaluate</code> methods of mock, or if it had called one of them more than once, our <code class="literal">mocker.verify</code> call would have alerted us to the problem. This ability to describe not just what should be called but how often each thing should be called is a very useful too that makes our descriptions of what we expect much more complete. When <code class="literal">multiply.evaluate</code> calls the <code class="literal">evaluate</code> method of mock, the values that get returned are the ones that we specified, so we know exactly what <code class="literal">multiply.evaluate</code> ought to do. We can test it thoroughly, and we can do it without involving any of the other units of our code. Try changing how <code class="literal">multiply.evaluate</code> works and see what <code class="literal">mocker.verify</code> says about it.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec53"/>Mocking functions</h2></div></div></div><p><a class="indexterm" id="id169"/>
<a class="indexterm" id="id170"/>Normal objects (that is to say, objects with methods and attributes created by instantiating a class) aren't the only things you can make mocks of. Functions are another kind of object that can be mocked, and it turns out to be pretty easy.</p><p>During your demonstration, if you want a mock object to represent a function, just call it. The mock object will recognize that you want it to behave like a function, and it will make a note of what parameters you passed it, so that it can compare them against what gets passed to it during the test.</p><p>For example, the following code creates a mock called <code class="literal">func</code>, which pretends to be a function that, when called once with the parameters <code class="literal">56</code> and <code class="literal">hello</code>, returns the number <code class="literal">11</code>. The second part of the example uses the mock in a very simple test:</p><div><pre class="programlisting">&gt;&gt;&gt; from mocker import Mocker
&gt;&gt;&gt; mocker = Mocker()
&gt;&gt;&gt; func = mocker.mock()
&gt;&gt;&gt; func(56, "hello") # doctest: +ELLIPSIS
&lt;mocker.Mock object at ...&gt;
&gt;&gt;&gt; mocker.result(11)

&gt;&gt;&gt; mocker.replay()
&gt;&gt;&gt; func(56, "hello")
11
&gt;&gt;&gt; mocker.restore()
&gt;&gt;&gt; mocker.verify()</pre></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec54"/>
<a class="indexterm" id="id171"/>
<a class="indexterm" id="id172"/>Mocking containers
</h2></div></div></div><p><a class="indexterm" id="id173"/>
<a class="indexterm" id="id174"/>Containers are another category of somewhat special objects that can be mocked. Like functions, containers can be mocked by simply using a mock object as if it were a container during your example.</p><p>Mock objects are able to understand examples that involve the following container operations: looking up a member, setting a member, deleting a member, finding the length, and getting an iterator over the members. Depending on the version of Mocker, membership testing via the <code class="literal">in</code> operator may also be available.</p><p>In the following example, all of the above capabilities are demonstrated, but the <code class="literal">in</code> tests are disabled for compatibility with versions of Mocker that don't support them. Keep in mind that even though, after we call <code class="literal">replay</code>, the object called <code class="literal">container</code> looks like an actual container, it's not. It's just responding to stimuli we told it to expect, in the way we told it to respond. That's why, when our test asks for an iterator, it returns <code class="literal">None</code> instead. That's what we told it to do, and that's all it knows.</p><div><pre class="programlisting">&gt;&gt;&gt; from mocker import Mocker

&gt;&gt;&gt; mocker = Mocker()
&gt;&gt;&gt; container = mocker.mock()

&gt;&gt;&gt; container['hi'] = 18

&gt;&gt;&gt; container['hi'] # doctest: +ELLIPSIS
&lt;mocker.Mock object at ...&gt;
&gt;&gt;&gt; mocker.result(18)

&gt;&gt;&gt; len(container)
0
&gt;&gt;&gt; mocker.result(1)

&gt;&gt;&gt; 'hi' in container # doctest: +SKIP
True
&gt;&gt;&gt; mocker.result(True)

&gt;&gt;&gt; iter(container) # doctest: +ELLIPSIS
&lt;...&gt;
&gt;&gt;&gt; mocker.result(None)

&gt;&gt;&gt; del container['hi']
&gt;&gt;&gt; mocker.result(None)

&gt;&gt;&gt; mocker.replay()

&gt;&gt;&gt; container['hi'] = 18

&gt;&gt;&gt; container['hi']
18

&gt;&gt;&gt; len(container)
1

&gt;&gt;&gt; 'hi' in container # doctest: +SKIP
True

&gt;&gt;&gt; for key in container:
...     print key
Traceback (most recent call last):
TypeError: iter() returned non-iterator of type 'NoneType'

&gt;&gt;&gt; del container['hi']

&gt;&gt;&gt; mocker.restore()
&gt;&gt;&gt; mocker.verify()</pre></div><p><a class="indexterm" id="id175"/>Something to notice in the above example is that during the initial phase, a few of the demonstrations (for example, the call to <code class="literal">len</code>) <a class="indexterm" id="id176"/>did not return a <code class="literal">mocker.Mock</code> object, as we might have expected. For some operations, Python enforces that the result is of a particular type (for example, container lengths have to be integers), which forces Mocker to break its normal pattern. Instead of returning a generic mock object, it returns an object of the correct type, although the value of the returned object is meaningless. Fortunately, this only applies during the initial phase, when you're showing Mocker what to expect, and only in a few cases, so it's usually not a big deal. There are times when the returned mock objects are needed, though, so it's worth knowing about the exceptions.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec55"/>Parameter matching</h2></div></div></div><p><a class="indexterm" id="id177"/>Sometimes, we would like our mocked functions and methods to accept a whole domain of parameters, instead of limiting itself to the accepting objects that compare equal to the parameters we specifically told it about. This can be useful for any number of reasons: perhaps the mock needs to accept an external variable as a parameter (the current time, or available disk space, for example), <a class="indexterm" id="id178"/>or maybe the mock example will be invoked multiple times (which we'll discuss soon), or maybe the parameters are simply not important to the definition of correct behavior.</p><p>We can tell a mock function to accept a domain of parameters by using the <code class="literal">ANY</code>, <code class="literal">ARGS</code>, <code class="literal">KWARGS</code>, <code class="literal">IS</code>, <code class="literal">IN</code>, <code class="literal">CONTAINS</code>, and <code class="literal">MATCH</code> special values, all of which are defined in the <code class="literal">mocker</code> module. These special values are passed to a mock object as function call parameters during its demonstration phase (before you call <code class="literal">replay</code>).</p><div><div><div><div><h3 class="title"><a id="ch04lvl3sec05"/>ANY</h3></div></div></div><p><a class="indexterm" id="id179"/>Passing <code class="literal">ANY</code> as a function parameter causes the object to accept any single object as its parameter in that position.</p><div><pre class="programlisting">
<a class="indexterm" id="id180"/>
<strong>&gt;&gt;&gt; from mocker import Mocker, ANY</strong>
&gt;&gt;&gt; mocker = Mocker()
&gt;&gt;&gt; func = mocker.mock()
<strong>&gt;&gt;&gt; func(7, ANY) # doctest: +ELLIPSIS</strong>
&lt;mocker.Mock object at ...&gt;
&gt;&gt;&gt; mocker.result(5)
&gt;&gt;&gt; mocker.replay()
<strong>&gt;&gt;&gt; func(7, 'this could be anything')</strong>
5
&gt;&gt;&gt; mocker.restore()
&gt;&gt;&gt; mocker.verify()</pre></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec06"/>ARGS</h3></div></div></div><p><a class="indexterm" id="id181"/>
<a class="indexterm" id="id182"/>Passing <code class="literal">ARGS</code> as a function parameter causes the object to accept any number of positional arguments, as if it had been declared with <code class="literal">*args</code> in its parameter list.</p><div><pre class="programlisting">
<strong>&gt;&gt;&gt; from mocker import Mocker, ARGS</strong>
&gt;&gt;&gt; mocker = Mocker()
&gt;&gt;&gt; func = mocker.mock()
<strong>&gt;&gt;&gt; func(7, ARGS) # doctest: +ELLIPSIS</strong>
&lt;mocker.Mock object at ...&gt;
&gt;&gt;&gt; mocker.result(5)
&gt;&gt;&gt; mocker.replay()
<strong>&gt;&gt;&gt; func(7, 'this could be anything', 'so could this', 99.2)</strong>
5
&gt;&gt;&gt; mocker.restore()
&gt;&gt;&gt; mocker.verify()</pre></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec07"/>
<a class="indexterm" id="id183"/>KWARGS
</h3></div></div></div><p><a class="indexterm" id="id184"/>Passing <a class="indexterm" id="id185"/><code class="literal">KWARGS</code> as a function parameter causes the object to accept any number of keyword arguments, as if it had been declared with <code class="literal">**kwargs</code> in its parameter list.</p><div><pre class="programlisting">
<strong>&gt;&gt;&gt; from mocker import Mocker, KWARGS</strong>
&gt;&gt;&gt; mocker = Mocker()
&gt;&gt;&gt; func = mocker.mock()
<strong>&gt;&gt;&gt; func(7, KWARGS) # doctest: +ELLIPSIS</strong>
&lt;mocker.Mock object at ...&gt;
&gt;&gt;&gt; mocker.result(5)
&gt;&gt;&gt; mocker.replay()
<strong>&gt;&gt;&gt; func(7, a='this could be anything', b='so could this')</strong>
5
&gt;&gt;&gt; mocker.restore()
&gt;&gt;&gt; mocker.verify()</pre></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec08"/>
<a class="indexterm" id="id186"/>IS
</h3></div></div></div><p><a class="indexterm" id="id187"/>
<a class="indexterm" id="id188"/>Passing <a class="indexterm" id="id189"/><code class="literal">IS(some_object)</code> is unusual, because instead of being an inexact parameter, it's more exact than the default. Mocker will normally accept any parameter that is <code class="literal">==</code> to the value passed during the initial phase, but if you use <code class="literal">IS</code>, it instead checks whether the parameter and <code class="literal">some_object</code> are in fact the exact same object, and only accepts the call if they are.</p><div><pre class="programlisting">
<strong>&gt;&gt;&gt; from mocker import Mocker, IS</strong>
&gt;&gt;&gt; mocker = Mocker()
<strong>&gt;&gt;&gt; param = [1, 2, 3]</strong>
&gt;&gt;&gt; func = mocker.mock()
<strong>&gt;&gt;&gt; func(7, IS(param)) # doctest: +ELLIPSIS</strong>
&lt;mocker.Mock object at ...&gt;
&gt;&gt;&gt; mocker.result(5)
&gt;&gt;&gt; mocker.replay()
<strong>&gt;&gt;&gt; func(7, param) # func(7, [1, 2, 3]) would fail</strong>
5
&gt;&gt;&gt; mocker.restore()
&gt;&gt;&gt; mocker.verify()</pre></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec09"/>IN</h3></div></div></div><p><a class="indexterm" id="id190"/>Passing <a class="indexterm" id="id191"/>
<code class="literal">IN(some_container)</code> causes Mocker to accept any parameter that is contained in the container object called <code class="literal">some_container</code>.</p><div><pre class="programlisting">
<a class="indexterm" id="id192"/>
<strong>&gt;&gt;&gt; from mocker import Mocker, IN</strong>
&gt;&gt;&gt; mocker = Mocker()
&gt;&gt;&gt; func = mocker.mock()
<strong>&gt;&gt;&gt; func(7, IN([45, 68, 19])) # doctest: +ELLIPSIS</strong>
&lt;mocker.Mock object at ...&gt;
&gt;&gt;&gt; mocker.result(5)
<strong>&gt;&gt;&gt; func(7, IN([45, 68, 19])) # doctest: +ELLIPSIS</strong>
&lt;mocker.Mock object at ...&gt;
&gt;&gt;&gt; mocker.result(5)
<strong>&gt;&gt;&gt; func(7, IN([45, 68, 19])) # doctest: +ELLIPSIS</strong>
&lt;mocker.Mock object at ...&gt;
&gt;&gt;&gt; mocker.result(5)
&gt;&gt;&gt; mocker.replay()
<strong>&gt;&gt;&gt; func(7, 19)</strong>
5
<strong>&gt;&gt;&gt; func(7, 19)</strong>
5
<strong>&gt;&gt;&gt; func(7, 45)</strong>
5
&gt;&gt;&gt; mocker.restore()
&gt;&gt;&gt; mocker.verify()<a class="indexterm" id="id193"/>
</pre></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec10"/>CONTAINS</h3></div></div></div><a class="indexterm" id="id194"/><p>Passing <code class="literal">CONTAINS(some_object)</code> <a class="indexterm" id="id195"/>causes Mocker to accept any parameter for which <code class="literal">some_object in parameter</code> is <code class="literal">True</code>.</p><div><pre class="programlisting">
<strong>&gt;&gt;&gt; from mocker import Mocker, CONTAINS</strong>
&gt;&gt;&gt; mocker = Mocker()
&gt;&gt;&gt; func = mocker.mock()
<strong>&gt;&gt;&gt; func(7, CONTAINS(45)) # doctest: +ELLIPSIS</strong>
&lt;mocker.Mock object at ...&gt;
&gt;&gt;&gt; mocker.result(5)
&gt;&gt;&gt; mocker.replay()
<strong>&gt;&gt;&gt; func(7, [12, 31, 45, 18])</strong>
5
&gt;&gt;&gt; mocker.restore()
&gt;&gt;&gt; mocker.verify()</pre></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec11"/>MATCH</h3></div></div></div><a class="indexterm" id="id196"/><a class="indexterm" id="id197"/><p>Finally, if none of the above lets you describe the conditions under which you want Mocker to accept a parameter as matching its expectation, you can pass <code class="literal">MATCH(test_function)</code>
<a class="indexterm" id="id198"/>. The <a class="indexterm" id="id199"/>
<code class="literal">test_function</code> should be a function with one parameter, which will be passed the received parameter when the mocked function gets called. If the <code class="literal">test_function</code> returns <code class="literal">True</code>, the parameter is accepted.</p><div><pre class="programlisting">
<strong>&gt;&gt;&gt; from mocker import Mocker, MATCH</strong>
<strong>&gt;&gt;&gt; def is_odd(val):</strong>
<strong>...     return val % 2 == 1</strong>
&gt;&gt;&gt; mocker = Mocker()
&gt;&gt;&gt; func = mocker.mock()
<strong>&gt;&gt;&gt; func(7, MATCH(is_odd)) # doctest: +ELLIPSIS</strong>
&lt;mocker.Mock object at ...&gt;
&gt;&gt;&gt; mocker.result(5)
&gt;&gt;&gt; mocker.replay()
<strong>&gt;&gt;&gt; func(7, 1001)</strong>
5
&gt;&gt;&gt; mocker.restore()
&gt;&gt;&gt; mocker.verify()<a class="indexterm" id="id200"/>
</pre></div></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec56"/>Mocking complex expressions</h2></div></div></div><a class="indexterm" id="id201"/><a class="indexterm" id="id202"/><p>It would be nice to be able to combine the various operations that Mocker's mock objects support. Simple attribute accesses, container member accesses and method calls make up the majority of object interactions, but they are commonly used in combinations, like <a class="indexterm" id="id203"/>
<code class="literal">container[index].attribute.method()</code>. We could write a demonstration of something equivalent to this out, step-by-step, using the things we already know about Mocker's mock objects, but it would be nice to be able to just write the example as we expect it to be in the actual code.</p><p>Fortunately, we can usually do exactly that. Throughout the previous examples in this chapter, you've been seeing expressions that return <code class="literal">&lt;mocker.Mock object at ...&gt;</code>. Those return values are mock objects, just like the ones you create by calling <code class="literal">Mocker.mock</code>, and they can be used in the same ways. That means that as long as part of a complex expression returns a mock object during the demonstration, you can continue chaining more parts of the complex expression onto it. With something like <code class="literal">container[index].attribute.method()</code>, <code class="literal">container[index]</code> returns a mock object, attribute access on that object returns another mock object, and we call a method on that object. The method call also returns a mock object, but we don't need to do anything with it in order to correctly demonstrate our expectations.</p><a class="indexterm" id="id204"/><a class="indexterm" id="id205"/><p>Mocker remembers our demonstration of use, no matter how complex it is or how deeply we drill down into nested objects. Later after we call <code class="literal">replay</code>, it checks that the usage is as we described it, even for very complicated usage patterns.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec57"/>Have a go hero</h2></div></div></div><p>Try telling Mocker to expect a function call which returns a string, which is then trimmed of whitespace and split on commas, and do it all as a single complex expression.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec58"/>Returning iterators</h2></div></div></div><a class="indexterm" id="id206"/><p>So far, we've been calling <a class="indexterm" id="id207"/>
<a class="indexterm" id="id208"/>
<code class="literal">Mocker.result</code> to tell Mocker that the result of evaluating a particular example expression should be some specific value. That's great for simulating most expressions, and it covers the common usage of functions and methods as well, but it doesn't really do the trick for simulating a generator, or other function that returns an iterator. To handle that, we call <a class="indexterm" id="id209"/>
<code class="literal">Mocker.generate</code> instead of <code class="literal">Mocker.result</code>, like so:</p><div><pre class="programlisting">&gt;&gt;&gt; from mocker import Mocker
&gt;&gt;&gt; from itertools import islice
&gt;&gt;&gt; mocker = Mocker()
&gt;&gt;&gt; generator = mocker.mock()
<strong>&gt;&gt;&gt; generator(12) # doctest: +ELLIPSIS</strong>
&lt;mocker.Mock object at ...&gt;
<strong>&gt;&gt;&gt; mocker.generate([16, 31, 24, 'hike'])</strong>

&gt;&gt;&gt; mocker.replay()
&gt;&gt;&gt; tuple(islice(generator(12), 1, 2))
(31,)
&gt;&gt;&gt; mocker.restore()
&gt;&gt;&gt; mocker.verify()</pre></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec59"/>Raising exceptions</h2></div></div></div><a class="indexterm" id="id210"/><a class="indexterm" id="id211"/><a class="indexterm" id="id212"/><p>Some expressions raise an exception instead of returning a result, so we need to be able to make our mock objects do the same. Fortunately, it's not difficult: you call <code class="literal">Mocker.throw</code> to tell Mocker <a class="indexterm" id="id213"/>
<a class="indexterm" id="id214"/>that the correct response to an expected expression is to raise a particular exception.</p><div><pre class="programlisting">&gt;&gt;&gt; from mocker import Mocker
&gt;&gt;&gt; mocker = Mocker()
&gt;&gt;&gt; obj = mocker.mock()
&gt;&gt;&gt; obj.thingy # doctest: +ELLIPSIS
&lt;mocker.Mock object at ...&gt;
<strong>&gt;&gt;&gt; mocker.throw(AttributeError('thingy does not exist'))</strong>
<a class="indexterm" id="id215"/>
&gt;&gt;&gt; mocker.replay()
&gt;&gt;&gt; obj.thingy
Traceback (most recent call last):
AttributeError: thingy does not exist
&gt;&gt;&gt; mocker.restore()
&gt;&gt;&gt; mocker.verify()</pre></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec60"/>Calling functions via a mock</h2></div></div></div><a class="indexterm" id="id216"/><a class="indexterm" id="id217"/><p>Sometimes a function that we're mocking has side-effects that are important to our tests. Mocker handles these situations by allowing you to specify one or more functions that should be called, when a particular expression occurs. These functions can either be existing functions that are pulled from somewhere in your codebase, or they can be special functions that you've embedded in your test specifically to produce the desired side effects.</p><p>There is one restriction on which functions can be called as a result of interacting with one of  the mock objects of Mocker: such a function must not require any parameters. This isn't as big a restriction as you might think, because you know exactly which parameters should be passed to the called functions, and so you can write a small wrapper function that just calls the target function with those parameters. This is demonstrated in the next example.</p><div><div><h3 class="title"><a id="note13"/>Note</h3><a class="indexterm" id="id218"/><p>The Python <code class="literal">lambda</code> keyword is a mechanism for wrapping a single expression up as a function. When the function gets called, the expression is evaluated, and whatever the expression evaluated to is returned from the function. The uses of <code class="literal">lambda</code> are many and varied, but using it to create minor wrappers around calls to other functions is a common one.</p></div></div><p>Calling functions in this way isn't exclusive with having the mocked function return a result. In the following example, the mocked function makes two function calls and returns the number 5.</p><div><pre class="programlisting">&gt;&gt;&gt; from mocker import Mocker
&gt;&gt;&gt; from sys import stdout
&gt;&gt;&gt; mocker = Mocker()
&gt;&gt;&gt; obj = mocker.mock()
&gt;&gt;&gt; obj.method() # doctest: +ELLIPSIS
&lt;mocker.Mock object at ...&gt;
<strong>&gt;&gt;&gt; mocker.call((lambda: stdout.write('hi')))</strong>
<strong>&gt;&gt;&gt; mocker.call((lambda: stdout.write('yo\n')))</strong>
&gt;&gt;&gt; mocker.result(5)

&gt;&gt;&gt; mocker.replay()

&gt;&gt;&gt; obj.method()
hiyo
5

&gt;&gt;&gt; mocker.restore()
&gt;&gt;&gt; mocker.verify()<a class="indexterm" id="id219"/>
<a class="indexterm" id="id220"/>
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec61"/>Specifying that an expectation should occur multiple times</h2></div></div></div><a class="indexterm" id="id221"/><a class="indexterm" id="id222"/><p>As you may have noticed in some of the preceding examples, sometimes telling Mocker what to expect can get repetitive. The example of the <code class="literal">IN</code> parameter matcher show this well: We did a lot of repetitive work telling Mocker that we expected three calls to the <a class="indexterm" id="id223"/>
<code class="literal">func</code> function. That makes the test long (which reduces its readability) and it violates the DRY (Don't Repeat Yourself) principle of programming, making it harder to modify the test later on. Besides which, it's annoying to write all those duplicate expectations.</p><p>To solve this problem, Mocker allows us to specify the number of times that an expectation ought to occur during the execution of the test. We do this by calling <a class="indexterm" id="id224"/>
<code class="literal">Mocker.count</code> to specify the expected number of repetitions. To see the simplest way to do that, let's re-write the <code class="literal">IN</code> example, so that we don't have to keep repeating ourselves:</p><div><pre class="programlisting">&gt;&gt;&gt; from mocker import Mocker, IN
&gt;&gt;&gt; mocker = Mocker()
&gt;&gt;&gt; func = mocker.mock()
&gt;&gt;&gt; func(7, IN([45, 68, 19])) # doctest: +ELLIPSIS
&lt;mocker.Mock object at ...&gt;
&gt;&gt;&gt; mocker.result(5)
<strong>&gt;&gt;&gt; mocker.count(3)</strong>

&gt;&gt;&gt; mocker.replay()
<strong>&gt;&gt;&gt; func(7, 19)</strong>
<strong>5</strong>
<strong>&gt;&gt;&gt; func(7, 19)</strong>
<strong>5</strong>
<strong>&gt;&gt;&gt; func(7, 45)</strong>
<strong>5</strong>
&gt;&gt;&gt; mocker.restore()
&gt;&gt;&gt; mocker.verify()</pre></div><p>Notice how parameter matching works well with specifying a count, letting us compress several different calls to <code class="literal">func</code> into a single expectation, even though they have different parameters. By using these two features in conjunction, the expectations of a mock can often be shortened significantly, removing redundant information. Keep in mind though, that you don't want to remove important information from a test; if it mattered that the first call to <code class="literal">func</code> had <code class="literal">19</code> as its parameter, or that the calls came in a particular order, compressing the expectation this way would lose that information, which would compromise the test.</p><a class="indexterm" id="id225"/><a class="indexterm" id="id226"/><p>In the above example, we specified a precise number of times to expect the call to <code class="literal">func</code> to repeat, but <code class="literal">count</code> is more flexible than that. By giving it two parameters, <code class="literal">count</code> can be told to expect any number of repetitions between a minimum and a maximum number. As long as the actual number of repetitions during the test is at least as many as the minimum number, and no more than the maximum number, Mocker will accept it as correct usage.</p><div><pre class="programlisting">&gt;&gt;&gt; from mocker import Mocker, IN
&gt;&gt;&gt; mocker = Mocker()
&gt;&gt;&gt; func = mocker.mock()
&gt;&gt;&gt; func(7, IN([45, 68, 19])) # doctest: +ELLIPSIS
&lt;mocker.Mock object at ...&gt;
&gt;&gt;&gt; mocker.result(5)
<strong>&gt;&gt;&gt; mocker.count(1, 3)</strong>

&gt;&gt;&gt; mocker.replay()
&gt;&gt;&gt; func(7, 19)
5
&gt;&gt;&gt; func(7, 45)
5
&gt;&gt;&gt; func(7, 19)
5
&gt;&gt;&gt; mocker.restore()
&gt;&gt;&gt; mocker.verify()</pre></div><p>Finally, it's possible to specify that an expectation is to be repeated at least a certain number of times, but with no maximum number of repetitions. As long as the expectation is met at least as many times as specified, Mocker considers its usage to have been correct. To do this, we pass <code class="literal">None</code> as the maximum parameter when we call <code class="literal">count</code>.</p><div><pre class="programlisting">&gt;&gt;&gt; from mocker import Mocker, IN
&gt;&gt;&gt; mocker = Mocker()
&gt;&gt;&gt; func = mocker.mock()
&gt;&gt;&gt; func(7, IN([45, 68, 19])) # doctest: +ELLIPSIS
&lt;mocker.Mock object at ...&gt;
&gt;&gt;&gt; mocker.result(5)
<strong>&gt;&gt;&gt; mocker.count(1, None)</strong>

&gt;&gt;&gt; mocker.replay()
<strong>&gt;&gt;&gt; [func(7, 19) for x in range(50)] == [5] * 50</strong>
True
&gt;&gt;&gt; mocker.restore()
&gt;&gt;&gt; mocker.verify()</pre></div><div><div><h3 class="title"><a id="note14"/>Note</h3><a class="indexterm" id="id227"/><a class="indexterm" id="id228"/><p>That last example uses a couple of esoteric Python features. On the left side of the <code class="literal">==</code> is a "list comprehension," which is a compact way of constructing a list as a transformation of another iterable. On the right is list multiplication, which creates a new list containing the members of the old list repeated a number of times—in this case, the list contains <code class="literal">50</code> repetitions of the value <code class="literal">5</code>.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec62"/>Replacing library objects with mocks</h2></div></div></div><a class="indexterm" id="id229"/><a class="indexterm" id="id230"/><p>Several times, we've seen a need to replace something outside of our own code with a mock object: for example, <code class="literal">time.time</code> needed to be replaced with something that produced predictable results, in order for the tests on our PID controller to be meaningful.</p><p>Mocker provides us with a tool to address this common need, and it's quite simple to use. Mocker's mocking contexts contain a method called <code class="literal">replace</code> which behaves pretty much like <code class="literal">mock</code> from our point of view, but which is able to completely replace an existing object with a mock object, no matter what module (or modules) it exists in, or when it was imported. Even better, when we call <code class="literal">restore</code> the mock goes away, and original object is returned to its rightful place.</p><p>This gives us an easy way to isolate our tests even from library code that we couldn't normally control, and to do it without leaving any trace after we're done.</p><p>To illustrate <code class="literal">replace</code>, we're going to temporarily replace <code class="literal">time.time</code> with a mock. We've done this before—in our PID tests—in an ad hoc manner. It made our tests ugly and difficult to read. It also only replaced the name <code class="literal">time.time</code> with our mock: if we'd done <code class="literal">from time import time</code> in our PID code, the replacement wouldn't have caught it unless the replacement was done before we imported PID. Mocker will handle such complex replacements correctly, no matter when the imports occur or what form they <a class="indexterm" id="id231"/>
<a class="indexterm" id="id232"/>take, with no extra effort on our part.</p><div><pre class="programlisting">&gt;&gt;&gt; from time import time
&gt;&gt;&gt; from mocker import Mocker

&gt;&gt;&gt; mocker = Mocker()
&gt;&gt;&gt; mock_time = mocker.replace('time.time')

&gt;&gt;&gt; mock_time() # doctest: +ELLIPSIS
&lt;mocker.Mock object at ...&gt;
&gt;&gt;&gt; mocker.result(1.3)

&gt;&gt;&gt; mock_time() # doctest: +ELLIPSIS
&lt;mocker.Mock object at ...&gt;
&gt;&gt;&gt; mocker.result(2.7)

&gt;&gt;&gt; mock_time() # doctest: +ELLIPSIS
&lt;mocker.Mock object at ...&gt;
&gt;&gt;&gt; mocker.result(3.12)

&gt;&gt;&gt; mocker.replay()
&gt;&gt;&gt; '%1.3g' % time()
'1.3'
&gt;&gt;&gt; '%1.3g' % time()
'2.7'
&gt;&gt;&gt; '%1.3g' % time()
'3.12'
&gt;&gt;&gt; mocker.restore()
&gt;&gt;&gt; mocker.verify()</pre></div><a class="indexterm" id="id233"/><p>Notice that we imported <code class="literal">time</code> before we replace it with a mock, and yet when we actually used it, it turned out to be the mock we were using. After the call to restore, if we'd called <code class="literal">time</code> again, it would have been the real time function again.</p><div><div><h3 class="title"><a id="note15"/>Note</h3><p>Why did we use string formatting on the output from <code class="literal">time</code>? We did this because floating point numbers are imprecise, meaning that the number we entered as 3.12, for example, might be represented in the system as 3.1200000000000001 or some other value that is very close to, but not precisely, 3.12. The exact value used can vary from system to system, so comparing against a float makes your tests less portable. Our string formatting rounded the number to just the relevant digits.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec63"/>Pop quiz – Mocker usage</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem"><a class="indexterm" id="id234"/><a class="indexterm" id="id235"/>Which of the following would you use to check whether a parameter passed to a mock was one of a set of allowed parameters: <code class="literal">CONTAINS</code>, <code class="literal">IN</code>, <code class="literal">IS</code>?</li><li class="listitem">When you specify that an expectation can repeat, how do you specify that there is no upper limit to how many times it can be repeated?</li><li class="listitem">What does <code class="literal">mocker.verify()</code> do?</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec64"/>Have a go hero – mocking datetime</h2></div></div></div><a class="indexterm" id="id236"/><p>Take a look at the following test code, and fill in the missing Mocker demonstrations so that the test passes:</p><div><pre class="programlisting">&gt;&gt;&gt; from datetime import datetime
&gt;&gt;&gt; from mocker import Mocker
&gt;&gt;&gt; mocker = Mocker()

Here's where your Mocker demonstrations should go.

&gt;&gt;&gt; mocker.replay()
&gt;&gt;&gt; now = datetime.now()
&gt;&gt;&gt; then = now.replace(hour = 12)
&gt;&gt;&gt; then.isocalendar()
(2009, 24, 3)
&gt;&gt;&gt; then.isoformat()
'2009-06-10T12:30:39.812555'
&gt;&gt;&gt; mocker.restore()
&gt;&gt;&gt; mocker.verify()</pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec38"/>Mocking self</h1></div></div></div><a class="indexterm" id="id237"/><p>When a method of an object is called, it's first parameter is a reference to the object that contains the method. We'd like to be able to replace it with a mock, because that's the only way to truly separate each method, so that each can be tested as an individual unit. If we can't mock <code class="literal">self</code>, the methods will tend to interfere with each other's tests by interacting via their containing object.</p><p>The stumbling block in all this is that the <code class="literal">self</code> object isn't passed explicitly by the caller when a method gets called: Python already knows which object the method is bound to, and fills it in automatically. How can we substitute a mock for a parameter that doesn't come from us?</p><p>We can solve this problem by finding the function that we're testing in its class and invoking it directly, rather than invoking it as a method bound to an object. That way, we can pass all of the parameters, including the first one, without the interpreter performing any of its magic.</p></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec39"/>Time for action – passing a mock object as self</h1></div></div></div><div><ol class="orderedlist arabic"><li class="listitem"><a class="indexterm" id="id238"/><a class="indexterm" id="id239"/>Remember the <code class="literal">testable</code> class that we used, among other things, to demonstrate how it can be difficult to separate methods so we can deal with them as units? Although we saw this before in Chapter 3, here it is again:<div><pre class="programlisting">class testable:
    def method1(self, number):
        number += 4
        number **= 0.5
        number *= 7
        return number

    def method2(self, number):
        return ((number * 2) ** 1.27) * 0.3

    def method3(self, number):
        return self.method1(number) + self.method2(number)

    def method4(self):
        return self.method3(id(self))</pre></div></li><li class="listitem"><a class="indexterm" id="id240"/><a class="indexterm" id="id241"/>We're going to write a unit test for <code class="literal">method3</code>. Like all unit tests, it needs to not involve any code from any other unit, which in this case means that <code class="literal">self.method1</code> and <code class="literal">self.method2</code> need to be mock objects. The best way to achieve that is to have <code class="literal">self</code> itself be a mock object, so that's what we're going to do. The first step is to create a mock object that expects the interactions that <code class="literal">method3</code> ought to perform:<div><pre class="programlisting">&gt;&gt;&gt; from testable import testable
&gt;&gt;&gt; from mocker import Mocker
&gt;&gt;&gt; mocker = Mocker()

&gt;&gt;&gt; target = mocker.mock()
&gt;&gt;&gt; target.method1(12) # doctest: +ELLIPSIS
&lt;mocker.Mock object at ...&gt;
&gt;&gt;&gt; mocker.result(5)
&gt;&gt;&gt; target.method2(12) # doctest: +ELLIPSIS
&lt;mocker.Mock object at ...&gt;
&gt;&gt;&gt; mocker.result(7)</pre></div></li><li class="listitem"><code class="literal">method3</code> is supposed to call <code class="literal">method1</code> and <code class="literal">method2</code>, and the mock we just created expects to see calls to <code class="literal">method1</code> and <code class="literal">method2</code>. So far, so good, so what's the trick to getting this mock object to be <code class="literal">self</code> for a call to <code class="literal">method3</code>? Here's the rest of the test:<div><pre class="programlisting">&gt;&gt;&gt; mocker.replay()
<strong>&gt;&gt;&gt; testable.method3.im_func(target, 12)</strong>
12</pre></div></li></ol></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec65"/>
<em>What just happened?</em>
</h2></div></div></div><a class="indexterm" id="id242"/><p>We went to the <code class="literal">testable</code> class and looked up its <code class="literal">method3</code> member, which is something called an "unbound method object." Once we had an unbound method object, we looked <a class="indexterm" id="id243"/>inside of it for its <code class="literal">im_func</code> attribute, which is simply a function, without any of the razzmatazz associated with methods. Once we had a normal function in hand, it was easy to call it, and pass our mock object as its first parameter.</p><div><div><h3 class="title"><a id="note16"/>Note</h3><a class="indexterm" id="id244"/><a class="indexterm" id="id245"/><p>Python version 3.0 made this easier, by getting rid of unbound method objects in favor of just storing the function object directly in the class. This means that if you're using Python 3.0 or higher, you can just call <code class="literal">testable.method3(target, 12)</code>.<a class="indexterm" id="id246"/>
</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec40"/>Summary</h1></div></div></div><p>We learned a lot in this chapter about mocking, and about the Python Mocker. We focused on the assorted features that Mocker provides to help you keep units separate from each other.</p><p>Specifically, we covered what mock objects are, and what they're for, how to use Python Mocker to make mocking easier, lots of ways to customize Mocker's behavior to suit your needs, and how to substitute a mock object for a method's <code class="literal">self</code> parameter.</p><p>By this time, we've started to see situations where <code class="literal">doctest</code>—simple and easy though it is—begins getting unwieldy. In the next chapter, we're going to look at Python's other built-in framework for unit testing: <code class="literal">unittest</code>.</p></div></body></html>