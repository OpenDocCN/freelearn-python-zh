- en: Chapter 4. Variables, Assignment and Scoping Rules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An expression creates objects; we can assign objects to variables to preserve
    them for future use. Python offers a number of variations on the theme of assignment.
    In addition to simply assigning a single variable, we can assign items from a
    tuple to multiple variables. We can also combine an operator with assignment,
    which updates a mutable object.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we'll also look at the `input()` function as a way to introduce
    new objects into a running script. This is limited—it doesn't compare with a proper
    **graphical user interface** (**GUI**). It will, however, help us learn more Python
    programming techniques before we introduce how to read data from files and the
    filesystem in [Chapter 10](ch10.html "Chapter 10. Files, Databases, Networks,
    and Contexts"), *Files, Databases, Networks, and Contexts*.
  prefs: []
  type: TYPE_NORMAL
- en: We'll also look at some important Python language concepts. We'll look at the
    way Python programs are always written generically, without specific bindings
    to data types or classes. We'll also look at the general concept of a namespace,
    and how this is applied widely in various Python language constructs. It defines
    the scope in which an identifier is visible; something that will become increasingly
    important as our programs become more complex.
  prefs: []
  type: TYPE_NORMAL
- en: Simple assignment and variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ve seen a few examples of the essential Python assignment statement in
    previous chapters. The statement includes a variable, `=`, and an expression.
    Since a single object is an expression, we can write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This will create the floating-point literal `3.14` and assign this object to
    a variable named `pi`.
  prefs: []
  type: TYPE_NORMAL
- en: Variable names must follow the rules in section 2.3, *Identifiers and Keywords*,
    of the *Python Language Reference*. The reference manual uses the Unicode character
    class definitions provided in the `unicodedata` module.
  prefs: []
  type: TYPE_NORMAL
- en: Interesting background information on the problem of programming language identifiers
    is available in Unicode Standard Annex 31, *Unicode Identifier and Pattern Syntax*.
    This shows how the Python problem of how "what is an identifier?" fits into the
    larger context of other programming languages and the variety of natural languages
    used around the world.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Python, identifiers have a small set of start characters; these are chosen
    to allow a lexical scanner to determine what kinds of characters can follow. If
    identifiers began with digits, it would be rather complex to distinguish identifiers
    from numbers. Consequently, identifiers must begin with a letter or `_`. After
    the initial character, Python allows an identifier to continue with characters
    that may come from a larger set of characters: letters, digits, and `_`.'
  prefs: []
  type: TYPE_NORMAL
- en: What do we really mean by "letter" or "digit"? In earlier versions of Python,
    these terms were defined by the Latin-based ASCII alphabet. Using Unicode means
    that the terms now have more inclusive definitions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python defines the identifier starting character as belonging to the following
    Unicode categories: uppercase letters (`Lu`), lowercase letters (`Ll`), title
    case letters (`Lt`), modifier letters (`Lm`), other letters (`Lo`), and letter
    numbers (`Nl`). Python also includes the small set of characters in the `Other_ID_Start`
    category. The set of characters defined by these categories is large. Latin letters
    in the ranges `a-z` and `A-Z`, for example, are in this set. When writing more
    mathematically-oriented programs, the Greek letters `α-ω` and `A-Ω` can also be
    used as identifier start characters. We can write this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This assigns the result of the expression to the variable, `π`. Some programmers
    find that their OS keyboard interface makes letters outside a single national
    alphabet awkward to use; consequently, they suggest focusing on Latin letters
    for programming.
  prefs: []
  type: TYPE_NORMAL
- en: 'Identifiers can continue with any of the letters defined in the previous paragraph,
    the `_` character, and characters from the following categories: nonspacing marks
    (`Mn`), spacing combining marks (`Mc`), decimal numbers (`Nd`), and connector
    punctuations (`Pc`). This allows us to include ordinary decimal digits as well
    as other "combining" marks that modify the previous character. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This shows the character **GREEK SMALL LETTER PI** followed by the **COMBINING
    DIACRITICAL CIRCUMFLEX** to create a "pi-hat" variable, ![Simple assignment and
    variables](img/B03671_04_01.jpg). It may be awkward to type for some developers,
    but it also may fit nicely with a population genomics formulae which use this
    symbol combination. The Inheritance By Descent estimator, for example, uses ![Simple
    assignment and variables](img/B03671_04_01.jpg). The expression shown earlier
    involves two other variables, `p_2` and `p_1`, which use more common Latin letters,
    `_,` and digits.
  prefs: []
  type: TYPE_NORMAL
- en: Note that variable names that begin and end with `__` (two underscores) are
    reserved by Python for special purposes. For example, we have global variables
    such as `__name__`, `__debug__`, and `__file__` which are set when our script
    starts running.
  prefs: []
  type: TYPE_NORMAL
- en: There's no reason for our application to ever create new names which begin and
    end with `__`. We're not prohibited from creating such variables, but any name
    that we might adopt could be used by some internal feature of Python.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It's best to assume that at all names beginning and ending with `__` (double
    underscore) are reserved by Python and do something special. Even if the name
    is not used in the current release, that doesn't mean it won't be used in a future
    release.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple assignment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We looked at tuples in [Chapter 2](ch02.html "Chapter 2. Simple Data Types"),
    *Simple Data Types*. One of the important reasons for using a tuple is that it
    has a fixed number of items. Since a tuple is a kind of sequence, we can refer
    to items within a tuple using numeric indices.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following RGB triple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We can use `brick_red[0]` to get the red element of this triple.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We've used multiple assignment to decompose the RGB three-tuple into three individual
    variables.
  prefs: []
  type: TYPE_NORMAL
- en: This works when the number of variables on the left side of the `=` matches
    the number of items in the collection on the right side. When working with fixed-sized
    tuples, this is an easy condition to guarantee.
  prefs: []
  type: TYPE_NORMAL
- en: When working with mutable collections such as `list`, `set`, or `dict`, this
    kind of assignment may not work out well. If we can't guarantee the number of
    elements in a mutable collection, we may wind up with a `ValueError` exception
    because our collection doesn't match the number of variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that Python''s syntax flexibility means that we can also do things like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: It isn't absolutely necessary to wrap a tuple in `()`. It's generally a best
    practice to use `()` around a tuple. However, in a few cases, the statement is
    perfectly clear without the additional parentheses.
  prefs: []
  type: TYPE_NORMAL
- en: Using repeated assignment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Python allows us to write statements like this: `a = b = 0`. This must be used
    carefully, because a single object is now shared by two variables. When working
    with immutable objects like numbers, strings, and tuples, multiple variables share
    a reference to a common object.'
  prefs: []
  type: TYPE_NORMAL
- en: When we look at mutable objects in [Chapter 6](ch06.html "Chapter 6. More Complex
    Data Types"), *More Complex Data Types*, we'll see that this kind of repeated
    assignment can become a source of confusion. While this assignment is legal, it
    must be used only with immutable objects like numbers, strings, or tuples.
  prefs: []
  type: TYPE_NORMAL
- en: Using the head, *tail assignment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When working with sequences, there are some algorithms which work by separating
    the head of the sequence from the rest of the sequence. We can do this with a
    variation on the assignment statement. We like to call this the `head, *tail =`
    assignment statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say that we have an input string with a list of values, something like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We have split the string into space-delimited words with `line.split()`. In
    this case, the head of the list is the first three fields of the red, green, and
    blue elements of a color. The tail is all the remaining fields, which is the name
    parsed into separate words.
  prefs: []
  type: TYPE_NORMAL
- en: We can use `head, *tail =` assignment to split the first three fields from the
    remaining files.
  prefs: []
  type: TYPE_NORMAL
- en: 'It looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We've assigned the first three items to three separate variables, `r`, `g`,
    and `b`. The `*` means that all of the remaining items will be collected into
    a single variable, `name`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can reconstruct the original name with the `join()` method, with a space
    as the separator string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We've used a space to join the elements of the sequence named `name`. This will
    reconstruct the original color name as a single string instead of a list of words.
  prefs: []
  type: TYPE_NORMAL
- en: Augmented assignment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The augmented assignment statement combines an operator with assignment. A
    common example is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This is equivalent to
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: When working with immutable objects (numbers, strings, and tuples) the idea
    of an augmented assignment is syntactic sugar. It allows us to write the updated
    variable just once. The statement `a += 1` always creates a fresh new number object,
    and replaces the value of *a* with the new number object.
  prefs: []
  type: TYPE_NORMAL
- en: Any of the operators can be combined with assignment. The means that `+=`, `-=`,
    `*=`, `/=`, `//=`, `%=`, `**=`, `>>=`, `<<=`, `&=`,`^=`, and `|=` are all assignment
    operators. We can see obvious parallels between sums using `+=`, and products
    using `*=`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of mutable objects, this augmented assignment can take on special
    significance. When we look at `list` objects in [Chapter 6](ch06.html "Chapter 6. More
    Complex Data Types"), *More Complex Data Types*, we''ll see how we can append
    an item to a `list` object. Here''s a forward-looking example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This assigns a `list` object, a variable-length sequence of items, to the variable
    `some_list`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can update this `list` object with an augmented assignment statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, we''re actually mutating a single `list` object, changing its
    internal state by extending it with items from another `list` instance. The existing
    object was updated; this does not create a new object. It is equivalent to using
    the `extend()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We've mutated the `list` object a second time, extending it with items from
    another single-item `list` object.
  prefs: []
  type: TYPE_NORMAL
- en: This optimization of a `list` object is something that we'll look at in [Chapter
    6](ch06.html "Chapter 6. More Complex Data Types"), *More Complex Data Types*.
  prefs: []
  type: TYPE_NORMAL
- en: The input() function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For simple applications, the `input()` function can be used to gather input
    from a user. This function writes a prompt and accepts input. The returned value
    is a string. We might use this in a script file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This will write a simple prompt on the console, and accept a string as input.
    The string value will be converted to a floating-point number, if possible. If
    the string is not a valid number, the `float()` function will raise an exception.
    This will then print a line of output.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how it looks when we run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We've highlighted the command, which is entered after the OS shell prompt. The
    statements in the script file, named as part of the command, are executed in order.
  prefs: []
  type: TYPE_NORMAL
- en: Our input to Python, `11`, is also highlighted, to show how the `input()` function
    supports simple interaction.
  prefs: []
  type: TYPE_NORMAL
- en: The `input()` function only returns a Unicode string. Our script is responsible
    for any further parsing, validation, or conversion.
  prefs: []
  type: TYPE_NORMAL
- en: When working on simple console applications, there are some additional libraries
    which may prove helpful. There is a `getpass` module which helps to get passwords
    by suppressing the character echo that's a default feature of console input. This
    is highly recommended as an alternative to plain passwords in a parameter file
    or the passwords provided on the command line.
  prefs: []
  type: TYPE_NORMAL
- en: We can include the `readline` module to provide a comprehensive history of input
    that makes it easier for interactive users to recover previous inputs. Additionally,
    the `rlcompleter` module can be used to provide auto-complete features so that
    users only need to enter partial commands.
  prefs: []
  type: TYPE_NORMAL
- en: Beyond this, Python can include an implementation of the Linux `curses` library
    for building richly interactive **character user interface** (**CUI**) applications.
    This is sometimes used to provide colored output on the console, something that
    can make a complex log easier to read.
  prefs: []
  type: TYPE_NORMAL
- en: Python is used in a wide variety of application contexts. When building a web
    server, for example, the idea of console or command-line input is utterly out
    of place. Similarly, the `input()` function isn't going to be part of a GUI application.
  prefs: []
  type: TYPE_NORMAL
- en: Python language concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll introduce a few central concepts of the Python language before looking
    at more complex examples in later chapters. The first of the central concepts
    is that everything in Python is an object. Several popular languages have **primitive**
    types which escape the object-oriented nature of the language. Python doesn't
    have this feature. Even simple integers are objects, with defined methods.
  prefs: []
  type: TYPE_NORMAL
- en: Because everything is an object, we're assured of consistent behavior with no
    special cases. In some languages, the `==` operator works in one way for primitive
    types and in another way for objects. Python lacks this divergent behavior. All
    built-in classes implement the `==` operator consistently; unless we make specific
    (and pathological) implementation choices, our own classes will also behave consistently.
  prefs: []
  type: TYPE_NORMAL
- en: This consistency is particularly pleasant when working with strings. In Python,
    we always compare strings for equality using something like `txt.lower() = "hours"`.
    This will make the expected character-by-character comparison between the value
    of `txt.lower()` and the literal `"hours"`.
  prefs: []
  type: TYPE_NORMAL
- en: Less commonly, we can see if two variables are references to the same underlying
    object using the `is` comparison operator. This is generally used to compare a
    variable with the `None` object. We use `is None` because the `None` object is
    a proper singleton; there can be only one instance of `None`. We'll look at this
    again in [Chapter 5](ch05.html "Chapter 5. Logic, Comparisons, and Conditions"),
    *Logic, Comparisons, and Conditions*.
  prefs: []
  type: TYPE_NORMAL
- en: Object types versus variable declarations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Python, we specify the processing generically with respect to type. We may
    write a sequence of statements with the implicit understanding that floating-point
    values should be used. We can formalize this to an extent using an explicit `float()`
    conversion function.
  prefs: []
  type: TYPE_NORMAL
- en: In some languages, each variable has a statically defined type. Only objects
    of the named type can be assigned to the variable.
  prefs: []
  type: TYPE_NORMAL
- en: In contrast to languages with statically defined variables, a Python variable
    can be understood as a name which is attached to an object. We can attach a name
    to any object of any class. We don't statically declare a narrow range of allowed
    types for a variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python allows us to assign multiple names to the same object by assigning the
    object to several variables. For example, when we evaluate a function, the function
    parameter variable names are assigned to the argument objects. (We''ll look at
    this in more depth in [Chapter 7](ch07.html "Chapter 7. Basic Function Definitions"),
    *Basic Function Definitions*.) This means that each object may have two variables
    referring to it: one parameter variable inside the function and another variable
    outside the function.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the internal `id()` function to see if two variables refer to the
    same underlying object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: From this, we can see that Python variables `a` and `b` have references to the
    underlying object, not copies of the object.
  prefs: []
  type: TYPE_NORMAL
- en: In the rare cases that object copying is necessary, we must do it explicitly.
    Details vary, based on the general kind of class. For example, sequences are trivially
    cloned by creating a slice that includes the entire sequence. Some classes offer
    a `copy()` method. Objects can also be cloned via functions in the `copy` library.
  prefs: []
  type: TYPE_NORMAL
- en: 'The lack of a fixed type declaration for a variable has several consequences:'
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s trivial to introduce a variable to decompose a complex expression. Here''s
    a complex expression:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can trivially rewrite this by pulling out subexpressions and assigning them
    to variables:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We've extracted each subexpression and assigned them to separate variables.
    We never need to know what the intermediate result types are.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: All algorithms are written generically. When we run a script, we apply our generic
    Python code to concrete objects. Our canonical example of this binding is based
    on the numeric tower. We can apply the same expression, `32+9*c/5`, to objects
    of the classes `complex`, `float`, `int`, `Decimal`, and `Fraction`. All of these
    classes provide the necessary implementations of the various operators. However,
    a string object won't implement all of the arithmetic operations required, and
    won't work. Similarly, we can execute statements like `head, *tail = sequence`
    for a wide variety of sequence-like classes, including `list`, `str`, `bytes`,
    and `tuple`. However, if we assign a numeric value to the variable named `sequence`,
    the statement won't work.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoiding the declaration of variables with static types is a great simplification.
    We can introduce variables as needed. We can write clear, simple, generic software
    and leave it to the Python runtime processing to determine if the runtime objects
    have the required implementations for operators and methods.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding confusion when naming variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Without variable declarations, there's a small possibility of creating programs
    which are confusing if we use vague, generic variables. A variable with a vague
    name like `list_of_items` might get used more than once in a longish sequence
    of statements. Worse, of course, are variables with names like `t` or `temp`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Name variables as specifically as possible. Avoid vague, generic names.
  prefs: []
  type: TYPE_NORMAL
- en: The other aspect of overusing variable names is the idea of a "longish" sequence
    of statements. If the body of a function is so long that generically-named variables
    could get reused accidentally, the size of the function has become a problem.
    No stretch of Python code should be so long that the variables used within it
    are confusing.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Keep sequences of code short and focused. Avoid long sequences of code where
    variables might get reused incorrectly.
  prefs: []
  type: TYPE_NORMAL
- en: It's import to name variables simply and clearly. In Python, the use of *Hungarian
    notation* to decorate a variable name with type information is considered deplorable.
    The original concept of Hungarian notation was to place a few characters as a
    prefix on a variable to indicate the type. In Python, we do not name a variable
    `lst_str_names` using a prefix to indicate that the variable refers to a list
    of string values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because Python code is written generically, a well-written function can apply
    to many different data types. If we try to encode data type information in variable
    names, we may actually be sowing confusion: the algorithm may work for types not
    explicitly stated in the variable name.'
  prefs: []
  type: TYPE_NORMAL
- en: In some situations, we need to distinguish between a collection of items and
    an individual item. We might have a `name_list` and an individual `name`. Or we
    might have a `name_iter`, when working with generator functions, and an individual
    `name`. A small, clear naming convention like this is better than elaborately
    misleading Hungarian notation.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Avoid complex Hungarian notation in variable names.
  prefs: []
  type: TYPE_NORMAL
- en: In a more complex program, we might have a dictionary that maps integer keys
    to sets associated with those keys; each set may have a collection of individual
    strings. It's difficult to summarize this with a Hungarian prefix or suffix. Would
    we want to try and call this `map_int_set_str_something`?
  prefs: []
  type: TYPE_NORMAL
- en: Looking ahead to [Chapter 7](ch07.html "Chapter 7. Basic Function Definitions"),
    *Basic Function Definitions* and [Chapter 11](ch11.html "Chapter 11. Class Definitions"),
    *Class Definitions*, we'll often use `docstring` comments in functions, classes,
    and modules to capture the details of what kind of structure is appropriate for
    a function. We may even include test cases in the `docstring` comments; test cases
    are perhaps the clearest and most precise way to describe data.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Write `docstring` comments in every context that allows them: function, class,
    module, and package.'
  prefs: []
  type: TYPE_NORMAL
- en: One consequence of Python's use of variables is that we rely on unit test cases
    to ensure that results are of the expected types as well as being correct. Programmers
    who work in languages with statically-typed variables are very aware that unit
    test cases are essential for correctness, even when a compiler does type checking
    of all variable declarations. In Python, the test cases are just as important
    as in languages that have static type checking. If it is necessary to clarify
    the intent of a function or class, we can include type checking in the test cases.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Write unit tests; use the `unittest` module, the `doctest` module, or both.
  prefs: []
  type: TYPE_NORMAL
- en: Garbage collection via reference counting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We've seen how expressions create new objects. Even something as simple as `2**2024`
    creates a new integer object. What happens to these objects? When will we run
    out of memory?
  prefs: []
  type: TYPE_NORMAL
- en: 'Python uses reference counting to determine how many times an object is being
    used when we do something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The resulting object is a very large integer; it is assigned to the variable
    `_` automatically. The object, shown as `192624...497216`, has a single reference;
    this keeps it alive in memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we do this, next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We get a new object, and it is assigned to the variable `_`. The large integer
    value formerly assigned to `_` has no more references. Since it's no longer being
    used, it's garbage, and the memory it occupied can be reused.
  prefs: []
  type: TYPE_NORMAL
- en: Each time we assign an object to a variable, the reference count goes up by
    one. Each time the variable's value is reassigned, the previous object that is
    no longer in use has its reference count decreased by one.
  prefs: []
  type: TYPE_NORMAL
- en: When a variable is no longer required, the variable is removed, and the objects
    referred to by the variable also have their reference counts reduced by one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Variables belong to namespaces. Most of our early examples used the global
    namespace. In [Chapter 7](ch07.html "Chapter 7. Basic Function Definitions"),
    *Basic Function Definitions*, we''ll see local namespaces. To summarize: when
    a namespace is removed, all of the variables in that namespace are removed, and
    all of the object references are decremented by one.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When the number of references to an object reaches zero, the object is no longer
    needed. The memory occupied by that object can be reclaimed.
  prefs: []
  type: TYPE_NORMAL
- en: We can easily create two complex objects which refer to each other. In the presence
    of these kinds of circular references, of course, the counts can never reach zero.
    The objects may never get removed from memory. We can use the `gc` module to discover
    more about this.
  prefs: []
  type: TYPE_NORMAL
- en: In the case where we must have objects with mutual references, we need to leverage
    the `weakref` module. This module provides references among objects that do not
    interfere with reference counting, allowing a large data structure of multiple
    objects to gracefully vanish from memory when no longer in use.
  prefs: []
  type: TYPE_NORMAL
- en: The little-used del statement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can remove variables manually with the `del` statement. Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We've created an integer object, and assigned it to the variable `a`. When we
    remove the variable, this will reduce the reference count on the integer object.
    The memory occupied by the big integer is now eligible to be reclaimed.
  prefs: []
  type: TYPE_NORMAL
- en: This kind of thing is done very rarely. Python's ordinary reference counting
    does almost everything we need. It's generally best not to waste brain calories
    tying to micro-manage memory allocation.
  prefs: []
  type: TYPE_NORMAL
- en: The Python namespace concept
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've already seen two applications of the Python namespace. When we assign
    variables at the `>>>` prompt, we're introducing the variable into the global
    namespace. When we import a module, the module creates its own namespace within
    the global namespace.
  prefs: []
  type: TYPE_NORMAL
- en: That's why we can then use qualified names like `math.sqrt()` to refer to objects
    inside the module's namespace.
  prefs: []
  type: TYPE_NORMAL
- en: When we look at functions and class definitions, we'll see additional use, of
    namespaces. In particular, when evaluating a function or a class method, a local
    namespace is created, and all variables are part of that local namespace. When
    the function evaluation finishes (because of an explicit `return` statement or
    the end of the indented block,) the local namespace is dropped, removing all local
    variables and reducing the reference count on all objects assigned to those local
    variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, the `types` module includes the `SimpleNamespace` class. An instance
    of this class allows us to build a complex object without a formal class definition.
    Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We've imported the `SimpleNamespace` class. We created an instance of that class,
    assigning three local variables, `red`, `green`, and `blue`, that are part of
    the new `SimpleNamespace` object. When we examine the object as a whole, we see
    that it has three internal variables.
  prefs: []
  type: TYPE_NORMAL
- en: We can use syntax like `red_violet.blue` to see the `blue` variable inside the
    `red_violet` namespace.
  prefs: []
  type: TYPE_NORMAL
- en: The `argparse` module is used by command-line programs to parse the command-line
    arguments. This module also contains a `Namespace` class definition. An instance
    of `Namespace` is used to collect the various arguments parsed from the command
    line. An application can set additional variables in the `Namespace` object to
    handle particularly complex parsing and configuration issues.
  prefs: []
  type: TYPE_NORMAL
- en: Globals and locals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we use a variable name in an expression, Python searches two namespaces
    to resolve the name and locate the object to which it refers. First, it checks
    the local namespace. If the name is not found, it will check the global namespace.
    This two-step search will ensure that local variables used inside a function or
    class method are used before global variables with the same name.
  prefs: []
  type: TYPE_NORMAL
- en: When working from the `>>>` prompt using the REPL, we can only create and use
    global variables. Further examples will have to wait until [Chapter 7](ch07.html
    "Chapter 7. Basic Function Definitions"), *Basic Function Definitions*.
  prefs: []
  type: TYPE_NORMAL
- en: When we use the `locals()` and `globals()` functions at the `>>>` prompt, we
    can see that they have the same results. At the `>>>` prompt, and at the top-level
    of a script file, the local namespace is the global namespace. When evaluating
    a function, however, the function works in a separate, local namespace.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've looked at how we assign objects to variables. We've looked at the simple
    assignment statement, as well as multiple assignment and augmented assignment.
    With augmented assignment, we can update a variable by applying an operator and
    an operand. This is a handy syntactic shortcut.
  prefs: []
  type: TYPE_NORMAL
- en: We've also addressed the `input()` function, which is a way to create new objects
    based on user input. It's very handy for simple command-line scripts. More sophisticated
    GUIs, of course, will have considerably more sophisticated input mechanisms.
  prefs: []
  type: TYPE_NORMAL
- en: The concept of a namespace, and how variables are tracked via a namespace, is
    central to Python. When a namespace is no longer needed, it's discarded, removing
    all of the variables. This will also reduce the reference count on all of the
    objects referred to by the variables. Once an object's reference count is reduced
    to zero, the object can be removed from memory. This is a tidy and simple way
    to handle variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 5](ch05.html "Chapter 5. Logic, Comparisons, and Conditions"),
    *Logic, Comparisons, and Conditions*, we''ll look at another fundamental data
    type: Boolean. We''ll look at Python''s approach to Boolean values and the logical
    operators of `and`, `or`, `not`, and `if-else`. We''ll also look at the various
    comparison operators.'
  prefs: []
  type: TYPE_NORMAL
- en: We'll look at several kinds of Python statements, include the `if-elif-else`
    statement, the `pass` statement, and the `assert` statement. This will allow us
    to write somewhat more sophisticated scripts.
  prefs: []
  type: TYPE_NORMAL
