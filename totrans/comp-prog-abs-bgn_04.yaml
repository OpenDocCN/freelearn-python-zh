- en: '*Chapter 3:* Types of Applications'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Computer programs, or applications as we sometimes call them, come in many types.
    Each type solves a special kind of problem. Some applications, such as a solitaire
    game or a word processor, just run on a local computer, and others need to communicate
    with other computers or networks to work, such as web browsers or email clients.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will look at some special types of applications and discuss
    what considerations we need to take when creating them.
  prefs: []
  type: TYPE_NORMAL
- en: It would be impossible for us to cover all types of applications as there are
    way too many of them. Instead, we will look at some common types that we will
    encounter when writing our applications.
  prefs: []
  type: TYPE_NORMAL
- en: We create programs to solve problems, and in the process of designing our application
    and deciding what it needs to do, we will often look at solutions others have
    found for similar problems. The goal of this chapter is to familiarize you with
    some of these solutions so you can recognize the problem they solve when, in the
    future, you need to create your own solutions.
  prefs: []
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you will be able to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Understand what is typical for the different types of applications that the
    chapter covers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand how the application type affects how we structure our applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand the importance of connected applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand the benefits of using cloud-based solutions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand the problems the different kinds of applications we talk about can
    solve
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Standalone applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A standalone application is a program that can work offline, that is, it does
    not necessarily require a network connection. Therefore, when writing such an
    application, we will need to provide all the resources the program will require.
    These resources can be images, such as icons used in the application, files to
    store program configuration, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: When learning to write applications, most of your programs will likely fall
    into this category. It is usually a rather straightforward affair to create these
    applications as we will not need to interact with other programs.
  prefs: []
  type: TYPE_NORMAL
- en: Examples of programs that fall into this category are text editors such as Notepad
    on Windows or TextEdit on Mac, simple games such as solitaire, and paint programs.
  prefs: []
  type: TYPE_NORMAL
- en: Client-server applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Client-server is a model we can use to create distributed applications, which
    are applications that run on more than one machine.
  prefs: []
  type: TYPE_NORMAL
- en: The idea behind the client-server model is that we have at least two computers
    involved. One acts as the server, and all the others have the role of the client.
    Clients and servers need to communicate with each other. It is always the client
    who initiates the communication. Sometimes the server communicates with several
    clients at once; other times, the server only communicates with a single client
    at a time.
  prefs: []
  type: TYPE_NORMAL
- en: This means that we can use different computers to take care of different parts
    of an application's responsibility. We can let one computer deal with one aspect
    of a problem and another computer work on a different aspect of the same problem.
    These two computers then need to communicate their results, usually to a single
    computer, which can then assemble the different results into one solution.
  prefs: []
  type: TYPE_NORMAL
- en: We can also use this model when we have different roles for different parts
    of an application. For example, we have one role that is to display data to and
    get input from a user (user interaction) and another role that is to process and
    store this data. We can divide these roles so the processing and storing role
    is done by one computer and the user interaction role by another computer.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – A server connected to several clients](img/B15554_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.1 – A server connected to several clients
  prefs: []
  type: TYPE_NORMAL
- en: To illustrate this, let's take a couple of scenarios where we would use a client-server
    solution and see what the solutions would be.
  prefs: []
  type: TYPE_NORMAL
- en: Example of a chat application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's assume that you want to create an application where you and your friends
    can chat with each other. Everyone that will use this chat application will need
    the **client software**; this is the program we start when we want to chat.
  prefs: []
  type: TYPE_NORMAL
- en: When we start thinking about how to design this application, we will face our
    first problem. Imagine that you start your chat application because you want to
    chat with your friend Alice. Our application needs to connect to Alice's computer,
    running her version of our program. Both you and Alice will run identical programs,
    but how can they connect? How can our application find Alice's computer among
    all the computers connected to the internet? It would be like if you want to call
    Alice but don't have her phone number. Our chat application will be our phone,
    and Alice's client will be her phone. You can't just randomly enter a number in
    the hope of reaching Alice.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2 – How can you find Alice''s computer when you want to chat?](img/B15554_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.2 – How can you find Alice's computer when you want to chat?
  prefs: []
  type: TYPE_NORMAL
- en: An IP address (**IP** is an abbreviation for **Internet Protocol** and is part
    of a larger protocol stack, called TCP/IP, that describes how computers communicate
    over the internet) identifies all computers and other devices connected to the
    internet. We can think of this address as a phone number. This number can uniquely
    identify a telephone anywhere in the world. The same is true for an IP address;
    it can uniquely identify any device that is connected to the internet.
  prefs: []
  type: TYPE_NORMAL
- en: The problem is, how can we know what address Alice's computer has? And even
    if we knew what it was, we must understand that it is subject to change. If she
    is connected to her home Wi-Fi network, she will have one IP address, but if she
    takes her computer to a café downtown and connects to their Wi-Fi network, she
    will get another IP address. This is because when connecting to a Wi-Fi network,
    it is the network router that assigns an IP address to your computer.
  prefs: []
  type: TYPE_NORMAL
- en: A better solution would be if all clients connected to a computer that always
    has the same address. This would be our `company.com` is easier to remember than
    an IP address.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3 – Using a server to handle the communication between you and Alice](img/B15554_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.3 – Using a server to handle the communication between you and Alice
  prefs: []
  type: TYPE_NORMAL
- en: If more than two users are connected to the server, then the server will need
    to keep track of who is the recipient of the message. When you send your message
    to Alice, your client application will need to provide the identity of who should
    get the message so the server can make sure it is sent to the right client.
  prefs: []
  type: TYPE_NORMAL
- en: Example of an email client
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Assume that you have been using several different applications to read and write
    emails, but you are not happy with how they work and you decide to write your
    own. What you will write is an email client.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take our friend Alice again. What happens if she sends you an email? Your
    emails must be stored somewhere as you can't have your client application running
    all the time. The email Alice sends to you will end up on an **email server**.
    When you start the email client you wrote, it will connect to the server and ask
    for all new emails that have been received since the last time you connected.
    These will now be transferred to your client application.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.4 – An email server will handle incoming and outgoing emails,'
  prefs: []
  type: TYPE_NORMAL
- en: and the client only connects to receive and transmit messages](img/B15554_03_04.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: Figure 3.4 – An email server will handle incoming and outgoing emails, and the
    client only connects to receive and transmit messages
  prefs: []
  type: TYPE_NORMAL
- en: Client-server, a two-part solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In both these examples, we saw that the solution to a problem is divided into
    two parts. We need one part that will be the client, and the other will be the
    server. The characteristics of these two are that we have a server with its location
    known by its IP address, and we will have a client that will know about the server
    address and will be the part that initiates the communication. An IP address can
    also be in the form of a domain name, such as [http://some-server.com](http://some-server.com).
    A domain name is a one-to-one mapping between an IP address and a name. In other
    words, a domain name is tied to one single IP address and is used because it is
    easier to remember a domain name than an IP address that is just four numbers
    in the form `123.123.123.123`.
  prefs: []
  type: TYPE_NORMAL
- en: This format is true for the version of IP addresses called `2001:db8:a0b:12f0::1`.
    These numbers are separated by colon instead of a period. In IPv4 the address
    was represented as a 32-bit value, and in IPv6 it is 128 bits. This means that
    we have many more addresses to distribute.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes these two roles are only distinct for how the two parts will connect;
    the client connects to the server, and when the connection is made, they can act
    as two identical parts. If we take the chat application as an example, if we knew
    Alice's address, we could connect directly to her application. Our application
    will initially be the client, and Alice's application would act as the server.
    But as soon as we have a connection, both parts will act in the same way, and
    the roles of who is the client and who is the server will be unimportant.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we move to understanding web applications.
  prefs: []
  type: TYPE_NORMAL
- en: Web applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A web application is a special form of client-server application where we have
    a client that interacts with a user in the form of a web page. The server is responsible
    for producing the results the user will see and to accept and process the input
    from the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'This process works something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: Imagine that you visit a website and are prompted to log in. You enter your
    username and password. When you press the **Log in** button, the information you
    entered is sent to the server:![Figure 3.5 – When logging in to a web application,
    your credentials will be sent to the server](img/B15554_03_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 3.5 – When logging in to a web application, your credentials will be
    sent to the server
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The server requests the information stored in a database about this user:![Figure
    3.6 – The web server requests the user information stored in a database](img/B15554_03_06.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 3.6 – The web server requests the user information stored in a database
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The database returns the information it has for this user. Note that usually,
    the password will not be stored in plain text as illustrated here, but for clarity,
    we ignore that in this scenario:![Figure 3.7 – The database returns the information](img/B15554_03_07.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 3.7 – The database returns the information
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The server application now verifies that the username and password are correct.
    If they are, it then produces a web page for this user and transmits it to the
    client''s computer so that a web browser running on this computer can display
    this page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.8 – The server produces a web page and transmits it to the client](img/B15554_03_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.8 – The server produces a web page and transmits it to the client
  prefs: []
  type: TYPE_NORMAL
- en: Let's see what this means if we want to create our very own social network.
  prefs: []
  type: TYPE_NORMAL
- en: Example of a social network
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You would need to create both the client and the server part of this application.
    First, the user needs to log in. To do this, the client will ask the user for
    their credentials. The client will then send the username and password to the
    server, and the server will verify if the information is correct. The result will
    be sent back to the client. If the login fails, the user will be asked to try
    again. If it is successful, the user will see the main window with all the posts
    from friends and relatives.
  prefs: []
  type: TYPE_NORMAL
- en: It might feel like there is some magic going on here, because how did we get
    the most recent post your uncle did 5 minutes ago on the other side of the world?
  prefs: []
  type: TYPE_NORMAL
- en: 'Your uncle uses his client to create his post. The information about this post
    is sent to the server, which stores it in a database. When you log in, the server
    asks the database for all users you are connected to, and among them, it finds
    your uncle. Then the server checks if your uncle has made any recent posts and
    then finds his post. This post is now part of the result, together with posts
    from other friends, that is sent to you:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.9 – Your uncle posts a new status update that gets included in your
    feed](img/B15554_03_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.9 – Your uncle posts a new status update that gets included in your
    feed
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will see how these apps are unique.
  prefs: []
  type: TYPE_NORMAL
- en: What makes web applications unique?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we have seen, a web application is more-or-less just a client-server solution,
    but there is a twist that makes it not just a client-server application, and that
    is how the client interacts with the user.
  prefs: []
  type: TYPE_NORMAL
- en: If we think back to the client-server applications we talked about previously,
    the chat and email programs had been designed as *standalone applications*. This
    means that we have a program on our computer that we can start. That is not the
    case for our social network application. When users want to access it, they will
    start a web browser and navigate to the server's address. We can say that the
    web browser is a general-purpose client as it is not made to serve one solution
    but can be used to access any page on the web, our social network being one of
    them.
  prefs: []
  type: TYPE_NORMAL
- en: We will still need to design what this page will look like and what information
    will be displayed to the user, but the client usually has very little program
    logic built into it. The logic of our application is done on the server side,
    and it's the server that will produce the pages the user sees. They are transmitted
    to the client, which is the user's web browser, which then displays the result.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we'll look at mobile applications.
  prefs: []
  type: TYPE_NORMAL
- en: Mobile applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we talk about a mobile application, we usually mean a program that is designed
    to run on a mobile device, such as a smartphone. These devices have some special
    characteristics that we need to consider when writing an application. First, their
    screen is smaller than a computer monitor. The screen can also be rotated in landscape
    or portrait orientation. We will also use the touchscreen of the device for input.
  prefs: []
  type: TYPE_NORMAL
- en: The mobile application might also use other features of the device, such as
    the GPS, sending text messages, or sensing the movement of the device using its
    accelerometer. These are things we usually can't do if an application runs on
    a normal computer.
  prefs: []
  type: TYPE_NORMAL
- en: A mobile application can be connected, but it does not have to be. Being connected
    means that it can communicate with another computer, maybe using the client-server
    techniques we discussed earlier.
  prefs: []
  type: TYPE_NORMAL
- en: When writing a mobile application, the platform the application will run on
    is very important. The reason is that the programs we write need to interact with
    the device more directly. This means is that it can dictate what programming language
    we will use to write these applications. The developers of the operating systems
    for mobile devices have some preferred programming languages. For iOS, Apple's
    operating system for mobile devices uses two languages, the old Objective-C and
    the new Swift. These are two languages you will hardly ever encounter if you are
    not creating applications for Apple devices. For the Android operating system,
    the preferred language used to be Java, but Google, which is the company behind
    Android, changed this in 2019 and now use a language called Kotlin as the preferred
    development language.
  prefs: []
  type: TYPE_NORMAL
- en: Having a preferred language for these systems does not mean that we can't use
    other languages. Still, Apple and Google recommend using these languages, so it
    is usually easier for us to use these languages when developing mobile applications.
    The reason is that the tools we use when writing our programs will be better suited
    to them than any other language.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we look at distributed applications.
  prefs: []
  type: TYPE_NORMAL
- en: Distributed applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A distributed application is an application that does not run on one single
    machine, but instead lets different parts of the program run on multiple computers
    that communicate with each other over a network. This might sound like the client-server
    solutions we talked about earlier, but here we don't have the distinct roles of
    a client and a server.
  prefs: []
  type: TYPE_NORMAL
- en: There could be several reasons to use this solution. One may be that what we
    are doing requires so much computing power that a single computer will not be
    enough. The idea is to use the computing power of many computers and distribute
    the calculations to all of them, letting each computer work on a small section
    of the problem and communicate the results to the other machines in the network.
    This will give us something of a *supercomputer* that will act as a very powerful
    single machine running a single application, when it is actually thousands of
    computers running small individual parts of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Let's explore distributed applications in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: SETI@home
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An example of a project that uses this technique is **SETI** (short for **Search
    for Extraterrestrial Intelligence**), a scientific project trying to find extraterrestrial
    intelligence in outer space. To do this, they use radio telescopes to collect
    lots of data. The problem is that all this data needs to be analyzed in the search
    for a signal that can be of intelligent origin. The solution they use is to let
    people help them out either by installing a screensaver on their computer or a
    special program that will use the computing power of that computer when it is
    not used for any other task. By doing this, they will have the power of all these
    computers to do the analysis, and they will report back the result of the part
    of the data that was assigned to them.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can try this out yourself by visiting [https://setiathome.berkeley.edu/](https://setiathome.berkeley.edu/)
    and installing the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.10 – SETI@home analyzing data. Copyright 2019 UC Regents. Used with
    permission](img/B15554_03_010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.10 – SETI@home analyzing data. Copyright 2019 UC Regents. Used with
    permission
  prefs: []
  type: TYPE_NORMAL
- en: Peer-to-peer networks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A **peer-to-peer** network, also known as **P2P**, is a network of computers
    that are equal participants in the network. Each computer in the network is called
    a node, or a peer, and they make portions of their resources, such as processing
    power or disk storage, directly available to other participants in the network.
    This technique was popularized by file-sharing systems such as Napster in the
    late ''90s. A peer in the network is both a supplier and a consumer of resources.
    This is what makes this solution different from a traditional client-server model
    in which the supply and consumption of resources are divided between the server
    and the client:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.11 – A P2P network where computers, or peers, are connected without
    a server](img/B15554_03_011.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.11 – A P2P network where computers, or peers, are connected without
    a server
  prefs: []
  type: TYPE_NORMAL
- en: Today, P2P networks are used by most cryptocurrencies making up a large portion
    of the blockchain industry (simply put, a blockchain is a database stored in separate
    copies on many nodes in a P2P network.). P2P is also used by web search engines,
    streaming platforms, and online marketplaces.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we look at cloud-based applications.
  prefs: []
  type: TYPE_NORMAL
- en: Cloud-based applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cloud computing was first mentioned in 1996, but it was not until Amazon released
    its Elastic Compute Cloud in 2006 that it became widely popular. The idea behind
    cloud-based computing is to move away from the need to host your servers and other
    resources needed to run your project, and instead buy time from large data centers
    to use their computing power. There are many advantages to this. You don't have
    to make sure that your computers are up and running, that operating systems are
    updated, that you have implemented back-up solutions for your data, and so on.
    You can set up your server to be online, and then you can deploy your software
    on this server and run it from there.
  prefs: []
  type: TYPE_NORMAL
- en: The companies providing these services soon began to add other features that
    we can use as well. These are ready-made parts that we can use in our applications.
    What this means is that there will be parts of our application that we won't need
    to write ourselves. Instead, we can buy these ready-made parts from the provider
    and integrate them into our application that will run on a server, also provided
    by them.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many variations of this: we can buy a server, we might only buy storage,
    or we might buy one or more services that we will use, and these can then be combined
    in any way we want.'
  prefs: []
  type: TYPE_NORMAL
- en: There are many reasons we would like to make our application using cloud-based
    resources. Let's look at some of them.
  prefs: []
  type: TYPE_NORMAL
- en: Advantages of adopting cloud-based applications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here are a couple of reasons why using cloud-based applications is beneficial
    for us.
  prefs: []
  type: TYPE_NORMAL
- en: Reduced costs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By having our application on a cloud-based server, we will not need to buy a
    server computer, and we will not need to maintain this computer. We can pay for
    services so the cloud service provider will take care of ensuring that our server's
    operating system is updated and that security patches are installed as they are
    released.
  prefs: []
  type: TYPE_NORMAL
- en: If our application is storing data, we can let the provider take care of making
    backups, making sure we don't lose any data. We can also let these backups be
    stored at different locations in the world, so even if one of the data centers
    our provider is using gets destroyed or affected for some reason, our data will
    remain safe.
  prefs: []
  type: TYPE_NORMAL
- en: These are just two examples of how we can reduce our costs as the amount we
    pay to the cloud service provider will be drastically lower than if we had done
    all of this ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: Scalability
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Scalability is how we can adapt when the amount of work our application is doing
    changes. If we, for example, have a web application running and suddenly it gets
    very popular overnight, we might go from a couple of hundred users that are simultaneously
    connected to it to several thousand. If the hardware running our application is
    not capable of handling this growing popularity, our users will soon get tired
    of using it as they need to spend too much time waiting for a response from our
    application. If we manage the hardware ourselves, we will need to get more and
    better server computers, install our application on them, and make sure everything
    works. If the interest in our application then drops, we will now have invested
    in hardware we no longer need.
  prefs: []
  type: TYPE_NORMAL
- en: If we, on the other hand, are using a cloud-based solution, we could, with a
    few clicks, pay to get more power to our servers. And if the demand drops, we
    can downgrade again and only pay for what we use. This process can also be automated,
    so the server hardware adapts to the demand.
  prefs: []
  type: TYPE_NORMAL
- en: Cloud service models
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Cloud computing providers offer different services according to three different
    models. These models define what parts the provider will handle and what is handled
    by us, the creators of the application. These different models can also be viewed
    as different layers, so when deciding what we need for our application, we can
    pick things from all three layers.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at these layers so that we understand what they can help us with.
  prefs: []
  type: TYPE_NORMAL
- en: Infrastructure as a Service (IaaS)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is the layer that handles hardware resources such as servers, storage,
    firewalls, and so on. Investing in services on this layer means that you don't
    need to buy the hardware, you don't need to spend time on configuration, and space
    for data storage will be managed for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some examples when IaaS is a good option for us are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Big data**: More and more applications need a huge amount of data. This can,
    for example, be data used when training **artificial intelligence** (**AI**) applications
    or applications that rely on a significant amount of what is known as unstructured
    data (that is, images, email, or social media content, for example). These applications
    will need to handle large workloads that can change over time. IaaS gives us tools
    to add storage and processing power with a click of a button; in fact, this can
    even be automated to suit our needs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Disaster recovery**: The most valuable asset we have in software is data,
    and we should always ensure that we can recover from a disaster. If we store copies
    of our data in different geographical locations, we can rest assured that we can
    recover it even if the worst happens. IaaS makes it easy and affordable to do
    this.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Testing and development**: When developing applications, we often want to
    test them on different hardware configurations running different operating systems.
    Setting up different IaaS solutions is a cheap and easy way to do this.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Platform as a Service (PaaS)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this layer, you will, among other things, find applications that will act
    as servers. Some examples are web servers that will handle web resources so users
    can access your website, and database servers that will manage storage and retrieval
    of data. This layer can also contain readily configured environments that are
    targeted to a programming language.
  prefs: []
  type: TYPE_NORMAL
- en: This level builds upon the IaaS level, so usually, you get the benefits of that
    layer plus the things that are included in this layer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s some examples of some benefits of using PaaS:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Faster time to market**: Going from an idea to a product that we can start
    to earn money from is essential when developing software. Using PaaS will dramatically
    reduce the time for acquiring hardware and installing and configuring software.
    There are examples of start-up companies that had an idea on Friday and a product
    that could be used on the next Monday. This can be made possible with the help
    of PaaS.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reduced costs**: Without the need to invest time and money acquiring hardware,
    configuring it, installing software, and ensuring all software is updated, our
    costs will be greatly reduced. The time we save can instead be used to develop
    our product.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Software as a Service (SaaS)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This layer will provide you with everything—the hardware, the server software,
    as well as applications—and the only thing you need to do is to configure it to
    work the way you want it to. A well-known example of SaaS is the array of Google
    apps. These are the applications provided by Google, such as Docs, Sheets, and
    Calendar.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s some examples of why you may want to use SaaS:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Less maintenance of office software**: When running a business, we need to
    provide email addresses to all our employees; we need to provide them with office
    applications such as word processors, spreadsheet applications, and presentation
    software. If we let someone else handle the installation, configuration, and updates,
    and reduce the time we spend on handling software licenses, we will free up resources
    and save money.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sharing information**: Using services such as cloud storage will make it
    easier to share files and documents between co-workers and customers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This completes our coverage of all the pertinent cloud service models.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a software developer, you will most likely work on the PaaS layer as it
    is the one providing the tools we need to develop our applications:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.12 – What the different cloud system layers handle](img/B15554_03_012.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.12 – What the different cloud system layers handle
  prefs: []
  type: TYPE_NORMAL
- en: Other advantages of cloud-based solutions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'These are just some examples of the advantages we get from using cloud-based
    solutions. In a 2017 article, The *Business Journal* lists what they think are
    the five biggest benefits of cloud-based solutions. They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Boost cost efficiency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide flexible pay options
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Promote collaboration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Increase mobility
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Aid in disaster recovery
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you search the web for the benefits of moving to the cloud, you will find
    similar lists. Some will also add environmental advantages.
  prefs: []
  type: TYPE_NORMAL
- en: We should also consider that there are risks of using cloud-based solutions.
    The major one is the security and personal integrity issues that can be hard to
    handle when you don't have full control over where and how the data is stored.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's look at some other types of applications.
  prefs: []
  type: TYPE_NORMAL
- en: Other types of applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Of course, we have several other categories that software can fall into. Let's
    look at some of them.
  prefs: []
  type: TYPE_NORMAL
- en: Systems software
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The software in this category helps the user, applications, and computer hardware
    to interact and function together. These applications create an environment that
    other programs can work in. When a computer is powered on, the first thing that
    is loaded into the computer's memory is system software applications. They will
    mostly run in the background, even if some of them can have a visual user interface.
    Because these programs work directly with the computer's hardware, they are often
    referred to as **low-level software**.
  prefs: []
  type: TYPE_NORMAL
- en: The most well-known type of application we find in this category is operating
    systems. As we saw in [*Chapter 1*](B15554_01_Final_NM_ePub.xhtml#_idTextAnchor016),
    *Introduction to Computer Programs*, they let other software run and take care
    of the direct communication with the hardware.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most well-known operating systems for desktop computers and laptops are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft Windows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: macOS and macOS X (for Apple devices)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For smartphones and tablets, we have the following operating systems:'
  prefs: []
  type: TYPE_NORMAL
- en: Android
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: iOS (for Apple devices)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Microsoft Windows Mobile
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Programming software
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this category, we find the tools and applications used by programmers when
    they write and test software. First, we need the programs that are the actual
    language the programmers use. To be able to write a program in C++, Java, Python,
    or any other language, we must first install the software that will take care
    of the translation of the source code into machine code (see [*Chapter 2*](B15554_02_Final_NM_ePub.xhtml#_idTextAnchor029),
    *Introduction to Programming Languages*).
  prefs: []
  type: TYPE_NORMAL
- en: A programmer often uses specialized text editors that will assist them when
    writing code. Some programs are even more advanced and will provide not only an
    editor for writing the code but a range of other built-in tools that are useful
    to have access to when writing programs. These are called **Integrated Development
    Environments** (**IDEs**). An example of a built-in tool is a debugger, which
    is a program that will help the programmer to find errors in the code.
  prefs: []
  type: TYPE_NORMAL
- en: Serverless applications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A serverless application is a specialized variant of cloud-based applications.
    It can come in several different forms. Common to all these variants is that the
    cloud provider runs the servers needed, and dynamically manages all the resources
    the application needs. What this means is that we, for example, will not need
    to buy storage of a fixed size. The provider will add more storage as we need
    it, and we will pay for the storage we use. We can compare this to a scenario
    where if our hard disk is full, it just keeps increasing its storage capacity
    to meet our needs for more space.
  prefs: []
  type: TYPE_NORMAL
- en: This kind of software is interesting if you want to automate the maintenance
    of servers, storage, and other aspects of your infrastructure. These solutions
    are *intelligent*, so they can adapt to changes, for example, by giving us more
    storage when we need and reducing it again when the need drops.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have talked about some typical types of applications and
    what makes them special.
  prefs: []
  type: TYPE_NORMAL
- en: We learned what a standalone application is and that this is the first type
    of application you will write when learning to program. After that, we looked
    at different types of applications that, in one way or the other, were divided
    to run parts of the program on different computers, and we saw that the parts
    communicate with each other.
  prefs: []
  type: TYPE_NORMAL
- en: We learned that a web application runs on a server but communicates with its
    users through web pages. We saw that mobile applications are special in that they
    can take advantage of the features of modern mobile devices including smartphones
    and tablets, such as the GPS and the camera.
  prefs: []
  type: TYPE_NORMAL
- en: Another category of applications is those that need lots of computing power
    and let many computers share the workload and perform parts of the computing.
    These are often referred to as distributed applications. Then we looked at a category
    that is growing fast, and that is cloud-based applications. The benefit of using
    these services is that it is usually much cheaper and more secure than if we manage
    everything ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we talked about a couple of other categories: system software, programming
    software, and serverless applications.'
  prefs: []
  type: TYPE_NORMAL
- en: All software will need to be written by programmers and, in this chapter, we
    saw that applications can come in many forms. You have different resources available
    to suit your application development needs. As a developer, you can specialize
    in one or a couple of categories, or you can choose to jump between technologies.
    No matter what you choose, the challenges will be very different depending on
    what type of application you are currently developing.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will take a closer look at what a software project is
    and how we can structure our code as our projects get larger. We will also talk
    about some details that have to do with problems we might run into as our projects
    grow, and how we can resolve those issues.
  prefs: []
  type: TYPE_NORMAL
