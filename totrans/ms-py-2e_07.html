<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer128" class="Basic-Text-Frame">&#13;
    <h1 class="chapterNumber">7</h1>&#13;
    <h1 id="_idParaDest-174" class="chapterTitle">Generators and Coroutines – Infinity, One Step at a Time</h1>&#13;
    <p class="normal">Generator functions are functions that behave like iterators by generating the return values one by one. While traditional methods build and return a <code class="inlineCode">list</code> or <code class="inlineCode">tuple</code> of items with a fixed length, a generator will <code class="inlineCode">yield</code> a single value only when requested by the caller. The side effect is that these generators can be infinitely large because you can keep yielding forever.</p>&#13;
    <p class="normal">In addition to <a id="_idIndexMarker475"/>generators, there is a variation to the generator’s syntax that creates coroutines. Coroutines are functions that allow multitasking without requiring multiple threads or processes. Whereas generators can only yield values to the caller based on the initial arguments, coroutines enable two-way communication with the calling function while running. The modern implementation of coroutines in Python is through the <code class="inlineCode">asyncio</code> module, which is covered extensively in <em class="chapterRef">Chapter 13, </em><em class="italic">asyncio – Multithreading without Threads</em>, but the basics stem from the coroutines discussed in this chapter. If coroutines or <code class="inlineCode">asyncio</code> work for your case, they can offer a tremendous performance improvement.</p>&#13;
    <p class="normal">In this chapter, we will cover the following topics:</p>&#13;
    <ul>&#13;
      <li class="bulletList">Advantages and disadvantages of generators</li>&#13;
      <li class="bulletList">The characteristics and quirks of generators</li>&#13;
      <li class="bulletList">Creating generators using regular functions</li>&#13;
      <li class="bulletList">Generator comprehensions similar to <code class="inlineCode">list</code>, <code class="inlineCode">dict</code>, and <code class="inlineCode">set</code> comprehensions</li>&#13;
      <li class="bulletList">Creating generators using classes</li>&#13;
      <li class="bulletList">Generators bundled with Python</li>&#13;
      <li class="bulletList">A basic implementation of coroutines and a few of their quirks</li>&#13;
    </ul>&#13;
    <h1 id="_idParaDest-175" class="heading-1">Generators</h1>&#13;
    <p class="normal">Generators<a id="_idIndexMarker476"/> are a very useful tool but they come with a set of rules to keep in mind.</p>&#13;
    <p class="normal">First, let’s explore the advantages <a id="_idIndexMarker477"/>of generators: </p>&#13;
    <ul>&#13;
      <li class="bulletList">Generators are often simpler to write than list-generating functions. Instead of having to declare a <code class="inlineCode">list</code>, <code class="inlineCode">list.append(value)</code>, and <code class="inlineCode">return</code>, you only need <code class="inlineCode">yield value</code>.</li>&#13;
      <li class="bulletList">Memory usage. Items can be processed one at a time, so there is generally no need to keep the entire list in memory.</li>&#13;
      <li class="bulletList">Results can depend on outside factors. Instead of having a static list, you generate the value when it is being requested. Think of processing a queue/stack, for example.</li>&#13;
      <li class="bulletList">Generators are lazy. This means that if you’re using only the first five results of a generator, the rest won’t even be calculated. Additionally, between fetching the items, the generator is completely frozen.</li>&#13;
    </ul>&#13;
    <p class="normal">The most<a id="_idIndexMarker478"/> important disadvantages are:</p>&#13;
    <ul>&#13;
      <li class="bulletList">Results are available only once. After processing the results of a generator, it cannot be used again.</li>&#13;
      <li class="bulletList">The size is unknown. Until you are done processing, you cannot get any information about the size of the generator. It might even be infinite. This makes <code class="inlineCode">list(some_infinite_generator)</code> a dangerous operation. It can quickly crash your Python interpreter or even your entire system.</li>&#13;
      <li class="bulletList">Slicing is not possible, so <code class="inlineCode">some_generator[10:20]</code> will not work. You can work around this using <code class="inlineCode">itertools.islice</code> as you will see later in this chapter, but that effectively discards the unused indices.</li>&#13;
      <li class="bulletList">Indexing generators, similar to slicing, is also not possible. This means that the following will not work: <code class="inlineCode">some_generator[5]</code>.</li>&#13;
    </ul>&#13;
    <p class="normal">Now that you know what to expect, let’s create a few generators.</p>&#13;
    <h2 id="_idParaDest-176" class="heading-2">Creating generators</h2>&#13;
    <p class="normal">The <a id="_idIndexMarker479"/>simplest generator is a function containing a <code class="inlineCode">yield</code> statement instead of a <code class="inlineCode">return</code> statement. The key difference with regular functions containing a <code class="inlineCode">return</code> is that you can have many <code class="inlineCode">yield</code> statements in your function.</p>&#13;
    <p class="normal">An example <a id="_idIndexMarker480"/>of a generator with a few fixed <code class="inlineCode">yield</code> statements and how it behaves with several operations is as follows:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">generator</span><span class="hljs-con-function">():</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">yield</span><span class="python"> </span><span class="hljs-con-number">1</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">yield</span><span class="python"> </span><span class="hljs-con-string">'a'</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">yield</span><span class="python"> []</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">return</span><span class="python"> </span><span class="hljs-con-string">'end'</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">result = generator()</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">result</span>&#13;
&lt;generator object generator at ...&gt;&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">len</span><span class="python">(result)</span>&#13;
Traceback (most recent call last):&#13;
    ...&#13;
TypeError: object of type 'generator' has no len()&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">result[:</span><span class="hljs-con-number">10</span><span class="python">]</span>&#13;
Traceback (most recent call last):&#13;
    ...&#13;
TypeError: 'generator' object is not subscriptable&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">list</span><span class="python">(result)</span>&#13;
[1, 'a', []]&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">list</span><span class="python">(result)</span>&#13;
[]&#13;
</code></pre>&#13;
    <p class="normal">A few of the downsides of generators become immediately apparent in this example. The <code class="inlineCode">result</code> does not offer much meaningful information when looking at its <code class="inlineCode">repr()</code>, getting <code class="inlineCode">len()</code> (length), or slicing. And trying to do <code class="inlineCode">list()</code> to get the values a second time does not work because the generator is already exhausted.</p>&#13;
    <p class="normal">Additionally, you may have noticed that the <code class="inlineCode">return</code> value of the function appears to have completely disappeared. This is actually not the case; the value of <code class="inlineCode">return</code> is still used, but as the value for the <code class="inlineCode">StopIteration</code> exception raised by the generator to indicate that the generator has been exhausted:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">generator_with_return</span><span class="hljs-con-function">():</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">yield</span><span class="python"> </span><span class="hljs-con-string">'some_value'</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">return</span><span class="python"> </span><span class="hljs-con-string">'The end of our generator'</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">result = generator_with_return()</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">next</span><span class="python">(result)</span>&#13;
'some_value'&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">next</span><span class="python">(result)</span>&#13;
Traceback (most recent call last):&#13;
    ...&#13;
StopIteration: The end of our generator&#13;
</code></pre>&#13;
    <p class="normal">The following example <a id="_idIndexMarker481"/>demonstrates the lazy execution of generators:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">lazy</span><span class="hljs-con-function">():</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    print(</span><span class="hljs-con-string">'before the yield'</span><span class="python">)</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">yield</span><span class="python"> </span><span class="hljs-con-string">'yielding'</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    print(</span><span class="hljs-con-string">'after the yield'</span><span class="python">)</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">generator = lazy()</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">next</span><span class="python">(generator)</span>&#13;
before the yield&#13;
'yielding'&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">next</span><span class="python">(generator)</span>&#13;
Traceback (most recent call last):&#13;
    ...&#13;
StopIteration&#13;
</code></pre>&#13;
    <p class="normal">As you can see in this example, the code after the <code class="inlineCode">yield</code> isn’t executed. This is caused by the <code class="inlineCode">StopIteration</code> exception; if we properly catch this exception, the code will be executed:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">lazy</span><span class="hljs-con-function">():</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    print(</span><span class="hljs-con-string">'before the yield'</span><span class="python">)</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">yield</span><span class="python"> </span><span class="hljs-con-string">'yielding'</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    print(</span><span class="hljs-con-string">'after the yield'</span><span class="python">)</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">generator = lazy()</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">next</span><span class="python">(generator)</span>&#13;
before the yield&#13;
'yielding'&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">try</span><span class="python">:</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-built_in">next</span><span class="python">(generator)</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-keyword">except</span><span class="python"> StopIteration:</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">pass</span>&#13;
after the yield&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">for</span><span class="python"> item </span><span class="hljs-con-keyword">in</span><span class="python"> lazy():</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    print(item)</span>&#13;
before the yield&#13;
yielding&#13;
after the yield&#13;
</code></pre>&#13;
    <p class="normal">To<a id="_idIndexMarker482"/> properly handle generators, you always need to either catch the <code class="inlineCode">StopIteration</code> yourself, or use a loop or another structure that handles the <code class="inlineCode">StopIteration</code> implicitly.</p>&#13;
    <h2 id="_idParaDest-177" class="heading-2">Creating infinite generators</h2>&#13;
    <p class="normal">Creating<a id="_idIndexMarker483"/> an endless generator (such as the <code class="inlineCode">itertools.count</code> iterator discussed in <em class="chapterRef">Chapter 5</em>, <em class="italic">Functional Programming – Readability Versus Brevity</em>) is easy as well. If, instead of having the fixed <code class="inlineCode">yield &lt;value&gt;</code> lines like in<a id="_idIndexMarker484"/> the previous function, we <code class="inlineCode">yield</code> from inside of an infinite loop, we can easily make an infinite generator. </p>&#13;
    <p class="normal">As opposed to the <code class="inlineCode">itertools.count()</code> generator, we will add a <code class="inlineCode">stop</code> parameter to make testing easier:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">count</span><span class="hljs-con-function">(</span><span class="hljs-con-params">start=</span><span class="hljs-con-number">0</span><span class="hljs-con-params">, step=</span><span class="hljs-con-number">1</span><span class="hljs-con-params">, stop=</span><span class="hljs-con-literal">None</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    n = start</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">while</span><span class="python"> stop </span><span class="hljs-con-keyword">is</span><span class="python"> </span><span class="hljs-con-keyword">not</span><span class="python"> </span><span class="hljs-con-literal">None</span><span class="python"> </span><span class="hljs-con-keyword">and</span><span class="python"> n &lt; stop:</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        </span><span class="hljs-con-keyword">yield</span><span class="python"> n</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        n += step</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">list</span><span class="python">(count(</span><span class="hljs-con-number">10</span><span class="python">, </span><span class="hljs-con-number">2.5</span><span class="python">, </span><span class="hljs-con-number">20</span><span class="python">))</span>&#13;
[10, 12.5, 15.0, 17.5]&#13;
</code></pre>&#13;
    <div class="packt_tip">&#13;
      <p class="normal">Due to the potentially infinite nature of generators, caution is required. Without the <code class="inlineCode">stop</code> variable, simply doing <code class="inlineCode">list(count())</code> would result in an infinite loop that results in an out-of-memory situation quite fast.</p>&#13;
    </div>&#13;
    <p class="normal">So, how does this work? Essentially it is just a normal loop, but the big difference between this and the regular<a id="_idIndexMarker485"/> method of returning a list of items is that the <code class="inlineCode">yield</code> statement returns the items one at a time, which means you only have to calculate the requested items and you don’t have to keep all results in memory.</p>&#13;
    <h2 id="_idParaDest-178" class="heading-2">Generators wrapping iterables</h2>&#13;
    <p class="normal">While <a id="_idIndexMarker486"/>generators are already quite useful when generating values from scratch, the real power comes when wrapping other iterables. To illustrate this, we will create a generator that automatically squares all numbers from the given input:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">square</span><span class="hljs-con-function">(</span><span class="hljs-con-params">iterable</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">for</span><span class="python"> i </span><span class="hljs-con-keyword">in</span><span class="python"> iterable:</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        </span><span class="hljs-con-keyword">yield</span><span class="python"> i ** </span><span class="hljs-con-number">2</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">list</span><span class="python">(square(</span><span class="hljs-con-built_in">range</span><span class="python">(</span><span class="hljs-con-number">5</span><span class="python">)))</span>&#13;
[0, 1, 4, 9, 16]&#13;
</code></pre>&#13;
    <p class="normal">Naturally, there is nothing stopping you from adding extra <code class="inlineCode">yield</code> statements outside of the loop:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">padded_square</span><span class="hljs-con-function">(</span><span class="hljs-con-params">iterable</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">yield</span><span class="python"> </span><span class="hljs-con-string">'begin'</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">for</span><span class="python"> i </span><span class="hljs-con-keyword">in</span><span class="python"> iterable:</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        </span><span class="hljs-con-keyword">yield</span><span class="python"> i ** </span><span class="hljs-con-number">2</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">yield</span><span class="python"> </span><span class="hljs-con-string">'end'</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">list</span><span class="python">(padded_square(</span><span class="hljs-con-built_in">range</span><span class="python">(</span><span class="hljs-con-number">5</span><span class="python">)))</span>&#13;
['begin', 0, 1, 4, 9, 16, 'end']&#13;
</code></pre>&#13;
    <p class="normal">Because these generators are iterable, you can chain them together by wrapping them as many times as you like. A basic example of chaining a <code class="inlineCode">square()</code> and an <code class="inlineCode">odd()</code> generator together is:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span><span class="python"> itertools</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">odd</span><span class="hljs-con-function">(</span><span class="hljs-con-params">iterable</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">for</span><span class="python"> i </span><span class="hljs-con-keyword">in</span><span class="python"> iterable:</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        </span><span class="hljs-con-keyword">if</span><span class="python"> i % </span><span class="hljs-con-number">2</span><span class="python">:</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">            </span><span class="hljs-con-keyword">yield</span><span class="python"> i</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">square</span><span class="hljs-con-function">(</span><span class="hljs-con-params">iterable</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">for</span><span class="python"> i </span><span class="hljs-con-keyword">in</span><span class="python"> iterable:</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        </span><span class="hljs-con-keyword">yield</span><span class="python"> i ** </span><span class="hljs-con-number">2</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">list</span><span class="python">(square(odd(</span><span class="hljs-con-built_in">range</span><span class="python">(</span><span class="hljs-con-number">10</span><span class="python">))))</span>&#13;
[1, 9, 25, 49, 81]&#13;
</code></pre>&#13;
    <p class="normal">If we analyze<a id="_idIndexMarker487"/> how the code is executed, we need to start from the inside to the outside: </p>&#13;
    <ol class="numberedList" style="list-style-type: decimal;">&#13;
      <li class="numberedList" value="1">The <code class="inlineCode">range(10)</code> statement generates 10 numbers for us.</li>&#13;
      <li class="numberedList">The <code class="inlineCode">odd()</code> generator filters the input values, so from the <code class="inlineCode">[0, 1, 2 … ]</code> values it only returns <code class="inlineCode">[1, 3, 5, 7, 9]</code>.</li>&#13;
      <li class="numberedList">The <code class="inlineCode">square()</code> function squares the given input, which is the list of odd numbers as generated by <code class="inlineCode">odd()</code>.</li>&#13;
    </ol>&#13;
    <p class="normal">The real power of chaining is that the generators will only do something when we request a value. If we request a single value with <code class="inlineCode">next()</code> instead of <code class="inlineCode">list()</code>, it will mean that only the first iteration of the loop in <code class="inlineCode">square()</code> will be run. For <code class="inlineCode">odd()</code> and <code class="inlineCode">range()</code>, however, it will have to process two values because <code class="inlineCode">odd()</code> will discard the first value given by <code class="inlineCode">range()</code> and not <code class="inlineCode">yield</code> anything.</p>&#13;
    <h2 id="_idParaDest-179" class="heading-2">Generator comprehensions</h2>&#13;
    <p class="normal">In the <a id="_idIndexMarker488"/>previous chapters, you saw <code class="inlineCode">list</code>, <code class="inlineCode">dict</code>, and <code class="inlineCode">set</code> comprehensions, which generate collections. With a generator comprehension we can make similar collections, but make them lazy so they are only evaluated as needed. The basic premise is identical to the <code class="inlineCode">list</code> comprehension but using round brackets/parentheses instead of square brackets:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">squares = (x ** </span><span class="hljs-con-number">2</span><span class="python"> </span><span class="hljs-con-keyword">for</span><span class="python"> x </span><span class="hljs-con-keyword">in</span><span class="python"> </span><span class="hljs-con-built_in">range</span><span class="python">(</span><span class="hljs-con-number">4</span><span class="python">))</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">squares</span>&#13;
&lt;generator object &lt;genexpr&gt; at 0x...&gt;&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">list</span><span class="python">(squares)</span>&#13;
[0, 1, 4, 9]&#13;
</code></pre>&#13;
    <p class="normal">This is very<a id="_idIndexMarker489"/> useful when you need to wrap the results of a different generator because it only calculates the values you asked for: </p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span><span class="python"> itertools</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">result = itertools.count()</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">odd = (x </span><span class="hljs-con-keyword">for</span><span class="python"> x </span><span class="hljs-con-keyword">in</span><span class="python"> result </span><span class="hljs-con-keyword">if</span><span class="python"> x % </span><span class="hljs-con-number">2</span><span class="python">)</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">sliced_odd = itertools.islice(odd, </span><span class="hljs-con-number">5</span><span class="python">)</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">list</span><span class="python">(sliced_odd)</span>&#13;
[1, 3, 5, 7, 9]&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">result = itertools.count()</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">sliced_result = itertools.islice(result, </span><span class="hljs-con-number">5</span><span class="python">)</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">odd = (x </span><span class="hljs-con-keyword">for</span><span class="python"> x </span><span class="hljs-con-keyword">in</span><span class="python"> sliced_result </span><span class="hljs-con-keyword">if</span><span class="python"> x % </span><span class="hljs-con-number">2</span><span class="python">)</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">list</span><span class="python">(odd)</span>&#13;
[1, 3]&#13;
</code></pre>&#13;
    <p class="normal">As you can probably surmise from this result, this can be dangerous with infinite-sized generators such as <code class="inlineCode">itertools.count()</code>. The order of operations is very important because the <code class="inlineCode">itertools.islice()</code> function slices the result at that point, not the original generator. This means that if we replace <code class="inlineCode">odd()</code> with a function that never evaluates to <code class="inlineCode">True</code> for the given collection, it will run forever because it will never <code class="inlineCode">yield</code> any results.</p>&#13;
    <h2 id="_idParaDest-180" class="heading-2">Class-based generators and iterators</h2>&#13;
    <p class="normal">In addition to <a id="_idIndexMarker490"/>creating generators as regular functions and through generator comprehensions, we can also create generators using classes. This can be beneficial for more complex generators where you need to remember the state or where inheritance can be used. </p>&#13;
    <p class="normal">First, let’s look at an example of creating a basic generator <code class="inlineCode">class</code> that mimics the behavior of <code class="inlineCode">itertools.count()</code> with an added <code class="inlineCode">stop</code> parameter:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">class</span><span class="hljs-con-class"> </span><span class="hljs-con-title">CountGenerator</span><span class="hljs-con-class">:</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">__init__</span><span class="hljs-con-function">(</span><span class="hljs-con-params">self, start=</span><span class="hljs-con-number">0</span><span class="hljs-con-params">, step=</span><span class="hljs-con-number">1</span><span class="hljs-con-params">, stop=</span><span class="hljs-con-literal">None</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        self.start = start</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        self.step = step</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        self.stop = stop</span>&#13;
<span class="hljs-con-meta">...</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">__iter__</span><span class="hljs-con-function">(</span><span class="hljs-con-params">self</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        i = self.start</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        </span><span class="hljs-con-keyword">while</span><span class="python"> self.stop </span><span class="hljs-con-keyword">is</span><span class="python"> </span><span class="hljs-con-literal">None</span><span class="python"> </span><span class="hljs-con-keyword">or</span><span class="python"> i &lt; self.stop:</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">            </span><span class="hljs-con-keyword">yield</span><span class="python"> i</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">            i += self.step</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">list</span><span class="python">(CountGenerator(start=</span><span class="hljs-con-number">2.5</span><span class="python">, step=</span><span class="hljs-con-number">0.5</span><span class="python">, stop=</span><span class="hljs-con-number">5</span><span class="python">))</span>&#13;
[2.5, 3.0, 3.5, 4.0, 4.5]&#13;
</code></pre>&#13;
    <p class="normal">Now let’s convert<a id="_idIndexMarker491"/> the generator class into an iterator with more features:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">class</span><span class="hljs-con-class"> </span><span class="hljs-con-title">CountIterator</span><span class="hljs-con-class">:</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">__init__</span><span class="hljs-con-function">(</span><span class="hljs-con-params">self, start=</span><span class="hljs-con-number">0</span><span class="hljs-con-params">, step=</span><span class="hljs-con-number">1</span><span class="hljs-con-params">, stop=</span><span class="hljs-con-literal">None</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        self.i = start</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        self.start = start</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        self.step = step</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        self.stop = stop</span>&#13;
<span class="hljs-con-meta">...</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">__iter__</span><span class="hljs-con-function">(</span><span class="hljs-con-params">self</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        </span><span class="hljs-con-keyword">return</span><span class="python"> self</span>&#13;
<span class="hljs-con-meta">...</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">__next__</span><span class="hljs-con-function">(</span><span class="hljs-con-params">self</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        </span><span class="hljs-con-keyword">if</span><span class="python"> self.stop </span><span class="hljs-con-keyword">is</span><span class="python"> </span><span class="hljs-con-keyword">not</span><span class="python"> </span><span class="hljs-con-literal">None</span><span class="python"> </span><span class="hljs-con-keyword">and</span><span class="python"> self.i &gt;= self.stop:</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">            </span><span class="hljs-con-keyword">raise</span><span class="python"> StopIteration</span>&#13;
<span class="hljs-con-meta">...</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        </span><span class="hljs-con-comment"># We need to return the value before we increment to</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        </span><span class="hljs-con-comment"># maintain identical behavior</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        value = self.i</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        self.i += self.step</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        </span><span class="hljs-con-keyword">return</span><span class="python"> value</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">list</span><span class="python">(CountIterator(start=</span><span class="hljs-con-number">2.5</span><span class="python">, step=</span><span class="hljs-con-number">0.5</span><span class="python">, stop=</span><span class="hljs-con-number">5</span><span class="python">))</span>&#13;
[2.5, 3.0, 3.5, 4.0, 4.5]&#13;
</code></pre>&#13;
    <p class="normal">The most important distinction between the generator and the iterator is that instead of a simple iterable object, we now have a fully fledged class that acts as an iterator, which means we can also expand it beyond the capabilities of regular generators.</p>&#13;
    <p class="normal">A few of the<a id="_idIndexMarker492"/> limitations of regular generators are that they don’t have a length and we cannot slice them. With an iterator, we can explicitly define the behavior in these scenarios if needed:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span><span class="python"> itertools</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">class</span><span class="hljs-con-class"> </span><span class="hljs-con-title">AdvancedCountIterator</span><span class="hljs-con-class">:</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">__init__</span><span class="hljs-con-function">(</span><span class="hljs-con-params">self, start=</span><span class="hljs-con-number">0</span><span class="hljs-con-params">, step=</span><span class="hljs-con-number">1</span><span class="hljs-con-params">, stop=</span><span class="hljs-con-literal">None</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        self.i = start</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        self.start = start</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        self.step = step</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        self.stop = stop</span>&#13;
<span class="hljs-con-meta">...</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">__iter__</span><span class="hljs-con-function">(</span><span class="hljs-con-params">self</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        </span><span class="hljs-con-keyword">return</span><span class="python"> self</span>&#13;
<span class="hljs-con-meta">...</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">__next__</span><span class="hljs-con-function">(</span><span class="hljs-con-params">self</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        </span><span class="hljs-con-keyword">if</span><span class="python"> self.stop </span><span class="hljs-con-keyword">is</span><span class="python"> </span><span class="hljs-con-keyword">not</span><span class="python"> </span><span class="hljs-con-literal">None</span><span class="python"> </span><span class="hljs-con-keyword">and</span><span class="python"> self.i &gt;= self.stop:</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">            </span><span class="hljs-con-keyword">raise</span><span class="python"> StopIteration</span>&#13;
<span class="hljs-con-meta">...</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        value = self.i</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        self.i += self.step</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        </span><span class="hljs-con-keyword">return</span><span class="python"> value</span>&#13;
<span class="hljs-con-meta">...</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">__len__</span><span class="hljs-con-function">(</span><span class="hljs-con-params">self</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        </span><span class="hljs-con-keyword">return</span><span class="python"> </span><span class="hljs-con-built_in">int</span><span class="python">((self.stop - self.start) // self.step)</span>&#13;
<span class="hljs-con-meta">...</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">__contains__</span><span class="hljs-con-function">(</span><span class="hljs-con-params">self, key</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        </span><span class="hljs-con-comment"># To check 'if 123 in count'.</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        </span><span class="hljs-con-comment"># Note that this does not look at 'step'!</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        </span><span class="hljs-con-keyword">return</span><span class="python"> self.start &lt; key &lt; self.stop</span>&#13;
<span class="hljs-con-meta">...</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">__repr__</span><span class="hljs-con-function">(</span><span class="hljs-con-params">self</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        </span><span class="hljs-con-keyword">return</span><span class="python"> (</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">            </span><span class="hljs-con-string">f'</span><span class="hljs-con-subst">{self.__class__.__name__}</span><span class="hljs-con-string">(start=</span><span class="hljs-con-subst">{self.start}</span><span class="hljs-con-string">, '</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">            </span><span class="hljs-con-string">f'step=</span><span class="hljs-con-subst">{self.step}</span><span class="hljs-con-string">, stop=</span><span class="hljs-con-subst">{self.stop}</span><span class="hljs-con-string">)'</span><span class="python">)</span>&#13;
<span class="hljs-con-meta">...</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">__getitem__</span><span class="hljs-con-function">(</span><span class="hljs-con-params">self, slice_</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        </span><span class="hljs-con-keyword">return</span><span class="python"> itertools.islice(self, slice_.start,</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">                                slice_.stop, slice_.step)</span>&#13;
</code></pre>&#13;
    <p class="normal">Now that we have our advanced count iterator with support for features such as <code class="inlineCode">len()</code>, <code class="inlineCode">in</code>, and <code class="inlineCode">repr()</code>, we can test to see if it works as expected:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">count = AdvancedCountIterator(start=</span><span class="hljs-con-number">2.5</span><span class="python">, step=</span><span class="hljs-con-number">0.5</span><span class="python">, stop=</span><span class="hljs-con-number">5</span><span class="python">)</span>&#13;
&#13;
<span class="hljs-con-comment"># Pretty representation using '__repr__'</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">count</span>&#13;
AdvancedCountIterator(start=2.5, step=0.5, stop=5)&#13;
&#13;
<span class="hljs-con-comment"># Check if item exists using '__contains__'</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-number">3</span><span class="python"> </span><span class="hljs-con-keyword">in</span><span class="python"> count</span>&#13;
True&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-number">3.1</span><span class="python"> </span><span class="hljs-con-keyword">in</span><span class="python"> count</span>&#13;
True&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-number">1</span><span class="python"> </span><span class="hljs-con-keyword">in</span><span class="python"> count</span>&#13;
False&#13;
&#13;
<span class="hljs-con-comment"># Getting the length using '__len__'</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">len</span><span class="python">(count)</span>&#13;
5&#13;
<span class="hljs-con-comment"># Slicing using '__getitem__' with a slice as a parameter</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">count[:</span><span class="hljs-con-number">3</span><span class="python">]</span>&#13;
&lt;itertools.islice object at 0x...&gt;&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">list</span><span class="python">(count[:</span><span class="hljs-con-number">3</span><span class="python">])</span>&#13;
[2.5, 3.0, 3.5]&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">list</span><span class="python">(count[:</span><span class="hljs-con-number">3</span><span class="python">])</span>&#13;
[4.0, 4.5]&#13;
</code></pre>&#13;
    <p class="normal">In addition to <a id="_idIndexMarker493"/>working around some of the limitations, in the last example, you can also see a very useful feature of generators. We can exhaust the items one by one and stop/start whenever we want. And since we still have full access to the object, we could alter <code class="inlineCode">count.i</code> to restart the iterator.</p>&#13;
    <h1 id="_idParaDest-181" class="heading-1">Generator examples</h1>&#13;
    <p class="normal">Now that <a id="_idIndexMarker494"/>you know how generators can be created, let’s look at a few useful generators and examples of how to use them.</p>&#13;
    <p class="normal">Before you start writing a generator for your project, always make sure to look at the Python <code class="inlineCode">itertools</code> module. It features a host of useful generators that cover a vast array of use cases. The following sections show some custom generators and a few of the most useful generators in the standard library.</p>&#13;
    <div class="packt_tip">&#13;
      <p class="normal">These generators work on all iterables, not just generators. So, you could also apply them to a <code class="inlineCode">list</code>, <code class="inlineCode">tuple</code>, <code class="inlineCode">string</code>, or other kinds of iterables.</p>&#13;
    </div>&#13;
    <h2 id="_idParaDest-182" class="heading-2">Breaking an iterable up into chunks/groups</h2>&#13;
    <p class="normal">When <a id="_idIndexMarker495"/>executing large amounts of queries in a database or when running tasks via multiple processes, it is often more efficient to chunk the operations. Having a single huge operation could result in out-of-memory issues; having many tiny operations can be slow due to start-up/teardown sequences.</p>&#13;
    <p class="normal">To make things more efficient, a good method is to split the input into chunks. The Python documentation (<a href="https://docs.python.org/3/library/itertools.html?highlight=chunk#itertools-recipes"><span class="url">https://docs.python.org/3/library/itertools.html?highlight=chunk#itertools-recipes</span></a>) already comes with an example of how to do this by using <code class="inlineCode">itertools.zip_longest()</code>:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span><span class="python"> itertools</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">grouper</span><span class="hljs-con-function">(</span><span class="hljs-con-params">iterable, n, fillvalue=</span><span class="hljs-con-literal">None</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-string">'''Collect data into fixed-length chunks or blocks'''</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    args = [</span><span class="hljs-con-built_in">iter</span><span class="python">(iterable)] * n </span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">return</span><span class="python"> itertools.zip_longest(*args, fillvalue=fillvalue)</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">list</span><span class="python">(grouper(</span><span class="hljs-con-string">'ABCDEFG'</span><span class="python">, </span><span class="hljs-con-number">3</span><span class="python">, </span><span class="hljs-con-string">'x'</span><span class="python">))</span>&#13;
[('A', 'B', 'C'), ('D', 'E', 'F'), ('G', 'x', 'x')]&#13;
</code></pre>&#13;
    <p class="normal">This code is a very nice example of how easy it is to chunk your data, but it has to hold the entire chunk in memory. To work around that, we can create a version that generates sub-generators for the chunks:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">chunker</span><span class="hljs-con-function">(</span><span class="hljs-con-params">iterable, chunk_size</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-comment"># Make sure 'iterable' is an iterator</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    iterable = </span><span class="hljs-con-built_in">iter</span><span class="python">(iterable)</span>&#13;
<span class="hljs-con-meta">...</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">chunk</span><span class="hljs-con-function">(</span><span class="hljs-con-params">value</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        </span><span class="hljs-con-comment"># Make sure not to skip the given value</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        </span><span class="hljs-con-keyword">yield</span><span class="python"> value</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        </span><span class="hljs-con-comment"># We already yielded a value so reduce the chunk_size</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        </span><span class="hljs-con-keyword">for</span><span class="python"> _ </span><span class="hljs-con-keyword">in</span><span class="python"> </span><span class="hljs-con-built_in">range</span><span class="python">(chunk_size - </span><span class="hljs-con-number">1</span><span class="python">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">            </span><span class="hljs-con-keyword">try</span><span class="python">:</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">                </span><span class="hljs-con-keyword">yield</span><span class="python"> </span><span class="hljs-con-built_in">next</span><span class="python">(iterable)</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">            </span><span class="hljs-con-keyword">except</span><span class="python"> StopIteration:</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">                </span><span class="hljs-con-keyword">break</span>&#13;
<span class="hljs-con-meta">...</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">while</span><span class="python"> </span><span class="hljs-con-literal">True</span><span class="python">:</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        </span><span class="hljs-con-keyword">try</span><span class="python">:</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">            </span><span class="hljs-con-comment"># Check if we're at the end by using 'next()'</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">            </span><span class="hljs-con-keyword">yield</span><span class="python"> chunk(</span><span class="hljs-con-built_in">next</span><span class="python">(iterable))</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        </span><span class="hljs-con-keyword">except</span><span class="python"> StopIteration:</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">            </span><span class="hljs-con-keyword">break</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">for</span><span class="python"> chunk </span><span class="hljs-con-keyword">in</span><span class="python"> chunker(</span><span class="hljs-con-string">'ABCDEFG'</span><span class="python">, </span><span class="hljs-con-number">3</span><span class="python">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">for</span><span class="python"> value </span><span class="hljs-con-keyword">in</span><span class="python"> chunk:</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        print(value, end=</span><span class="hljs-con-string">', '</span><span class="python">)</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    print()</span>&#13;
A, B, C,&#13;
D, E, F,&#13;
G,&#13;
</code></pre>&#13;
    <p class="normal">Because <a id="_idIndexMarker496"/>we need to catch the <code class="inlineCode">StopIteration</code> exceptions, this example does not look very pretty in my opinion. Part of the code could be improved by using <code class="inlineCode">itertools.islice()</code> (which is covered next) but that will still leave us with the problem that we cannot know when we have reached the end.</p>&#13;
    <p class="normal">If you are interested, an implementation using <code class="inlineCode">itertools.islice()</code> and <code class="inlineCode">itertools.chains()</code> can be found on this book’s GitHub: <a href="https://github.com/mastering-python/code_2"><span class="url">https://github.com/mastering-python/code_2</span></a>.</p>&#13;
    <h2 id="_idParaDest-183" class="heading-2">itertools.islice – Slicing iterables</h2>&#13;
    <p class="normal">One<a id="_idIndexMarker497"/> limitation of generators is that they cannot be <a id="_idIndexMarker498"/>sliced. You can work around this by converting the generator into a <code class="inlineCode">list</code> before slicing, but that is not possible with infinite generators, and it can be inefficient if you only need a few values.</p>&#13;
    <p class="normal">To solve this, the <code class="inlineCode">itertools</code> library has an <code class="inlineCode">islice()</code> function, which can slice any iterable object. The function is the generator version of the slicing operators and similarly to slicing supports a <code class="inlineCode">start</code>, <code class="inlineCode">stop</code>, and <code class="inlineCode">step</code> parameter. The following illustrates how regular slicing and <code class="inlineCode">itertools.islice()</code> compare:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span><span class="python"> itertools</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">some_list = </span><span class="hljs-con-built_in">list</span><span class="python">(</span><span class="hljs-con-built_in">range</span><span class="python">(</span><span class="hljs-con-number">1000</span><span class="python">))</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">some_list[:</span><span class="hljs-con-number">5</span><span class="python">]</span>&#13;
[0, 1, 2, 3, 4]&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">list</span><span class="python">(itertools.islice(some_list, </span><span class="hljs-con-number">5</span><span class="python">))</span>&#13;
[0, 1, 2, 3, 4]&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">some_list[</span><span class="hljs-con-number">10</span><span class="python">:</span><span class="hljs-con-number">20</span><span class="python">:</span><span class="hljs-con-number">2</span><span class="python">]</span>&#13;
[10, 12, 14, 16, 18]&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">list</span><span class="python">(itertools.islice(some_list, </span><span class="hljs-con-number">10</span><span class="python">, </span><span class="hljs-con-number">20</span><span class="python">, </span><span class="hljs-con-number">2</span><span class="python">))</span>&#13;
[10, 12, 14, 16, 18]&#13;
</code></pre>&#13;
    <p class="normal">It is very important to note that while the output is identical, these methods are far from equivalent internally. Regular slicing only works on objects that are sliceable; effectively, this means the object has to implement the <code class="inlineCode">__getitem__(self, slice)</code> method.</p>&#13;
    <p class="normal">Additionally, we<a id="_idIndexMarker499"/> expect that slicing objects is a fast and efficient operation. For <code class="inlineCode">list</code> and <code class="inlineCode">tuple</code> this is certainly the case, but for a given generator this might not be the case.</p>&#13;
    <p class="normal">If for a list with size <code class="inlineCode">n=1000</code> we take any slice of any <code class="inlineCode">k=10</code> elements, we can expect the time complexity of that to be only <code class="inlineCode">O(k)</code>; that is, 10 steps. It doesn’t matter whether we do <code class="inlineCode">some_list[:10]</code> or <code class="inlineCode">some_list[900:920:2]</code>.</p>&#13;
    <p class="normal">For <code class="inlineCode">itertools.islice()</code> this is not the case because the only assumption it makes is that the input is iterable. That means that getting the first 10 items is easy; simply loop through the items, return the first 10, and stop. So <code class="inlineCode">itertools.islice(some_list, 10)</code> also takes 10 steps. Getting items 900 to 920, however, means walking through and discarding the first 900 items, and only returning 10 of the next 20 items. So that is 920 steps instead.</p>&#13;
    <p class="normal">To illustrate <a id="_idIndexMarker500"/>this, here’s a slightly simplified implementation of <code class="inlineCode">itertools.islice()</code> that expects to always have a <code class="inlineCode">stop</code> available:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">islice</span><span class="hljs-con-function">(</span><span class="hljs-con-params">iterable, start, stop=</span><span class="hljs-con-literal">None</span><span class="hljs-con-params">, step=</span><span class="hljs-con-number">1</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-comment"># 'islice' has signatures: 'islice(iterable, stop)' and:</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-comment"># 'islice(iterable, start, stop[, step])'</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-comment"># 'fill' stop with 'start' if needed</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">if</span><span class="python"> stop </span><span class="hljs-con-keyword">is</span><span class="python"> </span><span class="hljs-con-literal">None</span><span class="python"> </span><span class="hljs-con-keyword">and</span><span class="python"> step == </span><span class="hljs-con-number">1</span><span class="python"> </span><span class="hljs-con-keyword">and</span><span class="python"> start </span><span class="hljs-con-keyword">is</span><span class="python"> </span><span class="hljs-con-keyword">not</span><span class="python"> </span><span class="hljs-con-literal">None</span><span class="python">:</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        start, stop = </span><span class="hljs-con-number">0</span><span class="python">, start</span>&#13;
<span class="hljs-con-meta">...</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-comment"># Create an iterator and discard the first 'start' items</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    iterator = </span><span class="hljs-con-built_in">iter</span><span class="python">(iterable)</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">for</span><span class="python"> _ </span><span class="hljs-con-keyword">in</span><span class="python"> </span><span class="hljs-con-built_in">range</span><span class="python">(start):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        </span><span class="hljs-con-built_in">next</span><span class="python">(iterator)</span>&#13;
<span class="hljs-con-meta">...</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-comment"># Enumerate the iterator making 'i' start at 'start'</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">for</span><span class="python"> i, item </span><span class="hljs-con-keyword">in</span><span class="python"> </span><span class="hljs-con-built_in">enumerate</span><span class="python">(iterator, start):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        </span><span class="hljs-con-comment"># Stop when we've reached 'stop' items</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        </span><span class="hljs-con-keyword">if</span><span class="python"> i &gt;= stop:</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">            </span><span class="hljs-con-keyword">return</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        </span><span class="hljs-con-comment"># Use modulo 'step' to discard non-matching items</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        </span><span class="hljs-con-keyword">if</span><span class="python"> i % step:</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">            </span><span class="hljs-con-keyword">continue</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        </span><span class="hljs-con-keyword">yield</span><span class="python"> item</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">list</span><span class="python">(islice(</span><span class="hljs-con-built_in">range</span><span class="python">(</span><span class="hljs-con-number">1000</span><span class="python">), </span><span class="hljs-con-number">10</span><span class="python">))</span>&#13;
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">list</span><span class="python">(islice(</span><span class="hljs-con-built_in">range</span><span class="python">(</span><span class="hljs-con-number">1000</span><span class="python">), </span><span class="hljs-con-number">900</span><span class="python">, </span><span class="hljs-con-number">920</span><span class="python">, </span><span class="hljs-con-number">2</span><span class="python">))</span>&#13;
[900, 902, 904, 906, 908, 910, 912, 914, 916, 918]&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">list</span><span class="python">(islice(</span><span class="hljs-con-built_in">range</span><span class="python">(</span><span class="hljs-con-number">1000</span><span class="python">), </span><span class="hljs-con-number">900</span><span class="python">, </span><span class="hljs-con-number">910</span><span class="python">))</span>&#13;
[900, 901, 902, 903, 904, 905, 906, 907, 908, 909]&#13;
</code></pre>&#13;
    <p class="normal">As you <a id="_idIndexMarker501"/>can see, both the <code class="inlineCode">start</code> and the <code class="inlineCode">step</code> sections discard items that are not needed. This does not <a id="_idIndexMarker502"/>mean you should not use <code class="inlineCode">itertools.islice()</code>, but be wary of the internals. Also, as you might expect, this generator does not support negative values for the indices and expects all values to be positive.</p>&#13;
    <h2 id="_idParaDest-184" class="heading-2">itertools.chain – Concatenating multiple iterables</h2>&#13;
    <p class="normal">The <code class="inlineCode">itertools.chain()</code> generator is <a id="_idIndexMarker503"/>one of the simplest yet one of the most useful generators in<a id="_idIndexMarker504"/> the Python library. It simply returns every item from every passed iterable in sequential order and can be implemented in just three lines:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">chain</span><span class="hljs-con-function">(</span><span class="hljs-con-params">*iterables</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">for</span><span class="python"> iterable </span><span class="hljs-con-keyword">in</span><span class="python"> iterables:</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        </span><span class="hljs-con-keyword">yield</span><span class="python"> </span><span class="hljs-con-keyword">from</span><span class="python"> iterable</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">a = </span><span class="hljs-con-number">1</span><span class="python">, </span><span class="hljs-con-number">2</span><span class="python">, </span><span class="hljs-con-number">3</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">b = [</span><span class="hljs-con-number">4</span><span class="python">, </span><span class="hljs-con-number">5</span><span class="python">, </span><span class="hljs-con-number">6</span><span class="python">]</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">c = </span><span class="hljs-con-string">'abc'</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">list</span><span class="python">(chain(a, b, c))</span>&#13;
[1, 2, 3, 4, 5, 6, 'a', 'b', 'c']&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">a + b + c</span>&#13;
Traceback (most recent call last):&#13;
    ...&#13;
TypeError: can only concatenate tuple (not "list") to tuple&#13;
</code></pre>&#13;
    <p class="normal">As you <a id="_idIndexMarker505"/>might notice, this also introduces a feature not yet discussed: the <code class="inlineCode">yield from</code> expression. <code class="inlineCode">yield from</code> does exactly what you can expect from the name and yields all items from <a id="_idIndexMarker506"/>the given iterable. So <code class="inlineCode">itertools.chain()</code> can also be replaced with the slightly more verbose:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">chain</span><span class="hljs-con-function">(</span><span class="hljs-con-params">*iterables</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">for</span><span class="python"> iterable </span><span class="hljs-con-keyword">in</span><span class="python"> iterables:</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        </span><span class="hljs-con-keyword">for</span><span class="python"> i </span><span class="hljs-con-keyword">in</span><span class="python"> iterable:</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">            </span><span class="hljs-con-keyword">yield</span><span class="python"> i</span>&#13;
</code></pre>&#13;
    <p class="normal">Interestingly, this method is more powerful than adding the collections because it doesn’t care about the types as long as they are iterable—duck typing at its finest.</p>&#13;
    <h2 id="_idParaDest-185" class="heading-2">itertools.tee – Using an output multiple times</h2>&#13;
    <p class="normal">As <a id="_idIndexMarker507"/>mentioned before, one of the biggest<a id="_idIndexMarker508"/> disadvantages of generators is that the results are usable only once. Luckily, Python has a function that allows you to copy the output to several generators. The name <code class="inlineCode">tee</code> might be familiar to you if you are used to working in a Linux/Unix command-line shell. The <code class="inlineCode">tee</code> program allows you to write outputs to both the screen and a file, so you can store an output while still maintaining a live view of it.</p>&#13;
    <p class="normal">The Python version, <code class="inlineCode">itertools.tee()</code>, does a similar thing except that it returns several iterators, allowing you to process the results separately.</p>&#13;
    <p class="normal">By default, <code class="inlineCode">tee</code> will split your generator into a tuple containing two different generators, which is why tuple unpacking works nicely here. By passing along the <code class="inlineCode">n</code> parameter, you can tell <code class="inlineCode">itertools.tee()</code> to create more than two generators. Here is an example:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span><span class="python"> itertools</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">spam_and_eggs</span><span class="hljs-con-function">():</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">yield</span><span class="python"> </span><span class="hljs-con-string">'spam'</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">yield</span><span class="python"> </span><span class="hljs-con-string">'eggs'</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">a, b = itertools.tee(spam_and_eggs())</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">next</span><span class="python">(a)</span>&#13;
'spam'&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">next</span><span class="python">(a)</span>&#13;
'eggs'&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">next</span><span class="python">(b)</span>&#13;
'spam'&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">next</span><span class="python">(b)</span>&#13;
'eggs'&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">next</span><span class="python">(b)</span>&#13;
Traceback (most recent call last):&#13;
    ...&#13;
StopIteration&#13;
</code></pre>&#13;
    <p class="normal">After <a id="_idIndexMarker509"/>seeing this code, you might be wondering about the memory usage of <code class="inlineCode">tee</code>. Does it need to store the entire list for you? Luckily, no. The <code class="inlineCode">tee</code> function is pretty smart in handling this. Assume you have a generator that contains 1,000 items, and you read the first 100 items from <code class="inlineCode">a</code> and the first <code class="inlineCode">75</code> items from <code class="inlineCode">b</code> simultaneously. Then <code class="inlineCode">tee</code> will only keep the difference (<code class="inlineCode">100 - 75 = 25</code> items) in memory and drop the rest while you are iterating the results.</p>&#13;
    <p class="normal">Whether <code class="inlineCode">tee</code> is the<a id="_idIndexMarker510"/> best solution in your case or not depends, of course. If instance <code class="inlineCode">a</code> is read from the beginning to (nearly) the end before instance <code class="inlineCode">b</code> is read, then it would not be a great idea to use <code class="inlineCode">tee</code>. Simply converting the generator into a <code class="inlineCode">list</code> would be faster since it involves much fewer operations.</p>&#13;
    <h2 id="_idParaDest-186" class="heading-2">contextlib.contextmanager – Creating context managers</h2>&#13;
    <p class="normal">You <a id="_idIndexMarker511"/>have already<a id="_idIndexMarker512"/> seen context managers in <em class="chapterRef">Chapter 5</em>, <em class="italic">Functional Programming – Readability Versus Brevity</em>, and <em class="chapterRef">Chapter 6</em>, <em class="italic">Decorators – Enabling Code Reuse by Decorating</em>, but there are many more useful things to be done with context managers. While the <code class="inlineCode">contextlib.contextmanager()</code> generator is not meant to be a result-generating generator like the examples you saw earlier in this chapter, it does use <code class="inlineCode">yield</code>, so it’s a nice example of non-standard generator usage.</p>&#13;
    <p class="normal">Some useful examples to log your output to a file and measure function execution time are:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span><span class="python"> time</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span><span class="python"> datetime</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span><span class="python"> contextlib</span>&#13;
&#13;
<span class="hljs-con-comment"># Context manager that shows how long a context was active</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-meta">@contextlib.contextmanager</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">timer</span><span class="hljs-con-function">(</span><span class="hljs-con-params">name</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    start_time = datetime.datetime.now()</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">yield</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    stop_time = datetime.datetime.now()</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    print(</span><span class="hljs-con-string">'%s took %s'</span><span class="python"> % (name, stop_time - start_time))</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">with</span><span class="python"> timer(</span><span class="hljs-con-string">'basic timer'</span><span class="python">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    time.sleep(</span><span class="hljs-con-number">0.1</span><span class="python">)</span>&#13;
basic timer took 0:00:00.1...&#13;
&#13;
<span class="hljs-con-comment"># Write standard print output to a file temporarily</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-meta">@contextlib.contextmanager</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">write_to_log</span><span class="hljs-con-function">(</span><span class="hljs-con-params">name</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">with</span><span class="python"> </span><span class="hljs-con-built_in">open</span><span class="python">(</span><span class="hljs-con-string">f'</span><span class="hljs-con-subst">{name}</span><span class="hljs-con-string">.txt'</span><span class="python">, </span><span class="hljs-con-string">'w'</span><span class="python">) </span><span class="hljs-con-keyword">as</span><span class="python"> fh:</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        </span><span class="hljs-con-keyword">with</span><span class="python"> contextlib.redirect_stdout(fh):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">            </span><span class="hljs-con-keyword">with</span><span class="python"> timer(name):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">                </span><span class="hljs-con-keyword">yield</span>&#13;
&#13;
<span class="hljs-con-comment"># Using as a decorator also works in addition to with-statements</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-meta">@write_to_log(</span><span class="hljs-con-string">'some_name'</span><span class="hljs-con-meta">)</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">some_function</span><span class="hljs-con-function">():</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    print(</span><span class="hljs-con-string">'This will be written to 'some_name.txt''</span><span class="python">)</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">some_function()</span>&#13;
</code></pre>&#13;
    <p class="normal">This all <a id="_idIndexMarker513"/>works perfectly, but the code could <a id="_idIndexMarker514"/>be prettier. Having three levels of context managers tends to get a bit unreadable, which is something you could generally solve using decorators, as covered in <em class="chapterRef">Chapter 6</em>. In this case, however, we need the output from one context manager as the input for the next, which would make for a more complicated decorator setup.</p>&#13;
    <p class="normal">That’s where the <code class="inlineCode">ExitStack</code> context manager comes in. It allows the easy combining of multiple context managers without increasing the indentation level:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span><span class="python"> contextlib</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-meta">@contextlib.contextmanager</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">write_to_log</span><span class="hljs-con-function">(</span><span class="hljs-con-params">name</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">with</span><span class="python"> contextlib.ExitStack() </span><span class="hljs-con-keyword">as</span><span class="python"> stack:</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        fh = stack.enter_context(</span><span class="hljs-con-built_in">open</span><span class="python">(</span><span class="hljs-con-string">f'</span><span class="hljs-con-subst">{name}</span><span class="hljs-con-string">.txt'</span><span class="python">, </span><span class="hljs-con-string">'w'</span><span class="python">))</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        stack.enter_context(contextlib.redirect_stdout(fh))</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        stack.enter_context(timer(name))</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        </span><span class="hljs-con-keyword">yield</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-meta">@write_to_log(</span><span class="hljs-con-string">'some_name'</span><span class="hljs-con-meta">)</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">some_function</span><span class="hljs-con-function">():</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    print(</span><span class="hljs-con-string">'This will be written to 'some_name.txt''</span><span class="python">)</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">some_function()</span>&#13;
</code></pre>&#13;
    <p class="normal">Looks a bit simpler, doesn’t it? While this example is still reasonably legible without the <code class="inlineCode">ExitStack</code> context manager, the convenience of <code class="inlineCode">ExitStack</code> becomes quickly apparent when you <a id="_idIndexMarker515"/>need to do specific teardowns. In <a id="_idIndexMarker516"/>addition to the automatic handling, as seen before, it’s also possible to transfer the contexts to a new <code class="inlineCode">ExitStack</code> to manually handle the closing:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span><span class="python"> contextlib</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">with</span><span class="python"> contextlib.ExitStack() </span><span class="hljs-con-keyword">as</span><span class="python"> stack:</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    fh = stack.enter_context(</span><span class="hljs-con-built_in">open</span><span class="python">(</span><span class="hljs-con-string">'file.txt'</span><span class="python">, </span><span class="hljs-con-string">'w'</span><span class="python">))</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-comment"># Move the context(s) to a new ExitStack</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    new_stack = stack.pop_all()</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">bytes_written = fh.write(</span><span class="hljs-con-string">'fh is still open'</span><span class="python">)</span>&#13;
&#13;
<span class="hljs-con-comment"># After closing we can't write anymore</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">new_stack.close()</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">fh.write(</span><span class="hljs-con-string">'cant write anymore'</span><span class="python">)</span>&#13;
Traceback (most recent call last):&#13;
    ...&#13;
ValueError: I/O operation on closed file. &#13;
</code></pre>&#13;
    <p class="normal">Most of the <code class="inlineCode">contextlib</code> functions have extensive documentation available in the Python manual. <code class="inlineCode">ExitStack</code> in particular is documented using many examples at <a href="https://docs.python.org/3/library/contextlib.html#contextlib.ExitStack"><span class="url">https://docs.python.org/3/library/contextlib.html#contextlib.ExitStack</span></a>. I recommend keeping an eye on the <code class="inlineCode">contextlib</code> documentation as it is improving greatly with every Python version.</p>&#13;
    <p class="normal">Now that we have covered regular generators, it is time to continue with coroutines.</p>&#13;
    <h1 id="_idParaDest-187" class="heading-1">Coroutines</h1>&#13;
    <p class="normal">Coroutines are subroutines<a id="_idIndexMarker517"/> that offer non-pre-emptive multitasking through multiple entry points. The basic premise is that coroutines allow two functions to communicate with each other while running within a single thread. Normally, this type of communication is reserved only for multitasking or multithreading solutions, but coroutines offer a relatively simple way of achieving this at almost no added performance cost.</p>&#13;
    <p class="normal">Since generators <a id="_idIndexMarker518"/>are lazy by default, you might be able to guess how coroutines function. Until a result is consumed, the generator sleeps; but while consuming a result, the generator becomes active. The difference between regular generators and coroutines is that with coroutines the communication goes both ways; the coroutine can receive values as well as <code class="inlineCode">yield</code> them to the calling function.</p>&#13;
    <p class="normal">If you are familiar with <code class="inlineCode">asyncio</code> you might notice a strong similarity between <code class="inlineCode">asyncio</code> and coroutines. That is because <code class="inlineCode">asyncio</code> is built on the idea of coroutines and has evolved from a little bit of syntactic sugar into a whole ecosystem. For practical purposes I would suggest using <code class="inlineCode">asyncio</code> instead of the coroutine syntax explained here; for educational purposes, however, it is very useful to understand how they work. The <code class="inlineCode">asyncio</code> module is under very active development and has a much less awkward syntax.</p>&#13;
    <h2 id="_idParaDest-188" class="heading-2">A basic example</h2>&#13;
    <p class="normal">In the <a id="_idIndexMarker519"/>previous sections, you saw how regular generators can <code class="inlineCode">yield</code> values. But generators can do more; they can actually receive values through <code class="inlineCode">yield</code> as well. The basic usage is fairly simple:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">generator</span><span class="hljs-con-function">():</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    value = </span><span class="hljs-con-keyword">yield</span><span class="python"> </span><span class="hljs-con-string">'value from generator'</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    print(</span><span class="hljs-con-string">'Generator received:'</span><span class="python">, value)</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">yield</span><span class="python"> </span><span class="hljs-con-string">f'Previous value: </span><span class="hljs-con-subst">{value!r}</span><span class="hljs-con-string">'</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">g = generator()</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">print(</span><span class="hljs-con-string">'Result from generator:'</span><span class="python">, </span><span class="hljs-con-built_in">next</span><span class="python">(g))</span>&#13;
Result from generator: value from generator&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">print(g.send(</span><span class="hljs-con-string">'value from caller'</span><span class="python">))</span>&#13;
Generator received: value from caller&#13;
Previous value: 'value from caller'&#13;
</code></pre>&#13;
    <p class="normal">And that’s all there is to it. The function is frozen until the <code class="inlineCode">send</code> method is called, at which point it will process up to the next <code class="inlineCode">yield</code> statement. One limitation you can see from this is that the coroutine can’t wake up by itself. The value exchanges can only happen when the calling code runs <code class="inlineCode">next(generator)</code> or <code class="inlineCode">generator.send()</code>.</p>&#13;
    <h2 id="_idParaDest-189" class="heading-2">Priming</h2>&#13;
    <p class="normal">Since<a id="_idIndexMarker520"/> generators are lazy, you can’t just send a value to a brand-new generator. Before a value can be sent to the generator, either a result must be fetched using <code class="inlineCode">next()</code> or a <code class="inlineCode">send(None)</code> has to be issued so that the code is actually reached. This is understandable, but a bit tedious at times. Let’s create a simple decorator to omit the need for this:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span><span class="python"> functools</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">coroutine</span><span class="hljs-con-function">(</span><span class="hljs-con-params">function</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-comment"># Copy the 'function' description with 'functools.wraps'</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-meta">    @functools.wraps(</span><span class="hljs-con-params">function</span><span class="hljs-con-meta">)</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">_coroutine</span><span class="hljs-con-function">(</span><span class="hljs-con-params">*args, **kwargs</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        active_coroutine = function(*args, **kwargs)</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        </span><span class="hljs-con-comment"># Prime the coroutine and make sure we get no values</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        </span><span class="hljs-con-keyword">assert</span><span class="python"> </span><span class="hljs-con-keyword">not</span><span class="python"> </span><span class="hljs-con-built_in">next</span><span class="python">(active_coroutine)</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        </span><span class="hljs-con-keyword">return</span><span class="python"> active_coroutine</span>&#13;
<span class="hljs-con-meta">...</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">return</span><span class="python"> _coroutine</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-meta">@coroutine</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">our_coroutine</span><span class="hljs-con-function">():</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">while</span><span class="python"> </span><span class="hljs-con-literal">True</span><span class="python">:</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        print(</span><span class="hljs-con-string">'Waiting for yield...'</span><span class="python">)</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        value = </span><span class="hljs-con-keyword">yield</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        print(</span><span class="hljs-con-string">'our coroutine received:'</span><span class="python">, value)</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">generator = our_coroutine()</span>&#13;
Waiting for yield...&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">generator.send(</span><span class="hljs-con-string">'a'</span><span class="python">)</span>&#13;
our coroutine received: a&#13;
Waiting for yield...&#13;
</code></pre>&#13;
    <p class="normal">As you’ve probably noticed, even though the generator is still lazy, it now automatically executes all of the code until it reaches the <code class="inlineCode">yield</code> statement again. At that point, it will stay dormant until new values are sent.</p>&#13;
    <div class="note">&#13;
      <p class="normal">Note that the <code class="inlineCode">coroutine</code> decorator will be used throughout this chapter from this point onward. For brevity, the coroutine function definition will be omitted from the following examples.</p>&#13;
    </div>&#13;
    <h2 id="_idParaDest-190" class="heading-2">Closing and throwing exceptions</h2>&#13;
    <p class="normal">Unlike <a id="_idIndexMarker521"/>regular generators, which simply exit as soon as the input sequence is exhausted, coroutines generally employ infinite <code class="inlineCode">while</code> loops, which means that they won’t be torn down the normal way. That’s why coroutines also support both the <code class="inlineCode">close</code> and <code class="inlineCode">throw</code> methods, which will exit the function. The important thing here is not the closing but the possibility of adding a teardown method. Essentially, it is very comparable to how context wrappers function with an <code class="inlineCode">__enter__</code> and <code class="inlineCode">__exit__</code> method, but with coroutines in this case.</p>&#13;
    <p class="normal">The following example <a id="_idIndexMarker522"/>shows a coroutine with normal and exception exit cases using the <code class="inlineCode">coroutine</code> decorator from the previous paragraph:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">from</span><span class="python"> coroutine_decorator </span><span class="hljs-con-keyword">import</span><span class="python"> coroutine</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-meta">@coroutine</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">simple_coroutine</span><span class="hljs-con-function">():</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    print(</span><span class="hljs-con-string">'Setting up the coroutine'</span><span class="python">)</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">try</span><span class="python">:</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        </span><span class="hljs-con-keyword">while</span><span class="python"> </span><span class="hljs-con-literal">True</span><span class="python">:</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">            item = </span><span class="hljs-con-keyword">yield</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">            print(</span><span class="hljs-con-string">'Got item:'</span><span class="python">, item)</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">except</span><span class="python"> GeneratorExit:</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        print(</span><span class="hljs-con-string">'Normal exit'</span><span class="python">)</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">except</span><span class="python"> Exception </span><span class="hljs-con-keyword">as</span><span class="python"> e:</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        print(</span><span class="hljs-con-string">'Exception exit:'</span><span class="python">, e)</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        </span><span class="hljs-con-keyword">raise</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">finally</span><span class="python">:</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        print(</span><span class="hljs-con-string">'Any exit'</span><span class="python">)</span>&#13;
</code></pre>&#13;
    <p class="normal">This <code class="inlineCode">simple_coroutine()</code> function can show us some of the internal flow of coroutines and how they are interrupted. The <code class="inlineCode">try</code>/<code class="inlineCode">finally</code> behavior might surprise you in particular:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">active_coroutine = simple_coroutine()</span>&#13;
Setting up the coroutine&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">active_coroutine.send(</span><span class="hljs-con-string">'from caller'</span><span class="python">)</span>&#13;
Got item: from caller&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">active_coroutine.close()</span>&#13;
Normal exit&#13;
Any exit&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">active_coroutine = simple_coroutine()</span>&#13;
Setting up the coroutine&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">active_coroutine.throw(RuntimeError, </span><span class="hljs-con-string">'caller sent an error'</span><span class="python">)</span>&#13;
Traceback (most recent call last):&#13;
    ...&#13;
RuntimeError: caller sent an error&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">active_coroutine = simple_coroutine()</span>&#13;
Setting up the coroutine&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">try</span><span class="python">:</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    active_coroutine.throw(RuntimeError, </span><span class="hljs-con-string">'caller sent an error'</span><span class="python">)</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-keyword">except</span><span class="python"> RuntimeError </span><span class="hljs-con-keyword">as</span><span class="python"> exception:</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    print(</span><span class="hljs-con-string">'Exception:'</span><span class="python">, exception)</span>&#13;
Exception exit: caller sent an error&#13;
Any exit&#13;
Exception: caller sent an error &#13;
</code></pre>&#13;
    <p class="normal">Most of <a id="_idIndexMarker523"/>this output<a id="_idIndexMarker524"/> is as you would expect, but as was the case with the <code class="inlineCode">StopIteration</code> in generators, you have to catch the exception to be sure the teardown is handled correctly.</p>&#13;
    <h2 id="_idParaDest-191" class="heading-2">Mixing generators and coroutines</h2>&#13;
    <p class="normal">While <a id="_idIndexMarker525"/>generators and coroutines appear to be very similar due to the <code class="inlineCode">yield</code> statements, they are somewhat different beasts. Let’s create a two-way<a id="_idIndexMarker526"/> pipeline to process the given input and pass this along to multiple coroutines along the way:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-comment"># The decorator from the Priming section in this chapter</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">from</span><span class="python"> coroutine_decorator </span><span class="hljs-con-keyword">import</span><span class="python"> coroutine</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">lines = </span><span class="hljs-con-string">'some old text'</span><span class="python">, </span><span class="hljs-con-string">'really really old'</span><span class="python">, </span><span class="hljs-con-string">'old old old'</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-meta">@coroutine</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">replace</span><span class="hljs-con-function">(</span><span class="hljs-con-params">search, replace</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">while</span><span class="python"> </span><span class="hljs-con-literal">True</span><span class="python">:</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        item = </span><span class="hljs-con-keyword">yield</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        print(item.replace(search, replace))</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">old_replace = replace(</span><span class="hljs-con-string">'old'</span><span class="python">, </span><span class="hljs-con-string">'new'</span><span class="python">)</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">for</span><span class="python"> line </span><span class="hljs-con-keyword">in</span><span class="python"> lines:</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    old_replace.send(line)</span>&#13;
some new text&#13;
really really new&#13;
new new new&#13;
</code></pre>&#13;
    <p class="normal">Given this example, you might be wondering why we are now printing the value instead of yielding it. We can <code class="inlineCode">yield</code> the value, but remember that generators freeze until a value is yielded. Let’s <a id="_idIndexMarker527"/>see what will happen if we simply <code class="inlineCode">yield</code> the value<a id="_idIndexMarker528"/> instead of calling <code class="inlineCode">print</code>. By default, you might be tempted to do this:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-meta">@coroutine</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">replace</span><span class="hljs-con-function">(</span><span class="hljs-con-params">search, replace</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">while</span><span class="python"> </span><span class="hljs-con-literal">True</span><span class="python">:</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        item = </span><span class="hljs-con-keyword">yield</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        </span><span class="hljs-con-keyword">yield</span><span class="python"> item.replace(search, replace)</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">old_replace = replace(</span><span class="hljs-con-string">'</span><span class="hljs-con-string">old'</span><span class="python">, </span><span class="hljs-con-string">'new'</span><span class="python">)</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">for</span><span class="python"> line </span><span class="hljs-con-keyword">in</span><span class="python"> lines:</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    old_replace.send(line)</span>&#13;
'some new text'&#13;
'new new new'&#13;
</code></pre>&#13;
    <p class="normal">Half of the values have disappeared now; our “<code class="inlineCode">really really new</code>" line has disappeared. Notice that the second <code class="inlineCode">yield</code> isn’t storing the results, and that <code class="inlineCode">yield</code> effectively makes this a generator and not a coroutine. We need to store the results from that <code class="inlineCode">yield</code> as well:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-meta">@coroutine</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">replace</span><span class="hljs-con-function">(</span><span class="hljs-con-params">search, replace</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    item = </span><span class="hljs-con-keyword">yield</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">while</span><span class="python"> </span><span class="hljs-con-literal">True</span><span class="python">:</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        item = </span><span class="hljs-con-keyword">yield</span><span class="python"> item.replace(search, replace)</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">old_replace = replace(</span><span class="hljs-con-string">'old'</span><span class="python">, </span><span class="hljs-con-string">'new'</span><span class="python">)</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">for</span><span class="python"> line </span><span class="hljs-con-keyword">in</span><span class="python"> lines:</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    old_replace.send(line)</span>&#13;
'some new text'&#13;
'really really new'&#13;
'new new new'&#13;
</code></pre>&#13;
    <p class="normal">But even this is far from optimal. We are essentially using coroutines to mimic the behavior of generators right now. It works, but it is a bit pointless and offers no real benefit.</p>&#13;
    <p class="normal">Let’s make a real pipeline this time where the coroutines send the data to the next coroutine or coroutines. This<a id="_idIndexMarker529"/> demonstrates the real power of coroutines, which is being able to <a id="_idIndexMarker530"/>chain multiple coroutines together: </p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-meta">@coroutine</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">replace</span><span class="hljs-con-function">(</span><span class="hljs-con-params">target, search, replace</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">while</span><span class="python"> </span><span class="hljs-con-literal">True</span><span class="python">:</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        target.send((</span><span class="hljs-con-keyword">yield</span><span class="python">).replace(search, replace))</span>&#13;
&#13;
<span class="hljs-con-comment"># Print will print the items using the provided formatstring</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-meta">@coroutine</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">print_</span><span class="hljs-con-function">(</span><span class="hljs-con-params">formatstring</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    count = </span><span class="hljs-con-number">0</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">while</span><span class="python"> </span><span class="hljs-con-literal">True</span><span class="python">:</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        count += </span><span class="hljs-con-number">1</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        print(count, formatstring.</span><span class="hljs-con-built_in">format</span><span class="python">((</span><span class="hljs-con-keyword">yield</span><span class="python">)))</span>&#13;
<span class="hljs-con-comment"># tee multiplexes the items to multiple targets</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-meta">@coroutine</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">tee</span><span class="hljs-con-function">(</span><span class="hljs-con-params">*targets</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">while</span><span class="python"> </span><span class="hljs-con-literal">True</span><span class="python">:</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        item = </span><span class="hljs-con-keyword">yield</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        </span><span class="hljs-con-keyword">for</span><span class="python"> target </span><span class="hljs-con-keyword">in</span><span class="python"> targets:</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">            target.send(item)</span>&#13;
</code></pre>&#13;
    <p class="normal">Now that we have our coroutine functions, let’s see how we can link these together:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-comment"># Because we wrap the results we need to work backwards from the</span>&#13;
<span class="hljs-con-comment"># inner layer to the outer layer.</span>&#13;
&#13;
<span class="hljs-con-comment"># First, create a printer for the items:</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">printer = print_(</span><span class="hljs-con-string">'print: {}'</span><span class="python">)</span>&#13;
&#13;
<span class="hljs-con-comment"># Create replacers that send the output to the printer</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">old_replace = replace(printer, </span><span class="hljs-con-string">'old'</span><span class="python">, </span><span class="hljs-con-string">'new'</span><span class="python">)</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">current_replace = replace(printer, </span><span class="hljs-con-string">'old'</span><span class="python">, </span><span class="hljs-con-string">'current'</span><span class="python">)</span>&#13;
&#13;
<span class="hljs-con-comment"># Send the input to both replacers</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">branch = tee(old_replace, current_replace)</span>&#13;
&#13;
<span class="hljs-con-comment"># Send the data to the tee routine for processing</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">for</span><span class="python"> line </span><span class="hljs-con-keyword">in</span><span class="python"> lines:</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    branch.send(line)</span>&#13;
1 print: some new text&#13;
2 print: some current text&#13;
3 print: really really new&#13;
4 print: really really current&#13;
5 print: new new new&#13;
6 print: current current current&#13;
</code></pre>&#13;
    <p class="normal">This <a id="_idIndexMarker531"/>makes the code much simpler and more readable and shows how you can send a single input <a id="_idIndexMarker532"/>source to multiple destinations simultaneously. At first glance, this example does not look that exciting, but the exciting part is that even though we split the input using <code class="inlineCode">tee()</code> and processed it through two separate <code class="inlineCode">replace()</code> instances, we still ended up at the same <code class="inlineCode">print_()</code> function with the same state. This means that it’s possible to route and modify your data along whichever way is convenient for you while still having it end up at the same endpoint with no effort whatsoever.</p>&#13;
    <p class="normal">For now, the most important takeaway is that mixing generators and coroutines is not a good idea in most cases since it can have very strange side effects if used incorrectly. Even though both use the <code class="inlineCode">yield</code> statement, they are significantly different creatures with different behavior. The next section will demonstrate one of the few cases where mixing coroutines and generators can be useful.</p>&#13;
    <h2 id="_idParaDest-192" class="heading-2">Using the state</h2>&#13;
    <p class="normal">Now that you <a id="_idIndexMarker533"/>know how to write basic coroutines and which pitfalls you have to take care of, how about writing a function where remembering the state is required? That is, a function that always gives you the average value of all sent values. This is one of the few cases where it is still relatively safe and useful to combine the coroutine and generator syntax:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span><span class="python"> itertools</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-meta">@coroutine</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">average</span><span class="hljs-con-function">():</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    total = </span><span class="hljs-con-keyword">yield</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">for</span><span class="python"> count </span><span class="hljs-con-keyword">in</span><span class="python"> itertools.count(start=</span><span class="hljs-con-number">1</span><span class="python">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        total += </span><span class="hljs-con-keyword">yield</span><span class="python"> total / count</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">averager = average()</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">averager.send(</span><span class="hljs-con-number">20</span><span class="python">)</span>&#13;
20.0&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">averager.send(</span><span class="hljs-con-number">10</span><span class="python">)</span>&#13;
15.0&#13;
</code></pre>&#13;
    <p class="normal">It still requires some extra logic to work properly, though. We need to prime our coroutine using <code class="inlineCode">yield</code>, but we don’t send any data at that point because the first <code class="inlineCode">yield</code> is the primer and is executed before we get the value. Once that’s all set up, we can easily yield the average value while summing. It’s not all that bad, but the pure coroutine<a id="_idIndexMarker534"/> version is slightly simpler to understand since we only have a single execution path because we don’t have to worry about priming. To illustrate this, here is the pure coroutine version:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span><span class="python"> itertools</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-meta">@coroutine</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">print_</span><span class="hljs-con-function">(</span><span class="hljs-con-params">formatstring</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">while</span><span class="python"> </span><span class="hljs-con-literal">True</span><span class="python">:</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        print(formatstring.</span><span class="hljs-con-built_in">format</span><span class="python">((</span><span class="hljs-con-keyword">yield</span><span class="python">)))</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-meta">@coroutine</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">average</span><span class="hljs-con-function">(</span><span class="hljs-con-params">target</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    total = </span><span class="hljs-con-number">0</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">for</span><span class="python"> count </span><span class="hljs-con-keyword">in</span><span class="python"> itertools.count(start=</span><span class="hljs-con-number">1</span><span class="python">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        total += </span><span class="hljs-con-keyword">yield</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        target.send(total / count)</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">printer = print_(</span><span class="hljs-con-string">'{:.1f}'</span><span class="python">)</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">averager = average(printer)</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">averager.send(</span><span class="hljs-con-number">20</span><span class="python">)</span>&#13;
20.0&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">averager.send(</span><span class="hljs-con-number">10</span><span class="python">)</span>&#13;
15.0&#13;
</code></pre>&#13;
    <p class="normal">While that example is a few lines longer than the version that includes a generator, it is much easier to understand. Let’s analyze it to make sure the workings are clear:</p>&#13;
    <ol class="numberedList" style="list-style-type: decimal;">&#13;
      <li class="numberedList" value="1">We set <code class="inlineCode">total</code> to <code class="inlineCode">0</code> to start counting.</li>&#13;
      <li class="numberedList">We keep track of the measurement count by using <code class="inlineCode">itertools.count()</code>, which we configure to start counting from 1.</li>&#13;
      <li class="numberedList">We fetch the next value using <code class="inlineCode">yield</code>.</li>&#13;
      <li class="numberedList">We send the average to the given coroutine instead of returning the value to make the code less confusing.</li>&#13;
    </ol>&#13;
    <p class="normal">Another nice example is <code class="inlineCode">itertools.groupby</code>, which is also quite simple to recreate using coroutines. For <a id="_idIndexMarker535"/>comparison, I will once again show both the generator coroutine and the pure coroutine version:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-meta">@coroutine</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">groupby</span><span class="hljs-con-function">():</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-comment"># Fetch the first key and value and initialize the state</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-comment"># variables</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    key, value = </span><span class="hljs-con-keyword">yield</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    old_key, values = key, []</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">while</span><span class="python"> </span><span class="hljs-con-literal">True</span><span class="python">:</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        </span><span class="hljs-con-comment"># Store the previous value so we can store it in the</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        </span><span class="hljs-con-comment"># list</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        old_value = value</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        </span><span class="hljs-con-keyword">if</span><span class="python"> key == old_key:</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">            key, value = </span><span class="hljs-con-keyword">yield</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        </span><span class="hljs-con-keyword">else</span><span class="python">:</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">            key, value = </span><span class="hljs-con-keyword">yield</span><span class="python"> old_key, values</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">            old_key, values = key, []</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        values.append(old_value)</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">grouper = groupby()</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">grouper.send(</span><span class="hljs-con-string">'a1'</span><span class="python">)</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">grouper.send(</span><span class="hljs-con-string">'a2'</span><span class="python">)</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">grouper.send(</span><span class="hljs-con-string">'a3'</span><span class="python">)</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">grouper.send(</span><span class="hljs-con-string">'b1'</span><span class="python">)</span>&#13;
('a', ['1', '2', '3'])&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">grouper.send(</span><span class="hljs-con-string">'b2'</span><span class="python">)</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">grouper.send(</span><span class="hljs-con-string">'</span><span class="hljs-con-string">a1'</span><span class="python">)</span>&#13;
('b', ['1', '2'])&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">grouper.send(</span><span class="hljs-con-string">'a2'</span><span class="python">)</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">grouper.send((</span><span class="hljs-con-literal">None</span><span class="python">, </span><span class="hljs-con-literal">None</span><span class="python">))</span>&#13;
('a', ['1', '2']) &#13;
</code></pre>&#13;
    <p class="normal">As you can see, this function uses a few tricks. Firstly, we store the previous <code class="inlineCode">key</code> and <code class="inlineCode">value</code> so that we can detect when the group (<code class="inlineCode">key</code>) changes. Secondly, we obviously cannot recognize a group until the group has changed, so only after the group has changed will the results be returned. This means that the last group will be sent only if a different group is sent after it, hence the <code class="inlineCode">(None, None)</code>.</p>&#13;
    <div class="packt_tip">&#13;
      <p class="normal">The example uses tuple unpacking for the string, splitting <code class="inlineCode">'a1'</code> into group <code class="inlineCode">'a'</code> and value <code class="inlineCode">'1'</code>. Alternatively, you could also use <code class="inlineCode">grouper.send(('a', 1))</code>.</p>&#13;
    </div>&#13;
    <p class="normal">Now here<a id="_idIndexMarker536"/> is the pure coroutine version:</p>&#13;
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-meta">@coroutine</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">print_</span><span class="hljs-con-function">(</span><span class="hljs-con-params">formatstring</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">while</span><span class="python"> </span><span class="hljs-con-literal">True</span><span class="python">:</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        print(formatstring.</span><span class="hljs-con-built_in">format</span><span class="python">(*(</span><span class="hljs-con-keyword">yield</span><span class="python">)))</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-meta">@coroutine</span>&#13;
<span class="hljs-con-meta">...</span> <span class="hljs-con-keyword">def</span><span class="hljs-con-function"> </span><span class="hljs-con-title">groupby</span><span class="hljs-con-function">(</span><span class="hljs-con-params">target</span><span class="hljs-con-function">):</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    old_key = </span><span class="hljs-con-literal">None</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">    </span><span class="hljs-con-keyword">while</span><span class="python"> </span><span class="hljs-con-literal">True</span><span class="python">:</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        key, value = </span><span class="hljs-con-keyword">yield</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        </span><span class="hljs-con-keyword">if</span><span class="python"> old_key != key:</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">            </span><span class="hljs-con-comment"># A different key means a new group so send the</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">            </span><span class="hljs-con-comment"># previous group and restart the cycle.</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">            </span><span class="hljs-con-keyword">if</span><span class="python"> old_key </span><span class="hljs-con-keyword">and</span><span class="python"> values:</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">                target.send((old_key, values))</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">            values = []</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">            old_key = key</span>&#13;
<span class="hljs-con-meta">...</span> <span class="python">        values.append(value)</span>&#13;
&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">grouper = groupby(print_(</span><span class="hljs-con-string">'</span><span class="hljs-con-string">group: {}, values: {}'</span><span class="python">))</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">grouper.send(</span><span class="hljs-con-string">'a1'</span><span class="python">)</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">grouper.send(</span><span class="hljs-con-string">'a2'</span><span class="python">)</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">grouper.send(</span><span class="hljs-con-string">'a3'</span><span class="python">)</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">grouper.send(</span><span class="hljs-con-string">'b1'</span><span class="python">)</span>&#13;
group: a, values: ['1', '2', '3']&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">grouper.send(</span><span class="hljs-con-string">'b2'</span><span class="python">)</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">grouper.send(</span><span class="hljs-con-string">'a1'</span><span class="python">)</span>&#13;
group: b, values: ['1', '2']&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">grouper.send(</span><span class="hljs-con-string">'a2'</span><span class="python">)</span>&#13;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="python">grouper.send((</span><span class="hljs-con-literal">None</span><span class="python">, </span><span class="hljs-con-literal">None</span><span class="python">))</span>&#13;
group: a, values: ['1', '2']&#13;
</code></pre>&#13;
    <p class="normal">While the functions are fairly similar, the coroutine version has a less complex control path and only needs to <code class="inlineCode">yield</code> in one spot. This is because we don’t have to think about priming and potentially losing values.</p>&#13;
    <h1 id="_idParaDest-193" class="heading-1">Exercises</h1>&#13;
    <p class="normal">Generators have a multitude of uses so you can probably start using them in your own code right away. Nevertheless, the following exercises might help you understand the features and the limitations a bit better:</p>&#13;
    <ul>&#13;
      <li class="bulletList">Create a generator similar to <code class="inlineCode">itertools.islice()</code> that allows for a negative step so you can execute <code class="inlineCode">some_list[20:10:-1]</code>.</li>&#13;
      <li class="bulletList">Create a class that wraps a generator so it becomes sliceable by using <code class="inlineCode">itertools.islice()</code> internally.</li>&#13;
      <li class="bulletList">Write a generator for the Fibonacci numbers.</li>&#13;
      <li class="bulletList">Write a generator that uses the sieve of Eratosthenes to generate prime numbers.</li>&#13;
    </ul>&#13;
    <div class="note">&#13;
      <p class="normal">Example answers for these exercises can be found on GitHub: <a href="https://github.com/mastering-python/exercises"><span class="url">https://github.com/mastering-python/exercises</span></a>. You are encouraged to submit your own solutions and learn about alternative solutions from others.</p>&#13;
    </div>&#13;
    <h1 id="_idParaDest-194" class="heading-1">Summary</h1>&#13;
    <p class="normal">This chapter showed you how to create generators and both the strengths and weaknesses that they possess. Additionally, it should now be clear how to work around their limitations and the implications of doing so.</p>&#13;
    <p class="normal">In general, I would always recommend the use of generators over traditional collection-generating functions. They are easier to write, consume less memory, and, if needed, the downsides can be mitigated by replacing <code class="inlineCode">some_generator()</code> with <code class="inlineCode">list(some_generator())</code>, or a decorator that handles that for you. </p>&#13;
    <p class="normal">While the paragraphs about coroutines provided some insights into what they are and how they can be used, they were just a mild introduction to coroutines. Both the pure coroutines and the coroutine generator combinations are still somewhat clunky, which is why the <code class="inlineCode">asyncio</code> library was created. <em class="chapterRef">Chapter 13, </em><em class="italic">- asyncio – Multithreading without Threads,</em> covers <code class="inlineCode">asyncio</code> in detail and also introduces the <code class="inlineCode">async</code> and <code class="inlineCode">await</code> statements, which make coroutine usage much more intuitive compared to <code class="inlineCode">yield</code>.</p>&#13;
    <p class="normal">In the previous chapter, you saw how we can modify classes using class decorators. In the next chapter, we will cover the creation of classes using metaclasses. Using metaclasses, you can modify classes during the creation of the class itself. Note that I am not talking about the instances of the class, but the actual class object. Using this technique, you can create automatically registering plugin systems, add extra attributes to classes, and more.</p>&#13;
    <h1 class="heading-1">Join our community on Discord</h1>&#13;
    <p class="normal">Join our community’s Discord space for discussions with the author and other readers: <a href="https://discord.gg/QMzJenHuJf"><span class="url">https://discord.gg/QMzJenHuJf</span></a></p>&#13;
    <p class="normal"><img src="Images/QR_Code156081100001293319171.png" alt="" width="177" height="177"/></p>&#13;
  </div>&#13;
</div></body></html>