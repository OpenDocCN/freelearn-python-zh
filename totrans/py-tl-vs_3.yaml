- en: Chapter 3. Day-to-day Coding Tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will go through the coding tools that are essential during
    a normal day of work for a Python programmer in Visual Studio.
  prefs: []
  type: TYPE_NORMAL
- en: First we will analyze how to handle projects and solutions in Visual Studio,
    and then we will go through the refactoring of functionalities. Finally, we will
    go through the debugger functions that are available.
  prefs: []
  type: TYPE_NORMAL
- en: Project handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most important and useful features of Visual Studio is the solution
    and project handling. Since the whole workflow is integrated into the IDE, the
    developer does not have the burden of dealing with files, working paths, and libraries.
    All of these can be managed directly in the IDE with the powerful Visual Studio
    user interface.
  prefs: []
  type: TYPE_NORMAL
- en: Before we dig into the tools in detail, we will first take a look at the Visual
    Studio lingo relating to project handling. The two main concepts used in this
    chapter are the solution and the project.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A solution is essentially a container of projects that are bundled together
    to cover a unique scope. The projects can be referenced to each other and they
    can be of different types. For example, in a solution, you can mix a Python project
    with a C++ project while referencing the output of the project in the Python solution
    to use it as an external library. A solution also provides a way to group the
    whole code base of work in a single file/folder structure. You can then insert
    and manage the grouping in the versioning tool of your choice to share it quickly.
    A Visual Studio solution is also capable of maintaining shared configurations
    for the inner projects, while handing different commands and operations during
    different events (i.e. during the build of the solution).
  prefs: []
  type: TYPE_NORMAL
- en: Project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A project is the classical definition of a bunch of files written in the same
    language and which covers a single scope. The types of projects can range from
    a website to a library or a console application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Visual Studio projects for Python contain the environment definition: where
    to target the code, the references to external libraries, and the search paths
    that the compiler has to search in the libraries. The last one is particularly
    important since PTVS does not use the computer''s PythonPath environment variable.'
  prefs: []
  type: TYPE_NORMAL
- en: The deliberate and useful feature of ignoring system-wide settings allows you
    to reference different libraries in different projects for different Python versions.
    Furthermore, the dependency list in the code brings the added bonus of an easier
    debugging process and also provides an easy setup of a new development environment
    on other computers.
  prefs: []
  type: TYPE_NORMAL
- en: PTVS offers preconfigured Python projects called project templates, as we have
    seen in [Chapter 1](ch01.html "Chapter 1. Introduction to PTVS"), *Introduction
    to PTVS*, which take care of creating the right project structure so that the
    developer can focus on the code.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at the actual tools that will handle solutions and projects.
    The most important and powerful one is the **Solution Explorer** window tool.
    This tool gives a complete view of the solution composition and the files and
    configurations available in each project.
  prefs: []
  type: TYPE_NORMAL
- en: '![Project](img/8687OS_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To add something or to perform actions on a Solution or a Project, select the
    Solution or Project node in the tree-view
  prefs: []
  type: TYPE_NORMAL
- en: 'By now, you should already know how to navigate through the code using this
    tool, as we learned in [Chapter 2](ch02.html "Chapter 2. Python Tools in Visual
    Studio"), *Python Tools in Visual Studio*. The **Solution Explorer** window tool
    also provides file handling capabilities, giving us the ability to add or remove
    files directly in the project structure. Just select a folder item in the project
    structure to insert a new file. To add something in the project root, select the
    project item in **Solution Explorer**, right-click to open the contextual menu,
    and go into the **Add** submenu as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Project](img/8687OS_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, you can choose to add either **New Item**, **Existing Item**, or **New
    Folder**. If you choose to add **New Item**, the **Add New Item** window will
    show up as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Project](img/8687OS_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: From here, you can create a new item from the various types that are available
    in the project.
  prefs: []
  type: TYPE_NORMAL
- en: If instead you want to add an existing file to the selected folder, select the
    **Add existing item** option from the contextual add menu. This will open a standard
    Windows browse file window; from here, you can navigate through the filesystem
    and select the file that you want to add to the selected folder. A copy of that
    file will be added to the folder.
  prefs: []
  type: TYPE_NORMAL
- en: To delete a file, just select the item in the project list and select the **Delete**
    menu item from the contextual menu.
  prefs: []
  type: TYPE_NORMAL
- en: '![Project](img/8687OS_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The file contextual menu in the Solution Explorer window offers lots of functions
    on file, like "Delete", "Rename" and others
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have more confidence in **Solution Explorer**, let''s dig a little
    deeper into the Python-specific options that **Solution Explorer** offers. In
    the following sections, you will learn more about the configuration of a Python
    project: the environment, the references, and the search path.'
  prefs: []
  type: TYPE_NORMAL
- en: Specifying Python environments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It''s possible to specifically define a Python environment version for a project
    instead of using the default Python version installed on the machine. This is
    particularly important for projects that we work on with other developers. By
    default, Visual Studio uses the default Python version installed on the machine
    when starting a new project. To link a project to a given Python version (environment),
    right-click on the **Python Environment** item in **Solution Explorer** to see
    the contextual menu. This is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Specifying Python environments](img/8687OS_03_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The Python Environments contextual menu in the Solution Explorer window
  prefs: []
  type: TYPE_NORMAL
- en: This contextual menu provides various functionalities such as adding or removing
    a Python environment and linking the project to either a virtual Python environment
    or an existing one. The last two options are very useful when you need to have
    a project running in a completely isolated environment space on the machine. The
    project can then be run with all of its dependencies and libraries in an isolated
    place, without interfering with the existing Python installations and Python path
    configurations on the machine.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a virtual environment in Visual Studio is straightforward. Click on
    either **Add Virtual Environment** or **Add Existing Virtual Environment** and
    follow a few steps to complete the setup.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, we will create a virtual environment for our project. Clicking
    on **Add Virtual Environment** will show the following modal window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Specifying Python environments](img/8687OS_03_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can define the name of the virtual environment and the targeted Python version
    in this window. Once the **Create** button is pressed, Visual Studio will create
    the virtual environment. As a nifty bonus, if the necessary Python libraries are
    not installed on the machine—essentially `pip`, `setuptools`, and `virtualEnv`—PTVS
    will take care of this by downloading and installing them. Like other generic
    Python packages, they will be installed in the system-defined `site-packages`
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'To link a project to a given Python version, just click on the **Add Python
    Environment** option in the contextual menu and the following helper box will
    show up:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Specifying Python environments](img/8687OS_03_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This helper box shows a list of the Python versions installed on the machine
    and which are available for you to choose. Once a Python version is selected,
    the reference will show up in **Solution Explorer**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Specifying Python environments](img/8687OS_03_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The **References** item elements in a project provide the ability to tightly
    link a library in your project or reference to packages compiled in the .pyd files
  prefs: []
  type: TYPE_NORMAL
- en: 'Right-click on the **Reference** option and then click on **Add Reference**
    to bring up the following helper window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Specifying Python environments](img/8687OS_03_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We will focus on the **Projects** tab, which shows all the other projects in
    your solution. If you wish to use another library project to handle a subscope
    of the application, select the desired project and click on **OK**. This creates
    a reference in your project. You can find the list of references under the reference
    option in the **Solution** **Explorer** window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Specifying Python environments](img/8687OS_03_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Defining Search Paths
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The **Search Paths** functionality basically tells Visual Studio where to search
    for additional libraries that will be used in the project. You can reference a
    folder in the system or a `.zip` file that contains the libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Defining Search Paths](img/8687OS_03_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The Search Path contextual menu, with the "Add Folder" and "Add Zip Archive"
    options
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the folder of the `.zip` file is selected, you can find the libraries
    in the window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Defining Search Paths](img/8687OS_03_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Refactoring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Refactoring is one of the biggest advancements in modern IDEs. It significantly
    cuts down on time and reduces the margin of error by the way in which it handles
    changes in the code and automated operations. Visual Studio comes with great out-of-the-box
    refactoring functionalities such as renaming and the creating method from a selected
    piece of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The renaming functionality can really help with potential errors in code, such
    as when changing the name of an element. There might be instances in the codebase
    where the old name is still used. Let''s have a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In this code, there's a class, `foo`, that has a method called `bar`. If `bar`
    is renamed, it will create an error by referencing to a nonexistent method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Visual Studio''s refactoring functionality helps the renaming process by taking
    all the references of the element into account. Select the element that you wish
    to demand and then access the refactoring function in the code contextual menu
    by right-clicking on it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Refactoring](img/8687OS_03_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Access refactoring function by right clicking on the element
  prefs: []
  type: TYPE_NORMAL
- en: 'Select the **Rename** function to start the two-step process:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Refactoring](img/8687OS_03_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You are prompted to enter a new name for the element. There's also a checkbox
    that permits you to preview the references of the element to be renamed. When
    the checkbox is unchecked, all the references that are found will be renamed;
    you will not be able to preview which references are going to be renamed.
  prefs: []
  type: TYPE_NORMAL
- en: '![Refactoring](img/8687OS_03_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In a situation where you wish to preview the reference change, a preview window
    will be shown. As shown in the preceding screenshot, in this window all references
    of the old element name can be found at the top panel and the code preview will
    be at the bottom. All the files of the project will be analyzed to refactor the
    element correctly. A checkbox near each reference provides the option to activate
    the refactoring of that reference. Clicking on the **Apply** button will rename
    the element and all the selected references.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other refactoring function is **Extract** **Method**. This comes in handy
    when you wish to reuse a piece of code somewhere else as a function or a method.
    Visual Studio can generate it as a function/method. As an example, refer to the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Refactoring](img/8687OS_03_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the code, the highlighted code aims to create a generic method that calculates
    the sum of two elements. Select the code and then select **Extract Method** from
    the **Refactor** submenu in the contextual menu. This brings up the **Extract
    Method** dialog box, which is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Refactoring](img/8687OS_03_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the **Extract Method** window, you can define the name of the method in the
    **New method name** field and provide a path for the method to be created in the
    **Extract to** field. A **Preview** panel also shows the generated code. Click
    on **OK** to create the new method based on the selected code.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Visual Studio offers a large set of debugging tools; PTVS inherits a lot of
    them, which helps Python developers to debug code by using step-by-step execution,
    runtime variable watch capabilities, breakpoints, and the ability to see where
    the code fails during a debugging session.
  prefs: []
  type: TYPE_NORMAL
- en: 'The ability to see where the code breaks can significantly speed up the debugging
    session. In the following screenshot, we can see an example of an untracked exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Debugging](img/8687OS_03_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: An example of error dialog box during debugging a Python application
  prefs: []
  type: TYPE_NORMAL
- en: When you run the code, Visual Studio will stop the execution because it detects
    the raised exception of a problematic code. It highlights the exact point where
    the error occurred while also suggesting ways to fix it—even if right now Visual
    Studio may not suggest useful solutions for the problem.
  prefs: []
  type: TYPE_NORMAL
- en: The debugging process is not only about understanding where exceptions are raised,
    but also to understand what happens in the code when it is not behaving as expected.
    This is where step-by-step execution and breakpoints come in handy.
  prefs: []
  type: TYPE_NORMAL
- en: Using breakpoints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A breakpoint is a point that you can define in the code to stop the execution.
    Visual Studio has made it very simple to set a breakpoint. It allows better visibility
    of the content of variables and it follows the flow of the code. A breakpoint
    can be set by clicking in the gutter of the code window, which will bring up a
    red circle. Select **Insert Breakpoint** in the **Breakpoint** submenu in the
    code contextual menu.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the breakpoint is set, you can see it in the code window as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using breakpoints](img/8687OS_03_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that the breakpoint is set, if you run the application, Visual Studio will
    stop its execution precisely at the breakpoint while following the flow of the
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using breakpoints](img/8687OS_03_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Indicated that line 29 as the breakpoint
  prefs: []
  type: TYPE_NORMAL
- en: The IDE puts the caret on the first column of the line of code in which we set
    the breakpoint. When hovering around the variables in that context, we can see
    the current value of the variable.
  prefs: []
  type: TYPE_NORMAL
- en: Utilizing watch entries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can also create a watch entry on a variable in order to see how the value
    of a variable changes during the program flow. To watch a variable, right-click
    on it during the debugging process and click on **Add Watch** in the contextual
    menu. The variable will be added into the **Watch** window as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Utilizing watch entries](img/8687OS_03_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Besides the `watch` variable, it is also possible to see all the variables
    in the current scope from the **Locals** tab:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Utilizing watch entries](img/8687OS_03_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once a breakpoint has been hit, it''s possible to use one of the following
    three functions to move on in the program flow: `Step Into`, `Step Over`, and
    `Step Out`. These functions are accessible through the **Debug** menu or the buttons
    available in the toolbar. Alternatively, you can also use `Run to Cursor` (*Ctrl*
    + *F10*) to run through the program until you reach where the cursor is:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Utilizing watch entries](img/8687OS_03_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '`Step Into`: This executes the next statement and stops. If the next statement
    is a call to a function, the debugger will stop at the first line of the function
    being called entering the function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Step Over`: This executes the next statement. However, if the next statement
    is a function, calling it will not go into it. It''s useful when you are not willing
    to follow the entire program flow of the function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Step Out`: This executes the code until the end of the current function. It''s
    useful when you do not wish to go through the entire program flow of the current
    function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you wish to just continue the execution of the program flow without going
    into a single line of code at the time, just press the **Continue** button in
    the toolbar or *F5*. If there are other breakpoints in your code, the execution
    will continue through all of them until the last one.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we introduced the tools for day-to-day coding. You are now
    familiar with browsing through the code with **Solution Explorer** and the flexible
    setting of Python environments. You also learned about the more efficient refactoring
    and debugging process and that setting up breakpoints and watching entries helps
    you trace exactly where the code breaks.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore how to harness the powerful Visual Studio
    IDE and the tools available to speed up Django development.
  prefs: []
  type: TYPE_NORMAL
