- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Improving the Look with Styles and Themes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While programs can be perfectly functional with plain text in shades of black,
    white, and gray, the subtle use of colors, fonts, and images can enhance the visual
    appeal and usability of even the most utilitarian applications. Your data entry
    application is no exception, and the current round of requests brought to you
    by your coworkers seems to require some retooling of the application's look and
    feel.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically, you''ve been asked to address these points:'
  prefs: []
  type: TYPE_NORMAL
- en: Your manager has informed you that ABQ's corporate policy requires the company
    logo to be displayed on all in-house software. You've been provided with a corporate
    logo image to include in the application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The data entry staff have some readability issues with the form. They want more
    visual distinction between the sections of the form and more visibility for error
    messages.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The data entry staff have also requested that you highlight records they've
    added or updated during a session to help them keep track of their work.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition to the user's requests, you'd like to make your application look
    more professional by adding some icons to your buttons and menu.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to learn about some features of Tkinter that
    will help us to solve these issues:'
  prefs: []
  type: TYPE_NORMAL
- en: In *Working with images in Tkinter*, we'll learn how to add pictures and icons
    to our Tkinter GUI.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In *Styling Tkinter widgets*, we'll learn how to adjust the colors and visual
    style of Tkinter widgets, both directly and using tags.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In *Working with fonts in Tkinter*, we'll learn the ins and outs of using fonts
    in Tkinter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In *Styling Ttk widgets*, we'll learn how to adjust the look of Ttk widgets
    using styles and themes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with images in Tkinter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To solve the corporate logo issue and spruce up our application with some icons,
    we''re going to need to understand how to work with images in Tkinter. Tkinter
    provides access to image files through two classes: the `PhotoImage` class and
    the `BitmapImage` class. Let''s see how these classes can help us add graphics
    to our application.'
  prefs: []
  type: TYPE_NORMAL
- en: Tkinter PhotoImage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many Tkinter widgets, including `Label` and `Button`, accept an `image` argument
    that allows us to display an image on the widget. This argument requires that
    we create and pass in a `PhotoImage` (or `BitmapImage`) object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Making a `PhotoImage` object is fairly simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '`PhotoImage` is typically called with the keyword argument `file`, which is
    pointed to a file path. Alternatively, you can use the `data` argument to point
    to a `bytes` object containing image data. In either case, the resulting object
    can now be used wherever an `image` argument is accepted, such as in a `Label`
    widget:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that if we pass both an `image` and `text` argument to the `Label` initializer,
    only the image will be displayed by default. To display both, we need to also
    provide a value for the `compound` argument, which determines how the image and
    text will be arranged with respect to one another. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In this situation, the first label would only show the `image`; the `text` will
    not be displayed. In the second, since we have specified a `compound` value of
    `tk.LEFT`, the `image` will be displayed to the left of the `text`. `compound`
    can be any of `LEFT`, `RIGHT`, `BOTTOM`, or `TOP` (either lowercase strings or
    the Tkinter constants), and indicates where the image will be placed in relation
    to the text.
  prefs: []
  type: TYPE_NORMAL
- en: PhotoImage and variable scope
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When using a `PhotoImage` object, it is critical to remember that your application
    must retain a reference to the object that will stay in scope for as long as the
    image is shown; otherwise, the image will not appear. To understand what this
    means, consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: If you run this example, you'll notice that no image gets displayed. That's
    because the variable holding the `PhotoImage` object, `smile`, is a local variable,
    and therefore destroyed as soon as the initializer returns. With no reference
    remaining to the `PhotoImage` object, it is discarded and the image vanishes,
    even though we've packed it into the layout.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s fix our script by making a simple change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we've stored the `PhotoImage` object in an instance variable,
    `self.smile`. Instance variables continue to exist until the object itself is
    destroyed, so the picture remains on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Using Pillow for extended image support
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Image support in Tkinter is limited to GIF, PGM, PPM, and PNG files. If you're
    merely adding logos and icons to a GUI, these formats are probably sufficient,
    but for more graphics-heavy scenarios, the absence of such common formats as JPEG,
    SVG, and WebP becomes quite limiting. If you need support for any of these formats,
    you can use the `Pillow` library.
  prefs: []
  type: TYPE_NORMAL
- en: '`Pillow` is not part of the standard library, nor shipped with most Python
    distributions. To install it, follow the instructions at [https://python-pillow.org](https://python-pillow.org/);
    though in most cases, you can simply enter the following at a terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This will install `Pillow` from the **Python Package Index** (**PyPI**). Pillow
    provides us with a class called `ImageTk`, which we can use to create `PhotoImage`
    objects from a wide range of image file formats. To see how it works, let's build
    a small Tkinter-based image viewer with filters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a new file called `image_viewer_demo.py` and start with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Note that `Pillow` is imported as `PIL`. Pillow is actually a fork of a discontinued
    project called `PIL` (Python Imaging Library). For backward compatibility, it
    continues to use the `PIL` module name. From `PIL` we're importing the `Image`
    class, which is used to load images; the `ImageTk` class, which is used to convert
    Pillow `Image` objects for use in Tkinter; and `ImageFilter`, which will provide
    some filters for transforming our images.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s create our main application class for this app, `PictureViewer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This class begins by subclassing `Tk`, just as we did in our ABQ application,
    and the initializer starts with some basic window and grid layout configuration.
    Next, we''ll create the GUI elements, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'So far, we just have a `Label` widget for displaying the image and a `Button`
    widget bound to an instance method, `self._choose_file()`. Let''s create that
    method, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This method starts by asking the user for the filename with the `filedialog.askopenfilename()`
    method we learned about in *Chapter 7*, *Creating Menus with Menu and Tkinter
    Dialogs*. If the user selects a file, we call the `Image.open()` method to create
    a Pillow `Image` object from the file. `Image.open()` is a convenience method
    that simply takes a filename or path and returns an `Image` object containing
    that file's image data. Next, we create a Tkinter `PhotoImage` object by passing
    the `Image` object to `ImageTk.PhotoImage()`. Finally, we update our `image_display`
    widget with the new `PhotoImage` object.
  prefs: []
  type: TYPE_NORMAL
- en: Using this approach, you can display a much wider variety of image formats in
    Tkinter â€” Pillow has full read support for over 40 different formats! However,
    Pillow offers far more than just image format conversions. We can also use it
    to edit or transform our images in a variety of ways. For example, we can apply
    filtering to our Pillow `Image` objects. Let's add this feature to the demo application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back up in `PictureViewer.__init__()`, add the following GUI code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `filters` list contains the names of all the filter objects Pillow provides
    that we can apply to an `Image` object (these can be found in the `Pillow` documentation).
    We've added all these to an `OptionMenu` along with the string `None`. The `OptionMenu`
    widget is then bound to the `filtervar` control variable, on which we've added
    a trace that calls the `_apply_filter()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `_apply_filter()` method looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: First, this method retrieves the filter name from the control variable. If it's
    `None`, we set `self.filtered_image` to the current `self.image` object. Otherwise,
    we retrieve the filter object from the `ImageFilter` module using `getattr()`
    and apply the filter to our Pillow `Image` object using its `filter()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we update the displayed image in the application by creating a new
    `PhotoImage` object and updating the configuration of the `Label` widget.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see this program in action, add the last two lines to the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see something that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1: The image viewer application, filtering the Mona Lisa](img/B17578_09_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.1: The image viewer application, filtering the Mona Lisa'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a handle on using images in Tkinter, let's apply this knowledge
    to the ABQ Data Entry application.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the company logo to ABQ Data Entry
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With our knowledge of `PhotoImage`, adding the company logo to our program should
    be simple. We've been provided with several PNG files of the company logo in different
    sizes.
  prefs: []
  type: TYPE_NORMAL
- en: 'You could simply copy one into the application root directory and add something
    like this to the `Application` class''s initializer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run the application from a terminal inside the application root directory,
    this approach works fine. However, if you run it from any other directory, the
    image won''t appear. For example, try this from the command line in the directory
    containing your root:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Why is this, and what can we do about it?
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with the image path problem
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you give Python only a filename (with no path) to open, it assumes the
    file is in the **current working directory**. This is the directory the user was
    in when running the application. In the example above, when we ran the program
    the first time, our working directory was the application's root directory. The
    image was in that directory, so Python found it. The second time we ran it, our
    working directory was the parent directory of the application root. Python looked
    for the image in *that* directory, and it wasn't found.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you know where your file is on the system, you can provide an absolute path;
    for example, if you''re on Windows 10 and the application root is on your home
    directory, you could do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The problem, though, is that this reference would break if we put the code anywhere
    else on the system. Remember, as well, that our application needs to run on Linux
    and Windows, so providing an absolute path like this won't work across different
    platforms.
  prefs: []
  type: TYPE_NORMAL
- en: The `r` in front of the path string above makes it a raw string. When a string
    is marked as raw, Python does not interpret backslash escape sequences in the
    string. This makes raw strings useful for file paths on Windows, which uses the
    backslash for a path separator. See *Chapter 10*, *Maintaining Cross-Platform
    Compatibility*, for more details on solving cross-platform path issues.
  prefs: []
  type: TYPE_NORMAL
- en: A more robust approach is to provide a relative path from some known point.
    Every Python script has access to a variable called `__file__`, which is a string
    containing the path to the script file. We can use this variable in conjunction
    with the `pathlib` module to locate files inside our application root directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we could rewrite our `PhotoImage` object''s configuration like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Since we are in `application.py`, `__file__` points to `ABQ_Data_Entry/abq_data_entry/application.py`.
    We can use this reference point to find the parent of the parent directory, where
    the image files are located. This will enable Python to successfully find the
    images no matter what the current working directory is.
  prefs: []
  type: TYPE_NORMAL
- en: This approach is functionally acceptable, but it's rather cluttered and clumsy
    to do these kinds of path manipulation every time we need to access an image file.
    Let's employ some of our organizational skills from *Chapter 6*, *Planning for
    the Expansion of Our Application*, to put the images in their own module.
  prefs: []
  type: TYPE_NORMAL
- en: Under the `abq_data_entry` directory, create a new directory called `images`,
    and place within it an appropriately sized PNG file that we can use in our application
    (the image in the example code has an 8x5 aspect ratio, so in this case, we're
    using 32x20).
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, create an `__init__.py` file inside the `images` folder, in which we''ll
    add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In this case, `__file__` points to `ABQ_Data_Entry/abq_data_entry/images/__init__.py`,
    so we can use that point of reference to get paths to all the image files we put
    in `ABQ_Data_Entry/abq_data_entry/images/`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, our `application.py` module can import the `images` module like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Once imported, we can reference the image paths for our `PhotoImage` object
    easily:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, regardless of what working directory you run the script from, you should
    see the title looking something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.2: The ABQ Data Entry application sporting a company logo](img/B17578_09_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.2: The ABQ Data Entry application sporting a company logo'
  prefs: []
  type: TYPE_NORMAL
- en: Setting a window icon
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Currently, our application's window icon (the icon that shows up in both the
    window decorations and in the operating system's taskbar) is the Tkinter logo,
    which is the default for any Tkinter application. It would make more sense for
    us to use the company logo image for this icon. How can we make this happen?
  prefs: []
  type: TYPE_NORMAL
- en: 'As a subclass of `Tk`, our `Application` object has a method called `iconphoto()`
    which should, given a path to an icon file, set the window icon appropriately.
    Unfortunately, this method is a bit inconsistent in its results across platforms.
    Let''s go ahead and add it to our initializer as follows and see what happens.
    Add this code just after the call to `super().__init__()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The first line creates another `PhotoImage` object, referencing a larger version
    of the logo. Next, we execute `self.iconphoto()`. The first argument indicates
    whether we want this icon to be the default across all new windows, or whether
    it's only for this window. Passing `True` here makes it the default for all. The
    second argument is our `PhotoImage` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, when you run the application, you should see an ABQ icon being used as
    the window icon; how it is used depends on the platform. For example, on Windows,
    it shows up in the window decorations, as seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.3: The ABQ Logo as a taskbar icon](img/B17578_09_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.3: The ABQ logo as a taskbar icon'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a summary of how the `iconphoto` is used on different platforms:'
  prefs: []
  type: TYPE_NORMAL
- en: On Linux, it will depend on your desktop environment, but typically, it will
    show up in both the taskbar or dock and on the window decorations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On macOS, it will show up as the icon in the dock, but not in the global menu
    or on the window itself
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On Windows 10, it will appear on the window decorations, but not on the taskbar
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Part of the reason for this inconsistency is that our application is a script
    being executed by Python, so from the operating system's point of view, the program
    we're running isn't ABQ Data Entry, but rather Python. For that reason, you may
    see the Python logo appearing instead of the ABQ logo on your platform. We'll
    address this further when we package our application in *Chapter 16*, *Packaging
    with setuptools and cxFreeze* .
  prefs: []
  type: TYPE_NORMAL
- en: Adding icons to buttons and menus
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While not required by the users or company, you feel your application would
    look a little more impressive with some simple icons accompanying the text on
    your buttons and menu items. Unfortunately, Tkinter does not ship with any icon
    themes, nor is it able to access the operating system's built-in icon themes.
    So, in order to use icons, we'll have to first acquire some PNG or GIF images
    to use. These can be acquired from a number of sources online or, of course, you
    can create your own.
  prefs: []
  type: TYPE_NORMAL
- en: The example code comes with some icons taken from the **Open-Iconic** project,
    which features a large selection of standard application icons released under
    an MIT license. You can find this project at [https://useiconic.com/open](https://useiconic.com/open).
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming you have obtained some icon files, let''s add them to the `images`
    folder and then update `images/__init__.py` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we''ve added images for the **Save** and **Reset** buttons, as well as
    images to represent the Record List and Data Entry Form portions of the GUI. We
    can now begin adding these to our application; for example, let''s add them to
    the buttons in the `DataRecordForm` frame. Start by importing `images` into `views.py`,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, in the initializer, let''s update the buttons in the `DataRecordForm`
    with image icons:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the form should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.4: The buttons in the Data Record Form, now with icons](img/B17578_09_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.4: The buttons in the Data Record Form, now with icons'
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember that we can also add images to the `Notebook` widget''s tabs. Back
    in `application.py`, locate the code in `__init__()` that creates the notebook
    tabs and let''s update it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s as simple as adding an `image` argument to the notebook''s `add()` and
    `insert()` method calls. As with buttons and labels, be sure to include the `compound`
    argument, or else only the icon will be displayed. Now, when we run the application,
    the tabs should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.5: The notebook tabs with icons](img/B17578_09_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.5: The notebook tabs with icons'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, the workflow for using the icons is fairly consistent:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `PhotoImage` object, making sure a reference to it will stay in scope.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pass the object to the `image` argument of the widget you want it to appear
    on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pass the widget's `compound` argument to specify the layout for widgets that
    will display both text and the image.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Rather than creating an individual class attribute for every icon, you may
    find it more efficient to store them in a dictionary object. For example, we should
    do this in the `MainMenu` class, where we''ll need a lot of icons. Import `images`
    into `mainmenu.py`, just as you did in the other two files, and let''s create
    a new `_create_icons()` instance method in `MainMenu`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Here, we're using an instance method to create a dictionary of `PhotoImage`
    objects and storing it as an instance attribute, `self.icons`. You might wonder
    why we don't create `MainMenu.icons` as a class attribute, similar to the `fields`
    dictionaries we created for our models.
  prefs: []
  type: TYPE_NORMAL
- en: The reason is that `PhotoImage` objects, like all Tkinter objects, cannot be
    created until an instance of `Tk` has been created (in our case, the `Application`
    object).
  prefs: []
  type: TYPE_NORMAL
- en: Class definitions, and therefore class attributes, are executed by Python before
    the main thread of execution begins, so there would be no `Application` object
    when this class is defined.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can call this method inside the initializer to make sure `self.icons` is
    populated before we define the menu; add that code like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, each menu item can access its `PhotoImage` object via the dictionary,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now our menu boasts some professional-looking icons, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.6: The "Go" menu, with some nice icons](img/B17578_09_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.6: The Go menu, with some nice icons'
  prefs: []
  type: TYPE_NORMAL
- en: Using BitmapImage
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Using `PhotoImage` with PNG files is more than sufficient for our application,
    but there is one other option for images in Tkinter that bears mentioning: `BitmapImage`.
    The `BitmapImage` object is similar to `PhotoImage`, but works exclusively with
    **XBM** (X11 Bitmap) files. This is a very old image format that only allows for
    monochromatic images. Despite being monochromatic, XBM images are not compressed,
    and therefore not smaller than PNG files of equivalent size. The only real advantage
    to a `BitmapImage` object is that we can tell Tkinter to render it with any colors
    we wish.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To see how this works, let''s add a few XBM files to our `images` module; copy
    in some XBM files and then add them to `__init__.py`, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Some XBM files are included in the sample code; alternatively, you can convert
    your own image files to XBM using image editing software like the GNU Image Manipulation
    Program from [https://www.gimp.org](https://www.gimp.org).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, back in `mainmenu.py`, let''s add them to our `icons` dictionary, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, creating a `BitmapImage` is identical to creating a `PhotoImage`
    object, but with the possibility of specifying `foreground` and `background` colors
    for the image. Once created, adding them to the menu item is identical to using
    `PhotoImage`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the **Help** menu should have a colorful icon, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.7: The now colorful About icon](img/B17578_09_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.7: The now colorful About icon'
  prefs: []
  type: TYPE_NORMAL
- en: You may find `BitmapImage` objects useful if you want to reuse a single file
    with different colors, or perhaps dynamically change the color scheme of your
    icons to fit with a theme or indicate some kind of state. Most of the time, though,
    using `PhotoImage` objects will be preferable.
  prefs: []
  type: TYPE_NORMAL
- en: These images have dramatically changed the look of our application, but the
    rest of it is still a rather drab gray. In the next sections, we'll work on updating
    its colors.
  prefs: []
  type: TYPE_NORMAL
- en: Styling Tkinter widgets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Tkinter has essentially two styling systems: the old Tkinter widgets system,
    and the newer Ttk system. Although we are using Ttk widgets wherever possible,
    there are still situations where regular Tkinter widgets are required, so it''s
    good to know both systems. Let''s take a look first at the older Tkinter system
    and apply some styling to the Tkinter widgets in our application.'
  prefs: []
  type: TYPE_NORMAL
- en: Widget color properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As you saw in *Chapter 1*, *Introduction to Tkinter*, basic Tkinter widgets
    allow you to change two color values: the foreground color, meaning mainly the
    color of text and borders, and the background color, meaning the rest of the widget.
    These can be set using the `foreground` and `background` arguments, or their aliases,
    `fg` and `bg`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can set the colors of a label like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The values for the colors can be color name strings or CSS-style RGB hex strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, this code produces the same effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: There are over 700 named colors recognized by Tkinter, roughly corresponding
    to those recognized by the X11 display server used on Linux and Unix, or the CSS
    named colors used by web designers. For a complete list, see [https://www.tcl.tk/man/tcl8.6/TkCmd/colors.htm](https://www.tcl.tk/man/tcl8.6/TkCmd/colors.htm).
  prefs: []
  type: TYPE_NORMAL
- en: Using widget properties on the MainMenu
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We aren't using many Tkinter widgets in our views, preferring Ttk as much as
    possible. One place where we *are* using a Tkinter widget is our application's
    main menu. We can use the main menu to demonstrate how Tkinter widget colors can
    be configured.
  prefs: []
  type: TYPE_NORMAL
- en: Note that setting colors and other appearance options on the menu system *only*
    works consistently on Linux or BSD. The effect on Windows or macOS is incomplete,
    so readers on those platforms may see incomplete results. In *Chapter 10*, *Maintaining
    Cross-Platform Compatibility*, we'll redesign our menu so that these differences
    in compatibility are accounted for.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `tk.Menu` widget accepts the following appearance-related arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Argument | Values | Description |'
  prefs: []
  type: TYPE_TB
- en: '| `background` | Color string | The color of the background under normal conditions
    |'
  prefs: []
  type: TYPE_TB
- en: '| `foreground` | Color string | The color of the foreground (text) under normal
    conditions |'
  prefs: []
  type: TYPE_TB
- en: '| `borderwidth` | Integer | The width of the widget border, in pixels, under
    normal conditions |'
  prefs: []
  type: TYPE_TB
- en: '| `activebackground` | Color string | The background color when the widget
    is active (being hovered over or selected via the keyboard) |'
  prefs: []
  type: TYPE_TB
- en: '| `activeforeground` | Color string | The foreground (text) color when the
    widget is active |'
  prefs: []
  type: TYPE_TB
- en: '| `activeborderwidth` | Integer | The border width, in pixels, of the widget
    when active |'
  prefs: []
  type: TYPE_TB
- en: '| `disabledforeground` | Color string | The foreground (text) color when the
    widget is disabled |'
  prefs: []
  type: TYPE_TB
- en: '| `relief` | One of the Tkinter constants `RAISED`, `SUNKEN`, `FLAT`, `RIDGE`,
    `SOLID`, or `GROOVE` | The style of the border drawn around the widget |'
  prefs: []
  type: TYPE_TB
- en: Note that there are versions of `background`, `foreground`, and `borderwidth`
    for both the normal and active states, and a version of `foreground` for the disabled
    state. Depending on what is applicable to the widget, many Tkinter widgets support
    additional arguments for certain states, conditions, or features; for example,
    widgets with selectable text like the `Entry` widget support `highlightbackground`
    and `highlightforeground` arguments to specify the colors used when text is selected.
  prefs: []
  type: TYPE_NORMAL
- en: The Tcl/Tk documentation at [https://www.tcl.tk/man/](https://www.tcl.tk/man/)
    provides the most complete reference for widget-specific options, including styling
    options.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open up the `mainmenu.py` file and let''s add some styles to our menu inside
    the initializer method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the application, and note the menu''s appearance. On Linux or BSD,
    it should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.8: A styled Tkinter menu on Ubuntu Linux](img/B17578_09_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.8: A styled Tkinter menu on Ubuntu Linux'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the styling does not go past the main menu; the sub-menus are still
    the default black-on-gray. To make the menu consistent, we''ll need to apply these
    styles to all the sub-menus as well. To avoid a lot of repetition, let''s change
    our code so that the styles are stored in a dictionary, which we can then unpack
    in each call to `tk.Menu`. Update the code like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, to add the styling to each sub-menu, we just need to add `**self.styles`
    to each sub-menu initialization, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Assuming your platform supports menu styling, you should now see the styles
    applied to the sub-menus as well.
  prefs: []
  type: TYPE_NORMAL
- en: Styling widget content with tags
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Foreground and background colors are sufficient for simple widgets such as buttons
    and labels, but more complex Tkinter widgets like the `Text` widget or the Ttk
    `Treeview` widget rely on a **tag**-based system for more detailed styling. A
    **tag** in Tkinter is a named region of a widget's content to which color and
    font settings can be applied. To see how this works, let's build a crude, but
    pretty, Python terminal emulator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a new file called `tags_demo.py`, and we''ll start by creating a `Text`
    widget to store the terminal input and output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Here, we've used the `fg` and `bg` arguments to set up a green-on-black terminal
    theme, a classic combination popular with programmers. Rather than having only
    green text, though, let's configure different colors for our prompt and our interpreter
    output.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we''ll define some tags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The `tag_configure()` method allows us to declare and configure tags on the
    `Text` widget. We've created one called `prompt` with magenta text for the shell
    prompt, and another called `output` with yellow text for the Python output. Note
    that we aren't restricted to a single configuration argument here; we could conceivably
    pass a `font` or `background` argument as well, if we wished.
  prefs: []
  type: TYPE_NORMAL
- en: 'To insert text with a given tag applied, we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'As you may remember, the `Text.insert()` method takes an index and string as
    its first two arguments. Notice the third argument: this is a tuple of the tags
    with which we want to mark the inserted text. This value must be a tuple, even
    if you''re only using one tag; naturally, you can include as many tags as you
    wish.'
  prefs: []
  type: TYPE_NORMAL
- en: If you add `text.mainloop()` to the end of the code and run it, you'll see that
    we have a black text entry window with a magenta prompt; however, if you type
    anything, your text will show up in green (the widget's default foreground color).
    So far so good; now, let's make it execute some Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a function just before the `mainloop()` call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Recall that, when retrieving text from a `Text` widget, we''re required to
    supply start and end indices for the text we want to retrieve. We can utilize
    tag names in our index values, as we''ve done here: `prompt.last` tells Tkinter
    to fetch the text starting *after* the end of the region tagged `prompt`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s execute the entered command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: If the `cmd` variable actually contains anything, we'll try to execute it with
    `eval()`, and then store a string of the response value as output. If it raises
    an exception, we'll cast our exception to a string and set that as the output.
  prefs: []
  type: TYPE_NORMAL
- en: Note that `eval()` only works on expressions, so our "shell" won't be able to
    handle loops, conditionals, or other statements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we''ll just show our output, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Here, we've inserted our `output` string, prefixed with a newline and tagged
    as `output`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll finish off the function by giving the user back a prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Note that we also return the string `break` here. This tells Tkinter to ignore
    the original event that triggered the callback. Since we're going to trigger this
    from a Return/Enter keystroke, we want to ignore that keystroke after we're finished.
    If we don't, the keystroke will be executed *after* our function returns, inserting
    the newline after the display of the prompt and leaving the user on the line under
    the prompt.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we need to bind our function to the Return key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Note that the event for the Enter/Return key is always `<Return>`, even on non-Apple
    hardware (where the key is more commonly labeled "Enter").
  prefs: []
  type: TYPE_NORMAL
- en: 'Make sure to add a call to `text.mainloop()` at the end of the script, and
    then launch the application. You should get something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.9: The colorful Python shell](img/B17578_09_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.9: The colorful Python shell'
  prefs: []
  type: TYPE_NORMAL
- en: While this shell won't be supplanting IDLE any time soon, it does look rather
    nice, don't you think?
  prefs: []
  type: TYPE_NORMAL
- en: Styling our record list with tags
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although `Treeview` is a Ttk widget, it uses tags to control the styling of
    individual rows. We can use this capability to address another of the requests
    you've gotten from the data entry staff â€“ specifically, that they'd like the record
    list to highlight the records updated and inserted during the current session.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we'll need to do is have our `RecordList` object keep track
    of which rows have been updated or inserted during the session.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start in `RecordList.__init__()` by creating a couple of instance variables
    to store the updated or inserted rows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'When a record is inserted or updated, we''ll need to append its row number
    to the appropriate list. Since `RecordList` doesn''t know when a record is updated
    or inserted, we''ll have to create some public methods that the `Application`
    object can call to append to the lists. Create these two methods in the `RecordList`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Each method takes a row number and appends it to the corresponding list. To
    avoid duplicates, we only do so if the row is not in the list. Now, to use these
    methods, we'll have to update the `Application._on_save()` method so that it calls
    the appropriate update method *after* the record is saved, but *before* we repopulate
    the record list.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `_on_save()`, right after calling `self.model.save_record()`, add these
    lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Updates have a `rownum` value that is not `None`, but could be `0`, so we explicitly
    test for `None` here rather than just using `if rownum:`. If `rownum` is not `None`,
    we'll append it to the updated list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to deal with inserts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Inserted records are a little more troublesome in that we don't have a row number
    readily available to record. We do know that an insert is always appended to the
    end of the file, though, so its row number should be one smaller than the number
    of rows in the file.
  prefs: []
  type: TYPE_NORMAL
- en: Our inserted and updated records will be kept until the end of the program session
    (when the user exits the program) or until the user selects a new file to work
    on. If the user selects a new file, we will need to clear out the lists since
    we're working with a completely new set of records.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once again, since `RecordList` doesn''t know when this happens, we''ll need
    to create a public method that clears the lists. Add the following `clear_tags()`
    method to the `RecordList` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need the `Application` class to call this whenever a new file is selected
    for saving, which happens in `Application._on_file_select()`. Add a call to the
    method just before repopulating the record list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have these lists updating correctly, we need to use them to color-code
    the list items.
  prefs: []
  type: TYPE_NORMAL
- en: To do this, we first need to configure tags with appropriate colors. Our data
    entry staff feel that light green would be a sensible color for inserted records,
    and light blue for updated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code at the end of `RecordList.__init__()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Just as we did with the `Text` widget earlier, we call the `TreeView` object's
    `tag_configure()` method to connect `background` color settings with our tag names.
    To add the tags to our `TreeView` rows, we'll need to update the `populate()`
    method so that as rows are inserted, the appropriate tag (if any) is added.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `populate()` method''s `for` loop, just before inserting the row,
    we''ll add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, our `treeview.insert()` call just needs to be amended with this tag value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Run the application and try to insert and update some records.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should get something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.10: The treeview with styled rows](img/B17578_09_10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.10: The treeview with styled rows. The light blue corresponds to updated
    rows (row 0) and the light green to inserted rows (row 1). Note that the dark
    blue row is just the selected row (row 2).'
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the `Text` and `Treeview` widgets, tags are also used with the
    Tkinter `Canvas` widget, which we'll learn more about in *Chapter 15*, *Visualizing
    Data Using the Canvas Widget*.
  prefs: []
  type: TYPE_NORMAL
- en: Working with fonts in Tkinter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some of our data entry users have complained that the font of the application
    is just a little too small to read easily, but others dislike the idea of you
    increasing it because it makes the application too big for the screen. To accommodate
    all the users, we can add a configuration option that allows them to set a preferred
    font size and family.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Tkinter fonts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Any widget in Tkinter that displays text allows us to specify a font, typically
    through its `font` configuration property. For widgets that support tags, we can
    also specify font settings for each tag. We've been using the `font` argument
    as far back as *Chapter 1*, *Introduction to Tkinter*, but now it's time to take
    a deeper look into what Tkinter allows us to do with fonts.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three ways of specifying a widget''s font in Tkinter: using a string,
    using a tuple, and using a `Font` object. Let''s take a look at each one.'
  prefs: []
  type: TYPE_NORMAL
- en: Configuring fonts with strings and tuples
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The simplest way to configure a font in Tkinter is to just use a font specification
    string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The string takes the format `font-family size styles`, where:'
  prefs: []
  type: TYPE_NORMAL
- en: '`font-family` is the name of the font family. It can only be a single word;
    no spaces are allowed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`size` is an integer describing the size. A positive integer indicates a size
    in *points*, a negative indicates a size in *pixels*. Float values are not supported.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`styles` can be any valid combination of text style keywords.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Everything but the font family is optional, though you need to specify a size
    if you want to specify any of the styling keywords. The keywords that can be used
    for styles include:'
  prefs: []
  type: TYPE_NORMAL
- en: '`bold` for boldface text, or `normal` for normal weight'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`italic` for italicized text, or `roman` for regular slant'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`underline` for underlined text'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`overstrike` for struck-out text'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ordering of style keywords doesn't matter, but the weight and slant keywords
    are mutually exclusive (that is, you can't have `bold normal` or `italic roman`).
  prefs: []
  type: TYPE_NORMAL
- en: While quick and simple, the string approach has its shortcomings; for one, it
    can't handle fonts with spaces in the name, something that is fairly common on
    modern systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'To handle fonts like that, you can use the tuple format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: This format is exactly like the string format, except that the different components
    are written as items in a tuple.
  prefs: []
  type: TYPE_NORMAL
- en: The size component can be an integer or a string containing digits, which provides
    some flexibility depending on where the value comes from.
  prefs: []
  type: TYPE_NORMAL
- en: The font module
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The string or tuple approach works fine for setting up a handful of font changes
    at launch time, but for situations where we need to dynamically manipulate font
    settings, Tkinter offers the `font` module. This module offers us a few font-related
    functions as well as a `Font` class, whose instances can be assigned to widgets
    and dynamically changed.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the `font` module, it must first be imported:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can create a custom `Font` object and assign it to some widgets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the values passed to the `Font` initializer arguments correlate
    with the weight and slant values used in string and tuple font specifications.
    The `weight` argument also supports the use of the constants `font.NORMAL` or
    `font.BOLD`, while `slant` supports the use of `font.ITALIC` or `font.ROMAN`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we''ve created a `Font` object and assigned it to one or more widgets,
    we can dynamically alter aspects of it at runtime. For example, we could create
    a button that will toggle the `overstrike` property of our font:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: The `Font` object is a Python interface to a Tcl/Tk feature called **named fonts**.
    In Tcl/Tk, a named font is just a collection of font properties associated with
    a name.
  prefs: []
  type: TYPE_NORMAL
- en: '`Tk` comes with several named fonts already configured, as shown in the following
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Font name | Defaults to | Used for |'
  prefs: []
  type: TYPE_TB
- en: '| `TkCaptionFont` | System title font | Window and dialog caption bars |'
  prefs: []
  type: TYPE_TB
- en: '| `TkDefaultFont` | System default font | Items not otherwise specified |'
  prefs: []
  type: TYPE_TB
- en: '| `TkFixedFont` | System fixed-width font | `Text` widget |'
  prefs: []
  type: TYPE_TB
- en: '| `TkHeadingFont` | System heading font | Column headings in lists and tables
    |'
  prefs: []
  type: TYPE_TB
- en: '| `TkIconFont` | System icon font | Icon captions |'
  prefs: []
  type: TYPE_TB
- en: '| `TkMenuFont` | System menu font | Menu labels |'
  prefs: []
  type: TYPE_TB
- en: '| `TkSmallCaptionFont` | System title | Subwindows, tool dialogs |'
  prefs: []
  type: TYPE_TB
- en: '| `TkTextFont` | System input font | Input widgets: `Entry`, `Spinbox`, and
    so on |'
  prefs: []
  type: TYPE_TB
- en: '| `TkTooltipFont` | System tooltip font | Tooltips |'
  prefs: []
  type: TYPE_TB
- en: The `font` module includes a function called `names()` that returns a list of
    the current named fonts on the system, including those that you create yourself
    (by creating `Font` objects). We can use the `font.nametofont()` function to generate
    a `Font` object from a given name.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can create a small program to demonstrate all the named fonts
    included with Tkinter, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: In this script, we retrieve a list of all the named fonts using `font.names()`
    and iterate through it. For each name, we create a `Font` object using `font.nametofont()`,
    and then create a label showing the named font name and using the `Font` object
    as its font.
  prefs: []
  type: TYPE_NORMAL
- en: This script will show what all the built-in named fonts look like on your system.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, on Ubuntu Linux, they look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.11: The Tkinter named fonts on Ubuntu Linux](img/B17578_09_11.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.11: The Tkinter named fonts on Ubuntu Linux'
  prefs: []
  type: TYPE_NORMAL
- en: Since Tkinter uses its built-in named fonts by default, we can change the overall
    look of the whole application by creating `Font` objects for these default named
    fonts and overriding their properties. The changes we make will get applied across
    all widgets that don't otherwise have an explicit font configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we could add some code to the preceding script, just before `root.mainloop()`,
    to allow us to customize the built-in fonts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: In this code, we set up three control variables to hold the named font name,
    family, and size values, and then set up three widgets to select them. The first
    `OptionMenu` widget uses `font.names()` to retrieve a list of all the named fonts,
    and the second uses the `font.families()` function to retrieve a list of the available
    font families on the operating system (this is likely to be a very long list on
    most modern systems). Then we have a `Spinbox` for selecting a font size.
  prefs: []
  type: TYPE_NORMAL
- en: The callback function, `setFont()`, creates a font object from the selected
    named font and then configures it with the selected family and size. This function
    is then bound to a button.
  prefs: []
  type: TYPE_NORMAL
- en: If you run the script now, you should be able to select any named font and edit
    its family and size. When you click **Change**, you should see the associated
    label change according to your selections. You may also note that changing certain
    named fonts affects your `OptionMenu`, `Spinbox`, and `Button` widgets as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, on Ubuntu Linux, it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.12: The named font editor on Ubuntu Linux](img/B17578_09_12.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.12: The named font editor on Ubuntu Linux'
  prefs: []
  type: TYPE_NORMAL
- en: Giving users font options in ABQ Data Entry
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we understand how to work with fonts in Tkinter, let's add the ability
    for our users to configure fonts in the application. We'll allow them to choose
    a size and a font family that will be used for all the widgets and data displayed
    in the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since users will want to persist this value between sessions, we should begin
    by adding keys for `font size` and `font family` to our settings model. Open `models.py`
    and append these to the `fields` dictionary, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: We have set the size default to 9 points, but the family default to a blank
    string. Configuring a font with a blank family value will cause Tkinter to use
    its own default font family.
  prefs: []
  type: TYPE_NORMAL
- en: Recall that the `Application` object will read the `fields` dictionary and set
    up a control variable for each setting, and that a dictionary of these control
    variables will be passed to our `MainMenu` object. So, our next task will be to
    create menu items for setting the size and family values of these variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `mainmenu.py` and let''s begin by importing the `font` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, inside the `MainMenu` initializer method, let''s create some sub-menus
    for the `options_menu` cascade:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: This should look familiar, since we created a nearly identical font size menu
    when learning about the Tkinter `Menu` widget in *Chapter 7*, *Creating Menus
    with Menu and Tkinter Dialogs*. We're allowing font sizes from 6 to 16, which
    should provide plenty of range for our users.
  prefs: []
  type: TYPE_NORMAL
- en: The font family menu is nearly identical, except we're pulling the list of possible
    values from `font.families()`, just as we did in our demonstration script earlier
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the user can select fonts and store their selection, let's actually
    make those settings change the fonts in the application. To do that, we'll first
    need to add a method to the `Application` class that will read the values and
    alter the appropriate named fonts accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `application.py`; add an import statement for `font` at the top, and then
    let''s add this new `_set_font()` method to the `Application` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: This method begins by retrieving the size and family settings from their respective
    control variables. Next, we're going to loop through a tuple of built-in named
    fonts that we want to change. `TkDefaultFont` will change most of the widgets,
    `TkMenuFont` will affect the main menu, `TkTextFont` will change the text-input
    widgets, and `TkFixedFont` will set the default for our `Text` widget.
  prefs: []
  type: TYPE_NORMAL
- en: For each one, we retrieve a `Font` object using `nametofont()` and reconfigure
    it with the values retrieved from `settings`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method needs to be called after the settings are initially loaded, and
    whenever the size or family values are changed. So, let''s add the following lines
    to the end of `Application._load_settings()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Now, whenever `Application()` creates new settings control variables, it will
    set up the font and add a trace to reconfigure the application fonts whenever
    these values are changed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the application and try out the font menu. It should look something like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.13: Switching our ABQ Data Entry to Comic Sans](img/B17578_09_13.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.13: Switching our ABQ Data Entry to Comic Sans'
  prefs: []
  type: TYPE_NORMAL
- en: Styling Ttk widgets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The final user requests we need to address involve the styles and colors of
    our `Ttk` widgets; users have asked for more visual distinction between the form
    sections, and more visibility for error messages.
  prefs: []
  type: TYPE_NORMAL
- en: 'After some thought and discussion, you decide to color-code the sections of
    the form as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The Record Information section will use khaki, suggesting the classic manila
    folders used for paper records
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Environment Data section will use light blue, symbolic of water and air
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Plant Data will have a light green background, symbolic of plants
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Notes input is distinctive enough, so it will remain the same default gray
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To improve the visibility of error messages, we'd like to make the background
    of the fields turn red when they have errors, and the error text itself display
    in a dark red color. To accomplish this, we're going to need to understand how
    to style `Ttk` widgets.
  prefs: []
  type: TYPE_NORMAL
- en: TTk styling breakdown
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Ttk widgets represent a major improvement over standard Tkinter widgets in
    terms of the power and flexibility with which they can be styled. This flexibility
    is what gives Ttk widgets the ability to mimic native UI controls across platforms,
    but it comes at a cost: Ttk styling is confusing, complicated, poorly documented,
    and occasionally inconsistent.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand Ttk styling, let''s start with some vocabulary, from the most
    basic parts to the most complex:'
  prefs: []
  type: TYPE_NORMAL
- en: Ttk starts with **elements**. An element is one piece of a widget, such as a
    border, an arrow, or a field where text can be typed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each element has a set of **options** that define properties such as color,
    size, and font.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Elements are composed using **layouts** into a complete widget (a `Combobox`
    or `Treeview`, for example).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Styles** are collections of element option settings that are applied to widgets.
    A style is identified by its name. Usually, the name is "T" plus the name of the
    widget, such as `TButton` or `TEntry`, although there are some exceptions to this.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Widgets also have a number of **states**, which are flags that can be turned
    on or off:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Styles can be configured with a **map** that associates element option values
    with states or combinations of states.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A collection of layouts and their associated styles is called a **theme**. Ttk
    comes with a different set of themes on different platforms, and each platform
    has a default that aims to match the look of its native widget set. Because each
    theme may contain elements with different style options, not every option is available,
    nor has the same effect, in every theme. For example, a `ttk.Button` on the default
    macOS theme may contain a different set of elements, applying style settings differently
    compared to a `ttk.Button` using the default theme in Windows.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you're confused at this point, that's understandable. To make things clearer,
    let's take a deep dive into the anatomy of a `ttk.Combobox`.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring a Ttk widget
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To get a better picture of how a Ttk widget is built, open a shell in IDLE
    and import `tkinter`, `ttk`, and `pprint`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, create a `root` window, `Combobox`, and `Style` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: The `Style` object is, perhaps, slightly misnamed; it doesn't point to a single
    *style*, but rather gives us a point of access to examine and alter the styles,
    layouts, and maps for the current *theme*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to examine our `Combobox`, we''ll first get its style name using the
    `winfo_class()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: As expected, the name is `TCombobox`, which is just `T` plus the widget name.
    We can use this name to find out more about this `Combobox` widget.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can examine its layout by passing the name to the `Style.layout()`
    method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Note that the output of `layout()` may be different on your system, as the layout
    contents depend on the theme. Different operating systems use a different default
    theme.
  prefs: []
  type: TYPE_NORMAL
- en: The returned layout specification shows the hierarchy of elements used to construct
    this widget. The elements, in this case, are `"Combobox.field"`, `"Combobox.downarrow"`,
    `"Combobox.padding"`, and `"Combobox.textarea"`. As you can see, each element
    has associated positioning properties similar to what you'd pass into a geometry
    manager method.
  prefs: []
  type: TYPE_NORMAL
- en: The `layout()` method can also be used to replace a style's layout by passing
    in a new specification as a second argument. Unfortunately, since styles are built
    using immutable tuples, this requires replacing the *entire* layout specification
    â€“ you can't just adjust or replace a single element in place.
  prefs: []
  type: TYPE_NORMAL
- en: To see what options are available for the elements in this layout, we can use
    the `style.element_options()` method. This method takes an element name and returns
    a list of options that can be used to alter it.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Once again, this list may be different (or even empty) depending on your operating
    system and theme settings.
  prefs: []
  type: TYPE_NORMAL
- en: This tells us that the `downarrow` element of the `Combobox` widget offers the
    `background`, `relief`, `borderwidth`, `arrowcolor`, and `arrowsize` style properties
    to adjust its appearance. To change these properties, we can use the `style.configure()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, let''s change the color of the arrow to red:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: If your operating system doesn't support the `arrowcolor` option, feel free
    to try a different option or switch to the alt theme. See the next section on
    how to switch themes.
  prefs: []
  type: TYPE_NORMAL
- en: You should see that the arrow's color has changed to red. This is all we need
    to know to configure widgets for static changes, but what about dynamic changes,
    such as when an input is disabled or invalid?
  prefs: []
  type: TYPE_NORMAL
- en: 'To make dynamic changes, we''ll need to work with our widget''s state and map.
    We can inspect or alter the state of our `Combobox` using the `state()` method,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '`state()` with no arguments will return a tuple with the currently set state
    flags; as you can see, the `Combobox` widget had no state flags by default. We
    can also set the state by passing in a sequence of strings, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Notice that in order to turn off a state flag, we prefix the flag name with
    a `!`. When you call `state()` with an argument to change the value, the return
    value is a tuple containing a set of states (or negated states) that would, if
    applied, *undo the state change you just set*. So, in this case, when we passed
    in the list that turned on `active` and `invalid`, the method returned a tuple
    that would turn these states off again. Likewise, when we passed in the negated
    `invalid` state, we got back a tuple containing `invalid`. This might be useful
    in a situation where you want to temporarily set a widget's state and then return
    it to its previous (possibly unknown) state.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can''t just use any arbitrary strings for `state()`; they must be one of
    the supported values, listed here in this table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| State | Indicates |'
  prefs: []
  type: TYPE_TB
- en: '| `active` | Widget element is being hovered on by the mouse |'
  prefs: []
  type: TYPE_TB
- en: '| `disabled` | Interaction with the widget is turned off |'
  prefs: []
  type: TYPE_TB
- en: '| `focus` | Widget will receive keyboard events |'
  prefs: []
  type: TYPE_TB
- en: '| `pressed` | Widget is currently being clicked on |'
  prefs: []
  type: TYPE_TB
- en: '| `selected` | Widget has been selected by the user (for example, a radio button)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `background` | Widget is on a window that is not the foreground window |'
  prefs: []
  type: TYPE_TB
- en: '| `readonly` | Widget will not allow modification |'
  prefs: []
  type: TYPE_TB
- en: '| `alternate` | Different things, depending on the widget |'
  prefs: []
  type: TYPE_TB
- en: '| `invalid` | Widget contains invalid data (that is, the validate command has
    returned `False`) |'
  prefs: []
  type: TYPE_TB
- en: '| `hover` | Like `active`, but referring to the whole widget rather than an
    element |'
  prefs: []
  type: TYPE_TB
- en: Exactly how different widgets use each of these states depends on the widget
    and the theme; not every state is configured by default to have an effect on every
    widget. For example, `readonly` has no effect on a `Label` widget, since it is
    not editable to begin with.
  prefs: []
  type: TYPE_NORMAL
- en: Widget states interact with the theme's widget style through the use of a **style
    map**. We can use the `style.map()` method to inspect or set the map for each
    style.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the default map for `TCombobox`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, `TCombobox` has style maps for the `arrowcolor` and `fieldbackground`
    options by default. Each style map is a list of tuples, and each tuple is one
    or more state flags followed by a value for the element option. When all of the
    state flags match the current state of the widget, the value (that is, the last
    string in the tuple) takes effect.
  prefs: []
  type: TYPE_NORMAL
- en: The default map turns the arrow color to a light gray color when the `disabled`
    flag is set, and turns the field background to a different light gray color when
    either the `disabled` or `readonly` flags are set.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can set our own style mapping using the same method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Here, we've configured the `arrowcolor` property to be `blue` when the invalid
    flag is not set, and `red` when both the `invalid` and `focus` flags are set.
    Notice that while our call to `map()` completely overwrote the `arrowcolor` style
    map, the `fieldbackground` map was unaffected. You can replace style mappings
    individually for each option without affecting other options, though whatever
    mapping you do specify for the option overwrites the whole mapping for that option.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we've been operating on the `TCombobox` style, which is the default
    style for all `Combobox` widgets. Any changes we made would impact every `Combobox`
    widget in the application. What if we only want to change a particular widget,
    or a particular set of widgets? We can do this by creating **custom styles**.
    Custom styles must be derived from the existing style by prefixing a name and
    a dot to an existing style name.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '`Blue.TCombobox` inherits all of the properties of `TCombobox` (including the
    dynamically colored down arrow we previously configured), but can add or override
    them with settings of its own that won''t affect `TCombobox`. This allows you
    to create custom styles for some widgets without affecting other widgets of the
    same type.'
  prefs: []
  type: TYPE_NORMAL
- en: We can even customize our custom styles by adding more prefixes; for example,
    the style `MyCB.Blue.TCombobox` would inherit all the styles of `TCombobox` and
    `Blue.TCombobox`, along with whatever additional settings we wanted to add or
    override in it.
  prefs: []
  type: TYPE_NORMAL
- en: Using themes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can alter the look of all the Ttk widgets in our application at once by changing
    the theme. Remember that a theme is a collection of styles *and layouts*; so changing
    a theme doesn't just change the appearance, it may also change the available styling
    options as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ttk comes with a different set of themes on each OS platform; to see the themes
    available on your platform, use the `Style.theme_names()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: (These are the themes available on Debian Linux; yours may differ.)
  prefs: []
  type: TYPE_NORMAL
- en: 'To query the current theme, or to set a new theme, use the `Style.theme_use()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: With no arguments, the method returns the name of the current theme. With an
    argument, it sets the theme to the given theme name. Notice how the previous styling
    is gone when you change the theme. If you switch back to the default, however,
    you'll see that your changes were retained. That's because any changes we make
    using `Style.configure()` *only affect the currently running theme*.
  prefs: []
  type: TYPE_NORMAL
- en: Adding some color to ABQ Data Entry
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that you have a firmer grasp of Ttk themes and styling, let's add some color
    to our data entry form. To begin, we will set a different background color for
    each `LabelFrame` widget in the data record form. Since we want to configure three
    widgets of the same type differently, we'll need to use custom styles. For each
    frame, we will create a custom style, configure it with the proper color, and
    then assign it to the frame.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by opening `views.py` and let''s add the following code to the `DataRecordForm`
    initializer method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: We begin by creating a `Style` object, which we can use to access and modify
    the widget styles. We then use the `style.configure()` method to set up three
    custom styles based on `TLabelframe`, the default style for Ttk `Labelframe` widgets.
    We've set the colors according to our plan, and also added some padding to the
    style.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to assign these styles to each frame. Remember that our `LabelFrame`
    widgets are being created in an instance method called `_add_frame()`. We''ll
    need to update this method to take a `style` argument that we can pass to the
    widget. Update the method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'In this version, we take a string for the style, and if one is passed, we''ll
    configure our `LabelFrame` widget to use it. Now, let''s update our calls to `_add_frame()`
    in the initializer to pass in the custom styles we''ve created, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, execute the application and let''s take a look at the form. It should
    look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.14: Our first attempt at coloring our record form frames](img/B17578_09_14.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.14: Our first attempt at coloring our record form frames'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, that's far from ideal. While there is a small amount of color
    peeking out from behind the widgets, the widgets in each section are still the
    default drab color, and even the label portion of the `LabelFrame` widgets is
    still gray. Styles do *not* propagate to child widgets, so we're going to have
    to set each widget individually to get the full effect.
  prefs: []
  type: TYPE_NORMAL
- en: Adding styles to individual form widgets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first thing we can quickly fix is the label portion of each `LabelFrame`
    widget. Although each widget has been assigned to the custom style, the label
    element of the widget needs to be explicitly styled. We can do that merely by
    adding the following code to the `DataRecordForm` initializer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: This is exactly the same thing we did to create the custom `TLabelframe` styles,
    except that we have added the name of the individual element we want to style
    (in this case, `Label`). If you run the program again, you'll see now that each
    frame's label also shares the background color of the frame. We're still not finished
    though, because we need all our widget labels to show the background color of
    the frame.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider which widgets we need to create a custom style for:'
  prefs: []
  type: TYPE_NORMAL
- en: We need a style for the `Label` widgets for each section, since we'll need different
    colors for these widgets in Record Information, Environment Data, and Plant Data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll need to style our `Checkbutton`, since it uses its own built-in label
    rather than a separate label widget. Since there's only one right now, we only
    need one style for it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll need to style the `Radiobutton` widgets, since they also use a built-in
    label. We only need one style, though, since they also appear in only one form
    section.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s create those styles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: Now that we've created the styles, we need to add them to each widget in the
    form. Remember that the `LabelInput` initializer takes a `label_args` dictionary
    for keywords that need to be passed to its `Label` widget, so we'll need to add
    the label styles there.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, here''s what the first line should look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'For the `Lab` input, remember that we''re using our `ValidatedRadioGroup` widget,
    which takes a `button_args` dictionary for arguments that need to be passed to
    the radio buttons. We will have to specify both a `label_args` argument and an
    `input_args` argument to get our styles set on these widgets, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Continue adding these styles to the rest of the `LabelInput` widgets; if you
    get stuck, refer to the code example included with the book. When you''re finished,
    the application should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.15: The application with colored labels](img/B17578_09_15.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.15: The application with colored labels'
  prefs: []
  type: TYPE_NORMAL
- en: This is a marked improvement, but it's not quite there yet; the error labels
    are still the old, default color. Let's address that next.
  prefs: []
  type: TYPE_NORMAL
- en: Fixing the error colors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To fix the error labels, we need to edit our `LabelInput` widget so that, when
    it creates the `Label` widget for the error, it uses the style value passed in
    with the `label_args` dictionary. However, we have a complication: we want to
    make our error text dark red. How can we honor the background color of the style
    passed in, but also customize the foreground just for this widget?'
  prefs: []
  type: TYPE_NORMAL
- en: The answer is that we can further prefix our custom style to create a new style
    that inherits all the traits of the custom, while adding or overriding its own.
    In other words, if we were to create a style called `Error.RecordInfo.TLabel`,
    it would inherit all the properties of `RecordInfo.TLabel` but allow us to make
    additional changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `widgets.py` file, and let''s see if we can implement this in the
    `LabelInput` initializer method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: In this code, we've extracted the `style` value from the `label_args` dictionary,
    defaulting to `TLabel` if no style was passed. Then, we create a new style name
    by prefixing the given style with `Error.` (note the dot, that's important!).
    Then, we call `Style.configure()` to set the text color of our new style to a
    dark red. Note that we don't give the `Style` object a name here; since we're
    only making one change, it's OK to just call `configure()` directly on the created
    object and then let the object get thrown away.
  prefs: []
  type: TYPE_NORMAL
- en: Now, you should see that the error display widgets match the color of your background,
    but also display in dark red.
  prefs: []
  type: TYPE_NORMAL
- en: Styling input widgets on error
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Setting the error text to dark red is a minor improvement on the error visibility
    issue, but for our color-blind users in particular, the improvement is subtle
    at best, if it's even noticeable. We can use our knowledge of styling to take
    things a bit farther, though. Rather than just changing the color of the text,
    let's invert the colors of the input so that we have light text on a dark background.
  prefs: []
  type: TYPE_NORMAL
- en: To do this, we will want to update the `ValidatedMixin` class. Recall that we
    previously implemented a `_toggle_error()` method that sets the foreground color
    to red when the widget is invalid on focus-out. We could update that command to
    apply a different style to the widget instead, so that the background color would
    change as well. However, there's a better way.
  prefs: []
  type: TYPE_NORMAL
- en: Earlier in this chapter, we learned that widgets get flagged with an `invalid`
    state when validation fails, and that Ttk styles can have colors and other properties
    tied to different widget states by means of a style map. Rather than explicitly
    changing styles or colors when validation fails, we can create a style map that
    changes colors automatically in response to a failed validation.
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin, go ahead and remove any calls to `self._toggle_error()` in the `ValidatedMixin`
    class, which can be found in the `_validate()` method and the `_focusout_invalid()`
    method. That will leave the `_focusout_invalid()` method empty, so replace it
    with `pass`, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Although the method now does nothing, we're leaving it in place because it's
    part of the mixin class's API that child classes can override. You can actually
    delete the `_toggle_error()` method, however, since its functionality will be
    handled by a style map.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, in the initializer, let''s configure a style and style map for our widget:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Since this is a mixin class, we don''t know the original style name of the
    widget we''re mixing with, so we''ve fetched that using the `winfo_class()` method.
    After getting the widget class, we''re creating a custom style by prefixing the
    class with `ValidatedInput`. Then, we call `style.map()` to configure the foreground
    and background colors of this style in both invalid and not-invalid states: an
    `invalid` state will cause the widget to have white text on dark red background,
    and a `!invalid` state (that is, if the widget doesn''t have an invalid flag)
    black on white. Finally, we apply the style to the widget using `self.configure()`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you try the application now, you might see that fields with errors now turn
    a dark red color with white text:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.16: Our new validation styles at work](img/B17578_09_16.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.16: Our new validation styles at work'
  prefs: []
  type: TYPE_NORMAL
- en: That is to say, you will see this on Linux or macOS; on Microsoft Windows, the
    field background will remain unchanged. What's going on here?
  prefs: []
  type: TYPE_NORMAL
- en: Remember that from our earlier discussion in *Exploring a Ttk widget*, each
    platform comes with its own set of distinct themes, and each theme defines a unique
    layout for its widgets. These layouts define the individual elements of each widget
    and what properties can be defined for them. That means that some style properties
    might work on one theme, but not on another.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the default Ttk theme for Windows (the `vista` theme) does not
    allow the background color of our input widgets to be altered. Our target users
    for ABQ Data Entry are on Debian Linux, so this won't impact them. But it would
    be nice if we could see this feature working on other platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Setting themes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Generally speaking, the default Ttk theme on any given platform is probably
    the best one to use on that platform, but looks are subjective and sometimes we
    might feel that Tkinter gets it wrong. And sometimes, as we saw in the previous
    section, features we require for an application may not work in the default theme.
    Having a way to switch the theme might help to smooth out some rough edges and
    make some users feel more comfortable with the look of the application.
  prefs: []
  type: TYPE_NORMAL
- en: As we've already seen, querying available themes and setting a new theme is
    fairly simple. Let's create a configuration option to change the theme of our
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Building a theme selector
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Themes aren't something users are going to need to change often, and as we've
    seen, changing the theme can undo style changes we've made to our widgets. In
    light of this, we'll play it safe by designing our theme changer in such a way
    that it requires a restart of the program to make the actual change.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start by adding a `theme` option to our `SettingsModel` class''s `fields`
    dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: Every platform has a theme aliased to `default`, so this is a safe and sensible
    default value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, our `Application` object will need to check this value when the settings
    are loaded and apply it. Add this code to the end of the `Application._load_settings()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: This code will create a `Style` object, retrieve the theme, and then set the
    theme using the `theme_use()` method. If we should happen to give Tkinter a theme
    that doesn't exist, it will raise a `TCLError` exception; to avoid this, we have
    added an `if` statement to make sure the given theme is in the list returned by
    `theme_names()`.
  prefs: []
  type: TYPE_NORMAL
- en: What remains now is to create the UI elements required. As we did with our font
    options, we will add a sub-menu to our `Options` menu for selecting a theme.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, open `mainmenu.py` and add an import statement for `ttk` at the
    top. Then, add the following code to the initializer method just after the font
    menus:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: Here, as we did with our font settings, we simply loop through the available
    themes retrieved from `theme_names()` and add a `Radiobutton` item for each theme,
    tying it to our `settings['theme']` variable.
  prefs: []
  type: TYPE_NORMAL
- en: It may not be obvious to users that changing the theme requires a restart, so
    let's make sure to let them know.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can do that using a variable trace, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Whenever the theme is changed, this trace will call the `self._on_theme_change()`
    method; let''s add this method to the end of the `MainMenu` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: Note that we don't actually take any action here to change the theme; this method
    simply displays the warning message box and nothing else. The actual change to
    the setting is handled by the control variable bound to the menu checkboxes, so
    we don't really need to explicitly do anything. Also, because this method doesn't
    require access to the instance or class, we've made it a static method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you can run the application and try changing the theme, and then restart
    the application. You should notice a change in the application''s appearance.
    For example, here''s the application using the "clam" theme:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.17: ABQ Data Entry using the "clam" theme on Windows](img/B17578_09_17.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.17: ABQ Data Entry using the "clam" theme on Windows'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, not every theme looks so good with our changes. Try the different
    themes available on your platform. Which theme looks best on your platform? Which
    ones work best with our style changes? Try them all out and see.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we overhauled the look and feel of our application for both
    aesthetic and usability improvements. You learned how to use images and icons
    in your application using PhotoImage and BitmapImage, and how to extend image
    format support using Pillow. You learned to assign fonts to widgets, and to change
    the settings for built-in fonts. You learned how to work with color and font settings
    for default Tkinter widgets and how to use tags to style individual `Treeview`
    items and `Text` widget contents. We explored the intricate world of Ttk styles
    and learned to create custom styles based on the built-in defaults. Finally, we
    applied our knowledge of styling to the ABQ Data Entry application to make it
    more aesthetically pleasing and user-friendly.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll take steps to make sure our program runs effectively
    across major desktop platforms. You'll learn strategies to avoid cross-platform
    pitfalls in both general Python programming and Tkinter programming in particular.
    We'll also explore the various guidelines platform vendors offer to developers
    targeting their platforms.
  prefs: []
  type: TYPE_NORMAL
