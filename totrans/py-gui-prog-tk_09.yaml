- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Improving the Look with Styles and Themes
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过样式和主题改进外观
- en: While programs can be perfectly functional with plain text in shades of black,
    white, and gray, the subtle use of colors, fonts, and images can enhance the visual
    appeal and usability of even the most utilitarian applications. Your data entry
    application is no exception, and the current round of requests brought to you
    by your coworkers seems to require some retooling of the application's look and
    feel.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然程序可以用黑色、白色和灰度的纯文本完美运行，但微妙地使用颜色、字体和图像可以增强甚至最实用应用程序的视觉吸引力和可用性。你的数据录入应用程序也不例外，你同事带来的这一轮请求似乎需要重新调整应用程序的外观和感觉。
- en: 'Specifically, you''ve been asked to address these points:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，你被要求解决以下这些点：
- en: Your manager has informed you that ABQ's corporate policy requires the company
    logo to be displayed on all in-house software. You've been provided with a corporate
    logo image to include in the application.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的经理已经通知你，ABQ的公司政策要求在公司内部的所有软件上显示公司标志。你已经提供了一个公司标志图像以包含在应用程序中。
- en: The data entry staff have some readability issues with the form. They want more
    visual distinction between the sections of the form and more visibility for error
    messages.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据录入人员在与表单的可读性方面存在一些问题。他们希望表单各部分之间有更多的视觉区分，以及错误消息有更高的可见性。
- en: The data entry staff have also requested that you highlight records they've
    added or updated during a session to help them keep track of their work.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据录入人员还要求你在会话期间突出显示他们添加或更新的记录，以帮助他们跟踪他们的工作。
- en: In addition to the user's requests, you'd like to make your application look
    more professional by adding some icons to your buttons and menu.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 除了用户的要求外，你还想通过在按钮和菜单中添加一些图标来使你的应用程序看起来更加专业。
- en: 'In this chapter, we''re going to learn about some features of Tkinter that
    will help us to solve these issues:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习Tkinter的一些功能，这些功能将帮助我们解决这些问题：
- en: In *Working with images in Tkinter*, we'll learn how to add pictures and icons
    to our Tkinter GUI.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 *在Tkinter中处理图像* 中，我们将学习如何将图片和图标添加到我们的Tkinter GUI中。
- en: In *Styling Tkinter widgets*, we'll learn how to adjust the colors and visual
    style of Tkinter widgets, both directly and using tags.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 *Tkinter小部件样式化* 中，我们将学习如何调整Tkinter小部件的颜色和视觉样式，无论是直接调整还是使用标签。
- en: In *Working with fonts in Tkinter*, we'll learn the ins and outs of using fonts
    in Tkinter.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 *在Tkinter中处理字体* 中，我们将学习Tkinter中字体使用的细节。
- en: In *Styling Ttk widgets*, we'll learn how to adjust the look of Ttk widgets
    using styles and themes.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 *样式化Ttk小部件* 中，我们将学习如何使用样式和主题调整Ttk小部件的外观。
- en: Working with images in Tkinter
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Tkinter中处理图像
- en: 'To solve the corporate logo issue and spruce up our application with some icons,
    we''re going to need to understand how to work with images in Tkinter. Tkinter
    provides access to image files through two classes: the `PhotoImage` class and
    the `BitmapImage` class. Let''s see how these classes can help us add graphics
    to our application.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决公司标志问题并使我们的应用程序看起来更加美观，我们需要了解如何在Tkinter中处理图像。Tkinter通过两个类提供对图像文件的访问：`PhotoImage`
    类和 `BitmapImage` 类。让我们看看这些类如何帮助我们向应用程序添加图形。
- en: Tkinter PhotoImage
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Tkinter PhotoImage
- en: Many Tkinter widgets, including `Label` and `Button`, accept an `image` argument
    that allows us to display an image on the widget. This argument requires that
    we create and pass in a `PhotoImage` (or `BitmapImage`) object.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 许多Tkinter小部件，包括 `Label` 和 `Button`，都接受一个 `image` 参数，允许我们在小部件上显示图像。这个参数要求我们创建并传递一个
    `PhotoImage`（或 `BitmapImage`）对象。
- en: 'Making a `PhotoImage` object is fairly simple:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 `PhotoImage` 对象相对简单：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`PhotoImage` is typically called with the keyword argument `file`, which is
    pointed to a file path. Alternatively, you can use the `data` argument to point
    to a `bytes` object containing image data. In either case, the resulting object
    can now be used wherever an `image` argument is accepted, such as in a `Label`
    widget:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`PhotoImage` 通常使用关键字参数 `file` 调用，该参数指向一个文件路径。或者，你可以使用 `data` 参数指向一个包含图像数据的
    `bytes` 对象。在两种情况下，生成的对象现在都可以在任何接受 `image` 参数的地方使用，例如在 `Label` 小部件中：'
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Note that if we pass both an `image` and `text` argument to the `Label` initializer,
    only the image will be displayed by default. To display both, we need to also
    provide a value for the `compound` argument, which determines how the image and
    text will be arranged with respect to one another. For example:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果我们向 `Label` 初始化器传递了 `image` 和 `text` 参数，默认情况下只会显示图像。要显示两者，我们还需要为 `compound`
    参数提供一个值，该参数决定了图像和文本相对于彼此的排列方式。例如：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this situation, the first label would only show the `image`; the `text` will
    not be displayed. In the second, since we have specified a `compound` value of
    `tk.LEFT`, the `image` will be displayed to the left of the `text`. `compound`
    can be any of `LEFT`, `RIGHT`, `BOTTOM`, or `TOP` (either lowercase strings or
    the Tkinter constants), and indicates where the image will be placed in relation
    to the text.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，第一个标签只会显示 `image`；`text` 不会显示。在第二个中，由于我们指定了 `compound` 值为 `tk.LEFT`，`image`
    将显示在 `text` 的左侧。`compound` 可以是 `LEFT`、`RIGHT`、`BOTTOM` 或 `TOP`（小写字符串或 Tkinter
    常量），它表示图像相对于文本的位置。
- en: PhotoImage and variable scope
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PhotoImage 和变量作用域
- en: 'When using a `PhotoImage` object, it is critical to remember that your application
    must retain a reference to the object that will stay in scope for as long as the
    image is shown; otherwise, the image will not appear. To understand what this
    means, consider the following example:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 `PhotoImage` 对象时，必须记住你的应用程序必须保留对将保持作用域的对象的引用，直到图像显示完毕；否则，图像将不会显示。为了理解这意味着什么，请考虑以下示例：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If you run this example, you'll notice that no image gets displayed. That's
    because the variable holding the `PhotoImage` object, `smile`, is a local variable,
    and therefore destroyed as soon as the initializer returns. With no reference
    remaining to the `PhotoImage` object, it is discarded and the image vanishes,
    even though we've packed it into the layout.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行这个示例，你会注意到没有图像被显示。这是因为持有 `PhotoImage` 对象的变量 `smile` 是一个局部变量，因此一旦初始化器返回，它就会被销毁。由于没有对
    `PhotoImage` 对象的引用，它被丢弃，图像消失，即使我们已经将它打包到布局中。
- en: 'Let''s fix our script by making a simple change:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过进行简单的更改来修复我们的脚本：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this case, we've stored the `PhotoImage` object in an instance variable,
    `self.smile`. Instance variables continue to exist until the object itself is
    destroyed, so the picture remains on the screen.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将 `PhotoImage` 对象存储在一个实例变量 `self.smile` 中。实例变量会持续存在，直到对象本身被销毁，因此图片会留在屏幕上。
- en: Using Pillow for extended image support
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Pillow 扩展图像支持
- en: Image support in Tkinter is limited to GIF, PGM, PPM, and PNG files. If you're
    merely adding logos and icons to a GUI, these formats are probably sufficient,
    but for more graphics-heavy scenarios, the absence of such common formats as JPEG,
    SVG, and WebP becomes quite limiting. If you need support for any of these formats,
    you can use the `Pillow` library.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Tkinter 的图像支持仅限于 GIF、PGM、PPM 和 PNG 文件。如果你只是将标志和图标添加到 GUI 中，这些格式可能足够了，但对于需要更多图形的场景，缺少像
    JPEG、SVG 和 WebP 这样的常见格式变得相当受限。如果你需要支持这些格式中的任何一种，你可以使用 `Pillow` 库。
- en: '`Pillow` is not part of the standard library, nor shipped with most Python
    distributions. To install it, follow the instructions at [https://python-pillow.org](https://python-pillow.org/);
    though in most cases, you can simply enter the following at a terminal:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`Pillow` 不是标准库的一部分，也不是大多数 Python 发行版的一部分。要安装它，请遵循 [https://python-pillow.org](https://python-pillow.org/)
    上的说明；尽管在大多数情况下，你只需在终端中输入以下内容即可：'
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This will install `Pillow` from the **Python Package Index** (**PyPI**). Pillow
    provides us with a class called `ImageTk`, which we can use to create `PhotoImage`
    objects from a wide range of image file formats. To see how it works, let's build
    a small Tkinter-based image viewer with filters.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使用 **Python 包索引**（**PyPI**）安装 `Pillow`。Pillow 为我们提供了一个名为 `ImageTk` 的类，我们可以使用它从广泛的各种图像文件格式创建
    `PhotoImage` 对象。为了了解它是如何工作的，让我们构建一个带有过滤器的基于 Tkinter 的小型图像查看器。
- en: 'Open a new file called `image_viewer_demo.py` and start with the following
    code:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 打开一个名为 `image_viewer_demo.py` 的新文件，并从以下代码开始：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note that `Pillow` is imported as `PIL`. Pillow is actually a fork of a discontinued
    project called `PIL` (Python Imaging Library). For backward compatibility, it
    continues to use the `PIL` module name. From `PIL` we're importing the `Image`
    class, which is used to load images; the `ImageTk` class, which is used to convert
    Pillow `Image` objects for use in Tkinter; and `ImageFilter`, which will provide
    some filters for transforming our images.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`Pillow` 被导入为 `PIL`。实际上，Pillow 是一个已停止的项目 `PIL`（Python Imaging Library）的分支。为了向后兼容，它继续使用
    `PIL` 模块名称。我们从 `PIL` 导入 `Image` 类，用于加载图像；`ImageTk` 类，用于将 Pillow `Image` 对象转换为
    Tkinter 可用；以及 `ImageFilter`，它将为我们提供一些用于转换图像的过滤器。
- en: 'Next, let''s create our main application class for this app, `PictureViewer`:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们为这个应用程序创建主应用程序类 `PictureViewer`：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This class begins by subclassing `Tk`, just as we did in our ABQ application,
    and the initializer starts with some basic window and grid layout configuration.
    Next, we''ll create the GUI elements, like so:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 此类首先继承自`Tk`，就像我们在ABQ应用程序中所做的那样，初始化器从一些基本的窗口和网格布局配置开始。接下来，我们将创建GUI元素，如下所示：
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'So far, we just have a `Label` widget for displaying the image and a `Button`
    widget bound to an instance method, `self._choose_file()`. Let''s create that
    method, like so:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只有一个用于显示图像的`Label`小部件和一个绑定到实例方法`self._choose_file()`的`Button`小部件。让我们创建这个方法，如下所示：
- en: '[PRE9]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This method starts by asking the user for the filename with the `filedialog.askopenfilename()`
    method we learned about in *Chapter 7*, *Creating Menus with Menu and Tkinter
    Dialogs*. If the user selects a file, we call the `Image.open()` method to create
    a Pillow `Image` object from the file. `Image.open()` is a convenience method
    that simply takes a filename or path and returns an `Image` object containing
    that file's image data. Next, we create a Tkinter `PhotoImage` object by passing
    the `Image` object to `ImageTk.PhotoImage()`. Finally, we update our `image_display`
    widget with the new `PhotoImage` object.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法首先使用我们在第7章中学习的`filedialog.askopenfilename()`方法请求用户输入文件名，*创建菜单和Tkinter对话框*。如果用户选择了一个文件，我们调用`Image.open()`方法从文件创建一个Pillow
    `Image`对象。`Image.open()`是一个便利方法，它只需一个文件名或路径，就返回一个包含该文件图像数据的`Image`对象。接下来，我们通过将`Image`对象传递给`ImageTk.PhotoImage()`创建一个Tkinter
    `PhotoImage`对象。最后，我们使用新的`PhotoImage`对象更新我们的`image_display`小部件。
- en: Using this approach, you can display a much wider variety of image formats in
    Tkinter — Pillow has full read support for over 40 different formats! However,
    Pillow offers far more than just image format conversions. We can also use it
    to edit or transform our images in a variety of ways. For example, we can apply
    filtering to our Pillow `Image` objects. Let's add this feature to the demo application.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，你可以在Tkinter中显示更广泛的各种图像格式——Pillow对超过40种不同的格式提供了完整的读取支持！然而，Pillow提供的不仅仅是图像格式转换。我们还可以用它以各种方式编辑或转换我们的图像。例如，我们可以将过滤应用于我们的Pillow
    `Image`对象。让我们将此功能添加到演示应用程序中。
- en: 'Back up in `PictureViewer.__init__()`, add the following GUI code:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在`PictureViewer.__init__()`中向上回溯，添加以下GUI代码：
- en: '[PRE10]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `filters` list contains the names of all the filter objects Pillow provides
    that we can apply to an `Image` object (these can be found in the `Pillow` documentation).
    We've added all these to an `OptionMenu` along with the string `None`. The `OptionMenu`
    widget is then bound to the `filtervar` control variable, on which we've added
    a trace that calls the `_apply_filter()` method.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`filters`列表包含所有可以应用于`Image`对象的Pillow提供的过滤器对象的名称（这些可以在`Pillow`文档中找到）。我们将所有这些添加到`OptionMenu`中，以及字符串`None`。然后，我们将`OptionMenu`小部件绑定到`filtervar`控制变量，我们在其上添加了一个调用`_apply_filter()`方法的跟踪。'
- en: 'The `_apply_filter()` method looks like this:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`_apply_filter()`方法如下所示：'
- en: '[PRE11]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: First, this method retrieves the filter name from the control variable. If it's
    `None`, we set `self.filtered_image` to the current `self.image` object. Otherwise,
    we retrieve the filter object from the `ImageFilter` module using `getattr()`
    and apply the filter to our Pillow `Image` object using its `filter()` method.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，这种方法从控制变量中检索过滤器名称。如果它是`None`，我们将`self.filtered_image`设置为当前的`self.image`对象。否则，我们使用`getattr()`从`ImageFilter`模块检索过滤器对象，并使用其`filter()`方法将过滤器应用于我们的Pillow
    `Image`对象。
- en: Finally, we update the displayed image in the application by creating a new
    `PhotoImage` object and updating the configuration of the `Label` widget.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过创建一个新的`PhotoImage`对象并更新`Label`小部件的配置来更新应用程序中显示的图像。
- en: 'To see this program in action, add the last two lines to the script:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看此程序的实际运行效果，将最后两行添加到脚本中：
- en: '[PRE12]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You should see something that looks like this:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到类似这样的东西：
- en: '![Figure 9.1: The image viewer application, filtering the Mona Lisa](img/B17578_09_01.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图9.1：图像查看器应用程序，过滤蒙娜丽莎](img/B17578_09_01.png)'
- en: 'Figure 9.1: The image viewer application, filtering the Mona Lisa'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1：图像查看器应用程序，过滤蒙娜丽莎
- en: Now that we have a handle on using images in Tkinter, let's apply this knowledge
    to the ABQ Data Entry application.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经掌握了在Tkinter中使用图像的方法，让我们将此知识应用到ABQ数据输入应用程序中。
- en: Adding the company logo to ABQ Data Entry
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将公司标志添加到ABQ数据输入
- en: With our knowledge of `PhotoImage`, adding the company logo to our program should
    be simple. We've been provided with several PNG files of the company logo in different
    sizes.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 通过我们对`PhotoImage`的了解，将公司标志添加到我们的程序应该是简单的。我们提供了几个不同尺寸的公司标志PNG文件。
- en: 'You could simply copy one into the application root directory and add something
    like this to the `Application` class''s initializer:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将其中一个复制到应用程序根目录，并在`Application`类的初始化器中添加类似的内容：
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If you run the application from a terminal inside the application root directory,
    this approach works fine. However, if you run it from any other directory, the
    image won''t appear. For example, try this from the command line in the directory
    containing your root:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从应用程序根目录内的终端运行应用程序，这种方法是可行的。然而，如果你从任何其他目录运行它，图像就不会出现。例如，尝试从包含你的根目录的命令行中这样做：
- en: '[PRE14]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Why is this, and what can we do about it?
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么会是这种情况，我们能做些什么来解决这个问题？
- en: Dealing with the image path problem
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理图像路径问题
- en: When you give Python only a filename (with no path) to open, it assumes the
    file is in the **current working directory**. This is the directory the user was
    in when running the application. In the example above, when we ran the program
    the first time, our working directory was the application's root directory. The
    image was in that directory, so Python found it. The second time we ran it, our
    working directory was the parent directory of the application root. Python looked
    for the image in *that* directory, and it wasn't found.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当你只给Python一个没有路径的文件名来打开时，它假设文件在**当前工作目录**中。这是用户运行应用程序时的目录。在上面的例子中，当我们第一次运行程序时，我们的工作目录是应用程序的根目录。图像就在那个目录中，所以Python找到了它。第二次我们运行它时，我们的工作目录是应用程序根目录的父目录。Python在*那个*目录中寻找图像，但没有找到。
- en: 'If you know where your file is on the system, you can provide an absolute path;
    for example, if you''re on Windows 10 and the application root is on your home
    directory, you could do this:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你知道你的文件在系统中的位置，你可以提供一个绝对路径；例如，如果你在Windows 10上，应用程序的根目录在你的家目录中，你可以这样做：
- en: '[PRE15]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The problem, though, is that this reference would break if we put the code anywhere
    else on the system. Remember, as well, that our application needs to run on Linux
    and Windows, so providing an absolute path like this won't work across different
    platforms.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，问题在于如果我们把代码放在系统的任何其他地方，这个参考就会失效。记住，我们的应用程序需要在Linux和Windows上运行，所以提供这样的绝对路径在跨平台上是不可行的。
- en: The `r` in front of the path string above makes it a raw string. When a string
    is marked as raw, Python does not interpret backslash escape sequences in the
    string. This makes raw strings useful for file paths on Windows, which uses the
    backslash for a path separator. See *Chapter 10*, *Maintaining Cross-Platform
    Compatibility*, for more details on solving cross-platform path issues.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的路径字符串前面的`r`使其成为一个原始字符串。当一个字符串被标记为原始字符串时，Python不会在字符串中解释反斜杠转义序列。这使得原始字符串在Windows上很有用，因为Windows使用反斜杠作为路径分隔符。有关解决跨平台路径问题的更多详细信息，请参阅*第10章*，*维护跨平台兼容性*。
- en: A more robust approach is to provide a relative path from some known point.
    Every Python script has access to a variable called `__file__`, which is a string
    containing the path to the script file. We can use this variable in conjunction
    with the `pathlib` module to locate files inside our application root directory.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 一种更稳健的方法是从某个已知点提供一个相对路径。每个Python脚本都可以访问一个名为`__file__`的变量，它是一个包含脚本文件路径的字符串。我们可以使用这个变量结合`pathlib`模块来定位应用程序根目录内的文件。
- en: 'For example, we could rewrite our `PhotoImage` object''s configuration like
    this:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以这样重写我们的`PhotoImage`对象的配置：
- en: '[PRE16]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Since we are in `application.py`, `__file__` points to `ABQ_Data_Entry/abq_data_entry/application.py`.
    We can use this reference point to find the parent of the parent directory, where
    the image files are located. This will enable Python to successfully find the
    images no matter what the current working directory is.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们处于`application.py`中，`__file__`指向`ABQ_Data_Entry/abq_data_entry/application.py`。我们可以使用这个参考点来找到父父目录，其中包含图像文件。这将使Python无论当前工作目录是什么都能成功找到图像。
- en: This approach is functionally acceptable, but it's rather cluttered and clumsy
    to do these kinds of path manipulation every time we need to access an image file.
    Let's employ some of our organizational skills from *Chapter 6*, *Planning for
    the Expansion of Our Application*, to put the images in their own module.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法在功能上是可接受的，但是每次我们需要访问图像文件时，进行这类路径操作会显得相当杂乱和笨拙。让我们运用我们在*第6章*，*为应用程序的扩展规划*中学到的一些组织技巧，将图像放入它们自己的模块中。
- en: Under the `abq_data_entry` directory, create a new directory called `images`,
    and place within it an appropriately sized PNG file that we can use in our application
    (the image in the example code has an 8x5 aspect ratio, so in this case, we're
    using 32x20).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在`abq_data_entry`目录下创建一个新的目录，命名为`images`，并在其中放置一个适合我们应用程序使用的PNG文件（示例代码中的图像具有8x5的宽高比，因此在这种情况下，我们使用32x20）。
- en: 'Next, create an `__init__.py` file inside the `images` folder, in which we''ll
    add the following code:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`images`文件夹内创建一个`__init__.py`文件，我们将添加以下代码：
- en: '[PRE17]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In this case, `__file__` points to `ABQ_Data_Entry/abq_data_entry/images/__init__.py`,
    so we can use that point of reference to get paths to all the image files we put
    in `ABQ_Data_Entry/abq_data_entry/images/`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`__file__`指向`ABQ_Data_Entry/abq_data_entry/images/__init__.py`，因此我们可以使用这个参考点来获取我们放在`ABQ_Data_Entry/abq_data_entry/images/`中的所有图像文件的路径。
- en: 'Now, our `application.py` module can import the `images` module like this:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的`application.py`模块可以像这样导入`images`模块：
- en: '[PRE18]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Once imported, we can reference the image paths for our `PhotoImage` object
    easily:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦导入，我们可以轻松地引用`PhotoImage`对象的图像路径：
- en: '[PRE19]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, regardless of what working directory you run the script from, you should
    see the title looking something like this:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，无论您从哪个工作目录运行脚本，您都应该看到标题看起来像这样：
- en: '![Figure 9.2: The ABQ Data Entry application sporting a company logo](img/B17578_09_02.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图9.2：带有公司标志的ABQ数据输入应用程序](img/B17578_09_02.png)'
- en: 'Figure 9.2: The ABQ Data Entry application sporting a company logo'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2：带有公司标志的ABQ数据输入应用程序
- en: Setting a window icon
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置窗口图标
- en: Currently, our application's window icon (the icon that shows up in both the
    window decorations and in the operating system's taskbar) is the Tkinter logo,
    which is the default for any Tkinter application. It would make more sense for
    us to use the company logo image for this icon. How can we make this happen?
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们应用程序的窗口图标（在窗口装饰和操作系统的任务栏中显示的图标）是Tkinter标志，这是任何Tkinter应用程序的默认设置。对我们来说，使用公司标志图像作为这个图标更有意义。我们如何实现这一点呢？
- en: 'As a subclass of `Tk`, our `Application` object has a method called `iconphoto()`
    which should, given a path to an icon file, set the window icon appropriately.
    Unfortunately, this method is a bit inconsistent in its results across platforms.
    Let''s go ahead and add it to our initializer as follows and see what happens.
    Add this code just after the call to `super().__init__()`:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 作为`Tk`的子类，我们的`Application`对象有一个名为`iconphoto()`的方法，它应该根据图标文件的路径设置窗口图标。不幸的是，这个方法在不同平台上的结果有些不一致。让我们继续将其添加到初始化器中，看看会发生什么。在调用`super().__init__()`之后添加此代码：
- en: '[PRE20]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The first line creates another `PhotoImage` object, referencing a larger version
    of the logo. Next, we execute `self.iconphoto()`. The first argument indicates
    whether we want this icon to be the default across all new windows, or whether
    it's only for this window. Passing `True` here makes it the default for all. The
    second argument is our `PhotoImage` object.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行创建了一个新的`PhotoImage`对象，引用了标志的较大版本。接下来，我们执行`self.iconphoto()`。第一个参数指示我们是否希望这个图标在所有新窗口中都是默认的，或者它只是针对这个窗口。在这里传递`True`使其对所有窗口都是默认的。第二个参数是我们的`PhotoImage`对象。
- en: 'Now, when you run the application, you should see an ABQ icon being used as
    the window icon; how it is used depends on the platform. For example, on Windows,
    it shows up in the window decorations, as seen here:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当您运行应用程序时，您应该看到ABQ图标被用作窗口图标；它如何使用取决于平台。例如，在Windows上，它出现在窗口装饰中，如下所示：
- en: '![Figure 9.3: The ABQ Logo as a taskbar icon](img/B17578_09_03.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图9.3：ABQ标志作为任务栏图标](img/B17578_09_03.png)'
- en: 'Figure 9.3: The ABQ logo as a taskbar icon'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3：ABQ标志作为任务栏图标
- en: 'Here''s a summary of how the `iconphoto` is used on different platforms:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是`iconphoto`在不同平台上使用的总结：
- en: On Linux, it will depend on your desktop environment, but typically, it will
    show up in both the taskbar or dock and on the window decorations
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Linux上，它将取决于您的桌面环境，但通常，它将在任务栏或坞站以及窗口装饰中出现
- en: On macOS, it will show up as the icon in the dock, but not in the global menu
    or on the window itself
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在macOS上，它将作为坞站图标出现，但不会在全局菜单或窗口本身上显示
- en: On Windows 10, it will appear on the window decorations, but not on the taskbar
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Windows 10上，它将出现在窗口装饰中，但不会出现在任务栏上
- en: Part of the reason for this inconsistency is that our application is a script
    being executed by Python, so from the operating system's point of view, the program
    we're running isn't ABQ Data Entry, but rather Python. For that reason, you may
    see the Python logo appearing instead of the ABQ logo on your platform. We'll
    address this further when we package our application in *Chapter 16*, *Packaging
    with setuptools and cxFreeze* .
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 造成这种不一致的部分原因是我们应用程序是一个由Python执行的脚本，从操作系统的角度来看，我们正在运行的程序不是ABQ数据输入，而是Python。因此，您可能会在您的平台上看到Python标志而不是ABQ标志。我们将在第16章*使用setuptools和cxFreeze打包*中进一步解决这个问题。
- en: Adding icons to buttons and menus
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为按钮和菜单添加图标
- en: While not required by the users or company, you feel your application would
    look a little more impressive with some simple icons accompanying the text on
    your buttons and menu items. Unfortunately, Tkinter does not ship with any icon
    themes, nor is it able to access the operating system's built-in icon themes.
    So, in order to use icons, we'll have to first acquire some PNG or GIF images
    to use. These can be acquired from a number of sources online or, of course, you
    can create your own.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然用户或公司不需要，但您觉得在按钮和菜单项的文本旁边添加一些简单的图标可以使您的应用程序看起来更令人印象深刻。不幸的是，Tkinter没有提供任何图标主题，也无法访问操作系统的内置图标主题。因此，为了使用图标，我们首先需要获取一些PNG或GIF图像来使用。这些可以从网上多个来源获取，或者当然，您也可以自己创建。
- en: The example code comes with some icons taken from the **Open-Iconic** project,
    which features a large selection of standard application icons released under
    an MIT license. You can find this project at [https://useiconic.com/open](https://useiconic.com/open).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 示例代码附带了一些来自**Open-Iconic**项目的图标，该项目提供了一组在MIT许可下发布的标准应用程序图标。您可以在[https://useiconic.com/open](https://useiconic.com/open)找到这个项目。
- en: 'Assuming you have obtained some icon files, let''s add them to the `images`
    folder and then update `images/__init__.py` as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您已经获取了一些图标文件，让我们将它们添加到`images`文件夹中，然后按以下方式更新`images/__init__.py`：
- en: '[PRE21]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Here, we''ve added images for the **Save** and **Reset** buttons, as well as
    images to represent the Record List and Data Entry Form portions of the GUI. We
    can now begin adding these to our application; for example, let''s add them to
    the buttons in the `DataRecordForm` frame. Start by importing `images` into `views.py`,
    like so:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们为**保存**和**重置**按钮添加了图像，以及代表GUI的记录列表和数据输入表部分的图像。我们现在可以开始将这些添加到我们的应用程序中；例如，让我们将它们添加到`DataRecordForm`框架中的按钮上。首先，将`images`导入到`views.py`中，如下所示：
- en: '[PRE22]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, in the initializer, let''s update the buttons in the `DataRecordForm`
    with image icons:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在初始化器中，让我们用图像图标更新`DataRecordForm`中的按钮：
- en: '[PRE23]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, the form should look something like this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，表单应该看起来像这样：
- en: '![Figure 9.4: The buttons in the Data Record Form, now with icons](img/B17578_09_04.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图9.4：现在带有图标的记录表单中的按钮](img/B17578_09_04.png)'
- en: 'Figure 9.4: The buttons in the Data Record Form, now with icons'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.4：现在带有图标的记录表单中的按钮
- en: 'Remember that we can also add images to the `Notebook` widget''s tabs. Back
    in `application.py`, locate the code in `__init__()` that creates the notebook
    tabs and let''s update it as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 记住我们还可以将图像添加到`Notebook`小部件的标签页上。回到`application.py`，找到在`__init__()`中创建笔记本标签的代码，并按以下方式更新它：
- en: '[PRE24]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'It''s as simple as adding an `image` argument to the notebook''s `add()` and
    `insert()` method calls. As with buttons and labels, be sure to include the `compound`
    argument, or else only the icon will be displayed. Now, when we run the application,
    the tabs should look like this:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这就像在笔记本的`add()`和`insert()`方法调用中添加一个`image`参数一样简单。与按钮和标签一样，务必包含`compound`参数，否则只会显示图标。现在，当我们运行应用程序时，标签应该看起来像这样：
- en: '![Figure 9.5: The notebook tabs with icons](img/B17578_09_05.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图9.5：带有图标的笔记本标签](img/B17578_09_05.png)'
- en: 'Figure 9.5: The notebook tabs with icons'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.5：带有图标的笔记本标签
- en: 'As you can see, the workflow for using the icons is fairly consistent:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，使用图标的流程相当一致：
- en: Create a `PhotoImage` object, making sure a reference to it will stay in scope.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`PhotoImage`对象，确保对其的引用将保持作用域。
- en: Pass the object to the `image` argument of the widget you want it to appear
    on.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将对象传递给您希望它显示的小部件的`image`参数。
- en: Pass the widget's `compound` argument to specify the layout for widgets that
    will display both text and the image.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将小部件的`compound`参数传递给指定将显示文本和图像的小部件的布局。
- en: 'Rather than creating an individual class attribute for every icon, you may
    find it more efficient to store them in a dictionary object. For example, we should
    do this in the `MainMenu` class, where we''ll need a lot of icons. Import `images`
    into `mainmenu.py`, just as you did in the other two files, and let''s create
    a new `_create_icons()` instance method in `MainMenu`, as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是为每个图标创建一个单独的类属性，你可能发现将它们存储在字典对象中更有效率。例如，我们应在`MainMenu`类中这样做，因为我们需要很多图标。将`images`导入到`mainmenu.py`中，就像你在其他两个文件中所做的那样，并在`MainMenu`中创建一个新的`_create_icons()`实例方法，如下所示：
- en: '[PRE25]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Here, we're using an instance method to create a dictionary of `PhotoImage`
    objects and storing it as an instance attribute, `self.icons`. You might wonder
    why we don't create `MainMenu.icons` as a class attribute, similar to the `fields`
    dictionaries we created for our models.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用实例方法创建一个`PhotoImage`对象的字典，并将其存储为实例属性`self.icons`。你可能想知道为什么我们不创建`MainMenu.icons`作为类属性，类似于我们为模型创建的`fields`字典。
- en: The reason is that `PhotoImage` objects, like all Tkinter objects, cannot be
    created until an instance of `Tk` has been created (in our case, the `Application`
    object).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 原因是`PhotoImage`对象，就像所有Tkinter对象一样，必须在创建`Tk`实例（在我们的案例中是`Application`对象）之后才能创建。
- en: Class definitions, and therefore class attributes, are executed by Python before
    the main thread of execution begins, so there would be no `Application` object
    when this class is defined.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 类定义以及因此类属性，在Python开始执行主执行线程之前由Python执行，所以在定义此类时，将不存在`Application`对象。
- en: 'We can call this method inside the initializer to make sure `self.icons` is
    populated before we define the menu; add that code like so:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在初始化器内部调用此方法，以确保在定义菜单之前`self.icons`已被填充；添加如下代码：
- en: '[PRE26]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, each menu item can access its `PhotoImage` object via the dictionary,
    as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每个菜单项都可以通过字典访问其`PhotoImage`对象，如下所示：
- en: '[PRE27]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now our menu boasts some professional-looking icons, as shown here:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的菜单展示了一些看起来专业的图标，如图所示：
- en: '![Figure 9.6: The "Go" menu, with some nice icons](img/B17578_09_06.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![图9.6：带有一些精美图标的“前往”菜单](img/B17578_09_06.png)'
- en: 'Figure 9.6: The Go menu, with some nice icons'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.6：带有一些精美图标的“前往”菜单
- en: Using BitmapImage
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用BitmapImage
- en: 'Using `PhotoImage` with PNG files is more than sufficient for our application,
    but there is one other option for images in Tkinter that bears mentioning: `BitmapImage`.
    The `BitmapImage` object is similar to `PhotoImage`, but works exclusively with
    **XBM** (X11 Bitmap) files. This is a very old image format that only allows for
    monochromatic images. Despite being monochromatic, XBM images are not compressed,
    and therefore not smaller than PNG files of equivalent size. The only real advantage
    to a `BitmapImage` object is that we can tell Tkinter to render it with any colors
    we wish.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`PhotoImage`与PNG文件配合已经足够满足我们的应用需求，但Tkinter中还有另一个值得提及的图像选项：`BitmapImage`。`BitmapImage`对象与`PhotoImage`类似，但仅限于与**XBM**（X11位图）文件协同工作。这是一个非常古老的图像格式，仅允许单色图像。尽管是单色的，XBM图像并未压缩，因此其大小并不小于同等大小的PNG文件。`BitmapImage`对象的唯一真正优势在于，我们可以告诉Tkinter以我们想要的任何颜色渲染它。
- en: 'To see how this works, let''s add a few XBM files to our `images` module; copy
    in some XBM files and then add them to `__init__.py`, like so:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解这是如何工作的，让我们在我们的`images`模块中添加一些XBM文件；复制一些XBM文件，然后像这样将它们添加到`__init__.py`中：
- en: '[PRE28]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Some XBM files are included in the sample code; alternatively, you can convert
    your own image files to XBM using image editing software like the GNU Image Manipulation
    Program from [https://www.gimp.org](https://www.gimp.org).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 样本代码中包含了一些XBM文件；或者，你可以使用像GNU Image Manipulation Program（[https://www.gimp.org](https://www.gimp.org)）这样的图像编辑软件将你的图像文件转换为XBM。
- en: 'Now, back in `mainmenu.py`, let''s add them to our `icons` dictionary, as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，回到`mainmenu.py`，让我们将它们添加到我们的`icons`字典中，如下所示：
- en: '[PRE29]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'As you can see, creating a `BitmapImage` is identical to creating a `PhotoImage`
    object, but with the possibility of specifying `foreground` and `background` colors
    for the image. Once created, adding them to the menu item is identical to using
    `PhotoImage`, as shown here:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，创建`BitmapImage`与创建`PhotoImage`对象相同，但可以指定图像的`前景色`和`背景色`。一旦创建，将它们添加到菜单项的操作与使用`PhotoImage`相同，如下所示：
- en: '[PRE30]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now the **Help** menu should have a colorful icon, as shown here:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，**帮助**菜单应该有一个彩色的图标，如图所示：
- en: '![Figure 9.7: The now colorful About icon](img/B17578_09_07.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![图9.7：现在彩色的关于图标](img/B17578_09_07.png)'
- en: 'Figure 9.7: The now colorful About icon'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.7：现在彩色的关于图标
- en: You may find `BitmapImage` objects useful if you want to reuse a single file
    with different colors, or perhaps dynamically change the color scheme of your
    icons to fit with a theme or indicate some kind of state. Most of the time, though,
    using `PhotoImage` objects will be preferable.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望重复使用单个文件但具有不同的颜色，或者可能需要动态更改图标颜色方案以适应主题或指示某种状态，那么`BitmapImage`对象可能会很有用。不过，大多数情况下，使用`PhotoImage`对象会更合适。
- en: These images have dramatically changed the look of our application, but the
    rest of it is still a rather drab gray. In the next sections, we'll work on updating
    its colors.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这些图像极大地改变了我们应用程序的外观，但其余部分仍然是相当单调的灰色。在接下来的几节中，我们将着手更新其颜色。
- en: Styling Tkinter widgets
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Tkinter小部件样式
- en: 'Tkinter has essentially two styling systems: the old Tkinter widgets system,
    and the newer Ttk system. Although we are using Ttk widgets wherever possible,
    there are still situations where regular Tkinter widgets are required, so it''s
    good to know both systems. Let''s take a look first at the older Tkinter system
    and apply some styling to the Tkinter widgets in our application.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: Tkinter本质上有两个样式系统：旧的Tkinter小部件系统和较新的Ttk系统。尽管我们尽可能使用Ttk小部件，但仍然有一些情况下需要使用常规的Tkinter小部件，因此了解这两个系统都是好的。让我们首先看看较旧的Tkinter系统，并给我们的应用程序中的Tkinter小部件应用一些样式。
- en: Widget color properties
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 小部件颜色属性
- en: 'As you saw in *Chapter 1*, *Introduction to Tkinter*, basic Tkinter widgets
    allow you to change two color values: the foreground color, meaning mainly the
    color of text and borders, and the background color, meaning the rest of the widget.
    These can be set using the `foreground` and `background` arguments, or their aliases,
    `fg` and `bg`.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在*第1章*，*Tkinter简介*中看到的，基本的Tkinter小部件允许你更改两个颜色值：前景色，主要指文本和边框的颜色，以及背景色，指小部件的其余部分。这些可以通过`foreground`和`background`参数，或它们的别名`fg`和`bg`来设置。
- en: 'For example, we can set the colors of a label like so:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以这样设置标签的颜色：
- en: '[PRE31]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The values for the colors can be color name strings or CSS-style RGB hex strings.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 颜色的值可以是颜色名称字符串或CSS风格的RGB十六进制字符串。
- en: 'For example, this code produces the same effect:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下代码会产生相同的效果：
- en: '[PRE32]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: There are over 700 named colors recognized by Tkinter, roughly corresponding
    to those recognized by the X11 display server used on Linux and Unix, or the CSS
    named colors used by web designers. For a complete list, see [https://www.tcl.tk/man/tcl8.6/TkCmd/colors.htm](https://www.tcl.tk/man/tcl8.6/TkCmd/colors.htm).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Tkinter识别了超过700种命名颜色，大致对应于Linux和Unix上使用的X11显示服务器所识别的颜色，或者网络设计师使用的CSS命名颜色。完整的列表，请参阅[https://www.tcl.tk/man/tcl8.6/TkCmd/colors.htm](https://www.tcl.tk/man/tcl8.6/TkCmd/colors.htm)。
- en: Using widget properties on the MainMenu
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在MainMenu上使用小部件属性
- en: We aren't using many Tkinter widgets in our views, preferring Ttk as much as
    possible. One place where we *are* using a Tkinter widget is our application's
    main menu. We can use the main menu to demonstrate how Tkinter widget colors can
    be configured.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的视图中，我们并没有使用很多Tkinter小部件，尽可能多地使用Ttk。我们确实使用Tkinter小部件的一个地方是应用程序的主菜单。我们可以使用主菜单来演示如何配置Tkinter小部件的颜色。
- en: Note that setting colors and other appearance options on the menu system *only*
    works consistently on Linux or BSD. The effect on Windows or macOS is incomplete,
    so readers on those platforms may see incomplete results. In *Chapter 10*, *Maintaining
    Cross-Platform Compatibility*, we'll redesign our menu so that these differences
    in compatibility are accounted for.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在菜单系统上设置颜色和其他外观选项仅在Linux或BSD上**一致**地工作。在Windows或macOS上的效果不完整，因此那些平台上的读者可能会看到不完整的结果。在*第10章*，*维护跨平台兼容性*中，我们将重新设计我们的菜单，以便考虑到这些兼容性差异。
- en: 'The `tk.Menu` widget accepts the following appearance-related arguments:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`tk.Menu`小部件接受以下与外观相关的参数：'
- en: '| Argument | Values | Description |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 值 | 描述 |'
- en: '| `background` | Color string | The color of the background under normal conditions
    |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| `background` | 颜色字符串 | 正常条件下的背景色 |'
- en: '| `foreground` | Color string | The color of the foreground (text) under normal
    conditions |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| `foreground` | 颜色字符串 | 正常条件下的前景色（文本）颜色 |'
- en: '| `borderwidth` | Integer | The width of the widget border, in pixels, under
    normal conditions |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| `borderwidth` | 整数 | 正常条件下的小部件边框宽度，以像素为单位 |'
- en: '| `activebackground` | Color string | The background color when the widget
    is active (being hovered over or selected via the keyboard) |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| `activebackground` | 颜色字符串 | 当小部件处于活动状态（被悬停或通过键盘选中）时的背景色 |'
- en: '| `activeforeground` | Color string | The foreground (text) color when the
    widget is active |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| `activeforeground` | 颜色字符串 | 当widget处于活动状态时的前景（文字）颜色 |'
- en: '| `activeborderwidth` | Integer | The border width, in pixels, of the widget
    when active |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| `activeborderwidth` | 整数 | 当widget处于活动状态时，边框的宽度，以像素为单位 |'
- en: '| `disabledforeground` | Color string | The foreground (text) color when the
    widget is disabled |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| `disabledforeground` | 颜色字符串 | 当widget被禁用时的前景（文字）颜色 |'
- en: '| `relief` | One of the Tkinter constants `RAISED`, `SUNKEN`, `FLAT`, `RIDGE`,
    `SOLID`, or `GROOVE` | The style of the border drawn around the widget |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| `relief` | Tkinter常量之一`RAISED`、`SUNKEN`、`FLAT`、`RIDGE`、`SOLID`或`GROOVE` |
    绘制在widget周围的边框样式 |'
- en: Note that there are versions of `background`, `foreground`, and `borderwidth`
    for both the normal and active states, and a version of `foreground` for the disabled
    state. Depending on what is applicable to the widget, many Tkinter widgets support
    additional arguments for certain states, conditions, or features; for example,
    widgets with selectable text like the `Entry` widget support `highlightbackground`
    and `highlightforeground` arguments to specify the colors used when text is selected.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，对于正常和活动状态，以及禁用状态，都有`background`、`foreground`和`borderwidth`的版本，还有一个用于禁用状态的`foreground`版本。根据widget适用的内容，许多Tkinter
    widget支持某些状态、条件或功能的额外参数；例如，具有可选文本的widget，如`Entry` widget，支持`highlightbackground`和`highlightforeground`参数来指定文本被选中时使用的颜色。
- en: The Tcl/Tk documentation at [https://www.tcl.tk/man/](https://www.tcl.tk/man/)
    provides the most complete reference for widget-specific options, including styling
    options.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: Tcl/Tk文档在[https://www.tcl.tk/man/](https://www.tcl.tk/man/)提供了关于widget特定选项的最完整参考，包括样式选项。
- en: 'Open up the `mainmenu.py` file and let''s add some styles to our menu inside
    the initializer method:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`mainmenu.py`文件，让我们在初始化方法中为我们的菜单添加一些样式：
- en: '[PRE33]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Execute the application, and note the menu''s appearance. On Linux or BSD,
    it should look something like this:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序，并注意菜单的外观。在Linux或BSD上，它应该看起来像这样：
- en: '![Figure 9.8: A styled Tkinter menu on Ubuntu Linux](img/B17578_09_08.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![图9.8：在Ubuntu Linux上的样式化Tkinter菜单](img/B17578_09_08.png)'
- en: 'Figure 9.8: A styled Tkinter menu on Ubuntu Linux'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.8：在Ubuntu Linux上的样式化Tkinter菜单
- en: 'Note that the styling does not go past the main menu; the sub-menus are still
    the default black-on-gray. To make the menu consistent, we''ll need to apply these
    styles to all the sub-menus as well. To avoid a lot of repetition, let''s change
    our code so that the styles are stored in a dictionary, which we can then unpack
    in each call to `tk.Menu`. Update the code like so:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，样式不会超出主菜单；子菜单仍然是默认的灰色背景黑色文字。为了使菜单保持一致，我们需要将这些样式应用到所有子菜单上。为了避免重复，让我们修改我们的代码，将样式存储在字典中，然后我们可以在每次调用`tk.Menu`时解包这些样式。按照以下方式更新代码：
- en: '[PRE34]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now, to add the styling to each sub-menu, we just need to add `**self.styles`
    to each sub-menu initialization, like so:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了将样式添加到每个子菜单，我们只需要在每个子菜单初始化时添加`**self.styles**`，如下所示：
- en: '[PRE35]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Assuming your platform supports menu styling, you should now see the styles
    applied to the sub-menus as well.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你的平台支持菜单样式，你现在应该看到子菜单上也应用了样式。
- en: Styling widget content with tags
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用标签对widget内容进行样式设置
- en: Foreground and background colors are sufficient for simple widgets such as buttons
    and labels, but more complex Tkinter widgets like the `Text` widget or the Ttk
    `Treeview` widget rely on a **tag**-based system for more detailed styling. A
    **tag** in Tkinter is a named region of a widget's content to which color and
    font settings can be applied. To see how this works, let's build a crude, but
    pretty, Python terminal emulator.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 对于像按钮和标签这样的简单小部件，前景色和背景色就足够了，但对于更复杂的Tkinter小部件，如`Text`小部件或Ttk `Treeview`小部件，它们依赖于基于**标签**的系统来进行更详细的样式设置。在Tkinter中，**标签**是widget内容的一个命名区域，可以将颜色和字体设置应用于该区域。为了了解这是如何工作的，让我们构建一个粗糙但相当漂亮的Python终端模拟器。
- en: 'Open a new file called `tags_demo.py`, and we''ll start by creating a `Text`
    widget to store the terminal input and output:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 打开一个名为`tags_demo.py`的新文件，我们首先创建一个`Text`小部件来存储终端的输入和输出：
- en: '[PRE36]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Here, we've used the `fg` and `bg` arguments to set up a green-on-black terminal
    theme, a classic combination popular with programmers. Rather than having only
    green text, though, let's configure different colors for our prompt and our interpreter
    output.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了`fg`和`bg`参数来设置绿色背景黑色文字的终端主题，这是程序员中流行的经典组合。然而，我们不想只有绿色文字，让我们为我们的提示符和解释器输出配置不同的颜色。
- en: 'To do this, we''ll define some tags:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们需要定义一些标签：
- en: '[PRE37]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The `tag_configure()` method allows us to declare and configure tags on the
    `Text` widget. We've created one called `prompt` with magenta text for the shell
    prompt, and another called `output` with yellow text for the Python output. Note
    that we aren't restricted to a single configuration argument here; we could conceivably
    pass a `font` or `background` argument as well, if we wished.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`tag_configure()`方法允许我们在`Text`小部件上声明和配置标记。我们创建了一个名为`prompt`的标记，用于外壳提示的洋红色文本，另一个名为`output`的标记，用于Python输出的黄色文本。注意，我们在这里并不限于单个配置参数；如果我们愿意，我们可以传递`font`或`background`参数。'
- en: 'To insert text with a given tag applied, we do the following:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 要插入应用了给定标记的文本，我们执行以下操作：
- en: '[PRE38]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'As you may remember, the `Text.insert()` method takes an index and string as
    its first two arguments. Notice the third argument: this is a tuple of the tags
    with which we want to mark the inserted text. This value must be a tuple, even
    if you''re only using one tag; naturally, you can include as many tags as you
    wish.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所记得，`Text.insert()`方法接受索引和字符串作为其前两个参数。注意第三个参数：这是我们想要标记插入文本的标记的元组。这个值必须是一个元组，即使你只使用一个标记；当然，你可以包括你想要的任意多个标记。
- en: If you add `text.mainloop()` to the end of the code and run it, you'll see that
    we have a black text entry window with a magenta prompt; however, if you type
    anything, your text will show up in green (the widget's default foreground color).
    So far so good; now, let's make it execute some Python.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将`text.mainloop()`添加到代码末尾并运行它，你会看到我们有一个黑色文本输入窗口和一个洋红色提示符；然而，如果你输入任何内容，你的文本将以绿色显示（小部件的默认前景色）。到目前为止，一切顺利；现在，让我们让它执行一些Python代码。
- en: 'Create a function just before the `mainloop()` call:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`mainloop()`之前创建一个函数：
- en: '[PRE39]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Recall that, when retrieving text from a `Text` widget, we''re required to
    supply start and end indices for the text we want to retrieve. We can utilize
    tag names in our index values, as we''ve done here: `prompt.last` tells Tkinter
    to fetch the text starting *after* the end of the region tagged `prompt`.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，当我们从`Text`小部件检索文本时，我们必须为要检索的文本提供起始和结束索引。我们可以像这里这样在我们的索引值中使用标记名称：`prompt.last`告诉Tkinter从标记为`prompt`的区域结束之后开始检索文本。
- en: 'Next, let''s execute the entered command:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们执行输入的命令：
- en: '[PRE40]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: If the `cmd` variable actually contains anything, we'll try to execute it with
    `eval()`, and then store a string of the response value as output. If it raises
    an exception, we'll cast our exception to a string and set that as the output.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`cmd`变量实际上包含任何内容，我们将尝试使用`eval()`执行它，然后将响应值的字符串存储为输出。如果引发异常，我们将异常转换为字符串并将其设置为输出。
- en: Note that `eval()` only works on expressions, so our "shell" won't be able to
    handle loops, conditionals, or other statements.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`eval()`只对表达式有效，所以我们的“外壳”无法处理循环、条件或其他语句。
- en: 'Then, we''ll just show our output, like so:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将像这样显示我们的输出：
- en: '[PRE41]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Here, we've inserted our `output` string, prefixed with a newline and tagged
    as `output`.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们插入我们的`output`字符串，前面带有换行符并标记为`output`。
- en: 'We''ll finish off the function by giving the user back a prompt:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过给用户返回一个提示符来完成函数：
- en: '[PRE42]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Note that we also return the string `break` here. This tells Tkinter to ignore
    the original event that triggered the callback. Since we're going to trigger this
    from a Return/Enter keystroke, we want to ignore that keystroke after we're finished.
    If we don't, the keystroke will be executed *after* our function returns, inserting
    the newline after the display of the prompt and leaving the user on the line under
    the prompt.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在这里也返回了字符串`break`。这告诉Tkinter忽略触发回调的原始事件。由于我们将从Return/Enter键盘中触发，我们希望在完成之后忽略该键盘中断。如果不这样做，键盘中断将在我们的函数返回后执行，在提示符显示后插入换行符，并使用户停留在提示符下的行。
- en: 'Finally, we need to bind our function to the Return key:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要将我们的函数绑定到Return键：
- en: '[PRE43]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Note that the event for the Enter/Return key is always `<Return>`, even on non-Apple
    hardware (where the key is more commonly labeled "Enter").
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Enter/Return键的事件始终是`<Return>`，即使在非Apple硬件上（那里的键通常标记为“Enter”）。
- en: 'Make sure to add a call to `text.mainloop()` at the end of the script, and
    then launch the application. You should get something like this:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在脚本末尾添加对`text.mainloop()`的调用，然后启动应用程序。你应该会得到类似以下内容：
- en: '![Figure 9.9: The colorful Python shell](img/B17578_09_09.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![图9.9：多彩的Python外壳](img/B17578_09_09.png)'
- en: 'Figure 9.9: The colorful Python shell'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.9：多彩的Python外壳
- en: While this shell won't be supplanting IDLE any time soon, it does look rather
    nice, don't you think?
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个外壳不会很快取代IDLE，但它看起来相当不错，不是吗？
- en: Styling our record list with tags
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用标签对记录列表进行样式化
- en: Although `Treeview` is a Ttk widget, it uses tags to control the styling of
    individual rows. We can use this capability to address another of the requests
    you've gotten from the data entry staff – specifically, that they'd like the record
    list to highlight the records updated and inserted during the current session.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`Treeview`是一个Ttk小部件，但它使用标签来控制单个行的样式。我们可以利用这一功能来满足您从数据录入人员那里收到的另一个请求——具体来说，他们希望记录列表能够突出显示当前会话中更新和插入的记录。
- en: The first thing we'll need to do is have our `RecordList` object keep track
    of which rows have been updated or inserted during the session.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要让我们的`RecordList`对象跟踪会话期间哪些行已被更新或插入。
- en: 'We''ll start in `RecordList.__init__()` by creating a couple of instance variables
    to store the updated or inserted rows:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从`RecordList.__init__()`开始，创建一些实例变量来存储会话期间更新或插入的行：
- en: '[PRE44]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'When a record is inserted or updated, we''ll need to append its row number
    to the appropriate list. Since `RecordList` doesn''t know when a record is updated
    or inserted, we''ll have to create some public methods that the `Application`
    object can call to append to the lists. Create these two methods in the `RecordList`
    class:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 当记录被插入或更新时，我们需要将其行号追加到相应的列表中。由于`RecordList`不知道何时更新或插入记录，我们需要创建一些公共方法，供`Application`对象调用以追加到列表中。在`RecordList`类中创建这两个方法：
- en: '[PRE45]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Each method takes a row number and appends it to the corresponding list. To
    avoid duplicates, we only do so if the row is not in the list. Now, to use these
    methods, we'll have to update the `Application._on_save()` method so that it calls
    the appropriate update method *after* the record is saved, but *before* we repopulate
    the record list.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 每个方法都接受一个行号并将其追加到相应的列表中。为了避免重复，我们只有在行不在列表中时才这样做。现在，为了使用这些方法，我们需要更新`Application._on_save()`方法，使其在记录保存后、重新填充记录列表之前调用适当的更新方法。
- en: 'In `_on_save()`, right after calling `self.model.save_record()`, add these
    lines:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在`_on_save()`中，在调用`self.model.save_record()`之后，添加以下行：
- en: '[PRE46]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Updates have a `rownum` value that is not `None`, but could be `0`, so we explicitly
    test for `None` here rather than just using `if rownum:`. If `rownum` is not `None`,
    we'll append it to the updated list.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 更新操作有一个`rownum`值，该值不为`None`，但可能是`0`，因此我们在这里明确检查`None`，而不是仅仅使用`if rownum:`。如果`rownum`不为`None`，我们将将其追加到更新列表中。
- en: 'Now, we need to deal with inserts:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要处理插入操作：
- en: '[PRE47]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Inserted records are a little more troublesome in that we don't have a row number
    readily available to record. We do know that an insert is always appended to the
    end of the file, though, so its row number should be one smaller than the number
    of rows in the file.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 插入的记录稍微麻烦一些，因为我们没有现成的行号来记录。不过，我们知道插入的记录总是追加到文件的末尾，因此其行号应该比文件中的行数少一。
- en: Our inserted and updated records will be kept until the end of the program session
    (when the user exits the program) or until the user selects a new file to work
    on. If the user selects a new file, we will need to clear out the lists since
    we're working with a completely new set of records.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们插入和更新的记录将保留到程序会话结束（当用户退出程序）或直到用户选择一个新的文件来工作。如果用户选择了一个新的文件，我们需要清除列表，因为我们正在处理一组全新的记录。
- en: 'Once again, since `RecordList` doesn''t know when this happens, we''ll need
    to create a public method that clears the lists. Add the following `clear_tags()`
    method to the `RecordList` class:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，由于`RecordList`不知道何时发生这种情况，我们需要创建一个公共方法来清除列表。将以下`clear_tags()`方法添加到`RecordList`类中：
- en: '[PRE48]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now we need the `Application` class to call this whenever a new file is selected
    for saving, which happens in `Application._on_file_select()`. Add a call to the
    method just before repopulating the record list:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要在`Application`类中选择保存新文件时调用此方法，这发生在`Application._on_file_select()`中。在重新填充记录列表之前，添加对方法的调用：
- en: '[PRE49]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Now that we have these lists updating correctly, we need to use them to color-code
    the list items.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经正确更新了这些列表，我们需要使用它们来为列表项着色。
- en: To do this, we first need to configure tags with appropriate colors. Our data
    entry staff feel that light green would be a sensible color for inserted records,
    and light blue for updated.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们首先需要配置带有适当颜色的标签。我们的数据录入人员认为，浅绿色是插入记录的合理颜色，浅蓝色是更新记录的颜色。
- en: 'Add the following code at the end of `RecordList.__init__()`:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在`RecordList.__init__()`的末尾添加以下代码：
- en: '[PRE50]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Just as we did with the `Text` widget earlier, we call the `TreeView` object's
    `tag_configure()` method to connect `background` color settings with our tag names.
    To add the tags to our `TreeView` rows, we'll need to update the `populate()`
    method so that as rows are inserted, the appropriate tag (if any) is added.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在之前的`Text`小部件中所做的那样，我们调用`TreeView`对象的`tag_configure()`方法来将`background`颜色设置与我们的标签名称连接起来。为了将标签添加到我们的`TreeView`行中，我们需要更新`populate()`方法，以便在插入行时，添加适当的标签（如果有的话）。
- en: 'Inside the `populate()` method''s `for` loop, just before inserting the row,
    we''ll add this code:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在`populate()`方法的`for`循环中，在插入行之前，我们将添加以下代码：
- en: '[PRE51]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Now, our `treeview.insert()` call just needs to be amended with this tag value:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的`treeview.insert()`调用只需要修改为这个标签值：
- en: '[PRE52]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Run the application and try to insert and update some records.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序并尝试插入和更新一些记录。
- en: 'You should get something like this:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该得到类似这样的结果：
- en: '![Figure 9.10: The treeview with styled rows](img/B17578_09_10.png)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![图9.10：具有样式行的treeview](img/B17578_09_10.png)'
- en: 'Figure 9.10: The treeview with styled rows. The light blue corresponds to updated
    rows (row 0) and the light green to inserted rows (row 1). Note that the dark
    blue row is just the selected row (row 2).'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.10：具有样式行的treeview。浅蓝色对应于更新的行（行0）和浅绿色对应于插入的行（行1）。请注意，深蓝色行只是选中的行（行2）。
- en: In addition to the `Text` and `Treeview` widgets, tags are also used with the
    Tkinter `Canvas` widget, which we'll learn more about in *Chapter 15*, *Visualizing
    Data Using the Canvas Widget*.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`Text`和`Treeview`小部件外，标签也用于Tkinter的`Canvas`小部件，我们将在第15章中了解更多关于它的内容，即《使用Canvas小部件可视化数据》。
- en: Working with fonts in Tkinter
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Tkinter中处理字体
- en: Some of our data entry users have complained that the font of the application
    is just a little too small to read easily, but others dislike the idea of you
    increasing it because it makes the application too big for the screen. To accommodate
    all the users, we can add a configuration option that allows them to set a preferred
    font size and family.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 一些我们的数据输入用户抱怨应用程序的字体有点太小，难以阅读，但其他人不喜欢你增加它的想法，因为它使得应用程序太大，不适合屏幕。为了满足所有用户的需求，我们可以添加一个配置选项，允许他们设置首选的字体大小和家族。
- en: Configuring Tkinter fonts
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置Tkinter字体
- en: Any widget in Tkinter that displays text allows us to specify a font, typically
    through its `font` configuration property. For widgets that support tags, we can
    also specify font settings for each tag. We've been using the `font` argument
    as far back as *Chapter 1*, *Introduction to Tkinter*, but now it's time to take
    a deeper look into what Tkinter allows us to do with fonts.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: Tkinter中任何显示文本的小部件都允许我们指定一个字体，通常通过其`font`配置属性。对于支持标签的小部件，我们还可以为每个标签指定字体设置。我们自第1章《Tkinter简介》以来一直在使用`font`参数，但现在是我们深入探究Tkinter允许我们用字体做什么的时候了。
- en: 'There are three ways of specifying a widget''s font in Tkinter: using a string,
    using a tuple, and using a `Font` object. Let''s take a look at each one.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在Tkinter中指定小部件字体有三种方式：使用字符串、使用元组和使用`Font`对象。让我们逐一看看。
- en: Configuring fonts with strings and tuples
  id: totrans-254
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用字符串和元组配置字体
- en: 'The simplest way to configure a font in Tkinter is to just use a font specification
    string:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在Tkinter中配置字体的最简单方法是直接使用字体指定字符串：
- en: '[PRE53]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The string takes the format `font-family size styles`, where:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串的格式为`font-family size styles`，其中：
- en: '`font-family` is the name of the font family. It can only be a single word;
    no spaces are allowed.'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`font-family`是字体家族的名称。它只能是一个单词；不允许有空格。'
- en: '`size` is an integer describing the size. A positive integer indicates a size
    in *points*, a negative indicates a size in *pixels*. Float values are not supported.'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`size`是一个描述大小的整数。正整数表示以点为单位的大小，负数表示以像素为单位的大小。不支持浮点值。'
- en: '`styles` can be any valid combination of text style keywords.'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`styles`可以是任何有效的文本样式关键字组合。'
- en: 'Everything but the font family is optional, though you need to specify a size
    if you want to specify any of the styling keywords. The keywords that can be used
    for styles include:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 除了字体家族之外，其他都是可选的，尽管如果你想要指定任何样式关键字，你需要指定一个大小。可用于样式的关键字包括：
- en: '`bold` for boldface text, or `normal` for normal weight'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bold`用于加粗文本，或`normal`用于正常重量'
- en: '`italic` for italicized text, or `roman` for regular slant'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`italic`用于斜体文本，或`roman`用于常规斜体'
- en: '`underline` for underlined text'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`underline`用于下划线文本'
- en: '`overstrike` for struck-out text'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`overstrike`用于删除线文本'
- en: The ordering of style keywords doesn't matter, but the weight and slant keywords
    are mutually exclusive (that is, you can't have `bold normal` or `italic roman`).
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 样式关键字的顺序无关紧要，但重量和斜体关键字是互斥的（也就是说，你不能有`bold normal`或`italic roman`）。
- en: While quick and simple, the string approach has its shortcomings; for one, it
    can't handle fonts with spaces in the name, something that is fairly common on
    modern systems.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然字符串方法快速简单，但它有其缺点；首先，它无法处理名称中包含空格的字体，这在现代系统中相当常见。
- en: 'To handle fonts like that, you can use the tuple format:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 要处理这样的字体，你可以使用元组格式：
- en: '[PRE54]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This format is exactly like the string format, except that the different components
    are written as items in a tuple.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 此格式与字符串格式完全相同，不同之处在于不同的组件被写成元组中的项。
- en: The size component can be an integer or a string containing digits, which provides
    some flexibility depending on where the value comes from.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 大小组件可以是一个整数或包含数字的字符串，这取决于值的来源提供了一些灵活性。
- en: The font module
  id: totrans-272
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字体模块
- en: The string or tuple approach works fine for setting up a handful of font changes
    at launch time, but for situations where we need to dynamically manipulate font
    settings, Tkinter offers the `font` module. This module offers us a few font-related
    functions as well as a `Font` class, whose instances can be assigned to widgets
    and dynamically changed.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串或元组方法在启动时设置少量字体更改时工作良好，但对于需要动态操作字体设置的情况，Tkinter提供了`font`模块。此模块为我们提供了一些与字体相关的函数以及一个`Font`类，其实例可以分配给小部件并动态更改。
- en: 'To use the `font` module, it must first be imported:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`font`模块，首先必须导入：
- en: '[PRE55]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Now, we can create a custom `Font` object and assign it to some widgets:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以创建一个自定义的`Font`对象并将其分配给一些小部件：
- en: '[PRE56]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: As you can see, the values passed to the `Font` initializer arguments correlate
    with the weight and slant values used in string and tuple font specifications.
    The `weight` argument also supports the use of the constants `font.NORMAL` or
    `font.BOLD`, while `slant` supports the use of `font.ITALIC` or `font.ROMAN`.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，传递给`Font`初始化参数的值与字符串和元组字体规范中使用的重量和斜体值相对应。`weight`参数还支持使用`font.NORMAL`或`font.BOLD`常量，而`slant`支持使用`font.ITALIC`或`font.ROMAN`。
- en: 'Once we''ve created a `Font` object and assigned it to one or more widgets,
    we can dynamically alter aspects of it at runtime. For example, we could create
    a button that will toggle the `overstrike` property of our font:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们创建了一个`Font`对象并将其分配给一个或多个小部件，我们就可以在运行时动态地更改其某些方面。例如，我们可以创建一个按钮来切换我们字体的`overstrike`属性：
- en: '[PRE57]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The `Font` object is a Python interface to a Tcl/Tk feature called **named fonts**.
    In Tcl/Tk, a named font is just a collection of font properties associated with
    a name.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '`Font`对象是Python对Tcl/Tk中称为**命名字体**的功能的接口。在Tcl/Tk中，命名字体只是一个与名称相关联的字体属性集合。'
- en: '`Tk` comes with several named fonts already configured, as shown in the following
    table:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '`Tk`已经预配置了几个命名的字体，如下表所示：'
- en: '| Font name | Defaults to | Used for |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
  zh: '| 字体名称 | 默认为 | 用于 |'
- en: '| `TkCaptionFont` | System title font | Window and dialog caption bars |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
  zh: '| `TkCaptionFont` | 系统标题字体 | 窗口和对话框标题栏 |'
- en: '| `TkDefaultFont` | System default font | Items not otherwise specified |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
  zh: '| `TkDefaultFont` | 系统默认字体 | 未指定其他项 |'
- en: '| `TkFixedFont` | System fixed-width font | `Text` widget |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
  zh: '| `TkFixedFont` | 系统固定宽度字体 | `Text`小部件 |'
- en: '| `TkHeadingFont` | System heading font | Column headings in lists and tables
    |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
  zh: '| `TkHeadingFont` | 系统标题字体 | 列表和表中的列标题 |'
- en: '| `TkIconFont` | System icon font | Icon captions |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
  zh: '| `TkIconFont` | 系统图标字体 | 图标标题 |'
- en: '| `TkMenuFont` | System menu font | Menu labels |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
  zh: '| `TkMenuFont` | 系统菜单字体 | 菜单标签 |'
- en: '| `TkSmallCaptionFont` | System title | Subwindows, tool dialogs |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
  zh: '| `TkSmallCaptionFont` | 系统标题字体 | 子窗口、工具对话框 |'
- en: '| `TkTextFont` | System input font | Input widgets: `Entry`, `Spinbox`, and
    so on |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
  zh: '| `TkTextFont` | 系统输入字体 | 输入小部件：`Entry`、`Spinbox`等 |'
- en: '| `TkTooltipFont` | System tooltip font | Tooltips |'
  id: totrans-292
  prefs: []
  type: TYPE_TB
  zh: '| `TkTooltipFont` | 系统工具提示字体 | 工具提示 |'
- en: The `font` module includes a function called `names()` that returns a list of
    the current named fonts on the system, including those that you create yourself
    (by creating `Font` objects). We can use the `font.nametofont()` function to generate
    a `Font` object from a given name.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '`font`模块包含一个名为`names()`的函数，该函数返回系统上当前命名的字体列表，包括您自己创建的字体（通过创建`Font`对象）。我们可以使用`font.nametofont()`函数从一个给定的名称生成一个`Font`对象。'
- en: 'For example, we can create a small program to demonstrate all the named fonts
    included with Tkinter, as follows:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以创建一个小程序来演示Tkinter包含的所有命名字体，如下所示：
- en: '[PRE58]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: In this script, we retrieve a list of all the named fonts using `font.names()`
    and iterate through it. For each name, we create a `Font` object using `font.nametofont()`,
    and then create a label showing the named font name and using the `Font` object
    as its font.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在此脚本中，我们使用`font.names()`检索所有命名字体的列表，并通过它迭代。对于每个名称，我们使用`font.nametofont()`创建一个`Font`对象，然后创建一个显示命名字体名称并使用`Font`对象作为其字体的标签。
- en: This script will show what all the built-in named fonts look like on your system.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本将显示您的系统上所有内置命名字体的外观。
- en: 'For example, on Ubuntu Linux, they look like this:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在Ubuntu Linux上，它们看起来像这样：
- en: '![Figure 9.11: The Tkinter named fonts on Ubuntu Linux](img/B17578_09_11.png)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
  zh: '![图9.11：Ubuntu Linux上的Tkinter命名字体](img/B17578_09_11.png)'
- en: 'Figure 9.11: The Tkinter named fonts on Ubuntu Linux'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.11：Ubuntu Linux上的Tkinter命名字体
- en: Since Tkinter uses its built-in named fonts by default, we can change the overall
    look of the whole application by creating `Font` objects for these default named
    fonts and overriding their properties. The changes we make will get applied across
    all widgets that don't otherwise have an explicit font configuration.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Tkinter默认使用其内置的命名字体，我们可以通过为这些默认命名字体创建`Font`对象并覆盖其属性来改变整个应用程序的整体外观。我们做出的更改将应用于所有没有明确字体配置的小部件。
- en: 'For example, we could add some code to the preceding script, just before `root.mainloop()`,
    to allow us to customize the built-in fonts:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以在前面的脚本中`root.mainloop()`之前添加一些代码，以允许我们自定义内置字体：
- en: '[PRE59]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: In this code, we set up three control variables to hold the named font name,
    family, and size values, and then set up three widgets to select them. The first
    `OptionMenu` widget uses `font.names()` to retrieve a list of all the named fonts,
    and the second uses the `font.families()` function to retrieve a list of the available
    font families on the operating system (this is likely to be a very long list on
    most modern systems). Then we have a `Spinbox` for selecting a font size.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们设置了三个控制变量来保存命名字体名称、字体族和大小值，然后设置了三个小部件来选择它们。第一个`OptionMenu`小部件使用`font.names()`检索所有命名字体的列表，第二个使用`font.families()`函数检索操作系统上可用的字体族列表（在大多数现代系统上这很可能是一个非常长的列表）。然后我们有一个`Spinbox`用于选择字体大小。
- en: The callback function, `setFont()`, creates a font object from the selected
    named font and then configures it with the selected family and size. This function
    is then bound to a button.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 回调函数`setFont()`从所选的命名字体创建一个字体对象，然后使用所选的字体族和大小配置它。然后此函数绑定到一个按钮上。
- en: If you run the script now, you should be able to select any named font and edit
    its family and size. When you click **Change**, you should see the associated
    label change according to your selections. You may also note that changing certain
    named fonts affects your `OptionMenu`, `Spinbox`, and `Button` widgets as well.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 如果现在运行此脚本，您应该能够选择任何命名字体并编辑其字体族和大小。当您点击**更改**时，您应该看到相关的标签根据您的选择而更改。您也可能注意到更改某些命名字体会影响您的`OptionMenu`、`Spinbox`和`Button`小部件。
- en: 'For example, on Ubuntu Linux, it looks like this:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在Ubuntu Linux上，它看起来像这样：
- en: '![Figure 9.12: The named font editor on Ubuntu Linux](img/B17578_09_12.png)'
  id: totrans-308
  prefs: []
  type: TYPE_IMG
  zh: '![图9.12：Ubuntu Linux上的命名字体编辑器](img/B17578_09_12.png)'
- en: 'Figure 9.12: The named font editor on Ubuntu Linux'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.12：Ubuntu Linux上的命名字体编辑器
- en: Giving users font options in ABQ Data Entry
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在ABQ数据输入中为用户提供字体选项
- en: Now that we understand how to work with fonts in Tkinter, let's add the ability
    for our users to configure fonts in the application. We'll allow them to choose
    a size and a font family that will be used for all the widgets and data displayed
    in the application.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何在Tkinter中处理字体，让我们为用户添加在应用程序中配置字体的能力。我们将允许他们选择一个大小和一个字体族，这些大小和字体族将用于应用程序中显示的所有小部件和数据。
- en: 'Since users will want to persist this value between sessions, we should begin
    by adding keys for `font size` and `font family` to our settings model. Open `models.py`
    and append these to the `fields` dictionary, like so:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 由于用户希望在会话之间持久化此值，我们应该首先在我们的设置模型中添加`font size`（字体大小）和`font family`（字体族）的键。打开`models.py`并将这些添加到`fields`字典中，如下所示：
- en: '[PRE60]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: We have set the size default to 9 points, but the family default to a blank
    string. Configuring a font with a blank family value will cause Tkinter to use
    its own default font family.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已将大小默认设置为9点，但字体族默认设置为空字符串。使用空字符串作为字体族值配置字体将导致Tkinter使用其自己的默认字体族。
- en: Recall that the `Application` object will read the `fields` dictionary and set
    up a control variable for each setting, and that a dictionary of these control
    variables will be passed to our `MainMenu` object. So, our next task will be to
    create menu items for setting the size and family values of these variables.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，`Application`对象将读取`fields`字典并为每个设置设置一个控制变量，然后这些控制变量的字典将传递给我们的`MainMenu`对象。因此，我们的下一个任务将是为这些变量的大小和家族值创建菜单项。
- en: 'Open `mainmenu.py` and let''s begin by importing the `font` module:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`mainmenu.py`，让我们首先导入`font`模块：
- en: '[PRE61]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Now, inside the `MainMenu` initializer method, let''s create some sub-menus
    for the `options_menu` cascade:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`MainMenu`初始化方法内部，让我们为`options_menu`级联创建一些子菜单：
- en: '[PRE62]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: This should look familiar, since we created a nearly identical font size menu
    when learning about the Tkinter `Menu` widget in *Chapter 7*, *Creating Menus
    with Menu and Tkinter Dialogs*. We're allowing font sizes from 6 to 16, which
    should provide plenty of range for our users.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该看起来很熟悉，因为我们创建了一个几乎相同的字体大小菜单，在*第7章*中学习Tkinter `Menu`小部件时。我们允许从6到16的字体大小，这应该为用户提供足够的范围。
- en: The font family menu is nearly identical, except we're pulling the list of possible
    values from `font.families()`, just as we did in our demonstration script earlier
    in this chapter.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 字体家族菜单几乎相同，除了我们从`font.families()`中拉取可能的值，就像我们在本章早些时候的演示脚本中所做的那样。
- en: Now that the user can select fonts and store their selection, let's actually
    make those settings change the fonts in the application. To do that, we'll first
    need to add a method to the `Application` class that will read the values and
    alter the appropriate named fonts accordingly.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 现在用户可以选择字体并存储他们的选择，让我们实际上让这些设置更改应用程序中的字体。要做到这一点，我们首先需要在`Application`类中添加一个方法，该方法将读取值并相应地更改适当的命名字体。
- en: 'Open `application.py`; add an import statement for `font` at the top, and then
    let''s add this new `_set_font()` method to the `Application` class:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`application.py`；在顶部添加一个`font`导入语句，然后让我们将这个新的`_set_font()`方法添加到`Application`类中：
- en: '[PRE63]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: This method begins by retrieving the size and family settings from their respective
    control variables. Next, we're going to loop through a tuple of built-in named
    fonts that we want to change. `TkDefaultFont` will change most of the widgets,
    `TkMenuFont` will affect the main menu, `TkTextFont` will change the text-input
    widgets, and `TkFixedFont` will set the default for our `Text` widget.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法首先从各自的控制变量中检索大小和家族设置。接下来，我们将遍历一个包含我们想要更改的内置命名字体的元组。`TkDefaultFont`将更改大多数小部件，`TkMenuFont`将影响主菜单，`TkTextFont`将更改文本输入小部件，而`TkFixedFont`将为我们的`Text`小部件设置默认值。
- en: For each one, we retrieve a `Font` object using `nametofont()` and reconfigure
    it with the values retrieved from `settings`.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每一个，我们使用`nametofont()`检索一个`Font`对象，并使用从`settings`检索的值重新配置它。
- en: 'This method needs to be called after the settings are initially loaded, and
    whenever the size or family values are changed. So, let''s add the following lines
    to the end of `Application._load_settings()`:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法需要在设置最初加载后以及每次更改大小或家族值后调用。因此，让我们将以下行添加到`Application._load_settings()`的末尾：
- en: '[PRE64]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Now, whenever `Application()` creates new settings control variables, it will
    set up the font and add a trace to reconfigure the application fonts whenever
    these values are changed.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每当`Application()`创建新的设置控制变量时，它将设置字体并添加一个跟踪，以便在更改这些值时重新配置应用程序字体。
- en: 'Run the application and try out the font menu. It should look something like
    this:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序并尝试字体菜单。它应该看起来像这样：
- en: '![Figure 9.13: Switching our ABQ Data Entry to Comic Sans](img/B17578_09_13.png)'
  id: totrans-331
  prefs: []
  type: TYPE_IMG
  zh: '![图9.13：将我们的ABQ数据输入切换为Comic Sans](img/B17578_09_13.png)'
- en: 'Figure 9.13: Switching our ABQ Data Entry to Comic Sans'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.13：将我们的ABQ数据输入切换为Comic Sans
- en: Styling Ttk widgets
  id: totrans-333
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ttk小部件的样式
- en: The final user requests we need to address involve the styles and colors of
    our `Ttk` widgets; users have asked for more visual distinction between the form
    sections, and more visibility for error messages.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要解决的最后用户请求涉及我们的`Ttk`小部件的样式和颜色；用户要求在表单部分之间有更多的视觉区分，以及错误消息有更高的可见性。
- en: 'After some thought and discussion, you decide to color-code the sections of
    the form as follows:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 经过一番思考和讨论，你决定按照以下方式对表单部分进行颜色编码：
- en: The Record Information section will use khaki, suggesting the classic manila
    folders used for paper records
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录信息部分将使用米色，暗示用于纸质记录的经典曼尼拉文件夹
- en: The Environment Data section will use light blue, symbolic of water and air
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 环境数据部分将使用浅蓝色，象征着水和空气
- en: The Plant Data will have a light green background, symbolic of plants
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 植物数据将具有浅绿色背景，象征着植物
- en: The Notes input is distinctive enough, so it will remain the same default gray
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 笔记输入足够独特，因此它将保持默认的灰色
- en: To improve the visibility of error messages, we'd like to make the background
    of the fields turn red when they have errors, and the error text itself display
    in a dark red color. To accomplish this, we're going to need to understand how
    to style `Ttk` widgets.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高错误信息的可见性，我们希望当字段有错误时，将其背景变为红色，并将错误文本本身显示为深红色。为了实现这一点，我们需要了解如何样式化 `Ttk` 部件。
- en: TTk styling breakdown
  id: totrans-341
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TTk 样式分解
- en: 'Ttk widgets represent a major improvement over standard Tkinter widgets in
    terms of the power and flexibility with which they can be styled. This flexibility
    is what gives Ttk widgets the ability to mimic native UI controls across platforms,
    but it comes at a cost: Ttk styling is confusing, complicated, poorly documented,
    and occasionally inconsistent.'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: Ttk 部件在样式化方面比标准 Tkinter 部件有了很大的改进，它们可以以更强大和灵活的方式被样式化。这种灵活性使得 Ttk 部件能够模仿跨平台的原生
    UI 控件，但这也带来了一定的代价：Ttk 样式化可能令人困惑、复杂、文档不完善，并且偶尔不一致。
- en: 'To understand Ttk styling, let''s start with some vocabulary, from the most
    basic parts to the most complex:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解 Ttk 样式，让我们从一些词汇开始，从最基本的到最复杂的：
- en: Ttk starts with **elements**. An element is one piece of a widget, such as a
    border, an arrow, or a field where text can be typed.
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ttk 以 **元素** 为起点。一个元素是部件的一部分，例如边框、箭头或可以输入文本的字段。
- en: Each element has a set of **options** that define properties such as color,
    size, and font.
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个元素都有一组 **选项**，定义了颜色、大小和字体等属性。
- en: Elements are composed using **layouts** into a complete widget (a `Combobox`
    or `Treeview`, for example).
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元素是通过 **布局** 组合成完整的部件（例如 `Combobox` 或 `Treeview`）。
- en: '**Styles** are collections of element option settings that are applied to widgets.
    A style is identified by its name. Usually, the name is "T" plus the name of the
    widget, such as `TButton` or `TEntry`, although there are some exceptions to this.'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**样式** 是应用于部件的元素选项设置的集合。一个样式通过其名称来识别。通常，名称是 "T" 加上部件的名称，例如 `TButton` 或 `TEntry`，尽管有一些例外。'
- en: 'Widgets also have a number of **states**, which are flags that can be turned
    on or off:'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部件也有许多 **状态**，这些是可开启或关闭的标志：
- en: Styles can be configured with a **map** that associates element option values
    with states or combinations of states.
  id: totrans-349
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 样式可以通过将元素选项值与状态或状态组合关联的 **映射** 来配置。
- en: A collection of layouts and their associated styles is called a **theme**. Ttk
    comes with a different set of themes on different platforms, and each platform
    has a default that aims to match the look of its native widget set. Because each
    theme may contain elements with different style options, not every option is available,
    nor has the same effect, in every theme. For example, a `ttk.Button` on the default
    macOS theme may contain a different set of elements, applying style settings differently
    compared to a `ttk.Button` using the default theme in Windows.
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一组布局及其相关样式被称为 **主题**。Ttk 在不同平台上提供不同的主题集，每个平台都有一个旨在匹配其原生部件集外观的默认主题。由于每个主题可能包含具有不同样式选项的元素，因此并非每个选项都可用，也不是每个主题都有相同的效果。例如，默认
    macOS 主题中的 `ttk.Button` 可能包含不同的元素集，与在 Windows 中使用默认主题的 `ttk.Button` 应用样式设置的方式不同。
- en: If you're confused at this point, that's understandable. To make things clearer,
    let's take a deep dive into the anatomy of a `ttk.Combobox`.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你此时感到困惑，这是可以理解的。为了使事情更清晰，让我们深入探讨 `ttk.Combobox` 的结构。
- en: Exploring a Ttk widget
  id: totrans-352
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 探索 Ttk 部件
- en: 'To get a better picture of how a Ttk widget is built, open a shell in IDLE
    and import `tkinter`, `ttk`, and `pprint`:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地了解 Ttk 部件的构建方式，请在 IDLE 中打开一个 shell 并导入 `tkinter`、`ttk` 和 `pprint`：
- en: '[PRE65]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Now, create a `root` window, `Combobox`, and `Style` object:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，创建一个 `root` 窗口、`Combobox` 和 `Style` 对象：
- en: '[PRE66]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The `Style` object is, perhaps, slightly misnamed; it doesn't point to a single
    *style*, but rather gives us a point of access to examine and alter the styles,
    layouts, and maps for the current *theme*.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '`Style` 对象可能被略微误命名；它并不指向单个 *样式*，而是为我们提供了一个访问点，以检查和修改当前 *主题* 的样式、布局和映射。'
- en: 'In order to examine our `Combobox`, we''ll first get its style name using the
    `winfo_class()` method:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检查我们的 `Combobox`，我们首先使用 `winfo_class()` 方法获取其样式名称：
- en: '[PRE67]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: As expected, the name is `TCombobox`, which is just `T` plus the widget name.
    We can use this name to find out more about this `Combobox` widget.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期，名称是 `TCombobox`，这仅仅是 `T` 加上小部件名称。我们可以使用这个名称来了解更多关于这个 `Combobox` 小部件的信息。
- en: 'For example, we can examine its layout by passing the name to the `Style.layout()`
    method, as follows:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以通过将名称传递给 `Style.layout()` 方法来检查其布局，如下所示：
- en: '[PRE68]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Note that the output of `layout()` may be different on your system, as the layout
    contents depend on the theme. Different operating systems use a different default
    theme.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`layout()` 的输出可能因你的系统而异，因为布局内容取决于主题。不同的操作系统使用不同的默认主题。
- en: The returned layout specification shows the hierarchy of elements used to construct
    this widget. The elements, in this case, are `"Combobox.field"`, `"Combobox.downarrow"`,
    `"Combobox.padding"`, and `"Combobox.textarea"`. As you can see, each element
    has associated positioning properties similar to what you'd pass into a geometry
    manager method.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的布局规范显示了构建此小部件所使用的元素层次结构。在这种情况下，元素是 `"Combobox.field"`、`"Combobox.downarrow"`、`"Combobox.padding"`
    和 `"Combobox.textarea"`。正如你所看到的，每个元素都有与几何管理器方法中传递的类似的位置属性。
- en: The `layout()` method can also be used to replace a style's layout by passing
    in a new specification as a second argument. Unfortunately, since styles are built
    using immutable tuples, this requires replacing the *entire* layout specification
    – you can't just adjust or replace a single element in place.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '`layout()` 方法也可以通过传入一个新的规范作为第二个参数来替换一个样式的布局。不幸的是，由于样式是使用不可变的元组构建的，这需要替换整个布局规范——你无法仅仅调整或替换单个元素。'
- en: To see what options are available for the elements in this layout, we can use
    the `style.element_options()` method. This method takes an element name and returns
    a list of options that can be used to alter it.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看此布局中元素可用的选项，我们可以使用 `style.element_options()` 方法。此方法接受一个元素名称，并返回一个可以用来更改它的选项列表。
- en: 'For example:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE69]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Once again, this list may be different (or even empty) depending on your operating
    system and theme settings.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 一次又一次，这个列表可能因你的操作系统和主题设置而不同（甚至可能是空的）。
- en: This tells us that the `downarrow` element of the `Combobox` widget offers the
    `background`, `relief`, `borderwidth`, `arrowcolor`, and `arrowsize` style properties
    to adjust its appearance. To change these properties, we can use the `style.configure()`
    method.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉我们 `Combobox` 小部件的 `downarrow` 元素提供了 `background`、`relief`、`borderwidth`、`arrowcolor`
    和 `arrowsize` 样式属性来调整其外观。要更改这些属性，我们可以使用 `style.configure()` 方法。
- en: 'For instance, let''s change the color of the arrow to red:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们将箭头的颜色改为红色：
- en: '[PRE70]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: If your operating system doesn't support the `arrowcolor` option, feel free
    to try a different option or switch to the alt theme. See the next section on
    how to switch themes.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的操作系统不支持 `arrowcolor` 选项，请随意尝试不同的选项或切换到 alt 主题。下一节将介绍如何切换主题。
- en: You should see that the arrow's color has changed to red. This is all we need
    to know to configure widgets for static changes, but what about dynamic changes,
    such as when an input is disabled or invalid?
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到箭头的颜色已变为红色。这就是我们为了配置静态更改所需的全部信息，但关于动态更改，比如当输入被禁用或无效时怎么办？
- en: 'To make dynamic changes, we''ll need to work with our widget''s state and map.
    We can inspect or alter the state of our `Combobox` using the `state()` method,
    like so:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 要进行动态更改，我们需要处理我们的小部件状态和映射。我们可以使用 `state()` 方法检查或更改 `Combobox` 的状态，如下所示：
- en: '[PRE71]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '`state()` with no arguments will return a tuple with the currently set state
    flags; as you can see, the `Combobox` widget had no state flags by default. We
    can also set the state by passing in a sequence of strings, like so:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '`state()` 不带参数将返回一个包含当前设置的状态标志的元组；正如你所看到的，`Combobox` 小部件默认没有状态标志。我们也可以通过传递一个字符串序列来设置状态，如下所示：'
- en: '[PRE72]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Notice that in order to turn off a state flag, we prefix the flag name with
    a `!`. When you call `state()` with an argument to change the value, the return
    value is a tuple containing a set of states (or negated states) that would, if
    applied, *undo the state change you just set*. So, in this case, when we passed
    in the list that turned on `active` and `invalid`, the method returned a tuple
    that would turn these states off again. Likewise, when we passed in the negated
    `invalid` state, we got back a tuple containing `invalid`. This might be useful
    in a situation where you want to temporarily set a widget's state and then return
    it to its previous (possibly unknown) state.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，为了关闭状态标志，我们需要在标志名称前加上一个 `!`。当你使用参数调用 `state()` 来更改值时，返回值是一个包含一组状态（或否定状态）的元组，如果应用这些状态，将*撤销你刚刚设置的状态改变*。因此，在这种情况下，当我们传入使
    `active` 和 `invalid` 状态开启的列表时，该方法返回一个将再次关闭这些状态的元组。同样，当我们传入否定 `invalid` 状态时，我们得到了包含
    `invalid` 的元组。这可能在你想暂时设置小部件的状态然后返回到其之前（可能是未知）的状态的情况下很有用。
- en: 'You can''t just use any arbitrary strings for `state()`; they must be one of
    the supported values, listed here in this table:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能为 `state()` 使用任何任意的字符串；它们必须是支持值之一，如下表所示：
- en: '| State | Indicates |'
  id: totrans-381
  prefs: []
  type: TYPE_TB
  zh: '| 状态 | 表示 |'
- en: '| `active` | Widget element is being hovered on by the mouse |'
  id: totrans-382
  prefs: []
  type: TYPE_TB
  zh: '| `active` | 小部件元素正被鼠标悬停 |'
- en: '| `disabled` | Interaction with the widget is turned off |'
  id: totrans-383
  prefs: []
  type: TYPE_TB
  zh: '| `disabled` | 小部件的交互被关闭 |'
- en: '| `focus` | Widget will receive keyboard events |'
  id: totrans-384
  prefs: []
  type: TYPE_TB
  zh: '| `focus` | 小部件将接收键盘事件 |'
- en: '| `pressed` | Widget is currently being clicked on |'
  id: totrans-385
  prefs: []
  type: TYPE_TB
  zh: '| `pressed` | 小部件当前正在被点击 |'
- en: '| `selected` | Widget has been selected by the user (for example, a radio button)
    |'
  id: totrans-386
  prefs: []
  type: TYPE_TB
  zh: '| `selected` | 小部件已被用户选中（例如，单选按钮） |'
- en: '| `background` | Widget is on a window that is not the foreground window |'
  id: totrans-387
  prefs: []
  type: TYPE_TB
  zh: '| `background` | 小部件位于非前景窗口的窗口上 |'
- en: '| `readonly` | Widget will not allow modification |'
  id: totrans-388
  prefs: []
  type: TYPE_TB
  zh: '| `readonly` | 小部件不允许修改 |'
- en: '| `alternate` | Different things, depending on the widget |'
  id: totrans-389
  prefs: []
  type: TYPE_TB
  zh: '| `alternate` | 根据小部件的不同，有不同的效果 |'
- en: '| `invalid` | Widget contains invalid data (that is, the validate command has
    returned `False`) |'
  id: totrans-390
  prefs: []
  type: TYPE_TB
  zh: '| `invalid` | 小部件包含无效数据（即验证命令返回 `False`） |'
- en: '| `hover` | Like `active`, but referring to the whole widget rather than an
    element |'
  id: totrans-391
  prefs: []
  type: TYPE_TB
  zh: '| `hover` | 与 `active` 类似，但指的是整个小部件而不是一个元素 |'
- en: Exactly how different widgets use each of these states depends on the widget
    and the theme; not every state is configured by default to have an effect on every
    widget. For example, `readonly` has no effect on a `Label` widget, since it is
    not editable to begin with.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 小部件如何使用这些状态中的每一个取决于小部件和主题；并非每个状态都默认配置为对每个小部件都有影响。例如，`readonly` 对 `Label` 小部件没有影响，因为它一开始就是不可编辑的。
- en: Widget states interact with the theme's widget style through the use of a **style
    map**. We can use the `style.map()` method to inspect or set the map for each
    style.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 小部件状态通过使用**样式映射**与主题的小部件样式交互。我们可以使用 `style.map()` 方法检查或设置每个样式的映射。
- en: 'Take a look at the default map for `TCombobox`:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 看看 `TCombobox` 的默认映射：
- en: '[PRE73]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: As you can see, `TCombobox` has style maps for the `arrowcolor` and `fieldbackground`
    options by default. Each style map is a list of tuples, and each tuple is one
    or more state flags followed by a value for the element option. When all of the
    state flags match the current state of the widget, the value (that is, the last
    string in the tuple) takes effect.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`TCombobox` 默认为 `arrowcolor` 和 `fieldbackground` 选项提供了样式映射。每个样式映射是一个元组的列表，每个元组是一个或多个状态标志后面跟着元素选项的值。当所有状态标志与当前小部件的状态匹配时，该值（即元组中的最后一个字符串）生效。
- en: The default map turns the arrow color to a light gray color when the `disabled`
    flag is set, and turns the field background to a different light gray color when
    either the `disabled` or `readonly` flags are set.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 默认映射在设置 `disabled` 标志时将箭头颜色转换为浅灰色，当设置 `disabled` 或 `readonly` 标志时，将字段背景转换为不同的浅灰色。
- en: 'We can set our own style mapping using the same method:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用相同的方法设置自己的样式映射：
- en: '[PRE74]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Here, we've configured the `arrowcolor` property to be `blue` when the invalid
    flag is not set, and `red` when both the `invalid` and `focus` flags are set.
    Notice that while our call to `map()` completely overwrote the `arrowcolor` style
    map, the `fieldbackground` map was unaffected. You can replace style mappings
    individually for each option without affecting other options, though whatever
    mapping you do specify for the option overwrites the whole mapping for that option.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们已将 `arrowcolor` 属性配置为在未设置无效标志时为 `blue`，在同时设置了 `invalid` 和 `focus` 标志时为
    `red`。请注意，虽然我们的 `map()` 调用完全覆盖了 `arrowcolor` 样式映射，但 `fieldbackground` 映射未受到影响。您可以单独替换每个选项的样式映射，而不会影响其他选项，尽管您为该选项指定的任何映射都会覆盖该选项的整个映射。
- en: So far, we've been operating on the `TCombobox` style, which is the default
    style for all `Combobox` widgets. Any changes we made would impact every `Combobox`
    widget in the application. What if we only want to change a particular widget,
    or a particular set of widgets? We can do this by creating **custom styles**.
    Custom styles must be derived from the existing style by prefixing a name and
    a dot to an existing style name.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在操作 `TCombobox` 样式，这是所有 `Combobox` 小部件的默认样式。我们所做的任何更改都会影响应用程序中的每个
    `Combobox` 小部件。如果我们只想更改特定的小部件或特定的一组小部件，我们应该怎么办？我们可以通过创建 **自定义样式** 来做到这一点。自定义样式必须通过在现有样式名称前添加一个名称和一个点来从现有样式派生。
- en: 'For example:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE75]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '`Blue.TCombobox` inherits all of the properties of `TCombobox` (including the
    dynamically colored down arrow we previously configured), but can add or override
    them with settings of its own that won''t affect `TCombobox`. This allows you
    to create custom styles for some widgets without affecting other widgets of the
    same type.'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '`Blue.TCombobox` 继承了 `TCombobox` 的所有属性（包括我们之前配置的动态着色向下箭头），但可以通过自己的设置添加或覆盖它们，而不会影响
    `TCombobox`。这允许您为某些小部件创建自定义样式，而不会影响相同类型的其他小部件。'
- en: We can even customize our custom styles by adding more prefixes; for example,
    the style `MyCB.Blue.TCombobox` would inherit all the styles of `TCombobox` and
    `Blue.TCombobox`, along with whatever additional settings we wanted to add or
    override in it.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以通过添加更多前缀来自定义我们的自定义样式；例如，样式 `MyCB.Blue.TCombobox` 将继承 `TCombobox` 和 `Blue.TCombobox`
    的所有样式，以及我们想要添加或覆盖的任何额外设置。
- en: Using themes
  id: totrans-406
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用主题
- en: We can alter the look of all the Ttk widgets in our application at once by changing
    the theme. Remember that a theme is a collection of styles *and layouts*; so changing
    a theme doesn't just change the appearance, it may also change the available styling
    options as well.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过更改主题来一次性改变应用中所有 Ttk 小部件的外观。请记住，主题是一组样式和布局的集合；因此，更改主题不仅会改变外观，还可能改变可用的样式选项。
- en: 'Ttk comes with a different set of themes on each OS platform; to see the themes
    available on your platform, use the `Style.theme_names()` method:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: Ttk 在每个操作系统平台上都提供了一组不同的主题；要查看您平台上的主题，请使用 `Style.theme_names()` 方法：
- en: '[PRE76]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: (These are the themes available on Debian Linux; yours may differ.)
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: （以下是在 Debian Linux 上可用的主题；您的可能不同。）
- en: 'To query the current theme, or to set a new theme, use the `Style.theme_use()`
    method:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 要查询当前主题或设置新主题，请使用 `Style.theme_use()` 方法：
- en: '[PRE77]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: With no arguments, the method returns the name of the current theme. With an
    argument, it sets the theme to the given theme name. Notice how the previous styling
    is gone when you change the theme. If you switch back to the default, however,
    you'll see that your changes were retained. That's because any changes we make
    using `Style.configure()` *only affect the currently running theme*.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有参数，该方法将返回当前主题的名称。如果有参数，它将主题设置为给定的主题名称。注意，当您更改主题时，之前的样式将消失。但是，如果您切换回默认主题，您会看到您的更改被保留了。这是因为我们使用
    `Style.configure()` 方法所做的任何更改仅影响当前正在运行的主题。
- en: Adding some color to ABQ Data Entry
  id: totrans-414
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为 ABQ 数据输入添加一些颜色
- en: Now that you have a firmer grasp of Ttk themes and styling, let's add some color
    to our data entry form. To begin, we will set a different background color for
    each `LabelFrame` widget in the data record form. Since we want to configure three
    widgets of the same type differently, we'll need to use custom styles. For each
    frame, we will create a custom style, configure it with the proper color, and
    then assign it to the frame.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经对 Ttk 主题和样式有了更深入的了解，让我们给我们的数据输入表单添加一些颜色。首先，我们将为数据记录表单中的每个 `LabelFrame`
    小部件设置不同的背景颜色。由于我们希望配置三个相同类型的小部件，我们将需要使用自定义样式。对于每个框架，我们将创建一个自定义样式，用适当的颜色配置它，然后将它分配给框架。
- en: 'Start by opening `views.py` and let''s add the following code to the `DataRecordForm`
    initializer method:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 首先打开`views.py`，让我们将以下代码添加到`DataRecordForm`初始化方法中：
- en: '[PRE78]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: We begin by creating a `Style` object, which we can use to access and modify
    the widget styles. We then use the `style.configure()` method to set up three
    custom styles based on `TLabelframe`, the default style for Ttk `Labelframe` widgets.
    We've set the colors according to our plan, and also added some padding to the
    style.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个`Style`对象，我们可以使用它来访问和修改小部件样式。然后我们使用`style.configure()`方法设置基于`TLabelframe`的三个自定义样式，这是Ttk
    `Labelframe`小部件的默认样式。我们已经根据我们的计划设置了颜色，并且还添加了一些样式填充。
- en: 'Now, we need to assign these styles to each frame. Remember that our `LabelFrame`
    widgets are being created in an instance method called `_add_frame()`. We''ll
    need to update this method to take a `style` argument that we can pass to the
    widget. Update the method as follows:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要将这些样式分配给每个框架。记住，我们的`LabelFrame`小部件是在一个名为`_add_frame()`的实例方法中创建的。我们需要更新这个方法，使其接受一个`style`参数，我们可以将其传递给小部件。按照以下方式更新方法：
- en: '[PRE79]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'In this version, we take a string for the style, and if one is passed, we''ll
    configure our `LabelFrame` widget to use it. Now, let''s update our calls to `_add_frame()`
    in the initializer to pass in the custom styles we''ve created, like so:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个版本中，我们接受一个字符串作为样式，如果传递了一个样式，我们将配置我们的`LabelFrame`小部件来使用它。现在，让我们更新初始化器中的`_add_frame()`调用，传入我们创建的自定义样式，如下所示：
- en: '[PRE80]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Now, execute the application and let''s take a look at the form. It should
    look something like this:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，执行应用程序，让我们看看表单。它应该看起来像这样：
- en: '![Figure 9.14: Our first attempt at coloring our record form frames](img/B17578_09_14.png)'
  id: totrans-424
  prefs: []
  type: TYPE_IMG
  zh: '![图9.14：我们尝试为记录表单框架着色的第一次尝试](img/B17578_09_14.png)'
- en: 'Figure 9.14: Our first attempt at coloring our record form frames'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.14：我们尝试为记录表单框架着色的第一次尝试
- en: As you can see, that's far from ideal. While there is a small amount of color
    peeking out from behind the widgets, the widgets in each section are still the
    default drab color, and even the label portion of the `LabelFrame` widgets is
    still gray. Styles do *not* propagate to child widgets, so we're going to have
    to set each widget individually to get the full effect.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这远远不是理想的。虽然有一些颜色从小部件后面透出，但每个部分的小部件仍然是默认的灰暗颜色，甚至`LabelFrame`小部件的标签部分仍然是灰色。样式不会传播到子小部件，因此我们需要单独设置每个小部件以获得完整效果。
- en: Adding styles to individual form widgets
  id: totrans-427
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为单个表单小部件添加样式
- en: 'The first thing we can quickly fix is the label portion of each `LabelFrame`
    widget. Although each widget has been assigned to the custom style, the label
    element of the widget needs to be explicitly styled. We can do that merely by
    adding the following code to the `DataRecordForm` initializer:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以迅速修复的第一件事是每个`LabelFrame`小部件的标签部分。尽管每个小部件都已分配到自定义样式，但小部件的标签元素需要显式地设置样式。我们可以通过将以下代码添加到`DataRecordForm`初始化器中来实现这一点：
- en: '[PRE81]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: This is exactly the same thing we did to create the custom `TLabelframe` styles,
    except that we have added the name of the individual element we want to style
    (in this case, `Label`). If you run the program again, you'll see now that each
    frame's label also shares the background color of the frame. We're still not finished
    though, because we need all our widget labels to show the background color of
    the frame.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是我们创建自定义`TLabelframe`样式的相同方法，只不过我们添加了想要样式的单个元素名称（在这种情况下，`Label`）。如果你再次运行程序，你会看到现在每个框架的标签也共享框架的背景颜色。但我们还没有完成，因为我们需要所有的小部件标签都显示框架的背景颜色。
- en: 'Let''s consider which widgets we need to create a custom style for:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑我们需要为哪些小部件创建自定义样式：
- en: We need a style for the `Label` widgets for each section, since we'll need different
    colors for these widgets in Record Information, Environment Data, and Plant Data.
  id: totrans-432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要为每个部分的`Label`小部件设置样式，因为我们将在记录信息、环境数据和植物数据中为这些小部件使用不同的颜色。
- en: We'll need to style our `Checkbutton`, since it uses its own built-in label
    rather than a separate label widget. Since there's only one right now, we only
    need one style for it.
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要为我们的`Checkbutton`设置样式，因为它使用的是其内置的标签而不是单独的标签小部件。由于目前只有一个，我们只需要为它设置一个样式。
- en: We'll need to style the `Radiobutton` widgets, since they also use a built-in
    label. We only need one style, though, since they also appear in only one form
    section.
  id: totrans-434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要为`Radiobutton`小部件设置样式，因为它们也使用内置的标签。尽管如此，我们只需要一个样式，因为它们也只出现在一个表单部分中。
- en: 'Let''s create those styles:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建这些样式：
- en: '[PRE82]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Now that we've created the styles, we need to add them to each widget in the
    form. Remember that the `LabelInput` initializer takes a `label_args` dictionary
    for keywords that need to be passed to its `Label` widget, so we'll need to add
    the label styles there.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了样式，我们需要将它们添加到表单中的每个小部件上。记住，`LabelInput`初始化器接受一个`label_args`字典，用于传递给其`Label`小部件的关键字参数，因此我们需要在那里添加标签样式。
- en: 'For example, here''s what the first line should look like:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，第一行应该看起来像这样：
- en: '[PRE83]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'For the `Lab` input, remember that we''re using our `ValidatedRadioGroup` widget,
    which takes a `button_args` dictionary for arguments that need to be passed to
    the radio buttons. We will have to specify both a `label_args` argument and an
    `input_args` argument to get our styles set on these widgets, like so:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`Lab`输入，记住我们正在使用我们的`ValidatedRadioGroup`小部件，它接受一个`button_args`字典，用于传递给单选按钮的参数。我们将必须指定一个`label_args`参数和一个`input_args`参数，以便在这些小部件上设置我们的样式，如下所示：
- en: '[PRE84]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Continue adding these styles to the rest of the `LabelInput` widgets; if you
    get stuck, refer to the code example included with the book. When you''re finished,
    the application should look like this:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 继续将这些样式添加到其余的`LabelInput`小部件中；如果你遇到了困难，请参考书中包含的代码示例。当你完成时，应用程序应该看起来像这样：
- en: '![Figure 9.15: The application with colored labels](img/B17578_09_15.png)'
  id: totrans-443
  prefs: []
  type: TYPE_IMG
  zh: '![图9.15：带有彩色标签的应用程序](img/B17578_09_15.png)'
- en: 'Figure 9.15: The application with colored labels'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.15：带有彩色标签的应用程序
- en: This is a marked improvement, but it's not quite there yet; the error labels
    are still the old, default color. Let's address that next.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个显著的改进，但还不是完全到位；错误标签仍然是旧的默认颜色。让我们接下来解决这一点。
- en: Fixing the error colors
  id: totrans-446
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修复错误颜色
- en: 'To fix the error labels, we need to edit our `LabelInput` widget so that, when
    it creates the `Label` widget for the error, it uses the style value passed in
    with the `label_args` dictionary. However, we have a complication: we want to
    make our error text dark red. How can we honor the background color of the style
    passed in, but also customize the foreground just for this widget?'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 要修复错误标签，我们需要编辑我们的`LabelInput`小部件，使其在创建错误标签的`Label`小部件时，使用通过`label_args`字典传入的样式值。然而，我们遇到了一个复杂的问题：我们希望将错误文本设置为深红色。我们如何尊重传入样式的背景色，同时只为这个小部件定制前景色？
- en: The answer is that we can further prefix our custom style to create a new style
    that inherits all the traits of the custom, while adding or overriding its own.
    In other words, if we were to create a style called `Error.RecordInfo.TLabel`,
    it would inherit all the properties of `RecordInfo.TLabel` but allow us to make
    additional changes.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是我们可以进一步给我们的自定义样式添加前缀，以创建一个新的样式，它继承所有自定义的属性，同时添加或覆盖其自身的属性。换句话说，如果我们创建一个名为`Error.RecordInfo.TLabel`的样式，它将继承`RecordInfo.TLabel`的所有属性，同时允许我们进行额外的更改。
- en: 'Open the `widgets.py` file, and let''s see if we can implement this in the
    `LabelInput` initializer method:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`widgets.py`文件，让我们看看我们是否可以在`LabelInput`初始化方法中实现这一点：
- en: '[PRE85]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: In this code, we've extracted the `style` value from the `label_args` dictionary,
    defaulting to `TLabel` if no style was passed. Then, we create a new style name
    by prefixing the given style with `Error.` (note the dot, that's important!).
    Then, we call `Style.configure()` to set the text color of our new style to a
    dark red. Note that we don't give the `Style` object a name here; since we're
    only making one change, it's OK to just call `configure()` directly on the created
    object and then let the object get thrown away.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们从`label_args`字典中提取了`style`值，如果没有传入样式，则默认为`TLabel`。然后，我们通过在给定的样式前加上`Error.`（注意点，这很重要！）来创建一个新的样式名称。然后，我们调用`Style.configure()`来设置我们新样式的文本颜色为深红色。请注意，我们没有给`Style`对象命名；因为我们只做了一次更改，所以可以直接在创建的对象上调用`configure()`，然后让对象被丢弃。
- en: Now, you should see that the error display widgets match the color of your background,
    but also display in dark red.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该看到错误显示小部件与背景色相匹配，但同时也以深红色显示。
- en: Styling input widgets on error
  id: totrans-453
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在错误时对输入小部件进行样式化
- en: Setting the error text to dark red is a minor improvement on the error visibility
    issue, but for our color-blind users in particular, the improvement is subtle
    at best, if it's even noticeable. We can use our knowledge of styling to take
    things a bit farther, though. Rather than just changing the color of the text,
    let's invert the colors of the input so that we have light text on a dark background.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 将错误文本设置为深红色是对错误可见性问题的微小改进，但对于我们的色盲用户来说，这种改进至多只是微妙的，如果甚至能注意到的话。然而，我们可以利用我们对样式的知识来更进一步。而不仅仅是改变文字的颜色，让我们将输入的颜色反转，这样我们就有浅色文字在深色背景上。
- en: To do this, we will want to update the `ValidatedMixin` class. Recall that we
    previously implemented a `_toggle_error()` method that sets the foreground color
    to red when the widget is invalid on focus-out. We could update that command to
    apply a different style to the widget instead, so that the background color would
    change as well. However, there's a better way.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们需要更新`ValidatedMixin`类。回想一下，我们之前实现了一个`_toggle_error()`方法，当控件在失去焦点时无效时，它会将前景颜色设置为红色。我们可以更新该命令以应用不同的样式到控件上，这样背景颜色也会改变。然而，有一个更好的方法。
- en: Earlier in this chapter, we learned that widgets get flagged with an `invalid`
    state when validation fails, and that Ttk styles can have colors and other properties
    tied to different widget states by means of a style map. Rather than explicitly
    changing styles or colors when validation fails, we can create a style map that
    changes colors automatically in response to a failed validation.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的早期，我们了解到当验证失败时，小部件会被标记为`无效`状态，并且 Ttk 样式可以通过样式映射将颜色和其他属性与不同的控件状态相关联。我们不需要在验证失败时明确更改样式或颜色，而是可以创建一个样式映射，在验证失败时自动更改颜色。
- en: 'To begin, go ahead and remove any calls to `self._toggle_error()` in the `ValidatedMixin`
    class, which can be found in the `_validate()` method and the `_focusout_invalid()`
    method. That will leave the `_focusout_invalid()` method empty, so replace it
    with `pass`, like so:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，请从`ValidatedMixin`类中删除对`self._toggle_error()`的所有调用，该类可以在`_validate()`方法和`_focusout_invalid()`方法中找到。这将使`_focusout_invalid()`方法为空，因此用`pass`替换它：
- en: '[PRE86]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Although the method now does nothing, we're leaving it in place because it's
    part of the mixin class's API that child classes can override. You can actually
    delete the `_toggle_error()` method, however, since its functionality will be
    handled by a style map.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个方法现在什么也不做，但我们保留它，因为它混合类 API 的一部分，子类可以覆盖它。实际上，你可以删除`_toggle_error()`方法，因为它的功能将由样式映射处理。
- en: 'Now, in the initializer, let''s configure a style and style map for our widget:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在初始化器中，让我们为我们的控件配置一个样式和样式映射：
- en: '[PRE87]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Since this is a mixin class, we don''t know the original style name of the
    widget we''re mixing with, so we''ve fetched that using the `winfo_class()` method.
    After getting the widget class, we''re creating a custom style by prefixing the
    class with `ValidatedInput`. Then, we call `style.map()` to configure the foreground
    and background colors of this style in both invalid and not-invalid states: an
    `invalid` state will cause the widget to have white text on dark red background,
    and a `!invalid` state (that is, if the widget doesn''t have an invalid flag)
    black on white. Finally, we apply the style to the widget using `self.configure()`.'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个混合类，我们不知道我们要混合的控件的原生样式名称，所以我们使用`winfo_class()`方法获取它。在获取控件类之后，我们通过在类名前添加`ValidatedInput`来创建一个自定义样式。然后，我们调用`style.map()`来配置此样式在无效和非无效状态下的前景和背景颜色：`无效`状态将使控件在深红色背景上显示白色文字，而`!invalid`状态（即，如果控件没有无效标志）则是黑色文字在白色背景上。最后，我们使用`self.configure()`将样式应用到控件上。
- en: 'If you try the application now, you might see that fields with errors now turn
    a dark red color with white text:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在尝试这个应用程序，你可能会看到现在带有错误的字段变成了深红色，文字为白色：
- en: '![Figure 9.16: Our new validation styles at work](img/B17578_09_16.png)'
  id: totrans-464
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.16：我们新的验证样式在工作](img/B17578_09_16.png)'
- en: 'Figure 9.16: Our new validation styles at work'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.16：我们新的验证样式在工作
- en: That is to say, you will see this on Linux or macOS; on Microsoft Windows, the
    field background will remain unchanged. What's going on here?
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，你将在 Linux 或 macOS 上看到这种情况；在 Microsoft Windows 上，字段背景将保持不变。这里发生了什么？
- en: Remember that from our earlier discussion in *Exploring a Ttk widget*, each
    platform comes with its own set of distinct themes, and each theme defines a unique
    layout for its widgets. These layouts define the individual elements of each widget
    and what properties can be defined for them. That means that some style properties
    might work on one theme, but not on another.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，根据我们在*探索Ttk小部件*中的早期讨论，每个平台都自带一组独特的主题，每个主题为其小部件定义了独特的布局。这些布局定义了每个小部件的各个元素以及可以为其定义的属性。这意味着某些样式属性可能在某个主题上有效，但在另一个主题上则无效。
- en: In this case, the default Ttk theme for Windows (the `vista` theme) does not
    allow the background color of our input widgets to be altered. Our target users
    for ABQ Data Entry are on Debian Linux, so this won't impact them. But it would
    be nice if we could see this feature working on other platforms.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 在此情况下，Windows的默认Ttk主题（`vista`主题）不允许更改我们输入小部件的背景颜色。我们的目标用户是Debian Linux上的ABQ数据输入，因此这不会影响他们。但如果我们能在其他平台上看到这个功能工作，那将很棒。
- en: Setting themes
  id: totrans-469
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置主题
- en: Generally speaking, the default Ttk theme on any given platform is probably
    the best one to use on that platform, but looks are subjective and sometimes we
    might feel that Tkinter gets it wrong. And sometimes, as we saw in the previous
    section, features we require for an application may not work in the default theme.
    Having a way to switch the theme might help to smooth out some rough edges and
    make some users feel more comfortable with the look of the application.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 一般而言，任何给定平台的默认Ttk主题可能是该平台上最好的选择，但外观是主观的，有时我们可能会觉得Tkinter处理得不对。有时，就像我们在上一节中看到的那样，我们可能需要的某些功能在默认主题中可能不起作用。有一种方法可以切换主题可能会帮助平滑一些粗糙的边缘，并让一些用户对应用程序的外观感到更加舒适。
- en: As we've already seen, querying available themes and setting a new theme is
    fairly simple. Let's create a configuration option to change the theme of our
    application.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经看到的，查询可用主题和设置新主题相当简单。让我们创建一个配置选项来更改应用程序的主题。
- en: Building a theme selector
  id: totrans-472
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建主题选择器
- en: Themes aren't something users are going to need to change often, and as we've
    seen, changing the theme can undo style changes we've made to our widgets. In
    light of this, we'll play it safe by designing our theme changer in such a way
    that it requires a restart of the program to make the actual change.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 主题通常不是用户需要经常更改的内容，正如我们所见，更改主题可能会撤销我们对小部件所做的样式更改。鉴于这一点，我们将通过设计一个需要重启程序才能实际更改主题的主题更改器来确保安全。
- en: 'We''ll start by adding a `theme` option to our `SettingsModel` class''s `fields`
    dictionary:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先在我们的`SettingsModel`类的`fields`字典中添加一个`theme`选项：
- en: '[PRE88]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Every platform has a theme aliased to `default`, so this is a safe and sensible
    default value.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 每个平台都有一个主题别名为`default`，因此这是一个安全和合理的默认值。
- en: 'Next, our `Application` object will need to check this value when the settings
    are loaded and apply it. Add this code to the end of the `Application._load_settings()`
    method:'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们的`Application`对象需要在设置加载时检查此值并应用它。将以下代码添加到`Application._load_settings()`方法的末尾：
- en: '[PRE89]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: This code will create a `Style` object, retrieve the theme, and then set the
    theme using the `theme_use()` method. If we should happen to give Tkinter a theme
    that doesn't exist, it will raise a `TCLError` exception; to avoid this, we have
    added an `if` statement to make sure the given theme is in the list returned by
    `theme_names()`.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码将创建一个`Style`对象，检索主题，然后使用`theme_use()`方法设置主题。如果我们给Tkinter一个不存在的主题，它将引发`TCLError`异常；为了避免这种情况，我们添加了一个`if`语句来确保给定的主题在`theme_names()`返回的列表中。
- en: What remains now is to create the UI elements required. As we did with our font
    options, we will add a sub-menu to our `Options` menu for selecting a theme.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 现在剩下的是创建所需的UI元素。就像我们处理字体选项一样，我们将为选择主题添加一个子菜单到我们的`Options`菜单中。
- en: 'To do this, open `mainmenu.py` and add an import statement for `ttk` at the
    top. Then, add the following code to the initializer method just after the font
    menus:'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，请打开`mainmenu.py`并在顶部添加对`ttk`的导入语句。然后，在字体菜单之后初始化方法中添加以下代码：
- en: '[PRE90]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Here, as we did with our font settings, we simply loop through the available
    themes retrieved from `theme_names()` and add a `Radiobutton` item for each theme,
    tying it to our `settings['theme']` variable.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，就像我们处理字体设置一样，我们只需遍历从`theme_names()`检索到的可用主题，并为每个主题添加一个`Radiobutton`项，将其绑定到我们的`settings['theme']`变量。
- en: It may not be obvious to users that changing the theme requires a restart, so
    let's make sure to let them know.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 对于用户来说，可能不明显的是更改主题需要重启，所以让我们确保让他们知道这一点。
- en: 'We can do that using a variable trace, like so:'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用变量跟踪来实现这一点，如下所示：
- en: '[PRE91]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Whenever the theme is changed, this trace will call the `self._on_theme_change()`
    method; let''s add this method to the end of the `MainMenu` class:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 每当主题更改时，此跟踪将调用`self._on_theme_change()`方法；让我们将此方法添加到`MainMenu`类的末尾：
- en: '[PRE92]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Note that we don't actually take any action here to change the theme; this method
    simply displays the warning message box and nothing else. The actual change to
    the setting is handled by the control variable bound to the menu checkboxes, so
    we don't really need to explicitly do anything. Also, because this method doesn't
    require access to the instance or class, we've made it a static method.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们实际上并没有采取任何行动来更改主题；此方法仅显示警告消息框，没有其他操作。实际的设置更改由绑定到菜单复选框的控制变量处理，所以我们实际上不需要明确地做任何事情。此外，因为这个方法不需要访问实例或类，所以我们将其设为静态方法。
- en: 'Now, you can run the application and try changing the theme, and then restart
    the application. You should notice a change in the application''s appearance.
    For example, here''s the application using the "clam" theme:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以运行应用程序并尝试更改主题，然后重新启动应用程序。你应该会注意到应用程序外观的变化。例如，这里是在Windows上使用“clam”主题的应用程序：
- en: '![Figure 9.17: ABQ Data Entry using the "clam" theme on Windows](img/B17578_09_17.png)'
  id: totrans-491
  prefs: []
  type: TYPE_IMG
  zh: '![图9.17：在Windows上使用“clam”主题的ABQ数据输入](img/B17578_09_17.png)'
- en: 'Figure 9.17: ABQ Data Entry using the "clam" theme on Windows'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.17：在Windows上使用“clam”主题的ABQ数据输入
- en: As you can see, not every theme looks so good with our changes. Try the different
    themes available on your platform. Which theme looks best on your platform? Which
    ones work best with our style changes? Try them all out and see.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，并非每个主题都适合我们的更改。尝试你平台上可用的不同主题。哪个主题在你的平台上看起来最好？哪些主题与我们的样式更改配合得最好？尝试它们所有，看看效果如何。
- en: Summary
  id: totrans-494
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we overhauled the look and feel of our application for both
    aesthetic and usability improvements. You learned how to use images and icons
    in your application using PhotoImage and BitmapImage, and how to extend image
    format support using Pillow. You learned to assign fonts to widgets, and to change
    the settings for built-in fonts. You learned how to work with color and font settings
    for default Tkinter widgets and how to use tags to style individual `Treeview`
    items and `Text` widget contents. We explored the intricate world of Ttk styles
    and learned to create custom styles based on the built-in defaults. Finally, we
    applied our knowledge of styling to the ABQ Data Entry application to make it
    more aesthetically pleasing and user-friendly.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们对应用程序的外观和用户体验进行了全面改造，以提升美学和实用性。你学习了如何使用PhotoImage和BitmapImage在你的应用程序中使用图片和图标，以及如何使用Pillow扩展图像格式支持。你学习了如何为小部件分配字体，以及如何更改内置字体的设置。你学习了如何处理默认Tkinter小部件的颜色和字体设置，以及如何使用标签来格式化单个`Treeview`项和`Text`小部件的内容。我们探索了Ttk样式的复杂世界，并学习了如何基于内置默认值创建自定义样式。最后，我们将我们对样式的知识应用到ABQ数据输入应用程序中，使其更具美学价值和用户友好性。
- en: In the next chapter, we'll take steps to make sure our program runs effectively
    across major desktop platforms. You'll learn strategies to avoid cross-platform
    pitfalls in both general Python programming and Tkinter programming in particular.
    We'll also explore the various guidelines platform vendors offer to developers
    targeting their platforms.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将采取措施确保我们的程序在主要桌面平台上有效运行。你将学习避免跨平台陷阱的策略，特别是在Tkinter编程中。我们还将探索平台供应商为针对其平台开发人员提供的各种指南。
