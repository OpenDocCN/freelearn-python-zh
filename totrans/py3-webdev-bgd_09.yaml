- en: 'Chapter 9. Creating Full-Fledged Webapps: Implementing Instances'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The framework for the rapid development of Python web applications is coming
    along nicely, but some distinct features are still lacking.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'In this chapter, we take a look at some of them, notably:'
  prefs: []
  type: TYPE_NORMAL
- en: How to implement more complex relations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to create the necessary user interface components to maintain those relations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And how to allow for a more fine-grained control of who is allowed to do what
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are some interesting challenges, so let's get started.
  prefs: []
  type: TYPE_NORMAL
- en: Even more relations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have seen, it was not very difficult to make `Display` capable of handling
    references to related entities. These relations, however, are limited to lookup
    relations (also known as many-to-one relations). A `Contact` entity, for example,
    refers to, at most, a single `Account` entity and the `Display` class allows us
    to select an `Account` when we edit a `Contact`.
  prefs: []
  type: TYPE_NORMAL
- en: But what do we need for the opposite situation? An `Account` may have many `Contacts`
    and both `Account` and `Contact` may have many `Addresses`. What we need is a
    way to make `Display` show which one-to-many relationships exist for an entity
    and provide the means to show those entities when the user clicks on such a relation.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action showing one-to-many relationships
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The illustration shows what we might expect:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for action showing one-to-many relationships](img/3746_09_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We have selected a `Contact` and its details are available for editing, including
    a reference to an `Account`. Now on the left, however, we have a sidebar showing
    the available one-to-many relations, in this case, the only one-to-many relation
    applicable to a `Contact` is `Address`.
  prefs: []
  type: TYPE_NORMAL
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To show a list of entities, we already have a suitable building block, the `Browse`
    class that will not only let us browse a list of entities in various ways, but
    is also capable of filtering those entities. In this example, we would want to
    show just those addresses that are associated with this specific contact.
  prefs: []
  type: TYPE_NORMAL
- en: 'We therefore add a new method to the `Display` class that will produce an HTML
    fragment together with some JavaScript to show the list of available one-to-many
    relations:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter9/display.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: To determine which relations are available, `related_entities()` refers to the
    `reltype` class variable (highlighted), which is a dictionary of entity names
    and their type maintained by the `MetaRelation` class when a new relation is defined.
    For each suitable relation, a`<li>` element is produced with the help of the `related_link()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: These`<li>` elements have an `id` attribute that holds the unique ID of the
    referring entity (the ID of the contact in this example) and a `class` attribute
    that indicates the type of the referring entity (Contact in this case). The`<li>`
    elements also have a `rel` attribute that points to the URL that is serviced by
    a `Browse` class. For now, we derive this URL from the name of the entities we
    are referring to (in this case, address).
  prefs: []
  type: TYPE_NORMAL
- en: The final piece of HTML produced is a`<script>` element that installs an event
    handler on the`<li>` elements. This click handler will take the `ref` attribute
    of its associated`<li>` element to construct a URL that is subsequently used to
    open a new window. We will have to adapt the `index()` methods of the `Display`
    and `Browse` classes slightly to pass and process those attributes around, as
    we will see in a minute.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example, the resulting HTML fragment (minus the script element) would
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'And the `load()` call that will replace the contents of the`<div>` element
    with the `content` class would be passed the following URL, for example: `http://127.0.0.1:8080/
    address/?_=1295184609212&pattern=Contact,1&related=Contact,1`.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that we use jQuery's `param()` function here to convert an object containing
    several attributes to a string suitable to add to a URL. We could have simply
    passed the object here, but that would result in a POST action even though we
    configured all AJAX calls to use the HTTP GET method. Normally, that wouldn't
    be a problem, but if the final slash is missing in the URL, CherryPy will redirect
    us to the URL with the slash at the end and the AJAX call will be made again,
    but this time without the parameters appended! To prevent this possible awkwardness
    and to aid in debugging, we force the use of the GET method by constructing the
    full URL ourselves with the help of the `param()` function.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action adapting MetaRelation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the `Display` class, we used the information about the type of relation
    stored by the `MetaRelation` metaclass. This is necessary because in recognizing
    that there is more than one type of relation, we need some way to indicate that
    when we define a new relation and act upon that information when creating a new
    class. Look at the following example code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we express the relation between `A` and `B` to be one-to-many. If we would
    like to express the notion that an instance of `A` may refer only to a single
    `B` instance, we need some way to indicate that in the definition. One way of
    doing so is by reversing the assignments in the class definition of the variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `MetaRelation` metaclass we defined earlier could act on such a definition
    as we arranged for the class dictionary of the relation being defined to be an
    `OrderedDict`, so in principle, we can act on the order of the definitions.
  prefs: []
  type: TYPE_NORMAL
- en: 'A slightly more explicit way of defining this is often clearer, so instead
    we opt for a `relation_type` attribute that can be assigned a string with the
    type of the relation. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: If we leave out the `relation_type`, a one-to-many relation is assumed.
  prefs: []
  type: TYPE_NORMAL
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's have a look at the changes and additions to `MetaRelation` needed to implement
    those semantics. We need two changes. The first is in the definition of the bridge
    table we use to administer the relation. We need an additional `unique` constraint
    here to enforce that in a one-to-many relation, the IDs in the column referring
    to the many side of the equation are unique.
  prefs: []
  type: TYPE_NORMAL
- en: 'This may sound counterintuitive, but let''s say we have the following cars:
    a Volvo, a Renault, a Ford, and a Nissan. There are also two owners, John and
    Jill. Jill owns the Volvo and the Renault, and John the other cars. The tables
    might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Car |   |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| ID | make |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | Volvo |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | Renault |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | Ford |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | Nissan |'
  prefs: []
  type: TYPE_TB
- en: '| Owner |   |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| ID | name |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | Jill |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | John |'
  prefs: []
  type: TYPE_TB
- en: 'The table that reflects the ownership of the cars might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Ownership |   |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Car | owner |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | 2 |'
  prefs: []
  type: TYPE_TB
- en: We see that while a *single* owner may have *many* cars, it is the numbers in
    the `Car` column that are unique because of this relation.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to define a table with those additional uniqueness constraints and
    to make the information about the type of relation available in the classes that
    form both halves of a relation, we have to adapt the final part of the `__new__()`
    method in the `MetaRelation` metaclass:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter9/entity.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The highlighted lines are the ones we added. The first set makes sure there
    is a `relation_type` attribute defined and if not, creates one with a default`'1:N'`
    value.
  prefs: []
  type: TYPE_NORMAL
- en: The second set of highlighted lines determines which column in the bridge table
    should receive an additional unique constraint and constructs the SQL query to
    create the table.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final block of highlighted lines adds class attributes to both classes
    in the relation. All those attributes are dictionaries indexed by the name of
    an entity. The `reltype` attribute holds the type of the relation, so in a `Car`
    entity, we might obtain the type of relation with an `Owner` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Which, if defined as in our previous example, will yield`'N:1'` (one or more
    cars may have a single owner).
  prefs: []
  type: TYPE_NORMAL
- en: 'Likewise, we can get information about the same relation from the perspective
    of the owner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Which will yield the inverse,`'1:N'` (an owner may have more than one car).
  prefs: []
  type: TYPE_NORMAL
- en: Time for action enhancing Display
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What do we have to change to add the functionality to the `Display` class to
    pop up a list of items when the user clicks on a related tag?
  prefs: []
  type: TYPE_NORMAL
- en: Because all activities of the `Display` class are served by its `index()` method,
    we will have to apply some changes there.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `index()` method both displays forms and processes the results when the
    submit button is pressed, so we have to look at both the aspects of the edit and
    add functionality.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When an edit form is shown, this will always be initiated from double-clicking
    in a list of items shown by a `Browse` instance and will therefore be passed a
    related argument. This argument must be passed along with the contents of the
    form when the submit button is clicked in order to associate it with the item
    that initiated this edit action.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These issues require that we apply a few changes to the `index()` method.
  prefs: []
  type: TYPE_NORMAL
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first thing we have to do is add a `related` parameter to the `index()`
    method. This parameter may hold the name of the entity and the ID of the specific
    related instance separated by a comma:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter9/display.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'When processing the information passed to the `index()` method of the `Display`
    class, the portion dealing with the results of an add action has to act on the
    information in the `related` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter9/display.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: If the method was called as the result of clicking the add button in a list
    of items, the `related` parameter will be non empty and we split it on the comma
    to retrieve the name of the entity and its ID.
  prefs: []
  type: TYPE_NORMAL
- en: The name of the entity is used to retrieve its class that was added to the `relclass`
    dictionary when the relation was defined and this class' constructor is called
    with the ID of the instance to create an object (highlighted). The relation between
    the item we are currently editing and the related item is subsequently established
    by the `add()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Likewise, the portion responsible for delivering the add or edit form in the
    first place must include a hidden`<input>` element that holds the contents of
    the related parameter passed to it when the user clicked the add button in a page
    delivered by a `Browse` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter9/display.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Time for action enhancing Browse
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All this passing around of the related parameter originates with the user clicking
    an 'add' button in a list of entities that, in its turn, was shown in response
    to clicking a related tag when editing or viewing an item.
  prefs: []
  type: TYPE_NORMAL
- en: Those lists of entities are generated by the `index()` method of the `Browse`
    class, so we have to make sure that suitable information (that is, the name of
    the entity that is listed together with the ID of the instance) is passed on.
  prefs: []
  type: TYPE_NORMAL
- en: 'This means we have to:'
  prefs: []
  type: TYPE_NORMAL
- en: Enhance the `index()` method to receive a related parameter that can be passed
    on when the 'add' button is clicked.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extend the code that generated the form associated with this add button with
    a hidden`<input>` element to hold this information, so that it may be passed on
    again to the `index()` method of the `Display` class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If it sounds a little confusing how `Display` and `Browse` are connected, it
    may help to envision the following scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: The user starts looking at a list of owners from the main menu and double-clicks
    a certain owner. This will result in an 'edit' form delivered by the `Display`
    class. Because double-clicking on an item will not pass a related argument, this
    argument in the `index()` method of `Display` will receive its default value of
    `None`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The edit form shows the details of the owner in the sidebar labeled Related,
    we see a Carsentry.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the user clicks this **Cars** entry to show the list of cars related to
    this owner, this will result in the `index()` method of a `Browse` instance for
    the `Car` entity to be called with both a `related` and a `pattern` argument of
    `Owner,5`, for example.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This will result in a list of cars of the indicated owner and when the 'add'
    button in this list is clicked, it is again the `index()` method of the `Display`
    class that is called, but this time, a `Display` instance associated with the
    `Car` entity. It will be passed the `related` argument of `Owner,5`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, when the user has entered the new car details and clicks 'add', the
    same `index()` method of the `Display` class is called, again with a `related`
    argument of `Owner,5` but also with an `add` argument. The car details will be
    used to create a new `Car` instance and the `related` argument to identify the
    `Owner` instance and associate the new car instance with.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following series of screenshots illustrates what is happening. We start
    with a list of owners:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for action enhancing Browse](img/3746_09_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'When we double-click on **Knut Larsson**, the following URL is sent to the
    server: `http://127.0.0.1:8080/owner/edit/?id=5&_=1295438048592` (the `id=5` indicates
    the instance, the number at the end is what jQuery adds to an AJAX call to prevent
    caching by the web browser).'
  prefs: []
  type: TYPE_NORMAL
- en: The result will be an edit form for **Knut:**
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for action enhancing Browse](img/3746_09_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'A click on **Car** will result in the following URL being sent to the server:
    `http://127.0.0.1:8080/car/?_=1295438364192&pattern=Owner,5&related=Owner,5`.'
  prefs: []
  type: TYPE_NORMAL
- en: We recognize the `related` and `pattern` arguments of `Owner,5` (that is, referring
    to **Knut)**. Note that the commas in the arguments appended to this URL would
    be sent to the server encoded as `%2C`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Why do we send both a `related` argument and a `pattern` argument containing
    the same information? For adding an entity to another entity, this is indeed redundant
    but if we would like to add the ability to transfer ownership as well as add a
    new entity, we would like to filter those cars that belong to some other owner
    and therefore we need to separately provide the `pattern` and `related` arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'If this is the first time we will be adding a car to **Knut**, the list of
    related cars will be empty:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for action enhancing Browse](img/3746_09_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If we now click on the **Add new** button, the following URL is constructed:'
  prefs: []
  type: TYPE_NORMAL
- en: '`http://127.0.0.1:8080/car/add/?_=1295438711800&related=Owner,5`, which will
    result in an add form for a new car:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for action enhancing Browse](img/3746_09_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'After filling in the details, clicking on the **Add** button will result in
    a new car instance that will be associated with **Knut** even if we leave the
    **Owner** field empty because of the related argument passed yet again in the
    URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '`http://127.0.0.1:8080/car/add/?_=1295439571424&make=Volvo&model=C30&color=Green&license=124-abc&Owner=&related=Owner,5&add=Add`.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for action enhancing Browse](img/3746_09_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To allow a `Browse` instance to receive and pass on a `related` attribute in
    the same manner as a `Display` instance, we need to make a few small changes.
    First, we have to alter the signature of the `index()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter9/browse.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'All that is left then is to make sure that clicking the **Add** new button
    will pass on this value by including a hidden`<input>` element to the form:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter9/browse.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Access control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the applications we designed so far, we took a very simple approach to access
    control. Based on someone's login credentials we either allowed access or not.
    We slightly expanded this notion in the books applications where deleting a book
    meant that the association between a book and an owner was deleted rather that
    removing the book instance from the database altogether.
  prefs: []
  type: TYPE_NORMAL
- en: In many situations, a finer control of privileges is required, but if this control
    is hardcoded into the application maintaining it will rapidly become unwieldy.
    We therefore need something that will allow us to manage access privileges in
    a simple way and in a manner that allows easy expansion.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following scenario: In a company using our CRM application, different
    accounts are owned by different sales persons. It''s a small firm so everybody
    is allowed to see all the information on all the accounts but changing information
    for an account is restricted to the sales person that owns that account. Of course
    the sales manager, their boss, is allowed to change this information also, regardless
    of whether he owns an account or not.'
  prefs: []
  type: TYPE_NORMAL
- en: We could implement such a strategy by letting the `update()` method of an `Entity`
    check whether this entity has an account and owned by the person doing the update
    and if not, whether the person is the sales manager.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action implementing access control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This scenario is implemented in `access1.py:`
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Note: In the code distributed with this chapter and the following one, the
    `logon` class is not only initialized with an `admin` user (with `admin` as a
    password) but with the following three name/password combinations: `eve/eve, john/john`,
    and `mike/mike`.'
  prefs: []
  type: TYPE_NORMAL
- en: If your run this application and point your browser to `http://localhost:8080`,
    you are presented with a list of accounts. If you have logged in as either **john**
    or **mike** both sales persons you can only alter the accounts owned by each of
    them. If however, you log in as eve, the sales manager, you can alter the information
    in all accounts.
  prefs: []
  type: TYPE_NORMAL
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The application is simple enough and follows a familiar pattern. The relevant
    definitions are shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter9/access1.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The database distributed with the code (access1.db) contains a number of accounts
    already so the code does not contain any lines to create those. The important
    part is highlighted in the preceding code: it imports a `permissions1` module
    that contains a dictionary of permissions. This dictionary lists for each combination
    of entity, action, ownership, and username whether this is permissible or not.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now override the `update()` method in the `AbstractEntity` class (highlighted):
    We retrieve the username from the current sessions by calling the `checkauth()`
    method and pass it along to the `isallowed()` function, together with the name
    of the action we want to check (update in this case), the entity, and a list of
    users (the owners). If this checks out okay, we call the original `update()` method.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we take a look at `permissions1.py`, we see that because, in this example,
    we only consider the `Account` entity and the update action in this list is quite
    small:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter9/permissions1.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The dictionary with privileges itself is called `allowed` (highlighted) and
    `permissions1.py` also defines a function called `isallowed()`, that will return
    `True` if there aren't any owners for this entity. Then it checks if there are
    any privileges known for this entity and action. If this is not the case, any
    exception will be raised because either the key for the entity or the key for
    the action does not exist.
  prefs: []
  type: TYPE_NORMAL
- en: If there are privileges known, we check if the user has specific privileges.
    If there is no key for the user, we return `False`. If there is, and the privilege
    is `all`, we return `True:` he/she may perform the action on this entity even
    for an entity instance he/she doesn't own. If the privilege is the owner, we only
    return `True` if the user is in fact the owner.
  prefs: []
  type: TYPE_NORMAL
- en: 'The aforementioned approach outlined is cumbersome for various reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: If we would like to add a new salesperson, for example, we would have to add
    permission entries for each entity/action combination. In the example, we only
    considered the `Account` entity and the `update` action, but in a somewhat more
    realistic application, there would be tens of entities (like `Contact, Address,
    Quote, Lead`, and so on) and quite a few actions more to consider (for example,
    `delete` and `create`, but also actions that involve other entities like *changing*
    ownership or adding an address to an account). Also, if that sales person was
    promoted to sales manager, we would have to repeat the whole exercise again.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we added a new type of entity, we would have to add lines for each and every
    person in the company.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Administering permissions in a Python module is not something you normally would
    expect a non-technical person to do as it is cumbersome, error prone, and requires
    the application to be restarted if something changes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last reason is why we will implement the list of permissions in the database.
    After all, we already have a framework that allows for easy manipulation of database
    entries with a web interface. The other reasons are why we will reconsider our
    first approach and will implement a scheme called **role-based access control**.
  prefs: []
  type: TYPE_NORMAL
- en: Role-based access control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The idea in role-based access control is to assign one or more roles to people
    instead of specific permissions.
  prefs: []
  type: TYPE_NORMAL
- en: Permissions are then associated with a role, and if a person has more than one
    role, the permissions are merged. If a new person needs a set of permissions to
    use an application, or if a person's role in the organization changes, only the
    list of roles associated with that person needs to be changed instead of having
    to change the permissions for this person for each type of entity in the application.
  prefs: []
  type: TYPE_NORMAL
- en: Likewise, if we would extend the available types of entities, we would only
    have to define what permissions associated with a role (or roles) would apply
    to this new entity instead of defining this for every person.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A good starter for reading more about this is this Wikipedia article: [http://en.wikipedia.org/wiki/Role-based_access_control](http://en.wikipedia.org/wiki/Role-based_access_control).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The aforementioned concepts described can be captured in this data model:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Role-based access control](img/3746OS_09_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In our simplified model, a user can have one role, but a role can have one or
    more permissions. A permission consists of several attributes, an entity, action,
    and level, that together describe under which conditions something is allowed.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action implementing role-based access control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Run the example application provided in `access2.py` and log in as `admin`.
    You will see that besides **Users** and **Accounts**, you are presented with links
    to **Roles** and **Permissions** as well. If you click on **Roles**, you will
    see we have defined several roles:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for action implementing role-based access control](img/3746_09_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see in the screenshot, we have also defined a **Superuser** role
    to illustrate that it is possible to extend the concept of role-based access control
    to the maintenance of roles and permissions themselves.
  prefs: []
  type: TYPE_NORMAL
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Applications that use this form of access control have to be adapted only slightly.
    Take a look at `access2.py:`
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter9/access2.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Compared to our previous example, only the first part is different, in that
    it includes the `rbacentity` instead of the `entity` module. This module provides
    the same functionality as the `entity` module, but the `AbstractEntity` class
    defined in this module has some added magic to provide access to roles and permissions.
    We will not inspect that in detail here, but will comment on it when we encounter
    it in the following code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next part is the definition of the `Entity` class. We could have opted
    for redefining the `AbstractEntity` class, but here we have chosen to add the
    functionality to the `Entity` subclass by adding and overriding methods where
    necessary:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter9/access2.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Instead of just defining a `database` class variable, we now also define a `userentity`
    class variable to hold a reference to the class of the entity that represents
    a user and a `logon` class variable to hold a reference to a logon instance that
    can provide us with the name of an authenticated user.
  prefs: []
  type: TYPE_NORMAL
- en: 'This distinction is identical to examples in the previous chapters: we have
    a `User` entity in our main database where we may store all sorts of information
    related to the user (like full name, telephone number, gender, and so on) and
    a separate password database that holds just usernames and encrypted passwords.
    If the user is correctly authenticated against the password database, we know
    his/her username, which we can then use to retrieve the corresponding `User` instance
    with all the extra associated information. The class methods provide the means
    to get access to these class variables.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we only override the `update()` method (highlighted) but in
    a full implementation you might want to override other `Entity` methods as well.
    The pattern is simple: we call the `isallowed()` method with an argument that
    indicates which action we would like to check and if `isallowed()` returns `True`,
    we call the original method.'
  prefs: []
  type: TYPE_NORMAL
- en: The first thing the `isallowed()` method itself does, is retrieve the username
    of the authenticated user with the `getAuthenticatedUsername()` class method.
    It then uses this name to find a `User` instance. Even though we might want to
    implement a role-based access scheme in our application to allow for the administration
    of roles and permissions by various users, we still provide a shortcut for the
    administrator here as a convenience (highlighted). This way we do not have to
    prime the database with roles and permissions for the admin user. For a real world
    application, you may choose differently of course.
  prefs: []
  type: TYPE_NORMAL
- en: Next we check if there are any roles associated with the user, and if this is
    the case, we retrieve all permissions associated with the first role (in this
    example, users have just one role). We then loop over all those permissions to
    check if there is one that applies to the entity we are interested in. If so,
    we check the `operation` field. If this field contains an asterisk (*) or is equal
    to the operation we are checking, we look at the `level`. If this `level` is zero,
    this means that the current user may perform this operation on this entity even
    if he/she is not the owner. If the level is one, he/she is only allowed to perform
    the operation if he/she owns the entity, so we check whether the user is in the
    list of users associated with the current entity.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Retrieving roles and permissions each time an operation is performed might incur
    a serious performance hit. It might be a good idea to cache some of this information.
    You have to be careful though and invalidate that cache as soon as the set of
    permissions for a user changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next part of `access2.py`, as shown, illustrates how we may use this augmented
    version of the `Entity` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter9/access2.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: As before, we define `User` and `Account` entities, and an ownership relation
    between them. The `rbacentity` module will have provided for `Role` and `Permission`
    classes and we can gain access to those with the `_rbac()` class method available
    to all `AbstractEntity` derived classes. The object returned by this `_rbac()`
    method provides a `getRole()` method that returns the class of the `Role` entity.
    We use it here to create a relation between users and their roles (highlighted).
    The final lines associate the password database and the `User` class with our
    new `Entity` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'To provide access to the lists of roles and permissions, we can use the same
    `_rbac()` method to provide the `Role` and `Permission` classes needed to create
    `Browse` classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter9/access2.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we filled in some gaps in our framework, Specifically, we learned
    how to implement more complex relations, for example, one-to-many and many-to-one
    relationships, how to create the necessary user interface components to maintain
    those relations, and how to implement role-based access control.
  prefs: []
  type: TYPE_NORMAL
- en: We're not quite there yet, because we are missing facilities to let end-users
    customize the datamodel, which is the subject of the next chapter.
  prefs: []
  type: TYPE_NORMAL
