- en: 'Chapter 9. Creating Full-Fledged Webapps: Implementing Instances'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章. 创建完整的Web应用：实现实例
- en: The framework for the rapid development of Python web applications is coming
    along nicely, but some distinct features are still lacking.
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Python Web应用的快速开发框架正在顺利进行，但一些独特的功能仍然缺失。
- en: 'In this chapter, we take a look at some of them, notably:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨其中的一些，特别是：
- en: How to implement more complex relations
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何实现更复杂的关系
- en: How to create the necessary user interface components to maintain those relations
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建必要的用户界面组件来维护这些关系
- en: And how to allow for a more fine-grained control of who is allowed to do what
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以及如何允许对谁可以做什么有更精细的控制
- en: These are some interesting challenges, so let's get started.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是一些有趣的挑战，让我们开始吧。
- en: Even more relations
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多的关系
- en: As we have seen, it was not very difficult to make `Display` capable of handling
    references to related entities. These relations, however, are limited to lookup
    relations (also known as many-to-one relations). A `Contact` entity, for example,
    refers to, at most, a single `Account` entity and the `Display` class allows us
    to select an `Account` when we edit a `Contact`.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，使`Display`能够处理相关实体的引用并不困难。然而，这些关系仅限于查找关系（也称为多对一关系）。例如，`Contact`实体最多引用一个`Account`实体，而`Display`类允许我们在编辑`Contact`时选择`Account`。
- en: But what do we need for the opposite situation? An `Account` may have many `Contacts`
    and both `Account` and `Contact` may have many `Addresses`. What we need is a
    way to make `Display` show which one-to-many relationships exist for an entity
    and provide the means to show those entities when the user clicks on such a relation.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 但对于相反的情况，我们还需要什么？一个`Account`可能有多个`Contacts`，而`Account`和`Contact`都可能有很多`Addresses`。我们需要一种方法让`Display`显示实体存在的一对多关系，并提供在用户点击此类关系时显示这些实体的手段。
- en: Time for action showing one-to-many relationships
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 展示一对一关系的行动时间
- en: 'The illustration shows what we might expect:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 插图显示了我们可能期望的结果：
- en: '![Time for action showing one-to-many relationships](img/3746_09_01.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![展示一对一关系的行动时间](img/3746_09_01.jpg)'
- en: We have selected a `Contact` and its details are available for editing, including
    a reference to an `Account`. Now on the left, however, we have a sidebar showing
    the available one-to-many relations, in this case, the only one-to-many relation
    applicable to a `Contact` is `Address`.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经选择了一个`Contact`，其详细信息可供编辑，包括对`Account`的引用。然而，现在在左侧，我们有一个侧边栏显示了可用的单一到多对关系，在这种情况下，适用于`Contact`的唯一单一到多对关系是`Address`。
- en: What just happened?
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: To show a list of entities, we already have a suitable building block, the `Browse`
    class that will not only let us browse a list of entities in various ways, but
    is also capable of filtering those entities. In this example, we would want to
    show just those addresses that are associated with this specific contact.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要显示实体列表，我们已经有了一个合适的构建块，即`Browse`类，它不仅让我们能够以各种方式浏览实体列表，还能够过滤这些实体。在这个例子中，我们只想显示与这个特定联系人相关联的地址。
- en: 'We therefore add a new method to the `Display` class that will produce an HTML
    fragment together with some JavaScript to show the list of available one-to-many
    relations:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们在`Display`类中添加了一个新方法，该方法将生成一个HTML片段和一些JavaScript，以显示可用的单一到多对关系列表：
- en: '**Chapter9/display.py**'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**Chapter9/display.py**'
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: To determine which relations are available, `related_entities()` refers to the
    `reltype` class variable (highlighted), which is a dictionary of entity names
    and their type maintained by the `MetaRelation` class when a new relation is defined.
    For each suitable relation, a`<li>` element is produced with the help of the `related_link()`
    method.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 要确定哪些关系可用，`related_entities()`方法引用了`reltype`类变量（已突出显示），这是一个由`MetaRelation`类维护的实体名称及其类型的字典，当定义新关系时。对于每个合适的关联，`related_link()`方法将帮助生成一个`<li>`元素。
- en: These`<li>` elements have an `id` attribute that holds the unique ID of the
    referring entity (the ID of the contact in this example) and a `class` attribute
    that indicates the type of the referring entity (Contact in this case). The`<li>`
    elements also have a `rel` attribute that points to the URL that is serviced by
    a `Browse` class. For now, we derive this URL from the name of the entities we
    are referring to (in this case, address).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这些`<li>`元素有一个`id`属性，它包含引用实体的唯一ID（在这个例子中是联系人的ID）和一个`class`属性，它指示引用实体的类型（在这种情况下是Contact）。`<li>`元素还有一个`rel`属性，它指向由`Browse`类服务的URL。目前，我们从这个我们引用的实体的名称（在这种情况下是地址）中派生这个URL。
- en: The final piece of HTML produced is a`<script>` element that installs an event
    handler on the`<li>` elements. This click handler will take the `ref` attribute
    of its associated`<li>` element to construct a URL that is subsequently used to
    open a new window. We will have to adapt the `index()` methods of the `Display`
    and `Browse` classes slightly to pass and process those attributes around, as
    we will see in a minute.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 最终生成的HTML片段是一个`<script>`元素，它为`<li>`元素安装了一个事件处理器。这个点击处理器将获取其关联的`<li>`元素的`ref`属性来构造一个URL，随后用于打开一个新窗口。我们将不得不稍微调整`Display`和`Browse`类的`index()`方法，以便传递和处理这些属性，正如我们稍后将看到的。
- en: 'In our example, the resulting HTML fragment (minus the script element) would
    look like this:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，生成的HTML片段（减去script元素）将如下所示：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'And the `load()` call that will replace the contents of the`<div>` element
    with the `content` class would be passed the following URL, for example: `http://127.0.0.1:8080/
    address/?_=1295184609212&pattern=Contact,1&related=Contact,1`.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 将替换`<div>`元素内容的`load()`调用将传递以下URL，例如：`http://127.0.0.1:8080/ address/?_=1295184609212&pattern=Contact,1&related=Contact,1`。
- en: Note
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that we use jQuery's `param()` function here to convert an object containing
    several attributes to a string suitable to add to a URL. We could have simply
    passed the object here, but that would result in a POST action even though we
    configured all AJAX calls to use the HTTP GET method. Normally, that wouldn't
    be a problem, but if the final slash is missing in the URL, CherryPy will redirect
    us to the URL with the slash at the end and the AJAX call will be made again,
    but this time without the parameters appended! To prevent this possible awkwardness
    and to aid in debugging, we force the use of the GET method by constructing the
    full URL ourselves with the help of the `param()` function.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在这里使用jQuery的`param()`函数将包含多个属性的对象转换为适合添加到URL的字符串。我们本可以直接在这里传递对象，但那样会导致即使我们配置了所有AJAX调用使用HTTP
    GET方法，也会触发POST操作。通常情况下，这不会成为问题，但如果URL中缺少最后的斜杠，CherryPy会重定向我们到以斜杠结尾的URL，并且AJAX调用将再次执行，但这次没有附加参数！为了防止这种可能的尴尬情况并帮助调试，我们通过使用`param()`函数自己构造完整的URL来强制使用GET方法。
- en: Time for action adapting MetaRelation
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 适应MetaRelation的时间
- en: 'In the `Display` class, we used the information about the type of relation
    stored by the `MetaRelation` metaclass. This is necessary because in recognizing
    that there is more than one type of relation, we need some way to indicate that
    when we define a new relation and act upon that information when creating a new
    class. Look at the following example code:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Display`类中，我们使用了`MetaRelation`元类存储的关系类型信息。这是必要的，因为当我们认识到存在多种关系类型时，我们需要某种方式来指示当我们定义一个新的关系并创建新类时使用该信息。看看下面的示例代码：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here we express the relation between `A` and `B` to be one-to-many. If we would
    like to express the notion that an instance of `A` may refer only to a single
    `B` instance, we need some way to indicate that in the definition. One way of
    doing so is by reversing the assignments in the class definition of the variable:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们表达`A`和`B`之间的关系是一对多。如果我们想表达一个`A`的实例可能只引用一个`B`实例的概念，我们需要在定义中表明这一点。这样做的一种方式是在变量的类定义中反转赋值：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `MetaRelation` metaclass we defined earlier could act on such a definition
    as we arranged for the class dictionary of the relation being defined to be an
    `OrderedDict`, so in principle, we can act on the order of the definitions.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前定义的`MetaRelation`元类可以对这样的定义进行操作，因为我们安排了被定义的关系的类字典是一个`OrderedDict`，所以原则上，我们可以对定义的顺序进行操作。
- en: 'A slightly more explicit way of defining this is often clearer, so instead
    we opt for a `relation_type` attribute that can be assigned a string with the
    type of the relation. For example:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 一种更明确的方式来定义这通常是更清晰的，所以我们选择一个可以分配关系类型的字符串的`relation_type`属性。例如：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If we leave out the `relation_type`, a one-to-many relation is assumed.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们省略了`relation_type`，则默认为多对一关系。
- en: What just happened?
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 这到底发生了什么？
- en: Let's have a look at the changes and additions to `MetaRelation` needed to implement
    those semantics. We need two changes. The first is in the definition of the bridge
    table we use to administer the relation. We need an additional `unique` constraint
    here to enforce that in a one-to-many relation, the IDs in the column referring
    to the many side of the equation are unique.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看实现这些语义所需的`MetaRelation`的更改和添加。我们需要两个更改。第一个是在我们用来管理关系的桥表定义中。我们需要在这里添加一个额外的`unique`约束，以强制在一对多关系中，方程多边的列中的ID是唯一的。
- en: 'This may sound counterintuitive, but let''s say we have the following cars:
    a Volvo, a Renault, a Ford, and a Nissan. There are also two owners, John and
    Jill. Jill owns the Volvo and the Renault, and John the other cars. The tables
    might look like this:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能听起来有些反直觉，但假设我们有以下车辆：一辆沃尔沃、一辆雷诺、一辆福特和一辆尼桑。还有两位所有者，John和Jill。Jill拥有沃尔沃和雷诺，而John拥有其他车辆。表格可能看起来像这样：
- en: '| Car |   |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| 汽车 |   |'
- en: '| --- | --- |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| ID | make |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| ID | 品牌 |'
- en: '| --- | --- |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 1 | Volvo |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 沃尔沃 |'
- en: '| 2 | Renault |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 雷诺 |'
- en: '| 3 | Ford |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 福特 |'
- en: '| 4 | Nissan |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 尼桑 |'
- en: '| Owner |   |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| 所有者 |   |'
- en: '| --- | --- |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| ID | name |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| ID | 名称 |'
- en: '| --- | --- |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 1 | Jill |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| 1 | Jill |'
- en: '| 2 | John |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| 2 | John |'
- en: 'The table that reflects the ownership of the cars might look like this:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 反映汽车所有权的表可能看起来像这样：
- en: '| Ownership |   |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| 所有权 |   |'
- en: '| --- | --- |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Car | owner |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| 汽车 | 所有者 |'
- en: '| --- | --- |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 1 | 1 |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 |'
- en: '| 2 | 1 |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 1 |'
- en: '| 3 | 2 |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 2 |'
- en: '| 4 | 2 |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 2 |'
- en: We see that while a *single* owner may have *many* cars, it is the numbers in
    the `Car` column that are unique because of this relation.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到，虽然一个*单一*所有者可能拥有*许多*辆车，但由于这种关系，`汽车`列中的数字是唯一的。
- en: 'In order to define a table with those additional uniqueness constraints and
    to make the information about the type of relation available in the classes that
    form both halves of a relation, we have to adapt the final part of the `__new__()`
    method in the `MetaRelation` metaclass:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 为了定义具有那些额外唯一约束条件的表，并使关系类型的信息在构成关系两半的类中可用，我们必须调整`MetaRelation`元类中的`__new__()`方法的最后部分：
- en: '**Chapter9/entity.py**'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**第9章/entity.py**'
- en: '[PRE5]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The highlighted lines are the ones we added. The first set makes sure there
    is a `relation_type` attribute defined and if not, creates one with a default`'1:N'`
    value.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 突出显示的行是我们添加的。第一组确保定义了`relation_type`属性，如果没有，则创建一个具有默认`'1:N'`值的属性。
- en: The second set of highlighted lines determines which column in the bridge table
    should receive an additional unique constraint and constructs the SQL query to
    create the table.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 突出显示的第二组行确定桥表中哪个列应该接收额外的唯一约束，并构建创建表的SQL查询。
- en: 'The final block of highlighted lines adds class attributes to both classes
    in the relation. All those attributes are dictionaries indexed by the name of
    an entity. The `reltype` attribute holds the type of the relation, so in a `Car`
    entity, we might obtain the type of relation with an `Owner` like this:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 突出显示的最后一行代码为两个相关类添加了类属性。所有这些属性都是按实体名称索引的字典。`reltype`属性持有关系类型，因此在一个`Car`实体中，我们可能通过以下方式获取与`Owner`的关系类型：
- en: '[PRE6]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Which, if defined as in our previous example, will yield`'N:1'` (one or more
    cars may have a single owner).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果像我们之前的例子那样定义，将产生`'N:1'`（一辆或多辆车可能有一个单一的所有者）。
- en: 'Likewise, we can get information about the same relation from the perspective
    of the owner:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以从所有者的角度获取相同关系的信息：
- en: '[PRE7]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Which will yield the inverse,`'1:N'` (an owner may have more than one car).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生逆关系，`'1:N'`（一个所有者可能有多辆车）。
- en: Time for action enhancing Display
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提升显示效果的行动时间
- en: What do we have to change to add the functionality to the `Display` class to
    pop up a list of items when the user clicks on a related tag?
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要更改什么来向`Display`类添加当用户点击相关标签时弹出项目列表的功能？
- en: Because all activities of the `Display` class are served by its `index()` method,
    we will have to apply some changes there.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为`Display`类的所有活动都由其`index()`方法提供服务，所以我们必须在那里做一些更改。
- en: The `index()` method both displays forms and processes the results when the
    submit button is pressed, so we have to look at both the aspects of the edit and
    add functionality.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`index()` 方法既显示表单，又在按下提交按钮时处理结果，因此我们必须查看编辑和添加功能的两个方面。'
- en: When an edit form is shown, this will always be initiated from double-clicking
    in a list of items shown by a `Browse` instance and will therefore be passed a
    related argument. This argument must be passed along with the contents of the
    form when the submit button is clicked in order to associate it with the item
    that initiated this edit action.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当显示编辑表单时，这始终是从双击 `Browse` 实例显示的项目列表中触发的，因此会传递一个相关参数。在点击提交按钮时，必须将此参数与表单内容一起传递，以便将其与启动此编辑操作的项关联。
- en: These issues require that we apply a few changes to the `index()` method.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这些问题要求我们对 `index()` 方法进行一些修改。
- en: What just happened?
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: 'The first thing we have to do is add a `related` parameter to the `index()`
    method. This parameter may hold the name of the entity and the ID of the specific
    related instance separated by a comma:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须做的第一件事是向 `index()` 方法添加一个 `related` 参数。此参数可以保存实体的名称和特定相关实例的 ID，用逗号分隔：
- en: '**Chapter9/display.py**'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '**Chapter9/display.py**'
- en: '[PRE8]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'When processing the information passed to the `index()` method of the `Display`
    class, the portion dealing with the results of an add action has to act on the
    information in the `related` parameter:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理传递给 `Display` 类的 `index()` 方法的 `related` 参数时，涉及添加操作结果的部分必须对 `related` 参数中的信息进行操作：
- en: '**Chapter9/display.py**'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '**Chapter9/display.py**'
- en: '[PRE9]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If the method was called as the result of clicking the add button in a list
    of items, the `related` parameter will be non empty and we split it on the comma
    to retrieve the name of the entity and its ID.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果方法是在点击项目列表中的 '添加' 按钮后调用的，则 `related` 参数将不为空，并且我们通过逗号分割它以检索实体的名称及其 ID。
- en: The name of the entity is used to retrieve its class that was added to the `relclass`
    dictionary when the relation was defined and this class' constructor is called
    with the ID of the instance to create an object (highlighted). The relation between
    the item we are currently editing and the related item is subsequently established
    by the `add()` method.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 实体的名称用于检索在定义关系时添加到 `relclass` 字典中的该类，并且使用实例的 ID 调用该类的构造函数以创建对象（突出显示）。随后，通过 `add()`
    方法建立我们正在编辑的项与相关项之间的关系。
- en: 'Likewise, the portion responsible for delivering the add or edit form in the
    first place must include a hidden`<input>` element that holds the contents of
    the related parameter passed to it when the user clicked the add button in a page
    delivered by a `Browse` instance:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，最初负责提供添加或编辑表单的部分必须包括一个隐藏的 `<input>` 元素，该元素保存当用户在 `Browse` 实例提供的页面上点击 '添加'
    按钮时传递给它的相关参数内容：
- en: '**Chapter9/display.py**'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**Chapter9/display.py**'
- en: '[PRE10]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Time for action enhancing Browse
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 是时候增强 `Browse` 的功能了。
- en: All this passing around of the related parameter originates with the user clicking
    an 'add' button in a list of entities that, in its turn, was shown in response
    to clicking a related tag when editing or viewing an item.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些相关参数的传递都始于用户在实体列表中点击 '添加' 按钮，而这个列表本身是在编辑或查看项时点击相关标签后显示的。
- en: Those lists of entities are generated by the `index()` method of the `Browse`
    class, so we have to make sure that suitable information (that is, the name of
    the entity that is listed together with the ID of the instance) is passed on.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这些实体列表是由 `Browse` 类的 `index()` 方法生成的，因此我们必须确保传递适当的信息（即，与实例 ID 一起列出的实体名称）。
- en: 'This means we have to:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们必须：
- en: Enhance the `index()` method to receive a related parameter that can be passed
    on when the 'add' button is clicked.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增强 `index()` 方法以接收一个相关参数，当点击 '添加' 按钮时可以传递。
- en: Extend the code that generated the form associated with this add button with
    a hidden`<input>` element to hold this information, so that it may be passed on
    again to the `index()` method of the `Display` class.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将生成与该添加按钮相关表单的代码扩展，添加一个隐藏的 `<input>` 元素来保存这些信息，以便它可以再次传递给 `Display` 类的 `index()`
    方法。
- en: 'If it sounds a little confusing how `Display` and `Browse` are connected, it
    may help to envision the following scenario:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `Display` 和 `Browse` 之间的连接听起来有点令人困惑，那么设想以下场景可能会有所帮助：
- en: The user starts looking at a list of owners from the main menu and double-clicks
    a certain owner. This will result in an 'edit' form delivered by the `Display`
    class. Because double-clicking on an item will not pass a related argument, this
    argument in the `index()` method of `Display` will receive its default value of
    `None`.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户从主菜单开始查看所有者列表，并双击某个特定所有者。这将导致由`Display`类提供的'编辑'表单。因为双击项目不会传递相关参数，所以`Display`类的`index()`方法中的此参数将接收其默认值`None`。
- en: The edit form shows the details of the owner in the sidebar labeled Related,
    we see a Carsentry.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编辑表单在标签为相关性的侧边栏中显示了所有者的详情，我们看到一个汽车条目。
- en: When the user clicks this **Cars** entry to show the list of cars related to
    this owner, this will result in the `index()` method of a `Browse` instance for
    the `Car` entity to be called with both a `related` and a `pattern` argument of
    `Owner,5`, for example.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用户点击此**汽车**条目以显示与该所有者相关的汽车列表时，这将导致调用`Car`实体的`Browse`实例的`index()`方法，同时带有`related`和`pattern`参数`Owner,5`，例如。
- en: This will result in a list of cars of the indicated owner and when the 'add'
    button in this list is clicked, it is again the `index()` method of the `Display`
    class that is called, but this time, a `Display` instance associated with the
    `Car` entity. It will be passed the `related` argument of `Owner,5`.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这将导致显示指定所有者的汽车列表，当点击此列表中的'添加'按钮时，再次调用`Display`类的`index()`方法，但这次是与`Car`实体关联的`Display`实例。它将传递`Owner,5`的`related`参数。
- en: Finally, when the user has entered the new car details and clicks 'add', the
    same `index()` method of the `Display` class is called, again with a `related`
    argument of `Owner,5` but also with an `add` argument. The car details will be
    used to create a new `Car` instance and the `related` argument to identify the
    `Owner` instance and associate the new car instance with.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，当用户输入了新的汽车详情并点击'添加'时，将再次调用`Display`类的`index()`方法，这次带有`related`参数`Owner,5`，同时还有一个`add`参数。汽车详情将被用来创建一个新的`Car`实例，而`related`参数用来识别`Owner`实例并将新的汽车实例与之关联。
- en: 'The following series of screenshots illustrates what is happening. We start
    with a list of owners:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 以下一系列截图展示了正在发生的情况。我们从一个所有者列表开始：
- en: '![Time for action enhancing Browse](img/3746_09_02.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![增强浏览时间的行动](img/3746_09_02.jpg)'
- en: 'When we double-click on **Knut Larsson**, the following URL is sent to the
    server: `http://127.0.0.1:8080/owner/edit/?id=5&_=1295438048592` (the `id=5` indicates
    the instance, the number at the end is what jQuery adds to an AJAX call to prevent
    caching by the web browser).'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们双击**Knut Larsson**时，以下URL将被发送到服务器：`http://127.0.0.1:8080/owner/edit/?id=5&_=1295438048592`（`id=5`表示实例，最后的数字是jQuery添加到AJAX调用中，以防止浏览器缓存）。
- en: The result will be an edit form for **Knut:**
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将是一个用于**Knut**的编辑表单：
- en: '![Time for action enhancing Browse](img/3746_09_03.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![增强浏览时间的行动](img/3746_09_03.jpg)'
- en: 'A click on **Car** will result in the following URL being sent to the server:
    `http://127.0.0.1:8080/car/?_=1295438364192&pattern=Owner,5&related=Owner,5`.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**汽车**将导致以下URL被发送到服务器：`http://127.0.0.1:8080/car/?_=1295438364192&pattern=Owner,5&related=Owner,5`。
- en: We recognize the `related` and `pattern` arguments of `Owner,5` (that is, referring
    to **Knut)**. Note that the commas in the arguments appended to this URL would
    be sent to the server encoded as `%2C`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们识别出`Owner,5`（即指**Knut**）的`related`和`pattern`参数。请注意，附加到此URL的参数中的逗号将被编码为`%2C`发送到服务器。
- en: Note
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Why do we send both a `related` argument and a `pattern` argument containing
    the same information? For adding an entity to another entity, this is indeed redundant
    but if we would like to add the ability to transfer ownership as well as add a
    new entity, we would like to filter those cars that belong to some other owner
    and therefore we need to separately provide the `pattern` and `related` arguments.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们发送包含相同信息的`related`参数和`pattern`参数？对于将实体添加到另一个实体，这确实是多余的，但如果我们想添加转移所有权以及添加新实体的能力，我们希望过滤出属于其他所有者的汽车，因此我们需要分别提供`pattern`和`related`参数。
- en: 'If this is the first time we will be adding a car to **Knut**, the list of
    related cars will be empty:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是我们第一次为**Knut**添加汽车，相关汽车列表将为空：
- en: '![Time for action enhancing Browse](img/3746_09_04.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![增强浏览时间的行动](img/3746_09_04.jpg)'
- en: 'If we now click on the **Add new** button, the following URL is constructed:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在点击**添加新**按钮，将构造以下URL：
- en: '`http://127.0.0.1:8080/car/add/?_=1295438711800&related=Owner,5`, which will
    result in an add form for a new car:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`http://127.0.0.1:8080/car/add/?_=1295438711800&related=Owner,5`，这将导致一个用于添加新汽车的表单：'
- en: '![Time for action enhancing Browse](img/3746_09_05.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![增强浏览时间的行动](img/3746_09_05.jpg)'
- en: 'After filling in the details, clicking on the **Add** button will result in
    a new car instance that will be associated with **Knut** even if we leave the
    **Owner** field empty because of the related argument passed yet again in the
    URL:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 填写详细信息后，点击**添加**按钮将导致一个新的汽车实例，即使我们因为URL中再次传递的相关参数而留空**所有者**字段，也会与**Knut**相关联：
- en: '`http://127.0.0.1:8080/car/add/?_=1295439571424&make=Volvo&model=C30&color=Green&license=124-abc&Owner=&related=Owner,5&add=Add`.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`http://127.0.0.1:8080/car/add/?_=1295439571424&make=Volvo&model=C30&color=Green&license=124-abc&Owner=&related=Owner,5&add=Add`.'
- en: '![Time for action enhancing Browse](img/3746_09_06.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![增强浏览时间的行动](img/3746_09_06.jpg)'
- en: What just happened?
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: 'To allow a `Browse` instance to receive and pass on a `related` attribute in
    the same manner as a `Display` instance, we need to make a few small changes.
    First, we have to alter the signature of the `index()` method:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 要允许`Browse`实例以与`Display`实例相同的方式接收和传递`related`属性，我们需要进行一些小的更改。首先，我们必须更改`index()`方法的签名：
- en: '**Chapter9/browse.py**'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '**第9章/browse.py**'
- en: '[PRE11]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'All that is left then is to make sure that clicking the **Add** new button
    will pass on this value by including a hidden`<input>` element to the form:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 然后剩下的就是确保点击**添加**新按钮时，通过在表单中包含一个隐藏的`<input>`元素来传递这个值：
- en: '**Chapter9/browse.py**'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '**第9章/browse.py**'
- en: '[PRE12]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Access control
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问控制
- en: In the applications we designed so far, we took a very simple approach to access
    control. Based on someone's login credentials we either allowed access or not.
    We slightly expanded this notion in the books applications where deleting a book
    meant that the association between a book and an owner was deleted rather that
    removing the book instance from the database altogether.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们迄今为止设计的应用程序中，我们采取了非常简单的方法来处理访问控制。基于某人的登录凭证，我们允许或不允许访问。在书籍应用程序中，我们稍微扩展了这个概念，删除书籍意味着删除书籍与所有者之间的关联，而不是从数据库中完全删除书籍实例。
- en: In many situations, a finer control of privileges is required, but if this control
    is hardcoded into the application maintaining it will rapidly become unwieldy.
    We therefore need something that will allow us to manage access privileges in
    a simple way and in a manner that allows easy expansion.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，需要更精细的权限控制，但如果这种控制被硬编码到应用程序中，维护它将很快变得难以管理。因此，我们需要某种东西，它将允许我们以简单的方式管理访问权限，并且允许轻松扩展。
- en: 'Consider the following scenario: In a company using our CRM application, different
    accounts are owned by different sales persons. It''s a small firm so everybody
    is allowed to see all the information on all the accounts but changing information
    for an account is restricted to the sales person that owns that account. Of course
    the sales manager, their boss, is allowed to change this information also, regardless
    of whether he owns an account or not.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下场景：在一个使用我们CRM应用程序的公司中，不同的账户由不同的销售人员拥有。由于公司规模较小，所以每个人都允许查看所有账户的信息，但更改账户信息仅限于拥有该账户的销售人员。当然，销售经理，他们的老板，也有权更改这些信息，无论他是否拥有账户。
- en: We could implement such a strategy by letting the `update()` method of an `Entity`
    check whether this entity has an account and owned by the person doing the update
    and if not, whether the person is the sales manager.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过让`Entity`的`update()`方法检查此实体是否由执行更新的个人拥有账户，如果不是，则该个人是否是销售经理来实现这种策略。
- en: Time for action implementing access control
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施访问控制的时间
- en: This scenario is implemented in `access1.py:`
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这种场景在`access1.py:`中实现
- en: Note
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Note: In the code distributed with this chapter and the following one, the
    `logon` class is not only initialized with an `admin` user (with `admin` as a
    password) but with the following three name/password combinations: `eve/eve, john/john`,
    and `mike/mike`.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在本章和下一章提供的代码中，`logon`类不仅使用`admin`用户（密码为`admin`）初始化，还使用以下三个用户名/密码组合：`eve/eve,
    john/john`, 和 `mike/mike`。
- en: If your run this application and point your browser to `http://localhost:8080`,
    you are presented with a list of accounts. If you have logged in as either **john**
    or **mike** both sales persons you can only alter the accounts owned by each of
    them. If however, you log in as eve, the sales manager, you can alter the information
    in all accounts.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行这个应用程序并将你的浏览器指向 `http://localhost:8080`，你会看到一个账户列表。如果你以 **john** 或 **mike**（都是销售人员）的身份登录，你只能更改他们各自拥有的账户。然而，如果你以
    eve（销售经理）的身份登录，你可以更改所有账户的信息。
- en: What just happened?
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: 'The application is simple enough and follows a familiar pattern. The relevant
    definitions are shown here:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用程序足够简单，遵循一个熟悉的模式。相关的定义如下所示：
- en: '**Chapter9/access1.py**'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '**Chapter9/access1.py**'
- en: '[PRE13]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The database distributed with the code (access1.db) contains a number of accounts
    already so the code does not contain any lines to create those. The important
    part is highlighted in the preceding code: it imports a `permissions1` module
    that contains a dictionary of permissions. This dictionary lists for each combination
    of entity, action, ownership, and username whether this is permissible or not.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 随代码一起分发的数据库（access1.db）已经包含了一些账户，因此代码中不包含创建这些账户的任何行。前述代码中突出显示的部分很重要：它导入了一个包含权限字典的
    `permissions1` 模块。这个字典列出了对于每个实体、动作、所有权和用户名的组合，这是否允许。
- en: 'We can now override the `update()` method in the `AbstractEntity` class (highlighted):
    We retrieve the username from the current sessions by calling the `checkauth()`
    method and pass it along to the `isallowed()` function, together with the name
    of the action we want to check (update in this case), the entity, and a list of
    users (the owners). If this checks out okay, we call the original `update()` method.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以覆盖 `AbstractEntity` 类中的 `update()` 方法（高亮显示）：我们通过调用 `checkauth()` 方法从当前会话中检索用户名，并将其连同我们想要检查的动作名称（在这种情况下是更新）一起传递给
    `isallowed()` 函数，以及实体和用户列表（所有者）。如果检查无误，我们调用原始的 `update()` 方法。
- en: 'If we take a look at `permissions1.py`, we see that because, in this example,
    we only consider the `Account` entity and the update action in this list is quite
    small:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看 `permissions1.py`，我们会看到，由于在这个示例中我们只考虑了 `Account` 实体和更新动作，这个列表相当小：
- en: '**Chapter9/permissions1.py**'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '**Chapter9/permissions1.py**'
- en: '[PRE14]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The dictionary with privileges itself is called `allowed` (highlighted) and
    `permissions1.py` also defines a function called `isallowed()`, that will return
    `True` if there aren't any owners for this entity. Then it checks if there are
    any privileges known for this entity and action. If this is not the case, any
    exception will be raised because either the key for the entity or the key for
    the action does not exist.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 具有特权的字典本身被称为 `allowed`（高亮显示），`permissions1.py` 还定义了一个名为 `isallowed()` 的函数，如果这个实体没有所有者，它将返回
    `True`。然后它检查这个实体和动作是否有已知的特权。如果不是这种情况，将引发任何异常，因为实体或动作的键不存在。
- en: If there are privileges known, we check if the user has specific privileges.
    If there is no key for the user, we return `False`. If there is, and the privilege
    is `all`, we return `True:` he/she may perform the action on this entity even
    for an entity instance he/she doesn't own. If the privilege is the owner, we only
    return `True` if the user is in fact the owner.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果已知特权，我们检查用户是否有特定的特权。如果没有用户键，我们返回 `False`。如果有，并且特权是 `all`，我们返回 `True`：他/她可以在这个实体上执行动作，即使他/她不是所有者。如果特权是所有者，我们只有在用户确实是所有者的情况下才返回
    `True`。
- en: 'The aforementioned approach outlined is cumbersome for various reasons:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 由于各种原因，上述方法显得有些繁琐：
- en: If we would like to add a new salesperson, for example, we would have to add
    permission entries for each entity/action combination. In the example, we only
    considered the `Account` entity and the `update` action, but in a somewhat more
    realistic application, there would be tens of entities (like `Contact, Address,
    Quote, Lead`, and so on) and quite a few actions more to consider (for example,
    `delete` and `create`, but also actions that involve other entities like *changing*
    ownership or adding an address to an account). Also, if that sales person was
    promoted to sales manager, we would have to repeat the whole exercise again.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们想添加一个新的销售人员，例如，我们必须为每个实体/动作组合添加权限条目。在示例中，我们只考虑了 `Account` 实体和 `update` 动作，但在一个更现实的应用程序中，会有数十个实体（如
    `Contact`、`Address`、`Quote`、`Lead` 等）和相当多的动作需要考虑（例如，`delete` 和 `create`，以及涉及其他实体的动作，如
    *更改* 所有权或向账户添加地址）。此外，如果那位销售人员被提升为销售经理，我们可能需要再次进行整个练习。
- en: If we added a new type of entity, we would have to add lines for each and every
    person in the company.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们添加一个新的实体类型，我们就必须为公司中的每个人添加相应的行。
- en: Administering permissions in a Python module is not something you normally would
    expect a non-technical person to do as it is cumbersome, error prone, and requires
    the application to be restarted if something changes.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Python模块中管理权限不是你通常期望非技术人员去做的事情，因为这很繁琐，容易出错，并且如果有所改变，需要重新启动应用程序。
- en: The last reason is why we will implement the list of permissions in the database.
    After all, we already have a framework that allows for easy manipulation of database
    entries with a web interface. The other reasons are why we will reconsider our
    first approach and will implement a scheme called **role-based access control**.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个原因是为什么我们将实现数据库中的权限列表。毕竟，我们已经有了一个允许通过网页界面轻松操作数据库条目的框架。其他原因是我们将重新考虑我们的第一个方法，并将实现一个称为**基于角色的访问控制**的方案。
- en: Role-based access control
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于角色的访问控制
- en: The idea in role-based access control is to assign one or more roles to people
    instead of specific permissions.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 基于角色的访问控制中的想法是将一个或多个角色分配给人员，而不是特定的权限。
- en: Permissions are then associated with a role, and if a person has more than one
    role, the permissions are merged. If a new person needs a set of permissions to
    use an application, or if a person's role in the organization changes, only the
    list of roles associated with that person needs to be changed instead of having
    to change the permissions for this person for each type of entity in the application.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，权限将与角色相关联，如果一个人拥有多个角色，权限将被合并。如果新员工需要一组权限来使用应用程序，或者如果一个人的组织角色发生变化，只需要更改与该人关联的角色列表，而不是必须更改应用程序中每种实体类型的权限。
- en: Likewise, if we would extend the available types of entities, we would only
    have to define what permissions associated with a role (or roles) would apply
    to this new entity instead of defining this for every person.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果我们想扩展可用的实体类型，我们只需要定义与角色（或角色集）关联的权限将应用于这个新实体，而不是为每个人定义这些权限。
- en: Note
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'A good starter for reading more about this is this Wikipedia article: [http://en.wikipedia.org/wiki/Role-based_access_control](http://en.wikipedia.org/wiki/Role-based_access_control).'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 了解更多关于此内容的良好起点是这篇维基百科文章：[http://en.wikipedia.org/wiki/Role-based_access_control](http://en.wikipedia.org/wiki/Role-based_access_control)。
- en: 'The aforementioned concepts described can be captured in this data model:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 上述概念可以在这个数据模型中体现：
- en: '![Role-based access control](img/3746OS_09_09.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![基于角色的访问控制](img/3746OS_09_09.jpg)'
- en: In our simplified model, a user can have one role, but a role can have one or
    more permissions. A permission consists of several attributes, an entity, action,
    and level, that together describe under which conditions something is allowed.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的简化模型中，一个用户可以有一个角色，但一个角色可以有一个或多个权限。一个权限由几个属性组成，包括实体、操作和级别，这些属性共同描述了在什么条件下允许做某事。
- en: Time for action implementing role-based access control
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施基于角色的访问控制的时机
- en: 'Run the example application provided in `access2.py` and log in as `admin`.
    You will see that besides **Users** and **Accounts**, you are presented with links
    to **Roles** and **Permissions** as well. If you click on **Roles**, you will
    see we have defined several roles:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`access2.py`中提供的示例应用程序，并以`admin`身份登录。你会看到除了**用户**和**账户**之外，你还看到了**角色**和**权限**的链接。如果你点击**角色**，你会看到我们已经定义了几个角色：
- en: '![Time for action implementing role-based access control](img/3746_09_07.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![实施基于角色的访问控制的时机](img/3746_09_07.jpg)'
- en: As you can see in the screenshot, we have also defined a **Superuser** role
    to illustrate that it is possible to extend the concept of role-based access control
    to the maintenance of roles and permissions themselves.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如截图所示，我们还定义了一个**超级用户**角色，以说明可以将基于角色的访问控制的概念扩展到角色和权限的维护。
- en: What just happened?
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: Applications that use this form of access control have to be adapted only slightly.
    Take a look at `access2.py:`
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种访问控制形式的应用程序只需要稍作调整。看看`access2.py`：
- en: '**Chapter9/access2.py**'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '**第9章/access2.py**'
- en: '[PRE15]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Compared to our previous example, only the first part is different, in that
    it includes the `rbacentity` instead of the `entity` module. This module provides
    the same functionality as the `entity` module, but the `AbstractEntity` class
    defined in this module has some added magic to provide access to roles and permissions.
    We will not inspect that in detail here, but will comment on it when we encounter
    it in the following code.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们之前的例子相比，只有第一部分不同，因为它包括了`rbacentity`模块而不是`entity`模块。这个模块提供了与`entity`模块相同的功能，但在这个模块中定义的`AbstractEntity`类增加了一些魔法功能，以提供对角色和权限的访问。我们在这里不会详细检查它，但当我们遇到它时，我们会进行注释。
- en: 'The next part is the definition of the `Entity` class. We could have opted
    for redefining the `AbstractEntity` class, but here we have chosen to add the
    functionality to the `Entity` subclass by adding and overriding methods where
    necessary:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分是`Entity`类的定义。我们本可以选择重新定义`AbstractEntity`类，但在这里我们选择通过添加和覆盖必要的方法来向`Entity`子类添加功能：
- en: '**Chapter9/access2.py**'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '**第9章/access2.py**'
- en: '[PRE16]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Instead of just defining a `database` class variable, we now also define a `userentity`
    class variable to hold a reference to the class of the entity that represents
    a user and a `logon` class variable to hold a reference to a logon instance that
    can provide us with the name of an authenticated user.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 除了定义一个`database`类变量之外，我们现在还定义了一个`userentity`类变量来保存表示用户的实体类的引用，以及一个`logon`类变量来保存一个登录实例的引用，该实例可以为我们提供已认证用户的名字。
- en: 'This distinction is identical to examples in the previous chapters: we have
    a `User` entity in our main database where we may store all sorts of information
    related to the user (like full name, telephone number, gender, and so on) and
    a separate password database that holds just usernames and encrypted passwords.
    If the user is correctly authenticated against the password database, we know
    his/her username, which we can then use to retrieve the corresponding `User` instance
    with all the extra associated information. The class methods provide the means
    to get access to these class variables.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这种区分与前面章节中的例子相同：在我们的主数据库中有一个`User`实体，我们可以存储与用户相关的各种信息（如全名、电话号码、性别等），还有一个单独的密码数据库，只包含用户名和加密密码。如果用户正确地通过了密码数据库的认证，我们就知道了他的/她的用户名，然后我们可以使用这个用户名来检索包含所有额外关联信息的相应`User`实例。类方法提供了访问这些类变量的手段。
- en: 'In this example, we only override the `update()` method (highlighted) but in
    a full implementation you might want to override other `Entity` methods as well.
    The pattern is simple: we call the `isallowed()` method with an argument that
    indicates which action we would like to check and if `isallowed()` returns `True`,
    we call the original method.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们只覆盖了`update()`方法（突出显示），但在完整实现中，你可能还希望覆盖其他`Entity`方法。模式很简单：我们使用一个表示我们想要检查的动作的参数调用`isallowed()`方法，如果`isallowed()`返回`True`，我们就调用原始方法。
- en: The first thing the `isallowed()` method itself does, is retrieve the username
    of the authenticated user with the `getAuthenticatedUsername()` class method.
    It then uses this name to find a `User` instance. Even though we might want to
    implement a role-based access scheme in our application to allow for the administration
    of roles and permissions by various users, we still provide a shortcut for the
    administrator here as a convenience (highlighted). This way we do not have to
    prime the database with roles and permissions for the admin user. For a real world
    application, you may choose differently of course.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`isallowed()`方法本身首先做的事情是使用`getAuthenticatedUsername()`类方法检索已认证用户的用户名。然后它使用这个名称来查找`User`实例。尽管我们可能希望在应用程序中实现基于角色的访问方案，以便允许不同用户管理角色和权限，但我们在这里仍然提供了一个方便的快捷方式（突出显示），以便管理员可以这样做。这样我们就不必在数据库中为管理员用户预先设置角色和权限。当然，对于实际应用，你可能会有不同的选择。'
- en: Next we check if there are any roles associated with the user, and if this is
    the case, we retrieve all permissions associated with the first role (in this
    example, users have just one role). We then loop over all those permissions to
    check if there is one that applies to the entity we are interested in. If so,
    we check the `operation` field. If this field contains an asterisk (*) or is equal
    to the operation we are checking, we look at the `level`. If this `level` is zero,
    this means that the current user may perform this operation on this entity even
    if he/she is not the owner. If the level is one, he/she is only allowed to perform
    the operation if he/she owns the entity, so we check whether the user is in the
    list of users associated with the current entity.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们检查是否有任何与用户关联的角色，如果是这样，我们就检索与第一个角色（在这个例子中，用户只有一个角色）关联的所有权限。然后，我们遍历所有这些权限，检查是否有适用于我们感兴趣的实体的权限。如果有，我们检查`operation`字段。如果这个字段包含星号（*）或者等于我们正在检查的操作，我们就查看`level`。如果这个`level`为零，这意味着当前用户即使不是所有者也可以在这个实体上执行此操作。如果级别为一级，他/她只有在拥有实体的情况下才能执行操作，因此我们需要检查用户是否在当前实体的关联用户列表中。
- en: Tip
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Retrieving roles and permissions each time an operation is performed might incur
    a serious performance hit. It might be a good idea to cache some of this information.
    You have to be careful though and invalidate that cache as soon as the set of
    permissions for a user changes.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 每次执行操作时检索角色和权限可能会严重影响性能。可能有必要缓存一些此类信息。但您必须小心，一旦用户的权限集合发生变化，就必须使缓存失效。
- en: 'The next part of `access2.py`, as shown, illustrates how we may use this augmented
    version of the `Entity` class:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如上图所示，`access2.py`的下一部分说明了我们如何使用这种增强版的`Entity`类：
- en: '**Chapter9/access2.py**'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '**第9章/access2.py**'
- en: '[PRE17]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As before, we define `User` and `Account` entities, and an ownership relation
    between them. The `rbacentity` module will have provided for `Role` and `Permission`
    classes and we can gain access to those with the `_rbac()` class method available
    to all `AbstractEntity` derived classes. The object returned by this `_rbac()`
    method provides a `getRole()` method that returns the class of the `Role` entity.
    We use it here to create a relation between users and their roles (highlighted).
    The final lines associate the password database and the `User` class with our
    new `Entity` class.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们定义了`User`和`Account`实体，以及它们之间的所有权关系。`rbacentity`模块将提供`Role`和`Permission`类，我们可以通过所有`AbstractEntity`派生类的`_rbac()`类方法访问它们。这个`_rbac()`方法返回的对象提供了一个`getRole()`方法，它返回`Role`实体的类。我们在这里使用它来创建用户与其角色之间的关系（突出显示）。最后的几行将密码数据库和`User`类与我们的新`Entity`类关联起来。
- en: 'To provide access to the lists of roles and permissions, we can use the same
    `_rbac()` method to provide the `Role` and `Permission` classes needed to create
    `Browse` classes:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供对角色和权限列表的访问，我们可以使用相同的`_rbac()`方法提供创建`Browse`类所需的`Role`和`Permission`类：
- en: '**Chapter9/access2.py**'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '**第9章/access2.py**'
- en: '[PRE18]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Summary
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we filled in some gaps in our framework, Specifically, we learned
    how to implement more complex relations, for example, one-to-many and many-to-one
    relationships, how to create the necessary user interface components to maintain
    those relations, and how to implement role-based access control.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们填补了我们框架的一些空白。具体来说，我们学习了如何实现更复杂的关系，例如一对一和多对一关系，如何创建维护这些关系的必要用户界面组件，以及如何实现基于角色的访问控制。
- en: We're not quite there yet, because we are missing facilities to let end-users
    customize the datamodel, which is the subject of the next chapter.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有完全完成，因为我们缺少让最终用户自定义数据模型的功能，这是下一章的主题。
