- en: Chapter 16
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第16章
- en: 'Project 5.2: Simple Multivariate Statistics'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 项目5.2：简单多元统计
- en: Are variables related? If so what’s the relationship? An analyst tries to answer
    these two questions. A negative answer — the null hypothesis — doesn’t require
    too many supporting details. A positive answer, on the other hand, suggests that
    a model can be defined to describe the relationship. In this chapter, we’ll look
    at simple correlation and linear regression as two elements of modeling a relationship
    between variables.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 变量是否相关？如果是，关系是什么？分析师试图回答这两个问题。一个否定的答案——零假设——不需要太多支持细节。另一方面，肯定的答案表明可以定义一个模型来描述这种关系。在本章中，我们将探讨简单相关性和线性回归作为描述变量之间关系建模的两个要素。
- en: 'In this chapter, we’ll expand on some skills of data analysis:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将扩展数据分析的一些技能：
- en: Use of the built-in `statistics` library to compute correlation measures and
    linear regression coefficients.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用内置的`statistics`库来计算相关性和线性回归系数。
- en: Use of the **matplotlib** library to create images. This means creating plot
    images outside a Jupyter Lab environment.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**matplotlib**库创建图像。这意味着在Jupyter Lab环境之外创建绘图图像。
- en: Expanding on the base modeling application to add features.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在基础建模应用的基础上添加功能。
- en: 'This chapter’s project will expand on earlier projects. Look back at [*Chapter** 13*](ch017.xhtml#x1-29700013),
    [*Project 4.1: Visual Analysis Techniques*](ch017.xhtml#x1-29700013) for some
    of the graphical techniques used in a Jupyter Lab context. These need to be more
    fully automated. The project will add multivariate statistics and graphs to illustrate
    relationships among variables.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的项目将扩展早期项目。回顾[第13章](ch017.xhtml#x1-29700013)[项目4.1：可视化分析技术](ch017.xhtml#x1-29700013)，了解在Jupyter
    Lab环境中使用的某些图形技术。这些需要更加自动化。项目将添加多元统计和图表来展示变量之间的关系。
- en: 16.1 Description
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 16.1 描述
- en: 'In [*Chapter** 15*](ch019.xhtml#x1-32500015), [*Project 5.1: Modeling Base
    Application*](ch019.xhtml#x1-32500015) we created an application to create a summary
    document with some core statistics. In that application, we looked at univariate
    statistics to characterize the data distributions. These statistics included measurements
    of the location, spread, and shape of a distribution. Functions like mean, median,
    mode, variance, and standard deviation were emphasized as ways to understand location
    and spread. The characterization of shape via skewness and kurtosis was left as
    an extra exercise for you.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第15章](ch019.xhtml#x1-32500015)[项目5.1：建模基础应用](ch019.xhtml#x1-32500015)中，我们创建了一个应用程序来生成包含一些核心统计信息的摘要文档。在那个应用程序中，我们研究了单变量统计来描述数据分布。这些统计包括对分布的位置、范围和形状的测量。均值、中位数、众数、方差和标准差等函数被强调为理解位置和范围的方法。通过偏度和峰度来描述形状则留作额外的练习。
- en: The base application from the previous chapter needs to be expanded to include
    the multivariate statistics and diagrams that are essential for clarifying the
    relationships among variables. There are a vast number of possible functions to
    describe the relationships among two variables. See [https://www.itl.nist.gov/div898/handbook/pmd/section8/pmd8.htm](https://www.itl.nist.gov/div898/handbook/pmd/section8/pmd8.htm)
    for some insight into the number of choices available.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 前一章的基础应用需要扩展，包括对变量之间关系的澄清所必需的多元统计和图表。描述两个变量之间关系的可能函数数量众多。参见[https://www.itl.nist.gov/div898/handbook/pmd/section8/pmd8.htm](https://www.itl.nist.gov/div898/handbook/pmd/section8/pmd8.htm)了解可用的选择数量。
- en: 'We’ll limit ourselves to linear functions. In the simplest cases, there are
    two steps to creating a linear model: identifying a correlation and creating the
    coefficients for a line that fits the data. We’ll look at each of these steps
    in the next two sections.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将限制自己使用线性函数。在最简单的情况下，创建线性模型有两个步骤：识别相关性并创建适合数据的线的系数。我们将在接下来的两个部分中查看这些步骤。
- en: 16.1.1 Correlation coefficient
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.1.1 相关系数
- en: 'The coefficient of correlation measures how well the values of two variables
    correlate with each other. A value of 1 indicates perfect correlation; a value
    of zero indicates no discernable correlation. A value of -1 indicates an “anti-correlation”:
    when one variable is at its maximum value, the other variable is at its minimum.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 相关系数衡量两个变量的值相互关联的程度。值为1表示完全相关；值为零表示没有可辨别的相关；值为-1表示“反相关”：当一个变量达到最大值时，另一个变量处于最小值。
- en: See [*Figure 16.1*](#16.1) to see how the correlation coefficient describes
    the distribution of the two variables.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 见[*图16.1*](#16.1) 了解相关系数如何描述两个变量的分布。
- en: '![Figure 16.1: Correlation Coefficients ](img/file64.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![图16.1：相关系数](img/file64.jpg)'
- en: 'Figure 16.1: Correlation Coefficients'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.1：相关系数
- en: 'The computation of the coefficient compares individual values of variables,
    *X*[i] and *Y* [i], to the mean values for those variables, *X* and *Ȳ*. Here’s
    a formula:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 系数的计算比较了变量的个别值，*X*[i]和*Y*[i]，与这些变量的平均值，*X*和*Ȳ*。以下是一个公式：
- en: '![ ∑ r = ∘-∑---(Xi-−-¯X∘)(Y∑i-−-¯Y)----- (Xi − ¯X )2 (Yi − ¯Y )2 ](img/file65.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![ ∑ r = ∘-∑---(Xi-−-¯X∘)(Y∑i-−-¯Y)----- (Xi − ¯X )2 (Yi − ¯Y )2 ](img/file65.jpg)'
- en: The computations of the mean values, *X* and *Ȳ*, can be factored into this,
    creating a somewhat more complicated version that’s often used to create the coefficient
    in a single pass through the data.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 均值*X*和*Ȳ*的计算可以分解到这一点，创建一个稍微复杂一些的版本，这种版本通常用于在单次通过数据时创建系数。
- en: This function is available as `statistics.correlation()` in the `standard` library.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 此功能在`standard`库中作为`statistics.correlation()`提供。
- en: If two variables correlate with each other, then a linear function will map
    one variable to a value near the other variable. If the correlation is 1.0 or
    -1.0, the mapping will be exact. For other correlation values, the mapping will
    be close, but not exact. In the next section, we’ll show how to transform the
    correlation coefficient into the parameters for a line.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个变量相互关联，那么一个线性函数将一个变量的值映射到另一个变量附近的值。如果相关系数为1.0或-1.0，映射将是精确的。对于其他相关系数值，映射将是接近的，但不是精确的。在下一节中，我们将展示如何将相关系数转换为直线的参数。
- en: 16.1.2 Linear regression
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.1.2 线性回归
- en: One equation for a line is *y* = *mx* + *b*. The values of *m* and *b* are parameters
    that describe the specific linear relationship between the *x* and *y* variables.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 一条线的方程是 *y* = *mx* + *b*。*m*和*b*的值是描述*x*和*y*变量之间特定线性关系的参数。
- en: When fitting a line to data, we’re estimating the parameters for a line. The
    goal is to minimize the error between the line and the actual data. The “least
    squares” technique is often used.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当拟合数据线时，我们正在估计线的参数。目标是使线与实际数据之间的误差最小化。“最小二乘”技术通常被使用。
- en: 'The two coefficients, *b* and *m*, can be computed as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 两个系数，*b*和*m*，可以按以下方式计算：
- en: '![ ∑ ∑ ∑ ∑ X2i Y 2i − Xi XiYi b = ----n-∑--X2-−-(∑-X--)2---- i i ](img/file66.jpg)![
    ∑ ∑ ∑ m = n---X∑iYi-−--∑-Xi---Yi n X2i − ( Xi)2 ](img/file67.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![ ∑ ∑ ∑ ∑ X2i Y 2i − Xi XiYi b = ----n-∑--X2-−-(∑-X--)2---- i i ](img/file66.jpg)![
    ∑ ∑ ∑ m = n---X∑iYi-−--∑-Xi---Yi n X2i − ( Xi)2 ](img/file67.jpg)'
- en: This is available as `statistics.linear_regression()` in the standard library.
    This saves us from having to write these two functions.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这在标准库中作为`statistics.linear_regression()`提供。这使我们免于编写这两个函数。
- en: The various sums and sums of squares are not terribly difficult values to compute.
    The built-in `sum()` function is the basis for most of this. We can use `sum(map(lambda`` x:`` x^2,`` x_values))`
    to compute ∑ *X*[i]².
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '各种总和以及平方和并不是特别难以计算的值。内置的`sum()`函数是大多数计算的基础。我们可以使用`sum(map(lambda x: x**2, x_values))`来计算
    ∑ *X*[i]²。'
- en: To clarify these multivariate relationships, diagrams can be very helpful. In
    the next sections, we’ll look at the most important type of diagram that needs
    to be part of the overall application.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 为了阐明这些多元关系，图表可以非常有帮助。在接下来的章节中，我们将探讨需要成为整体应用一部分的最重要类型的图表。
- en: 16.1.3 Diagrams
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.1.3 图表
- en: 'One essential diagram for showing multivariate data is the X-Y “scatter” plot.
    In [*Chapter** 13*](ch017.xhtml#x1-29700013), [*Project 4.1: Visual Analysis Techniques*](ch017.xhtml#x1-29700013)
    we looked at ways to create these. In that chapter, we relied on Jupyter Lab to
    present the diagram as part of the overall web page. For this application, we’ll
    need to embed the diagram into a document.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 显示多元数据的一个基本图表是X-Y“散点”图。在[*第13章*](ch017.xhtml#x1-29700013)，[*项目4.1：可视化分析技术*](ch017.xhtml#x1-29700013)中，我们探讨了创建这些图表的方法。在那个章节中，我们依赖于Jupyter
    Lab将图表作为整体网页的一部分进行展示。对于这个应用，我们需要将图表嵌入到文档中。
- en: This generally means there will be a markup document that includes a reference
    to a diagram file. The format of the diagram file can be SVG, PNG, or even JPEG.
    For technical graphics, the SVG files are often the smallest and scale extremely
    well.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常意味着将有一个包含对图表文件引用的标记文档。图表文件的格式可以是SVG、PNG，甚至是JPEG。对于技术图形，SVG文件通常是最小的，并且缩放效果非常好。
- en: Each markup language, including Markdown, RST, HTML, and LaTeX, have unique
    ways to identify the place where an image needs to be inserted. In the case of
    Markdown, it’s often necessary to use HTML syntax to properly include frames and
    captions.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 每种标记语言，包括Markdown、RST、HTML和LaTeX，都有独特的方式来标识需要插入图像的位置。在Markdown的情况下，通常需要使用HTML语法来正确地包括框架和标题。
- en: Now that we’ve seen what the application needs to do, we can look at an approach
    to create the software.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了应用程序需要做什么，我们可以看看创建软件的方法。
- en: 16.2 Approach
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 16.2 方法
- en: 'As with the previous project, this application works in these two distinct
    parts:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 与上一个项目一样，这个应用程序分为两个不同的部分：
- en: Compute the statistics and create the diagram files.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算统计量并创建图表文件。
- en: Create a report file in a simplified markup language from a template with the
    details interpolated. A tool like **Jinja** is very helpful for this.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从模板中创建一个简化标记语言的报表文件，并插入详细信息。像**Jinja**这样的工具对此非常有帮助。
- en: Once the report file in a markup language — like Markdown or RST — is available,
    then a tool like **Pandoc** can be used to create an HTML page or a PDF document
    from the markup file. Using a tool like **Pandoc** permits quite a bit of flexibility
    in choosing the final format. It also allows the insertion of style sheets and
    page templates in a tidy, uniform way.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦有了标记语言（如Markdown或RST）的报表文件，就可以使用像**Pandoc**这样的工具将标记文件转换为HTML页面或PDF文档。使用**Pandoc**这样的工具允许在最终格式选择上具有相当大的灵活性。它还允许以整洁、统一的方式插入样式表和页面模板。
- en: The LaTeX language as markup provides the most comprehensive capabilities. It
    is challenging to work with, however. Languages like Markdown and RST are designed
    to offer fewer, easier-to-use capabilities.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 作为标记语言的LaTeX语言提供了最全面的特性。然而，它的工作是具有挑战性的。像Markdown和RST这样的语言被设计为提供更少、更容易使用的特性。
- en: This book is written with LaTeX.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书是用LaTeX编写的。
- en: 'We’ll look at three aspects of this application: the statistical computations,
    creating the diagrams, and finally, creating the final markup file to include
    the diagrams. We’ll start with a quick review of the statistical computations.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨这个应用程序的三个方面：统计计算、创建图表，最后是创建包含图表的最终标记文件。我们将从对统计计算的快速回顾开始。
- en: 16.2.1 Statistical computations
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.2.1 统计计算
- en: The statistical summary output file, in TOML notation, has a section for each
    variable and the univariate statistics about those variables.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 统计摘要输出文件，在TOML表示法中，为每个变量及其变量的单变量统计提供了一个部分。
- en: 'This section of the file looked like the following snippet of TOML:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 文件的这个部分看起来像以下TOML片段：
- en: '[PRE0]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'When parsed, the TOML syntax of `x.location` and `x.spread` creates a dictionary
    that looks like the following fragment of a Python object:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当解析时，`x.location`和`x.spread`的TOML语法创建了一个类似于以下Python对象片段的字典：
- en: '[PRE1]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This structure can be expanded to include additional locations and spread statistical
    measures. It can also be expanded to include multivariate statistics. The `statistics`
    module has `correlation()` and `covariance()` functions, making it easy to include
    these measures.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这种结构可以扩展以包括额外的位置和分布统计量。它还可以扩展以包括多元统计。`statistics`模块有`correlation()`和`covariance()`函数，这使得包括这些度量变得容易。
- en: 'For datasets with few variables, it’s common to consider a matrix that includes
    all the combinations of covariance between variables. This leads to two alternative
    representations of these additional statistics:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 对于变量较少的数据集，通常考虑一个包括变量之间所有协方差组合的矩阵。这导致这些附加统计量的两种替代表示：
- en: A separate section for a covariance matrix. A section label of `[covariance]`
    can be followed by nested dictionaries that include all combinations of variables.
    Since the covariance matrix is symmetric, all *n*² combinations aren’t needed;
    only *n*× (*n*− 1) values are unique.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为协方差矩阵单独划分一个部分。标签为`[covariance]`的部分可以跟随着嵌套的字典，包括所有变量的组合。由于协方差矩阵是对称的，不需要所有的*n*²组合；只需要*n*×
    (*n*− 1)个独特的值。
- en: Multivariate sub-sections within each variable’s section. This means we’d have
    `x.location`, `x.spread`, `x.covariance.y`, and `x.correlation.y` sub-sections
    for the `x` variable.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个变量部分内的多元子部分。这意味着对于`x`变量，我们将有`x.location`、`x.spread`、`x.covariance.y`和`x.correlation.y`子部分。
- en: For a dataset with fewer variables, it seems sensible to bundle covariance and
    correlation into the details for a given variable. In the case of Anscombe’s Quartet,
    with only two variables, the covariance and correlation seem like they belong
    with the other statistics.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 对于变量较少的数据集，将协方差和相关性捆绑到给定变量的细节中似乎是合理的。在 Anscombe 的四重奏的情况下，只有两个变量，协方差和相关性似乎应该与其他统计数据放在一起。
- en: For a dataset with a larger number of variables, the covariance among all the
    variables can become bewildering. In these cases, a technique like finding principal
    components might be needed to reduce the number of variables to a more manageable
    population. In this case, separate sections with covariance and auto-correlation
    might be more useful.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 对于具有更多变量的数据集，所有变量之间的协方差可能会变得令人困惑。在这些情况下，可能需要像寻找主成分这样的技术来将变量的数量减少到更易于管理的数量。在这种情况下，带有协方差和自相关的单独部分可能更有用。
- en: The resulting model is often the result of some careful thought, based on the
    covariance matrix. For this reason, a separate `[model]` section should be provided
    with some details about the model’s structure and the coefficients. In the case
    of a linear model, there are two coefficients, sometimes called *β*[0] and *β*[1].
    We’ve called them *b* and *m*.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 结果模型通常是基于协方差矩阵的某些仔细思考的结果。因此，应该提供一个单独的 `[model]` 部分，其中包含有关模型结构和系数的一些详细信息。在线性模型的情况下，有两个系数，有时称为
    *β*[0] 和 *β*[1]。我们称它们为 *b* 和 *m*。
- en: For Python 3.11, the included `tomllib` module doesn’t create TOML-format files.
    It’s, therefore, necessary to properly format a text file that can be parsed by
    the `tomllib` module. It’s helpful to use a Jinja template for this.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Python 3.11，包含的 `tomllib` 模块不会创建 TOML 格式的文件。因此，有必要正确格式化一个文本文件，该文件可以被 `tomllib`
    模块解析。使用 Jinja 模板来做这件事是有帮助的。
- en: 16.2.2 Analysis diagrams
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.2.2 分析图
- en: Diagrams must first be created. Once created, they can then be included in a
    document. The process of creating a diagram is nearly identical to the approach
    used in Jupyter Lab. A few extra steps need to be taken to export the diagram
    to a file that can be imported into a document.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图表必须首先创建。一旦创建，就可以将其包含在文档中。创建图表的过程几乎与 Jupyter Lab 中使用的方法相同。需要采取一些额外的步骤来将图表导出为可以导入到文档中的文件。
- en: 'When working in Jupyter Lab, some cells to load the data are required to create
    two variables, `x` and `y`, with the values to be plotted. After these cells,
    a cell like the following example will create and display a scatter plot:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当在 Jupyter Lab 中工作时，需要一些加载数据的单元格来创建两个变量，`x` 和 `y`，用于绘制值。在这些单元格之后，一个类似于以下示例的单元格将创建并显示一个散点图：
- en: '[PRE2]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This presumes previous cells have loaded clean data and extracted two list objects,
    `x` and `y`, with the values to be plotted.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这假设之前的单元格已经加载了干净的数据并提取了两个列表对象，`x` 和 `y`，用于绘制值。
- en: 'The above code sample doesn’t save the resulting PNG or SVG file, however.
    To save the figure, we need to perform two more steps. Here are the lines of code
    required to create a file from the plot:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，上述代码示例并没有保存生成的 PNG 或 SVG 文件。要保存图形，我们需要执行两个额外的步骤。以下是创建来自图形的文件的代码行：
- en: '[PRE3]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: It helps to transform this cell’s code into a function. This function has proper
    type annotations so that a tool like **mypy** can confirm the types are used properly.
    It can also have unit test cases to be sure it really works.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 将此单元格的代码转换为函数可能会有所帮助。这个函数有适当的类型注解，以便像 **mypy** 这样的工具可以确认类型被正确使用。它还可以有单元测试用例以确保它确实有效。
- en: The `savefig()` function will write a new file in PNG format with the image.
    If the file path suffix is `’.jpg’` then an SVG format file will be created.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`savefig()` 函数将使用 PNG 格式写入包含图像的新文件。如果文件路径后缀是 `’.jpg’`，则将创建 SVG 格式的文件。'
- en: The size of the figure is defined by the `figure()` function. There are often
    design and page layout considerations that suggest an appropriate size for a figure.
    This decision can be deferred, and the size can be provided by the markup used
    to create a final PDF file or HTML page. It’s often best, however, to create the
    figure in the required size and resolution to avoid any unexpected alterations
    as part of the final publication.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图形的尺寸由 `figure()` 函数定义。通常会有设计和页面布局考虑因素，这表明图形的适当大小。这个决定可以推迟，大小可以通过创建最终 PDF 文件或
    HTML 页面时使用的标记来提供。然而，通常最好创建所需大小和分辨率的图形，以避免在最终出版物中发生任何意外的更改。
- en: Once the diagram has been created, the Markdown needs to refer to the diagram’s
    PNG or SVG file so it can be included in a document. We’ll look at some examples
    of this in the next section.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了图表，Markdown就需要引用图表的PNG或SVG文件，以便将其包含在文档中。我们将在下一节中查看一些此类示例。
- en: 16.2.3 Including diagrams in the final document
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.2.3 在最终文档中包含图表
- en: Diagrams are included in the final document by using markup commands to show
    where the diagram should be placed, and providing other information about captions
    and sizing.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用标记命令来显示图表应放置的位置，并提供有关标题和尺寸的其他信息，将图表包含在最终文档中。
- en: 'The Markdown language has a tidy format for the simplest case of including
    an image in a document:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Markdown语言有一个整洁的格式，用于在文档中最简单的情况中包含图像：
- en: '[PRE4]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Depending on the style sheet, this may be perfectly acceptable. In some cases,
    the image is the wrong size for its role in the document. Markdown permits using
    HTML directly instead of the `![image!](path)` construct. Including a diagram
    often looks like this:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 根据样式表，这可能是完全可接受的。在某些情况下，图像的大小不适合其在文档中的作用。Markdown允许直接使用HTML而不是`![image!](path)`结构。包括图表通常如下所示：
- en: '[PRE5]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Using HTML permits more control over image size and placement via references
    to CSS.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 使用HTML可以通过引用CSS来对图像大小和位置进行更多控制。
- en: 'When using RST, the syntax offers more options without switching to HTML. Including
    a diagram would be like this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用RST时，语法提供了更多选项，无需切换到HTML。包括图表的方式如下：
- en: '[PRE6]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Using this kind of markup technique creates considerable freedom. The report’s
    author can include content from a variety of sources. This can include boilerplate
    text that doesn’t change, the results of computations, some text based on the
    computations, and important diagrams.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种类型的标记技术可以提供相当大的自由度。报告的作者可以包括来自各种来源的内容。这可以包括不更改的样板文本、计算结果、基于计算的某些文本以及重要的图表。
- en: The formatting of the markup has little impact on the final document. The way
    a browser renders HTML depends on the markup and the style sheets, not the formatting
    of the source file. Similarly, when creating a PDF document, this is often done
    by LaTeX tools, which create the final document based on LaTeX settings in the
    document’s preamble.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 标记的格式对最终文档的影响很小。浏览器渲染HTML的方式取决于标记和样式表，而不是源文件的格式。同样，在创建PDF文档时，这通常是通过LaTeX工具完成的，这些工具根据文档前言中的LaTeX设置创建最终文档。
- en: Now that we have an approach, we can look at the deliverable files that must
    be built.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了方法，我们可以查看必须构建的可交付成果文件。
- en: 16.3 Deliverables
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 16.3 可交付成果
- en: 'This project has the following deliverables:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 此项目有以下可交付成果：
- en: Documentation in the `docs` folder.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文档位于`docs`文件夹中。
- en: Acceptance tests in the `tests/features` and `tests/steps` folders.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接受测试位于`tests/features`和`tests/steps`文件夹中。
- en: Unit tests for model module classes in the `tests` folder.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对位于`tests`文件夹中的模型模块类进行的单元测试。
- en: Mock objects for the `csv_extract` module tests that will be part of the unit
    tests.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将作为单元测试一部分的`csv_extract`模块测试的模拟对象。
- en: Unit tests for the `csv_extract` module components that are in the `tests` folder.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对位于`tests`文件夹中的`csv_extract`模块组件进行的单元测试。
- en: An application to extend the summary written to a TOML file, including figures
    with diagrams.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个扩展到TOML文件的总结的应用程序，包括带有图表的图形。
- en: An application secondary feature to transform the TOML file to an HTML page
    or PDF file with the summary.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个将TOML文件转换为包含总结的HTML页面或PDF文件的应用程序二级功能。
- en: We’ll look at a few of these deliverables in a little more detail. We’ll start
    with some suggestions for creating the acceptance tests.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将更详细地查看一些这些可交付成果。我们将从创建接受测试的建议开始。
- en: 16.3.1 Acceptance tests
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.3.1 接受测试
- en: As we noted in the previous chapter’s section on acceptance testing, [*Acceptance*
    *testing*](ch019.xhtml#x1-3340001), the output TOML document can be parsed and
    examined by the `Then` steps of a scenario. Because we’re looking at Anscombe’s
    Quartet data in the examples in this book, a subset of data for testing doesn’t
    really make much sense. For any other dataset, a subset should be extracted and
    used for acceptance testing.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在前一章关于接受测试的章节中所述，[*接受测试*](ch019.xhtml#x1-3340001)，输出TOML文档可以被场景的`Then`步骤解析和检查。由于本书中的示例是查看Anscombe的四重奏数据，因此为测试提取的数据子集实际上并没有太多意义。对于任何其他数据集，都应该提取子集并用于接受测试。
- en: It is often helpful to extract a small subset that’s used for acceptance testing.
    Instead of processing millions of rows, a few dozen rows are adequate to confirm
    the application read and summarized data. The data should be representative of
    the entire set of samples under consideration.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，提取用于验收测试的小子集是有帮助的。与其处理数百万行数据，不如处理几十行数据就足以确认应用程序已读取并总结了数据。数据应该是考虑的整个样本集的代表。
- en: This subset is part of the testing suite; as such, it rarely changes. This makes
    the results predictable.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这个子集是测试套件的一部分；因此，它很少改变。这使得结果可预测。
- en: The secondary feature of this application — expanding on the TOML output to
    add extensive Markdown — also works with text files. This makes it relatively
    easy to create scenarios to confirm the correct behavior by reading and writing
    text files. In many cases, the `Then` steps will look for a few key features of
    the resulting document. They may check for specific section titles or a few important
    keywords included in boilerplate text. Of course, the test scenario can check
    for substitution values that are computed and are part of the TOML summary.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用程序的次要功能——在TOML输出中扩展以添加广泛的Markdown——也适用于文本文件。这使得通过读取和写入文本文件来确认正确行为的情况相对容易。在许多情况下，`Then`步骤将查找结果文档的一些关键特征。它们可能会检查特定的部分标题或包含在模板文本中的几个重要关键词。当然，测试场景可以检查计算出的替换值，这些值是TOML摘要的一部分。
- en: The automated testing can’t easily confirm that the document makes sense to
    prospective readers. It can’t be sure the colors chosen for the figures make the
    relationships clear. For this kind of usability test, a good copy editor or trusted
    associate is essential.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 自动测试很难确认文档对潜在读者是有意义的。它不能确定所选的图形颜色是否使关系清晰。对于这种可用性测试，一个好的校对编辑器或可信赖的合作伙伴是必不可少的。
- en: 16.3.2 Unit tests
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.3.2 单元测试
- en: A unit test for a function to create a figure can’t do very much. It’s limited
    to confirming that a PNG or SVG file was created. It’s difficult for an automated
    test to “look” at the image to be sure it has a title, labels for the axes, and
    sensible colors.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 对于创建图形的函数的单元测试做不了太多。它限于确认是否创建了PNG或SVG文件。自动测试很难“看”到图像以确保它有标题、轴标签和合理的颜色。
- en: It is important not to overlook the unit test cases that confirm output files
    are created. A figure that looks great in a Jupyter notebook will not get written
    to a file unless the CLI application saves the figure to a file.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是不要忽视确认输出文件已创建的单元测试用例。一个在Jupyter笔记本中看起来很棒的图形不会写入文件，除非CLI应用程序将图形保存到文件中。
- en: For some applications, it makes sense to mock the `plt` package functions to
    be sure the application calls the right functions with the expected argument values.
    Note that a mocked version of `plt.subplots()` may need to return a tuple with
    several `Mock` objects.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些应用，模拟`plt`包函数以确保应用程序使用预期的参数值调用正确的函数是有意义的。请注意，模拟版本的`plt.subplots()`可能需要返回一个包含多个`Mock`对象的元组。
- en: 'We’ll need to define a complex collection of mock objects to form the fixture
    for testing. The fixture creation can look like the following example:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要定义一个复杂的模拟对象集合来形成测试的固定装置。固定装置的创建可能看起来像以下示例：
- en: '[PRE7]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This fixture creates three mock objects. The `plt_mock` is a mock of the overall
    `plt` module; it defines three mock functions that will be used by the application.
    The `fig_mock` is a mock of the figure object returned by the `subplots()` function.
    The `ax_mock` is a mock of the axes object, which is also returned by the `subplots()`
    function. This mocked axes object is used to provide axis labels, and the title,
    and perform the scatter plot request.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这个固定装置创建了三个模拟对象。`plt_mock`是对整体`plt`模块的模拟；它定义了三个将被应用程序使用的模拟函数。`fig_mock`是对由`subplots()`函数返回的图形对象的模拟。`ax_mock`是对由`subplots()`函数返回的轴对象的模拟。这个模拟的轴对象用于提供轴标签、标题并执行散点图请求。
- en: 'This three-tuple of mock objects is then used by a test as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 然后这个由三个模拟对象组成的元组被测试如下：
- en: '[PRE8]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This test function evaluates the application’s `scatter_figure()` function.
    The test function then confirms that the various functions from the `plt` module
    are called with the expected argument values.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试函数评估应用程序的`scatter_figure()`函数。然后测试函数确认来自`plt`模块的各种函数是否使用预期的参数值被调用。
- en: The test can continue by looking at the calls to the `ax_mock` object to see
    if the labels and title requests were made as expected. This level of detail —
    looking at the calls to the axes object — may be a bit too fine-grained. These
    tests become very brittle as we explore changing titles or colors to help make
    a point more clearly.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看对`ax_mock`对象的调用，可以继续测试以查看标签和标题请求是否按预期进行。这种详细程度——查看对坐标轴对象的调用——可能过于细致。当我们探索更改标题或颜色以更清晰地表达观点时，这些测试变得非常脆弱。
- en: The overall use of mock objects, however, helps make sure the application will
    create the needed file with an image.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用模拟对象的整体使用有助于确保应用程序将创建所需的包含图像的文件。
- en: 16.4 Summary
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 16.4 摘要
- en: In this chapter, we’ve extended the automated analysis and reporting to include
    more use of the built-in `statistics` library to compute correlation and linear
    regression coefficients. We’ve also made use of the **matplotlib** library to
    create images that reveal relationships among variables.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们扩展了自动分析和报告，包括更多使用内置的`statistics`库来计算相关性和线性回归系数。我们还利用了**matplotlib**库来创建揭示变量之间关系的图像。
- en: The objective of automated reporting is designed to reduce the number of manual
    steps and avoid places where omissions or errors can lead to unreliable data analysis.
    Few things are more embarrassing than a presentation that reuses a diagram from
    the previous period’s data. It’s far too easy to fail to rebuild one important
    notebook in a series of analysis products.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 自动报告的目标是设计用来减少手动步骤并避免遗漏或错误可能导致不可靠数据分析的地方。没有什么比重复使用上一期数据的图表更尴尬的了。在一系列分析产品中未能重建一个重要的笔记本是极其容易发生的。
- en: The level of automation needs to be treated with a great deal of respect. Once
    a reporting application is built and deployed, it must be actively monitored to
    be sure it’s working and producing useful, informative results. The analysis job
    shifts from developing an understanding to monitoring and maintaining the tools
    that confirm — or reject — that understanding.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化的程度需要得到极大的尊重。一旦报告应用程序构建并部署，就必须积极监控以确保其正常工作并产生有用、信息丰富的结果。分析工作从开发理解转变为监控和维护确认或拒绝该理解的工具。
- en: In the next chapter, we’ll review the journey from raw data to a polished suite
    of applications that acquires, cleans, and summarizes the data.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将回顾从原始数据到经过精炼的应用程序套件的过程，这些应用程序获取、清理和总结数据。
- en: 16.5 Extras
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 16.5 补充内容
- en: Here are some ideas for you to add to this project.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些想法供您添加到这个项目中。
- en: 16.5.1 Use pandas to compute basic statistics
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.5.1 使用pandas计算基本统计
- en: The **pandas** package offers a robust set of tools for doing data analysis.
    The core concept is to create a `DataFrame` that contains the relevant samples.
    The `pandas` package needs to be installed and added to the `requirements.txt`
    file.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**pandas**包提供了一套强大的工具用于数据分析。核心概念是创建包含相关样本的`DataFrame`。需要安装`pandas`包并将其添加到`requirements.txt`文件中。'
- en: There are methods for transforming a sequence of `SeriesSample` objects into
    a `DataFrame`. The best approach is often to convert each of the **pydantic**
    objects into a dictionary, and build the dataframe from the list of dictionaries.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 有将`SeriesSample`对象序列转换为`DataFrame`的方法。通常最好的方法是将每个**pydantic**对象转换为字典，然后从字典列表构建数据框。
- en: 'The idea is something like the following:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 想法类似于以下内容：
- en: '[PRE9]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this example, the value of `series_data` is a sequence of `SeriesSample`
    instances.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`series_data`的值是一系列`SeriesSample`实例。
- en: Each column in the resulting dataframe will be one of the variables of the sample.
    Given this object, methods of the `DataFrame` object produce useful statistics.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 结果数据框中的每一列都将包含样本中的一个变量。给定此对象，`DataFrame`对象的方法可以产生有用的统计数据。
- en: The `corr()` function, for example, computes the correlation values among all
    of the columns in the dataframe.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`corr()`函数计算数据框中所有列之间的相关值。
- en: The `cov()` function computes the pairwise covariance among the columns in the
    dataframe.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`cov()`函数计算数据框中列之间的成对协方差。'
- en: Pandas doesn’t compute the linear regression parameters, but it can create a
    wide variety of descriptive statistics.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Pandas不计算线性回归参数，但它可以创建各种描述性统计。
- en: See [https://pandas.pydata.org](https://pandas.pydata.org) for more information
    on Pandas.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Pandas的更多信息，请参阅[https://pandas.pydata.org](https://pandas.pydata.org)。
- en: 'In addition to a variety of statistics computations, this package is designed
    for interactive use. It works particularly well with Juypyter Lab. The interested
    reader may want to revisit [*Chapter** 13*](ch017.xhtml#x1-29700013), [*Project
    4.1: Visual Analysis Techniques*](ch017.xhtml#x1-29700013) using Pandas instead
    of native Python.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 除了各种统计计算之外，这个包还设计用于交互式使用。它与 Juypyter Lab 工作得特别出色。感兴趣的读者可能想重新阅读[*第13章*](ch017.xhtml#x1-29700013)，[*项目4.1：可视化分析技术*](ch017.xhtml#x1-29700013)，使用
    Pandas 而不是原生 Python。
- en: 16.5.2 Use the dask version of pandas
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.5.2 使用 pandas 的 dask 版本
- en: The **pandas** package offers a robust set of tools for doing data analysis.
    When the volume of data is vast, it helps to process parts of the dataset concurrently.
    The **Dask** project has an implementation of the **pandas** package that maximizes
    opportunities for concurrent processing.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '**pandas**包提供了一套强大的工具，用于进行数据分析。当数据量巨大时，同时处理数据集的一部分会有所帮助。**Dask**项目实现了**pandas**包，最大限度地提高了并发处理的机会。'
- en: The `dask` package needs to be installed and added to the `requirements.txt`
    file. This will include a `pandas` package that can be used to improve overall
    application performance.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`dask`包需要安装并添加到`requirements.txt`文件中。这将包括一个`pandas`包，可以用来提高整体应用性能。'
- en: 16.5.3 Use numpy for statistics
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.5.3 使用 numpy 进行统计
- en: The **numpy** package offers a collection of tools for doing high-performance
    processing on large arrays of data. These basic tools are enhanced with libraries
    for statistics and linear algebra among many, many other features. This package
    needs to be installed and added to the `requirements.txt` file.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '**numpy**包提供了一套用于在大数据数组上进行高性能处理的工具。这些基本工具通过统计和线性代数等众多库进行了增强。此包需要安装并添加到`requirements.txt`文件中。'
- en: The **numpy** package works with its own internal array type. This means the
    `SeriesSample` objects aren’t used directly. Instead, a `numpy.array` object can
    be created for each of the variables in the source series.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '**numpy**包使用其自己的内部数组类型。这意味着`SeriesSample`对象不会被直接使用。相反，可以为源序列中的每个变量创建一个`numpy.array`对象。'
- en: 'The conversion might look like the following:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 转换可能看起来像以下这样：
- en: '-'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '-'
- en: '[PRE10]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this example, the value of `series_data` is a sequence of `SeriesSample`
    instances.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`series_data`的值是一系列`SeriesSample`实例。
- en: It’s also sensible to create a single multi-dimensional array. In this case,
    axis 0 (i.e. rows) will be the individual samples, and axis 1 (i.e. columns) will
    be the values for each variable of the sample.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个单一的多维数组也是合理的。在这种情况下，轴0（即行）将是单个样本，轴1（即列）将是样本中每个变量的值。
- en: 'An array has methods like `mean()` to return the mean of the values. When using
    a multi-dimensional array, it’s essential to provide the `axis=0` parameter to
    ensure that the results come from processing the collection of rows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 数组有`mean()`等方法来返回值的平均值。当使用多维数组时，提供`axis=0`参数是至关重要的，以确保结果来自对行集合的处理：
- en: '[PRE11]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: See [https://numpy.org/doc/stable/reference/routines.statistics.html#](https://numpy.org/doc/stable/reference/routines.statistics.html#)
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 查看[https://numpy.org/doc/stable/reference/routines.statistics.html#](https://numpy.org/doc/stable/reference/routines.statistics.html#)
- en: Using the least squares technique to compute the coefficients for a line can
    be confusing. The least squares solver in **numpy.linalg** is a very general algorithm,
    which can be applied to creating a linear model. The `numpy.linalg.lstsq()` function
    expects a small matrix that contains the ”x” values. The result will be a vector
    with the same length as each of the ”x” matrices. The ”y” values will also be
    a vector.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 使用最小二乘法计算直线的系数可能会令人困惑。**numpy.linalg**中的最小二乘求解器是一个非常通用的算法，可以应用于创建线性模型。`numpy.linalg.lstsq()`函数期望一个包含“x”值的矩阵。结果将是一个与每个“x”矩阵长度相同的向量。“y”值也将是一个向量。
- en: 'The processing winds up looking something like the following:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 处理过程可能看起来像以下这样：
- en: '[PRE12]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The value of `A` is a small matrix based on the x values. The value of `y` is
    a simple array of the y values. The least-squares algorithm returns a four-tuple
    with the coefficients, residuals, the rank of the source matrix, and any singular
    values. In the above example, we only wanted the vector of the coefficients, so
    we used `[0]` to extract the coefficient values from the four-tuple with the results.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`A`的值是基于x值的小矩阵。`y`的值是y值的简单数组。最小二乘算法返回一个包含系数、残差、源矩阵的秩和任何奇异值的四元组。在上面的例子中，我们只想得到系数向量，所以我们使用`[0]`从四元组结果中提取系数值。'
- en: 'This is further decomposed to extract the two coefficients for the line that
    best fits this set of points. See: [https://numpy.org/doc/stable/reference/generated/numpy.linalg.lstsq.html](https://numpy.org/doc/stable/reference/generated/numpy.linalg.lstsq.html).'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这进一步分解以提取最适合这组点的直线的两个系数。参见：[https://numpy.org/doc/stable/reference/generated/numpy.linalg.lstsq.html](https://numpy.org/doc/stable/reference/generated/numpy.linalg.lstsq.html)。
- en: This approach has a distinct advantage when working with very large sets of
    data. The **numpy** libraries are very fast and designed to scale to extremely
    large data volumes.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理非常大的数据集时，这种方法具有明显的优势。**numpy** 库非常快速，并设计用于扩展到极大规模的数据量。
- en: 16.5.4 Use scikit-learn for modeling
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.5.4 使用 scikit-learn 进行建模
- en: The **scikit-learn** library has a vast number of tools focused on modeling
    and machine learning. This library is built on the foundation of **numpy**, so
    both packages need to be installed.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '**scikit-learn** 库拥有大量专注于建模和机器学习的工具。这个库建立在 **numpy** 的基础上，因此需要安装这两个包。'
- en: The data needs to be converted into **numpy** arrays. Because the modeling approach
    is very generalized, the assumption is there may be multiple independent variables
    that predict the value of a dependent variable.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 数据需要转换为 **numpy** 数组。由于建模方法非常通用，假设可能有多个独立变量可以预测因变量的值。
- en: 'The conversion might look like the following:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 转换可能看起来像以下这样：
- en: '[PRE13]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this example, the value of `series_data` is a sequence of `SeriesSample`
    instances. The `x` array uses a very short vector for each sample; in this case,
    there’s only a single value. It needs to be a vector to fit the generalized least-squares
    regression that **scikit-learn** is capable of solving.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`series_data` 的值是一系列 `SeriesSample` 实例。`x` 数组为每个样本使用一个非常短的向量；在这种情况下，只有一个值。它需要是一个向量，以便适合
    **scikit-learn** 能够解决的广义最小二乘回归。
- en: The scikit-learn library is designed to create models in a very generalized
    way. The model isn’t always a simple line with a coefficient and an intercept
    that define the relationship. Because of this very general approach to modeling,
    we’ll create an instance of the `linear_model.LinearRegression` class. This object
    has methods to create coefficients that fit a given set of data points. We can
    then examine the coefficients, or use them to interpolate new values.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: scikit-learn 库被设计成以非常通用的方式创建模型。模型不总是由一个具有系数和截距的简单直线定义的关系。正因为这种非常通用的建模方法，我们将创建
    `linear_model.LinearRegression` 类的实例。该对象具有创建适合给定数据点的系数的方法。然后我们可以检查这些系数，或使用它们来插值新值。
- en: 'The code might look like the following:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 代码可能看起来像以下这样：
- en: '[PRE14]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The linear model’s `coef_` attribute is a vector of coefficients, the same length
    as each row of the `x` independent variable values. Even when the row length is
    1, the result is a vector with a length of 1.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 线性模型的 `coef_` 属性是一个系数向量，其长度与 `x` 自变量值的每一行相同。即使行长度为 1，结果也是一个长度为 1 的向量。
- en: Because this works with **numpy** it can work with very large sets of data.
    Further, the scikit-learn approach to creating models to fit data generalizes
    to a number of machine-learning approaches. This is often the next step in creating
    richer and more useful models.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它与 **numpy** 一起工作，它可以处理非常大的数据集。此外，scikit-learn 创建适合数据的模型的方法可以推广到多种机器学习方法。这通常是创建更丰富、更有用模型的下一步。
- en: 16.5.5 Compute the correlation and regression using functional programming
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.5.5 使用函数式编程计算相关性和回归
- en: 'The computations for correlation and the coefficients for a line can be summarized
    as follows. First, we’ll define a function *M*(*a*;*f*()) that computes the mean
    of a transformed sequence of values. The *f*() function transforms each value,
    *a*[i]. An identity function, *ϕ*(*a*[i]) = *a*[i], does no transformation:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 相关系数和直线的计算可以总结如下。首先，我们将定义一个函数 *M*(*a*;*f*())，该函数计算转换值序列的平均值。*f*() 函数将每个值 *a*[i]
    进行转换。恒等函数 *ϕ*(*a*[i]) = *a*[i] 不进行任何转换：
- en: '![M (a;f()) = 1-∑ f(a) N i ](img/file68.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![M (a;f()) = 1-∑ f(a) N i ](img/file68.jpg)'
- en: We’ll also need a function to compute the standard deviation for a variable,
    *a*.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一个函数来计算变量 *a* 的标准差。
- en: '![ ∘ -∑--------- --(ai −-¯a)2 S (a) = N ](img/file69.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![ ∘ -∑--------- --(ai −-¯a)2 S (a) = N ](img/file69.jpg)'
- en: This lets us define a number of related values as mean values after some transformation.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许我们在某些转换后定义一系列相关值作为平均值。
- en: '![¯x = M (x;f(ai) = ai) ](img/file70.jpg)![¯y = M (y;f(ai) = ai) ](img/file71.jpg)![---
    x2 = M (x;f(ai) = a2i) ](img/file72.jpg)![--- y2 = M (y;f(ai) = a2i) ](img/file73.jpg)![---
    xy = M (x,y;f(ai,bi) = ai × bi) ](img/file74.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![¯x = M (x;f(ai) = ai) ](img/file70.jpg)![¯y = M (y;f(ai) = ai) ](img/file71.jpg)![---
    x2 = M (x;f(ai) = a2i) ](img/file72.jpg)![--- y2 = M (y;f(ai) = a2i) ](img/file73.jpg)![---
    xy = M (x,y;f(ai,bi) = ai × bi) ](img/file74.jpg)'
- en: From these individual values, we can compute the correlation coefficient, *r*[xy].
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 从这些个别值中，我们可以计算出相关系数 *r*[xy]。
- en: '![ --- -----xy-−-¯xy¯------ rxy = ∘ --2---2---2----2- (x − ¯x )(y − y¯) ](img/file75.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![ --- -----xy-−-¯xy¯------ rxy = ∘ --2---2---2----2- (x − ¯x )(y − y¯) ](img/file75.jpg)'
- en: In addition to the above values, we need two more values for the standard deviations
    of the two variables.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 除了上述值之外，我们还需要两个变量标准差的值。
- en: '![sx = S(x)sy = S(y) ](img/file76.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![sx = S(x)sy = S(y) ](img/file76.jpg)'
- en: From the correlation coefficient, and the two standard deviations, we can compute
    the coefficient of the line, *m*, and the intercept value, *b*.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 从相关系数和两个标准差中，我们可以计算出直线的系数 *m* 和截距值 *b*。
- en: '![m = rxysy sx ](img/file77.jpg)![b = ¯y − m ¯x ](img/file78.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![m = rxysy sx ](img/file77.jpg)![b = ¯y − m ¯x ](img/file78.jpg)'
- en: This yields the coefficient, *m*, and intercept, *b*, for the equation *y* =
    *mx* + *b*, which minimizes the error between the given samples and the line.
    This is computed using one higher-order function, *M*(*a*;*f*()), and one ordinary
    function, *S*(*a*). This doesn’t seem to be a significant improvement over other
    methods. Because it’s built using standard library functions and functional programming
    techniques, it can be applied to any Python data structure. This can save the
    step of transforming data into **numpy** array objects.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这给出了方程 *y* = *mx* + *b* 的系数 *m* 和截距 *b*，该方程最小化了给定样本与直线之间的误差。这是通过一个高阶函数 *M*(*a*;*f*())
    和一个普通函数 *S*(*a*) 来计算的。这似乎并没有比其他方法有显著的改进。因为它使用了标准库函数和函数式编程技术，所以它可以应用于任何 Python
    数据结构。这可以节省将数据转换为 **numpy** 数组对象的一步。
