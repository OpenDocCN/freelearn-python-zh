<html><head></head><body>
        

                            
                    <h1 class="header-title">Simulating Robot Behavior with Gazebo</h1>
                
            
            
                
<p>This chapter deals with the dynamic simulation of a robot, which, conceptually, is a better approach to examining the actual behavior of the robot rather than just using software. Rigid body mechanics, including mass and inertia, friction, damping, motor controllers, sensor detection properties, noise signals, and every aspect of the robot and the environment that can be retained in a model with reasonable accuracy is much less expensive when replicated in a simulator than if you tried to do this with physical hardware.</p>
<p>By reading this chapter, you will learn how to plug the digital definition of your robot (the URDF file) into the simulation environment of <strong>Gazebo</strong>, which is powered with a physics engine that's able to emulate realistic behaviors. You will also extend your training by checking and testing the digital robot so that its behavior represents what should happen in the physical world.</p>
<p>To achieve ROS integration with Gazebo, a set of ROS packages grouped under <kbd>gazebo_ros_pkgs</kbd> (<a href="http://wiki.ros.org/gazebo_ros_pkgs">http://wiki.ros.org/gazebo_ros_pkgs</a>) provides the required wrappers. These packages provide the interfaces that are used to simulate a robot in Gazebo using ROS messages, services, and reconfigurable ROS parameters.</p>
<p class="mce-root">By following a guided path, you will become familiar with the ROS simulation environment of Gazebo. Specifically, you will learn how to prepare the model of a robot in order to simulate realistic behavior with the Gazebo physics engine. Finally, you will simulate the maximum weight that GoPiGo3 can carry and compare this with the real world.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Getting started with the Gazebo simulator</li>
<li>Making modifications to the robot URDF</li>
<li>Verifying a Gazebo model and viewing the URDF</li>
<li>Moving your model around</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Technical requirements</h1>
                
            
            
                
<p>The code files for this chapter can be found at <a href="https://github.com/PacktPublishing/Hands-On-ROS-for-Robotics-Programming/tree/master/Chapter5_Gazebo_basics">https://github.com/PacktPublishing/Hands-On-ROS-for-Robotics-Programming/tree/master/Chapter5_Gazebo_basics</a>.</p>
<p>By completing the previous chapter, you should have cloned this book's code repository into the home folder of your laptop. In case you didn't, we'll go over this now. From a Terminal on your laptop, clone the repository into your home folder, like so:</p>
<pre><strong>$ cd ~</strong><br/><strong>$ git clone https://github.com/PacktPublishing/Hands-On-ROS-for-Robotics-Programming</strong> </pre>
<p>Next, we copy the code for this chapter to the ROS workspace. This way, you will have a cleaner ROS environment:</p>
<pre><strong>$ cp -R ~/Hands-On-ROS-for-Robotics-Programming/Chapter5_Gazebo_basics ~/catkin_ws/src</strong></pre>
<p>This chapter contains a new ROS package called <kbd>gazebo_basics</kbd>, so rebuild the workspace so that it is known to your ROS environment:</p>
<pre><strong>$ cd ~/catkin_ws</strong><br/><strong>$ catkin_make</strong><br/><strong>$ source ~/catkin_ws/devel/setup.bash</strong></pre>
<p>Check that the package is correctly installed by selecting it and listing its files:</p>
<pre><strong>$ roscd gazebo_basics</strong><br/><strong>$ pwd</strong><br/><strong>  ~/catkin_ws/src/Chapter5_Gazebo_basics</strong></pre>
<p>The output of the <kbd>pwd</kbd> command shows the location, as expected. Now, you are ready to complete this chapter.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting started with the Gazebo simulator</h1>
                
            
            
                
<p>Let's go through a quick tour so that you have a clear understanding of what you can expect when implementing a dynamic simulation for GoPiGo3. Gazebo is an open source 3D robotics simulator and includes an ODE physics engine and OpenGL rendering, and supports code integration for closed-loop control in robot drives—that is, sensor simulation and actuator control. There are two new concepts within this definition. Let's explain each one:</p>
<ul>
<li><strong>Open Dynamics Engine</strong> (<strong>ODE</strong>), a physics engine written in C/C++ that includes two main components: rigid-body dynamics simulation and collision detection (<a href="https://www.ode.org/">https://www.ode.org/</a>).</li>
<li><strong>Open Graphics Library</strong> (<strong>OpenGL</strong>), which is both a cross-language and cross-platform API for rendering 2D and 3D vector graphics. This API is typically used to interact with a GPU in order to achieve hardware-accelerated rendering. It is a specification that sets a standard for how the GPU of a PC has to display graphics on the screen by rendering 2D and 3D vector graphics. Being a specification, it is cross-platform by nature, and every manufacturer can make a different implementation with it (GPU driver). The point of this is that the functionality it provides has to be as it's specified in the standard so that we can say that the driver is OpenGL compliant.<br/>
<a href="https://ieeexplore.ieee.org/document/8755083"/></li>
</ul>
<p>Follow these steps to get started with Gazebo:</p>
<ol>
<li> Test the Gazebo installation by launching it with a premade environment:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ roslaunch gazebo_ros empty_world.launch</strong></pre>
<p style="padding-left: 60px">The <kbd>gazebo_ros</kbd> package is a ROS package that resides in the <kbd>/opt/ros/kinetic/share/</kbd> system folder. It comes with the installation of <kbd>ros-kinetic-desktop-full</kbd> (or <kbd>ros-melodic-desktop-full</kbd>, if you are in Ubuntu 18.04) that was detailed in <a href="f3ecc0de-28c4-4140-9a9c-ed351c68d121.xhtml">Chapter 3</a>, <em>Getting Started with ROS</em>.</p>
<p>If you don't want to run a full installation of ROS, you can install the packages individually. In the case of Gazebo, the installation command is <kbd>$ sudo apt-get install ros-kinetic-gazebo-ros-pkgs ros-kinetic-gazebo-ros-control</kbd> if you're on Ubuntu 16.04 or <kbd>$ sudo apt-get install ros-melodic-gazebo-ros-pkgs ros-melodic-gazebo-ros-control</kbd> if you're on Ubuntu 18.04.</p>
<p style="padding-left: 60px">Apart from <kbd>empty_world.launch</kbd>, you have additional world launch files available whose names can be found by using the following command, which lists the files inside the launch folder of the <kbd>gazebo_ros</kbd> package:</p>
<pre style="padding-left: 60px"><strong>$ roscd gazebo_ros/launch &amp;&amp; ls -la</strong></pre>
<p style="padding-left: 60px">The <kbd>&amp;&amp;</kbd> symbol is commonly used in bash to run two commands in the same line. They are executed in the same order that they're written in. The output is as follows:</p>
<pre style="padding-left: 60px"><strong>-rw-r--r-- 1 root root 2013 Jan 23 16:58 elevator_world.launch</strong><br/><strong>-rw-r--r-- 1 root root 2300 Jan 23 16:58 empty_world.launch</strong><br/><strong>-rw-r--r-- 1 root root 637 Jan 23 16:58 mud_world.launch</strong><br/><strong>-rw-r--r-- 1 root root 850 Jan 23 16:58 range_world.launch</strong><br/><strong>-rw-r--r-- 1 root root 640 Jan 23 16:58 rubble_world.launch</strong><br/><strong>-rw-r--r-- 1 root root 640 Jan 23 16:58 shapes_world.launch</strong><br/><strong>-rw-r--r-- 1 root root 646 Jan 23 16:58 willowgarage_world.launch</strong></pre>
<ol start="2">
<li>Launch <kbd>mud_world.launch</kbd> and be patient; it will take a few seconds to render since it contains mobile parts:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ roslaunch gazebo_ros mud_world.launch</strong></pre>
<p style="padding-left: 60px">The following screenshot shows the output of the preceding commands:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/31387efb-cd6c-46ae-820f-7383ac6498a6.png" style="width:59.08em;height:28.00em;"/></p>
<p>Using the mouse, you can move and rotate the world to change the perspective:</p>
<ul>
<li>Hold down the left button of the mouse when the Gazebo window is active. Moving the mouse will cause the world to move on the screen.</li>
<li>Hold down the central wheel button and move the mouse to turn the world. The point of rotation will be the one that the mouse pointer was in when you first pressed the wheel.</li>
<li>Hold down the right button of the mouse. By moving the mouse forward and backward, you will get to zoom in and zoom out, respectively.</li>
</ul>
<p>To stop Gazebo, you have to press <em>Ctrl</em> + <em>C</em> in the Terminal where you executed the command. It can take several seconds to stop this process. Be aware that closing the Gazebo window is not enough to end the simulation process.</p>
<p>A more complex version is <kbd>willowgarage_world</kbd>:</p>
<pre><strong>$ roslaunch gazebo_ros willowgarage_world.launch</strong></pre>
<p>This looks as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/84ecfade-282a-4c06-a53d-6e1fcff9c75f.png" style="width:51.42em;height:31.42em;"/></p>
<p>As a brief insight into Gazebo, we are going to identify the panels in the user GUI—as depicted in the following screenshot—that you can reproduce with this command:</p>
<pre><strong>$ roslaunch gazebo_basics gopigo_gazebo.launch</strong></pre>
<p>For this to work, you need to have copied the files in this chapter's repository, as we explained in the <em>Technical requirements</em> section:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/b075bd5b-6ff3-4f40-b725-9d05f0581ebf.png" style="width:61.33em;height:35.67em;"/></p>
<p>Let's have a look at the different fields that are available on the panel in the preceding screenshot in detail:</p>
<ul>
<li><strong>Environment toolbar</strong>: There are icons that you can use to change between different modes: selection, translation of an object/robot, rotation of the object, and scale (limited to simple shapes). There are also icons that you can use to create simple shapes, provide lighting characteristics, and change the perspective.</li>
<li><strong>World panel</strong>: This provides us with access to all of the environment elements: Scene, Physics, Models, and Lights. </li>
</ul>
<ul>
<li><strong>Joints panel</strong>: This provides us with access to the locations that you can pick models up from. The first is <kbd>/home/&lt;username&gt;/.gazebo/models</kbd>, which is the user's repository of Gazebo models that have been selected from the main Gazebo repository. This repository is the second option and is available at <a href="http://models.gazebosim.org">http://models.gazebosim.org</a>.</li>
<li><strong>Main window menu bar</strong>: This provides options under the basic File, Edit, View, Window, and Help headings.</li>
<li><strong>Simulation panel</strong>: Located at the bottom of the environment display, it is a handy tool that's used to run simulation scripts and provide real-time information when recording or playing back a simulation.</li>
</ul>
<p>Now that we have understood how the Gazebo simulator works, let's make some modifications to the robot URDF.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Making modifications to the robot URDF</h1>
                
            
            
                
<p>URDF, as we explained in the previous chapter, stands for Unified Robot Description Format and has an XML-compliant syntax to simulate the visual properties of a robot. This format, fitting the scope it was conceived for, does not model some of the characteristics that are needed for a dynamic simulation. More precisely, it cannot specify the following:</p>
<ul>
<li>The pose of the robot itself within a world.</li>
<li>Joint loops (parallel linkages).</li>
<li>Friction and other properties.</li>
<li>Things that are not robots, such as lights, height maps, and so on.</li>
</ul>
<p>For such reasons, an evolved XML format called <strong>Simulation Description Format</strong> (<strong>SDF</strong>) started its development as part of the Gazebo robot simulator. SDF allows us to describe objects to the environments for robot simulators, visualization, and control. Over the years, SDF has become a stable, robust, and extensible format that's capable of describing all aspects of robots.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Extending URDF to produce an SDF robot definition</h1>
                
            
            
                
<p>The way to arrive at an SDF specification for your robot is quite straightforward if you start from the URDF definition we saw in the previous chapter.</p>
<p>Always have the SDF format specification at hand (<a href="http://sdformat.org/spec">http://sdformat.org/spec</a>) since it offers an interactive tree so that you can navigate through all the tags, allowing you to understand the purpose of each one and how it relates to others. The open source code repository is located at <a href="https://bitbucket.org/osrf/sdformat">https://bitbucket.org/osrf/sdformat</a>.</p>
<p>To show that SDF extends and does not break URDF specification, here are some simple guidelines that allow you to convert your URDF model into a Gazebo-ready SDF description:</p>
<ul>
<li>The minimum required adaptation is to include an <kbd>&lt;inertia&gt;</kbd> element within each <kbd>&lt;link&gt;</kbd> element. The goal of this new element is to include the mass and moment of inertia properties of all of the robot links, which is essential to carrying out a dynamic simulation. The rest of the adaptations that we'll list here are optional.</li>
<li>Adding a <kbd>&lt;gazebo&gt;</kbd> element for every <kbd>&lt;link&gt;</kbd> provides the functionality of converting visual colors into Gazebo format and translating STL files into DAE files for better textures. Sensor plugins are placed inside this tag.</li>
<li>Adding a <kbd>&lt;gazebo&gt;</kbd> element for every <kbd>&lt;joint&gt;</kbd> allows us to specify damping, friction, and spring stiffness, and also allows us to add actuator control plugins.</li>
<li>Add a <kbd>&lt;gazebo&gt;</kbd> element for the <kbd>&lt;robot&gt;</kbd> element.</li>
<li>Add a <kbd>&lt;link name="world"/&gt;</kbd> link if the robot should be rigidly attached to the <kbd>world</kbd>/<kbd>base_link</kbd>.</li>
</ul>
<p>You can find out more about this conversion by following the tutorial <em>Using a URDF in Gazebo</em> (<a href="http://gazebosim.org/tutorials?tut=ros_urdf">http://gazebosim.org/tutorials?tut=ros_urdf</a>), along with the applied examples.</p>
<p>The <kbd>&lt;gazebo&gt;</kbd> tag sets some default values that will be automatically included with your SDF description. This tag allows us to identify any elements that are found in SDF format that can't be found in URDF format. If a <kbd>&lt;gazebo&gt;</kbd> tag is used without a <kbd>reference=" "</kbd> property, it is assumed that the description inside refers to the whole robot model. The reference parameter usually refers to a specific robot link—that is, it defines its material.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Collisions and physical properties</h1>
                
            
            
                
<p><strong>Collision</strong> tags specify the volumes that need to be taken into account by the physics engine to detect interference/clearance between bodies. The visual tag from URDF is ignored for the purpose of this computation since it's only used for visualization purposes. This means that, in general, you can decouple visible aspects of the robot (more detailed) from the envelope shapes that are used for computing interference (simpler shapes).</p>
<p>The <strong>inertia</strong> tag of a part specifies its mass and tensor of inertia (3 x 3), along with all of its components (only six components are needed since the matrix is symmetrical).</p>
<p>In the <kbd>gopigo.urdf</kbd> file under the <kbd>urdf</kbd> folder, you can find the blocks of XML for the <kbd>base_link</kbd> and caster (remember that the latter has been modeled as part of <kbd>base_link</kbd> as an acceptable simplification of the model). This first snippet corresponds to the <kbd>base_link</kbd> itself and specifies the collision and mass properties:</p>
<pre>&lt;link name="base_link"&gt;<br/>...    <br/>    <strong>&lt;!-- Base collision, mass and inertia --&gt;<br/>    </strong>&lt;collision&gt;<br/>        &lt;<strong>origin</strong> xyz="0 0 0" rpy="0 0 0" /&gt;<br/>        &lt;<strong>geometry</strong>&gt;<br/>            &lt;box size="0.5 0.5 0.25"/&gt;<br/>        &lt;/geometry&gt;<br/>    &lt;/collision&gt;<br/>    <br/>    &lt;inertial&gt;<br/>      &lt;<strong>mass</strong> value="5"/&gt;<br/>      &lt;<strong>inertia</strong> ixx="0.13" ixy="0.0" ixz="0.0" iyy="0.21" iyz="0.0" izz="0.13"/&gt;<br/>    &lt;/inertial&gt;</pre>
<p>This includes the frame origin and orientation (<kbd>&lt;origin&gt;</kbd> tag), the geometry of the element (<kbd>&lt;geometry&gt;</kbd>), the mass (<kbd>&lt;mass</kbd>&gt;), and the inertia tensor (<kbd>&lt;inertia&gt;</kbd>). The second part models the caster and closes the block with the <kbd>&lt;/link&gt;</kbd> tag:</p>
<pre>    <strong>&lt;!-- Caster collision, mass and inertia --&gt;</strong><br/>    &lt;collision&gt;<br/>      &lt;origin xyz="0.2 0 -0.125" rpy="0 0 0" /&gt;<br/>      &lt;geometry&gt;<br/>        &lt;sphere radius="0.05" /&gt;<br/>      &lt;/geometry&gt;<br/>    &lt;/collision&gt;<br/>    &lt;inertial&gt;<br/>      &lt;mass value="0.5"/&gt;<br/> &lt;inertia ixx="0.0001" ixy="0.0" ixz="0.0" iyy="0.0001" iyz="0.0" izz="0.0001"/&gt;<br/>    &lt;/inertial&gt;<br/>&lt;/link&gt;</pre>
<p>These properties use the same tags we explained previously. For the right wheel, the following is the corresponding piece of code:</p>
<pre>&lt;!-- Right Wheel --&gt;<br/>&lt;link name="right_wheel"&gt;<br/>...<br/>    &lt;!-- Right Wheel collision, mass and inertia --&gt;<br/>    &lt;collision&gt;<br/>      &lt;origin xyz="0 0 0" rpy="1.570795 0 0" /&gt;<br/>      &lt;geometry&gt;<br/>          &lt;cylinder length="0.1" radius="0.2" /&gt;<br/>      &lt;/geometry&gt;<br/>    &lt;/collision&gt;<br/>    &lt;inertial&gt;<br/> &lt;mass value="0.5"/&gt;<br/> &lt;inertia ixx="0.01" ixy="0.0" ixz="0.0" iyy="0.005" iyz="0.0" izz="0.005"/&gt;<br/> &lt;/inertial&gt;<br/>&lt;/link&gt;</pre>
<p>For the left wheel, the specification is exactly the same.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Gazebo tags</h1>
                
            
            
                
<p>As we mentioned previously, <kbd>&lt;gazebo&gt;</kbd> tags are used to specify the additional elements to URDF that are needed within the native Gazebo format, SDF. In the <kbd>gopigo.gazebo</kbd> file under the <kbd>URDF</kbd> folder, you can find the following blocks of code, which specify the material for each link:</p>
<ul>
<li>The first is the robot body (<kbd>base_link</kbd>). This block specifies the color of the part, as well as its initial pose:</li>
</ul>
<pre style="padding-left: 60px">  &lt;gazebo reference="<strong>base_link</strong>"&gt;<br/>    &lt;material&gt;Gazebo/Blue&lt;/material&gt;<br/>    &lt;pose&gt;0 0 3 0 0 0&lt;/pose&gt;<br/>  &lt;/gazebo&gt;</pre>
<ul>
<li>Next is the wheels. These blocks are only needed to specify the colors since the pose was defined in <kbd>base_link</kbd>:</li>
</ul>
<pre style="padding-left: 60px">  &lt;gazebo reference="right_wheel"&gt;<br/>    &lt;material&gt;Gazebo/Black&lt;/material&gt;<br/>  &lt;/gazebo&gt;<br/>...<br/>  &lt;gazebo reference="left_wheel"&gt;<br/>    &lt;material&gt;Gazebo/Black&lt;/material&gt;<br/>  &lt;/gazebo&gt;</pre>
<p>If you plan to reuse this code or share it, it is recommended that you add the dependency to your <kbd>package.xml</kbd> file for the <kbd>gazebo_basics</kbd> package. The following statement should be added under the dependencies section of such a file:</p>
<pre>&lt;exec_depend&gt;gazebo_ros&lt;/exec_depend&gt;</pre>
<p>This way, when building the ROS workspace, the requested dependencies will be taken into account, providing an output that permits the package to be executed when called from the runtime.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Verifying a Gazebo model and viewing the URDF</h1>
                
            
            
                
<p>Once the SDF definition has been completed in the <kbd>gopigo.urdf</kbd> file, you should perform some checks to ensure that the file can be read by Gazebo. To do so, navigate to the folder where the model resides:</p>
<pre><strong>$ roscd gazebo_basics/urdf</strong></pre>
<p>The <kbd>roscd</kbd> command is a very useful ROS command that's equivalent to the Linux <kbd>cd</kbd> command, but specifies the paths that are relative to a given package. It's also easier to use because all you have to do is provide the name of the package that you want to move to the Terminal. The first part, <kbd>gazebo_basics</kbd>, retrieves the absolute path of the package, as well as the second part of the folder or subfolder path you want to show. This ROS command, as well as other useful ones, will be covered in detail in the next chapter, under the <em>Shell commands</em> subsection.</p>
<p>Use the following two commands to print and check the model, respectively:</p>
<pre><strong>$ gz sdf --print gopigo.gazebo</strong><br/><strong>$ gz sdf --check gopigo.gazebo</strong></pre>
<p>The first command prints the XML file in the Terminal window so that you can inspect it. The second checks the syntax of such a file. Alternatively, you can do this with a single command, respectively (without needing the initial <kbd>roscd</kbd>):</p>
<pre><strong>$ gz sdf --print $(rospack find gazebo_basics)/urdf/gopigo.gazebo</strong><br/><strong>$ gz sdf --check $(rospack find gazebo_basics)/urdf/gopigo.gazebo</strong></pre>
<p>In this case, we are using another ROS command, <kbd>rospack find</kbd>, to write the path of the model.</p>
<p>The <kbd>$</kbd> symbol before the opening bracket in bash is telling us this: <kbd>return me the path of the gazebo_basics package</kbd>.</p>
<p>After the closing bracket, there is the route inside the package—that is, <kbd>/urdf</kbd>—which is where <kbd>gopigo.gazebo</kbd> is located. </p>
<p>If everything goes well in the checking process, you will obtain a successful message:</p>
<pre><strong>Check complete</strong></pre>
<p>If you intentionally remove the closing <kbd>&gt;</kbd> of a tag or a complete <kbd>&lt;tag&gt;</kbd>, the check command will throw the following error:</p>
<pre><strong>Error [parser.cc:293] Error parsing XML in file [~/catkin_ws/src/CH5_GAZEBO_BASICS/urdf/gopigo.gazebo]: Error reading end tag.</strong><br/><strong>Error: SDF parsing the xml failed</strong></pre>
<p>If you remove the opening <kbd>&lt;link&gt;</kbd> and closing <kbd>&lt;/link&gt;</kbd>, you'll obtain the following error:</p>
<pre><strong>Error [parser_urdf.cc:3474] Unable to call parseURDF on robot model</strong><br/><strong>Error [parser.cc:310] parse as old deprecated model file failed.</strong><br/><strong>Error: SDF parsing the xml failed</strong></pre>
<p>Remove any incorrect syntax from the file and make sure it passes the check procedure. When you're ready, proceed to the next section, where we will see the model in action.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Launching the GoPiGo model in Gazebo</h1>
                
            
            
                
<p>The single-launch file of this chapter can be found under the launch folder of the package and is called <kbd>gopigo_gazebo.launch</kbd>. We've divided its code into the following two snippets for explanation purposes:</p>
<pre>&lt;launch&gt;<br/>  &lt;include file="<strong>$(find gazebo_ros)/launch/empty_world.launch</strong>"&gt;<br/>    &lt;<strong>arg</strong> name="world_name" value="$(find gazebo_basics)/worlds/gopigo.world"/&gt;<br/>    &lt;<strong>arg</strong> name="paused" default="false"/&gt;<br/>    &lt;<strong>arg</strong> name="use_sim_time" default="true"/&gt;<br/>    &lt;<strong>arg</strong> name="gui" default="true"/&gt;<br/>    &lt;<strong>arg</strong> name="headless" default="false"/&gt;<br/>    &lt;<strong>arg</strong> name="debug" default="false"/&gt;<br/>  &lt;/include&gt;</pre>
<p>Here, you can see two new tags, <kbd>&lt;include&gt;</kbd> and <kbd>&lt;arg&gt;</kbd>. The former allows us to include launch files from other ROS packages, while the latter allows us to make the launch file configurable using local arguments. The <kbd>&lt;arg&gt;</kbd> tag will be explained in the <em>Explaining configurable launch files using the &lt;arg&gt; tag</em> section.</p>
<p>The <kbd>&lt;include&gt;</kbd> block calls external files and defines the default values for the parameters. Its syntax can be clearly understood if we bear its equivalent command in mind when using the Terminal:</p>
<pre><strong>$ roslaunch gazebo_ros empty_world.launch</strong></pre>
<p>As you might have guessed, the <kbd>&lt;include&gt;</kbd> tag specifies the <kbd>empty_world.launch</kbd> file belonging to the <kbd>gazebo_ros</kbd> ROS package (which ships with the ROS installation, and is, therefore, a system package).</p>
<p>Regarding the file path, it is worth mentioning the mechanism that ROS uses to abstract the physical location of any package in the disk by using the <kbd>find</kbd> keyword:</p>
<pre><strong>$(find gazebo_basics)</strong></pre>
<p>Similar to the purpose of the <kbd>$</kbd> symbol in bash—that is, accessing the value of an environment variable—the preceding snippet provides us with a message stating <kbd>return me the path of the gazebo_basics package</kbd>. After the closing bracket, we can see the route inside the package—that is, <kbd>/launch</kbd>—which is where <kbd>empty_world.launch</kbd> is located.</p>
<p>You can explore its contents by listing the file, as usual:</p>
<pre><strong>$ roscd gazebo_ros/launch</strong><br/><strong>$ cat empty_world.launch<br/></strong></pre>
<p>This is where the available worlds (that the line in bold letters refers to) are loaded from the Gazebo installation directory—<kbd>/usr/share/gazebo-7/worlds</kbd> if you are in Ubuntu 16.04 or <kbd>/usr/share/gazebo-9/worlds</kbd> if you are in Ubuntu 18.04. In the case of our launch file, we are using <kbd>worlds/empty.world</kbd>. It's marked in bold in the following code:</p>
<pre>&lt;launch&gt;<br/>  &lt;!-- these are the arguments you can pass this launch file, for example paused:=true --&gt;<br/>  ...<br/>  &lt;arg name="physics" default="ode"/&gt;<br/>  &lt;arg name="verbose" default="false"/&gt;<br/>  <strong>&lt;arg name="world_name" default="worlds/empty.world"/&gt;</strong><br/>  ...<br/><br/>  &lt;!-- start gazebo server--&gt;<br/>  ...<br/>  <br/>  &lt;!-- start gazebo client --&gt;<br/>  ...<br/>&lt;/launch&gt;</pre>
<p>The <kbd>&lt;include&gt;</kbd> tag is followed by the second snippet, which describes the Gazebo node to be launched:</p>
<pre> ...<br/>  &lt;node name="spawn_urdf" pkg="<strong>gazebo_ros</strong>" type="<strong>spawn_model</strong>" output="screen"<br/>     args="-file $(find gazebo_basics)/urdf/gopigo.gazebo -urdf -model gopigo" /&gt;<br/>&lt;/launch&gt;</pre>
<p>This node spawns the GoPiGo3 model into Gazebo using the <kbd>spawn_model</kbd> script of the <kbd>gazebo_ros</kbd> package. So why aren't we using the <kbd>&lt;include&gt;</kbd> tag here? Because we are including an external single node. We reserve <kbd>&lt;include&gt;</kbd> for launch files, where there are more nodes and configuration options.</p>
<p>Finally, issue the <kbd>roslaunch</kbd> command to start the simulation:</p>
<pre><strong>$ roslaunch gazebo_basics gopigo_gazebo.launch</strong></pre>
<p>This will result in the following output (be patient; depending on your graphics card, the 3D scene can take several seconds to be launched in a Gazebo window):</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/6408f731-fee9-4e0c-a798-82da29fcfd5f.png" style="width:61.33em;height:35.00em;"/></p>
<p>We will conclude this section by explaining the <kbd>&lt;arg&gt;</kbd> tag that we skipped previously.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Explaining configurable launch files using the &lt;arg&gt; tag</h1>
                
            
            
                
<p>Arguments are a way to use variables in the scope of a launch file. Let's take the example of the <kbd>world_name</kbd> argument inside the <kbd>include</kbd> tag:</p>
<pre>&lt;include file="<strong>$(find gazebo_ros)/launch/empty_world.launch</strong>"&gt;<br/>    &lt;<strong>arg</strong> name="world_name" value="$(find gazebo_basics)/worlds/gopigo.world"/&gt;</pre>
<p>This tag tells us which Gazebo world to use—referenced by the <kbd>name</kbd> attribute—and specifies the path where the file for the world can be found—that is, <kbd>value="$(find gazebo_basics)/worlds/gopigo.world"</kbd>. Be aware that how you specify the file path is done in exactly the same way in which we tell it the launch file to include.</p>
<p>The syntax for the <kbd>&lt;arg&gt;</kbd> tag is neatly explained in the official documentation at <a href="http://wiki.ros.org/roslaunch/XML/arg">http://wiki.ros.org/roslaunch/XML/arg</a>. Remember that, in the <em>Controlling GoPiGo3 wheels from RViz</em> section of the previous chapter, we explained how to specify the argument values when issuing the <kbd>roslaunch</kbd> command while providing default values in the launch file. </p>
<p>At this point, you are ready to understand how the model simulates the dynamics of your robot.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Moving your model around</h1>
                
            
            
                
<p>Once the simulation has been launched, you can use the interaction icons in the Gazebo window. For example, you can play with the rotation tool of the environment toolbar to see how gravity affects the cone when you move it from its point of equilibrium:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/e6ba0155-324f-4808-ada4-464f055ee187.png" style="width:30.08em;height:25.25em;"/></p>
<p>Also, you can access the Joints panel (drag from the right border of the Gazebo window if it is not visible), select the GoPiGo model from the left pane, and under the Force tab in the Joints panel, apply 1 N.m torque to the left wheel. You will see how the robot starts to rotate around the right wheel, where no external force is acting:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/6598f45d-8ad2-4c26-9261-fdf129332ff8.png" style="width:37.17em;height:26.67em;"/></p>
<p>These interactions are quite simple, and at this point, they should give you a good taste of what simulation can support your work as a robotics engineer.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Guidelines for tuning the Gazebo model</h1>
                
            
            
                
<p>The general goal in simulation is to reproduce reality to some extent with minimal effort, and this approximation should serve to be your concrete goal of designing a robot or evaluating the performance of existing ones. </p>
<p>Digital models are an abstraction of reality. You don't need to reproduce every detail of the physical robot in its Gazebo model. If you tried to do so, the required workload would be so high that the benefits of simulation would not compensate for the effort. Instead, what you do is reproduce those characteristics to verify the robot. You should start by defining the concrete goals and then build the simplest model that will allow us to comply with them.</p>
<p>Let's go through an example to understand these concepts. In this chapter, you've seen that the GoPiGo3 model is just a box (robot body), a semisphere (caster), and two cylinders (left and right wheels). The real GoPiGo3 contains many more parts, including bolts, washers, and nuts, as you know from experience when you put the hardware together in <a href="9bb411d1-934c-4497-aad4-7ad770d3783c.xhtml" target="_blank">Chapter 1</a>, <em>Assembling the Robot</em>. If you try to reproduce all these elements in URDF, we are sure you would be discouraged from continuing to work on such a hard task. Instead of following that dead end, ask yourself what you want the model for. From now on, we will refer to the simulated model as the <strong>digital twin</strong>, which is the technical name we will use to refer to the digital replica of the physical robot. </p>
<p>Here are two of the possible goals:</p>
<ul>
<li>Measure the actual maximum torque that servomotors can exert</li>
<li>Determine the weight of the heaviest object that GoPiGo3 can transport as a function of the slope of a ramp</li>
</ul>
<p>Now, let's think about the characteristics that the digital twin should have:</p>
<ul>
<li>Since we are trying to measure dynamic features, we just have to reproduce the total mass of GoPiGo3 and the torque actuating on the wheels. Moments of inertia are not strictly necessary if the robot is going to follow a smooth path. For example, in the case of a spinning motion, the inertia tensor would need to be considered to simulate the maximum turning speed when the robot goes around without moving from its position. This would be accomplished by rotating the left and right wheels at maximum speed with opposite signs.</li>
<li>We will need <kbd>&lt;visual&gt;</kbd> tagged elements to see the digital model on the screen, but will not need <kbd>&lt;collision&gt;</kbd> elements since there is no need to include obstacles for our purposes.</li>
</ul>
<p>With just those characteristics, you will have the minimum digital twin. The procedure to achieve these goals would be as follows:</p>
<ol>
<li>In the real world, take a ramp that you can manually change the slope of. Then, get GoPiGo3 to climb the ramp and determine the maximum slope it can deal with. You will reach a point where the robot stays almost still, without climbing or going backward. Let's say that this angle is <em>a</em>.</li>
<li>The force that the two motors are exerting is given by the formula <img class="fm-editor-equation" src="img/6fb8fee3-c112-4836-bd6b-409f857e7aca.png" style="width:6.92em;height:1.08em;"/>, where <em>m</em> is the robot's mass and <em>g</em> is the acceleration of gravity (9.8 m/s²).</li>
<li>The torque that's applied by each motor to produce such traction is given by the formula  <img class="fm-editor-equation" src="img/3d77e374-cb39-4dd7-b1b4-bbe4d3899fc4.png" style="width:4.25em;height:0.83em;"/>, where <em>r</em> is the radius of the wheels and the factor 2 means that we produce this force using two motors (one per wheel).</li>
</ol>
<ol start="4">
<li>Once you've determined the maximum torque, <em>T</em>, you can go to the simulation environment, apply it to each of the motors, and see the robot rolling on a ramp of a slope, α &lt; <em>a</em>. By progressively increasing the mass of the robot body (concentrated in the <kbd>base_link</kbd> URDF element), you will find the total weight that makes the robot stop moving forward.</li>
</ol>
<p>Bear in mind that if the ramp had slope <em>a</em>, the force that the wheels have to exert to make the robot climb will correspond to the maximum motor torque, so it won't have the capacity to transport more weight. Therefore, you should always consider a slope, α, lower than <em>a</em>.</p>
<p>By doing this, you will obtain a good estimation of the maximum weight that GoPiGo3 can carry for a given maximum ramp slope, α. You can introduce this modification in Gazebo very easily by modifying the mass value of the <kbd>base_link</kbd> in the URDF file, as follows:</p>
<pre>&lt;link name="base_link"&gt;<br/>...<br/>    &lt;inertial&gt;<br/>         &lt;mass value="m+dm"/&gt;<br/>    &lt;/inertial&gt;<br/>...</pre>
<p>Here, <kbd>m + dm</kbd> represents the sum of two terms:</p>
<ul>
<li><kbd>m</kbd> is the mass of the unloaded robot.</li>
<li><kbd>dm</kbd> is the mass of the object to be transported. The value of <kbd>dm</kbd> (in kilograms) that makes sure the robot does not climb the ramp will be the maximum load for the slope, α. For a ramp slope equal to <em>a</em>, we have <em>dm = dm*= 0.</em></li>
</ul>
<p>We'll cover how we can specify the maximum motor torque in Gazebo in <a href="0653ab6b-8710-41e7-9c01-5024865e3e27.xhtml" target="_blank">Chapter 7</a>, <em>Robot Control and Simulation</em>, in the <em>Simulating GoPiGo3 with Gazebo</em> section. Here, you will see that there is a plugin element that can be used to simulate the motor controller that mobile robots such as GoPiGo3 have.</p>
<p>With these modifications to the URDF file, as well as the check we made in Gazebo regarding <em>dm*= 0</em> for a ramp slope equal to <em>a</em>, you have tuned the digital twin so that it can simulate freight transport and has the transport capability of <em>dm</em> kilograms for a maximum slope of α.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we introduced the simulation environment of ROS called Gazebo, a standalone simulator that also provides full integration with ROS.</p>
<p>First, you learned about SDF, the standard XML format for robot simulation driven by Gazebo. SDF extends URDF and allows us to describe objects and environments for robot simulators, visualization, and control. </p>
<p>Following a parallel process to that of <a href="742e6846-70e4-4bd4-8576-f3e4f445df3f.xhtml" target="_blank">Chapter 4</a>, <em>Creating the Virtual Two-Wheeled ROS Robot</em>, we produced a robot description within the <kbd>./urdf/gopigo.gazebo</kbd> file. The simulation was then started by running <kbd>./launch/gopigo_gazebo.launch</kbd>.</p>
<p>In this chapter, you were provided with an overview of how the Gazebo interface GUI is organized and performed some simple interactions with the GoPiGo3 model to see how it is affected by the gravity or the application of torque in the joint of one of its wheels.</p>
<p class="mce-root">By now, you should have started to develop a feeling of how to simulate realistic behavior with the robot with the physics engine of Gazebo. This will provide you with a powerful and cost-effective tool that you can use to troubleshoot the differences between the physical robot and its digital twin.</p>
<p>In the next chapter, we will look at the physical robot and explain how to interface with it. What you have done so far with the virtual robot will help you anticipate how the actual GoPiGo3 behaves when you run a ROS program in its CPU.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Questions</h1>
                
            
            
                
<ol>
<li>What is the format of the SDF?</li>
</ol>
<p style="padding-left: 60px">A) It is a text file<br/>
B) JSON<br/>C) XML</p>
<ol start="2">
<li>Why can't the UDRF format be directly used by simulation for robots?</li>
</ol>
<p style="padding-left: 60px">A) Because URDF cannot specify the pose of the robot within a world<br/>
B) Because it cannot specify the dynamic properties of joints, such as stiffness, damping, and/or friction<br/>
C) All of the above</p>
<p class="mce-root"/>
<p class="mce-root"/>
<ol start="3">
<li>What is the <kbd>&lt;collision&gt;</kbd> tag used for?</li>
</ol>
<p style="padding-left: 60px">A) For defining the physical obstacles the robot has to avoid<br/>B) It is an optional tag for performing the interference checking of robot joints<br/>
C) To define the volume to be considered for the interference checking of robot links</p>
<ol start="4">
<li>What is the ROS <kbd>find</kbd> command used for?</li>
</ol>
<p style="padding-left: 60px">A) It is used to refer to other ROS nodes with the same name<br/>B) It returns the absolute path of the ROS package that is specified as its argument<strong><br/></strong>C) It allows you to easily find any file within the ROS environment</p>
<ol start="5">
<li>What is a robot simulation in Gazebo used for?</li>
</ol>
<p style="padding-left: 60px">A) To find out more about a robot before purchasing it<br/>B) To develop functionality prior to applying it to the real robot<strong><br/></strong>C) To check the visual aspect of a robot before manufacturing it</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Further reading</h1>
                
            
            
                
<ul>
<li>Gazebo tutorials: <a href="http://gazebosim.org/tutorials">http://gazebosim.org/tutorials</a></li>
<li>Simulator Gazebo tutorials (ROS-specific): <a href="http://wiki.ros.org/simulator_gazebo/Tutorials">http://wiki.ros.org/simulator_gazebo/Tutorials</a></li>
<li><em>ROS Robot Programming: A handbook Written by TurtleBot3 Developers</em>, YoonSeok Pyo, HanCheol Cho, RyuWoon Jung, TaeHoon Lim (2017), ROBOTIS Co. Ltd, first edition: <a href="http://www.pishrobot.com/wp-content/uploads/2018/02/ROS-robot-programming-book-by-turtlebo3-developers-EN.pdf">http://www.pishrobot.com/wp-content/uploads/2018/02/ROS-robot-programming-book-by-turtlebo3-developers-EN.pdf</a>, Chapter: <em>ROS Tools: RViz and rqt </em>and 10.9 <em>TurtleBot3 Simulation using Gazebo</em></li>
</ul>


            

            
        
    </body></html>