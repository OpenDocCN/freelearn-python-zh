<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer008">
<h1 class="chapter-number" id="_idParaDest-119"><a id="_idTextAnchor122"/>4</h1>
<h1 id="_idParaDest-120"><a id="_idTextAnchor123"/>Authentication and Authorization</h1>
<p>In this chapter of our <em class="italic">FastAPI Cookbook</em>, we will delve into the critical realms of authentication and authorization, laying the foundation to secure your web applications against <span class="No-Break">unauthorized access.</span></p>
<p>As we navigate through this chapter, you’ll embark on a practical journey to implement a comprehensive security model in your FastAPI applications. From the basics of user registration and authentication to the integration of sophisticated <strong class="bold">OAuth2 </strong>protocols with <strong class="bold">JSON Web Token</strong> (<strong class="bold">JWT</strong>) for <a id="_idIndexMarker215"/>enhanced security, this chapter covers <span class="No-Break">it all.</span></p>
<p>We will create the essential<a id="_idIndexMarker216"/> components of <strong class="bold">software as a service</strong> (<strong class="bold">SaaS</strong>) to help you learn practically how to establish user registration systems, verify users, and handle sessions efficiently. We’ll also show you how to <a id="_idIndexMarker217"/>apply <strong class="bold">role-based access control</strong> (<strong class="bold">RBAC</strong>) to adjust user permissions and protect API endpoints with API key authentication. The incorporation of third-party authentication using external login services, such as GitHub, will demonstrate how to leverage existing platforms for user authentication, simplifying the login process for <span class="No-Break">your users.</span></p>
<p>Furthermore, you’ll add an extra layer of security by implementing <strong class="bold">multi-factor authentication</strong> (<strong class="bold">MFA</strong>), ensuring<a id="_idIndexMarker218"/> that your application’s security is robust against various <span class="No-Break">attack vectors.</span></p>
<p>In this chapter, we’re going to cover the <span class="No-Break">following recipes:</span></p>
<ul>
<li>Setting up <span class="No-Break">user registration</span></li>
<li>Working with OAuth2 and JWT <span class="No-Break">for authentication</span></li>
<li>Setting <span class="No-Break">up RBAC</span></li>
<li>Using <span class="No-Break">third-party authentication</span></li>
<li><span class="No-Break">Implementing MFA</span></li>
<li>Handling API <span class="No-Break">key authentication</span></li>
<li>Handling session cookies and <span class="No-Break">logout functionality</span></li>
</ul>
<h1 id="_idParaDest-121"><a id="_idTextAnchor124"/>Technical requirements</h1>
<p>To dive into the chapter and follow along with recipes on authentication and authorization, ensure your setup includes the <span class="No-Break">following essentials:</span></p>
<ul>
<li><strong class="bold">Python</strong>: Install a Python version higher than 3.9 in <span class="No-Break">your environment.</span></li>
<li><strong class="bold">FastAPI</strong>: This should be installed with all required dependencies. If you didn’t do so during the previous chapters, you can simply do it from <span class="No-Break">your terminal:</span><pre class="source-code">
<strong class="bold">$ pip install fastapi[all]</strong></pre></li> </ul>
<p>The code used in the chapter is hosted on GitHub <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/FastAPI-Cookbook/tree/main/Chapter04"><span class="No-Break">https://github.com/PacktPublishing/FastAPI-Cookbook/tree/main/Chapter04</span></a><span class="No-Break">.</span></p>
<p>Setting up a virtual environment for the project within the project root folder is also recommended to manage dependencies efficiently and maintain project isolation. Within your virtual environment, you can install all the dependencies at once by using the <strong class="source-inline">requirements.txt</strong> file, provided in the GitHub repository in the <span class="No-Break">project folder:</span></p>
<pre class="console">
pip install –r requirements.txt</pre> <p>Since the interactive Swagger documentation is limited at the time of writing, a basic mastering of <strong class="bold">Postman</strong> or any other testing API is beneficial to test <span class="No-Break">our API.</span></p>
<p>Now that we have this ready, we can begin preparing <span class="No-Break">our recipes.</span></p>
<h1 id="_idParaDest-122"><a id="_idTextAnchor125"/>Setting up user registration</h1>
<p>User registration is <a id="_idIndexMarker219"/>the first step in securing your FastAPI application. It involves collecting user details and storing them securely. Here’s how you can set up a basic user registration system. The recipe will show you how to set up a FastAPI application’s <span class="No-Break">registration system.</span></p>
<h2 id="_idParaDest-123"><a id="_idTextAnchor126"/>Getting ready</h2>
<p>We will start by storing users in an SQL database. Let’s create a project root folder called <strong class="source-inline">saas_app</strong>, containing the <span class="No-Break">code base.</span></p>
<p>To store user passwords, we will use an external package to hash plain text with the <strong class="bold">bcrypt</strong> algorithm. The<a id="_idIndexMarker220"/> hashing function transforms a text string into a unique and irreversible output, allowing for secure storage of sensitive data such as passwords. You can find more details at <a href="https://en.wikipedia.org/wiki/Hash_function"><span class="No-Break">https://en.wikipedia.org/wiki/Hash_function</span></a><span class="No-Break">.</span></p>
<p>If you haven’t installed packages from <strong class="source-inline">requirements.txt</strong> from the GitHub repository of the chapter under the <strong class="source-inline">saas_app</strong> project folder,, you can install the <strong class="source-inline">passlib</strong> package with <strong class="source-inline">bycrypt</strong> by running <span class="No-Break">the following:</span></p>
<pre class="console">
$ pip install passlib[bcrypt]</pre> <p>You will also need to install a version of <strong class="source-inline">sqlalchemy</strong> higher than 2.0.0 to follow along with the code in the <span class="No-Break">GitHub repository:</span></p>
<pre class="console">
$ pip install sqlalchemy&gt;=2.0.0</pre> <p>Our environment is <a id="_idIndexMarker221"/>now ready to implement the user registration in <span class="No-Break">our SaaS.</span></p>
<h2 id="_idParaDest-124"><a id="_idTextAnchor127"/>How to do it…</h2>
<p>Before starting the implementation, we need to set up the database to store <span class="No-Break">our users.</span></p>
<p>We need to set <a id="_idIndexMarker222"/>up a <strong class="bold">SQLite</strong> database with <strong class="source-inline">sqlalchemy</strong> for the application to store <span class="No-Break">user credentials.</span></p>
<p>You need to do <span class="No-Break">the following:</span></p>
<ul>
<li>Set up a <strong class="source-inline">User</strong> class to map the users table in the SQL database. The table should contain the <strong class="source-inline">id</strong>, <strong class="source-inline">username</strong>, <strong class="source-inline">email</strong>, and <span class="No-Break"><strong class="source-inline">hashed_password</strong></span><span class="No-Break"> fields.</span></li>
<li>Establish the connection between the application and <span class="No-Break">the database.</span></li>
</ul>
<p>First let's create our project root folder called <strong class="source-inline">saas_app</strong>. Then you can refer to the <em class="italic">Setting up SQL databases</em> recipe in <a href="B21025_02.xhtml#_idTextAnchor052"><span class="No-Break"><em class="italic">Chapter 2</em></span></a>, <em class="italic">Working with Data</em>, or copy the <strong class="source-inline">database.py</strong> and <strong class="source-inline">db_connection.py</strong> modules from the GitHub repository under your <span class="No-Break">root folder.</span></p>
<p>With the database session set up, let’s define the function that adds <span class="No-Break">a user.</span></p>
<p>Let’s make it into a dedicated module called <strong class="source-inline">operations.py</strong>, in which we will define all the support functions used by the <span class="No-Break">API endpoints.</span></p>
<p>The function will use a password context object from the <strong class="source-inline">bcrypt</strong> package to hash plain text passwords. We can define it <span class="No-Break">as follows:</span></p>
<pre class="source-code">
from passlib.context import CryptContext
pwd_context = CryptContext(
    schemes=["bcrypt"], deprecated="auto"
)</pre> <p>We can then define the <strong class="source-inline">add_user</strong> function, which inserts a new user into the database with <a id="_idIndexMarker223"/>the hashed password, according to most of data <span class="No-Break">compliance regulations:</span></p>
<pre class="source-code">
from sqlalchemy.exc import IntegrityError
from sqlalchemy.orm import Session
from models import User
def add_user(
    session: Session,
    username: str,
    password: str,
    email: str,
) -&gt; User | None:
    hashed_password = pwd_context.hash(password)
    db_user = User(
        username=username,
        email=email,
        hashed_password=hashed_password,
    )
    session.add(db_user)
    try:
        session.commit()
        session.refresh(db_user)
    except IntegrityError:
        session.rollback()
        return
    return db_user</pre> <p><strong class="source-inline">InegrityError</strong> will take into account the attempt to add a username or email that <span class="No-Break">already exists.</span></p>
<p>We now have to<a id="_idIndexMarker224"/> define our endpoint, but first, we need to set up our server and initialize the database connection. We can do it in the <strong class="source-inline">main.py</strong> module, <span class="No-Break">as follows:</span></p>
<pre class="source-code">
from contextlib import (
    asynccontextmanager,
)
from fastapi import  FastAPI
from db_connection import get_engine
@asynccontextmanager
async def lifespan(app: FastAPI):
    Base.metadata.create_all(bind=get_engine())
    yield
app = FastAPI(
    title="Saas application", lifespan=lifespan
)</pre> <p>We use the <strong class="source-inline">lifespan</strong> parameter of the <strong class="source-inline">FastAPI</strong> object to instruct the server to sync our database class, <strong class="source-inline">User</strong>, with the database when it <span class="No-Break">starts up.</span></p>
<p>In addition, we can create a separate module, <strong class="source-inline">responses.py</strong>, to keep the response classes used for different endpoints. Feel free to create your own or copy the one provided in the <span class="No-Break">GitHub repository.</span></p>
<p>We can now write <a id="_idIndexMarker225"/>the suitable endpoint to sign up a user in the same <span class="No-Break"><strong class="source-inline">main.py</strong></span><span class="No-Break"> module:</span></p>
<pre class="source-code">
from typing import Annotated
from sqlalchemy.orm import Session
from fastapi import Depends, HTTPException, status
from models import Base
from db_connection import get_session
from operations import add_user
@app.post(
    "/register/user",
    status_code=status.HTTP_201_CREATED,
    response_model=ResponseCreateUser,
    responses={
        status.HTTP_409_CONFLICT: {
            "description": "The user already exists"
        }
    },
)
def register(
    user: UserCreateBody,
    session: Session = Depends(get_session),
) -&gt; dict[str, UserCreateResponse]:
    user = add_user(
        session=session, **user.model_dump()
    )
    if not user:
        raise HTTPException(
            status.HTTP_409_CONFLICT,
            "username or email already exists",
        )
    user_response = UserCreateResponse(
        username=user.username, email=user.email
    )
    return {
        "message": "user created",
        "user": user_response,
    }</pre> <p>We have just <a id="_idIndexMarker226"/>implemented a basic mechanism to register and store users in our <span class="No-Break">SaaS database.</span></p>
<h2 id="_idParaDest-125"><a id="_idTextAnchor128"/>How it works...</h2>
<p>The endpoint will accept a JSON body containing a username, email, <span class="No-Break">and password.</span></p>
<p>If the username or email already exists, a <strong class="source-inline">409</strong> response will be returned, and user creation will <span class="No-Break">be disallowed.</span></p>
<p>To test this, at the project root level, spin up the server by running <span class="No-Break">the following:</span></p>
<pre class="console">
$ uvicorn main:app</pre> <p>Then, connect with your browser at <strong class="source-inline">localhost:8000/docs</strong> and check the endpoint we just created in<a id="_idIndexMarker227"/> the Swagger documentation. Feel free to play around <span class="No-Break">with it.</span></p>
<p class="callout-heading">Exercise</p>
<p class="callout">Create proper tests for both the <strong class="source-inline">add_user</strong> function and the <strong class="source-inline">/register/user</strong> endpoint, such as <span class="No-Break">the following:</span></p>
<p class="callout"><span class="No-Break"><strong class="source-inline">def test_add_user_into_the_database(session):</strong></span></p>
<p class="callout">    <strong class="source-inline">user = </strong><span class="No-Break"><strong class="source-inline">add_user(…</strong></span></p>
<p class="callout">    <strong class="source-inline"># fill in </strong><span class="No-Break"><strong class="source-inline">the test</strong></span></p>
<p class="callout"><span class="No-Break"><strong class="source-inline">def test_endpoint_add_basic_user(client):</strong></span></p>
<p class="callout">    <strong class="source-inline">response = </strong><span class="No-Break"><strong class="source-inline">client.post(</strong></span></p>
<p class="callout">        <strong class="source-inline">"/</strong><span class="No-Break"><strong class="source-inline">register/user",</strong></span></p>
<p class="callout">        <span class="No-Break"><strong class="source-inline">json=</strong></span></p>
<p class="callout">    <strong class="source-inline"># continue </strong><span class="No-Break"><strong class="source-inline">the test</strong></span></p>
<p class="callout">You can arrange the test in any way that works best <span class="No-Break">for you.</span></p>
<p class="callout">You can find a possible way of testing in the <strong class="source-inline">Chapter04/saas_app</strong> folder of the book’s <span class="No-Break">GitHub repository.</span></p>
<h2 id="_idParaDest-126"><a id="_idTextAnchor129"/>See also</h2>
<p>The <strong class="bold">bcrypt</strong> library allows you to add several layers of security to your hashing functions, such as salt and additional keys. Feel free to have a look at the source code <span class="No-Break">on GitHub:</span></p>
<ul>
<li><em class="italic">Bcrypt GitHub </em><span class="No-Break"><em class="italic">Repository</em></span><span class="No-Break">: </span><a href="https://github.com/pyca/bcrypt/"><span class="No-Break">https://github.com/pyca/bcrypt/</span></a></li>
</ul>
<p>Also, you can<a id="_idIndexMarker228"/> find some interesting examples of how to use it at <span class="No-Break">the following:</span></p>
<ul>
<li><em class="italic">Hashing Passwords in Python with </em><span class="No-Break"><em class="italic">Bcrypt</em></span><span class="No-Break">: </span><a href="https://www.geeksforgeeks.org/hashing-passwords-in-python-with-bcrypt/"><span class="No-Break">https://www.geeksforgeeks.org/hashing-passwords-in-python-with-bcrypt/</span></a></li>
</ul>
<h1 id="_idParaDest-127"><a id="_idTextAnchor130"/>Working with OAuth2 and JWT for authentication</h1>
<p>In this recipe, we’ll <a id="_idIndexMarker229"/>integrate OAuth2 with JWTs for<a id="_idIndexMarker230"/> secure user authentication in your application. This approach improves security by utilizing tokens instead of credentials, aligning with modern <span class="No-Break">authentication standards.</span></p>
<h2 id="_idParaDest-128"><a id="_idTextAnchor131"/>Getting ready</h2>
<p>Since we will use a specific library to manage JWT, ensure you have the necessary dependencies installed. If you haven’t installed the packages from <strong class="source-inline">requirements.txt</strong>, run <span class="No-Break">the following:</span></p>
<pre class="console">
$ pip install python-jose[cryptography]</pre> <p>Also, we will use the users table used in the previous recipe, <em class="italic">Setting up user registration</em>. Make sure to have set it up before starting <span class="No-Break">the recipe.</span></p>
<h2 id="_idParaDest-129"><a id="_idTextAnchor132"/>How to do it...</h2>
<p>We can set up the JWT token integration through the <span class="No-Break">following steps.</span></p>
<ol>
<li>In a new <a id="_idIndexMarker231"/>module <a id="_idIndexMarker232"/>called <strong class="source-inline">security.py</strong>, let’s define the authentication function for <span class="No-Break">the user:</span><pre class="source-code">
from sqlalchemy.orm import Session
from models import User
from email_validator import (
    validate_email,
    EmailNotValidError,
)
from operations import pwd_context
def authenticate_user(
    session: Session,
    username_or_email: str,
    password: str,
) -&gt; User | None:
    try:
        validate_email(username_or_email)
        query_filter = User.email
    except EmailNotValidError:
        query_filter = User.username
    user = (
        session.query(User)
        .filter(query_filter == username_or_email)
        .first()
    )
    if not user or not pwd_context.verify(
        password, user.hashed_password
    ):
        return
    return user</pre><p class="list-inset">The function can validate the input based on either the username <span class="No-Break">or email.</span></p></li> <li>Let’s define the functions to create and decode the access token in the same module (<strong class="source-inline">create_access_token</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">decode_access_token</strong></span><span class="No-Break">).</span><p class="list-inset">To create<a id="_idIndexMarker233"/> the <a id="_idIndexMarker234"/>access token, we will need to specify a secret key, the algorithm used to generate it, and the expiration time, <span class="No-Break">as follows:</span></p><pre class="source-code">
SECRET_KEY = "a_very_secret_key"
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 30</pre><p class="list-inset">Then, the <strong class="source-inline">create_access_token_function</strong> is <span class="No-Break">as follows:</span></p><pre class="source-code">from jose import jwt
def create_access_token(data: dict) -&gt; str:
    to_encode = data.copy()
    expire = datetime.utcnow() + timedelta(
        minutes=ACCESS_TOKEN_EXPIRE_MINUTES
    )
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(
        to_encode, SECRET_KEY, algorithm=ALGORITHM
    )
    return encoded_jwt</pre><p class="list-inset">To decode the access token, we can use a support function, <strong class="source-inline">get_user</strong>, that returns the <strong class="source-inline">User</strong> object by the username. You can do it on your own in the <strong class="source-inline">operations.py</strong> module or take it from the <span class="No-Break">GitHub repository.</span></p><p class="list-inset">The function<a id="_idIndexMarker235"/> to<a id="_idIndexMarker236"/> decode the token will be <span class="No-Break">as follows:</span></p><pre class="source-code">from jose import JWTError
def decode_access_token(
    token: str, session: Session
) -&gt; User | None:
    try:
        payload = jwt.decode(
            token, SECRET_KEY, algorithms=[ALGORITHM]
        )
        username: str = payload.get("sub")
    except JWTError:
        return
    if not username:
        return
    user = get_user(session, username)
    return user</pre></li> <li>We can now proceed to <a id="_idIndexMarker237"/>create<a id="_idIndexMarker238"/> the endpoint to retrieve the token in the same module, <strong class="source-inline">security.py</strong>, with the <span class="No-Break"><strong class="source-inline">APIRouter</strong></span><span class="No-Break"> class:</span><pre class="source-code">
from fastapi import (
    APIRouter,
    Depends,
    HTTPException,
    status,
)
from fastapi.security import (
    OAuth2PasswordRequestForm,
)
router = APIRouter()
class Token(BaseModel):
    access_token: str
    token_type: str
@router.post(
    "/token",
    response_model=Token,
    responses=..., # document the responses
)
def get_user_access_token(
    form_data: OAuth2PasswordRequestForm = Depends(),
    session: Session = Depends(get_session),
):
    user = authenticate_user(
        session,
        form_data.username,
        form_data.password
    )
    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect username or password",
        )
    access_token = create_access_token(
        data={"sub": user.username}
    )
    return {
        "access_token": access_token,
        "token_type": "bearer",
    }</pre></li> <li>Then, we can now create an <strong class="source-inline">OAuth2PasswordBearer</strong> object for the <strong class="source-inline">POST /token</strong> endpoint to obtain the <span class="No-Break">access token:</span><pre class="source-code">
from fastapi.security import (
    OAuth2PasswordBearer,
)
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")</pre></li> <li>Finally, we<a id="_idIndexMarker239"/> can<a id="_idIndexMarker240"/> create the <strong class="source-inline">/users/me</strong> endpoint that returns the credentials based on <span class="No-Break">the token:</span><pre class="source-code">
@router.get(
    "/users/me",
    responses=..., # document responses
)
def read_user_me(
    token: str = Depends(oauth2_scheme),
    session: Session = Depends(get_session),
):
    user = decode_access_token(token, session)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="User not authorized",
        )
    return {
        "description": f"{user.username} authorized",
    }</pre></li> <li>Now, let’s import those endpoints into the FastAPI server in <strong class="source-inline">main.py</strong>. Right after defining the FastAPI object, let’s add the router, <span class="No-Break">as follows:</span><pre class="source-code">
<strong class="bold">import security</strong>
# rest of the code
<strong class="bold">app.include_router(security.router)</strong></pre></li> </ol>
<p>We have just defined the authentication mechanism for <span class="No-Break">our SaaS.</span></p>
<h2 id="_idParaDest-130"><a id="_idTextAnchor133"/>How it works…</h2>
<p>Now, spin up the server by running the following code from the terminal at the project root <span class="No-Break">folder level:</span></p>
<pre class="console">
$ uvicorn main:app</pre> <p>Go to the Swagger documentation address in your browser (<strong class="source-inline">localhost:8000/docs</strong>) and you will see the new endpoints, <strong class="source-inline">POST /token</strong> and <span class="No-Break"><strong class="source-inline">GET /users/me</strong></span><span class="No-Break">.</span></p>
<p>You need the token to call the second endpoint, which you can store in your browser automatically by clicking on the lock icon and filling out the form with <span class="No-Break">your credentials.</span></p>
<p>You’ve made<a id="_idIndexMarker241"/> your<a id="_idIndexMarker242"/> SaaS application more secure by using OAuth2 with JWT, which help you guard your sensitive endpoints and make sure that only users who are logged in can use them. This arrangement gives you a reliable and safe way to verify users that works well for modern <span class="No-Break">web applications.</span></p>
<h2 id="_idParaDest-131"><a id="_idTextAnchor134"/>See also</h2>
<p>You can gain a better understanding of the OAuth2 framework by reading <span class="No-Break">this article:</span></p>
<ul>
<li><em class="italic">Introduction to </em><span class="No-Break"><em class="italic">OAuth2</em></span><span class="No-Break">: </span><a href="https://www.digitalocean.com/community/tutorials/an-introduction-to-oauth-2"><span class="No-Break">https://www.digitalocean.com/community/tutorials/an-introduction-to-oauth-2</span></a></li>
</ul>
<p>Also, you can have a look at the protocol definition for JWTs at <span class="No-Break">the following:</span></p>
<ul>
<li><em class="italic">JWT IETF </em><span class="No-Break"><em class="italic">Document</em></span><span class="No-Break">: </span><a href="https://datatracker.ietf.org/doc/html/rfc7519"><span class="No-Break">https://datatracker.ietf.org/doc/html/rfc7519</span></a></li>
</ul>
<h1 id="_idParaDest-132"><a id="_idTextAnchor135"/>Setting up RBAC</h1>
<p>RBAC is a method <a id="_idIndexMarker243"/>of regulating access to resources based on the roles of individual users within an organization. In this recipe, we’ll implement RBAC in a FastAPI application to manage user <span class="No-Break">permissions effectively.</span></p>
<h2 id="_idParaDest-133"><a id="_idTextAnchor136"/>Getting ready</h2>
<p>Since we will expand our database to accommodate role definitions, make sure you have completed the <em class="italic">Setting up user registration</em> recipe before diving <span class="No-Break">into this.</span></p>
<p>To set up access control, we first need to define a variety of roles that we can allocate to. Let’s follow these steps to <span class="No-Break">do it.</span></p>
<ol>
<li>In the <strong class="source-inline">module.py</strong> module, we can define a new class called <strong class="source-inline">Role</strong> and add it as a new field of the <strong class="source-inline">User</strong> model that will be stored in the <span class="No-Break">users table:</span><pre class="source-code">
from enum import Enum
class Role(str, Enum):
    basic = "basic"
    premium = "premium"
class User(Base):
    __tablename__ = "users"
# existing fields
    role: Mapped[Role] = mapped_column(
        default=Role.basic
    )</pre></li> <li>Then, in the <strong class="source-inline">operations.py</strong> module, we will modify the <strong class="source-inline">add_user</strong> function in <strong class="source-inline">operations.py</strong> to accept a parameter to define the user role; the default<a id="_idIndexMarker244"/> value will be the <span class="No-Break">basic role:</span><pre class="source-code">
<strong class="bold">from models import Role</strong>
def add_user(
    session: Session,
    username: str,
    password: str,
    email: str,
<strong class="bold">    role: Role = Role.basic,</strong>
) -&gt; User | None:
    hashed_password = pwd_context.hash(password)
    db_user = User(
        username=username,
        email=email,
        hashed_password=hashed_password,
<strong class="bold">        role=role,</strong>
    )
    # rest of the function</pre></li> <li>Let’s create a new module called <strong class="source-inline">premium_access.py</strong> and define the endpoint through a new router to sign up a premium user, which will look a lot like the endpoint <a id="_idIndexMarker245"/>to sign up a <span class="No-Break">basic user:</span><pre class="source-code">
@router.post(
    "/register/premium-user",
    status_code=status.HTTP_201_CREATED,
    response_model=ResponseCreateUser,
    responses=..., # document responses
)
def register_premium_user(
    user: UserCreateBody,
    session: Session = Depends(get_session),
):
    user = add_user(
        session=session,
         *user.model_dump(),
        role=Role.premium,
    )
    if not user:
        raise HTTPException(
            status.HTTP_409_CONFLICT,
            "username or email already exists",
        )
    user_response = UserCreate(
        username=user.username,
        email=user.email,
    )
    return {
        "message": "user created",
        "user": user_response,
    }</pre><p class="list-inset">In the previous code snippet, the imports and the router definition are skipped, since they are <a id="_idIndexMarker246"/>similar to the ones used in <span class="No-Break">other modules.</span></p></li> <li>Let’s add the router to our <strong class="source-inline">app</strong> class in the <span class="No-Break"><strong class="source-inline">main.py</strong></span><span class="No-Break"> module:</span><pre class="source-code">
import security
<strong class="bold">import premium_access</strong>
# rest of the code
app.include_router(security.router)
<strong class="bold">app.include_router(premium_access.router)</strong></pre></li> </ol>
<p>We have now all the elements to implement RBAC in our <span class="No-Break">SaaS application.</span></p>
<h2 id="_idParaDest-134"><a id="_idTextAnchor137"/>How to do it...</h2>
<p>Let’s create two endpoints, one accessible for all the users and one reserved only for premium user. Let's make the endpoints through the <span class="No-Break">following steps.</span></p>
<ol>
<li>First, let’s create two helper functions, <strong class="source-inline">get_current_user</strong> and <strong class="source-inline">get_premium_user</strong>, to retrieve each case and to be used as dependencies for the <span class="No-Break">endpoints, respectively.</span><p class="list-inset">We can define a separate module, called the <strong class="source-inline">rbac.py</strong> module. Let’s start with <span class="No-Break">the imports:</span></p><pre class="source-code">
from typing import Annotated
from fastapi import (
    APIRouter,
    Depends,
    HTTPException,
    Status
)
from sqlalchemy.orm import Session
from db_connection import get_session
from models import Role
from security import (
    decode_access_token,
    oauth2_scheme
)</pre><p class="list-inset">Then, we create <a id="_idIndexMarker247"/>the request model that we will use with <span class="No-Break">the endpoints:</span></p><pre class="source-code">class UserCreateResquestWithRole(BaseModel):
    username: str
    email: EmailStr
    role: Role</pre><p class="list-inset">Then, we define a support function to retrieve the user based on <span class="No-Break">the token:</span></p><pre class="source-code">def get_current_user(
    token: str = Depends(oauth2_scheme),
    session: Session = Depends(get_session),
) -&gt; UserCreateRequestWithRole:
    user = decode_access_token(token, session)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="User not authorized",
        )
    return UserCreateRequestWithRole(
        username=user.username,
        email=user.email,
        role=user.role,
    )</pre><p class="list-inset">We can then<a id="_idIndexMarker248"/> leverage this function to shortlist premium <span class="No-Break">users only:</span></p><pre class="source-code">def get_premium_user(
    current_user: Annotated[
        get_current_user, Depends()
    ]
):
    if current_user.role != Role.premium:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="User not authorized",
        )
    return current_user</pre></li> <li>Now, we can use the functions to create the respective endpoints with the router in the <a id="_idIndexMarker249"/>same module. First, we define a welcome page for all <span class="No-Break">the users:</span><pre class="source-code">
router = APIRouter()
@router.get(
    "/welcome/all-users",
    responses=..., # document responses
)
def all_users_can_access(
    user: Annotated[get_current_user, Depends()]
):
    return {
        f"Hello {user.username}, "
        "welcome to your space"
    }</pre><p class="list-inset">Then, we define the endpoint, allowing only <span class="No-Break">premium users:</span></p><pre class="source-code">@router.get(
    "/welcome/premium-user",
    responses={
        status.HTTP_401_UNAUTHORIZED: {
            "description": "User not authorized"
        }
    },
)
def only_premium_users_can_access(
    user: UserCreateResponseWithRole = Depends(
        get_premium_user
    ),
):
    return {
        f"Hello {user.username}, "
        "Welcome to your premium space"
    }</pre></li> <li>Let’s add the <a id="_idIndexMarker250"/>router we create <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">main.py</strong></span><span class="No-Break">:</span><pre class="source-code">
import security
import premium_access
<strong class="bold">import rbac</strong>
# rest of the module
app.include_router(premium_access.router)
<strong class="bold">app.include_router(rbac.router)</strong>
# rest of the module</pre></li> </ol>
<p>We have just implemented two endpoints with permissions based on the <span class="No-Break">use role.</span></p>
<p>To test our endpoints, start the server from the <span class="No-Break">command line:</span></p>
<pre class="console">
$ uvicorn main:app</pre> <p>Then, from your browser, go to the Swagger page at <strong class="source-inline">http://localhost:8000/docs</strong>, and you can see the new endpoints <span class="No-Break">just created.</span></p>
<p>A way to experiment is to create a basic and a premium user and use the corresponding endpoints. After you have made the users, you can try using the <strong class="source-inline">GET welcome/all-users</strong> and <strong class="source-inline">GET /welcome/premium-user</strong> endpoints with both roles and see that the response matches the <span class="No-Break">role’s expectations.</span></p>
<p>In this recipe, you<a id="_idIndexMarker251"/> just made simple endpoints that are available based on the user role. You can also play around with making more roles <span class="No-Break">and endpoints.</span></p>
<h2 id="_idParaDest-135"><a id="_idTextAnchor138"/>There’s more…</h2>
<p>Another way to apply RBAC is to assign a scope to a token. This scope can be a string that represents certain permissions. As a result, the role is controlled by the token generation system. In FastAPI, you can define scopes within the token. You can check out the dedicated documentation page for more <span class="No-Break">information:</span><span class="No-Break"><span class="P---URL"> </span></span><a href="https://fastapi.tiangolo.com/advanced/security/oauth2-scopes/"><span class="No-Break">https://fastapi.tiangolo.com/advanced/security/oauth2-scopes/</span></a><span class="No-Break">.</span></p>
<h1 id="_idParaDest-136"><a id="_idTextAnchor139"/>Using third-party authentication</h1>
<p>Incorporating<a id="_idIndexMarker252"/> third-party authentication into your FastAPI application allows users to log in using their existing social media accounts, such as Google or Facebook. This recipe guides you through the process of integrating GitHub third-party login, enhancing user experience by simplifying the <span class="No-Break">sign-in process.</span></p>
<h2 id="_idParaDest-137"><a id="_idTextAnchor140"/>Getting ready</h2>
<p>We’ll focus on integrating GitHub OAuth2 for authentication. GitHub provides comprehensive documentation and a well-supported client library that simplifies the <span class="No-Break">integration process.</span></p>
<p>You will need the <strong class="source-inline">httpx</strong> package in your environment, so if you haven’t installed it with the <strong class="source-inline">requirements.txt</strong>, you can do it by running <span class="No-Break">the following:</span></p>
<pre class="console">
$ pip install httpx</pre> <p>You will need also a GitHub account set up. If you don’t have one, create one; you can find a comprehensive guide on the official documentation <span class="No-Break">at </span><a href="https://docs.github.com/en/get-started/start-your-journey/creating-an-account-on-github"><span class="No-Break">https://docs.github.com/en/get-started/start-your-journey/creating-an-account-on-github</span></a><span class="No-Break">.</span></p>
<p>Then, you need to create an application in your account by following the <span class="No-Break">following steps:</span></p>
<ol>
<li>From<a id="_idIndexMarker253"/> your personal page, click on the profile icon on the top right of the screen, the navigate to <strong class="bold">Settings</strong> | <strong class="bold">Developer settings</strong> | <strong class="bold">OAuth Apps</strong> | <strong class="bold">New OAuth App</strong> and fill the required fields in <span class="No-Break">the form:</span><ul><li><strong class="bold">Application name</strong>: For <span class="No-Break">example, </span><span class="No-Break"><strong class="source-inline">SaasFastAPIapp</strong></span><span class="No-Break">.</span></li><li><strong class="bold">Homepage URL</strong>: The address of your SaaS home page at <strong class="source-inline">http://localhost:8000/home</strong>, which we will <span class="No-Break">create later.</span></li><li><strong class="bold">Authorization callback URL</strong>: This is our application’s endpoint, which will be called to refresh the token. You can set it to <strong class="source-inline">http://localhost:8000/github/auth/token</strong>, which we will define later <span class="No-Break">as well.</span></li></ul></li>
<li>Click on <strong class="bold">Register application</strong> and the app will be created, and you will be redirected to a page listing essential data about your <span class="No-Break">OAuth2 app.</span></li>
<li>Take note of the client ID and click on the <strong class="bold">Generate a new </strong><span class="No-Break"><strong class="bold">client secret</strong></span><span class="No-Break">.</span></li>
<li>Store the client secret you just created. With the client ID and the client secret, we can proceed to implement the third-party authentication <span class="No-Break">by GitHub.</span></li>
</ol>
<p>Now, we have all we need to integrate the GitHub third-party login with <span class="No-Break">our application.</span></p>
<h2 id="_idParaDest-138"><a id="_idTextAnchor141"/>How to do it...</h2>
<p>Let’s start by creating a new module called <strong class="source-inline">third_party_login.py</strong> to store helper data and functions<a id="_idIndexMarker254"/> for the GitHub authentication. Then let's continue <span class="No-Break">as follows.</span></p>
<ol>
<li>Within the <strong class="source-inline">third_party_login.py</strong> module, you can define the variables used for <span class="No-Break">the authentication:</span><pre class="source-code">
GITHUB_CLIENT_ID = "your_github_client_id"
GITHUB_CLIENT_SECRET = (
    "your_github_client_secret"
)
GITHUB_REDIRECT_URI = (
    "http://localhost:8000/github/auth/token"
)
GITHUB_AUTHORIZATION_URL = (
    "https://github.com/login/oauth/authorize"
)</pre><p class="list-inset">For <strong class="source-inline">GITHUB_CLIENT_ID</strong> and <strong class="source-inline">GITHUB_CLIENT_SECRET</strong>, use the values of your <span class="No-Break">OAuth app.</span></p></li> </ol>
<p class="callout-heading">Warning</p>
<p class="callout">In a production environment, make sure to not hardcode any username or client ID in your <span class="No-Break">code base.</span></p>
<ol>
<li value="2">Then, still in the <strong class="source-inline">third_party_login.py</strong> module, let’s define a helper function, <strong class="source-inline">resolve_github_token</strong>, that resolves the GitHub token and returns information <a id="_idIndexMarker255"/>about <span class="No-Break">the user:</span><pre class="source-code">
import httpx
from fastapi import Depends, HTTPException
from fastapi.security import OAuth2
from sqlalchemy.orm import Session
from models import User, get_session
from operations import get_user
def resolve_github_token(
    access_token: str = Depends(OAuth2()),
    session: Session = Depends(get_session),
) -&gt; User:
    user_response = httpx.get(
        "https://api.github.com/user",
        headers={"Authorization": access_token},
    ).json()
    username = user_response.get("login", " ")
    user = get_user(session, username)
    if not user:
        email = user_response.get("email", " ")
        user = get_user(session, email)
    # Process user_response
    # to log the user in or create a new account
    if not user:
        raise HTTPException(
            status_code=403, detail="Token not valid"
        )
    return user</pre></li> <li>In a new module called <strong class="source-inline">github_login.py</strong>, we can start creating the endpoints used for the GitHub authentication. Let’s create a new router and the <strong class="source-inline">github_login</strong> endpoint that will return the URL used by the frontend to redirect the <a id="_idIndexMarker256"/>user to the GitHub <span class="No-Break">login page:</span><pre class="source-code">
import httpx
from fastapi import APIRouter, HTTPException, status
from security import Token
from third_party_login import (
    GITHUB_AUTHORIZATION_URL,
    GITHUB_CLIENT_ID,
    GITHUB_CLIENT_SECRET,
    GITHUB_REDIRECT_URI,
)
router = APIRouter()
@router.get("/auth/url")
def github_login():
    return {
        "auth_url": GITHUB_AUTHORIZATION_URL
        + f"?client_id={GITHUB_CLIENT_ID}"
    }</pre></li> <li>Now, let’s add the router to the server in the <span class="No-Break"><strong class="source-inline">main.py</strong></span><span class="No-Break"> module:</span><pre class="source-code">
<strong class="bold">import github_login</strong>
# rest of the module
<strong class="bold">app.include_router(github_login.router)</strong>
# rest of the module</pre></li> <li>Spin up the server with the same command, <strong class="source-inline">uvicorn main:app</strong>, and call the endpoint <strong class="source-inline">GET</strong> <strong class="source-inline">/auth/url</strong> we have just created. You will have a similar link in the <span class="No-Break">response: </span><a href="https://github.com/login/oauth/authorize?client_id=your_github_client_id"><span class="No-Break">https://github.com/login/oauth/authorize?client_id=your_github_client_id</span></a><span class="No-Break">.</span><p class="list-inset">This link is <a id="_idIndexMarker257"/>used by GitHub for the authentication. The redirection is managed by the frontend and is out of the scope of <span class="No-Break">this book.</span></p></li>
<li>After validating the login, you will be redirected to a <strong class="source-inline">404</strong> page. This is because we still haven’t created the callback endpoint in our application. Let’s do so in the <span class="No-Break"><strong class="source-inline">github_login.py</strong></span><span class="No-Break"> module:</span><pre class="source-code">
@router.get(
    "/github/auth/token",
    response_model=Token,
    responses=..., # add responses documentation
)
async def github_callback(code: str):
    token_response = httpx.post(
        "https://github.com/login/oauth/access_token",
        data={
            "client_id": GITHUB_CLIENT_ID,
            "client_secret": GITHUB_CLIENT_SECRET,
            "code": code,
            "redirect_uri": GITHUB_REDIRECT_URI,
        },
        headers={"Accept": "application/json"},
    ).json()
    access_token = token_response.get("access_token")
    if not access_token:
        raise HTTPException(
            status_code=401,
            detail="User not registered",
        )
    token_type = token_response.get(
        "token_type", "bearer"
    )
    return {
        "access_token": access_token,
        "token_type": token_type,
    }</pre><p class="list-inset">The endpoint we just created returns the actual <span class="No-Break">access token.</span></p></li> <li>If you restart the server and try to validate the GitHub login again with the link provded by the <strong class="source-inline">GET</strong> <strong class="source-inline">/auth/url</strong> endpoint, you will receive a response containing the token similar to <span class="No-Break">the following:</span><pre class="source-code">
{
    "access_token": "gho_EnHbcmHdCHD1Bf2QzJ2B6gyt",
    "token_type": "bearer"
}</pre></li> <li>The last piece of the puzzle is to create the home page endpoint that can be accessed with the GitHub token and will recognize the user by resolving the token. We <a id="_idIndexMarker258"/>can define it in the <span class="No-Break"><strong class="source-inline">main.py</strong></span><span class="No-Break"> module:</span><pre class="source-code">
from third_party_login import resolve_github_token
@router.get(
    "/home",
    responses=…, # add responses documentation
)
def homepage(
    user: UserCreateResponse = Depends(
        resolve_github_token
    ),
):
    return {
        "message" : f"logged in {user.username} !"
    }</pre></li> </ol>
<p>You’ve just implemented an endpoint that authenticates with the GitHub <span class="No-Break">third-party authenticator.</span></p>
<h2 id="_idParaDest-139"><a id="_idTextAnchor142"/>How it works…</h2>
<p>First, by using the register endpoint <strong class="source-inline">POST /register/user</strong>, add a user that has the same username or email as the GitHub account you are going <span class="No-Break">to test.</span></p>
<p>Then, retrieve the token from the GitHub URL provided by the <strong class="source-inline">GET /</strong><span class="No-Break"><strong class="source-inline">auth/url</strong></span><span class="No-Break"> endpoint.</span></p>
<p>You will use a token with your favorite tool to query the <strong class="source-inline">GET /home</strong> endpoint, which uses the GitHub token to <span class="No-Break">validate permission.</span></p>
<p>At the time of writing, we cannot test endpoints requiring external bearer tokens with the interactive documentation, so feel free to use your favorite tool to query the endpoint by providing the bearer token in the <span class="No-Break">headers authorization.</span></p>
<p>You can do it <a id="_idIndexMarker259"/>with <strong class="bold">Postman</strong>, for example, and you can use the equivalent <strong class="source-inline">curl</strong> request from your shell as well, <span class="No-Break">as follows:</span></p>
<pre class="console">
$ curl --location 'http://localhost:8000/home' \
--header 'Authorization: Bearer &lt;github-token&gt;'</pre> <p>If everything is correctly set up, you will receive <span class="No-Break">the response:</span></p>
<pre class="console">
{"message":"logged in &lt;your-username&gt; !"}</pre> <p>You just<a id="_idIndexMarker260"/> implemented and tested authentication by using a third-party application such as GitHub. Other providers such as Google or Twitter follow similar procedures, with small differences. Feel free to implement them <span class="No-Break">as well.</span></p>
<h2 id="_idParaDest-140"><a id="_idTextAnchor143"/>See also</h2>
<p>Take a look at the GitHub documentation that provides a guide on how to set up <span class="No-Break">OAuth2 authentication:</span></p>
<ul>
<li><em class="italic">GitHub OAuth2 </em><span class="No-Break"><em class="italic">integration</em></span><span class="No-Break">: </span><a href="https://docs.github.com/en/apps/oauth-apps/building-oauth-apps/authorizing-oauth-apps"><span class="No-Break">https://docs.github.com/en/apps/oauth-apps/building-oauth-apps/authorizing-oauth-apps</span></a></li>
</ul>
<p>You can use third-party authorization login with other providers that allow a similar configuration. You can check, for example, Google <span class="No-Break">and Twitter:</span></p>
<ul>
<li><em class="italic">Google OAuth2 </em><span class="No-Break"><em class="italic">integration</em></span><span class="No-Break">: </span><a href="https://developers.google.com/identity/protocols/oauth2"><span class="No-Break">https://developers.google.com/identity/protocols/oauth2</span></a></li>
<li><em class="italic">Twitter OAuth2 </em><span class="No-Break"><em class="italic">integration</em></span><span class="No-Break">: </span><a href="https://developer.twitter.com/en/docs/authentication/oauth-2-0"><span class="No-Break">https://developer.twitter.com/en/docs/authentication/oauth-2-0</span></a></li>
</ul>
<h1 id="_idParaDest-141"><a id="_idTextAnchor144"/>Implementing MFA</h1>
<p>MFA adds a layer<a id="_idIndexMarker261"/> of security by requiring users to provide two or more verification factors to gain access to a resource. The recipe guides you through adding MFA to your FastAPI application, enhancing security by combining something the user knows (their password) with something they have (<span class="No-Break">a device).</span></p>
<h2 id="_idParaDest-142"><a id="_idTextAnchor145"/>Getting ready</h2>
<p>For our FastAPI application, we’ll <a id="_idIndexMarker262"/>use a <strong class="bold">time-based one-time password</strong> (<strong class="bold">TOTP</strong>) as our MFA method. TOTP provides a six to eight-digit number that’s valid for a short period, typically <span class="No-Break">30 seconds.</span></p>
<p>First, ensure you have the necessary <span class="No-Break">packages installed:</span></p>
<pre class="console">
$ pip install pyotp</pre> <p><strong class="bold">Pyotp</strong> is a Python<a id="_idIndexMarker263"/> library that implements one-time password algorithms, <span class="No-Break">including TOTP.</span></p>
<p>To use the TOTP authentication, we need to modify the user table in our database to take into account the TOTP secret used to validate the <span class="No-Break">secret number.</span></p>
<p>Let’s modify the <strong class="source-inline">User</strong> class in the <strong class="source-inline">models.py</strong> module by adding the <span class="No-Break"><strong class="source-inline">totp_secret</strong></span><span class="No-Break"> field:</span></p>
<pre class="source-code">
class User(Base):
    # existing fields
<strong class="bold">    totp_secret: Mapped[str] = mapped_column(</strong>
<strong class="bold">        nullable=True</strong>
<strong class="bold">    </strong><strong class="bold">)</strong></pre> <p>We are now ready to <span class="No-Break">implement MFA.</span></p>
<h2 id="_idParaDest-143"><a id="_idTextAnchor146"/>How to do it...</h2>
<p>Let’s start by creating two helper functions to generate a TOTP secret and TOTP URI used by the authenticatorthrough the <span class="No-Break">following steps.</span></p>
<ol>
<li>We define <a id="_idIndexMarker264"/>the functions in a new module <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">mfa.py</strong></span><span class="No-Break">:</span><pre class="source-code">
import pyotp
def generate_totp_secret():
    return pyotp.random_base32()
def generate_totp_uri(secret, user_email):
    return pyotp.totp.TOTP(secret).provisioning_uri(
        name=user_email, issuer_name="YourAppName"
    )</pre><p class="list-inset">The TOTP URI can be a QR code as well in the form of <span class="No-Break">a link.</span></p><p class="list-inset">We will use the <strong class="source-inline">generate_totp_secret</strong> and <strong class="source-inline">generate_totp_uri</strong> functions to create the endpoint to <span class="No-Break">request MFA.</span></p></li> <li>The endpoint will<a id="_idIndexMarker265"/> return a <strong class="bold">TOTP URI</strong> for use by the authenticator. To show the mechanism, we will also return the secret number, which in a real-life scenario is the number<a id="_idIndexMarker266"/> generated by <span class="No-Break">the authenticator:</span><pre class="source-code">
from fastapi import (
    APIRouter,
    Depends,
    HTTPException,
    status,
)
from sqlalchemy.orm import Session
from db_connection import get_session
from operations import get_user
from rbac import get_current_user
from responses import UserCreateResponse
router = APIRouter()
@router.post("/user/enable-mfa")
def enable_mfa(
    user: UserCreateResponse = Depends(
        get_current_user
    ),
    db_session: Session = Depends(get_session),
):
    secret = generate_totp_secret()
    db_user = get_user(db_session, user.username)
    db_user.totp_secret = secret
    db_session.add(db_user)
    db_session.commit()
    totp_uri = generate_totp_uri(secret, user.email)
    # Return the TOTP URI
    # for QR code generation in the frontend
    return {
        "totp_uri": totp_uri,
        "secret_numbers": pyotp.TOTP(secret).now(),
    }</pre></li> <li>Now, we can <a id="_idIndexMarker267"/>create the endpoint to validate the <span class="No-Break">secret number:</span><pre class="source-code">
@app.post("/verify-totp")
def verify_totp(
    code: str,
    username: str,
    session: Session = Depends(get_session),
):
    user = get_user(session, username)
    if not user.totp_secret:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="MFA not activated",
        )
    totp = pyotp.TOTP(user.totp_secret)
    if not totp.verify(code):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid TOTP token",
        )
    # Proceed with granting access
    # or performing the sensitive operation
    return {
        "message": "TOTP token verified successfully"
    }</pre></li> </ol>
<p>As before, you need<a id="_idIndexMarker268"/> to include the router in the <strong class="source-inline">FastAPI</strong> object class in <strong class="source-inline">main.py</strong> for all the <span class="No-Break">previous endpoints.</span></p>
<p>To test it, as usual spin up the server from the terminal <span class="No-Break">by running:</span></p>
<pre class="console">
$ uvicorn main:app</pre> <p>Make sure you have a user in your database, go to the interactive documentation, and call the <strong class="source-inline">/user/enable-mfa</strong> endpoint by authenticating with the user credentials. You will get a response with the TOTP URI and a temporary secret number, like <span class="No-Break">the following:</span></p>
<pre class="source-code">
{
  "totp_uri":
  "otpauth://totp/YourAppName:giunio%40example.com?secret=
  NBSUC4CFDUT5IEYX4IR7WKBTDTU7LN25&amp;issuer=YourAppName",
  "secret_numbers": "853567"
}</pre> <p>Take note of the secret number to use as a parameter of the <strong class="source-inline">/verify-totp</strong> endpoint with the username, and you will get <span class="No-Break">this response:</span></p>
<pre class="source-code">
{
  "message": "TOTP token verified successfully"
}</pre> <p>You’ve just implemented MFA in your FastAPI application and enhanced security by ensuring that even if a user’s password is compromised, an attacker still needs access to the user’s second <a id="_idIndexMarker269"/>factor (the device running the MFA app) to <span class="No-Break">gain access.</span></p>
<h2 id="_idParaDest-144"><a id="_idTextAnchor147"/>See also</h2>
<p>Take a look at the Python One-Time Password library in the <span class="No-Break">official documentation:</span></p>
<ul>
<li><em class="italic">Python One-Time Password </em><span class="No-Break"><em class="italic">library</em></span><span class="No-Break">: </span><a href="https://pyauth.github.io/pyotp/"><span class="No-Break">https://pyauth.github.io/pyotp/</span></a></li>
</ul>
<h1 id="_idParaDest-145"><a id="_idTextAnchor148"/>Handling API key authentication</h1>
<p>API key authentication <a id="_idIndexMarker270"/>is a simple yet effective way to control access to an application. This method involves generating a unique key for each user or service that needs access to your API and requiring that key to be included in the <span class="No-Break">request headers.</span></p>
<p>API keys can be generated in various ways, depending on the level of <span class="No-Break">security needed.</span></p>
<p>FastAPI doesn’t have built-in support for API key authentication, but you can easily implement it using dependencies or middleware. A dependency is more flexible for most use cases, so we’ll use <span class="No-Break">that approach.</span></p>
<p>This recipe will show you a basic, yet not secure, way to <span class="No-Break">implement it.</span></p>
<h2 id="_idParaDest-146"><a id="_idTextAnchor149"/>Getting ready</h2>
<p>We will keep working on our application. However, you can apply this recipe to a simple application from scratch <span class="No-Break">as well.</span></p>
<h2 id="_idParaDest-147"><a id="_idTextAnchor150"/>How to do it...</h2>
<p>Let’s create an <strong class="source-inline">api_key.py</strong> module to store the logic to handle API keys. The package will contain the <a id="_idIndexMarker271"/>API list and <span class="No-Break">verification method:</span></p>
<pre class="source-code">
from fastapi import HTTPException
from typing import Optional
VALID_API_KEYS = [
    "verysecureapikey",
    "anothersecureapi",
    "onemoresecureapi",
]
async def get_api_key(
    api_key: Optional[str]
):
    if (
        api_key not in VALID_API_KEYS
    ):
        raise HTTPException(
            status_code=403, detail="Invalid API Key"
        )
    return api_key</pre> <p>In the example, the keys are hardcoded into the <strong class="source-inline">VALID_API_KEYS</strong> list. However, in real-life production scenarios, the management and validation of the keys are usually done by dedicated libraries or <span class="No-Break">even services.</span></p>
<p>Let’s create an endpoint that makes use of the <span class="No-Break">API key:</span></p>
<pre class="source-code">
from fastatpi import APIrouter
router = APIRouter()
@router.get("/secure-data")
async def get_secure_data(
    api_key: str = Depends(get_api_key),
):
    return {"message": "Access to secure data granted"}</pre> <p>Now, add the<a id="_idIndexMarker272"/> router to the <strong class="source-inline">FastAPI</strong> object class in <strong class="source-inline">main.py</strong>, and then the endpoint is ready to <span class="No-Break">be tested.</span></p>
<p>Spin up the server from the command by running <span class="No-Break">the following:</span></p>
<pre class="console">
$ uvicorn main:app</pre> <p>Go to the interactive documentation at <strong class="source-inline">http://localhost:8000/docs</strong> and test the endpoint you just created by providing an <span class="No-Break">API key.</span></p>
<p>As you see, by adding a simple dependency to the endpoint, you can secure any endpoint of your app with an <span class="No-Break">API key.</span></p>
<h2 id="_idParaDest-148"><a id="_idTextAnchor151"/>There’s more…</h2>
<p>We have developed a simple module for managing the API of our application. In production environment this can be handled by external services often provided by the hosting platform. However, If you are going to implement your API management system, keep in mind the best practices for API <span class="No-Break">key authentication:</span></p>
<ul>
<li><strong class="bold">Transmission security</strong>: Always<a id="_idIndexMarker273"/> use HTTPS to prevent API keys from being intercepted <span class="No-Break">during transmission</span></li>
<li><strong class="bold">Key rotation</strong>: Regularly rotate API keys to minimize the risk <span class="No-Break">of compromise</span></li>
<li><strong class="bold">Limit permissions</strong>: Assign minimal permissions required for each API key based on the principle of <span class="No-Break">least privilege</span></li>
<li><strong class="bold">Monitoring and revocation</strong>: Monitor the usage of API keys and have mechanisms<a id="_idIndexMarker274"/> in place to revoke them if suspicious activity <span class="No-Break">is detected</span></li>
</ul>
<h1 id="_idParaDest-149"><a id="_idTextAnchor152"/>Handling session cookies and logout functionality</h1>
<p>Managing user <a id="_idIndexMarker275"/>sessions and implementing logout functionality is <a id="_idIndexMarker276"/>crucial for maintaining security and user experience in web applications. This recipe shows how to handle session cookies in FastAPI, from creating cookies upon user login to securely terminating sessions <span class="No-Break">upon logout.</span></p>
<h2 id="_idParaDest-150"><a id="_idTextAnchor153"/>Getting ready</h2>
<p>Sessions provide a way to persist user data across requests. When a user logs in, the application creates a session on the server side and sends a session identifier to the client, usually in a <strong class="bold">cookie</strong>. The client sends this identifier back with each request, allowing the server to retrieve the user’s <span class="No-Break">session data.</span></p>
<p>The recipe will show how to manage cookies for sessions with login and <span class="No-Break">logout functionality.</span></p>
<h2 id="_idParaDest-151"><a id="_idTextAnchor154"/>How to do it...</h2>
<p>Cookies in FastAPI are easily managed by the <strong class="source-inline">Request</strong> and <strong class="source-inline">Response</strong> object classes. Let’s create a login and a logout endpoints to attaches a session cookie to the response and ignore it from the request. </p>
<p>Let’s create a dedicated module called <strong class="source-inline">user_session.py</strong> and add the <strong class="source-inline">/</strong><span class="No-Break"><strong class="source-inline">login</strong></span><span class="No-Break"> endpoint:</span></p>
<pre class="source-code">
from fastapi import APIRouter, Depends, Response
from sqlalchemy.orm import Session
from db_connection import get_session
from operations import get_user
from rbac import get_current_user
from responses import UserCreateResponse
router = APIRouter()
@router.post("/login")
async def login(
    response: Response,
    user: UserCreateResponse = Depends(
        get_current_user
    ),
    session: Session = Depends(get_session),
):
    user = get_user(session, user.username)
    response.set_cookie(
        key="fakesession", value=f"{user.id}"
    )
    return {"message": "User logged in successfully"}</pre> <p>Testing the login endpoint won’t be possible with the Swagger documentation because we need to verify that the <strong class="source-inline">fakesession</strong> cookie has <span class="No-Break">been created.</span></p>
<p>Spin up the server with <strong class="source-inline">uvicorn main:app</strong> and use Postman to create a <strong class="source-inline">Post</strong> request to the <strong class="source-inline">/login</strong> endpoint by providing the authentication token for the user you want to <span class="No-Break">log in.</span></p>
<p>Verify that the response contains the <strong class="source-inline">fakesession</strong> cookie by selecting <strong class="bold">Cookies</strong> from the drop-down menu of the <span class="No-Break">response section.</span></p>
<p>Accordingly, we <a id="_idIndexMarker277"/>can define a logout endpoint that won’t return<a id="_idIndexMarker278"/> any session cookie in <span class="No-Break">the response:</span></p>
<pre class="source-code">
@router.post("/logout")
async def logout(
    response: Response,
    user: UserCreateResponse = Depends(
         get_current_user
    ),
):
    response.delete_cookie(
        "fakesession"
    )  # Clear session data
    return {"message": "User logged out successfully"}</pre> <p>That’s all you need to <span class="No-Break">manage sessions.</span></p>
<p>To test the <strong class="source-inline">POST /logout</strong> endpoint, restart the server with <strong class="source-inline">uvicorn</strong>. Then, when calling the endpoint, make sure you provide the <strong class="source-inline">fakesession</strong> cookie in your HTTP request with the user bearer token. If you previously called the login endpoint, it should be automatically stored; otherwise, you can set it in the <strong class="source-inline">Cookies</strong> section of <span class="No-Break">the request.</span></p>
<p>Check the<a id="_idIndexMarker279"/> response<a id="_idIndexMarker280"/> and confirm that the <strong class="source-inline">fakesession</strong> cookie is not present anymore in <span class="No-Break">the response.</span></p>
<h2 id="_idParaDest-152"><a id="_idTextAnchor155"/>There’s more…</h2>
<p>There is a lot to learn about cookies besides the basic recipe. In a real-world setting, you can use specialized libraries or even <span class="No-Break">external services.</span></p>
<p>Whatever your choice is, put security first and follow those practices to make your session secure <span class="No-Break">and efficient:</span></p>
<ul>
<li><strong class="bold">Secure cookies</strong>: Mark session cookies as <strong class="source-inline">Secure</strong>, <strong class="source-inline">HttpOnly</strong>, and <strong class="source-inline">SameSite</strong> to<a id="_idIndexMarker281"/> protect<a id="_idIndexMarker282"/> against <strong class="bold">cross-site request forgery</strong> (<strong class="bold">CSRF</strong>) and <strong class="bold">cross-site scripting</strong> (<span class="No-Break"><strong class="bold">XSS</strong></span><span class="No-Break">) attacks</span></li>
<li><strong class="bold">Session expiry</strong>: Implement session expiry both in your session store and by setting a maximum age on <span class="No-Break">the cookie</span></li>
<li><strong class="bold">Regenerate Session ID</strong>: Regenerate session IDs upon login to prevent session <span class="No-Break">fixation attacks</span></li>
<li><strong class="bold">Monitor sessions</strong>: Implement mechanisms to monitor active sessions and <span class="No-Break">detect anomalies</span></li>
</ul>
<p>By integrating session management and logout functionality into your FastAPI application, you ensure that user state is managed securely and efficiently across requests. This enhances both the security and user experience of your application. Remember to <a id="_idIndexMarker283"/>follow<a id="_idIndexMarker284"/> best practices for session security to protect your users and their <span class="No-Break">data effectively.</span></p>
<p>In the next chapter, we will see how to efficiently debug your <span class="No-Break">FastAPI application.</span></p>
<h2 id="_idParaDest-153"><a id="_idTextAnchor156"/>See also</h2>
<p>You can see more on managing cookies in Fast on the <span class="No-Break">documentation page:</span></p>
<ul>
<li><em class="italic">Response </em><span class="No-Break"><em class="italic">cookies</em></span><span class="No-Break">: </span><a href="https://fastapi.tiangolo.com/advanced/response-cookies/"><span class="No-Break">https://fastapi.tiangolo.com/advanced/response-cookies/</span></a></li>
</ul>
</div>
</div></body></html>