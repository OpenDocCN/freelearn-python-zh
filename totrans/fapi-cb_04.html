<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-119"><a id="_idTextAnchor122"/>4</h1>
<h1 id="_idParaDest-120"><a id="_idTextAnchor123"/>Authentication and Authorization</h1>
<p>In this chapter of our <em class="italic">FastAPI Cookbook</em>, we will delve into the critical realms of authentication and authorization, laying the foundation to secure your web applications against unauthorized access.</p>
<p>As we navigate through this chapter, you’ll embark on a practical journey to implement a comprehensive security model in your FastAPI applications. From the basics of user registration and authentication to the integration of sophisticated <strong class="bold">OAuth2 </strong>protocols with <strong class="bold">JSON Web Token</strong> (<strong class="bold">JWT</strong>) for <a id="_idIndexMarker215"/>enhanced security, this chapter covers it all.</p>
<p>We will create the essential<a id="_idIndexMarker216"/> components of <strong class="bold">software as a service</strong> (<strong class="bold">SaaS</strong>) to help you learn practically how to establish user registration systems, verify users, and handle sessions efficiently. We’ll also show you how to <a id="_idIndexMarker217"/>apply <strong class="bold">role-based access control</strong> (<strong class="bold">RBAC</strong>) to adjust user permissions and protect API endpoints with API key authentication. The incorporation of third-party authentication using external login services, such as GitHub, will demonstrate how to leverage existing platforms for user authentication, simplifying the login process for your users.</p>
<p>Furthermore, you’ll add an extra layer of security by implementing <strong class="bold">multi-factor authentication</strong> (<strong class="bold">MFA</strong>), ensuring<a id="_idIndexMarker218"/> that your application’s security is robust against various attack vectors.</p>
<p>In this chapter, we’re going to cover the following recipes:</p>
<ul>
<li>Setting up user registration</li>
<li>Working with OAuth2 and JWT for authentication</li>
<li>Setting up RBAC</li>
<li>Using third-party authentication</li>
<li>Implementing MFA</li>
<li>Handling API key authentication</li>
<li>Handling session cookies and logout functionality</li>
</ul>
<h1 id="_idParaDest-121"><a id="_idTextAnchor124"/>Technical requirements</h1>
<p>To dive into the chapter and follow along with recipes on authentication and authorization, ensure your setup includes the following essentials:</p>
<ul>
<li><strong class="bold">Python</strong>: Install a Python version higher than 3.9 in your environment.</li>
<li><strong class="bold">FastAPI</strong>: This should be installed with all required dependencies. If you didn’t do so during the previous chapters, you can simply do it from your terminal:<pre class="source-code">
<strong class="bold">$ pip install fastapi[all]</strong></pre></li> </ul>
<p>The code used in the chapter is hosted on GitHub at <a href="https://github.com/PacktPublishing/FastAPI-Cookbook/tree/main/Chapter04">https://github.com/PacktPublishing/FastAPI-Cookbook/tree/main/Chapter04</a>.</p>
<p>Setting up a virtual environment for the project within the project root folder is also recommended to manage dependencies efficiently and maintain project isolation. Within your virtual environment, you can install all the dependencies at once by using the <code>requirements.txt</code> file, provided in the GitHub repository in the project folder:</p>
<pre class="console">
pip install –r requirements.txt</pre> <p>Since the interactive Swagger documentation is limited at the time of writing, a basic mastering of <strong class="bold">Postman</strong> or any other testing API is beneficial to test our API.</p>
<p>Now that we have this ready, we can begin preparing our recipes.</p>
<h1 id="_idParaDest-122"><a id="_idTextAnchor125"/>Setting up user registration</h1>
<p>User registration is <a id="_idIndexMarker219"/>the first step in securing your FastAPI application. It involves collecting user details and storing them securely. Here’s how you can set up a basic user registration system. The recipe will show you how to set up a FastAPI application’s registration system.</p>
<h2 id="_idParaDest-123"><a id="_idTextAnchor126"/>Getting ready</h2>
<p>We will start by storing users in an SQL database. Let’s create a project root folder called <code>saas_app</code>, containing the code base.</p>
<p>To store user passwords, we will use an external package to hash plain text with the <strong class="bold">bcrypt</strong> algorithm. The<a id="_idIndexMarker220"/> hashing function transforms a text string into a unique and irreversible output, allowing for secure storage of sensitive data such as passwords. You can find more details at <a href="https://en.wikipedia.org/wiki/Hash_function">https://en.wikipedia.org/wiki/Hash_function</a>.</p>
<p>If you haven’t installed packages from <code>requirements.txt</code> from the GitHub repository of the chapter under the <code>saas_app</code> project folder,, you can install the <code>passlib</code> package with <code>bycrypt</code> by running the following:</p>
<pre class="console">
$ pip install passlib[bcrypt]</pre> <p>You will also need to install a version of <code>sqlalchemy</code> higher than 2.0.0 to follow along with the code in the GitHub repository:</p>
<pre class="console">
$ pip install sqlalchemy&gt;=2.0.0</pre> <p>Our environment is <a id="_idIndexMarker221"/>now ready to implement the user registration in our SaaS.</p>
<h2 id="_idParaDest-124"><a id="_idTextAnchor127"/>How to do it…</h2>
<p>Before starting the implementation, we need to set up the database to store our users.</p>
<p>We need to set <a id="_idIndexMarker222"/>up a <code>sqlalchemy</code> for the application to store user credentials.</p>
<p>You need to do the following:</p>
<ul>
<li>Set up a <code>User</code> class to map the users table in the SQL database. The table should contain the <code>id</code>, <code>username</code>, <code>email</code>, and <code>hashed_password</code> fields.</li>
<li>Establish the connection between the application and the database.</li>
</ul>
<p>First let's create our project root folder called <code>saas_app</code>. Then you can refer to the <em class="italic">Setting up SQL databases</em> recipe in <a href="B21025_02.xhtml#_idTextAnchor052"><em class="italic">Chapter 2</em></a>, <em class="italic">Working with Data</em>, or copy the <code>database.py</code> and <code>db_connection.py</code> modules from the GitHub repository under your root folder.</p>
<p>With the database session set up, let’s define the function that adds a user.</p>
<p>Let’s make it into a dedicated module called <code>operations.py</code>, in which we will define all the support functions used by the API endpoints.</p>
<p>The function will use a password context object from the <code>bcrypt</code> package to hash plain text passwords. We can define it as follows:</p>
<pre class="source-code">
from passlib.context import CryptContext
pwd_context = CryptContext(
    schemes=["bcrypt"], deprecated="auto"
)</pre> <p>We can then define the <code>add_user</code> function, which inserts a new user into the database with <a id="_idIndexMarker223"/>the hashed password, according to most of data compliance regulations:</p>
<pre class="source-code">
from sqlalchemy.exc import IntegrityError
from sqlalchemy.orm import Session
from models import User
def add_user(
    session: Session,
    username: str,
    password: str,
    email: str,
) -&gt; User | None:
    hashed_password = pwd_context.hash(password)
    db_user = User(
        username=username,
        email=email,
        hashed_password=hashed_password,
    )
    session.add(db_user)
    try:
        session.commit()
        session.refresh(db_user)
    except IntegrityError:
        session.rollback()
        return
    return db_user</pre> <p><code>InegrityError</code> will take into account the attempt to add a username or email that already exists.</p>
<p>We now have to<a id="_idIndexMarker224"/> define our endpoint, but first, we need to set up our server and initialize the database connection. We can do it in the <code>main.py</code> module, as follows:</p>
<pre class="source-code">
from contextlib import (
    asynccontextmanager,
)
from fastapi import  FastAPI
from db_connection import get_engine
@asynccontextmanager
async def lifespan(app: FastAPI):
    Base.metadata.create_all(bind=get_engine())
    yield
app = FastAPI(
    title="Saas application", lifespan=lifespan
)</pre> <p>We use the <code>lifespan</code> parameter of the <code>FastAPI</code> object to instruct the server to sync our database class, <code>User</code>, with the database when it starts up.</p>
<p>In addition, we can create a separate module, <code>responses.py</code>, to keep the response classes used for different endpoints. Feel free to create your own or copy the one provided in the GitHub repository.</p>
<p>We can now write <a id="_idIndexMarker225"/>the suitable endpoint to sign up a user in the same <code>main.py</code> module:</p>
<pre class="source-code">
from typing import Annotated
from sqlalchemy.orm import Session
from fastapi import Depends, HTTPException, status
from models import Base
from db_connection import get_session
from operations import add_user
@app.post(
    "/register/user",
    status_code=status.HTTP_201_CREATED,
    response_model=ResponseCreateUser,
    responses={
        status.HTTP_409_CONFLICT: {
            "description": "The user already exists"
        }
    },
)
def register(
    user: UserCreateBody,
    session: Session = Depends(get_session),
) -&gt; dict[str, UserCreateResponse]:
    user = add_user(
        session=session, **user.model_dump()
    )
    if not user:
        raise HTTPException(
            status.HTTP_409_CONFLICT,
            "username or email already exists",
        )
    user_response = UserCreateResponse(
        username=user.username, email=user.email
    )
    return {
        "message": "user created",
        "user": user_response,
    }</pre> <p>We have just <a id="_idIndexMarker226"/>implemented a basic mechanism to register and store users in our SaaS database.</p>
<h2 id="_idParaDest-125"><a id="_idTextAnchor128"/>How it works...</h2>
<p>The endpoint will accept a JSON body containing a username, email, and password.</p>
<p>If the username or email already exists, a <code>409</code> response will be returned, and user creation will be disallowed.</p>
<p>To test this, at the project root level, spin up the server by running the following:</p>
<pre class="console">
$ uvicorn main:app</pre> <p>Then, connect with your browser at <code>localhost:8000/docs</code> and check the endpoint we just created in<a id="_idIndexMarker227"/> the Swagger documentation. Feel free to play around with it.</p>
<p class="callout-heading">Exercise</p>
<p class="callout">Create proper tests for both the <code>add_user</code> function and the <code>/register/user</code> endpoint, such as the following:</p>
<p class="callout"><code>def test_add_user_into_the_database(session):</code></p>
<p class="callout">    <code>user = </code><code>add_user(…</code></p>
<p class="callout">    <code># fill in </code><code>the test</code></p>
<p class="callout"><code>def test_endpoint_add_basic_user(client):</code></p>
<p class="callout">    <code>response = </code><code>client.post(</code></p>
<p class="callout">        <code>"/</code><code>register/user",</code></p>
<p class="callout">        <code>json=</code></p>
<p class="callout">    <code># continue </code><code>the test</code></p>
<p class="callout">You can arrange the test in any way that works best for you.</p>
<p class="callout">You can find a possible way of testing in the <code>Chapter04/saas_app</code> folder of the book’s GitHub repository.</p>
<h2 id="_idParaDest-126"><a id="_idTextAnchor129"/>See also</h2>
<p>The <strong class="bold">bcrypt</strong> library allows you to add several layers of security to your hashing functions, such as salt and additional keys. Feel free to have a look at the source code on GitHub:</p>
<ul>
<li><em class="italic">Bcrypt GitHub </em><em class="italic">Repository</em>: <a href="https://github.com/pyca/bcrypt/">https://github.com/pyca/bcrypt/</a></li>
</ul>
<p>Also, you can<a id="_idIndexMarker228"/> find some interesting examples of how to use it at the following:</p>
<ul>
<li><em class="italic">Hashing Passwords in Python with </em><em class="italic">Bcrypt</em>: <a href="https://www.geeksforgeeks.org/hashing-passwords-in-python-with-bcrypt/">https://www.geeksforgeeks.org/hashing-passwords-in-python-with-bcrypt/</a></li>
</ul>
<h1 id="_idParaDest-127"><a id="_idTextAnchor130"/>Working with OAuth2 and JWT for authentication</h1>
<p>In this recipe, we’ll <a id="_idIndexMarker229"/>integrate OAuth2 with JWTs for<a id="_idIndexMarker230"/> secure user authentication in your application. This approach improves security by utilizing tokens instead of credentials, aligning with modern authentication standards.</p>
<h2 id="_idParaDest-128"><a id="_idTextAnchor131"/>Getting ready</h2>
<p>Since we will use a specific library to manage JWT, ensure you have the necessary dependencies installed. If you haven’t installed the packages from <code>requirements.txt</code>, run the following:</p>
<pre class="console">
$ pip install python-jose[cryptography]</pre> <p>Also, we will use the users table used in the previous recipe, <em class="italic">Setting up user registration</em>. Make sure to have set it up before starting the recipe.</p>
<h2 id="_idParaDest-129"><a id="_idTextAnchor132"/>How to do it...</h2>
<p>We can set up the JWT token integration through the following steps.</p>
<ol>
<li>In a new <a id="_idIndexMarker231"/>module <a id="_idIndexMarker232"/>called <code>security.py</code>, let’s define the authentication function for the user:<pre class="source-code">
from sqlalchemy.orm import Session
from models import User
from email_validator import (
    validate_email,
    EmailNotValidError,
)
from operations import pwd_context
def authenticate_user(
    session: Session,
    username_or_email: str,
    password: str,
) -&gt; User | None:
    try:
        validate_email(username_or_email)
        query_filter = User.email
    except EmailNotValidError:
        query_filter = User.username
    user = (
        session.query(User)
        .filter(query_filter == username_or_email)
        .first()
    )
    if not user or not pwd_context.verify(
        password, user.hashed_password
    ):
        return
    return user</pre><p class="list-inset">The function can validate the input based on either the username or email.</p></li> <li>Let’s define the functions to create and decode the access token in the same module (<code>create_access_token</code> and <code>decode_access_token</code>).<p class="list-inset">To create<a id="_idIndexMarker233"/> the <a id="_idIndexMarker234"/>access token, we will need to specify a secret key, the algorithm used to generate it, and the expiration time, as follows:</p><pre class="source-code">
SECRET_KEY = "a_very_secret_key"
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 30</pre><p class="list-inset">Then, the <code>create_access_token_function</code> is as follows:</p><pre class="source-code">from jose import jwt
def create_access_token(data: dict) -&gt; str:
    to_encode = data.copy()
    expire = datetime.utcnow() + timedelta(
        minutes=ACCESS_TOKEN_EXPIRE_MINUTES
    )
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(
        to_encode, SECRET_KEY, algorithm=ALGORITHM
    )
    return encoded_jwt</pre><p class="list-inset">To decode the access token, we can use a support function, <code>get_user</code>, that returns the <code>User</code> object by the username. You can do it on your own in the <code>operations.py</code> module or take it from the GitHub repository.</p><p class="list-inset">The function<a id="_idIndexMarker235"/> to<a id="_idIndexMarker236"/> decode the token will be as follows:</p><pre class="source-code">from jose import JWTError
def decode_access_token(
    token: str, session: Session
) -&gt; User | None:
    try:
        payload = jwt.decode(
            token, SECRET_KEY, algorithms=[ALGORITHM]
        )
        username: str = payload.get("sub")
    except JWTError:
        return
    if not username:
        return
    user = get_user(session, username)
    return user</pre></li> <li>We can now proceed to <a id="_idIndexMarker237"/>create<a id="_idIndexMarker238"/> the endpoint to retrieve the token in the same module, <code>security.py</code>, with the <code>APIRouter</code> class:<pre class="source-code">
from fastapi import (
    APIRouter,
    Depends,
    HTTPException,
    status,
)
from fastapi.security import (
    OAuth2PasswordRequestForm,
)
router = APIRouter()
class Token(BaseModel):
    access_token: str
    token_type: str
@router.post(
    "/token",
    response_model=Token,
    responses=..., # document the responses
)
def get_user_access_token(
    form_data: OAuth2PasswordRequestForm = Depends(),
    session: Session = Depends(get_session),
):
    user = authenticate_user(
        session,
        form_data.username,
        form_data.password
    )
    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect username or password",
        )
    access_token = create_access_token(
        data={"sub": user.username}
    )
    return {
        "access_token": access_token,
        "token_type": "bearer",
    }</pre></li> <li>Then, we can now create an <code>OAuth2PasswordBearer</code> object for the <code>POST /token</code> endpoint to obtain the access token:<pre class="source-code">
from fastapi.security import (
    OAuth2PasswordBearer,
)
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")</pre></li> <li>Finally, we<a id="_idIndexMarker239"/> can<a id="_idIndexMarker240"/> create the <code>/users/me</code> endpoint that returns the credentials based on the token:<pre class="source-code">
@router.get(
    "/users/me",
    responses=..., # document responses
)
def read_user_me(
    token: str = Depends(oauth2_scheme),
    session: Session = Depends(get_session),
):
    user = decode_access_token(token, session)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="User not authorized",
        )
    return {
        "description": f"{user.username} authorized",
    }</pre></li> <li>Now, let’s import those endpoints into the FastAPI server in <code>main.py</code>. Right after defining the FastAPI object, let’s add the router, as follows:<pre class="source-code">
<strong class="bold">import security</strong>
# rest of the code
<strong class="bold">app.include_router(security.router)</strong></pre></li> </ol>
<p>We have just defined the authentication mechanism for our SaaS.</p>
<h2 id="_idParaDest-130"><a id="_idTextAnchor133"/>How it works…</h2>
<p>Now, spin up the server by running the following code from the terminal at the project root folder level:</p>
<pre class="console">
$ uvicorn main:app</pre> <p>Go to the Swagger documentation address in your browser (<code>localhost:8000/docs</code>) and you will see the new endpoints, <code>POST /token</code> and <code>GET /users/me</code>.</p>
<p>You need the token to call the second endpoint, which you can store in your browser automatically by clicking on the lock icon and filling out the form with your credentials.</p>
<p>You’ve made<a id="_idIndexMarker241"/> your<a id="_idIndexMarker242"/> SaaS application more secure by using OAuth2 with JWT, which help you guard your sensitive endpoints and make sure that only users who are logged in can use them. This arrangement gives you a reliable and safe way to verify users that works well for modern web applications.</p>
<h2 id="_idParaDest-131"><a id="_idTextAnchor134"/>See also</h2>
<p>You can gain a better understanding of the OAuth2 framework by reading this article:</p>
<ul>
<li><em class="italic">Introduction to </em><em class="italic">OAuth2</em>: <a href="https://www.digitalocean.com/community/tutorials/an-introduction-to-oauth-2">https://www.digitalocean.com/community/tutorials/an-introduction-to-oauth-2</a></li>
</ul>
<p>Also, you can have a look at the protocol definition for JWTs at the following:</p>
<ul>
<li><em class="italic">JWT IETF </em><em class="italic">Document</em>: <a href="https://datatracker.ietf.org/doc/html/rfc7519">https://datatracker.ietf.org/doc/html/rfc7519</a></li>
</ul>
<h1 id="_idParaDest-132"><a id="_idTextAnchor135"/>Setting up RBAC</h1>
<p>RBAC is a method <a id="_idIndexMarker243"/>of regulating access to resources based on the roles of individual users within an organization. In this recipe, we’ll implement RBAC in a FastAPI application to manage user permissions effectively.</p>
<h2 id="_idParaDest-133"><a id="_idTextAnchor136"/>Getting ready</h2>
<p>Since we will expand our database to accommodate role definitions, make sure you have completed the <em class="italic">Setting up user registration</em> recipe before diving into this.</p>
<p>To set up access control, we first need to define a variety of roles that we can allocate to. Let’s follow these steps to do it.</p>
<ol>
<li>In the <code>module.py</code> module, we can define a new class called <code>Role</code> and add it as a new field of the <code>User</code> model that will be stored in the users table:<pre class="source-code">
from enum import Enum
class Role(str, Enum):
    basic = "basic"
    premium = "premium"
class User(Base):
    __tablename__ = "users"
# existing fields
    role: Mapped[Role] = mapped_column(
        default=Role.basic
    )</pre></li> <li>Then, in the <code>operations.py</code> module, we will modify the <code>add_user</code> function in <code>operations.py</code> to accept a parameter to define the user role; the default<a id="_idIndexMarker244"/> value will be the basic role:<pre class="source-code">
<strong class="bold">from models import Role</strong>
def add_user(
    session: Session,
    username: str,
    password: str,
    email: str,
<strong class="bold">    role: Role = Role.basic,</strong>
) -&gt; User | None:
    hashed_password = pwd_context.hash(password)
    db_user = User(
        username=username,
        email=email,
        hashed_password=hashed_password,
<strong class="bold">        role=role,</strong>
    )
    # rest of the function</pre></li> <li>Let’s create a new module called <code>premium_access.py</code> and define the endpoint through a new router to sign up a premium user, which will look a lot like the endpoint <a id="_idIndexMarker245"/>to sign up a basic user:<pre class="source-code">
@router.post(
    "/register/premium-user",
    status_code=status.HTTP_201_CREATED,
    response_model=ResponseCreateUser,
    responses=..., # document responses
)
def register_premium_user(
    user: UserCreateBody,
    session: Session = Depends(get_session),
):
    user = add_user(
        session=session,
         *user.model_dump(),
        role=Role.premium,
    )
    if not user:
        raise HTTPException(
            status.HTTP_409_CONFLICT,
            "username or email already exists",
        )
    user_response = UserCreate(
        username=user.username,
        email=user.email,
    )
    return {
        "message": "user created",
        "user": user_response,
    }
similar to the ones used in other modules.</pre></li> <li>Let’s add the router to our <code>app</code> class in the <code>main.py</code> module:<pre class="source-code">
import security
<strong class="bold">import premium_access</strong>
# rest of the code
app.include_router(security.router)
<strong class="bold">app.include_router(premium_access.router)</strong></pre></li> </ol>
<p>We have now all the elements to implement RBAC in our SaaS application.</p>
<h2 id="_idParaDest-134"><a id="_idTextAnchor137"/>How to do it...</h2>
<p>Let’s create two endpoints, one accessible for all the users and one reserved only for premium user. Let's make the endpoints through the following steps.</p>
<ol>
<li>First, let’s create two helper functions, <code>get_current_user</code> and <code>get_premium_user</code>, to retrieve each case and to be used as dependencies for the endpoints, respectively.<p class="list-inset">We can define a separate module, called the <code>rbac.py</code> module. Let’s start with the imports:</p><pre class="source-code">
from typing import Annotated
from fastapi import (
    APIRouter,
    Depends,
    HTTPException,
    Status
)
from sqlalchemy.orm import Session
from db_connection import get_session
from models import Role
from security import (
    decode_access_token,
    oauth2_scheme
)</pre><p class="list-inset">Then, we create <a id="_idIndexMarker247"/>the request model that we will use with the endpoints:</p><pre class="source-code">class UserCreateResquestWithRole(BaseModel):
    username: str
    email: EmailStr
    role: Role</pre><p class="list-inset">Then, we define a support function to retrieve the user based on the token:</p><pre class="source-code">def get_current_user(
    token: str = Depends(oauth2_scheme),
    session: Session = Depends(get_session),
) -&gt; UserCreateRequestWithRole:
    user = decode_access_token(token, session)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="User not authorized",
        )
    return UserCreateRequestWithRole(
        username=user.username,
        email=user.email,
        role=user.role,
    )</pre><p class="list-inset">We can then<a id="_idIndexMarker248"/> leverage this function to shortlist premium users only:</p><pre class="source-code">def get_premium_user(
    current_user: Annotated[
        get_current_user, Depends()
    ]
):
    if current_user.role != Role.premium:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="User not authorized",
        )
    return current_user</pre></li> <li>Now, we can use the functions to create the respective endpoints with the router in the <a id="_idIndexMarker249"/>same module. First, we define a welcome page for all the users:<pre class="source-code">
router = APIRouter()
@router.get(
    "/welcome/all-users",
    responses=..., # document responses
)
def all_users_can_access(
    user: Annotated[get_current_user, Depends()]
):
    return {
        f"Hello {user.username}, "
        "welcome to your space"
    }</pre><p class="list-inset">Then, we define the endpoint, allowing only premium users:</p><pre class="source-code">@router.get(
    "/welcome/premium-user",
    responses={
        status.HTTP_401_UNAUTHORIZED: {
            "description": "User not authorized"
        }
    },
)
def only_premium_users_can_access(
    user: UserCreateResponseWithRole = Depends(
        get_premium_user
    ),
):
    return {
        f"Hello {user.username}, "
        "Welcome to your premium space"
    }</pre></li> <li>Let’s add the <a id="_idIndexMarker250"/>router we create in <code>main.py</code>:<pre class="source-code">
import security
import premium_access
<strong class="bold">import rbac</strong>
# rest of the module
app.include_router(premium_access.router)
<strong class="bold">app.include_router(rbac.router)</strong>
# rest of the module</pre></li> </ol>
<p>We have just implemented two endpoints with permissions based on the use role.</p>
<p>To test our endpoints, start the server from the command line:</p>
<pre class="console">
$ uvicorn main:app</pre> <p>Then, from your browser, go to the Swagger page at <code>http://localhost:8000/docs</code>, and you can see the new endpoints just created.</p>
<p>A way to experiment is to create a basic and a premium user and use the corresponding endpoints. After you have made the users, you can try using the <code>GET welcome/all-users</code> and <code>GET /welcome/premium-user</code> endpoints with both roles and see that the response matches the role’s expectations.</p>
<p>In this recipe, you<a id="_idIndexMarker251"/> just made simple endpoints that are available based on the user role. You can also play around with making more roles and endpoints.</p>
<h2 id="_idParaDest-135"><a id="_idTextAnchor138"/>There’s more…</h2>
<p>Another way to apply RBAC is to assign a scope to a token. This scope can be a string that represents certain permissions. As a result, the role is controlled by the token generation system. In FastAPI, you can define scopes within the token. You can check out the dedicated documentation page for more information: <a href="https://fastapi.tiangolo.com/advanced/security/oauth2-scopes/">https://fastapi.tiangolo.com/advanced/security/oauth2-scopes/</a>.</p>
<h1 id="_idParaDest-136"><a id="_idTextAnchor139"/>Using third-party authentication</h1>
<p>Incorporating<a id="_idIndexMarker252"/> third-party authentication into your FastAPI application allows users to log in using their existing social media accounts, such as Google or Facebook. This recipe guides you through the process of integrating GitHub third-party login, enhancing user experience by simplifying the sign-in process.</p>
<h2 id="_idParaDest-137"><a id="_idTextAnchor140"/>Getting ready</h2>
<p>We’ll focus on integrating GitHub OAuth2 for authentication. GitHub provides comprehensive documentation and a well-supported client library that simplifies the integration process.</p>
<p>You will need the <code>httpx</code> package in your environment, so if you haven’t installed it with the <code>requirements.txt</code>, you can do it by running the following:</p>
<pre class="console">
$ pip install httpx</pre> <p>You will need also a GitHub account set up. If you don’t have one, create one; you can find a comprehensive guide on the official documentation at <a href="https://docs.github.com/en/get-started/start-your-journey/creating-an-account-on-github">https://docs.github.com/en/get-started/start-your-journey/creating-an-account-on-github</a>.</p>
<p>Then, you need to create an application in your account by following the following steps:</p>
<ol>
<li>From<a id="_idIndexMarker253"/> your personal page, click on the profile icon on the top right of the screen, the navigate to <code>SaasFastAPIapp</code>.</li><li><code>http://localhost:8000/home</code>, which we will create later.</li><li><code>http://localhost:8000/github/auth/token</code>, which we will define later as well.</li></ul></li>
<li>Click on <strong class="bold">Register application</strong> and the app will be created, and you will be redirected to a page listing essential data about your OAuth2 app.</li>
<li>Take note of the client ID and click on the <strong class="bold">Generate a new </strong><strong class="bold">client secret</strong>.</li>
<li>Store the client secret you just created. With the client ID and the client secret, we can proceed to implement the third-party authentication by GitHub.</li>
</ol>
<p>Now, we have all we need to integrate the GitHub third-party login with our application.</p>
<h2 id="_idParaDest-138"><a id="_idTextAnchor141"/>How to do it...</h2>
<p>Let’s start by creating a new module called <code>third_party_login.py</code> to store helper data and functions<a id="_idIndexMarker254"/> for the GitHub authentication. Then let's continue as follows.</p>
<ol>
<li>Within the <code>third_party_login.py</code> module, you can define the variables used for the authentication:<pre class="source-code">
GITHUB_CLIENT_ID = "your_github_client_id"
GITHUB_CLIENT_SECRET = (
    "your_github_client_secret"
)
GITHUB_REDIRECT_URI = (
    "http://localhost:8000/github/auth/token"
)
GITHUB_AUTHORIZATION_URL = (
    "https://github.com/login/oauth/authorize"
)</pre><p class="list-inset">For <code>GITHUB_CLIENT_ID</code> and <code>GITHUB_CLIENT_SECRET</code>, use the values of your OAuth app.</p></li> </ol>
<p class="callout-heading">Warning</p>
<p class="callout">In a production environment, make sure to not hardcode any username or client ID in your code base.</p>
<ol>
<li value="2">Then, still in the <code>third_party_login.py</code> module, let’s define a helper function, <code>resolve_github_token</code>, that resolves the GitHub token and returns information <a id="_idIndexMarker255"/>about the user:<pre class="source-code">
import httpx
from fastapi import Depends, HTTPException
from fastapi.security import OAuth2
from sqlalchemy.orm import Session
from models import User, get_session
from operations import get_user
def resolve_github_token(
    access_token: str = Depends(OAuth2()),
    session: Session = Depends(get_session),
) -&gt; User:
    user_response = httpx.get(
        "https://api.github.com/user",
        headers={"Authorization": access_token},
    ).json()
    username = user_response.get("login", " ")
    user = get_user(session, username)
    if not user:
        email = user_response.get("email", " ")
        user = get_user(session, email)
    # Process user_response
    # to log the user in or create a new account
    if not user:
        raise HTTPException(
            status_code=403, detail="Token not valid"
        )
    return user</pre></li> <li>In a new module called <code>github_login.py</code>, we can start creating the endpoints used for the GitHub authentication. Let’s create a new router and the <code>github_login</code> endpoint that will return the URL used by the frontend to redirect the <a id="_idIndexMarker256"/>user to the GitHub login page:<pre class="source-code">
import httpx
from fastapi import APIRouter, HTTPException, status
from security import Token
from third_party_login import (
    GITHUB_AUTHORIZATION_URL,
    GITHUB_CLIENT_ID,
    GITHUB_CLIENT_SECRET,
    GITHUB_REDIRECT_URI,
)
router = APIRouter()
@router.get("/auth/url")
def github_login():
    return {
        "auth_url": GITHUB_AUTHORIZATION_URL
        + f"?client_id={GITHUB_CLIENT_ID}"
    }</pre></li> <li>Now, let’s add the router to the server in the <code>main.py</code> module:<pre class="source-code">
<strong class="bold">import github_login</strong>
# rest of the module
<strong class="bold">app.include_router(github_login.router)</strong>
# rest of the module</pre></li> <li>Spin up the server with the same command, <code>uvicorn main:app</code>, and call the endpoint <code>GET</code> <code>/auth/url</code> we have just created. You will have a similar link in the response: <a href="https://github.com/login/oauth/authorize?client_id=your_github_client_id">https://github.com/login/oauth/authorize?client_id=your_github_client_id</a>.<p class="list-inset">This link is <a id="_idIndexMarker257"/>used by GitHub for the authentication. The redirection is managed by the frontend and is out of the scope of this book.</p></li>
<li>After validating the login, you will be redirected to a <code>404</code> page. This is because we still haven’t created the callback endpoint in our application. Let’s do so in the <code>github_login.py</code> module:<pre class="source-code">
@router.get(
    "/github/auth/token",
    response_model=Token,
    responses=..., # add responses documentation
)
async def github_callback(code: str):
    token_response = httpx.post(
        "https://github.com/login/oauth/access_token",
        data={
            "client_id": GITHUB_CLIENT_ID,
            "client_secret": GITHUB_CLIENT_SECRET,
            "code": code,
            "redirect_uri": GITHUB_REDIRECT_URI,
        },
        headers={"Accept": "application/json"},
    ).json()
    access_token = token_response.get("access_token")
    if not access_token:
        raise HTTPException(
            status_code=401,
            detail="User not registered",
        )
    token_type = token_response.get(
        "token_type", "bearer"
    )
    return {
        "access_token": access_token,
        "token_type": token_type,
    }</pre><p class="list-inset">The endpoint we just created returns the actual access token.</p></li> <li>If you restart the server and try to validate the GitHub login again with the link provded by the <code>GET</code> <code>/auth/url</code> endpoint, you will receive a response containing the token similar to the following:<pre class="source-code">
{
    "access_token": "gho_EnHbcmHdCHD1Bf2QzJ2B6gyt",
    "token_type": "bearer"
}</pre></li> <li>The last piece of the puzzle is to create the home page endpoint that can be accessed with the GitHub token and will recognize the user by resolving the token. We <a id="_idIndexMarker258"/>can define it in the <code>main.py</code> module:<pre class="source-code">
from third_party_login import resolve_github_token
@router.get(
    "/home",
    responses=…, # add responses documentation
)
def homepage(
    user: UserCreateResponse = Depends(
        resolve_github_token
    ),
):
    return {
        "message" : f"logged in {user.username} !"
    }</pre></li> </ol>
<p>You’ve just implemented an endpoint that authenticates with the GitHub third-party authenticator.</p>
<h2 id="_idParaDest-139"><a id="_idTextAnchor142"/>How it works…</h2>
<p>First, by using the register endpoint <code>POST /register/user</code>, add a user that has the same username or email as the GitHub account you are going to test.</p>
<p>Then, retrieve the token from the GitHub URL provided by the <code>GET /</code><code>auth/url</code> endpoint.</p>
<p>You will use a token with your favorite tool to query the <code>GET /home</code> endpoint, which uses the GitHub token to validate permission.</p>
<p>At the time of writing, we cannot test endpoints requiring external bearer tokens with the interactive documentation, so feel free to use your favorite tool to query the endpoint by providing the bearer token in the headers authorization.</p>
<p>You can do it <a id="_idIndexMarker259"/>with <code>curl</code> request from your shell as well, as follows:</p>
<pre class="console">
$ curl --location 'http://localhost:8000/home' \
--header 'Authorization: Bearer &lt;github-token&gt;'</pre> <p>If everything is correctly set up, you will receive the response:</p>
<pre class="console">
{"message":"logged in &lt;your-username&gt; !"}</pre> <p>You just<a id="_idIndexMarker260"/> implemented and tested authentication by using a third-party application such as GitHub. Other providers such as Google or Twitter follow similar procedures, with small differences. Feel free to implement them as well.</p>
<h2 id="_idParaDest-140"><a id="_idTextAnchor143"/>See also</h2>
<p>Take a look at the GitHub documentation that provides a guide on how to set up OAuth2 authentication:</p>
<ul>
<li><em class="italic">GitHub OAuth2 </em><em class="italic">integration</em>: <a href="https://docs.github.com/en/apps/oauth-apps/building-oauth-apps/authorizing-oauth-apps">https://docs.github.com/en/apps/oauth-apps/building-oauth-apps/authorizing-oauth-apps</a></li>
</ul>
<p>You can use third-party authorization login with other providers that allow a similar configuration. You can check, for example, Google and Twitter:</p>
<ul>
<li><em class="italic">Google OAuth2 </em><em class="italic">integration</em>: <a href="https://developers.google.com/identity/protocols/oauth2">https://developers.google.com/identity/protocols/oauth2</a></li>
<li><em class="italic">Twitter OAuth2 </em><em class="italic">integration</em>: <a href="https://developer.twitter.com/en/docs/authentication/oauth-2-0">https://developer.twitter.com/en/docs/authentication/oauth-2-0</a></li>
</ul>
<h1 id="_idParaDest-141"><a id="_idTextAnchor144"/>Implementing MFA</h1>
<p>MFA adds a layer<a id="_idIndexMarker261"/> of security by requiring users to provide two or more verification factors to gain access to a resource. The recipe guides you through adding MFA to your FastAPI application, enhancing security by combining something the user knows (their password) with something they have (a device).</p>
<h2 id="_idParaDest-142"><a id="_idTextAnchor145"/>Getting ready</h2>
<p>For our FastAPI application, we’ll <a id="_idIndexMarker262"/>use a <strong class="bold">time-based one-time password</strong> (<strong class="bold">TOTP</strong>) as our MFA method. TOTP provides a six to eight-digit number that’s valid for a short period, typically 30 seconds.</p>
<p>First, ensure you have the necessary packages installed:</p>
<pre class="console">
$ pip install pyotp</pre> <p><strong class="bold">Pyotp</strong> is a Python<a id="_idIndexMarker263"/> library that implements one-time password algorithms, including TOTP.</p>
<p>To use the TOTP authentication, we need to modify the user table in our database to take into account the TOTP secret used to validate the secret number.</p>
<p>Let’s modify the <code>User</code> class in the <code>models.py</code> module by adding the <code>totp_secret</code> field:</p>
<pre class="source-code">
class User(Base):
    # existing fields
<strong class="bold">    totp_secret: Mapped[str] = mapped_column(</strong>
<strong class="bold">        nullable=True</strong>
<strong class="bold">    </strong><strong class="bold">)</strong></pre> <p>We are now ready to implement MFA.</p>
<h2 id="_idParaDest-143"><a id="_idTextAnchor146"/>How to do it...</h2>
<p>Let’s start by creating two helper functions to generate a TOTP secret and TOTP URI used by the authenticatorthrough the following steps.</p>
<ol>
<li>We define <a id="_idIndexMarker264"/>the functions in a new module called <code>mfa.py</code>:<pre class="source-code">
import pyotp
def generate_totp_secret():
    return pyotp.random_base32()
def generate_totp_uri(secret, user_email):
    return pyotp.totp.TOTP(secret).provisioning_uri(
        name=user_email, issuer_name="YourAppName"
    )</pre><p class="list-inset">The TOTP URI can be a QR code as well in the form of a link.</p><p class="list-inset">We will use the <code>generate_totp_secret</code> and <code>generate_totp_uri</code> functions to create the endpoint to request MFA.</p></li> <li>The endpoint will<a id="_idIndexMarker265"/> return a <strong class="bold">TOTP URI</strong> for use by the authenticator. To show the mechanism, we will also return the secret number, which in a real-life scenario is the number<a id="_idIndexMarker266"/> generated by the authenticator:<pre class="source-code">
from fastapi import (
    APIRouter,
    Depends,
    HTTPException,
    status,
)
from sqlalchemy.orm import Session
from db_connection import get_session
from operations import get_user
from rbac import get_current_user
from responses import UserCreateResponse
router = APIRouter()
@router.post("/user/enable-mfa")
def enable_mfa(
    user: UserCreateResponse = Depends(
        get_current_user
    ),
    db_session: Session = Depends(get_session),
):
    secret = generate_totp_secret()
    db_user = get_user(db_session, user.username)
    db_user.totp_secret = secret
    db_session.add(db_user)
    db_session.commit()
    totp_uri = generate_totp_uri(secret, user.email)
    # Return the TOTP URI
    # for QR code generation in the frontend
    return {
        "totp_uri": totp_uri,
        "secret_numbers": pyotp.TOTP(secret).now(),
    }</pre></li> <li>Now, we can <a id="_idIndexMarker267"/>create the endpoint to validate the secret number:<pre class="source-code">
@app.post("/verify-totp")
def verify_totp(
    code: str,
    username: str,
    session: Session = Depends(get_session),
):
    user = get_user(session, username)
    if not user.totp_secret:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="MFA not activated",
        )
    totp = pyotp.TOTP(user.totp_secret)
    if not totp.verify(code):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid TOTP token",
        )
    # Proceed with granting access
    # or performing the sensitive operation
    return {
        "message": "TOTP token verified successfully"
    }</pre></li> </ol>
<p>As before, you need<a id="_idIndexMarker268"/> to include the router in the <code>FastAPI</code> object class in <code>main.py</code> for all the previous endpoints.</p>
<p>To test it, as usual spin up the server from the terminal by running:</p>
<pre class="console">
$ uvicorn main:app</pre> <p>Make sure you have a user in your database, go to the interactive documentation, and call the <code>/user/enable-mfa</code> endpoint by authenticating with the user credentials. You will get a response with the TOTP URI and a temporary secret number, like the following:</p>
<pre class="source-code">
{
  "totp_uri":
  "otpauth://totp/YourAppName:giunio%40example.com?secret=
  NBSUC4CFDUT5IEYX4IR7WKBTDTU7LN25&amp;issuer=YourAppName",
  "secret_numbers": "853567"
}</pre> <p>Take note of the secret number to use as a parameter of the <code>/verify-totp</code> endpoint with the username, and you will get this response:</p>
<pre class="source-code">
{
  "message": "TOTP token verified successfully"
}</pre> <p>You’ve just implemented MFA in your FastAPI application and enhanced security by ensuring that even if a user’s password is compromised, an attacker still needs access to the user’s second <a id="_idIndexMarker269"/>factor (the device running the MFA app) to gain access.</p>
<h2 id="_idParaDest-144"><a id="_idTextAnchor147"/>See also</h2>
<p>Take a look at the Python One-Time Password library in the official documentation:</p>
<ul>
<li><em class="italic">Python One-Time Password </em><em class="italic">library</em>: <a href="https://pyauth.github.io/pyotp/">https://pyauth.github.io/pyotp/</a></li>
</ul>
<h1 id="_idParaDest-145"><a id="_idTextAnchor148"/>Handling API key authentication</h1>
<p>API key authentication <a id="_idIndexMarker270"/>is a simple yet effective way to control access to an application. This method involves generating a unique key for each user or service that needs access to your API and requiring that key to be included in the request headers.</p>
<p>API keys can be generated in various ways, depending on the level of security needed.</p>
<p>FastAPI doesn’t have built-in support for API key authentication, but you can easily implement it using dependencies or middleware. A dependency is more flexible for most use cases, so we’ll use that approach.</p>
<p>This recipe will show you a basic, yet not secure, way to implement it.</p>
<h2 id="_idParaDest-146"><a id="_idTextAnchor149"/>Getting ready</h2>
<p>We will keep working on our application. However, you can apply this recipe to a simple application from scratch as well.</p>
<h2 id="_idParaDest-147"><a id="_idTextAnchor150"/>How to do it...</h2>
<p>Let’s create an <code>api_key.py</code> module to store the logic to handle API keys. The package will contain the <a id="_idIndexMarker271"/>API list and verification method:</p>
<pre class="source-code">
from fastapi import HTTPException
from typing import Optional
VALID_API_KEYS = [
    "verysecureapikey",
    "anothersecureapi",
    "onemoresecureapi",
]
async def get_api_key(
    api_key: Optional[str]
):
    if (
        api_key not in VALID_API_KEYS
    ):
        raise HTTPException(
            status_code=403, detail="Invalid API Key"
        )
    return api_key</pre> <p>In the example, the keys are hardcoded into the <code>VALID_API_KEYS</code> list. However, in real-life production scenarios, the management and validation of the keys are usually done by dedicated libraries or even services.</p>
<p>Let’s create an endpoint that makes use of the API key:</p>
<pre class="source-code">
from fastatpi import APIrouter
router = APIRouter()
@router.get("/secure-data")
async def get_secure_data(
    api_key: str = Depends(get_api_key),
):
    return {"message": "Access to secure data granted"}</pre> <p>Now, add the<a id="_idIndexMarker272"/> router to the <code>FastAPI</code> object class in <code>main.py</code>, and then the endpoint is ready to be tested.</p>
<p>Spin up the server from the command by running the following:</p>
<pre class="console">
$ uvicorn main:app</pre> <p>Go to the interactive documentation at <code>http://localhost:8000/docs</code> and test the endpoint you just created by providing an API key.</p>
<p>As you see, by adding a simple dependency to the endpoint, you can secure any endpoint of your app with an API key.</p>
<h2 id="_idParaDest-148"><a id="_idTextAnchor151"/>There’s more…</h2>
<p>We have developed a simple module for managing the API of our application. In production environment this can be handled by external services often provided by the hosting platform. However, If you are going to implement your API management system, keep in mind the best practices for API key authentication:</p>
<ul>
<li><strong class="bold">Transmission security</strong>: Always<a id="_idIndexMarker273"/> use HTTPS to prevent API keys from being intercepted during transmission</li>
<li><strong class="bold">Key rotation</strong>: Regularly rotate API keys to minimize the risk of compromise</li>
<li><strong class="bold">Limit permissions</strong>: Assign minimal permissions required for each API key based on the principle of least privilege</li>
<li><strong class="bold">Monitoring and revocation</strong>: Monitor the usage of API keys and have mechanisms<a id="_idIndexMarker274"/> in place to revoke them if suspicious activity is detected</li>
</ul>
<h1 id="_idParaDest-149"><a id="_idTextAnchor152"/>Handling session cookies and logout functionality</h1>
<p>Managing user <a id="_idIndexMarker275"/>sessions and implementing logout functionality is <a id="_idIndexMarker276"/>crucial for maintaining security and user experience in web applications. This recipe shows how to handle session cookies in FastAPI, from creating cookies upon user login to securely terminating sessions upon logout.</p>
<h2 id="_idParaDest-150"><a id="_idTextAnchor153"/>Getting ready</h2>
<p>Sessions provide a way to persist user data across requests. When a user logs in, the application creates a session on the server side and sends a session identifier to the client, usually in a <strong class="bold">cookie</strong>. The client sends this identifier back with each request, allowing the server to retrieve the user’s session data.</p>
<p>The recipe will show how to manage cookies for sessions with login and logout functionality.</p>
<h2 id="_idParaDest-151"><a id="_idTextAnchor154"/>How to do it...</h2>
<p>Cookies in FastAPI are easily managed by the <code>Request</code> and <code>Response</code> object classes. Let’s create a login and a logout endpoints to attaches a session cookie to the response and ignore it from the request. </p>
<p>Let’s create a dedicated module called <code>user_session.py</code> and add the <code>/</code><code>login</code> endpoint:</p>
<pre class="source-code">
from fastapi import APIRouter, Depends, Response
from sqlalchemy.orm import Session
from db_connection import get_session
from operations import get_user
from rbac import get_current_user
from responses import UserCreateResponse
router = APIRouter()
@router.post("/login")
async def login(
    response: Response,
    user: UserCreateResponse = Depends(
        get_current_user
    ),
    session: Session = Depends(get_session),
):
    user = get_user(session, user.username)
    response.set_cookie(
        key="fakesession", value=f"{user.id}"
    )
    return {"message": "User logged in successfully"}</pre> <p>Testing the login endpoint won’t be possible with the Swagger documentation because we need to verify that the <code>fakesession</code> cookie has been created.</p>
<p>Spin up the server with <code>uvicorn main:app</code> and use Postman to create a <code>Post</code> request to the <code>/login</code> endpoint by providing the authentication token for the user you want to log in.</p>
<p>Verify that the response contains the <code>fakesession</code> cookie by selecting <strong class="bold">Cookies</strong> from the drop-down menu of the response section.</p>
<p>Accordingly, we <a id="_idIndexMarker277"/>can define a logout endpoint that won’t return<a id="_idIndexMarker278"/> any session cookie in the response:</p>
<pre class="source-code">
@router.post("/logout")
async def logout(
    response: Response,
    user: UserCreateResponse = Depends(
         get_current_user
    ),
):
    response.delete_cookie(
        "fakesession"
    )  # Clear session data
    return {"message": "User logged out successfully"}</pre> <p>That’s all you need to manage sessions.</p>
<p>To test the <code>POST /logout</code> endpoint, restart the server with <code>uvicorn</code>. Then, when calling the endpoint, make sure you provide the <code>fakesession</code> cookie in your HTTP request with the user bearer token. If you previously called the login endpoint, it should be automatically stored; otherwise, you can set it in the <code>Cookies</code> section of the request.</p>
<p>Check the<a id="_idIndexMarker279"/> response<a id="_idIndexMarker280"/> and confirm that the <code>fakesession</code> cookie is not present anymore in the response.</p>
<h2 id="_idParaDest-152"><a id="_idTextAnchor155"/>There’s more…</h2>
<p>There is a lot to learn about cookies besides the basic recipe. In a real-world setting, you can use specialized libraries or even external services.</p>
<p>Whatever your choice is, put security first and follow those practices to make your session secure and efficient:</p>
<ul>
<li><code>Secure</code>, <code>HttpOnly</code>, and <code>SameSite</code> to<a id="_idIndexMarker281"/> protect<a id="_idIndexMarker282"/> against <strong class="bold">cross-site request forgery</strong> (<strong class="bold">CSRF</strong>) and <strong class="bold">cross-site scripting</strong> (<strong class="bold">XSS</strong>) attacks</li>
<li><strong class="bold">Session expiry</strong>: Implement session expiry both in your session store and by setting a maximum age on the cookie</li>
<li><strong class="bold">Regenerate Session ID</strong>: Regenerate session IDs upon login to prevent session fixation attacks</li>
<li><strong class="bold">Monitor sessions</strong>: Implement mechanisms to monitor active sessions and detect anomalies</li>
</ul>
<p>By integrating session management and logout functionality into your FastAPI application, you ensure that user state is managed securely and efficiently across requests. This enhances both the security and user experience of your application. Remember to <a id="_idIndexMarker283"/>follow<a id="_idIndexMarker284"/> best practices for session security to protect your users and their data effectively.</p>
<p>In the next chapter, we will see how to efficiently debug your FastAPI application.</p>
<h2 id="_idParaDest-153"><a id="_idTextAnchor156"/>See also</h2>
<p>You can see more on managing cookies in Fast on the documentation page:</p>
<ul>
<li><em class="italic">Response </em><em class="italic">cookies</em>: <a href="https://fastapi.tiangolo.com/advanced/response-cookies/">https://fastapi.tiangolo.com/advanced/response-cookies/</a></li>
</ul>
</div>
</div></body></html>