["```py\n[2019/11/12:08:09:10,123] INFO #PJQXB^{}eRwnEGG?2%32U path=\"/openapi.yaml\" method=GET \n\n[2019/11/12:08:09:10,234] INFO 9DiC!B^{}nXxnEGG?2%32U path=\"/items?limit=x\" method=GET \n\n[2019/11/12:08:09:10,235] INFO 9DiC!B^{}nXxnEGG?2%32U error=\"invalid query\" \n\n[2019/11/12:08:09:10,345] INFO #PJQXB^{}eRwnEGG?2%32U status=\"200\" bytes=\"11234\" \n\n[2019/11/12:08:09:10,456] INFO 9DiC!B^{}nXxnEGG?2%32U status=\"404\" bytes=\"987\" \n\n[2019/11/12:08:09:10,567] INFO >~UL>~PB_R>&nEGG?2%32U path=\"/category/42\" method=GET\n```", "```py\nimport re \n\nlog_parser = re.compile(r\"\\[(.*?)\\] (\\w+) (\\S+) (.*)\")\n```", "```py\n[(’2019/11/12:08:09:10,123’, \n\n  ’INFO’, \n\n  ’#PJQXB^{}eRwnEGG?2%32U’, \n\n  ’path=\"/openapi.yaml\" method=GET’), \n\n (’2019/11/12:08:09:10,234’, \n\n  ’INFO’, \n\n  ’9DiC!B^{}nXxnEGG?2%32U’, \n\n  ’path=\"/items?limit=x\" method=GET’),\n```", "```py\n... details omitted ...\n```", "```py\n (’2019/11/12:08:09:10,567’, \n\n  ’INFO’, \n\n  ’>~UL>~PB_R>&nEGG?2%32U’, \n\n  ’path=\"/category/42\" method=GET’)]\n```", "```py\n    >>> histogram = {}\n    ```", "```py\n    >>> for line in log_lines: \n\n    ...     path_method = line[3]  # group(4) of the original match \n\n    ...     if path_method.startswith(\"path\"):\n    ```", "```py\n     ...         if path_method not in histogram: \n\n    ...             histogram[path_method] = 0 \n\n    ...         histogram[path_method] += 1\n    ```", "```py\nparam_parser = re.compile( \n\n    r’(\\w+)=(\".*?\"|\\w+)’ \n\n)\n```", "```py\n    >>> for line in log_lines: \n\n    ...     name_value_pairs = param_parser.findall(line[3])\n    ```", "```py\n     ...     params = {match[0]: match[1] for match in name_value_pairs} \n    ```", "```py\n{’path’: ’\"/openapi.yaml\"’, ’method’: ’GET’} \n\n{’path’: ’\"/items?limit=x\"’, ’method’: ’GET’} \n\n{’error’: ’\"invalid query\"’}\n```", "```py\nhistogram[customer] = histogram[customer] + 1\n```", "```py\n>>> from collections import defaultdict\n\n>>> histogram = defaultdict(int) \n\n>>> for line in log_lines: \n\n...     path_method = line[3]  # group(4) of the match \n\n...     if path_method.startswith(\"path\"): \n\n...         histogram[path_method] += 1\n```", "```py\n>>> from collections import Counter \n\n>>> filtered_paths = ( \n\n...     line[3] \n\n...     for line in log_lines \n\n...     if line[3].startswith(\"path\") \n\n... ) \n\n>>> histogram = Counter(filtered_paths) \n\n>>> histogram \n\nCounter({’path=\"/openapi.yaml\" method=GET’: 1, ’path=\"/items?limit=x\" method=GET’: 1, ’path=\"/category/42\" method=GET’: 1})\n```", "```py\n    from collections import defaultdict \n\n    from collections.abc import Iterable, Iterator\n    ```", "```py\n    LogRec = tuple[str, ...] \n\n    def request_iter_t(source: Iterable[str]) -> Iterator[list[LogRec]]: \n\n        requests: defaultdict[str, list[LogRec]] = defaultdict(list)\n    ```", "```py\n     for line in source: \n\n            if match := log_parser.match(line): \n\n                id = match.group(3)\n    ```", "```py\n     requests[id].append(tuple(match.groups()))\n    ```", "```py\n     if match.group(4).startswith(’status’): \n\n                    yield requests[id] \n\n                    del requests[id]\n    ```", "```py\n        requests.pop(id)\n```", "```py\ndate,engine on,fuel height on,engine off,fuel height off \n\n10/25/13,08:24:00,29,13:15:00,27 \n\n10/26/13,09:12:00,27,18:25:00,22 \n\n10/28/13,13:21:00,22,06:25:00,14\n```", "```py\nimport csv \n\nfrom pathlib import Path \n\ndef get_fuel_use(source_path: Path) -> list[dict[str, str]]: \n\n    with source_path.open() as source_file: \n\n        rdr = csv.DictReader(source_file) \n\n        data: list[dict[str, str]] = list(rdr) \n\n    return data\n```", "```py\n    import datetime \n\n    from typing import TypedDict \n\n    class History(TypedDict): \n\n        date: datetime.date \n\n        start_time: datetime.time \n\n        start_fuel: float \n\n        end_time: datetime.time \n\n        end_fuel: float\n    ```", "```py\nfrom collections.abc import Iterable, Iterator \n\ndef make_history(source: Iterable[dict[str, str]]) -> Iterator[History]: \n\n    for row in source: \n\n        yield dict( \n\n            date=datetime.datetime.strptime( \n\n                row[’date’], \"%m/%d/%y\").date(), \n\n            start_time=datetime.datetime.strptime( \n\n                row[’engine on’], ’%H:%M:%S’).time(), \n\n            start_fuel=float(row[’fuel height on’]), \n\n            end_time=datetime.datetime.strptime( \n\n                row[’engine off’], ’%H:%M:%S’).time(), \n\n            end_fuel=float(row[’fuel height off’]), \n\n        )\n```", "```py\n>>> from pprint import pprint \n\n>>> source_path = Path(\"data/fuel2.csv\") \n\n>>> fuel_use = make_history(get_fuel_use(source_path)) \n\n>>> for row in fuel_use: \n\n...     pprint(row) \n\n{’date’: datetime.date(2013, 10, 25), \n\n ’end_fuel’: 27.0, \n\n ’end_time’: datetime.time(13, 15), \n\n ’start_fuel’: 29.0, \n\n ’start_time’: datetime.time(8, 24)} \n\n{’date’: datetime.date(2013, 10, 26), \n\n ’end_fuel’: 22.0, \n\n ’end_time’: datetime.time(18, 25), \n\n ’start_fuel’: 27.0, \n\n ’start_time’: datetime.time(9, 12)} \n\n{’date’: datetime.date(2013, 10, 28), \n\n ’end_fuel’: 14.0, \n\n ’end_time’: datetime.time(6, 25), \n\n ’start_fuel’: 22.0, \n\n ’start_time’: datetime.time(13, 21)}\n```", "```py\nresult: History = {’date’: 42}\n```", "```py\n(cookbook3) % python -m mypy src/ch05/recipe_04_bad.py \n\nsrc/ch05/recipe_04_bad.py:18: error: Missing keys (\"start_time\", \"start_fuel\", \"end_time\", \"end_fuel\") for TypedDict \"History\"  [typeddict-item] \n\nFound 1 error in 1 file (checked 1 source file)\n```", "```py\nfrom typing import TypedDict, NotRequired \n\nclass History2(TypedDict): \n\n   date: datetime.date \n\n   start_time: NotRequired[datetime.time] \n\n   start_fuel: NotRequired[float] \n\n   end_time: NotRequired[datetime.time] \n\n   end_fuel: NotRequired[float] \n```", "```py\n>>> mutable = [1, 1, 2, 3, 5, 8] \n\n>>> immutable = (5, 8, 13, 21)\n```", "```py\n    >>> mutable_b = mutable \n\n    >>> immutable_b = immutable \n    ```", "```py\n    >>> mutable_b is mutable \n\n    True \n\n    >>> immutable_b is immutable \n\n    True\n    ```", "```py\n    >>> mutable += [mutable[-2] + mutable[-1]]\n    ```", "```py\n    >>> immutable += (immutable[-2] + immutable[-1],)\n    ```", "```py\n    >>> mutable_b \n\n    [1, 1, 2, 3, 5, 8, 13] \n\n    >>> mutable is mutable_b \n\n    True\n    ```", "```py\n     >>> immutable_b \n\n    (5, 8, 13, 21) \n\n    >>> immutable \n\n    (5, 8, 13, 21, 34)\n    ```", "```py\nimmutable += (immutable[-2] + immutable[-1],)\n```", "```py\nimmutable = immutable + (immutable[-2] + immutable[-1],)\n```", "```py\na = 355 \n\na += 113\n```", "```py\na = b\n```", "```py\n>>> some_dict = {’a’: [1, 1, 2, 3]} \n\n>>> another_dict = some_dict.copy()\n```", "```py\n>>> another_dict \n\n{’a’: [1, 1, 2, 3]}\n```", "```py\n>>> some_dict[’a’].append(5) \n\n>>> another_dict \n\n{’a’: [1, 1, 2, 3, 5]}\n```", "```py\n>>> id(some_dict[’a’]) == id(another_dict[’a’]) \n\nTrue\n```", "```py\n    >>> import copy\n    ```", "```py\n    >>> some_dict = {’a’: [1, 1, 2, 3]} \n\n    >>> another_dict = copy.deepcopy(some_dict)\n    ```", "```py\n>>> some_dict[’a’].append(5) \n\n>>> some_dict \n\n{’a’: [1, 1, 2, 3, 5]} \n\n>>> another_dict \n\n{’a’: [1, 1, 2, 3]}\n```", "```py\n>>> id(some_dict[’a’]) == id(another_dict[’a’]) \n\nFalse\n```", "```py\n>>> copy_of_list = [item for item in some_list] \n\n>>> copy_of_dict = {key:value for key, value in some_dict.items()}\n```", "```py\nfrom typing import Any \n\ndef deepcopy_json(some_obj: Any) -> Any: \n\n    match some_obj: \n\n        case int() | float() | tuple() | str() | bytes() | None: \n\n            return some_obj \n\n        case list() as some_list: \n\n            list_copy: list[Any] = [] \n\n            for item in some_list: \n\n                list_copy.append(deepcopy_json(item)) \n\n            return list_copy \n\n        case dict() as some_dict: \n\n            dict_copy: dict[Any, Any] = {} \n\n            for key in some_dict: \n\n                dict_copy[key] = deepcopy_json(some_dict[key]) \n\n            return dict_copy \n\n        case _: \n\n            raise ValueError(f\"can’t copy {type(some_obj)}\") \n```", "```py\nfrom collections import Counter \n\nfrom random import randint, seed \n\ndef gather_stats_bad( \n\n    n: int, \n\n    samples: int = 1000, \n\n    summary: Counter[int] = Counter() \n\n) -> Counter[int]: \n\n    summary.update( \n\n      sum(randint(1, 6) \n\n      for d in range(n)) for _ in range(samples) \n\n    ) \n\n    return summary\n```", "```py\n    >>> seed(1) \n\n    >>> s1 = gather_stats_bad(2) \n\n    >>> s1 \n\n    Counter({7: 168, 6: 147, 8: 136, 9: 114, 5: 110, 10: 77, 11: 71, 4: 70, 3: 52, 12: 29, 2: 26})\n    ```", "```py\n    >>> seed(1) \n\n    >>> mc = Counter() \n\n    >>> gather_stats_bad(2, summary=mc) \n\n    Counter... \n\n    >>> mc \n\n    Counter({7: 168, 6: 147, 8: 136, 9: 114, 5: 110, 10: 77, 11: 71, 4: 70, 3: 52, 12: 29, 2: 26})\n    ```", "```py\n>>> seed(1) \n\n>>> s3b = gather_stats_bad(2) \n\n>>> s3b \n\nCounter({7: 336, 6: 294, 8: 272, 9: 228, 5: 220, 10: 154, 11: 142, 4: 140, 3: 104, 12: 58, 2: 52})\n```", "```py\n>>> s1 is s3b \n\nTrue\n```", "```py\n    def gather_stats_good( \n\n        n: int, \n\n        samples: int = 1000, \n\n        summary: Counter[int] | None = None \n\n    ) -> Counter[int]:\n    ```", "```py\n     def gather_stats_good( \n\n        n: int, \n\n        summary: Counter[int] | None = None, \n\n        samples: int = 1000, \n\n    ) -> Counter[int]:\n    ```", "```py\n     if summary is None: \n\n            summary = Counter()\n    ```", "```py\ndef update_stats( \n\n    n: int, \n\n    summary: Counter[int], \n\n    samples: int = 1000, \n\n) -> Counter[int]: \n\n    summary.update( \n\n        sum(randint(1, 6) \n\n        for d in range(n)) for _ in range(samples)) \n\n    return summary \n\ndef create_stats(n: int, samples: int = 1000) -> Counter[int]: \n\n    return update_stats(n, Counter(), samples)\n```", "```py\nfrom collections import Counter \n\nfrom collections.abc import Callable, Iterable, Hashable \n\nfrom typing import TypeVar, TypeAlias \n\nT = TypeVar(’T’, bound=Hashable) \n\nSummarizer: TypeAlias = Callable[[Iterable[T]], Counter[T]] \n\ndef gather_stats_flex( \n\n    n: int, \n\n    samples: int = 1000, \n\n    summary_func: Summarizer[int] = Counter \n\n) -> Counter[int]: \n\n    summary = summary_func( \n\n        sum(randint(1, 6) \n\n        for d in range(n)) for _ in range(samples)) \n\n    return summary\n```", "```py\n>>> seed(1) \n\n>>> gather_stats_flex(2, 12, summary_func=list) \n\n[7, 4, 5, 8, 10, 3, 5, 8, 6, 10, 9, 7]\n```", "```py\n>>> seed(1) \n\n>>> gather_stats_flex(2, 12) \n\nCounter({7: 2, 5: 2, 8: 2, 10: 2, 4: 1, 3: 1, 6: 1, 9: 1})\n```"]