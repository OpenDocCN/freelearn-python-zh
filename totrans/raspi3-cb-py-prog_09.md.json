["```py\n#!/usr/bin/python3 \n#ledtest.py \nimport time \nimport RPi.GPIO as GPIO \n# RGB LED module \n#HARDWARE SETUP \n# GPIO \n# 2[======XRG=B==]26[=======]40 \n# 1[=============]25[=======]39 \n# X=GND R=Red G=Green B=Blue  \n#Setup Active States \n#Common Cathode RGB-LED (Cathode=Active Low) \nRGB_ENABLE = 1; RGB_DISABLE = 0 \n\n#LED CONFIG - Set GPIO Ports \nRGB_RED = 16; RGB_GREEN = 18; RGB_BLUE = 22 \nRGB = [RGB_RED,RGB_GREEN,RGB_BLUE] \n\ndef led_setup(): \n  #Setup the wiring \n  GPIO.setmode(GPIO.BOARD) \n  #Setup Ports \n  for val in RGB: \n    GPIO.setup(val,GPIO.OUT) \n\ndef main(): \n  led_setup() \n  for val in RGB: \n    GPIO.output(val,RGB_ENABLE) \n    print(\"LED ON\") \n    time.sleep(5) \n    GPIO.output(val,RGB_DISABLE) \n    print(\"LED OFF\") \n\ntry: \n  main() \nfinally: \n  GPIO.cleanup() \n  print(\"Closed Everything. END\") \n#End\n```", "```py\nsudo python3 ledtest.py  \n```", "```py\nsudo apt-get install flite  \n```", "```py\nsudo flite -t \"hello I can talk\"  \n```", "```py\namixer set PCM 100%  \n```", "```py\n#!/usr/bin/python3 \n#btntest.py \nimport time \nimport os \nimport RPi.GPIO as GPIO \n#HARDWARE SETUP \n# GPIO \n# 2[==X==1=======]26[=======]40 \n# 1[=============]25[=======]39 \n#Button Config \nBTN = 12 \n\ndef gpio_setup(): \n  #Setup the wiring \n  GPIO.setmode(GPIO.BOARD) \n  #Setup Ports \n  GPIO.setup(BTN,GPIO.IN,pull_up_down=GPIO.PUD_UP) \n\ndef main(): \n  gpio_setup() \n  count=0 \n  btn_closed = True \n  while True: \n    btn_val = GPIO.input(BTN) \n    if btn_val and btn_closed: \n       print(\"OPEN\") \n       btn_closed=False \n    elif btn_val==False and btn_closed==False: \n       count+=1 \n       print(\"CLOSE %s\" % count) \n       os.system(\"flite -t '%s'\" % count) \n       btn_closed=True \n    time.sleep(0.1) \n\ntry: \n  main() \nfinally: \n  GPIO.cleanup() \n  print(\"Closed Everything. END\") \n#End \n```", "```py\nGPIO.setup(BTN,GPIO.IN,pull_up_down=GPIO.PUD_UP) \n```", "```py\n#!/usr/bin/python3 \n#shtdwn.py \nimport time \nimport RPi.GPIO as GPIO \nimport os \n\n# Shutdown Script \nDEBUG=True #Simulate Only \nSNDON=True \n#HARDWARE SETUP \n# GPIO \n# 2[==X==L=======]26[=======]40 \n# 1[===1=========]25[=======]39 \n\n#BTN CONFIG - Set GPIO Ports \nGPIO_MODE=GPIO.BOARD \nSHTDWN_BTN = 7 #1 \nLED = 12       #L \n\ndef gpio_setup(): \n  #Setup the wiring \n  GPIO.setmode(GPIO_MODE) \n  #Setup Ports \n  GPIO.setup(SHTDWN_BTN,GPIO.IN,pull_up_down=GPIO.PUD_UP) \n  GPIO.setup(LED,GPIO.OUT) \n\ndef doShutdown(): \n  if(DEBUG):print(\"Press detected\") \n  time.sleep(3) \n  if GPIO.input(SHTDWN_BTN): \n    if(DEBUG):print(\"Ignore the shutdown (<3sec)\") \n  else: \n    if(DEBUG):print (\"Would shutdown the RPi Now\") \n    GPIO.output(LED,0) \n    time.sleep(0.5) \n    GPIO.output(LED,1) \n    if(SNDON):os.system(\"flite -t 'Warning commencing power down 3 2 1'\") \n    if(DEBUG==False):os.system(\"sudo shutdown -h now\") \n    if(DEBUG):GPIO.cleanup() \n    if(DEBUG):exit() \n\ndef main(): \n  gpio_setup() \n  GPIO.output(LED,1) \n  while True: \n    if(DEBUG):print(\"Waiting for >3sec button press\") \n    if GPIO.input(SHTDWN_BTN)==False: \n       doShutdown() \n    time.sleep(1) \n\ntry: \n  main() \nfinally: \n  GPIO.cleanup() \n  print(\"Closed Everything. END\") \n#End\n```", "```py\nmkdir ~/bin \nmv shtdwn.py ~/bin/shtdwn.py  \ncrontab -e \n```", "```py\n@reboot sudo python3 ~/bin/shtdwn.py \n```", "```py\nLAN_SWA = 11    #2 \n```", "```py\nGPIO.setup(LAN_SWA,GPIO.IN,pull_up_down=GPIO.PUD_UP) \n```", "```py\ndef doChangeLAN(direct): \n  if(DEBUG):print(\"Direct LAN: %s\" % direct) \n  if GPIO.input(LAN_SWA) and direct==True: \n    if(DEBUG):print(\"LAN Switch OFF\") \n    cmd=\"sudo dhclient eth0\" \n    direct=False \n    GPIO.output(LED,1) \n  elif GPIO.input(LAN_SWA)==False and direct==False: \n    if(DEBUG):print(\"LAN Switch ON\") \n    cmd=\"sudo ifconfig eth0 169.254.69.69\" \n    direct=True \n  else: \n    return direct \n  if(DEBUG==False):os.system(cmd) \n  if(SNDON):os.system(\"hostname -I | flite\") \n  return direct \n```", "```py\ndef flashled(ledon): \n  if ledon: \n    ledon=False \n  else: \n    ledon=True \n  GPIO.output(LED,ledon) \n  return ledon\n```", "```py\ndef main(): \n  gpio_setup() \n  GPIO.output(LED,1) \n  directlan=False \n  ledon=True \n  while True: \n    if(DEBUG):print(\"Waiting for >3sec button press\") \n    if GPIO.input(SHTDWN_BTN)==False: \n       doShutdown() \n    directlan= doChangeLAN(directlan) \n    if directlan: \n      flashled(ledon) \n    time.sleep(1) \n```", "```py\nwget https://github.com/tuomasjjrasanen/python-uinput/archive/master.zip\nunzip master.zip\n\n```", "```py\nrm master.zip  \n```", "```py\nsudo apt-get install python3-setuptools python3-dev\nsudo apt-get install libudev-dev  \n```", "```py\ncd python-uinput-master\nsudo python3 setup.py install  \n```", "```py\nsudo modprobe uinput  \n```", "```py\nsudo nano /etc/modules  \n```", "```py\n#!/usr/bin/python3 \n#gpiokeys.py \nimport time \nimport RPi.GPIO as GPIO \nimport uinput \n\n#HARDWARE SETUP \n# GPIO \n# 2[==G=====<=V==]26[=======]40 \n# 1[===2=1>^=====]25[=======]39 \nB_DOWN  = 22    #V \nB_LEFT  = 18   #< \nB_UP    = 15   #^ \nB_RIGHT = 13   #> \nB_1  = 11   #1 \nB_2  = 7   #2 \n\nDEBUG=True \nBTN = [B_UP,B_DOWN,B_LEFT,B_RIGHT,B_1,B_2] \nMSG = [\"UP\",\"DOWN\",\"LEFT\",\"RIGHT\",\"1\",\"2\"] \n\n#Setup the DPad module pins and pull-ups \ndef dpad_setup(): \n  #Set up the wiring \n  GPIO.setmode(GPIO.BOARD) \n  # Setup BTN Ports as INPUTS \n  for val in BTN: \n    # set up GPIO input with pull-up control \n    #(pull_up_down can be: \n    #    PUD_OFF, PUD_UP or PUD_DOWN, default PUD_OFF) \n    GPIO.setup(val, GPIO.IN, pull_up_down=GPIO.PUD_UP) \n\ndef main(): \n  #Setup uinput \n  events = (uinput.KEY_UP,uinput.KEY_DOWN,uinput.KEY_LEFT, \n           uinput.KEY_RIGHT,uinput.KEY_ENTER,uinput.KEY_ENTER) \n  device = uinput.Device(events) \n  time.sleep(2) # seconds \n  dpad_setup() \n  print(\"DPad Ready!\") \n\n  btn_state=[False,False,False,False,False,False] \n  key_state=[False,False,False,False,False,False] \n  while True: \n    #Catch all the buttons pressed before pressing the related keys \n    for idx, val in enumerate(BTN): \n      if GPIO.input(val) == False: \n        btn_state[idx]=True \n      else: \n        btn_state[idx]=False \n\n    #Perform the button presses/releases (but only change state once) \n    for idx, val in enumerate(btn_state): \n      if val == True and key_state[idx] == False: \n        if DEBUG:print (str(val) + \":\" + MSG[idx]) \n        device.emit(events[idx], 1) # Press. \n        key_state[idx]=True \n      elif val == False and key_state[idx] == True: \n        if DEBUG:print (str(val) + \":!\" + MSG[idx]) \n        device.emit(events[idx], 0) # Release. \n        key_state[idx]=False \n\n    time.sleep(.1) \n\ntry: \n  main() \nfinally: \n  GPIO.cleanup() \n#End \n```", "```py\nsudo python3 gpiokeys.py &  \n```", "```py\nomxplayer filename.mp4  \n```", "```py\nevents_dpad = (uinput.KEY_UP,uinput.KEY_DOWN,uinput.KEY_LEFT, \n              uinput.KEY_RIGHT,uinput.KEY_ENTER,uinput.KEY_ENTER) \nevents_z80 = (uinput.KEY_Q,uinput.KEY_A,uinput.KEY_O, \n             uinput.KEY_P,uinput.KEY_M,uinput.KEY_ENTER) \nevents_omx = (uinput.KEY_EQUAL,uinput.KEY_MINUS,uinput.KEY_LEFT, \n             uinput.KEY_RIGHT,uinput.KEY_P,uinput.KEY_Q) \n```", "```py\nless /usr/include/linux/input.h  \n```", "```py\nMSG = [\"M_UP\",\"M_DOWN\",\"M_LEFT\",\"M_RIGHT\",\"1\",\"Enter\"] \nevents_mouse=(uinput.REL_Y,uinput.REL_Y, uinput.REL_X, \n             uinput.REL_X,uinput.BTN_LEFT,uinput.BTN_RIGHT) \nmousemove=1 \n```", "```py\n#Perform the button presses/releases \n#(but only change state once) \nfor idx, val in enumerate(btn_state): \n  if MSG[idx] == \"M_UP\" or MSG[idx] == \"M_LEFT\": \n    state = -mousemove \n  else: \n    state = mousemove \n  if val == True: \n    device.emit(events[idx], state) # Press. \n  elif val == False: \n    device.emit(events[idx], 0) # Release. \ntime.sleep(0.01) \n```", "```py\n#!/usr/bin/python3 \n#rgbled.py \nimport time \nimport RPi.GPIO as GPIO \n\n#Setup Active states \n#Common Cathode RGB-LEDs (Cathode=Active Low) \nLED_ENABLE = 0; LED_DISABLE = 1 \nRGB_ENABLE = 1; RGB_DISABLE = 0 \n#HARDWARE SETUP \n# GPIO \n# 2[=====1=23=4==]26[=======]40 \n# 1[===5=RGB=====]25[=======]39 \n#LED CONFIG - Set GPIO Ports \nLED1 = 12; LED2 = 16; LED3 = 18; LED4 = 22; LED5 = 7 \nLED = [LED1,LED2,LED3,LED4,LED5] \nRGB_RED = 11; RGB_GREEN = 13; RGB_BLUE = 15 \nRGB = [RGB_RED,RGB_GREEN,RGB_BLUE] \n#Mixed Colors \nRGB_CYAN = [RGB_GREEN,RGB_BLUE] \nRGB_MAGENTA = [RGB_RED,RGB_BLUE] \nRGB_YELLOW = [RGB_RED,RGB_GREEN] \nRGB_WHITE = [RGB_RED,RGB_GREEN,RGB_BLUE] \nRGB_LIST = [RGB_RED,RGB_GREEN,RGB_BLUE,RGB_CYAN, \n            RGB_MAGENTA,RGB_YELLOW,RGB_WHITE] \n```", "```py\ndef led_setup(): \n  '''Setup the RGB-LED module pins and state.''' \n  #Set up the wiring \n  GPIO.setmode(GPIO.BOARD) \n  # Setup Ports \n  for val in LED: \n    GPIO.setup(val, GPIO.OUT) \n  for val in RGB: \n    GPIO.setup(val, GPIO.OUT) \n  led_clear()\n```", "```py\ndef led_gpiocontrol(pins,state): \n  '''This function will control the state of \n  a single or multiple pins in a list.''' \n  #determine if \"pins\" is a single integer or not \n  if isinstance(pins,int): \n    #Single integer - reference directly \n    GPIO.output(pins,state) \n  else: \n    #if not, then cycle through the \"pins\" list \n    for i in pins: \n      GPIO.output(i,state) \n\ndef led_activate(led,color): \n  '''Enable the selected led(s) and set the required color(s) \n  Will accept single or multiple values''' \n  #Enable led \n  led_gpiocontrol(led,LED_ENABLE) \n  #Enable color \n  led_gpiocontrol(color,RGB_ENABLE) \n\ndef led_deactivate(led,color): \n  '''Deactivate the selected led(s) and set the required \n  color(s) will accept single or multiple values''' \n  #Disable led \n  led_gpiocontrol(led,LED_DISABLE) \n  #Disable color \n  led_gpiocontrol(color,RGB_DISABLE) \n\ndef led_time(led, color, timeon): \n  '''Switch on the led and color for the timeon period''' \n  led_activate(led,color) \n  time.sleep(timeon) \n  led_deactivate(led,color) \n\ndef led_clear(): \n  '''Set the pins to default state.''' \n  for val in LED: \n    GPIO.output(val, LED_DISABLE) \n  for val in RGB: \n    GPIO.output(val, RGB_DISABLE) \n\ndef led_cleanup(): \n  '''Reset pins to default state and release GPIO''' \n  led_clear() \n  GPIO.cleanup()\n```", "```py\ndef main(): \n  '''Directly run test function. \n  This function will run if the file is executed directly''' \n  led_setup() \n  led_time(LED1,RGB_RED,5) \n  led_time(LED2,RGB_GREEN,5) \n  led_time(LED3,RGB_BLUE,5) \n  led_time(LED,RGB_MAGENTA,2) \n  led_time(LED,RGB_YELLOW,2) \n  led_time(LED,RGB_CYAN,2)  \n\nif __name__=='__main__': \n  try: \n    main() \n  finally: \n    led_cleanup() \n#End \n```", "```py\nfrom random import randint\n```", "```py\ndef led_rgbrandom(led,period,colors): \n   ''' Light up the selected led, for period in seconds, \n   in one of the possible colors. The colors can be \n   1 to 3 for RGB, or 1-6 for RGB plus combinations, \n   1-7 includes white. Anything over 7 will be set as \n   OFF (larger the number more chance of OFF).'''  \n  value = randint(1,colors) \n  if value < len(RGB_LIST): \n    led_time(led,RGB_LIST[value-1],period) \n```", "```py\nfor i in range(20): \n  for j in LED: \n    #Select from all, plus OFF \n    led_rgbrandom(j,0.1,20) \n```", "```py\n#Combo Colors \nRGB_AQUA = [RGB_CYAN,RGB_GREEN] \nRGB_LBLUE = [RGB_CYAN,RGB_BLUE] \nRGB_PINK = [RGB_MAGENTA,RGB_RED] \nRGB_PURPLE = [RGB_MAGENTA,RGB_BLUE] \nRGB_ORANGE = [RGB_YELLOW,RGB_RED] \nRGB_LIME = [RGB_YELLOW,RGB_GREEN] \nRGB_COLORS = [RGB_LIME,RGB_YELLOW,RGB_ORANGE,RGB_RED, \n              RGB_PINK,RGB_MAGENTA,RGB_PURPLE,RGB_BLUE, \n              RGB_LBLUE,RGB_CYAN,RGB_AQUA,RGB_GREEN] \n```", "```py\ndef led_combo(pins,colors,period): \n  #determine if \"colors\" is a single integer or not \n  if isinstance(colors,int): \n    #Single integer - reference directly \n    led_time(pins,colors,period) \n  else: \n    #if not, then cycle through the \"colors\" list \n    for i in colors: \n      led_time(pins,i,period) \n```", "```py\n#!/usr/bin/python3 \n#rgbledrainbow.py \nimport time \nimport rgbled as RGBLED \n\ndef next_value(number,max): \n  number = number % max \n  return number \n\ndef main(): \n  print (\"Setup the RGB module\") \n  RGBLED.led_setup() \n\n  # Multiple LEDs with different Colors \n  print (\"Switch on Rainbow\") \n  led_num = 0 \n  col_num = 0 \n  for l in range(5): \n    print (\"Cycle LEDs\") \n    for k in range(100): \n      #Set the starting point for the next set of colors \n      col_num = next_value(col_num+1,len(RGBLED.RGB_COLORS)) \n      for i in range(20):  #cycle time \n        for j in range(5): #led cycle \n          led_num = next_value(j,len(RGBLED.LED)) \n          led_color = next_value(col_num+led_num, \n                                 len(RGBLED.RGB_COLORS)) \n          RGBLED.led_combo(RGBLED.LED[led_num], \n                           RGBLED.RGB_COLORS[led_color],0.001) \n\n    print (\"Cycle COLORs\")         \n    for k in range(100): \n      #Set the next color \n      col_num = next_value(col_num+1,len(RGBLED.RGB_COLORS)) \n      for i in range(20): #cycle time \n        for j in range(5): #led cycle \n          led_num = next_value(j,len(RGBLED.LED)) \n          RGBLED.led_combo(RGBLED.LED[led_num], \n                           RGBLED.RGB_COLORS[col_num],0.001) \n  print (\"Finished\") \n\nif __name__=='__main__': \n  try: \n    main() \n  finally: \n    RGBLED.led_cleanup() \n#End \n```", "```py\n#!/usr/bin/python3 \n#tilt.py \nimport RPi.GPIO as GPIO \n#HARDWARE SETUP \n# GPIO \n# 2[===========T=]26[=======]40 \n# 1[=============]25[=======]39 \n#Tilt Config \nTILT_SW = 24 \n\ndef tilt_setup(): \n  #Setup the wiring \n  GPIO.setmode(GPIO.BOARD) \n  #Setup Ports \n  GPIO.setup(TILT_SW,GPIO.IN,pull_up_down=GPIO.PUD_UP) \n\ndef tilt_moving(): \n  #Report the state of the Tilt Switch \n  return GPIO.input(TILT_SW) \n\ndef main(): \n  import time \n  tilt_setup() \n  while True: \n    print(\"TILT %s\"% (GPIO.input(TILT_SW))) \n    time.sleep(0.1) \n\nif __name__=='__main__': \n  try: \n    main() \n  finally: \n    GPIO.cleanup() \n    print(\"Closed Everything. END\") \n#End \n```", "```py\nsudo python3 tilt.py\n```", "```py\ndef rgbled_pov(led_pattern,color,ontime): \n  '''Disable all the LEDs and re-enable the LED pattern in the required color''' \n  led_deactivate(LED,RGB) \n  for led_num,col_num in enumerate(led_pattern): \n    if col_num >= 1: \n      led_activate(LED[led_num],color) \n  time.sleep(ontime) \n```", "```py\n#!/usr/bin/python3 \n# rgbledmessage.py \nimport rgbled as RGBLED \nimport tilt as TILT \nimport os \n\nDEBUG = True \n```", "```py\ndef readMessageFile(filename): \n  assert os.path.exists(filename), 'Cannot find the message file: %s' % (filename) \n  try: \n    with open(filename, 'r') as theFile: \n    fileContent = theFile.readlines() \n  except IOError: \n    print(\"Unable to open %s\" % (filename)) \n  if DEBUG:print (\"File Content START:\") \n  if DEBUG:print (fileContent) \n  if DEBUG:print (\"File Content END\") \n  dictionary = processFileContent(fileContent) \n  return dictionary  \n\ndef processFileContent(content): \n  letterIndex = [] #Will contain a list of letters stored in the file \n  letterList = []  #Will contain a list of letter formats \n  letterFormat = [] #Will contain the format of each letter \n  firstLetter = True \n  nextLetter = False \n  LETTERDIC={} \n  #Process each line that was in the file \n  for line in content: \n    # Ignore the # as comments \n    if '#' in line: \n      if DEBUG:print (\"Comment: %s\"%line) \n    #Check for \" in the line = index name   \n    elif '\"' in line: \n      nextLetter = True \n      line = line.replace('\"','') #Remove \" characters \n      LETTER=line.rstrip() \n      if DEBUG:print (\"Index: %s\"%line) \n    #Remaining lines are formatting codes \n    else: \n      #Skip firstLetter until complete \n      if firstLetter: \n        firstLetter = False \n        nextLetter = False \n        lastLetter = LETTER \n      #Move to next letter if needed \n      if nextLetter: \n        nextLetter = False \n        LETTERDIC[lastLetter]=letterFormat[:] \n        letterFormat[:] = [] \n        lastLetter = LETTER \n      #Save the format data \n      values = line.rstrip().split(' ') \n      row = [] \n      for val in values: \n        row.append(int(val)) \n      letterFormat.append(row) \n  LETTERDIC[lastLetter]=letterFormat[:] \n  #Show letter patterns for debugging \n  if DEBUG:print (\"LETTERDIC: %s\" %LETTERDIC) \n  if DEBUG:print (\"C: %s\"%LETTERDIC['C']) \n  if DEBUG:print (\"O: %s\"%LETTERDIC['O']) \n  return LETTERDIC\n```", "```py\ndef createBuffer(message,dictionary): \n  buffer=[] \n  for letter in message: \n    try: \n      letterPattern=dictionary[letter] \n    except KeyError: \n      if DEBUG:print(\"Unknown letter %s: use _\"%letter) \n      letterPattern=dictionary['_'] \n    buffer=addLetter(letterPattern,buffer) \n  if DEBUG:print(\"Buffer: %s\"%buffer) \n  return buffer \n\ndef addLetter(letter,buffer): \n  for row in letter: \n    buffer.append(row) \n  buffer.append([0,0,0,0,0]) \n  buffer.append([0,0,0,0,0]) \n  return buffer \n```", "```py\ndef displayBuffer(buffer): \n  position=0 \n  while(1): \n    if(TILT.tilt_moving()==False): \n      position=0 \n    elif (position+1)<len(buffer): \n      position+=1 \n      if DEBUG:print(\"Pos:%s ROW:%s\"%(position,buffer[position])) \n    RGBLED.rgbled_pov(buffer[position],RGBLED.RGB_GREEN,0.001) \n    RGBLED.rgbled_pov(buffer[position],RGBLED.RGB_BLUE,0.001) \n```", "```py\ndef main(): \n  RGBLED.led_setup() \n  TILT.tilt_setup() \n  dict=readMessageFile('letters.txt') \n  buffer=createBuffer('_COOKBOOK_',dict) \n  displayBuffer(buffer) \n\nif __name__=='__main__': \n  try: \n    main() \n  finally: \n    RGBLED.led_cleanup() \n    print(\"Closed Everything. END\") \n#End \n```", "```py\n#COOKBOOK \n\"C\" \n0 1 1 1 0 \n1 0 0 0 1 \n1 0 0 0 1 \n\"O\" \n0 1 1 1 0 \n1 0 0 0 1 \n1 0 0 0 1 \n0 1 1 1 0 \n\"K\" \n1 1 1 1 1 \n0 1 0 1 0 \n1 0 0 0 1 \n\"B\" \n1 1 1 1 1 \n1 0 1 0 1 \n0 1 0 1 0 \n\"_\" \n0 0 0 0 0 \n0 0 0 0 0 \n0 0 0 0 0 \n0 0 0 0 0 \n0 0 0 0 0 \n```", "```py\n'_': [[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]] \n'C': [[0, 1, 1, 1, 0], [1, 0, 0, 0, 1], [1, 0, 0, 0, 1]] \n'B': [[1, 1, 1, 1, 1], [1, 0, 1, 0, 1], [0, 1, 0, 1, 0]] \n'K': [[1, 1, 1, 1, 1], [0, 1, 0, 1, 0], [1, 0, 0, 0, 1]] \n'O': [[0, 1, 1, 1, 0], [1, 0, 0, 0, 1], [1, 0, 0, 0, 1], [0, 1, 1, 1, 0]] \n```"]