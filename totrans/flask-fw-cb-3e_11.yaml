- en: '11'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Deployment and Post-Deployment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have learned how to write Flask applications in different ways. Deploying
    an application and managing the application post-deployment is as important as
    developing it. There can be various ways of deploying an application and choosing
    the best way depends on the requirements. Deploying an application correctly is
    very important from a security and performance point of view. There are multiple
    ways of monitoring an application after deployment, of which some are paid and
    others are free to use. Using them depends on the requirements and features that
    are offered by them.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will talk about various application deployment techniques,
    followed by some monitoring tools that are used post-deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Each of the tools and techniques we will cover has a set of features. For example,
    adding too much monitoring to an application can prove to be an extra overhead
    to the application and the developers. Similarly, missing out on monitoring can
    lead to undetected user errors and overall user dissatisfaction.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, I will be focusing on deployment to **Ubuntu 22.04** servers.
    This should cover most cases. I will try to cover any special steps needed for
    macOS and Windows but do not treat those as exhaustive.
  prefs: []
  type: TYPE_NORMAL
- en: Hence, we should choose the tools that we use wisely, which, in turn, will ease
    our lives as much as possible.
  prefs: []
  type: TYPE_NORMAL
- en: In terms of post-deployment monitoring tools, we will discuss New Relic. Sentry
    is another tool that will prove to be the most beneficial of all from a developer’s
    perspective. We covered this in the *Using Sentry to monitor exceptions* recipe
    in [*Chapter 10*](B19111_10.xhtml#_idTextAnchor502), *Debugging, Error Handling,*
    *and Testing*.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Several topics will be covered in this chapter and all of them can be followed/implemented
    independently of each other. You can club some of them together to make use of
    multiple features and I have mentioned this wherever I felt best. As a software
    developer, feel free to use your judgment about which library to use for what
    purpose.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Deploying with Apache
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying with uWSGI and Nginx
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying with Gunicorn and Supervisor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying with Tornado
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using S3 storage for file uploads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing and monitoring application performance with New Relic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Infrastructure and application monitoring with Datadog
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying with Apache
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to deploy a Flask application with `Apache`,
    which is, arguably, the most popular HTTP server. For Python web applications,
    we will use `mod_wsgi`, which implements a simple Apache module that can host
    any Python applications that support the WSGI interface.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Remember that `mod_wsgi` is not the same as Apache and needs to be installed
    separately.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will start with the catalog application from the previous chapter. There
    is no need to make any changes to the existing code.
  prefs: []
  type: TYPE_NORMAL
- en: For deploying with Apache, it is important to make sure that the latest version
    of the Apache `httpd` server is installed on the machine on which you intend to
    deploy. Usually, the versions of Apache shipped with the operating systems (especially
    macOS) might be older and will not be supported by the `mod_wsgi` library.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: '`httpd` stands for `httpd` refers to the web server that implements the daemon
    created by Apache Software Foundation. `apache` and `httpd` are mostly used interchangeably.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For macOS, `httpd` can be installed using Homebrew:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'For Ubuntu, `httpd` is provided by default. Just simply upgrade it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: For Windows operating systems, please follow the official documentation at [https://httpd.apache.org/docs/trunk/platform/](https://httpd.apache.org/docs/trunk/platform/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Once Apache has been successfully installed/updated, the next step is to install
    the `mod_wsgi` library. It can simply be installed inside your virtual environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In stark contrast to the previous editions of this book, `mod_wsgi` now ships
    with a modern `mod_wsgi-express` command, which removes all the complexity of
    writing the Apache `httpd` configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'The only argument to the `mod_wsgi-express` command is a file containing the
    Flask application object. So, create a file called `wsgi.py` with the following
    content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Important
  prefs: []
  type: TYPE_NORMAL
- en: The `app` object needs to be imported as `application` since `mod_wsgi` expects
    the `application` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Run the following command to invoke the web server using `mod_wsgi`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Now, visit `http://localhost:8000/` to see the application in action.
  prefs: []
  type: TYPE_NORMAL
- en: You can also run your application on privileged ports such as `80` or `443`
    by providing the `--port` parameter. Just make sure that the shell user/group
    running the command has permission to access the port(s). If not, you can change
    the user/group to the relevant ones by passing the `--user` and `--``group` parameters.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Refer to [http://httpd.apache.org/](http://httpd.apache.org/) to read more about
    Apache.
  prefs: []
  type: TYPE_NORMAL
- en: The latest documentation on `mod_wgsi` can be found at [https://modwsgi.readthedocs.io/en/develop](https://modwsgi.readthedocs.io/en/develop).
  prefs: []
  type: TYPE_NORMAL
- en: You can read about WSGI in general at [http://wsgi.readthedocs.org/en/latest/](http://wsgi.readthedocs.org/en/latest/).
  prefs: []
  type: TYPE_NORMAL
- en: Deploying with uWSGI and Nginx
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For those who are already aware of the usefulness of uWSGI and Nginx, not much
    needs to be explained. uWSGI is a protocol as well as an application server and
    provides a complete stack so that you can build hosting services. Nginx is a reverse
    proxy and HTTP server that is very lightweight and capable of handling virtually
    unlimited requests. Nginx works seamlessly with uWSGI and provides many under-the-hood
    optimizations for better performance. In this recipe, we will use uWSGI and Nginx
    together to facilitate the deployment of our application.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will use our application from the previous recipe, *Deploying with Apache*,
    and use the same `wsgi.py` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, install Nginx and uWSGI. On Debian-based distributions such as Ubuntu,
    they can be easily installed using the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: These installation instructions are OS-specific, so please refer to the respective
    documentation as per the OS that you’re using.
  prefs: []
  type: TYPE_NORMAL
- en: Make sure that you have a `sites-enabled` folder for Nginx since this is where
    we will keep our site-specific configuration files. Usually, it is already present
    in most installations in the `/etc/` folder. If not, please refer to the OS-specific
    documentation for your OS to figure this out.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps to deploy the application using uWSGI first and then combine
    it with Nginx as a reverse proxy:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to create a file named `wsgi.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is needed because `uwsgi` expects to find an executable named `application`,
    so we just import our `app` as `application`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, create a file named `uwsgi.ini` in our application root folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we have configured `uwsgi` to run the `wsgi-file` provided at the HTTP
    address mentioned with the number of workers, as specified in `processes`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test whether uWSGI is working as expected, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Now, point your browser to `http://127.0.0.1:9090/`; this should open the home
    page of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Before moving on, edit the preceding file to replace `http-socket` with `socket`.
    This will change the protocol from HTTP to uWSGI (you can read more about this
    at [https://uwsgi-docs.readthedocs.io/en/latest/Protocol.html](https://uwsgi-docs.readthedocs.io/en/latest/Protocol.html)).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Important
  prefs: []
  type: TYPE_NORMAL
- en: You must keep the `uwsgi` process running. Right now, we have run this as a
    foreground process.
  prefs: []
  type: TYPE_NORMAL
- en: You might want to keep the uWSGI process running automatically in the background
    as a headless service rather than having it run manually in the foreground. There
    are multiple tools to do this, such as `supervisord`, `circus`, and so on. We
    will touch on `supervisord` in the next recipe for a different purpose, but that
    can be replicated here as well. I will leave it to you to try this out for yourself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, create a new file called `nginx-wsgi.conf`. This will contain the Nginx
    configuration that’s needed to serve our application and the static content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding code block, `uwsgi_pass` specifies the uWSGI server that needs
    to be mapped to the specified location.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: The `nginx-wsgi.conf` file can be created anywhere. It can be created with your
    code bundle so that it can be version controlled, or it can be placed at `/etc/nginx/sites-available`
    for easier maintenance if you have multiple `.``conf` files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a soft link from this file to the `sites-enabled` folder we mentioned
    earlier using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'By default, Nginx comes with a site configuration named `default` in the `sites-available`
    folder with a symlink to the `sites-enabled` folder. Unlink the same to serve
    our application; otherwise, the default will block our application from being
    loaded:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After all of this, reload the Nginx server using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Point your browser to `http://127.0.0.1/` or `http://<your server IP or domain
    address>` to see the application that serves via Nginx and uWSGI.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Refer to [https://uwsgi-docs.readthedocs.org/en/latest/](https://uwsgi-docs.readthedocs.org/en/latest/)
    for more information on uWSGI.
  prefs: []
  type: TYPE_NORMAL
- en: Refer to [https://www.nginx.com/](https://www.nginx.com/) for more information
    on Nginx.
  prefs: []
  type: TYPE_NORMAL
- en: There is a good article by DigitalOcean on Nginx and uWSGI. I advise you to
    go through it so that you have a better understanding of the topic. It is available
    at [https://www.digitalocean.com/community/tutorials/how-to-serve-flask-applications-with-uwsgi-and-nginx-on-ubuntu-22-04](https://www.digitalocean.com/community/tutorials/how-to-serve-flask-applications-with-uwsgi-and-nginx-on-ubuntu-22-04).
  prefs: []
  type: TYPE_NORMAL
- en: To get an insight into the differences between Apache and Nginx, I think an
    article by Anturis, which can be found at [https://anturis.com/blog/nginx-vs-apache/](https://anturis.com/blog/nginx-vs-apache/),
    is pretty good.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying with Gunicorn and Supervisor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Gunicorn** is a WSGI HTTP server for Unix. It is very simple to implement,
    ultra-light, and fairly speedy. Its simplicity lies in its broad compatibility
    with various web frameworks.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Supervisor** is a monitoring tool that controls various child processes and
    handles starting/restarting these child processes when they exit abruptly, or
    due to some other reason. It can be extended to control processes via the XML-RPC
    API over remote locations without you having to log into the server (we won’t
    discuss this here as it is beyond the scope of this book).'
  prefs: []
  type: TYPE_NORMAL
- en: One thing to remember is that these tools can be used along with the other tools
    mentioned in the applications in the previous recipe, such as using Nginx as a
    proxy server. This is left to you to try out.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will start by installing both the packages – that is, `gunicorn` and `supervisor`.
    Both can be directly installed using `pip`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To check whether the `gunicorn` package works as expected, just run the following
    command from inside our application folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After this, point your browser to `http://0.0.0.0:8000/` or `http://<IP address
    or domain name>:8000/` to see the application’s home page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to do the same as in the previous step using Supervisor so that
    this process runs as a daemon that will be controlled by Supervisor itself rather
    than through human intervention. First of all, we need a Supervisor configuration
    file. This can be achieved by running the following command inside your virtual
    environment. Supervisor, by default, looks for an `etc` folder that has a file
    named `supervisord.conf`. In system-wide installations, this folder is `/etc/`,
    while in a virtual environment, it will look for an `etc` folder in the virtual
    environment root folder and then fall back to `/etc/`. Hence, it is suggested
    that you create a folder named `etc` in your virtual environment to maintain separation
    of concerns:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The last command will create a configuration file named `supervisord.conf` in
    the `etc` folder. This file houses all the configurations for the processes that
    would be run using the Supervisor daemon.
  prefs: []
  type: TYPE_NORMAL
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: The `echo_supervisord_conf` program is provided by Supervisor; it prints a sample
    config file to the location specified. If you run into permission issues while
    running the command, try using `sudo`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add the following configuration block in the file you created previously:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we specified the `gunicorn` process as the command to run, along with
    the directory and user to be used for the process. Other settings specify the
    behavior at the start or restart of the Supervisor daemon and the locations to
    save respective log files in.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Note that you should never run the applications as a `root` user. This is a
    huge security flaw in itself as the application may crash or the flaws may harm
    the OS itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the setup is complete, run `supervisord` by using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To check the status of the application, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This command provides a status for all of the child processes.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: The tools that were discussed in this recipe can be coupled with Nginx to serve
    as a reverse proxy server. I suggest that you try this out for yourself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Every time you make a change to your application and then wish to restart Gunicorn
    for it to reflect the changes that have been made, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also specify specific processes instead of restarting everything:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can read more about Gunicorn at [http://gunicorn-docs.readthedocs.org/en/latest/index.html](http://gunicorn-docs.readthedocs.org/en/latest/index.html).
  prefs: []
  type: TYPE_NORMAL
- en: For more information on Supervisor, please refer to [http://supervisord.org/index.html](http://supervisord.org/index.html).
  prefs: []
  type: TYPE_NORMAL
- en: Deploying with Tornado
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tornado is a complete web framework and a standalone web server in itself. Here,
    we will use Flask to create our application, which is a combination of URL routing
    and templating, and leave the server part to Tornado. Tornado is built to hold
    thousands of simultaneous standing connections and makes applications very scalable.
  prefs: []
  type: TYPE_NORMAL
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: Tornado has limitations while working with WSGI applications, so choose wisely!
    You can read more about this at [http://www.tornadoweb.org/en/stable/wsgi.html#running-wsgi-apps-on-tornado-servers](http://www.tornadoweb.org/en/stable/wsgi.html#running-wsgi-apps-on-tornado-servers).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Installing Tornado can be done using `pip`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s create a file named `tornado_server.py` and put the following code in
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Here, we created a WSGI container for our application; this container is then
    used to create an HTTP server, and the application is hosted on port `8000`.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Run the Python file we created in the previous section using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Point your browser to `http://0.0.0.0:8000/` or `http://<IP address or domain
    name>:8000/` to see the home page being served.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: We can couple Tornado with Nginx (as a reverse proxy to serve static content)
    and Supervisor (as a process manager) for the best results. This is left for you
    as an exercise.
  prefs: []
  type: TYPE_NORMAL
- en: Using S3 storage for file uploads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Amazon Web Services** (**AWS**) explains S3 as the storage for the internet
    that is designed to make web-scale computing easier for developers. S3 provides
    a very simple interface via web services; this makes storing and retrieving any
    amount of data very simple at any time from anywhere on the internet. Until now,
    in our catalog application, we saw that there were issues in managing the product
    images that were uploaded as a part of the creation process. This whole headache
    will go away if the images are stored somewhere globally and are easily accessible
    from anywhere. We will use S3 for the same purpose.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Amazon offers `boto3`. It can be installed using `pip`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, make some changes to our existing catalog application to accommodate support
    for file upload and retrieval from S3:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to store the AWS-specific configuration to allow `boto3` to
    make calls to S3\. Add the following statements to the application’s configuration
    file – that is, `my_app/__init__.py`. Make sure that you group the following configuration
    values along with other pre-existing configuration values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can get these values from AWS IAM. Ensure that the user associated with
    these credentials has access to create and get objects from S3.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to change our `views.py` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This is the import that we need from `boto3`. Next, we need to replace the
    following line in `create_product()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'We must replace this with the following block of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: With this code change, we are essentially changing how we save files. Earlier,
    the image was being saved locally using `image.save`. Now, this is done by creating
    an S3 connection and uploading the image to a bucket there. First, we create a
    `session` connection with AWS using `boto3.Session`. We use this session to access
    S3 resources and then create a `bucket` (if it doesn’t exist; otherwise, use the
    same) with a location constraint to `'ap-south-1'`. This location constraint isn’t
    necessary and can be used as needed. Finally, we upload our image to the bucket.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last change will be made to our `product.html` template, where we need
    to change the image’s `src` path. Replace the original `img src` statement with
    the following statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 1.amazonaws.com/' + config['AWS_BUCKET']
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: + '/' + product.image_path }}"/>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, run the application as usual and create a product. When the created product
    is rendered, the product image will take a bit of time to come up as it is now
    being served from S3 (and not from a local machine). If this happens, then the
    integration with S3 has been successful.
  prefs: []
  type: TYPE_NORMAL
- en: Managing and monitoring application performance with New Relic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**New Relic** is an analytics software that provides near real-time operational
    and business analytics related to your application. It provides deep analytics
    on the behavior of the application from various aspects. It does the job of a
    profiler, as well as eliminates the need to maintain extra moving parts in the
    application. It works in the data push principle, where our application sends
    data to New Relic rather than New Relic asking for statistics from our application.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will use the catalog application that we have built throughout this book.
    In essence, the application to be used does not matter here; it should just be
    a running Flask application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step will be to sign up with New Relic for an account. Follow the
    simple sign-up process and, upon completion and email verification, you will be
    sent to your dashboard. Here, choose **Application monitoring** as the product
    that we need to use from the suite of offerings from New Relic and choose **Python**
    as the tech stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.1 – New Relic stack selection](img/B19111_11_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.1 – New Relic stack selection
  prefs: []
  type: TYPE_NORMAL
- en: 'This guided install widget will ask about the operating system being used before
    handing out the commands to be run:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.2 – New Relic install configuration](img/B19111_11_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.2 – New Relic install configuration
  prefs: []
  type: TYPE_NORMAL
- en: Following this, you can choose to do the configuration and setup manually or
    just follow the steps that are outlined by New Relic. I will discuss both approaches
    in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: For the manual method, make sure to copy the license key, as shown in the preceding
    screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can choose either guided or manual configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Guided configuration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following screenshot lists all the steps that you need to follow to make
    your application work with New Relic for APM:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.3 – New Relic guided configuration](img/B19111_11_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.3 – New Relic guided configuration
  prefs: []
  type: TYPE_NORMAL
- en: Manual configuration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Once we have the license key, we need to install the `newrelic` Python library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to generate a file called `newrelic.ini`, which will contain details
    regarding the license key, the name of our application, and so on. This can be
    done using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding command, replace `LICENSE-KEY` with the actual license key
    of your account. Now, we have a new file called `newrelic.ini`. Open and edit
    the file in terms of the application name and anything else, as needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'To check whether the `newrelic.ini` file is working successfully, run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: This will tell us whether the validation was successful or not. If not, then
    check the license key and its validity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add the following lines at the top of the application’s configuration
    file, which is `my_app/__init__.py` in our case. Make sure that you add these
    lines before anything else is imported:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, when you run your application, it will start sending statistics to New
    Relic, and the dashboard will have a new application added to it. In the following
    screenshot, there are two applications, where one corresponds to the application
    that we are working on and the other is the test that we ran a while back to validate
    whether New Relic is working correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.4 – New Relic application list](img/B19111_11_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.4 – New Relic application list
  prefs: []
  type: TYPE_NORMAL
- en: Open the application-specific page; a whole lot of statistics will appear. It
    will also show you which calls have taken the most amount of time and how the
    application is performing. You will also see multiple menu items, where each one
    will correspond to a different type of monitoring to cover all the necessary aspects.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can read more about New Relic and its configuration at [https://docs.newrelic.com/](https://docs.newrelic.com/).
  prefs: []
  type: TYPE_NORMAL
- en: Infrastructure and application monitoring with Datadog
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Datadog** is an observability service that provides detailed analytics for
    infrastructure, databases, applications, and services. Just like New Relic, Datadog
    is a full-stack platform that allows all-around monitoring that provides great
    insights into the health of an application and infrastructure.'
  prefs: []
  type: TYPE_NORMAL
- en: Although both Datadog and New Relic are similar in almost all aspects, both
    of them have some benefits over each other. For example, a popular opinion is
    that while New Relic is great at **Application Performance Monitoring** (**APM**),
    Datadog is stronger at infrastructure monitoring.
  prefs: []
  type: TYPE_NORMAL
- en: In short, both these platforms are great for most purposes and you can choose
    to use any of them or maybe some other tool/platform based on your needs.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Just like in the previous recipe, we will use the catalog application that we
    have built throughout this book. In essence, the application to be used does not
    matter here; it should just be a running Flask application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to create a new account with Datadog. They have a free tier
    that would suffice for testing, as in our case. Once you’ve signed up and logged
    in, the first step is to enable/install the Python integration in the Datadog
    console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.5 – Installing the Python integration](img/B19111_11_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.5 – Installing the Python integration
  prefs: []
  type: TYPE_NORMAL
- en: As shown in the preceding screenshot, click on the **Python** tile and install
    the integration.
  prefs: []
  type: TYPE_NORMAL
- en: 'As soon as you create an account on Datadog, it creates an API key by default.
    This API key will be needed in all further steps to make sure that monitoring
    statistics from your machine/server and application are sent to the correct Datadog
    account. Navigate to **Your account** | **Organization Settings** | **API Keys**
    to get your API key or just go to [https://app.datadoghq.com/organization-settings/api-keys](https://app.datadoghq.com/organization-settings/api-keys):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.6 – Fetching the API key](img/B19111_11_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.6 – Fetching the API key
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Go through the following steps to set up infrastructure and application monitoring
    with Datadog:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you get the API key, the next step is to install the Datadog agent on
    your operating system to allow for infrastructure monitoring. Follow the instructions
    according to your OS or infrastructure by navigating to **Integrations** | **Agent**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.7 – Installing the Datadog agent](img/B19111_11_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.7 – Installing the Datadog agent
  prefs: []
  type: TYPE_NORMAL
- en: As shown in the preceding screenshot, select your OS and follow the instructions
    accordingly. Your OS might ask for some permissions, which you will need to grant
    for Datadog to work properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you’ve installed the agent, navigate to **Infrastructure** | **Infrastructure
    List** to validate that your infrastructure is being monitored:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.8 – Infrastructure monitoring validation](img/B19111_11_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.8 – Infrastructure monitoring validation
  prefs: []
  type: TYPE_NORMAL
- en: Feel free to explore other options or drill down into the details here to see
    more analytics.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to install the `ddtrace` utility, which is Datadog’s Python
    APM client and allows you to profile code, requests, and trace data to flow to
    Datadog:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Important
  prefs: []
  type: TYPE_NORMAL
- en: If your application is running on port 5000, make sure you change the port to
    something else – ports 5000 to 5002 are used by Datadog for its agent and other
    utilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following the installation of `ddtrace`, run your Flask application using the
    following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note the `DD_SERVICE` and `DD_ENV` environment variables. These are important
    for Datadog to decide how to segregate and group your application logs.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you get an error, as shown in the following screenshot, just set `DD_REMOTE_CONFIGURATION_ENABLED=false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.9 – Handling configuration errors](img/B19111_11_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.9 – Handling configuration errors
  prefs: []
  type: TYPE_NORMAL
- en: 'Hence, in my case, the command looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, just wait for a few minutes – your application statistics should start
    reflecting on Datadog:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.10 – APM in action](img/B19111_11_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.10 – APM in action
  prefs: []
  type: TYPE_NORMAL
- en: Feel free to play around and dig into more details to understand how Datadog
    works and what kind of statistics it provides.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can read more about Datadog and `ddtrace` at the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Flask configuration for `ddtrace`: [https://ddtrace.readthedocs.io/en/stable/integrations.html#flask](https://ddtrace.readthedocs.io/en/stable/integrations.html#flask)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Datadog documentation: [https://docs.datadoghq.com/](https://docs.datadoghq.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
