<html><head></head><body>
<div id="_idContainer100">
<h1 class="chapter-number" id="_idParaDest-248"><a id="_idTextAnchor285"/><span class="koboSpan" id="kobo.1.1">14</span></h1>
<h1 id="_idParaDest-249"><a id="_idTextAnchor286"/><span class="koboSpan" id="kobo.2.1">Modular Architecture – Harnessing the Power of Blueprints</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In a far-off kingdom called Flaskland, there lived a brave prince named Modular. </span><span class="koboSpan" id="kobo.3.2">He was known for his love of clean and organized programming code, and his dream was to create a kingdom where all the snippet code lived in harmony. </span><span class="koboSpan" id="kobo.3.3">One day, as he was wandering through the land, he came across a castle in disarray. </span><span class="koboSpan" id="kobo.3.4">The code snippets were scattered everywhere, and there was no clear structure to </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">be found.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">The prince knew that this was a challenge he had to take on. </span><span class="koboSpan" id="kobo.5.2">He rallied his army of helper functions and organized them into modules, each with a specific purpose. </span><span class="koboSpan" id="kobo.5.3">He then declared that these modules were the building blocks of the kingdom, and with them, they could conquer </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">the chaos.</span></span></p>
<p><span class="koboSpan" id="kobo.7.1">And so, the prince and his army of helper functions set out to build a kingdom of well-structured, reusable code. </span><span class="koboSpan" id="kobo.7.2">They worked day and night until, finally, the newly organized kingdom was born. </span><span class="koboSpan" id="kobo.7.3">The snippets were organized, and the kingdom was a beauty to behold. </span><span class="koboSpan" id="kobo.7.4">This story captures the heart of code modularity, the practice of breaking down a program or system into smaller, self-contained modules or components. </span><span class="koboSpan" id="kobo.7.5">Blueprints in Flask encourage this modular approach to building </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">web applications.</span></span></p>
<p><strong class="bold"><span class="koboSpan" id="kobo.9.1">Modular architecture</span></strong><span class="koboSpan" id="kobo.10.1"> has become increasingly important as web applications have become more complex in size </span><a id="_idIndexMarker989"/><span class="koboSpan" id="kobo.11.1">and scope. </span><span class="koboSpan" id="kobo.11.2">Modular architecture is a modular programming paradigm that emphasizes breaking down large applications into smaller, reusable modules that can be developed and </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">tested independently.</span></span></p>
<p><span class="koboSpan" id="kobo.13.1">The </span><strong class="bold"><span class="koboSpan" id="kobo.14.1">object-oriented programming</span></strong><span class="koboSpan" id="kobo.15.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.16.1">OOP</span></strong><span class="koboSpan" id="kobo.17.1">) revolution of the 1980s also had a significant impact </span><a id="_idIndexMarker990"/><span class="koboSpan" id="kobo.18.1">on the development of modular architecture. </span><span class="koboSpan" id="kobo.18.2">OOP encouraged the creation of self-contained, reusable objects that could be combined to form complex applications. </span><span class="koboSpan" id="kobo.18.3">This approach was well suited to the development of modular applications and helped to drive the widespread adoption of </span><span class="No-Break"><span class="koboSpan" id="kobo.19.1">modular architecture.</span></span></p>
<p><span class="koboSpan" id="kobo.20.1">The principles of modularity, separation of concerns, and encapsulation remain key elements of modular architecture, and the pattern continues to evolve and adapt to meet the changing needs of software development. </span><span class="koboSpan" id="kobo.20.2">Today, modular architecture is a widely accepted and widely used software </span><span class="No-Break"><span class="koboSpan" id="kobo.21.1">design pattern.</span></span></p>
<p><span class="koboSpan" id="kobo.22.1">Modular architecture is used in a variety of contexts, from large-scale enterprise applications to small, single-page web applications. </span><span class="koboSpan" id="kobo.22.2">In Flask web applications, Blueprints refer to a way to </span><a id="_idIndexMarker991"/><span class="koboSpan" id="kobo.23.1">organize a group of related views and other code into a single module. </span><span class="koboSpan" id="kobo.23.2">Blueprints resemble what components are to React: reusable pieces of UI that encapsulate a set of functions and states. </span><span class="koboSpan" id="kobo.23.3">But in the context of Flask, Flask allows you to organize your application into smaller, reusable components </span><span class="No-Break"><span class="koboSpan" id="kobo.24.1">called Blueprints.</span></span></p>
<p><span class="koboSpan" id="kobo.25.1">In this chapter, we will explore modular architecture in web development. </span><span class="koboSpan" id="kobo.25.2">With Blueprints in perspective, we will discuss how Blueprints can help you to build decoupled, reusable, maintainable, and testable Flask </span><span class="No-Break"><span class="koboSpan" id="kobo.26.1">web applications.</span></span></p>
<p><span class="koboSpan" id="kobo.27.1">In this chapter, we will cover the </span><span class="No-Break"><span class="koboSpan" id="kobo.28.1">following topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.29.1">Understanding the benefits of modular architecture in </span><span class="No-Break"><span class="koboSpan" id="kobo.30.1">web development</span></span></li>
<li><span class="koboSpan" id="kobo.31.1">Understanding </span><span class="No-Break"><span class="koboSpan" id="kobo.32.1">Flask Blueprints</span></span></li>
<li><span class="koboSpan" id="kobo.33.1">Setting up a Flask application </span><span class="No-Break"><span class="koboSpan" id="kobo.34.1">with Blueprints</span></span></li>
<li><span class="koboSpan" id="kobo.35.1">Handling the React frontend with </span><span class="No-Break"><span class="koboSpan" id="kobo.36.1">Flask Blueprints</span></span></li>
</ul>
<h1 id="_idParaDest-250"><a id="_idTextAnchor287"/><span class="koboSpan" id="kobo.37.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.38.1">The complete code for this chapter is available on GitHub </span><span class="No-Break"><span class="koboSpan" id="kobo.39.1">at: </span></span><a href="https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter14"><span class="No-Break"><span class="koboSpan" id="kobo.40.1">https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter14</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.41.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.42.1">Due to the page count constraints, most of the long code blocks have been snipped. </span><span class="koboSpan" id="kobo.42.2">Please refer to GitHub for the </span><span class="No-Break"><span class="koboSpan" id="kobo.43.1">complete code.</span></span></p>
<h1 id="_idParaDest-251"><a id="_idTextAnchor288"/><span class="koboSpan" id="kobo.44.1">Understanding the benefits of modular architecture in web development</span></h1>
<p><span class="koboSpan" id="kobo.45.1">Modular architecture is a software </span><a id="_idIndexMarker992"/><span class="koboSpan" id="kobo.46.1">development approach that involves breaking down a large, complex system into smaller, independent, and reusable modules. </span><span class="koboSpan" id="kobo.46.2">In the history of web development, modular architecture became more apparent. </span><span class="koboSpan" id="kobo.46.3">The traditional monolithic architecture involved having all the components of a web application tightly coupled, resulting in a large, unwieldy code base that was difficult to maintain </span><span class="No-Break"><span class="koboSpan" id="kobo.47.1">and scale.</span></span></p>
<p><span class="koboSpan" id="kobo.48.1">As web applications became more complex and the need for scalability increased, developers began to seek alternative approaches that would allow them to break down a web application into smaller, </span><span class="No-Break"><span class="koboSpan" id="kobo.49.1">independent components.</span></span></p>
<p><span class="koboSpan" id="kobo.50.1">Modular architecture emerged as a solution to these limitations, as it allowed developers to create smaller, reusable components that could be combined to form a complete web application. </span><span class="koboSpan" id="kobo.50.2">This approach provided several benefits, including improved maintainability, easier scalability, and better separation </span><span class="No-Break"><span class="koboSpan" id="kobo.51.1">of concerns.</span></span></p>
<p><span class="koboSpan" id="kobo.52.1">With modular architecture, developers could work on individual components in isolation, which reduced the risk of breaking the entire application and made it easier to test and deploy changes independently. </span><span class="koboSpan" id="kobo.52.2">As a result, modular architecture quickly gained popularity among web developers, and many modern web development frameworks such as Flask, Django, Ruby on Rails, and Angular have embraced this architectural style. </span><span class="koboSpan" id="kobo.52.3">The popularity of modular architecture has continued to grow over the years, and it remains a crucial component of modern web </span><span class="No-Break"><span class="koboSpan" id="kobo.53.1">development practices.</span></span></p>
<p><span class="koboSpan" id="kobo.54.1">Let’s explore some of </span><a id="_idIndexMarker993"/><span class="koboSpan" id="kobo.55.1">the benefits of modular architecture in </span><span class="No-Break"><span class="koboSpan" id="kobo.56.1">web development:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.57.1">Scalability</span></strong><span class="koboSpan" id="kobo.58.1">: In a traditional monolithic architecture, as an application grows, it becomes more difficult to manage, maintain, and scale. </span><span class="koboSpan" id="kobo.58.2">With modular architecture, each module is independent and can be developed, tested, and deployed independently, which makes it easier to scale individual components </span><span class="No-Break"><span class="koboSpan" id="kobo.59.1">as needed.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.60.1">Reusability</span></strong><span class="koboSpan" id="kobo.61.1">: Modular architecture encourages code reuse, which leads to a more efficient development process. </span><span class="koboSpan" id="kobo.61.2">Modules can be reused across different projects, reducing the amount of time and effort required to develop new applications. </span><span class="koboSpan" id="kobo.61.3">Furthermore, modular architecture makes it easier to update and maintain existing code, as changes can be made to a single module without affecting the rest of </span><span class="No-Break"><span class="koboSpan" id="kobo.62.1">the application.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.63.1">Maintainability</span></strong><span class="koboSpan" id="kobo.64.1">: With modular architecture, the application is divided into smaller, manageable components, making it easier to identify and resolve issues. </span><span class="koboSpan" id="kobo.64.2">The modular design makes it easier to isolate problems and debug issues, reducing the time and effort required to resolve them. </span><span class="koboSpan" id="kobo.64.3">Furthermore, modular architecture makes it easier to test individual components, ensuring that the application remains reliable and maintainable </span><span class="No-Break"><span class="koboSpan" id="kobo.65.1">over time.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.66.1">Flexibility</span></strong><span class="koboSpan" id="kobo.67.1">: Modular architecture allows developers to easily modify or extend the functionality of an application without affecting the rest of the system. </span><span class="koboSpan" id="kobo.67.2">This makes it easier to add new features, make changes, or integrate new technologies into the application. </span><span class="koboSpan" id="kobo.67.3">With modular architecture, developers can work on individual modules, ensuring that the application remains flexible and adaptable </span><span class="No-Break"><span class="koboSpan" id="kobo.68.1">over time.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.69.1">Improved collaboration</span></strong><span class="koboSpan" id="kobo.70.1">: Modular architecture enables developers to work on different parts of an application in parallel, improving collaboration and reducing the time required to complete projects. </span><span class="koboSpan" id="kobo.70.2">The modular design allows teams to divide the work into smaller, manageable components, making it easier to coordinate and integrate </span><span class="No-Break"><span class="koboSpan" id="kobo.71.1">their efforts.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.72.1">Better performance</span></strong><span class="koboSpan" id="kobo.73.1">: Modular architecture can improve the performance of web applications by reducing the size of individual components and improving the load times of </span><a id="_idIndexMarker994"/><span class="koboSpan" id="kobo.74.1">an application. </span><span class="koboSpan" id="kobo.74.2">With smaller, more focused components, the application can load faster, improving the user experience. </span><span class="koboSpan" id="kobo.74.3">Additionally, modular architecture allows for better resource allocation, ensuring that the application uses resources efficiently </span><span class="No-Break"><span class="koboSpan" id="kobo.75.1">and effectively.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.76.1">In conclusion, modular architecture is </span><a id="_idIndexMarker995"/><span class="koboSpan" id="kobo.77.1">becoming increasingly important in web development, as it provides several benefits over traditional monolithic architecture. </span><span class="koboSpan" id="kobo.77.2">With its ability to improve scalability, reusability, maintainability, flexibility, collaboration, and performance, modular architecture provides a compelling reason for developers to adopt this approach in </span><span class="No-Break"><span class="koboSpan" id="kobo.78.1">their projects.</span></span></p>
<p><span class="koboSpan" id="kobo.79.1">By embracing modular architecture, developers can create better, more efficient applications that are </span><a id="_idIndexMarker996"/><span class="koboSpan" id="kobo.80.1">easier to manage and maintain </span><span class="No-Break"><span class="koboSpan" id="kobo.81.1">over time.</span></span></p>
<p><span class="koboSpan" id="kobo.82.1">Next, we will discuss the big elephant in the Flask community – Blueprint. </span><span class="koboSpan" id="kobo.82.2">Blueprint is a powerful organizational tool that facilitates the structuring of a web application into modular and </span><span class="No-Break"><span class="koboSpan" id="kobo.83.1">reusable components.</span></span></p>
<h1 id="_idParaDest-252"><a id="_idTextAnchor289"/><span class="koboSpan" id="kobo.84.1">Understanding Flask Blueprints</span></h1>
<p><span class="koboSpan" id="kobo.85.1">As you may be aware, Flask is a simple and lightweight framework that allows developers to create web applications </span><a id="_idIndexMarker997"/><span class="koboSpan" id="kobo.86.1">quickly and easily. </span><span class="koboSpan" id="kobo.86.2">Flask Blueprints are an important feature of Flask that help developers organize their applications into </span><span class="No-Break"><span class="koboSpan" id="kobo.87.1">reusable components.</span></span></p>
<p><span class="koboSpan" id="kobo.88.1">Flask Blueprints are a way to organize </span><a id="_idIndexMarker998"/><span class="koboSpan" id="kobo.89.1">your Flask application into smaller and reusable components. </span><span class="koboSpan" id="kobo.89.2">Essentially, Blueprints are a collection of routes, templates, and static files that can be registered and used in multiple Flask applications. </span><span class="koboSpan" id="kobo.89.3">Blueprints allow you to split your Flask application into smaller, modular components that can be easily maintained and scaled. </span><span class="koboSpan" id="kobo.89.4">This modular approach to building web applications makes it easier to manage the code base and collaborate with </span><span class="No-Break"><span class="koboSpan" id="kobo.90.1">other developers.</span></span></p>
<p><span class="koboSpan" id="kobo.91.1">Let’s glance through some of the </span><a id="_idIndexMarker999"/><span class="koboSpan" id="kobo.92.1">benefits of using Blueprints in your Flask </span><span class="No-Break"><span class="koboSpan" id="kobo.93.1">application development:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.94.1">Modular design</span></strong><span class="koboSpan" id="kobo.95.1">: Flask Blueprints allow developers to break down their applications into smaller, reusable components. </span><span class="koboSpan" id="kobo.95.2">This makes it easier to maintain and scale the code base </span><span class="No-Break"><span class="koboSpan" id="kobo.96.1">over time.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.97.1">Reusability</span></strong><span class="koboSpan" id="kobo.98.1">: Once you create a Blueprint, you can reuse it across different Flask applications. </span><span class="koboSpan" id="kobo.98.2">This saves you time and effort. </span><span class="koboSpan" id="kobo.98.3">Indeed, using Flask Blueprints can greatly simplify the process of building complex web applications, allowing developers to quickly and easily create reusable components with just a few clicks of </span><span class="No-Break"><span class="koboSpan" id="kobo.99.1">the mouse.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.100.1">Flexibility</span></strong><span class="koboSpan" id="kobo.101.1">: Flask Blueprints can be customized to suit the needs of your application. </span><span class="koboSpan" id="kobo.101.2">You can define your own URL prefixes for a Blueprint, which allows you to customize your application’s URL structure. </span><span class="koboSpan" id="kobo.101.3">This gives you more control over how your web application is structured </span><span class="No-Break"><span class="koboSpan" id="kobo.102.1">and accessed.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.103.1">Template inheritance</span></strong><span class="koboSpan" id="kobo.104.1">: Blueprints can inherit templates from the main application, which allows you to reuse templates across multiple Blueprints. </span><span class="koboSpan" id="kobo.104.2">This makes it easier to create consistent and well-designed </span><span class="No-Break"><span class="koboSpan" id="kobo.105.1">web applications.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.106.1">Namespaces</span></strong><span class="koboSpan" id="kobo.107.1">: Blueprints can define their own view functions, and these functions are namespaced </span><a id="_idIndexMarker1000"/><span class="koboSpan" id="kobo.108.1">within the Blueprint. </span><span class="koboSpan" id="kobo.108.2">This helps prevent naming conflicts between different parts of </span><span class="No-Break"><span class="koboSpan" id="kobo.109.1">your application.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.110.1">Flask Blueprints undoubtedly promote a clear separation of concerns within your application code base. </span><span class="koboSpan" id="kobo.110.2">By organizing your code into separate Blueprints, you can ensure that each component </span><a id="_idIndexMarker1001"/><span class="koboSpan" id="kobo.111.1">of your application is responsible for a specific area of functionality. </span><span class="koboSpan" id="kobo.111.2">This can make it easier to understand and debug your code, as well as ensure that your application is more maintainable </span><span class="No-Break"><span class="koboSpan" id="kobo.112.1">over time.</span></span></p>
<p><span class="koboSpan" id="kobo.113.1">In the next section, we will delve into setting up a Flask application with Blueprints </span><span class="No-Break"><span class="koboSpan" id="kobo.114.1">in mind.</span></span></p>
<h1 id="_idParaDest-253"><a id="_idTextAnchor290"/><span class="koboSpan" id="kobo.115.1">Setting up a Flask application with Blueprints</span></h1>
<p><span class="koboSpan" id="kobo.116.1">Blueprints in Flask are a way to organize and structure a Flask application into smaller, reusable </span><a id="_idIndexMarker1002"/><span class="koboSpan" id="kobo.117.1">components. </span><span class="koboSpan" id="kobo.117.2">To use Blueprints in a Flask application, you typically define your Blueprint in a separate Python file where you </span><a id="_idIndexMarker1003"/><span class="koboSpan" id="kobo.118.1">can define your routes, templates, and any other necessary logic specific to that Blueprint. </span><span class="koboSpan" id="kobo.118.2">Once defined, you can register the Blueprint with your Flask application, which allows you to use the Blueprint functionality within your main </span><span class="No-Break"><span class="koboSpan" id="kobo.119.1">Flask application.</span></span></p>
<p><span class="koboSpan" id="kobo.120.1">With Blueprints, you can easily separate concerns between different parts of your application, making it </span><a id="_idIndexMarker1004"/><span class="koboSpan" id="kobo.121.1">easier to maintain </span><a id="_idIndexMarker1005"/><span class="koboSpan" id="kobo.122.1">and update </span><span class="No-Break"><span class="koboSpan" id="kobo.123.1">over time.</span></span></p>
<p><span class="koboSpan" id="kobo.124.1">Now, let’s dive deep into the heart of how you can set up Flask applications </span><span class="No-Break"><span class="koboSpan" id="kobo.125.1">with Blueprints.</span></span></p>
<h2 id="_idParaDest-254"><a id="_idTextAnchor291"/><span class="koboSpan" id="kobo.126.1">Structuring Blueprint Flask applications</span></h2>
<p><span class="koboSpan" id="kobo.127.1">In web application development, efficient organization and modularity of the code base are essential for building </span><a id="_idIndexMarker1006"/><span class="koboSpan" id="kobo.128.1">robust and maintainable projects. </span><span class="koboSpan" id="kobo.128.2">One of the key structural elements in Flask is the concept of Blueprints. </span><span class="koboSpan" id="kobo.128.3">These Blueprints provide a structured way to compartmentalize and encapsulate various components of a </span><span class="No-Break"><span class="koboSpan" id="kobo.129.1">web application.</span></span></p>
<p><span class="koboSpan" id="kobo.130.1">The approach invariably promotes clarity, reusability, and scalability. </span><span class="koboSpan" id="kobo.130.2">We are going to examine the</span><a id="_idTextAnchor292"/><span class="koboSpan" id="kobo.131.1"> structure of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.132.1">attendees</span></strong><span class="koboSpan" id="kobo.133.1"> Blueprint – a crafted, organizational structure designed to streamline the development of attendee-related features within our </span><span class="No-Break"><span class="koboSpan" id="kobo.134.1">web</span><a id="_idTextAnchor293"/><span class="koboSpan" id="kobo.135.1"> application.</span></span></p>
<p><span class="koboSpan" id="kobo.136.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.137.1">attendees</span></strong><span class="koboSpan" id="kobo.138.1"> Blueprint is nestled within the </span><strong class="source-inline"><span class="koboSpan" id="kobo.139.1">bizza\backend\blueprints\attendees</span></strong><span class="koboSpan" id="kobo.140.1"> directory. </span><span class="koboSpan" id="kobo.140.2">Create a new directory inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.141.1">bizza/backend</span></strong><span class="koboSpan" id="kobo.142.1"> project directory for the Flask applications and name it </span><strong class="source-inline"><span class="koboSpan" id="kobo.143.1">blueprints</span></strong><span class="koboSpan" id="kobo.144.1">. </span><span class="koboSpan" id="kobo.144.2">The Blueprints added to the project make the directory structure appear </span><span class="No-Break"><span class="koboSpan" id="kobo.145.1">as follows:</span></span></p>
<p><strong class="bold"><span class="koboSpan" id="kobo.146.1">The </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.147.1">attendees Blueprint</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.148.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.149.1">bizza\backend\blueprints\attendees-models
-templates
-static
-attendee_blueprint.py</span></pre>
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.150.1">Detailed structure</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.151.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.152.1">bizza\backend\blueprints\attendees-models
- __init__.py
- attendee.py
-templates
- attendees/
- base.html
- attendee_form.html
- attendee_list.html
- attendee_profile.html
- attendee_profile_edit.html
-static
- css/
- attendees.css
- js/
- attendees.js
attendee_blueprint.py</span></pre>
<p><span class="koboSpan" id="kobo.153.1">The preceding </span><strong class="source-inline"><span class="koboSpan" id="kobo.154.1">attendees</span></strong><span class="koboSpan" id="kobo.155.1"> Blueprint contains the </span><span class="No-Break"><span class="koboSpan" id="kobo.156.1">following components:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.157.1">models</span></strong><span class="koboSpan" id="kobo.158.1">: This is a subdirectory containing a Python module named </span><strong class="source-inline"><span class="koboSpan" id="kobo.159.1">attendee.py</span></strong><span class="koboSpan" id="kobo.160.1"> that defines the data model for attendees. </span><span class="koboSpan" id="kobo.160.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.161.1">__init__.py</span></strong><span class="koboSpan" id="kobo.162.1"> file is a blank Python module that indicates to Python that this directory should be treated as </span><span class="No-Break"><span class="koboSpan" id="kobo.163.1">a package.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.164.1">Templates</span></strong><span class="koboSpan" id="kobo.165.1">: This is a subdirectory containing HTML templates for the attendee views. </span><span class="koboSpan" id="kobo.165.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.166.1">base.html</span></strong><span class="koboSpan" id="kobo.167.1"> template is a base template that other templates inherit</span><a id="_idIndexMarker1007"/><span class="koboSpan" id="kobo.168.1"> from. </span><span class="koboSpan" id="kobo.168.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.169.1">attendee_form.html</span></strong><span class="koboSpan" id="kobo.170.1"> template is used for creating or editing attendee profiles. </span><span class="koboSpan" id="kobo.170.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.171.1">attendee_list.html</span></strong><span class="koboSpan" id="kobo.172.1"> template is used to display a list of all attendees. </span><span class="koboSpan" id="kobo.172.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.173.1">attendee_profile.html</span></strong><span class="koboSpan" id="kobo.174.1"> template is used to display a single attendee’s profile. </span><span class="koboSpan" id="kobo.174.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.175.1">attendee_profile_edit.html</span></strong><span class="koboSpan" id="kobo.176.1"> template is used to edit an </span><span class="No-Break"><span class="koboSpan" id="kobo.177.1">attendee’s profile.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.178.1">static</span></strong><span class="koboSpan" id="kobo.179.1">: This is a subdirectory containing static files used by the templates. </span><span class="koboSpan" id="kobo.179.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.180.1">css</span></strong><span class="koboSpan" id="kobo.181.1"> directory contains an </span><strong class="source-inline"><span class="koboSpan" id="kobo.182.1">attendees.css</span></strong><span class="koboSpan" id="kobo.183.1"> file used to style the HTML templates. </span><span class="koboSpan" id="kobo.183.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.184.1">js</span></strong><span class="koboSpan" id="kobo.185.1"> directory contains an </span><strong class="source-inline"><span class="koboSpan" id="kobo.186.1">attendees.js</span></strong><span class="koboSpan" id="kobo.187.1"> file used for </span><span class="No-Break"><span class="koboSpan" id="kobo.188.1">client-side scripting.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.189.1">attendee_blueprint.py</span></strong><span class="koboSpan" id="kobo.190.1">: This is a Python module containing the Blueprint definition and the routing for the attendee views. </span><span class="koboSpan" id="kobo.190.2">This Blueprint defines routes for displaying a list of attendees, displaying an individual attendee’s profile, creating a </span><a id="_idIndexMarker1008"/><span class="koboSpan" id="kobo.191.1">new attendee profile, and updating an existing attendee profile. </span><span class="koboSpan" id="kobo.191.2">The Blueprint also contains database-related functions for handling attendee data, such as adding new attendees and updating </span><span class="No-Break"><span class="koboSpan" id="kobo.192.1">attendee information.</span></span></li>
</ul>
<h2 id="_idParaDest-255"><a id="_idTextAnchor294"/><span class="koboSpan" id="kobo.193.1">Defining models and Blueprint modules</span></h2>
<p><span class="koboSpan" id="kobo.194.1">Models serve as the foundation </span><a id="_idIndexMarker1009"/><span class="koboSpan" id="kobo.195.1">of a web application’s data structure. </span><span class="koboSpan" id="kobo.195.2">Models represent the essential entities and relationships within web applications. </span><span class="koboSpan" id="kobo.195.3">They encapsulate data </span><a id="_idIndexMarker1010"/><span class="koboSpan" id="kobo.196.1">attributes, business logic, and interactions, providing a coherent representation of </span><span class="No-Break"><span class="koboSpan" id="kobo.197.1">real-world concepts.</span></span></p>
<p><span class="koboSpan" id="kobo.198.1">When defining models within a Blueprint module, you create a self-contained unit that encapsulates data-related logic. </span><span class="koboSpan" id="kobo.198.2">With the integration of models into Blueprint modules, you achieve a harmonious synergy, and </span><a id="_idIndexMarker1011"/><span class="koboSpan" id="kobo.199.1">benefits such as </span><span class="No-Break"><span class="koboSpan" id="kobo.200.1">the following:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.201.1">Clear separation</span></strong><span class="koboSpan" id="kobo.202.1">: Blueprint modules isolate various functionalities, while models encapsulate data handling. </span><span class="koboSpan" id="kobo.202.2">This separation simplifies code base maintenance and </span><span class="No-Break"><span class="koboSpan" id="kobo.203.1">enhances readability.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.204.1">Coherent structure</span></strong><span class="koboSpan" id="kobo.205.1">: Blueprint modules provide a logical context for models, making it easier to navigate and understand </span><span class="No-Break"><span class="koboSpan" id="kobo.206.1">data-related operations.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.207.1">Reusability</span></strong><span class="koboSpan" id="kobo.208.1">: Models defined within a Blueprint can be reused across other parts of the application </span><a id="_idIndexMarker1012"/><span class="koboSpan" id="kobo.209.1">through Blueprint integration, promoting a </span><strong class="bold"><span class="koboSpan" id="kobo.210.1">Don’t Repeat Yourself</span></strong><span class="koboSpan" id="kobo.211.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.212.1">DRY</span></strong><span class="koboSpan" id="kobo.213.1">) </span><span class="No-Break"><span class="koboSpan" id="kobo.214.1">coding approach.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.215.1">Now, let’s delve</span><a id="_idIndexMarker1013"/><span class="koboSpan" id="kobo.216.1"> into the attributes of the attendee model in a </span><span class="No-Break"><span class="koboSpan" id="kobo.217.1">Blueprint </span></span><span class="No-Break"><a id="_idIndexMarker1014"/></span><span class="No-Break"><span class="koboSpan" id="kobo.218.1">module:</span></span></p>
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.219.1">Attendees Blueprint</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.220.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.221.1">-models- __init__.py
- attendee.py</span></pre>
<p><span class="koboSpan" id="kobo.222.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.223.1">attendee.py</span></strong><span class="koboSpan" id="kobo.224.1"> model is defined as </span><span class="No-Break"><span class="koboSpan" id="kobo.225.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.226.1">from bizza.backend.blueprints import dbclass Attendee(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(50), nullable=False)
    email = db.Column(db.String(120), unique=True,
        nullable=False)
    registration_date = db.Column(db.DateTime,
        nullable=False)
    def __repr__(self):
        return f'&lt;Attendee {self.name}&gt;'</span></pre>
<p><span class="koboSpan" id="kobo.227.1">The preceding </span><strong class="source-inline"><span class="koboSpan" id="kobo.228.1">Attendee</span></strong><span class="koboSpan" id="kobo.229.1"> model represents attendees at the conference. </span><span class="koboSpan" id="kobo.229.2">It has columns for </span><strong class="source-inline"><span class="koboSpan" id="kobo.230.1">id</span></strong><span class="koboSpan" id="kobo.231.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.232.1">name</span></strong><span class="koboSpan" id="kobo.233.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.234.1">email</span></strong><span class="koboSpan" id="kobo.235.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.236.1">registration_date</span></strong><span class="koboSpan" id="kobo.237.1">. </span><span class="koboSpan" id="kobo.237.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.238.1">__repr__</span></strong><span class="koboSpan" id="kobo.239.1"> method specifies how instances of the model should be represented </span><span class="No-Break"><span class="koboSpan" id="kobo.240.1">as strings.</span></span></p>
<p><span class="koboSpan" id="kobo.241.1">The attendee Blueprint is defined </span><span class="No-Break"><span class="koboSpan" id="kobo.242.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.243.1">from bizza.backend.blueprints.attendees.models.attendee import Attendeefrom bizza.backend.blueprints.attendees.forms import AttendeeForm, EditAttendeeForm
from bizza.backend.blueprints.attendees import db
attendee_bp = Blueprint('attendee', __name__, template_folder='templates', static_folder='static')
@attendee_bp.route('/attendees')
def attendees():
    attendees = Attendee.query.all()
    return render_template('attendees/attendee_list.html',
        attendees=attendees)
@attendee_bp.route('/attendee/add', methods=['GET',
    'POST'])
def add_attendee():
    form = AttendeeForm()
    if form.validate_on_submit():
        attendee = Attendee(name=form.name.data,
                            email=form.email.data,
                            phone=form.phone.data,
            ...
</span><span class="koboSpan" id="kobo.243.2">        return redirect(url_for('attendee.attendees'))
    return render_template('attendees/attendee_form.html',
        form=form, action='Add')
...</span></pre>
<p><span class="koboSpan" id="kobo.244.1">The preceding snippet defines a Flask Blueprint for managing attendees. </span><span class="koboSpan" id="kobo.244.2">It imports the necessary modules, including the </span><strong class="source-inline"><span class="koboSpan" id="kobo.245.1">Attendee</span></strong><span class="koboSpan" id="kobo.246.1"> model, </span><strong class="source-inline"><span class="koboSpan" id="kobo.247.1">AttendeeForm</span></strong><span class="koboSpan" id="kobo.248.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.249.1">EditAttendeeForm</span></strong><span class="koboSpan" id="kobo.250.1"> from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.251.1">attendees</span></strong><span class="koboSpan" id="kobo.252.1"> package, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.253.1">db</span></strong><span class="koboSpan" id="kobo.254.1"> from the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.255.1">bizza.backend.blueprints</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.256.1"> package.</span></span></p>
<p><span class="koboSpan" id="kobo.257.1">The Blueprint has a route for the attendee list that requires the user to be logged in. </span><span class="koboSpan" id="kobo.257.2">It retrieves all attendees from the database using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.258.1">Attendee.query.all()</span></strong><span class="koboSpan" id="kobo.259.1"> method and renders the </span><strong class="source-inline"><span class="koboSpan" id="kobo.260.1">attendee_list.html</span></strong><span class="koboSpan" id="kobo.261.1"> template with the list </span><span class="No-Break"><span class="koboSpan" id="kobo.262.1">of attendees.</span></span></p>
<p><span class="koboSpan" id="kobo.263.1">The Blueprint also </span><a id="_idIndexMarker1015"/><span class="koboSpan" id="kobo.264.1">has a route for adding attendees that is accessible via </span><strong class="source-inline"><span class="koboSpan" id="kobo.265.1">GET</span></strong><span class="koboSpan" id="kobo.266.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.267.1">POST</span></strong><span class="koboSpan" id="kobo.268.1"> requests. </span><span class="koboSpan" id="kobo.268.2">It creates an instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.269.1">AttendeeForm</span></strong><span class="koboSpan" id="kobo.270.1">, and if the form is </span><a id="_idIndexMarker1016"/><span class="koboSpan" id="kobo.271.1">validated, it creates a new attendee object with the data submitted through the form, adds it to the database, and commits the changes. </span><span class="koboSpan" id="kobo.271.2">If successful, it flashes a message and redirects to the attendee list page. </span><span class="koboSpan" id="kobo.271.3">If the form is not valid, it re-renders the </span><strong class="source-inline"><span class="koboSpan" id="kobo.272.1">attendee_form.html</span></strong><span class="koboSpan" id="kobo.273.1"> template with the form and the </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.274.1">Add</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.275.1"> action.</span></span></p>
<h2 id="_idParaDest-256"><a id="_idTextAnchor295"/><span class="koboSpan" id="kobo.276.1">Registering the Blueprints</span></h2>
<p><span class="koboSpan" id="kobo.277.1">When you create a Blueprint, you define its routes, views, models, templates, and static files. </span><span class="koboSpan" id="kobo.277.2">Once you </span><a id="_idIndexMarker1017"/><span class="koboSpan" id="kobo.278.1">have defined your Blueprint, you need to register it with your Flask application using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.279.1">register_blueprint</span></strong><span class="koboSpan" id="kobo.280.1"> method. </span><span class="koboSpan" id="kobo.280.2">This method tells Flask to include the views, templates, and static files of the Blueprint in </span><span class="No-Break"><span class="koboSpan" id="kobo.281.1">the application.</span></span></p>
<p><span class="koboSpan" id="kobo.282.1">So, when the </span><strong class="source-inline"><span class="koboSpan" id="kobo.283.1">app.register_blueprint</span></strong><span class="koboSpan" id="kobo.284.1"> method is called, it adds the routes and views defined in the Blueprint to the application. </span><span class="koboSpan" id="kobo.284.2">This makes the functionality provided by the Blueprint available to the rest of </span><span class="No-Break"><span class="koboSpan" id="kobo.285.1">the application.</span></span></p>
<p><span class="koboSpan" id="kobo.286.1">Let’s use a basic Flask application factory function to create and configure a </span><span class="No-Break"><span class="koboSpan" id="kobo.287.1">Flask application:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.288.1">from flask import Flaskfrom flask_sqlalchemy import SQLAlchemy
# initialize the db object
db = SQLAlchemy()
def create_app():
    app = Flask(__name__)
    # load the config
    app.config.from_object('config.Config')
    # initialize the db
    db.init_app(app)
    # import the blueprints
    from .blueprints.speaker_blueprint import speaker_bp
    from .blueprints.presentation_blueprint import
        presentation_bp
    from .blueprints.attendee_blueprint import attendee_bp
    # register the blueprints
    app.register_blueprint(speaker_bp)
    app.register_blueprint(presentation_bp)
    app.register_blueprint(attendee_bp)
    return app</span></pre>
<p><span class="koboSpan" id="kobo.289.1">The preceding </span><a id="_idIndexMarker1018"/><span class="koboSpan" id="kobo.290.1">code does </span><span class="No-Break"><span class="koboSpan" id="kobo.291.1">the following:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.292.1">Imports the </span><strong class="source-inline"><span class="koboSpan" id="kobo.293.1">Flask</span></strong><span class="koboSpan" id="kobo.294.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.295.1">SQLAlchemy</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.296.1"> modules.</span></span></li>
<li><span class="koboSpan" id="kobo.297.1">Creates an instance of the </span><span class="No-Break"><span class="koboSpan" id="kobo.298.1">Flask application.</span></span></li>
<li><span class="koboSpan" id="kobo.299.1">Loads the configuration from a </span><span class="No-Break"><span class="koboSpan" id="kobo.300.1">configuration file.</span></span></li>
<li><span class="koboSpan" id="kobo.301.1">Initializes the </span><strong class="source-inline"><span class="koboSpan" id="kobo.302.1">SQLAlchemy</span></strong><span class="koboSpan" id="kobo.303.1"> object with </span><span class="No-Break"><span class="koboSpan" id="kobo.304.1">the application.</span></span></li>
<li><span class="koboSpan" id="kobo.305.1">Imports the Blueprints from the different parts of </span><span class="No-Break"><span class="koboSpan" id="kobo.306.1">the application.</span></span></li>
<li><span class="koboSpan" id="kobo.307.1">Registers the Blueprints </span><a id="_idIndexMarker1019"/><span class="koboSpan" id="kobo.308.1">with the </span><span class="No-Break"><span class="koboSpan" id="kobo.309.1">Flask application.</span></span></li>
<li><span class="koboSpan" id="kobo.310.1">Returns the Flask </span><span class="No-Break"><span class="koboSpan" id="kobo.311.1">application object.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.312.1">Next, we will shift our focus to how Blueprints and the React frontend can be integrated seamlessly. </span><span class="koboSpan" id="kobo.312.2">We need to get creative and discover exciting ways to blend Blueprints with a React frontend and take our development to the </span><span class="No-Break"><span class="koboSpan" id="kobo.313.1">next level.</span></span></p>
<h1 id="_idParaDest-257"><a id="_idTextAnchor296"/><span class="koboSpan" id="kobo.314.1">Handling the React frontend with Flask Blueprints</span></h1>
<p><span class="koboSpan" id="kobo.315.1">In the case of a React frontend and Flask backend, Blueprints can be used to organize the different API </span><a id="_idIndexMarker1020"/><span class="koboSpan" id="kobo.316.1">routes and views that the frontend </span><a id="_idIndexMarker1021"/><span class="koboSpan" id="kobo.317.1">needs to communicate with the backend. </span><span class="koboSpan" id="kobo.317.2">The frontend can make requests to the backend API endpoints that are defined in the Blueprints, and the backend can respond with the </span><span class="No-Break"><span class="koboSpan" id="kobo.318.1">appropriate data.</span></span></p>
<p><span class="koboSpan" id="kobo.319.1">Additionally, using Flask for the backend and React for the frontend provides a flexible and powerful development environment. </span><span class="koboSpan" id="kobo.319.2">Flask is a lightweight and </span><em class="italic"><span class="koboSpan" id="kobo.320.1">easy-to-use</span></em><span class="koboSpan" id="kobo.321.1"> web framework that is ideal </span><a id="_idIndexMarker1022"/><span class="koboSpan" id="kobo.322.1">for building </span><strong class="bold"><span class="koboSpan" id="kobo.323.1">RESTful</span></strong><span class="koboSpan" id="kobo.324.1"> APIs, while React is a popular and powerful frontend library that allows for the creation of complex and dynamic user interfaces. </span><span class="koboSpan" id="kobo.324.2">With these </span><a id="_idIndexMarker1023"/><span class="koboSpan" id="kobo.325.1">technologies, you can create high-performance, scalable web applications that are easy to maintain </span><span class="No-Break"><span class="koboSpan" id="kobo.326.1">and update.</span></span></p>
<p><span class="koboSpan" id="kobo.327.1">It’s time to unleash our imagination and explore the limitless potential of combining a Blueprint with a React frontend. </span><span class="koboSpan" id="kobo.327.2">Integrating a Flask backend with a React frontend involves setting up the communication between the two using API endpoints. </span><span class="koboSpan" id="kobo.327.3">We set up a typical Flask Blueprint, for instance, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.328.1">attendees</span></strong><span class="koboSpan" id="kobo.329.1"> Blueprint structure, </span><span class="No-Break"><span class="koboSpan" id="kobo.330.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.331.1">bizza\backend\blueprints\attendees-models
-attendee_blueprint.py</span></pre>
<p><span class="koboSpan" id="kobo.332.1">This route should serve as the entry point to the React app. </span><span class="koboSpan" id="kobo.332.2">Modify the existing Flask routes in </span><strong class="source-inline"><span class="koboSpan" id="kobo.333.1">attendees_blueprint.py</span></strong><span class="koboSpan" id="kobo.334.1"> to return JSON data instead </span><span class="No-Break"><span class="koboSpan" id="kobo.335.1">of HTML.</span></span></p>
<p><span class="koboSpan" id="kobo.336.1">In the React </span><a id="_idIndexMarker1024"/><span class="koboSpan" id="kobo.337.1">frontend, we will create an </span><strong class="source-inline"><span class="koboSpan" id="kobo.338.1">attendee</span></strong><span class="koboSpan" id="kobo.339.1"> component </span><a id="_idIndexMarker1025"/><span class="koboSpan" id="kobo.340.1">and make API calls to the Flask routes using a library such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.341.1">axios</span></strong><span class="koboSpan" id="kobo.342.1"> to retrieve the JSON data and render it in </span><span class="No-Break"><span class="koboSpan" id="kobo.343.1">the UI.</span></span></p>
<p><span class="koboSpan" id="kobo.344.1">The updated </span><strong class="source-inline"><span class="koboSpan" id="kobo.345.1">attendee_blueprint.py</span></strong><span class="koboSpan" id="kobo.346.1"> file is </span><span class="No-Break"><span class="koboSpan" id="kobo.347.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.348.1">from flask import Blueprint, jsonify, requestfrom bizza.backend.blueprints.attendees.models.attendee import Attendee
from bizza.backend.blueprints.attendees.forms import AttendeeForm, EditAttendeeForm
from bizza.backend.blueprints.attendees import db
attendee_bp = Blueprint('attendee', __name__, url_prefix='/api/attendees')
@attendee_bp.route('/', methods=['GET'])
def get_attendees():
    attendees = Attendee.query.all()
    return jsonify([a.to_dict() for a in attendees])
@attendee_bp.route('/&lt;int:attendee_id&gt;',
    methods=['DELETE'])
def delete_attendee(attendee_id):
    attendee = Attendee.query.get_or_404(attendee_id)
    db.session.delete(attendee)
    db.session.commit()
    return jsonify(success=True)</span></pre>
<p><span class="koboSpan" id="kobo.349.1">The preceding code defines a Flask Blueprint for managing attendees in the application. </span><span class="koboSpan" id="kobo.349.2">The Blueprint is registered at the </span><strong class="source-inline"><span class="koboSpan" id="kobo.350.1">/api/v1/attendees</span></strong><span class="koboSpan" id="kobo.351.1"> URL prefix. </span><span class="koboSpan" id="kobo.351.2">It includes routes for getting all attendees, adding a new attendee, getting a specific attendee, updating an existing attendee, and deleting </span><span class="No-Break"><span class="koboSpan" id="kobo.352.1">an attendee.</span></span></p>
<p><span class="koboSpan" id="kobo.353.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.354.1">get_attendees()</span></strong><span class="koboSpan" id="kobo.355.1"> function is decorated with </span><strong class="source-inline"><span class="koboSpan" id="kobo.356.1">@attendee_bp.route('/', methods=['GET'])</span></strong><span class="koboSpan" id="kobo.357.1">, which means it will handle </span><strong class="source-inline"><span class="koboSpan" id="kobo.358.1">GET</span></strong><span class="koboSpan" id="kobo.359.1"> requests to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.360.1">/api/v1/attendees/</span></strong><span class="koboSpan" id="kobo.361.1"> URL. </span><span class="koboSpan" id="kobo.361.2">It queries the database for all attendees, converts them into a dictionary using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.362.1">to_dict()</span></strong><span class="koboSpan" id="kobo.363.1"> method defined in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.364.1">Attendee</span></strong><span class="koboSpan" id="kobo.365.1"> model, and returns a JSON representation of the list </span><span class="No-Break"><span class="koboSpan" id="kobo.366.1">of attendees.</span></span></p>
<p><span class="koboSpan" id="kobo.367.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.368.1">add_attendee()</span></strong><span class="koboSpan" id="kobo.369.1"> function is decorated with </span><strong class="source-inline"><span class="koboSpan" id="kobo.370.1">@attendee_bp.route('/', methods=['POST'])</span></strong><span class="koboSpan" id="kobo.371.1">, which means it will handle </span><strong class="source-inline"><span class="koboSpan" id="kobo.372.1">POST</span></strong><span class="koboSpan" id="kobo.373.1"> requests to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.374.1">/api/v1/attendees/</span></strong><span class="koboSpan" id="kobo.375.1"> URL. </span><span class="koboSpan" id="kobo.375.2">It first creates an </span><strong class="source-inline"><span class="koboSpan" id="kobo.376.1">AttendeeForm</span></strong><span class="koboSpan" id="kobo.377.1"> object from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.378.1">POST</span></strong><span class="koboSpan" id="kobo.379.1"> request </span><a id="_idIndexMarker1026"/><span class="koboSpan" id="kobo.380.1">data. </span><span class="koboSpan" id="kobo.380.2">If the form data is valid, a new </span><a id="_idIndexMarker1027"/><span class="koboSpan" id="kobo.381.1">attendee is created using the form data and added to </span><span class="No-Break"><span class="koboSpan" id="kobo.382.1">the database.</span></span></p>
<p><span class="koboSpan" id="kobo.383.1">The new attendee is then converted into a dictionary using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.384.1">to_dict()</span></strong><span class="koboSpan" id="kobo.385.1"> method and returned as a JSON response. </span><span class="koboSpan" id="kobo.385.2">If the form data is not valid, the errors are returned as a </span><span class="No-Break"><span class="koboSpan" id="kobo.386.1">JSON response.</span></span></p>
<p><span class="koboSpan" id="kobo.387.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.388.1">get_attendee()</span></strong><span class="koboSpan" id="kobo.389.1"> function is decorated with </span><strong class="source-inline"><span class="koboSpan" id="kobo.390.1">@attendee_bp.route('/&lt;int:attendee_id&gt;', methods=['GET'])</span></strong><span class="koboSpan" id="kobo.391.1">, which means it will handle </span><strong class="source-inline"><span class="koboSpan" id="kobo.392.1">GET</span></strong><span class="koboSpan" id="kobo.393.1"> requests to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.394.1">/api/v1/attendees/&lt;attendee_id&gt;</span></strong><span class="koboSpan" id="kobo.395.1"> URL, where </span><strong class="source-inline"><span class="koboSpan" id="kobo.396.1">attendee_id</span></strong><span class="koboSpan" id="kobo.397.1"> is the ID of the specific attendee being requested. </span><span class="koboSpan" id="kobo.397.2">It queries the database for the attendee with the specified ID, converts it into a dictionary using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.398.1">to_dict()</span></strong><span class="koboSpan" id="kobo.399.1"> method, and returns a JSON representation of </span><span class="No-Break"><span class="koboSpan" id="kobo.400.1">the attendee.</span></span></p>
<p><span class="koboSpan" id="kobo.401.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.402.1">update_attendee()</span></strong><span class="koboSpan" id="kobo.403.1"> function is decorated with </span><strong class="source-inline"><span class="koboSpan" id="kobo.404.1">@attendee_bp.route('/&lt;int:attendee_id&gt;', methods=['PUT'])</span></strong><span class="koboSpan" id="kobo.405.1">, which means it will handle </span><strong class="source-inline"><span class="koboSpan" id="kobo.406.1">PUT</span></strong><span class="koboSpan" id="kobo.407.1"> requests to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.408.1">/api/v1/attendees/&lt;attendee_id&gt;</span></strong><span class="koboSpan" id="kobo.409.1"> URL. </span><span class="koboSpan" id="kobo.409.2">It first queries the database for the attendee with the specified ID. </span><span class="koboSpan" id="kobo.409.3">It then creates an </span><strong class="source-inline"><span class="koboSpan" id="kobo.410.1">EditAttendeeForm</span></strong><span class="koboSpan" id="kobo.411.1"> object from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.412.1">PUT</span></strong><span class="koboSpan" id="kobo.413.1"> request data, using the current attendee object as the </span><span class="No-Break"><span class="koboSpan" id="kobo.414.1">default value.</span></span></p>
<p><span class="koboSpan" id="kobo.415.1">If the form data is valid, the attendee object is updated with the new data and saved to the database. </span><span class="koboSpan" id="kobo.415.2">The updated attendee object is then converted into a dictionary using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.416.1">to_dict()</span></strong><span class="koboSpan" id="kobo.417.1"> method and returned as a JSON response. </span><span class="koboSpan" id="kobo.417.2">If the form data is not valid, the errors are returned as a </span><span class="No-Break"><span class="koboSpan" id="kobo.418.1">JSON response.</span></span></p>
<p><span class="koboSpan" id="kobo.419.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.420.1">delete_attendee()</span></strong><span class="koboSpan" id="kobo.421.1"> function is decorated with </span><strong class="source-inline"><span class="koboSpan" id="kobo.422.1">@attendee_bp.route('/&lt;int:attendee_id&gt;', methods=['DELETE'])</span></strong><span class="koboSpan" id="kobo.423.1">, which means it will handle </span><strong class="source-inline"><span class="koboSpan" id="kobo.424.1">DELETE</span></strong><span class="koboSpan" id="kobo.425.1"> requests to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.426.1">/api/v1/attendees/&lt;attendee_id&gt;</span></strong><span class="koboSpan" id="kobo.427.1"> URL. </span><span class="koboSpan" id="kobo.427.2">It queries the database for the attendee with the </span><a id="_idIndexMarker1028"/><span class="koboSpan" id="kobo.428.1">specified ID, deletes it from the </span><a id="_idIndexMarker1029"/><span class="koboSpan" id="kobo.429.1">database, and returns a JSON response </span><span class="No-Break"><span class="koboSpan" id="kobo.430.1">indicating success.</span></span></p>
<p><span class="koboSpan" id="kobo.431.1">The utilization of Flask Blueprints to handle the integration of a React frontend with a Flask backend offers numerous benefits in terms of code organization, modularity, scalability, and maintainability. </span><span class="koboSpan" id="kobo.431.2">This structured development approach facilitates seamless full stack development while maintaining a clear separation </span><span class="No-Break"><span class="koboSpan" id="kobo.432.1">of concerns.</span></span></p>
<h1 id="_idParaDest-258"><a id="_idTextAnchor297"/><span class="koboSpan" id="kobo.433.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.434.1">As we come to the end of this chapter, let’s take a moment to reflect on the exciting journey we’ve been on. </span><span class="koboSpan" id="kobo.434.2">The chapter explores modular architecture in web development and how Flask Blueprints can help build decoupled, reusable, maintainable, and testable Flask </span><span class="No-Break"><span class="koboSpan" id="kobo.435.1">web applications.</span></span></p>
<p><span class="koboSpan" id="kobo.436.1">The benefits of modularity, separation of concerns, and encapsulation remain key elements of modular architecture. </span><span class="koboSpan" id="kobo.436.2">In Flask, Blueprints organize a group of related views and other code into a single module. </span><span class="koboSpan" id="kobo.436.3">This chapter also covers setting up a Flask application with Blueprints. </span><span class="koboSpan" id="kobo.436.4">Finally, we discussed a very flexible way to build full stack web applications at scale with React frontend and </span><span class="No-Break"><span class="koboSpan" id="kobo.437.1">Flask Blueprints.</span></span></p>
<p><span class="koboSpan" id="kobo.438.1">Next, we will explore unit testing in Flask. </span><span class="koboSpan" id="kobo.438.2">Fasten up and let’s delve into the exciting world of testing in Flask </span><span class="No-Break"><span class="koboSpan" id="kobo.439.1">backend development.</span></span></p>
</div>
</body></html>