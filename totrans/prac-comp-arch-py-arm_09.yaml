- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Simulators for Other Architectures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you will learn how to create simulators for different instruction
    set architectures, for example, the stack-based computer and the classic CISC.
  prefs: []
  type: TYPE_NORMAL
- en: After describing a simple stack-based calculator, TC0, we will introduce a simulator
    for a one-address format. Most operations take place between an accumulator (i.e.,
    register) and the contents of a memory location; for example, `ADD Y` means *add
    the contents of memory location Y to the accumulator*. The term *accumulator*
    indicates the location where the result of an addition is *accumulated*. Early
    microprocessors lacked room on the silicon chip for multiple registers, and all
    data had to pass through one or two accumulators.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we will simulate a CISC architecture, which is an extension of the
    accumulator-based machine, where you can perform an operation on the contents
    of memory and on-chip registers.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we will present the code of TC4\. This is a simulator for a non-von
    Neumann machine with separate address and data memories and where the address
    and data word lengths differ.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'TC0: A Stack-Based Calculator'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'TC2: A One-Address Accumulator Machine'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'TC3: A CISC Machine with a Register-to-Memory Architecture'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Complete TC3 Code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arithmetic and Logic Unit (ALU)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A Final Example: TC4'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can find the programs used in this chapter on GitHub at [https://github.com/PacktPublishing/Practical-Computer-Architecture-with-Python-and-ARM/tree/main/Chapter08](https://github.com/PacktPublishing/Practical-Computer-Architecture-with-Python-and-ARM/tree/main/Chapter08).
  prefs: []
  type: TYPE_NORMAL
- en: 'TC0: A stack-based calculator'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ll begin with a very simple s*tack-based calculator*. Here, we’ll introduce
    a zero-address machine that avoids explicit operand addresses by storing data
    on a stack. We have included the notion of a stack-based computer for two reasons.
    First, it forms the basis of many classic calculators, a programming language
    (FORTH) and the design of a classic computer (Burroughs B5000). Second, constructing
    a stack-based computer is very easy and you can experiment with this class of
    computer. Indeed, elements of a stack-based processor can easily be incorporated
    into any computer. In a conventional computer, two elements are added with an
    operation such as `ADD A,B,C`. In a stack-based computer, two elements are added
    with `ADD`. There is no need for operand addresses because the elements to be
    added are the top two in a stack.
  prefs: []
  type: TYPE_NORMAL
- en: The computer we describe here is called TC0 to indicate that it is a proto-simulator,
    rather than a full simulator (it cannot execute conditional operations).
  prefs: []
  type: TYPE_NORMAL
- en: The stack is a data structure in the form of a queue. Items enter the queue
    at the top and leave the queue in the reverse order to that in which they entered.
    It’s called a *stack* because it behaves exactly like a stack of papers.
  prefs: []
  type: TYPE_NORMAL
- en: 'A stack provides two operations: *push*, in which an item is added to the stack,
    and *pull* (or *pop*), in which an item is removed from the stack.'
  prefs: []
  type: TYPE_NORMAL
- en: An operation on a single element (e.g., negate) is applied to the *top* element
    of the stack. An operation with two operands is applied to the two elements at
    the **Top of the Stack (TOS)**; for example, an addition is performed by pulling
    two operands off the stack, performing the addition, and then pushing the result
    back on the stack. *Figure 8**.1* demonstrates the behavior of the stack as we
    evaluate P = (A + B)×(C – B – D).
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1 – The sequence of actions taking place during the evaluation of
    (A + B)×(C – B – D)](img/Figure_8.1_B19624.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.1 – The sequence of actions taking place during the evaluation of (A
    + B)×(C – B – D)
  prefs: []
  type: TYPE_NORMAL
- en: '*Table 8.1* shows how we perform the P = (A + B)×(C – B – D) calculation using
    the `PUSH`, `PULL`, `ADD`, `SUB`, and `MUL` stack operations. As well as arithmetic
    operations, two other common stack operations are `DUP` (duplicate) and `SWAP`.
    The `DUP` operation makes a copy of the item at the TOS and pushes it on the stack
    (i.e., the top of the stack is duplicated). The `SWAP` operation exchanges the
    TOS and **Next on Stack (****NOS)** values.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Table 8.1 – The code to evaluate (A + B)×(C – B – D)
  prefs: []
  type: TYPE_NORMAL
- en: To simplify the simulator, each instruction is stored in a Python list consisting
    of the operation and memory address (for `PUSH` and `PULL`). This is not intended
    to be a practical simulator; it’s a demonstration of the use of the stack to handle
    arithmetic operations and an introduction to the stack for later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: A register called a `1231,` pushing an element on the stack stores it at address
    `1230`, since the stack grows toward low addresses.
  prefs: []
  type: TYPE_NORMAL
- en: 'In some implementations, the stack pointer points at the *next free location*
    above the top of the stack. We will represent the stack in Python by the list
    `stack[]`. The stack pointer is sp and the operation to push item A on the stack
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember that the stack pointer is decremented because the stack grows toward
    lower addresses. If an item is popped off the stack, the inverse operation is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: These are complementary operations. A pull operation cancels a push. Consider
    evaluating an expression. *Figure 8**.2* shows the state of the stack during the
    evaluation of `X = (A + B)×(C –` `D)`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2 – The sequence of actions taking place during the evaluation of
    X = (A + B)×(C – D)](img/Figure_8.2_B19624.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.2 – The sequence of actions taking place during the evaluation of X
    = (A + B)×(C – D)
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to demonstrate how we can implement a simple calculator, TC0,
    based on a stack.
  prefs: []
  type: TYPE_NORMAL
- en: 'TC0: A python stack machine'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can represent the addition `y3 = y1 + y2` on a stack machine in Python as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ve taken a shortcut. We could have pulled two elements off the stack, added
    them, and pushed the result. Instead, we put the result back where the second
    operand was and saved two stack pointer movements. The following Python code illustrates
    a very simple stack machine interpreter. It does not implement branch operations,
    so it is not a realistic computation machine. Because a stack machine often operates
    on the top of the stack and the element below it, the second element is frequently
    called NOS. Note that the program is stored as a list of lists, with each instruction
    consisting of either a two-element list (e.g., `[''push'', ''2''])` or a single-element
    list (e.g., `[''``mul'']`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output from this program, which shows the program counter,
    the top of the stack, NOS, the stack itself, the data, and the opcode being executed.
    Values that change between cycles are in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will look at a more realistic machine that implements
    a simple accumulator machine of the early 8-bit microprocessor era.
  prefs: []
  type: TYPE_NORMAL
- en: 'TC2: A one-address accumulator machine'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you will learn about a computer that implements a memory-to-register
    architecture. This is a very simple machine that implements a one-address instruction
    format (like an 8-bit CISC microprocessor from the 1970s).
  prefs: []
  type: TYPE_NORMAL
- en: The TC2 model can be used to simulate classic 8-bit microprocessors that are
    found in low-cost computer systems (e.g., controllers in mechanical devices).
    It also teaches you about the trade-off between simplicity (of the computer) and
    complexity (of the software that is constrained by the primitive architecture).
  prefs: []
  type: TYPE_NORMAL
- en: 'Unlike modern RISC architectures with data-processing operations between two
    registers, this computer implements a dyadic operation between one operand in
    the accumulator and the other operand, which is either a literal or the contents
    of memory; for example, `ADD M` adds the contents of memory location `M` to the
    accumulator, and `ADD #5` adds a literal to the contents of the accumulator. This
    computer does not have a large set of general-purpose registers.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The one-address machine permits operations between data in the accumulator
    and in memory. This contrasts with RISC architectures that permit data-processing
    operations only between registers. Load and store are the only memory operations
    permitted by a RISC architecture. This computer, TC2, implements a minimal instruction
    set that demonstrates its operation. Table 8.2 describes the instruction set:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Mnemonic | Action | Memory form | Literal form | Opcode |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `LDA` | Load accumulator | `[A]` ← `[``M]` | `[A]` ← `L` | `0` |'
  prefs: []
  type: TYPE_TB
- en: '| `STA` | Store accumulator | `[M]` ← `[``A]` | `[M]` ← `L` | `0` |'
  prefs: []
  type: TYPE_TB
- en: '| `ADD` | Add to accumulator | `[A]` ← `[A] + [``M]` | `[A]` ← `[A] + L` |
    `1` |'
  prefs: []
  type: TYPE_TB
- en: '| `SUB` | Subtract from accumulator | `[A]` ← `[A] - [``M]` | `[A]` ← `[A]
    – L` | `2` |'
  prefs: []
  type: TYPE_TB
- en: '| `CLR` | Load accumulator/memory with zero | `[A]` ← `0` | `[M]` ← `0` | `3`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `BRA` | Branch unconditionally to L | `[PC]` ← `L` |  | `4` |'
  prefs: []
  type: TYPE_TB
- en: '| `BEQ` | Branch on zero to L | `if Z = 1 then[PC]` ← `L` |  | `5` |'
  prefs: []
  type: TYPE_TB
- en: '| `BNE` | Branch on not zero to L | `if Z = 0 then[PC]` ← `L` |  | `6` |'
  prefs: []
  type: TYPE_TB
- en: '| `STOP` | Stop |  |  | `7` |'
  prefs: []
  type: TYPE_TB
- en: Table 8.2 – Typical operations of a register-to-memory computer
  prefs: []
  type: TYPE_NORMAL
- en: Here, `[A]` is the contents of the accumulator, `[M]` is the contents of memory
    location *M*, *L* is a literal, and the Z-bit is set if the result of a subtraction
    is zero. *M* and *L* represent the literal field of an instruction and are mutually
    exclusive. You can’t have an instruction with both an *M* and *L* operand.
  prefs: []
  type: TYPE_NORMAL
- en: Simulating a computer teaches us a lot about partitioning an instruction into
    various fields and how to implement instructions. In this example, we use a 3-bit
    opcode, a 1-bit *direction* flag (for `LDA` and `STA`) that defines the direction
    of data movement (to or from memory), and a 1-bit *mode* flag that selects either
    a literal or a direct memory access. A 5-bit numeric field provides an integer
    in the range 0 to 31, or a memory address. The instruction size is 10 bits with
    the format `CCC D M LLLLL`, where *CCC* is the opcode field, *D* is the direction
    bit, *M* is the mode bit, and *LLLLL* is the literal or memory address (*Figure
    8**.3*). The extreme simplicity of this makes it easy to write a tiny simulator
    and leaves the user with a lot of opportunities to expand the code into a more
    realistic machine.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.3 – TC2 instruction format](img/Figure_8.3_B19624.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.3 – TC2 instruction format
  prefs: []
  type: TYPE_NORMAL
- en: TC2 simulates a stored program computer with a single memory that holds both
    the program and data. The 32-bit location memory is initialized by memory = `[``0]*32`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The TC2 code has a setup section and a `while` loop that includes a fetch instruction
    and an execute instruction part. The structure of the `while` loop part of the
    code (instruction fetch/execute cycle) consists of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Within the while loop, we have a `fetch` phase followed by an execution phase.
    The `fetch` phase is identical to the CPUs we have already described. Instruction
    decoding is included in this phase. Instruction decoding separates OpCode, Dir
    (i.e., direction to or from memory), Mode, and Literal by using shifting and bit-masking
    operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Right shifts and ANDs extract fields from the instruction; for example, the
    3-bit opcode is extracted from the 10-bit `CCCDMLLLLL` instruction by shifting
    seven places left to get `0000000CCC`. The direction bit, Dir, is extracted by
    performing six left shifts to get `000000CCCD` and then ANDing the result with
    1 to get `000000000D`. These two operations can be combined and written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`(IR >> 6) & 1`      # 6-bit shift right with >> and AND with 1 using the AND
    operator, &'
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, we extract the mode bit by performing `Mode = (IR >> 5) & 1`. Finally,
    the literal is in place, so all we have to do is to clear the other bits by ANDing
    it with `0b0000011111`, that is, `IR &` `0x1F`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `execute` phase, the three op-code bits, `OpCode`, select one of the
    eight possible instructions. Of course, the use of `if … elif` would have been
    more appropriate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Each op-code is guarded by an `if` statement. Here’s the code for the load
    and store accumulator instruction. We treat this as one operation and use the
    direction flag, `Dir`, to select between `LDA` (direction memory to accumulator)
    and `STA` (direction accumulator to memory):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: To make it easier to read the code, we’ve divided it into two blocks (one shaded
    in dark gray and one in light gray) guarded by the if `Dir == 0` statement. When
    the direction flag is 0, the instruction is *load accumulator* and the address
    is copied to the `MAR`, a read is performed, and the data is copied to the `MBR`
    and then the accumulator. If the direction flag is 1, the instruction is a *store
    accumulator* and the accumulator is copied to the `MBR` and a write operation
    is carried out.
  prefs: []
  type: TYPE_NORMAL
- en: Note the use of the `Mode` flag. When loading the accumulator from memory, `LDA`,
    the mode flag is used to load the accumulator with either a literal or the contents
    of memory. When executing a `STA`, which refers to the store accumulator, the
    mode flag is ignored because only a memory store is possible.
  prefs: []
  type: TYPE_NORMAL
- en: We don’t need to describe the `ADD` and `SUB` operations because they are simply
    extensions of the load and store operations. We’ve included a clear operation,
    `CLR`, which sets either the accumulator to 0 or the contents of memory to 0 depending
    only on the `Mode` flag.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll now present the full simulator code. The `Memory[MAR]` notation means
    the contents of memory whose address is in the `MAR` and is conveniently identical
    to the RTL we’ve been using. In the execute instruction block, alternate opcodes
    are shaded gray and blue to facilitate reading.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve included a small program in memory, complete with data that tests several
    of the instructions, including load and store, add, subtract, and branch.
  prefs: []
  type: TYPE_NORMAL
- en: TC2 has a clear operation, `CLR`, that sets either the accumulator or the contents
    of memory to 0 depending on the Mode flag. This simplified computer has only a
    Z-bit (no N and C bits).
  prefs: []
  type: TYPE_NORMAL
- en: The branch group of instructions (`BRA`, `BEQ`, and `BNE`) load the program
    counter with a literal to force a jump. `BRA` performs an unconditional branch,
    and `BEQ`/`BNE` depending on the state of the Z-bit, which is set/cleared by add
    and subtract operations. The branch target address is an absolute address provided
    by the literal field.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have reserved the last instruction opcode, `111`, as a stop (halt) instruction
    that breaks out of the `while` loop and terminates execution. In general, a real
    CPU does not need a halt instruction, although a halt instruction can be used
    to force it into a power-down mode until it is awakened by an external event,
    such as a keyboard/mouse input or a screen touch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we’ve loaded memory with the program and set up some variables, we
    can enter the `fetch` `execute` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The following block (dark shading) implements a clear operation. This instruction
    is not strictly necessary, because you can always load a zero or subtract x from
    X. For this reason, some computers do not incorporate a clear instruction. Some
    computers allow you to write `CLR` and then substitute an operation such as `SUB
    X,X`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'You could argue that we should have inserted a break or exit here because if
    we haven’t encountered a valid op-code by the end of the `execute` loop, the source
    code must be invalid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We now run this program. The output when running this program is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Enhancing the TC2 Simulator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The simple example of an accumulator-based machine illustrates several aspects
    of the implementation of instructions, the design of the instruction set, and
    the allocation of bits. The TC2 has a 3-bit opcode giving us eight operations.
    Or does it?
  prefs: []
  type: TYPE_NORMAL
- en: 'The direction bit, Dir, is employed only by the `LDA`/`STA` instruction. If
    we removed this bit from the opcode field, we would have a 4-bit opcode giving
    16 instructions. Since `LDA` and `STA` would now be separate instructions, our
    eight-instruction computer would have nine instructions, leaving 16 – 9 = 7 new
    (i.e., unallocated) opcodes. We could have also used the direction flag with `ADD`
    and `SUB` instructions allowing the destination to be either the accumulator or
    memory. Consider the following example. The current TC2 simulator can increment
    variables *x* and *y* using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'By extending the addition operation (`ADDA` to add to the accumulator and `ADDM`
    to add to memory), we can now write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This enhancement halves the number of instructions, because we load the accumulator
    with the literal once and then add it to two different memory locations. The new
    code for the `ADD` operation is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'What else can we do to extend the instruction set? We allocated *three* opcodes
    to the branch group. That was very wasteful. Since each of these branch instructions
    has a direction and a mode bit that is unused, we can press these bits into service
    (i.e., redefine their meaning). Consider the arrangement of *Table 8.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Operation | Direction | Mode |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `BRA` | 0 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| Undefined | 0 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| `BEQ` | 1 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| `BNE` | 1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: Table 8.3 – Re-purposing the direction and mode bits
  prefs: []
  type: TYPE_NORMAL
- en: 'We have used the `Dir` and `Mode` instruction bits to select the branch type.
    As a bonus, we have a spare operation that is marked *undefined*. The code for
    the branch group is as follows. We’ve used shading to help identify the blocks.
    Note that in this example, we demonstrate how branches can be made program counter
    relative:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This code looks a little more complex than it is, because we have `if` statements
    nested four deep when we test for op-code, direction, mode, and then Z-bit. However,
    this example demonstrates how instruction bits can be reused to increase the number
    of instructions at the cost of decoding complexity.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s still room to maneuver and squeeze more functionality out of the instruction
    set. Look at the `CLR` instruction. We use the mode bit to clear memory or the
    accumulator. How about being a little creative and using the *direction* bit to
    provide another operation? Incrementing a register or memory is a common operation,
    so let’s provide that. We can use `Dir == 0` for `CLR` and `Dir == 1` for `INC`
    Memory/accumulator. The block shaded in gray is the original clear and the block
    shaded in blue is the new increment operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Finally, consider the `STOP` (halt) instruction with the `111DMLLLLL` opcode.
    Here, we have 7 bits doing nothing. That is 27 = 128 combinations. If we were
    to reserve one code for halt, say, `1110000000`, we could allocate codes 1110000001
    to `1111111111` to new instructions. The next section extends this architecture
    to create a more realistic simulator.
  prefs: []
  type: TYPE_NORMAL
- en: 'TC3: A CISC machine with a register-to-memory architecture'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you will learn about the design of a simulator that implements
    a CISC-style instruction set architecture, providing both register-to-register
    and register-to-memory operations. TC3 is a more sophisticated version of TC2
    with a more practical architecture.
  prefs: []
  type: TYPE_NORMAL
- en: 'TC3 supports register direct, register indirect, memory direct, and literal
    addressing modes. For example, `AND [R2], #129` performs a logical `AND` between
    the contents of the memory location pointed at by register `R2` and the binary
    value `10000001`.'
  prefs: []
  type: TYPE_NORMAL
- en: We have included memory direct operations. These are intended to illustrate
    the features of a computer, rather than being practical. Early 8-bit microprocessors
    like the Motorola 6800 let you operate on memory directly. Most modern processors
    don’t. TC3 can access, say, memory at location 12 with `MOV` R2,`M:12`. This instruction
    loads register 2 with the contents of memory location 12\. Note the syntax. A
    TC3 instruction provides a single literal field that can serve as a literal or
    a memory address, but not both at the same time. I’ve used `#` to indicate a literal
    and `M:` to indicate a memory address; consider `MOV` R2,`M:12` and `MOV` R2,`#12`.
    The former loads register `R2` with the contents of memory location `12`, and
    the latter loads `R2` with the integer `12`. With a single literal field in the
    instruction, TC3 can’t support an instruction like `MOV M:12,#127.`
  prefs: []
  type: TYPE_NORMAL
- en: The TC3 instruction set architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The TC3 simulator is a one-and-a-half address CISC processor with a 24-bit instruction
    and an 8-bit data word length. This makes it a Harvard machine, because it has
    separate data and program memory. We have taken this approach for two reasons.
    First, an 8-bit data word is easy to work with from an educational point of view.
    Second, a 24-bit instruction provides functionality, without either using a large
    32-bit word or employing variable-length instructions like some CISC processors.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 8**.4* describes the TC3’s instruction format, which has an instruction
    class and an op-code field, an addressing mode field, two register fields, and
    a literal field. The format is the same for all instructions.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.4 – Instruction format of the TC3](img/Figure_8.4_B19624.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.4 – Instruction format of the TC3
  prefs: []
  type: TYPE_NORMAL
- en: We use 8-bit registers, an 8-bit address, and an 8-bit literal to simplify the
    design. The data space is restricted to 28 = 256 locations, since the literal
    can access only 256 locations. Changing the instruction width to 32 bits and expanding
    the literal to 16 bits would provide a data space of 65,536 locations.
  prefs: []
  type: TYPE_NORMAL
- en: The TC3 has eight general-purpose registers, `R0` to `R7`. It requires 6 bits
    to provide source and destination register fields The instruction field is 6 bits
    wide and is divided into a 2-bit instruction-class field and a 4-bit op-code field.
    This allows up to 64 instructions with a maximum of 16 in each class. We took
    this approach (instruction class and op-code) to simplify the design. This is
    a rather inefficient approach in terms of instruction-space usage, because most
    instructions fall within one class and other classes are nearly empty.
  prefs: []
  type: TYPE_NORMAL
- en: 'The 4-bit mode field defines an instruction’s attributes (e.g., addressing
    modes). The TC3 supports the addressing modes defined by *Table 8.4*, that is,
    no-operand instructions, one-register instructions, instructions with a literal,
    and two-operand instructions. Although the TC3 supports only two operands (register
    + register and register + literal), there are three fields in the instruction.
    Consequently, the computer could be easily modified to provide three-operand instructions.
    We chose this approach to simplify instruction encoding and decoding. An alternative
    approach would be to provide two operand fields – a register field and a register
    or literal field:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Mode** | **Address** | **Example** | **RTL** | **Class** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | No operand | `STOP` |  | `0` |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | Single register | `INC R1` | `[R1]` ← `[R1] + 1` | `1` |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | Literal offset | `BEQ 123` | `[pc]` ← `123` | `2` |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | Reserved |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | Literal to register | `MOV R1,#M` | `[R1]` ← `M` | `3` |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | Register to register | `MOV R1,R2` | `[R1]` ← `[``R2]` | `3` |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | Register indirect to register | `MOV R1,[R2]` | `[R1]` ← `[[``R2]]` |
    `3` |'
  prefs: []
  type: TYPE_TB
- en: '| 7 | Register to register indirect | `MOV [R1],R2` | `[[R1]]` ← `[``R2]` |
    `3` |'
  prefs: []
  type: TYPE_TB
- en: '| 8 | Register indirect to register indirect | `MOV [R1],[R2]` | `[[R1]]` ←
    `[[``R2]]` | `3` |'
  prefs: []
  type: TYPE_TB
- en: '| 9 | Register to memory | `MOV M:123,R2` | `M[123] ← [``R2]` | `3` |'
  prefs: []
  type: TYPE_TB
- en: '| 10 | Register indirect to memory | `MOV M:123,[R2]` | `M[123]` ← `[[``R2]]`
    | `3` |'
  prefs: []
  type: TYPE_TB
- en: '| 11 | Memory to register | `MOV R1,M:123` | `[R1]` ← `M[123]` | `3` |'
  prefs: []
  type: TYPE_TB
- en: '| 12 | Memory to register indirect | `MOV [R1],M:123` | `[[R1]]` ← `M[123]`
    | `3` |'
  prefs: []
  type: TYPE_TB
- en: '| 13-15 | Reserved |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: Table 8.4 – TC3 processor addressing modes
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following assembly language program that runs on this computer.
    We wish to add together two vectors plus an integer, that is, *z*i = xi + yi +
    5 for *i* = 0 to 3\. The following code should be largely self-explanatory. Literals
    are prefixed with #, and a label in an instruction is terminated with a colon.
    The first part of the code uses the `RND R5` instruction to fill vectors `X` and
    `Y` with random numbers to aid testing.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This example uses literal, register direct, and register indirect (pointer-based)
    addressing. We have provided the binary code of each instruction with the class,
    op-code, addressing mode, registers, and literal fields.
  prefs: []
  type: TYPE_NORMAL
- en: Initially, we didn’t construct an assembler for this simulator. However, it
    was such a pain to hand-code the instructions that an assembler was incorporated.
    The key to both the assembler and simulator is the `mode` field of the instruction,
    which indicates the addressing mode.
  prefs: []
  type: TYPE_NORMAL
- en: When an instruction in mnemonic form is read, it is examined, and its addressing
    modes and operands are used to determine the four mode bits required by the instruction.
    The reverse action is carried out when the instruction is executed, and the mode
    bits are used to implement the appropriate addressing modes. For example, if the
    instruction is `LDR` `R6,#5`, the mode is `4` and the assembler stores `6` in
    the first register field and `5` in the literal field. When the instruction is
    executed, the simulator uses the mode bits, `0100`, to determine that the destination
    register is `110` and the literal is `00000101`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first part of the TC3 simulator is given as follows. We create two lists:
    one for the program memory and one for the data memory (pMem and dMem). The instructions
    in program memory are imported from a file. The data memory is set up as 16 locations
    that are initialized to 0\. The text file containing the source program is src
    and is processed to reformat instructions and remove assembler directives.'
  prefs: []
  type: TYPE_NORMAL
- en: The shaded section of the code was added to detect the `'END'` directive in
    the source code, which terminates the assembly processing and acts as a `STOP`
    when the code is executed. I added it for convenience. I sometimes want to test
    one or two instructions but don’t want to write a new source code program. I can
    put the code under test at the top of an existing program, followed by `END`.
    All code after `END` is ignored. Later, I can delete the new code and `END`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The following code takes an instruction in assembly language form, tokenizes
    it, and converts it into the bit pattern of an instruction. In the following code,
    we use ic as the instruction counter, which steps through the source program line
    by line.
  prefs: []
  type: TYPE_NORMAL
- en: 'One issue we must deal with is the label. Some instructions have one and some
    don’t. That means that the mnemonic is token `0` for an instruction without a
    label, and token `1` if there is a label. The Python code checks for a label (which
    ends in a colon). If a label is found, `j` is set to `1`, and, if not found, `j`
    is set to `0`. We then use `j` to calculate the location of tokens in the instruction.
    The tLen variable is the number of tokens in an instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The next section of the assembler does all the work. Here, we generate the
    binary code. Unlike other simulators we’ve developed, we use directories and lists
    to detect registers, as the following (partial) code shows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can take a token and ask whether it’s in `rName` to detect `R0` to
    `R7`, or whether it’s in `rNamInd` to detect whether it’s `[R0]` to `[R7]`. Moreover,
    we can use the mnemonic from an instruction and ask whether it’s in each class
    in turn in order to determine the two class bits of the instruction; for example,
    if `t0` is the first token (corresponding to the mnemonic), we can write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, we can use if t1 in `rNamInd` to determine whether the second token
    is a register used as a pointer (e.g., `[R4]`).
  prefs: []
  type: TYPE_NORMAL
- en: 'The most complex class of instructions is `iClass3`, which deals with two-operand
    instructions, such as `ADD [R3],R4`. In this case, token `t0` would be `''ADD''`,
    token `t1` would be `''``[r3]''`, and token `t2` would be `''R4''`. To identify
    the class of this instruction, we look for a first operand, which is an indirect
    register, and a second operand, which is a register, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The code that determines the mode of an instruction is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: After extracting the instruction class, op-code, and mode, the final step is
    to get the actual register numbers and any literals. In the following fragment
    of code, we define the two register fields and the literal field, respectively.
    These are `rField1`, `rField2`, and `lField` and are all initialized to `0`, because
    instructions without three fields have the corresponding bits set to `0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we use the list as a very convenient method for extracting fields rather
    than combined if and or operators. For example, register field `1` is used by
    modes `4`, `5`, `6`, and `11`. We could write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'However, we can write instead, which is far easier to read:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code shows how the three register/literal fields are evaluated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The following two lines of the code-generation logic insert the register/literal
    fields by shifting and executing OR on bits and append the current binary instruction,
    binC, to the program memory, pMem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Features of the simulator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The simulator part of TC3 is relatively straightforward. Here, I’ll simply provide
    a few comments on some of its features to aid in understanding the code.
  prefs: []
  type: TYPE_NORMAL
- en: '**1.** **Printing data**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The number of items to be displayed increased during the simulator’s development.
    So, we created a list of strings, one for each item to be printed, and then concatenated
    the items. For example, this is the print mechanism I used to display data during
    assembly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The `displayLevel` parameter is included to determine what information was
    printed during the assembly process. For example, we could write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This would print binary code only when debugging is required by setting the
    variable to `5` or greater.
  prefs: []
  type: TYPE_NORMAL
- en: '**2. Implementing add** **with carry**'
  prefs: []
  type: TYPE_NORMAL
- en: 'When I implemented the ALU with its numbered functions, I initially forgot
    to include `ADC`, add with carry. Rather than renumbering the functions, I converted
    the `ADD` into a dual `ADD`/`ADC` operation by first performing an addition. Then,
    if the op-code was an `ADC`, add the carry bit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '**3. Dealing with simple** **instruction classes**'
  prefs: []
  type: TYPE_NORMAL
- en: Here is the code used to deal with class 1 instructions. We do not have to worry
    about decoding the mode as there is only one mode for this class. Of course, the
    class could be extended (in the future) by the addition of other modes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Class 1 instructions have an op-code and literal and are generally used to implement
    branch operations. Notice that we compare the current instruction with a name
    (e.g., `'BRA'`) rather than an op-code, as we did in other simulators. The use
    of a table of reverse op-code-to-mnemonic translations makes life much easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have added a `CZN` (carry zero negative) instruction, which allows us to
    preset condition codes; for example, `CZN #%101` sets `c` and `n` to `1`, and
    `z` to `0`. Computers often have an operation that allows you to test condition
    codes, clear them, set them, and toggle (flip) them.'
  prefs: []
  type: TYPE_NORMAL
- en: '**4.** **Handling literals**'
  prefs: []
  type: TYPE_NORMAL
- en: 'TC3’s numeric values can be expressed in several formats, for example, binary,
    where we represent `8` by `%1000`. Literal processing in TC3 must also deal with
    special formats, such as M:12, which indicates a memory address. The following
    function performs all the literal processing and handles several formats. It can
    also deal with literals that are symbolic names that must be looked up in the
    symbol table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '**5.** **Result Writeback**'
  prefs: []
  type: TYPE_NORMAL
- en: 'After performing an ALU operation or a data movement, the resulting operand
    must be written back into the computer. However, because we have specified a two-operand
    CISC-style format, the result of a calculation can be written to a register (like
    any RISC operation), it can be written to a memory location pointed at by a register,
    or it can be written to a memory operation specified by its address. The following
    fragment of code demonstrates TC3’s writeback:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Sample output
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following is a sample of the output from the simulator that demonstrates
    integer handling. We have written a program with six different ways of inputting
    a literal. In each case, we load the literal into register `r0`. The source program
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following code block, we have the output of TC3\. This output has been
    designed for the purpose of developing and testing the simulator (for example,
    following the assembly process):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output during the assembly and analysis phase:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following code block, we have the single-step execution output. It’s
    been edited to help fit it on the page. We printed only two memory locations for
    each line. The literal in the instruction and its value in `r0` are printed in
    bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The complete TC3 code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have discussed the design of TC3\. Here, we present the code of a complete
    simulator. There are some slight differences between the descriptive fragments
    of code we described in the previous section and this more complete simulator.
    This is followed by a sample run of the simulator. The first part of the code
    defines the instruction modes and provides a simple source program that will be
    executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The following block contains the dictionaries for instruction decoding and register
    lookup. We’ve provided reverse lookup so that you can look up a mnemonic to get
    its code or look up the code to get the mnemonic. Similarly, we’ve provided lookup
    for registers, such as `R0` and `R2`, and indirect registers, such as `[R0]` and
    `[R1]:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The following two functions provide the ability to read integer operands in
    various formats, and an ALU that performs arithmetic and logic operations. Both
    of these functions can be expanded to provide additional capabilities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The `trace()` function prints the state of the processor as a program is executed.
    This can be modified to change the amount, layout, and format of the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the instruction execution part of the program. Note that instructions
    are executed in the order of their class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: A sample run of TC3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here is the output from a sample run of TC3\. We have provided the source code
    that is executed, the equate and branch table, the assembled code, and then the
    output of a run:'
  prefs: []
  type: TYPE_NORMAL
- en: Source code
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Equate and branch table
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Assembly loop
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: EXECUTE
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We have provided only a few lines of the traced output and reformatted them
    to fit on the page.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Output not displayed to save space
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll look at one component of simulators in greater detail,
    the ALU.
  prefs: []
  type: TYPE_NORMAL
- en: Arithmetic and Logic Unit (ALU)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: And now for something different. We have used an ALU in all the simulators.
    Here, you will learn about the ALU in greater detail and about its testing.
  prefs: []
  type: TYPE_NORMAL
- en: The following Python code demonstrates the implementation of an 8-bit, 16-function
    ALU. We have added several *contemporary operations* that some computers provide,
    such as modulus, minimum, and maximum. The alu function is called with the `op`,
    `a`, `b`, `cIn`, and `display` parameters. The `op` parameter is in the range
    0 to 15 and defines the function. The `a` and `b` parameters are two 8-bit integers
    in the range 0 to 255, `cin` is a carry in, and `display` is a flag. When display
    is `0`, no data is printed. When `display` is `1`, the inputs and results are
    printed by the function. This feature is for debugging.
  prefs: []
  type: TYPE_NORMAL
- en: 'This code demonstrates the use of Python’s if...elif construct to decode the
    arithmetic operation. We have also included a *dictionary structure* that enables
    us to print out the operation code by name. In this case, the dictionary is `allOps`
    and is written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Another feature is that we can easily print data in binary form. The `print(bin(c))`
    operation prints `c` in binary form. However, because we are using 8-bit arithmetic
    and wish to see leading zeros, we can force an 8-bit output by using the zfill;
    that is `print(bin(c).zfill(8))` method.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, we can use `print('Result', format(c,'08b'))` to print the `c`
    variable as an 8-bit binary string.
  prefs: []
  type: TYPE_NORMAL
- en: 'A Python function can return multiple values as a *tuple*. A tuple is a Python
    list of immutable values that cannot be changed; for example, if you write return
    (`c`, `z`, `n`, `v` `cOut`), you are returning a tuple that consists of the function
    we calculated and the `z`, `n`, `v`, and `cOut` flags. These can’t be changed,
    but they can be assigned to variables in the calling program; take the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Note the calculation of overflow. The `v-bit` is set if the sign bits of the
    two operands are the same and the sign bit of the result is different. Overflow
    is valid only for addition and subtraction. The modulus function returns a positive
    value if the input parameter is negative in two’s complement terms. We do this
    by inverting the bits and adding 1.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Testing the ALU
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will now demonstrate testing the ALU. A `while` loop is created and two integers
    are inputted using Python’s keyboard input function and the `.split()` method
    to divide the input string into substrings. For example, you can enter add 3 5
    to perform the addition of 3 and 5\. A null input (i.e., a return) ends the sequence.
  prefs: []
  type: TYPE_NORMAL
- en: I have arranged the code so that you can see only the parameters entered as
    needed for the operation, for example, add 3,7, mod 5, or sbc 3 4 1\. To make
    it easier to test logic functions, you can enter parameters in binary `(%10110`)
    or hexadecimal `($``3B`) format.
  prefs: []
  type: TYPE_NORMAL
- en: A feature of the test code is that I use a reverse dictionary. This allows you
    to enter a function by its name, rather than number.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the code I used to test the ALU:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s some sample output from a test run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'A final example: TC4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this example, we provide a new simulator that introduces you to some new
    elements of Python, such as the ability to include the date and time. This final
    example of a computer simulator brings some of the things we have discussed together
    and creates a simulator with a 32-bit instruction memory and a 16-bit data memory.
    Consequently, this is not a von Neumann machine because it has different program
    and data memories. TC4 incorporates several modifications to demonstrate both
    simplifications and additions.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll present the code first and then add some comments via the labels that
    indicate points of interest. Shaded parts of the code have comments following
    the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'The `memProc()` function deals with the data memory and allows you to store
    data in memory and even ASCII code. This function processes assembler directives:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The `get_reg()` function determines the number of a register. It first looks
    in the symbol table to determine whether the name is symbolic. Otherwise, it extracts
    the register number from the predicate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'The `get_lit()` function extracts a literal from the predicate. As in the case
    of register names, it is able to deal with symbolic values by first looking for
    the name in the symbol table. If there is no symbolic name, the text is converted
    into the appropriate integer by observing and dealing with any prefixes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'The `display()` function takes care of displaying data after each instruction
    has been executed. In this case, the data values are converted into hexadecimal
    format and turned into strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'The `alu()` function performs arithmetic operations. This example is very rudimentary
    and provides only basic operations. Since we have covered ALU elsewhere, it’s
    not necessary to be comprehensive. You can easily add new functions yourself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we carry out the usual cleaning up of the source text in the assembly
    language file and prepare the text for later parsing and analysis. Note that we
    use a regular expression to remove multiple spaces. This is a feature we do not
    use in this book, but it is worthwhile investigating if you are doing extensive
    text processing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Now, we execute the code. The program counter is first initialized to 0\. Of
    course, we could have started at any arbitrary point or even provided assembly
    language directives to preset the pc. After setting the pc, we read an instruction
    and parse it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can use `opFormat` to extract the required parameters from the predicate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example of a simulator, we create the binary code to be executed. The
    various parameters extracted from the predicate have to be moved into the appropriate
    place to create the final binary code, `binCode`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'This block initializes variables, registers, memory, and the stack pointer
    before we enter the code execution loop. Note that we create a stack with 16 entries.
    The stack pointer is set to `16`, which is one below the bottom of the stack.
    When the first item is pushed, the stack pointer is pre-decremented to `15`, the
    bottom of the available stack area:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the instructions are executed. Note we used an `if` statement for each
    instruction. This was used during the initial development phase. In practice,
    an if...elif structure would be more suitable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following code we’ve included stack-based operations for the sake of
    demonstrating stack usage and for versatility:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Comments on TC4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have not provided a detailed discussion of this program because it follows
    the same pattern as earlier simulators. However, we have highlighted some of its
    principal features. The following numbers correspond to the numbers (at the end
    of the comment field) in the shaded lines of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: Call regular expressions library. This is a library that handles regular expressions
    that offer a very powerful means of processing text. In this example, we use only
    one simple example of regular text processing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `src = [re.sub(' +', ' ',i) for i in src ]` Python expression uses a regular
    expression to remove multiple spaces from a text string. We have included this
    to point you in the direction of regular expressions for more sophisticated text
    manipulation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `from datetime import date` operation imports a method date from datetime
    that can be used to display the date and time. This is useful for labeling your
    output during a run.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: TC4 has an optional debugging facility. We can select three options. Entering
    ‘D’ provides a debugging facility by printing the source program as it is processed.
    We can see the original source code, the source code without comments and assembly
    directives, and the processed version, which includes the binary output after
    assembly. The ‘T’ option provides a line-by-line trace function that executes
    a line of code each time the *Enter* key is pressed. The ‘B’ option supports breakpoints
    where the output is printed only at a breakpoint. The breakpoint may be a label,
    a mnemonic, or the PC value. Note that in breakpoint mode, only breakpoint lines
    are displayed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Entering `T` or `B` at the prompt can be used to set up a trace mode or enter
    instructions or PC values into the breakpoint table. Unusually, this is performed
    once at the beginning of the program and not during the execution phase.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The function processes the source code and deals with assembly directives related
    to setting up the data memory, for example, loading data values with the `.WORD`
    directive. It also supports storing an ASCII character in memory and reserving
    a named memory location for data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The most important directive is `.WORD`, which stores a numeric value in memory
    and gives that address a symbolic value. For example, if the next free data memory
    location were `20`, then the`.WORD TIME 100` expression would store the number
    `100` at memory location `20` and bind the name `time` to `100`. The`.DSW` (define
    storage word) directive simply reserves memory locations for future data access
    and names the address of the first location; for example, if the current memory
    location is `10`, then `.DSW XYZ 5` frees five memory locations (`10`, `11`, `12`,
    `13`, and `14`) and binds the names `XYZ` to `10`. The memory pointer is moved
    to `15`, the next free location. The `memPoint` variable is the memory pointer
    that keeps track of where data is to be stored in data memory during the assembly
    phase. The `.ASCII` directive is there for demonstration purposes. The `.ASCII
    PQR` directive would store the ASCII code for the character `'T'` in memory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: These directives are removed from the source code after they have done their
    job.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We have created a very simple ALU that implements only add and subtract. This
    was done to keep the program small and concentrate on more interesting instructions
    in this final example. Simple logic operations are directly implemented in the
    code execution of the program, in the style
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`if thisOpcode == ''AND'': result = a & b`.'
  prefs: []
  type: TYPE_NORMAL
- en: TC4 provides several stack operations (push and pull). We initially create a
    separate stack. TC4’s stack does not use the data memory. This feature is for
    demonstration and can be expanded.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Real computers normally contain a far wider range of conditional branches than
    we have in this book. Here, we demonstrate one such branch operation, `BHS`, which
    means branch if higher or same. This operation forces a branch if two values are
    compared and `x` > `y` or `x` = `y`. Note that this applies to unsigned numbers
    (i.e., not two’s complement). This condition is met if the carry bit, `c`, is
    `0` after a comparison. `BHS` and `BCC` (branch on carry 0) are synonyms. For
    example, if `x = 1000` and `y = 0100`, `x` > `y` if the numbers are unsigned (4
    > -8) and y > `x` (8 > 4) if the numbers are signed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `LDRI+` operation performs a pointer-based load register operation and then
    increments the pointer register.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We have provided an interesting branch and return operation like that of the
    ARM’s branch with link. The `BL` operation jumps to a target address and saves
    the return address in a special register called the link register, `rl`. At the
    end of the subroutine, the `RL` (return from link) instruction returns to the
    instruction after the call. This mechanism allows only one call, because a second
    call would overwrite the return address in the link register.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To demonstrate direct printing, the `PRT` operation displays the character corresponding
    to the ASCII code in the register; for example, if R1 contains 0x42, the `PRT
    R2` operation would display `B` on the console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the program has been executed, the `sys.exit()` library function exits
    the program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here’s an example of code that can be executed by TC4\. It’s been badly set
    out in order to test TC4’s ability to process text:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This example ends the section of this book on designing simulators in Python.
    In the next part, we’ll look at a real computer.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have extended our overview of simulator design. We started
    with one of the simplest simulators of them all, the *zero-address machine*; that
    is, the *stack computer*, TC0\. This simulator is not a true computer, because
    it does not include conditional and branch operations. However, it demonstrates
    the use of the stack as a means of performing chained calculations.
  prefs: []
  type: TYPE_NORMAL
- en: We then looked at the instruction set architecture (IAS) of a classic 8-bit
    computer, with its simple one-address instruction format, where all operations
    are applied to a single accumulator (i.e., register) and the contents of a memory
    location or a literal.
  prefs: []
  type: TYPE_NORMAL
- en: The one-address machine is followed by the simulation of a multi-register CISC
    ISA that allows operations between two registers or between a register and the
    contents of a memory location. The simulator we developed had a 22-bit address
    just to demonstrate that you can have instructions of any width.
  prefs: []
  type: TYPE_NORMAL
- en: We also looked at the simulator of an ALU to further demonstrate the way in
    which arithmetic operations can be simulated.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we presented a register-to-register machine with separate data and
    instruction memories.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll change course and introduce the ARM-based Raspberry
    Pi microprocessor, which can be used to write programs in Python, and learn how
    to program a real 32-bit ARM microprocessor in assembly language.
  prefs: []
  type: TYPE_NORMAL
