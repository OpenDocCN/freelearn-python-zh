<html><head></head><body>
<div id="_idContainer037">
<h1 class="chapter-number" id="_idParaDest-147"><a id="_idTextAnchor273"/><a id="_idTextAnchor274"/><span class="koboSpan" id="kobo.1.1">5</span></h1>
<h1 id="_idParaDest-148"><a id="_idTextAnchor275"/><span class="koboSpan" id="kobo.2.1">Web Forms with WTForms</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Form handling is an integral part of any web application. </span><span class="koboSpan" id="kobo.3.2">There can be innumerable cases that make the presence of forms in any web app very important. </span><span class="koboSpan" id="kobo.3.3">Some cases may include situations where users need to log in or submit some data, or where applications might require input from users. </span><span class="koboSpan" id="kobo.3.4">As much as forms are important, their validation holds equal importance, if not more. </span><span class="koboSpan" id="kobo.3.5">Presenting this information to users in an interactive fashion adds a lot of value to </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">the application.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">There are various ways in which we can design and implement forms in a web application. </span><span class="koboSpan" id="kobo.5.2">As web applications have matured, form validation and communicating the correct messages to a user have become very important. </span><span class="koboSpan" id="kobo.5.3">Client-side validations can be implemented at the frontend using JavaScript and HTML5. </span><span class="koboSpan" id="kobo.5.4">Server-side validations have a more important role in adding security to an application, rather than being user-interactive. </span><span class="koboSpan" id="kobo.5.5">Server-side validations prevent any incorrect data from going through to the database and, hence, curb fraud </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">and attacks.</span></span></p>
<p><span class="koboSpan" id="kobo.7.1">WTForms provides many fields with server-side validation by default and, hence, increases development speed and decreases the overall effort required. </span><span class="koboSpan" id="kobo.7.2">It also provides the flexibility to write custom validations and custom fields </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">as required.</span></span></p>
<p><span class="koboSpan" id="kobo.9.1">We will use </span><a id="_idIndexMarker188"/><span class="koboSpan" id="kobo.10.1">a Flask extension in this chapter. </span><span class="koboSpan" id="kobo.10.2">This extension is called Flask-WTF (</span><a href="https://flask-wtf.readthedocs.io/en/latest/"><span class="koboSpan" id="kobo.11.1">https://flask-wtf.readthedocs.io/en/latest/</span></a><span class="koboSpan" id="kobo.12.1">); it provides integration between WTForms and Flask, taking care of important and trivial stuff that we would have to otherwise reinvent in order to make our application secure and effective. </span><span class="koboSpan" id="kobo.12.2">We can install it using the </span><span class="No-Break"><span class="koboSpan" id="kobo.13.1">following command:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.14.1">
$ pip install Flask-WTF</span></pre>
<p><span class="koboSpan" id="kobo.15.1">In this chapter, we will cover the </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">following recipes:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.17.1">Representing SQLAlchemy model data as </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">a form</span></span></li>
<li><span class="koboSpan" id="kobo.19.1">Validating fields on the </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">server side</span></span></li>
<li><span class="koboSpan" id="kobo.21.1">Creating a common </span><span class="No-Break"><span class="koboSpan" id="kobo.22.1">form set</span></span></li>
<li><span class="koboSpan" id="kobo.23.1">Creating custom fields </span><span class="No-Break"><span class="koboSpan" id="kobo.24.1">and validations</span></span></li>
<li><span class="koboSpan" id="kobo.25.1">Creating a </span><span class="No-Break"><span class="koboSpan" id="kobo.26.1">custom widget</span></span></li>
<li><span class="koboSpan" id="kobo.27.1">Uploading files </span><span class="No-Break"><span class="koboSpan" id="kobo.28.1">via forms</span></span></li>
<li><span class="koboSpan" id="kobo.29.1">Protecting </span><a id="_idIndexMarker189"/><span class="koboSpan" id="kobo.30.1">applications from </span><strong class="bold"><span class="koboSpan" id="kobo.31.1">cross-site request </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.32.1">forgery</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.33.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.34.1">CSRF</span><a id="_idTextAnchor276"/></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.35.1">)</span></span></li>
</ul>
<h1 id="_idParaDest-149"><a id="_idTextAnchor277"/><span class="koboSpan" id="kobo.36.1">Representing SQLAlchemy model data as a form</span></h1>
<p><span class="koboSpan" id="kobo.37.1">First, let’s </span><a id="_idIndexMarker190"/><span class="koboSpan" id="kobo.38.1">build a form using a SQLAlchemy model. </span><span class="koboSpan" id="kobo.38.2">In this recipe, we will take the product model from our catalog application used previously in this book and add functionality, creating products from the frontend using a </span><span class="No-Break"><span class="koboSpan" id="kobo.39.1">web for</span><a id="_idTextAnchor278"/><span class="koboSpan" id="kobo.40.1">m.</span></span></p>
<h2 id="_idParaDest-150"><a id="_idTextAnchor279"/><span class="koboSpan" id="kobo.41.1">Getting ready</span></h2>
<p><span class="koboSpan" id="kobo.42.1">We will use our catalog application from </span><a href="B19111_04.xhtml#_idTextAnchor184"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.43.1">Chapter 4</span></em></span></a><span class="koboSpan" id="kobo.44.1">, </span><em class="italic"><span class="koboSpan" id="kobo.45.1">Working with Views</span></em><span class="koboSpan" id="kobo.46.1">, and we will develop a form for the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.47.1">Product</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.48.1"> mode</span><a id="_idTextAnchor280"/><span class="koboSpan" id="kobo.49.1">l.</span></span></p>
<h2 id="_idParaDest-151"><a id="_idTextAnchor281"/><span class="koboSpan" id="kobo.50.1">How to do it...</span></h2>
<p><span class="koboSpan" id="kobo.51.1">If you recall, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.52.1">Product</span></strong><span class="koboSpan" id="kobo.53.1"> model looks like the following lines of code in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.54.1">models.py</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.55.1"> file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.56.1">
class Product(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(255))
    price = db.Column(db.Float)
    category_id = db.Column(db.Integer,
      db.ForeignKey('category.id'))
    category = db.relationship(
        'Category', backref=db.backref('products',
          lazy='dynamic')
    )</span></pre>
<p><span class="koboSpan" id="kobo.57.1">First, we will create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.58.1">ProductForm</span></strong><span class="koboSpan" id="kobo.59.1"> class in </span><strong class="source-inline"><span class="koboSpan" id="kobo.60.1">models.py</span></strong><span class="koboSpan" id="kobo.61.1">; this will subclass the </span><strong class="source-inline"><span class="koboSpan" id="kobo.62.1">FlaskForm</span></strong><span class="koboSpan" id="kobo.63.1"> class, which is provided by </span><strong class="source-inline"><span class="koboSpan" id="kobo.64.1">flask_wtf</span></strong><span class="koboSpan" id="kobo.65.1">, to represent the fields required on a </span><span class="No-Break"><span class="koboSpan" id="kobo.66.1">web form</span></span><span class="No-Break"><span class="koboSpan" id="kobo.67.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.68.1">
from wtforms import StringField, DecimalField, SelectField
from flask_wtf import FlaskForm
class ProductForm(FlaskForm):
    name = StringField('Name')
    price = DecimalField('Price')
    category = SelectField('Category', coerce=int)</span></pre>
<p><span class="koboSpan" id="kobo.69.1">We import </span><strong class="source-inline"><span class="koboSpan" id="kobo.70.1">FlaskForm</span></strong><span class="koboSpan" id="kobo.71.1"> from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.72.1">flask-wtf</span></strong><span class="koboSpan" id="kobo.73.1"> extension. </span><span class="koboSpan" id="kobo.73.2">Everything else, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.74.1">fields</span></strong><span class="koboSpan" id="kobo.75.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.76.1">validators</span></strong><span class="koboSpan" id="kobo.77.1">, are imported from </span><strong class="source-inline"><span class="koboSpan" id="kobo.78.1">wtforms</span></strong><span class="koboSpan" id="kobo.79.1"> directly. </span><span class="koboSpan" id="kobo.79.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.80.1">Name</span></strong><span class="koboSpan" id="kobo.81.1"> field is of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.82.1">StringField</span></strong><span class="koboSpan" id="kobo.83.1"> type, as it requires text data, while </span><strong class="source-inline"><span class="koboSpan" id="kobo.84.1">Price</span></strong><span class="koboSpan" id="kobo.85.1"> is of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.86.1">DecimalField</span></strong><span class="koboSpan" id="kobo.87.1"> type, which will parse the data to Python’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.88.1">Decimal</span></strong><span class="koboSpan" id="kobo.89.1"> data type. </span><span class="koboSpan" id="kobo.89.2">We have kept </span><strong class="source-inline"><span class="koboSpan" id="kobo.90.1">Category</span></strong><span class="koboSpan" id="kobo.91.1"> as the </span><strong class="source-inline"><span class="koboSpan" id="kobo.92.1">SelectField</span></strong><span class="koboSpan" id="kobo.93.1"> type, which means that we can choose only </span><a id="_idIndexMarker191"/><span class="koboSpan" id="kobo.94.1">from the categories created previously when creating </span><span class="No-Break"><span class="koboSpan" id="kobo.95.1">a product.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.96.1">Information</span></p>
<p class="callout"><span class="koboSpan" id="kobo.97.1">Note that we have </span><a id="_idIndexMarker192"/><span class="koboSpan" id="kobo.98.1">a parameter called </span><strong class="source-inline"><span class="koboSpan" id="kobo.99.1">coerce</span></strong><span class="koboSpan" id="kobo.100.1"> in the field definition for </span><strong class="source-inline"><span class="koboSpan" id="kobo.101.1">Category</span></strong><span class="koboSpan" id="kobo.102.1"> (which is a selection list); this means that the incoming data from the HTML form will be coerced to an integer value prior to validating or any other processing. </span><span class="koboSpan" id="kobo.102.2">Here, coercing simply means converting a value, provided in a specific data type, to a different </span><span class="No-Break"><span class="koboSpan" id="kobo.103.1">data type.</span></span></p>
<p><span class="koboSpan" id="kobo.104.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.105.1">create_product()</span></strong><span class="koboSpan" id="kobo.106.1"> handler in </span><strong class="source-inline"><span class="koboSpan" id="kobo.107.1">views.py</span></strong><span class="koboSpan" id="kobo.108.1"> should now accommodate the form </span><span class="No-Break"><span class="koboSpan" id="kobo.109.1">created earlier:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.110.1">
from my_app.catalog.models import ProductForm
@catalog.route('/product-create', methods=['GET', 'POST'])
def create_product():
    form = ProductForm(meta={'csrf': False})
    categories = [(c.id, c.name) for c in
      Category.query.all()]
    form.category.choices = categories
    if request.method == 'POST':
        name = request.form.get('name')
        price = request.form.get('price')
        category = Category.query.get_or_404(
            request.form.get('category')
        )
        product = Product(name, price, category)
        db.session.add(product)
        db.session.commit()
        flash('The product %s has been created' % name,
          'success')
        return redirect(url_for('catalog.product',
          id=product.id))
    return render_template('product-create.html',
      form=form)</span></pre>
<p><span class="koboSpan" id="kobo.111.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.112.1">create_product()</span></strong><span class="koboSpan" id="kobo.113.1"> method accepts values from a form on a </span><strong class="source-inline"><span class="koboSpan" id="kobo.114.1">POST</span></strong><span class="koboSpan" id="kobo.115.1"> request. </span><span class="koboSpan" id="kobo.115.2">This method will render an empty form with the prefilled choices in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.116.1">Category</span></strong><span class="koboSpan" id="kobo.117.1"> field on a </span><strong class="source-inline"><span class="koboSpan" id="kobo.118.1">GET</span></strong><span class="koboSpan" id="kobo.119.1"> request. </span><span class="koboSpan" id="kobo.119.2">On the </span><strong class="source-inline"><span class="koboSpan" id="kobo.120.1">POST</span></strong><span class="koboSpan" id="kobo.121.1"> request, the form data will be used to create a new product, and when </span><a id="_idIndexMarker193"/><span class="koboSpan" id="kobo.122.1">the creation of the product is completed, the newly created product’s page will </span><span class="No-Break"><span class="koboSpan" id="kobo.123.1">be displayed.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.124.1">Information</span></p>
<p class="callout"><span class="koboSpan" id="kobo.125.1">Note that while creating the </span><strong class="source-inline"><span class="koboSpan" id="kobo.126.1">form</span></strong><span class="koboSpan" id="kobo.127.1"> object as </span><strong class="source-inline"><span class="koboSpan" id="kobo.128.1">form = ProductForm(meta={'csrf': False})</span></strong><span class="koboSpan" id="kobo.129.1">, we set </span><strong class="source-inline"><span class="koboSpan" id="kobo.130.1">csrf</span></strong><span class="koboSpan" id="kobo.131.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.132.1">False</span></strong><span class="koboSpan" id="kobo.133.1">. </span><span class="koboSpan" id="kobo.133.2">CSRF is an important part of any secure web application. </span><span class="koboSpan" id="kobo.133.3">We will talk about this in detail in the </span><em class="italic"><span class="koboSpan" id="kobo.134.1">Protecting applications from CSRF</span></em><span class="koboSpan" id="kobo.135.1"> recipe of </span><span class="No-Break"><span class="koboSpan" id="kobo.136.1">this chapter.</span></span></p>
<p><span class="koboSpan" id="kobo.137.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.138.1">templates/product-create.html</span></strong><span class="koboSpan" id="kobo.139.1"> template also requires some modification. </span><span class="koboSpan" id="kobo.139.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.140.1">form</span></strong><span class="koboSpan" id="kobo.141.1"> objects created by WTForms provide an easy way to create HTML forms and keep </span><span class="No-Break"><span class="koboSpan" id="kobo.142.1">code readable:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.143.1">
{% extends 'home.html' %}
{% block container %}
  &lt;div class="top-pad"&gt;
    &lt;form method="POST" action="{{
      url_for('catalog.create_product') }}" role="form"&gt;
      &lt;div class="form-group"&gt;{{ form.name.label }}: {{
        form.name() }}&lt;/div&gt;
      &lt;div class="form-group"&gt;{{ form.price.label }}: {{
        form.price() }}&lt;/div&gt;
      &lt;div class="form-group"&gt;{{ form.category.label }}: {{
        form.category() }}&lt;/div&gt;
      &lt;button type="submit" class="btn btn-
        default"&gt;Submit&lt;/button&gt;
    &lt;/form&gt;
  &lt;/div&gt;
{% endblo</span><a id="_idTextAnchor282"/><span class="koboSpan" id="kobo.144.1">ck %}</span></pre>
<h2 id="_idParaDest-152"><a id="_idTextAnchor283"/><span class="koboSpan" id="kobo.145.1">How it works...</span></h2>
<p><span class="koboSpan" id="kobo.146.1">On a </span><strong class="source-inline"><span class="koboSpan" id="kobo.147.1">GET</span></strong><span class="koboSpan" id="kobo.148.1"> request – that is, upon opening </span><strong class="source-inline"><span class="koboSpan" id="kobo.149.1">http://127.0.0.1:5000/product-create</span></strong><span class="koboSpan" id="kobo.150.1"> – we will see </span><a id="_idIndexMarker194"/><span class="koboSpan" id="kobo.151.1">a form similar to the one shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.152.1">following screenshot:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer028">
<span class="koboSpan" id="kobo.153.1"><img alt="Figure 5.1 – Product creation form using WTForms" src="image/B19111_05_1.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.154.1">Figure 5.1 – Product creation form using WTForms</span></p>
<p><span class="koboSpan" id="kobo.155.1">You can fill in this form to create a </span><span class="No-Break"><span class="koboSpan" id="kobo.156.1">new pro</span><a id="_idTextAnchor284"/><span class="koboSpan" id="kobo.157.1">duct.</span></span></p>
<h2 id="_idParaDest-153"><a id="_idTextAnchor285"/><span class="koboSpan" id="kobo.158.1">See also</span></h2>
<p><span class="koboSpan" id="kobo.159.1">Refer to the following </span><em class="italic"><span class="koboSpan" id="kobo.160.1">Validating fields on the server side</span></em><span class="koboSpan" id="kobo.161.1"> recipe to understand how to validate the fields we just learned </span><span class="No-Break"><span class="koboSpan" id="kobo.162.1">to cr</span><a id="_idTextAnchor286"/><span class="koboSpan" id="kobo.163.1">eate.</span></span></p>
<h1 id="_idParaDest-154"><a id="_idTextAnchor287"/><span class="koboSpan" id="kobo.164.1">Validating fields on the server side</span></h1>
<p><span class="koboSpan" id="kobo.165.1">We have </span><a id="_idIndexMarker195"/><span class="koboSpan" id="kobo.166.1">created forms and fields, but we need to validate them in order to make sure that only the correct data goes through to the database and that errors are handled beforehand, rather than corrupting the database. </span><span class="koboSpan" id="kobo.166.2">These validations can </span><a id="_idIndexMarker196"/><span class="koboSpan" id="kobo.167.1">also protect an application against </span><strong class="bold"><span class="koboSpan" id="kobo.168.1">cross-site scripting</span></strong><span class="koboSpan" id="kobo.169.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.170.1">XSS</span></strong><span class="koboSpan" id="kobo.171.1">) and CSRF attacks. </span><span class="koboSpan" id="kobo.171.2">WTForms provides a whole lot of field types that, themselves, have validations written for them by default. </span><span class="koboSpan" id="kobo.171.3">Apart from these, there are a bunch of validators that can be used based on choice and need. </span><span class="koboSpan" id="kobo.171.4">In this recipe, we will use a few of them to understand </span><span class="No-Break"><span class="koboSpan" id="kobo.172.1">the c</span><a id="_idTextAnchor288"/><span class="koboSpan" id="kobo.173.1">oncept.</span></span></p>
<h2 id="_idParaDest-155"><a id="_idTextAnchor289"/><span class="koboSpan" id="kobo.174.1">How to do it...</span></h2>
<p><span class="koboSpan" id="kobo.175.1">It is pretty </span><a id="_idIndexMarker197"/><span class="koboSpan" id="kobo.176.1">easy to add validations to our WTForm fields. </span><span class="koboSpan" id="kobo.176.2">We just need to pass a </span><strong class="source-inline"><span class="koboSpan" id="kobo.177.1">validators</span></strong><span class="koboSpan" id="kobo.178.1"> parameter, which accepts a list of validators to be implemented. </span><span class="koboSpan" id="kobo.178.2">Each of the validators can have their own arguments, which enables us to control the validations to a </span><span class="No-Break"><span class="koboSpan" id="kobo.179.1">great extent.</span></span></p>
<p><span class="koboSpan" id="kobo.180.1">Let’s modify our </span><strong class="source-inline"><span class="koboSpan" id="kobo.181.1">ProductForm</span></strong><span class="koboSpan" id="kobo.182.1"> object in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.183.1">models.py</span></strong><span class="koboSpan" id="kobo.184.1"> class to </span><span class="No-Break"><span class="koboSpan" id="kobo.185.1">have validations:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.186.1">
from decimal import Decimal
class ProductForm(FlaskForm):
    name = StringField('Name',
      validators=[InputRequired()])
    price = DecimalField('Price', validators=[
        InputRequired(), NumberRange(min=Decimal('0.0'))
    ])
    category = SelectField(
        'Category', validators=[InputRequired()],
          coerce=int
    )</span></pre>
<p><span class="koboSpan" id="kobo.187.1">Here, we have the </span><strong class="source-inline"><span class="koboSpan" id="kobo.188.1">InputRequired</span></strong><span class="koboSpan" id="kobo.189.1"> validator on all three fields; this means that these fields are required, and the form will not be submitted unless we have values for </span><span class="No-Break"><span class="koboSpan" id="kobo.190.1">these fields.</span></span></p>
<p><span class="koboSpan" id="kobo.191.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.192.1">Price</span></strong><span class="koboSpan" id="kobo.193.1"> field has an additional validator, </span><strong class="source-inline"><span class="koboSpan" id="kobo.194.1">NumberRange</span></strong><span class="koboSpan" id="kobo.195.1">, with a </span><strong class="source-inline"><span class="koboSpan" id="kobo.196.1">min</span></strong><span class="koboSpan" id="kobo.197.1"> parameter set to </span><strong class="source-inline"><span class="koboSpan" id="kobo.198.1">0.0</span></strong><span class="koboSpan" id="kobo.199.1">. </span><span class="koboSpan" id="kobo.199.2">This implies that we cannot have a value of less than </span><strong class="source-inline"><span class="koboSpan" id="kobo.200.1">0</span></strong><span class="koboSpan" id="kobo.201.1"> as the price of a product. </span><span class="koboSpan" id="kobo.201.2">To complement </span><a id="_idIndexMarker198"/><span class="koboSpan" id="kobo.202.1">these changes, we will have to modify our </span><strong class="source-inline"><span class="koboSpan" id="kobo.203.1">create_product()</span></strong><span class="koboSpan" id="kobo.204.1"> method </span><span class="No-Break"><span class="koboSpan" id="kobo.205.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.206.1">views.py</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.207.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.208.1">
@catalog.route('/product-create', methods=['GET', 'POST'])
def create_product():
    form = ProductForm(meta={'csrf': False})
    categories = [(c.id, c.name) for c in
      Category.query.all()]
    form.category.choices = categories
    if form.validate_on_submit():
        name = form.name.data
        price = form.price.data
        category = Category.query.get_or_404(
            form.category.data
        )
        product = Product(name, price, category)
        db.session.add(product)
        db.session.commit()
        flash('The product %s has been created' % name,
          'success')
        return redirect(url_for('catalog.product',
          id=product.id))
    if form.errors:
        flash(form.errors, 'danger')
    return render_template('product-create.html',
      form=form)</span></pre>
<p class="callout-heading"><span class="koboSpan" id="kobo.209.1">Tip</span></p>
<p class="callout"><span class="koboSpan" id="kobo.210.1">The flashing of </span><strong class="source-inline"><span class="koboSpan" id="kobo.211.1">form.errors</span></strong><span class="koboSpan" id="kobo.212.1"> will just display the errors in the form of a JSON object. </span><span class="koboSpan" id="kobo.212.2">This can be formatted to be shown in a pleasing format to a user. </span><span class="koboSpan" id="kobo.212.3">This is left for you to </span><span class="No-Break"><span class="koboSpan" id="kobo.213.1">try yourself.</span></span></p>
<p><span class="koboSpan" id="kobo.214.1">Here, we modified our </span><strong class="source-inline"><span class="koboSpan" id="kobo.215.1">create_product()</span></strong><span class="koboSpan" id="kobo.216.1"> method to validate the form for the input value </span><a id="_idIndexMarker199"/><span class="koboSpan" id="kobo.217.1">when submitted. </span><span class="koboSpan" id="kobo.217.2">Some of the validations will be translated and applied to the frontend as well, just like the </span><strong class="source-inline"><span class="koboSpan" id="kobo.218.1">InputRequired</span></strong><span class="koboSpan" id="kobo.219.1"> validation will add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.220.1">required</span></strong><span class="koboSpan" id="kobo.221.1"> property to the form field’s HTML. </span><span class="koboSpan" id="kobo.221.2">On a </span><strong class="source-inline"><span class="koboSpan" id="kobo.222.1">POST</span></strong><span class="koboSpan" id="kobo.223.1"> request, the form data will be validated first. </span><span class="koboSpan" id="kobo.223.2">If the validation fails for some reason, the same page will be rendered again, with error messages flashed on it. </span><span class="koboSpan" id="kobo.223.3">If the validation succeeds and the creation of the product is completed, the newly created product’s page will </span><span class="No-Break"><span class="koboSpan" id="kobo.224.1">be displayed.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.225.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.226.1">Note the very convenient </span><strong class="source-inline"><span class="koboSpan" id="kobo.227.1">validate_on_submit()</span></strong><span class="koboSpan" id="kobo.228.1"> method. </span><span class="koboSpan" id="kobo.228.2">This will automatically check whether the request is </span><strong class="source-inline"><span class="koboSpan" id="kobo.229.1">POST</span></strong><span class="koboSpan" id="kobo.230.1"> and whether it is valid. </span><span class="koboSpan" id="kobo.230.2">It is essentially a combination of </span><strong class="source-inline"><span class="koboSpan" id="kobo.231.1">request.method == 'POST'</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.232.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.233.1">form.v</span><a id="_idTextAnchor290"/><span class="koboSpan" id="kobo.234.1">alidate()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.235.1">.</span></span></p>
<h2 id="_idParaDest-156"><a id="_idTextAnchor291"/><span class="koboSpan" id="kobo.236.1">How it works...</span></h2>
<p><span class="koboSpan" id="kobo.237.1">Now, try to submit the form without any field filled in – that is, an empty form. </span><span class="koboSpan" id="kobo.237.2">An alert message with </span><a id="_idIndexMarker200"/><span class="koboSpan" id="kobo.238.1">an error will be shown </span><span class="No-Break"><span class="koboSpan" id="kobo.239.1">as follows:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer029">
<span class="koboSpan" id="kobo.240.1"><img alt="Figure 5.2 – In-built error handling in WTForms" src="image/B19111_05_2.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.241.1">Figure 5.2 – In-built error handling in WTForms</span></p>
<p><span class="koboSpan" id="kobo.242.1">If you try to submit the form with a negative price value, the flashed error will look something like the </span><span class="No-Break"><span class="koboSpan" id="kobo.243.1">following screenshot:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer030">
<span class="koboSpan" id="kobo.244.1"><img alt="Figure 5.3 – Custom error handling in WTForms" src="image/B19111_05_3.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.245.1">Figure 5.3 – Custom error handling in WTForms</span></p>
<p><span class="koboSpan" id="kobo.246.1">Try different combinations of form submissions that will violate the defined validators, and note the different error messages that</span><a id="_idTextAnchor292"/> <span class="No-Break"><span class="koboSpan" id="kobo.247.1">come up.</span></span></p>
<h2 id="_idParaDest-157"><a id="_idTextAnchor293"/><span class="koboSpan" id="kobo.248.1">See also</span></h2>
<p><span class="koboSpan" id="kobo.249.1">Refer to the previous recipe, </span><em class="italic"><span class="koboSpan" id="kobo.250.1">Representing SQLAlchemy model data as a form</span></em><span class="koboSpan" id="kobo.251.1">, to understand basic form creation </span><span class="No-Break"><span class="koboSpan" id="kobo.252.1">using</span><a id="_idTextAnchor294"/><span class="koboSpan" id="kobo.253.1"> WTForms.</span></span></p>
<h1 id="_idParaDest-158"><a id="_idTextAnchor295"/><span class="koboSpan" id="kobo.254.1">Creating a common form set</span></h1>
<p><span class="koboSpan" id="kobo.255.1">An application can have many forms, depending on the design and purpose. </span><span class="koboSpan" id="kobo.255.2">Some of these forms </span><a id="_idIndexMarker201"/><span class="koboSpan" id="kobo.256.1">will have common fields with common validators. </span><span class="koboSpan" id="kobo.256.2">You might think, “</span><em class="italic"><span class="koboSpan" id="kobo.257.1">Why not have common form parts and then reuse them as and when needed?</span></em><span class="koboSpan" id="kobo.258.1">” In this recipe, we will see that this is certainly possible with the class structure for forms’ definition provided </span><span class="No-Break"><span class="koboSpan" id="kobo.259.1">b</span><a id="_idTextAnchor296"/><span class="koboSpan" id="kobo.260.1">y WTForms.</span></span></p>
<h2 id="_idParaDest-159"><a id="_idTextAnchor297"/><span class="koboSpan" id="kobo.261.1">How to do it...</span></h2>
<p><span class="koboSpan" id="kobo.262.1">In our catalog application, we can have two forms, one each for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.263.1">Product</span></strong><span class="koboSpan" id="kobo.264.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.265.1">Category</span></strong><span class="koboSpan" id="kobo.266.1"> models. </span><span class="koboSpan" id="kobo.266.2">These forms will have a common field called </span><strong class="source-inline"><span class="koboSpan" id="kobo.267.1">Name</span></strong><span class="koboSpan" id="kobo.268.1">. </span><span class="koboSpan" id="kobo.268.2">We can create a common form for this field, and then the separate forms for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.269.1">Product</span></strong><span class="koboSpan" id="kobo.270.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.271.1">Category</span></strong><span class="koboSpan" id="kobo.272.1"> models can use this form, instead of having a </span><strong class="source-inline"><span class="koboSpan" id="kobo.273.1">Name</span></strong><span class="koboSpan" id="kobo.274.1"> field in each </span><span class="No-Break"><span class="koboSpan" id="kobo.275.1">of them.</span></span></p>
<p><span class="koboSpan" id="kobo.276.1">This can be implemented as follows </span><span class="No-Break"><span class="koboSpan" id="kobo.277.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.278.1">models.py</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.279.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.280.1">
class NameForm(FlaskForm):
    name = StringField('Name',
      validators=[InputRequired()])
class ProductForm(NameForm):
    price = DecimalField('Price', validators=[
        InputRequired(), NumberRange(min=Decimal('0.0'))
    ])
    category = SelectField(
        'Category', validators=[InputRequired()],
          coerce=int
    )
class CategoryForm(NameForm):
    pass</span></pre>
<p><span class="koboSpan" id="kobo.281.1">We created a </span><a id="_idIndexMarker202"/><span class="koboSpan" id="kobo.282.1">common form called </span><strong class="source-inline"><span class="koboSpan" id="kobo.283.1">NameForm</span></strong><span class="koboSpan" id="kobo.284.1">, and the other forms, </span><strong class="source-inline"><span class="koboSpan" id="kobo.285.1">ProductForm</span></strong><span class="koboSpan" id="kobo.286.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.287.1">CategoryForm</span></strong><span class="koboSpan" id="kobo.288.1">, inherit from this form to have a field called </span><strong class="source-inline"><span class="koboSpan" id="kobo.289.1">Name</span></strong><span class="koboSpan" id="kobo.290.1"> by default. </span><span class="koboSpan" id="kobo.290.2">Then, we can add more fields </span><span class="No-Break"><span class="koboSpan" id="kobo.291.1">as necessary.</span></span></p>
<p><span class="koboSpan" id="kobo.292.1">We can modify the </span><strong class="source-inline"><span class="koboSpan" id="kobo.293.1">create_category()</span></strong><span class="koboSpan" id="kobo.294.1"> method in </span><strong class="source-inline"><span class="koboSpan" id="kobo.295.1">views.py</span></strong><span class="koboSpan" id="kobo.296.1"> to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.297.1">CategoryForm</span></strong><span class="koboSpan" id="kobo.298.1"> to </span><span class="No-Break"><span class="koboSpan" id="kobo.299.1">create categories:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.300.1">
@catalog.route('/category-create', methods=['GET', 'POST'])
def create_category():
    form = CategoryForm(meta={'csrf': False})
    if form.validate_on_submit():
        name = form.name.data
        category = Category(name)
        db.session.add(category)
        db.session.commit()
        flash(
            'The category %s has been created' % name,
              'success'
        )
        return redirect(url_for('catalog.category',
          id=category.id))
    if form.errors:
        flash(form.errors)
    return render_template('category-create.html',
      form=form)</span></pre>
<p><span class="koboSpan" id="kobo.301.1">A new </span><a id="_idIndexMarker203"/><span class="koboSpan" id="kobo.302.1">template, </span><strong class="source-inline"><span class="koboSpan" id="kobo.303.1">templates/category-create.html</span></strong><span class="koboSpan" id="kobo.304.1">, also needs to be added for </span><span class="No-Break"><span class="koboSpan" id="kobo.305.1">category creation:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.306.1">
{% extends 'home.html' %}
{% block container %}
  &lt;div class="top-pad"&gt;
    &lt;form method="POST" action="{{
      url_for('catalog.create_category') }}" role="form"&gt;
      &lt;div class="form-group"&gt;{{ form.name.label }}: {{
        form.name() }}&lt;/div&gt;
      &lt;button type="submit" class="btn btn-
        default"&gt;Submit&lt;/button&gt;
    &lt;/form&gt;
  &lt;/div&gt;
{%</span><a id="_idTextAnchor298"/><span class="koboSpan" id="kobo.307.1"> endblock %}</span></pre>
<h2 id="_idParaDest-160"><a id="_idTextAnchor299"/><span class="koboSpan" id="kobo.308.1">How it works...</span></h2>
<p><span class="koboSpan" id="kobo.309.1">Open the </span><strong class="source-inline"><span class="koboSpan" id="kobo.310.1">http://127.0.0.1:5000/category-create</span></strong><span class="koboSpan" id="kobo.311.1"> URL in your browser. </span><span class="koboSpan" id="kobo.311.2">The newly created category form will look like the </span><span class="No-Break"><span class="koboSpan" id="kobo.312.1">following screenshot:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer031">
<span class="koboSpan" id="kobo.313.1"><img alt="Figure 5.4 – A common form used for category creation" src="image/B19111_05_4.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.314.1">Figure 5.4 – A common form used for category creation</span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.315.1">Tip</span></p>
<p class="callout"><span class="koboSpan" id="kobo.316.1">This is a very </span><a id="_idIndexMarker204"/><span class="koboSpan" id="kobo.317.1">small example of how a common form set can be implemented. </span><span class="koboSpan" id="kobo.317.2">The actual benefits of this approach can be seen in e-commerce applications, where we can have common address forms, and then they can be expanded to have separate billing and </span><span class="No-Break"><span class="koboSpan" id="kobo.318.1">shippin</span><a id="_idTextAnchor300"/><span class="koboSpan" id="kobo.319.1">g addresses.</span></span></p>
<h1 id="_idParaDest-161"><a id="_idTextAnchor301"/><span class="koboSpan" id="kobo.320.1">Creating custom fields and validations</span></h1>
<p><span class="koboSpan" id="kobo.321.1">Apart from providing a bunch of fields and validations, Flask and WTForms also provide you with </span><a id="_idIndexMarker205"/><span class="koboSpan" id="kobo.322.1">the flexibility to create custom fields and validations. </span><span class="koboSpan" id="kobo.322.2">Sometimes, we might need to parse some form of data that cannot be processed using the available current fields. </span><span class="koboSpan" id="kobo.322.3">In such cases, we can implement ou</span><a id="_idTextAnchor302"/><span class="koboSpan" id="kobo.323.1">r </span><span class="No-Break"><span class="koboSpan" id="kobo.324.1">own fields.</span></span></p>
<h2 id="_idParaDest-162"><a id="_idTextAnchor303"/><span class="koboSpan" id="kobo.325.1">How to do it...</span></h2>
<p><span class="koboSpan" id="kobo.326.1">In our catalog application, we used </span><strong class="source-inline"><span class="koboSpan" id="kobo.327.1">SelectField</span></strong><span class="koboSpan" id="kobo.328.1"> for the category, and we populated the values for this field in our </span><strong class="source-inline"><span class="koboSpan" id="kobo.329.1">create_product()</span></strong><span class="koboSpan" id="kobo.330.1"> method on a </span><strong class="source-inline"><span class="koboSpan" id="kobo.331.1">GET</span></strong><span class="koboSpan" id="kobo.332.1"> request by querying the </span><strong class="source-inline"><span class="koboSpan" id="kobo.333.1">Category</span></strong><span class="koboSpan" id="kobo.334.1"> model. </span><span class="koboSpan" id="kobo.334.2">It would be much more convenient if we did not concern ourselves with this and the population of this field took care </span><span class="No-Break"><span class="koboSpan" id="kobo.335.1">of itself.</span></span></p>
<p><span class="koboSpan" id="kobo.336.1">Now, let’s implement a custom field to do this </span><span class="No-Break"><span class="koboSpan" id="kobo.337.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.338.1">models.py</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.339.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.340.1">
class CategoryField(SelectField):
    def iter_choices(self):
        categories = [(c.id, c.name) for c in
          Category.query.all()]
        for value, label in categories:
            yield (value, label, self.coerce(value) ==
              self.data)
    def pre_validate(self, form):
        for v, _ in [(c.id, c.name) for c in
          Category.query.all()]:
            if self.data == v:
                break
        else:
            raise ValueError(self.gettext('Not a valid
              choice'))
class ProductForm(NameForm):
    price = DecimalField('Price', validators=[
        InputRequired(), NumberRange(min=Decimal('0.0'))
    ])
    category = CategoryField(
        'Category', validators=[InputRequired()],
          coerce=int
    )</span></pre>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.341.1">SelectField</span></strong><span class="koboSpan" id="kobo.342.1"> implements a method called </span><strong class="source-inline"><span class="koboSpan" id="kobo.343.1">iter_choices()</span></strong><span class="koboSpan" id="kobo.344.1">, which populates the values to the form using the list of values provided to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.345.1">choices</span></strong><span class="koboSpan" id="kobo.346.1"> parameter. </span><span class="koboSpan" id="kobo.346.2">We overwrite the </span><strong class="source-inline"><span class="koboSpan" id="kobo.347.1">iter_choices()</span></strong><span class="koboSpan" id="kobo.348.1"> method to get the values of categories directly from the database, and this </span><a id="_idIndexMarker206"/><span class="koboSpan" id="kobo.349.1">eliminates the need to populate this field every time we need to use </span><span class="No-Break"><span class="koboSpan" id="kobo.350.1">this form.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.351.1">Information</span></p>
<p class="callout"><span class="koboSpan" id="kobo.352.1">The behavior </span><a id="_idIndexMarker207"/><span class="koboSpan" id="kobo.353.1">created by </span><strong class="source-inline"><span class="koboSpan" id="kobo.354.1">CategoryField</span></strong><span class="koboSpan" id="kobo.355.1"> here can also be achieved using </span><strong class="source-inline"><span class="koboSpan" id="kobo.356.1">QuerySelectField</span></strong><span class="koboSpan" id="kobo.357.1">. </span><span class="koboSpan" id="kobo.357.2">Refer to </span><a href="https://wtforms-sqlalchemy.readthedocs.io/en/stable/wtforms_sqlalchemy/#wtforms_sqlalchemy.fields.QuerySelectField"><span class="koboSpan" id="kobo.358.1">https://wtforms-sqlalchemy.readthedocs.io/en/stable/wtforms_sqlalchemy/#wtforms_sqlalchemy.fields.QuerySelectField</span></a><span class="koboSpan" id="kobo.359.1"> for </span><span class="No-Break"><span class="koboSpan" id="kobo.360.1">more information.</span></span></p>
<p><span class="koboSpan" id="kobo.361.1">Due to the changes described in this section, our </span><strong class="source-inline"><span class="koboSpan" id="kobo.362.1">create_product()</span></strong><span class="koboSpan" id="kobo.363.1"> method in </span><strong class="source-inline"><span class="koboSpan" id="kobo.364.1">views.py</span></strong><span class="koboSpan" id="kobo.365.1"> will have to be modified. </span><span class="koboSpan" id="kobo.365.2">For this, just remove the following two statements that populated the categories in </span><span class="No-Break"><span class="koboSpan" id="kobo.366.1">the form:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.367.1">
categories = [(c.id, c.name) for c in Category.query.all()]
form.category.choic</span><a id="_idTextAnchor304"/><span class="koboSpan" id="kobo.368.1">es = categories</span></pre>
<h2 id="_idParaDest-163"><a id="_idTextAnchor305"/><span class="koboSpan" id="kobo.369.1">How it works...</span></h2>
<p><span class="koboSpan" id="kobo.370.1">There will not be any visual effect on the application. </span><span class="koboSpan" id="kobo.370.2">The only change will be in the way the categories are populated in the form, as explained in the </span><span class="No-Break"><span class="koboSpan" id="kobo.371.1">pr</span><a id="_idTextAnchor306"/><span class="koboSpan" id="kobo.372.1">evious section.</span></span></p>
<h2 id="_idParaDest-164"><a id="_idTextAnchor307"/><span class="koboSpan" id="kobo.373.1">There’s more...</span></h2>
<p><span class="koboSpan" id="kobo.374.1">We just saw how to write custom fields. </span><span class="koboSpan" id="kobo.374.2">Similarly, we can write custom validations, too. </span><span class="koboSpan" id="kobo.374.3">Let’s assume that we do not want to allow duplicate categories. </span><span class="koboSpan" id="kobo.374.4">We can implement this in our models easily, but let’s do this using a custom validator on </span><span class="No-Break"><span class="koboSpan" id="kobo.375.1">our form:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.376.1">
def check_duplicate_category(case_sensitive=True):
    def _check_duplicate(form, field):
        if case_sensitive:
            res = Category.query.filter(
                Category.name.like('%' + field.data + '%')
            ).first()
        else:
            res = Category.query.filter(
                Category.name.ilike('%' + field.data + '%')
            ).first()
        if res:
            raise ValidationError(
                'Category named %s already exists' %
                  field.data
            )
    return _check_duplicate
class CategoryForm(NameForm):
    name = StringField('Name', validators=[
        InputRequired(), check_duplicate_category()
    ])</span></pre>
<p><span class="koboSpan" id="kobo.377.1">So, we created </span><a id="_idIndexMarker208"/><span class="koboSpan" id="kobo.378.1">our validator in a factory style, where we can get separate validation results based on whether we want a case-sensitive comparison. </span><span class="koboSpan" id="kobo.378.2">We can even write a class-based design, which makes the validator much more generic and flexible, but I will leave that for you </span><span class="No-Break"><span class="koboSpan" id="kobo.379.1">to explore.</span></span></p>
<p><span class="koboSpan" id="kobo.380.1">Now, if you try to create a new category with the same name as the one that already exists, the following error will </span><span class="No-Break"><span class="koboSpan" id="kobo.381.1">be shown:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer032">
<span class="koboSpan" id="kobo.382.1"><img alt="Figure 5.5 – An error on the duplicate ca﻿tegory creation" src="image/B19111_05_5.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.383.1">Figure 5.5 – An error on the duplicate ca</span><a id="_idTextAnchor308"/><span class="koboSpan" id="kobo.384.1">tegory creation</span></p>
<h1 id="_idParaDest-165"><a id="_idTextAnchor309"/><span class="koboSpan" id="kobo.385.1">Creating a custom widget</span></h1>
<p><span class="koboSpan" id="kobo.386.1">Just like we can create custom fields and validators, we can also create custom widgets. </span><span class="koboSpan" id="kobo.386.2">These widgets </span><a id="_idIndexMarker209"/><span class="koboSpan" id="kobo.387.1">allow us to control how our fields will look on the frontend. </span><span class="koboSpan" id="kobo.387.2">Each field type has a widget associated with it, and WTForms, by itself, provides a lot of basic and HTML5 widgets. </span><span class="koboSpan" id="kobo.387.3">In this recipe, to understand how to write a custom widget, we will convert our custom selection field for </span><strong class="source-inline"><span class="koboSpan" id="kobo.388.1">Category</span></strong><span class="koboSpan" id="kobo.389.1"> into a radio field. </span><span class="koboSpan" id="kobo.389.2">I agree with those of you who would argue that we can directly use the radio field provided by WTForms. </span><span class="koboSpan" id="kobo.389.3">Here, we are just trying to understand how to do </span><span class="No-Break"><span class="koboSpan" id="kobo.390.1">it ourselves.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.391.1">Information</span></p>
<p class="callout"><span class="koboSpan" id="kobo.392.1">The widgets </span><a id="_idIndexMarker210"/><span class="koboSpan" id="kobo.393.1">provided by default by WTForms can be found </span><span class="No-Break"><span class="koboSpan" id="kobo.394.1">at </span></span><a href="https://wtforms.readthedocs.io/en/3.0.x/widgets/"><span class="No-Break"><span class="koboSpan" id="kobo.395.1">https://wtforms.readthedocs.io/e</span><span id="_idTextAnchor310"/><span class="koboSpan" id="kobo.396.1">n/3.0.x/widgets/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.397.1">.</span></span></p>
<h2 id="_idParaDest-166"><a id="_idTextAnchor311"/><span class="koboSpan" id="kobo.398.1">How to do it...</span></h2>
<p><span class="koboSpan" id="kobo.399.1">In our previous recipe, we created </span><strong class="source-inline"><span class="koboSpan" id="kobo.400.1">CategoryField</span></strong><span class="koboSpan" id="kobo.401.1">. </span><span class="koboSpan" id="kobo.401.2">This field used the </span><strong class="source-inline"><span class="koboSpan" id="kobo.402.1">Select</span></strong><span class="koboSpan" id="kobo.403.1"> widget, which was provided by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.404.1">Select</span></strong><span class="koboSpan" id="kobo.405.1"> superclass. </span><span class="koboSpan" id="kobo.405.2">Let’s replace the </span><strong class="source-inline"><span class="koboSpan" id="kobo.406.1">Select</span></strong><span class="koboSpan" id="kobo.407.1"> widget with a radio input </span><span class="No-Break"><span class="koboSpan" id="kobo.408.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.409.1">models.py</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.410.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.411.1">
from wtforms.widgets import html_params, Select
from markupsafe import Markup
class CustomCategoryInput(Select):
    def __call__(self, field, **kwargs):
        kwargs.setdefault('id', field.id)
        html = []
        for val, label, selected in field.iter_choices():
            html.append(
                '&lt;input type="radio" %s&gt; %s' % (
                    html_params(
                        name=field.name, value=val,
                          checked=selected, **kwargs
                    ), label
                )
            )
        return Markup(' '.join(html))
class CategoryField(SelectField):
    widget = CustomCategoryInput()
    # Rest of the code remains same as in last recipe
      Creating custom field and validation</span></pre>
<p><span class="koboSpan" id="kobo.412.1">Here, we added </span><a id="_idIndexMarker211"/><span class="koboSpan" id="kobo.413.1">a class attribute called </span><strong class="source-inline"><span class="koboSpan" id="kobo.414.1">widget</span></strong><span class="koboSpan" id="kobo.415.1"> to our </span><strong class="source-inline"><span class="koboSpan" id="kobo.416.1">CategoryField</span></strong><span class="koboSpan" id="kobo.417.1"> class. </span><span class="koboSpan" id="kobo.417.2">This widget points to </span><strong class="source-inline"><span class="koboSpan" id="kobo.418.1">CustomCategoryInput</span></strong><span class="koboSpan" id="kobo.419.1">, which takes care of HTML code generation for the field to be rendered. </span><span class="koboSpan" id="kobo.419.2">This class has a </span><strong class="source-inline"><span class="koboSpan" id="kobo.420.1">__call__()</span></strong><span class="koboSpan" id="kobo.421.1"> method, which is overwritten to return radio inputs corresponding to the values provided by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.422.1">iter_choices()</span></strong><span class="koboSpan" id="kobo.423.1"> method</span><a id="_idTextAnchor312"/> <span class="No-Break"><span class="koboSpan" id="kobo.424.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.425.1">CategoryField</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.426.1">.</span></span></p>
<h2 id="_idParaDest-167"><a id="_idTextAnchor313"/><span class="koboSpan" id="kobo.427.1">How it works...</span></h2>
<p><span class="koboSpan" id="kobo.428.1">When you </span><a id="_idIndexMarker212"/><span class="koboSpan" id="kobo.429.1">open the product creation page, </span><strong class="source-inline"><span class="koboSpan" id="kobo.430.1">http://127.0.0.1:5000/product-create</span></strong><span class="koboSpan" id="kobo.431.1">, it will look like the </span><span class="No-Break"><span class="koboSpan" id="kobo.432.1">following screenshot:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer033">
<span class="koboSpan" id="kobo.433.1"><img alt="Figure 5.6 – A custom widget for ﻿category selection" src="image/B19111_05_6.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.434.1">Figure 5.6 – A custom widget for </span><a id="_idTextAnchor314"/><span class="koboSpan" id="kobo.435.1">category selection</span></p>
<h2 id="_idParaDest-168"><a id="_idTextAnchor315"/><span class="koboSpan" id="kobo.436.1">See also</span></h2>
<p><span class="koboSpan" id="kobo.437.1">Refer to the previous recipe, </span><em class="italic"><span class="koboSpan" id="kobo.438.1">Creating custom fields and validation</span></em><span class="koboSpan" id="kobo.439.1">, to understand more about the level of customization that can be done to the comp</span><a id="_idTextAnchor316"/><span class="koboSpan" id="kobo.440.1">onents </span><span class="No-Break"><span class="koboSpan" id="kobo.441.1">of WTForms.</span></span></p>
<h1 id="_idParaDest-169"><a id="_idTextAnchor317"/><span class="koboSpan" id="kobo.442.1">Uploading files via forms</span></h1>
<p><span class="koboSpan" id="kobo.443.1">Uploading </span><a id="_idIndexMarker213"/><span class="koboSpan" id="kobo.444.1">files via forms, and doing it properly, is usually a matter of concern for many web frameworks. </span><span class="koboSpan" id="kobo.444.2">In this recipe, we will see how Flask and WTForms handle this for us in a simple and </span><a id="_idTextAnchor318"/><span class="No-Break"><span class="koboSpan" id="kobo.445.1">streamlined manner.</span></span></p>
<h2 id="_idParaDest-170"><a id="_idTextAnchor319"/><span class="koboSpan" id="kobo.446.1">How to do it...</span></h2>
<p><span class="koboSpan" id="kobo.447.1">In this recipe, we will implement a feature to store product images while creating products. </span><span class="koboSpan" id="kobo.447.2">First, we will start with the configuration bit. </span><span class="koboSpan" id="kobo.447.3">We need to provide a parameter to our application configuration – that is, </span><strong class="source-inline"><span class="koboSpan" id="kobo.448.1">UPLOAD_FOLDER</span></strong><span class="koboSpan" id="kobo.449.1">. </span><span class="koboSpan" id="kobo.449.2">This parameter tells Flask about the location where our uploaded files will </span><span class="No-Break"><span class="koboSpan" id="kobo.450.1">be stored.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.451.1">Tip</span></p>
<p class="callout"><span class="koboSpan" id="kobo.452.1">One way to store product images can be to store images in a binary-type field in our database, but this method is highly inefficient and never recommended in any application. </span><span class="koboSpan" id="kobo.452.2">We should always store images and other uploads in a filesystem, and store their locations in a database using a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.453.1">string</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.454.1"> field.</span></span></p>
<p><span class="koboSpan" id="kobo.455.1">Add the </span><a id="_idIndexMarker214"/><span class="koboSpan" id="kobo.456.1">following statements to the configuration </span><span class="No-Break"><span class="koboSpan" id="kobo.457.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.458.1">my_app/__init__.py</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.459.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.460.1">
import os
ALLOWED_EXTENSIONS = set(['txt', 'pdf', 'png', 'jpg',
  'jpeg', 'gif'])
app.config['UPLOAD_FOLDER'] = os.path.realpath('.') +
  '/my_app/static/uploads'</span></pre>
<p class="callout-heading"><span class="koboSpan" id="kobo.461.1">Tip</span></p>
<p class="callout"><span class="koboSpan" id="kobo.462.1">Note the </span><strong class="source-inline"><span class="koboSpan" id="kobo.463.1">app.config['UPLOAD_FOLDER']</span></strong><span class="koboSpan" id="kobo.464.1"> statement, where we store the images inside a subfolder in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.465.1">static</span></strong><span class="koboSpan" id="kobo.466.1"> folder itself. </span><span class="koboSpan" id="kobo.466.2">This will make the process of rendering images easier. </span><span class="koboSpan" id="kobo.466.3">Also, note the </span><strong class="source-inline"><span class="koboSpan" id="kobo.467.1">ALLOWED_EXTENSIONS</span></strong><span class="koboSpan" id="kobo.468.1"> statement, which is used to make sure that only files of a specific format go through. </span><span class="koboSpan" id="kobo.468.2">The list here is actually for demonstration purposes only, and for image types, we can filter this list even more. </span><span class="koboSpan" id="kobo.468.3">Make sure the folder path specified in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.469.1">app.config['UPLOAD_FOLDER']</span></strong><span class="koboSpan" id="kobo.470.1"> statement exists; otherwise, the application will </span><span class="No-Break"><span class="koboSpan" id="kobo.471.1">error out.</span></span></p>
<p><span class="koboSpan" id="kobo.472.1">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.473.1">models</span></strong><span class="koboSpan" id="kobo.474.1"> file – that is, </span><strong class="source-inline"><span class="koboSpan" id="kobo.475.1">my_app/catalog/models.py</span></strong><span class="koboSpan" id="kobo.476.1"> – add the following highlighted statements to their </span><span class="No-Break"><span class="koboSpan" id="kobo.477.1">designated places:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.478.1">from flask_wtf.file import FileField, FileRequired</span></strong><span class="koboSpan" id="kobo.479.1">
class Product(db.Model):
</span><strong class="bold"><span class="koboSpan" id="kobo.480.1">    image_path = db.Column(db.String(255))</span></strong><span class="koboSpan" id="kobo.481.1">
    def __init__(self, name, price, category, image_path):
</span><strong class="bold"><span class="koboSpan" id="kobo.482.1">        self.image_path = image_path</span></strong><span class="koboSpan" id="kobo.483.1">
class ProductForm(NameForm):
    </span><strong class="bold"><span class="koboSpan" id="kobo.484.1">image = FileField('Product Image',</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.485.1">      validators=[FileRequired()])</span></strong></pre>
<p><span class="koboSpan" id="kobo.486.1">Check </span><strong class="source-inline"><span class="koboSpan" id="kobo.487.1">FileField</span></strong><span class="koboSpan" id="kobo.488.1"> for </span><strong class="source-inline"><span class="koboSpan" id="kobo.489.1">image</span></strong><span class="koboSpan" id="kobo.490.1"> in </span><strong class="source-inline"><span class="koboSpan" id="kobo.491.1">ProductForm</span></strong><span class="koboSpan" id="kobo.492.1"> and the field for </span><strong class="source-inline"><span class="koboSpan" id="kobo.493.1">image_path</span></strong><span class="koboSpan" id="kobo.494.1"> to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.495.1">Product</span></strong><span class="koboSpan" id="kobo.496.1"> model. </span><span class="koboSpan" id="kobo.496.2">Here, the uploaded file will be stored on the filesystem at the path defined </span><a id="_idIndexMarker215"/><span class="koboSpan" id="kobo.497.1">in the config, and the path generated will be stored in </span><span class="No-Break"><span class="koboSpan" id="kobo.498.1">the database.</span></span></p>
<p><span class="koboSpan" id="kobo.499.1">Now, modify the </span><strong class="source-inline"><span class="koboSpan" id="kobo.500.1">create_product()</span></strong><span class="koboSpan" id="kobo.501.1"> method to save the file </span><span class="No-Break"><span class="koboSpan" id="kobo.502.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.503.1">my_app/catalog/views.py</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.504.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.505.1">
import os
from werkzeug.utils import secure_filename
from my_app import ALLOWED_EXTENSIONS
@catalog.route('/product-create', methods=['GET', 'POST'])
def create_product():
    form = ProductForm(meta={'csrf': False})
    if form.validate_on_submit():
        name = form.name.data
        price = form.price.data
        category = Category.query.get_or_404(
            form.category.data
        )
        image = form.image.data
        if allowed_file(image.filename):
            filename = secure_filename(image.filename)
            image.save(os.path.join(app.config
              ['UPLOAD_FOLDER'], filename))
        product = Product(name, price, category, filename)
        db.session.add(product)
        db.session.commit()
        flash('The product %s has been created' % name,
          'success')
        return redirect(url_for('catalog.product',
          id=product.id))
    if form.errors:
        flash(form.errors, 'danger')
    return render_template('product-create.html',
      form=form)</span></pre>
<p><span class="koboSpan" id="kobo.506.1">Add the </span><a id="_idIndexMarker216"/><span class="koboSpan" id="kobo.507.1">new field to the product create form in </span><strong class="source-inline"><span class="koboSpan" id="kobo.508.1">template templates/product-create.html</span></strong><span class="koboSpan" id="kobo.509.1">. </span><span class="koboSpan" id="kobo.509.2">Modify the </span><strong class="source-inline"><span class="koboSpan" id="kobo.510.1">form</span></strong><span class="koboSpan" id="kobo.511.1"> tag definition to include the </span><strong class="source-inline"><span class="koboSpan" id="kobo.512.1">enctype</span></strong><span class="koboSpan" id="kobo.513.1"> parameter, and add the field for the image before the </span><strong class="bold"><span class="koboSpan" id="kobo.514.1">Submit</span></strong><span class="koboSpan" id="kobo.515.1"> button (or wherever you feel it is necessary inside </span><span class="No-Break"><span class="koboSpan" id="kobo.516.1">the form):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.517.1">
&lt;form method="POST"
        action="{{ url_for('catalog.create_product') }}"
        role="form"
        enctype="multipart/form-data"&gt;
      &lt;!-- The other field definitions as always --&gt;
      &lt;div class="form-group"&gt;{{ form.image.label }}: {{
        form.image(style='display:inline;') }}&lt;/div&gt;
      &lt;button type="submit" class="btn btn-
        default"&gt;Submit&lt;/button&gt;
    &lt;/form&gt;</span></pre>
<p><span class="koboSpan" id="kobo.518.1">The form </span><a id="_idIndexMarker217"/><span class="koboSpan" id="kobo.519.1">should have the </span><strong class="source-inline"><span class="koboSpan" id="kobo.520.1">enctype="multipart/form-data"</span></strong><span class="koboSpan" id="kobo.521.1"> statement to tell the application that the form input will have </span><span class="No-Break"><span class="koboSpan" id="kobo.522.1">multipart data.</span></span></p>
<p><span class="koboSpan" id="kobo.523.1">Rendering the image is very easy, as we are storing the files in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.524.1">static</span></strong><span class="koboSpan" id="kobo.525.1"> folder itself. </span><span class="koboSpan" id="kobo.525.2">Just add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.526.1">img</span></strong><span class="koboSpan" id="kobo.527.1"> tag wherever the image needs to be displayed </span><span class="No-Break"><span class="koboSpan" id="kobo.528.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.529.1">templates/product.html</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.530.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.531.1">
&lt;img src="{{ url_for('static', filename='uploads/' +
  pr</span><a id="_idTextAnchor320"/><span class="koboSpan" id="kobo.532.1">oduct.image_path) }}"/&gt;</span></pre>
<h2 id="_idParaDest-171"><a id="_idTextAnchor321"/><span class="koboSpan" id="kobo.533.1">How it works...</span></h2>
<p><span class="koboSpan" id="kobo.534.1">The field to upload the image will look something like the </span><span class="No-Break"><span class="koboSpan" id="kobo.535.1">following screenshot:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer034">
<span class="koboSpan" id="kobo.536.1"><img alt="Figure 5.7 – Uploading files for the product image" src="image/B19111_05_7.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.537.1">Figure 5.7 – Uploading files for the product image</span></p>
<p><span class="koboSpan" id="kobo.538.1">Following the </span><a id="_idIndexMarker218"/><span class="koboSpan" id="kobo.539.1">creation of the product, the image will be displayed, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.540.1">following screenshot:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer035">
<span class="koboSpan" id="kobo.541.1"><img alt="Figure 5.8 – The product page ﻿with the uploaded file" src="image/B19111_05_8.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.542.1">Figure 5.8 – The product page </span><a id="_idTextAnchor322"/><span class="koboSpan" id="kobo.543.1">with the uploaded file</span></p>
<h1 id="_idParaDest-172"><a id="_idTextAnchor323"/><span class="koboSpan" id="kobo.544.1">Protecting applications from CSRF</span></h1>
<p><span class="koboSpan" id="kobo.545.1">In the first recipe of this chapter, we learned that CSRF is an important part of web form security. </span><span class="koboSpan" id="kobo.545.2">We </span><a id="_idIndexMarker219"/><span class="koboSpan" id="kobo.546.1">will now talk about this in detail. </span><span class="koboSpan" id="kobo.546.2">CSRF basically means that someone can hack into the request </span><a id="_idIndexMarker220"/><span class="koboSpan" id="kobo.547.1">that carries a cookie and use this to trigger a destructive action. </span><span class="koboSpan" id="kobo.547.2">We won’t be discussing CSRF in detail here, since ample resources are available on the internet to learn about it. </span><span class="koboSpan" id="kobo.547.3">We will talk about how WTForms helps us to prevent CSRF. </span><span class="koboSpan" id="kobo.547.4">Flask does not provide any security against CSRF by default, as this has to be handled at the form-validation level, which is not a core feature of Flask as a framework. </span><span class="koboSpan" id="kobo.547.5">However, in this recipe, we will see how this can be done for us by using the </span><span class="No-Break"><span class="koboSpan" id="kobo.548.1">Flask-WTF extension.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.549.1">Information</span></p>
<p class="callout"><span class="koboSpan" id="kobo.550.1">More </span><a id="_idIndexMarker221"/><span class="koboSpan" id="kobo.551.1">information about CSRF can be found </span><span class="No-Break"><span class="koboSpan" id="kobo.552.1">at </span></span><a href="https://owasp.org/www-community/attacks/csrf"><span class="No-Break"><span class="koboSpan" id="kobo.553.1">https://owasp.org/ww</span><span id="_idTextAnchor324"/><span class="koboSpan" id="kobo.554.1">w-community/attacks/csrf</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.555.1">.</span></span></p>
<h2 id="_idParaDest-173"><a id="_idTextAnchor325"/><span class="koboSpan" id="kobo.556.1">How to do it...</span></h2>
<p><span class="koboSpan" id="kobo.557.1">Flask-WTF, by default, provides a form that is CSRF-protected. </span><span class="koboSpan" id="kobo.557.2">If we have a look at the recipes so far, we can see that we have explicitly told our form to </span><em class="italic"><span class="koboSpan" id="kobo.558.1">not be CSRF-protected</span></em><span class="koboSpan" id="kobo.559.1">. </span><span class="koboSpan" id="kobo.559.2">We just have to remove the corresponding statement to </span><span class="No-Break"><span class="koboSpan" id="kobo.560.1">enable CSRF.</span></span></p>
<p><span class="koboSpan" id="kobo.561.1">So, </span><strong class="source-inline"><span class="koboSpan" id="kobo.562.1">form = ProductForm(meta={'csrf': False})</span></strong><span class="koboSpan" id="kobo.563.1"> will become </span><strong class="source-inline"><span class="koboSpan" id="kobo.564.1">form = </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.565.1">ProductForm()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.566.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.567.1">Some configuration bits also need to be done in </span><span class="No-Break"><span class="koboSpan" id="kobo.568.1">our application:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.569.1">
app.config['WTF_CSRF_SECRET_KEY'] = 'random key for form'</span></pre>
<p><span class="koboSpan" id="kobo.570.1">By default, the CSRF key is the same as our application’s </span><span class="No-Break"><span class="koboSpan" id="kobo.571.1">secret key.</span></span></p>
<p><span class="koboSpan" id="kobo.572.1">With CSRF enabled, we will have to provide an additional field in our forms; this is a hidden field and contains the CSRF token. </span><span class="koboSpan" id="kobo.572.2">WTForms takes care of the hidden field for us, and we just have to add </span><strong class="source-inline"><span class="koboSpan" id="kobo.573.1">{{ form.csrf_token }}</span></strong><span class="koboSpan" id="kobo.574.1"> to </span><span class="No-Break"><span class="koboSpan" id="kobo.575.1">our form:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.576.1">
&lt;form method="POST" action="/some-action-like-create-
  product"&gt;
    {{ form.csrf_token }}
&lt;/form&gt;</span></pre>
<p><span class="koboSpan" id="kobo.577.1">That was easy! </span><span class="koboSpan" id="kobo.577.2">Now, this is not the only type of form submission that we do. </span><span class="koboSpan" id="kobo.577.3">We also submit AJAX form posts; this actually happens a lot more than normal forms since the advent </span><a id="_idIndexMarker222"/><span class="koboSpan" id="kobo.578.1">of JavaScript-based </span><a id="_idIndexMarker223"/><span class="koboSpan" id="kobo.579.1">web applications, which are replacing traditional </span><span class="No-Break"><span class="koboSpan" id="kobo.580.1">web applications.</span></span></p>
<p><span class="koboSpan" id="kobo.581.1">For this, we need to include another step in our </span><span class="No-Break"><span class="koboSpan" id="kobo.582.1">application’s configuration:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.583.1">
from flask_wtf.csrf import CSRFProtect
#
# Add configurations #
CSRFProtect(app)</span></pre>
<p><span class="koboSpan" id="kobo.584.1">The preceding configuration will allow us to access the CSRF token using </span><strong class="source-inline"><span class="koboSpan" id="kobo.585.1">{{ csrf_token() }}</span></strong><span class="koboSpan" id="kobo.586.1"> anywhere in our templates. </span><span class="koboSpan" id="kobo.586.2">Now, there are two ways to add a CSRF token to AJAX </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.587.1">POST</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.588.1"> requests.</span></span></p>
<p><span class="koboSpan" id="kobo.589.1">One way is to fetch the CSRF token in our </span><strong class="source-inline"><span class="koboSpan" id="kobo.590.1">script</span></strong><span class="koboSpan" id="kobo.591.1"> tag and use it in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.592.1">POST</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.593.1"> request:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.594.1">
&lt;script type="text/javascript"&gt;
    var csrfToken = "{{ csrf_token() }}";
&lt;/script&gt;</span></pre>
<p><span class="koboSpan" id="kobo.595.1">Another way is to render the token in a </span><strong class="source-inline"><span class="koboSpan" id="kobo.596.1">meta</span></strong><span class="koboSpan" id="kobo.597.1"> tag and use it </span><span class="No-Break"><span class="koboSpan" id="kobo.598.1">whenever required:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.599.1">
&lt;meta name="csrf-token" content="{{ csrf_token() }}"/&gt;</span></pre>
<p><span class="koboSpan" id="kobo.600.1">The difference between the two approaches is that the first approach may have to be repeated in multiple places, depending on the number of </span><strong class="source-inline"><span class="koboSpan" id="kobo.601.1">script</span></strong><span class="koboSpan" id="kobo.602.1"> tags in </span><span class="No-Break"><span class="koboSpan" id="kobo.603.1">the application.</span></span></p>
<p><span class="koboSpan" id="kobo.604.1">Now, to add the CSRF token to the AJAX </span><strong class="source-inline"><span class="koboSpan" id="kobo.605.1">POST</span></strong><span class="koboSpan" id="kobo.606.1"> request, we have to add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.607.1">X-CSRFToken</span></strong><span class="koboSpan" id="kobo.608.1"> attribute to it. </span><span class="koboSpan" id="kobo.608.2">This attribute’s value can be taken from either of the two approaches </span><a id="_idIndexMarker224"/><span class="koboSpan" id="kobo.609.1">stated here. </span><span class="koboSpan" id="kobo.609.2">We </span><a id="_idIndexMarker225"/><span class="koboSpan" id="kobo.610.1">will take the second one for </span><span class="No-Break"><span class="koboSpan" id="kobo.611.1">our example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.612.1">
$.ajaxSetup({
    beforeSend: function(xhr, settings) {
        if (!/^(GET|HEAD|OPTIONS|TRACE)$/i
          .test(settings.type)) {
            xhr.setRequestHeader("X-CSRFToken", csrftoken)
        }
    }
})</span></pre>
<p><span class="koboSpan" id="kobo.613.1">This will make sure that a CSRF token is added to all the AJ</span><a id="_idTextAnchor326"/><span class="koboSpan" id="kobo.614.1">AX </span><strong class="source-inline"><span class="koboSpan" id="kobo.615.1">POST</span></strong><span class="koboSpan" id="kobo.616.1"> requests that </span><span class="No-Break"><span class="koboSpan" id="kobo.617.1">go out.</span></span></p>
<h2 id="_idParaDest-174"><a id="_idTextAnchor327"/><span class="koboSpan" id="kobo.618.1">How it works...</span></h2>
<p><span class="koboSpan" id="kobo.619.1">The following screenshot shows what the CSRF token added by WTForms in our form </span><span class="No-Break"><span class="koboSpan" id="kobo.620.1">looks like:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer036">
<span class="koboSpan" id="kobo.621.1"><img alt="Figure 5.9 – The CSRF token" src="image/B19111_05_9.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.622.1">Figure 5.9 – The CSRF token</span></p>
<p><span class="koboSpan" id="kobo.623.1">The token </span><a id="_idIndexMarker226"/><span class="koboSpan" id="kobo.624.1">is completely </span><a id="_idIndexMarker227"/><span class="koboSpan" id="kobo.625.1">random and different for all the requests. </span><span class="koboSpan" id="kobo.625.2">There are multiple ways of implementing CSRF token generation, but this is beyond the scope of this book, although I encourage you to explore some alternative implementations on your own to understand how </span><span class="No-Break"><span class="koboSpan" id="kobo.626.1">it’s done.</span></span></p>
</div>
</body></html>