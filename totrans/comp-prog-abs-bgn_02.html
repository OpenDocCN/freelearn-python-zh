<html><head></head><body>
		<div id="_idContainer024">
			<h1 id="_idParaDest-17"><em class="italic"><a id="_idTextAnchor016"/>Chapter 1</em>: Introduction to Computer Programs</h1>
			<p>Programming is the art and science of writing instructions that a computer can follow to accomplish a task. This task can be playing a game, performing a calculation, or browsing the web, for example. However, before we can learn how to write programs, we should understand what a program is and how a computer can understand and execute the instructions we give it. In this chapter, we will study this in more detail, along with the basics of what a computer is, how it works, and its history. </p>
			<p>Even a basic level of understanding of these topics will help us later on when we discuss the different aspects of writing programs, as we can then relate to how the computer will treat the code we write.</p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>A perspective on the history and origins of the computer</li>
				<li>Background knowledge of the original ideas behind programming </li>
				<li>Understanding what a computer program is</li>
				<li>Learning how a computer program works </li>
				<li>An understanding of what machine code is</li>
			</ul>
			<h1 id="_idParaDest-18"><a id="_idTextAnchor017"/>A brief history of computing</h1>
			<p>Humans have always built tools and made innovations to make life more comfortable and to allow us to do<a id="_idIndexMarker000"/> more things faster and more efficiently. We need to go back in time a few hundred years in order to see the first attempts at building a tool that could resemble a computer. However, before we do that, we might want to define what a computer is. Wikipedia offers the following definition: </p>
			<p class="author-quote">A computer is a machine that can be instructed to carry out sequences of arithmetic or logical operations automatically via computer programming.</p>
			<p>So, a computer is a programmable machine that performs arithmetic or logical operations. Let's review a few inventions from the past using this definition to ascertain which of them could be considered a computer.</p>
			<p>To begin, we can rule out the Jacquard machine, which was the automated loom invented in the early years of the 19th century. These looms could be programmed using punch cards, but they produced woven silk, which, of course, is not the result of an arithmetic or logical operation. Programmability, using punch cards, was an idea that survived well into the computer age, but these looms were not computers.</p>
			<p>If we go even further back in time, we find devices such as the abacus that helped us to get the results of arithmetic operations; however, they were not programmable.</p>
			<p>In the 1770s, Pierre Jaquet-Droz, a Swiss watchmaker, created some mechanical dolls that he called automata. These dolls <a id="_idIndexMarker001"/>could read instructions and could thereby be considered programmable, but they did not perform arithmetic or logical operations. Instead, he created one doll that could play music, one that could make drawings, and one that could write letters (they are referred to as the musician, the draughtsman, and the writer):</p>
			<div>
				<div id="_idContainer005" class="IMG---Figure">
					<img src="image/B15554_01_01.jpg" alt="Figure 1.1: The Jaquet-Droz automata (photograph by Rama, Wikimedia Commons; Cc-by-sa-2.0-fr)"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.1: The Jaquet-Droz automata (photograph by Rama, Wikimedia Commons; Cc-by-sa-2.0-fr)</p>
			<p>In order to see something that resembles a computer, we will need to look at Charles Babbage's inventions. He originated the concept of a programmable computer with his ideas for a machine, called the Difference Engine, and later, a more advanced version called the Analytical Engine. Of the two, the Analytical Engine was particularly groundbreaking as it could be programmable, which meant it could be used to solve different problems. He presented his work in the first half of the 19th century, and even if the machines were never completed, we can agree that Babbage is a very important person behind the basic concept of the programmable computer.</p>
			<p>During the first half of the 20th century, we witnessed some analog computers, but it was not until the second world war, and the years following, that we saw the birth of real digital computers. The difference between an analog and a digital computer is that the former is a mechanical machine that works with an analog input such as voltage, temperature, or<a id="_idIndexMarker002"/> pressure. In comparison, a digital computer works with input that can be represented by numbers. </p>
			<p>Many people<a id="_idIndexMarker003"/> consider the <strong class="bold">Electronic Numerical Integrator and Computer</strong> (<strong class="bold">ENIAC</strong>), constructed by J. Presper Eckert and John Mauchly between 1943 and 1946, as the first digital computer because it was the first one that was both completed and fully functional:</p>
			<div>
				<div id="_idContainer006" class="IMG---Figure">
					<img src="image/B15554_01_02.jpg" alt="Figure 1.2: Betty Jean Jennings and Fran Bilas, both programmers, operate ENIAC's main control panel – U. S. Army Photo (Public Domain [PD])"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.2: Betty Jean Jennings and Fran Bilas, both programmers, operate ENIAC's main control panel – U.S. Army Photo (Public Domain [PD])</p>
			<p>Since then, we have seen tremendous development up until the point we are at today. However, even though our modern computers can do so much more and at a much faster rate than these earlier inventions, the basic principles of how they operate remain the same.</p>
			<h1 id="_idParaDest-19"><a id="_idTextAnchor018"/>A brief history of programming</h1>
			<p>A programmable computer needs to be, well, programmed. So, of course, the history of programming goes hand in hand <a id="_idIndexMarker004"/>with the evolution of computers.</p>
			<p>In 1833, Charles Babbage met Ada Lovelace, daughter of poet Lord Byron. She became very impressed and interested in Babbage's plans for his programmable machines, and their collaboration began. Among other things, she wrote some notes outlining her ideas for how the Babbage Analytical Engine could be programmed. We can call her the inventor of programming, even if we had to wait over 100 years until we had the machine that could make her ideas come true. Her status today is summarized in a <em class="italic">History Extra</em> article, from 2017, by James Essinger:</p>
			<p class="author-quote">Today, Ada is quite rightly seen as an icon of feminist scientific achievement, a heroine of the mind, and one of the earliest visionaries in the early history of the computer. </p>
			<p>In her notes, Lovelace did a couple of remarkable things. The first was that she wrote an algorithm for how Bernoulli numbers, a sequence of rational numbers often used in number theory, could be calculated by the Analytical Engine. This algorithm is considered by many to be the first computer program. Second, she outlined the future of what these machines could do, and, in her vision, she saw that they could be used to draw pictures and compose music. The fact is that when we finally could build a computer, the way they were programmed was heavily influenced by her ideas:</p>
			<div>
				<div id="_idContainer007" class="IMG---Figure">
					<img src="image/B15554_01_03.jpg" alt="Figure 1.3: Ada Lovelace, aged 17 (portrait by Joan Baum; PD-Art)"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.3: Ada Lovelace, aged 17 (portrait by Joan Baum; PD-Art)</p>
			<p>The first digital computers were programmed using machine code – the only thing a computer understands. Later in this chapter, we will talk more about machine code and explore what it is. And, as you will discover, it is just a sequence of numbers.</p>
			<p>In 1949, John Mauchly <a id="_idIndexMarker005"/>proposed something called Brief Code, which was later renamed to Short Code. Short Code can be considered to be one of the first higher-level programming languages. A higher-level programming language is a way for us to write instructions to the computer in a way that is more understandable to humans, which is better than a machine code. The Short Code program is then translated into machine code, and it is that code that the computer executes.</p>
			<p>In 1954, the language Fortran was invented at IBM, by John Backus, and this can be considered to be the first widely used high-level, general-purpose programming language. Fortran is, in fact, still in use.</p>
			<p>The 1950s saw the birth of some other languages that have also survived, such as Lisp and COBOL. Since then, we have had over 2,300 new programming languages. In the next chapter, we will look at how programming languages have evolved and how they are related, but also why people keep inventing new ones.</p>
			<h1 id="_idParaDest-20"><a id="_idTextAnchor019"/>What is a program?</h1>
			<p>A computer is dumb in the sense that, without programs, it can't do anything. A computer program is a<a id="_idIndexMarker006"/> set of instructions that the computer can execute, and it is our job, as programmers, to write these programs using one or more programming languages.</p>
			<p>Most applications that we run, such as a web browser, word processor, or mail client, can't communicate with the computer hardware directly. They require a layer in between that takes care of this. This layer<a id="_idIndexMarker007"/> is called the <strong class="bold">operating system</strong>. Windows and Linux are two examples of well-known operating systems. The main purpose of an operating system is to take care of the direct communication between the applications that we use and the hardware, such as the processor, memory, hard drives, keyboards, and printers. To be able to perform this communication, the operating system requires special programs that are designed to communicate with a particular device. These programs are called <strong class="bold">device drivers</strong>. A somewhat <a id="_idIndexMarker008"/>simplified diagram of how this works is shown here:</p>
			<div>
				<div id="_idContainer008" class="IMG---Figure">
					<img src="image/B15554_01_04.jpg" alt="Figure 1.4: The system architecture"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.4: The system architecture</p>
			<p>Programmers will write the user applications, the operating system, and the device drivers, but the user applications category is by far the most common. The programs we write will communicate with the system kernel, which is the core of the operating system. The operating system will take care of the direct communication with the underlying hardware. The good thing about this structure is that we only need to talk to the operating system, so we don't need to think about what kind of mouse the user has or how to send a line of text to a particular printer model. The operating system will talk to the device drivers for the mouse and the printer, and the driver will know precisely how to communicate with that device.</p>
			<p>If we write a program and that<a id="_idIndexMarker009"/> program wants to print the text <strong class="bold">Hi there computer!</strong> to the screen, then this request will be sent to the operating system. The operating system will pass this on to the device driver for the monitor, and this driver will know how to send this to the monitor connected to this computer: </p>
			<div>
				<div id="_idContainer009" class="IMG---Figure">
					<img src="image/B15554_01_05.jpg" alt="Figure 1.5: How instructions flow from the application to the hardware"/>
				</div>
			</div>
			<p>The text entered will not magically appear on the screen, though. It will pass through several layers inside the computer. In 1945, the Hungarian-American mathematician and physicist John Von Neumann, and others, created a document titled <em class="italic">First Draft of a Report to the EDVAC</em>. In this 101-page document, the first logical design of a computer using the concept of a stored program was presented. Additionally, the design of an electronic digital computer was described. This design is today known as the Von Neumann Architecture, and it defines four different components that can be used to construct a computer. These <a id="_idIndexMarker010"/>components are as follows:</p>
			<ul>
				<li>A processing unit that has an arithmetic logic unit and registers for the processing unit to use.</li>
				<li>A control unit that contains an instruction register and a program counter. These are used to execute programs.</li>
				<li>Memory that stores data and instructions. This memory is volatile, meaning that its content will be erased <a id="_idIndexMarker011"/>when the power is turned off or the computer is restarted.</li>
				<li>External mass storage. This is long-time storage for programs and data that can also be preserved after a computer restarts.</li>
				<li>Input and output mechanisms. Today, this is typically a keyboard, a mouse, and a monitor.</li>
			</ul>
			<p>All of these components, except external mass storage, come into play when text is entered on the keyboard and displayed on the screen.</p>
			<p>As mentioned in the previous section, the computer can only understand one thing, and that is machine code. The machine code is a set of numerical values that the computer interprets as different instructions. The computer only works with numbers in the binary form, also known as base 2, and that is why we often hear that a computer only understands zeros and ones.</p>
			<p>To understand the different bases, let's consider how many digits they have. In our daily life, we use the decimal system, called base 10, because we have 10 digits, from 0 to 9 (we assume the reason for this is that we started counting on our fingers). In the base 2 binary system, we only have two digits, 0 and 1. In base 16, the hexadecimal system, we have 16 digits. As we only have digits for 0 to 9, we must use some letters in the hexadecimal system to represent the values between 10 and 15. Those letters are A to F. We do this because we must understand the difference between digits and numbers: a digit is a single symbol representing a value, whereas a number is a sequence of one or more digits. So, for example, we can talk about the digit 7, but not the digit 12 (as it is a number made up of 2 digits). In the hexadecimal system, we need to represent 16 values; therefore, we need 16 digits. Since we only have 10 digits in our decimal system, we need to use something<a id="_idIndexMarker012"/> else. In this case, it is the letters A to F.</p>
			<p>Refer to the following table for a comparison between decimal, binary, and hexadecimal numbers:</p>
			<div>
				<div id="_idContainer010" class="IMG---Figure">
					<img src="image/B15554_Table_1.1.jpg" alt=""/>
				</div>
			</div>
			<p class="figure-caption">Table 1.1: The numbers 1-15 in the decimal, binary, and hexadecimal format</p>
			<h2 id="_idParaDest-21"><a id="_idTextAnchor020"/>How does a computer program work?</h2>
			<p>All the tools that we, as humans, have created have helped us with physical labor. Finally, we reached a<a id="_idIndexMarker013"/> point where we could invent a tool that would help us with mental labor: the computer.</p>
			<p>When planning the design of such a machine, the inventors discovered that it must perform four different tasks. The computer would need to take data as input, store that data, process the data, and then output the result.</p>
			<p>These four tasks are common to all the computers we have ever built. Let's take a closer look at these tasks:</p>
			<ol>
				<li value="1">We can provide input to the computer in many ways, such as with a keyboard, a mouse, voice commands, and touch screens. </li>
				<li>The input data is sent to the computer's storage: the internal memory. </li>
				<li>The <strong class="bold">CPU</strong> (which is the <strong class="bold">central processing unit</strong>) retrieves the data from storage and performs<a id="_idIndexMarker014"/> operations on it. </li>
				<li>The result of these operations is then sent back to be stored in memory again before it is sent out as output.</li>
			</ol>
			<p>Just as different devices can be used to send input to the computer, so too can the output be in different forms, and we can use various appliances to present the result, such as text to a printer, music through the speakers, or video to a screen. The output from one computer can<a id="_idIndexMarker015"/> even be inputted to another computer:</p>
			<div>
				<div id="_idContainer011" class="IMG---Figure">
					<img src="image/B15554_01_06.jpg" alt="Figure 1.6: The four tasks of a computer"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.6: The four tasks of a computer</p>
			<p>All four steps – input, storage, process, and output – handle data. Let's explore what this data is and what form it takes.</p>
			<h1 id="_idParaDest-22"><a id="_idTextAnchor021"/>Understanding the binary system</h1>
			<p>Why is it that computers only work with zeros and ones? Why can't they work directly with text or<a id="_idIndexMarker016"/> images, for example? The answer is that it is rather easy to build circuits that can represent two states. If you have an electrical wire, you can either run electricity through it or not. The flow or no flow of electricity could represent several things, such as on or off, true or false, or zero or one. Let's think of these two states as zero and one for now, with zero representing no electricity flowing and one symbolizing that we do have flow. If we can serve these two states, we could add more wires and, by doing that, have more zeros and ones.</p>
			<p>But what could we possibly do with all of these zeros and ones? Well, the answer is that we can do almost anything. For example, with only zeros and ones, we can represent any integer by using the binary numeral system. Let's demonstrate how that works.</p>
			<p>To understand binary numbers, we must start by looking at the decimal numeral system. In the decimal system, we work with 10 digits, from 0 to 9. When we count, we go through these digits until we reach 9. Now we have run out of digits, so we start over from zero and add a one in front of it, forming the number 10. Then, we continue until we reach 19, then we do the same thing again; start over from zero and increase the value in front of the zero by one, so we get 20. </p>
			<p>Another way to think about different numeral systems is to think about the value a position represents. Let's consider an example. The number 212 has the digit 2 in two places, but their position gives them two different values. If we start from the right and move to the left, we can say that we take the first digit, 2, and multiply it by 1. Then, we take the second digit, 1, and multiply it by 10. Finally, we take the last digit, 2, and multiply it by 100. If we move from right to left, each step is worth 10 times as much as the previous step. Take a look at this calculation represented in the following table:</p>
			<div>
				<div id="_idContainer012" class="IMG---Figure">
					<img src="image/B15554_Table_1.2.jpg" alt="Table 1.2:The positional values of a binary number"/>
				</div>
			</div>
			<p class="figure-caption">Table 1.2. The positional values of a decimal number</p>
			<p>When using the binary system, we do the same thing, but only using the digits 0 and 1. We start our counting with 0, followed by 1. At this point, we run out of digits, so we start over from 0, adding a 1 in front of it. </p>
			<p>Counting in binary looks like this:</p>
			<p>0, 1, 10, 11, 100, 101, 110, 111, 1000, 1001, 1010, 1011, 1100, 1101, 1110, 1111, and so on</p>
			<p>When it comes to the values each position has for binary numbers, it works just as it does with decimal numbers. However, the value for each position is not multiplied by 10 but instead by 2. We multiply the first digit by 1, the second digit by 2, the third digit by 4, and so on. To make<a id="_idIndexMarker017"/> things simpler, we could say that a one in a particular position means that the number representing that position shall be a part of the final value, and zero means it shall not. Take a look at this table for binary number 11010100:</p>
			<div>
				<div id="_idContainer013" class="IMG---Figure">
					<img src="image/B15554_Table_1.3.jpg" alt="Table 1.3: Interpreting binary number 11010100"/>
				</div>
			</div>
			<p class="figure-caption">Table 1.3: Interpreting binary number 11010100</p>
			<p>Here, we have ones at the positions represented by 128, 64, 16, and 4, so now we can add them together (we can ignore the positions with zeros as adding zero to something will not make any difference) to get what the binary number of 11010100 is in decimal form, which is 212.</p>
			<p>If we want to convert a decimal number, say 27, into binary, we start by thinking how far we can go through the sequence of positional values: 1, 2, 4, 8, 16, and so on. Which is the largest of these that we can find that is smaller than or equal to 27? The answer is 16, so the first 1 in this binary number will be at this position. On all positions before 16, we can insert 0:</p>
			<div>
				<div id="_idContainer014" class="IMG---Figure">
					<img src="image/B15554_01_07.jpg" alt="Figure 1.7: Finding the first position that is less than or equal to 27"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.7: Finding the first position that is less than or equal to 27</p>
			<p>We then subtract 16 from 27 and get 11 and repeat the process with this value. The largest value that is less than or equal to 11 is 8:</p>
			<div>
				<div id="_idContainer015" class="IMG---Figure">
					<img src="image/B15554_01_08.jpg" alt="Figure 1.8: Finding the first position that is less than or equal to 8"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.8: Finding the first position that is less than or equal to 8</p>
			<p>We subtract 8 from 11 <a id="_idIndexMarker018"/>and get 3. The next value, 4, is larger than 3, so we insert a 0 at this position:</p>
			<div>
				<div id="_idContainer016" class="IMG---Figure">
					<img src="image/B15554_01_09.jpg" alt="Figure 1.9. We encounter a position that is greater than 3 so we insert a 0"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.9: We encounter a position that is greater than 3 so we insert a 0</p>
			<p>As we have not inserted a 1 yet, we keep the value of 3 and try to find a value that works for it. The next one, 2, is less than or equal to 3, so we insert a 1 here and then subtract 2 from 3 and get 1:</p>
			<div>
				<div id="_idContainer017" class="IMG---Figure">
					<img src="image/B15554_01_010.jpg" alt="Figure 1.10: 2 is less than 3, so we insert a 1 at this position"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.10: 2 is less than 3, so we insert a 1 at this position</p>
			<p>We repeat this until we reach 0:</p>
			<div>
				<div id="_idContainer018" class="IMG---Figure">
					<img src="image/B15554_01_011.jpg" alt="Figure 1.11: When we have reached the end, we have arrived at the complete binary number"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.11: When we have reached the end, we have arrived at the complete binary number</p>
			<p>We now know that 27 will be 11011 in binary. We can ignore the leading zeros.</p>
			<p>When we have one single<a id="_idIndexMarker019"/> binary<a id="_idIndexMarker020"/> digit, we call it a <strong class="bold">bit</strong>, and if we place them in groups of 8 bits, we call them a <strong class="bold">byte</strong>. One byte can hold values between 0 and 255. This is because a 1 in all positions (11111111) will be 128 + 64 + 32 + 16 + 8 + 4 + 2 + 1= 255.</p>
			<p>By using lots of zeros and ones, the computer can represent any number in binary form, and if it can represent <a id="_idIndexMarker021"/>numbers, it can serve other things too, such as text.</p>
			<h2 id="_idParaDest-23"><a id="_idTextAnchor022"/>Understanding ASCII and Unicode</h2>
			<p>If you give each letter of the English alphabet a <a id="_idIndexMarker022"/>numerical value, you <a id="_idIndexMarker023"/>could represent<a id="_idIndexMarker024"/> text with <a id="_idIndexMarker025"/>numbers. We could, for example, say that A=1, B=2, and so on. The computer does not use these values for the letters, but instead, it can either use something that is called the ASCII table (pronounced <em class="italic">as-key</em>) or another representation that is called Unicode. It is not important to understand exactly how they work; the only thing we need to understand is that a number can represent every character. This number can then be looked up using either the ASCII table or Unicode.</p>
			<p>The ASCII table uses one byte to represent different characters. The table starts with characters that are non-printable. Eventually, it reaches the characters in the English alphabet. So, A, for example, is 65, B is 66, and so on. 255 characters will not take us far as we have lots of different alphabets around the world, and we also want to represent other symbols. That is why we also have Unicode. Its mapping to individual characters is not as direct as it is in the ASCII table, but all we need to know right now is that with it, we can use numbers to represent characters.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Non-printable characters are symbols that are not used for visual representation; for example, when we need a way to indicate a tab or a new line, or if printing text to a printer, we want the printer to continue to the next page. </p>
			<h2 id="_idParaDest-24"><a id="_idTextAnchor023"/>Representing other forms of data</h2>
			<p>We've learned<a id="_idIndexMarker026"/> how to represent text in binary, but what about things other than text and numbers? What about images? And video? And sound?</p>
			<p>Images are made up of pixels, and three values, RGB, represent each pixel. These values tell the computer how much red, green, and blue a pixel has:</p>
			<div>
				<div id="_idContainer019" class="IMG---Figure">
					<img src="image/B15554_01_012.jpg" alt="Figure 1.12: Three values represent a single pixel, indicating how much red, green, and blue it has"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.12: Three values represent a single pixel, indicating how much red, green, and blue it has</p>
			<p>A video is nothing more than a composite of many images, so every frame is an image; therefore, it can be represented the same way.</p>
			<p>A waveform can represent sound. Each peak and valley can be a number:</p>
			<div>
				<div id="_idContainer020" class="IMG---Figure">
					<img src="image/B15554_01_013.jpg" alt=""/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.13: Audio depicted as a waveform</p>
			<p>Now that we know how the computer can represent data, we have to find out how it processes it. To understand that, we <a id="_idIndexMarker027"/>must first dive into a corner of mathematics that is called Boolean algebra.</p>
			<h2 id="_idParaDest-25"><a id="_idTextAnchor024"/>Boolean algebra</h2>
			<p>George Boole, who <a id="_idIndexMarker028"/>lived between 1815 and 1864, was a self-taught English mathematician and the inventor of Boolean logic, which is the basis of how all our computers work. </p>
			<p>Boolean logic, sometimes referred to as Boolean algebra, is a form of mathematics that works with only two values: <strong class="bold">true</strong> and <strong class="bold">false</strong>. It also defines three operations that we can perform on these two values: <strong class="bold">AND</strong>, <strong class="bold">OR</strong>, and <strong class="bold">NOT</strong>. </p>
			<p><strong class="bold">NOT</strong> is the simplest of these operations as all it does is just switch the value, so not true is false, and not false is true. For example, if I say, "It is raining today," this statement can be true or false. It is true if it rains and false if it is not. If I instead say, "It is <strong class="bold">NOT</strong> raining today," then the statement will be true if it doesn't rain and false if it does.</p>
			<p><strong class="bold">AND</strong> takes two statements that can be either true or false and evaluates them into a single value. The outcome will be true if both incoming values are true and false in all other situations. If I say, "It is raining today, <strong class="bold">AND</strong> I have a blue umbrella," the statement will only be true if both parts are true, that is, if it is actually raining and my umbrella is actually blue. However, if it is raining but my umbrella is pink, what I say will be false, even though half of it was true.</p>
			<p><strong class="bold">OR</strong> works on two parts, just like <strong class="bold">AND</strong>, but now only one of the two must be true to make the statement true. If I say, "Today I will go to the beach <strong class="bold">OR</strong> I will go to town," then the statement will be true whether I either go to the beach or to town, and also if I manage to do both.</p>
			<p>We can illustrate how these three operations work in something called a truth table. A truth table is a way to describe how an input of the <strong class="bold">true</strong> and <strong class="bold">false</strong> values is transformed by an operation. The input is often referred to as <strong class="bold">P</strong> if we only have one input value, or <strong class="bold">P</strong> and <strong class="bold">Q</strong> if we have two. The result is shown in the last column.</p>
			<p>If <strong class="bold">P</strong> is the input value, the truth table for <strong class="bold">NOT</strong> will look like this:</p>
			<div>
				<div id="_idContainer021" class="IMG---Figure">
					<img src="image/B15554_Table_1.4.jpg" alt="Table 1.4: The truth table for NOT"/>
				</div>
			</div>
			<p class="figure-caption">Table 1.4: The truth table for NOT</p>
			<p>For <strong class="bold">AND</strong>, the truth table looks like this if <strong class="bold">P</strong> and <strong class="bold">Q</strong> are the input:</p>
			<div>
				<div id="_idContainer022" class="IMG---Figure">
					<img src="image/B15554_Table_1.5.jpg" alt="Table 1.5: The truth table for AND"/>
				</div>
			</div>
			<p class="figure-caption">Table 1.5: The truth table for AND</p>
			<p>For <strong class="bold">OR</strong>, the truth <a id="_idIndexMarker029"/>table looks like this:</p>
			<div>
				<div id="_idContainer023" class="IMG---Figure">
					<img src="image/B15554_Table_1.6.jpg" alt="Table 1.6: The truth table for OR"/>
				</div>
			</div>
			<p class="figure-caption">Table 1.6: The truth table for OR</p>
			<p>As you can see, the only way an <strong class="bold">AND</strong> operation can be <strong class="bold">true</strong> is if both parts are true, and the only time <strong class="bold">OR</strong> can be false is if both parts are <strong class="bold">false</strong>.</p>
			<p>When Claude Shannon, an American mathematician and electrical engineer, published his master's degree thesis in 1937, <em class="italic">A Symbolic Analysis of Relay and Switching Circuits</em>, he based his work on the ideas of Boole. From Shannon's ideas, Boolean logic made its way into our modern computers because, with the help of the simple operations that Boole defined, we could transform any value that can be in one of two states: true or false, on or off, or, in the case of binary numbers, one or zero.</p>
			<p>We can accomplish these operations with the help of transistors. There is no need for us to go into the details of how a transistor works – just knowing that it can be used to represent true/false, on/off, or 0/1 is enough. We can then connect several transistors into different configurations to accomplish operations such as <strong class="bold">AND</strong>, <strong class="bold">OR</strong>, and <strong class="bold">NOT</strong>. These combinations are called <strong class="bold">gates</strong>, so we will have a group of transistors called an <strong class="bold">AND gate</strong>, one that is called an <strong class="bold">OR gate</strong>, and one that is called a <strong class="bold">NOT gate</strong>. These gates can then be connected further to construct circuits that can add, subtract, multiply, and divide. We <a id="_idIndexMarker030"/>have now built a machine that can represent both numbers and these basic operations. We have done this using only numbers, and all these numbers will be in binary, so we have a machine that only works with zeros and ones: the computer.</p>
			<h2 id="_idParaDest-26"><a id="_idTextAnchor025"/>Machine code – the native language of the computer</h2>
			<p>Now that we have circuits that can perform some basic operations on numbers, and we have data in the form<a id="_idIndexMarker031"/> of numbers, we can start to write programs that will perform operations on the data. We can do that with the only thing the computer understands: machine code. As numbers can represent everything, the instructions we give to the computer will be – yes, that's right – just numbers.</p>
			<p>Each processor type has a specific set of instructions. That is why a program written for a Mac can't run on a PC running Windows, for example. So, the instructions can be machine code. Machine code has several <a id="_idIndexMarker032"/>operations, called <strong class="bold">opcodes</strong>. The operations can be things such as <strong class="bold">AND</strong>, <strong class="bold">OR</strong>, <strong class="bold">ADD</strong>, and so on. Each opcode has a unique number. For example, <strong class="bold">AND</strong> could have an opcode value of 1, and <strong class="bold">OR</strong> could have an opcode value of 9. </p>
			<p>The processor will also have several registers. A register is a small area, sometimes referred to as a data holding place, where the processor can store data it is currently working with. Before executing an operation, we will need to move the data we want as input to the operation, from memory, into some of these registers. The result of the operation, the output, is also stored in a register. In reality, things are a bit more complicated than this, but we do not need to go into all the details here. </p>
			<p>We can now recall the image of the four operations that were common for all computers: input, storage, process, and output. We first get some <strong class="bold">input</strong>, and it will go to the computer's memory for <strong class="bold">storage</strong>. The processor will then retrieve it from its registers and perform operations on it, which is the <strong class="bold">process</strong> part. When we have the result of the operations, it will go back into the memory so that it can later be sent to the <strong class="bold">output</strong>.</p>
			<p>One way to write these instructions is to use something called an <em class="italic">assembly</em>. This is a way of writing a program where we use three-letter abbreviations for the opcodes and have names for the registers. By doing this, it will be easier to read and understand the instructions we give. We<a id="_idIndexMarker033"/> can then use a program that can translate the assembly code into machine code. </p>
			<p>The assembly language is the first programming language we encounter. The assembly language can look like th<a id="_idTextAnchor026"/>is:</p>
			<p class="source-code">mov     eax, 14</p>
			<p class="source-code">mov     ebx, 10</p>
			<p class="source-code">add     eax, ebx</p>
			<p>Here, we are moving (<strong class="source-inline">mov</strong>) the value of 14 into one of the registers, called <strong class="source-inline">eax</strong>, and then we are moving the value of 10 into another register, called <strong class="source-inline">ebx</strong>. We are then performing the <strong class="source-inline">add</strong> operation on the contents of these two registers. The result will be written back into a register; perhaps <strong class="source-inline">eax</strong> will be reused for this.</p>
			<p>If the <strong class="bold">move</strong> operation has an opcode of 136 and the <strong class="bold">add</strong> operation has an opcode of 1, we can use these values together with the numerical representations of the registers to have all of this in only numerical format. And, as we know, everything that is numerical can be represented in binary form, that is, with zeros and ones.</p>
			<p>Now we have all that, we need to look at some machine code.</p>
			<h2 id="_idParaDest-27"><a id="_idTextAnchor027"/>Example machine code</h2>
			<p>Remember that the<a id="_idIndexMarker034"/> instructions we give will be different depending on what processor and operating system we use. The following is an example of what machine code can look like for a program printing the text <strong class="bold">Hello, World!</strong> to the screen on a computer using the Linux operating system:</p>
			<p class="source-code">b8    21 0a 00 00   </p>
			<p class="source-code">a3    0c 10 00 06   </p>
			<p class="source-code">b8    6f 72 6c 64   </p>
			<p class="source-code">a3    08 10 00 06   </p>
			<p class="source-code">b8    6f 2c 20 57   </p>
			<p class="source-code">a3    04 10 00 06   </p>
			<p class="source-code">b8    48 65 6c 6c   </p>
			<p class="source-code">a3    00 10 00 06   </p>
			<p class="source-code">b9    00 10 00 06   </p>
			<p class="source-code">ba    10 00 00 00   </p>
			<p class="source-code">bb    01 00 00 00   </p>
			<p class="source-code">b8    04 00 00 00   </p>
			<p class="source-code">cd    80            </p>
			<p class="source-code">b8    01 00 00 00   </p>
			<p class="source-code">cd    80            </p>
			<p>When looking at this<a id="_idIndexMarker035"/> program, we can write the numbers in binary or decimal format if we want to. However, to make it easier to read, we often use hexadecimal numbers as we can then use fewer digits. For example, 15 in the decimal format (two digits) is 1111 (four digits) in binary, but only F (one digit) in hexadecimal. It is just more compact – that is the only reason we do this.</p>
			<p>Don't worry if you don't understand anything about the machine code program. It is not supposed to be readable for humans; however, for the computer, this all makes sense.</p>
			<p>Writing code in machine code is error-prone. A number in the wrong place can be the difference between success and disaster. The natural next step, therefore, has been to create something more comfortable for humans to read and write, which the computer can then translate into machine code. One such measure has been the creation of the assembly language that we talked about earlier. </p>
			<p>Here is the same program, written in the assembly language: </p>
			<p class="source-code">section     .text</p>
			<p class="source-code">global      _start                               </p>
			<p class="source-code">_start:                                         </p>
			<p class="source-code">    mov     edx,len                             </p>
			<p class="source-code">    mov     ecx,msg                             </p>
			<p class="source-code">    mov     ebx,1                               </p>
			<p class="source-code">    mov     eax,4                               </p>
			<p class="source-code">    int     0x80                                </p>
			<p class="source-code">    mov     eax,1                               </p>
			<p class="source-code">    int     0x80                                </p>
			<p class="source-code">section     .data</p>
			<p class="source-code">msg     db  'Hello, world!',0xa                 </p>
			<p class="source-code">len     equ $ - msg                             </p>
			<p>As you can see, this is <a id="_idIndexMarker036"/>still not that easy to understand. In the next chapter, we will learn how to write the same program using languages that resemble human language to a much higher degree.</p>
			<h1 id="_idParaDest-28">S<a id="_idTextAnchor028"/>ummary</h1>
			<p>In this chapter, we have gone back in history and explored the development of computers. The history of computers is a vast topic, but we touched on some important events that have made computers the fantastic machines that we know today.</p>
			<p>For a computer to be useful, it requires programs, and to be able to write programs, we need programming languages. We learned that the development of programming was closely related to the development of computers, even if Lady Ada Lovelace managed to write what was considered to be the first computer program about 100 years before the first computer was built.</p>
			<p>With the history of computers covered, we then turned our attention to what a computer program is and how the computer can use the instructions given in the program to accomplish the intentions of the programmer. To do that, we examined the smallest parts of data a computer can handle, the bits, which are the zeros and ones of the binary representation of numbers. We learned that the ideas of George Boole and his Boolean logic are the core of how a computer can transform data. Boole's ideas will return in later chapters, as we will use them when writing programs as well.</p>
			<p>Finally, we took a closer look at the language of computers, machine code. We saw how hard it is for us to read and understand, and because of that, we will appreciate the next chapter, where we will learn what we can do to avoid working with this difficult code directly.</p>
		</div>
	</body></html>