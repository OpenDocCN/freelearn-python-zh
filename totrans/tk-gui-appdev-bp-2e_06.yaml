- en: Paint Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We used the Canvas widget to define a custom widget in [Chapter 5](73aef6b5-11e2-4cb9-bb4a-5c96bf81dfcc.xhtml),
    *Building an Audio Player*. The Canvas widget is truly one of Tkinter's highlights.
    It is an incredibly powerful and flexible widget. Let's, therefore, devote most
    of this chapter to looking at the Canvas widget in detail.
  prefs: []
  type: TYPE_NORMAL
- en: We will now develop a paint application. The application will let the user draw freehand
    lines, straight lines, circles, rectangles, arcs, and other polygons. It will also
    let the user define new complex shapes.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to exploring the Canvas widget, we will also develop a tiny GUI framework
    on top of the Tkinter interface. As you will see, frameworks are a great way to
    maximize code reuse. This makes them a powerful tool for **Rapid ****Application
    Development (RAD)**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the key learning objectives for this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Master the Canvas widget API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn to build and use custom GUI frameworks for maximum code reuse and rapid
    application development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn to use the `colorchooser` module of Tkinter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn to use the ttk ComboBox widget
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get to know available widget methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reinforce things that we have learned in previous projects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overview of the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In its final form, our paint application would look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/caaa69fc-faea-49ba-ab31-c4950c8a1e36.png)'
  prefs: []
  type: TYPE_IMG
- en: There are no external library requirements for this chapter, so let's dive into
    the code.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a tiny framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So why do we need another framework on top of Tkinter? If we need to build just a
    single program, we need not build a framework. However, if we find ourselves writing
    the same boilerplate code over and over again, a framework is what we need. That
    is, a framework is a tool that lets us easily generate generic and often-used patterns
    with ease.
  prefs: []
  type: TYPE_NORMAL
- en: Consider, for example, menus used in programs. A menu is such a common element
    in most programs, yet we need to handcraft each menu item every time we sit down to
    write a program. What if we could further abstract to simplify menu generation?
  prefs: []
  type: TYPE_NORMAL
- en: This is where frameworks come in handy.
  prefs: []
  type: TYPE_NORMAL
- en: Say you have a program that has 10 different top-level menus. Say each of the
    top-level menus has five menu items. We will have to then write 50 lines of code
    simply to display these 50 menu items. You have to link each of them manually
    to other commands besides having to set tons of options for each of them.
  prefs: []
  type: TYPE_NORMAL
- en: If we keep doing this for all our widgets, our GUI programming becomes an exercise in
    typing. Every extra line of code that you write adds to the program complexity, making
    it more difficult for someone else to read, maintain, modify, and/or debug the
    code.
  prefs: []
  type: TYPE_NORMAL
- en: This is where using a custom framework comes to our aid. Let's develop a tiny framework
    that makes menu generation easy for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'We create a file, `framework.py`, and create a new class, `Framework`, to the
    file. Every class that uses this framework must inherit from this class and should
    pass the root window as an argument to this class by calling the super method
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This will make all methods defined in the `Framework` class available to the inheriting
    class.
  prefs: []
  type: TYPE_NORMAL
- en: We will now define a method, `build_menu`, which takes a tuple in an expected format
    as input and automatically creates the menu for us. Let's define an arbitrary rule
    that each group of menu items must be represented by a single entry in a tuple.
  prefs: []
  type: TYPE_NORMAL
- en: 'Furthermore, we come up with a rule that each item in the tuple must be presented
    in the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '`MenuSeparator` is denoted by a string `''sep''`.'
  prefs: []
  type: TYPE_NORMAL
- en: An alternative representation of menu definition could be specifying it as a
    tuple instead of a string definition, which is like asking the user to already
    split the definition rather than us having to extract the menu definition from
    a string.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, passing this tuple as an argument to the `build_menu` method
    should generate three menus as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Take a look at the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/178dbd61-7fd6-4922-8257-8deab81bf4b2.png)'
  prefs: []
  type: TYPE_IMG
- en: The first item of the string (before dash (`-`)) represents the top-level menu button.
    Each subsequent part of the string separated by a forward slash (`/`)  represents
    one menu item, its accelerator key, and the attached command callback.
  prefs: []
  type: TYPE_NORMAL
- en: The position of the ampersand symbol (`&`) represents the position of the shortcut
    key to be underlined. If we encounter the string `sep`, we add a menu separator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have defined the rules, the code for `build_menu` is as follows: (see
    the `framework.py` code):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The description of the code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The method, `build_menu`, operates on a tuple by the name `menu_definition`, which
    must specify all desired menus and menu items in the exact format, as previously
    discussed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It iterates through each item in the tuple, splitting the item based on the dash
    (`–`) delimiter, building the top-menu button for each item left to the dash (`-`
    ) delimiter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It then splits the second part of the string based on the comma (`,`) delimiter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It then iterates through this second part, creating menu items for each of the
    parts, adding the accelerator key, command callback, and underline key using another
    method, `_add_menu_command`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `_add_menu_command` method iterates through the string and adds a separator
    if it finds the string `sep`. If not, it next searches for an ampersand (`&`)
    in the string. If it finds one, it calculates its index position and assigns it
    to the underline variable. It then replaces the ampersand value with an empty string,
    because we do not want to display the ampersand in our menu item.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If an ampersand is not found in a string, the code assigns `None` to the underline
    variable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, the code adds a command callback, accelerator key, and underline value
    to the menu item. Note that our framework adds only the accelerator key label.
    It is the developer's responsibility to bind events to the bound keys.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our demonstration of making GUI frameworks ends here. We can now use this method
    to define literally hundreds of menus simply by adding one new line for each group
    of menus.
  prefs: []
  type: TYPE_NORMAL
- en: However, this is a rather rudimentary framework. The rules for defining items
    are completely arbitrary. The choice of delimiters means that we can no longer
    use the dash (`-`), slash (`/`), and ampersand (`&`) characters that we have used
    as delimiters in any menus that we define using this framework.
  prefs: []
  type: TYPE_NORMAL
- en: Our framework does not lay down rules for any other widgets. In fact, this definition
    is not even sufficient to generate other types of menu such as cascading menus,
    check button menus, or radio button menus. We will, however, not extend the framework further,
    as it is sufficient to have developed the concept behind framework design and usage
    and that is all we need to use in our paint application.
  prefs: []
  type: TYPE_NORMAL
- en: We have also included a small test in the `framework.py` file. If you execute
    the file as a standalone program, it should pop up a window and define some menus for
    testing.
  prefs: []
  type: TYPE_NORMAL
- en: Fully-fledged frameworks use more structured markup languages to represent rules.
    XML is one of the most popular choices for writing GUI frameworks. You can find
    an example of a full-blown XML-based Tkinter RAD (tkRAD) framework here: [https://github.com/muxuezi/tkRAD](https://github.com/muxuezi/tkRAD).
    A simple menu implementation using the preceding framework can be seen here:[ https://github.com/muxuezi/tkRAD/blob/master/xml/rad_xml_menu.py](https://github.com/muxuezi/tkRAD/blob/master/xml/rad_xml_menu.py).
  prefs: []
  type: TYPE_NORMAL
- en: Using a framework for smaller programs may be overkill, but they are invaluable assets
    for large programs. Hopefully, you should now be able to appreciate the benefits
    of using frameworks for larger programs.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the code for `build_menu`, we can extend it to add as many
    menu items as required without having to write repetitive and similar code for
    each of them.
  prefs: []
  type: TYPE_NORMAL
- en: This ends our first iteration. We will use this tiny framework to define the
    menu for our drawing program in the next step.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a broad GUI structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s now set up the broad GUI elements of our program. We will create a `PaintApplication`
    class in `6.01.py`. Since we want to draw the menu using our framework, we import
    the framework into our file and inherit from the `Framework` class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `__init__` method calls another method, `create_gui`, which is responsible
    for creating the basic GUI structure for our program.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `create_gui` method simply delegates the task to five separate methods,
    each being responsible for creating one section of the GUI as follows (see code
    `6.01.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'These five methods together build a structure as shown in the following screenshot
    (see code `6.01.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/453f9f3d-5ab0-4f15-ab85-cb14575c2383.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We have written similar code in all previous chapters, hence we will not reproduce the
    code for these five methods here. Note, however, a few things about the code in `6.01.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: Since we want to use the framework, we inherit from the `Framework` class and
    call its `__init__` method using `` `super()` ``
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `create_menu` method specifies the tuple for our menu definition and calls
    the `build_menu` method defined earlier in our framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We define a lot of empty methods that will be implemented later. Each empty
    method is added as a command callback to individual menu items. The empty methods
    defined here are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This gives us a broad GUI structure for our program. Next, we will look at interacting with
    the drawing canvas.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with mouse events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we draw in a paint program, we use a mouse as the primary input device.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are primarily two kinds of mouse event that cause changes on the drawing canvas
    and are therefore of interest:'
  prefs: []
  type: TYPE_NORMAL
- en: Click and release
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Click, drag, and release
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is also a third event in which we have limited interest—the mouse movements
    with no buttons clicked. Our interest is limited there since an unclicked motion
    normally does not cause any changes on the canvas.
  prefs: []
  type: TYPE_NORMAL
- en: We ignore right-click and wheel-scroll as we will not be using them in our program.
  prefs: []
  type: TYPE_NORMAL
- en: In both the preceding cases, we need to know where the mouse was first clicked
    and where it was released. For click and release, this could be the same location.
    For click, drag, and release this will normally be different locations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Accordingly, we define four attributes to keep track of the coordinates for
    these two locations (see code `6.02.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Our immediate goal then is to bind our mouse events in such a way that any click
    or drag gives us the value of these four start and end coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: The coordinates of the Canvas widget begin at the top-left corner ((`0, 0`)
    is the top-corner).
  prefs: []
  type: TYPE_NORMAL
- en: 'The Canvas widget uses two coordinate systems:'
  prefs: []
  type: TYPE_NORMAL
- en: The **window coordinate system**, which is always `0, 0` for the leftmost corner,
    no matter where you scroll down or up the canvas
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **canvas coordinate system**, which specifies where the items are actually
    drawn on the canvas
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will mostly be interested in the canvas coordinate system, but mouse events
    emit data on the window coordinate system. To convert from the window coordinate
    system to the canvas coordinate system we can use the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now modify our `__init__` method to also call a method, `bind_mouse`.
    We define the `bind_mouse` method as follows (see code `6.02.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We then define the first three methods that were bound just now. We ignore
    the unpressed motion for now by making an empty method. Remember that we are interested in
    getting the start and end coordinates, which are acquired as follows (see code `6.02.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We have temporarily added two `print` statements to show these four values on
    the console (see code `6.02.py`).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the location of the start and end mouse events, we can act
    upon those events to do all kinds of activities on the canvas.
  prefs: []
  type: TYPE_NORMAL
- en: Adding toolbar buttons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next, we need to add 16 buttons to the left toolbar. Furthermore, depending
    on which button is clicked, different options would show up in the top bar as
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/09a714e8-a7fb-4040-9a3a-2eebacdd4b95.png)'
  prefs: []
  type: TYPE_IMG
- en: We do not want our code structure to be too bloated by conditional logic to
    switch among these 16 functions. Therefore, we will call these methods dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: 'We first begin by defining a tuple of all 16 function names (see code `6.01.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Doing so ensures that we do not have to call each method explicitly from our
    code. We can instead use the index of the tuple to retrieve the method name and
    call it dynamically using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This makes sense here because we would eventually add more features to our drawing
    program by simply extending the `toolbar_functions` tuple.
  prefs: []
  type: TYPE_NORMAL
- en: 'We further define an attribute, `selected_tool_bar_function`, which will keep track
    of which button was last clicked. We initialize it to the first button ( `draw_line`
    ) as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Next, we create a folder named `icons` and add icons for all these 16 toolbar buttons.
    The icons have been named the same as the corresponding function name.
  prefs: []
  type: TYPE_NORMAL
- en: Maintaining this consistency allows us to use the same tuple to loop over and
    build our toolbar buttons. This style of programming is what you could call programming
    using **conventions over configuration**.
  prefs: []
  type: TYPE_NORMAL
- en: 'We next create the method that makes the actual buttons (see code `6.03.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code creates all the buttons and adds command callbacks to the
    buttons as highlighted. We accordingly define the command callback as follows
    (see code `6.03.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding method sets the value of `selected_tool_bar_function`. Next,
    it calls two methods that are defined as follows (see code `6.03.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We need to remove any existing options currently displaying in the top bar before we
    can display options for the newly selected button. The `winfo_children` method used
    just now returns a list of all widgets that are children of this widget.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have removed all items from the top bar, we define the selected
    tool icon on the top bar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Currently, this method only calls one other method to display the selected tool
    icon in the top bar. We will, however, use this method as the central place for
    adding options to the top bar later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'We do not discuss the `show_selected_tool_icon_in_top_bar` method here as it simply
    adds a label with an icon to the top bar (see code `6.03.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/889c4325-4549-4330-b166-e8127b7fe0e7.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, if you go and run the code `6.03.py`, it should display all 16 buttons
    in the left toolbar. Furthermore, clicking on any one of the buttons should display
    the selected button in the top bar, as shown in the preceding screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: The `winfo_children()` method used earlier is an example of widget methods that
    are available to be called on all widgets. Several useful widget methods are defined
    in Tkinter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the widget methods that are available on all widgets, some methods
    are only available on the top-level window. You can get a list of all such available
    methods and their descriptions by typing the following in your Python 3 console:'
  prefs: []
  type: TYPE_NORMAL
- en: '`**>>> import tkinter**`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**>>> help (tkinter.Misc)**`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**>>> help (tkinter.Wm)**`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are available online at [http://effbot.org/tkinterbook/widget.htm](http://effbot.org/tkinterbook/widget.htm) and
    at [http://effbot.org/tkinterbook/wm.htm](http://effbot.org/tkinterbook/wm.htm).
  prefs: []
  type: TYPE_NORMAL
- en: You are encouraged to take a look at all these available methods.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will extend our program to actually draw items on the canvas.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing items on the canvas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Objects added to the canvas are called **items**. New items are added to the
    canvas using different create methods such as `create_line`, `create_arc`, `create_oval`, `create_rectangle`,
    `create_polygon`, `create_text`, `create_bitmap`, and `create_image`.
  prefs: []
  type: TYPE_NORMAL
- en: Items added to the canvas are placed in a stack. New items are added on top
    of items already on the canvas. Every time you add an item using one of the various create
    methods, it returns a unique item handle or an item ID that is a unique integer.
    This item handle can be used to refer to and manipulate the added item.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to an item handle, items can have the following item specifiers:'
  prefs: []
  type: TYPE_NORMAL
- en: '`tags` are specifiers that we can add to one or more items'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ALL` (or the string all) matches all items on the canvas'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CURRENT (or `current`) matches the item under the mouse pointer if any
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can use any of the preceding item specifiers for methods that act on canvas
    items.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add a tag to an item, you specify the tag (which is a string) as its configurable option,
    either at the time of creating the object or later using the `itemconfig` method or
    the `addtag_withtag` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'You can add multiple tags to an item at once by passing in the tags as a tuple
    of strings, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'To get all tags associated with an item handle, use `gettags` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This returns a tuple of all tags associated with that item handle.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get the item handles for all items that have a given tag, use `find_withtag`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This returns a tuple of item handles for all items with a tag of spam.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given this information, let''s code the functionality for the first six buttons,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ee68d097-34fc-4234-9390-1c6051bc4948.png)'
  prefs: []
  type: TYPE_IMG
- en: 'More specifically, we will code the functionality for the following function
    names that we have already defined earlier in the tuple `tool_bar_functions`:
     `"draw_line"`, `"draw_oval"`, `"draw_rectangle"`, `"draw_arc"`, and `"draw_triangle",
    "draw_star"`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the code for `draw_ line` (see code `6.04.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This uses the `create_line` method and draws a line from the start *x*, *y*
    coordinates to the end *x*, *y* coordinates. We have defined four new attributes
    for handling four different properties of the line:'
  prefs: []
  type: TYPE_NORMAL
- en: '`fill`: Line color. Default is `black`, initialized as red in our program.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`width`: Default is `1`, initialized as `2` in our program.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`arrow`: Default is `None`. The available choices are: `None`, `First`, `Last`,
    `Both`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dash`: A `dash` pattern, which is a list of segment lengths. Only the odd segments
    are drawn.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will later provide options for changing these four values from the top bar
    and hence these have been added as class attributes.
  prefs: []
  type: TYPE_NORMAL
- en: Also note that since `create_line` (and all create methods) return the item
    handle for the created item, we store it in an attribute named `current_item`.
    This gives us access to the last created item, which we will soon put to good
    use.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, here''s the code for `draw_ oval` (see code `6.04.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This is identical to the code for `draw_line`, except that we added a new attribute named
    outline that takes care of the outline color.
  prefs: []
  type: TYPE_NORMAL
- en: We will not discuss the code for `create_rectangle` and `create_arc`, which
    are almost identical to the code of `draw_oval` discussed here (see code `6.04.py`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now discuss the `create_polygon` method. This method can be used to
    create all sorts of interesting shapes. Let''s begin with the simple case of drawing
    an equilateral triangle (see code `6.04.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code first converts the changes in the *x*, *y* coordinates from
    the Cartesian coordinate system to the polar coordinates represented by an angle
    and a radius. It then calculates the *x*, *y* coordinates for all three edges
    of the triangle using the following formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Once we have the x, y coordinates for all three vertices of the triangle, we
    call the `create_polygon` method to draw the triangle.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now use the `create_polygon` method to make stars. A star (and many
    other polygons) can be thought of as a collection of points or spokes on two concentric
    circles, as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b7a716e9-86ca-45b5-9edc-3230898586b4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The star shown in the preceding figure has five spokes. We will later allow the
    user to change the number of spokes. Therefore, let''s start by defining a class attribute
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The shape of the star is also determined by the ratio of the radius of the
    inner circle to the radius of the outer circle, as in the preceding figure. This
    is called the **spoke ratio**. This ratio is 2 for a standard star. Changing this
    ratio can also produce all sorts of interesting star shapes. However, we will
    keep it at `2` for our example. Given these rules, the code for `draw_star` is
    defined as follows (see code `6.04.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is heavily commented for you to understand. This is very
    similar to the code we used to draw triangles.
  prefs: []
  type: TYPE_NORMAL
- en: Now, instead of having points on one circle (as for triangles), we have points
    on two circles. We again use the same technique to first convert the *x*, *y*
    coordinates from mouse events to polar coordinates. Once we have the polar coordinates,
    it is easy to move the points in the circle.
  prefs: []
  type: TYPE_NORMAL
- en: We then move the points by a given angle and change back to Cartesian coordinates.
    We keep appending all the points to an empty list called **points**. Once we have
    all the points, the last line calls the `create_polygon` method of the canvas
    object to draw the star.
  prefs: []
  type: TYPE_NORMAL
- en: Now we have all the methods to create these six shapes. But they need to be called
    from somewhere for the drawing to happen. And we have already decided that they
    would be called dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: Accordingly, we define a method, `execute_selected_method`, which takes the
    string for the selected toolbar function, converts the string into a callable
    function, and executes it dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code is as follows (see code `6.04.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This method, `getattr`, provides a reference to a method from the given string
    at runtime. A second argument provides a fallback mechanism whereby if the method object
    from the first argument is not found, a reference to the second method is provided.
  prefs: []
  type: TYPE_NORMAL
- en: 'This helps us gracefully handle situations where a dynamically created method
    does not exist. We simply define the fallback method as an empty method to handle
    those cases (see code `6.04.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: So now we have a method to execute the selected method dynamically. Where do we
    plug in this method?
  prefs: []
  type: TYPE_NORMAL
- en: Since the drawing must begin when the mouse is clicked, we call the `execute_selected_method` method
    once from the `on_mouse_button_pressed` method.
  prefs: []
  type: TYPE_NORMAL
- en: The drawing must continue while the mouse is dragged in a clicked position.
    So we call this method again from the `on_mouse_button_pressed_motion` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, although we want to keep the last drawn object during the mouse motion, we
    want to remove all other items except for the last drawn item. We therefore modify
    `on_mouse_button_pressed_motion` as follows (see code `6.04.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if you run `6.04.py`, the top six buttons on the toolbar should function
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d5ad7fda-4953-41b4-bd99-c123934d08ed.png)'
  prefs: []
  type: TYPE_IMG
- en: Adding a color palette
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can now draw basic shapes in our paint program. However, we still cannot change
    the colors of these shapes. Before we allow users to change colors, we must provide
    a way for them to select colors.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will, therefore, provide a color chooser, letting the user select two different colors:
    the foreground color and the background color.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/54e3e6b6-85b9-4f36-ac1e-50396b64626c.png)'
  prefs: []
  type: TYPE_IMG
- en: While we are at it, let's also add a label showing the *x*, *y* coordinate of
    the mouse over the canvas, as highlighted in the preceding screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: Let's begin with the color palette. The two color palettes are nothing but two
    small rectangle items placed on a canvas. To show these two rectangles, we define
    a method, `create_color_palette` and call it from the existing `create_gui` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for `create_color_palette` is as follows (see code `6.05.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The method ends by calling a method named `bind_color_palette`, which is defined
    as follows (see code `6.05.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code simply binds the mouse click to two not yet defined methods, `set_background_color`,
    and `set_foreground_color`, using the `tag_bind` method of the Canvas widget.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the signature of the `tag_bind` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The method adds an event binding to all matching items. Note that the bindings
    apply to the items, not the tag. For example, if you add the existing tag to new
    items after a call to `tag_bind,` the new items will not automatically bind to
    the event.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's define the method that actually opens a color picker and sets the foreground
    and background colors based on user-selected colors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Tkinter comes with a built-in `colorchooser` module that we import into our namespace
    as follows (see code `6.06.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'To open a color chooser, we need to call its `askcolor` method, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Upon clicking OK, the color chooser returns a tuple of the form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Where the first item of the tuple is another tuple comprising the RGB values
    of the chosen color and the last item of the tuple represents the hexadecimal
    color code of the chosen color, if the Cancel button is clicked, it returns `None`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then use the preceding method to set the foreground and background colors as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This concludes coding the color chooser for our paint program. However, note
    that the colors you choose will simply change the value of the foreground and background
    attributes. It will not change the color of items drawn on the canvas. We will
    do that in a separate iteration.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, let's define the methods that show the current mouse position in a
    label.
  prefs: []
  type: TYPE_NORMAL
- en: 'We create two new methods (see code `6.05.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'And we call the `show_current_coordinates` from our existing `on_mouse_unpressed_motion`
    method as follows (see code `6.05.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Adding top bar options for draw methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Each of the 16 toolbar buttons can have its own option. Just like we called
    the functions related to the toolbar buttons dynamically, we will again call methods to
    display options for the top bar dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: So we decide that the method for handling the top bar options would be named
    by appending the string `_options` to the existing method.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose we want to display the options for the `draw_line` method, it would
    be defined in the method called `draw_line_options`. Similarly, we have to define
    methods such as `draw_arc_options`, `draw_star_options`, and others.
  prefs: []
  type: TYPE_NORMAL
- en: 'We achieve this dynamic call in the `display_options_in_the_top_bar` method
    as follows (see code `6.06.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Now, with that code in place, every time a toolbar button is clicked the program
    will look for a method named by appending the `_options` string to the current
    method related to the button. If it finds one, it will be executed. If not found,
    the fallback function `function_not_defined` will be called, which is an empty
    method to silently ignore the absence of a method.
  prefs: []
  type: TYPE_NORMAL
- en: The Canvas widget lets you specify the fill color, outline color, and border
    width for most shapes as their configurable options.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to these, the Canvas widget also has several other configurable
    options for many of these basic shapes. For instance, for a line, you can specify
    whether it will have an arrowhead shape at the end or it will be dashed.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to display the following top options for the first six buttons:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6f0f28f9-1107-41cd-9a4b-da0391babbc5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As can be seen, we need to create Combobox widgets for fill, outline, width,
    arrow, and dash. We first import the `ttk` module into our namespace and then
    create the Combobox widget as shown in the following code (see code `6.06.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The ttk Combobox widget binds to another method called `set_fill`, which is defined
    as follows (`6.06.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: We define a similar `combobox` for the `width`, `outline`, `arrow`, and `dash`
    properties. We also define a `combobox` to allow the user to change the number
    of spokes in the star.
  prefs: []
  type: TYPE_NORMAL
- en: Since the code for all these methods is pretty similar to the code we have just
    discussed, we do not explore it here (`6.06.py`)*.*
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we add the required comboboxes to each of the six options methods as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: There's similar code for all the other five toolbar buttons (see code `6.06.py`).
  prefs: []
  type: TYPE_NORMAL
- en: Now, if you run code `6.06.py`, it should display options for the first six
    buttons.
  prefs: []
  type: TYPE_NORMAL
- en: When you change the options, the change is reflected in all subsequent drawings
    on the canvas.
  prefs: []
  type: TYPE_NORMAL
- en: However, there is a small bug in our code. What if someone has chosen the fill color
    as the foreground color? And then they change the foreground color from the color
    palette. Although this changes the value of the foreground attribute, it does
    not change the value of the fill attribute. Our program will keep using the old
    foreground value for fill.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to fix this bug, we modify the code for `set_background_color` and
    `set_foreground_color` to call two new methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The two methods are kept in a `try…except` block because not every toolbar button will
    have a fill and outline options `combobox`. Even if a toolbar button has the fill
    or outline `combobox`, it may not be selected to use the foreground or background
    color.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, since we want the `draw_line` options to populate the top bar immediately when
    the program starts, we add the following two lines to the `create_gui` method
    (see the `6.06.py` code):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: This concludes this iteration. We will add functionality to a few other toolbar
    buttons in the next iteration.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing irregular lines and super shapes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s now add the capability to draw irregular or continuous free-flowing
    lines. We will also add the ability to draw a variety of interesting shapes on
    the drawing canvas, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ba682999-dcd5-4bab-9997-8d476a59be74.png)'
  prefs: []
  type: TYPE_IMG
- en: As a reminder, all our buttons are linked to dynamically call functions defined
    in our `tool_bar_functions` tuple. Furthermore, we can specify unique options
    for a given function by adding the `_options` string to the function name.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing irregular lines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To add the capability to draw irregular lines, we just need to define the method named
    `draw_irregular_line`. To specify options that appear in the top bar, we need
    to define the method named `draw_irregular_line_options`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We define the `draw_irregular_line` method as follows (see code `6.07.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is similar to the code for `draw_line`, except that it adds
    an extra line that binds mouse-clicked movements to a new method that replaces the
    start *x*, *y* coordinates with the end *x*, *y* coordinates and again calls back
    the `draw_irregular_line` method, thereby drawing in a continuous manner.
  prefs: []
  type: TYPE_NORMAL
- en: 'The options that show in the top bar are defined using the following method (see
    code `6.07.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Now we can draw irregular lines on the canvas. However, since we have modified the
    mouse binding, all other methods will also start to draw in a continuous manner.
  prefs: []
  type: TYPE_NORMAL
- en: We, therefore, need to rebind the buttons back to their original bindings. We
    do that by modifying `on_tool_bar_button_clicked` to call `bind_mouse`, which then
    restores the mouse binding to its original behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Adding an event binding to more than one method wipes away the previous binding,
    whereby the new binding replaces any existing binding.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, you can use `add="+"` as an additional argument to keep more
    than one binding to the same event, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`mywidget.bind("<SomeEvent>", method1, add="+")`'
  prefs: []
  type: TYPE_NORMAL
- en: '`mywidget.bind("<SameEvent>", method2, add="+")`'
  prefs: []
  type: TYPE_NORMAL
- en: This will bind the same event to `method1` and `method2`.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing super shapes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We call these shapes super shapes because we can build many interesting shapes
    using a single mathematical formula called **Super Formula**. See [https://en.wikipedia.org/wiki/Superformula](https://en.wikipedia.org/wiki/Superformula)
    for more details on the formula.
  prefs: []
  type: TYPE_NORMAL
- en: 'The super formula takes six input arguments: `a`, `b`, `m`, `n1`, `n2`, and
    `n3`. Varying these five arguments produces varied shapes found in nature such
    as the shapes of shells, starfish, flowers, and more.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We do not get into why or how this formula works. All we do is write a method that,
    given these five arguments, returns the coordinates for unique shapes. We then pass
    these coordinates to our `create_polygon` method to create these shapes on the canvas.
    The method that returns these points is defined as follows (see code `6.07.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The method uses a custom-defined `float_range` method, since Python''s built-in range
    method does not allow for float step sizes. The `float_range` generator method
    is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we define the `draw_super_shape` method, which creates a polygon with
    the calculated points (see code `6.07.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we want to provide a different set of five parameters to the super formula.
    We define a new file named `supershapes.py` with a dictionary named `super_shapes`*with*
    different shapes represented by a shape name and five parameters as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'We also define an attribute (see code `6.07.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we define a `combobox` to let the user select from among the shapes defined previously
    (`6.07.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'And we define a method that sets the selected shape for the value of `selected_super_shape` (see
    code `6.07.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we define the `draw_super_shapes_options` that shows all of the options
    we want to show in the top option bar (see code `6.07.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: This concludes the iteration. You can now run `*6.07.py*` and draw irregular
    lines as well as all of the super shapes that we have defined in the `supershapes.py`
    file. In fact, you can extend the `super_shapes` dictionary to add many more shapes
    simply by changing the values for the five parameters. You can look at [https://en.wikipedia.org/wiki/Superformula](https://en.wikipedia.org/wiki/Superformula)
    for values of parameters that create interesting shapes.
  prefs: []
  type: TYPE_NORMAL
- en: Adding functionality to the remaining buttons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will now code the features related to the remaining toolbar buttons:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/06165595-3c77-46e0-814f-956f4ac6326d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Specifically, we will code the following functions: `draw_text`, `delete_item`, `fill_item`,
    `duplicate_item`, `move_to_top`, `drag_item`, `enlarge_item_size`, and `reduce_item_size`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the code for `draw_text`. When a user clicks on the `draw_text`
    button, we want to show the following options in the top bar:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7f2e7aeb-8e78-4705-bf80-ea7f455c42a6.png)'
  prefs: []
  type: TYPE_IMG
- en: The user can enter text in the textbox and specify its font size and fill color.
    Once the user presses the Go button, the text appears on the center of the canvas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us, therefore, define the `draw_text_options` method as follows (see code
    `6.08.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code is self-explanatory. The Go button is attached to a command callback
    named `on_create_text_button_clicked`, which is defined as follows (see code `6.08.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Our `draw_text` method is now functional. Next, let's code the `delete_item`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: The operations that we want to do now are slightly different from their predecessors. Earlier,
    we were creating items on the canvas. Now we have to target items already present
    on the canvas.
  prefs: []
  type: TYPE_NORMAL
- en: The item that needs to be targeted is the one on which the user clicks with
    their mouse. Fortunately, getting the item handle for the item under the mouse
    is very easy using the current tag.
  prefs: []
  type: TYPE_NORMAL
- en: 'Accordingly, the code for `delete_item` is as follows (see code `6.08.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Now, if you select the Delete button from the toolbar and click on any item
    on the canvas, that item is deleted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s code the `fill_item` and `fill_item_options` methods (see code
    `6.08.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'We had to use a `try…except` block because some canvas items such as lines
    and text do not have an outline option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we code the `duplicate_item` method. In order to duplicate an item we
    need to know three things:'
  prefs: []
  type: TYPE_NORMAL
- en: Type of item—if the item is a `line`, `oval`, `arc`, `rectangle`, or `polygon`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The coordinates for the item
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The configurations of the item
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can get the type of item as a string using the type method as follows: `canvas.type(item_specifier)`'
  prefs: []
  type: TYPE_NORMAL
- en: This returns a string such as `line`, `oval`, `arc`, `rectangle`, or `polygon`.
    In order to recreate an item of the same type, we need to append the string `create_`
    to the returned type and call the method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The coordinates of a given item can be obtained by calling the coordinates
    method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`` `coordinates = canvas.coords("item_specifier")` ``'
  prefs: []
  type: TYPE_NORMAL
- en: 'The configurations for an item can be obtained as a dictionary using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '`canvas.itemconfig(item_specifier)`'
  prefs: []
  type: TYPE_NORMAL
- en: 'This returns all the configurations for an item, whether specified or not specified.
    For example, here''s a sample of a dictionary returned by calling the preceding
    method on a canvas item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Clearly, we do not require those configuration values that are empty or zero.
    We, therefore, write a method that filters out all unnecessary configurations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we know how to fetch all required elements to duplicate a canvas item, here''s
    the code for `duplicate_item` (see code `6.08.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the last line calls a `wrapper` function that actually runs the function
    that duplicates the canvas item (see code `6.08.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if you create an item, select the duplicate item button, and click on
    the item, a duplicate item is created. However, since we do not want the duplicate
    item to be created exactly on top of the existing item, we offset its coordinates
    by `10` pixels from the coordinates of the item being duplicated. This offsetting
    is done in the line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Now, if you create an item on the canvas, select the duplicate item button,
    and click on the item, its duplicate is created at an offset of `10` pixels from
    the original item.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we code the `move_to_top` method. We have already discussed that items added
    to the canvas are added on top of each other. What if we want to move an item
    previously added to the canvas? The following figure shows what it means to move
    an item on top of another:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c7f21151-ab49-479a-b1f3-632fe00dc550.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We use the `tag_raise` and `tag_lower` methods to move items higher and lower in
    the stack. We use `tag_raise` to define the `move_to_top` method as follows (see
    code `6.08.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code raises the clicked item highest up in the item's stack.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you draw multiple items on the canvas, the items are placed in a stack.
    By default, new items get added on top of items previously drawn on the canvas.
    You can, however, change the stacking order using:'
  prefs: []
  type: TYPE_NORMAL
- en: '`canvas.tag_raise(item)`.'
  prefs: []
  type: TYPE_NORMAL
- en: If multiple items match, they are all moved, with their relative order preserved. However,
    this method will not change the stacking order for any new window item that you
    draw within the canvas.
  prefs: []
  type: TYPE_NORMAL
- en: Then there are the `find_above` and `find_below` methods that you can use to
    find items above or below an item in the canvas stacking order.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will define the `drag_item` method. This method uses the move method
    to change the coordinates of a given item (see code `6.08.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Since we want the drag to occur continuously and not as a jump from one place to
    another, we temporarily bind the mouse binding to update the start and end coordinates
    like we did when we defined the `draw_irregular_line` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we define two methods to enlarge and reduce item size. We will use
    the `canvas.scale` method to increase and reduce item size by 20%:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Note that, immediately upon item resize, we reconfigure the scroll region option
    to update the scroll bar.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `bbox` method returns the bounding box for an item. The syntax is:  `.canvas.bbox(item_specifier)`.
    This returns the bounding box as a tuple of length 4\. If the item-specifier is
    omitted, the bounding box for all items is returned.'
  prefs: []
  type: TYPE_NORMAL
- en: Note that bounding box values are approximate and may differ from the real value
    by a few pixels.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes the iteration. All the buttons in the left toolbar are now functional
    (see code `6.08.py`).
  prefs: []
  type: TYPE_NORMAL
- en: Adding functionality to menu items
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Recall that, at the time of creating our menu using the `Framework` class, we
    created empty methods that were linked to our menu items. We will now modify those
    empty methods to make them functional (see code `6.09.py` )
  prefs: []
  type: TYPE_NORMAL
- en: 'File | New Menu:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The canvas delete method can be used to delete an item, given an item-specifier.
    Here we use `ALL` to delete all items from the canvas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'File | Save, File | Save As:'
  prefs: []
  type: TYPE_NORMAL
- en: Tkinter lets you save canvas objects as a postscript file using the command
    `postscript()`. Note, however, that the resulting postscript file cannot save
    images or any widgets embedded on the canvas. Furthermore, note that the pickling
    of Tkinter widgets or saving to `.jpg` or `.png` formats is not possible. This
    is one of the major limitations of Tkinter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the code for the save and save as features (see code `6.09.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: We do not discuss the Close and About menu as we have coded similar menus in
    all our previous projects (see code `6.09.py`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit | Undo:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Recall that all items added to the canvas are stored in a stack. We can access
    the stack using the canvas command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Using this, we implement a very basic undo operation, which lets us delete the
    last drawn item on the canvas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Accordingly, the code for adding the undo feature is as follows (see code `6.09.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Note that this will not undo any styling changes such as changes in color, width,
    outline, and so on. In fact, it will only be able to delete the last item from
    the stack.
  prefs: []
  type: TYPE_NORMAL
- en: We can implement a fully-fledged undo stack by saving all actions in a suitable
    data structure, but that would be an exercise worth its own chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the find method we used here, the Canvas widget has a method
    named:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: It returns the item handle for the item closest to the given position on the
    canvas. This means that if there is only one item on the canvas, it will be selected
    regardless of how near or how far you click from it.
  prefs: []
  type: TYPE_NORMAL
- en: 'If, on the other hand, you want objects only within a certain area, you can
    use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: This returns all items that overlap the given rectangle, or that are completely enclosed
    by it.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a hold on the item to be manipulated, we can proceed to do whatever
    we want with the item.
  prefs: []
  type: TYPE_NORMAL
- en: For a complete list of canvas methods, please see [http://infohost.nmt.edu/tcc/help/pubs/tkinter/web/canvas-methods.html](http://infohost.nmt.edu/tcc/help/pubs/tkinter/web/canvas-methods.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'View | Zoom in, View | Zoom out:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we define these two methods using the `canvas.scale` method. We have
    already used the scale methods earlier to enlarge and reduce individual items.
    Here, we simply use the method on the `ALL` item-specifier, as in the following
    code (see code `6.09.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: That concludes the iteration and the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To summarize, in this chapter, we began by creating a custom GUI framework on
    top of Tkinter.
  prefs: []
  type: TYPE_NORMAL
- en: We saw how GUI frameworks can be used to generate boilerplate code for our programs,
    thereby ensuring maximum code reuse and rapid application development.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we explored the Canvas widget in detail. We saw how to create various
    canvas items. Then, we saw how we could manipulate the attributes of these canvas
    items using tag or ID.
  prefs: []
  type: TYPE_NORMAL
- en: We saw the `colorchooser` module of Tkinter in action. We worked with the ttk
    Combobox widget. We also looked at common methods that are available on all Tkinter
    widgets.
  prefs: []
  type: TYPE_NORMAL
- en: We also saw the benefits of writing programs that use convention over configuration
    to ease the logical flow of the program.
  prefs: []
  type: TYPE_NORMAL
- en: QA section
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before you proceed to the next chapter, make sure you can answer these questions
    to your
  prefs: []
  type: TYPE_NORMAL
- en: 'satisfaction:'
  prefs: []
  type: TYPE_NORMAL
- en: What are software frameworks?  Why are they used?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When is it beneficial to use software frameworks instead of writing code from
    scratch?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is a structured markup language? Can you a list a few of them?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is the convention over configuration software design paradigm?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are tags used for in the context of  Tkinter's Canvas widget?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Read the complete documentation for the Tkinter Canvas widget. You can find
    the documentation by typing the following command in a Python command shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
