- en: Paint Application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 涂鸦应用
- en: We used the Canvas widget to define a custom widget in [Chapter 5](73aef6b5-11e2-4cb9-bb4a-5c96bf81dfcc.xhtml),
    *Building an Audio Player*. The Canvas widget is truly one of Tkinter's highlights.
    It is an incredibly powerful and flexible widget. Let's, therefore, devote most
    of this chapter to looking at the Canvas widget in detail.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: We will now develop a paint application. The application will let the user draw freehand
    lines, straight lines, circles, rectangles, arcs, and other polygons. It will also
    let the user define new complex shapes.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: In addition to exploring the Canvas widget, we will also develop a tiny GUI framework
    on top of the Tkinter interface. As you will see, frameworks are a great way to
    maximize code reuse. This makes them a powerful tool for **Rapid ****Application
    Development (RAD)**.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 除了探索 Canvas 小部件，我们还将基于 Tkinter 接口开发一个微型的 GUI 框架。正如您将看到的，框架是最大化代码重用的一种很好的方式。这使得它们成为快速应用开发（RAD）的强大工具。**快速应用开发（RAD）**。
- en: 'Some of the key learning objectives for this chapter are as follows:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的一些关键学习目标如下：
- en: Master the Canvas widget API
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 掌握 Canvas 小部件 API
- en: Learn to build and use custom GUI frameworks for maximum code reuse and rapid
    application development
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习构建和使用自定义GUI框架以实现最大程度地代码复用和快速应用开发
- en: Learn to use the `colorchooser` module of Tkinter
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习使用 Tkinter 的 `colorchooser` 模块
- en: Learn to use the ttk ComboBox widget
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习使用 ttk ComboBox 小部件
- en: Get to know available widget methods
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解可用的小部件方法
- en: Reinforce things that we have learned in previous projects
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 巩固我们在先前项目中学习到的知识
- en: Overview of the application
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用概述
- en: 'In its final form, our paint application would look as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在其最终形态下，我们的油漆应用程序将如下所示：
- en: '![](img/caaa69fc-faea-49ba-ab31-c4950c8a1e36.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
- en: There are no external library requirements for this chapter, so let's dive into
    the code.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Creating a tiny framework
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个微型框架
- en: So why do we need another framework on top of Tkinter? If we need to build just a
    single program, we need not build a framework. However, if we find ourselves writing
    the same boilerplate code over and over again, a framework is what we need. That
    is, a framework is a tool that lets us easily generate generic and often-used patterns
    with ease.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Consider, for example, menus used in programs. A menu is such a common element
    in most programs, yet we need to handcraft each menu item every time we sit down to
    write a program. What if we could further abstract to simplify menu generation?
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: This is where frameworks come in handy.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Say you have a program that has 10 different top-level menus. Say each of the
    top-level menus has five menu items. We will have to then write 50 lines of code
    simply to display these 50 menu items. You have to link each of them manually
    to other commands besides having to set tons of options for each of them.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: If we keep doing this for all our widgets, our GUI programming becomes an exercise in
    typing. Every extra line of code that you write adds to the program complexity, making
    it more difficult for someone else to read, maintain, modify, and/or debug the
    code.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: This is where using a custom framework comes to our aid. Let's develop a tiny framework
    that makes menu generation easy for us.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: 'We create a file, `framework.py`, and create a new class, `Framework`, to the
    file. Every class that uses this framework must inherit from this class and should
    pass the root window as an argument to this class by calling the super method
    as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This will make all methods defined in the `Framework` class available to the inheriting
    class.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: We will now define a method, `build_menu`, which takes a tuple in an expected format
    as input and automatically creates the menu for us. Let's define an arbitrary rule
    that each group of menu items must be represented by a single entry in a tuple.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: 'Furthermore, we come up with a rule that each item in the tuple must be presented
    in the following format:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`MenuSeparator` is denoted by a string `''sep''`.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: An alternative representation of menu definition could be specifying it as a
    tuple instead of a string definition, which is like asking the user to already
    split the definition rather than us having to extract the menu definition from
    a string.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, passing this tuple as an argument to the `build_menu` method
    should generate three menus as shown in the following code:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Take a look at the following screenshot:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/178dbd61-7fd6-4922-8257-8deab81bf4b2.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
- en: The first item of the string (before dash (`-`)) represents the top-level menu button.
    Each subsequent part of the string separated by a forward slash (`/`)  represents
    one menu item, its accelerator key, and the attached command callback.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: The position of the ampersand symbol (`&`) represents the position of the shortcut
    key to be underlined. If we encounter the string `sep`, we add a menu separator.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have defined the rules, the code for `build_menu` is as follows: (see
    the `framework.py` code):'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The description of the code is as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: The method, `build_menu`, operates on a tuple by the name `menu_definition`, which
    must specify all desired menus and menu items in the exact format, as previously
    discussed.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It iterates through each item in the tuple, splitting the item based on the dash
    (`–`) delimiter, building the top-menu button for each item left to the dash (`-`
    ) delimiter.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It then splits the second part of the string based on the comma (`,`) delimiter.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It then iterates through this second part, creating menu items for each of the
    parts, adding the accelerator key, command callback, and underline key using another
    method, `_add_menu_command`.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `_add_menu_command` method iterates through the string and adds a separator
    if it finds the string `sep`. If not, it next searches for an ampersand (`&`)
    in the string. If it finds one, it calculates its index position and assigns it
    to the underline variable. It then replaces the ampersand value with an empty string,
    because we do not want to display the ampersand in our menu item.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If an ampersand is not found in a string, the code assigns `None` to the underline
    variable.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, the code adds a command callback, accelerator key, and underline value
    to the menu item. Note that our framework adds only the accelerator key label.
    It is the developer's responsibility to bind events to the bound keys.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our demonstration of making GUI frameworks ends here. We can now use this method
    to define literally hundreds of menus simply by adding one new line for each group
    of menus.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: However, this is a rather rudimentary framework. The rules for defining items
    are completely arbitrary. The choice of delimiters means that we can no longer
    use the dash (`-`), slash (`/`), and ampersand (`&`) characters that we have used
    as delimiters in any menus that we define using this framework.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: Our framework does not lay down rules for any other widgets. In fact, this definition
    is not even sufficient to generate other types of menu such as cascading menus,
    check button menus, or radio button menus. We will, however, not extend the framework further,
    as it is sufficient to have developed the concept behind framework design and usage
    and that is all we need to use in our paint application.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: We have also included a small test in the `framework.py` file. If you execute
    the file as a standalone program, it should pop up a window and define some menus for
    testing.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: Fully-fledged frameworks use more structured markup languages to represent rules.
    XML is one of the most popular choices for writing GUI frameworks. You can find
    an example of a full-blown XML-based Tkinter RAD (tkRAD) framework here: [https://github.com/muxuezi/tkRAD](https://github.com/muxuezi/tkRAD).
    A simple menu implementation using the preceding framework can be seen here:[ https://github.com/muxuezi/tkRAD/blob/master/xml/rad_xml_menu.py](https://github.com/muxuezi/tkRAD/blob/master/xml/rad_xml_menu.py).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: Using a framework for smaller programs may be overkill, but they are invaluable assets
    for large programs. Hopefully, you should now be able to appreciate the benefits
    of using frameworks for larger programs.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the code for `build_menu`, we can extend it to add as many
    menu items as required without having to write repetitive and similar code for
    each of them.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: This ends our first iteration. We will use this tiny framework to define the
    menu for our drawing program in the next step.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a broad GUI structure
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s now set up the broad GUI elements of our program. We will create a `PaintApplication`
    class in `6.01.py`. Since we want to draw the menu using our framework, we import
    the framework into our file and inherit from the `Framework` class as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `__init__` method calls another method, `create_gui`, which is responsible
    for creating the basic GUI structure for our program.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: 'The `create_gui` method simply delegates the task to five separate methods,
    each being responsible for creating one section of the GUI as follows (see code
    `6.01.py`):'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'These five methods together build a structure as shown in the following screenshot
    (see code `6.01.py`):'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/453f9f3d-5ab0-4f15-ab85-cb14575c2383.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
- en: 'We have written similar code in all previous chapters, hence we will not reproduce the
    code for these five methods here. Note, however, a few things about the code in `6.01.py`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: Since we want to use the framework, we inherit from the `Framework` class and
    call its `__init__` method using `` `super()` ``
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `create_menu` method specifies the tuple for our menu definition and calls
    the `build_menu` method defined earlier in our framework
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We define a lot of empty methods that will be implemented later. Each empty
    method is added as a command callback to individual menu items. The empty methods
    defined here are:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This gives us a broad GUI structure for our program. Next, we will look at interacting with
    the drawing canvas.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with mouse events
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we draw in a paint program, we use a mouse as the primary input device.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: 'There are primarily two kinds of mouse event that cause changes on the drawing canvas
    and are therefore of interest:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: Click and release
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Click, drag, and release
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is also a third event in which we have limited interest—the mouse movements
    with no buttons clicked. Our interest is limited there since an unclicked motion
    normally does not cause any changes on the canvas.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: We ignore right-click and wheel-scroll as we will not be using them in our program.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: In both the preceding cases, we need to know where the mouse was first clicked
    and where it was released. For click and release, this could be the same location.
    For click, drag, and release this will normally be different locations.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: 'Accordingly, we define four attributes to keep track of the coordinates for
    these two locations (see code `6.02.py`):'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Our immediate goal then is to bind our mouse events in such a way that any click
    or drag gives us the value of these four start and end coordinates.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: The coordinates of the Canvas widget begin at the top-left corner ((`0, 0`)
    is the top-corner).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: 'The Canvas widget uses two coordinate systems:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: The **window coordinate system**, which is always `0, 0` for the leftmost corner,
    no matter where you scroll down or up the canvas
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **canvas coordinate system**, which specifies where the items are actually
    drawn on the canvas
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will mostly be interested in the canvas coordinate system, but mouse events
    emit data on the window coordinate system. To convert from the window coordinate
    system to the canvas coordinate system we can use the following methods:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Let''s now modify our `__init__` method to also call a method, `bind_mouse`.
    We define the `bind_mouse` method as follows (see code `6.02.py`):'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We then define the first three methods that were bound just now. We ignore
    the unpressed motion for now by making an empty method. Remember that we are interested in
    getting the start and end coordinates, which are acquired as follows (see code `6.02.py`):'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We have temporarily added two `print` statements to show these four values on
    the console (see code `6.02.py`).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the location of the start and end mouse events, we can act
    upon those events to do all kinds of activities on the canvas.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: Adding toolbar buttons
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next, we need to add 16 buttons to the left toolbar. Furthermore, depending
    on which button is clicked, different options would show up in the top bar as
    shown here:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/09a714e8-a7fb-4040-9a3a-2eebacdd4b95.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
- en: We do not want our code structure to be too bloated by conditional logic to
    switch among these 16 functions. Therefore, we will call these methods dynamically.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: 'We first begin by defining a tuple of all 16 function names (see code `6.01.py`):'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Doing so ensures that we do not have to call each method explicitly from our
    code. We can instead use the index of the tuple to retrieve the method name and
    call it dynamically using the following:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This makes sense here because we would eventually add more features to our drawing
    program by simply extending the `toolbar_functions` tuple.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: 'We further define an attribute, `selected_tool_bar_function`, which will keep track
    of which button was last clicked. We initialize it to the first button ( `draw_line`
    ) as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Next, we create a folder named `icons` and add icons for all these 16 toolbar buttons.
    The icons have been named the same as the corresponding function name.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Maintaining this consistency allows us to use the same tuple to loop over and
    build our toolbar buttons. This style of programming is what you could call programming
    using **conventions over configuration**.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: 'We next create the method that makes the actual buttons (see code `6.03.py`):'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The preceding code creates all the buttons and adds command callbacks to the
    buttons as highlighted. We accordingly define the command callback as follows
    (see code `6.03.py`):'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The preceding method sets the value of `selected_tool_bar_function`. Next,
    it calls two methods that are defined as follows (see code `6.03.py`):'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We need to remove any existing options currently displaying in the top bar before we
    can display options for the newly selected button. The `winfo_children` method used
    just now returns a list of all widgets that are children of this widget.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have removed all items from the top bar, we define the selected
    tool icon on the top bar:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Currently, this method only calls one other method to display the selected tool
    icon in the top bar. We will, however, use this method as the central place for
    adding options to the top bar later in the chapter.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: 'We do not discuss the `show_selected_tool_icon_in_top_bar` method here as it simply
    adds a label with an icon to the top bar (see code `6.03.py`):'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/889c4325-4549-4330-b166-e8127b7fe0e7.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
- en: Now, if you go and run the code `6.03.py`, it should display all 16 buttons
    in the left toolbar. Furthermore, clicking on any one of the buttons should display
    the selected button in the top bar, as shown in the preceding screenshot.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: The `winfo_children()` method used earlier is an example of widget methods that
    are available to be called on all widgets. Several useful widget methods are defined
    in Tkinter.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the widget methods that are available on all widgets, some methods
    are only available on the top-level window. You can get a list of all such available
    methods and their descriptions by typing the following in your Python 3 console:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '`**>>> import tkinter**`'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**>>> help (tkinter.Misc)**`'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**>>> help (tkinter.Wm)**`'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are available online at [http://effbot.org/tkinterbook/widget.htm](http://effbot.org/tkinterbook/widget.htm) and
    at [http://effbot.org/tkinterbook/wm.htm](http://effbot.org/tkinterbook/wm.htm).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: You are encouraged to take a look at all these available methods.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will extend our program to actually draw items on the canvas.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: Drawing items on the canvas
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Objects added to the canvas are called **items**. New items are added to the
    canvas using different create methods such as `create_line`, `create_arc`, `create_oval`, `create_rectangle`,
    `create_polygon`, `create_text`, `create_bitmap`, and `create_image`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Items added to the canvas are placed in a stack. New items are added on top
    of items already on the canvas. Every time you add an item using one of the various create
    methods, it returns a unique item handle or an item ID that is a unique integer.
    This item handle can be used to refer to and manipulate the added item.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to an item handle, items can have the following item specifiers:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '`tags` are specifiers that we can add to one or more items'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ALL` (or the string all) matches all items on the canvas'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CURRENT (or `current`) matches the item under the mouse pointer if any
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can use any of the preceding item specifiers for methods that act on canvas
    items.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: 'To add a tag to an item, you specify the tag (which is a string) as its configurable option,
    either at the time of creating the object or later using the `itemconfig` method or
    the `addtag_withtag` method, as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You can add multiple tags to an item at once by passing in the tags as a tuple
    of strings, as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To get all tags associated with an item handle, use `gettags` as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This returns a tuple of all tags associated with that item handle.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: 'To get the item handles for all items that have a given tag, use `find_withtag`:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This returns a tuple of item handles for all items with a tag of spam.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: 'Given this information, let''s code the functionality for the first six buttons,
    as shown in the following screenshot:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ee68d097-34fc-4234-9390-1c6051bc4948.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
- en: 'More specifically, we will code the functionality for the following function
    names that we have already defined earlier in the tuple `tool_bar_functions`:
     `"draw_line"`, `"draw_oval"`, `"draw_rectangle"`, `"draw_arc"`, and `"draw_triangle",
    "draw_star"`'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the code for `draw_ line` (see code `6.04.py`):'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This uses the `create_line` method and draws a line from the start *x*, *y*
    coordinates to the end *x*, *y* coordinates. We have defined four new attributes
    for handling four different properties of the line:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '`fill`: Line color. Default is `black`, initialized as red in our program.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`width`: Default is `1`, initialized as `2` in our program.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`arrow`: Default is `None`. The available choices are: `None`, `First`, `Last`,
    `Both`.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dash`: A `dash` pattern, which is a list of segment lengths. Only the odd segments
    are drawn.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will later provide options for changing these four values from the top bar
    and hence these have been added as class attributes.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: Also note that since `create_line` (and all create methods) return the item
    handle for the created item, we store it in an attribute named `current_item`.
    This gives us access to the last created item, which we will soon put to good
    use.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, here''s the code for `draw_ oval` (see code `6.04.py`):'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This is identical to the code for `draw_line`, except that we added a new attribute named
    outline that takes care of the outline color.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: We will not discuss the code for `create_rectangle` and `create_arc`, which
    are almost identical to the code of `draw_oval` discussed here (see code `6.04.py`).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now discuss the `create_polygon` method. This method can be used to
    create all sorts of interesting shapes. Let''s begin with the simple case of drawing
    an equilateral triangle (see code `6.04.py`):'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The preceding code first converts the changes in the *x*, *y* coordinates from
    the Cartesian coordinate system to the polar coordinates represented by an angle
    and a radius. It then calculates the *x*, *y* coordinates for all three edges
    of the triangle using the following formula:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Once we have the x, y coordinates for all three vertices of the triangle, we
    call the `create_polygon` method to draw the triangle.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now use the `create_polygon` method to make stars. A star (and many
    other polygons) can be thought of as a collection of points or spokes on two concentric
    circles, as shown in the following figure:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b7a716e9-86ca-45b5-9edc-3230898586b4.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
- en: 'The star shown in the preceding figure has five spokes. We will later allow the
    user to change the number of spokes. Therefore, let''s start by defining a class attribute
    as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The shape of the star is also determined by the ratio of the radius of the
    inner circle to the radius of the outer circle, as in the preceding figure. This
    is called the **spoke ratio**. This ratio is 2 for a standard star. Changing this
    ratio can also produce all sorts of interesting star shapes. However, we will
    keep it at `2` for our example. Given these rules, the code for `draw_star` is
    defined as follows (see code `6.04.py`):'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The preceding code is heavily commented for you to understand. This is very
    similar to the code we used to draw triangles.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: Now, instead of having points on one circle (as for triangles), we have points
    on two circles. We again use the same technique to first convert the *x*, *y*
    coordinates from mouse events to polar coordinates. Once we have the polar coordinates,
    it is easy to move the points in the circle.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: We then move the points by a given angle and change back to Cartesian coordinates.
    We keep appending all the points to an empty list called **points**. Once we have
    all the points, the last line calls the `create_polygon` method of the canvas
    object to draw the star.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: Now we have all the methods to create these six shapes. But they need to be called
    from somewhere for the drawing to happen. And we have already decided that they
    would be called dynamically.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: Accordingly, we define a method, `execute_selected_method`, which takes the
    string for the selected toolbar function, converts the string into a callable
    function, and executes it dynamically.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: 'The code is as follows (see code `6.04.py`):'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This method, `getattr`, provides a reference to a method from the given string
    at runtime. A second argument provides a fallback mechanism whereby if the method object
    from the first argument is not found, a reference to the second method is provided.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: 'This helps us gracefully handle situations where a dynamically created method
    does not exist. We simply define the fallback method as an empty method to handle
    those cases (see code `6.04.py`):'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: So now we have a method to execute the selected method dynamically. Where do we
    plug in this method?
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: Since the drawing must begin when the mouse is clicked, we call the `execute_selected_method` method
    once from the `on_mouse_button_pressed` method.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: The drawing must continue while the mouse is dragged in a clicked position.
    So we call this method again from the `on_mouse_button_pressed_motion` method.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: 'However, although we want to keep the last drawn object during the mouse motion, we
    want to remove all other items except for the last drawn item. We therefore modify
    `on_mouse_button_pressed_motion` as follows (see code `6.04.py`):'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, if you run `6.04.py`, the top six buttons on the toolbar should function
    as shown in the following screenshot:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d5ad7fda-4953-41b4-bd99-c123934d08ed.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
- en: Adding a color palette
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can now draw basic shapes in our paint program. However, we still cannot change
    the colors of these shapes. Before we allow users to change colors, we must provide
    a way for them to select colors.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: 'We will, therefore, provide a color chooser, letting the user select two different colors:
    the foreground color and the background color.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/54e3e6b6-85b9-4f36-ac1e-50396b64626c.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
- en: While we are at it, let's also add a label showing the *x*, *y* coordinate of
    the mouse over the canvas, as highlighted in the preceding screenshot.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: Let's begin with the color palette. The two color palettes are nothing but two
    small rectangle items placed on a canvas. To show these two rectangles, we define
    a method, `create_color_palette` and call it from the existing `create_gui` method.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for `create_color_palette` is as follows (see code `6.05.py`):'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The method ends by calling a method named `bind_color_palette`, which is defined
    as follows (see code `6.05.py`):'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The preceding code simply binds the mouse click to two not yet defined methods, `set_background_color`,
    and `set_foreground_color`, using the `tag_bind` method of the Canvas widget.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the signature of the `tag_bind` method:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The method adds an event binding to all matching items. Note that the bindings
    apply to the items, not the tag. For example, if you add the existing tag to new
    items after a call to `tag_bind,` the new items will not automatically bind to
    the event.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's define the method that actually opens a color picker and sets the foreground
    and background colors based on user-selected colors.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: 'Tkinter comes with a built-in `colorchooser` module that we import into our namespace
    as follows (see code `6.06.py`):'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'To open a color chooser, we need to call its `askcolor` method, as shown here:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Upon clicking OK, the color chooser returns a tuple of the form:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Where the first item of the tuple is another tuple comprising the RGB values
    of the chosen color and the last item of the tuple represents the hexadecimal
    color code of the chosen color, if the Cancel button is clicked, it returns `None`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: 'We then use the preceding method to set the foreground and background colors as
    follows:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This concludes coding the color chooser for our paint program. However, note
    that the colors you choose will simply change the value of the foreground and background
    attributes. It will not change the color of items drawn on the canvas. We will
    do that in a separate iteration.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: Finally, let's define the methods that show the current mouse position in a
    label.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: 'We create two new methods (see code `6.05.py`):'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'And we call the `show_current_coordinates` from our existing `on_mouse_unpressed_motion`
    method as follows (see code `6.05.py`):'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Adding top bar options for draw methods
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Each of the 16 toolbar buttons can have its own option. Just like we called
    the functions related to the toolbar buttons dynamically, we will again call methods to
    display options for the top bar dynamically.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: So we decide that the method for handling the top bar options would be named
    by appending the string `_options` to the existing method.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: Suppose we want to display the options for the `draw_line` method, it would
    be defined in the method called `draw_line_options`. Similarly, we have to define
    methods such as `draw_arc_options`, `draw_star_options`, and others.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: 'We achieve this dynamic call in the `display_options_in_the_top_bar` method
    as follows (see code `6.06.py`):'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Now, with that code in place, every time a toolbar button is clicked the program
    will look for a method named by appending the `_options` string to the current
    method related to the button. If it finds one, it will be executed. If not found,
    the fallback function `function_not_defined` will be called, which is an empty
    method to silently ignore the absence of a method.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: The Canvas widget lets you specify the fill color, outline color, and border
    width for most shapes as their configurable options.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: In addition to these, the Canvas widget also has several other configurable
    options for many of these basic shapes. For instance, for a line, you can specify
    whether it will have an arrowhead shape at the end or it will be dashed.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to display the following top options for the first six buttons:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6f0f28f9-1107-41cd-9a4b-da0391babbc5.png)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
- en: 'As can be seen, we need to create Combobox widgets for fill, outline, width,
    arrow, and dash. We first import the `ttk` module into our namespace and then
    create the Combobox widget as shown in the following code (see code `6.06.py`):'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The ttk Combobox widget binds to another method called `set_fill`, which is defined
    as follows (`6.06.py`):'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We define a similar `combobox` for the `width`, `outline`, `arrow`, and `dash`
    properties. We also define a `combobox` to allow the user to change the number
    of spokes in the star.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: Since the code for all these methods is pretty similar to the code we have just
    discussed, we do not explore it here (`6.06.py`)*.*
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we add the required comboboxes to each of the six options methods as
    follows:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: There's similar code for all the other five toolbar buttons (see code `6.06.py`).
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: Now, if you run code `6.06.py`, it should display options for the first six
    buttons.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: When you change the options, the change is reflected in all subsequent drawings
    on the canvas.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: However, there is a small bug in our code. What if someone has chosen the fill color
    as the foreground color? And then they change the foreground color from the color
    palette. Although this changes the value of the foreground attribute, it does
    not change the value of the fill attribute. Our program will keep using the old
    foreground value for fill.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to fix this bug, we modify the code for `set_background_color` and
    `set_foreground_color` to call two new methods:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The two methods are kept in a `try…except` block because not every toolbar button will
    have a fill and outline options `combobox`. Even if a toolbar button has the fill
    or outline `combobox`, it may not be selected to use the foreground or background
    color.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, since we want the `draw_line` options to populate the top bar immediately when
    the program starts, we add the following two lines to the `create_gui` method
    (see the `6.06.py` code):'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This concludes this iteration. We will add functionality to a few other toolbar
    buttons in the next iteration.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: Drawing irregular lines and super shapes
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s now add the capability to draw irregular or continuous free-flowing
    lines. We will also add the ability to draw a variety of interesting shapes on
    the drawing canvas, as shown here:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ba682999-dcd5-4bab-9997-8d476a59be74.png)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
- en: As a reminder, all our buttons are linked to dynamically call functions defined
    in our `tool_bar_functions` tuple. Furthermore, we can specify unique options
    for a given function by adding the `_options` string to the function name.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: Drawing irregular lines
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To add the capability to draw irregular lines, we just need to define the method named
    `draw_irregular_line`. To specify options that appear in the top bar, we need
    to define the method named `draw_irregular_line_options`.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: 'We define the `draw_irregular_line` method as follows (see code `6.07.py`):'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The preceding code is similar to the code for `draw_line`, except that it adds
    an extra line that binds mouse-clicked movements to a new method that replaces the
    start *x*, *y* coordinates with the end *x*, *y* coordinates and again calls back
    the `draw_irregular_line` method, thereby drawing in a continuous manner.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: 'The options that show in the top bar are defined using the following method (see
    code `6.07.py`):'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Now we can draw irregular lines on the canvas. However, since we have modified the
    mouse binding, all other methods will also start to draw in a continuous manner.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: We, therefore, need to rebind the buttons back to their original bindings. We
    do that by modifying `on_tool_bar_button_clicked` to call `bind_mouse`, which then
    restores the mouse binding to its original behavior.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: Adding an event binding to more than one method wipes away the previous binding,
    whereby the new binding replaces any existing binding.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, you can use `add="+"` as an additional argument to keep more
    than one binding to the same event, as follows:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '`mywidget.bind("<SomeEvent>", method1, add="+")`'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '`mywidget.bind("<SameEvent>", method2, add="+")`'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: This will bind the same event to `method1` and `method2`.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: Drawing super shapes
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We call these shapes super shapes because we can build many interesting shapes
    using a single mathematical formula called **Super Formula**. See [https://en.wikipedia.org/wiki/Superformula](https://en.wikipedia.org/wiki/Superformula)
    for more details on the formula.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: 'The super formula takes six input arguments: `a`, `b`, `m`, `n1`, `n2`, and
    `n3`. Varying these five arguments produces varied shapes found in nature such
    as the shapes of shells, starfish, flowers, and more.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: 'We do not get into why or how this formula works. All we do is write a method that,
    given these five arguments, returns the coordinates for unique shapes. We then pass
    these coordinates to our `create_polygon` method to create these shapes on the canvas.
    The method that returns these points is defined as follows (see code `6.07.py`):'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The method uses a custom-defined `float_range` method, since Python''s built-in range
    method does not allow for float step sizes. The `float_range` generator method
    is defined as follows:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Next, we define the `draw_super_shape` method, which creates a polygon with
    the calculated points (see code `6.07.py`):'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Now we want to provide a different set of five parameters to the super formula.
    We define a new file named `supershapes.py` with a dictionary named `super_shapes`*with*
    different shapes represented by a shape name and five parameters as follows:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We also define an attribute (see code `6.07.py`):'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Next, we define a `combobox` to let the user select from among the shapes defined previously
    (`6.07.py`):'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'And we define a method that sets the selected shape for the value of `selected_super_shape` (see
    code `6.07.py`):'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Finally, we define the `draw_super_shapes_options` that shows all of the options
    we want to show in the top option bar (see code `6.07.py`):'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: This concludes the iteration. You can now run `*6.07.py*` and draw irregular
    lines as well as all of the super shapes that we have defined in the `supershapes.py`
    file. In fact, you can extend the `super_shapes` dictionary to add many more shapes
    simply by changing the values for the five parameters. You can look at [https://en.wikipedia.org/wiki/Superformula](https://en.wikipedia.org/wiki/Superformula)
    for values of parameters that create interesting shapes.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: Adding functionality to the remaining buttons
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will now code the features related to the remaining toolbar buttons:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/06165595-3c77-46e0-814f-956f4ac6326d.png)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
- en: 'Specifically, we will code the following functions: `draw_text`, `delete_item`, `fill_item`,
    `duplicate_item`, `move_to_top`, `drag_item`, `enlarge_item_size`, and `reduce_item_size`.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the code for `draw_text`. When a user clicks on the `draw_text`
    button, we want to show the following options in the top bar:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7f2e7aeb-8e78-4705-bf80-ea7f455c42a6.png)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
- en: The user can enter text in the textbox and specify its font size and fill color.
    Once the user presses the Go button, the text appears on the center of the canvas.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us, therefore, define the `draw_text_options` method as follows (see code
    `6.08.py`):'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The preceding code is self-explanatory. The Go button is attached to a command callback
    named `on_create_text_button_clicked`, which is defined as follows (see code `6.08.py`):'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Our `draw_text` method is now functional. Next, let's code the `delete_item`
    method.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: The operations that we want to do now are slightly different from their predecessors. Earlier,
    we were creating items on the canvas. Now we have to target items already present
    on the canvas.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: The item that needs to be targeted is the one on which the user clicks with
    their mouse. Fortunately, getting the item handle for the item under the mouse
    is very easy using the current tag.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: 'Accordingly, the code for `delete_item` is as follows (see code `6.08.py`):'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Now, if you select the Delete button from the toolbar and click on any item
    on the canvas, that item is deleted.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s code the `fill_item` and `fill_item_options` methods (see code
    `6.08.py`):'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'We had to use a `try…except` block because some canvas items such as lines
    and text do not have an outline option:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Next, we code the `duplicate_item` method. In order to duplicate an item we
    need to know three things:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: Type of item—if the item is a `line`, `oval`, `arc`, `rectangle`, or `polygon`
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The coordinates for the item
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The configurations of the item
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can get the type of item as a string using the type method as follows: `canvas.type(item_specifier)`'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: This returns a string such as `line`, `oval`, `arc`, `rectangle`, or `polygon`.
    In order to recreate an item of the same type, we need to append the string `create_`
    to the returned type and call the method.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: 'The coordinates of a given item can be obtained by calling the coordinates
    method as follows:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: '`` `coordinates = canvas.coords("item_specifier")` ``'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: 'The configurations for an item can be obtained as a dictionary using the following
    command:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: '`canvas.itemconfig(item_specifier)`'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: 'This returns all the configurations for an item, whether specified or not specified.
    For example, here''s a sample of a dictionary returned by calling the preceding
    method on a canvas item:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Clearly, we do not require those configuration values that are empty or zero.
    We, therefore, write a method that filters out all unnecessary configurations:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Now that we know how to fetch all required elements to duplicate a canvas item, here''s
    the code for `duplicate_item` (see code `6.08.py`):'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Finally, the last line calls a `wrapper` function that actually runs the function
    that duplicates the canvas item (see code `6.08.py`):'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Now, if you create an item, select the duplicate item button, and click on
    the item, a duplicate item is created. However, since we do not want the duplicate
    item to be created exactly on top of the existing item, we offset its coordinates
    by `10` pixels from the coordinates of the item being duplicated. This offsetting
    is done in the line:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Now, if you create an item on the canvas, select the duplicate item button,
    and click on the item, its duplicate is created at an offset of `10` pixels from
    the original item.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we code the `move_to_top` method. We have already discussed that items added
    to the canvas are added on top of each other. What if we want to move an item
    previously added to the canvas? The following figure shows what it means to move
    an item on top of another:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c7f21151-ab49-479a-b1f3-632fe00dc550.png)'
  id: totrans-327
  prefs: []
  type: TYPE_IMG
- en: 'We use the `tag_raise` and `tag_lower` methods to move items higher and lower in
    the stack. We use `tag_raise` to define the `move_to_top` method as follows (see
    code `6.08.py`):'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The preceding code raises the clicked item highest up in the item's stack.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: 'When you draw multiple items on the canvas, the items are placed in a stack.
    By default, new items get added on top of items previously drawn on the canvas.
    You can, however, change the stacking order using:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: '`canvas.tag_raise(item)`.'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: If multiple items match, they are all moved, with their relative order preserved. However,
    this method will not change the stacking order for any new window item that you
    draw within the canvas.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: Then there are the `find_above` and `find_below` methods that you can use to
    find items above or below an item in the canvas stacking order.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will define the `drag_item` method. This method uses the move method
    to change the coordinates of a given item (see code `6.08.py`):'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Since we want the drag to occur continuously and not as a jump from one place to
    another, we temporarily bind the mouse binding to update the start and end coordinates
    like we did when we defined the `draw_irregular_line` method.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we define two methods to enlarge and reduce item size. We will use
    the `canvas.scale` method to increase and reduce item size by 20%:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Note that, immediately upon item resize, we reconfigure the scroll region option
    to update the scroll bar.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: 'The `bbox` method returns the bounding box for an item. The syntax is:  `.canvas.bbox(item_specifier)`.
    This returns the bounding box as a tuple of length 4\. If the item-specifier is
    omitted, the bounding box for all items is returned.'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: Note that bounding box values are approximate and may differ from the real value
    by a few pixels.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: This concludes the iteration. All the buttons in the left toolbar are now functional
    (see code `6.08.py`).
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: Adding functionality to menu items
  id: totrans-344
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Recall that, at the time of creating our menu using the `Framework` class, we
    created empty methods that were linked to our menu items. We will now modify those
    empty methods to make them functional (see code `6.09.py` )
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: 'File | New Menu:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: 'The canvas delete method can be used to delete an item, given an item-specifier.
    Here we use `ALL` to delete all items from the canvas:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'File | Save, File | Save As:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: Tkinter lets you save canvas objects as a postscript file using the command
    `postscript()`. Note, however, that the resulting postscript file cannot save
    images or any widgets embedded on the canvas. Furthermore, note that the pickling
    of Tkinter widgets or saving to `.jpg` or `.png` formats is not possible. This
    is one of the major limitations of Tkinter.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the code for the save and save as features (see code `6.09.py`):'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: We do not discuss the Close and About menu as we have coded similar menus in
    all our previous projects (see code `6.09.py`).
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit | Undo:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: 'Recall that all items added to the canvas are stored in a stack. We can access
    the stack using the canvas command:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Using this, we implement a very basic undo operation, which lets us delete the
    last drawn item on the canvas.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: 'Accordingly, the code for adding the undo feature is as follows (see code `6.09.py`):'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Note that this will not undo any styling changes such as changes in color, width,
    outline, and so on. In fact, it will only be able to delete the last item from
    the stack.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: We can implement a fully-fledged undo stack by saving all actions in a suitable
    data structure, but that would be an exercise worth its own chapter.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the find method we used here, the Canvas widget has a method
    named:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: It returns the item handle for the item closest to the given position on the
    canvas. This means that if there is only one item on the canvas, it will be selected
    regardless of how near or how far you click from it.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: 'If, on the other hand, you want objects only within a certain area, you can
    use:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: This returns all items that overlap the given rectangle, or that are completely enclosed
    by it.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a hold on the item to be manipulated, we can proceed to do whatever
    we want with the item.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: For a complete list of canvas methods, please see [http://infohost.nmt.edu/tcc/help/pubs/tkinter/web/canvas-methods.html](http://infohost.nmt.edu/tcc/help/pubs/tkinter/web/canvas-methods.html).
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: 'View | Zoom in, View | Zoom out:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we define these two methods using the `canvas.scale` method. We have
    already used the scale methods earlier to enlarge and reduce individual items.
    Here, we simply use the method on the `ALL` item-specifier, as in the following
    code (see code `6.09.py`):'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: That concludes the iteration and the chapter.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-374
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To summarize, in this chapter, we began by creating a custom GUI framework on
    top of Tkinter.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: We saw how GUI frameworks can be used to generate boilerplate code for our programs,
    thereby ensuring maximum code reuse and rapid application development.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: Next, we explored the Canvas widget in detail. We saw how to create various
    canvas items. Then, we saw how we could manipulate the attributes of these canvas
    items using tag or ID.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: We saw the `colorchooser` module of Tkinter in action. We worked with the ttk
    Combobox widget. We also looked at common methods that are available on all Tkinter
    widgets.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: We also saw the benefits of writing programs that use convention over configuration
    to ease the logical flow of the program.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: QA section
  id: totrans-380
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before you proceed to the next chapter, make sure you can answer these questions
    to your
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: 'satisfaction:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: What are software frameworks?  Why are they used?
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When is it beneficial to use software frameworks instead of writing code from
    scratch?
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is a structured markup language? Can you a list a few of them?
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is the convention over configuration software design paradigm?
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are tags used for in the context of  Tkinter's Canvas widget?
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-388
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Read the complete documentation for the Tkinter Canvas widget. You can find
    the documentation by typing the following command in a Python command shell:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
