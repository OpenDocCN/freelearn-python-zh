<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:m="http://www.w3.org/1998/Math/MathML" xmlns:pls="http://www.w3.org/2005/01/pronunciation-lexicon" xmlns:ssml="http://www.w3.org/2001/10/synthesis">
<head>
  <meta charset="UTF-8"/>
  <title>Creating API Views</title>
  <link type="text/css" rel="stylesheet" media="all" href="style.css"/>
  <link type="text/css" rel="stylesheet" media="all" href="core.css"/>
</head>
<body>
  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Creating API Views</h1>
                </header>
            
            <article>
                
<p>In this chapter, we have to run our first version of a RESTful Web Service powered by Django. We will write API views to process different HTTP requests and we will perform HTTP requests with command-line and GUI tools. We will analyze how Django and Django REST framework process each HTTP request. We will gain an understanding of:</p>
<ul>
<li>Creating Django views combined with serializer classes</li>
<li>CRUD operations with Django views and the request methods</li>
<li>Launching Django's development server</li>
<li>Making HTTP GET requests that target a collection of instances with command-line tools</li>
<li>Making HTTP GET requests that target a single instance with command-line tools</li>
<li>Making HTTP GET requests with command-line tools</li>
<li>Making HTTP POST requests with command-line tools</li>
<li>Making HTTP PUT requests with command-line tools</li>
<li>Making HTTP DELETE requests with command-line tools</li>
<li>Making HTTP GET requests with Postman&#160; &#160; &#160;&#160;</li>
<li>Making HTTP POST requests with Postman</li>
</ul>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Creating Django views combined with serializer classes</h1>
                </header>
            
            <article>
                
<p>We have created the necessary model and its serializer. It is time to code the necessary elements to process HTTP requests and produce HTTP responses. Now, we will create Django views that use the&#160;<kbd>ToySerializer</kbd> class that we created previously to return JSON representations of the entities for each HTTP request that our web service will handle. Open the <kbd>toys/views.py</kbd> file. The following lines show the initial code for this file with just one import statement and a comment that indicates we should create the views:</p>
<pre>from django.shortcuts import render 
 
# Create your views here. </pre>
<p><span>We will create our first version of the web service and we will use functions to keep the code as simple as possible. We will work with classes and more complex code in later examples. First, it is very important to understand how Django and Django REST framework work by way of a simple example.</span></p>
<p>Now, write the following lines in the <kbd>restful01/toys/views.py</kbd> <span>file</span>&#160;to create a <kbd>JSONResponse</kbd> class and declare two functions: <kbd>toy_list</kbd> and <kbd>toy_detail</kbd>. The code file for the sample is included in the <kbd>hillar_django_restful_03_01</kbd> folder, in the <kbd>restful01/toys/views.py</kbd> file:</p>
<pre>from django.shortcuts import render 
from django.http import HttpResponse 
from django.views.decorators.csrf import csrf_exempt 
from rest_framework.renderers import JSONRenderer 
from rest_framework.parsers import JSONParser 
from rest_framework import status 
from toys.models import Toy 
from toys.serializers import ToySerializer 
 
 
class JSONResponse(HttpResponse): 
    def __init__(self, data, **kwargs): 
        content = JSONRenderer().render(data) 
        kwargs['content_type'] = 'application/json' 
        super(JSONResponse, self).__init__(content, **kwargs) 
 
 
@csrf_exempt 
def toy_list(request):<strong> 
    if request.method == 'GET': 
        </strong>toys = Toy.objects.all() 
        toys_serializer = ToySerializer(toys, many=True) 
        return JSONResponse(toys_serializer.data)<strong> 
 
    elif request.method == 'POST': 
        </strong>toy_data = JSONParser().parse(request) 
        toy_serializer = ToySerializer(data=toy_data) 
        if toy_serializer.is_valid(): 
            toy_serializer.save() 
            return JSONResponse(toy_serializer.data, \
                status=status.HTTP_201_CREATED) 
        return JSONResponse(toy_serializer.errors, \
            status=status.HTTP_400_BAD_REQUEST) 
 
 
@csrf_exempt 
def toy_detail(request, pk): 
    try: 
        toy = Toy.objects.get(pk=pk) 
    except Toy.DoesNotExist: 
        return HttpResponse(status=status.HTTP_404_NOT_FOUND) 
 
    <strong>if request.method == 'GET':</strong> 
        toy_serializer = ToySerializer(toy) 
        return JSONResponse(toy_serializer.data) 
 
    <strong>elif request.method == 'PUT':</strong> 
        toy_data = JSONParser().parse(request) 
        toy_serializer = ToySerializer(toy, data=toy_data) 
        if toy_serializer.is_valid(): 
            toy_serializer.save() 
            return JSONResponse(toy_serializer.data) 
        return JSONResponse(toy_serializer.errors, \<br/>            status=status.HTTP_400_BAD_REQUEST) 
 
  <strong>  elif request.method == 'DELETE':</strong> 
        toy.delete() 
        return HttpResponse(status=status.HTTP_204_NO_CONTENT) </pre>
<p><span>The highlighted lines show the expressions that evaluate the value of the</span> <kbd>request.method</kbd> <span>attribute to determine the actions to be performed based on the HTTP verb.</span> The <kbd>JSONResponse</kbd> class is a subclass of the <kbd>django.http.HttpResponse</kbd> class. The <kbd>django.http.HttpResponse</kbd> superclass represents an HTTP response with string content.</p>
<p>The <kbd>JSONResponse</kbd> class renders its content in JSON. The class just declares the <kbd>__init__</kbd> method that creates a <kbd>rest_framework.renderers.JSONRenderer</kbd> instance and calls its <kbd>render</kbd> method to render the received data in JSON and save the returned byte string in the <kbd>content</kbd> local variable. Then, the code adds the <kbd>'content_type'</kbd> key to the response header with <kbd>'application/json'</kbd> as its value. Finally, the code calls the initializer for the base class with the JSON byte string and the key-value pair added to the header. This way, the class represents a JSON response that we use in the two functions to easily return a JSON response in each HTTP request our web service will process. Since Django 1.7, the <kbd>django.http.JsonResponse</kbd> class has accomplished the same goal. However, we created our own class for educational purposes in this example as well as to understand the difference between an <kbd>HttpResponse</kbd> and a <kbd>JSONResponse</kbd>.</p>
<p>The code uses the <kbd>@csrf_exempt</kbd> decorator in the two functions to ensure that the view sets a <strong>CSRF</strong> (short for <strong>Cross-Site Request Forgery</strong>) cookie. We do this to make it easier to test this example, which doesn't represent a production-ready web service. We will add security features to our RESTful Web Service later. Of course, it is very important to understand that we should never put a web service into production before configuring security and throttling rules.</p>
<div class="packt_tip">Note that the previous code has many problems that we will analyze and fix in the forthcoming chapters. However, first, we need to understand how some basic things work.</div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Understanding CRUD operations with Django views and the request methods</h1>
                </header>
            
            <article>
                
<p>When the Django server receives an HTTP request, Django creates an <kbd>HttpRequest</kbd> instance, specifically a <kbd>django.http.HttpRequest</kbd> object. This instance contains metadata about the request, and this metadata includes an HTTP verb such as GET, POST, or PUT. The <kbd>method</kbd> attribute provides a string representing the HTTP verb or method used in the request.</p>
<p>When Django loads the appropriate view that will process the request, it passes the <kbd>HttpRequest</kbd> instance as the first argument to the <kbd>view</kbd> function. The <kbd>view</kbd> function has to return an <kbd>HttpResponse</kbd> instance, specifically a <kbd>django.http.HttpResponse</kbd> instance.</p>
<p>The <kbd>toy_list</kbd> function lists all the toys or creates a new toy. The function receives an <kbd>HttpRequest</kbd> instance in the <kbd>request</kbd> argument. The function is capable of processing two HTTP verbs: <kbd>GET</kbd> and <kbd>POST</kbd>. The code checks the value of the <kbd>request.method</kbd> attribute to determine the code to be executed based on the HTTP verb.</p>
<p>If the HTTP verb is <kbd>GET</kbd>, the expression <kbd>request.method == 'GET'</kbd> will evaluate to <kbd>True</kbd> and the code has to list all the toys. The code will retrieve all the <kbd>Toy</kbd> objects from the database, use the <kbd>ToySerializer</kbd> to serialize all of them and return a <kbd>JSONResponse</kbd> instance built with the data generated by the <kbd>ToySerializer</kbd> serializer. The code creates the <kbd>ToySerializer</kbd> instance with the <kbd>many=True</kbd> argument to specify that multiple instances have to be serialized and not just one. Under the hood, Django uses a <kbd>ListSerializer</kbd> instance when the <kbd>many</kbd> argument value is set to <kbd>True</kbd>. This way, Django is capable of serializing a list of objects.</p>
<p>If the HTTP verb is <kbd>POST</kbd>, the code has to create a new toy based on the JSON data that is included in the body of the HTTP request. First, the code uses a <kbd>JSONParser</kbd> instance and calls its <kbd>parse</kbd> method with the <kbd>request</kbd> parameter that the <kbd>toy_list</kbd> function receives as an argument to parse the toy data provided as <kbd>JSON</kbd> data in the request body and saves the results in the <kbd>toy_data</kbd> local variable. Then, the code creates a <kbd>ToySerializer</kbd> instance with the previously retrieved data and calls the <kbd>is_valid</kbd> method to determine whether the <kbd>Toy</kbd> instance is valid or not. If the instance is valid, the code calls the <kbd>save</kbd> method to persist the instance in the database and returns a <kbd>JSONResponse</kbd> with the saved data in its body and a status equal to <kbd>status.HTTP_201_CREATED</kbd>, that is, <kbd>201 Created</kbd>.</p>
<div class="packt_tip">Whenever we have to return a specific status different from the default <kbd>200 OK</kbd> status, it is a good practice to use the module variables defined in the <kbd>rest_framework.status</kbd> module and avoid using hard-coded numeric values. If you see <kbd>status=status.HTTP_201_CREATED</kbd>, as in the sample code, it is easy to understand that the status is an HTTP <kbd>201 Created</kbd> status. If you read <kbd>status=201</kbd>, you have to remember what the number 201 stands for in the HTTP status codes.</div>
<p>The <kbd>toy_detail</kbd> function retrieves, updates, or deletes an existing toy. The function receives an <kbd>HttpRequest</kbd> instance in the <kbd>request</kbd> argument and the identifier for the toy to be retrieved, updated, or deleted in the <kbd>pk</kbd> argument. The function is capable of processing three HTTP verbs: <kbd>GET</kbd>, <kbd>PUT</kbd>, and <kbd>DELETE</kbd>. The code checks the value of the <kbd>request.method</kbd> attribute to determine the code to be executed based on the HTTP verb.</p>
<p>No matter what the HTTP verb is, the <kbd>toy_detail</kbd> function calls the <kbd>Toy.objects.get</kbd> method with the received <kbd>pk</kbd> as the <kbd>pk</kbd> argument to retrieve a <kbd>Toy</kbd> instance from the database based on the specified identifier, and saves it in the <kbd>toy</kbd> local variable. In case a toy with the specified identifier doesn't exist in the database, the code returns an <kbd>HttpResponse</kbd> with its status set to <kbd>status.HTTP_404_NOT_FOUND</kbd>, that is, <kbd>404 Not Found</kbd>.</p>
<p>If the HTTP verb is <kbd>GET</kbd>, the code creates a <kbd>ToySerializer</kbd> instance with <kbd>toy</kbd> as an argument and returns the data for the serialized toy in a <kbd>JSONResponse</kbd> that will include the default HTTP <kbd>200 OK</kbd> status. The code returns the retrieved toy serialized as JSON in the response body.</p>
<p>If the HTTP verb is <kbd>PUT</kbd>, the code has to create a new toy based on the JSON data that is included in the HTTP request and use it to replace an existing toy. First, the code uses a <kbd>JSONParser</kbd> instance and calls its <kbd>parse</kbd> method with <kbd>request</kbd> as an argument to parse the toy data provided as JSON data in the request and saves the results in the <kbd>toy_data</kbd> local variable. Then, the code creates a <kbd>ToySerializer</kbd> instance with the <kbd>Toy</kbd> instance previously retrieved from the database (<kbd>toy</kbd>) and the retrieved data that will replace the existing data (<kbd>toy_data</kbd>). Then, the code calls the <kbd>is_valid</kbd> method to determine whether the <kbd>Toy</kbd> instance is valid or not. If the instance is valid, the code calls the <kbd>save</kbd> method to persist the instance with the replaced values in the database and returns a <kbd>JSONResponse</kbd> with the saved data serialized as JSON in its body and the default HTTP <kbd>200 OK</kbd> status. If the parsed data doesn't generate a valid <kbd>Toy</kbd> instance, the code returns a <kbd>JSONResponse</kbd> with a status equal to <kbd>status.HTTP_400_BAD_REQUEST</kbd>, that is <kbd>400 Bad Request</kbd>.</p>
<p>If the HTTP verb is <kbd>DELETE</kbd>, the code calls the <kbd>delete</kbd> method for the <kbd>Toy</kbd> instance previously retrieved from the database (<kbd>toy</kbd>). The call to the <kbd>delete</kbd> method erases the underlying row in the <kbd>toys_toy</kbd> table that we analyzed in the previous chapter. Thus, the toy won't be available anymore. Then, the code returns a <kbd>JSONResponse</kbd> with a status equal to <kbd>status</kbd>. <kbd>HTTP_204_NO_CONTENT</kbd> that is, <kbd>204 No Content</kbd>.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Routing URLs to Django views and functions</h1>
                </header>
            
            <article>
                
<p>Now, we have to create a new Python file named <kbd>urls.py</kbd> in the <kbd>toys</kbd> folder, specifically, the <kbd>toys/urls.py</kbd> file. The following lines show the code for this file, which defines the URL patterns that specify the regular expressions that have to be matched in the request to run a specific function previously defined in the <kbd>views.py</kbd> file. The code file for the sample is included in the <kbd>hillar_django_restful_03_01</kbd> folder, in the <kbd>restful01/toys/urls.py</kbd> file:</p>
<pre>from django.conf.urls import url 
from toys import views 
 
urlpatterns = [ 
    url(r'^toys/$', views.toy_list), 
    url(r'^toys/(?P&lt;pk&gt;[0-9]+)$', views.toy_detail), 
] </pre>
<p>The <kbd>urlpatterns</kbd> list makes it possible to route URLs to views. The code calls the <kbd>django.conf.urls.url</kbd> function with the regular expression that has to be matched and the <kbd>view</kbd> function defined in the <kbd>views</kbd> module as arguments to create a <kbd>RegexURLPattern</kbd> instance for each entry in the <kbd>urlpatterns</kbd> list.</p>
<p>Now, we have to replace the code in the <kbd>urls.py</kbd> file in the <kbd>restful01</kbd> folder, specifically, the <kbd>restful01/urls.py</kbd> file. The file defines the root URL configurations, and therefore we must include the URL patterns declared in the previously coded <kbd>toys/urls.py</kbd> file. The following lines show the new code for the <kbd>restful01/urls.py</kbd> file. The code file for the sample is included in the <kbd>hillar_django_restful_03_01</kbd> folder, in the <kbd>restful01/urls.py</kbd> file:</p>
<pre>from django.conf.urls import url, include 
 
urlpatterns = [ 
    url(r'^', include('toys.urls')), 
] </pre>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Launching Django's development server</h1>
                </header>
            
            <article>
                
<p>Now, we can launch Django's development server to compose and send HTTP requests to our unsecured web service. Remember that we will add security later.</p>
<p>Execute the following command in a Linux or macOS Terminal, or in the Windows Command Prompt or Powershell that has our previously created virtual environment activated. Make sure you are in the <kbd>restful01</kbd> folder within the virtual environment's main folder:</p>
<pre>    <strong>python manage.py runserver</strong></pre>
<p>The following lines show the output after we execute the previous command. The development server is listening at port <kbd>8000</kbd>:</p>
<pre>    <strong>Performing system checks...</strong>
    
    <strong>System check identified no issues (0 silenced).</strong>
    <strong>October 09, 2017 - 18:42:30</strong>
    <strong>Django version 1.11.5, using settings 'restful01.settings'</strong>
    <strong>Starting development server at http://127.0.0.1:8000/</strong>
    <strong>Quit the server with CTRL-BREAK.</strong></pre>
<p>With the previous command, we will start the Django development server and we will only be able to access it on our development computer. The previous command starts the development server at the default IP address, that is, <kbd>127.0.0.1</kbd> (<kbd>localhost</kbd>). It is not possible to access this IP address from other computers or devices connected to our LAN. Thus, if we want to make HTTP requests to our API from other computers or devices connected to our LAN, we should use the development computer IP address, <kbd>0.0.0.0</kbd> (for IPv4 configurations) or <kbd>::</kbd> (for IPv6 configurations) as the desired IP address for our development server.</p>
<p>If we specify <kbd>0.0.0.0</kbd> as the desired IP address for IPv4 configurations, the development server will listen on every interface on port 8000. When we specify <kbd>::</kbd> for IPv6 configurations, it will have the same effect. In addition, it is necessary to open the default port <kbd>8000</kbd> in our firewalls (software and/or hardware) and configure port-forwarding to the computer that is running the development server. The following command launches Django's development server in an IPv4 configuration and allows requests to be made from other computers and devices connected to our LAN:</p>
<pre>    <strong>python manage.py runserver 0.0.0.0:8000</strong> </pre>
<p>If you decide to compose and send HTTP requests from other computers or devices connected to the LAN, remember that you have to use the development computer's assigned IP address instead of <kbd>localhost</kbd>. For example, if the computer's assigned IPv4 IP address is <kbd>192.168.2.103</kbd>, instead of <kbd>localhost:8000</kbd>, you should use <kbd>192.168.2.103:8000</kbd>. Of course, you can also use the hostname instead of the IP address.</p>
<div class="packt_tip">The previously explained configurations are very important because mobile devices might be the consumers of our RESTful Web Services and we will always want to test the apps that make use of our web services and APIs in our development environments.</div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Making HTTP GET requests that target a collection of instances</h1>
                </header>
            
            <article>
                
<p>In <a href="dj-rst-websvc_ch11.html">Chapter 1</a>, <em>Installing the Required Software and Tools</em>, we installed command-line and GUI tools that were going to allow us to compose and send HTTP requests to the web services we were going to build throughout this book. Now, we will use the curl utility to make HTTP GET requests, specifically, HTTP GET requests that target a collection of toys. In case curl is not included in the path, make sure you replace curl with the full path to this utility.</p>
<p>Make sure you leave the Django development server running. Don't close the terminal or Command Prompt that is running this development server. Open a new Terminal in Linux or macOS, or a Command Prompt in Windows, and run the following command. It is very important that you enter the ending slash (<kbd>/</kbd>) because <kbd>/toys</kbd> won't match any of the patterns specified in <kbd>urlpatterns</kbd> in the <kbd>toys/urls.py</kbd> file. We aren't going to use options to follow redirects. Thus, we must enter <kbd>/toys/</kbd>, including the ending slash (<kbd>/</kbd>).</p>
<pre><strong>    curl -X GET localhost:8000/toys/</strong></pre>
<p>The previous command will compose and send the following HTTP request: <kbd>GET http://localhost:8000/toys/</kbd>. The request is the simplest case in our RESTful Web Service because it will match and run the <kbd>views.toy_list</kbd> function, that is, the <kbd>toy_list</kbd> function we coded within the <kbd>toys/views.py</kbd> file. The function just receives <kbd>request</kbd> as a parameter because the URL pattern doesn't include any parameters. As the HTTP verb for the request is <kbd>GET</kbd>, the <kbd>request.method</kbd> property is equal to <kbd>'GET'</kbd>, and therefore, the function will execute the code that retrieves all the <kbd>Toy</kbd> objects and generates a JSON response with all of these <kbd>Toy</kbd> objects serialized.</p>
<p>The following lines show an example response for the HTTP request, with three <kbd>Toy</kbd> objects in the JSON response:</p>
<pre>    <strong>[{"pk":3,"name":"Clash Royale play set","description":"6 figures from Clash Royale","release_date":"2017-10-09T12:10:00.776594Z","toy_category":"Playset","was_included_in_home":false},{"pk":2,"name":"Hawaiian Barbie","description":"Barbie loves Hawaii","release_date":"2017-10-09T12:11:37.090335Z","toy_category":"Dolls","was_included_in_home":true},{"pk":1,"name":"Snoopy talking action figure","description":"Snoopy speaks five languages","release_date":"2017-10-09T12:11:37.090335Z","toy_category":"Action figures","was_included_in_home":false}]</strong></pre>
<p>As we might notice from the previous response, the curl utility displays the JSON response in a single line, and therefore, it is a bit difficult to read. It is possible to use different tools, including some Python scripts, to provide a better format to the response. However, we will use the HTTPie command-line tool we installed in our virtual environment for this purpose later.</p>
<p>In this case, we know that the value of the <kbd>Content-Type</kbd> header key of the response is <kbd>application/json</kbd>. However, in case we want more details about the response, we can use the <kbd>-i</kbd> option to request curl to print the HTTP response headers and their key-value pairs. We can combine the <kbd>-i</kbd> and <kbd>-X</kbd> options by entering <kbd>-iX</kbd>.</p>
<p>Go back to the terminal in Linux or macOS, or the Command prompt in Windows, and run the following command:</p>
<pre>    <strong>curl -iX GET localhost:8000/toys/</strong></pre>
<p>The following lines show an example response for the HTTP request. The first lines show the HTTP response headers, including the status (<kbd>200 OK</kbd>) and the <kbd>Content-Type: application/json</kbd>. After the HTTP response headers, we can see the details for the three <kbd>Toy</kbd> objects in the JSON response:</p>
<pre>    <strong>HTTP/1.0 200 OK</strong>
    <strong>Date: Tue, 10 Oct 2017 00:53:41 GMT</strong>
    <strong>Server: WSGIServer/0.2 CPython/3.6.2</strong>
    <strong>Content-Type: application/json</strong>
    <strong>X-Frame-Options: SAMEORIGIN</strong>
    <strong>Content-Length: 548</strong>
    
[{"pk":3,"name":"Clash Royale play set","description":"6 figures from Clash Royale","release_date":"2017-10-09T12:10:00.776594Z","toy_category":"Playset","was_included_in_home":false},{"pk":2,"name":"Hawaiian Barbie","description":"Barbie loves Hawaii","release_date":"2017-10-09T12:11:37.090335Z","toy_category":"Dolls","was_included_in_home":true},{"pk":1,"name":"Snoopy talking action figure","description":"Snoopy speaks five languages","release_date":"2017-10-09T12:11:37.090335Z","toy_category":"Action figures","was_included_in_home":false}]</pre>
<p>After we run the two requests, we will see the following lines in the window running the Django development server. The output indicates that the server received two HTTP requests with the <kbd>GET</kbd> verb and <kbd>/toys/</kbd> as the URI. The server processed both HTTP requests, returned a status code equal to <kbd>200</kbd>, and the response length was equal to <kbd>548</kbd> characters.</p>
<p>The response length might be different because the value for the primary key assigned to each toy will have an incidence in the response length. The first number after <kbd>HTTP/1.1."</kbd> indicates the returned status code (<kbd>200</kbd>) and the second number the response length (<kbd>548</kbd>):</p>
<pre>    <strong>[09/Oct/2017 22:12:37] "GET /toys/ HTTP/1.1" 200 548</strong>
    <strong>[09/Oct/2017 22:12:40] "GET /toys/ HTTP/1.1" 200 548</strong></pre>
<p>The following image shows two Terminal windows side-by-side on macOS. The Terminal window on the left-hand side is running the Django development server and displays the received and processed HTTP requests. The Terminal window on the right-hand side is running <kbd>curl</kbd> commands to generate the HTTP requests. It is a good idea to use a similar configuration to check the output while we compose and send the HTTP requests. Notice that the JSON outputs are a bit difficult to read because they don't use syntax highlighting:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="364" width="610" class=" image-border" src="images/58c92084-44cd-45fa-9d0d-309ab5577703.png"/></div>
<p>Now, open a new Terminal in Linux or macOS, or a new Command Prompt in Windows, and activate the virtual environment we created. This way, you will be able to access the HTTPie utility we installed within the virtual environment.</p>
<p>We will use the <kbd>http</kbd> command to easily compose and send HTTP requests to <kbd>localhost:8000</kbd> and test the RESTful Web Service. HTTPie supports curl-like shorthand for localhost, and therefore we can use <kbd>:8000</kbd> as a shorthand that expands to <kbd>http://localhost:8000</kbd>. Run the following command and remember to enter the ending slash (<kbd>/</kbd>):</p>
<pre> <strong>http :8000/toys/</strong></pre>
<p>The previous command will compose and send the following HTTP request: <kbd>GET http://localhost:8000/toys/</kbd>. The request is the same one we previously composed with the <kbd>curl</kbd> command. However, in this case, the HTTPie utility will display a colorized output and it will use multiple lines to display the JSON response, without any additional tweaks. The previous command is equivalent to the following command that specifies the <kbd>GET</kbd> method after <kbd>http</kbd>:</p>
<pre><strong>http :8000/toys/</strong></pre>
<p>The following lines show an example response for the HTTP request, with the headers and the three <kbd>Toy</kbd> objects in the JSON response. It is indeed easier to understand the response compared with the results that were generated when we composed the HTTP request with curl. HTTPie automatically formats the JSON data received as a response and applies syntax highlighting, specifically, both colors and formatting:</p>
<pre>    <strong>HTTP/1.0 200 OK</strong>
    <strong>Content-Length: 548</strong>
    <strong>Content-Type: application/json</strong>
    <strong>Date: Tue, 10 Oct 2017 01:26:52 GMT</strong>
    <strong>Server: WSGIServer/0.2 CPython/3.6.2</strong>
    <strong>X-Frame-Options: SAMEORIGIN</strong>
    
    <strong>[</strong>
    <strong>    {</strong>
    <strong>        "description": "6 figures from Clash Royale",</strong>
    <strong>        "name": "Clash Royale play set",</strong>
    <strong>        "pk": 3,</strong>
    <strong>        "release_date": "2017-10-09T12:10:00.776594Z",</strong>
    <strong>        "toy_category": "Playset",</strong>
    <strong>        "was_included_in_home": false</strong>
    <strong>    },</strong>
    <strong>    {</strong>
    <strong>        "description": "Barbie loves Hawaii",</strong>
    <strong>        "name": "Hawaiian Barbie",</strong>
    <strong>        "pk": 2,</strong>
    <strong>        "release_date": "2017-10-09T12:11:37.090335Z",</strong>
    <strong>        "toy_category": "Dolls",</strong>
    <strong>        "was_included_in_home": true</strong>
    <strong>    },</strong>
    <strong>    {</strong>
    <strong>        "description": "Snoopy speaks five languages",</strong>
    <strong>        "name": "Snoopy talking action figure",</strong>
    <strong>        "pk": 1,</strong>
    <strong>        "release_date": "2017-10-09T12:11:37.090335Z",</strong>
    <strong>        "toy_category": "Action figures",</strong>
    <strong>        "was_included_in_home": false</strong>
    <strong>    }</strong>
    <strong>]</strong> </pre>
<div class="packt_tip">We can achieve the same results by combining the output generated with the curl command with other utilities. However, HTTPie provides us exactly what we need for working with RESTful Web Services such as the one we are building with Django. We will use HTTPie to compose and send HTTP requests, but we will always provide the equivalent curl command. Remember that curl is faster when you need to execute it many times, such as when you prepare automated scripts.</div>
<p>The following image shows two Terminal windows side-by-side on macOS. The Terminal window on the left-hand side is running the Django development server and displays the received and processed HTTP requests. The Terminal window on the right-hand side is running HTTPie commands to generate the HTTP requests. Notice that the JSON output is easier to read compared to the output generated by the curl command:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="288" width="482" class=" image-border" src="images/9a42efd6-5ca6-49ae-b908-4f8517f64a0b.png"/></div>
<p>We can execute the <kbd>http</kbd> command with the <kbd>-b</kbd> option in case we don't want to include the header in the response. For example, the following line performs the same HTTP request but doesn't display the header in the response output, and therefore, the output will just display the JSON response:</p>
<pre>    <strong>http -b :8000/toys/</strong></pre>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Making HTTP GET requests that target a single instance</h1>
                </header>
            
            <article>
                
<p>Now, we will make HTTP GET requests that target a single <kbd>Toy</kbd> instance. We will select one of the toys from the previous list and we will compose an HTTP request to retrieve only the chosen toy. For example, in the previous list, the first toy has a <kbd>pk</kbd> value equal to <kbd>3</kbd> because the results are ordered by the toy's name in ascending order. Run the following command to retrieve this toy. Use the <kbd>pk</kbd> value you have retrieved in the previous command for the first toy, as the pk number might be different if you execute the sample code or the commands more than once or you make changes to the <kbd>toys_toy</kbd> table. In this case, you don't have to enter an ending slash (<kbd>/</kbd>) because <kbd>/toys/3/</kbd> won't match any of the patterns specified in <kbd>urlpatterns</kbd> in the <kbd>toys/urls.py</kbd> file:</p>
<pre>    <strong>http :8000/toys/3</strong>  </pre>
<p>The following is the equivalent <kbd>curl</kbd> command:</p>
<pre>    <strong>curl -iX GET localhost:8000/toys/3</strong></pre>
<p>The previous commands will compose and send the following HTTP request: <kbd>GET http://localhost:8000/toys/3/</kbd>. The request has a number after <kbd>/toys/</kbd>, and therefore, it will match <kbd>'^toys/(?P&lt;pk&gt;[0-9]+)$'</kbd> and run the <kbd>views.toy_detail</kbd> function, that is, the <kbd>toy_detail</kbd> function declared within the <kbd>toys/views.py</kbd> file. The function receives <kbd>request</kbd> and <kbd>pk</kbd> as parameters because the URL pattern passes the number specified after <kbd>/toys/</kbd> in the <kbd>pk</kbd> parameter.</p>
<p>As the HTTP verb for the request is <kbd>GET</kbd>, the <kbd>request.method</kbd> property is equal to <kbd>'GET'</kbd>, and therefore, the <kbd>toy_detail</kbd> function will execute the code that retrieves the <kbd>Toy</kbd> object whose primary key matches the <kbd>pk</kbd> value received as an argument and, if found, generates a JSON response with this <kbd>Toy</kbd> object serialized. The following lines show an example response for the HTTP request, with the <kbd>Toy</kbd> object that matches the <kbd>pk</kbd> value in the JSON response:</p>
<pre>    <strong>HTTP/1.0 200 OK</strong>
    <strong>Content-Length: 182</strong>
    <strong>Content-Type: application/json</strong>
    <strong>Date: Tue, 10 Oct 2017 04:24:35 GMT</strong>
    <strong>Server: WSGIServer/0.2 CPython/3.6.2</strong>
    <strong>X-Frame-Options: SAMEORIGIN</strong>
    
    <strong>{</strong>
    <strong>    "description": "6 figures from Clash Royale", </strong>
    <strong>    "name": "Clash Royale play set", </strong>
    <strong>    "pk": 3, </strong>
    <strong>    "release_date": "2017-10-09T12:10:00.776594Z", </strong>
    <strong>    "toy_category": "Playset", </strong>
    <strong>    "was_included_in_home": false</strong>
    <strong>}</strong></pre>
<p>Now, we will compose and send an HTTP request to retrieve a toy that doesn't exist. For example, in the previous list, there is no toy with a <kbd>pk</kbd> value equal to <kbd>17500</kbd>. Run the following command to try to retrieve this toy. Make sure you use a <kbd>pk</kbd> value that doesn't exist. We must make sure that the utilities display the headers as part of the response because the response won't have a body:</p>
<pre>    <strong>http :8000/toys/17500</strong>  </pre>
<p>The following is the equivalent <kbd>curl</kbd> command:</p>
<pre>    <strong>curl -iX GET localhost:8000/toys/17500</strong></pre>
<p>The previous commands will compose and send the following HTTP request: <kbd>GET http://localhost:8000/toys/17500</kbd>. The request is the same as the previous one we analyzed, with a different number for the <kbd>pk</kbd> parameter. The server will run the <kbd>views.toy_detail</kbd> function, that is, the <kbd>toy_detail</kbd> function declared within the <kbd>toys/views.py</kbd> file. The function will execute the code that retrieves the <kbd>Toy</kbd> object whose primary key matches the <kbd>pk</kbd> value received as an argument and a <kbd>Toy.DoesNotExist</kbd> exception will be thrown and captured because there is no toy with the specified <kbd>pk</kbd> value. Thus, the code will return an HTTP <kbd>404 Not Found</kbd> status code. The following lines show an example header response for the HTTP request:</p>
<pre>    <strong>HTTP/1.0 404 Not Found</strong>
    <strong>Content-Length: 0</strong>
    <strong>Content-Type: text/html; charset=utf-8</strong>
    <strong>Date: Tue, 10 Oct 2017 15:54:59 GMT</strong>
    <strong>Server: WSGIServer/0.2 CPython/3.6.2</strong>
    <strong>X-Frame-Options: SAMEORIGIN</strong></pre>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Making HTTP POST requests</h1>
                </header>
            
            <article>
                
<p>Now, we will compose and send an HTTP request to create a new toy:</p>
<pre>    <strong>http POST :8000/toys/ name="PvZ 2 puzzle" description="Plants vs    <br/>    Zombies 2 puzzle" toy_category="Puzzle" was_included_in_home=false <br/>    release_date="2017-10-08T01:01:00.776594Z"</strong>  </pre>
<p>The following is the equivalent <kbd>curl</kbd> command. It is very important to use the <kbd>-H "Content-Type: application/json"</kbd> option to indicate to curl that it should send the data specified after the <kbd>-d</kbd> option as <kbd>application/json</kbd> instead of the default <kbd>application/x-www-form-urlencoded</kbd>:</p>
<pre>    <strong>curl -iX POST -H "Content-Type: application/json" -d '{"name":"PvZ   <br/>    2 puzzle", "description":"Plants vs Zombies 2 puzzle",    <br/>    "toy_category":"Puzzle", "was_included_in_home": "false", <br/>    "release_date": "2017-10-08T01:01:00.776594Z"}' <br/>     localhost:8000/toys/</strong>  </pre>
<p>The previous commands will compose and send the following HTTP request: <kbd>POST http://localhost:8000/toys/</kbd> with the following JSON key-value pairs:</p>
<pre>{ 
    "name": "PvZ 2 puzzle",  
    "description":"Plants vs Zombies 2 puzzle", 
    "toy_category":"Puzzle", 
    "was_included_in_home": "false", 
    "release_date": "2017-10-08T01:01:00.776594Z" 
} </pre>
<p>The request specifies <kbd>/toys/</kbd>, and therefore, it will match the <kbd>'^toys/$'</kbd> regular expression and run the <kbd>views.toy_list</kbd> function, that is, the <kbd>toy_detail</kbd> function declared within the <kbd>toys/views.py</kbd> file. The function just receives <kbd>request</kbd> as a parameter because the URL pattern doesn't include any parameters. As the HTTP verb for the request is <kbd>POST</kbd>, the <kbd>request.method</kbd> property is equal to <kbd>'POST'</kbd>, and therefore, the function will execute the code that parses the JSON data received in the request. Then, the function creates a new <kbd>Toy</kbd> and, if the data is valid, it saves the new <kbd>Toy</kbd> to the <kbd>toys_toy</kbd> table in the SQLite database. If the new <kbd>Toy</kbd> was successfully persisted in the database, the function returns an HTTP <kbd>201 Created</kbd> status code and the recently persisted <kbd>Toy</kbd> serialized to JSON in the response body. The following lines show an example response for the HTTP request, with the new <kbd>Toy</kbd> object in the JSON response:</p>
<pre>    <strong>HTTP/1.0 201 Created</strong>
    <strong>Content-Length: 171</strong>
    <strong>Content-Type: application/json</strong>
    <strong>Date: Tue, 10 Oct 2017 16:27:57 GMT</strong>
    <strong>Server: WSGIServer/0.2 CPython/3.6.2</strong>
    <strong>X-Frame-Options: SAMEORIGIN</strong>
    
    <strong>{</strong>
    <strong>    "description": "Plants vs Zombies 2 puzzle", </strong>
    <strong>    "name": "PvZ 2 puzzle", </strong>
    <strong>    "pk": 4, </strong>
    <strong>    "release_date": "2017-10-08T01:01:00.776594Z", </strong>
    <strong>    "toy_category": "Puzzle", </strong>
    <strong>    "was_included_in_home": false</strong>
    <strong>}</strong></pre>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Making HTTP PUT requests</h1>
                </header>
            
            <article>
                
<p>Now, we will compose and send an HTTP request to update an existing toy, specifically, the previously added toy. We have to check the value assigned to <kbd>pk</kbd> in the previous response and replace <kbd>4</kbd> in the command with the returned value. For example, if the value for <kbd>pk</kbd> was <kbd>4</kbd>, you should use <kbd>:8000/toys/4</kbd> instead of <kbd>:8000/toys/4</kbd>:</p>
<pre><strong>http PUT :8000/toys/4 name="PvZ 3 puzzle" description="Plants vs Zombies 3 puzzle" toy_category="Puzzles &amp; Games" was_included_in_home=false release_date="2017-10-08T01:01:00.776594Z"<br/></strong></pre>
<p>The following is the equivalent <kbd>curl</kbd> command. As with the previous curl example, it is very important to use the <kbd>-H "Content-Type: application/json"</kbd> option to indicate <kbd>curl</kbd> to send the data specified after the <kbd>-d</kbd> option as <kbd>application/json</kbd> instead of the default <kbd>application/x-www-form-urlencoded</kbd>:</p>
<pre><strong>curl -iX PUT -H "Content-Type: application/json" -d '{"name":"PvZ 3 puzzle", "description":"Plants vs Zombies 3 puzzle", "toy_category":"Puzzles &amp; Games", "was_included_in_home": "false", "release_date": "2017-10-08T01:01:00.776594Z"}' localhost:8000/toys/4<br/></strong></pre>
<p>The previous commands will compose and send the following HTTP request: <kbd>PUT http://localhost:8000/toys/4</kbd> with the following JSON key-value pairs:</p>
<pre>{ 
    "name": "PvZ 3 puzzle",  
    "description":"Plants vs Zombies 3 puzzle", 
    "toy_category":"Puzzles &amp; Games", 
    "was_included_in_home": "false", 
    "release_date": "2017-10-08T01:01:00.776594Z" 
}</pre>
<p>The request has a number after <kbd>/toys/</kbd>, and therefore, it will match the <kbd>'^toys/(?P&lt;pk&gt;[0-9]+)$'</kbd> regular expression and run the <kbd>views.toy_detail</kbd> function, that is, the <kbd>toy_detail</kbd> function declared within the <kbd>toys/views.py</kbd> file. The function receives <kbd>request</kbd> and <kbd>pk</kbd> as parameters because the URL pattern passes the number specified after <kbd>/toys/</kbd> in the <kbd>pk</kbd> parameter. As the HTTP verb for the request is <kbd>PUT</kbd>, the <kbd>request.method</kbd> property is equal to <kbd>'PUT'</kbd>, and therefore, the function will execute the code that parses the JSON data received in the request. Then, the function will create a <kbd>Toy</kbd> instance from this data and update the existing toy in the database. If the toy was successfully updated in the database, the function returns an HTTP <kbd>200 OK</kbd> status code and the recently updated <kbd>Toy</kbd> serialized to JSON in the response body. The following lines show an example response for the HTTP request, with the updated <kbd>Toy</kbd> object in the JSON response:</p>
<pre>    <strong>HTTP/1.0 200 OK</strong>
    <strong>Content-Length: 180</strong>
    <strong>Content-Type: application/json</strong>
    <strong>Date: Tue, 10 Oct 2017 17:06:43 GMT</strong>
    <strong>Server: WSGIServer/0.2 CPython/3.6.2</strong>
    <strong>X-Frame-Options: SAMEORIGIN</strong>
    
    <strong>{</strong>
    <strong>    "description": "Plants vs Zombies 3 puzzle", </strong>
    <strong>    "name": "PvZ 3 puzzle", </strong>
    <strong>    "pk": 4, </strong>
    <strong>    "release_date": "2017-10-08T01:01:00.776594Z", </strong>
    <strong>    "toy_category": "Puzzles &amp; Games", </strong>
    <strong>    "was_included_in_home": false</strong>
    <strong>}</strong></pre>
<p>In order to successfully process a <kbd>PUT</kbd> HTTP request that updates an existing toy, we must provide values for all the required fields. We will compose and send an HTTP request to try to update an existing toy, and we will fail to do so because we will just provide a value for the name. As in the previous request, we will use the value assigned to <kbd>pk</kbd> in the last toy we added:</p>
<pre>    <strong>http PUT :8000/toys/4 name="PvZ 4 puzzle"</strong></pre>
<p>The following is the equivalent <kbd>curl</kbd> command:</p>
<pre>    <strong>curl -iX PUT -H "Content-Type: application/json" -d '{"name":"PvZ 4   <br/>    puzzle"}' localhost:8000/toys/4</strong></pre>
<p>The previous commands will compose and send the following HTTP request: <kbd>PUT http://localhost:8000/toys/4</kbd> with the following JSON key-value pair:</p>
<pre>{  
   "name": "PvZ 4 puzzle",  
} </pre>
<p>The request will execute the same code we explained for the previous request. As we didn't provide all the required values for a <kbd>Toy</kbd> instance, the <kbd>toy_serializer.is_valid()</kbd> method will return <kbd>False</kbd> and the function will return an HTTP <kbd>400 Bad Request</kbd> status code and the details generated in the <kbd>toy_serializer.errors</kbd> attribute serialized to JSON in the response body. The following lines show an example response for the HTTP request, with the required fields that our request didn't include values in the JSON response (<kbd>description</kbd>, <kbd>release_date</kbd>, and <kbd>toy_category</kbd>):</p>
<pre>    <strong>HTTP/1.0 400 Bad Request</strong>
    <strong>Content-Length: 129</strong>
    <strong>Content-Type: application/json</strong>
    <strong>Date: Tue, 10 Oct 2017 17:23:46 GMT</strong>
    <strong>Server: WSGIServer/0.2 CPython/3.6.2</strong>
    <strong>X-Frame-Options: SAMEORIGIN</strong>
    
    <strong>{</strong>
    <strong>    "description": [</strong>
    <strong>        "This field is required."</strong>
    <strong>    ], </strong>
    <strong>    "release_date": [</strong>
    <strong>        "This field is required."</strong>
    <strong>    ], </strong>
    <strong>    "toy_category": [</strong>
    <strong>        "This field is required."</strong>
    <strong>    ]</strong>
    <strong>}</strong></pre>
<p>When we want our API to be able to update a single field for an existing resource, in this case, an existing toy, we should provide an implementation for the PATCH method. The PUT method is meant to replace an entire resource and the PATCH method is meant to apply a delta to an existing resource. We can write code in the handler for the PUT method to apply a delta to an existing resource, but it is a better practice to use the PATCH method for this specific task. We will work with the PATCH method later.</p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Making HTTP DELETE requests</h1>
                </header>
            
            <article>
                
<p>Now, we will compose and send an HTTP request to delete an existing toy, specifically, the last toy we added. As in our last HTTP request, we have to check the value assigned to <kbd>pk</kbd> in the previous response and replace <kbd>4</kbd> in the command with the returned value:</p>
<pre>    <strong>http DELETE :8000/toys/4</strong></pre>
<p>The following is the equivalent <kbd>curl</kbd> command:</p>
<pre>    <strong>curl -iX DELETE localhost:8000/toys/4</strong></pre>
<p>The previous commands will compose and send the following HTTP request: <kbd>DELETE http://localhost:8000/toys/4</kbd>. The request has a number after <kbd>/toys/</kbd>, and therefore, it will match the <kbd>'^toys/(?P&lt;pk&gt;[0-9]+)$'</kbd> regular expression and run the <kbd>views.toy_detail</kbd> function, that is, the <kbd>toy_detail</kbd> function declared within the <kbd>toys/views.py</kbd> file. The function receives <kbd>request</kbd> and <kbd>pk</kbd> as parameters because the URL pattern passes the number specified after <kbd>/toys/</kbd> in the <kbd>pk</kbd> parameter. As the HTTP verb for the request is <kbd>DELETE</kbd>, the <kbd>request.method</kbd> property is equal to <kbd>'DELETE'</kbd>, and therefore, the function will execute the code that parses the JSON data received in the request. Then, the function creates a <kbd>Toy</kbd> instance from this data and deletes the existing toy in the database. If the toy was successfully deleted in the database, the function returns an HTTP <kbd>204 No Content</kbd> status code. The following lines show an example response to the HTTP request after successfully deleting an existing toy:</p>
<pre>    <strong>HTTP/1.0 204 No Content</strong>
    <strong>Content-Length: 0</strong>
    <strong>Content-Type: text/html; charset=utf-8</strong>
    <strong>Date: Tue, 10 Oct 2017 17:45:40 GMT</strong>
    <strong>Server: WSGIServer/0.2 CPython/3.6.2</strong>
    <strong>X-Frame-Options: SAMEORIGIN</strong> </pre>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Making HTTP GET requests with Postman</h1>
                </header>
            
            <article>
                
<p>Now, we will use one of the GUI tools we installed in <a href="dj-rst-websvc_ch11.html" target="_blank">Chapter 1</a>, <em>Installing the Required Software and Tools</em>, specifically Postman. We will use this GUI tool to compose and send HTTP requests to the web service.</p>
<p>The first time you execute Postman, you will see a modal that provides shortcuts to the most common operations. Make sure you close this modal so that we can focus on the main UI for Postman.</p>
<p>We will use the <span class="packt_screen">Builder</span> tab in Postman to easily compose and send diverse HTTP requests to <kbd>localhost:8000</kbd> and test the RESTful Web Service with this GUI tool. Postman doesn't support curl-like shorthand for localhost, and therefore, we cannot use the same shorthand we have been using when composing requests with HTTPie.</p>
<p>Select <span class="packt_screen">GET</span> in the drop-down menu on the left-hand side of the <span class="packt_screen">Enter request URL</span> textbox, and enter <kbd>localhost:8000/toys/</kbd> in this textbox on the right-hand side of the drop-down menu. Then, click <span class="packt_screen">Send</span> and Postman will display the following information:</p>
<ul>
<li><span class="packt_screen">Status</span>: <kbd>200 OK</kbd>.</li>
<li><span class="packt_screen">Time</span>: The time it took for the request to be processed.</li>
<li><span class="packt_screen">Size</span>: The approximate response size (sum of body size plus headers size).</li>
<li><span class="packt_screen">Body</span>: The response body with all the toys formatted as JSON with syntax highlighting. The default view for the body is <span class="packt_screen">Pretty</span> and it activates syntax highlighting.</li>
</ul>
<p>The following screenshot shows the JSON response body in Postman for the HTTP GET request to <kbd>localhost:8000/toys/</kbd>.</p>
<div class="CDPAlignCenter CDPAlign"><img src="images/ca8e5bd9-10b8-49a1-9119-8747a04f05f9.png"/></div>
<p>Click on the <span class="packt_screen">Headers</span> tab on the right-hand side of the <span class="packt_screen">Body</span> and <span class="packt_screen">Cookies</span> tab to read the response headers. The following screenshot shows the layout for the response headers that Postman displays for the previous response. Notice that Postman displays the <span class="packt_screen">Status</span> on the right-hand side of the response and doesn't include it as the first line of the key-value pairs that compose the headers, as when we worked with both the <kbd>curl</kbd> and <kbd>http</kbd> command-line utilities.</p>
<div class="CDPAlignCenter CDPAlign"><img height="295" width="523" src="images/3ce07f6d-f8a9-4954-956b-e0ad58987534.png"/></div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Making HTTP POST requests with Postman</h1>
                </header>
            
            <article>
                
<p>Now, we will use the <span class="packt_screen">Builder</span> tab in Postman to compose and send an HTTP POST request to create a new toy. Perform the following steps:</p>
<ol>
<li>Click on the plus (<strong>+</strong>) button on the right-hand side of the tab that displayed the previous request. This way, you will create a new tab.</li>
<li>Select <span class="packt_screen">Request</span> in the New drop-down menu located in the upper-left corner.</li>
<li>Select <span class="packt_screen">POST</span> in the drop-down menu on the left-hand side of the <span class="packt_screen">Enter request URL</span> textbox.</li>
<li>Enter <kbd>localhost:8000/toys/</kbd> in that textbox on the right-hand side of the drop-down menu.</li>
</ol>
<ol start="5">
<li>Click <span class="packt_screen">Body</span> on the right-hand side of <span class="packt_screen">Authorization</span> and <span class="packt_screen">Headers</span>, within the panel that composes the request.</li>
<li>Activate the <span class="packt_screen">raw</span> radio button and select <span class="packt_screen">JSON (application/json)</span> in the drop-down menu on the right-hand side of the <span class="packt_screen">binary</span> radio button. Postman will automatically add a <kbd>Content-type = application/json</kbd> header, and therefore, you will notice the <span class="packt_screen">Headers</span> tab will be renamed to <span class="packt_screen">Headers (1)</span>, indicating to us that there is one key-value pair specified for the request headers.</li>
<li>Enter the following lines in the textbox below the radio buttons, within the <span class="packt_screen">Body</span> tab:</li>
</ol>
<pre>{ 
    "name": "Wonderboy puzzle",  
    "description":"The Dragon's Trap puzzle", 
    "toy_category":"Puzzles &amp; Games", 
    "was_included_in_home": "false", 
    "release_date": "2017-10-03T01:01:00.776594Z" 
} </pre>
<p>The following screenshot shows the request body in Postman:</p>
<div class="CDPAlignCenter CDPAlign"><img src="images/c6eb6181-8157-4d1b-aab0-acba39bb9d62.png"/></div>
<p>We followed the necessary steps to create an HTTP POST request with a JSON body that specifies the necessary key-value pairs to create a new toy. Click <span class="packt_screen">Send</span> and Postman will display the following information:</p>
<ul>
<li><span class="packt_screen">Status</span>: <kbd>201 Created</kbd></li>
<li><span class="packt_screen">Time</span>: The time it took for the request to be processed</li>
<li><span class="packt_screen">Size</span>: The approximate response size (sum of body size plus headers size)</li>
<li><span class="packt_screen">Body</span>: The response body with the recently added toy formatted as JSON with syntax highlighting</li>
</ul>
<p>The following screenshot shows the JSON response body in Postman for the HTTP POST request:</p>
<div class="CDPAlignCenter CDPAlign"><img src="images/6405c361-5bce-4de4-a0cf-c2ae264a7139.png"/></div>
<div class="packt_tip">If we want to compose and send an HTTP PUT request with Postman, it is necessary to follow the previously explained steps to provide JSON data within the request body.</div>
<p>One of the nice features included in Postman is that we can easily review and run the HTTP requests we have made again by browsing the saved <span class="packt_screen">History</span> shown on the left-hand side of the Postman window. The <span class="packt_screen">History</span> panel displays a list with the HTTP verb followed by the URL for each HTTP request we have composed and sent. We just need to click on the desired HTTP request and click <span class="packt_screen">Send</span> to run it again. The following screenshot shows the many HTTP requests in the <span class="packt_screen">History</span> panel and the first HTTP GET request that was executed selected so it can be easily resent:</p>
<div class="CDPAlignCenter CDPAlign"><img src="images/8bcea9b6-c921-4579-a657-906a1762f270.png"/></div>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Test your knowledge</h1>
                </header>
            
            <article>
                
<p>Let's see whether you can answer the following questions correctly:</p>
<ol>
<li>The <kbd>urlpatterns</kbd> list declared in the <kbd>urls.py</kbd> file makes it possible to:
<ol>
<li>Route URLs to Django models</li>
<li>Route URLs to Django views</li>
<li>Route URLs to Python primitives</li>
</ol>
</li>
<li>When the Django server receives an HTTP request, Django creates an instance of which of the following classes?
<ol>
<li><kbd>django.restframework.HttpRequest</kbd></li>
<li><kbd>django.http.HttpRequest</kbd></li>
<li><kbd>django.http.Request</kbd></li>
</ol>
</li>
<li>A view function has to return an instance of which of the following classes?
<ol>
<li><kbd>django.http.HttpResponse</kbd></li>
<li><kbd>django.http.Response</kbd></li>
<li><kbd>django.restfremework.HttpResponse</kbd></li>
</ol>
</li>
<li>Whenever you have to return a specific status different from the default <kbd>200 OK</kbd> status, it is a good practice to use the module variables defined in which of the following modules?
<ol>
<li><kbd>rest_framework.HttpStatus</kbd></li>
<li><kbd>django.status</kbd></li>
<li><kbd>rest_framework.status</kbd></li>
</ol>
</li>
</ol>
<ol start="5">
<li>If you want to retrieve a Toy instance whose primary key value is equal to <kbd>10</kbd> and save it in the toy variable, which line of code would you write?
<ol>
<li>toy = Toy.get_by(pk=10)</li>
<li>toy = Toy.objects.all(pk=10)</li>
<li>toy = Toy.objects.get(pk=pk)</li>
</ol>
</li>
</ol>
<p>&#160;</p>
<p><span>The rights answers are included in the <a href="https://cdp.packtpub.com/django_restful_web_services__/wp-admin/post.php?post=44&amp;action=edit#post_454" target="_blank">Appendix</a>,&#160;<em>Solutions</em>.</span></p>


            </article>

            
        </section>
    </div>


  <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we executed our first version of a simple Django RESTful Web Service that interacts with an SQLite database. We wrote API views to process diverse HTTP requests on a collection of toys and on a specific toy. We worked with the following HTTP verbs: GET, POST, and PUT. We configured the URL patterns list to route URLs to views.</p>
<p>Then, we started the Django development server and we used command-line tools (curl and HTTPie) to compose and send diverse HTTP requests to our RESTful Web Service. We learned how HTTP requests were processed in Django and our code. Finally, we worked with Postman, a GUI tool, to compose and send other HTTP requests to our RESTful Web Service.</p>
<p>Now that we understand the basics of a RESTful Web Service with Django REST framework and a simple SQLite database, we will work with a seriously powerful PostgreSQL database, use class-based views instead of function views, and we will take advantage of advanced features included in Django REST framework to work with different content types, without writing a huge amount of code. We will cover these topics in the next chapter.</p>


            </article>

            
        </section>
    </div>
</body>
</html>