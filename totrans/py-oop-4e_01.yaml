- en: '1'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Object-Oriented Design
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In software development, design is often considered as the step that's done
    *before* programming. This isn't true; in reality, analysis, programming, and
    design tend to overlap, combine, and interweave. Throughout this book, we'll be
    covering a mixture of design and programming issues without trying to parse them
    into separate buckets. One of the advantages of a language like Python is the
    ability to express the design clearly.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will talk a little about how we can move from a good idea
    toward writing software. We''ll create some design artifacts – like diagrams –
    that can help clarify our thinking before we start writing code. We''ll cover
    the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What object-oriented means
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The difference between object-oriented design and object-oriented programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The basic principles of object-oriented design
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic **Unified Modeling Language** (**UML**) and when it isn't evil
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will also introduce this book''s object-oriented design case study, using
    the "4+1" architectural view model. We''ll touch on a number of topics here:'
  prefs: []
  type: TYPE_NORMAL
- en: An overview of a classic machine learning application, the famous Iris classification
    problem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The general processing context for this classifier
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sketching out two views of the class hierarchy that look like they'll be adequate
    to solve the problem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing object-oriented
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Everyone knows what an object is: a tangible thing that we can sense, feel,
    and manipulate. The earliest objects we interact with are typically baby toys.
    Wooden blocks, plastic shapes, and over-sized puzzle pieces are common first objects.
    Babies learn quickly that certain objects do certain things: bells ring, buttons
    are pressed, and levers are pulled.'
  prefs: []
  type: TYPE_NORMAL
- en: The definition of an object in software development is not terribly different.
    Software objects may not be tangible things that you can pick up, sense, or feel,
    but they are models of something that can do certain things and have certain things
    done to them. Formally, an object is a collection of **data** and associated **behaviors**.
  prefs: []
  type: TYPE_NORMAL
- en: Considering what an object is, what does it mean to be object-oriented? In the
    dictionary, *oriented* means *directed toward*. Object-oriented programming means
    writing code directed toward modeling objects. This is one of many techniques
    used for describing the actions of complex systems. It is defined by describing
    a collection of interacting objects via their data and behavior.
  prefs: []
  type: TYPE_NORMAL
- en: If you've read any hype, you've probably come across the terms *object-oriented
    analysis*, *object-oriented design*, *object-oriented analysis and design*, and *object-oriented
    programming*. These are all related concepts under the general *object-oriented* umbrella.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, analysis, design, and programming are all stages of software development.
    Calling them object-oriented simply specifies what kind of software development
    is being pursued.
  prefs: []
  type: TYPE_NORMAL
- en: '**Object-oriented analysis** (**OOA**) is the process of looking at a problem,
    system, or task (that somebody wants to turn into a working software application)
    and identifying the objects and interactions between those objects. The analysis
    stage is all about *what* needs to be done.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of the analysis stage is a description of the system, often in the
    form of *requirements*. If we were to complete the analysis stage in one step,
    we would have turned a task, such as *As a botanist, I need a website to help
    users classify plants so I can help with correct identification*, into a set of
    required features. As an example, here are some requirements as to what a website
    visitor might need to do. Each item is an action bound to an object; we''ve written
    them with *italics* to highlight the actions, and **bold** to highlight the objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Browse* **Previous Uploads**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Upload new* **Known Examples**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Test* for **Quality**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Browse* **Products**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*See* **Recommendations**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In some ways, the term *analysis* is a misnomer. The baby we discussed earlier
    doesn't analyze the blocks and puzzle pieces. Instead, she explores her environment,
    manipulates shapes, and sees where they might fit. A better turn of phrase might
    be *object-oriented exploration*. In software development, the initial stages
    of analysis include interviewing customers, studying their processes, and eliminating
    possibilities.
  prefs: []
  type: TYPE_NORMAL
- en: '**Object-oriented design** (**OOD**) is the process of converting such requirements
    into an implementation specification. The designer must name the objects, define
    the behaviors, and formally specify which objects can activate specific behaviors
    on other objects. The design stage is all about transforming *what* should be
    done into *how* it should be done.'
  prefs: []
  type: TYPE_NORMAL
- en: The output of the design stage is an implementation specification. If we were
    to complete the design stage in a single step, we would have turned the requirements
    defined during object-oriented analysis into a set of classes and interfaces that
    could be implemented in (ideally) any object-oriented programming language.
  prefs: []
  type: TYPE_NORMAL
- en: '**Object-oriented programming** (**OOP**) is the process of converting a design
    into a working program that does what the product owner originally requested.'
  prefs: []
  type: TYPE_NORMAL
- en: Yeah, right! It would be lovely if the world met this ideal and we could follow
    these stages one by one, in perfect order, like all the old textbooks told us
    to. As usual, the real world is much murkier. No matter how hard we try to separate
    these stages, we'll always find things that need further analysis while we're
    designing. When we're programming, we find features that need clarification in
    the design.
  prefs: []
  type: TYPE_NORMAL
- en: Most 21st century development recognizes that this cascade (or waterfall) of
    stages doesn't work out well. What seems to be better is an *iterative* development
    model. In iterative development, a small part of the task is modeled, designed,
    and programmed, and then the product is reviewed and expanded to improve each
    feature and include new features in a series of short development cycles.
  prefs: []
  type: TYPE_NORMAL
- en: The rest of this book is about object-oriented programming, but in this chapter,
    we will cover the basic object-oriented principles in the context of design. This
    allows us to understand concepts without having to argue with software syntax
    or Python tracebacks.
  prefs: []
  type: TYPE_NORMAL
- en: Objects and classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An **object** is a collection of data with associated behaviors. How do we differentiate
    between types of objects? Apples and oranges are both objects, but it is a common
    adage that they cannot be compared. Apples and oranges aren't modeled very often
    in computer programming, but let's pretend we're doing an inventory application
    for a fruit farm. To facilitate this example, we can assume that apples go in
    barrels and oranges go in baskets.
  prefs: []
  type: TYPE_NORMAL
- en: 'The problem domain we''ve uncovered so far has four kinds of objects: apples,
    oranges, baskets, and barrels. In object-oriented modeling, the term used for
    a *kind of object* is **class**. So, in technical terms, we now have four classes
    of objects.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s important to understand the difference between an object and a class.
    Classes describe related objects. They are like blueprints for creating an object.
    You might have three oranges sitting on the table in front of you. Each orange
    is a distinct object, but all three have the attributes and behaviors associated
    with one class: the general class of oranges.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The relationship between the four classes of objects in our inventory system
    can be described using a **Unified Modeling Language** (invariably referred to
    as **UML**, because three-letter acronyms never go out of style) class diagram.
    Here is our first *class diagram*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram  Description automatically generated](img/B17070_01_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.1: Class diagram'
  prefs: []
  type: TYPE_NORMAL
- en: This diagram shows that instances of the **Orange** class (usually called "oranges")
    are somehow associated with a **Basket** and that instances of the **Apple** class
    ("apples") are also somehow associated with a **Barrel**. *Association* is the
    most basic way for instances of two classes to be related.
  prefs: []
  type: TYPE_NORMAL
- en: The syntax of a UML diagram is generally pretty obvious; you don't have to read
    a tutorial to (mostly) understand what is going on when you see one. UML is also
    fairly easy to draw, and quite intuitive. After all, many people, when describing
    classes and their relationships, will naturally draw boxes with lines between
    them. Having a standard based on these intuitive diagrams makes it easy for programmers to
    communicate with designers, managers, and each other.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the UML diagram generally depicts the class definitions, but we're
    describing attributes of the objects. The diagram shows the class of Apple and
    the class of Barrel, telling us that a given apple is in a specific barrel. While
    we can use UML to depict individual objects, that's rarely necessary. Showing
    these classes tells us enough about the objects that are members of each class.
  prefs: []
  type: TYPE_NORMAL
- en: Some programmers disparage UML as a waste of time. Citing iterative development,
    they will argue that formal specifications done up in fancy UML diagrams are going
    to be redundant before they're implemented, and that maintaining these formal
    diagrams will only waste time and not benefit anyone.
  prefs: []
  type: TYPE_NORMAL
- en: Every programming team consisting of more than one person will occasionally
    have to sit down and hash out the details of the components being built. UML is
    extremely useful for ensuring quick, easy, and consistent communication. Even
    those organizations that scoff at formal class diagrams tend to use some informal
    version of UML in their design meetings or team discussions.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, the most important person you will ever have to communicate with
    is your future self. We all think we can remember the design decisions we've made,
    but there will always be *Why did I do that?* moments hiding in our future. If
    we keep the scraps of papers we did our initial diagramming on when we started
    a design, we'll eventually find them to be a useful reference.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter, however, is not meant to be a tutorial on UML. There are many
    of those available on the internet, as well as numerous books on the topic. UML
    covers far more than class and object diagrams; it also has a syntax for use cases,
    deployment, state changes, and activities. We'll be dealing with some common class
    diagram syntax in this discussion of object-oriented design. You can pick up the
    structure by example, and then you'll subconsciously choose the UML-inspired syntax
    in your own team or personal design notes.
  prefs: []
  type: TYPE_NORMAL
- en: Our initial diagram, while correct, does not remind us that apples go in barrels
    or how many barrels a single apple can go in. It only tells us that apples are
    somehow associated with barrels. The association between classes is often obvious
    and needs no further explanation, but we have the option to add further clarification
    as needed.
  prefs: []
  type: TYPE_NORMAL
- en: The beauty of UML is that most things are optional. We only need to specify
    as much information in a diagram as makes sense for the current situation. In
    a quick whiteboard session, we might just draw simple lines between boxes. In
    a formal document, we might go into more detail.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of apples and barrels, we can be fairly confident that the association
    is **many apples go in one barrel**, but just to make sure nobody confuses it
    with **one apple spoils one barrel**, we can enhance the diagram, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram  Description automatically generated with medium confidence](img/B17070_01_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.2: Class diagram with more detail'
  prefs: []
  type: TYPE_NORMAL
- en: This diagram tells us that oranges **go in** baskets, with a little arrow showing
    what goes in what. It also tells us the number of that object that can be used
    in the association on both sides of the relationship. One **Basket** can hold
    many (represented by a *****) **Orange** objects. Any one **Orange** can go in
    exactly one **Basket**. This number is referred to as the *multiplicity* of the
    object. You may also hear it described as the *cardinality*; it can help to think
    of cardinality as a specific number or range, and what we're using here, multiplicity,
    as a generalized "more-than-one instance".
  prefs: []
  type: TYPE_NORMAL
- en: We may sometimes forget which end of the relationship line is supposed to have
    which multiplicity number. The multiplicity nearest to a class is the number of
    objects of that class that can be associated with any one object at the other
    end of the association. For the apple goes in barrel association, reading from
    left to right, many instances of the **Apple** class (that is, many **Apple** objects)
    can go in any one **Barrel**. Reading from right to left, exactly one **Barrel** can
    be associated with any one **Apple**.
  prefs: []
  type: TYPE_NORMAL
- en: We've seen the basics of classes, and how they specify relationships among objects.
    Now, we need to talk about the attributes that define an object's state, and the
    behaviors of an object that may involve state change or interaction with other
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: Specifying attributes and behaviors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We now have a grasp of some basic object-oriented terminology. Objects are instances
    of classes that can be associated with each other. A class instance is a specific
    object with its own set of data and behaviors; a specific orange on the table
    in front of us is said to be an instance of the general class of oranges.
  prefs: []
  type: TYPE_NORMAL
- en: The orange has a state, for example, ripe or raw; we implement the state of
    an object via the values of specific attributes. An orange also has behaviors.
    By themselves, oranges are generally passive. State changes are imposed on them.
    Let's dive into the meaning of those two words, *state* and *behaviors*.
  prefs: []
  type: TYPE_NORMAL
- en: Data describes object state
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's start with data. Data represents the individual characteristics of a certain
    object; its current state. A class can define specific sets of characteristics
    that are part of all objects that are members of that class. Any specific object
    can have different data values for the given characteristics. For example, the
    three oranges on our table (if we haven't eaten any) could each weigh a different
    amount. The orange class could have a weight attribute to represent that datum.
    All instances of the orange class have a weight attribute, but each orange has
    a different value for this attribute. Attributes don't have to be unique, though;
    any two oranges may weigh the same amount.
  prefs: []
  type: TYPE_NORMAL
- en: Attributes are frequently referred to as **members** or **properties**. Some
    authors suggest that the terms have different meanings, usually that attributes
    are settable, while properties are read-only. A Python property can be defined
    as read-only, but the value will be based on attribute values that are – ultimately
    – writable, making the concept of *read-only* rather pointless; throughout this
    book, we'll see the two terms used interchangeably. In addition, as we'll discuss
    in *Chapter 5*, *When to Use Object-Oriented Programming*, the `property` keyword
    has a special meaning in Python for a particular kind of attribute.
  prefs: []
  type: TYPE_NORMAL
- en: In Python, we can also call an attribute an **instance variable**. This can
    help clarify the way attributes work. They are variables with unique values for
    each instance of a class. Python has other kinds of attributes, but we'll focus
    on the most common kind to get started.
  prefs: []
  type: TYPE_NORMAL
- en: In our fruit inventory application, the fruit farmer may want to know what orchard
    the orange came from, when it was picked, and how much it weighs. They might also
    want to keep track of where each **Basket** is stored. Apples might have a color
    attribute, and barrels might come in different sizes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of these properties may also belong to multiple classes (we may want to
    know when apples are picked, too), but for this first example, let''s just add
    a few different attributes to our class diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram  Description automatically generated](img/B17070_01_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.3: Class diagram with attributes'
  prefs: []
  type: TYPE_NORMAL
- en: Depending on how detailed our design needs to be, we can also specify the type
    for each attribute's value. In UML, attribute types are often generic names common
    to many programming languages, such as integer, floating-point number, string,
    byte, or Boolean. However, they can also represent generic collections such as
    lists, trees, or graphs, or most notably, other, non-generic, application-specific
    classes. This is one area where the design stage can overlap with the programming
    stage. The various primitives and built-in collections available in one programming
    language may be different from what is available in another.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a version with (mostly) Python-specific type hints:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram  Description automatically generated](img/B17070_01_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.4: Class diagram with attributes and their types'
  prefs: []
  type: TYPE_NORMAL
- en: Usually, we don't need to be overly concerned with data types at the design
    stage, as implementation-specific details are chosen during the programming stage.
    Generic names are normally sufficient for design; that's why we included `date`
    as a placeholder for a Python type like `datetime.datetime`. If our design calls
    for a list container type, Java programmers can choose to use a `LinkedList` or
    an `ArrayList` when implementing it, while Python programmers (that's us!) might
    specify `List[Apple]` as a type hint, and use the `list` type for the implementation.
  prefs: []
  type: TYPE_NORMAL
- en: In our fruit-farming example so far, our attributes are all basic primitives.
    However, there are some implicit attributes that we can make explicit – the associations.
    For a given orange, we have an attribute referring to the basket that holds that
    orange, the `basket` attribute, with a type hint of `Basket`.
  prefs: []
  type: TYPE_NORMAL
- en: Behaviors are actions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we know how data defines the object's state, the last undefined term
    we need to look at is *behaviors*. Behaviors are actions that can occur on an
    object. The behaviors that can be performed on a specific class of object are
    expressed as the **methods** of the class. At the programming level, methods are
    like functions in structured programming, but they have access to the attributes
    – in particular, the instance variables with the data associated with this object.
    Like functions, methods can also accept **parameters** and return **values**.
  prefs: []
  type: TYPE_NORMAL
- en: A method's parameters are provided to it as a collection of objects that need
    to be **passed** into that method. The actual object instances that are passed
    into a method during a specific invocation are usually referred to as **arguments**.
    These objects are bound to **parameter** variables in the method body. They are
    used by the method to perform whatever behavior or task it is meant to do. Returned
    values are the results of that task. Internal state changes are another possible
    effect of evaluating a method.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve stretched our *comparing apples and oranges* example into a basic (if
    far-fetched) inventory application. Let''s stretch it a little further and see
    whether it breaks. One action that can be associated with oranges is the **pick** action.
    If you think about implementation, **pick** would need to do two things:'
  prefs: []
  type: TYPE_NORMAL
- en: Place the orange in a basket by updating the **Basket** attribute of the orange.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add the orange to the **Orange** list on the given **Basket**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, **pick** needs to know what basket it is dealing with. We do this by giving
    the **pick** method a **Basket** parameter. Since our fruit farmer also sells
    juice, we can add a **squeeze** method to the **Orange** class. When called, the **squeeze** method
    might return the amount of juice retrieved, while also removing the **Orange** from
    the **Basket** it was in.
  prefs: []
  type: TYPE_NORMAL
- en: 'The class **Basket** can have a **sell** action. When a basket is sold, our
    inventory system might update some data on as-yet unspecified objects for accounting
    and profit calculations. Alternatively, our basket of oranges might go bad before
    we can sell them, so we add a **discard** method. Let''s add these methods to
    our diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram  Description automatically generated with medium confidence](img/B17070_01_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.5: Class diagram with attributes and methods'
  prefs: []
  type: TYPE_NORMAL
- en: Adding attributes and methods to individual objects allows us to create a **system** of
    interacting objects. Each object in the system is a member of a certain class.
    These classes specify what types of data the object can hold and what methods
    can be invoked on it. The data in each object can be in a different state from
    other instances of the same class; each object may react to method calls differently
    because of the differences in state.
  prefs: []
  type: TYPE_NORMAL
- en: Object-oriented analysis and design is all about figuring out what those objects
    are and how they should interact. Each class has responsibilities and collaborations.
    The next section describes principles that can be used to make those interactions
    as simple and intuitive as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Note that selling a basket is not unconditionally a feature of the **Basket**
    class. It may be that some other class (not shown) cares about the various Baskets
    and where they are. We often have boundaries around our design. We will also have
    questions about responsibilities allocated to various classes. The responsibility
    allocation problem doesn't always have a tidy technical solution, forcing us to
    draw (and redraw) our UML diagrams more than once to examine alternative designs.
  prefs: []
  type: TYPE_NORMAL
- en: Hiding details and creating the public interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The key purpose of modeling an object in object-oriented design is to determine
    what the public **interface** of that object will be. The interface is the collection
    of attributes and methods that other objects can access to interact with that
    object. Other objects do not need, and in some languages are not allowed, to access
    the internal workings of the object.
  prefs: []
  type: TYPE_NORMAL
- en: A common real-world example is the television. Our interface to the television
    is the remote control. Each button on the remote control represents a method that
    can be called on the television object. When we, as the calling object, access
    these methods, we do not know or care if the television is getting its signal
    from a cable connection, a satellite dish, or an internet-enabled device. We don't
    care what electronic signals are being sent to adjust the volume, or whether the
    sound is destined for speakers or headphones. If we open the television to access
    its internal workings, for example, to split the output signal to both external
    speakers and a set of headphones, we may void the warranty.
  prefs: []
  type: TYPE_NORMAL
- en: This process of hiding the implementation of an object is suitably called **information
    hiding**. It is also sometimes referred to as **encapsulation**, but encapsulation
    is actually a more encompassing term. Encapsulated data is not necessarily hidden.
    Encapsulation is, literally, creating a capsule (or wrapper) on the attributes.
    The TV's external case encapsulates the state and behavior of the television.
    We have access to the external screen, the speakers, and the remote. We don't
    have direct access to the wiring of the amplifiers or receivers within the TV's
    case.
  prefs: []
  type: TYPE_NORMAL
- en: When we buy a component entertainment system, we change the level of encapsulation,
    exposing more of the interfaces between components. If we're an Internet of Things
    maker, we may decompose this even further, opening cases and breaking the information
    hiding attempted by the manufacturer.
  prefs: []
  type: TYPE_NORMAL
- en: The distinction between encapsulation and information hiding is largely irrelevant,
    especially at the design level. Many practical references use these terms interchangeably.
    As Python programmers, we don't actually have or need information hiding via completely
    private, inaccessible variables (we'll discuss the reasons for this in *Chapter
    2*, *Objects in Python*), so the more encompassing definition for encapsulation
    is suitable.
  prefs: []
  type: TYPE_NORMAL
- en: The public interface, however, is very important. It needs to be carefully designed
    as it can be difficult to change when other classes depend on it. Changing an
    interface can break any client objects that depend on it. We can change the internals
    all we like, for example, to make it more efficient, or to access data over the
    network as well as locally, and the client objects will still be able to talk
    to it, unmodified, using the public interface. On the other hand, if we alter
    the interface by changing publicly accessed attribute names or the order or types
    of arguments that a method can accept, all client classes will also have to be
    modified. When designing public interfaces, keep it simple. Always design the
    interface of an object based on how easy it is to use, not how hard it is to code
    (this advice applies to user interfaces as well). For this reason, you'll sometimes
    see Python variables with a leading _ in their name as a warning that these aren't
    part of the public interface.
  prefs: []
  type: TYPE_NORMAL
- en: Remember, program objects may represent real objects, but that does not make
    them real objects. They are models. One of the greatest gifts of modeling is the
    ability to ignore irrelevant details. The model car one of the authors built as
    a child looked like a real 1956 Thunderbird on the outside, but it obviously didn't
    run. When they were too young to drive, these details were overly complex and
    irrelevant. The model is an **abstraction** of a real concept.
  prefs: []
  type: TYPE_NORMAL
- en: '**Abstraction** is another object-oriented term related to encapsulation and
    information hiding. Abstraction means dealing with the level of detail that is
    most appropriate to a given task. It is the process of extracting a public interface
    from the inner details. A car''s driver needs to interact with the steering, accelerator,
    and brakes. The workings of the motor, drive train, and brake subsystem don''t
    matter to the driver. A mechanic, on the other hand, works at a different level
    of abstraction, tuning the engine and bleeding the brakes. Here''s an example
    of two abstraction levels for a car:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram  Description automatically generated](img/B17070_01_06.png)Figure
    1.6: Abstraction levels for a car'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we have several new terms that refer to similar concepts. Let''s summarize
    all this jargon in a couple of sentences: abstraction is the process of encapsulating
    information with a separate public interface. Any private elements can be subject
    to information hiding. In UML diagrams, we might use a leading – instead of a
    leading + to suggest it''s not part of a public interface.'
  prefs: []
  type: TYPE_NORMAL
- en: The important lesson to take away from all these definitions is to make our
    models understandable to other objects that have to interact with them. This means
    paying careful attention to small details.
  prefs: []
  type: TYPE_NORMAL
- en: Ensure methods and properties have sensible names. When analyzing a system,
    objects typically represent nouns in the original problem, while methods are normally
    verbs. Attributes may show up as adjectives or more nouns. Name your classes,
    attributes, and methods accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: When designing the interface, imagine you are the object; you want clear definitions
    of your responsibility and you have a very strong preference for privacy to meet
    those responsibilities. Don't let other objects have access to data about you
    unless you feel it is in your best interest for them to have it. Don't give them
    an interface to force you to perform a specific task unless you are certain it's
    your responsibility to do that.
  prefs: []
  type: TYPE_NORMAL
- en: Composition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have learned to design systems as a group of interacting objects,
    where each interaction involves viewing objects at an appropriate level of abstraction.
    But we don't yet know how to create these levels of abstraction. There are a variety
    of ways to do this; we'll discuss some advanced design patterns in *Chapters 10*,
    *11*, and *12*. But even most design patterns rely on two basic object-oriented
    principles known as **composition** and **inheritance**. Composition is simpler,
    so let's start with that.
  prefs: []
  type: TYPE_NORMAL
- en: Composition is the act of collecting several objects together to create a new
    one. Composition is usually a good choice when one object is part of another object.
    We've already seen a first hint of composition when talking about cars. A fossil-fueled
    car is composed of an engine, transmission, starter, headlights, and windshield,
    among numerous other parts. The engine, in turn, is composed of pistons, a crank
    shaft, and valves. In this example, composition is a good way to provide levels
    of abstraction. The **Car** object can provide the interface required by a driver,
    while also giving access to its component parts, which offers the deeper level
    of abstraction suitable for a mechanic. Those component parts can, of course,
    be further decomposed into details if the mechanic needs more information to diagnose
    a problem or tune the engine.
  prefs: []
  type: TYPE_NORMAL
- en: A car is a common introductory example of composition, but it's not overly useful
    when it comes to designing computer systems. Physical objects are easy to break
    into component objects. People have been doing this at least since the ancient
    Greeks originally postulated that atoms were the smallest units of matter (they,
    of course, didn't have access to particle accelerators). Because computer systems
    involve a lot of peculiar concepts, identifying the component objects does not
    happen as naturally as with real-world valves and pistons.
  prefs: []
  type: TYPE_NORMAL
- en: The objects in an object-oriented system occasionally represent physical objects
    such as people, books, or telephones. More often, however, they represent concepts.
    People have names, books have titles, and telephones are used to make calls. Calls,
    titles, accounts, names, appointments, and payments are not usually considered
    objects in the physical world, but they are all frequently-modeled components
    in computer systems.
  prefs: []
  type: TYPE_NORMAL
- en: Let's try modeling a more computer-oriented example to see composition in action.
    We'll be looking at the design of a computerized chess game. This was a very popular
    pastime in the 80s and 90s. People were predicting that computers would one day
    be able to defeat a human chess master. When this happened in 1997 (IBM's Deep
    Blue defeated world chess champion, Gary Kasparov), interest in the problem of
    chess waned. Nowadays, the descendants of Deep Blue always win.
  prefs: []
  type: TYPE_NORMAL
- en: A *game* of chess is **played** between two *players*, using a chess set featuring
    a *board* containing 64 *positions* in an 8×8 grid. The board can have two sets
    of 16 *pieces* that can be **moved**, in alternating *turns* by the two players
    in different ways. Each piece can **take** other pieces. The board will be required
    to **draw** itself on the computer *screen* after each turn.
  prefs: []
  type: TYPE_NORMAL
- en: I've identified some of the possible objects in the description using *italics*,
    and a few key methods using **bold**. This is a common first step in turning an
    object-oriented analysis into a design. At this point, to emphasize composition,
    we'll focus on the board, without worrying too much about the players or the different
    types of pieces.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start at the highest level of abstraction possible. We have two players
    interacting with a **Chess Set** by taking turns making moves:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram  Description automatically generated](img/B17070_01_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.7: Object/instance diagram for a chess game'
  prefs: []
  type: TYPE_NORMAL
- en: 'This doesn''t quite look like our earlier class diagrams, which is a good thing
    since it isn''t one! This is an **object diagram**, also called an **instance
    diagram**. It describes the system at a specific state in time, and is describing
    specific instances of objects, not the interaction between classes. Remember,
    both players are members of the same class, so the class diagram looks a little
    different:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17070_01_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.8: Class diagram for a chess game'
  prefs: []
  type: TYPE_NORMAL
- en: This diagram shows that exactly two players can interact with one chess set.
    This also indicates that any one player can be playing with only one **Chess Set** at
    a time.
  prefs: []
  type: TYPE_NORMAL
- en: However, we're discussing composition, not UML, so let's think about what the **Chess
    Set** is composed of. We don't care what the player is composed of at this time.
    We can assume that the player has a heart and brain, among other organs, but these
    are irrelevant to our model. Indeed, there is nothing stopping said player from
    being Deep Blue itself, which has neither a heart nor a brain.
  prefs: []
  type: TYPE_NORMAL
- en: The chess set, then, is composed of a board and 32 pieces. The board further
    comprises 64 positions. You could argue that these pieces are not part of the
    chess set, because you could replace the pieces of a chess set with a different
    set of pieces. While this is unlikely or impossible in a computerized version
    of chess, it introduces us to **aggregation**.
  prefs: []
  type: TYPE_NORMAL
- en: Aggregation is almost exactly like composition. The difference is that aggregate
    objects can exist independently. It would be impossible for a position to be associated
    with a different chess board, so we say the board is composed of positions. But
    the pieces, which might exist independently of the chess set, are said to be in
    an aggregate relationship with that set.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way to differentiate between aggregation and composition is to think
    about the lifespan of the object:'
  prefs: []
  type: TYPE_NORMAL
- en: If the composite (outside) object controls when the related (inside) objects
    are created and destroyed, composition is most suitable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the related object is created independently of the composite object, or can
    outlast that object, an aggregate relationship makes more sense.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also, keep in mind that composition is aggregation; aggregation is simply a
    more general form of composition. Any composite relationship is also an aggregate
    relationship, but not vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s describe our current **Chess Set** composition and add some attributes
    to the objects to hold the composite relationships:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram  Description automatically generated](img/B17070_01_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.9: Class diagram for a chess game'
  prefs: []
  type: TYPE_NORMAL
- en: The composition relationship is represented in UML as a solid diamond. The hollow
    diamond represents the aggregate relationship. You'll notice that the board and
    pieces are stored as part of the **Chess Set** in exactly the same way a reference
    to them is stored as an attribute on the chess set. This shows that, once again,
    in practice, the distinction between aggregation and composition is often irrelevant
    once you get past the design stage. When implemented, they behave in much the
    same way.
  prefs: []
  type: TYPE_NORMAL
- en: This distinction can help you differentiate between the two when your team is
    discussing how the different objects interact. You'll often need to distinguish
    between them when talking about how long related objects exist. In many cases,
    deleting a composite object (like the board) deletes all the locations. The aggregated
    objects, however, are not deleted automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We discussed three types of relationships between objects: association, composition,
    and aggregation. However, we have not fully specified our chess set, and these
    tools don''t seem to give us all the power we need. We discussed the possibility
    that a player might be a human or it might be a piece of software featuring artificial
    intelligence. It doesn''t seem right to say that a player is *associated* with
    a human, or that the artificial intelligence implementation is *part of* the player
    object. What we really need is the ability to say that *Deep Blue is a player*, or
    that *Gary Kasparov is a player*.'
  prefs: []
  type: TYPE_NORMAL
- en: The *is a* relationship is formed by **inheritance**. Inheritance is the most
    famous, well-known, and overused relationship in object-oriented programming.
    Inheritance is sort of like a family tree. Dusty Phillips is one of this book's
    authors.
  prefs: []
  type: TYPE_NORMAL
- en: His grandfather's last name was Phillips, and his father inherited that name.
    Dusty inherited it from him. In object-oriented programming, instead of inheriting
    features and behaviors from a person, one class can inherit attributes and methods
    from another class.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, there are 32 chess pieces in our chess set, but there are only
    six different types of pieces (pawns, rooks, bishops, knights, king, and queen),
    each of which behaves differently when it is moved. All of these classes of piece
    have properties, such as color and the chess set they are part of, but they also
    have unique shapes when drawn on the chess board, and make different moves. Let''s
    see how the six types of pieces can inherit from a **Piece** class:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram  Description automatically generated](img/B17070_01_10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.10: How chess pieces inherit from the Piece class'
  prefs: []
  type: TYPE_NORMAL
- en: The hollow arrows indicate that the individual classes of pieces inherit from
    the **Piece** class. All the child classes automatically have a **chess_set**
    and **color** attribute inherited from the base class. Each piece provides a different
    shape property (to be drawn on the screen when rendering the board), and a different
    **move** method to move the piece to a new position on the board at each turn.
  prefs: []
  type: TYPE_NORMAL
- en: We actually know that all subclasses of the **Piece** class need to have a **move**
    method; otherwise, when the board tries to move the piece, it will get confused.
    It is possible that we would want to create a new version of the game of chess
    that has one additional piece (the wizard). Our current design will allow us to
    design this piece without giving it a **move** method. The board would then choke
    when it asked the piece to move itself.
  prefs: []
  type: TYPE_NORMAL
- en: We can fix this by creating a dummy move method on the **Piece** class. The
    subclasses can then **override** this method with a more specific implementation.
    The default implementation might, for example, pop up an error message that says **That
    piece cannot be moved**.
  prefs: []
  type: TYPE_NORMAL
- en: Overriding methods in subclasses allows very powerful object-oriented systems
    to be developed. For example, if we wanted to implement a **Player** class with
    artificial intelligence, we might provide a **calculate_move** method that takes
    a **Board** object and decides which piece to move where. A very basic class might
    randomly choose a piece and direction and move it accordingly. We could then override
    this method in a subclass with the Deep Blue implementation. The first class would
    be suitable for play against a raw beginner; the latter would challenge a grand
    master. The important thing is that other methods in the class, such as the ones
    that inform the board as to which move was chosen, need not be changed; this implementation
    can be shared between the two classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of chess pieces, it doesn''t really make sense to provide a default
    implementation of the move method. All we need to do is specify that the move
    method is required in any subclasses. This can be done by making **Piece** an **abstract
    class** with the **move** method declared as **abstract**. Abstract methods basically
    say this:'
  prefs: []
  type: TYPE_NORMAL
- en: '"We demand this method exist in any non-abstract subclass, but we are declining
    to specify an implementation in this class."'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Indeed, it is possible to make an abstraction that does not implement any methods
    at all. Such a class would simply tell us what the class *should* do, but provides
    absolutely no advice on how to do it. In some languages, these purely abstract
    classes are called **interfaces**. It's possible to define a class with only abstract
    method placeholders in Python, but it's very rare.
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance provides abstraction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's explore the longest word in object-oriented argot. **Polymorphism** is
    the ability to treat a class differently, depending on which subclass is implemented.
    We've already seen it in action with the pieces system we've described. If we
    took the design a bit further, we'd probably see that the **Board** object can
    accept a move from the player and call the **move** function on the piece. The
    board need not ever know what type of piece it is dealing with. All it has to
    do is call the **move** method, and the proper subclass will take care of moving
    it as a **Knight** or a **Pawn**.
  prefs: []
  type: TYPE_NORMAL
- en: Polymorphism is pretty cool, but it is a word that is rarely used in Python
    programming. Python goes an extra step past allowing a subclass of an object to
    be treated like a parent class. A board implemented in Python could take any object
    that has a **move** method, whether it is a bishop piece, a car, or a duck. When **move** is
    called, the **Bishop** will move diagonally on the board, the car will drive someplace,
    and the duck will swim or fly, depending on its mood.
  prefs: []
  type: TYPE_NORMAL
- en: This sort of polymorphism in Python is typically referred to as **duck typing**: *if
    it walks like a duck or swims like a duck, we call it a duck*. We don't care if
    it really *is a* duck (*is a* being a cornerstone of inheritance), only that it
    swims or walks. Geese and swans might easily be able to provide the duck-like
    behavior we are looking for. This allows future designers to create new types
    of birds without actually specifying a formal inheritance hierarchy for all possible
    kinds of aquatic birds. The chess examples, above, use formal inheritance to cover
    all possible pieces in the chess set. Duck typing also allows a programmer to
    extend a design, creating completely different drop-in behaviors the original
    designers never planned for. For example, future designers might be able to make
    a walking, swimming penguin that works with the same interface without ever suggesting
    that penguins have a common superclass with ducks.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple inheritance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we think of inheritance in our own family tree, we can see that we inherit
    features from more than just one parent. When strangers tell a proud mother that
    her son has *his father's eyes*, she will typically respond along the lines of, *yes,
    but he got my nose*.
  prefs: []
  type: TYPE_NORMAL
- en: Object-oriented design can also feature such **multiple inheritance**, which
    allows a subclass to inherit functionality from multiple parent classes. In practice,
    multiple inheritance can be a tricky business, and some programming languages
    (most famously, Java) strictly prohibit it. However, multiple inheritance can
    have its uses. Most often, it can be used to create objects that have two distinct
    sets of behaviors. For example, an object designed to connect to a scanner to
    make an image and send a fax of the scanned image might be created by inheriting
    from two separate `scanner` and `faxer` objects.
  prefs: []
  type: TYPE_NORMAL
- en: As long as two classes have distinct interfaces, it is not normally harmful
    for a subclass to inherit from both of them. However, it gets messy if we inherit
    from two classes that provide overlapping interfaces. The scanner and faxer don't
    have any overlapping features, so combining features from both is easy. Our counterexample
    is a motorcycle class that has a `move` method, and a boat class also featuring
    a `move` method.
  prefs: []
  type: TYPE_NORMAL
- en: If we want to merge them into the ultimate amphibious vehicle, how does the
    resulting class know what to do when we call `move`? At the design level, this
    needs to be explained. (As a sailor who lived on a boat, one of the authors really
    wants to know how this is supposed to work.)
  prefs: []
  type: TYPE_NORMAL
- en: Python has a defined **method resolution order** (**MRO**) to help us understand
    which of the alternative methods will be used. While the MRO rules are simple,
    avoiding overlap is even simpler. Multiple inheritance as a "mixin" technique
    for combining unrelated aspects can be helpful. In many cases, though, a composite
    object may be easier to design.
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance is a powerful tool for extending behavior and reusing features.
    It is also one of the most marketable advancements of object-oriented design over
    earlier paradigms. Therefore, it is often the first tool that object-oriented
    programmers reach for. However, it is important to recognize that owning a hammer
    does not turn screws into nails. Inheritance is the perfect solution for obvious *is
    a* relationships. Beyond this, it can be abused. Programmers often use inheritance
    to share code between two kinds of objects that are only distantly related, with
    no *is a* relationship in sight. While this is not necessarily a bad design, it
    is a terrific opportunity to ask just why they decided to design it that way,
    and whether a different relationship or design pattern would have been more suitable.
  prefs: []
  type: TYPE_NORMAL
- en: Case study
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our case study will span many of the chapters of this book. We''ll be examining
    a single problem closely from a variety of perspectives. It''s very important
    to look at alternative designs and design patterns; more than once, we''ll point
    out that there''s no single right answer: there are a number of good answers.
    Our intent here is to provide a realistic example that involves realistic depth
    and complications and leads to difficult trade-off decisions. Our goal is to help
    the reader apply object-oriented programming and design concepts. This means choosing
    among the technical alternatives to create something useful.'
  prefs: []
  type: TYPE_NORMAL
- en: This first part of the case study is an overview of the problem and why we're
    tackling it. This background will cover a number of aspects of the problem to
    set up the design and construction of solutions in later chapters. Part of this
    overview will include some UML diagrams to capture elements of the problem to
    be solved. These will evolve in later chapters as we dive into the consequences
    of design choices and make changes to those design choices.
  prefs: []
  type: TYPE_NORMAL
- en: As with many realistic problems, the authors bring personal bias and assumptions.
    For information on the consequences of this, consider books like *Technically
    Wrong*, by Sara Wachter-Boettcher.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our users want to automate a job often called **classification**. This is the
    underpinning idea behind product recommendations: last time, a customer bought
    product X, so perhaps they''d be interested in a similar product, Y. We''ve classified
    their desires and can locate other items in that class of products. This problem
    can involve complex data organization issues.'
  prefs: []
  type: TYPE_NORMAL
- en: It helps to start with something smaller and more manageable. The users eventually
    want to tackle complex consumer products, but recognize that solving a difficult
    problem is not a good way to learn how to build this kind of application. It's
    better to start with something of a manageable level of complexity and then refine
    and expand it until it does everything they need. In this case study, therefore,
    we'll be building a classifier for iris species. This is a classic problem, and
    there's a great deal written about approaches to classifying iris flowers.
  prefs: []
  type: TYPE_NORMAL
- en: A training set of data is required, which the classifier uses as examples of
    correctly classified irises. We will discuss what the training data looks like
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: We'll create a collection of diagrams using the **Unified Modeling Language**
    (**UML**) to help depict and summarize the software we're going to build.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll examine the problem using a technique called **4+1 Views**. The views
    are:'
  prefs: []
  type: TYPE_NORMAL
- en: A **logical view** of the data entities, their static attributes, and their
    relationships. This is the heart of object-oriented design.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **process view** that describes how the data is processed. This can take a
    variety of forms, including state models, activity diagrams, and sequence diagrams.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **development view** of the code components to be built. This diagram shows
    relationships among software components. This is used to show how class definitions
    are gathered into modules and packages.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **physical view** of the application to be integrated and deployed. In cases
    where an application follows a common design pattern, a sophisticated diagram
    isn't necessary. In other cases, a diagram is essential to show how a collection
    of components are integrated and deployed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A **context view** that provides a unifying context for the other four views.
    The context view will often describe the actors that use (or interact) with the
    system to be built. This can involve human actors as well as automated interfaces:
    both are outside the system, and the system must respond to these external actors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's common to start with the context view so that we have a sense of what the
    other views describe. As our understanding of the users and the problem domain
    evolves, the context will evolve also.
  prefs: []
  type: TYPE_NORMAL
- en: It's very important to recognize that all of these 4+1 views evolve together.
    A change to one will generally be reflected in other views. It's a common mistake
    to think that one view is in some way foundational, and that the other views build
    on it in a cascade of design steps that always lead to software.
  prefs: []
  type: TYPE_NORMAL
- en: We'll start with a summary of the problem and some background before we start
    trying to analyze the application or design software.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction and problem overview
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we mentioned previously, we'll be starting with a simpler problem – classifying
    flowers. We want to implement one popular approach called *k*-**nearest neighbors**,
    or *k*-**NN** for short. We require a training set of data, which the classifier
    algorithm uses as examples of correctly classified irises. Each training sample
    has a number of attributes, reduced to numeric scores, and a final, correct, classification
    (i.e. iris species). In this iris example, each training sample is an iris, with
    its attributes, such as petal shape, size, and so on, encoded into a numeric vector
    that is an overall representation of the iris, along with a correct species label
    for that iris.
  prefs: []
  type: TYPE_NORMAL
- en: Given an unknown sample, an iris whose species we want to know, we can measure
    the distance between the unknown sample and any of the known samples in the vector
    space. For some small group of nearby neighbors, we can take a vote. The unknown
    sample can be classified into the sub-population selected by the majority of the
    nearby neighbors.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we only have two dimensions (or attributes), we can diagram the *k*-NN classification
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram, engineering drawing  Description automatically generated](img/B17070_01_11.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.11: k-nearest neighbors'
  prefs: []
  type: TYPE_NORMAL
- en: Our unknown sample is a diamond tagged with "??". It's surrounded by known samples
    of the square and circle species. When we locate the three nearest neighbors,
    shown inside the dashed circle, we can take a vote and decide that the unknown
    is most like the Circle species.
  prefs: []
  type: TYPE_NORMAL
- en: One underpinning concept is having tangible, numeric measurements for the various
    attributes. Converting words, addresses, and other non-ordinal data into an ordinal
    measurement can be challenging. The good news is that the data we're going to
    start with data that already has properly ordinal measurements with explicit units
    of measure.
  prefs: []
  type: TYPE_NORMAL
- en: Another supporting concept is the number of neighbors involved in the voting.
    This is the *k* factor in *k*-nearest neighbors. In our conceptual diagram, we've
    shown *k*=3 neighbors; two of the three nearest neighbors are circles, with the
    third being a square. If we change the *k*-value to 5, this will change the composition
    of the pool and tip the vote in favor of the squares. Which is right? This is
    checked by having test data with known right answers to confirm that the classification
    algorithm works acceptably well. In the preceding diagram, it's clear the diamond
    was cleverly chosen to be a midway between two clusters, intentionally creating
    a difficult classification problem.
  prefs: []
  type: TYPE_NORMAL
- en: A popular dataset for learning how this works is the Iris Classification data.
    See [https://archive.ics.uci.edu/ml/datasets/iris](https://archive.ics.uci.edu/ml/datasets/iris)
    for some background on this data. This is also available at [https://www.kaggle.com/uciml/iris](https://www.kaggle.com/uciml/iris)
    and many other places.
  prefs: []
  type: TYPE_NORMAL
- en: More experienced readers may notice some gaps and possible contradictions as
    we move through the object-oriented analysis and design work. This is intentional.
    An initial analysis of a problem of any scope will involve learning and rework.
    This case study will evolve as we learn more. If you've spotted a gap or contradiction,
    formulate your own design and see if it converges with the lessons learned in
    subsequent chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Having looked at some aspects of the problem, we can provide a more concrete
    context with actors and the use cases or scenarios that describe how an actor
    interacts with the system to be built. We'll start with the context view.
  prefs: []
  type: TYPE_NORMAL
- en: Context view
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The context for our application that classifies iris species involves these
    two classes of actors:'
  prefs: []
  type: TYPE_NORMAL
- en: A "Botanist" who provides the properly classified training data and a properly
    classified set of test data. The Botanist also runs the test cases to establish
    the proper parameters for the classification. In the simple case of *k*-NN, they
    can decide which *k* value should be used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A "User" who needs to do classification of unknown data. The user has made careful
    measurements and makes a request with the measurement data to get a classification
    from this classifier system. The name "User" seems vague, but we're not sure what's
    better. We'll leave it for now, and put off changing it until we foresee a problem.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This UML context diagram illustrates the two actors and the three scenarios
    we will explore:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram  Description automatically generated](img/B17070_01_12.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.12: UML context diagram'
  prefs: []
  type: TYPE_NORMAL
- en: The system as a whole is depicted as a rectangle. It encloses ovals to represent
    user stories. In the UML, specific shapes have meanings, and we reserve rectangles
    for objects. Ovals (and circles) are for user stories, which are interfaces to
    the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to do any useful processing, we need training data, properly classified.
    There are two parts to each set of data: a training set and a test set. We''ll
    call the whole assembly "training data" instead of the longer (but more precise)
    "training and test data."'
  prefs: []
  type: TYPE_NORMAL
- en: 'The tuning parameters are set by the botanist, who must examine the test results
    to be sure the classifier works. These are the two parameters that can be tuned:'
  prefs: []
  type: TYPE_NORMAL
- en: The distance computation to use
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The number of neighbors to consider for voting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll look at these parameters in detail in the *Processing view* section later
    in this chapter. We'll also revisit these ideas in subsequent case study chapters.
    The distance computation is an interesting problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can define a set of experiments as a grid of each alternative and methodically
    fill in the grid with the results of measuring the test set. The combination that
    provides the best fit will be the recommended parameter set from the botanist.
    In our case, there are two choices, and the grid is a two-dimensional table, like
    the one shown below. With more complex algorithms, the "grid" may be a multidimensional
    space:'
  prefs: []
  type: TYPE_NORMAL
- en: '|  |  | Various k factors |'
  prefs: []
  type: TYPE_TB
- en: '|  |  | k=3 | k=5 | k=7 |'
  prefs: []
  type: TYPE_TB
- en: '| Distance computationalgorithms | Euclidean | Test results… |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| Manhattan |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| Chebyshev |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| Sorensen |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| Other? |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: After the testing, a User can make requests. They provide unknown data to receive
    classification results from this trained classifier process. In the long run,
    this "User" won't be a person – they'll be a connection from some website's sales
    or catalog engine to our clever classifier-based recommendation engine.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can summarize each of these scenarios with a **use case** or **user story**
    statement:'
  prefs: []
  type: TYPE_NORMAL
- en: As a Botanist, I want to provide properly classified training and testing data
    to this system so users can correctly identify plants.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a Botanist, I want to examine the test results from the classifier to be
    sure that new samples are likely to be correctly classified.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a User, I want to be able to provide a few key measurements to the classifier
    and have the iris species correctly classified.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Given the nouns and verbs in the user stories, we can use that information to
    create a logical view of the data the application will process.
  prefs: []
  type: TYPE_NORMAL
- en: Logical view
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Looking at the context diagram, processing starts with training data and testing
    data. This is properly classified sample data used to test our classification
    algorithm. The following diagram shows one way to look at a class that contains
    various training and testing datasets:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram  Description automatically generated](img/B17070_01_13.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.13: Class diagram for training and testing'
  prefs: []
  type: TYPE_NORMAL
- en: 'This shows a `Training Data` class of objects with the attributes of each instance
    of this class. The `TrainingData` object gives our sample collection a name, and
    some dates where uploading and testing were completed. For now, it seems like
    each `TrainingData` object should have a single tuning parameter, `k`, used for
    the *k*-NN classifier algorithm. An instance also includes two lists of individual
    samples: a training list and a testing list.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Each class of objects is depicted in a rectangle with a number of individual
    sections:'
  prefs: []
  type: TYPE_NORMAL
- en: The top-most section provides a name for the class of objects. In two cases,
    we've used a type hint, `List[Sample]`; the generic class, `list`, is used in
    a way that ensures the contents of the list are only `Sample` objects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next section of a class rectangle shows the attributes of each object; these
    attributes are also called the instance variables of this class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Later, we'll add "methods" to the bottom section for instances of the class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Each object of the `Sample` class has a handful of attributes: four floating-point
    measurement values and a string value, which is the botanist-assigned classification
    for the sample. In this case, we used the attribute name `class` because that''s
    what it''s called in the source data.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The UML arrows show two specific kinds of relationships, highlighted by filled
    or empty diamonds. A filled diamond shows **composition**: a `TrainingData` object
    is composed – in part – of two collections. The open diamond shows **aggregation**:
    a `List[Sample]` object is an aggregate of `Sample` items. To recap what we learned
    earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A **composition** is an existential relationship: we can''t have `TrainingData`
    without the two `List[Sample]` objects. And, conversely, a `List[Sample]` object
    isn''t used in our application without being part of a `TrainingData` object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An **aggregation**, on the other hand, is a relationship where items can exist
    independently of each other. In this diagram, a number of `Sample` objects can
    be part of `List[Sample]` or can exist independently of the list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's not clear that the open diamond to show the aggregation of `Sample` objects
    into a `List` object is relevant. It may be an unhelpful design detail. When in
    doubt, it's better to omit these kinds of the details until they're clearly required
    to ensure there's an implementation that meets the user's expectations.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve shown a `List[Sample]` as a separate class of objects. This is Python''s
    generic `List`, qualified with a specific class of objects, `Sample`, that will
    be in the list. It''s common to avoid this level of detail and summarize the relationships
    in a diagram like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram  Description automatically generated](img/B17070_01_14.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.14: Condensed class diagram'
  prefs: []
  type: TYPE_NORMAL
- en: This slightly abbreviated form can help with doing analytical work, where the
    underlying data structures don't matter. It's less helpful for design work, as
    specific Python class information becomes more important.
  prefs: []
  type: TYPE_NORMAL
- en: Given an initial sketch, we'll compare this logical view with each of the three
    scenarios mentioned in the context diagram, shown in *Figure 1.12* in the previous
    section. We want to be sure all of the data and processing in the user stories
    can be allocated as responsibilities scattered among the classes, attributes,
    and methods in the diagram.
  prefs: []
  type: TYPE_NORMAL
- en: 'Walking through the user stories, we uncover these two problems:'
  prefs: []
  type: TYPE_NORMAL
- en: It's not clear how the testing and parameter tuning fit with this diagram. We
    know there's a *k* factor that's required, but there are no relevant test results
    to show alternative *k* factors and the consequence of those choices.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The user's request is not shown at all. Nor is the response to the user. No
    classes have these items as part of their responsibilities.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first point suggests we'll need to re-read the user stories and try again
    to create a better logical view. The second point is a question of boundaries.
    While the web request and response details are missing, it's more important to
    describe the essential problem domain – classification and *k*-NN – first. The
    web services for handling a user's requests is one (of many) solution technologies,
    and we should set that aside when getting started.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we'll turn our focus to the processing for the data. We're following what
    seems to be an effective order for creating a description of an application. The
    data has to be described first; it's the most enduring part, and the thing that
    is always preserved through each refinement of the processing. The processing
    can be secondary to the data, because this changes as the context changes and
    user experience and preferences change.
  prefs: []
  type: TYPE_NORMAL
- en: Process view
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are three separate user stories. This does not necessarily force us to
    create three process diagrams. For complex processing, there may be more process
    diagrams than user stories. In some cases, a user story may be too simple to require
    a carefully designed diagram.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our application, it seems as though there are at least three unique processes
    of interest, specifically these:'
  prefs: []
  type: TYPE_NORMAL
- en: Upload the initial set of `Samples` that comprise some `TrainingData`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run a test of the classifier with a given *k* value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make a classification request with a new `Sample` object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll sketch activity diagrams for these use cases. An activity diagram summarizes
    a number of state changes. The processing begins with a start node and proceeds
    until an end node is reached. In transaction-based applications, like web services,
    it's common to omit showing the overall web server engine. This saves us from
    describing common features of HTTP, including standard headers, cookies, and security
    concerns. Instead, we generally focus on the unique processing that's performed
    to create a response for each distinct kind of request.
  prefs: []
  type: TYPE_NORMAL
- en: The activities are shown in round-corner rectangles. Where specific classes
    of objects or software components are relevant, they can be linked to relevant
    activities.
  prefs: []
  type: TYPE_NORMAL
- en: What's more important is making sure that the logical view is updated as ideas
    arise while working on the processing view. It's difficult to get either view
    done completely in isolation. It's far more important to make incremental changes
    in each view as new solution ideas arise. In some cases, additional user input
    is required, and this too will lead to the evolution of these views.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can sketch a diagram to show how the system responds when the Botanist provides
    the initial data. Here''s the first example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram  Description automatically generated](img/B17070_01_15.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.15: Activity diagram'
  prefs: []
  type: TYPE_NORMAL
- en: 'The collection of `KnownSample` values will be partitioned into two subsets:
    a training subset and a testing subset. There''s no rule in our problem summary
    or user stories for making this distinction; the gap shows we''re missing details
    in the original user story. When details are missing from the user stories, then
    the logical view may be incomplete, also. For now, we can labor under an assumption
    that most of the data – say 75% - will be used for training, and the rest, 25%,
    will be used for testing.'
  prefs: []
  type: TYPE_NORMAL
- en: It often helps to create similar diagrams for each of the user stories. It also
    helps to be sure that the activities all have relevant classes to implement the
    steps and represent state changes caused by each step.
  prefs: []
  type: TYPE_NORMAL
- en: We've included a verb, `Partition`, in this diagram. This suggests a method
    will be required to implement the verb. This may lead to rethinking the class
    model to be sure the processing can be implemented.
  prefs: []
  type: TYPE_NORMAL
- en: We'll turn next to considering some of the components to be built. Since this
    is a preliminary analysis, our ideas will evolve as we do more detailed design
    and start creating class definitions.
  prefs: []
  type: TYPE_NORMAL
- en: Development view
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There's often a delicate balance between the final deployment and the components
    to be developed. In rare cases, there are few deployment constraints, and the
    designer can think freely about the components to be developed. A physical view
    will evolve from the development. In more common cases, there's a specific target
    architecture that must be used, and elements of the physical view are fixed.
  prefs: []
  type: TYPE_NORMAL
- en: There are several ways to deploy this classifier as part of a larger application.
    We might build a desktop application, a mobile application, or a website. Because
    of the ubiquity of internetworked computers, one common approach is to create
    a website and connect to it from desktops and mobile apps.
  prefs: []
  type: TYPE_NORMAL
- en: A web services architecture, for example, means requests can be made to a server;
    the responses could be HTML pages for presentation in a browser, or JSON documents
    that can be displayed by a mobile application. Some requests will provide whole
    new sets of training data. Other requests will be seek to classify unknown samples.
    We'll detail the architecture in the physical view below. We might want to use
    the Flask framework to build a web service. For more information on Flask, see
    *Mastering Flask Web Development*, [https://www.packtpub.com/product/mastering-flask-web-development-second-edition/9781788995405](https://www.packtpub.com/product/mastering-flask-web-development-second-edition/9781788995405),
    or *Learning Flask Framework*, [https://www.packtpub.com/product/learning-flask-framework/9781783983360](https://www.packtpub.com/product/learning-flask-framework/9781783983360).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows some of the components we need would need to build
    for a Flask-based application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram  Description automatically generated](img/B17070_01_16.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.16: Components to be built'
  prefs: []
  type: TYPE_NORMAL
- en: 'This diagram shows a Python package, `Classifier`, that contains a number of
    modules. The three top-level modules are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Data Model**: (Since this is still analysis time, the name here is not properly
    Pythonic; we''ll change it later as we move into implementation.) It''s often
    helpful to separate the classes that define the problem domain into modules. This
    makes it possible for us to test them in isolation from any particular application
    that uses those classes. We''ll focus on this part, since it is foundational.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**View Functions**: (Also an analysis name, not a Pythonic implementation name.)
    This module will create an instance of the `Flask` class, our application. It
    will define the functions that handle requests by creating responses that can
    be displayed by a mobile app or a browser. These functions expose features of
    the model, and don''t involve the same depth and complexity of the model itself;
    we won''t focus on this component in the case study.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tests**: This will have unit tests for the model and view functions. While
    tests are essential for being sure the software is usable, they are the subject
    of *Chapter 13*, *Testing Object-Oriented Programs*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have included dependency arrows, using dashed lines. These can be annotated
    with the Python-specific "imports" label to help clarify how the various packages
    and modules are related.
  prefs: []
  type: TYPE_NORMAL
- en: As we move through the design in later chapters, we'll expand on this initial
    view. Having thought about what needs to be built, we can now consider how it's
    deployed by drawing a physical view of the application. As noted above, there's
    a delicate dance between development and deployment. The two views are often built
    together.
  prefs: []
  type: TYPE_NORMAL
- en: Physical view
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The physical view shows how the software will be installed into physical hardware.
    For web services, we often talk about a **continuous integration and continuous
    deployment** (**CI/CD**) pipeline. This means that a change to the software is
    tested as a unit, integrated with the existing applications, tested as an integrated
    whole, then deployed for the users.
  prefs: []
  type: TYPE_NORMAL
- en: While it's common to assume a website, this can also be deployed as a command-line
    application. It might be run on a local computer. It might also be run on a computer
    in the cloud. Another choice is to build a web application around the core classifier.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows a view of a web application server:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram  Description automatically generated](img/B17070_01_17.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.17: Application server diagram'
  prefs: []
  type: TYPE_NORMAL
- en: 'This diagram shows the client and server nodes as three-dimensional "boxes"
    with "components" installed on them. We''ve identified three components:'
  prefs: []
  type: TYPE_NORMAL
- en: A Client running the **client app** application. This application connects to
    the classifier web service and makes RESTful requests. It might be a website,
    written in JavaScript. It might be a mobile application, written in Kotlin or
    Swift. All of these frontends have a common **HTTPS** connection to our web server.
    This secure connection requires some configuration of certificates and encryption
    key pairs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **GUnicorn** web server. This server can handle a number of details of web
    service requests, including the important HTTPS protocol. See [https://docs.gunicorn.org/en/stable/index.html](https://docs.gunicorn.org/en/stable/index.html)
    for details.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our **Classifier** application. From this view, the complexities have been omitted,
    and the entire `Classifier` package is reduced to a small component in a larger
    web services framework. This could be built using the Flask framework.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Of these components, the Client's **client app** is not part of the work being
    done to develop the classifier. We've included this to illustrate the context,
    but we're not really going to be building it.
  prefs: []
  type: TYPE_NORMAL
- en: We've used a dotted dependency arrow to show that our `Classifier` application
    is a dependency from the web server. **GUnicorn** will import our web server object
    and use it to respond to requests.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've sketched out the application, we can consider writing some code.
    As we write, it helps to keep the diagrams up-to-date. Sometimes, they serve as
    a handy roadmap in a wilderness of code.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are several key concepts in this case study:'
  prefs: []
  type: TYPE_NORMAL
- en: Software applications can be rather complicated. There are five views to depict
    the users, the data, the processing, the components to be built, and the target
    physical implementation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Mistakes will be made. This overview has some gaps in it. It's important to
    move forward with partial solutions. One of Python's advantages is the ability
    to build software quickly, meaning we're not deeply invested in bad ideas. We
    can (and should) remove and replace code quickly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Be open to extensions. After we implement this, we'll see that setting the *k* parameter
    is a tedious exercise. An important next step is to automate tuning using a grid
    search tuning algorithm. It's often helpful to set these things aside and get
    something that works first, then extend working software later to add this helpful
    feature.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Try to assign clear responsibilities to each class. This has been moderately
    successful, and some responsibilities are vague or omitted entirely. We'll revisit
    this as we expand this initial analysis into implementation details.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In later chapters, we'll dive more deeply into these various topics. Because
    our intent is to present realistic work, this will involve rework. Some design
    decisions may be revised as the reader is exposed to more and more of the available
    objected-oriented programming techniques in Python. Additionally, some parts of
    the solution will evolve as our understanding of design choices and the problem
    itself evolves. Rework based on lessons learned is a consequence of an agile approach
    to development.
  prefs: []
  type: TYPE_NORMAL
- en: Recall
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Some key points in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing problem requirements in an object-oriented context
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to draw **Unified Modeling Language** (**UML**) diagrams to communicate
    how the system works
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discussing object-oriented systems using the correct terminology and jargon
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the distinction between class, object, attribute, and behavior
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Some OO design techniques are used more than others. In our case study example,
    we focused on a few:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encapsulating features into classes
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Inheritance to extend a class with new features
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Composition to build a class from component objects
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is a practical book. As such, we're not assigning a bunch of fake object-oriented
    analysis problems to create designs for you to analyze and design. Instead, we
    want to give you some ideas that you can apply to your own projects. If you have
    previous object-oriented experience, you won't need to put much effort into this
    chapter. However, they are useful mental exercises if you've been using Python
    for a while, but have never really cared about all that class stuff.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, think about a recent programming project you''ve completed. Identify
    the most prominent object in the design. Try to think of as many attributes for
    this object as possible. Did it have the following: Color? Weight? Size? Profit?
    Cost? Name? ID number? Price? Style?'
  prefs: []
  type: TYPE_NORMAL
- en: Think about the attribute types. Were they primitives or classes? Were some
    of those attributes actually behaviors in disguise? Sometimes, what looks like
    data is actually calculated from other data on the object, and you can use a method
    to do those calculations. What other methods or behaviors did the object have?
    Which objects called those methods? What kinds of relationships did they have
    with this object?
  prefs: []
  type: TYPE_NORMAL
- en: Now, think about an upcoming project. It doesn't matter what the project is;
    it might be a fun free-time project or a multi-million-dollar contract. It doesn't
    have to be a complete application; it could just be one subsystem. Perform a basic
    object-oriented analysis. Identify the requirements and the interacting objects.
    Sketch out a class diagram featuring the highest level of abstraction on that
    system. Identify the major interacting objects. Identify minor supporting objects.
    Go into detail for the attributes and methods of some of the most interesting
    ones. Take different objects to different levels of abstraction. Look for places
    where you can use inheritance or composition. Look for places where you should
    avoid inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: The goal is not to design a system (although you're certainly welcome to do
    so if inclination meets both ambition and available time). The goal is to think
    about object-oriented design. Focusing on projects that you have worked on, or
    are expecting to work on in the future, simply makes it real.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, visit your favorite search engine and look up some tutorials on UML.
    There are dozens, so find one that suits your preferred method of study. Sketch
    some class diagrams or a sequence diagram for the objects you identified earlier.
    Don't get too hung up on memorizing the syntax (after all, if it is important,
    you can always look it up again); just get a feel for the language. Something
    will stay lodged in your brain, and it can make communicating a bit easier if
    you can quickly sketch a diagram for your next OOP discussion.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we took a whirlwind tour through the terminology of the object-oriented
    paradigm, focusing on object-oriented design. We can separate different objects
    into a taxonomy of different classes and describe the attributes and behaviors
    of those objects via the class interface. Abstraction, encapsulation, and information
    hiding are highly-related concepts. There are many different kinds of relationships
    between objects, including association, composition, and inheritance. UML syntax
    can be useful for fun and communication.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll explore how to implement classes and methods in Python.
  prefs: []
  type: TYPE_NORMAL
