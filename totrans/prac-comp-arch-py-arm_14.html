<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer094" class="_idGenObjectStyleOverride-1">&#13;
			<h1 id="_idParaDest-193" class="chapter-number" lang="en-GB"><a id="_idTextAnchor209"/>12</h1>&#13;
			<h1 id="_idParaDest-194" lang="en-GB"><a id="_idTextAnchor210"/>Subroutines and the Stack</h1>&#13;
			<p lang="en-GB">A subroutine is a piece of code that is called from a point within a program and executed, and then a return is made to the instruction after the calling point. All computers use subroutines, but some computers provide a programmer with more facilities to implement subroutines <span class="No-Break">than others.</span></p>&#13;
			<p lang="en-GB">In this chapter, we will look at the ARM’s subroutine handling mechanisms – in particular, <span class="No-Break">the following:</span></p>&#13;
			<ul>&#13;
				<li lang="en-GB">The special branch and <span class="No-Break">link instruction</span></li>&#13;
				<li lang="en-GB"><span class="No-Break">The stack</span></li>&#13;
				<li lang="en-GB">A subroutine call <span class="No-Break">and return</span></li>&#13;
				<li lang="en-GB">Block <span class="No-Break">move instructions</span></li>&#13;
			</ul>&#13;
			<h1 id="_idParaDest-195" lang="en-GB"><a id="_idTextAnchor211"/>The Branch with link instruction</h1>&#13;
			<p lang="en-GB">First, we discuss the ARM’s <em class="italic">branch and link</em> instruction, <strong class="source-inline">bl</strong>, which provides a quick and easy way to call a subroutine without using a <span class="No-Break">stack mechanism.</span></p>&#13;
			<p lang="en-GB">There are two basic ways of implementing <a id="_idIndexMarker687"/>subroutine calls and returns. The classic <a id="_idIndexMarker688"/>CISC approach is <strong class="source-inline">BSR</strong> (branch to subroutine) and <strong class="source-inline">RTS</strong> (return from subroutine). The typical <a id="_idIndexMarker689"/>code might be <span class="No-Break">as follows:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>      bsr abc    <span class="sc-comment">@ Call the subroutine on the line labeled abc</span></span>&#13;
<span>      . . .</span>&#13;
<span>      . . .</span>&#13;
<span class="sc-grey" lang="en-GB"><span class="sc-source-bg">abc:  . . .      </span><span class="sc-comment-bg">@ Subroutine abc entry point</span></span>&#13;
<span class="sc-grey" lang="en-GB"><span class="sc-source-bg">      . . .</span></span>&#13;
<span class="sc-grey" lang="en-GB"><span class="sc-source-bg">      rts        </span><span class="sc-comment-bg">@ Subroutine abc return to calling point</span></span></pre>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">This is simplicity in action. You call a piece of code, execute it, and return to the instruction after the calling point. Most RISC processors reject this mechanism because the subroutine call and return are complex instructions that save the return address on the stack during a call, and then pull the return address off the stack during a return. This is very convenient for a programmer but requires several CPU clock cycles to execute, and it does not fit into the one-cycle-per-instruction paradigm of the <span class="No-Break">RISC processor.</span></p>&#13;
			<p lang="en-GB">The great advantage of the stack-based subroutine call/return is that you can nest subroutines and call subroutines from other subroutines, and the stack mechanism automatically deals with <span class="No-Break">return addresses.</span></p>&#13;
			<p lang="en-GB">You will soon see that you can implement this mechanism yourself on an ARM, but not by using two dedicated instructions. You have to write your <span class="No-Break">own code.</span></p>&#13;
			<p lang="en-GB">If you want a simple subroutine call and return (the subroutine is called a <em class="italic">leaf</em>), all you need to do is save the return address in a register (no external memory or stack is required). Then, to return, you just put the return address in the program counter – simple and fast. However, once you are in the subroutine, you can’t do the same thing again and call another subroutine. Doing that would destroy your existing saved <span class="No-Break">return address.</span></p>&#13;
			<p lang="en-GB">The ARM’s subroutine mechanism is called <em class="italic">branch with link</em> and has the mnemonic <strong class="source-inline">bl target</strong>, where <strong class="source-inline">target</strong> is the symbolic address of the subroutine. The actual address is program counter-relative and is a 24-bit signed word that gives you a branch range of 2<span class="superscript">23</span> words from the current PC. The range is 2<span class="superscript">23</span> words in either direction from the PC (i.e., branch forward and <span class="No-Break">branch back).</span></p>&#13;
			<p lang="en-GB">The branch with link instruction <a id="_idIndexMarker690"/>behaves like a branch instruction, but it also copies the return address (i.e., the address of the next instruction to be executed following a return into the link register <strong class="source-inline">r14</strong>. Let’s say you execute <span class="No-Break">the following:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>        bl     sub_A          <span class="sc-comment">@ Branch to sub_A with link and save return address in r14</span></span></pre>&#13;
			<p lang="en-GB">The ARM executes a branch to the target address specified by the label <strong class="source-inline">sub_A</strong>. It also copies the program counter, held in register <strong class="source-inline">r15</strong>, into the link register <strong class="source-inline">r14</strong> to preserve the return address. At the end of the subroutine, you return by transferring the return address in <strong class="source-inline">r14</strong> to the program counter. You don’t need a special return instruction; you just write <span class="No-Break">the following:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>        mov    <strong class="bold">pc</strong>,lr          <span class="sc-comment">@ We can also write this as mov </span><span class="sc-comment-bold">r15</span><span class="sc-comment">,r14</span></span></pre>&#13;
			<p lang="en-GB">Let’s look at a simple example of the use of a subroutine. Suppose that you need to evaluate the <strong class="source-inline">if x &gt; 0 then</strong> <strong class="source-inline">x = 16x + 1 else x = 32x</strong> function several times in a program. Assuming that the x parameter is in register <strong class="source-inline">r0</strong>, we can write the <span class="No-Break">following subroutine:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>Func1:  cmp    r0,#0          <span class="sc-comment">@ Test for x &gt; 0</span></span>&#13;
<span>        mov<strong class="bold">gt</strong>  <strong class="bold">r0</strong>,r0, lsl #4  <span class="sc-comment">@ If x &gt; 0 then x = 16x</span></span>&#13;
<span>        add<strong class="bold">gt</strong>  <strong class="bold">r0</strong>,r0,#1       <span class="sc-comment">@ If x &gt; 0 then x = 16x + 1</span></span>&#13;
<span>        mov<strong class="bold">le</strong>  <strong class="bold">r0</strong>,r0, lsl #5  <span class="sc-comment">@ ELSE if x &lt; 0 THEN x = 32x</span></span>&#13;
<span>        mov    <strong class="bold">pc</strong>,lr          <span class="sc-comment">@ Return by restoring saved PC</span></span></pre>&#13;
			<p lang="en-GB">All you need to create a subroutine is an entry point (the label <strong class="source-inline">Func1</strong>) and a return point that restores the saved address by bl in the <span class="No-Break">link register.</span></p>&#13;
			<h2 id="_idParaDest-196" lang="en-GB"><a id="_idTextAnchor212"/>The stack</h2>&#13;
			<p lang="en-GB">We’ve already described <a id="_idIndexMarker691"/>the stack. We’ll go over it again here because it’s probably the single most important data structure in computing. The stack is a pile that you add things on at the top and take things off, also from the top. If you take something off the stack, it is the last thing that was added to the stack. Consequently, the stack is called a <strong class="bold">last in first out queue</strong> (<strong class="bold">LIFO</strong>), in which <a id="_idIndexMarker692"/>items enter at one end and leave in the <span class="No-Break">reverse order.</span></p>&#13;
			<p lang="en-GB">Computers implement stacks by using a pointer register to point at the top of the stack. The ARM uses <strong class="source-inline">r13</strong> as a stack pointer, or, to be precise, the ARM <em class="italic">mandates</em> the use of <strong class="source-inline">r13</strong> as a stack pointer. You can use <strong class="source-inline">r0</strong> to <strong class="source-inline">r13</strong> as a stack pointer if you wish. The use of <strong class="source-inline">r13</strong> is a <em class="italic">convention</em> designed to make code more readable <span class="No-Break">and sharable.</span></p>&#13;
			<p lang="en-GB">There are four variations of the stack. They all do the same thing but are implemented differently. The ARM supports all four variations, but we’ll use only one <a id="_idIndexMarker693"/>here for the sake of simplicity. A stack is stored in memory, which has no up or down in the normal human sense. When items are added to the stack, they can be added to the next location with a lower address or the next location with a higher address. By convention, most stacks are implemented so that the next item is stored at the <em class="italic">lower address</em>. We say that the stack grows <em class="italic">up</em> toward <em class="italic">lower</em> addresses (that’s because we number lines in a book from top to bottom, with line one at <span class="No-Break">the top).</span></p>&#13;
			<p lang="en-GB">The other variation in the arrangement of stacks is that the stack pointer can either point to the top item on the stack, TOS, or point to the next free item on that stack. I will cover stacks where the stack pointer points to the top item on the stack (again, this is the most <span class="No-Break">common convention).</span></p>&#13;
			<p lang="en-GB"><span class="No-Break"><em class="italic">Figure 12</em></span><em class="italic">.1</em> illustrates a stack used to save subroutine <span class="No-Break">return addresses.</span></p>&#13;
			<div class="_idGenObjectLayout-1">&#13;
				<div id="_idContainer089" class="IMG---Figure">&#13;
					<img class="_idGenObjectAttribute-1" src="Images/Figure_12.01_B19624.jpg" alt="Figure 12.1 – Using the stack to save a return address, N" width="1737" height="550"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.1 – Using the stack to save a return address, N</p>&#13;
			<p lang="en-GB">The stack pointer points at the top item on the stack, and when an item is added to the stack (pushed), the stack pointer is first decremented. When an item is removed from the stack, it is taken at the location indicated by the stack pointer, and the stack <a id="_idIndexMarker694"/>pointer is incremented (i.e., moved down). We can define the push and pull (pop) actions with relation to the <strong class="bold">stack pointer </strong>(<strong class="bold">SP</strong>) <span class="No-Break">as follows:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>PUSH:    [SP]   ← [SP] – 4    <span class="sc-comment">@ Move stack pointer up one word (up toward lower addresses)</span></span>&#13;
<span>         [[SP]] ← data        <span class="sc-comment">@ Push data onto the stack. Push uses pre-decrementing.</span></span>&#13;
<span>PULL:    data  ← [[SP]]       <span class="sc-comment">@ Pull data off the stack by reading TOS</span></span></pre>&#13;
			<pre class="source-code">         [SP]  ← [SP] + 4     <span class="sc-comment">@ Move stack pointer down one word (pull uses post-incrementing)</span></pre>&#13;
			<p lang="en-GB">The stack pointer is decremented and incremented by four, since we follow the ARM convention that the memory is byte-addressed and stack items are one-word long (four bytes). The next section looks in greater detail at how a subroutine is called and an orderly return is made to the <span class="No-Break">calling point.</span></p>&#13;
			<h1 id="_idParaDest-197" lang="en-GB"><a id="_idTextAnchor213"/>A subroutine call and return</h1>&#13;
			<p lang="en-GB">To call a subroutine, you push the return address on the stack. CISC processors implement a subroutine call with <strong class="source-inline">bsr target</strong>. Because the ARM lacks a subroutine <a id="_idIndexMarker695"/>call instruction, you can write the following ARM code. Remember that we are dealing with 32-bit word push and pulls, and the stack must be incremented or decremented by four. Remember that <strong class="source-inline">r15</strong> and <strong class="source-inline">SP</strong> and <strong class="source-inline">r13</strong> and <strong class="source-inline">lr</strong> are interchangeable terms in <span class="No-Break">ARM literature:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>      sub  <strong class="bold">r13</strong>,r13,#4       <span class="sc-comment">@ Pre-decrement the stack pointer (r13 is used as the SP)</span></span>&#13;
<span>      str  r15,<strong class="bold">[r13]</strong>        <span class="sc-comment">@ Push the return address in r15 on the stack</span></span>&#13;
<span>      b    Target           <span class="sc-comment">@ Jump to the target address</span></span>&#13;
<span>        ...                 <span class="sc-comment">@ Return here</span></span></pre>&#13;
			<p lang="en-GB">There’s no ARM subroutine return instruction, so you implement one with <span class="No-Break">the following:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>      ldr  <strong class="bold">r12</strong>,[r13],#+4    <span class="sc-comment">@ Get saved PC from stack and post-increment the stack pointer</span></span>&#13;
<span class="sc-grey" lang="en-GB">      mov  <strong class="bold">r15</strong>,r12          <span class="sc-comment">@ Load PC with return address</span></span></pre>&#13;
			<p lang="en-GB">The following is a simple program that sets up a call and return using this mechanism. Note that we don’t set up the initial stack pointer. The ARM’s operating system <span class="No-Break">does that:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>.section .text</span>&#13;
<span>.global _start</span>&#13;
<span>_start: mov  r0,#9          <span class="sc-comment">@ Dummy operation</span></span>&#13;
<span>        sub  sp,sp,#4       <span class="sc-comment">@ Decrement stack</span></span>&#13;
<span>        str  pc,[sp]        <span class="sc-comment">@ Save pc on stack</span></span>&#13;
<span>        b    target         <span class="sc-comment">@ Branch to subroutine "target"</span></span>&#13;
<span>        mov  r2,#0xFFFFFFFF <span class="sc-comment">@ Return here ... this is a marker</span></span>&#13;
<span>        nop                 <span class="sc-comment">@ Dummy operation</span></span>&#13;
<span>        mov  r7,#1          <span class="sc-comment">@ Set up exit code</span></span>&#13;
<span>        svc  0              <span class="sc-comment">@ Leave program</span></span>&#13;
<span>target: mov  r1,#0xFF       <span class="sc-comment">@ Subroutine ... dummy operation</span></span>&#13;
<span>        ldr  r12,[sp],#+4   <span class="sc-comment">@ Pull pc off the stack</span></span>&#13;
<span>        mov  r15,r12        <span class="sc-comment">@ Return</span></span></pre>&#13;
			<pre class="source-code">        .end</pre>&#13;
			<p lang="en-GB"><span class="No-Break"><em class="italic">Figure 12</em></span><em class="italic">.2</em> demonstrates the output of the ARM simulator after running this code. We have included the disassembly window and the register windows. Note how the <strong class="source-inline">mov </strong><span class="pcode-bold">r2</span><strong class="source-inline">,#0xFFFFFFFF</strong> instruction has been transformed into the <strong class="source-inline">mvn </strong><span class="pcode-bold">r2</span><strong class="source-inline">,#0</strong> operation. Recall that <strong class="source-inline">MVN</strong><strong class="bold"> (move negative)</strong> moves a literal to a register and inverts its bits. Note also how <strong class="source-inline">ldr r12,[sp],#+</strong> has been renamed <strong class="source-inline">pop {r12}</strong>. This is equivalent to the pop stack operation (removing an item from the top of <span class="No-Break">the stack).</span></p>&#13;
			<p lang="en-GB">Registers after <a id="_idIndexMarker696"/>execution of <span class="No-Break">the code:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>Register group: general</span>&#13;
<span>r0             0x9                 9</span>&#13;
<span>r1             0xff                255</span>&#13;
<span>r2             0xffffffff          4294967295</span>&#13;
<span>r12            0x10064             65636</span>&#13;
<span>sp             0xbefff380          0xbefff380</span>&#13;
<span>lr             0x0                 0</span>&#13;
<span>pc             0x1006c             0x1006c &lt;_start+24&gt;</span></pre>&#13;
			<p lang="en-GB">The following is an execution of the code step by step. This is an example of a subroutine call <span class="No-Break">and return:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>B+ 0x10054 &lt;_start&gt;        mov    r0, #9</span>&#13;
<span>   0x10058 &lt;_start+4&gt;      sub    sp, sp, #4</span>&#13;
<span>   0x1005c &lt;_start+8&gt;      str    pc, [sp]</span>&#13;
<span>   0x10060 &lt;_start+12&gt;     b      0x10074 &lt;target&gt;</span>&#13;
<span>   0x10064 &lt;_start+16&gt;     mvn    r2, #0</span>&#13;
<span>   0x10068 &lt;_start+20&gt;     nop                    ; (mov r0, r0)</span>&#13;
<span>  ^0x1006c &lt;_start+24&gt;     mov    r7, #1</span>&#13;
<span>   0x10070 &lt;_start+28&gt;     svc    0x00000000</span>&#13;
<span>   0x10074 &lt;target&gt;        mov    r1, #255        ; 0xff</span>&#13;
<span>   0x10078 &lt;target+4&gt;      pop    {r12}           ; (ldr r12, [sp], #4)</span>&#13;
<span>   0x1007c &lt;target+8&gt;      mov    pc, r12</span></pre>&#13;
			<p lang="en-GB">In the next section, we will look at <a id="_idIndexMarker697"/>one of the ARM’s most powerful and least RISC-like operations – the ability to move blocks of data between memory and <span class="No-Break">multiple registers.</span></p>&#13;
			<h1 id="_idParaDest-198" lang="en-GB"><a id="_idTextAnchor214"/>Block move instructions</h1>&#13;
			<p lang="en-GB">In this section, we will learn <a id="_idIndexMarker698"/>how multiple registers can be moved. The fundamental concepts are <span class="No-Break">as follows:</span></p>&#13;
			<ul>&#13;
				<li lang="en-GB">How to specify a group <span class="No-Break">of registers</span></li>&#13;
				<li lang="en-GB">How to <span class="No-Break">address memory</span></li>&#13;
				<li lang="en-GB">How to sequence the storage <span class="No-Break">of registers</span></li>&#13;
				<li class="_idGenParaOverride-1" lang="en-GB">The different types of <span class="No-Break">block moves</span></li>&#13;
			</ul>&#13;
			<p lang="en-GB">A great feature of some CISC processors was that you could push a group of registers on the stack in a single instruction. RISC processors generally don’t have such an instruction because it conflicts with the one-operation-per-cycle design constraint that’s at the heart of the RISC philosophy. Surprisingly, the ARM implements a block move instruction that lets you copy a group of registers to or from memory in one operation (i.e., an instruction). The following ARM code demonstrates how to load registers <strong class="source-inline">r1</strong>,<strong class="source-inline">r2</strong>,<strong class="source-inline">r3</strong>,<strong class="source-inline">r5</strong> <span class="No-Break">from memory:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>    adr  <strong class="bold">r0</strong>,DataToGo    <span class="sc-comment">@ Load r0 with the address of the data area</span></span>&#13;
<span>    ldr  <strong class="bold">r1</strong>,[r0],#4     <span class="sc-comment">@ Load r1 with the word pointed at by r0 and update the pointer</span></span>&#13;
<span>    ldr  <strong class="bold">r2</strong>,[r0],#4     <span class="sc-comment">@ Load r2 with the word pointed at by r0 and update the pointer</span></span>&#13;
<span>    ldr  <strong class="bold">r3</strong>,[r0],#4     <span class="sc-comment">@ and so forth for the remaining registers r3 and r5</span>…</span>&#13;
<span>    ldr  <strong class="bold">r5</strong>,[r0],#4</span></pre>&#13;
			<p lang="en-GB">ARM has a <em class="italic">block move to memory</em> instruction, <strong class="source-inline">stm</strong>, and a <em class="italic">block move from memory</em>, <strong class="source-inline">ldm</strong>, that copies groups of registers to and from memory. Block move instructions require a two-character suffix to describe how the data is accessed (e.g., <strong class="source-inline">stm</strong><span class="pcode-bold">ia</span> or <strong class="source-inline">ldm</strong><span class="pcode-bold">db</span>), as we <span class="No-Break">shall see.</span></p>&#13;
			<p lang="en-GB">Conceptually, a block move is easy to understand because it is simply a <em class="italic">copy the contents of these registers to memory</em> operation, or vice versa. In practice, it is more complex. ARM provides a full set of options that determine how the move takes place – for example, whether the registers are moved from high-to-low or low-to-high memory addresses, or whether the memory <a id="_idIndexMarker699"/>pointer is updated before or after a transfer (just like a stack structure). In fact, block moves are just like the push and pull stack operations found on <span class="No-Break">other computers.</span></p>&#13;
			<p lang="en-GB">Let’s move the contents of registers <strong class="source-inline">r1</strong>, <strong class="source-inline">r2</strong>, <strong class="source-inline">r3</strong>, and <strong class="source-inline">r5</strong> into sequential memory locations <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">stm</strong></span><span class="No-Break">:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>stmia  <strong class="bold">r0!</strong>,<strong class="bold">{r1-r3,r5}</strong>   <span class="sc-comment">@ Note block move syntax. The register list is in braces</span></span>&#13;
<span>                        <span class="sc-comment">@ r0! is the destination register with auto indexing</span></span>&#13;
<span>                        <span class="sc-comment">@ The register list is {r1-r3,r5} r1,r2,r3,r5</span></span></pre>&#13;
			<p lang="en-GB">This instruction copies registers <strong class="source-inline">r1</strong> to <strong class="source-inline">r3</strong>, and <strong class="source-inline">r5</strong> into sequential memory locations, using <strong class="source-inline">r0</strong> as a pointer register with auto-indexing (indicated by the <strong class="source-inline">!</strong> suffix). The <span class="pcode-bold">ia</span> suffix indicates that the index register <strong class="source-inline">r0</strong> is incremented <em class="italic">after</em> each transfer, with data transfer in order of <em class="italic">ascending</em> addresses. We’ll also see that this instruction can be written as <strong class="source-inline">stm</strong><span class="pcode-bold">fd</span> (which is the same operation, but ARM provides two naming conventions for the same thing in <span class="No-Break">their documentation).</span></p>&#13;
			<p lang="en-GB">Although ARM’s block move mode instructions have several variations, the lowest numbered register is always stored at the lowest address, followed by the next lowest numbered register at the next higher address, and so on (e.g., <strong class="source-inline">r1</strong>, then<strong class="source-inline"> r2</strong>, <strong class="source-inline">r3</strong>, and <strong class="source-inline">r5</strong> in the <span class="No-Break">preceding example).</span></p>&#13;
			<p lang="en-GB">Consider the following example of the block move. Because it’s a little more complicated than some instructions we’ve encountered, we will demonstrate its execution. I’ve included several features that are not strictly part of the demonstration but include features I use when experimenting. In particular, I use markers in both registers and memory so that I can follow debugging more easily. For example, in the memory block, I store the data words <strong class="source-inline">0xFFFFFFFF</strong> and <strong class="source-inline">0xAAAAAAAA</strong>. These serve no function other than to show me, at a glance, where my data area starts and stops when I debug memory. Similarly, I use values such as <strong class="source-inline">0x11111111</strong> as words to move from registers because I can easily follow them <span class="No-Break">in debugging:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>           .text                       <span class="sc-comment">@ This is a code section</span></span>&#13;
<span>           .global _start              <span class="sc-comment">@ Define entry point for code execution</span></span>&#13;
<span> _start:    nop                        <span class="sc-comment">@ nop = no operation and is a dummy instruction</span></span>&#13;
<span class="sc-grey" lang="en-GB">           ldr    <strong class="bold">r0</strong>,=0xFFFFFFFF       <span class="sc-comment">@ Dummy values for testing</span></span>&#13;
<span class="sc-grey" lang="en-GB">           ldr    <strong class="bold">r1</strong>,=0x11111111</span>&#13;
<span class="sc-grey" lang="en-GB">           ldr    <strong class="bold">r2</strong>,=0x22222222</span>&#13;
<span class="sc-grey" lang="en-GB">           ldr    <strong class="bold">r3</strong>,=0x33333333</span>&#13;
<span class="sc-grey" lang="en-GB">           ldr    <strong class="bold">r4</strong>,=0x44444444</span>&#13;
<span class="sc-grey" lang="en-GB">           ldr    <strong class="bold">r5</strong>,=0x55555555</span>&#13;
<span class="sc-grey" lang="en-GB">           ldr    <strong class="bold">r0</strong>,adr_mem           <span class="sc-comment">@ Load pointer r0 with memory</span></span>&#13;
<span class="sc-grey" lang="en-GB">           <strong class="bold">stmia</strong>  <strong class="bold">r0</strong>!,<strong class="bold">{r1-r3,r5}</strong>       <span class="sc-comment-bold">@ Do a multiple load to memory</span></span>&#13;
<span class="sc-bottom" lang="en-GB">           mov    <strong class="bold">r10</strong>,r0               <span class="sc-comment">@ Save r0 in r10 (for debugging)</span></span>&#13;
<span class="sc-bottom" lang="en-GB">           <strong class="bold">ldmdb  r0!</strong>,{r6-r9}          <span class="sc-comment-bold">@ Now load data from memory</span></span>&#13;
<span class="sc-bottom" lang="en-GB">           mov    <strong class="bold">r11</strong>,r0</span>&#13;
<span class="sc-bottom" lang="en-GB">           mov    <strong class="bold">r1</strong>,#1                <span class="sc-comment">@ Terminate command</span></span>&#13;
<span class="sc-bottom" lang="en-GB">           svc    0                    <span class="sc-comment">@ Call OS to leave</span></span>&#13;
<span class="sc-bottom" lang="en-GB">           .word  0xFFFFFFFF           <span class="sc-comment">@ A dummy value for testing</span></span>&#13;
<span class="sc-bottom" lang="en-GB">           .word  0xAAAAAAAA           <span class="sc-comment">@ Another dummy value</span></span>&#13;
<span class="sc-bottom" lang="en-GB">adr_mem:   .word  memory               <span class="sc-comment">@ The address of the memory for storing data</span></span>&#13;
<span class="sc-grey" lang="en-GB"><span class="sc-source-bg">           .data                       </span><span class="sc-comment-bg">@ Declare a memory segment for the data</span></span>&#13;
<span class="sc-grey" lang="en-GB"><span class="sc-source-bg">memory:    .word  0xBBBBBBBB           </span><span class="sc-comment-bg">@ Yet another memory marker</span></span>&#13;
<span class="sc-grey" lang="en-GB"><span class="sc-source-bg">           .space 32                   </span><span class="sc-comment-bg">@ Reserve space for storage (8 words)</span></span>&#13;
<span class="sc-grey" lang="en-GB"><span class="sc-source-bg">           .word  0xCCCCCCCC           </span><span class="sc-comment-bg">@ Final memory marker</span></span>&#13;
<span class="sc-grey" lang="en-GB"><span class="sc-source-bg">           .end</span></span></pre>&#13;
			<p lang="en-GB">This code sets up five registers with data that is easily visible when examining memory. Thirty-two bytes of memory are saved between two word markers <a id="_idIndexMarker700"/>at the end of the program with the <strong class="source-inline">.space</strong> directive. The start of this block is labeled <strong class="source-inline">memory</strong>, and <strong class="source-inline">r0</strong> points to it. Then the five registers are stored in memory. Instructions that carry out the block store are shaded in light gray, and the data area is shaded in <span class="No-Break">dark gray.</span></p>&#13;
			<p lang="en-GB">The code we are initially interested in is for the five register loads that preset registers <strong class="source-inline">r1</strong> to <strong class="source-inline">r5</strong> with <strong class="source-inline">0x11111111</strong> to <strong class="source-inline">0x55555555</strong>, respectively. Register <strong class="source-inline">r0</strong> was set initially to <strong class="source-inline">0xFFFFFFFF</strong> just as a marker for debugging. The key instruction is <span class="pcode-bold">stmia r0!,{r1-r3,r5}</span>, whose purpose is to store the contents of registers <strong class="source-inline">r1</strong>, <strong class="source-inline">r2</strong>, <strong class="source-inline">r3</strong>, and <strong class="source-inline">r5</strong> in consecutive memory locations pointed at <span class="No-Break">by r0.</span></p>&#13;
			<p lang="en-GB">The following Raspberry Pi output is from the <strong class="source-inline">gdb</strong> debugger. The source code is <strong class="source-inline">blockMove1.s</strong>. We’ve omitted some of the register values to make the listing more readable when registers haven’t changed or haven’t been used. Similarly, repetitive command lines have <span class="No-Break">been omitted:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>pi@raspberrypi:~/Desktop $ as -g -o blockMove1.o blockMove1.s</span>&#13;
<span>pi@raspberrypi:~/Desktop $ ld -o blockMove1 blockMove1.o</span>&#13;
<span>pi@raspberrypi:~/Desktop $ gdb blockMove1</span>&#13;
<span>(gdb) b 1</span>&#13;
<span>Breakpoint 1 at 0x10078: file blockMove1.s, line 6.</span>&#13;
<span>(gdb) r</span>&#13;
<span>Starting program: /home/pi/Desktop/blockMove1</span>&#13;
<span>Breakpoint 1, _start () at blockMove1.s:6</span>&#13;
<span>6               ldr    r0,=0xFFFFFFFF         <span class="sc-comment">@ Dummy value for testing</span></span>&#13;
<span>(gdb) i r</span>&#13;
<span>r0             0x0                 0          <span class="sc-comment"># These are the initial registers before we start</span></span>&#13;
<span>r1             0x0                 0</span>&#13;
<span>r2             0x0                 0</span>&#13;
<span>r3             0x0                 0</span>&#13;
<span>r4             0x0                 0</span>&#13;
<span>r5             0x0                 0</span>&#13;
<span>r6             0x0                 0</span>&#13;
<span>r7             0x0                 0</span>&#13;
<span>r8             0x0                 0</span>&#13;
<span>r9             0x0                 0</span>&#13;
<span>r10            0x0                 0</span>&#13;
<span>r11            0x0                 0</span>&#13;
<span>r12            0x0                 0</span>&#13;
<span>sp             0xbefff380          0xbefff380 <span class="sc-comment"># The OS sets up the stack pointer</span></span>&#13;
<span>lr             0x0                 0</span>&#13;
<span>pc             0x10078             0x10078 &lt;_start+4&gt;  <span class="sc-comment"># The OS sets up stack pointer</span></span></pre>&#13;
			<p lang="en-GB">Having looked at the registers, we will now proceed <a id="_idIndexMarker701"/>to execute a series of instructions. Note that we need to enter <strong class="source-inline">si 1</strong> once and then simply hit <em class="italic">Return</em> to repeat <span class="No-Break">the operation:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>(gdb) si 1</span>&#13;
<span>7              ldr    r1,=0x11111111          <span class="sc-comment"># Here we trace seven instructions</span></span>&#13;
<span>8              ldr    r2,=0x22222222</span>&#13;
<span>9              ldr    r3,=0x33333333</span>&#13;
<span>10             ldr    r4,=0x44444444</span>&#13;
<span>11             ldr    r5,=0x55555555</span>&#13;
<span>12             ldr    r0,adr_mem              <span class="sc-comment">@ Load pointer r0 with memory</span></span>&#13;
<span>13             stmia  r0!,{r1-r3,r5}          <span class="sc-comment">@ Multiple load to memory</span></span>&#13;
<span>(gdb) i r</span>&#13;
<span>r0             0x200cc             131276</span></pre>&#13;
			<p lang="en-GB">Now, let’s look at the registers we set up. Only registers of interest have been displayed. Note that <strong class="source-inline">r0</strong> points to the data at <strong class="source-inline">0x200CC</strong>. The system software is responsible for <span class="No-Break">this address:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>r1             0x11111111          286331153</span>&#13;
<span>r2             0x22222222          572662306</span>&#13;
<span>r3             0x33333333          858993459</span>&#13;
<span>r4             0x44444444          1145324612</span>&#13;
<span>r5             0x55555555          1431655765</span>&#13;
<span>r6             0x0                 0</span></pre>&#13;
			<p lang="en-GB">At this point, we’ve set up register <strong class="source-inline">r0</strong> as a pointer, and its value is <strong class="source-inline">0x200cc</strong>. This value has been determined by the assembler and loader. If you refer back to the source code, we used <strong class="source-inline">ldr </strong><span class="pcode-bold">r0</span><strong class="source-inline">,adr</strong>_mem to load <strong class="source-inline">r0</strong> via a pointer to the actual data stored in memory. This is because the software does not let us load a direct <span class="No-Break">memory address.</span></p>&#13;
			<p lang="en-GB">You can see that the registers have been set up with their <em class="italic">easy-to-trace</em> values. The next step is to examine memory using the <strong class="source-inline">x/16xw gdb</strong> command to display 16 words of <span class="No-Break">hexadecimal data:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>pc             0x10094             0x10094 &lt;_start+32&gt;</span>&#13;
<span>(gdb) x/16xw 0x200cc</span>&#13;
<span>0x200cc:    <strong class="bold">0xbbbbbbbb</strong>    0x00000000    0x00000000    0x00000000</span>&#13;
<span>0x200dc:    0x00000000    0x00000000    0x00000000    0x00000000</span>&#13;
<span>0x200ec:    0x00000000    <strong class="bold">0xcccccccc</strong>    0x00001141    0x61656100</span>&#13;
<span>0x200fc:    0x01006962    0x00000007    0x00000108    0x0000001c</span></pre>&#13;
			<p lang="en-GB">The two markers we’ve stored in memory are in bold font. Now, let’s execute the stored multiple registers. Before that, we will copy the pointer to <strong class="source-inline">r10</strong> (again, that is just for my own debugging purposes) so that we can see what it was before the move. After the block <a id="_idIndexMarker702"/>move instruction, we display registers <span class="No-Break">of interest:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>(gdb) si 1</span>&#13;
<span>14               mov    r10,r0</span>&#13;
<span>15               ldmdb  r0!,{r6-r9}             <span class="sc-comment">@ Now load data from memory</span></span>&#13;
<span>(gdb) i r</span>&#13;
<span>r0             0x200dc             131292</span>&#13;
<span>r1             0x11111111          286331153</span>&#13;
<span>r2             0x22222222          572662306</span>&#13;
<span>r3             0x33333333          858993459</span>&#13;
<span>r4             0x44444444          1145324612</span>&#13;
<span>r5             0x55555555          1431655765</span>&#13;
<span>r6             0x0                 0</span>&#13;
<span>r10            0x200dc             131292</span>&#13;
<span>pc             0x1009c             0x1009c &lt;_start+40&gt;</span></pre>&#13;
			<p lang="en-GB">Now for the proof of the pudding. Here’s the memory after the <strong class="source-inline">x/16xw</strong> display command. Note that the contents of the four registers have been stored in consecutive rising <span class="No-Break">memory locations:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>(gdb) x/16xw 0x200cc</span>&#13;
<span>0x200cc:    <strong class="bold">0x11111111    0x22222222    0x33333333    0x55555555</strong></span>&#13;
<span>0x200dc:    0x00000000    0x00000000    0x00000000    0x00000000</span>&#13;
<span>0x200ec:    0x00000000    0xcccccccc    0x00001141    0x61656100</span></pre>&#13;
			<pre class="source-code">0x200fc:    0x01006962    0x00000007    0x00000108    0x0000001c</pre>&#13;
			<p lang="en-GB">Finally, we will execute the last two commands and display the <span class="No-Break">register contents:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>(gdb) si 1</span>&#13;
<span>16               mov    r11,r0</span>&#13;
<span>18               mov    r1,#1      <span class="sc-comment">@ Terminate command</span></span>&#13;
<span>(gdb) i r</span>&#13;
<span>r0             0x200cc             131276</span>&#13;
<span>r1             0x11111111          286331153</span>&#13;
<span>r2             0x22222222          572662306</span>&#13;
<span>r3             0x33333333          858993459</span>&#13;
<span>r4             0x44444444          1145324612</span>&#13;
<span>r5             0x55555555          1431655765</span>&#13;
<span><strong class="bold">r6             0x11111111          286331153</strong>       Data copied to registers r6 - r9</span>&#13;
<span><strong class="bold">r7             0x22222222          572662306</strong></span>&#13;
<span><strong class="bold">r8             0x33333333          858993459</strong></span>&#13;
<span><strong class="bold">r9             0x55555555          1431655765</strong></span>&#13;
<span>r10            0x200dc             131292</span></pre>&#13;
			<p lang="en-GB">You can see that the block move from the <strong class="source-inline">ldmdb r0!,{r6-r9}</strong> memory operation has copied the four registers from the memory and placed them in registers <strong class="source-inline">r7</strong> <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">r9</strong></span><span class="No-Break">.</span></p>&#13;
			<p lang="en-GB">Consider the suffix of <span class="pcode-bold">ldm</span>, which is <span class="pcode-bold">db</span>. Why <strong class="source-inline">ldmdb</strong>? When we transferred data to memory, we used the <em class="italic">increment after </em>suffix, where the pointer register is used <a id="_idIndexMarker703"/>to move the data to a memory location, and then it is incremented after the move. When we retrieve the data, we initially point at the location after the last value is moved. Consequently, to remove the items we stored in memory, we have to decrement the pointer before each move – hence the <em class="italic">decrement before </em>(<strong class="source-inline">db</strong>) suffix. For this reason, the instruction pair <strong class="source-inline">stmia</strong> and <strong class="source-inline">ldmdb</strong> correspond to the stack push and pull <span class="No-Break">operations, respectively.</span></p>&#13;
			<h2 id="_idParaDest-199" lang="en-GB"><a id="_idTextAnchor215"/>Disassembling the code</h2>&#13;
			<p lang="en-GB">The following is a disassembly of the <a id="_idIndexMarker704"/>code for this program. It’s been edited and reformatted for easier viewing. Some instructions have two lines. One line is the <em class="italic">original </em>instruction, as presented in the program. The following line is the instruction as interpreted by the assembler. This demonstrates how pseudo instructions such as <strong class="source-inline">ldr </strong><span class="pcode-bold">r1</span><strong class="source-inline">,=0x111111</strong> <span class="No-Break">are handled.</span></p>&#13;
			<p lang="en-GB">The lines in bold require some further explanation, as <span class="No-Break">shown here:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>(gdb) disassemble /m</span>&#13;
<span>Dump of assembler code for function _start:</span>&#13;
<span><strong class="bold">5 _start:            nop</strong></span>&#13;
<span><strong class="bold">   0x00010074 &lt;+0&gt;:  nop ;  (mov r0, r0)</strong></span>&#13;
<span><strong class="bold">6                    ldr     r0,=0xFFFFFFFF  </strong><span class="sc-comment-bold">@ Dummy value for testing</span></span>&#13;
<span><strong class="bold">=&gt; 0x00010078 &lt;+4&gt;:  mvn     r0, #0</strong></span>&#13;
<span><strong class="bold">7                    ldr     r1,=0x11111111</strong></span>&#13;
<span><strong class="bold">   0x0001007c &lt;+8&gt;:  ldr     r1, [pc, #52]   ; 0x100b8 &lt;adr_mem+4&gt;</strong></span>&#13;
<span><strong class="bold">8                    ldr     r2,=0x22222222</strong></span>&#13;
<span><strong class="bold">   0x00010080 &lt;+12&gt;: </strong><strong class="bold">ldr     r2, [pc, #52]   ; 0x100bc &lt;adr_mem+8&gt;</strong></span>&#13;
<span>9                    ldr     r3,=0x33333333</span>&#13;
<span>   0x00010084 &lt;+16&gt;: ldr     r3, [pc, #52]   ; 0x100c0 &lt;adr_m</span>&#13;
<span>10                   ldr     r4,=0x44444444</span>&#13;
<span>   0x00010088 &lt;+20&gt;: ldr     r4, [pc, #52]   ; 0x100c4 &lt;adr_mem+16&gt;</span>&#13;
<span>11                   ldr     r5,=0x55555555      </span>&#13;
<span>   0x0001008c &lt;+24&gt;: ldr     r5, [pc, #52]   ; 0x100c8 &lt;adr_mem+20&gt;</span>&#13;
<span><strong class="bold">12                   ldr     r0,adr_mem      </strong><span class="sc-comment-bold">@ Load pointer r0 with memory</span></span>&#13;
<span><strong class="bold">   0x00010090 &lt;+28&gt;: ldr     r0, [pc, #28]   </strong><span class="sc-comment-bold">; 0x100b4 &lt;adr_mem&gt;</span></span>&#13;
<span>13                   stmia   r0!,{r1-r3,r5}  <span class="sc-comment">@ Do a multiple load to memory</span></span>&#13;
<span>   0x00010094 &lt;+32&gt;: stmia   r0!, {r1,r2,r3,r5}</span>&#13;
<span>14                   mov     r10,r0</span>&#13;
<span>   0x00010098 &lt;+36&gt;: mov     r10, r0</span>&#13;
<span>15                   ldmdb   r0!,{r6-r9}     <span class="sc-comment">@ Now load data from memory</span></span>&#13;
<span>   0x0001009c &lt;+40&gt;: ldmdb   r0!, {r6,r7,r8,r9}</span>&#13;
<span>16                   mov     r11,r0</span>&#13;
<span>   0x000100a0 &lt;+44&gt;: mov     r11, r0</span>&#13;
<span>18                   mov     r1,#1           <span class="sc-comment">@ Terminate command</span></span>&#13;
<span>   0x000100a4 &lt;+48&gt;: mov     r1, #1</span>&#13;
<span>19                   svc     0               <span class="sc-comment">@ Call OS to leave  </span></span>&#13;
<span>   0x000100a8 &lt;+52&gt;: svc 0x00000000</span>&#13;
<span><strong class="bold">   0x000100ac &lt;+56&gt;: ; &lt;UNDEFINED&gt; instruction: 0xffffffff</strong></span>&#13;
<span>   0x000100b0 &lt;+60&gt;: bge 0xfeabab60</span>&#13;
<span>   0x000100b4 &lt;+0&gt;:  andeq r0, r2, r12, asr #1</span></pre>&#13;
			<p lang="en-GB">The following command uses x/32xw to display 32 consecutive words <a id="_idIndexMarker705"/>of memory in hexadecimal form so that we can observe what has happened in memory. Here’s where our use of markers such as 0xAAAAAAAA makes it easy to recognize where we are <span class="No-Break">in memory.</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span><strong class="bold">(gdb) x/32xw 0x100a8</strong>                         <span class="sc-comment">This displays 32 words of memory</span></span>&#13;
<span>0x100a8 &lt;_start+52&gt;:  0xef000000 0xffffffff 0xaaaaaaaa <strong class="bold">0x000200cc</strong></span>&#13;
<span>0x100b8 &lt;adr_mem+4&gt;:  0x11111111 0x22222222 0x33333333 0x44444444</span>&#13;
<span>0x100c8 &lt;adr_mem+20&gt;: 0x55555555 0xbbbbbbbb 0x00000000 0x00000000</span>&#13;
<span>0x100d8:              0x00000000 0x00000000 0x00000000 0x00000000</span>&#13;
<span>0x100e8:              0x00000000 0x00000000 0xcccccccc 0x00001141</span>&#13;
<span>0x100f8:              0x61656100 0x01006962 0x00000007 0x00000108</span>&#13;
<span>0x10108:              0x0000001c 0x00000002 0x00040000 0x00000000</span></pre>&#13;
			<pre class="source-code">0x10118:              0x00010074 0x00000058 0x00000000 0x00000000</pre>&#13;
			<p lang="en-GB"><em class="italic">Line 5</em> contains a <strong class="source-inline">nop</strong> instruction <a id="_idIndexMarker706"/>that does nothing (other than advance the PC to the next instruction). It can provide a placeholder for later code, or act as a debugging aid. Here, it provides a space for the first instruction to land on. The ARM lacks a <strong class="source-inline">nop</strong>, and the assembler translates <strong class="source-inline">nop</strong> to <strong class="source-inline">mov r0,r0</strong>. Like <strong class="source-inline">nop</strong>, this instruction <span class="No-Break">achieves nothing!</span></p>&#13;
			<p lang="en-GB"><strong class="source-inline">ldr </strong><span class="pcode-bold">r0</span><strong class="source-inline">,=0xFFFFFFFF</strong> is interesting. The assembler uses ARM’s <strong class="source-inline">mvn</strong> to invert the bits of the operand before moving them. If the operand is <strong class="source-inline">0</strong>, the bits moved will be all <strong class="source-inline">1</strong>s, which is exactly what <span class="No-Break">we want.</span></p>&#13;
			<p lang="en-GB">Instruction 7 demonstrates <span class="No-Break">another pseudo-operation:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>7                      ldr      r1,=0x11111111</span>&#13;
<span>   0x0001007c &lt;+8&gt;:    ldr     r1, [pc, #52]   ; 0x100b8 &lt;adr_mem+4&gt;</span></pre>&#13;
			<p lang="en-GB">The instruction requires a 32-bit literal, <strong class="source-inline">0x11111111</strong>, and that cannot be loaded as such. The compiler converts the instruction to a program counter-relative load from memory. The address is the current program counter, <strong class="source-inline">0x0001007c</strong>, plus the offset of <strong class="source-inline">52</strong> or <strong class="source-inline">0x44</strong>, plus the ARM PC’s 8-byte lead. At that target address, you will find the <strong class="source-inline">0x11111111</strong> <span class="No-Break">constant stored.</span></p>&#13;
			<p lang="en-GB"><em class="italic">Instruction 12</em> uses a similar pseudo-instruction. In this case, it’s to <a id="_idIndexMarker707"/>get the address in memory for the store multiple registers <span class="No-Break">to use:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>12                   ldr     r0,adr_mem      <span class="sc-comment">@ Load pointer r0 with memory</span></span>&#13;
<span>   0x00010090 &lt;+28&gt;: ldr     r0, [pc, #28]   <span class="sc-comment">@ 0x100b4 &lt;adr_mem&gt;</span></span></pre>&#13;
			<p lang="en-GB">The code ends with <strong class="source-inline">svc</strong>, followed by the comment “<em class="italic">undefined</em>.” That’s because the disassembler tried to disassemble the data in memory, and it did not apply to a <span class="No-Break">valid instruction.</span></p>&#13;
			<h2 id="_idParaDest-200" lang="en-GB"><a id="_idTextAnchor216"/>Block moves and stack operations</h2>&#13;
			<p lang="en-GB"><span class="No-Break"><em class="italic">Figure 12</em></span><em class="italic">.2</em> to <span class="No-Break"><em class="italic">Figure 12</em></span><em class="italic">.5</em> show the four variations of block move instructions in terms of the stack type. Recall that, in this text, I use only a <em class="italic">full descending</em> full stack mode, where the stack pointer points at the top of the stack and is decremented before a new <a id="_idIndexMarker708"/>item is added. The differences between these modes are the direction in which the stack grows (up or ascending and down or descending) and depend on whether the stack pointer points at the item at the top of the stack or the next free item on it. ARM’s literature uses four terms to <span class="No-Break">describe stacks:</span></p>&#13;
			<ul>&#13;
				<li lang="en-GB">FD<span class="CharOverride-1">    </span>Full descending<span class="CharOverride-1">     </span><span class="sc-comment CharOverride-2"> </span><span class="No-Break"><em class="italic">Figure 12</em></span><span class="No-Break"><em class="italic">.2</em></span></li>&#13;
				<li lang="en-GB">FA<span class="CharOverride-1">    </span><span class="sc-comment CharOverride-2"> </span>Full ascending<span class="CharOverride-1">      </span><span class="No-Break"><em class="italic">Figure 12</em></span><span class="No-Break"><em class="italic">.3</em></span></li>&#13;
				<li lang="en-GB">ED<span class="CharOverride-1">    </span>Empty descending<span class="CharOverride-1">   </span><span class="No-Break"><em class="italic">Figure 12</em></span><span class="No-Break"><em class="italic">.4</em></span></li>&#13;
				<li lang="en-GB">EA<span class="CharOverride-1">    </span>Empty ascending<span class="CharOverride-1">    </span><span class="No-Break"><em class="italic">Figure 12</em></span><span class="No-Break"><em class="italic">.5</em></span></li>&#13;
			</ul>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">Block moves improve the performance of code by loading or storing several registers with one instruction. They are also frequently used to save registers, before calling a subroutine and then restoring them after a return from it, as the following example demonstrates. In what follows, SP is the stack pointer – that is, <strong class="source-inline">r13</strong> (you can write either <strong class="source-inline">r13</strong> or sp in the ARM <span class="No-Break">assembly language).</span></p>&#13;
			<p lang="en-GB">When used by load operations, the suffix is <em class="italic">increment after</em>. When used by store operations, the suffix is <span class="No-Break"><em class="italic">decrement before</em></span><span class="No-Break">.</span></p>&#13;
			<div class="_idGenObjectLayout-1">&#13;
				<div id="_idContainer090" class="IMG---Figure">&#13;
					<img class="_idGenObjectAttribute-1" src="Images/Figure_12.03_B19624.jpg" alt="Figure 12.2 – One of ARM’s four stack modes – full descending (FD, IA load, and DB store)" width="1120" height="546"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.2 – One of ARM’s four stack modes – full descending (FD, IA load, and DB store)</p>&#13;
			<p lang="en-GB">In a full descending stack, the stack pointer points at the item at the top of the stack (full), and when an item is added to the stack, the stack pointer is <em class="italic">decremented before</em> and when an item is removed, the stack is <span class="No-Break"><em class="italic">incremented after</em></span><span class="No-Break">.</span></p>&#13;
			<p lang="en-GB">Consequently, we have <span class="No-Break">the following:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span><span class="sc-comment">Push r0 to r3 on the stack</span>    stm<strong class="bold">fd</strong> sp!,{r0-r3}     <span class="sc-comment">or</span>    stm<strong class="bold">db</strong> sp!,{r0-r3}</span>&#13;
<span><span class="sc-comment">Pull r0 to r3 off the stack</span>    <span class="sc-comment">  </span>ldm<strong class="bold">fd</strong> sp!,{r0-r3}     <span class="sc-comment">or</span>    ldm<strong class="bold">ia</strong> sp!,{r0-r3}</span></pre>&#13;
			<p lang="en-GB">As you can see, we can describe the <a id="_idIndexMarker709"/>instruction by either what it does (<strong class="source-inline">db</strong> or <strong class="source-inline">ia</strong>) or the type of stack (<strong class="source-inline">fd</strong>). It is rather unusual for assembly language designers to provide such options, and this is, initially, a <span class="No-Break">little confusing.</span></p>&#13;
			<div class="_idGenObjectLayout-1">&#13;
				<div id="_idContainer091" class="IMG---Figure">&#13;
					<img class="_idGenObjectAttribute-1" src="Images/Figure_12.04_B19624.jpg" alt="Figure 12.3 – One of ARM’s four stack modes – full ascending (FA, DA load, and IB store)" width="1183" height="532"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="IMG---Caption">Figure 12.3 – One of ARM’s four stack modes – full ascending (FA, DA load, and IB store)</p>&#13;
			<p lang="en-GB">In a full ascending stack, the stack pointer points at the item at the top of the stack (full), and when an item is added to the stack, the stack pointer is <em class="italic">incremented before</em>. When an item is removed, the stack is <span class="No-Break"><em class="italic">decremented after</em></span><span class="No-Break">.</span></p>&#13;
			<p lang="en-GB">Consequently, we have <span class="No-Break">the following:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span><span class="sc-comment">Push r0 to r3 on the stack</span>    stm<strong class="bold">fa</strong> sp!,{r0-r3}     <span class="sc-comment">or</span>    stm<strong class="bold">ib</strong> sp!,{r0-r3}</span>&#13;
<span><span class="sc-comment">Pull r0 to r3 off the stack</span>    <span class="sc-comment">  </span>ldm<strong class="bold">fa</strong> sp!,{r0-r3}     <span class="sc-comment">or</span>    ldm<strong class="bold">da</strong> sp!,{r0-r3}</span></pre>&#13;
			<div class="_idGenObjectLayout-1">&#13;
				<div id="_idContainer092" class="IMG---Figure">&#13;
					<img class="_idGenObjectAttribute-1" src="Images/Figure_12.05_B19624.jpg" alt="Figure 12.4 – One of ARM’s four stack modes – empty descending (ED, IB load, and DA store)" width="1132" height="575"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figur<a id="_idTextAnchor217"/>e 12.4 – One of ARM’s four stack modes – empty descending (ED, IB load, and DA store)</p>&#13;
			<p lang="en-GB">In an empty descending stack, the stack <a id="_idIndexMarker710"/>pointer points at the item above the top of the stack (empty), and when an item is added to the stack, the stack pointer is incremented after. When an item is removed, the stack is decremented before. Consequently, we have <span class="No-Break">the following:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span><span class="sc-comment">Push r0 to r3 on the stack</span>    stm<strong class="bold">ea</strong> sp!,{r0-r3}     <span class="sc-comment">or</span>    stm<strong class="bold">ia</strong> sp!,{r0-r3}</span>&#13;
<span><span class="sc-comment">Pull r0 to r3 off the stack</span>    <span class="sc-comment">  </span>ldm<strong class="bold">ea</strong> sp!,{r0-r3}     <span class="sc-comment">or</span>    ldm<strong class="bold">db</strong> sp!,{r0-r3}</span></pre>&#13;
			<div class="_idGenObjectLayout-1">&#13;
				<div id="_idContainer093" class="IMG---Figure">&#13;
					<img class="_idGenObjectAttribute-1" src="Images/Figure_12.06_B19624.jpg" alt="Figure 12.5 – One of ARM’s four stack modes – empty ascending (EA, DB load, and IA store)" width="1094" height="530"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="IMG---Caption">Figure 12.5 – One of ARM’s four stack modes – empty ascending (EA, DB load, and IA store)</p>&#13;
			<p lang="en-GB">We use the <strong class="source-inline">fd</strong> block move suffix to mean <em class="italic">full descending</em>. ARM lets you use two different naming conventions for block move instructions. You can write the pair <strong class="source-inline">stmia </strong>and <strong class="source-inline">ldmdb</strong>, or the pair <strong class="source-inline">stmfd</strong> and <strong class="source-inline">ldmfd</strong>; they are the same. Yes, it <span class="No-Break">is confusing:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>                                   <span class="sc-comment">@ Call abc and save some registers</span></span>&#13;
<span>       bl     abc                  <span class="sc-comment">@ Call subroutine abc, save return address in lr (r14)</span></span>&#13;
<span>       .</span>&#13;
<span>abc:   stm<strong class="bold">fd</strong>  sp!,<strong class="bold">{r0-r3,r8}</strong>       <span class="sc-comment">@ Subroutine abc. Block move saves registers on the stack</span></span>&#13;
<span>       .</span>&#13;
<span>       .                           <span class="sc-comment">@ Body of code</span></span>&#13;
<span>       .</span>&#13;
<span>       ldmfd  sp!,{r0-r3,r8}       <span class="sc-comment">@ Subroutine complete. Now restore the registers</span></span>&#13;
<span>       mov    pc,lr                <span class="sc-comment">@ Copy the return address in lr to the PC</span></span></pre>&#13;
			<p lang="en-GB">Since the program counter is also a user-visible register, we can simplify the code by including the PC as one of the registers <span class="No-Break">we save:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>abc:   stmfd  sp!,<strong class="bold">{r0-r3,r8,lr}</strong>    <span class="sc-comment">@ Save registers plus address in link register</span></span>&#13;
<span>        :</span>&#13;
<span>       ldmfd  <strong class="bold">sp!</strong>,{r0-r3,r8,pc}    <span class="sc-comment">@ Restore registers and transfer lr to PC</span></span></pre>&#13;
			<p lang="en-GB">The link register with the return address is pushed onto the stack, and then at the end, we pull the saved registers, including the value of the return address that is placed in the PC, <span class="No-Break">to return.</span></p>&#13;
			<p lang="en-GB">The block move provides a convenient <a id="_idIndexMarker711"/>means of copying data between memory regions. In the next example, we will copy 256 words from <strong class="source-inline">pqr</strong> to <strong class="source-inline">xyz</strong>. The block move instruction allows us to move eight registers at once, as the following <span class="No-Break">code illustrates:</span></p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<span>       adr    <strong class="bold">r0</strong>,pqr               <span class="sc-comment">@ r0 points to source (note the pseudo-op adr)</span></span>&#13;
<span>       adr    <strong class="bold">r1</strong>,xyz               <span class="sc-comment">@ r1 points to the destination</span></span>&#13;
<span>       mov    <strong class="bold">r2</strong>,#32               <span class="sc-comment">@ 32 blocks of eight words to move (256 words total)</span></span>&#13;
<span>Loop:  ldrfd  r0!,<strong class="bold">{r3-r10}</strong>         <span class="sc-comment">@ REPEAT Load 8 registers in r3 to r10</span></span>&#13;
<span>       strfd  <strong class="bold">r1!</strong>,{r3-r10          <span class="sc-comment">@ Store the registers (moving 8 words at once)</span></span>&#13;
<span>       subs   <strong class="bold">r2</strong>,r2,#1             <span class="sc-comment">@ Decrement loop counter</span></span>&#13;
<span>       bne    Loop                 <span class="sc-comment">@ Loop back until zero</span></span></pre>&#13;
			<p lang="en-GB">This ends the section on Raspberry Pi and the ARM assembly language. In this book, you have learned how a computer works and what it does. We’ve examined instructions sets, their encoding, and their execution. In the last four chapters, we looked at high-performance architecture with an <span class="No-Break">imaginative design.</span></p>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">Now, you should be able to write your <span class="No-Break">own programs.</span></p>&#13;
			<h1 id="_idParaDest-201" lang="en-GB">Summar<a id="_idTextAnchor218"/>y</h1>&#13;
			<p lang="en-GB">One of the key data structures in computing is the stack, or the LIFO queue. A stack is a queue with only one end – that is, new items enter at the same end as items leave. This single end is called the <strong class="bold">top of </strong><span class="No-Break"><strong class="bold">stack</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">TOS</strong></span><span class="No-Break">).</span></p>&#13;
			<p lang="en-GB">The stack is important because it enables the mechanization of many computing processes, ranging from dealing with arithmetic expressions to translating languages. Here, we are interested in the stack as a means of ensuring that subroutines are called and returned from in a consistent, efficient, and <span class="No-Break">fool-proof manner.</span></p>&#13;
			<p lang="en-GB">A subroutine is a piece of code that can be called (invoked) from any point in a program and a return made to the calling point. This action requires the management of return addresses, and the stack is eminently suitable because the sequence of return addresses is the inverse sequence of the calling addresses – that is, the same as the order of items pushed and pulled from <span class="No-Break">a stack.</span></p>&#13;
			<p lang="en-GB">We have looked at the ARM’s branch and link instruction, <strong class="source-inline">bl</strong>, that can be used to call a subroutine without the overhead of the stack. However, using the branch with link a second time overwrites the return address in the link register, and you then have to use a stack to preserve <span class="No-Break">previous addresses.</span></p>&#13;
			<p lang="en-GB">RISC computers, in principle, implement simple, one-cycle operations. The ARM has a very non-RISC like set of block-move instructions that allow you to move an entire group of instructions in a single operation. You can transfer up to 16 registers to or from memory in one operation. The block move lets you pass parameters to and from a subroutine via <span class="No-Break">the stack.</span></p>&#13;
			<p lang="en-GB">There are four standard stack implementations. The stack pointer can point either to the item at the top of the stack, or to the free space above that item. Similarly, the stack can grow (as items are added) toward low addresses or toward high addresses. This gives four possible arrangements. However, most computers implement a stack that points to the top item on it that grows toward <span class="No-Break">low addresses.</span></p>&#13;
			<p lang="en-GB">An unusual feature of the ARM’s literature is that it has two naming conventions for stack organization. One convention uses the type of stack (pointing at the top or the next free item) and direction of the stack, whereas the other convention describes whether the stack is incremented/decremented before or after the operation – for example, <strong class="source-inline">stm</strong><span class="pcode-bold">ia</span><strong class="source-inline"> r0!,{r2-r6}</strong> and <strong class="source-inline">stm</strong><span class="pcode-bold">ea</span><strong class="source-inline"> r0!,{r2-r6}</strong> are <span class="No-Break">identical operations.</span></p>&#13;
			<p lang="en-GB">In this book, we introduced the computer and demonstrated how it can be simulated with Python. By the end of <a href="B19624_08.xhtml#_idTextAnchor135"><span class="No-Break"><em class="italic">Chapter 8</em></span></a>, you should be able to design and simulate a computer instruction set, created to your <span class="No-Break">own specification.</span></p>&#13;
			<p lang="en-GB">Following the design of a hypothetical teaching computer, we looked at Raspberry Pi and the ARM microprocessor at its heart. This provides an introduction to real computers. We described the ARM’s instruction set architecture, explained how it operates, and explained how to write ARM assembly language programs and debug them on <span class="No-Break">Raspberry Pi.</span></p>&#13;
			<p lang="en-GB">Having reached the end of this book, you might like to consider designing your own <span class="No-Break">ARM simulator.</span></p>&#13;
			<p lang="en-GB">Finally, we wil provide some appendices to enable you to find some of the pieces of information you will need <span class="No-Break">most frequently.</span></p>&#13;
		</div>&#13;
	</div></body></html>