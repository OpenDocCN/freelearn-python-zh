<html><head></head><body><div><p>&#13;
			<h1 id="_idParaDest-193" class="chapter-number" lang="en-GB"><a id="_idTextAnchor209"/>12</h1>&#13;
			<h1 id="_idParaDest-194" lang="en-GB"><a id="_idTextAnchor210"/>Subroutines and the Stack</h1>&#13;
			<p lang="en-GB">A subroutine is a piece of code that is called from a point within a program and executed, and then a return is made to the instruction after the calling point. All computers use subroutines, but some computers provide a programmer with more facilities to implement subroutines than others.</p>&#13;
			<p lang="en-GB">In this chapter, we will look at the ARM’s subroutine handling mechanisms – in particular, the following:</p>&#13;
			<ul>&#13;
				<li lang="en-GB">The special branch and link instruction</li>&#13;
				<li lang="en-GB">The stack</li>&#13;
				<li lang="en-GB">A subroutine call and return</li>&#13;
				<li lang="en-GB">Block move instructions</li>&#13;
			</ul>&#13;
			<h1 id="_idParaDest-195" lang="en-GB"><a id="_idTextAnchor211"/>The Branch with link instruction</h1>&#13;
			<p lang="en-GB">First, we discuss the ARM’s <em class="italic">branch and link</em> instruction, <code>bl</code>, which provides a quick and easy way to call a subroutine without using a stack mechanism.</p>&#13;
			<p lang="en-GB">There are two basic ways of implementing <a id="_idIndexMarker687"/>subroutine calls and returns. The classic <a id="_idIndexMarker688"/>CISC approach is <code>BSR</code> (branch to subroutine) and <code>RTS</code> (return from subroutine). The typical <a id="_idIndexMarker689"/>code might be as follows:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
      bsr abc    @ Call the subroutine on the line labeled abc&#13;
      . . .&#13;
      . . .&#13;
abc:  . . .      @ Subroutine abc entry point&#13;
      . . .&#13;
      rts        @ Subroutine abc return to calling point</pre>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">This is simplicity in action. You call a piece of code, execute it, and return to the instruction after the calling point. Most RISC processors reject this mechanism because the subroutine call and return are complex instructions that save the return address on the stack during a call, and then pull the return address off the stack during a return. This is very convenient for a programmer but requires several CPU clock cycles to execute, and it does not fit into the one-cycle-per-instruction paradigm of the RISC processor.</p>&#13;
			<p lang="en-GB">The great advantage of the stack-based subroutine call/return is that you can nest subroutines and call subroutines from other subroutines, and the stack mechanism automatically deals with return addresses.</p>&#13;
			<p lang="en-GB">You will soon see that you can implement this mechanism yourself on an ARM, but not by using two dedicated instructions. You have to write your own code.</p>&#13;
			<p lang="en-GB">If you want a simple subroutine call and return (the subroutine is called a <em class="italic">leaf</em>), all you need to do is save the return address in a register (no external memory or stack is required). Then, to return, you just put the return address in the program counter – simple and fast. However, once you are in the subroutine, you can’t do the same thing again and call another subroutine. Doing that would destroy your existing saved return address.</p>&#13;
			<p lang="en-GB">The ARM’s subroutine mechanism is called <em class="italic">branch with link</em> and has the mnemonic <code>bl target</code>, where <code>target</code> is the symbolic address of the subroutine. The actual address is program counter-relative and is a 24-bit signed word that gives you a branch range of 223 words from the current PC. The range is 223 words in either direction from the PC (i.e., branch forward and branch back).</p>&#13;
			<p lang="en-GB">The branch with link instruction <a id="_idIndexMarker690"/>behaves like a branch instruction, but it also copies the return address (i.e., the address of the next instruction to be executed following a return into the link register <code>r14</code>. Let’s say you execute the following:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
        bl     sub_A          @ Branch to sub_A with link and save return address in r14</pre>&#13;
			<p lang="en-GB">The ARM executes a branch to the target address specified by the label <code>sub_A</code>. It also copies the program counter, held in register <code>r15</code>, into the link register <code>r14</code> to preserve the return address. At the end of the subroutine, you return by transferring the return address in <code>r14</code> to the program counter. You don’t need a special return instruction; you just write the following:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
        mov    <strong class="bold">pc</strong>,lr          @ We can also write this as mov r15,r14</pre>&#13;
			<p lang="en-GB">Let’s look at a simple example of the use of a subroutine. Suppose that you need to evaluate the <code>if x &gt; 0 then</code> <code>x = 16x + 1 else x = 32x</code> function several times in a program. Assuming that the x parameter is in register <code>r0</code>, we can write the following subroutine:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
Func1:  cmp    r0,#0          @ Test for x &gt; 0&#13;
        mov<strong class="bold">gt</strong>  <strong class="bold">r0</strong>,r0, lsl #4  @ If x &gt; 0 then x = 16x&#13;
        add<strong class="bold">gt</strong>  <strong class="bold">r0</strong>,r0,#1       @ If x &gt; 0 then x = 16x + 1&#13;
        mov<strong class="bold">le</strong>  <strong class="bold">r0</strong>,r0, lsl #5  @ ELSE if x &lt; 0 THEN x = 32x&#13;
        mov    <strong class="bold">pc</strong>,lr          @ Return by restoring saved PC</pre>&#13;
			<p lang="en-GB">All you need to create a subroutine is an entry point (the label <code>Func1</code>) and a return point that restores the saved address by bl in the link register.</p>&#13;
			<h2 id="_idParaDest-196" lang="en-GB"><a id="_idTextAnchor212"/>The stack</h2>&#13;
			<p lang="en-GB">We’ve already described <a id="_idIndexMarker691"/>the stack. We’ll go over it again here because it’s probably the single most important data structure in computing. The stack is a pile that you add things on at the top and take things off, also from the top. If you take something off the stack, it is the last thing that was added to the stack. Consequently, the stack is called a <strong class="bold">last in first out queue</strong> (<strong class="bold">LIFO</strong>), in which <a id="_idIndexMarker692"/>items enter at one end and leave in the reverse order.</p>&#13;
			<p lang="en-GB">Computers implement stacks by using a pointer register to point at the top of the stack. The ARM uses <code>r13</code> as a stack pointer, or, to be precise, the ARM <em class="italic">mandates</em> the use of <code>r13</code> as a stack pointer. You can use <code>r0</code> to <code>r13</code> as a stack pointer if you wish. The use of <code>r13</code> is a <em class="italic">convention</em> designed to make code more readable and sharable.</p>&#13;
			<p lang="en-GB">There are four variations of the stack. They all do the same thing but are implemented differently. The ARM supports all four variations, but we’ll use only one <a id="_idIndexMarker693"/>here for the sake of simplicity. A stack is stored in memory, which has no up or down in the normal human sense. When items are added to the stack, they can be added to the next location with a lower address or the next location with a higher address. By convention, most stacks are implemented so that the next item is stored at the <em class="italic">lower address</em>. We say that the stack grows <em class="italic">up</em> toward <em class="italic">lower</em> addresses (that’s because we number lines in a book from top to bottom, with line one at the top).</p>&#13;
			<p lang="en-GB">The other variation in the arrangement of stacks is that the stack pointer can either point to the top item on the stack, TOS, or point to the next free item on that stack. I will cover stacks where the stack pointer points to the top item on the stack (again, this is the most common convention).</p>&#13;
			<p lang="en-GB"><em class="italic">Figure 12</em><em class="italic">.1</em> illustrates a stack used to save subroutine return addresses.</p>&#13;
			<div>&#13;
				<div>&#13;
					<img class="_idGenObjectAttribute-1" src="img/Figure_12.01_B19624.jpg" alt="Figure 12.1 – Using the stack to save a return address, N" width="1737" height="550"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.1 – Using the stack to save a return address, N</p>&#13;
			<p lang="en-GB">The stack pointer points at the top item on the stack, and when an item is added to the stack (pushed), the stack pointer is first decremented. When an item is removed from the stack, it is taken at the location indicated by the stack pointer, and the stack <a id="_idIndexMarker694"/>pointer is incremented (i.e., moved down). We can define the push and pull (pop) actions with relation to the <strong class="bold">stack pointer </strong>(<strong class="bold">SP</strong>) as follows:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
PUSH:    [SP]   ← [SP] – 4    @ Move stack pointer up one word (up toward lower addresses)&#13;
         [[SP]] ← data        @ Push data onto the stack. Push uses pre-decrementing.&#13;
PULL:    data  ← [[SP]]       @ Pull data off the stack by reading TOS</pre>&#13;
			<pre class="source-code">         [SP]  ← [SP] + 4     @ Move stack pointer down one word (pull uses post-incrementing)</pre>&#13;
			<p lang="en-GB">The stack pointer is decremented and incremented by four, since we follow the ARM convention that the memory is byte-addressed and stack items are one-word long (four bytes). The next section looks in greater detail at how a subroutine is called and an orderly return is made to the calling point.</p>&#13;
			<h1 id="_idParaDest-197" lang="en-GB"><a id="_idTextAnchor213"/>A subroutine call and return</h1>&#13;
			<p lang="en-GB">To call a subroutine, you push the return address on the stack. CISC processors implement a subroutine call with <code>bsr target</code>. Because the ARM lacks a subroutine <a id="_idIndexMarker695"/>call instruction, you can write the following ARM code. Remember that we are dealing with 32-bit word push and pulls, and the stack must be incremented or decremented by four. Remember that <code>r15</code> and <code>SP</code> and <code>r13</code> and <code>lr</code> are interchangeable terms in ARM literature:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
      sub  <strong class="bold">r13</strong>,r13,#4       @ Pre-decrement the stack pointer (r13 is used as the SP)&#13;
      str  r15,<strong class="bold">[r13]</strong>        @ Push the return address in r15 on the stack&#13;
      b    Target           @ Jump to the target address&#13;
        ...                 @ Return here</pre>&#13;
			<p lang="en-GB">There’s no ARM subroutine return instruction, so you implement one with the following:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
      ldr  <strong class="bold">r12</strong>,[r13],#+4    @ Get saved PC from stack and post-increment the stack pointer&#13;
      mov  <strong class="bold">r15</strong>,r12          @ Load PC with return address</pre>&#13;
			<p lang="en-GB">The following is a simple program that sets up a call and return using this mechanism. Note that we don’t set up the initial stack pointer. The ARM’s operating system does that:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
.section .text&#13;
.global _start&#13;
_start: mov  r0,#9          @ Dummy operation&#13;
        sub  sp,sp,#4       @ Decrement stack&#13;
        str  pc,[sp]        @ Save pc on stack&#13;
        b    target         @ Branch to subroutine "target"&#13;
        mov  r2,#0xFFFFFFFF @ Return here ... this is a marker&#13;
        nop                 @ Dummy operation&#13;
        mov  r7,#1          @ Set up exit code&#13;
        svc  0              @ Leave program&#13;
target: mov  r1,#0xFF       @ Subroutine ... dummy operation&#13;
        ldr  r12,[sp],#+4   @ Pull pc off the stack&#13;
        mov  r15,r12        @ Return</pre>&#13;
			<pre class="source-code">        .end</pre>&#13;
			<p lang="en-GB"><em class="italic">Figure 12</em><em class="italic">.2</em> demonstrates the output of the ARM simulator after running this code. We have included the disassembly window and the register windows. Note how the <code>mov </code>r2<code>,#0xFFFFFFFF</code> instruction has been transformed into the <code>mvn </code>r2<code>,#0</code> operation. Recall that <code>MVN</code><code>ldr r12,[sp],#+</code> has been renamed <code>pop {r12}</code>. This is equivalent to the pop stack operation (removing an item from the top of the stack).</p>&#13;
			<p lang="en-GB">Registers after <a id="_idIndexMarker696"/>execution of the code:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
Register group: general&#13;
r0             0x9                 9&#13;
r1             0xff                255&#13;
r2             0xffffffff          4294967295&#13;
r12            0x10064             65636&#13;
sp             0xbefff380          0xbefff380&#13;
lr             0x0                 0&#13;
pc             0x1006c             0x1006c &lt;_start+24&gt;</pre>&#13;
			<p lang="en-GB">The following is an execution of the code step by step. This is an example of a subroutine call and return:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
B+ 0x10054 &lt;_start&gt;        mov    r0, #9&#13;
   0x10058 &lt;_start+4&gt;      sub    sp, sp, #4&#13;
   0x1005c &lt;_start+8&gt;      str    pc, [sp]&#13;
   0x10060 &lt;_start+12&gt;     b      0x10074 &lt;target&gt;&#13;
   0x10064 &lt;_start+16&gt;     mvn    r2, #0&#13;
   0x10068 &lt;_start+20&gt;     nop                    ; (mov r0, r0)&#13;
  ^0x1006c &lt;_start+24&gt;     mov    r7, #1&#13;
   0x10070 &lt;_start+28&gt;     svc    0x00000000&#13;
   0x10074 &lt;target&gt;        mov    r1, #255        ; 0xff&#13;
   0x10078 &lt;target+4&gt;      pop    {r12}           ; (ldr r12, [sp], #4)&#13;
   0x1007c &lt;target+8&gt;      mov    pc, r12</pre>&#13;
			<p lang="en-GB">In the next section, we will look at <a id="_idIndexMarker697"/>one of the ARM’s most powerful and least RISC-like operations – the ability to move blocks of data between memory and multiple registers.</p>&#13;
			<h1 id="_idParaDest-198" lang="en-GB"><a id="_idTextAnchor214"/>Block move instructions</h1>&#13;
			<p lang="en-GB">In this section, we will learn <a id="_idIndexMarker698"/>how multiple registers can be moved. The fundamental concepts are as follows:</p>&#13;
			<ul>&#13;
				<li lang="en-GB">How to specify a group of registers</li>&#13;
				<li lang="en-GB">How to address memory</li>&#13;
				<li lang="en-GB">How to sequence the storage of registers</li>&#13;
				<li class="_idGenParaOverride-1" lang="en-GB">The different types of block moves</li>&#13;
			</ul>&#13;
			<p lang="en-GB">A great feature of some CISC processors was that you could push a group of registers on the stack in a single instruction. RISC processors generally don’t have such an instruction because it conflicts with the one-operation-per-cycle design constraint that’s at the heart of the RISC philosophy. Surprisingly, the ARM implements a block move instruction that lets you copy a group of registers to or from memory in one operation (i.e., an instruction). The following ARM code demonstrates how to load registers <code>r1</code>,<code>r2</code>,<code>r3</code>,<code>r5</code> from memory:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
    adr  <strong class="bold">r0</strong>,DataToGo    @ Load r0 with the address of the data area&#13;
    ldr  <strong class="bold">r1</strong>,[r0],#4     @ Load r1 with the word pointed at by r0 and update the pointer&#13;
    ldr  <strong class="bold">r2</strong>,[r0],#4     @ Load r2 with the word pointed at by r0 and update the pointer&#13;
    ldr  <strong class="bold">r3</strong>,[r0],#4     @ and so forth for the remaining registers r3 and r5…&#13;
    ldr  <strong class="bold">r5</strong>,[r0],#4</pre>&#13;
			<p lang="en-GB">ARM has a <em class="italic">block move to memory</em> instruction, <code>stm</code>, and a <em class="italic">block move from memory</em>, <code>ldm</code>, that copies groups of registers to and from memory. Block move instructions require a two-character suffix to describe how the data is accessed (e.g., <code>stm</code>ia or <code>ldm</code>db), as we shall see.</p>&#13;
			<p lang="en-GB">Conceptually, a block move is easy to understand because it is simply a <em class="italic">copy the contents of these registers to memory</em> operation, or vice versa. In practice, it is more complex. ARM provides a full set of options that determine how the move takes place – for example, whether the registers are moved from high-to-low or low-to-high memory addresses, or whether the memory <a id="_idIndexMarker699"/>pointer is updated before or after a transfer (just like a stack structure). In fact, block moves are just like the push and pull stack operations found on other computers.</p>&#13;
			<p lang="en-GB">Let’s move the contents of registers <code>r1</code>, <code>r2</code>, <code>r3</code>, and <code>r5</code> into sequential memory locations with <code>stm</code>:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
stmia  <strong class="bold">r0!</strong>,<strong class="bold">{r1-r3,r5}</strong>   @ Note block move syntax. The register list is in braces&#13;
                        @ r0! is the destination register with auto indexing&#13;
                        @ The register list is {r1-r3,r5} r1,r2,r3,r5</pre>&#13;
			<p lang="en-GB">This instruction copies registers <code>r1</code> to <code>r3</code>, and <code>r5</code> into sequential memory locations, using <code>r0</code> as a pointer register with auto-indexing (indicated by the <code>!</code> suffix). The ia suffix indicates that the index register <code>r0</code> is incremented <em class="italic">after</em> each transfer, with data transfer in order of <em class="italic">ascending</em> addresses. We’ll also see that this instruction can be written as <code>stm</code>fd (which is the same operation, but ARM provides two naming conventions for the same thing in their documentation).</p>&#13;
			<p lang="en-GB">Although ARM’s block move mode instructions have several variations, the lowest numbered register is always stored at the lowest address, followed by the next lowest numbered register at the next higher address, and so on (e.g., <code>r1</code>, then<code> r2</code>, <code>r3</code>, and <code>r5</code> in the preceding example).</p>&#13;
			<p lang="en-GB">Consider the following example of the block move. Because it’s a little more complicated than some instructions we’ve encountered, we will demonstrate its execution. I’ve included several features that are not strictly part of the demonstration but include features I use when experimenting. In particular, I use markers in both registers and memory so that I can follow debugging more easily. For example, in the memory block, I store the data words <code>0xFFFFFFFF</code> and <code>0xAAAAAAAA</code>. These serve no function other than to show me, at a glance, where my data area starts and stops when I debug memory. Similarly, I use values such as <code>0x11111111</code> as words to move from registers because I can easily follow them in debugging:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
           .text                       @ This is a code section&#13;
           .global _start              @ Define entry point for code execution&#13;
 _start:    nop                        @ nop = no operation and is a dummy instruction&#13;
           ldr    <strong class="bold">r0</strong>,=0xFFFFFFFF       @ Dummy values for testing&#13;
           ldr    <strong class="bold">r1</strong>,=0x11111111&#13;
           ldr    <strong class="bold">r2</strong>,=0x22222222&#13;
           ldr    <strong class="bold">r3</strong>,=0x33333333&#13;
           ldr    <strong class="bold">r4</strong>,=0x44444444&#13;
           ldr    <strong class="bold">r5</strong>,=0x55555555&#13;
           ldr    <strong class="bold">r0</strong>,adr_mem           @ Load pointer r0 with memory&#13;
           <strong class="bold">stmia</strong>  <strong class="bold">r0</strong>!,<strong class="bold">{r1-r3,r5}</strong>       @ Do a multiple load to memory&#13;
           mov    <strong class="bold">r10</strong>,r0               @ Save r0 in r10 (for debugging)&#13;
           <strong class="bold">ldmdb  r0!</strong>,{r6-r9}          @ Now load data from memory&#13;
           mov    <strong class="bold">r11</strong>,r0&#13;
           mov    <strong class="bold">r1</strong>,#1                @ Terminate command&#13;
           svc    0                    @ Call OS to leave&#13;
           .word  0xFFFFFFFF           @ A dummy value for testing&#13;
           .word  0xAAAAAAAA           @ Another dummy value&#13;
adr_mem:   .word  memory               @ The address of the memory for storing data&#13;
           .data                       @ Declare a memory segment for the data&#13;
memory:    .word  0xBBBBBBBB           @ Yet another memory marker&#13;
           .space 32                   @ Reserve space for storage (8 words)&#13;
           .word  0xCCCCCCCC           @ Final memory marker&#13;
           .end</pre>&#13;
			<p lang="en-GB">This code sets up five registers with data that is easily visible when examining memory. Thirty-two bytes of memory are saved between two word markers <a id="_idIndexMarker700"/>at the end of the program with the <code>.space</code> directive. The start of this block is labeled <code>memory</code>, and <code>r0</code> points to it. Then the five registers are stored in memory. Instructions that carry out the block store are shaded in light gray, and the data area is shaded in dark gray.</p>&#13;
			<p lang="en-GB">The code we are initially interested in is for the five register loads that preset registers <code>r1</code> to <code>r5</code> with <code>0x11111111</code> to <code>0x55555555</code>, respectively. Register <code>r0</code> was set initially to <code>0xFFFFFFFF</code> just as a marker for debugging. The key instruction is stmia r0!,{r1-r3,r5}, whose purpose is to store the contents of registers <code>r1</code>, <code>r2</code>, <code>r3</code>, and <code>r5</code> in consecutive memory locations pointed at by r0.</p>&#13;
			<p lang="en-GB">The following Raspberry Pi output is from the <code>gdb</code> debugger. The source code is <code>blockMove1.s</code>. We’ve omitted some of the register values to make the listing more readable when registers haven’t changed or haven’t been used. Similarly, repetitive command lines have been omitted:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
pi@raspberrypi:~/Desktop $ as -g -o blockMove1.o blockMove1.s&#13;
pi@raspberrypi:~/Desktop $ ld -o blockMove1 blockMove1.o&#13;
pi@raspberrypi:~/Desktop $ gdb blockMove1&#13;
(gdb) b 1&#13;
Breakpoint 1 at 0x10078: file blockMove1.s, line 6.&#13;
(gdb) r&#13;
Starting program: /home/pi/Desktop/blockMove1&#13;
Breakpoint 1, _start () at blockMove1.s:6&#13;
6               ldr    r0,=0xFFFFFFFF         @ Dummy value for testing&#13;
(gdb) i r&#13;
r0             0x0                 0          # These are the initial registers before we start&#13;
r1             0x0                 0&#13;
r2             0x0                 0&#13;
r3             0x0                 0&#13;
r4             0x0                 0&#13;
r5             0x0                 0&#13;
r6             0x0                 0&#13;
r7             0x0                 0&#13;
r8             0x0                 0&#13;
r9             0x0                 0&#13;
r10            0x0                 0&#13;
r11            0x0                 0&#13;
r12            0x0                 0&#13;
sp             0xbefff380          0xbefff380 # The OS sets up the stack pointer&#13;
lr             0x0                 0&#13;
pc             0x10078             0x10078 &lt;_start+4&gt;  # The OS sets up stack pointer</pre>&#13;
			<p lang="en-GB">Having looked at the registers, we will now proceed <a id="_idIndexMarker701"/>to execute a series of instructions. Note that we need to enter <code>si 1</code> once and then simply hit <em class="italic">Return</em> to repeat the operation:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
(gdb) si 1&#13;
7              ldr    r1,=0x11111111          # Here we trace seven instructions&#13;
8              ldr    r2,=0x22222222&#13;
9              ldr    r3,=0x33333333&#13;
10             ldr    r4,=0x44444444&#13;
11             ldr    r5,=0x55555555&#13;
12             ldr    r0,adr_mem              @ Load pointer r0 with memory&#13;
13             stmia  r0!,{r1-r3,r5}          @ Multiple load to memory&#13;
(gdb) i r&#13;
r0             0x200cc             131276</pre>&#13;
			<p lang="en-GB">Now, let’s look at the registers we set up. Only registers of interest have been displayed. Note that <code>r0</code> points to the data at <code>0x200CC</code>. The system software is responsible for this address:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
r1             0x11111111          286331153&#13;
r2             0x22222222          572662306&#13;
r3             0x33333333          858993459&#13;
r4             0x44444444          1145324612&#13;
r5             0x55555555          1431655765&#13;
r6             0x0                 0</pre>&#13;
			<p lang="en-GB">At this point, we’ve set up register <code>r0</code> as a pointer, and its value is <code>0x200cc</code>. This value has been determined by the assembler and loader. If you refer back to the source code, we used <code>ldr </code>r0<code>,adr</code>_mem to load <code>r0</code> via a pointer to the actual data stored in memory. This is because the software does not let us load a direct memory address.</p>&#13;
			<p lang="en-GB">You can see that the registers have been set up with their <em class="italic">easy-to-trace</em> values. The next step is to examine memory using the <code>x/16xw gdb</code> command to display 16 words of hexadecimal data:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
pc             0x10094             0x10094 &lt;_start+32&gt;&#13;
(gdb) x/16xw 0x200cc&#13;
0x200cc:    <strong class="bold">0xbbbbbbbb</strong>    0x00000000    0x00000000    0x00000000&#13;
0x200dc:    0x00000000    0x00000000    0x00000000    0x00000000&#13;
0x200ec:    0x00000000    <strong class="bold">0xcccccccc</strong>    0x00001141    0x61656100&#13;
0x200fc:    0x01006962    0x00000007    0x00000108    0x0000001c</pre>&#13;
			<p lang="en-GB">The two markers we’ve stored in memory are in bold font. Now, let’s execute the stored multiple registers. Before that, we will copy the pointer to <code>r10</code> (again, that is just for my own debugging purposes) so that we can see what it was before the move. After the block <a id="_idIndexMarker702"/>move instruction, we display registers of interest:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
(gdb) si 1&#13;
14               mov    r10,r0&#13;
15               ldmdb  r0!,{r6-r9}             @ Now load data from memory&#13;
(gdb) i r&#13;
r0             0x200dc             131292&#13;
r1             0x11111111          286331153&#13;
r2             0x22222222          572662306&#13;
r3             0x33333333          858993459&#13;
r4             0x44444444          1145324612&#13;
r5             0x55555555          1431655765&#13;
r6             0x0                 0&#13;
r10            0x200dc             131292&#13;
pc             0x1009c             0x1009c &lt;_start+40&gt;</pre>&#13;
			<p lang="en-GB">Now for the proof of the pudding. Here’s the memory after the <code>x/16xw</code> display command. Note that the contents of the four registers have been stored in consecutive rising memory locations:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
(gdb) x/16xw 0x200cc&#13;
0x200cc:    <strong class="bold">0x11111111    0x22222222    0x33333333    0x55555555</strong>&#13;
0x200dc:    0x00000000    0x00000000    0x00000000    0x00000000&#13;
0x200ec:    0x00000000    0xcccccccc    0x00001141    0x61656100</pre>&#13;
			<pre class="source-code">0x200fc:    0x01006962    0x00000007    0x00000108    0x0000001c</pre>&#13;
			<p lang="en-GB">Finally, we will execute the last two commands and display the register contents:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
(gdb) si 1&#13;
16               mov    r11,r0&#13;
18               mov    r1,#1      @ Terminate command&#13;
(gdb) i r&#13;
r0             0x200cc             131276&#13;
r1             0x11111111          286331153&#13;
r2             0x22222222          572662306&#13;
r3             0x33333333          858993459&#13;
r4             0x44444444          1145324612&#13;
r5             0x55555555          1431655765&#13;
<strong class="bold">r6             0x11111111          286331153</strong>       Data copied to registers r6 - r9&#13;
<strong class="bold">r7             0x22222222          572662306</strong>&#13;
<strong class="bold">r8             0x33333333          858993459</strong>&#13;
<strong class="bold">r9             0x55555555          1431655765</strong>&#13;
r10            0x200dc             131292</pre>&#13;
			<p lang="en-GB">You can see that the block move from the <code>ldmdb r0!,{r6-r9}</code> memory operation has copied the four registers from the memory and placed them in registers <code>r7</code> to <code>r9</code>.</p>&#13;
			<p lang="en-GB">Consider the suffix of ldm, which is db. Why <code>ldmdb</code>? When we transferred data to memory, we used the <em class="italic">increment after </em>suffix, where the pointer register is used <a id="_idIndexMarker703"/>to move the data to a memory location, and then it is incremented after the move. When we retrieve the data, we initially point at the location after the last value is moved. Consequently, to remove the items we stored in memory, we have to decrement the pointer before each move – hence the <em class="italic">decrement before </em>(<code>db</code>) suffix. For this reason, the instruction pair <code>stmia</code> and <code>ldmdb</code> correspond to the stack push and pull operations, respectively.</p>&#13;
			<h2 id="_idParaDest-199" lang="en-GB"><a id="_idTextAnchor215"/>Disassembling the code</h2>&#13;
			<p lang="en-GB">The following is a disassembly of the <a id="_idIndexMarker704"/>code for this program. It’s been edited and reformatted for easier viewing. Some instructions have two lines. One line is the <em class="italic">original </em>instruction, as presented in the program. The following line is the instruction as interpreted by the assembler. This demonstrates how pseudo instructions such as <code>ldr </code>r1<code>,=0x111111</code> are handled.</p>&#13;
			<p lang="en-GB">The lines in bold require some further explanation, as shown here:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
(gdb) disassemble /m&#13;
Dump of assembler code for function _start:&#13;
<strong class="bold">5 _start:            nop</strong>&#13;
<strong class="bold">   0x00010074 &lt;+0&gt;:  nop ;  (mov r0, r0)</strong>&#13;
<strong class="bold">6                    ldr     r0,=0xFFFFFFFF  </strong>@ Dummy value for testing&#13;
<strong class="bold">=&gt; 0x00010078 &lt;+4&gt;:  mvn     r0, #0</strong>&#13;
<strong class="bold">7                    ldr     r1,=0x11111111</strong>&#13;
<strong class="bold">   0x0001007c &lt;+8&gt;:  ldr     r1, [pc, #52]   ; 0x100b8 &lt;adr_mem+4&gt;</strong>&#13;
<strong class="bold">8                    ldr     r2,=0x22222222</strong>&#13;
<strong class="bold">   0x00010080 &lt;+12&gt;: </strong><strong class="bold">ldr     r2, [pc, #52]   ; 0x100bc &lt;adr_mem+8&gt;</strong>&#13;
9                    ldr     r3,=0x33333333&#13;
   0x00010084 &lt;+16&gt;: ldr     r3, [pc, #52]   ; 0x100c0 &lt;adr_m&#13;
10                   ldr     r4,=0x44444444&#13;
   0x00010088 &lt;+20&gt;: ldr     r4, [pc, #52]   ; 0x100c4 &lt;adr_mem+16&gt;&#13;
11                   ldr     r5,=0x55555555      &#13;
   0x0001008c &lt;+24&gt;: ldr     r5, [pc, #52]   ; 0x100c8 &lt;adr_mem+20&gt;&#13;
<strong class="bold">12                   ldr     r0,adr_mem      </strong>@ Load pointer r0 with memory&#13;
<strong class="bold">   0x00010090 &lt;+28&gt;: ldr     r0, [pc, #28]   </strong>; 0x100b4 &lt;adr_mem&gt;&#13;
13                   stmia   r0!,{r1-r3,r5}  @ Do a multiple load to memory&#13;
   0x00010094 &lt;+32&gt;: stmia   r0!, {r1,r2,r3,r5}&#13;
14                   mov     r10,r0&#13;
   0x00010098 &lt;+36&gt;: mov     r10, r0&#13;
15                   ldmdb   r0!,{r6-r9}     @ Now load data from memory&#13;
   0x0001009c &lt;+40&gt;: ldmdb   r0!, {r6,r7,r8,r9}&#13;
16                   mov     r11,r0&#13;
   0x000100a0 &lt;+44&gt;: mov     r11, r0&#13;
18                   mov     r1,#1           @ Terminate command&#13;
   0x000100a4 &lt;+48&gt;: mov     r1, #1&#13;
19                   svc     0               @ Call OS to leave  &#13;
   0x000100a8 &lt;+52&gt;: svc 0x00000000&#13;
<strong class="bold">   0x000100ac &lt;+56&gt;: ; &lt;UNDEFINED&gt; instruction: 0xffffffff</strong>&#13;
   0x000100b0 &lt;+60&gt;: bge 0xfeabab60&#13;
   0x000100b4 &lt;+0&gt;:  andeq r0, r2, r12, asr #1</pre>&#13;
			<p lang="en-GB">The following command uses x/32xw to display 32 consecutive words <a id="_idIndexMarker705"/>of memory in hexadecimal form so that we can observe what has happened in memory. Here’s where our use of markers such as 0xAAAAAAAA makes it easy to recognize where we are in memory.</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
<strong class="bold">(gdb) x/32xw 0x100a8</strong>                         This displays 32 words of memory&#13;
0x100a8 &lt;_start+52&gt;:  0xef000000 0xffffffff 0xaaaaaaaa <strong class="bold">0x000200cc</strong>&#13;
0x100b8 &lt;adr_mem+4&gt;:  0x11111111 0x22222222 0x33333333 0x44444444&#13;
0x100c8 &lt;adr_mem+20&gt;: 0x55555555 0xbbbbbbbb 0x00000000 0x00000000&#13;
0x100d8:              0x00000000 0x00000000 0x00000000 0x00000000&#13;
0x100e8:              0x00000000 0x00000000 0xcccccccc 0x00001141&#13;
0x100f8:              0x61656100 0x01006962 0x00000007 0x00000108&#13;
0x10108:              0x0000001c 0x00000002 0x00040000 0x00000000</pre>&#13;
			<pre class="source-code">0x10118:              0x00010074 0x00000058 0x00000000 0x00000000</pre>&#13;
			<p lang="en-GB"><em class="italic">Line 5</em> contains a <code>nop</code> instruction <a id="_idIndexMarker706"/>that does nothing (other than advance the PC to the next instruction). It can provide a placeholder for later code, or act as a debugging aid. Here, it provides a space for the first instruction to land on. The ARM lacks a <code>nop</code>, and the assembler translates <code>nop</code> to <code>mov r0,r0</code>. Like <code>nop</code>, this instruction achieves nothing!</p>&#13;
			<p lang="en-GB"><code>ldr </code>r0<code>,=0xFFFFFFFF</code> is interesting. The assembler uses ARM’s <code>mvn</code> to invert the bits of the operand before moving them. If the operand is <code>0</code>, the bits moved will be all <code>1</code>s, which is exactly what we want.</p>&#13;
			<p lang="en-GB">Instruction 7 demonstrates another pseudo-operation:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
7                      ldr      r1,=0x11111111&#13;
   0x0001007c &lt;+8&gt;:    ldr     r1, [pc, #52]   ; 0x100b8 &lt;adr_mem+4&gt;</pre>&#13;
			<p lang="en-GB">The instruction requires a 32-bit literal, <code>0x11111111</code>, and that cannot be loaded as such. The compiler converts the instruction to a program counter-relative load from memory. The address is the current program counter, <code>0x0001007c</code>, plus the offset of <code>52</code> or <code>0x44</code>, plus the ARM PC’s 8-byte lead. At that target address, you will find the <code>0x11111111</code> constant stored.</p>&#13;
			<p lang="en-GB"><em class="italic">Instruction 12</em> uses a similar pseudo-instruction. In this case, it’s to <a id="_idIndexMarker707"/>get the address in memory for the store multiple registers to use:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
12                   ldr     r0,adr_mem      @ Load pointer r0 with memory&#13;
   0x00010090 &lt;+28&gt;: ldr     r0, [pc, #28]   @ 0x100b4 &lt;adr_mem&gt;</pre>&#13;
			<p lang="en-GB">The code ends with <code>svc</code>, followed by the comment “<em class="italic">undefined</em>.” That’s because the disassembler tried to disassemble the data in memory, and it did not apply to a valid instruction.</p>&#13;
			<h2 id="_idParaDest-200" lang="en-GB"><a id="_idTextAnchor216"/>Block moves and stack operations</h2>&#13;
			<p lang="en-GB"><em class="italic">Figure 12</em><em class="italic">.2</em> to <em class="italic">Figure 12</em><em class="italic">.5</em> show the four variations of block move instructions in terms of the stack type. Recall that, in this text, I use only a <em class="italic">full descending</em> full stack mode, where the stack pointer points at the top of the stack and is decremented before a new <a id="_idIndexMarker708"/>item is added. The differences between these modes are the direction in which the stack grows (up or ascending and down or descending) and depend on whether the stack pointer points at the item at the top of the stack or the next free item on it. ARM’s literature uses four terms to describe stacks:</p>&#13;
			<ul>&#13;
				<li lang="en-GB">FD    Full descending      <em class="italic">Figure 12</em><em class="italic">.2</em></li>&#13;
				<li lang="en-GB">FA     Full ascending      <em class="italic">Figure 12</em><em class="italic">.3</em></li>&#13;
				<li lang="en-GB">ED    Empty descending   <em class="italic">Figure 12</em><em class="italic">.4</em></li>&#13;
				<li lang="en-GB">EA    Empty ascending    <em class="italic">Figure 12</em><em class="italic">.5</em></li>&#13;
			</ul>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">Block moves improve the performance of code by loading or storing several registers with one instruction. They are also frequently used to save registers, before calling a subroutine and then restoring them after a return from it, as the following example demonstrates. In what follows, SP is the stack pointer – that is, <code>r13</code> (you can write either <code>r13</code> or sp in the ARM assembly language).</p>&#13;
			<p lang="en-GB">When used by load operations, the suffix is <em class="italic">increment after</em>. When used by store operations, the suffix is <em class="italic">decrement before</em>.</p>&#13;
			<p>&#13;
				<div>&#13;
					<img class="_idGenObjectAttribute-1" src="img/Figure_12.03_B19624.jpg" alt="Figure 12.2 – One of ARM’s four stack modes – full descending (FD, IA load, and DB store)" width="1120" height="546"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.2 – One of ARM’s four stack modes – full descending (FD, IA load, and DB store)</p>&#13;
			<p lang="en-GB">In a full descending stack, the stack pointer points at the item at the top of the stack (full), and when an item is added to the stack, the stack pointer is <em class="italic">decremented before</em> and when an item is removed, the stack is <em class="italic">incremented after</em>.</p>&#13;
			<p lang="en-GB">Consequently, we have the following:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
Push r0 to r3 on the stack    stm<strong class="bold">fd</strong> sp!,{r0-r3}     or    stm<strong class="bold">db</strong> sp!,{r0-r3}&#13;
Pull r0 to r3 off the stack      ldm<strong class="bold">fd</strong> sp!,{r0-r3}     or    ldm<strong class="bold">ia</strong> sp!,{r0-r3}</pre>&#13;
			<p lang="en-GB">As you can see, we can describe the <a id="_idIndexMarker709"/>instruction by either what it does (<code>db</code> or <code>ia</code>) or the type of stack (<code>fd</code>). It is rather unusual for assembly language designers to provide such options, and this is, initially, a little confusing.</p>&#13;
			<p>&#13;
				<div>&#13;
					<img class="_idGenObjectAttribute-1" src="img/Figure_12.04_B19624.jpg" alt="Figure 12.3 – One of ARM’s four stack modes – full ascending (FA, DA load, and IB store)" width="1183" height="532"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="IMG---Caption">Figure 12.3 – One of ARM’s four stack modes – full ascending (FA, DA load, and IB store)</p>&#13;
			<p lang="en-GB">In a full ascending stack, the stack pointer points at the item at the top of the stack (full), and when an item is added to the stack, the stack pointer is <em class="italic">incremented before</em>. When an item is removed, the stack is <em class="italic">decremented after</em>.</p>&#13;
			<p lang="en-GB">Consequently, we have the following:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
Push r0 to r3 on the stack    stm<strong class="bold">fa</strong> sp!,{r0-r3}     or    stm<strong class="bold">ib</strong> sp!,{r0-r3}&#13;
Pull r0 to r3 off the stack      ldm<strong class="bold">fa</strong> sp!,{r0-r3}     or    ldm<strong class="bold">da</strong> sp!,{r0-r3}</pre>&#13;
			<p>&#13;
				<div>&#13;
					<img class="_idGenObjectAttribute-1" src="img/Figure_12.05_B19624.jpg" alt="Figure 12.4 – One of ARM’s four stack modes – empty descending (ED, IB load, and DA store)" width="1132" height="575"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figur<a id="_idTextAnchor217"/>e 12.4 – One of ARM’s four stack modes – empty descending (ED, IB load, and DA store)</p>&#13;
			<p lang="en-GB">In an empty descending stack, the stack <a id="_idIndexMarker710"/>pointer points at the item above the top of the stack (empty), and when an item is added to the stack, the stack pointer is incremented after. When an item is removed, the stack is decremented before. Consequently, we have the following:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
Push r0 to r3 on the stack    stm<strong class="bold">ea</strong> sp!,{r0-r3}     or    stm<strong class="bold">ia</strong> sp!,{r0-r3}&#13;
Pull r0 to r3 off the stack      ldm<strong class="bold">ea</strong> sp!,{r0-r3}     or    ldm<strong class="bold">db</strong> sp!,{r0-r3}</pre>&#13;
			<p>&#13;
				<div>&#13;
					<img class="_idGenObjectAttribute-1" src="img/Figure_12.06_B19624.jpg" alt="Figure 12.5 – One of ARM’s four stack modes – empty ascending (EA, DB load, and IA store)" width="1094" height="530"/>&#13;
				</p>&#13;
			</div>&#13;
			<p class="IMG---Caption">Figure 12.5 – One of ARM’s four stack modes – empty ascending (EA, DB load, and IA store)</p>&#13;
			<p lang="en-GB">We use the <code>fd</code> block move suffix to mean <em class="italic">full descending</em>. ARM lets you use two different naming conventions for block move instructions. You can write the pair <code>stmia </code>and <code>ldmdb</code>, or the pair <code>stmfd</code> and <code>ldmfd</code>; they are the same. Yes, it is confusing:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
                                   @ Call abc and save some registers&#13;
       bl     abc                  @ Call subroutine abc, save return address in lr (r14)&#13;
       .&#13;
abc:   stm<strong class="bold">fd</strong>  sp!,<strong class="bold">{r0-r3,r8}</strong>       @ Subroutine abc. Block move saves registers on the stack&#13;
       .&#13;
       .                           @ Body of code&#13;
       .&#13;
       ldmfd  sp!,{r0-r3,r8}       @ Subroutine complete. Now restore the registers&#13;
       mov    pc,lr                @ Copy the return address in lr to the PC</pre>&#13;
			<p lang="en-GB">Since the program counter is also a user-visible register, we can simplify the code by including the PC as one of the registers we save:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
abc:   stmfd  sp!,<strong class="bold">{r0-r3,r8,lr}</strong>    @ Save registers plus address in link register&#13;
        :&#13;
       ldmfd  <strong class="bold">sp!</strong>,{r0-r3,r8,pc}    @ Restore registers and transfer lr to PC</pre>&#13;
			<p lang="en-GB">The link register with the return address is pushed onto the stack, and then at the end, we pull the saved registers, including the value of the return address that is placed in the PC, to return.</p>&#13;
			<p lang="en-GB">The block move provides a convenient <a id="_idIndexMarker711"/>means of copying data between memory regions. In the next example, we will copy 256 words from <code>pqr</code> to <code>xyz</code>. The block move instruction allows us to move eight registers at once, as the following code illustrates:</p>&#13;
			<pre class="source-code" lang="en-GB">&#13;
       adr    <strong class="bold">r0</strong>,pqr               @ r0 points to source (note the pseudo-op adr)&#13;
       adr    <strong class="bold">r1</strong>,xyz               @ r1 points to the destination&#13;
       mov    <strong class="bold">r2</strong>,#32               @ 32 blocks of eight words to move (256 words total)&#13;
Loop:  ldrfd  r0!,<strong class="bold">{r3-r10}</strong>         @ REPEAT Load 8 registers in r3 to r10&#13;
       strfd  <strong class="bold">r1!</strong>,{r3-r10          @ Store the registers (moving 8 words at once)&#13;
       subs   <strong class="bold">r2</strong>,r2,#1             @ Decrement loop counter&#13;
       bne    Loop                 @ Loop back until zero</pre>&#13;
			<p lang="en-GB">This ends the section on Raspberry Pi and the ARM assembly language. In this book, you have learned how a computer works and what it does. We’ve examined instructions sets, their encoding, and their execution. In the last four chapters, we looked at high-performance architecture with an imaginative design.</p>&#13;
			<p class="_idGenParaOverride-1" lang="en-GB">Now, you should be able to write your own programs.</p>&#13;
			<h1 id="_idParaDest-201" lang="en-GB">Summar<a id="_idTextAnchor218"/>y</h1>&#13;
			<p lang="en-GB">One of the key data structures in computing is the stack, or the LIFO queue. A stack is a queue with only one end – that is, new items enter at the same end as items leave. This single end is called the <strong class="bold">top of </strong><strong class="bold">stack</strong> (<strong class="bold">TOS</strong>).</p>&#13;
			<p lang="en-GB">The stack is important because it enables the mechanization of many computing processes, ranging from dealing with arithmetic expressions to translating languages. Here, we are interested in the stack as a means of ensuring that subroutines are called and returned from in a consistent, efficient, and fool-proof manner.</p>&#13;
			<p lang="en-GB">A subroutine is a piece of code that can be called (invoked) from any point in a program and a return made to the calling point. This action requires the management of return addresses, and the stack is eminently suitable because the sequence of return addresses is the inverse sequence of the calling addresses – that is, the same as the order of items pushed and pulled from a stack.</p>&#13;
			<p lang="en-GB">We have looked at the ARM’s branch and link instruction, <code>bl</code>, that can be used to call a subroutine without the overhead of the stack. However, using the branch with link a second time overwrites the return address in the link register, and you then have to use a stack to preserve previous addresses.</p>&#13;
			<p lang="en-GB">RISC computers, in principle, implement simple, one-cycle operations. The ARM has a very non-RISC like set of block-move instructions that allow you to move an entire group of instructions in a single operation. You can transfer up to 16 registers to or from memory in one operation. The block move lets you pass parameters to and from a subroutine via the stack.</p>&#13;
			<p lang="en-GB">There are four standard stack implementations. The stack pointer can point either to the item at the top of the stack, or to the free space above that item. Similarly, the stack can grow (as items are added) toward low addresses or toward high addresses. This gives four possible arrangements. However, most computers implement a stack that points to the top item on it that grows toward low addresses.</p>&#13;
			<p lang="en-GB">An unusual feature of the ARM’s literature is that it has two naming conventions for stack organization. One convention uses the type of stack (pointing at the top or the next free item) and direction of the stack, whereas the other convention describes whether the stack is incremented/decremented before or after the operation – for example, <code>stm</code>ia<code> r0!,{r2-r6}</code> and <code>stm</code>ea<code> r0!,{r2-r6}</code> are identical operations.</p>&#13;
			<p lang="en-GB">In this book, we introduced the computer and demonstrated how it can be simulated with Python. By the end of <a href="B19624_08.xhtml#_idTextAnchor135"><em class="italic">Chapter 8</em></a>, you should be able to design and simulate a computer instruction set, created to your own specification.</p>&#13;
			<p lang="en-GB">Following the design of a hypothetical teaching computer, we looked at Raspberry Pi and the ARM microprocessor at its heart. This provides an introduction to real computers. We described the ARM’s instruction set architecture, explained how it operates, and explained how to write ARM assembly language programs and debug them on Raspberry Pi.</p>&#13;
			<p lang="en-GB">Having reached the end of this book, you might like to consider designing your own ARM simulator.</p>&#13;
			<p lang="en-GB">Finally, we wil provide some appendices to enable you to find some of the pieces of information you will need most frequently.</p>&#13;
		</div>&#13;
	</div></body></html>