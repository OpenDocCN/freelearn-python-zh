- en: Chapter 3. Going Visual – GUIs to Help Understand Profiler Output
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。可视化——用于理解性能分析器输出的GUI
- en: Although we already covered profiling in the previous chapter, the process we
    went through was like walking in the dark, or at least, in a place with very little
    light. We kept looking at numbers. Basically, we kept trying to decrease the number
    of hits, number of seconds, or other similar numbers. However, it was hard to
    understand how those numbers related to each other based on the representation
    we had of them.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们在上一章已经介绍了性能分析，但我们所经历的过程就像在黑暗中行走，或者至少是在光线非常微弱的地方。我们一直在看数字。基本上，我们一直在尝试减少命中次数、秒数或其他类似的数字。然而，根据我们所拥有的表示，很难理解这些数字之间的关系。
- en: We couldn't easily see the big blueprint of our system, based off of that output.
    If our systems would've been even bigger, seeing that blueprint would've been
    even harder.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 基于该输出，我们无法轻易地看到我们系统的整体蓝图。如果我们的系统更大，那么看到这个蓝图将会更加困难。
- en: Simply because we're human beings and not computers ourselves, we work better
    when we have some sort of visual aid. In this particular case, our work would
    benefit if we could better understand how everything is related. To do this, we
    have tools that provide visual representations of the numbers we saw in the previous
    chapter. These tools will provide us with much needed help. In turn, we'll be
    able to locate and fix the bottlenecks of our systems much faster. As an added
    bonus, we'll have a better understanding of our system.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 简单地因为我们是人类，而不是计算机本身，所以我们有某种视觉辅助时工作得更好。在这种情况下，如果我们能更好地理解一切是如何相互关联的，我们的工作将受益匪浅。为此，我们有工具可以提供我们在上一章看到的数字的视觉表示。这些工具将为我们提供急需的帮助。反过来，我们将能够更快地定位和修复我们系统的瓶颈。作为额外的奖励，我们将更好地理解我们的系统。
- en: 'In this chapter, we''ll cover two tools that fall into this category:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍属于这一类别的两个工具：
- en: '**KCacheGrind / pyprof2calltree**: This combo will provide the ability to transform
    the output of `cProfile` into the format required by KCacheGrind, which in turn
    will help us visualize the information.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**KCacheGrind / pyprof2calltree**: 这个组合将使我们能够将`cProfile`的输出转换为KCacheGrind所需的格式，这反过来将帮助我们可视化信息。'
- en: '**RunSnakeRun** ([http://www.vrplumber.com/programming/runsnakerun/](http://www.vrplumber.com/programming/runsnakerun/)):
    This tool will also allow us to visualize and analyze the output from `cProfile`.
    It provides square maps and sortable lists to help us in our task.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RunSnakeRun** ([http://www.vrplumber.com/programming/runsnakerun/](http://www.vrplumber.com/programming/runsnakerun/)):
    此工具将使我们能够可视化和分析`cProfile`的输出。它提供了方格图和可排序的列表，以帮助我们完成任务。'
- en: For each one, we'll go over the basics of installation and UI explanation. Then,
    we'll grab the examples from [Chapter 2](ch02.html "Chapter 2. The Profilers"),
    *The Profilers*, and reanalyze them based on the output from these tools.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每一个，我们将介绍安装和UI解释的基础知识。然后，我们将从[第2章](ch02.html "第2章。性能分析器") *性能分析器*中获取示例，并根据这些工具的输出重新分析它们。
- en: KCacheGrind – pyprof2calltree
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: KCacheGrind – pyprof2calltree
- en: The first GUI tool we will see is KCacheGrind. It is a data visualization tool
    designed to parse and display different formats of profiling data. For our case,
    we will display the output from `cProfile`. However, to do this, we'll also need
    the help from the command-line tool called `pyprof2calltree`.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到的第一个GUI工具是KCacheGrind。它是一个数据可视化工具，旨在解析和显示不同格式的性能分析数据。在我们的案例中，我们将显示`cProfile`的输出。然而，为了做到这一点，我们还需要命令行工具`pyprof2calltree`的帮助。
- en: This tool is a rebranding of a very popular one called `lsprofcalltree.py` ([https://people.gnome.org/~johan/lsprofcalltree.py](https://people.gnome.org/~johan/lsprofcalltree.py)).
    It tries to behave more like the `kcachegrind-converter` ([https://packages.debian.org/en/stable/kcachegrind-converters](https://packages.debian.org/en/stable/kcachegrind-converters))
    package from Debian. We'll use the tool to transform the output from `cProfile`
    into something KCacheGrind can understand.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 此工具是对一个非常受欢迎的工具`lsprofcalltree.py`([https://people.gnome.org/~johan/lsprofcalltree.py](https://people.gnome.org/~johan/lsprofcalltree.py))的重新命名。它试图更像Debian中的`kcachegrind-converter`([https://packages.debian.org/en/stable/kcachegrind-converters](https://packages.debian.org/en/stable/kcachegrind-converters))包。我们将使用此工具将`cProfile`的输出转换为KCacheGrind可以理解的内容。
- en: Installation
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装
- en: 'To install `pyprof2calltree`, you''ll first need to install the `pip` command-line
    utility. Then, just use the following command:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装`pyprof2calltree`，您首先需要安装`pip`命令行工具。然后，只需使用以下命令：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note that all installation steps and instructions are meant for the Ubuntu 14.04
    Linux distribution, unless otherwise noted.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，所有安装步骤和说明都是针对 Ubuntu 14.04 Linux 发行版的，除非另有说明。
- en: 'Now, for KCacheGrind, the installation is a bit different. The visualizer is
    part of the KDE desktop environment, so if you already have it installed, chances
    are that you already have KCacheGrind also. However, if you don''t have it (maybe
    you''re a Gnome user), you can just use your package manager and install it. For
    instance, in Ubuntu, you''d use the following command:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，对于 KCacheGrind 来说，安装略有不同。可视化器是 KDE 桌面环境的一部分，所以如果你已经安装了它，那么你很可能也已经安装了 KCacheGrind。然而，如果你没有安装它（也许你是
    Gnome 用户），你只需使用你的包管理器并安装它。例如，在 Ubuntu 上，你会使用以下命令：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: With this command, you'll probably have to install a lot of packages not directly
    related to the utility, but to KDE. So, the installation might take some time
    depending on your Internet connection.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个命令，你可能需要安装很多与实用程序不直接相关的包，而是与 KDE 相关。因此，安装可能需要一些时间，这取决于你的互联网连接。
- en: For Windows and OS X users, there is the option of installing the QCacheGrind
    branch of KCacheGrind, which is already precompiled and can be installed as a
    binary.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Windows 和 OS X 用户，有一个选项可以安装 KCacheGrind 的 QCacheGrind 分支，它已经预编译并可以作为二进制文件安装。
- en: 'Windows users can download it from [http://sourceforge.net/projects/qcachegrindwin/](http://sourceforge.net/projects/qcachegrindwin/),
    and OS X users can install it using brew:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 用户可以从 [http://sourceforge.net/projects/qcachegrindwin/](http://sourceforge.net/projects/qcachegrindwin/)
    下载，而 OS X 用户可以使用 brew 安装：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Usage
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用方法
- en: 'There are two ways to use `pyprof2calltree`: one is from the command line,
    passing in arguments, and the other one is directly from the **read–eval–print
    loop**(**REPL**) (or even from our own scripts being profiled).'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `pyprof2calltree` 有两种方式：一种是从命令行传递参数，另一种是直接从 **读取-评估-打印循环**（**REPL**）（甚至是从我们自己的被分析脚本中）。
- en: 'The first one (command-line version) comes in very handy when we already have
    the profiling results stored somewhere. So, with this tool, we can simply run
    the following command and get the output when needed:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个（命令行版本）在我们已经将分析结果存储在某个地方时非常有用。因此，使用这个工具，我们只需运行以下命令，并在需要时获取输出：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'There are some optional parameters, which can help us in different cases. Two
    of them are explained here:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些可选参数，它们可以帮助我们在不同情况下。其中两个在这里进行了说明：
- en: '`-k`: If we want to run KCacheGrind on the output data right away, this option
    will do it for us'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-k`：如果我们想立即在输出数据上运行 KCacheGrind，这个选项会为我们完成'
- en: '`-r`: If we don''t have the profiling data already saved in a file, we can
    use this parameter to pass in the Python script we''ll use to collect the said
    data'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-r`：如果我们还没有将分析数据保存到文件中，我们可以使用这个参数传入我们将用来收集这些数据的 Python 脚本'
- en: Now, if you want to use it from the REPL instead, you can simply import either
    (or both) the `convert` function or the `visualize` function from the `pyprof2calltree`
    package. The first one will save the data into a file, and the second one will
    launch KCacheGrind with the output from the profiler.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你想从 REPL 中使用它，你可以简单地从 `pyprof2calltree` 包中导入（或同时导入）`convert` 函数或 `visualize`
    函数。第一个会将数据保存到文件中，而第二个会使用分析器的输出启动 KCacheGrind。
- en: 'Here is an example:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This code will call KCacheGrind. It''ll show something like what you see in
    the following screenshot:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将调用 KCacheGrind。它将显示类似于以下屏幕截图中的内容：
- en: '![Usage](img/B02088_03_01.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![使用方法](img/B02088_03_01.jpg)'
- en: In the preceding screenshot, you can see the list on the left-hand side (**1**)
    showing some of the numbers we saw in the previous chapter. On the right-hand
    side (**2**), we've selected one of the tabs, specifically the **Callee Map**
    tab. It shows a set of boxes, representing the hierarchy of function calls from
    the one selected on the left-hand side all the way down.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，你可以看到左侧的列表（**1**）显示了我们在上一章中看到的一些数字。在右侧（**2**），我们选择了一个标签，具体是 **调用图**
    标签。它显示了一系列盒子，代表从左侧选中的函数调用到最底层的层次结构。
- en: 'On the list from the left-hand side, there are two columns that we''ll want
    to pay special attention to:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在左侧的列表中，有两个列我们需要特别注意：
- en: '**Incl. (from Inclusive time) column**: This shows an indicator of how long
    each function takes in aggregate. This means it adds up the time its code takes
    plus the time that other functions called by it take. If a function has a high
    number in this column, it doesn''t necessarily mean that the function takes too
    long. It could mean that the functions called by it do.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**包含（从包含时间）列**：这显示了每个函数在总体上花费的时间的指标。这意味着它加上其代码花费的时间以及它调用的其他函数花费的时间。如果一个函数在这个列中有很高的数字，这并不一定意味着函数花费了很长时间。这可能意味着它调用的函数花费了很长时间。'
- en: '**Self column**: This shows the time spent inside a particular function, without
    taking into account the ones called by it. So, if a function has a high **Self**
    value, then it probably means that a lot of time is spent inside it, and it''s
    a good place to start looking for optimization paths.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自我列**：这显示了在特定函数内部花费的时间，不考虑它调用的函数。所以，如果一个函数有很高的**自我**值，那么这可能意味着在它内部花费了很多时间，这是一个寻找优化路径的好起点。'
- en: 'Another useful view is **Call Graph**, which can be found on the lower-right
    box once a function is selected on the list. It''ll show a representation of the
    functions that will help explain how each one calls the next one (and how many
    times). Here is an example from the preceding code:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的视图是**调用图**，一旦在列表中选择了一个函数，就可以在右下角的框中找到。它将显示函数的表示，有助于解释每个函数是如何调用下一个函数的（以及调用的次数）。以下是从前面的代码中的一个示例：
- en: '![Usage](img/B02088_03_10.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![使用示例](img/B02088_03_10.jpg)'
- en: A profiling example – TweetStats
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 剖析示例 - TweetStats
- en: Let's now go back to the examples of [Chapter 2](ch02.html "Chapter 2. The Profilers"),
    *The Profilers*, and tackle them using the `pyprof2calltree`/`kcachegrind` combo.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到[第2章](ch02.html "第2章。剖析器")，*剖析器*的例子，并使用`pyprof2calltree`/`kcachegrind`组合来处理它们。
- en: Let's avoid the Fibonacci examples, since they're quite simple and we've been
    over them already. So, let's jump directly to the code from the TweetStats module.
    It would read a list of tweets and get some statistics from it. We're not modifying
    the code. So, for reference, just take a look at it in [Chapter 2](ch02.html "Chapter 2. The
    Profilers"), *The Profilers*.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们避免斐波那契示例，因为它们相当简单，而且我们已经讨论过了。所以，让我们直接跳到TweetStats模块的代码。它将读取一系列推文并从中获取一些统计数据。我们不会修改代码。所以，仅供参考，请查看[第2章](ch02.html
    "第2章。剖析器")，*剖析器*。
- en: 'As for the script using the class and printing the actual stats, we''re modifying
    it to save the stats instead. This is a very simple change as you can see here:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 至于使用类并打印实际统计信息的脚本，我们正在修改它以保存统计信息。正如你所看到的，这是一个非常简单的更改：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, with the stats saved into the `tweet-stats.prof` file, we can use the
    following command to transform it and start the visualizer all at once:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将统计数据保存到`tweet-stats.prof`文件中后，我们可以使用以下命令一次性转换它并启动可视化器：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This, in turn, will show us something like the following screenshot:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这反过来会显示类似以下截图的内容：
- en: '![A profiling example – TweetStats](img/B02088_03_02.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![剖析示例 - TweetStats](img/B02088_03_02.jpg)'
- en: 'Again, with the **Callee Map** selected for the first function call, we can
    see the entire map of our script. It clearly shows where the bottlenecks are (biggest
    blocks on the right-hand side): `read_data`, the `split` method, and the `get_data`
    function on the far right of the map.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，当在列表中选择第一个函数调用时，选择**调用图**，我们可以看到我们脚本的整个图。它清楚地显示了瓶颈在哪里（右侧最大的块）：`read_data`，`split`方法和地图最右边的`get_data`函数。
- en: 'Inside the `get_stats` section of the map, we can see how there are two functions
    that make up for part of the size: `inc_stat` and `find` from string. We know
    the first one from seeing the code. This function does very little, so it''s entire
    size will only be due to lookup times accumulated (we''re calling it around 760k
    times after all). The same thing happens for the `find` method. We''re calling
    it way too many times, so the lookup time accumulates and starts to be of notice.
    So, let''s apply a set of very simple improvements to this function. Let''s remove
    the `inc_stat` function and inline it''s behavior. Let''s also change the `find`
    method line and use the in operator. The result will look like the one shown in
    this screenshot: :'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '在地图的`get_stats`部分，我们可以看到有两个函数构成了部分大小：来自字符串的`inc_stat`和`find`。我们从代码中知道第一个函数。这个函数做得很少，所以它的大小将完全归因于累积的查找时间（毕竟我们调用它大约760k次）。对于`find`方法也是同样的情况。我们调用它的次数太多，所以查找时间累积起来，开始变得引人注目。因此，让我们对这个函数应用一系列非常简单的改进。让我们移除`inc_stat`函数并将其内联。同时，让我们更改`find`方法行并使用in运算符。结果将类似于这个截图所示：:'
- en: '![A profiling example – TweetStats](img/B02088_03_03.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![一个性能分析示例 – TweetStats](img/B02088_03_03.jpg)'
- en: That other side of the map changed drastically. Now, we can see that the `get_stats`
    function no longer calls other functions, so the lookup times were removed. It
    now only represents 9.45 percent of the total execution time, down from 23.73
    percent.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 地图的另一侧发生了巨大变化。现在，我们可以看到`get_stats`函数不再调用其他函数，因此查找时间被移除。现在它只代表总执行时间的9.45%，而之前是23.73%。
- en: 'Yes, the preceding conclusions are the same ones we arrived at in the previous
    chapter, but we did so using a different method. Let''s then keep doing the same
    optimization we did earlier and see how the map changes again:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，前面的结论与我们在上一章中得出的结论相同，但我们使用的是不同的方法。那么，让我们继续进行之前所做的相同优化，看看地图又发生了什么变化：
- en: '![A profiling example – TweetStats](img/B02088_03_04.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![一个性能分析示例 – TweetStats](img/B02088_03_04.jpg)'
- en: In the preceding screenshot, we see that by selecting the `build_twitt_stats`
    function (in the list on the left-hand side), the functions that get called are
    simply methods of the string objects.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图中，我们可以看到通过选择左侧列表中的`build_twitt_stats`函数，被调用的函数仅仅是字符串对象的方法。
- en: Sadly, KCacheGrind isn't showing us the total time of execution. However, the
    map clearly shows that we've simplified and optimized our code anyway.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 很遗憾，KCacheGrind没有显示执行的总时间。然而，地图清楚地表明我们无论如何已经简化并优化了我们的代码。
- en: A profiling example – Inverted Index
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个性能分析示例 – 倒排索引
- en: 'Again, let''s get another example from [Chapter 2](ch02.html "Chapter 2. The
    Profilers"), *The Profilers*: the inverted index. Let''s update its code in order
    to generate the stats data and save it into a file so that we can later analyze
    it with KCacheGrind.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，让我们从[第2章](ch02.html "第2章。分析器")，*分析器*，中获取另一个例子：倒排索引。让我们更新其代码以生成统计数据并将其保存到文件中，以便我们稍后可以用KCacheGrind分析它。
- en: 'The only thing we need to change is the last line of the file, instead of just
    calling the `__start__` function. We have the following code:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们唯一需要更改的是文件的最后一行，而不是仅仅调用`__start__`函数。我们有以下代码：
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'So now, executing the script will save the data into the `inverted-index-stats.prof`
    file. Later, we can use the following command to start up KCacheGrind:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，执行脚本将数据保存到`inverted-index-stats.prof`文件中。稍后，我们可以使用以下命令启动KCacheGrind：
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This is what we will see first:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们首先看到的：
- en: '![A profiling example – Inverted Index](img/B02088_03_05.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![一个性能分析示例 – 倒排索引](img/B02088_03_05.jpg)'
- en: 'Let''s first do a resort of the functions on the left-hand side by the second
    column (**Self**). So, we can look at the functions that take the longest to execute
    because of their code (not because of how long the functions it calls take). We
    will get the following list:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先根据左侧的第二列（**Self**）对左侧的函数进行重新排序。这样，我们可以查看由于代码原因（而不是因为调用的函数运行时间较长）执行时间最长的函数。我们将得到以下列表：
- en: '![A profiling example – Inverted Index](img/B02088_03_06.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![一个性能分析示例 – 倒排索引](img/B02088_03_06.jpg)'
- en: So, according to the preceding list, the two most problematic functions right
    now are `getWords` and `list2dict`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 根据前面的列表，目前最成问题的两个函数是`getWords`和`list2dict`。
- en: 'The first one can be improved in several ways, as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个可以通过以下几种方式改进：
- en: The `wordIndexDict` attribute can be changed to be of the `defaultdict` type,
    which will remove the `if` statement checking for an existing index
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`wordIndexDict`属性可以更改为`defaultdict`类型，这将移除检查现有索引的`if`语句'
- en: The strip statements can be removed from the `readFileContent` function, simplifying
    our code here
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以从`readFileContent`函数中移除strip语句，从而简化我们这里的代码
- en: A lot of assignments can be removed, so avoid spending milliseconds in them,
    since we can use the values directly
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以移除很多赋值操作，因此避免在这些操作中浪费毫秒，因为我们可以直接使用这些值
- en: 'So, our new `getWords` function looks like this:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们新的`getWords`函数看起来是这样的：
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, if we run the stats again, the map and the numbers look a bit different:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们再次运行统计，映射和数字看起来略有不同：
- en: '![A profiling example – Inverted Index](img/B02088_03_07.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![一个性能分析示例 – 倒排索引](img/B02088_03_07.jpg)'
- en: So, our function is now using less time, both overall (**Incl.** column) and
    inside it (**Self** column). However, there is still another detail we might want
    to look into before leaving this function alone. The `getWords` function is calling
    `getOffsetUpToWord` a total of **141,295** times, the lookup time spent in there
    alone, should be enough to merit a review. So, let's see what we can do.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的函数现在使用的时间更少了，无论是总体上（**Incl.**列）还是内部（**Self**列）。然而，在离开这个函数之前，我们可能还想关注另一个细节。`getWords`函数总共调用了`getOffsetUpToWord`
    **141,295**次，仅查找时间就足以值得审查。那么，让我们看看我们能做什么。
- en: 'We''ve already solved this issue in the earlier chapter. We saw that we can
    reduce the entire `getOffsetUpToWord` function to a one-liner, which we can later
    write directly inside the `getWords` function to avoid lookup time. With this
    in mind, let see what our new map looks like:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在前面的章节中解决了这个问题。我们看到了可以将整个`getOffsetUpToWord`函数简化为一行，我们可以在稍后直接将其写入`getWords`函数中，以避免查找时间。考虑到这一点，让我们看看我们的新映射是什么样的：
- en: '![A profiling example – Inverted Index](img/B02088_03_08.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![一个性能分析示例 – 倒排索引](img/B02088_03_08.jpg)'
- en: Now, we have increased the overall time, but that's nothing to worry about.
    It is due to the fact that now we have one function less to spread the timing
    between, so the number changed for all other functions. However, the one we really
    care about (the **Self** time) went down, by about 4 percent.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的总体时间有所增加，但不用担心。这是因为现在我们有一个函数可以分散时间，所以所有其他函数的数字都发生了变化。然而，我们真正关心的是（**Self**时间），下降了大约4%。
- en: 'The preceding screenshot also shows the **Call Graph** view, which helps us
    see that even though we made an improvement, the `reduce` function is still being
    called over **100,000** times. If you look at the code of the `getWords` function,
    you would notice we don''t really need the `reduce` function. This is because
    on every call, we''re adding up all the numbers we added on the previous call
    plus one more, so we can simplify this in the following code:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的截图还显示了**调用图**视图，它帮助我们看到，尽管我们进行了改进，但`reduce`函数仍然被调用了超过**100,000**次。如果你查看`getWords`函数的代码，你会注意到我们实际上并不需要`reduce`函数。这是因为每次调用时，我们都在前一次调用的所有数字上加上一个，所以我们可以将以下代码简化：
- en: '[PRE10]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'With this final touch to the functions, the numbers change once again:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在对函数进行最后的润色后，数字又发生了变化：
- en: '![A profiling example – Inverted Index](img/B02088_03_09.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![一个性能分析示例 – 倒排索引](img/B02088_03_09.jpg)'
- en: The inclusive amount of time of the function was lowered significantly, so overall,
    this function now takes less time to execute (which was our goal). The internal
    time (**Self** column) went down, which is a good thing. This is because it also
    means that we're doing the same in less time (specially because we know that we're
    not calling any other function).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的总耗时显著降低，所以总的来说，这个函数现在执行所需的时间更少了（这正是我们的目标）。内部时间（**Self**列）有所下降，这是一个好现象。这是因为这也意味着我们在更短的时间内完成了同样的工作（特别是因为我们知道我们没有调用任何其他函数）。
- en: RunSnakeRun
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RunSnakeRun
- en: RunSnakeRun is yet another GUI tool to help us visualize the profiling output
    and, in turn, help us make sense of it. This particular project is a simplified
    version of KCacheGrind. Whereas the latter is also useful for C and C++ developers,
    RunSnakeRun is specifically designed and written for Python developers.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: RunSnakeRun是另一个GUI工具，帮助我们可视化性能分析输出，进而帮助我们理解它。这个特定项目是KCacheGrind的简化版本。虽然后者对C和C++开发者也有用，但RunSnakeRun是专门为Python开发者设计和编写的。
- en: Earlier, with KCacheGrind, if we wanted to plot the output of `cProfile`, we
    needed an extra tool (`pyprof2calltree`). This time we won't. RunSnakeRun knows
    how to interpret it and display it, so all we need to do is call it and pass in
    the path to the file.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，使用KCacheGrind，如果我们想绘制`cProfile`的输出，我们需要一个额外的工具（`pyprof2calltree`）。这次我们不需要。RunSnakeRun知道如何解释并显示它，所以我们只需要调用它并传入文件路径。
- en: 'The features provided by this tool are as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 此工具提供以下功能：
- en: 'Sortable data grid views with fields, such as:'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可排序的数据网格视图，具有如下字段：
- en: function name
  id: totrans-90
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数名称
- en: number of total calls
  id: totrans-91
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总调用次数
- en: cumulative time
  id: totrans-92
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 累计时间
- en: filename and line number
  id: totrans-93
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件名和行号
- en: Function-specific information, such as all callers of this function and all
    callee's of this function
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数特定信息，例如此函数的所有调用者和所有被调用者
- en: Square map of the call tree with size proportional to the amount of time spent
    inside each function
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用树平方图，大小与每个函数内花费的时间成比例
- en: Installation
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装
- en: 'In order to install this tool, you have to make sure that several dependencies
    are covered, mainly the following ones:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 为了安装此工具，您必须确保几个依赖项已覆盖，主要是以下这些：
- en: Python profiler
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python分析器
- en: wxPython (2.8 or above) ([http://www.wxpython.org/](http://www.wxpython.org/))
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: wxPython（2.8或更高版本）([http://www.wxpython.org/](http://www.wxpython.org/))
- en: Python (of course!) 2.5 or above, but lower than 3.x
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python（当然！）2.5或更高版本，但低于3.x
- en: You'll also need to have `pip` ([https://pypi.python.org/pypi/pip](https://pypi.python.org/pypi/pip))
    installed in order to run the installation command.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要安装`pip` ([https://pypi.python.org/pypi/pip](https://pypi.python.org/pypi/pip))，以便运行安装命令。
- en: 'So, make sure you have all these installed before moving forward. If you''re
    in a Debian-based distribution of Linux (say Ubuntu), you can use the following
    line to make sure you have everything you need (provided you already have Python
    installed):'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在继续之前，请确保您已经安装了所有这些。如果您使用的是基于Debian的Linux发行版（例如Ubuntu），您可以使用以下行来确保您拥有所需的一切（假设您已经安装了Python）：
- en: '[PRE11]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Windows and OS X users will need to find the correct precompiled binaries for
    their current OS version for each of the dependencies mentioned earlier.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Windows和OS X用户需要为之前提到的每个依赖项找到当前OS版本的正确预编译的二进制文件。
- en: 'After that, you can just run this command:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，您只需运行以下命令：
- en: '[PRE12]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: After that, you should be ready to go.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，您应该可以开始使用了。
- en: Usage
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用方法
- en: 'Now, to quickly show you how to use it, let''s go back to previous last example:
    `inverted-index.py`.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了快速向您展示如何使用它，让我们回到之前的最后一个示例：`inverted-index.py`。
- en: 'Let''s execute that script using the `cProfile` profiler as a parameter and
    save that output into a file. Then, we can just call `runsnake` and pass it the
    file path:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用`cProfile`分析器作为参数执行该脚本，并将输出保存到文件中。然后，我们只需调用`runsnake`并传入文件路径：
- en: '[PRE13]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This will generate the following screenshot:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成以下截图：
- en: '![Usage](img/B02088_03_11.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![使用方法](img/B02088_03_11.jpg)'
- en: 'From the preceding screenshot, you can see the three main areas of interest:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的截图，您可以看到三个主要感兴趣的区域：
- en: The sortable list, which contains all the numbers returned by `cProfile`
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可排序的列表，其中包含`cProfile`返回的所有数字
- en: The function-specific info section, which has several tabs of interest, such
    as the **Callees**, **Callers** and **Source Code** tabs
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数特定信息部分，其中包含几个有趣的标签，例如**被调用者**、**调用者**和**源代码**标签
- en: The square map section, which graphically represents the call tree of the execution
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平方地图部分，它以图形方式表示执行调用树
- en: Note
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A nice little feature that the GUI has is that it'll highlight the related box
    on the right-hand side if you hover your mouse over a function in the list from
    the left-hand side. The same thing will happen if you hover over a box on the
    right-hand side; its corresponding entry in the list will be highlighted.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: GUI的一个很棒的小功能是，如果您将鼠标悬停在左侧列表中的函数上，它会在右侧突出显示相关的框。如果您将鼠标悬停在右侧的框上，同样会发生这种情况；列表中的对应条目将被突出显示。
- en: Profiling examples – the lowest common multiplier
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分析示例 – 最低公共乘数
- en: Let's take a look at a very basic, non-practical example of a function in need
    of serious optimization and what it would look like using this GUI.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个非常基础、不实用的函数优化示例，以及使用此GUI会是什么样子。
- en: 'Our example function takes care of finding the lowest common multiplier between
    two numbers. It''s a pretty basic example: one you can find all over the Internet.
    However, it''s also a good place to start getting a feel of this UI.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例函数负责找到两个数字之间的最小公倍数。这是一个相当基本的例子：你可以在互联网上找到很多。然而，这也是开始了解这个UI的好地方。
- en: 'The function''s code is as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的代码如下：
- en: '[PRE14]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: I'm pretty sure you can spot every single possible optimization just by looking
    at it, but stay with me. Let's profile this bad boy and load up the resulting
    output on RunSnakeRun.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我很确信你只需看一眼就能找到每一个可能的优化点，但请跟我一起。让我们分析这个家伙，并将结果输出加载到RunSnakeRun中。
- en: 'So, to run it, use this command:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，要运行它，请使用以下命令：
- en: '[PRE15]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To start the GUI, use this command:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动GUI，请使用以下命令：
- en: '[PRE16]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This is what we get:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们得到的结果：
- en: '![Profiling examples – the lowest common multiplier](img/B02088_03_12.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![配置示例 – 最小公倍数](img/B02088_03_12.jpg)'
- en: One thing we didn't mention earlier, but that is a nice add-on to the square
    map, is the fact that next to each box's name, we can see how much time it takes
    to run that function.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前没有提到的一件事，但它是正方形映射的一个很好的附加功能，是每个框的名称旁边我们可以看到运行该函数所需的时间。
- en: 'So, at first sight, we can spot several issues already:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，乍一看，我们可以发现几个问题：
- en: We see that both `max` and `min` functions only take up to 0,228 seconds out
    of the total 0,621 seconds that our function takes to run. So, there is more to
    our function than simply max and min.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以看到，`max`和`min`函数总共只占用了我们函数运行时间的0,228秒，而我们的函数运行总时间是0,621秒。所以，我们的函数不仅仅是`max`和`min`。
- en: We can also see that both `max` and `min` functions are called **943,446** times
    each. No matter how small the lookup time is, if you call a function almost 1
    million times it's going to add up.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还可以看到，`max`和`min`函数都被调用了**943,446**次。无论查找时间有多小，如果你几乎调用了100万次函数，这将会累积起来。
- en: 'Let''s perform some obvious fixes to our code and see how it looks again, through
    the *eyes of the snake*:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们对我们的代码进行一些明显的修复，并再次通过“蛇之眼”看看它：
- en: '[PRE17]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You should get something like what''s shown in the following screenshot:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该得到以下截图所示的内容：
- en: '![Profiling examples – the lowest common multiplier](img/B02088_03_13.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![配置示例 – 最小公倍数](img/B02088_03_13.jpg)'
- en: Now, neither `min` nor `max` even register on the square map. This is because
    we're just only calling them once, and the function went from 0.6 seconds to 0.1
    second. This is the power of not doing unnecessary function lookups for you folks.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`min`和`max`甚至没有在正方形映射上注册。这是因为我们只调用了一次，函数从0.6秒减少到0.1秒。这就是不进行不必要的函数查找的力量。
- en: Now, let's take a look at another, more complex, and thus, interesting function
    in dire need of optimization.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看另一个更复杂、因此更有趣、急需优化的函数。
- en: A profiling example – search using the inverted index
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 倒排索引的搜索示例
- en: Since the previous chapter, we've been over the code of the inverted index from
    all possible angles. This is great, since we've analyzed it from several perspectives
    and using different approaches. However, it would make no sense to also look at
    it using RunSnakeRun, since this tool is very similar to the one we just tried
    (KCacheGrind).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 自从上一章以来，我们已经从所有可能的角度分析了倒排索引的代码。这很好，因为我们已经从几个不同的角度和不同的方法进行了分析。然而，使用RunSnakeRun来分析它就没有意义了，因为这个工具与我们刚刚尝试的工具非常相似（KCacheGrind）。
- en: 'So instead, let''s use the output of the inverted search script and code ourselves,
    a search script that will use that output. We will initially shoot for a simple
    search function that will only look for one single word in the index. The steps
    are quite straightforward:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们使用倒排搜索脚本的输出，并自己编写一个使用该输出的搜索脚本。我们最初的目标是编写一个简单的搜索函数，它将只查找索引中的一个单词。步骤相当直接：
- en: Load the index in memory.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将索引加载到内存中。
- en: Search for the word and grab the indexing information.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 搜索单词并获取索引信息。
- en: Parse the indexing information.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解析索引信息。
- en: For each index entry, read the corresponding file and grab the surrounding string
    as a result.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个索引条目，读取相应的文件，并获取周围的字符串作为结果。
- en: Print the results.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印结果。
- en: 'Here''s the initial version of our code:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的代码的初始版本：
- en: '[PRE18]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'To run the code, just run the following command:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行代码，只需运行以下命令：
- en: '[PRE19]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The output we will get is similar to the following screenshot (given we have
    a few books inside the `files` folder):'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将得到的输出类似于以下截图（假设我们在`files`文件夹中有几本书）：
- en: '![A profiling example – search using the inverted index](img/B02088_03_14.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![性能分析示例 – 使用倒排索引进行搜索](img/B02088_03_14.jpg)'
- en: The output could be improved by highlighting the search term or showing some
    of the previous words for more context. However, we'll run with it for the time
    being.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过突出显示搜索词或显示一些上下文中的前缀词来改进输出。然而，我们暂时就这样进行。
- en: 'Now, let''s see how our code looks when we open the `search.prof` file inside
    `RunSnakeRun`:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看在`RunSnakeRun`中打开`search.prof`文件时我们的代码看起来如何：
- en: '![A profiling example – search using the inverted index](img/B02088_03_15.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![性能分析示例 – 使用倒排索引进行搜索](img/B02088_03_15.jpg)'
- en: That's a lot of boxes, especially comparing it to our previous example of the
    lowest common multiplier. However, let's see what insight can be gathered from
    it at first sight.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们之前示例中的最低公倍数相比，这里有很多框。然而，让我们先看看从第一眼就能得到的见解。
- en: 'The two most time-consuming functions are `loadIndex` and `list2dict`, closely
    followed by `readFileContent`. We can see this on the left-side column:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 两个耗时最长的函数是`loadIndex`和`list2dict`，紧接着是`readFileContent`。我们可以在左侧列中看到这一点：
- en: All these functions are actually spending most of their time inside other functions
    they call. So, their cumulative time is high, but their local time is considerably
    lower.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有这些函数实际上大部分时间都是在它们调用的其他函数内部度过的。所以，它们的累积时间很高，但它们的局部时间却相对较低。
- en: 'If we sort by local time on the list, we would see that the top five functions
    are:'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们按局部时间对列表进行排序，我们会看到前五个函数是：
- en: The `read` method from the file object
  id: totrans-164
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件对象的`read`方法
- en: The `loadIndex` function
  id: totrans-165
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`loadIndex`函数'
- en: The `list2dict` function
  id: totrans-166
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`list2dict`函数'
- en: The `findAll` method of the regular expression object
  id: totrans-167
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正则表达式对象的`findAll`方法
- en: And the `readFileContent` function
  id: totrans-168
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以及`readFileContent`函数
- en: 'So, let''s first take a look at the `loadIndex` function. Even though most
    of its time is spent inside the `list2dict` function, we still have one minor
    optimization to do, which will simplify its code and significantly reduce its
    local time:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们首先看看`loadIndex`函数。尽管它的大部分时间是在`list2dict`函数内部度过的，但我们仍然有一个小的优化要做，这将简化其代码并显著减少其局部时间：
- en: '[PRE20]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This simple change took the local time of the function from 0.03s down to 0.00002s.
    Even though it wasn't already a big pain, we both increased its readability and
    improved its time. So, overall, we did well.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的更改将函数的局部时间从0.03秒降低到0.00002秒。尽管它之前并不是一个大问题，但我们提高了其可读性并改善了其性能。所以，总的来说，我们做得不错。
- en: 'Now, based on the last analysis, we knew that most of the time spent inside
    this function was actually spent inside another one called by it. So, now that
    we basically decreased its local time to almost nothing, we need to focus on our
    next target: `list2dict`.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，根据最后的分析，我们知道在这个函数内部花费的大部分时间实际上是在它调用的另一个函数内部度过的。所以，现在我们已经基本上将其局部时间降低到几乎为零，我们需要关注我们的下一个目标：`list2dict`。
- en: 'However, first, let''s see how the picture has changed with the simple improvement
    we did earlier:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，首先，让我们看看通过我们之前所做的简单改进，图片是如何变化的：
- en: '![A profiling example – search using the inverted index](img/B02088_03_16.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![性能分析示例 – 使用倒排索引进行搜索](img/B02088_03_16.jpg)'
- en: Now, let's move on to `list2dict`. This function is the one in charge of parsing
    every line of the index file into something we can use later. It will parse every
    line of the index file, more specifically, into a hash table (or dictionary) indexed
    by a word, which will make our search be of O(1) in average (read back to [Chapter
    1](ch01.html "Chapter 1. Profiling 101"), *Profiling 101,* if you don't remember
    what this means) when we search. The values of the dictionary are the path to
    the actual files and the different offsets where the word is.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续讨论`list2dict`函数。这个函数负责将索引文件的每一行解析成我们可以稍后使用的格式。它将解析索引文件的每一行，更具体地说，将其解析成一个以单词为索引的哈希表（或字典），这样当我们进行搜索时，平均搜索时间复杂度将是O(1)。如果你不记得这是什么意思，可以回读至[第1章](ch01.html
    "第1章。性能分析101")，*性能分析101*。
- en: 'From our analysis, we can see that though we spend some time inside the function
    itself, most of the complexity is inside the regular expression methods. Regular
    expressions are great for many reasons, but sometimes, we tend to overuse them
    in cases where using simple `split` and `replace` functions would do. So, let''s
    see how we can parse our data, get the same output without the regular expressions,
    and see if we can do it in less `time:def list2dict(l)`:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们的分析中，我们可以看出，尽管我们在函数内部花费了一些时间，但大部分的复杂性都集中在正则表达式方法中。正则表达式有很多优点，但有时我们倾向于在可以使用简单的
    `split` 和 `replace` 函数的情况下过度使用它们。那么，让我们看看我们如何解析数据，在不使用正则表达式的情况下获得相同的输出，并看看我们是否能在更少的
    `time:def list2dict(l)` 时间内完成：
- en: '[PRE21]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The code looks cleaner already. There are no regular expressions anywhere (which
    will help readability sometimes, since not everyone is an expert in reading regular
    expressions). We have less lines of code. We removed the `join` line, and we even
    got rid of the nasty `del` line, which was not necessary.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 代码看起来已经更简洁了。没有任何地方使用正则表达式（这有时有助于可读性，因为并不是每个人都是阅读正则表达式的专家）。代码行数更少了。我们移除了 `join`
    行，甚至去掉了不必要的 `del` 行。
- en: We, however, added a list comprehension line, but this is just a simple `replace`
    method on every item of the list in one line, that's all.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们添加了一条列表解析行，但这只是对列表中的每个项目进行一行简单的 `replace` 方法，仅此而已。
- en: 'Let''s see what our map looks like now:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看现在的映射看起来像什么：
- en: '![A profiling example – search using the inverted index](img/B02088_03_17.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![一个性能分析示例 – 使用倒排索引进行搜索](img/B02088_03_17.jpg)'
- en: 'Well, there is definitely a change there. If you compare the last two screenshots,
    you would notice the box for the `list2dict` function has moved to the right.
    This means it now takes less time than the `readFileContent` function. Our function''s
    box is also simpler now. The only things inside it are the `split` and the `replace`
    methods. Finally, in case there was any doubt, let''s look at the numbers:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，确实有变化。如果你比较最后两个截图，你会注意到 `list2dict` 函数的框已经移动到了右边。这意味着它现在比 `readFileContent`
    函数花费的时间更少。我们的函数框现在也更简单了。里面只有 `split` 和 `replace` 方法。最后，以防有任何疑问，让我们看看这些数字：
- en: Local time went down from 0.024s to 0.019s. It makes sense that the local time
    didn't decrease that much, because we're still doing all the work inside the function.
    This decrease is mainly due to the absence of the `del` line and the `join` line.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地时间从 0.024 秒下降到 0.019 秒。本地时间没有大幅下降是有道理的，因为我们仍然在函数内部做所有的工作。这种下降主要是由于没有 `del`
    行和 `join` 行。
- en: The total cumulative time decreased considerably. It went down from 0.094s to
    0.031s, due to the lack of complex functions (regular expressions) used for the
    job.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总累计时间显著下降。它从 0.094 秒下降到 0.031 秒，这是由于缺乏用于这项工作的复杂函数（正则表达式）。
- en: We took the total cumulative time of the function down to a third of what is
    was. So, it was a good optimization, especially considering that if we had larger
    indexes, then the time would be much bigger.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将函数的总累计时间降低到了原来的三分之一。所以，这是一个很好的优化，特别是考虑到如果我们有更大的索引，那么时间会更大。
- en: Note
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The last assumption is not always true. It depends greatly on the type of algorithm
    being used. However, in our case, since we're looping over all the lines of the
    index file, we can safely assume it is.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的假设并不总是正确的。它很大程度上取决于所使用的算法类型。然而，在我们的情况下，因为我们正在遍历索引文件的每一行，所以我们可以安全地假设它是正确的。
- en: 'Let''s take a quick look at the numbers from the first analysis of the code
    and the last one so that we can see if there is actually an improvement on the
    overall time:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速查看代码的第一分析和最后分析中的数字，以便我们可以看到整体时间是否真的有所改进：
- en: '![A profiling example – search using the inverted index](img/B02088_03_18.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![一个性能分析示例 – 使用倒排索引进行搜索](img/B02088_03_18.jpg)'
- en: Finally, as you can see, we went from around 0.2 seconds of execution with the
    original code all the way down to 0.072 seconds.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，正如你所看到的，我们的执行时间从原始代码的约 0.2 秒下降到了 0.072 秒。
- en: 'Here''s the final version of the code, all put together with the earlier improvements:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这是代码的最终版本，所有之前做出的改进都整合在一起：
- en: '[PRE22]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Summary
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: To summarize, in this chapter, we covered two of the most popular and common
    tools used by Python developers trying to make sense of the numbers returned by
    profilers such as `cProfile`. We analyzed the old code under this new light. We
    even got to analyze some new code.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，在本章中，我们介绍了 Python 开发者尝试理解由 `cProfile` 等分析器返回的数字时使用的两个最流行和常见的工具。我们用新的视角分析了旧代码。我们甚至分析了一些新代码。
- en: In the next chapter, we'll start talking about optimization in more detail.
    We will cover some of the things we've already seen in practice and some recommendations
    of good practices when profiling and optimizing code.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将更详细地讨论优化问题。我们将涵盖一些我们在实践中已经看到的内容，以及一些在分析和优化代码时的良好实践建议。
