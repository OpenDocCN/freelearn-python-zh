- en: Game of Chess
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's build a game of chess in Tkinter. If you already know the basic rules
    of chess, you are ready to write this program. However, if you do not know the
    rules, you should read them before you start programming this application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the key objectives of this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Learning how to structure a program in a **Model-View-Controller** (**MVC**)
    architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning how to tame complexity by implementing programs in a modular structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Taking a look at the versatility and power of the Tkinter Canvas widget
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning the basic usage of canvas coordinates, object IDs, and tags
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning the recommended error-handling practices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning how to extend Python's built-in data types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using object inheritance to code classes with similar attributes and behavior
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Python's built-in `configparser` module to store program preferences
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting acquainted with several Python modules that you will often use in a
    variety of application development projects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An overview of the chapter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will now implement a *human* versus *human* chess game. Our chess game will
    enforce all the standard rules that are applicable to a game of chess. Some advanced
    rules such as castling and en passant are left as an exercise for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'In its final form, our chess program will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/670b8c08-8200-4bdd-8a5a-83e95d0029ed.png)'
  prefs: []
  type: TYPE_IMG
- en: Module requirements for this chapter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will not use any external third-party modules in this chapter. However, we
    will use several built-in Python modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'To check whether all the required libraries are indeed provided by your Python
    distribution, type the following command in your Python command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This should be executed without an error message. If no errors are thrown back,
    you are ready to build the chess application. Let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Structuring our program
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we decide on an overall structure for our program.
  prefs: []
  type: TYPE_NORMAL
- en: The development of large applications generally starts with recording the **software
    requirement specifications** (**SRS**). This is generally followed by a graphical representation
    of constructs, such as the class, composition, inheritance, and the hiding of
    information using several modeling tools. These tools can be flow charts, **Unified
    Modeling Language** (**UML**) tools, data flow diagrams, Venn diagrams (for database
    modeling), and so on.
  prefs: []
  type: TYPE_NORMAL
- en: These tools are very useful when the problem domain is not very clear. However, if
    you have ever played the game of chess, you should be very well acquainted with
    the problem domain. Furthermore, our chess program can be classified as a medium-sized
    program spanning a few hundred lines of code. Therefore, let's bypass these visual
    tools and get to the actual program design.
  prefs: []
  type: TYPE_NORMAL
- en: All of our previous projects have been structured as a single file. However,
    as programs grow in complexity, we need to break programs into modules and class
    structures.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the key objectives of this chapter is to learn to write programs in
    the **MVC** architecture. Some of the central aspects of the MVC architecture
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A model handles backend data and logic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A view handles the frontend presentation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The model and view never interact directly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whenever the view needs to access backend data, it requests the controller to
    intervene with the model and fetch the required data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Given these aspects, let''s create three files for our chess program: `model.py`,
    `view.py`, and `controller.py` (see `4.01.py`).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s create an empty `Model` class, an empty `View` class, and a `Controller`
    class in their respective files, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note that since the `Controller` class needs to fetch data from the `Model`
    class, we instantiated a new `Model` class from within the `Controller` class.
    This now provides us with a way to fetch data from the `Model` class as and when
    needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s also add a separate file called `exceptions.py`. This will be our central
    place for the handling of all errors and exceptions. Within this file, add the
    following single line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We created a custom `ChessError` class that was inherited from the standard `Exception`
    class. This simple line of code now allows the `ChessError` class and all of its
    children to raise errors, which can then be handled by using the `try…except` block.
    All the new error classes that will be defined in our code from now on will derive
    from this `ChessError` base class.
  prefs: []
  type: TYPE_NORMAL
- en: With this boilerplate code out of the way, let's create another blank file called `configurations.py
    (4.01)`. We will use this file to store all the constants and configurable values
    in one place.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s define some constants right away, as follows (see code `4.01`—`configurations.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'To make these constant values available to all files, let''s import them in
    to the `model.py`, `view.py`, and `controller.py` folders (see `4.01`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'As per the tenets of the MVC architecture, the `View` class is never supposed
    to interact directly with the `Model` class. It should always interact with the
    `Controller` class, and the `Controller` class is then responsible for fetching
    data from the `Model` class. Accordingly, let''s import the controller in the
    `View` class and the model in the `Controller` class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s start by editing the `view.py` file to display a chessboard (see `4.01`—`view.py`).
    Our goal for this iteration is to display the empty chessboard as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/40be4ee4-13b3-4b49-a482-7df875247a4b.png)'
  prefs: []
  type: TYPE_IMG
- en: Take a look at the code implementation in `view.py` (see `4.01`).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `__init__` method of the `View` class calls a method called `create_chess_base`, which
    is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We will not reproduce the code responsible for the creation of the root window,
    the menu at the top, or the frame at the bottom. We have implemented similar widgets in
    previous chapters (see `4.01`—`view.py` for a complete reference).
  prefs: []
  type: TYPE_NORMAL
- en: 'However, we will discuss the code that creates the chessboard:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Nothing fancy here. Creating a Canvas widget is similar to creating other widgets
    in Tkinter. The Canvas widget takes the `width` and `height` of two configurable
    options. Next, paint the Canvas widget in alternating shades to form the chessboard (`view.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the description of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: We used the Canvas widget's `create_rectangle()` method to draw alternating
    shades of squares to resemble a chessboard.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The rectangles are drawn from point `x1`, `y1`, and they extend to `x2`, `y2`. These
    values correspond to two diagonally opposite corners of the rectangle (coordinates
    of the upper-left and lower-right edges).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `x` and `y` values are calculated by using a newly defined method called `get_x_y_coordinate()`,
    which performs simple mathematics depending on the dimensions of each square that
    was defined in pixel units earlier.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `y` value is calculated by first subtracting a row from (7-row) because the
    Canvas widget measures the coordinates starting from the top left. The top-left
    corner of the canvas has the coordinates (`0`, `0`).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `get_alternate_color` method is a helper method that, not surprisingly,
    returns the alternate color.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Tkinter Canvas widget lets you draw a line, an oval, a rectangle, an arc,
    and polygon shapes at a given coordinate. You can also specify various configuration
    options, such as fill, outline, width, and so on for each of these shapes.
  prefs: []
  type: TYPE_NORMAL
- en: The Canvas widget uses a coordinate system to specify the position of objects
    on the widget. Coordinates are measured in pixels. The top-left corner of the
    canvas has the coordinates (`0`, `0`).
  prefs: []
  type: TYPE_NORMAL
- en: The objects drawn on the Canvas widget are usually handled by assigning them
    an ID or a tag. We will see an example of this later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: If an object on the Canvas widget is tagged to multiple tags, the options defined
    for tags at the top of the stack have precedence.
  prefs: []
  type: TYPE_NORMAL
- en: However, you can change the precedence of tags by using `tag_raise(name)` or
    `tag_lower(name)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a complete list of Canvas widget-related options, refer to the interactive
    help for the Canvas widget using `help(Tkinter.Canvas)` in the command line, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`>>> import tkinter`'
  prefs: []
  type: TYPE_NORMAL
- en: '**`>>> help(tkinter.Canvas)`**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s bind the mouse click to the Canvas widget from the `__init__`
    method of the `View` class (see `4.01`—`view.py`), as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The bound method calls another method called `get_clicked_row_column()`, and
    for now it prints the result on the console as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The `get_clicked_row_column()` method is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if you run the code (see `4.01`—`view.py`) and click on different squares,
    it should output a message like this to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This completes our first iteration. In this iteration, we determined the broader
    file structure for the chess program. We created the `model`, `view`, and `controller` classes.
    We also decided to keep all the constants and configuration values in a separate
    file called `configurations.py`.
  prefs: []
  type: TYPE_NORMAL
- en: We have now had a first taste of the Canvas widget. We created a blank canvas
    and then added square areas using the `canvas.create_rectangle` method to create a
    chessboard.
  prefs: []
  type: TYPE_NORMAL
- en: Now, if you run `4.01`—`view.py`, you will see an empty chessboard. You will
    also find out that the *File* menu and the *Edit* menu dropdowns are not functional.
    The *About* menu should show a standard `messagebox` widget.
  prefs: []
  type: TYPE_NORMAL
- en: Before you proceed to the next section, you are encouraged to go and explore
    the code in the `4.01` folder in its entirety.
  prefs: []
  type: TYPE_NORMAL
- en: Modeling the data structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Coming back to the old adage, data structures, not algorithms, are central to
    writing good programs. Therefore, it is important that we spend some time defining
    the data structure.
  prefs: []
  type: TYPE_NORMAL
- en: The key data that the model needs to record is the position of the chess pieces
    on the chessboard. Accordingly, we first need a way to define these locations
    and a unique way to identify the chess pieces. Let's first agree to the naming
    conventions that we will stick to in the program.
  prefs: []
  type: TYPE_NORMAL
- en: Convention on naming chess pieces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every chess piece is identified by a single letter (pawn = p, knight = n (yes
    knight with an n!), bishop = b, rook = r, queen = q, and king = k).
  prefs: []
  type: TYPE_NORMAL
- en: The *white* chess pieces are represented by *uppercase* letters (PNBRQK), and
    the *black* chess pieces are represented by *lowercase* letters (pnbrqk).
  prefs: []
  type: TYPE_NORMAL
- en: Convention for naming locations on the chessboard
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to assign unique identifiers to every square on the chessboard, we
    will mark the squares along the *x* axis by using the letters A to H. We will
    mark the *y* axis by using the numbers 1 to 8.
  prefs: []
  type: TYPE_NORMAL
- en: 'Accordingly, the squares on the chessboard will be identified as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/27a601f3-ad2e-4128-a2c0-cc1255f1f6fb.png)'
  prefs: []
  type: TYPE_IMG
- en: Thus, **A1** denotes the leftmost square at the bottom of the chessboard. Currently,
    it is occupied by a white rook. The **C3** position is currently empty, **E8**
    has a black king, and **A8** has a black rook.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add this to the `configurations.py` file (see `4.02`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now, if you want to represent the chessboard at any point in time, all you need
    is a mapping of the location to the chess piece at that location. Looks like a
    perfect candidate for storing as a Python dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, the initial position of all the chess pieces on the chessboard can be
    represented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We need this data to get started. So, let's add this as a constant to the `configurations.py`
    file (see `4.02`).
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's move on to code the `Model` class for our program. We have already decided
    that we will use a Python dictionary to store the position of chess pieces on
    the chessboard. We can go ahead and add a dictionary attribute to the class.
  prefs: []
  type: TYPE_NORMAL
- en: However, we will take a slightly different approach.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s make the `Model` class a child class of the built-in dictionary class,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Thus, the `self` variable that refers to the current class object instance will
    also have all the properties and methods that are available to the dictionary.
    All the methods that are available to the standard dictionary class can now be
    called on the `Model` object (`self`).
  prefs: []
  type: TYPE_NORMAL
- en: 'So now we can define a method that returns the short name of the chess piece
    at that position when it''s given a position on the chessboard, as follows (see
    `4.02`—`model.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: If there is no chess piece at the position, this returns `None` rather than
    giving a `KeyError` exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s add some more important attributes to the `Model` class, as follows
    (see `4.02`—`model.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `half-move_clock` keeps a track of the number of turns played since the
    last pawn's advance or the last capture. This is used to determine whether a draw can
    be claimed under the `fifty-move` rule.
  prefs: []
  type: TYPE_NORMAL
- en: The `full-move` number is a count that is incremented by `1` after every move
    of a black piece. This is used to track the overall length of a game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s add another method that, given the row-column tuple for a square, returns
    its alphanumeric position (for example, an input of (`1`, `2`) returns `B3`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s define an associated helper method to ensure that we only process
    mouse clicks that occur on the Canvas widget and not anywhere else in the root
    window, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: There is not much that can be added to the `Model` class for now until we lay
    down the code logic to handle the chess pieces.
  prefs: []
  type: TYPE_NORMAL
- en: We can define the rules for all the chess pieces within the `Model` class, but
    that would make the `Model` class too bulky.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, let's define the chess piece-related logic in a new file named `piece.py`.
    Since this is inherently a part of the `Model` class but it is defined in a new
    file, let's add a reference to the `Model` class within this file.
  prefs: []
  type: TYPE_NORMAL
- en: (see `4.02`—`piece.py`)
  prefs: []
  type: TYPE_NORMAL
- en: Let's do this next.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Piece class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Think about it. We need to define rules for all the different chess pieces.
    Some attributes and methods, such as color, will be common to all the chess pieces,
    while other attributes/methods, such as rules for movement, will vary for each
    chess piece.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''ll define a new `Piece` class. This class will have the attributes
    and methods that are common to all the chess pieces. Then, we will define classes
    for every individual piece as a subclass of this parent `Piece` class. We can
    then override all the attributes and methods in these individual classes. The
    code will look like this (see `4.02`—`piece.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `Piece` class needs `color` as an argument for object creation.
    We create two attributes, named `self.name` and `self.color`, in the class.
  prefs: []
  type: TYPE_NORMAL
- en: Also note the `keep_reference(self, model)` method definition. Since the `Piece` class
    is nothing but an extension of the `Model` class, we need to get a reference to
    the `Model` class in this method to communicate with it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, the `Model` class needs a reference to the new `Piece` class. Accordingly,
    we add this as an import to the `Model` class, as follows (see `4.02`—`model.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we need a method that takes a string pertaining to the name of a given
    piece object and creates a new piece object. For example, we need a method that,
    given the arguments (Pawn, black) or simply (`"p"`), dynamically creates a new
    `Pawn` object with the color attribute defined as black.
  prefs: []
  type: TYPE_NORMAL
- en: 'Accordingly, let''s define a helper method in the `piece.py` file but outside
    the `Piece` class, as follows (see `4.02`—`piece.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'To support the preceding method, add the following constant to the `configurations.py`
    file (see `4.02`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code simply takes a single character as an input. It then gets
    the full name for the corresponding piece class (for example, if a `p` is given,
    it gets the full name, which is `Pawn`). It then checks the case of the character
    and defines the color variable as *white* if the input character is uppercase.
    Otherwise, the color is set to *black*. It then dynamically creates a corresponding
    piece object.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes the iteration. We have created the `Piece` class and all of its
    subclasses, and we have the ability to create `Piece` objects dynamically from
    a given input character. This class is simply an extension of the `Model` class,
    and each of the two classes can access each other's methods by keeping a reference
    to each other.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying chess pieces on the chessboard
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, let's turn our attention to displaying all the chess pieces on the chessboard.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''ll define a method named `draw_single_piece`, which draws a chess
    piece at the given position when it''s given a position, and the character representing
    the chess piece as follows (see `4.03`—`view.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is a description of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: The images of the chess pieces are stored in a folder named `pieces_image` and
    are named with the chess piece's name in `lowercase + _ + color.png` format. So
    for instance, the black queen is saved by the name `queen_black.png`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The images are added to the chessboard by using the `canvas.create_image()`
    method, which takes the *x*, *y* coordinates and a `PhotoImage()` object that
    relies on the location of the image file as its argument.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We used Tkinter's `PhotoImage` class to reference the `.png` files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition to creating and displaying a chess piece on the chessboard, we also
    *tagged* them with a custom tag called `occupied`. Tagging is an important feature
    of the Canvas widget which lets us uniquely identify items placed on the Canvas
    widget.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We  used the following helper method in the preceding code (see `4.03`—`view.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We also define another helper method that returns the numeric notation for
    the position of a piece (see `4.03`—`controller.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This is just a wrapper around the following code from `4.03`—`piece.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, it''s time simply to call the preceding `draw_single_piece` method on
    all the chess pieces (`4.03`—`view.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'A key aspect that you need to note here is that when we needed some data from
    the `Model` class, say, a dictionary containing all the chess pieces on the chessboard,
    we did not directly call the `Model` class for the data. Instead, we requested
    the controller get us the data from the model. The `get_all_pieces_on_chess_board()` controller
    method is simply a wrapper around the actual method from the `Model` class (see
    `4.03`—`controller.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Great! We now have the methods required to draw all the chess pieces on the chessboard.
    But merely defining them does not help. These methods need to be called from somewhere.
    Therefore, let''s define a new method named `start_new_game()` and call it from
    the `__init__` method of the `View` class, as follows (see `4.03`—`view.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition to calling the `draw_all pieces()` method, this method also resets
    the `Model` via calls to two wrapper controller methods (see `4.03`—`controller.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The actual methods are defined in the `Model` class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The `reset_game_data()` method is simple. It just resets all the attributes
    of the `Model` class to their initial states.
  prefs: []
  type: TYPE_NORMAL
- en: The `reset_to_initial_locations()` method initializes all the chess piece locations to
    reflect the starting position of the game. This too should be self-explanatory
    if you are aware of the data structure that we discussed earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, when you go ahead and run the code (see `4.03`—`view.py`), the chessboard
    should display all the chess pieces at the starting position of the game, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4d6034d2-d50b-473f-85bc-b9a4b67ef9d3.png)'
  prefs: []
  type: TYPE_IMG
- en: This completes the current iteration. The next iteration will define the rules
    for the movement of the chess pieces on the chessboard. We need this part done
    before we can think of moving the chess pieces around.
  prefs: []
  type: TYPE_NORMAL
- en: Defining rules for the chess pieces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Different chess pieces have different rules of movement. Let''s try to tabulate the
    rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Name of the** **chess piece** | **Orthogonal movement** | **Diagonal movement**
    | **The maximum number** **of places the chess piece**'
  prefs: []
  type: TYPE_NORMAL
- en: '**is allowed to move** |'
  prefs: []
  type: TYPE_NORMAL
- en: '| King | Yes | Yes | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| Queen | Yes | Yes | 8 |'
  prefs: []
  type: TYPE_TB
- en: '| Rook | Yes | No | 8 |'
  prefs: []
  type: TYPE_TB
- en: '| Bishop | No | Yes | 8 |'
  prefs: []
  type: TYPE_TB
- en: '| Knight | N/A | N/A | N/A |'
  prefs: []
  type: TYPE_TB
- en: '| Pawn | Yes, but it captures diagonally | No | 1 or 2 |'
  prefs: []
  type: TYPE_TB
- en: As evident from the table, the rules for all the chess pieces except for *Knight*
    and *Pawn* are pretty straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: Knights are different from the others. They must move two squares in one direction, and
    then one more move at a 90-degree angle, following the shape of an L. Knights
    are also the only chess pieces that can jump over other chess pieces.
  prefs: []
  type: TYPE_NORMAL
- en: Pawns move forward, but they capture diagonally. Pawns can only move forward one
    square at a time, except for their very first move, where they can move forward by
    two squares. Pawns can only capture one square diagonally in front of them.
  prefs: []
  type: TYPE_NORMAL
- en: Rules for the king, queen, rooks, and bishops
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's first take a look at simple cases of orthogonally and diagonally moving
    chess pieces, which are the king, queen, rooks, and bishops. We need somehow to
    figure out a way to change the position of these chess pieces by using a mathematical
    rule.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows what it takes to move a chess piece from its current position
    (say *x*, *y)* both orthogonally and diagonally:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7b70b290-f160-45f8-9a8a-5676b126e5c1.png)'
  prefs: []
  type: TYPE_IMG
- en: If you look at the preceding diagram, *x* represents the column number and *y* represents
    the row number. It is clear that we can represent the orthogonal movements by
    adding to the current position the items from the tuples (`-1`, `0`), (`0`, `1`),
    (`1`, `0`), (`0`, `-1`).
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, diagonal movements can be represented by adding to the tuples (`-1`,
    `1`), (`1`, `1`), (`1`, `-1`), (`-1`, `-1`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add these two tuples to `configurations.py` (see `4.04`), as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: If a chess piece can move both orthogonally and diagonally, such as the *queen,*
    the representative tuple is simply an addition of the preceding two tuples.
  prefs: []
  type: TYPE_NORMAL
- en: If a chess piece can be moved by more than one square, it's simply a matter
    of multiplying the representative tuple by an integer to get all the other allowed positions
    on the chessboard.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this information in mind, let''s code a `moves_available` method that,
    given the current position of the chess piece, the directions tuple relevant to
    the chess piece, and the maximum distance that the chess piece can move, returns
    a list of all the `allowed_moves`, as follows (see `4.04`—`piece.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is a description of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the arguments, the method collects all the allowed moves for a
    given chess piece in a list named `allowed_moves`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code iterates through all the locations to detect a possible collision. If
    a collision is detected, it breaks out of the loop. Otherwise, it appends the
    coordinate to the `allowed_moves` list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second to last line filters out the moves that fall outside the chessboard,
    and the last line returns the equivalent position in alphanumeric notations for
    all the allowed moves.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can also define a few helper methods to support the preceding method, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s modify the `Piece` child classes of king, queen, rooks, and bishops
    as follows (see `4.04`—`piece.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Rules for the Knight
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The knight is a different beast because it does not move orthogonally or diagonally. It
    can also jump over chess pieces.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like the rules that we followed earlier to arrive at `ORTHOGONAL_POSITIONS` and
    `DIAGONAL_POSITIONS`, we can similarly arrive at the rules that are required to
    determine the `KNIGHT_POSITIONS` tuple. This is defined in `4.04`—`configurations.py`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s override the `moves_available` method from the `Knight` class (see
    code `4.04`—`piece.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is a description of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: The method is quite similar to the previous superclass method. However, unlike
    the superclass method, the changes are represented as capture moves using the
    `KNIGHT_POSITIONS` tuple.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unlike the superclass, we do not need to track collisions, because knights can
    jump over other chess pieces.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rules for a pawn
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A pawn has a unique movement too in that it moves forward, but it captures diagonally.
    Let''s similarly override the `moves_available` class from within the `Pawn` class,
    as follows (see `4.04`—`piece.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is a description of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: We first assigned the `initial_row_position`, direction, and enemy variables
    depending on whether the pawn is black or white.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Similar to the previous `moves_allowed` methods, this method collects all the
    allowed moves in a blank list named `allowed_moves`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, we collected a list of all the prohibited moves by concatenating two lists
    of squares occupied by all the black and white chess pieces.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We defined a variable named `forward` which holds the position of the square
    immediately ahead of the current position of the pawn.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A pawn cannot move forward if there is a chess piece in front of it. If the
    forward position is not prohibited, the position is appended to the `allowed_moves`
    list.  A pawn can move two places forward from its starting position. We check
    whether the current position is the starting position, and if it is the starting
    position, we append the double move to the `allowed_moves` list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A pawn can capture only the diagonally adjacent chess pieces in front of it.
    Therefore, we assigned a variable attack to track the diagonally adjacent positions
    on the chessboard. If the diagonally adjacent square is occupied by an enemy,
    that position qualifies to be appended to the `allowed_moves` list.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, we filtered the list to remove all the positions that may fall outside the
    chessboard. The last line returns all the allowed moves as a list of corresponding
    alphanumeric notations, as we did in all the previous definitions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This completes the current iteration. We coded the logic needed to enforce the
    rules related to the movement of chess pieces on the chessboard.
  prefs: []
  type: TYPE_NORMAL
- en: Movement validation of chess pieces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we allow chess pieces to move, we must have a record of all the possible movement
    options on the chessboard. At every move, we also need to check whether it is
    a legitimate turn for a given player and the proposed move should not cause check
    on the current player's king.
  prefs: []
  type: TYPE_NORMAL
- en: Now, check may occur on the king not only from a chess piece that was moved, but
    from any other chess piece on the chessboard as a consequence of such a movement.
    Thus, after every move, we need to calculate the possible moves for all the chess
    pieces of the opponent.
  prefs: []
  type: TYPE_NORMAL
- en: 'Accordingly, we will need two methods to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Keep a track of all the available moves for a player
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check whether there is check on the king
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's add two new methods in the `Model` class (see `4.05`—`model.py`).
  prefs: []
  type: TYPE_NORMAL
- en: Tracking all available moves
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code needed to keep track of all the available moves for a player is as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The description of the code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We have already coded the `moves_available` method in the previous iteration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The preceding method simply iterates through every item in the dictionary and
    appends the `moves_available` result for every chess piece of a given color in
    a list named `result`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding out the current position of the king
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we code the method that checks whether a king is in check, we first
    need to know the exact position of the king. Let''s define a method to find out
    the current position of the king, as follows (see `4.05`—`model.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code simply iterates through all the items in the dictionary.
    If a given position is an instance of the `King` class, it simply returns its
    position.
  prefs: []
  type: TYPE_NORMAL
- en: Checking whether the king is in check
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s define a method to check whether the king is in check from the opponent, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is a description of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we obtained the current position of the king and the color of the opponent.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We then found out all the possible moves for all the chess pieces of the opponent.
    If the position of the king coincides with any position from all the possible
    moves, the king is in check and we return `True`. Otherwise, we return `False`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This accomplishes the objectives for the iteration. We are now in a position
    to check all the available moves for a player at a given point in the game. We
    can also check whether a king is in check from the opponent.
  prefs: []
  type: TYPE_NORMAL
- en: Making the game functional
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have all the chess pieces and chessboard-related validation rules
    in place, let's add life to our chess program. In this iteration, we will make
    our chess game fully functional.
  prefs: []
  type: TYPE_NORMAL
- en: The objective of this iteration is to move the chess pieces with a click of
    the left mouse button. When a player clicks on a chess piece, the code should
    first check whether it is a legitimate turn for that chess piece.
  prefs: []
  type: TYPE_NORMAL
- en: On the first click, the chess piece that needs to be moved is selected, and
    all the allowed moves for that chess piece are highlighted on the chessboard.
    The second click should be performed on the destination square. If the second
    click is done on a valid destination square, the chess piece should move from
    the source square to the destination square.
  prefs: []
  type: TYPE_NORMAL
- en: We also need to code the events of capturing chess pieces and the king being
    in check. The other attributes that need to be tracked include a list of the captured
    chess pieces, the half-move clock count, the full-move number count, and the history
    of all the previous moves.
  prefs: []
  type: TYPE_NORMAL
- en: You may recall that we created a dummy method which is bound to the left-click event.
    The method, for now, simply prints the row and column value on the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s modify this method, as follows (see `4.06`—`view.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is a description of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: The first part of the code calculates the coordinates for the chess piece on
    which you clicked. Based on the calculated coordinates, it stores the corresponding
    letter notation in a variable named `position_of_click`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It then tries to assign the piece variable to the corresponding piece instance.
    If there is no piece instance on the clicked square, it simply ignores the click.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second part of the method checks whether this is the second click that was
    intended to move a chess piece to a destination square. If this is the second
    click, it calls the `shift` method, passing the source and destination coordinates
    as its two arguments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the `shift` method succeeds, it sets all the previously set attributes to
    their original empty values and calls the `draw_board` and `draw_pieces` methods
    to redraw the chessboard and chess pieces.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While coding the desired functionality for the `on_square_clicked` method, we called
    several new methods from within it. We need to define these new methods.
  prefs: []
  type: TYPE_NORMAL
- en: Keep an eye on the `on_square_clicked` method. This is the central method around
    which all the other methods will evolve over the course of our attempts to make
    the chess game functional.
  prefs: []
  type: TYPE_NORMAL
- en: Getting the source and destination position
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have called the `shift` method from the `on_square_clicked` method. The code for
    the `shift` method is responsible for the collection of the necessary arguments that
    are required for the `shift` operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for the `shift` method is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The code first checks whether a chess piece exists at the destination. If a
    chess piece does not exist at the destination square, it calls on a method, `shift`,
    from the *controller,* which is a wrapper around the actual `shift` method from
    the `Model` class.
  prefs: []
  type: TYPE_NORMAL
- en: Collecting a list of the moves that need to be highlighted
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We also called the `update_highlight_list(position)` method from the `on_square_clicked`
    method. The purpose of this method is to collect all the possible moves for a
    given chess piece in a list named `all_squares_to_be_highlighted`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The actual focusing of the available moves takes place in the `draw_board`
    method of the GUI class. The code for this is as follows (see `4.06`—`view.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Highlighting allowed moves
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the `on_square_clicked` method, we called the `draw_board` method to take care
    of the redrawing or changing of the chess pieces' coordinates. The current `draw_board`
    method is not equipped to handle this because we only designed it in the first
    iteration to provide us with a blank chessboard.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s add a `HIGHLIGHT_COLOR` constant to the `configurations.py` file, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, modify the `draw_board` method to handle this, as follows (see `4.06`—`view.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Pre-move validation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The chess piece must only be moved if it does not violate the rules of the game.
    For example, a chess piece can move to a valid location only if that location
    is not already occupied by a chess piece of the same color. Similarly, a piece
    can move only if it is the player's turn to move. Another rule states that a piece
    can only move if the resulting move does not result in check for the king of the
    same color.
  prefs: []
  type: TYPE_NORMAL
- en: 'This `pre_move_validation` method is responsible for checking all the rules. If
    all validations pass, it calls the `move` method to update the move, as follows (see
    `4.06`—`model.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'If the rules are not being followed, this code raises several exceptions, which
    are defined in the exceptions class as follows (see `4.06`—`exceptions.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'We could have further coded the error classes, but we chose not to because
    we simply updated the name of the error class to the bottom label, which is sufficient for
    our current purpose. The error message is displayed from the shift method of the
    `View` class, as follows (see `4.06`—`view.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Check whether a move will cause check on the King
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Though a major part of the validation check done in the preceding lines is simple, one
    of the validation steps needs to check whether a movement will cause the king to
    be in check. This is a tricky situation. We can only find this out after we have made
    the actual move. However, we cannot allow that movement to happen on the chessboard.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, the `pre_move_validation` method calls a method named `will_move_cause_check`,
    which creates a copy of the `Model` class. Then, it performs a move on the new
    temporary copy to check whether it does cause a king to be in check. The code
    for this is as follows (`4.06`—`model.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Note that when you create a copy by simple assignment, Python creates a shallow
    copy. In a shallow copy, the two variables now share the same data. So, a modification
    in one place affects the other as well.
  prefs: []
  type: TYPE_NORMAL
- en: In contrast to this, deep copies create a copy of everything—the structure as
    well as the elements. We need to create a deep copy of the chessboard because
    we want to check whether the king makes a valid move before it actually moves,
    and we want to do this without modifying the original object's state in any way.
  prefs: []
  type: TYPE_NORMAL
- en: Recording a move in the data structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `shift` method defined in `view.py` is responsible for the actual moving
    of a chess piece on the chessboard. However, this brings about a change in the
    underlying data structure. The `move` method of the `Model` class is then responsible
    for updating the data structure. This `move` method is called from the previously
    defined `pre_move_validation()` method if and only if no errors are raised, as
    follows (`4.06`—`model.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Note that as soon as this update is complete, the control returns to the `on_square_clicked()`
    method in `view.py`*.* The method then calls the `draw_all_pieces()` method, which
    updates the view.
  prefs: []
  type: TYPE_NORMAL
- en: Keep game statistics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `pre_move_validation()` method also calls another method called `update_game_statistics()`
    on successfully recording a move (see `4.06`—`model.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Congratulations, our chess game is now functional!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s complete the iteration by binding the File *|* New Game menu item to
    start a new game. Earlier, we defined the `start_new_game()` method. Now, it''s
    simply a matter of calling it from the `on_new_game_menu_clicked()` method, as
    follows (`4.06`—`view.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Managing user preferences
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A very common theme in several GUI programs involves letting the user set the program's
    preferences.
  prefs: []
  type: TYPE_NORMAL
- en: For example, what if we want users to be able to customize the chessboard colors? What
    if we want users to select colors and, once selected, it is saved as a user preference
    and it is loaded the next time the program is run? Let's implement this as a feature.
  prefs: []
  type: TYPE_NORMAL
- en: Python offers a standard module called `configparser` that lets us save user preferences.
    Let's see the `configparser` module in action.
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin with, import the `ConfigParser` class from the `configparser` module in
    the `configurations.py` file, as follows (see `4.07 preferenceswindow.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The `configparser` module uses the `.ini` files to store and read the configuration values.
    The file consists of one or more named sections. These sections contain individual
    options with names and values.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate this, let''s create a file called `chess_options.ini` in the
    project''s root folder (see `4.07`). The file looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: The first line of the file enclosed in square brackets (`[chess_colors]` in
    our example) is called a **section**. A `.ini` file can have multiple sections.
    This file has a single section. Each section can have multiple *key-value* options,
    as specified in the example.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can read these values in our program by using the `getter` methods, as follows (see
    `4.07`—`configurations.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code replaces the three color constants that we defined earlier
    in the code.
  prefs: []
  type: TYPE_NORMAL
- en: Now, if you change the options in the `.ini` file, the color of the chessboard
    changes accordingly. However, we cannot expect end users to be conversant with
    editing the `.ini` files. Therefore, we will let them choose the colors using
    the **color chooser **module of Tkinter. A color that a user chooses gets reflected
    in the `.ini` file and consequently on the chessboard.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a user clicks on the Edit *|* Preference menu item, we want to open a
    *transient window* with three different buttons to choose two chessboard colors
    and one highlight color. Clicking on a single button opens a color select window,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b515c321-a74d-4b71-9ab5-f34dd1342f40.png)'
  prefs: []
  type: TYPE_IMG
- en: We created this transient window in a new file called `preferenceswindow.py`(see
    `4.07.py`). We will not discuss the code that creates this window, as this should
    be an easy task for you now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that this window is converted into a transient window with respect to
    the top-level window by using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: As a reminder, a transient window is one that always stays at the top of its parent
    window. It gets minimized when its parent window is minimized. For a quick refresher
    on transient windows, refer to [Chapter 2](41f1fda5-b3b1-4dfa-8971-2a016274d39a.xhtml),
    *Making a Text Editor,—*`2.06.py`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we have created the window in `preferencewindow.py`, we''ll import it into
    the `View` class as follows (see `2.07`—`view.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, command bind the preference menu by using the following two methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'When a user clicks on the Cancel button, we simply want the settings window
    to close. To do this, use the following code (see `4.07`—`preferencewindow.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'When a user changes the colors and clicks on the Save button, the method calls
    the `set_new_values()` method, which first writes the new values to the `.ini`
    file and then returns the values to the `View` class to update the chessboard immediately:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'When the preceding code writes the new values to the `.ini` file, call the `reload_colors()`
    method from the `View` class to update the chessboard''s color immediately. If
    you do not do this, the color change will take place the next time the chess program
    is run (see `4.07`—`view.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Having changed these attributes, we call `draw_board()` and `draw_all_pieces()` to
    repaint the chessboard in the newly defined colors. (see `4.07`—`view.py`).
  prefs: []
  type: TYPE_NORMAL
- en: This concludes the iteration. The users of the program can change the colors to
    match their preferences, and the program will remember the chosen values.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have come to the end of this chapter. So, what is it that we achieved here?
    Let's have a look at all the key things that we learned from the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We learned how to structure programs using the MVC architecture.
  prefs: []
  type: TYPE_NORMAL
- en: We took a peek at the versatility and power of the Tkinter Canvas widget. This
    included a tour through the basic usage of the canvas coordinates, object IDs,
    and tags.
  prefs: []
  type: TYPE_NORMAL
- en: We discussed how to handle complexity by implementing programs in a modular structure.
    We achieved this modularity by breaking down the code into several smaller files.
    We handled the entire configuration from a single file and all the errors in another
    file.
  prefs: []
  type: TYPE_NORMAL
- en: We explored how to extend Python's built-in error class to define a custom error
    and exceptions. We also had a look at how we can extend Python's built-in data
    types, as in the case of the `Model` class, which directly extended the `dict`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: We studied how to use object inheritance to code classes with similar attributes
    and behavior when building the `Piece` class and all its subclasses.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you learned how to use Python's built-in `configparser` module to store
    user preferences.
  prefs: []
  type: TYPE_NORMAL
- en: We will create an audio player in the next chapter. In addition to this, we'll
    work with several new widgets. We will also take a look at how to create our own
    widgets!
  prefs: []
  type: TYPE_NORMAL
- en: QA section
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before you proceed to the next chapter, make sure you can answer these questions
    to your
  prefs: []
  type: TYPE_NORMAL
- en: 'satisfaction:'
  prefs: []
  type: TYPE_NORMAL
- en: What are the central tenets of the model-view-controller framework?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is modularity in programming? Why is modularity good?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are the advantages and disadvantages of using class inheritance in programs?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While inheritance provided us with a tool to reuse our code, multiple inheritance
    is frowned upon by many experts.  What could be the reason for this?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are `tags` used for in the Tkinter Canvas widget?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why do we use a `configparser` module? What are some of the alternatives to
    using a `configparser` module?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MVC is a popular software **architectural pattern**, but there are many more
    architectural patterns that suit different use cases. Read about different architectural
    patterns at [https://en.wikipedia.org/wiki/Architectural_pattern](https://en.wikipedia.org/wiki/Architectural_pattern).
  prefs: []
  type: TYPE_NORMAL
- en: If chess enthuses you, or if you would like to get started in artificial intelligence, 
    you might attempt to implement a chess engine that plays as an opponent. This
    would require some reading on optimal search algorithms. Here's a tutorial that
    walks us through the process: [https://medium.freecodecamp.org/simple-chess-ai-step-by-step-1d55a9266977](https://medium.freecodecamp.org/simple-chess-ai-step-by-step-1d55a9266977).
    The tutorial engine has been implemented in JavaScript, but we can use it as a
    reference to build our own engine in Python.
  prefs: []
  type: TYPE_NORMAL
