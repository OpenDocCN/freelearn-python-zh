- en: Game of Chess
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 国际象棋
- en: Let's build a game of chess in Tkinter. If you already know the basic rules
    of chess, you are ready to write this program. However, if you do not know the
    rules, you should read them before you start programming this application.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在Tkinter中构建一个棋盘游戏。如果你已经了解棋盘游戏的基本规则，你就可以开始编写这个程序了。然而，如果你不知道规则，你应该在开始编程这个应用程序之前先阅读它们。
- en: 'Some of the key objectives of this chapter are as follows:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的一些关键目标如下：
- en: Learning how to structure a program in a **Model-View-Controller** (**MVC**)
    architecture
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何在**模型-视图-控制器**（MVC）架构中构建程序
- en: Learning how to tame complexity by implementing programs in a modular structure
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何通过实现模块化结构来驯服复杂性
- en: Taking a look at the versatility and power of the Tkinter Canvas widget
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看Tkinter Canvas小部件的多样性和强大功能
- en: Learning the basic usage of canvas coordinates, object IDs, and tags
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习画布坐标、对象ID和标签的基本用法
- en: Learning the recommended error-handling practices
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习推荐的错误处理实践
- en: Learning how to extend Python's built-in data types
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何扩展 Python 的内置数据类型
- en: Using object inheritance to code classes with similar attributes and behavior
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用对象继承来编写具有相似属性和行为的类
- en: Using Python's built-in `configparser` module to store program preferences
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Python 的内置 `configparser` 模块来存储程序首选项
- en: Getting acquainted with several Python modules that you will often use in a
    variety of application development projects
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 熟悉你将在各种应用开发项目中经常使用的几个Python模块
- en: An overview of the chapter
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 章节概述
- en: We will now implement a *human* versus *human* chess game. Our chess game will
    enforce all the standard rules that are applicable to a game of chess. Some advanced
    rules such as castling and en passant are left as an exercise for you.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将实现一个**人机**对战的棋局。我们的棋局将执行所有适用于棋局的标准规则。一些高级规则，如王车易位和吃过路兵，将作为练习留给你。
- en: 'In its final form, our chess program will look like this:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在其最终形态下，我们的棋类程序将看起来是这样的：
- en: '![](img/670b8c08-8200-4bdd-8a5a-83e95d0029ed.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/670b8c08-8200-4bdd-8a5a-83e95d0029ed.png)'
- en: Module requirements for this chapter
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本章节的模块要求
- en: We will not use any external third-party modules in this chapter. However, we
    will use several built-in Python modules.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将不使用任何外部第三方模块。然而，我们将使用几个内置的Python模块。
- en: 'To check whether all the required libraries are indeed provided by your Python
    distribution, type the following command in your Python command line:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查是否所有必需的库确实由您的Python发行版提供，请在您的Python命令行中输入以下命令：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This should be executed without an error message. If no errors are thrown back,
    you are ready to build the chess application. Let's get started!
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该在没有错误消息的情况下执行。如果没有抛出错误，你就可以准备构建棋类应用程序了。让我们开始吧！
- en: Structuring our program
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结构化我们的程序
- en: In this section, we decide on an overall structure for our program.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们为我们的程序确定一个整体结构。
- en: The development of large applications generally starts with recording the **software
    requirement specifications** (**SRS**). This is generally followed by a graphical representation
    of constructs, such as the class, composition, inheritance, and the hiding of
    information using several modeling tools. These tools can be flow charts, **Unified
    Modeling Language** (**UML**) tools, data flow diagrams, Venn diagrams (for database
    modeling), and so on.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 大型应用程序的开发通常从记录**软件需求规格说明书**（**SRS**）开始。这通常随后是使用几种建模工具对结构进行图形表示，例如类、组合、继承以及使用信息隐藏。这些工具可以是流程图、**统一建模语言**（**UML**）工具、数据流图、维恩图（用于数据库建模）等等。
- en: These tools are very useful when the problem domain is not very clear. However, if
    you have ever played the game of chess, you should be very well acquainted with
    the problem domain. Furthermore, our chess program can be classified as a medium-sized
    program spanning a few hundred lines of code. Therefore, let's bypass these visual
    tools and get to the actual program design.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当问题域不是很明确时，这些工具非常有用。然而，如果你曾经玩过国际象棋游戏，你应该非常熟悉问题域。此外，我们的国际象棋程序可以归类为中等规模程序，跨越了几百行代码。因此，让我们跳过这些视觉工具，直接进入实际程序设计。
- en: All of our previous projects have been structured as a single file. However,
    as programs grow in complexity, we need to break programs into modules and class
    structures.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前的所有项目都结构化为单个文件。然而，随着程序的复杂性增加，我们需要将程序分解为模块和类结构。
- en: 'One of the key objectives of this chapter is to learn to write programs in
    the **MVC** architecture. Some of the central aspects of the MVC architecture
    are as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的关键目标之一是学习编写**MVC**架构的程序。MVC架构的一些核心方面如下：
- en: A model handles backend data and logic
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型处理后端数据和逻辑
- en: A view handles the frontend presentation
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视图处理前端展示
- en: The model and view never interact directly
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型和视图从不直接交互
- en: Whenever the view needs to access backend data, it requests the controller to
    intervene with the model and fetch the required data
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每当视图需要访问后端数据时，它请求控制器介入模型并获取所需数据
- en: 'Given these aspects, let''s create three files for our chess program: `model.py`,
    `view.py`, and `controller.py` (see `4.01.py`).'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这些方面，让我们为我们的棋类程序创建三个文件：`model.py`、`view.py`和`controller.py`（参见`4.01.py`）。
- en: 'Now, let''s create an empty `Model` class, an empty `View` class, and a `Controller`
    class in their respective files, as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在各自的文件中创建一个空的 `Model` 类，一个空的 `View` 类，以及一个 `Controller` 类，具体如下：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note that since the `Controller` class needs to fetch data from the `Model`
    class, we instantiated a new `Model` class from within the `Controller` class.
    This now provides us with a way to fetch data from the `Model` class as and when
    needed.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，由于`Controller`类需要从`Model`类获取数据，我们在`Controller`类内部实例化了一个新的`Model`类。这现在为我们提供了一种按需从`Model`类获取数据的方法。
- en: 'Let''s also add a separate file called `exceptions.py`. This will be our central
    place for the handling of all errors and exceptions. Within this file, add the
    following single line of code:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再添加一个名为 `exceptions.py` 的单独文件。这个文件将成为我们处理所有错误和异常的中心位置。在这个文件中，添加以下单行代码：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We created a custom `ChessError` class that was inherited from the standard `Exception`
    class. This simple line of code now allows the `ChessError` class and all of its
    children to raise errors, which can then be handled by using the `try…except` block.
    All the new error classes that will be defined in our code from now on will derive
    from this `ChessError` base class.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个自定义的 `ChessError` 类，它继承自标准 `Exception` 类。现在，这一行简单的代码允许 `ChessError` 类及其所有子类抛出错误，这些错误可以通过使用
    `try…except` 块来处理。从现在开始，我们代码中定义的所有新错误类都将从这个 `ChessError` 基类派生。
- en: With this boilerplate code out of the way, let's create another blank file called `configurations.py
    (4.01)`. We will use this file to store all the constants and configurable values
    in one place.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 将这个模板代码移除后，让我们创建另一个名为 `configurations.py (4.01)`的空白文件。我们将使用这个文件来存储所有常量和可配置值在一个地方。
- en: 'Let''s define some constants right away, as follows (see code `4.01`—`configurations.py`):'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '让我们立即定义一些常量，如下所示（参见代码`4.01`—`configurations.py`):'
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To make these constant values available to all files, let''s import them in
    to the `model.py`, `view.py`, and `controller.py` folders (see `4.01`):'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让这些常量值对所有文件可用，让我们将它们导入到`model.py`、`view.py`和`controller.py`文件夹中（参见`4.01`）：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'As per the tenets of the MVC architecture, the `View` class is never supposed
    to interact directly with the `Model` class. It should always interact with the
    `Controller` class, and the `Controller` class is then responsible for fetching
    data from the `Model` class. Accordingly, let''s import the controller in the
    `View` class and the model in the `Controller` class, as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 MVC 架构的原则，`View` 类永远不应该直接与 `Model` 类交互。它应该始终与 `Controller` 类交互，然后由 `Controller`
    类负责从 `Model` 类获取数据。因此，让我们按照以下方式在 `View` 类中导入控制器，在 `Controller` 类中导入模型：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let''s start by editing the `view.py` file to display a chessboard (see `4.01`—`view.py`).
    Our goal for this iteration is to display the empty chessboard as shown in the
    following screenshot:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从编辑`view.py`文件开始，以显示棋盘（参见`4.01`—`view.py`）。本次迭代的目的是显示如下截图所示的空棋盘：
- en: '![](img/40be4ee4-13b3-4b49-a482-7df875247a4b.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/40be4ee4-13b3-4b49-a482-7df875247a4b.png)'
- en: Take a look at the code implementation in `view.py` (see `4.01`).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 查看代码实现，请参阅`view.py`（见`4.01`）。
- en: 'The `__init__` method of the `View` class calls a method called `create_chess_base`, which
    is defined as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`View` 类的 `__init__` 方法调用了名为 `create_chess_base` 的方法，该方法定义如下：'
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We will not reproduce the code responsible for the creation of the root window,
    the menu at the top, or the frame at the bottom. We have implemented similar widgets in
    previous chapters (see `4.01`—`view.py` for a complete reference).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会重现创建根窗口、顶部菜单或底部框架的代码。我们已在之前的章节中实现了类似的控件（参见`4.01`—`view.py`以获取完整参考）。
- en: 'However, we will discuss the code that creates the chessboard:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们将讨论创建棋盘的代码：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Nothing fancy here. Creating a Canvas widget is similar to creating other widgets
    in Tkinter. The Canvas widget takes the `width` and `height` of two configurable
    options. Next, paint the Canvas widget in alternating shades to form the chessboard (`view.py`):'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有太多花哨的东西。创建一个Canvas小部件与在Tkinter中创建其他小部件类似。Canvas小部件接受两个可配置选项的`width`和`height`。接下来，用交替的色调绘制Canvas小部件以形成棋盘（`view.py`）：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The following is the description of the code:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对代码的描述：
- en: We used the Canvas widget's `create_rectangle()` method to draw alternating
    shades of squares to resemble a chessboard.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用了Canvas小部件的`create_rectangle()`方法来绘制交替阴影的方块，以模拟棋盘。
- en: The rectangles are drawn from point `x1`, `y1`, and they extend to `x2`, `y2`. These
    values correspond to two diagonally opposite corners of the rectangle (coordinates
    of the upper-left and lower-right edges).
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 矩形是从点 `x1`, `y1` 绘制，并延伸到 `x2`, `y2`。这些值对应于矩形的两个对角相对的角（上左和下右边的坐标）。
- en: The `x` and `y` values are calculated by using a newly defined method called `get_x_y_coordinate()`,
    which performs simple mathematics depending on the dimensions of each square that
    was defined in pixel units earlier.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x`和`y`值是通过使用一种新定义的方法`get_x_y_coordinate()`计算得出的，该方法根据之前以像素单位定义的每个正方形的尺寸执行简单的数学运算。'
- en: The `y` value is calculated by first subtracting a row from (7-row) because the
    Canvas widget measures the coordinates starting from the top left. The top-left
    corner of the canvas has the coordinates (`0`, `0`).
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`y` 值是通过首先从（7行）中减去一行来计算的，因为 Canvas 小部件是从左上角开始测量坐标的。画布的左上角坐标为 (`0`, `0`)。'
- en: The `get_alternate_color` method is a helper method that, not surprisingly,
    returns the alternate color.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get_alternate_color` 方法是一个辅助方法，不出所料，它返回交替颜色。'
- en: The Tkinter Canvas widget lets you draw a line, an oval, a rectangle, an arc,
    and polygon shapes at a given coordinate. You can also specify various configuration
    options, such as fill, outline, width, and so on for each of these shapes.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Tkinter画布小部件允许你在指定的坐标处绘制线条、椭圆形、矩形、圆弧和多边形等形状。你还可以为这些形状指定各种配置选项，例如填充、轮廓、宽度等。
- en: The Canvas widget uses a coordinate system to specify the position of objects
    on the widget. Coordinates are measured in pixels. The top-left corner of the
    canvas has the coordinates (`0`, `0`).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 画布小部件使用一个坐标系来指定小部件上对象的位置。坐标以像素为单位进行测量。画布的左上角坐标为 (`0`, `0`)。
- en: The objects drawn on the Canvas widget are usually handled by assigning them
    an ID or a tag. We will see an example of this later in the chapter.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在Canvas小部件上绘制的对象通常通过分配一个ID或标签来处理。我们将在本章后面看到一个例子。
- en: If an object on the Canvas widget is tagged to multiple tags, the options defined
    for tags at the top of the stack have precedence.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果画布小部件上的对象被标记为多个标签，则堆栈顶部标签定义的选项具有优先权。
- en: However, you can change the precedence of tags by using `tag_raise(name)` or
    `tag_lower(name)`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，您可以通过使用`tag_raise(name)`或`tag_lower(name)`来改变标签的优先级。
- en: 'For a complete list of Canvas widget-related options, refer to the interactive
    help for the Canvas widget using `help(Tkinter.Canvas)` in the command line, as
    follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取Canvas小部件相关选项的完整列表，请参考使用命令行中的`help(Tkinter.Canvas)`获取Canvas小部件的交互式帮助，如下所示：
- en: '`>>> import tkinter`'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`>>> import tkinter`'
- en: '**`>>> help(tkinter.Canvas)`**'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**`>>> help(tkinter.Canvas)`**'
- en: 'Next, let''s bind the mouse click to the Canvas widget from the `__init__`
    method of the `View` class (see `4.01`—`view.py`), as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们在`View`类的`__init__`方法中将鼠标点击绑定到Canvas小部件（参见`4.01`—`view.py`），如下所示：
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The bound method calls another method called `get_clicked_row_column()`, and
    for now it prints the result on the console as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定方法调用另一个名为 `get_clicked_row_column()` 的方法，目前它将结果按如下方式打印到控制台：
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `get_clicked_row_column()` method is defined as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_clicked_row_column()` 方法定义如下：'
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, if you run the code (see `4.01`—`view.py`) and click on different squares,
    it should output a message like this to the console:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你运行代码（见`4.01`—`view.py`）并点击不同的方块，它应该会在控制台输出类似以下的消息：
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This completes our first iteration. In this iteration, we determined the broader
    file structure for the chess program. We created the `model`, `view`, and `controller` classes.
    We also decided to keep all the constants and configuration values in a separate
    file called `configurations.py`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了我们的第一次迭代。在这个迭代中，我们确定了棋类程序的更广泛文件结构。我们创建了`model`、`view`和`controller`类。我们还决定将所有常量和配置值保存在一个名为`configurations.py`的单独文件中。
- en: We have now had a first taste of the Canvas widget. We created a blank canvas
    and then added square areas using the `canvas.create_rectangle` method to create a
    chessboard.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经初步体验了Canvas小部件。我们创建了一个空白画布，然后使用`canvas.create_rectangle`方法添加了方形区域，从而创建了一个棋盘。
- en: Now, if you run `4.01`—`view.py`, you will see an empty chessboard. You will
    also find out that the *File* menu and the *Edit* menu dropdowns are not functional.
    The *About* menu should show a standard `messagebox` widget.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你运行 `4.01`—`view.py`，你会看到一个空白的棋盘。你还会发现 *文件* 菜单和 *编辑* 菜单的下拉菜单不可用。*关于* 菜单应该显示一个标准的
    `messagebox` 小部件。
- en: Before you proceed to the next section, you are encouraged to go and explore
    the code in the `4.01` folder in its entirety.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在你继续阅读下一节之前，我们鼓励你全面地探索`4.01`文件夹中的代码。
- en: Modeling the data structure
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟数据结构
- en: Coming back to the old adage, data structures, not algorithms, are central to
    writing good programs. Therefore, it is important that we spend some time defining
    the data structure.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 回到那句古老的谚语，数据结构，而非算法，是编写良好程序的核心。因此，花些时间定义数据结构是很重要的。
- en: The key data that the model needs to record is the position of the chess pieces
    on the chessboard. Accordingly, we first need a way to define these locations
    and a unique way to identify the chess pieces. Let's first agree to the naming
    conventions that we will stick to in the program.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 模型需要记录的关键数据是棋盘上棋子的位置。因此，我们首先需要一个方法来定义这些位置，以及一个独特的方式来识别棋子。让我们首先同意我们将遵守的程序中的命名约定。
- en: Convention on naming chess pieces
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 国际象棋棋子命名公约
- en: Every chess piece is identified by a single letter (pawn = p, knight = n (yes
    knight with an n!), bishop = b, rook = r, queen = q, and king = k).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 每个棋子都由一个单独的字母来标识（兵 = p，马 = n（是的，马用 n 表示！），象 = b，车 = r，后 = q，王 = k）。
- en: The *white* chess pieces are represented by *uppercase* letters (PNBRQK), and
    the *black* chess pieces are represented by *lowercase* letters (pnbrqk).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 白色棋子用大写字母（PNBRQK）表示，黑色棋子用小写字母（pnbrqk）表示。
- en: Convention for naming locations on the chessboard
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 国际象棋棋盘上地点命名的规则
- en: In order to assign unique identifiers to every square on the chessboard, we
    will mark the squares along the *x* axis by using the letters A to H. We will
    mark the *y* axis by using the numbers 1 to 8.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 为了给棋盘上的每一个方格分配唯一的标识符，我们将使用字母A到H来标记*x*轴上的方格。我们将使用数字1到8来标记*y*轴。
- en: 'Accordingly, the squares on the chessboard will be identified as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，棋盘上的方格将被标识如下：
- en: '![](img/27a601f3-ad2e-4128-a2c0-cc1255f1f6fb.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/27a601f3-ad2e-4128-a2c0-cc1255f1f6fb.png)'
- en: Thus, **A1** denotes the leftmost square at the bottom of the chessboard. Currently,
    it is occupied by a white rook. The **C3** position is currently empty, **E8**
    has a black king, and **A8** has a black rook.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，**A1** 表示棋盘最左下角的方块。目前，它被一个白方车占据。**C3** 位置目前是空的，**E8** 有一个黑方国王，而 **A8** 有一个黑方车。
- en: 'Let''s add this to the `configurations.py` file (see `4.02`):'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这个添加到`configurations.py`文件中（参见`4.02`）：
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now, if you want to represent the chessboard at any point in time, all you need
    is a mapping of the location to the chess piece at that location. Looks like a
    perfect candidate for storing as a Python dictionary.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你想在某个时间点表示棋盘，你所需要的只是一个将位置映射到该位置棋子的映射。看起来这是一个存储为Python字典的完美候选者。
- en: 'Thus, the initial position of all the chess pieces on the chessboard can be
    represented as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，棋盘上所有棋子的初始位置可以表示如下：
- en: '[PRE14]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We need this data to get started. So, let's add this as a constant to the `configurations.py`
    file (see `4.02`).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要这些数据来开始工作。因此，让我们将此作为常量添加到`configurations.py`文件中（见`4.02`）。
- en: Now, let's move on to code the `Model` class for our program. We have already decided
    that we will use a Python dictionary to store the position of chess pieces on
    the chessboard. We can go ahead and add a dictionary attribute to the class.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续为我们的程序编写`Model`类。我们已经决定将使用Python字典来存储棋盘上棋子的位置。我们可以继续为类添加一个字典属性。
- en: However, we will take a slightly different approach.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们将采取一种略有不同的方法。
- en: 'Let''s make the `Model` class a child class of the built-in dictionary class,
    as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将`Model`类设置为内置字典类的子类，如下所示：
- en: '[PRE15]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Thus, the `self` variable that refers to the current class object instance will
    also have all the properties and methods that are available to the dictionary.
    All the methods that are available to the standard dictionary class can now be
    called on the `Model` object (`self`).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，指向当前类对象实例的`self`变量也将拥有字典中可用的所有属性和方法。现在可以在`Model`对象（`self`）上调用标准字典类中可用的所有方法。
- en: 'So now we can define a method that returns the short name of the chess piece
    at that position when it''s given a position on the chessboard, as follows (see
    `4.02`—`model.py`):'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在我们可以定义一个方法，当给定棋盘上的位置时，它返回该位置棋子的简称，如下所示（参见 `4.02`—`model.py`）：
- en: '[PRE16]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If there is no chess piece at the position, this returns `None` rather than
    giving a `KeyError` exception.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果该位置没有棋子，则返回`None`而不是抛出`KeyError`异常。
- en: 'Next, let''s add some more important attributes to the `Model` class, as follows
    (see `4.02`—`model.py`):'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '接下来，让我们给`Model`类添加一些更重要的属性，如下所示（见`4.02`—`model.py`):'
- en: '[PRE17]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `half-move_clock` keeps a track of the number of turns played since the
    last pawn's advance or the last capture. This is used to determine whether a draw can
    be claimed under the `fifty-move` rule.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`half-move_clock` 记录自上次兵的推进或上次捕获以来的回合数。这用于确定是否可以根据 `五十回合` 规则要求判和。'
- en: The `full-move` number is a count that is incremented by `1` after every move
    of a black piece. This is used to track the overall length of a game.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`全移动数`是指在每一步黑棋移动后增加`1`的计数。这用于跟踪整场比赛的总长度。'
- en: 'Finally, let''s add another method that, given the row-column tuple for a square, returns
    its alphanumeric position (for example, an input of (`1`, `2`) returns `B3`):'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们再添加一种方法，该方法根据正方形的行-列元组返回其字母数字位置（例如，输入（`1`，`2`）返回 `B3`）：
- en: '[PRE18]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Next, let''s define an associated helper method to ensure that we only process
    mouse clicks that occur on the Canvas widget and not anywhere else in the root
    window, as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们定义一个相关的辅助方法，以确保我们只处理发生在 Canvas 小部件上的鼠标点击，而不是根窗口的任何其他地方，具体如下：
- en: '[PRE19]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: There is not much that can be added to the `Model` class for now until we lay
    down the code logic to handle the chess pieces.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 目前为止，在`Model`类中添加的内容并不多，直到我们编写代码逻辑来处理棋子。
- en: We can define the rules for all the chess pieces within the `Model` class, but
    that would make the `Model` class too bulky.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`Model`类中定义所有棋子的规则，但这会使`Model`类变得过于庞大。
- en: Therefore, let's define the chess piece-related logic in a new file named `piece.py`.
    Since this is inherently a part of the `Model` class but it is defined in a new
    file, let's add a reference to the `Model` class within this file.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们在一个名为 `piece.py` 的新文件中定义棋子相关的逻辑。由于这本质上是 `Model` 类的一部分，但它定义在一个新文件中，所以让我们在这个文件内添加对
    `Model` 类的引用。
- en: (see `4.02`—`piece.py`)
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: (参见 `4.02`—`piece.py`)
- en: Let's do this next.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来做这个。
- en: Creating a Piece class
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个 Piece 类
- en: Think about it. We need to define rules for all the different chess pieces.
    Some attributes and methods, such as color, will be common to all the chess pieces,
    while other attributes/methods, such as rules for movement, will vary for each
    chess piece.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 想想看。我们需要为所有不同的棋子定义规则。一些属性和方法，例如颜色，将适用于所有棋子，而其他属性/方法，例如移动规则，将因每个棋子而异。
- en: 'First, we''ll define a new `Piece` class. This class will have the attributes
    and methods that are common to all the chess pieces. Then, we will define classes
    for every individual piece as a subclass of this parent `Piece` class. We can
    then override all the attributes and methods in these individual classes. The
    code will look like this (see `4.02`—`piece.py`):'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将定义一个新的 `Piece` 类。这个类将包含所有棋子共有的属性和方法。然后，我们将为每个单独的棋子定义一个类，作为这个父 `Piece`
    类的子类。我们可以在这些单独的类中重写所有的属性和方法。代码将看起来像这样（参见 `4.02`—`piece.py`）：
- en: '[PRE20]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note that the `Piece` class needs `color` as an argument for object creation.
    We create two attributes, named `self.name` and `self.color`, in the class.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`Piece` 类在对象创建时需要 `color` 作为参数。我们在类中创建了两个属性，分别命名为 `self.name` 和 `self.color`。
- en: Also note the `keep_reference(self, model)` method definition. Since the `Piece` class
    is nothing but an extension of the `Model` class, we need to get a reference to
    the `Model` class in this method to communicate with it.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意`keep_reference(self, model)`方法的定义。由于`Piece`类不过是`Model`类的一个扩展，因此在这个方法中我们需要获取到`Model`类的引用以便与之通信。
- en: 'Similarly, the `Model` class needs a reference to the new `Piece` class. Accordingly,
    we add this as an import to the `Model` class, as follows (see `4.02`—`model.py`):'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，`Model` 类需要引用新的 `Piece` 类。因此，我们将此作为导入添加到 `Model` 类中，如下所示（见 `4.02`—`model.py`）：
- en: '[PRE21]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Finally, we need a method that takes a string pertaining to the name of a given
    piece object and creates a new piece object. For example, we need a method that,
    given the arguments (Pawn, black) or simply (`"p"`), dynamically creates a new
    `Pawn` object with the color attribute defined as black.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要一个方法，它接受一个与给定棋子对象名称相关的字符串，并创建一个新的棋子对象。例如，我们需要一个方法，给定参数（兵，黑色）或简单地（`"p"`），动态创建一个新的具有颜色属性定义为黑色的`Pawn`对象。
- en: 'Accordingly, let''s define a helper method in the `piece.py` file but outside
    the `Piece` class, as follows (see `4.02`—`piece.py`):'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们在`piece.py`文件中但不在`Piece`类外部定义一个辅助方法，如下所示（见`4.02`—`piece.py`）：
- en: '[PRE22]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'To support the preceding method, add the following constant to the `configurations.py`
    file (see `4.02`):'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持上述方法，请将以下常量添加到`configurations.py`文件中（参见`4.02`）：
- en: '[PRE23]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The preceding code simply takes a single character as an input. It then gets
    the full name for the corresponding piece class (for example, if a `p` is given,
    it gets the full name, which is `Pawn`). It then checks the case of the character
    and defines the color variable as *white* if the input character is uppercase.
    Otherwise, the color is set to *black*. It then dynamically creates a corresponding
    piece object.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码简单地接受单个字符作为输入。然后它获取对应棋子类的完整名称（例如，如果输入的是 `p`，它将获取完整的名称，即 `Pawn`）。接着它检查字符的大小写，如果输入字符是大写，则将颜色变量定义为
    *白色*。否则，颜色设置为 *黑色*。然后它动态创建一个对应的棋子对象。
- en: This concludes the iteration. We have created the `Piece` class and all of its
    subclasses, and we have the ability to create `Piece` objects dynamically from
    a given input character. This class is simply an extension of the `Model` class,
    and each of the two classes can access each other's methods by keeping a reference
    to each other.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了迭代。我们已经创建了`Piece`类及其所有子类，并且能够从给定的输入字符动态创建`Piece`对象。这个类仅仅是`Model`类的一个扩展，两个类都可以通过保持对彼此的引用来访问对方的方法。
- en: Displaying chess pieces on the chessboard
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在棋盘上显示棋子
- en: Now, let's turn our attention to displaying all the chess pieces on the chessboard.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将注意力转向在棋盘上显示所有棋子。
- en: 'First, we''ll define a method named `draw_single_piece`, which draws a chess
    piece at the given position when it''s given a position, and the character representing
    the chess piece as follows (see `4.03`—`view.py`):'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将定义一个名为 `draw_single_piece` 的方法，该方法在给定位置并传入棋子字符时，将在该位置绘制一个棋子，其字符表示如下（参见
    `4.03`—`view.py`）：
- en: '[PRE24]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The following is a description of the preceding code:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对前面代码的描述：
- en: The images of the chess pieces are stored in a folder named `pieces_image` and
    are named with the chess piece's name in `lowercase + _ + color.png` format. So
    for instance, the black queen is saved by the name `queen_black.png`.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 棋子的图片存储在一个名为 `pieces_image` 的文件夹中，并以 `lowercase + _ + color.png` 格式命名。例如，黑后棋子的图片保存为
    `queen_black.png`。
- en: The images are added to the chessboard by using the `canvas.create_image()`
    method, which takes the *x*, *y* coordinates and a `PhotoImage()` object that
    relies on the location of the image file as its argument.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用`canvas.create_image()`方法将图像添加到棋盘上，该方法需要*x*、*y*坐标以及一个以图像文件位置为参数的`PhotoImage()`对象。
- en: We used Tkinter's `PhotoImage` class to reference the `.png` files.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用了Tkinter的`PhotoImage`类来引用`.png`文件。
- en: In addition to creating and displaying a chess piece on the chessboard, we also
    *tagged* them with a custom tag called `occupied`. Tagging is an important feature
    of the Canvas widget which lets us uniquely identify items placed on the Canvas
    widget.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了在棋盘上创建和显示棋子外，我们还用自定义标签`occupied`对它们进行了标记。标记是Canvas小部件的一个重要功能，它使我们能够唯一地识别放置在Canvas小部件上的项目。
- en: 'We  used the following helper method in the preceding code (see `4.03`—`view.py`):'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前面代码中使用了以下辅助方法（见`4.03`—`view.py`）：
- en: '[PRE25]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We also define another helper method that returns the numeric notation for
    the position of a piece (see `4.03`—`controller.py`):'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还定义了另一个辅助方法，该方法返回棋子位置的数字表示（参见`4.03`—`controller.py`）：
- en: '[PRE26]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This is just a wrapper around the following code from `4.03`—`piece.py`:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是对以下来自`4.03`—`piece.py`的代码的一个包装：
- en: '[PRE27]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, it''s time simply to call the preceding `draw_single_piece` method on
    all the chess pieces (`4.03`—`view.py`):'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，只需在所有棋子（`4.03`—`view.py`）上调用前面的 `draw_single_piece` 方法：
- en: '[PRE28]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'A key aspect that you need to note here is that when we needed some data from
    the `Model` class, say, a dictionary containing all the chess pieces on the chessboard,
    we did not directly call the `Model` class for the data. Instead, we requested
    the controller get us the data from the model. The `get_all_pieces_on_chess_board()` controller
    method is simply a wrapper around the actual method from the `Model` class (see
    `4.03`—`controller.py`):'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '在这里需要你注意的一个关键方面是，当我们需要从`Model`类获取一些数据时，比如说，一个包含棋盘上所有棋子的字典，我们并没有直接调用`Model`类来获取数据。相反，我们请求控制器从模型中获取数据。`get_all_pieces_on_chess_board()`控制器方法只是`Model`类实际方法的包装（参见`4.03`—`controller.py`):'
- en: '[PRE29]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Great! We now have the methods required to draw all the chess pieces on the chessboard.
    But merely defining them does not help. These methods need to be called from somewhere.
    Therefore, let''s define a new method named `start_new_game()` and call it from
    the `__init__` method of the `View` class, as follows (see `4.03`—`view.py`):'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！我们现在已经有了在棋盘上绘制所有棋子的方法。但仅仅定义它们是不够的。这些方法需要从某个地方被调用。因此，让我们定义一个新的方法名为 `start_new_game()`
    并在 `View` 类的 `__init__` 方法中调用它，如下所示（见 `4.03`—`view.py`）：
- en: '[PRE30]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In addition to calling the `draw_all pieces()` method, this method also resets
    the `Model` via calls to two wrapper controller methods (see `4.03`—`controller.py`):'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 除了调用`draw_all pieces()`方法外，此方法还通过调用两个包装控制器方法来重置`Model`（参见`4.03`—`controller.py`）：
- en: '[PRE31]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The actual methods are defined in the `Model` class, as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 实际方法在`Model`类中定义，如下所示：
- en: '[PRE32]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The `reset_game_data()` method is simple. It just resets all the attributes
    of the `Model` class to their initial states.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`reset_game_data()` 方法很简单。它只是将 `Model` 类的所有属性重置为其初始状态。'
- en: The `reset_to_initial_locations()` method initializes all the chess piece locations to
    reflect the starting position of the game. This too should be self-explanatory
    if you are aware of the data structure that we discussed earlier.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`reset_to_initial_locations()` 方法将所有棋子位置初始化为反映游戏起始位置。如果你了解我们之前讨论过的数据结构，这一点也应该不言而喻。'
- en: 'Now, when you go ahead and run the code (see `4.03`—`view.py`), the chessboard
    should display all the chess pieces at the starting position of the game, as shown
    in the following screenshot:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你运行代码（见`4.03`—`view.py`）时，棋盘应该显示所有棋子在游戏起始位置的状态，如下面的截图所示：
- en: '![](img/4d6034d2-d50b-473f-85bc-b9a4b67ef9d3.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4d6034d2-d50b-473f-85bc-b9a4b67ef9d3.png)'
- en: This completes the current iteration. The next iteration will define the rules
    for the movement of the chess pieces on the chessboard. We need this part done
    before we can think of moving the chess pieces around.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了当前的迭代。下一个迭代将定义棋盘上棋子移动的规则。在我们考虑移动棋子之前，我们需要这部分完成。
- en: Defining rules for the chess pieces
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义棋子的规则
- en: 'Different chess pieces have different rules of movement. Let''s try to tabulate the
    rules:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 不同棋子的移动规则各不相同。让我们尝试将这些规则制成表格：
- en: '| **Name of the** **chess piece** | **Orthogonal movement** | **Diagonal movement**
    | **The maximum number** **of places the chess piece**'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '**is allowed to move** |'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '**允许移动** |'
- en: '| King | Yes | Yes | 1 |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| 国王 | 是 | 是 | 1 |'
- en: '| Queen | Yes | Yes | 8 |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| 王后 | 是 | 是 | 8 |'
- en: '| Rook | Yes | No | 8 |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| 车卒 | 是 | 否 | 8 |'
- en: '| Bishop | No | Yes | 8 |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| 主教 | 否 | 是 | 8 |'
- en: '| Knight | N/A | N/A | N/A |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| 骑士 | N/A | N/A | N/A |'
- en: '| Pawn | Yes, but it captures diagonally | No | 1 or 2 |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| 兵 | 是的，但可以斜着吃子 | 否 | 1 或 2 |'
- en: As evident from the table, the rules for all the chess pieces except for *Knight*
    and *Pawn* are pretty straightforward.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如表格所示，除了**马**和**兵**之外，所有棋子的规则都非常简单明了。
- en: Knights are different from the others. They must move two squares in one direction, and
    then one more move at a 90-degree angle, following the shape of an L. Knights
    are also the only chess pieces that can jump over other chess pieces.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 骑士与其他棋子不同。它们必须在一个方向上移动两个方格，然后以90度角再移动一步，形成L形。骑士也是唯一能够跳过其他棋子的棋子。
- en: Pawns move forward, but they capture diagonally. Pawns can only move forward one
    square at a time, except for their very first move, where they can move forward by
    two squares. Pawns can only capture one square diagonally in front of them.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 兵棋向前移动，但它们可以斜向捕获。兵棋每次只能向前移动一个方格，除了它们的第一步移动，那时它们可以向前移动两个方格。兵棋只能斜向捕获它们前方的一个方格。
- en: Rules for the king, queen, rooks, and bishops
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 国王、王后、车和象的规则
- en: Let's first take a look at simple cases of orthogonally and diagonally moving
    chess pieces, which are the king, queen, rooks, and bishops. We need somehow to
    figure out a way to change the position of these chess pieces by using a mathematical
    rule.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看正交和对角移动的简单棋子案例，这些是国王、王后、车和象。我们需要找到一种方法，通过数学规则来改变这些棋子的位置。
- en: 'The following diagram shows what it takes to move a chess piece from its current position
    (say *x*, *y)* both orthogonally and diagonally:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表展示了将棋子从当前位置（比如说 *x*，*y*）沿正交和斜向移动所需的步骤：
- en: '![](img/7b70b290-f160-45f8-9a8a-5676b126e5c1.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7b70b290-f160-45f8-9a8a-5676b126e5c1.png)'
- en: If you look at the preceding diagram, *x* represents the column number and *y* represents
    the row number. It is clear that we can represent the orthogonal movements by
    adding to the current position the items from the tuples (`-1`, `0`), (`0`, `1`),
    (`1`, `0`), (`0`, `-1`).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您查看前面的图表，*x* 代表列号，而 *y* 代表行号。很明显，我们可以通过向当前位置添加元组（`-1`, `0`）、（`0`, `1`）、（`1`,
    `0`）、（`0`, `-1`）中的项来表示正交移动。
- en: Similarly, diagonal movements can be represented by adding to the tuples (`-1`,
    `1`), (`1`, `1`), (`1`, `-1`), (`-1`, `-1`).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，对角线移动可以通过向元组（`-1`, `1`），（`1`, `1`），（`1`, `-1`），（`-1`, `-1`）中添加来表示。
- en: 'Let''s add these two tuples to `configurations.py` (see `4.04`), as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`configurations.py`文件中添加这两个元组（见`4.04`），如下所示：
- en: '[PRE33]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: If a chess piece can move both orthogonally and diagonally, such as the *queen,*
    the representative tuple is simply an addition of the preceding two tuples.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个棋子可以同时进行水平和斜向移动，例如*皇后*，那么其代表元组就是前两个元组的简单相加。
- en: If a chess piece can be moved by more than one square, it's simply a matter
    of multiplying the representative tuple by an integer to get all the other allowed positions
    on the chessboard.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个棋子可以移动超过一个方格，那么只需将代表元组乘以一个整数，就可以得到棋盘上所有允许的其他位置。
- en: 'With this information in mind, let''s code a `moves_available` method that,
    given the current position of the chess piece, the directions tuple relevant to
    the chess piece, and the maximum distance that the chess piece can move, returns
    a list of all the `allowed_moves`, as follows (see `4.04`—`piece.py`):'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 带着这些信息，让我们编写一个`moves_available`方法，该方法根据棋子的当前位置、与棋子相关的方向元组以及棋子可以移动的最大距离，返回所有允许的`allowed_moves`列表，如下所示（参见`4.04`—`piece.py`）：
- en: '[PRE34]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The following is a description of the preceding code:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对前面代码的描述：
- en: Depending on the arguments, the method collects all the allowed moves for a
    given chess piece in a list named `allowed_moves`.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据参数，该方法将给定棋子的所有允许移动收集到一个名为 `allowed_moves` 的列表中。
- en: The code iterates through all the locations to detect a possible collision. If
    a collision is detected, it breaks out of the loop. Otherwise, it appends the
    coordinate to the `allowed_moves` list.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码遍历所有位置以检测可能的碰撞。如果检测到碰撞，它将跳出循环。否则，它将坐标添加到`allowed_moves`列表中。
- en: The second to last line filters out the moves that fall outside the chessboard,
    and the last line returns the equivalent position in alphanumeric notations for
    all the allowed moves.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 倒数第二行过滤掉所有超出棋盘范围的走法，最后一行返回所有允许走法的等效位置，以字母数字符号表示。
- en: 'We can also define a few helper methods to support the preceding method, as
    follows:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以定义几个辅助方法来支持前面的方法，具体如下：
- en: '[PRE35]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Next, let''s modify the `Piece` child classes of king, queen, rooks, and bishops
    as follows (see `4.04`—`piece.py`):'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们按照以下方式修改国王、王后、车和象的`Piece`子类（参见`4.04`—`piece.py`）：
- en: '[PRE36]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Rules for the Knight
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 骑士规则
- en: The knight is a different beast because it does not move orthogonally or diagonally. It
    can also jump over chess pieces.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 骑士是一种不同的棋子，因为它既不沿正交方向也不沿对角线移动。它还可以跳过其他棋子。
- en: 'Like the rules that we followed earlier to arrive at `ORTHOGONAL_POSITIONS` and
    `DIAGONAL_POSITIONS`, we can similarly arrive at the rules that are required to
    determine the `KNIGHT_POSITIONS` tuple. This is defined in `4.04`—`configurations.py`,
    as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们之前遵循的规则来达到`ORTHOGONAL_POSITIONS`和`DIAGONAL_POSITIONS`，我们同样可以得出确定`KNIGHT_POSITIONS`元组的所需规则。这定义在`4.04`—`configurations.py`中，如下所示：
- en: '[PRE37]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Next, let''s override the `moves_available` method from the `Knight` class (see
    code `4.04`—`piece.py`):'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '接下来，让我们重写`Knight`类中的`moves_available`方法（参见代码`4.04`—`piece.py`):'
- en: '[PRE38]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The following is a description of the preceding code:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对前面代码的描述：
- en: The method is quite similar to the previous superclass method. However, unlike
    the superclass method, the changes are represented as capture moves using the
    `KNIGHT_POSITIONS` tuple.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该方法与之前的超类方法相当相似。然而，与超类方法不同，这些变化是通过使用`KNIGHT_POSITIONS`元组来表示的捕获移动。
- en: Unlike the superclass, we do not need to track collisions, because knights can
    jump over other chess pieces.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与超类不同，我们不需要跟踪碰撞，因为骑士可以跳过其他棋子。
- en: Rules for a pawn
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 车的规则
- en: 'A pawn has a unique movement too in that it moves forward, but it captures diagonally.
    Let''s similarly override the `moves_available` class from within the `Pawn` class,
    as follows (see `4.04`—`piece.py`):'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 车兵也有独特的移动方式，它向前移动，但可以斜着吃子。我们可以类似地从`Pawn`类内部覆盖`moves_available`类，如下所示（参见`4.04`—`piece.py`）：
- en: '[PRE39]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The following is a description of the preceding code:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对前面代码的描述：
- en: We first assigned the `initial_row_position`, direction, and enemy variables
    depending on whether the pawn is black or white.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们首先根据兵是黑色还是白色，分配了`初始行位置`、方向和敌人变量。
- en: Similar to the previous `moves_allowed` methods, this method collects all the
    allowed moves in a blank list named `allowed_moves`.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与之前的 `moves_allowed` 方法类似，此方法将所有允许的移动收集到一个名为 `allowed_moves` 的空白列表中。
- en: Then, we collected a list of all the prohibited moves by concatenating two lists
    of squares occupied by all the black and white chess pieces.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们通过连接所有黑白棋子占据的方格的两个列表，收集了一个所有禁止移动的列表。
- en: We defined a variable named `forward` which holds the position of the square
    immediately ahead of the current position of the pawn.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们定义了一个名为`forward`的变量，它保存了棋子当前位置前方正方形的坐标。
- en: A pawn cannot move forward if there is a chess piece in front of it. If the
    forward position is not prohibited, the position is appended to the `allowed_moves`
    list.  A pawn can move two places forward from its starting position. We check
    whether the current position is the starting position, and if it is the starting
    position, we append the double move to the `allowed_moves` list.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果前方有棋子，则兵不能向前移动。如果前方位置没有被禁止，则该位置将被添加到`allowed_moves`列表中。兵可以从起始位置向前移动两格。我们检查当前位置是否是起始位置，如果是起始位置，则将双倍移动添加到`allowed_moves`列表中。
- en: A pawn can capture only the diagonally adjacent chess pieces in front of it.
    Therefore, we assigned a variable attack to track the diagonally adjacent positions
    on the chessboard. If the diagonally adjacent square is occupied by an enemy,
    that position qualifies to be appended to the `allowed_moves` list.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 车棋只能捕获其前方斜线上的棋子。因此，我们分配了一个变量来追踪棋盘上斜线相邻的位置。如果斜线相邻的方格被敌方棋子占据，那么该位置符合添加到`allowed_moves`列表的条件。
- en: Then, we filtered the list to remove all the positions that may fall outside the
    chessboard. The last line returns all the allowed moves as a list of corresponding
    alphanumeric notations, as we did in all the previous definitions.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们将列表过滤，移除所有可能超出棋盘边界的位置。最后一行返回所有允许的走法，以对应的双字符代数符号列表形式呈现，正如我们在所有之前的定义中所做的那样。
- en: This completes the current iteration. We coded the logic needed to enforce the
    rules related to the movement of chess pieces on the chessboard.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了当前迭代。我们编写了执行棋盘上棋子移动相关规则的逻辑代码。
- en: Movement validation of chess pieces
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 棋子的移动验证
- en: Before we allow chess pieces to move, we must have a record of all the possible movement
    options on the chessboard. At every move, we also need to check whether it is
    a legitimate turn for a given player and the proposed move should not cause check
    on the current player's king.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们允许棋子移动之前，我们必须记录下棋盘上所有可能的移动选项。在每一步移动中，我们还需要检查是否是给定玩家的合法回合，并且提议的移动不应该对当前玩家的国王造成将军。
- en: Now, check may occur on the king not only from a chess piece that was moved, but
    from any other chess piece on the chessboard as a consequence of such a movement.
    Thus, after every move, we need to calculate the possible moves for all the chess
    pieces of the opponent.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，检查可能不仅来自被移动的棋子，还可能来自棋盘上因这种移动而产生的任何其他棋子。因此，在每一步之后，我们需要计算对手所有棋子的可能走法。
- en: 'Accordingly, we will need two methods to do the following:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要两种方法来完成以下任务：
- en: Keep a track of all the available moves for a player
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跟踪记录一个玩家的所有可用移动
- en: Check whether there is check on the king
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查是否有对国王的检查
- en: Let's add two new methods in the `Model` class (see `4.05`—`model.py`).
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`Model`类中添加两种新的方法（参见`4.05`—`model.py`）。
- en: Tracking all available moves
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跟踪所有可用的移动
- en: 'The code needed to keep track of all the available moves for a player is as
    follows:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 用于跟踪玩家所有可用移动的代码如下：
- en: '[PRE40]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The description of the code is as follows:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的描述如下：
- en: We have already coded the `moves_available` method in the previous iteration
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们已经在之前的迭代中编写了`moves_available`方法
- en: The preceding method simply iterates through every item in the dictionary and
    appends the `moves_available` result for every chess piece of a given color in
    a list named `result`
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上述方法简单地遍历字典中的每个项目，并将给定颜色的每个棋子的`moves_available`结果追加到名为`result`的列表中
- en: Finding out the current position of the king
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找国王当前的位置
- en: 'Before we code the method that checks whether a king is in check, we first
    need to know the exact position of the king. Let''s define a method to find out
    the current position of the king, as follows (see `4.05`—`model.py`):'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们编写检查国王是否处于将军状态的代码之前，我们首先需要知道国王的确切位置。让我们定义一个方法来找出国王的当前位置，如下所示（见`4.05`—`model.py`）：
- en: '[PRE41]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The preceding code simply iterates through all the items in the dictionary.
    If a given position is an instance of the `King` class, it simply returns its
    position.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码简单地遍历字典中的所有项。如果给定位置是`King`类的实例，它就简单地返回其位置。
- en: Checking whether the king is in check
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查国王是否处于将军状态
- en: 'Let''s define a method to check whether the king is in check from the opponent, as
    follows:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义一种方法来检查国王是否受到对手的将军，具体如下：
- en: '[PRE42]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The following is a description of the preceding code:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对前面代码的描述：
- en: First, we obtained the current position of the king and the color of the opponent.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们获取了国王的当前位置和对手的颜色。
- en: We then found out all the possible moves for all the chess pieces of the opponent.
    If the position of the king coincides with any position from all the possible
    moves, the king is in check and we return `True`. Otherwise, we return `False`.
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们随后找出对手所有棋子的所有可能走法。如果国王的位置与所有可能走法中的任何一个位置重合，那么国王处于将军状态，我们返回`True`。否则，我们返回`False`。
- en: This accomplishes the objectives for the iteration. We are now in a position
    to check all the available moves for a player at a given point in the game. We
    can also check whether a king is in check from the opponent.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了迭代的目标。我们现在可以检查游戏在某个特定时刻所有可用的棋子移动。我们还可以检查是否对方正在将军。
- en: Making the game functional
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使游戏功能化
- en: Now that we have all the chess pieces and chessboard-related validation rules
    in place, let's add life to our chess program. In this iteration, we will make
    our chess game fully functional.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了所有棋子和棋盘相关的验证规则，让我们给我们的棋程序注入生命力。在这个迭代中，我们将使我们的棋游戏完全功能化。
- en: The objective of this iteration is to move the chess pieces with a click of
    the left mouse button. When a player clicks on a chess piece, the code should
    first check whether it is a legitimate turn for that chess piece.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 本迭代的目的是通过点击左鼠标按钮来移动棋子。当玩家点击一个棋子时，代码应首先检查该棋子是否处于合法的移动回合。
- en: On the first click, the chess piece that needs to be moved is selected, and
    all the allowed moves for that chess piece are highlighted on the chessboard.
    The second click should be performed on the destination square. If the second
    click is done on a valid destination square, the chess piece should move from
    the source square to the destination square.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一次点击时，需要移动的棋子被选中，并且该棋子所有允许的走法在棋盘上都会被高亮显示。第二次点击应该执行在目标方格上。如果第二次点击是在一个有效的目标方格上，那么棋子应该从起始方格移动到目标方格。
- en: We also need to code the events of capturing chess pieces and the king being
    in check. The other attributes that need to be tracked include a list of the captured
    chess pieces, the half-move clock count, the full-move number count, and the history
    of all the previous moves.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要编码捕捉棋子和国王被将军的事件。需要跟踪的其他属性包括已捕获的棋子列表、半回合时钟计数、全回合数计数以及所有先前移动的历史记录。
- en: You may recall that we created a dummy method which is bound to the left-click event.
    The method, for now, simply prints the row and column value on the console.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得我们创建了一个与左键点击事件绑定的虚拟方法。目前，该方法只是简单地将在控制台上打印行和列的值。
- en: 'Let''s modify this method, as follows (see `4.06`—`view.py`):'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改这个方法，如下所示（见 `4.06`—`view.py`）：
- en: '[PRE43]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The following is a description of the preceding code:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对前面代码的描述：
- en: The first part of the code calculates the coordinates for the chess piece on
    which you clicked. Based on the calculated coordinates, it stores the corresponding
    letter notation in a variable named `position_of_click`.
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码的第一部分计算您点击的棋子的坐标。根据计算出的坐标，它将相应的字母标记存储在一个名为`position_of_click`的变量中。
- en: It then tries to assign the piece variable to the corresponding piece instance.
    If there is no piece instance on the clicked square, it simply ignores the click.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后它尝试将片段变量分配给相应的片段实例。如果点击的方格上没有片段实例，它就简单地忽略这次点击。
- en: The second part of the method checks whether this is the second click that was
    intended to move a chess piece to a destination square. If this is the second
    click, it calls the `shift` method, passing the source and destination coordinates
    as its two arguments.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该方法的第二部分检查这是否是意图将棋子移动到目标格子的第二次点击。如果是第二次点击，它将调用`shift`方法，并将源坐标和目标坐标作为其两个参数传递。
- en: If the `shift` method succeeds, it sets all the previously set attributes to
    their original empty values and calls the `draw_board` and `draw_pieces` methods
    to redraw the chessboard and chess pieces.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`shift`方法成功执行，它将所有之前设置的属性重置为其原始的空值，并调用`draw_board`和`draw_pieces`方法来重新绘制棋盘和棋子。
- en: While coding the desired functionality for the `on_square_clicked` method, we called
    several new methods from within it. We need to define these new methods.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写`on_square_clicked`方法所需的功能时，我们在其中调用了几个新的方法。我们需要定义这些新方法。
- en: Keep an eye on the `on_square_clicked` method. This is the central method around
    which all the other methods will evolve over the course of our attempts to make
    the chess game functional.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 密切关注`on_square_clicked`方法。这是所有其他方法在尝试使棋盘游戏功能化的过程中演变的核心方法。
- en: Getting the source and destination position
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取源位置和目标位置
- en: We have called the `shift` method from the `on_square_clicked` method. The code for
    the `shift` method is responsible for the collection of the necessary arguments that
    are required for the `shift` operation.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从`on_square_clicked`方法中调用了`shift`方法。`shift`方法的代码负责收集`shift`操作所需的必要参数。
- en: 'The code for the `shift` method is as follows:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`shift` 方法的代码如下：'
- en: '[PRE44]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The code first checks whether a chess piece exists at the destination. If a
    chess piece does not exist at the destination square, it calls on a method, `shift`,
    from the *controller,* which is a wrapper around the actual `shift` method from
    the `Model` class.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 代码首先检查目标位置是否存在棋子。如果目标方格上不存在棋子，它将调用来自*控制器*的方法，`shift`，这是一个围绕`Model`类实际`shift`方法的包装器。
- en: Collecting a list of the moves that need to be highlighted
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 收集需要突出显示的动作列表
- en: We also called the `update_highlight_list(position)` method from the `on_square_clicked`
    method. The purpose of this method is to collect all the possible moves for a
    given chess piece in a list named `all_squares_to_be_highlighted`.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也从`on_square_clicked`方法中调用了`update_highlight_list(position)`方法。这个方法的目的在于收集给定棋子在列表`all_squares_to_be_highlighted`中所有可能的走法。
- en: 'The actual focusing of the available moves takes place in the `draw_board`
    method of the GUI class. The code for this is as follows (see `4.06`—`view.py`):'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，可用的移动聚焦发生在GUI类的`draw_board`方法中。该方法的代码如下（见`4.06`—`view.py`）：
- en: '[PRE45]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Highlighting allowed moves
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 突出显示允许移动的选项
- en: In the `on_square_clicked` method, we called the `draw_board` method to take care
    of the redrawing or changing of the chess pieces' coordinates. The current `draw_board`
    method is not equipped to handle this because we only designed it in the first
    iteration to provide us with a blank chessboard.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在`on_square_clicked`方法中，我们调用了`draw_board`方法来处理棋子坐标的重绘或更改。当前的`draw_board`方法尚未准备好处理这种情况，因为我们最初只设计它在一轮迭代中为我们提供一个空白的棋盘。
- en: 'First, let''s add a `HIGHLIGHT_COLOR` constant to the `configurations.py` file, as
    follows:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们在`configurations.py`文件中添加一个`HIGHLIGHT_COLOR`常量，具体如下：
- en: '[PRE46]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Then, modify the `draw_board` method to handle this, as follows (see `4.06`—`view.py`):'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，修改`draw_board`方法以处理这个问题，如下所示（见`4.06`—`view.py`）：
- en: '[PRE47]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Pre-move validation
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 预迁移验证
- en: The chess piece must only be moved if it does not violate the rules of the game.
    For example, a chess piece can move to a valid location only if that location
    is not already occupied by a chess piece of the same color. Similarly, a piece
    can move only if it is the player's turn to move. Another rule states that a piece
    can only move if the resulting move does not result in check for the king of the
    same color.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 国际象棋的棋子只有在不会违反游戏规则的情况下才能移动。例如，一个棋子只能移动到未被同色棋子占据的有效位置。同样，一个棋子只有在轮到该玩家移动时才能移动。另一条规定是，一个棋子只有在移动结果不会对该色国王构成将军的情况下才能移动。
- en: 'This `pre_move_validation` method is responsible for checking all the rules. If
    all validations pass, it calls the `move` method to update the move, as follows (see
    `4.06`—`model.py`):'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `pre_move_validation` 方法负责检查所有规则。如果所有验证都通过，它将调用 `move` 方法来更新移动，如下所示（见 `4.06`—`model.py`）：
- en: '[PRE48]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'If the rules are not being followed, this code raises several exceptions, which
    are defined in the exceptions class as follows (see `4.06`—`exceptions.py`):'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 如果规则没有被遵循，此代码会引发几个异常，这些异常在异常类中如下定义（见`4.06`—`exceptions.py`）：
- en: '[PRE49]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We could have further coded the error classes, but we chose not to because
    we simply updated the name of the error class to the bottom label, which is sufficient for
    our current purpose. The error message is displayed from the shift method of the
    `View` class, as follows (see `4.06`—`view.py`):'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本可以进一步对错误类别进行编码，但我们选择不这样做，因为我们只是将错误类别的名称更新为底部标签，这对我们当前的目的来说已经足够了。错误信息是从`View`类的位移方法中显示的，如下所示（见`4.06`—`view.py`）：
- en: '[PRE50]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Check whether a move will cause check on the King
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查一个移动是否会导致对国王的将军（即王后将受到攻击）
- en: Though a major part of the validation check done in the preceding lines is simple, one
    of the validation steps needs to check whether a movement will cause the king to
    be in check. This is a tricky situation. We can only find this out after we have made
    the actual move. However, we cannot allow that movement to happen on the chessboard.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然前面几行中进行的验证检查的大部分是简单的，但其中一步验证需要检查一个移动是否会使得国王处于被将军的状态。这是一个棘手的情况。我们只能在实际移动之后才能找出这一点。然而，我们不允许这种移动在棋盘上发生。
- en: 'To do this, the `pre_move_validation` method calls a method named `will_move_cause_check`,
    which creates a copy of the `Model` class. Then, it performs a move on the new
    temporary copy to check whether it does cause a king to be in check. The code
    for this is as follows (`4.06`—`model.py`):'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '要实现这一点，`pre_move_validation` 方法调用了一个名为 `will_move_cause_check` 的方法，该方法创建了一个
    `Model` 类的副本。然后，它在新创建的临时副本上进行移动操作，以检查这会不会导致国王处于被将军的状态。相应的代码如下 (`4.06`—`model.py`):'
- en: '[PRE51]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Note that when you create a copy by simple assignment, Python creates a shallow
    copy. In a shallow copy, the two variables now share the same data. So, a modification
    in one place affects the other as well.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当你通过简单赋值创建一个副本时，Python 会创建一个浅拷贝。在浅拷贝中，两个变量现在共享相同的数据。因此，对其中一个位置的修改也会影响另一个。
- en: In contrast to this, deep copies create a copy of everything—the structure as
    well as the elements. We need to create a deep copy of the chessboard because
    we want to check whether the king makes a valid move before it actually moves,
    and we want to do this without modifying the original object's state in any way.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 与此相反，深拷贝会创建一个包含所有内容的副本——包括结构和元素。我们需要创建棋盘的深拷贝，因为我们希望在国王实际移动之前检查其是否进行了一次有效的移动，并且我们希望在不以任何方式修改原始对象状态的情况下完成这项操作。
- en: Recording a move in the data structure
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记录数据结构中的移动
- en: 'The `shift` method defined in `view.py` is responsible for the actual moving
    of a chess piece on the chessboard. However, this brings about a change in the
    underlying data structure. The `move` method of the `Model` class is then responsible
    for updating the data structure. This `move` method is called from the previously
    defined `pre_move_validation()` method if and only if no errors are raised, as
    follows (`4.06`—`model.py`):'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `view.py` 中定义的 `shift` 方法负责在棋盘上实际移动棋子。然而，这会导致底层数据结构发生变化。因此，`Model` 类的 `move`
    方法负责更新数据结构。只有当没有错误抛出时，这个 `move` 方法才会从之前定义的 `pre_move_validation()` 方法中被调用，如下所示（`4.06`—`model.py`）：
- en: '[PRE52]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Note that as soon as this update is complete, the control returns to the `on_square_clicked()`
    method in `view.py`*.* The method then calls the `draw_all_pieces()` method, which
    updates the view.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，一旦这次更新完成，控制权就会返回到`view.py`中的`on_square_clicked()`方法*.* 然后，该方法会调用`draw_all_pieces()`方法，该方法会更新视图。
- en: Keep game statistics
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保持游戏统计数据
- en: 'The `pre_move_validation()` method also calls another method called `update_game_statistics()`
    on successfully recording a move (see `4.06`—`model.py`):'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '`pre_move_validation()` 方法在成功记录一个移动后，也会调用另一个名为 `update_game_statistics()` 的方法（参见
    `4.06`—`model.py`）：'
- en: '[PRE53]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Congratulations, our chess game is now functional!
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜，我们的棋局现在已启用！
- en: 'Let''s complete the iteration by binding the File *|* New Game menu item to
    start a new game. Earlier, we defined the `start_new_game()` method. Now, it''s
    simply a matter of calling it from the `on_new_game_menu_clicked()` method, as
    follows (`4.06`—`view.py`):'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '让我们通过将文件 *|* 新游戏菜单项绑定到启动新游戏来完成迭代。之前，我们定义了 `start_new_game()` 方法。现在，只需从 `on_new_game_menu_clicked()`
    方法中调用它即可，如下所示 (`4.06`—`view.py`):'
- en: '[PRE54]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Managing user preferences
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理用户偏好
- en: A very common theme in several GUI programs involves letting the user set the program's
    preferences.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在多个图形用户界面程序中，一个非常常见的主题是让用户设置程序的偏好设置。
- en: For example, what if we want users to be able to customize the chessboard colors? What
    if we want users to select colors and, once selected, it is saved as a user preference
    and it is loaded the next time the program is run? Let's implement this as a feature.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想让用户能够自定义棋盘颜色怎么办？如果我们想让用户选择颜色，一旦选择，它就被保存为用户偏好，并在下次程序运行时加载？让我们把这个作为一个功能来实现。
- en: Python offers a standard module called `configparser` that lets us save user preferences.
    Let's see the `configparser` module in action.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: Python提供了一个名为`configparser`的标准模块，允许我们保存用户偏好设置。让我们看看`configparser`模块的实际应用。
- en: 'To begin with, import the `ConfigParser` class from the `configparser` module in
    the `configurations.py` file, as follows (see `4.07 preferenceswindow.py`):'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，从`configparser`模块中导入`ConfigParser`类到`configurations.py`文件中，如下所示（参见`4.07 preferenceswindow.py`）：
- en: '[PRE55]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The `configparser` module uses the `.ini` files to store and read the configuration values.
    The file consists of one or more named sections. These sections contain individual
    options with names and values.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '`configparser`模块使用`.ini`文件来存储和读取配置值。该文件包含一个或多个命名部分。这些部分包含具有名称和值的单个选项。'
- en: 'To illustrate this, let''s create a file called `chess_options.ini` in the
    project''s root folder (see `4.07`). The file looks like this:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一点，让我们在项目的根目录下创建一个名为 `chess_options.ini` 的文件（参见 `4.07`）。该文件看起来是这样的：
- en: '[PRE56]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The first line of the file enclosed in square brackets (`[chess_colors]` in
    our example) is called a **section**. A `.ini` file can have multiple sections.
    This file has a single section. Each section can have multiple *key-value* options,
    as specified in the example.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 方括号内（在我们的示例中为 `[chess_colors]`）的第一行被称为**部分**。一个 `.ini` 文件可以有多个部分。此文件只有一个部分。每个部分可以有多个如示例中指定的
    *键值* 选项。
- en: 'We can read these values in our program by using the `getter` methods, as follows (see
    `4.07`—`configurations.py`):'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用`getter`方法在我们的程序中读取这些值，如下所示（参见`4.07`—`configurations.py`）：
- en: '[PRE57]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The preceding code replaces the three color constants that we defined earlier
    in the code.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码替换了我们在代码中之前定义的三个颜色常量。
- en: Now, if you change the options in the `.ini` file, the color of the chessboard
    changes accordingly. However, we cannot expect end users to be conversant with
    editing the `.ini` files. Therefore, we will let them choose the colors using
    the **color chooser **module of Tkinter. A color that a user chooses gets reflected
    in the `.ini` file and consequently on the chessboard.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你在 `.ini` 文件中更改选项，棋盘的颜色会相应地改变。然而，我们无法期望最终用户熟悉编辑 `.ini` 文件。因此，我们将让他们通过 Tkinter
    的 **颜色选择器** 模块来选择颜色。用户选择的颜色会反映在 `.ini` 文件中，并相应地显示在棋盘上。
- en: 'When a user clicks on the Edit *|* Preference menu item, we want to open a
    *transient window* with three different buttons to choose two chessboard colors
    and one highlight color. Clicking on a single button opens a color select window,
    as shown in the following screenshot:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击编辑 *|* 预设菜单项时，我们希望打开一个 *短暂窗口*，其中包含三个不同的按钮，用于选择两种棋盘颜色和一种高亮颜色。点击单个按钮将打开一个颜色选择窗口，如下面的截图所示：
- en: '![](img/b515c321-a74d-4b71-9ab5-f34dd1342f40.png)'
  id: totrans-311
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b515c321-a74d-4b71-9ab5-f34dd1342f40.png)'
- en: We created this transient window in a new file called `preferenceswindow.py`(see
    `4.07.py`). We will not discuss the code that creates this window, as this should
    be an easy task for you now.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在名为 `preferenceswindow.py` 的新文件中创建了这个短暂的窗口（参见 `4.07.py`）。我们不会讨论创建此窗口的代码，因为这对你来说现在应该是一个简单的任务。
- en: 'Note that this window is converted into a transient window with respect to
    the top-level window by using the following code:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，此窗口通过以下代码转换为相对于顶级窗口的瞬态窗口：
- en: '[PRE58]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: As a reminder, a transient window is one that always stays at the top of its parent
    window. It gets minimized when its parent window is minimized. For a quick refresher
    on transient windows, refer to [Chapter 2](41f1fda5-b3b1-4dfa-8971-2a016274d39a.xhtml),
    *Making a Text Editor,—*`2.06.py`.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 作为提醒，一个瞬态窗口是指始终位于其父窗口顶部的窗口。当其父窗口最小化时，它也会被最小化。若想快速回顾瞬态窗口的相关内容，请参阅[第2章](41f1fda5-b3b1-4dfa-8971-2a016274d39a.xhtml)，*制作一个文本编辑器—*`2.06.py`。
- en: 'As we have created the window in `preferencewindow.py`, we''ll import it into
    the `View` class as follows (see `2.07`—`view.py`):'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在 `preferencewindow.py` 中创建了窗口，我们将将其导入到 `View` 类中，如下所示（参见 `2.07`—`view.py`）：
- en: '[PRE59]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Then, command bind the preference menu by using the following two methods:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，通过以下两种方法使用命令绑定首选项菜单：
- en: '[PRE60]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'When a user clicks on the Cancel button, we simply want the settings window
    to close. To do this, use the following code (see `4.07`—`preferencewindow.py`):'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击取消按钮时，我们只想让设置窗口关闭。为此，请使用以下代码（参见`4.07`—`preferencewindow.py`）：
- en: '[PRE61]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'When a user changes the colors and clicks on the Save button, the method calls
    the `set_new_values()` method, which first writes the new values to the `.ini`
    file and then returns the values to the `View` class to update the chessboard immediately:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户更改颜色并点击保存按钮时，该方法会调用`set_new_values()`方法，该方法首先将新值写入`.ini`文件，然后将值返回给`View`类以立即更新棋盘：
- en: '[PRE62]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'When the preceding code writes the new values to the `.ini` file, call the `reload_colors()`
    method from the `View` class to update the chessboard''s color immediately. If
    you do not do this, the color change will take place the next time the chess program
    is run (see `4.07`—`view.py`):'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 当前面的代码将新值写入`.ini`文件时，请从`View`类中调用`reload_colors()`方法来立即更新棋盘的颜色。如果不这样做，颜色变化将在下次运行棋程序时发生（参见`4.07`—`view.py`）：
- en: '[PRE63]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Having changed these attributes, we call `draw_board()` and `draw_all_pieces()` to
    repaint the chessboard in the newly defined colors. (see `4.07`—`view.py`).
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 修改了这些属性后，我们调用 `draw_board()` 和 `draw_all_pieces()` 函数来以新定义的颜色重新绘制棋盘。（见 `4.07`—`view.py`）。
- en: This concludes the iteration. The users of the program can change the colors to
    match their preferences, and the program will remember the chosen values.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了迭代。程序的用户可以根据自己的喜好更改颜色，程序将记住所选的值。
- en: Summary
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We have come to the end of this chapter. So, what is it that we achieved here?
    Let's have a look at all the key things that we learned from the chapter.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经到达了这一章节的结尾。那么，我们在这里都取得了哪些成果呢？让我们来看看我们从这一章节中学到的所有关键要点。
- en: We learned how to structure programs using the MVC architecture.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了如何使用MVC架构来构建程序。
- en: We took a peek at the versatility and power of the Tkinter Canvas widget. This
    included a tour through the basic usage of the canvas coordinates, object IDs,
    and tags.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 我们瞥了一眼Tkinter Canvas小部件的多样性和强大功能。这包括对画布坐标、对象ID和标签的基本用法进行了一次巡礼。
- en: We discussed how to handle complexity by implementing programs in a modular structure.
    We achieved this modularity by breaking down the code into several smaller files.
    We handled the entire configuration from a single file and all the errors in another
    file.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了如何通过实现模块化结构来处理复杂性。我们通过将代码分解成几个较小的文件来实现这种模块化。我们从一个文件中处理整个配置，并在另一个文件中处理所有错误。
- en: We explored how to extend Python's built-in error class to define a custom error
    and exceptions. We also had a look at how we can extend Python's built-in data
    types, as in the case of the `Model` class, which directly extended the `dict`
    class.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 我们探讨了如何扩展 Python 的内置错误类来定义自定义错误和异常。我们还查看了一下如何扩展 Python 的内置数据类型，例如在 `Model` 类的情况下，它直接扩展了
    `dict` 类。
- en: We studied how to use object inheritance to code classes with similar attributes
    and behavior when building the `Piece` class and all its subclasses.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 我们研究了如何在构建`Piece`类及其所有子类时，利用对象继承来编写具有相似属性和行为的类。
- en: Finally, you learned how to use Python's built-in `configparser` module to store
    user preferences.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你学会了如何使用 Python 的内置 `configparser` 模块来存储用户偏好。
- en: We will create an audio player in the next chapter. In addition to this, we'll
    work with several new widgets. We will also take a look at how to create our own
    widgets!
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一章创建一个音频播放器。除此之外，我们还将使用几个新的小部件。我们还将探讨如何创建我们自己的小部件！
- en: QA section
  id: totrans-337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: QA部分
- en: Before you proceed to the next chapter, make sure you can answer these questions
    to your
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在你继续阅读下一章之前，请确保你能回答这些问题
- en: 'satisfaction:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 满意度：
- en: What are the central tenets of the model-view-controller framework?
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型-视图-控制器框架的核心原则是什么？
- en: What is modularity in programming? Why is modularity good?
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是编程中的模块化？为什么模块化是好的？
- en: What are the advantages and disadvantages of using class inheritance in programs?
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用类继承在程序中的优缺点是什么？
- en: While inheritance provided us with a tool to reuse our code, multiple inheritance
    is frowned upon by many experts.  What could be the reason for this?
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然[继承](#)为我们提供了一个重用代码的工具，但许多专家都不赞成使用[多重继承](#)。这其中的原因可能是什么呢？
- en: What are `tags` used for in the Tkinter Canvas widget?
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Tkinter Canvas小部件中`标签`用于什么？
- en: Why do we use a `configparser` module? What are some of the alternatives to
    using a `configparser` module?
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么我们使用`configparser`模块？使用`configparser`模块有哪些替代方案？
- en: Further reading
  id: totrans-346
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: MVC is a popular software **architectural pattern**, but there are many more
    architectural patterns that suit different use cases. Read about different architectural
    patterns at [https://en.wikipedia.org/wiki/Architectural_pattern](https://en.wikipedia.org/wiki/Architectural_pattern).
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: MVC 是一种流行的软件 **架构模式**，但还有许多其他适合不同用例的架构模式。了解更多不同的架构模式，请参阅 [https://en.wikipedia.org/wiki/Architectural_pattern](https://en.wikipedia.org/wiki/Architectural_pattern)。
- en: If chess enthuses you, or if you would like to get started in artificial intelligence, 
    you might attempt to implement a chess engine that plays as an opponent. This
    would require some reading on optimal search algorithms. Here's a tutorial that
    walks us through the process: [https://medium.freecodecamp.org/simple-chess-ai-step-by-step-1d55a9266977](https://medium.freecodecamp.org/simple-chess-ai-step-by-step-1d55a9266977).
    The tutorial engine has been implemented in JavaScript, but we can use it as a
    reference to build our own engine in Python.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你热衷于下棋，或者想要开始学习人工智能，你可能会尝试实现一个作为对手的棋引擎。这需要阅读一些关于最优搜索算法的资料。这里有一个教程，它将引导我们完成这个过程：[https://medium.freecodecamp.org/simple-chess-ai-step-by-step-1d55a9266977](https://medium.freecodecamp.org/simple-chess-ai-step-by-step-1d55a9266977)。教程中的引擎是用JavaScript实现的，但我们可以用它作为参考来构建我们自己的Python引擎。
