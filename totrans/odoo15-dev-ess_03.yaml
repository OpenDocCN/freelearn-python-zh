- en: '[*Chapter 5*](B16119_05_Final_PD_ePub.xhtml#_idTextAnchor146): Importing, Exporting,
    and Module Data'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most Odoo module definitions, such as **user interfaces** and **security rules**,
    are data records that are stored in specific **database tables**. The XML and
    CSV files that are found in modules are not used by Odoo applications at runtime.
    They are a means of loading those definitions into database tables.
  prefs: []
  type: TYPE_NORMAL
- en: Because of this, an important part of Odoo modules is representing data in files
    so that it can be loaded into a database upon module installation. Modules can
    also contain initial data and demonstration data. Data files allow us to add that
    to our modules.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, understanding Odoo data representation formats is important for
    exporting and importing business data within the context of a project's implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the external identifier concept
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exporting and importing data files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using CSV files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding module data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using XML data files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to perform data exports and imports
    to populate initial data into a database and automate the creation of default
    and demonstration data in modules that have been created.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter requires you to have an Odoo server running, with the library app
    base module installed.
  prefs: []
  type: TYPE_NORMAL
- en: The code for this chapter can be found in this book's GitHub repository, [https://github.com/PacktPublishing/Odoo-15-Development-Essentials](https://github.com/PacktPublishing/Odoo-15-Development-Essentials),
    in the `ch05/` directory. It contains a copy of the original `library_app` that
    we created in [*Chapter 3*](B16119_03_Final_PD_ePub.xhtml#_idTextAnchor072), *Your
    First Odoo Application*, with additional files added for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the external identifier concept
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An **external identifier**, also called an **XML ID**, is a *human-readable
    string identifier* that uniquely identifies a particular record in Odoo. They
    are important for loading data into Odoo, allowing us to modify an existing data
    record or reference it in other data records.
  prefs: []
  type: TYPE_NORMAL
- en: First, we will introduce how external identifiers work, and how we can inspect
    them. Then, we will learn how to use the web client to find the external identifiers
    for particular data records, since this is frequently needed when creating add-on
    modules, thus extending existing features.
  prefs: []
  type: TYPE_NORMAL
- en: How external identifiers work
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's begin by understanding how identifiers work. The actual database identifier
    for a record is an automatically assigned sequential number, and there is no way
    to know ahead of time what ID will be assigned to each record during module installation.
    External identifiers let us reference a related record without the need to know
    the actual database ID that's been assigned to it. The XML ID provides a convenient
    alias for the database ID so that we can use it whenever we need to reference
    a particular record.
  prefs: []
  type: TYPE_NORMAL
- en: Records defined in Odoo module data files use *XML IDs*. One reason for this
    is to avoid creating duplicate records when upgrading a module. The module upgrade
    will load the data files into the database again. We want it to detect pre-existing
    records for them to be updated, instead of creating duplicate records.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another reason to use XML IDs is to support interrelated data: data records
    that need to reference other data records. Since we can''t know the actual database
    ID, we can use the XML ID, so the translation will be transparently handled by
    the **Odoo framework**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Odoo takes care of translating the external identifier names into the actual
    database IDs that have been assigned to them. The mechanism behind this is quite
    simple: Odoo keeps a table with the mapping between the named external identifiers
    and their corresponding numeric database IDs: the `ir.model.data` model.'
  prefs: []
  type: TYPE_NORMAL
- en: We must have **Developer mode** enabled to have the menu option available. Check
    whether you have the *Developer mode* bug icon in the top right, next to the user's
    avatar icon. If not, you should enable it now in the **Settings** top menu. Please
    refer to [*Chapter 1*](B16119_01_Final_PD_ePub.xhtml#_idTextAnchor015), *Quick
    Start Using the Developer Mode*, for more details.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can inspect the existing mappings using the `library_app` module, we will
    see the external identifiers that have been generated by the module we created,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 – External identifiers generated by the library_app module'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image_00_001.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.1 – External identifiers generated by the library_app module
  prefs: []
  type: TYPE_NORMAL
- en: Here, we can see that the external identifiers have `library_app.action_library_book`.
  prefs: []
  type: TYPE_NORMAL
- en: External identifiers only need to be unique inside an Odoo module so that there
    is no risk of two modules conflicting because of accidentally choosing the same
    identifier name. The globally unique identifier is built by joining the module
    name with the actual external identifier name. This is what you can see in the
    **Complete ID** field.
  prefs: []
  type: TYPE_NORMAL
- en: When using an external identifier in a data file, we can choose to use either
    the complete identifier or just the external identifier name. Usually, it's simpler
    to just use the external identifier name, but the complete identifier enables
    us to reference data records from other modules. When doing so, make sure that
    those modules are included in the module dependencies to ensure that those records
    are loaded before ours.
  prefs: []
  type: TYPE_NORMAL
- en: There are some cases where the complete ID is needed, even if we're referring
    to an XML ID from the same module.
  prefs: []
  type: TYPE_NORMAL
- en: At the top of the list, we can see the `library_app.action_library_book` complete
    identifier. This is the menu action we created for the module, which is also referenced
    in the corresponding menu item. By clicking on it, we go to the form view, which
    contains its details. There, we can see that the `action_library_book` external
    identifier in the `library_app` module maps to a specific record ID in the `ir.actions.act_window`
    model, which is `87` in this case.
  prefs: []
  type: TYPE_NORMAL
- en: 'By clicking on the record''s line, the information can be seen in a form view,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2 – Form view for the library_app.action_library_book external identifier'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image_00_002.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.2 – Form view for the library_app.action_library_book external identifier
  prefs: []
  type: TYPE_NORMAL
- en: Besides providing a way for records to easily reference other records, external
    identifiers also allow you to avoid data duplication on repeated imports. If the
    external identifier is already present, the existing record will be updated, avoiding
    a new, duplicate record being created.
  prefs: []
  type: TYPE_NORMAL
- en: Finding external identifiers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we're writing data records for our modules, we frequently need to look
    up the existing external identifiers to use for our reference. So, it is important
    to know how to find these identifiers.
  prefs: []
  type: TYPE_NORMAL
- en: One way to do this is to use the **Settings** | **Technical** | **Sequences
    & Identifiers** | **External Identifiers** menu, which was shown earlier in *Figure
    5.1*. We can also use the **Developer** menu for this. As you may recall from
    [*Chapter 1*](B16119_01_Final_PD_ePub.xhtml#_idTextAnchor015), *Quick Start Using
    the Developer Mode*, the **Developer** menu can be activated in the **Settings**
    dashboard, at the bottom right.
  prefs: []
  type: TYPE_NORMAL
- en: To find the external identifier for a data record, we should open the corresponding
    form view, select the **Developer** menu, and then choose the **View Metadata**
    option. This will display a dialog containing the record's database ID and external
    identifier (also known as the XML ID).
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to look up the `demo` user ID, we should navigate to the users
    form view at `demo` user form, and then select the `base.user_demo` and that the
    database ID is `6`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3 – The View Metadata dialog window'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image_00_003.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.3 – The View Metadata dialog window
  prefs: []
  type: TYPE_NORMAL
- en: To find the external identifier for view elements, such as **form**, **tree**,
    **search**, or **action**, the **Developer** menu is also a good source of help.
    For this, we can use the appropriate **Edit View** option to open a form containing
    the details of the corresponding view. There, we will find an **External ID**
    field, which provides the information we are looking for.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, in the following screenshot, we can see that the `base.view_users_form`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.4 – The Edit View window showing the External ID property for a
    form view'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image_00_004.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.4 – The Edit View window showing the External ID property for a form
    view
  prefs: []
  type: TYPE_NORMAL
- en: With that, we have learned about **External IDs** and how they can be used as
    aliases to reference database records. We have also looked at several ways to
    find the **XML IDs** that will be needed to reference records in the data files.
    Next, we will learn how to create data files where these **XML IDs** will be useful.
  prefs: []
  type: TYPE_NORMAL
- en: Exporting and importing CSV data files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An easy way to generate data files and get insight into what structure the files
    should have is to use the built-in export feature.
  prefs: []
  type: TYPE_NORMAL
- en: With generated CSV files, we can learn about the format that's needed to import
    data manually into the system, edit them to perform mass updates, or even use
    them to produce demo data for our add-on modules.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will learn about the basics of exporting and importing data
    from Odoo's user interface.
  prefs: []
  type: TYPE_NORMAL
- en: Exporting data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Data exporting** is a standard feature that''s available in any list view.
    To use it, we must pick the rows to export by selecting the corresponding checkboxes,
    on the far left, and then selecting the **Export** option from the **Action**
    button at the top of the list.'
  prefs: []
  type: TYPE_NORMAL
- en: First, we should add a couple of Odoo books to the `Odoo Development Essentials
    11` and `Odoo 11 Development Cookbook`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to have the **Contacts** app installed so that we can see a **Partner**
    list view and can export those records from there. Notice that the default view
    is **Kanban** for the contact cards, so we need to switch to the **list** view:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.5 – The Export option in the Action menu'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image_00_005.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.5 – The Export option in the Action menu
  prefs: []
  type: TYPE_NORMAL
- en: We can also tick the checkbox in the header of the column to select all of the
    available records that match the current search criteria.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Export** option takes us to the **Export Data** dialog form, where we
    can choose what and how to export. We are concerned with exporting in a way that
    allows us to import that file later, either manually or as part of an add-on module:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.6 – The Export Data dialog window'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image_00_006.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.6 – The Export Data dialog window
  prefs: []
  type: TYPE_NORMAL
- en: 'At the top of the dialog form, we have two selections available:'
  prefs: []
  type: TYPE_NORMAL
- en: '**I want to update data (import-compatible export)**: Enable this checkbox
    so that the data is exported in a format-friendly manner for a later import.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Export format**: You can choose between **CSV** or **XLSX** here. We will
    choose a **CSV** file to get a better understanding of the raw export format,
    which is still understood by any spreadsheet application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, pick the columns to export. In this example, a very simple export was
    done by choosing only the **Name** field. By clicking on the **Export** button,
    an exported data file will be available. The exported CSV file should look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The first row contains the **field names**, which will be used during the import
    to automatically map the columns to their destination.
  prefs: []
  type: TYPE_NORMAL
- en: The first row has the selected `name` column, as expected. An initial ID column
    was automatically added because the import-compatible export option was selected.
  prefs: []
  type: TYPE_NORMAL
- en: The automatically added `id` column has the external ID assigned to each record.
    This allows the exported data file to be edited and reimported later, to update
    the records, instead of creating duplicated ones.
  prefs: []
  type: TYPE_NORMAL
- en: Missing external identifiers are automatically generated using the `__export__`
    prefix, as shown in the previous file export example.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Because of the automatically generated record identifiers, the export or import
    features can be used to mass edit Odoo data – export the data to CSV, use spreadsheet
    software to mass edit it, and then import it back into Odoo.
  prefs: []
  type: TYPE_NORMAL
- en: Importing data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once we have a properly formatted data file ready, we want to import it into
    Odoo. Let's learn how this is can be done through the web client user interface.
  prefs: []
  type: TYPE_NORMAL
- en: First, we have to make sure that the import feature is *enabled*. It should
    be enabled by default. If not, the option is available in the **Settings** app,
    under the **General Settings** menu item. Under the **Permissions** section, the
    **Import & Export** option should be checked.
  prefs: []
  type: TYPE_NORMAL
- en: With this option enabled, the list view search widget will show an **Import
    records** option in the **Favorites** menu, next to the **Filters** and **Group
    By** menus.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The `base_import` module, which is responsible for providing this feature.
  prefs: []
  type: TYPE_NORMAL
- en: Let's try performing a bulk edit on our *Contact* or *Partner* data. Open the
    CSV file we just downloaded in a spreadsheet or a text editor and change a few
    values. We can also add some new rows, leaving the `id` column blank for them.
  prefs: []
  type: TYPE_NORMAL
- en: As we mentioned previously, the first column, `id`, provides a unique identifier
    for each row. This allows pre-existing records to be updated instead of us needing
    to duplicate them when we import the data back to Odoo. If we edit any of the
    names in the exported file, the corresponding record will be updated when we import
    the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the new rows that have been added to the CSV file, we can choose to either
    provide an external identifier of our choice or we can leave the `id` column blank.
    Either way, a new record will be created for them. As an example, we added a line
    with no `id` and the name `Phillip K. Dick` to be created in the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'After saving these changes to the **CSV** file, click on the **Import** option,
    in the **Favorites** menu. The next page allows us to upload the data file. Then,
    the import assistant will be presented:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.7 – The Import a File assistant'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image_00_007.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.7 – The Import a File assistant
  prefs: []
  type: TYPE_NORMAL
- en: Here, we should select the CSV file's location on the disk and then click on
    the **Test** button, at the top left, to check it for correctness.
  prefs: []
  type: TYPE_NORMAL
- en: Since the file to import is based on an Odoo export, there is a good chance
    that it will be valid and that the columns will be automatically mapped to their
    proper destination in the database. Depending on the application that's used to
    edit the data file, you may have to play with the separator and encoding options
    to get the best results.
  prefs: []
  type: TYPE_NORMAL
- en: Now, click on **Import**, and there you go – the modifications and new records
    should have been loaded into Odoo!
  prefs: []
  type: TYPE_NORMAL
- en: Related records in CSV data files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The examples in the previous section were quite simple, but the data files can
    become more complex once we start using relational fields, linking records from
    several tables.
  prefs: []
  type: TYPE_NORMAL
- en: Previously, we handled *Partner* records that were used in *Books*. We will
    now look at how we can represent the reference for these Partners in a CSV file
    for book data. In particular, we have a many-to-one (or a foreign key) relationship
    for the Publisher (the `publisher_id` field) and a many-to-many relationship for
    the Authors (the `author_ids` field).
  prefs: []
  type: TYPE_NORMAL
- en: In the CSV file header line, relationship columns should have `/id` appended
    to their names. It will reference the related records using external identifiers.
    In our example, we will load the book publisher into a `publisher_id/id` field,
    using the external ID for the related partner as a value.
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to use `/.id` instead so that we can use the actual database
    IDs (the real numeric identifier that's been assigned), but this is rarely what
    we need. Unless you have good reason to do otherwise, always use external IDs
    instead of database IDs. Also, remember that database IDs are specific to a particular
    Odoo database, so, most of the time, it won't work correctly if it's imported
    into a database other than the original one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Many-to-many fields can also be imported through `CSV` data files. It''s as
    easy as providing a comma-separated list of external IDs, surrounded by double
    quotes. For example, to load the book authors, we would have an `author_ids/id`
    column, where we would use a comma-separated list of the external IDs of the Partners
    to link as values. Here is an example of what a to-many field would look like
    in a CSV file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: One-to-many fields often represent headers or lines, or parent or child relationships,
    and there is special support to import these types of relationships – for the
    same parent record, we can have several related lines.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we have an example of a one-to-many field in the *Partners* model: a
    company partner can have several child contacts. If we export the data from the
    *Partner* model and include the **Contacts**/**Name** field, we will see the structure
    that can be used to import this type of data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.8 – Data file example importing to-many related records'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image_00_008.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.8 – Data file example importing to-many related records
  prefs: []
  type: TYPE_NORMAL
- en: The `id` and `name` columns are for the parent records, while the `child_ids`
    columns are for the child records. Notice how the parent record columns are left
    blank for the child records after the first one.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding table, which is represented as a CSV file, looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see that the first two columns, `id` and `name`, have values in
    the first line and are empty in the next two lines. They have data for the parent
    record, which is the *Contact's Company*.
  prefs: []
  type: TYPE_NORMAL
- en: The other two columns are both prefixed with `child_ids/` and have values on
    all three lines. They contain data for the contacts related to the parent company.
    The first line contains data for both the company and the first contact, while
    the lines that follow contain data for the columns of the child contacts.
  prefs: []
  type: TYPE_NORMAL
- en: Adding module data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Modules use data files to load their default data, demonstration data, user
    interface definitions, and other configurations into the database. For this, we
    can use both CSV and XML files.
  prefs: []
  type: TYPE_NORMAL
- en: Changes in Odoo 12
  prefs: []
  type: TYPE_NORMAL
- en: The YAML file format was also supported until Odoo 11 and was removed in Odoo
    12\. Still, for a usage example, you can look at the `l10n_be` official module
    in Odoo 11, and for information on the YAML format, you can visit [http://yaml.org/](http://yaml.org/).
  prefs: []
  type: TYPE_NORMAL
- en: CSV files that are used by modules are the same as those we have seen and used
    for the import feature. When using them in modules, the filename must match the
    name of the model that the data will be loaded into. For example, a CSV file for
    loading data into the `library.book` model must be named `library.book.csv`.
  prefs: []
  type: TYPE_NORMAL
- en: A common usage of data CSV files is for accessing security definitions that
    have been loaded into the `ir.model.access` model. They usually use CSV files
    in a `security/` subdirectory, named `ir.model.access.csv`.
  prefs: []
  type: TYPE_NORMAL
- en: Demonstration data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Odoo add-on modules may install demonstration data, and it is considered good
    practice to do so. This is useful for providing usage examples for a module and
    the datasets to be used in tests. Demonstration data for a module is declared
    using the `demo` attribute of the `__manifest__.py` manifest file. Just like the
    `data` attribute, it is a list of filenames with the corresponding relative paths
    inside the module.
  prefs: []
  type: TYPE_NORMAL
- en: Some demonstration data should be added to the `library.book` module. An easy
    way to do this is to export some data from the development database with the module
    installed.
  prefs: []
  type: TYPE_NORMAL
- en: The convention is to place data files in a `data/` subdirectory. We should save
    these data files in the `library_app` add-on module as `data/library.book.csv`.
    Since this data will be owned by our module, we should edit the `id` values to
    remove the `__export__` prefix in the identifiers that are generated by the export
    feature.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, our `res.partner.csv` data file might look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The `library.book.csv` data file containing the Book demo data will look as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Do not forget to add these data files to the `__manifest__.py` manifest''s
    `demo` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The files are loaded in the order they are declared. This is important since
    records in a file cannot reference other records that haven't been created yet.
  prefs: []
  type: TYPE_NORMAL
- en: The next time the module is updated, the content of the file will be imported,
    so long as it is installed with the demo data enabled.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'While data files are also re-imported on module upgrades, this is not the case
    for the demo data files: these are only imported upon module installation.'
  prefs: []
  type: TYPE_NORMAL
- en: Of course, XML files can also be used to load or initialize data, leveraging
    the additional features they provide, compared to plain CSV files. In the next
    section, we will discuss using data files in XML format.
  prefs: []
  type: TYPE_NORMAL
- en: Using XML data files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While CSV files provide a simple and compact format to represent data, XML files
    are more powerful and give more control over the loading process. For example,
    their filenames are not required to match the model to be loaded. This is because
    the XML format is much richer and more information regarding what to load can
    be provided through the XML elements inside the file.
  prefs: []
  type: TYPE_NORMAL
- en: We used XML data files in the previous chapters. The user interface components,
    such as the views and menu items, are, in fact, records that are stored in system
    models. The XML files in the modules are used to load these records into the instance
    database.
  prefs: []
  type: TYPE_NORMAL
- en: 'To showcase this, a second data file will be added to the `library_app` module,
    `data/book_demo.xml`, with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'As usual, the new data file must be declared in the `__manifest__.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Similar to the CSV data file we saw in the previous section, this file also
    loads data into the *Library Books* model.
  prefs: []
  type: TYPE_NORMAL
- en: XML data files have an `<odoo>` top element, inside of which there can be several
    `<record>` elements, which are the equivalent to data rows in CSV files.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The `<odoo>` top element in data files was introduced in version 9.0 and replaces
    the former `<openerp>` tag. A `<data>` section inside the top element is still
    supported, but it's now optional. In fact, now, `<odoo>` and `<data>` are equivalent,
    so we could use either one as the top element for our XML data files.
  prefs: []
  type: TYPE_NORMAL
- en: A `<record>` element has two mandatory attributes, `model` and `id`, for the
    external identifier for the record, and contains a `<field>` tag for each field
    to write on.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the slash notation in the field names is not available here; we can't
    use `<field name="publisher_id/id">`. Instead, the `ref` special attribute is
    used to reference external identifiers. We'll discuss the values of the relational
    to-many fields in a moment.
  prefs: []
  type: TYPE_NORMAL
- en: You may have noticed the `noupdate="1"` attribute in the top `<odoo>` element.
    This prevents the data records from being loaded on module upgrades so that any
    later edits that are made to them are not lost.
  prefs: []
  type: TYPE_NORMAL
- en: The noupdate data attribute
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When a module is upgraded, the data file loading is repeated, and the module's
    records are rewritten. This means that upgrading a module will overwrite any manual
    changes that might have been made to the module's data.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Notably, if views were manually modified to add quick customizations, these
    changes will be lost with the next module upgrade. To avoid this, the correct
    approach is to create inherited views with the changes we want to introduce.
  prefs: []
  type: TYPE_NORMAL
- en: This rewrite behavior is the default, but it can be changed so that some of
    the data is only imported at install time, and is ignored in later module upgrades.
    This can be done using the `noupdate="1"` attribute in the `<odoo>` or `<data>`
    elements.
  prefs: []
  type: TYPE_NORMAL
- en: This is useful for data that is to be used for the initial configuration but
    is expected to be customized later since these manually made customizations will
    be safe from module upgrades. For example, it is frequently used for record access
    rules, allowing them to be adapted to implementation-specific needs.
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to have more than one `<data>` section in the same `XML` file.
    We can take advantage of this to separate data to import only once, with `noupdate="1"`,
    and data that can be re-imported on each upgrade, with `noupdate="0"`. `noupdate="0"`
    is the default, so we can just omit it if we prefer. Note that we need to have
    a top-level XML element, so in this case, we will use two `<data>` sections. They
    must be inside a top-level `<odoo>` or `<data>` element.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: The `noupdate` attribute can be tricky when we're developing modules because
    changes that are made to the data later will be ignored. One solution is to, instead
    of upgrading the module with the `-u` option, reinstall it using the `-i` option.
    Reinstalling from the command line using the `-i` option ignores the `noupdate`
    flags on data records.
  prefs: []
  type: TYPE_NORMAL
- en: The `noupdate` flag is stored in the **External Identifier** information for
    each record. It's possible to manually edit it directly using the **External Identifier**
    form, which is available in the **Technical** menu, by using the **Non Updatable**
    checkbox.
  prefs: []
  type: TYPE_NORMAL
- en: Changes in Odoo 12
  prefs: []
  type: TYPE_NORMAL
- en: In **Developer Menu**, when accessing **View Metadata**, the dialog box now
    also shows the value for the **No Update** flag, along with the record's **XML
    ID**. Furthermore, **No Update flag** can be changed there by clicking on it.
  prefs: []
  type: TYPE_NORMAL
- en: Defining records in XML
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In an `XML` data file, each `<record>` element has two basic attributes, `id`
    and `model`, and contains `<field>` elements that assign values to each column.
    The `id` attribute corresponds to the record's external identifier, while the
    `model` attribute corresponds to the target model. The `<field>` elements have
    a few different ways to assign values. Let's look at them in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Setting field values directly
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `name` attribute of a `<field>` element identifies the field to write on.
  prefs: []
  type: TYPE_NORMAL
- en: 'The value to write is the element''s content: the text between the field''s
    opening and closing tag. For dates and date-times, `eval` attributes with expressions
    that return `date` or `datetime` objects will work. Returning strings with `"YYYY-mm-dd"`
    and `"YYYY-mm-dd HH:MM:SS"` will be converted properly. For boolean fields, the
    `"0"` and `"False"` values are converted into `False`, and any other non-empty
    values will be converted into `True`.'
  prefs: []
  type: TYPE_NORMAL
- en: Changes in Odoo 10
  prefs: []
  type: TYPE_NORMAL
- en: The way Boolean `False` values are read from data files has been improved in
    Odoo 10\. In previous versions, any non-empty values, including `"0"` and `"False"`,
    were converted into `True`. Until Odoo 9, Boolean values should be set using the
    `eval` attribute, such as `eval="False"`.
  prefs: []
  type: TYPE_NORMAL
- en: Setting values using expressions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A more elaborate alternative for setting a field value is using the `eval` attribute.
    It evaluates a Python expression and assigns the result to the field.
  prefs: []
  type: TYPE_NORMAL
- en: The expression is evaluated in a context that, besides Python built-ins, also
    has some additional identifiers that are available to build the expression to
    evaluate.
  prefs: []
  type: TYPE_NORMAL
- en: 'To handle dates, the following Python modules are available: `time`, `datetime`,
    `timedelta`, and `relativedelta`. They allow you to calculate date values, something
    that is frequently used in demonstrations and test data so that the dates used
    are close to the module installation date. For more information about these Python
    modules, see the documentation at [https://docs.python.org/3/library/datatypes.html](https://docs.python.org/3/library/datatypes.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to set a value to yesterday, we can use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Also available in the evaluation context is the `ref()` function, which is
    used to translate an external identifier into the corresponding database ID. This
    can be used to set values for relational fields. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This example sets a value for the `publisher_id` field using the `eval` attribute.
    The evaluated expression is Python code that uses the special `ref()` function,
    which is used to translate an *XML ID* into the corresponding database ID.
  prefs: []
  type: TYPE_NORMAL
- en: Setting values on many-to-one relationship fields
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For many-to-one relationship fields, the value to write is the database ID for
    the linked record. In XML files, we usually know the *XML ID* for the record,
    and we need to have it translated into the actual database ID.
  prefs: []
  type: TYPE_NORMAL
- en: One way to do this is to use the `eval` attribute with a `ref()` function, like
    we just did in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: 'A simpler alternative is to use the `ref` attribute, which is available for
    `<field>` elements; for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This example sets a value for the `publisher_id` many-to-one field, referencing
    the database record with an *XML ID* of `res_partner_packt`.
  prefs: []
  type: TYPE_NORMAL
- en: Setting values on to-many relationship fields
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For one-to-many and many-to-many fields, instead of a single ID, a list of related
    IDs is expected. Furthermore, several operations can be performed – we may want
    to replace the current list of related records with a new one, or append a few
    records to it, or even unlink some records.
  prefs: []
  type: TYPE_NORMAL
- en: To support write operations on to-many fields, we can use a special syntax in
    the `eval` attribute. To write to a to-many field, we can use a *list* of *triples*.
    Each *triple* is a `write` command that does different things based on the code
    that was used in the first element.
  prefs: []
  type: TYPE_NORMAL
- en: 'To overwrite the list of authors of a book, we would use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'To append a linked record to the current list of the authors of a book, we
    would use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The preceding examples are the most common. In both cases, we used just one
    command, but we could chain several commands in the outer list. The `append (4)`
    and `replace (6)` commands are the most used. In the case of `append (4)`, the
    last value of the triple is not used and is not needed, so it can be omitted,
    as we did in the preceding code sample.
  prefs: []
  type: TYPE_NORMAL
- en: 'The complete list of available **to-many write commands** is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`(0, _ , {''field'': value})` creates a new record and links it to this one.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(1, id, {''field'': value})` updates the values on an already linked record.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(2, id, _)` removes the link to and deletes the id-related record.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(3, id, _)` removes the link to, but does not delete, the id-related record.
    This is usually what you will use to delete related records on many-to-many fields.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(4, id, _)` links an already existing record. This can only be used for many-to-many
    fields.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(5, _, _)` removes all the links, without deleting the linked records.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(6, _, [ids])` replaces the list of linked records with the provided list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `_` underscore symbol that was used in the preceding list represents irrelevant
    values, usually filled with `0` or `False`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: The trailing irrelevant values can be safely omitted. For example, `(4, id,
    _)` can be used as `(4, id)`.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned how to use the `<record>` tag to load records into
    the database. As an alternative, there are a few shortcut tags that can be used
    in place of a regular `<record>` tag. The next section will introduce these to
    us.
  prefs: []
  type: TYPE_NORMAL
- en: Shortcuts for frequently used models
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If we go back to [*Chapter 3*](B16119_03_Final_PD_ePub.xhtml#_idTextAnchor072),
    *Your First Odoo Application*, we will find elements other than `<record>` in
    the XML files, such as `<menuitem>`.
  prefs: []
  type: TYPE_NORMAL
- en: These are convenient shortcuts for frequently used models, with a more compact
    notation compared to the regular `<record>` elements. They are used to load data
    into base models that support the user interface, and they will be explored in
    more detail later, in [*Chapter 10*](B16119_10_Final_PD_ePub.xhtml#_idTextAnchor287),
    *Backend Views – Designing the User Interface*.
  prefs: []
  type: TYPE_NORMAL
- en: 'For reference, these are the shortcut elements available, along with the corresponding
    models they load data into:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<menuitem>` is for the menu items model, `ir.ui.menu`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<template>` is for *QWeb* templates stored in the `ir.ui.view` model.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changes in Odoo 14
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Past versions of Odoo used to support additional shortcut tags, which are not
    supported anymore. There was an `<act_window>` for the window action model, `ir.actions.act_window`,
    and a `<report>` for the report action model, `ir.actions.report.xml`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: It is important to note that, when used to modify existing records, the shortcut
    elements overwrite all the fields. This differs from the `<record>` basic element,
    which only writes to the fields provided. So, for cases where we need to modify
    just a particular field of a user interface element, we should do so using a `<record>`
    element instead.
  prefs: []
  type: TYPE_NORMAL
- en: Using other actions in XML data files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we have seen how to add or update data using XML files. But XML files
    also allow you to delete data and execute arbitrary model methods. This can be
    useful for more complex data setups. In the following sections, we will learn
    how the delete and function call XML features can be used.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting records
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To delete a data record, we can use the `<delete>` element, providing it with
    either an ID or a search domain to find the target records.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, using a search domain to find the record to delete looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'If we know the specific ID to delete, we can use it with the `id` attribute
    instead. This was the case for the previous example, so it could also be written
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This has the same effect as the previous example. Since we know the ID to look
    for, instead of using the `search` attribute with a domain expression, we can
    simply use the `id` attribute with the *XML ID*.
  prefs: []
  type: TYPE_NORMAL
- en: Calling model methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An `XML` file can also execute arbitrary methods during its load process through
    the `<function>` element. This can be used to set up demo and test data.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the **Notes** app, which is bundled with Odoo, uses it to set
    up demonstration data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This calls the `_init_data_user_note_stages` method of the `res.users` model,
    passing no arguments. The argument list is provided by the `eval` attribute, which
    is an empty list in this case.
  prefs: []
  type: TYPE_NORMAL
- en: This completes everything we need to know to use XML data files. We provided
    an overview of `<data>` elements and the `noupdate` flag. We then learned how
    to use the `<record>` element to load data records, as well as how to set values
    on related fields. We also learned about record shortcuts, such as `<menuitem>`
    and `<template>`. Finally, we learned how to delete records and make arbitrary
    function calls with the `<delete>` and `<function>` elements.
  prefs: []
  type: TYPE_NORMAL
- en: With this, we should be prepared to use XML data files for whatever data needs
    our project might have.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to represent data in text files. These can be
    used to manually import data into Odoo or include it in add-on modules as default
    or *demonstration data*.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we should be able to export and import CSV data files from the
    web interface and leverage *external IDs* to detect and update records that already
    exist in the database. They can also be used to perform a mass edit on data, by
    editing and reimporting a CSV file that has been exported from Odoo.
  prefs: []
  type: TYPE_NORMAL
- en: We also learned about how XML data files are structured, and all the features
    they provide, in more detail. These were not only set values on fields but also
    actions such as deleting records and calling model methods.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will focus on how to use *records* to work with the
    data contained in models. This will give us the necessary tools to then implement
    our application's business logic and rules.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The official Odoo documentation provides additional resources on data files:
    [https://www.odoo.com/documentation/15.0/developer/reference/backend/data.html](https://www.odoo.com/documentation/15.0/developer/reference/backend/data.html).'
  prefs: []
  type: TYPE_NORMAL
