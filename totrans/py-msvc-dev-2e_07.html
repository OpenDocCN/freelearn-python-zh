<html><head></head><body>
  <div id="_idContainer044">
    <h1 class="chapterNumber">7</h1>
    <h1 id="_idParaDest-118" class="chapterTitle">Securing Your Services</h1>
    <p class="normal">So far in this book, all the interactions between services were done without any form of authentication or authorization; each HTTP request would happily return a result. This cannot happen in production for two simple reasons: we need to know who is calling the service (authentication), and we need to make sure that the caller is allowed to perform the call (authorization). For instance, we probably don't want an anonymous caller to delete entries in a database.</p>
    <p class="normal">In a monolithic web application, simple authentication can happen with a login form, and once the user is identified a cookie is set with a session identifier so that the client and server can collaborate on all subsequent requests. In a microservice-based architecture, we cannot use this scheme everywhere because services are not users and won't use web forms for authentication. We need a way to accept or reject calls between services automatically.</p>
    <p class="normal">The OAuth2 authorization protocol gives us the flexibility to add authentication and authorization in our microservices, which can be used to authenticate both users and services. In this chapter, we will discover the essential features of OAuth2 and how to implement an authentication microservice. This service will be used to secure service-to-service interactions.</p>
    <p class="normal">A few things can be done at the code level to protect your services, such as controlling system calls, or making sure HTTP redirects are not ending up on hostile web pages. We will discuss how to add protection against badly formed data, some common pitfalls to avoid, and demonstrate how you can scan your code against potential security issues.</p>
    <p class="normal">Lastly, securing services also means we want to filter out any suspicious or malicious network traffic before it reaches our application. We will look at setting up a basic web application firewall to defend our services.</p>
    <h1 id="_idParaDest-119" class="title">The OAuth2 protocol</h1>
    <p class="normal">If you are reading this book, you are in<a id="_idIndexMarker414"/> all likelihood someone who has logged in to a web page with a username and password. It's a straightforward model to confirm who you are, but there are drawbacks.</p>
    <p class="normal">Many different websites exist, and each needs to properly handle someone's identity and password. The potential for security leaks multiplies with the number of different places an identity is stored, and how many routes a password can take through the different systems involved. It also becomes easier for attackers to create fake sites, as people become used to entering their username and password in multiple different places that may all look slightly different. Instead, you have probably come across websites that let you "Login with Google," Microsoft, Facebook, or GitHub. This feature uses OAuth2, or tools built on top of it.</p>
    <p class="normal">OAuth2 is a standard that is widely adopted for securing web applications and their interactions with users and other web applications. Only one service ever gets told your password or multi-factor authentication codes, and any site that needs to authenticate you directs you there. There are two types of authentication that we will cover here, the first being the Authentication Code Grant, which is initiated by a human using a browser or mobile app.</p>
    <p class="normal">The process for a user-driven Authentication Code Grant looks complicated as it is depicted in <em class="italic">Figure 7.1</em>, but it serves an important purpose. Following the figure through, when a client requests a resource—whether it is a web page or some data, say—that they must log in to view, the application sends a <code class="Code-In-Text--PACKT-">302</code> redirection to visit the authentication service. In that URL will be another address that the authentication service can use to send the client back to the application.</p>
    <p class="normal">Once the client connects, the authentication service does the things you might expect—it asks for a username, password, and multi-factor authentication codes, and some may even display a picture or some text to demonstrate that you are visiting the right place. After logging in correctly, the authentication service redirects the client back to the application, this time with a token to present.</p>
    <p class="normal">The application can validate the token with the authentication service, and can remember that result until the token expires, or for some other configurable length of time, occasionally rechecking it to check that the token hasn't been revoked. This way the application never has to deal with a username or password, and only has to learn enough to uniquely identify the client.</p>
    <figure class="mediaobject"><img src="../Images/B17108_07_01.png" alt=""/></figure>
    <p class="packt_figref">Figure 7.1: The OAuth2 authentication flow</p>
    <p class="normal">When setting up OAuth2 for a program to use, so that one service can connect to another, there is a similar process<a id="_idIndexMarker415"/> called <strong class="keyword">Client Credentials Grant</strong> (<strong class="keyword">CCG</strong>) in which a service can connect to the authentication microservice and ask for a token that it can use. You can<a id="_idIndexMarker416"/> refer to the CCG <a id="_idIndexMarker417"/>scenario described in <em class="italic">section 4.4</em> of the OAuth2 Authorization Framework for more information: <a href="https://tools.ietf.org/html/rfc6749#section-4.4"><span class="url">https://tools.ietf.org/html/rfc6749#section-4.4</span></a>.</p>
    <p class="normal">This works like the authorization code, but the service is not redirected to a web page as a user is. Instead, it's implicitly authorized with a secret key that can be traded for a token.</p>
    <p class="normal">For a microservices-based architecture, using these two types of grants will let us centralize every aspect of authentication and authorization of the system. Building a microservice that implements part of the OAuth2 protocol to authenticate services and keep track of how they interact with each other is a good solution to reduce security issues—everything is centralized in a single place.</p>
    <p class="normal">The CCG flow is by far the most interesting aspect to look at in this chapter, because it allows us to secure our microservice interactions independently from the users. It also simplifies permission management, since we can issue tokens with different scopes depending on the context. The applications are still responsible for enforcing what those scopes can and cannot do.</p>
    <p class="normal">If you do not <a id="_idIndexMarker418"/>want to implement and maintain the authentication part of your application and you can trust a third party to manage this process, then Auth0 is an excellent commercial solution that provides all the APIs needed for a microservice-based application: <a href="https://auth0.com/"><span class="url">https://auth0.com/</span></a>.</p>
    <h1 id="_idParaDest-120" class="title">X.509 certificate-based authentication</h1>
    <p class="normal">The <code class="Code-In-Text--PACKT-">X.509</code> standard (<a href="https://datatracker.ietf.org/doc/html/rfc5280"><span class="url">https://datatracker.ietf.org/doc/html/rfc5280</span></a>) is used to secure the web. Every<a id="_idIndexMarker419"/> website using TLS—the ones with <code class="Code-In-Text--PACKT-">https://</code> URLs—has an <code class="Code-In-Text--PACKT-">X.509</code> certificate on its <a id="_idIndexMarker420"/>web server, and uses it to verify the server's identity and set up the encryption the connection will use.</p>
    <p class="normal">How does a client verify a server's identity when it is presented with such a certificate? Each properly issued certificate is cryptographically signed by a trusted authority. A <strong class="keyword">Certificate Authority</strong> (<strong class="keyword">CA</strong>) will often <a id="_idIndexMarker421"/>be the one issuing the certificate to you and will be the ultimate organization that browsers rely on to know who to trust. When the encrypted connection is being negotiated, a client will examine the certificate it's given and check who has signed it. If it is a trusted CA and the cryptographic checks are passed, then we can assume the certificate represents who it claims to. Sometimes the signer is an intermediary, so this step should be repeated until the client reaches a trusted CA.</p>
    <p class="normal">It is possible to create a self-signed certificate, and this can be useful in test suites or for local development environments—although it is the digital equivalent of saying, "trust me, because I said so." A production service should not use self-signed certificates, and if the browser issues a warning, the human sitting in front of it will be right to be wary of the site they're accessing.</p>
    <p class="normal">Obtaining a good certificate is significantly <a id="_idIndexMarker422"/>easier than it used to be, thanks to Let's Encrypt (<a href="https://letsencrypt.org/"><span class="url">https://letsencrypt.org/</span></a>). Organizations that charge money for a certificate still offer value—there are features such as Extended Validation that aren't easily automated, and sometimes that extra display in the browser, often as a green padlock in the address bar, is worth it.</p>
    <p class="normal">Let us generate a certificate using Let's Encrypt, and use some command-line tools to examine it. On the Let's Encrypt website there are instructions to install a utility called <code class="Code-In-Text--PACKT-">certbot</code>. The instructions will vary slightly depending on the platform being used, so we won't include them here. Once <code class="Code-In-Text--PACKT-">certbot</code> is installed, obtaining a certificate for a web server such as <code class="Code-In-Text--PACKT-">nginx</code> is simple:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span><span class="language-bash">sudo certbot --nginx</span>
No names were found in your configuration files. Please enter in your domain
name(s) (comma and/or space separated)  (Enter 'c' to cancel): certbot-test.mydomain.org
Requesting a certificate for certbot-test.mydomain.org
Performing the following challenges:
http-01 challenge for certbot-test.mydomain.org
Waiting for verification...
Cleaning up challenges
Deploying Certificate to VirtualHost /etc/nginx/sites-enabled/default
Redirecting all traffic on port 80 to ssl in /etc/nginx/sites-enabled/default
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
Congratulations! You have successfully enabled https://certbot-test.mydomain.org
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
</code></pre>
    <p class="normal">Now we can examine our <a id="_idIndexMarker423"/><code class="Code-In-Text--PACKT-">nginx</code> configuration, and the site mentioned in the <code class="Code-In-Text--PACKT-">certbot</code> output—<code class="Code-In-Text--PACKT-">/etc/nginx/sites-enabled/default</code>. We can also see that the certificates have been set up for us, and we could have told <code class="Code-In-Text--PACKT-">certbot</code> to just generate some certificates and let us install them if we wanted more fine-grained control over what happens with our configuration. In the following snippet of <code class="Code-In-Text--PACKT-">nginx</code> configuration, we see the parts that <code class="Code-In-Text--PACKT-">certbot</code> has added in order to secure the web service:</p>
    <pre class="programlisting con"><code class="hljs-con">listen [::]:443 ssl ipv6only=on; # managed by Certbot
listen 443 ssl; # managed by Certbot
ssl_certificate /etc/letsencrypt/live/certbot-test.mydomain.org/fullchain.pem; # managed by Certbot
ssl_certificate_key /etc/letsencrypt/live/certbot-test.mydomain.org/privkey.pem; # managed by Certbot
include /etc/letsencrypt/options-ssl-nginx.conf; # managed by Certbot
ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem; # managed by Certbot
</code></pre>
    <p class="normal">We can use the OpenSSL toolkit to examine our certificate, both by looking at the file and by sending a query to the web server. Examining the certificate will provide a lot of information, although the important pieces for us include the sections on <strong class="screenText">Validity</strong> and <strong class="screenText">Subject</strong>. A certificate expiring without being renewed is a common error condition when running a service; <code class="Code-In-Text--PACKT-">certbot</code> includes helpers to automatically refresh certificates that are about to expire, and so if we use the provided tools, this should not be a problem.</p>
    <p class="normal">A certificate subject<a id="_idIndexMarker424"/> describes the entity that the certificate has been created for, and in this instance, that is a hostname. The certificate presented here has a subject <strong class="keyword">Common Name</strong> (<strong class="keyword">CN</strong>) of <code class="Code-In-Text--PACKT-">certbot-test.mydomain.org</code>, but if that's not the hostname we are using then the clients connecting to our service will rightfully complain. </p>
    <p class="normal">In order to examine a certificate's details, including the subject, we can use the <code class="Code-In-Text--PACKT-">openssl</code> utility to display the certificate:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span><span class="language-bash">sudo openssl x509</span> -in <span class="language-bash">/etc/letsencrypt/live/certbot-test.mydomain.org/fullchain.pem  -text -noout</span>
Certificate:
	Data:
  	Version: 3 (0x2)
  	Serial Number:
    	04:92:e3:37:a4:83:77:4f:b9:d7:5c:62:24:74:7e:a4:5a:e0
  	Signature Algorithm: sha256WithRSAEncryption
  	Issuer: C = US, O = Let's Encrypt, CN = R3
  	Validity
    	Not Before: Mar 13 14:43:12 2021 GMT
    	Not After : Jun 11 14:43:12 2021 GMT
  	Subject: CN = certbot-test.mydomain.org
...
</code></pre>
    <p class="normal">It is also possible to connect to a running web server using the <code class="Code-In-Text--PACKT-">openssl</code> utility, which may be useful to confirm that the correct certificate is being used, to run monitoring scripts for certificates that will soon expire, or for other such diagnostics. Using the <code class="Code-In-Text--PACKT-">nginx</code> instance we configured above, we can establish an encrypted session over which we can send HTTP commands:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span><span class="language-bash">openssl s_client -connect localhost:443</span>
CONNECTED(00000003)
Can't use SSL_get_servername
depth=2 O = Digital Signature Trust Co., CN = DST Root CA X3
verify return:1
depth=1 C = US, O = Let's Encrypt, CN = R3
verify return:1
depth=0 CN = certbot-test.mydomain.org
verify return:1
---
Certificate chain
 0 s:CN = certbot-test.mydomain.org
 i:C = US, O = Let's Encrypt, CN = R3
 1 s:C = US, O = Let's Encrypt, CN = R3
 i:O = Digital Signature Trust Co., CN = DST Root CA X3
---
Server certificate
-----BEGIN CERTIFICATE-----
MII  
<span class="hljs-con-meta">#</span><span class="hljs-con-meta"> </span><span class="language-bash">A really long certificate has been removed here</span>
-----END CERTIFICATE-----
subject=CN = certbot-test.mydomain.org
issuer=C = US, O = Let's Encrypt, CN = R3
---
New, TLSv1.3, Cipher is TLS_AES_256_GCM_SHA384
Server public key is 2048 bit
Secure Renegotiation IS NOT supported
Compression: NONE
Expansion: NONE
No ALPN negotiated
Early data was not sent
Verify return code: 0 (ok)
---
</code></pre>
    <p class="normal">We can easily read the<a id="_idIndexMarker425"/> public certificate in this exchange, and confirm it is the one we are expecting the server to use, from its configuration file. We can also discover which encryption suites have been negotiated between the client and server, and identify any that might be a cause of problems if older client libraries or web browsers are being used.</p>
    <p class="normal">So far, we have only discussed the server using certificates to verify its identity and to establish a secure connection. It is also possible for the client to present a certificate to authenticate itself. The certificate would allow our application to verify that the client is who they claim to be, but we should be careful, as it does not automatically mean that the client is allowed to do something—that control still lies with our own application. Managing these certificates, setting up a CA to issue the appropriate certificates for clients, and how to properly distribute the files, are beyond the scope of this book. If it is the right choice for an application you are creating, a good place to start is the <code class="Code-In-Text--PACKT-">nginx</code> documentation at <a href="http://nginx.org/en/docs/http/ngx_http_ssl_module.html#ssl_verify_client"><span class="url">http://nginx.org/en/docs/http/ngx_http_ssl_module.html#ssl_verify_client</span></a>.</p>
    <p class="normal">Let's take a look at authenticating clients that use our services, and how we can set up a microservice dedicated to validating client access.</p>
    <h1 id="_idParaDest-121" class="title">Token-based authentication</h1>
    <p class="normal">As we said earlier, when one service wants to get access to another without any user intervention, we can use a CCG flow. The idea behind CCG is that a service can connect to an<a id="_idIndexMarker426"/> authentication service and ask for a token that it can then use to authenticate against other services. </p>
    <p class="normal">Authentication services could issue multiple tokens in systems where different sets of permissions are needed, or identities vary.</p>
    <p class="normal">Tokens can hold any information that is useful for the authentication and authorization process. Some of these are as follows:</p>
    <ul>
      <li class="bullet">The <code class="Code-In-Text--PACKT-">username</code> or <code class="Code-In-Text--PACKT-">ID</code>, if it's pertinent to the context</li>
      <li class="bullet">The scope, which indicates what the caller can do (<code class="Code-In-Text--PACKT-">read</code>, <code class="Code-In-Text--PACKT-">write</code>, and so on)</li>
      <li class="bullet">A <code class="Code-In-Text--PACKT-">timestamp</code> indicating when the token was issued</li>
      <li class="bullet">An expiration <code class="Code-In-Text--PACKT-">timestamp</code>, indicating how long the token is valid for</li>
    </ul>
    <p class="normal">A token is usually built as a complete proof that you have permission to use a service. It is complete because it is possible to validate the token with the authentication service without knowing anything else, or having to query an external resource. Depending on the implementation, a token can also be used to access different microservices.</p>
    <p class="normal">OAuth2 uses the JWT standard for its tokens. There is nothing in OAuth2 that requires the use of JWT—it just happens to be a good fit for what OAuth2 wants to do.</p>
    <h2 id="_idParaDest-122" class="title">The JWT standard</h2>
    <p class="normal">The <strong class="keyword">JSON Web Token </strong>(<strong class="keyword">JWT</strong>) described in<a id="_idIndexMarker427"/> RFC 7519 is a standard<a id="_idIndexMarker428"/> that is commonly used to represent tokens: <a href="https://tools.ietf.org/html/rfc7519"><span class="url">https://tools.ietf.org/html/rfc7519</span></a>.</p>
    <p class="normal">A JWT is a long string composed of three dot-separated parts:</p>
    <ul>
      <li class="bullet"><strong class="keyword">A header</strong>: This provides<a id="_idIndexMarker429"/> information on the token, such as which hashing algorithm is used</li>
      <li class="bullet"><strong class="keyword">A payload</strong>: This is the <a id="_idIndexMarker430"/>actual data</li>
      <li class="bullet"><strong class="keyword">A signature</strong>: This is a signed hash of the <a id="_idIndexMarker431"/>header and payload to verify that it is legitimate</li>
    </ul>
    <p class="normal">JWTs are Base64-encoded so they can be safely used in query strings. Here's a JWT in its encoded form:</p>
    <pre class="programlisting con"><code class="hljs-con">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9
.
eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IlNpbW9uIEZyYXNlciIsIm lhdCI6MTYxNjQ0NzM1OH0
.
K4ONCpK9XKtc4s56YCC-13L0JgWohZr5J61jrbZnt1M
</code></pre>
    <p class="normal">Each part in the <a id="_idIndexMarker432"/>token above is separated by a line break for display purposes—the original token is a single line. You can experiment with JWT encoding and decoding using a utility provided by Auth0 at <a href="https://jwt.io/"><span class="url">https://jwt.io/</span></a>.</p>
    <p class="normal">If we use Python to decode it, the data is simply in Base64:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> base64
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">def</span> <span class="hljs-con-title">decode</span>(data):
<span class="hljs-con-meta">...</span> # adding extra = for padding if needed
<span class="hljs-con-meta">...</span> pad = <span class="hljs-con-built_in">len</span>(data) % <span class="hljs-con-number">4</span>
<span class="hljs-con-meta">...</span> <span class="hljs-con-keyword">if</span> pad &gt; <span class="hljs-con-number">0</span>:
<span class="hljs-con-meta">...</span>     data += <span class="hljs-con-string">"="</span> * (<span class="hljs-con-number">4</span> - pad)
<span class="hljs-con-meta">...</span> <span class="hljs-con-keyword">return</span> base64.urlsafe_b64decode(data)
<span class="hljs-con-meta">...</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> decode(<span class="hljs-con-string">"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9"</span>)
b'{"alg":"HS256","typ":"JWT"}'
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">import</span> base64 
<span class="hljs-con-meta">&gt;&gt;&gt;</span> decode(<span class="hljs-con-string">"eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IlNpbW9uIEZyYXNlciIsImlhdC I6MTYxNjQ0NzM1OH0"</span>)
b'{"sub":"1234567890","name":"Simon Fraser","iat":1616447358}'
<span class="hljs-con-meta">&gt;&gt;&gt;</span> decode(<span class="hljs-con-string">"K4ONCpK9XKtc4s56YCC-13L0JgWohZr5J61jrbZnt1M"</span>)
b"+\x83\x8d\n\x92\xbd\\\xab\\\xe2\xcez` \xbe\xd7r\xf4&amp;\x05\xa8\x85\x9a\xf9'\xadc\xad\xb6g\xb7S"
</code></pre>
    <p class="normal">Every part of the JWT is a JSON mapping except the signature. The header usually contains just the <code class="Code-In-Text--PACKT-">typ</code> and the <code class="Code-In-Text--PACKT-">alg</code> keys: the <code class="Code-In-Text--PACKT-">typ</code> key says that it is a JWT, and the <code class="Code-In-Text--PACKT-">alg</code> key indicates which hashing algorithm is used. In the following header example, we have <code class="Code-In-Text--PACKT-">HS256</code>, which stands for <code class="Code-In-Text--PACKT-">HMAC-SHA256</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">{<span class="hljs-string">"typ"</span>: <span class="hljs-string">"JWT"</span>,  <span class="hljs-string">"alg"</span>: <span class="hljs-string">"HS256"</span>} 
</code></pre>
    <p class="normal">The payload contains whatever you <a id="_idIndexMarker433"/>need, and each field is called a <strong class="keyword">JWT claim </strong>in the RFC 7519 jargon. The RFC has a predefined list of claims that a token may<a id="_idIndexMarker434"/> contain, called <strong class="keyword">Registered Claim Names</strong>. Here's a subset of them:</p>
    <ul>
      <li class="bullet"><code class="Code-In-Text--PACKT-">iss</code>: This is the issuer, which is the name of the entity that generated the token. It's typically the<a id="_idIndexMarker435"/> fully qualified hostname, so the client can use it to discover its public keys by requesting <code class="Code-In-Text--PACKT-">/.well-known/jwks.json</code>.</li>
      <li class="bullet"><code class="Code-In-Text--PACKT-">exp</code>: This is the expiration time, which is a timestamp after which the token is invalid.</li>
      <li class="bullet"><code class="Code-In-Text--PACKT-">nbf</code>: This stands for <em class="italic">not before time</em>, which is a timestamp before which the token is invalid.</li>
      <li class="bullet"><code class="Code-In-Text--PACKT-">aud</code>: This indicates the audience, which is the recipient for whom the token was issued.</li>
      <li class="bullet"><code class="Code-In-Text--PACKT-">iat</code>: Stands for <em class="italic">issued at</em>, which is a timestamp for when the token was issued.</li>
    </ul>
    <p class="normal">In the following payload example, we're providing the custom <code class="Code-In-Text--PACKT-">user_id</code> value along with timestamps that make the token valid for the 24 hours after it was issued; once valid, that token can be used for 24 hours:</p>
    <pre class="programlisting code"><code class="hljs-code">{
  <span class="hljs-string">"iss"</span>: <span class="hljs-string">"https://tokendealer.mydomain.org"</span>, 
  <span class="hljs-string">"aud"</span>: <span class="hljs-string">"mydomain.org"</span>, 
  <span class="hljs-string">"iat"</span>: <span class="hljs-number">1616447358</span>, 
  <span class="hljs-string">"nbt"</span>: <span class="hljs-number">1616447358</span>, 
  <span class="hljs-string">"exp"</span>: <span class="hljs-number">1616533757</span>, 
  <span class="hljs-string">"user_id"</span>: <span class="hljs-number">1234</span>
} 
</code></pre>
    <p class="normal">These headers give us a lot of flexibility to control how long our tokens will stay valid. Depending on the nature of the microservice, the<a id="_idIndexMarker436"/> token <strong class="keyword">Time-To-Live</strong> (<strong class="keyword">TTL</strong>) can be anything from very short to infinite. For instance, a microservice that interacts with others within your system should probably rely on tokens that are valid for long enough to avoid having to regenerate tokens unnecessarily, multiple times. On the other hand, if your tokens are distributed in the wild, or if they relate to changing something highly important, it's a good idea to make them short-lived.</p>
    <p class="normal">The last part of a JWT is the signature. It contains a signed hash of the header and the payload. There are several<a id="_idIndexMarker437"/> algorithms used to sign the hash; some are based on a secret key, while others are based on a public and private key pair.</p>
    <h2 id="_idParaDest-123" class="title">PyJWT</h2>
    <p class="normal">In Python, the <code class="Code-In-Text--PACKT-">PyJWT</code> library provides<a id="_idIndexMarker438"/> all the tools you need to<a id="_idIndexMarker439"/> generate and read back JWTs: <a href="https://pyjwt.readthedocs.io/"><span class="url">https://pyjwt.readthedocs.io/</span></a>.</p>
    <p class="normal">Once you've pip-installed <code class="Code-In-Text--PACKT-">pyjwt</code> (and <code class="Code-In-Text--PACKT-">cryptography</code>), you can use the <code class="Code-In-Text--PACKT-">encode()</code> and the <code class="Code-In-Text--PACKT-">decode()</code> functions to create tokens. In the following example, we're creating a JWT using <code class="Code-In-Text--PACKT-">HMAC-SHA256</code> and reading it back. The signature is verified when the token is read, by providing the secret:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span><span class="language-bash"> </span><span class="hljs-con-keyword">import</span><span class="language-bash"> jwt</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span><span class="language-bash">  </span><span class="hljs-con-keyword">def</span><span class="language-bash"> </span><span class="hljs-con-title">create_token</span><span class="language-bash">(alg=</span><span class="hljs-con-string">"HS256"</span><span class="language-bash">, secret=</span><span class="hljs-con-string">"secret"</span><span class="language-bash">, data=</span><span class="hljs-con-literal">None</span><span class="language-bash">):</span>
        <span class="hljs-con-keyword">return</span> jwt.encode(data, secret, algorithm=alg)
<span class="hljs-con-meta">...</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span><span class="language-bash"> </span><span class="hljs-con-keyword">def</span><span class="language-bash"> </span><span class="hljs-con-title">read_token</span><span class="language-bash">(token, secret=</span><span class="hljs-con-string">"secret"</span><span class="language-bash">, algs=[</span><span class="hljs-con-string">"HS256"</span><span class="language-bash">]):</span>
<span class="hljs-con-meta">...</span>  <span class="hljs-con-keyword">return</span> jwt.decode(token, secret, algorithms=algs)
<span class="hljs-con-meta">...</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span><span class="language-bash">  token = create_token(data={</span><span class="hljs-con-string">"some"</span><span class="language-bash">: </span><span class="hljs-con-string">"data"</span><span class="language-bash">, </span><span class="hljs-con-string">"inthe"</span><span class="language-bash">: </span><span class="hljs-con-string">"token"</span><span class="language-bash">})</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span><span class="language-bash"> </span>print<span class="language-bash">(token)</span>
eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzb21lIjoiZGF0YSIsImludGhlIjoidG9rZW4ifQ.vMHiSS_vk-Z3gMMxcM22Ssjk3vW3aSmJXQ8YCSCwFu4
<span class="hljs-con-meta">&gt;</span><span class="hljs-con-meta">&gt;&gt;</span><span class="language-bash"> </span>print<span class="language-bash">(read_token(token))</span>
{'some': 'data', 'inthe': 'token'}
</code></pre>
    <p class="normal">When executing this code, the token is displayed in both its compressed and uncompressed forms. If you use one of the registered claims, <code class="Code-In-Text--PACKT-">PyJWT</code> will control them. For instance, if the <code class="Code-In-Text--PACKT-">exp</code> field is provided and the token is outdated, the library will raise an error.</p>
    <p class="normal">Using a secret for signing and verifying the signature is great when you have a few services running, but it can soon become a problem due to it requiring you to share the secret among all services that need to verify the signature. So, when the secret needs to be changed, it can be a challenge to change it across your stack securely. Basing your authentication on a secret that you are sharing around is also a weakness. If a single service is compromised and the secret is stolen, your whole authentication system is compromised.</p>
    <p class="normal">A better technique is to use an asymmetric key composed of a public key and a private key. The private key is used by the token issuer to sign the tokens, and the public key can be utilized by anyone to verify that the signature was signed by that issuer. Of course, if an attacker has access to the private key, or can convince clients that a forged public key is the legitimate one, you would still be in trouble.</p>
    <p class="normal">But using a public/private key pair does still reduce the attack surface of your authentication process, often sufficiently to discourage most attackers; and, since the authentication <a id="_idIndexMarker440"/>microservice will be the only place that contains the private key, you can focus on adding extra security to it. For instance, such sensible services are often deployed in a firewalled environment where all access is strictly controlled. Let us now see how we can create asymmetric keys in practice.</p>
    <h2 id="_idParaDest-124" class="title">Using a certificate with JWT</h2>
    <p class="normal">To simplify <a id="_idIndexMarker441"/>matters for this example, we will use the <code class="Code-In-Text--PACKT-">letsencrypt</code> certificates we generated for <code class="Code-In-Text--PACKT-">nginx</code> earlier on. If you are developing on a laptop or container that is not available from the internet, you may need to generate those certificates using a cloud instance or a <code class="Code-In-Text--PACKT-">certbot</code> DNS plugin and copy them to the right place. </p>
    <p class="normal">If <code class="Code-In-Text--PACKT-">certbot</code> generated the certificates directly, they will be available in <code class="Code-In-Text--PACKT-">/etc/letsencrypt/live/your-domain/</code>. To start with, we are interested in these two files:</p>
    <ul>
      <li class="bullet"><code class="Code-In-Text--PACKT-">cert.pem</code>, which contains the certificate</li>
      <li class="bullet"><code class="Code-In-Text--PACKT-">privkey.pem</code>, which has the RSA private key</li>
    </ul>
    <p class="normal">In order to use these with PyJWT, we need to extract the public key from the certificate:</p>
    <pre class="programlisting code"><code class="hljs-code">openssl x509 -pubkey -noout -in cert.pem  &gt; pubkey.pem
</code></pre>
    <p class="normal"><strong class="keyword">RSA</strong> stands for <strong class="keyword">Rivest, Shamir, and Adleman</strong>, the three authors. The RSA encryption algorithm generates <a id="_idIndexMarker442"/>crypto keys that can go up to 4,096 bytes, and are considered secure.</p>
    <p class="normal">From there, we can use <code class="Code-In-Text--PACKT-">pubkey.pem</code> and <code class="Code-In-Text--PACKT-">privkey.pem</code> in our PyJWT script to sign and verify the signature of the token, using the <code class="Code-In-Text--PACKT-">RSASSA-PKCS1-v1_5</code> signature algorithm and the <code class="Code-In-Text--PACKT-">SHA-512</code> hash algorithm:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-keyword">import</span> jwt
  <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">"pubkey.pem"</span>) <span class="hljs-keyword">as</span> f:
    PUBKEY = f.read()
  <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">"privkey.pem"</span>) <span class="hljs-keyword">as</span> f:
    PRIVKEY = f.read()
  <span class="hljs-keyword">def</span> <span class="hljs-title">create_token</span>(<span class="hljs-params">**data</span>):
    <span class="hljs-keyword">return</span> jwt.encode(data, PRIVKEY, algorithm=<span class="hljs-string">"RS512"</span>)
  <span class="hljs-keyword">def</span> <span class="hljs-title">read_token</span>(<span class="hljs-params">token</span>):
    <span class="hljs-keyword">return</span> jwt.decode(token, PUBKEY, algorithms=<span class="hljs-string">"RS512"</span>)
  token = create_token(some=<span class="hljs-string">"data"</span>, inthe=<span class="hljs-string">"token"</span>)
  <span class="hljs-built_in">print</span>(token)
  read = read_token(token)
  <span class="hljs-built_in">print</span>(read)
</code></pre>
    <p class="normal">The result is <a id="_idIndexMarker443"/>similar to the previous run, except that we get a much bigger token:</p>
    <pre class="programlisting con"><code class="hljs-con">eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzUxMiJ9.eyJzb21lIjoiZGF0YSIsImludGh lIjoidG9rZW4ifQ.gi5p3k4PAErw8KKrghRjsi8g1IXnflivXiwwaZdFEh84zvgw9RJRa 50uJe778A1CBelnmo2iapSWOQ9Mq5U6gpv4VxoVYv6QR2zFNO13GB_tce6xQ OhjpAd-hRxouy3Ozj4oNmvwLpCT5dYPsCvIiuYrLt4ScK5S3q3a0Ny64VXy 3CcISNkyjs7fnxyMMkCMZq65Z7jOncf1RXpzNNIt546aJGsCcpCPGHR1cRj uvV_uxPAMd-dfy2d5AfiCXOgvmwQhNdaxYIM0gPgz9_yHPzgaPjtgYoJMc9iK ZdOLz2-8pLc1D3r_uP3P-4mfxP7mOhQHYBrY9nv5MTSwFC3JDA
{'some': 'data', 'inthe': 'token'}
</code></pre>
    <p class="normal">Adding that much extra data to each request can have consequences for the amount of network traffic generated, so the secret-based JWT technique is an option to keep in mind if you need to reduce the network overhead.</p>
    <h1 id="_idParaDest-125" class="title">The TokenDealer microservice</h1>
    <p class="normal">Our first step in <a id="_idIndexMarker444"/>building the authentication microservice will be to implement everything needed to perform a CCG flow. For that, the app receives requests from services that want a token and generates them on demand, assuming the request has a known secret in it. The generated tokens will have a lifespan of one day. This approach has the most flexibility, without the complexity of generating our own <code class="Code-In-Text--PACKT-">X.509</code> certificates, while allowing us to have one service responsible for generating the tokens.</p>
    <p class="normal">This service will be the only service to possess the private key that is used to sign the tokens, and will expose the public key for other services that want to verify tokens. This service will also be the only place where all the client IDs and secret keys are kept.</p>
    <p class="normal">We will greatly simplify the implementation by stating that once a service gets a token, it can access any other service in our ecosystem. When a service is accessed with a token, it can verify <a id="_idIndexMarker445"/>that token locally or call the TokenDealer to perform the verification. The choice between a network request and some CPU usage in the microservice will depend on what the application does and where its bottlenecks are. When balancing the security and performance requirements it might be necessary to validate the token, at most, once every few minutes, rather than every single time. This will cause a delay if the token needs to be invalidated, though, so we should consult the user stories and, if necessary, discuss the topic with the people who will be using the service to see which is most important.</p>
    <p class="normal">To implement everything we've described, three endpoints will be created in this microservice:</p>
    <ul>
      <li class="bullet"><code class="Code-In-Text--PACKT-">GET /.well-known/jwks.json</code>: This is the public key <a id="_idIndexMarker446"/>published in the <strong class="keyword">JSON Web Key</strong> (<strong class="keyword">JWK</strong>) format, as described in RFC 7517, when other microservices want to verify tokens on their own. For more information, see the following: <a href="https://tools.ietf.org/html/rfc7517"><span class="url">https://tools.ietf.org/html/rfc7517</span></a>.</li>
      <li class="bullet"><code class="Code-In-Text--PACKT-">POST /oauth/token</code>: This endpoint accepts a request with credentials and returns a token. Adding the <code class="Code-In-Text--PACKT-">/oauth</code> prefix is a widely adopted convention, since it is used in the OAuth RFC.</li>
      <li class="bullet"><code class="Code-In-Text--PACKT-">POST /verify_token</code>: This endpoint returns the token payload, given a token. If the token is not valid, it returns an HTTP 400 error code.</li>
    </ul>
    <p class="normal">Using the microservice skeleton, we can create a very simple Quart application that implements these three views. The skeleton is available at <a href="https://github.com/PacktPublishing/Python-Microservices-Development-2nd-Edition/"><span class="url">https://github.com/PacktPublishing/Python-Microservices-Development-2nd-Edition/</span></a>.</p>
    <p class="normal">Let's look at these three OAuth views.</p>
    <h2 id="_idParaDest-126" class="title">The OAuth implementation</h2>
    <p class="normal">For the CCG flow, the <a id="_idIndexMarker447"/>service that wants a token sends a <code class="Code-In-Text--PACKT-">POST</code> request with a URL-encoded body that contains the following fields:</p>
    <ul>
      <li class="bullet"><code class="Code-In-Text--PACKT-">client_id</code>: This is a unique string identifying the requester.</li>
      <li class="bullet"><code class="Code-In-Text--PACKT-">client_secret</code>: This is a secret key that authenticates the requester. It should be a random string generated upfront and registered with the auth service.</li>
      <li class="bullet"><code class="Code-In-Text--PACKT-">grant_type</code>: This is the grant type, which here must be <code class="Code-In-Text--PACKT-">client_credentials</code>.</li>
    </ul>
    <p class="normal">We'll make a few assumptions to simplify the implementation. Firstly, we will keep the list of secrets in a Python data structure, for demonstration purposes. In a production service, they should be encrypted at rest and kept in a resilient data store. We will also assume that <code class="Code-In-Text--PACKT-">client_id</code> is the name of the calling microservice, and for now we will generate secrets using <code class="Code-In-Text--PACKT-">binascii.hexlify(os.urandom(16))</code>.</p>
    <p class="normal">The first view will be the<a id="_idIndexMarker448"/> one that actually generates the tokens needed by the other services. In our example we are reading in the private key each time we create a token—this may be better stored in the application configuration for a real service, just to reduce the time spent waiting to read a file from the disk. We make sure the client has sent us a reasonable request, and that it wants some <code class="Code-In-Text--PACKT-">client_credentials</code>. The error handling functions and utilities are available in the full source code samples for this chapter.</p>
    <p class="normal">The token itself is a data structure with several fields: The issuer (<code class="Code-In-Text--PACKT-">iss</code>) of the token, commonly the URL of the service; the intended audience (<code class="Code-In-Text--PACKT-">aud</code>) for the token, that is, who the token is intended for; the time the token was issued (<code class="Code-In-Text--PACKT-">iat</code>); as well as its expiry (<code class="Code-In-Text--PACKT-">exp</code>) time. We then sign this data using the <code class="Code-In-Text--PACKT-">jwt.encode</code> method and return it to the requesting client:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">@app.route(</span><span class="hljs-string">"/oauth/token"</span><span class="hljs-params">, methods=[</span><span class="hljs-string">"POST"</span><span class="hljs-params">]</span><span class="hljs-meta">)</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title">create_token</span>():
    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(current_app.config[<span class="hljs-string">"PRIVATE_KEY_PATH"</span>]) <span class="hljs-keyword">as</span> f:
        key = f.read().strip()
    <span class="hljs-keyword">try</span>:
        data = <span class="hljs-keyword">await</span> request.form
        <span class="hljs-keyword">if</span> data.get(<span class="hljs-string">"grant_type"</span>) != <span class="hljs-string">"client_credentials"</span>:
            <span class="hljs-keyword">return</span> bad_request(<span class="hljs-string">f"Wrong grant_type </span><span class="hljs-subst">{data.get(</span><span class="hljs-string">'grant_type'</span><span class="hljs-subst">)}</span><span class="hljs-string">"</span>)
 
        client_id = data.get(<span class="hljs-string">"client_id"</span>)
        client_secret = data.get(<span class="hljs-string">"client_secret"</span>)
        aud = data.get(<span class="hljs-string">"audience"</span>, <span class="hljs-string">""</span>)
 
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> is_authorized_app(client_id, client_secret):
            <span class="hljs-keyword">return</span> abort(<span class="hljs-number">401</span>)
 
        now = <span class="hljs-built_in">int</span>(time.time())
 
        token = {
            <span class="hljs-string">"iss"</span>: current_app.config[<span class="hljs-string">"TOKENDEALER_URL"</span>],
            <span class="hljs-string">"aud"</span>: aud,
            <span class="hljs-string">"iat"</span>: now,
            <span class="hljs-string">"exp"</span>: now + <span class="hljs-number">3600</span> * <span class="hljs-number">24</span>,
        }
        token = jwt.encode(token, key, algorithm=<span class="hljs-string">"RS512"</span>)
        <span class="hljs-keyword">return</span> {<span class="hljs-string">"access_token"</span>: token}
    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:
        <span class="hljs-keyword">return</span> bad_request(<span class="hljs-string">"Unable to create a token"</span>) 
</code></pre>
    <p class="normal">The next view to add is a function that returns the public keys used by our token generation, so that any client can verify the tokens without making further HTTP requests. This is often located at a well-known URL—the address literally contains the string <code class="Code-In-Text--PACKT-">.well-known/</code>, which is a practice encouraged by the IETF to provide a way for a client to discover<a id="_idIndexMarker449"/> metadata about a service. Here we are responding with the JWKS. </p>
    <p class="normal">In the data returned are the key type (<code class="Code-In-Text--PACKT-">kty</code>), the algorithm (<code class="Code-In-Text--PACKT-">alg</code>), the public key use (<code class="Code-In-Text--PACKT-">use</code>)—here a signature—and two values used by the RSA algorithm that our cryptographic keys are generated with:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">@app.route(</span><span class="hljs-string">"/.well-known/jwks.json"</span><span class="hljs-meta">)</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title">_jwks</span>():
    <span class="hljs-string">"""Returns the public key in the Json Web Key Set (JWKS) format"""</span>
    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(current_app.config[<span class="hljs-string">"PUBLIC_KEY_PATH"</span>]) <span class="hljs-keyword">as</span> f:
        key = f.read().strip()
    data = {
        <span class="hljs-string">"alg"</span>: <span class="hljs-string">"RS512"</span>,
        <span class="hljs-string">"e"</span>: <span class="hljs-string">"AQAB"</span>,
        <span class="hljs-string">"n"</span>: key,
        <span class="hljs-string">"kty"</span>: <span class="hljs-string">"RSA"</span>,
        <span class="hljs-string">"use"</span>: <span class="hljs-string">"sig"</span>,
    }
 
    <span class="hljs-keyword">return</span> jsonify({<span class="hljs-string">"keys"</span>: [data]})
</code></pre>
    <p class="normal">The final view lets clients verify a token without doing the work themselves. Much more straightforward than the token generation, we simply extract the right fields from the input data and call the <code class="Code-In-Text--PACKT-">jwt.decode</code> function to provide the values. Note that this function verifies the token is valid, but not that the token allows any particular access — that part is up to the service that has been presented with the token:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">@app.route(</span><span class="hljs-string">"/verify_token"</span><span class="hljs-params">, methods=[</span><span class="hljs-string">"POST"</span><span class="hljs-params">]</span><span class="hljs-meta">)</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title">verify_token</span>():
    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(current_app.config[<span class="hljs-string">"PUBLIC_KEY_PATH"</span>]) <span class="hljs-keyword">as</span> f:
        key = f.read()
    <span class="hljs-keyword">try</span>:
        input_data = <span class="hljs-keyword">await</span> request.form
        token = input_data[<span class="hljs-string">"access_token"</span>]
        audience = input_data.get(<span class="hljs-string">"audience"</span>, <span class="hljs-string">""</span>)
        <span class="hljs-keyword">return</span> jwt.decode(token, key, algorithms=[<span class="hljs-string">"RS512"</span>], audience=audience)
    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:
        <span class="hljs-keyword">return</span> bad_request(<span class="hljs-string">"Unable to verify the token"</span>) 
</code></pre>
    <p class="normal">The whole source code of the TokenDealer microservice can be found on GitHub: <a href="https://github.com/PacktPublishing/Python-Microservices-Development-2nd-Edition"><span class="url">https://github.com/PacktPublishing/Python-Microservices-Development-2nd-Edition</span></a>.</p>
    <p class="normal">The microservice<a id="_idIndexMarker450"/> could offer more features around token generation. For instance, the ability to manage scopes and make sure microservice A is not allowed to generate a token that can be used in microservice B, or managing a whitelist of services that are authorized to ask for some tokens. A client could also request a token that is intended for read-only use. Despite this, however, the pattern we have implemented is the basis for a simple token-based authentication system in a microservice environment that you can develop on your own, while also being good enough for our Jeeves app.</p>
    <p class="normal">Looking back at our example microservice, TokenDealer now sits as a separate microservice in the ecosystem, creating and verifying keys that allow access to our data service, and authorizing access to the third-party tokens and API keys we need to query other sites:</p>
    <figure class="mediaobject"><img src="../Images/B17108_07_02.png" alt=""/></figure>
    <p class="packt_figref">Figure 7.2: The microservice ecosystem with the CCG TokenDealer</p>
    <p class="normal">Those services that<a id="_idIndexMarker451"/> require a JWT may validate it by calling the TokenDealer microservice. The Quart app in <em class="italic">Figure 7.2</em> needs to obtain tokens from TokenDealer on behalf of its users.</p>
    <p class="normal">Now that we have a TokenDealer service that implements CCG, let us see how it can be used by our services in the next section.</p>
    <h2 id="_idParaDest-127" class="title">Using TokenDealer</h2>
    <p class="normal">In Jeeves, the <strong class="screenText">Data Service</strong> is a <a id="_idIndexMarker452"/>good example of a <a id="_idIndexMarker453"/>place where authentication is required. Adding information via the <strong class="screenText">Data Service</strong> needs to be restricted to authorized services:</p>
    <figure class="mediaobject"><img src="../Images/B17108_07_03.png" alt="image1.png"/></figure>
    <p class="packt_figref">Figure 7.3: Requesting a CCG workflow</p>
    <p class="normal">Adding authentication for<a id="_idIndexMarker454"/> that link is done in four steps:</p>
    <ol>
      <li class="numbered"><strong class="screenText">TokenDealer</strong> manages a <code class="Code-In-Text--PACKT-">client_id</code> and <code class="Code-In-Text--PACKT-">client_secret</code> pair for the Strava worker and shares it with the Strava worker developers</li>
      <li class="numbered">The Strava worker uses <code class="Code-In-Text--PACKT-">client_id</code> and <code class="Code-In-Text--PACKT-">client_secret</code> to retrieve a token from <strong class="screenText">TokenDealer</strong></li>
      <li class="numbered">The worker adds the token to the header for each request to the <strong class="screenText">Data Service</strong></li>
      <li class="numbered">The <strong class="screenText">Data Service</strong> verifies the token by calling the verification API of <strong class="screenText">TokenDealer</strong> or by performing a local <strong class="screenText">JWT</strong> verification</li>
    </ol>
    <p class="normal">In a <a id="_idIndexMarker455"/>full implementation, the first step can be partially automated. Generating a client secret is usually done through a web administration panel in the authentication service. That secret is then provided to the client microservice developers. Each microservice that requires a token can now get one, whether it is the first time connecting, or because the tokens it has already obtained have expired. All they need to do to use it is add that token to the Authorization header when calling the Data Service.</p>
    <p class="normal">The following is an example of such a call using the <code class="Code-In-Text--PACKT-">requests</code> library—assuming our TokenDealer is already running on <code class="Code-In-Text--PACKT-">localhost:5000</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># fetch_token.py</span>
<span class="hljs-keyword">import</span> requests
TOKENDEALER_SERVER = <span class="hljs-string">"http://localhost:5000"</span>
SECRET = <span class="hljs-string">"f0fdeb1f1584fd5431c4250b2e859457"</span>
<span class="hljs-keyword">def</span> <span class="hljs-title">get_token</span>():
    data = {
        <span class="hljs-string">"client_id"</span>: <span class="hljs-string">"worker1"</span>,
        <span class="hljs-string">"client_secret"</span>: secret,
        <span class="hljs-string">"audience"</span>: <span class="hljs-string">"jeeves.domain"</span>,
        <span class="hljs-string">"grant_type"</span>: <span class="hljs-string">"client_credentials"</span>,
    }
    headers = {<span class="hljs-string">"Content-Type"</span>: <span class="hljs-string">"application/x-www-form-urlencoded"</span>}
    url = tokendealer_server + <span class="hljs-string">"/oauth/token"</span>
    response = requests.post(url, data=data, headers=headers)
    <span class="hljs-keyword">return</span> response.json()[<span class="hljs-string">"access_token"</span>]
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">get_token()</code> function<a id="_idIndexMarker456"/> retrieves a token that can then be used in the Authorization header when the code calls the Data Service, which we assume is listening on port <code class="Code-In-Text--PACKT-">5001</code> for this example:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># auth_caller.py</span>
_TOKEN = <span class="hljs-literal">None</span>
<span class="hljs-keyword">def</span> <span class="hljs-title">get_auth_header</span>(<span class="hljs-params">new=</span><span class="hljs-literal">False</span>):
    <span class="hljs-keyword">global</span> _TOKEN
    <span class="hljs-keyword">if</span> _TOKEN <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">or</span> new:
        _TOKEN = get_token()
    <span class="hljs-keyword">return</span> <span class="hljs-string">"Bearer "</span> + _TOKEN
_dataservice = <span class="hljs-string">"http://localhost:5001"</span>
<span class="hljs-keyword">def</span> <span class="hljs-title">_call_service</span>(<span class="hljs-params">endpoint, token</span>):
    <span class="hljs-comment"># not using session and other tools, to simplify the code</span>
    url = _dataservice + <span class="hljs-string">"/"</span> + endpoint
    headers = {<span class="hljs-string">"Authorization"</span>: token}
    <span class="hljs-keyword">return</span> requests.get(url, headers=headers)
<span class="hljs-keyword">def</span> <span class="hljs-title">call_data_service</span>(<span class="hljs-params">endpoint</span>):
    token = get_auth_header()
    response = _call_service(endpoint, token)
    <span class="hljs-keyword">if</span> response.status_code == <span class="hljs-number">401</span>:
        <span class="hljs-comment"># the token might be revoked, let's try with a fresh one</span>
        token = get_auth_header(new=<span class="hljs-literal">True</span>)
        response = _call_service(endpoint, token)
    <span class="hljs-keyword">return</span> response
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">call_data_service()</code> function will try to get a new token if the call to the Data Service leads to a 401 response. This refresh-token-on-401 pattern can be used in all your microservices to automate token generation.</p>
    <p class="normal">This covers service-to-service authentication. You can find the full implementation in the example GitHub repository to play with this JWT-based authentication scheme and use it as a basis for building your authentication process.</p>
    <p class="normal">The next section looks<a id="_idIndexMarker457"/> at another important aspect of securing your web services, and that is securing the code itself.</p>
    <h1 id="_idParaDest-128" class="title">Securing your code</h1>
    <p class="normal">Whatever we do, an<a id="_idIndexMarker458"/> application must receive data and act on it, somehow, or it will not be very useful. If a service receives data, then as soon as you expose your <a id="_idIndexMarker459"/>app to the world, it is open to numerous possible types of attack, and your code needs to be designed with this in mind.</p>
    <p class="normal">Anything that is published to the web can be attacked, although we have the advantage that most microservices are not exposed to the public internet, which reduces the possible ways they could be exploited. The expected inputs and outputs of the system are narrower, and often better defined using specification tools, such as OpenAPI.</p>
    <p class="normal">Attacks are not always due to hostile intent, either. If the caller has a bug or is just not calling your service correctly, the expected behavior should be to send back a <code class="Code-In-Text--PACKT-">4xx</code> response and explain to the client why the request was rejected.</p>
    <p class="normal">The <strong class="keyword">Open Web Application Security Project</strong> (<strong class="keyword">OWASP</strong>) (<a href="https://www.owasp.org"><span class="url">https://www.owasp.org</span></a>) is an excellent resource to learn about<a id="_idIndexMarker460"/> ways to protect your web apps from bad behaviors. Let's look at some of the most common forms of attack:</p>
    <ul>
      <li class="bullet"><strong class="keyword">Injection</strong>: In an application<a id="_idIndexMarker461"/> that receives data, an attacker sends SQL statements, shell commands, or some other instructions inside the request. If your application is not careful about how it uses that data, you can end up running code that is meant to damage your application. In Python, SQL injection attacks can be avoided by using SQLAlchemy, which constructs the SQL statements for you in a safe way. If you do use SQL directly, or provide arguments to shell scripts, LDAP servers, or some other structured query, you must make sure that every variable is quoted correctly.</li>
      <li class="bullet"><strong class="keyword">Cross-Site Scripting</strong> (<strong class="keyword">XSS</strong>): This attack happens only on web pages that display some HTML. The attacker uses <a id="_idIndexMarker462"/>some of the query attributes to try to inject their piece of HTML on the page to trick the user into performing some set of actions, thinking they are on the legitimate website.</li>
      <li class="bullet"><strong class="keyword">Cross-Site Request Forgery</strong> (<strong class="keyword">XSRF</strong>/<strong class="keyword">CSRF</strong>): This attack is based on attacking a service by reusing the <a id="_idIndexMarker463"/>user's credentials from another website. The typical CSRF attack happens with <code class="Code-In-Text--PACKT-">POST</code> requests. For instance, a malicious website displays a link to a user to trick that user into performing the <code class="Code-In-Text--PACKT-">POST</code> request on your site using their existing credentials.</li>
    </ul>
    <p class="normal">Things such <a id="_idIndexMarker464"/>as <strong class="keyword">Local File Inclusion</strong> (<strong class="keyword">LFI</strong>), <strong class="keyword">Remote File Inclusion</strong> (<strong class="keyword">RFI</strong>), or <strong class="keyword">Remote Code Execution</strong> (<strong class="keyword">RCE</strong>) are all attacks that trick the server into executing something via client input, or <a id="_idIndexMarker465"/>revealing server files. They <a id="_idIndexMarker466"/>can happen of course in applications written in most languages and toolkits, but we will examine some <a id="_idIndexMarker467"/>of Python's tools to protect against these attacks.</p>
    <p class="normal">The idea behind secure code is simple, yet hard to do well in practice. The two fundamental principles are:</p>
    <ul>
      <li class="bullet">Every request from the outside world should be carefully assessed before it does something in your application and data.</li>
      <li class="bullet">Everything your application is doing on a system should have a well-defined and limited scope.</li>
    </ul>
    <p class="normal">Let's look at how to implement these principles in practice.</p>
    <h2 id="_idParaDest-129" class="title">Limiting your application scope</h2>
    <p class="normal">Even if you trust the <a id="_idIndexMarker468"/>authentication system, you should make sure that whoever connects has the minimum level of access required to perform their work. If there is a client that connects to your microservice and can authenticate themselves, that doesn't mean they should be allowed to perform any action. If they only need read-only access, then that's all they should be granted.</p>
    <p class="normal">This isn't just protecting against malicious code, but also bugs and accidents. Any time you think, "the client should never call this endpoint," then there should be something in place that actively prevents the client using it.</p>
    <p class="normal">That scope limitation can be done with JWTs by defining roles (such as read/write) and adding that information in the token under a permissions or scope key, for example. The target microservice will then be able to reject a call on a <code class="Code-In-Text--PACKT-">POST</code> that is made with a token that is supposed to only read data.</p>
    <p class="normal">This is what happens when you grant access to an application on your GitHub account, or on your Android phone. A detailed list of what the app wants to do is displayed, and you can grant or reject access.</p>
    <p class="normal">This is in addition to network-level controls and firewalls. If you are controlling all parts of your microservices ecosystem, you can also use strict firewall rules at the system level to whitelist the IPs that are allowed to interact with each microservice, but that kind of setup greatly depends on where you are deploying your application. In the <strong class="keyword">Amazon Web Services</strong> (<strong class="keyword">AWS</strong>) cloud environment, you<a id="_idIndexMarker469"/> don't need to configure a Linux firewall; all you have to do is set up the access rules in the AWS Console. <em class="chapterRef">Chapter 10</em>, <em class="italic">Deploying on AWS</em>, covers the basics of deploying your microservices on the Amazon cloud.</p>
    <p class="normal">Besides network access, any <a id="_idIndexMarker470"/>other resource your application can access should be limited whenever possible. Running the application as a root user on Linux is not a good idea because if your application has full administrative privileges, then so does an attacker who successfully breaks in.</p>
    <p class="normal">In essence, if a layer of security fails, there should be another behind it. If an application's web server is successfully attacked, any attacker should ideally be as limited as possible in what they can do, as they only have access to the well-defined interfaces between the services in the application—instead of full administrative control over the computer running the code. Root access to a system has become an indirect threat in modern deployments, since most applications are running in containers or a <strong class="keyword">Virtual Machine</strong> (<strong class="keyword">VM</strong>), but a <a id="_idIndexMarker471"/>process can still do a lot of damage even if its abilities are limited by the VM it is running in. If an attacker gains access to one of your VMs, they have achieved the first step in getting control over the whole system. To mitigate the problem, there are two rules you should follow:</p>
    <ol>
      <li class="numbered" value="1">All software should run with the smallest set of permissions possible</li>
      <li class="numbered">Be very cautious when executing processes from your web service, and avoid it if you can</li>
    </ol>
    <p class="normal">For the first rule, the default behavior for web servers such as <code class="Code-In-Text--PACKT-">nginx</code> is to run its processes using the <code class="Code-In-Text--PACKT-">www-data</code> user and group, so that standard user controls prevent the server accessing other files, and the account itself can be set up to not be allowed to run a shell or any other interactive commands. The same rules apply to your Quart processes. We will see in <em class="chapterRef">Chapter 9</em>, <em class="italic">Packaging and Running Python</em>, the best practices to run a stack in the user space on a Linux system.</p>
    <p class="normal">For the second rule, any Python call to <code class="Code-In-Text--PACKT-">os.system()</code> should be avoided unless absolutely necessary, as it creates a new user shell on the computer, adding risks associated with badly formed commands being run, and increasing the risk of uncontrolled access to the system. The <code class="Code-In-Text--PACKT-">subprocess</code> module<a id="_idIndexMarker472"/> is better, although it, too, must be used carefully to avoid unwanted side effects—avoid using the <code class="Code-In-Text--PACKT-">shell=True</code> argument, which will result in the same trouble as <code class="Code-In-Text--PACKT-">os.system()</code>, and avoid using input data as arguments and commands. This is also true for high-level network modules that send emails or connect to third-party servers via FTP, via the local system.</p>
    <h2 id="_idParaDest-130" class="title">Untrusted incoming data</h2>
    <p class="normal">The majority of applications accept<a id="_idIndexMarker473"/> data as input: whose account to look up; which city to fetch a weather report for; which account to transfer money into, and so forth. The trouble is that data that comes from outside our system is not easily trusted.</p>
    <p class="normal">Earlier, we discussed SQL injection attacks; let us now consider a very naive example, where we use a SQL query to look up a user. We have a function that treats the query as a string to be formatted, and fills it in using standard Python syntax:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> pymysql 
connection = pymysql.connect(host=<span class="hljs-string">'localhost'</span>, db=<span class="hljs-string">'book'</span>) 
<span class="hljs-keyword">def</span> <span class="hljs-title">get_user</span>(<span class="hljs-params">user_id</span>): 
    query = <span class="hljs-string">f"select * from user where id = </span><span class="hljs-subst">{user_id}</span><span class="hljs-string">"</span>
        <span class="hljs-keyword">with</span> connection.cursor() <span class="hljs-keyword">as</span> cursor: 
        cursor.execute(query) 
        result = cursor.fetchone() 
        <span class="hljs-keyword">return</span> result
</code></pre>
    <p class="normal">This looks fine when the <code class="Code-In-Text--PACKT-">user_id</code> is always a sensible value. However, what if someone presents a carefully crafted malicious value? If we allow people to enter data for <code class="Code-In-Text--PACKT-">get_user()</code>, above, and instead of entering a number as a <code class="Code-In-Text--PACKT-">user_id</code>, they enter:</p>
    <pre class="programlisting code"><code class="hljs-code">'1'; insert into user(id, firstname, lastname, password) values (999, 'pwnd', 'yup', 'somehashedpassword')
</code></pre>
    <p class="normal">Now our SQL statement is really two statements:</p>
    <pre class="programlisting code"><code class="hljs-code">select * from user where id = '1'
insert into user(id, firstname, lastname, password) values (999, 'pwnd', 'yup', 'somehashedpassword')
</code></pre>
    <p class="normal"><code class="Code-In-Text--PACKT-">get_user</code> will perform the expected query, and a second query that will add a new user! It could also delete a table, or perform any other action available to SQL statements. Some damage limitation is there if the authenticated client has limited permissions, but a large amount of data<a id="_idIndexMarker474"/> could still be exposed. This scenario can be prevented by quoting any value used to build raw SQL queries. In <code class="Code-In-Text--PACKT-">PyMySQL</code>, you just need to pass the values as parameters to the <code class="Code-In-Text--PACKT-">execute</code> argument to avoid this problem:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span> <span class="hljs-title">get_user</span>(<span class="hljs-params">user_id</span>): 
    query = <span class="hljs-string">'select * from user where id = %s'</span> 
        <span class="hljs-keyword">with</span> connection.cursor() <span class="hljs-keyword">as</span> cursor: 
        cursor.execute(query, (user_id,)) 
        result = cursor.fetchone() 
        <span class="hljs-keyword">return</span> result 
</code></pre>
    <p class="normal">Every database library has this feature, so as long as you are correctly using these libraries when building raw SQL, you should be fine. Better still is to avoid using raw SQL completely, and instead use a database model through SQLAlchemy.</p>
    <p class="normal">If you have a view that grabs JSON data from the incoming request and uses it to push data to a database, you should verify that the incoming request has the data you are expecting, and not blindly pass it over to your database backend. That's why it can be interesting to use Swagger to describe your data as schemas, and use them to validate incoming data. Microservices usually use JSON, but if you happen to use templates to provide formatted output, that's yet another place where you need to be careful with respect to what the template is doing with variables.</p>
    <p class="normal"><strong class="keyword">Server-Side Template Injection</strong> (<strong class="keyword">SSTI</strong>) is a possible attack in which your templates blindly execute Python statements. In 2016, such an <a id="_idIndexMarker475"/>injection vulnerability was found on Uber's website on a Jinja2 template, because raw formatting was done before the template was executed. See more at <a href="https://hackerone.com/reports/125980"><span class="url">https://hackerone.com/reports/125980</span></a>.</p>
    <p class="normal">The code was something similar to this small app:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">from</span> quart <span class="hljs-keyword">import</span> Quart, request, render_template_string
app = Quart(__name__)
SECRET = <span class="hljs-string">"oh no!"</span>
_TEMPLATE = <span class="hljs-string">"""</span>
<span class="hljs-string">    Hello %s</span>
<span class="hljs-string">    Welcome to my API!</span>
<span class="hljs-string">    """</span>
<span class="hljs-keyword">class</span> <span class="hljs-title">Extra</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, data</span>):
    self.data = data
<span class="hljs-meta">@app.route(</span><span class="hljs-string">"/"</span><span class="hljs-meta">)</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title">my_microservice</span>():
    user_id = request.args.get(<span class="hljs-string">"user_id"</span>, <span class="hljs-string">"Anonymous"</span>)
    tmpl = _TEMPLATE % user_id
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> render_template_string(tmpl, extra=Extra(<span class="hljs-string">"something"</span>))
app.run()
</code></pre>
    <p class="normal">By doing this preformatting on the template with a raw <code class="Code-In-Text--PACKT-">%</code> formatting syntax, the view creates a huge security hole in the app, since it allows attackers to inject what they want into the Jinja script before it is executed. In the following example, the <code class="Code-In-Text--PACKT-">user_id</code> variable security hole is exploited to read the value of the <code class="Code-In-Text--PACKT-">SECRET</code> global variable from the module:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"># </span><span class="language-bash">Here we URL encode the following:</span>
<span class="hljs-con-meta"># </span><span class="language-bash">http://localhost:5000/?user_id={{extra.__class__.__init__.__globals__[</span>"SECRET"<span class="language-bash">]}}</span> 
<span class="hljs-con-meta">$ </span><span class="language-bash">curl http://localhost:5000/?user_id=%7B%7Bextra.__class__.__init__.__globals__%5B%22SECRET%22%5D%7D%7D</span>
Hello oh no!
Welcome to my API!
</code></pre>
    <p class="normal">That's why it is important to <a id="_idIndexMarker476"/>avoid string formatting with input data unless there is a template engine or some other layer that provides protection.</p>
    <p class="normal">If you need to evaluate untrusted code in a template, you can use Jinja's sandbox; refer to <a href="http://jinja.pocoo.org/docs/latest/sandbox/"><span class="url">http://jinja.pocoo.org/docs/latest/sandbox/</span></a>. This sandbox will reject any access to methods and attributes from the object being evaluated. For instance, if you're passing a callable<a id="_idIndexMarker477"/> in your template, you will be sure that its attributes, such as <code class="Code-In-Text--PACKT-">;__class__</code>, cannot be used.</p>
    <p class="normal">That said, Python sandboxes are tricky to get right due to the nature of the language. It's easy to misconfigure a sandbox, and the sandbox itself can be compromised with a new version of the language. The <a id="_idIndexMarker478"/>safest bet is to avoid evaluating untrusted code altogether and make sure you're not directly relying on incoming data for templates.</p>
    <h2 id="_idParaDest-131" class="title">Redirecting and trusting queries</h2>
    <p class="normal">The same <a id="_idIndexMarker479"/>precaution applies when dealing with redirects. One common mistake is to<a id="_idIndexMarker480"/> create a login view that makes the assumption that the caller will be redirected to an internal page and use a plain URL for that redirect:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">@app.route(</span><span class="hljs-string">'/login'</span><span class="hljs-meta">) </span>
<span class="hljs-keyword">def</span> <span class="hljs-title">login</span>(): 
    from_url = request.args.get(<span class="hljs-string">'from_url'</span>, <span class="hljs-string">'/'</span>) 
    <span class="hljs-comment"># do some authentication </span>
    <span class="hljs-keyword">return</span> redirect(from_url) 
</code></pre>
    <p class="normal">This view can redirect the caller to any website, which is a significant threat—particularly during the login process. Good practice involves avoiding free strings when calling <code class="Code-In-Text--PACKT-">redirect()</code>, by using the <code class="Code-In-Text--PACKT-">url_for()</code> function, which will create a link to your app domain. If you need to redirect to third parties, you cannot use the <code class="Code-In-Text--PACKT-">url_for()</code> and <code class="Code-In-Text--PACKT-">redirect()</code> functions, as they can potentially send your clients to unwanted places.</p>
    <p class="normal">One solution is to create a restricted list of third-party domains that your application is allowed to redirect to and make sure any redirection done by your application or underlying third-party libraries is checked against that list.</p>
    <p class="normal">This can be done with the <code class="Code-In-Text--PACKT-">after_request()</code> hook that will be called after our views have generated a response, but before Quart has sent it back to the client. If the application tries to send back a <code class="Code-In-Text--PACKT-">302</code>, you can check that its location is safe, given a list of domains and ports:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># quart_after_response.py</span>
<span class="hljs-keyword">from</span> quart <span class="hljs-keyword">import</span> Quart, redirect
<span class="hljs-keyword">from</span> quart.helpers <span class="hljs-keyword">import</span> make_response
<span class="hljs-keyword">from</span> urllib.parse <span class="hljs-keyword">import</span> urlparse
app = Quart(__name__)
<span class="hljs-meta">@app.route(</span><span class="hljs-string">"/api"</span><span class="hljs-meta">)</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title">my_microservice</span>():
    <span class="hljs-keyword">return</span> redirect(<span class="hljs-string">"https://github.com:443/"</span>)
<span class="hljs-comment"># domain:port</span>
SAFE_DOMAINS = [<span class="hljs-string">"github.com:443"</span>, <span class="hljs-string">"google.com:443"</span>]
<span class="hljs-meta">@app.after_request</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title">check_redirect</span>(<span class="hljs-params">response</span>):
    <span class="hljs-keyword">if</span> response.status_code != <span class="hljs-number">302</span>:
        <span class="hljs-keyword">return</span> response
    url = urlparse(response.location)
    netloc = url.netloc
    <span class="hljs-keyword">if</span> netloc <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> SAFE_DOMAINS:
        <span class="hljs-comment"># not using abort() here or it'll break the hook</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> make_response(<span class="hljs-string">"Forbidden"</span>, <span class="hljs-number">403</span>)
    <span class="hljs-keyword">return</span> response
<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">"__main__"</span>:
    app.run(debug=<span class="hljs-literal">True</span>)
</code></pre>
    <h2 id="_idParaDest-132" class="title">Sanitizing input data</h2>
    <p class="normal">In addition to the <a id="_idIndexMarker481"/>other practices for handling untrusted data, we can ensure the fields themselves match what we expect. Faced with the examples above, it is tempting to think that we should filter out any semicolons, or perhaps all the curly braces, but this leaves us in the position of having to think of all the ways in which the data could be malformed, and trying to outwit the inventiveness of both malicious programmers and also random bugs.</p>
    <p class="normal">Instead, we should concentrate on what we know about what our data should look like—instead of what it should not. This is a much narrower question, and the answer can often be much easier to define. As an example, if we know that an endpoint accepts an ISBN to look up a book, then we know that we should only expect a series of numbers either 10 or 13 digits long, perhaps with dashes as separators. When it comes to people, however, data is much harder to clean up.</p>
    <p class="normal">There are several fantastic lists of falsehoods that programmers believe about various topics at <a href="https://github.com/kdeldycke/awesome-falsehood"><span class="url">https://github.com/kdeldycke/awesome-falsehood</span></a>. These lists are not meant to be exhaustive or authoritative, but they are helpful in reminding us that we may have false notions about how human information works. Human names, postal addresses, phone numbers: we should not make assumptions about what any of this data looks like, how many lines it has, or what order the elements are in. The best we can do is ensure that the human entering the information has the best chance to check that it is all correct, and then use the quoting and sandboxing techniques described earlier to avoid any incidents.</p>
    <p class="normal">Even an email address is extremely complicated to validate. The permitted format has a lot of different parts to it, and not all of them are supported by every email system. An oft-quoted saying is that the best way to validate an email address is to try sending it an email, and this validation method is used by both legitimate websites—sending an email and informing you that they "have sent an email to confirm your account"—and by spammers who send nonsensical messages to millions of addresses and record which ones don't return an error.</p>
    <p class="normal">To summarize, you <a id="_idIndexMarker482"/>should always treat incoming data as a potential threat, as a source of attacks to be injected into your system. Escape or remove any special characters, avoid using the data directly in database queries or templates without a layer of isolation between them, and ensure your data looks as you would expect it to.</p>
    <p class="normal">There is also a way to continuously check your code for potential security issues using the Bandit linter, explored in the next section.</p>
    <h2 id="_idParaDest-133" class="title">Using Bandit linter</h2>
    <p class="normal">Managed by the Python Code Quality Authority, Bandit (<a href="https://github.com/PyCQA/bandit"><span class="url">https://github.com/PyCQA/bandit</span></a>) is another tool to scan your source code for potential security risks. It can <a id="_idIndexMarker483"/>be run in CI systems for the automatic testing of any changes before they get deployed. The tool uses the <code class="Code-In-Text--PACKT-">ast</code> module to parse the code in the same way that <code class="Code-In-Text--PACKT-">flake8</code> and <code class="Code-In-Text--PACKT-">pylint</code> do. Bandit will also scan for some known security issues in your code. Once you have installed it with the <code class="Code-In-Text--PACKT-">pip install bandit</code> command, you can run it against your Python module using the <code class="Code-In-Text--PACKT-">bandit</code> command.</p>
    <p class="normal">Adding Bandit to your continuous integration pipeline alongside other checks, as described in <em class="chapterRef">Chapter 3</em>, <em class="italic">Coding, Testing, and Documentation: the Virtuous Cycle</em>, is a good way to catch potential security issues in your code.</p>
    <h2 id="_idParaDest-134" class="title">Dependencies</h2>
    <p class="normal">Most projects will use other <a id="_idIndexMarker484"/>libraries, as programmers build on the work of others, and oftentimes there is not enough time to keep a close eye on how those other projects are doing. If there's a security vulnerability in one of our dependencies, we want to know about it quickly so that we can update our own software, without manually checking.</p>
    <p class="normal">Dependabot (<a href="https://dependabot.com/"><span class="url">https://dependabot.com/</span></a>) is a tool that will <a id="_idIndexMarker485"/>perform security sweeps of your project's dependencies. Dependabot is a built-in component of GitHub, and its reports should be visible in your project's <strong class="keyword">Security</strong> tab. Turning on some extra features in the project's <strong class="keyword">Settings</strong> page allows Dependabot to automatically create pull requests with any changes that need making to remain secure.</p>
    <p class="normal">PyUp has a similar set of<a id="_idIndexMarker486"/> features but requires manually setting up—as does Dependabot if you're not using GitHub.</p>
    <h1 id="_idParaDest-135" class="title">Web application firewall</h1>
    <p class="normal">Even with the safest handling<a id="_idIndexMarker487"/> of data, our application can still be vulnerable to attack. When you're exposing HTTP endpoints to the world, this is always a risk. You will be hoping for callers to behave as intended, with each HTTP conversation following a scenario that you have programmed in the service.</p>
    <p class="normal">A client can send legitimate requests and just hammer your service with it, leading to a <strong class="keyword">Denial of Service</strong> (<strong class="keyword">DoS</strong>) due to all the<a id="_idIndexMarker488"/> resources then being used to handle requests from the attacker. When many hundreds or thousands of clients are used to do this, it's <a id="_idIndexMarker489"/>known as a <strong class="keyword">Distributed Denial of Service</strong> (<strong class="keyword">DDoS</strong>) attack. This problem sometimes occurs within distributed systems when clients have replay features that are automatically recalling the same API. If nothing is done on the client side to throttle calls, you might end up with a service overloaded by legitimate clients.</p>
    <p class="normal">Adding protection on the server side to make such zealous clients back off is usually not hard to do, and goes a long way to protect your microservice stack. Some cloud providers also supply protection against DDoS attacks and a lot of the features mentioned here.</p>
    <p class="normal">OWASP, mentioned earlier in this chapter, provides a set of rules for the <code class="Code-In-Text--PACKT-">ModSecurity</code> toolkit's WAF that can be used to avoid many types of attacks: <a href="https://github.com/coreruleset/coreruleset/"><span class="url">https://github.com/coreruleset/coreruleset/</span></a>.</p>
    <p class="normal">In this section, we will focus on creating a basic WAF that will explicitly reject a client that's making too many requests on our service. The intention of this section is not to create a full WAF, but rather to give you a good understanding of how WAFs are implemented and used. We could build our WAF in a Python microservice, but it would add a lot of overhead if all the traffic has to go through it. A much better solution is to rely directly on the web server.</p>
    <h2 id="_idParaDest-136" class="title">OpenResty: Lua and nginx</h2>
    <p class="normal">OpenResty (<a href="http://openresty.org/en/"><span class="url">http://openresty.org/en/</span></a>) is an <code class="Code-In-Text--PACKT-">nginx</code><a id="_idIndexMarker490"/> distribution that embeds a Lua (<a href="http://www.lua.org/"><span class="url">http://www.lua.org/</span></a>) interpreter that <a id="_idIndexMarker491"/>can be used to script the web server. We can then use <a id="_idIndexMarker492"/>scripts to apply rules and filters to the traffic.</p>
    <p class="normal">Lua is an excellent, dynamically typed programming language that has a lightweight and fast interpreter. The language offers a complete set of features and has built-in async features. You can write coroutines directly in vanilla Lua.</p>
    <p class="normal">If you install<a id="_idIndexMarker493"/> Lua (refer to <a href="http://www.lua.org/start.html"><span class="url">http://www.lua.org/start.html</span></a>), you can play with the language<a id="_idIndexMarker494"/> using the Lua <strong class="keyword">Read-Eval-Print Loop</strong> (<strong class="keyword">REPL</strong>), exactly as you would with Python:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span><span class="language-bash">lua</span> 
Lua 5.4.2  Copyright (C) 1994-2020 Lua.org, PUC-Rio
<span class="hljs-con-meta">&gt; </span><span class="language-bash">io.write(</span><span class="hljs-con-string">"Hello world\n"</span><span class="language-bash">)</span>
Hello world
file (0x7f5a66f316a0)
<span class="hljs-con-meta">&gt; </span><span class="language-bash">mytable = {}</span>
<span class="hljs-con-meta">&gt; </span><span class="language-bash">mytable[</span><span class="hljs-con-string">"user"</span><span class="language-bash">] = </span><span class="hljs-con-string">"simon"</span>
<span class="hljs-con-meta">&gt; </span><span class="language-bash">= mytable[</span><span class="hljs-con-string">"user"</span><span class="language-bash">]</span>
simon
<span class="hljs-con-meta">&gt; </span><span class="language-bash">= string.upper(mytable[</span><span class="hljs-con-string">"user"</span><span class="language-bash">])</span>
SIMON
<span class="hljs-con-meta">&gt;</span>
</code></pre>
    <p class="normal">To discover the Lua language, this is your starting page: <a href="http://www.lua.org/docs.html"><span class="url">http://www.lua.org/docs.html</span></a>.</p>
    <p class="normal">Lua is often the language of choice to be embedded in compiled apps. Its memory footprint is ridiculously small, and it allows for fast dynamic scripting features—this is what is happening in <code class="Code-In-Text--PACKT-">OpenResty</code>. Instead of building <code class="Code-In-Text--PACKT-">nginx</code> modules you can extend the web server using Lua scripts and deploy them directly with OpenResty.</p>
    <p class="normal">When you invoke some Lua code<a id="_idIndexMarker495"/> from your <code class="Code-In-Text--PACKT-">nginx</code> configuration, the <code class="Code-In-Text--PACKT-">LuaJIT</code> (<a href="http://luajit.org/"><span class="url">http://luajit.org/</span></a>) interpreter that's employed by OpenResty will run them, running at the same speed as the <code class="Code-In-Text--PACKT-">nginx</code> code itself. Some performance benchmarks find that Lua can be faster than C or C++ in some cases; refer to: <a href="http://luajit.org/performance.html"><span class="url">http://luajit.org/performance.html</span></a>.</p>
    <p class="normal">Lua functions are coroutines, and so will run asynchronously in <code class="Code-In-Text--PACKT-">nginx</code>. This leads to a low overhead even when your server receives a lot of concurrent requests, which is exactly what is needed for a WAF.</p>
    <p class="normal">OpenResty comes as a<a id="_idIndexMarker496"/> Docker image and a package for some Linux distributions. It can also be compiled from the source code if needed; refer to <a href="http://openresty.org/en/installation.html"><span class="url">http://openresty.org/en/installation.html</span></a>.</p>
    <p class="normal">On macOS, you can use <code class="Code-In-Text--PACKT-">Brew</code> and the <code class="Code-In-Text--PACKT-">brew install openresty</code> command.</p>
    <p class="normal">Once OpenResty is installed, you will get an <code class="Code-In-Text--PACKT-">openresty</code> command, which can be used exactly like <code class="Code-In-Text--PACKT-">nginx</code> to serve your applications. In the following example, the <code class="Code-In-Text--PACKT-">nginx</code> configuration will proxy requests to a Quart application running on port <code class="Code-In-Text--PACKT-">5000</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># resty.conf</span>
daemon off;
worker_processes  1;
error_log /dev/stdout info;
events {
worker_connections  1024;
}
http {
  access_log /dev/stdout;
  server {
    listen   8888;
    server_name  localhost;
    location / {
      proxy_pass http://localhost:5000;
      proxy_set_header Host $host;
      proxy_set_header X-Real-IP $remote_addr;
      proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    }
   }
  } 
</code></pre>
    <p class="normal">This configuration can be used with the <code class="Code-In-Text--PACKT-">openresty</code> command line, and will run in the foreground (daemon off) on port <code class="Code-In-Text--PACKT-">8888</code> to proxy pass all requests to the Quart app running on port <code class="Code-In-Text--PACKT-">5000</code>:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span><span class="language-bash">openresty -p $(</span><span class="hljs-con-built_in">pwd</span><span class="language-bash">) -c resty.conf</span>
2021/07/03 16:11:08 [notice] 44691#12779096: using the "kqueue" event method
2021/07/03 16:11:08 [warn] 44691#12779096: 1024 worker_connections exceed open file resource limit: 256
nginx: [warn] 1024 worker_connections exceed open file resource limit: 256
2021/07/03 16:11:08 [notice] 44691#12779096: openresty/1.19.3.2
2021/07/03 16:11:08 [notice] 44691#12779096: built by clang 12.0.0 (clang-1200.0.32.2)
2021/07/03 16:11:08 [notice] 44691#12779096: OS: Darwin 19.6.0
2021/07/03 16:11:08 [notice] 44691#12779096: hw.ncpu: 12
2021/07/03 16:11:08 [notice] 44691#12779096: net.inet.tcp.sendspace: 131072
2021/07/03 16:11:08 [notice] 44691#12779096: kern.ipc.somaxconn: 128
2021/07/03 16:11:08 [notice] 44691#12779096: getrlimit(RLIMIT_NOFILE): 256:9223372036854775807
2021/07/03 16:11:08 [notice] 44691#12779096: start worker processes
2021/07/03 16:11:08 [notice] 44691#12779096: start worker process 44692
</code></pre>
    <p class="normal">Note that this <a id="_idIndexMarker497"/>configuration can also be used in a plain <code class="Code-In-Text--PACKT-">nginx</code> server since we are not using any Lua yet. That's one of the great things about OpenResty: it's a drop-in replacement for <code class="Code-In-Text--PACKT-">nginx</code>, and can run your existing configuration files.</p>
    <p class="normal">The code and configuration demonstrated in this section can be found at <a href="https://github.com/PacktPublishing/Python-Microservices-Development-2nd-Edition/tree/main/CodeSample"><span class="url">https://github.com/PacktPublishing/Python-Microservices-Development-2nd-Edition/tree/main/CodeSamples</span></a>.</p>
    <p class="normal">Lua can be invoked at different moments when a request comes in; the two that are most attractive to this chapter are:</p>
    <ul>
      <li class="bullet"><code class="Code-In-Text--PACKT-">access_by_lua_block</code>: This is called on every incoming request before a response is built, and is where we can build access rules in our WAF</li>
      <li class="bullet"><code class="Code-In-Text--PACKT-">content_by_lua_block</code>: This uses Lua to generate a response</li>
    </ul>
    <p class="normal">Let us now see how we can rate-limit incoming requests.</p>
    <h2 id="_idParaDest-137" class="title">Rate and concurrency limiting</h2>
    <p class="normal">Rate limiting<a id="_idIndexMarker498"/> consists of counting how many requests a server accepts within a given period of time, and rejecting new ones when a limit is reached.</p>
    <p class="normal">Concurrency limiting consists <a id="_idIndexMarker499"/>of counting how many concurrent requests are being served by the web server to the same remote user, and rejecting new ones when it reaches a defined threshold. Since many requests can reach the server simultaneously, a concurrency limiter needs to have a small allowance in its threshold.</p>
    <p class="normal">These techniques avoid any trouble within our application when we know there is an upper limit to how many requests it can respond to concurrently, and that can be a factor in load balancing across multiple instances of our app. Both are implemented using the same technique. Let's look at how to build a concurrency limiter.</p>
    <p class="normal">OpenResty ships with a rate-limiting library written in Lua called <code class="Code-In-Text--PACKT-">lua-resty-limit-traffic</code>; you can use it in an <code class="Code-In-Text--PACKT-">access_by_lua_block</code> section: <a href="https://github.com/openresty/lua-resty-limit-traffic"><span class="url">https://github.com/openresty/lua-resty-limit-traffic</span></a>.</p>
    <p class="normal">The function uses Lua <em class="italic">Shared Dict</em>, which is a memory mapping that is shared by all <code class="Code-In-Text--PACKT-">nginx</code> workers within the same process. Using an in-memory dictionary means that rate limiting will work at the process level.</p>
    <p class="normal">Since we're <a id="_idIndexMarker500"/>typically deploying one <code class="Code-In-Text--PACKT-">nginx</code> per service node, rate limiting will happen per web server. So, if you are deploying several nodes for the same microservice, our effective rate limit will be the number of connections a single node can handle <a id="_idIndexMarker501"/>multiplied by the number of nodes—this will be important to take into account when deciding on the overall rate limit and how many concurrent requests the microservices can process.</p>
    <p class="normal">In the following example, we're adding a <code class="Code-In-Text--PACKT-">lua_shared_dict</code> definition and a section called <code class="Code-In-Text--PACKT-">access_by_lua_block</code> to activate the rate limiting. Note that this example is a simplified version of the example in the project's documentation:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># resty_limiting.conf</span>
daemon off;
worker_processes  1;
error_log /dev/stdout info;
events {
    worker_connections  1024;
}
http {
    lua_shared_dict my_limit_req_store 100m;
 
    server {
        listen   8888;
        server_name  localhost;
        access_log /dev/stdout;
        location / {
            access_by_lua_block {
                local limit_req = require "resty.limit.req"
                local lim, err = limit_req.new("my_limit_req_store", 200, 100)
                local key = ngx.var.binary_remote_addr
                local delay, err = lim:incoming(key, true)
                if not delay then
                    if err == "rejected" then
                        return ngx.exit(503)
                    end
                    ngx.log(ngx.ERR, "failed to limit req: ", err)
                    return ngx.exit(500)
                end
 
                if delay &gt;= 0.001 then
                    local excess = err
                    ngx.sleep(delay)
                end
            }
            proxy_pass http://localhost:5000;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        }
    }
}
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">access_by_lua_block</code> section can be considered as a Lua function, and can use some of the variables <a id="_idIndexMarker502"/>and functions that <code class="Code-In-Text--PACKT-">OpenResty</code> exposes. For instance, <code class="Code-In-Text--PACKT-">ngx.var</code> is a table containing all the <code class="Code-In-Text--PACKT-">nginx</code> variables, and <code class="Code-In-Text--PACKT-">ngx.exit()</code> is a<a id="_idIndexMarker503"/> function that can be used to immediately return a response to the user—in our case, a <code class="Code-In-Text--PACKT-">503</code> when we need to reject a call because of rate limiting.</p>
    <p class="normal">The library uses the <code class="Code-In-Text--PACKT-">my_limit_req_store</code> dictionary that is passed to the <code class="Code-In-Text--PACKT-">resty.limit.req</code> function; every time a request reaches the server, it calls the <code class="Code-In-Text--PACKT-">incoming()</code> function with the <code class="Code-In-Text--PACKT-">binary_remote_addr</code> value, which is the client address.</p>
    <p class="normal">The <code class="Code-In-Text--PACKT-">incoming()</code> function will use the shared dictionary to maintain the number of active connections per remote address, and send back a rejected value when that number reaches the threshold; for example, when there are more than <code class="Code-In-Text--PACKT-">300 </code>concurrent requests.</p>
    <p class="normal">If the connection is accepted, the <code class="Code-In-Text--PACKT-">incoming()</code> function sends back a delay value. Lua will hold the request using that delay and the asynchronous <code class="Code-In-Text--PACKT-">ngx.sleep()</code> function. The delay will be <code class="Code-In-Text--PACKT-">0</code> when the remote client has not reached the threshold of <code class="Code-In-Text--PACKT-">200</code>, and a small delay when between <code class="Code-In-Text--PACKT-">200</code> and <code class="Code-In-Text--PACKT-">300</code>, so the server has a chance to unstack all the pending requests.</p>
    <p class="normal">This design is quite efficient to prevent a service from becoming overwhelmed by many requests. Setting up a ceiling like this is also a good way to avoid reaching a point at which you know your microservice will start to break. For instance, if some of your benchmarks concluded that your service could not serve more than 100 simultaneous requests before starting to crash, you can set the rate limit appropriately, so it is <code class="Code-In-Text--PACKT-">nginx</code> that rejects requests instead of letting your Quart microservice try to process all those incoming connections only to reject them.</p>
    <p class="normal">The key used to<a id="_idIndexMarker504"/> calculate the rate in this example is the remote address header<a id="_idIndexMarker505"/> of the request. If your <code class="Code-In-Text--PACKT-">nginx</code> server is itself behind a proxy, make sure you are using a header that contains the real remote address. Otherwise, you will rate limit a single remote client, the proxy server. It's usually in the <code class="Code-In-Text--PACKT-">X-Forwarded-For</code> header in that case.</p>
    <p class="normal">If you want a WAF with more features, the <code class="Code-In-Text--PACKT-">lua-resty-waf</code> (<a href="https://github.com/p0pr0ck5/lua-resty-waf"><span class="url">https://github.com/p0pr0ck5/lua-resty-waf</span></a>) project works like <code class="Code-In-Text--PACKT-">lua-resty-limit-traffic</code>, but offers a lot of other protections. It is also able to read <code class="Code-In-Text--PACKT-">ModSecurity</code> rule files, so you can use the rule files from the OWASP project without having to use <code class="Code-In-Text--PACKT-">ModSecurity</code> itself.</p>
    <h2 id="_idParaDest-138" class="title">Other OpenResty features</h2>
    <p class="normal">OpenResty <a id="_idIndexMarker506"/>comes with many Lua scripts that can be useful to enhance <code class="Code-In-Text--PACKT-">nginx</code>. Some developers are even using it to serve their data directly. The following components page contains some useful tools for having <code class="Code-In-Text--PACKT-">nginx</code> interact with databases, cache <a id="_idIndexMarker507"/>servers, and so on: <a href="http://openresty.org/en/components.html"><span class="url">http://openresty.org/en/components.html</span></a>.</p>
    <p class="normal">There's also a website for the community to publish OpenResty components: <a href="https://opm.openresty.org/"><span class="url">https://opm.openresty.org/</span></a>.</p>
    <p class="normal">If you are using OpenResty in front of your Quart microservices, there will probably be other use cases where you can transfer some code that is in the Quart app to a few lines of Lua in OpenResty. The goal should not be to move the app's logic to OpenResty, but rather to leverage the web server to do anything that can be done before or after your Quart app is called. Let Python focus on the application logic and OpenResty work on a layer of protection.</p>
    <p class="normal">For instance, if you are using a Redis or a Memcached server to cache some of your <code class="Code-In-Text--PACKT-">GET</code> resources, you can directly call them from Lua to add or fetch a cached version for a given endpoint. The <a id="_idIndexMarker508"/><code class="Code-In-Text--PACKT-">srcache-nginx-module</code> (<a href="https://github.com/openresty/srcache-nginx-module"><span class="url">https://github.com/openresty/srcache-nginx-module</span></a>) is an implementation of such behavior, and will reduce the number of <code class="Code-In-Text--PACKT-">GET</code> calls made to your Quart apps if you can cache them.</p>
    <p class="normal">To conclude this <a id="_idIndexMarker509"/>section about WAFs: OpenResty is a powerful <code class="Code-In-Text--PACKT-">nginx</code> distribution that can be used to create a simple WAF to protect your microservices. It also offers abilities that go beyond firewalling. In fact, if you adopt OpenResty to run your microservices, it opens a whole new world of possibilities, thanks to Lua.</p>
    <h1 id="_idParaDest-139" class="title">Summary</h1>
    <p class="normal">In this chapter, we have looked at how to centralize authentication and authorization in a microservices-based application environment using OAuth2 and JWTs. Tokens give us the ability to limit what a caller can do with one of the microservices, and for how long they can do it.</p>
    <p class="normal">When used with public and private keys, it also limits the damage an attacker can inflict if one component of the whole application is compromised. It also ensures that each connection is cryptographically validated.</p>
    <p class="normal">A secure code base is the first step to a secure application. You should follow good coding practices and make sure your code does not do anything bad when interacting with incoming user data and resources. While a tool like Bandit will not guarantee the safety and security of your code, it will catch the most obvious potential security issues, so there should be no hesitation about continuously running it on your code base.</p>
    <p class="normal">Lastly, a WAF is also a good way to prevent some fraud and abuse on your endpoints and is very easy to do with a tool such as OpenResty, thanks to the power of the Lua programming language.</p>
    <p class="normal">OpenResty is also an excellent way to empower and speed up your microservices by doing a few things at the web server level when they do not need to be done within the Quart application.</p>
  </div>
</body></html>