- en: Chapter 7. Test-driven Development Walk-through
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we're not going to talk about new techniques of testing in
    Python, and we're not going to spend much time talking about the philosophy of
    testing. Instead, what we're going to do is a step-by-step walk-through of an
    actual development process. Your humble and sadly fallible author has commemorated
    his mistakes—and the ways that testing helped him fix them—while developing part
    of a personal scheduling program.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Writing a testable specification
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing unit tests that drive the development process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing code that complies with the specification and unit tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the testable specification and unit tests to help debug
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You'll be prompted to design and build your own module as you read through this
    chapter, so that you can walk through your own process as well.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the specification
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As usual, the process starts with a written specification. The specification
    is a `doctest` that we learned in [Chapter 2](ch02.html "Chapter 2. Working with
    doctest"), *Working with doctest*, and [Chapter 3](ch03.html "Chapter 3. Unit
    Testing with doctest"), *Unit Testing with doctest*, so the computer can use it
    to check the implementation. The specification isn't strictly a set of unit tests,
    though the discipline of unit testing has been sacrificed (for the moment) in
    exchange for making the document more accessible to a human reader. That's a common
    trade-off, and it's fine as long as you make up for it by also writing unit tests
    covering the code.
  prefs: []
  type: TYPE_NORMAL
- en: The goal of the project in this chapter is to make a Python package capable
    of representing personal time management information.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code goes in a file called `docs/outline.txt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This `doctest` will serve as a testable specification for my project, which
    means that it will be the foundation stone for all of my tests and my program
    code that will be built on. Let''s look at each section in more detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code consists of some introductory English text, and a couple
    of `import` statements that bring in code that we need for these tests. By doing
    so, they also tell us about some of the structure of the `planner` package. It
    contains a module called `data` that defines `Activity` and `Status`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding tests describe some of the desired behavior of `the Schedule`
    instances when interacting with the `Activity` and `Status` objects. According
    to these tests, a `Schedule` instance must accept an `Activity` or `Status` object
    as the parameter of its `add` and `remove` methods; once added, the `in` operator
    must return `True` for an object until it is removed. Furthermore, the two `Activity`
    instances that have the same parameters must be treated as the same object by
    `Schedule`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding test code describes what should happen when overlapping activities
    are added to a schedule. Specifically, a `ScheduleError` exception should be raised:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding test code describes what should happen when overlapping statuses
    are added to a schedule: the schedule should accept them. Furthermore, if a status
    and an activity overlap, they can still both be added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code describes how schedule storage should work. It also tells
    us that the `planner` package needs to contain a `persistence` module that, in
    turn, should contain `File`. It also tells us that `Schedule` instances should
    have `load` and `store` methods, and that the `==` operator should return `True`
    when they contain the same data.
  prefs: []
  type: TYPE_NORMAL
- en: Try it for yourself – what are you going to do?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It''s time for you to come up with a project of your own, something you can
    work on for yourself. We step through the development process:'
  prefs: []
  type: TYPE_NORMAL
- en: Think of a project of approximately the same complexity as the one described
    in this chapter. It should be a single module or a few modules in a single package.
    It should also be something that interests you, which is why I haven't given you
    a specific assignment here.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Imagine that the project is already done, and you need to write a description
    of what you've done, along with a little bit of demonstration code. Then go ahead
    and write your description and demo code in the form of a `doctest` file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: As you're writing the `doctest` file, watch out for places where your original
    idea has to change a little bit to make the demo easier to write or work better.
    When you find such cases, pay attention to them! At this stage, it's better to
    change the idea a little bit and save yourself effort all through the process.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Wrapping up the specification
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We've now got testable specifications for a couple of moderately-sized projects—yours
    and mine. These will help us to write unit tests and code, and they'll give us
    a sense of how complete each project is as a whole.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, the process of writing code into the `doctest` gave us a chance
    to test-drive our ideas. We've probably improved on our projects a little bit
    by using them in a concrete manner, even though the project implementation is
    still merely imaginary.
  prefs: []
  type: TYPE_NORMAL
- en: Once again, it's important that we have these tests written before writing the
    code that they will test. By writing the tests first, we give ourselves a touchstone
    that we can use in order to judge how well our code conforms to what we intended.
    If we write the code first, and then the tests, all we end up doing is enshrining
    what the code actually does—as opposed to what we meant for it to do—into the
    tests.
  prefs: []
  type: TYPE_NORMAL
- en: Writing initial unit tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since the specification doesn't contain unit tests, there's still a need for
    unit tests before the coding of the module can begin. The `planner.data` classes
    are the first target for the implementation, so they're the first ones to get
    the tests.
  prefs: []
  type: TYPE_NORMAL
- en: Activities and statuses are defined to be very similar, so their test modules
    are also similar. They're not identical, though, and they're not required to have
    any particular inheritance relationship; so the tests remain distinct.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following tests are in `tests/test_activities.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a look at the following code, step-by-step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The `test_valid` method checks whether the constructor works correctly when
    all of the parameters are correct. This is an important test, because it defines
    what correct behavior should be normally. We need more tests, though, to define
    correct behavior in abnormal situations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we''re making sure that you can''t create an activity that ends before
    it begins. That doesn''t make any sense, and can easily throw off assumptions
    made during the implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We don''t want extremely short activities, either. In the real world, an activity
    that takes no time is meaningless, so we have a test here to make sure that such
    things are not allowed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: While `repr(activity)` isn't likely to be used in any production code paths,
    it's handy during development and debugging. This test defines how the text representation
    of an activity ought to look, to make sure that it contains the desired information.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `repr` function is often useful during debugging, because it attempts to
    take any object and turn it into a string that represents that object. This is
    distinct from the `str` function, because `str` tries to turn the object into
    a string that is convenient for humans to read. The `repr` function, on the other
    hand, tries to create a string containing code that will recreate the object.
    That''s a slightly tough concept, so here''s an example contrasting `str` and
    `repr`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: It's up to the objects stored in a schedule to decide whether they are exclusive
    with other objects they overlap. Specifically, activities are supposed to exclude
    each other, so we check this here. We're using a mock object for the main activity,
    but we're being a bit lazy and use a real `Activity` instance to compare it against,
    trusting that there won't be a problem in this case. We don't expect that `Activity.excludes`
    will do much more than apply the `isinstance` function to its parameter, so there's
    not much that an error in the constructor can do to mess things up.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'These tests describe the behavior of the code that checks whether activities
    overlap in the cases where the first activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Comes before the second activity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overlaps the beginning of the second activity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overlaps the end of the second activity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Begins and ends within the range of the second activity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Begins before the second activity and ends after it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comes after the second activity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This covers the domain of possible relationships between the tasks.
  prefs: []
  type: TYPE_NORMAL
- en: No actual activities were used in these tests, just `Mock` objects that had
    been given the attributes that the `Activity.overlaps` function should look for.
    As always, we're doing our best to keep the code in different units from being
    able to interact during the tests.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You might have noticed that we used a shortcut to create the mock objects, by
    passing the attributes, we wanted them to have as keyword parameters for the constructor.
    Most of the time, that's a handy way to save a little work, but it does have the
    problem that it only works for attribute names that don't happen to be used as
    actual parameters to the `Mock` constructor. Notably, attributes called `name`
    can't be assigned in this way, because that parameter has a special meaning for
    `Mock`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code in `tests/test_statuses.py` is almost the same, except that it uses
    the `Status` class instead of the `Activity` class. There is one significant difference,
    though:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The defining difference between a `Status` and an `Activity` is that a status
    does not exclude other tasks that overlap with it. The tests, naturally, should
    reflect that difference.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code goes in `tests/test_schedules.py`. We define several mock
    objects that behave as if they were statuses or activities, and in which they
    support the overlap and exclusion protocol. We''ll use these mock objects in several
    tests, to see how the schedule deals with the various combinations of overlapping
    and exclusive objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a closer look at some sections of the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'These lines create mock objects as attributes of the `add_tests` class. Each
    of these mock objects has mocked `overlaps` and `excludes` methods that will always
    return either `True` or `False` when called. This means that each of these mock
    objects considers itself as overlap ping either everything or nothing, and excludes
    either everything or nothing. Between the four mock objects, we have covered all
    the possible combinations. In the following tests, we''ll add various combinations
    of these mock objects to a schedule, and make sure that it does the right things:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The preceding four tests are covering cases where we add a nonoverlapping object
    to a schedule. All of them are expected to accept the nonoverlapping object, except
    the first. In this test, we've previously added an object that claims that it
    does indeed overlap; furthermore, it excludes anything it overlaps. This test
    shows that, if either the object being added or an object already in the schedule
    believes that there's an overlap, the schedule must treat it as an overlap.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In this test, we're making sure that if an object already in the schedule overlaps
    a new object and claims exclusivity, then adding the new object will fail.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In this test, we're making sure that, even though the object already in the
    schedule doesn't think that it overlaps with the new object, it excludes the new
    object because the new object thinks that there's an overlap.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: These tests are making sure that the inclusive objects don't somehow interfere
    with adding each other to a schedule.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: These two tests describe the schedule behavior with respect to the `in` operator.
    Specifically, it should return `True` when the object in question is actually
    in the schedule.
  prefs: []
  type: TYPE_NORMAL
- en: Try it for yourself – write your early unit tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A specification—even a testable specification written in `doctest`—still hosts
    a lot of ambiguities that can be ironed out with good unit tests. Add that to
    the fact that the specification doesn''t maintain separation between different
    tests, and you can see that it''s time for your project to gain some unit tests.
    Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Find some element of your project that is described in (or implied by) your
    specification.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a unit test that describes the behavior of that element when given the
    correct input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a unit test that describes the behavior of that element when given the
    incorrect input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write unit tests that describe the behavior of the element at the boundaries
    between correct and incorrect input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go back to step 1 if you can find another untested part of your program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Wrapping up the initial unit tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is where you really take what was an ill-defined idea and turn it into
    a precise description of what you're going to do.
  prefs: []
  type: TYPE_NORMAL
- en: The end result can be quite lengthy, which shouldn't come as much of a surprise.
    After all, your goal at this stage is to completely define the behavior of your
    project; even without concerning yourself with the details of how that behavior
    is implemented, that's a lot of information.
  prefs: []
  type: TYPE_NORMAL
- en: Coding planner.data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's time to write some code using the specification document and the unit tests
    as guides. Specifically, it's time to write the `planner.data` module, which contains
    `Status`, `Activity`, and `Schedule`.
  prefs: []
  type: TYPE_NORMAL
- en: To create this package, I made a directory called `planner` and, within this
    directory, created a file called `__init__.py`. There's no need to put anything
    inside `__init__.py`, but the file itself needs to exist to tell Python that the
    `planner` directory is a package.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code goes in `planner/data.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `Task` class here contains most of the behavior that is needed for both
    the `Activity` class and the `Status` class. Since so much of what they do is
    common to both, it makes sense to write the code once and reuse it. Only the `excludes`
    method needs to be different in each of the subclasses. That makes the classes
    for activities and statuses very simple. The `Schedule` class turns out to be
    pretty easy, too. But is it right? Our tests will tell us.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We used the `timedelta` class and the `datetime.isoformat` method in the preceding
    code. Both are useful but somewhat obscure features of the `datetime` module.
    A `timedelta` instance represents the duration between two points in time. The
    `isoformat` method returns a string representing the `datetime` module in ISO
    8601 standard format.
  prefs: []
  type: TYPE_NORMAL
- en: Using tests to get the code right
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All right, so that code looks fairly good. Unfortunately, Nose tells us that
    there are a few problems. Actually, Nose reports quite a large number of problems,
    but a lot of them seem to be related to a few root causes.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s address the problem that, though the `Activity` and `Status`
    classes don''t seem to have the `exclude` methods, some of our code tries to call
    that method. A typical report of this problem from the Nose output looks like
    a traceback followed by:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Looking at our code, we see that it is properly called `excludes`. The tracebacks
    included in the Nose error report tell us that the problem is on line 51 of `planner/data.py`,
    and it looks like a quick fix.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll just change line 51 from the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: and run Nose again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, several of our tests report the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This is clearly another typo. That one's on line 52 of `planner/data.py`. Oops!!
    We'll fix that one, too, and run Nose again to see what else is wrong.
  prefs: []
  type: TYPE_NORMAL
- en: 'Continuing our trend of picking the low-hanging fruit first, let''s clear up
    the problem reported as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This is yet another typo, this time in `docs/outline.txt`. This time, it's not
    a problem with the code being tested, but with the test itself. It still needs
    to be fixed.
  prefs: []
  type: TYPE_NORMAL
- en: The problem is that, when originally entering the tests, I apparently only typed
    in two dots at the beginning of several lines, instead of the three that tell
    doctest that an expression continues onto that line.
  prefs: []
  type: TYPE_NORMAL
- en: 'After fixing that, things are starting to get less obvious. Let''s pick on
    this one next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Why isn't the activity being seen as a member of the schedule? The previous
    example passed, which shows that the `in` operator works for the activity we actually
    added to the schedule. The failure shows up when we try to use an equivalent activity;
    once we realize that, we know what we need to fix. Either our `__eq__` method
    isn't working, or (as is the actual case) we forgot to write it.
  prefs: []
  type: TYPE_NORMAL
- en: We can fix this bug by adding the `__eq__` and `__ne__` methods to `Task`, which
    will be inherited by `Activity` and `Status`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Now, two tasks that have the same name, start time, and end time will compare
    as equivalent even if one is a `Status` and the other is an `Activity`. The last
    isn't necessarily right, but it doesn't cause any of our tests to fail, so we'll
    leave it for now. If it becomes a problem later, we'll write a test that checks
    it, and then fix it.
  prefs: []
  type: TYPE_NORMAL
- en: What's the deal with this one?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Well, it looks ugly but, if you look at it, you'll see that `doctest` is just
    complaining that the raised exception doesn't print out as expected. It's even
    the right exception; it's just a question of formatting.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can fix this on line 62 of `planner/data.py`, by changing the line to read:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: There's one more problem with this doctest example, which is that we wrote the
    name of the expected exception as `ScheduleError`, and that was how Python 2 printed
    out exceptions. Python 3 prints out exceptions with a qualified name, though,
    so we need to change it to `planner.data.ScheduleError` on line 63 of the doctest
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Now, if you've been following along, all of the errors should be fixed, except
    for some of the acceptance tests in `docs/outline.txt`. Basically, these failing
    tests tell us that we haven't written the persistence code yet, which is true.
  prefs: []
  type: TYPE_NORMAL
- en: Try it for yourself – writing and debugging code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The basic procedure, as we''ve discussed before, is to write some code, then
    run the tests to find problems with the code, and repeat. When you happen to come
    across an error that isn''t covered by an existing test, you need to write a new
    test and continue the process. Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Write code that ought to satisfy at least some of your tests.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run your tests. If you''ve used the tools we talked about in the previous chapters,
    you should be able to run everything simply by executing:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If there are errors in the code you've already written, use the test output
    to help you locate and identity them. Once you understand the bugs, try to fix
    them and then go back to step 2.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you've fixed all the errors in the code you've written, and if your project
    isn't complete, choose some new tests to concentrate on and go back to step 1.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enough iterations on this procedure lead you to have a complete and tested project.
    Of course, the real task is more difficult than simply saying "it will work" but,
    in the end, it will work. You will produce a codebase that you can be confident
    in. It will also be an easier process than it would have been without the tests.
  prefs: []
  type: TYPE_NORMAL
- en: Your project might be done, but there's still more to do on the personal scheduler.
    At this stage of the chapter, I haven't finished going through the writing and
    debugging process. It's time to do that.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the persistence tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since I don''t have any actual unit tests for the persistence code yet, I''ll
    start off by making some. In the process, I have to figure out how persistence
    will actually work. The following code goes in `tests/test_persistence.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Looking at each of the important sections of the test code, we see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The `test_basic` test creates `File`, stores a single object under the name
    `'tag1'`, and then loads that object back from storage and checks whether it is
    equal to the original object. It really is a very basic test, but it covers the
    simple use case.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We don't need a test fixture here because we're not actually working with an
    on-disk file that we need to create and delete. The special filename `':memory:'`
    tells SQLite to do everything in memory. This is particularly handy for testing.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The `test_multiple_tags` test creates a storage, and then stores multiple objects
    in it, some with duplicate tags. It then checks whether the storage keeps all
    of the objects with a given tag, and returns all of them on request.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, all these tests define the persistence file as a multimap from
    string keys to object values.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A multimap is a mapping between single keys and any number of values. In other
    words, each individual key might be associated with one value, of fifty.
  prefs: []
  type: TYPE_NORMAL
- en: Finishing up the personal planner
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that there are at least basic unit tests covering the persistence mechanism,
    it''s time to write the persistence code itself. The following goes in `planner/persistence.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The `store_object` method runs a short SQL statement to store the object into
    a database field. The object serialization is handled by the `dumps` function
    from the `pickle` module.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `pickle` module, as a whole, deals with storing and retrieving Python objects.
    The `dumps` function in particular transforms Python objects into byte strings
    that can be transformed back into a Python object via the `loads` function.
  prefs: []
  type: TYPE_NORMAL
- en: The `load_object` method uses SQL to query the database for the serialized version
    of every object stored under a given tag, and then uses `pickle.loads` to transform
    these serializations into real objects for it to return.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now I run Nose to find out what''s broken:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Ah, yes. The `sqlite3` module returns the query rows as tuples, unless you
    tell it otherwise. I want to use column names as indexes, so I need to set the
    row factory. We''ll add the following line to the `File` constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Now when I run Nose, the only problems it tells me about are that I haven''t
    implemented `Schedule.load` and `Schedule.store` yet. Furthermore, there aren''t
    any unit tests that check these methods. The only error comes from the specification
    doctest. It''s time to write some more unit tests in `tests/test_schedules.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that I have some tests to check against, it''s time to write the store
    and load methods of the `Schedule` class in `planner/data.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'These changes also imply a change to the Schedule constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Okay, now, I run Nose, and... something''s still broken::'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Looks like schedules need to compare equal based on their contents, too. That''s
    easily done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Just like last time we wrote a comparison function; this one has some unusual
    behavior, in that it only considers two schedules equal if the tasks were added
    to them in the same order. Again, though this smells a little funny, it doesn't
    make any tests fail, and it's not clearly wrong; so we'll leave it until it matters.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about how the skills that we covered in earlier
    parts of this book are applied in practice. We did this by stepping through a
    recording of your humble author's actual process in writing a package. At the
    same time, you had the chance to work through your own project, make your own
    decisions, and design your own tests. You've taken the lead in a test-driven project,
    and you should be able to do it again whenever you want.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've covered the heart of Python testing, we're ready to talk about
    testing at the integration and system levels, which we'll do in the next chapter.
  prefs: []
  type: TYPE_NORMAL
