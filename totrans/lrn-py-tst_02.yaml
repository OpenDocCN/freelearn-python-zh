- en: Chapter 2. Working with doctest
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章。使用 doctest
- en: The first testing tool we're going to look at is called `doctest`. The name
    is short for "document testing" or perhaps a "testable document". Either way,
    it's a literate tool designed to make it easy to write tests in such a way that
    computers and humans both benefit from them. Ideally, `doctest` tests both, informs
    human readers, and tells the computer what to expect.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要查看的第一个测试工具叫做 `doctest`。这个名字是 "document testing" 或 "testable document" 的缩写。无论如何，它是一个文学工具，旨在使编写测试变得容易，以便计算机和人类都能从中受益。理想情况下，`doctest`
    测试两者，向人类读者提供信息，并告诉计算机期望什么。
- en: 'Mixing tests and documentation helps us:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 将测试和文档混合使用有助于我们：
- en: Keeps the documentation up-to-date with reality
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持文档与现实的同步
- en: Make sure that the tests express the intended behavior
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保测试表达了预期的行为
- en: Reuse some of the efforts involved in the documentation and test creation
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重复在文档和测试创建中的一些努力
- en: Where doctest performs best
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Doctest 的工作最佳之处
- en: The design decisions that went into `doctest` make it particularly well suited
    to writing acceptance tests at the integration and system testing levels. This
    is because `doctest` mixes human-only text with examples that both humans and
    computers can read. This structure doesn't support or enforce any of the formalizations
    of testing, but it conveys information beautifully and it still provides the computer
    with the ability to say *that works* or *that doesn't work*. As an added bonus,
    it is about the easiest way to write tests you'll ever see.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '`doctest` 的设计决策使其特别适合在集成和系统测试级别编写验收测试。这是因为 `doctest` 将仅人类可读的文本与人类和计算机都能阅读的示例混合在一起。这种结构不支持或强制任何测试的形式化，但它能美妙地传达信息，并且仍然为计算机提供了说
    *这行得通* 或 *这行不通* 的能力。作为额外的奖励，这是你见过的写测试最简单的方法之一。'
- en: In other words, a `doctest` file is a truly excellent program specification
    that you can have the computer check against your actual code any time you want.
    API documentation also benefits from being written as doctests and checked alongside
    your other tests. You can even include doctests in your docstrings.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，一个 `doctest` 文件是一个真正优秀的程序规范，你可以随时让计算机检查你的实际代码。API 文档如果以 doctests 的形式编写并与其他测试一起检查，也会受益。你甚至可以在你的
    docstrings 中包含 doctests。
- en: The basic idea you should be getting from all this is that `doctest` is ideal
    for uses where humans and computers will both benefit from reading them.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 从所有这些中你应该得到的基本想法是，`doctest` 对于人类和计算机都将从中受益的用途来说是非常理想的。
- en: The doctest language
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Doctest 语言
- en: Like program source code, `doctest` tests are written in plain text. The `doctest`
    module extracts the tests and ignores the rest of the text, which means that the
    tests can be embedded in human-readable explanations or discussions. This is the
    feature that makes `doctest` suitable for uses such as program specifications.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 与程序源代码一样，`doctest` 测试是用纯文本编写的。`doctest` 模块提取测试并忽略其余的文本，这意味着测试可以嵌入到人类可读的解释或讨论中。这正是使
    `doctest` 适用于程序规范等用途的功能。
- en: Example – creating and running a simple doctest
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例 - 创建和运行一个简单的 doctest
- en: 'We are going to create a simple `doctest` file, to show the fundamentals of
    using the tool. Perform the following steps:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个简单的 `doctest` 文件，以展示使用该工具的基本原理。执行以下步骤：
- en: Open a new text file in your editor, and name it `test.txt`.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的编辑器中打开一个新的文本文件，并将其命名为 `test.txt`。
- en: 'Insert the following text into the file:'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下文本插入到文件中：
- en: '[PRE0]'
  id: totrans-16
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We can now run the `doctest`. At the command prompt, change to the directory
    where you saved `test.txt`. Type the following command:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以运行 `doctest`。在命令提示符下，切换到保存 `test.txt` 的目录。输入以下命令：
- en: '[PRE1]'
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: When the test is run, you should see output like this:![Example – creating and
    running a simple doctest](img/3211OS_02_01.jpg)
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当运行测试时，你应该看到如下输出：![示例 - 创建和运行一个简单的 doctest](img/3211OS_02_01.jpg)
- en: Result – three times three does not equal ten
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结果 - 三乘三不等于十
- en: You just wrote a `doctest` file that describes a couple of arithmetic operations,
    and ran it to check whether Python behaved as the tests said it should. You ran
    the tests by telling Python to execute `doctest` on the file containing the tests.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚编写了一个 `doctest` 文件，描述了一些算术运算，并运行它来检查 Python 是否像测试所说的那样表现。你是通过告诉 Python 在包含测试的文件上执行
    `doctest` 来运行测试的。
- en: In this case, Python's behavior differed from the tests because, according to
    the tests, three times three equals ten. However, Python disagrees on that. As
    `doctest` expected one thing and Python did something different, `doctest` presented
    you with a nice little error report showing where to find the failed test, and
    how the actual result differed from the expected result. At the bottom of the
    report is a summary showing how many tests failed in each file tested, which is
    helpful when you have more than one file containing tests.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，Python的行为与测试不同，因为根据测试，三乘三等于十。然而，Python对此表示不同意。由于`doctest`期望一件事，而Python做了不同的事情，`doctest`向您提供了一个很好的错误报告，显示了如何找到失败的测试，以及实际结果与预期结果之间的差异。报告的底部是一个总结，显示了每个测试文件中失败的测试数量，当你有多个包含测试的文件时，这很有帮助。
- en: The syntax of doctests
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: doctests的语法
- en: 'You might have already figured it out from looking at the previous example:
    `doctest` recognizes tests by looking for sections of text that look like they''ve
    been copied and pasted from a Python interactive session. Anything that can be
    expressed in Python is valid within a `doctest`.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经从查看之前的示例中猜出来了：`doctest`通过寻找看起来像是从Python交互会话中复制粘贴的文本部分来识别测试。任何可以用Python表达的内容都可以在`doctest`中使用。
- en: Lines that start with a `>>>` prompt are sent to a Python interpreter. Lines
    that start with a `...` prompt are sent as continuations of the code from the
    previous line, allowing you to embed complex block statements into your doctests.
    Finally, any lines that don't start with `>>>` or `...`, up to the next blank
    line or `>>>` prompt, represent the output expected from the statement. The output
    appears as it would in an interactive Python session, including both the return
    value and anything printed to the console. If you don't have any output lines,
    `doctest` assumes it to mean that the statement is expected to have no visible
    result on the console, which usually means that it returns None.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 以`>>>`提示符开始的行被发送到Python解释器。以`...`提示符开始的行是前一行代码的延续，允许你在doctests中嵌入复杂的块语句。最后，任何不以`>>>`或`...`开始的行，直到下一个空白行或`>>>`提示符，代表从该语句期望的输出。输出将像在交互式Python会话中一样出现，包括返回值和打印到控制台的内容。如果你没有输出行，`doctest`会假设它意味着该语句在控制台上期望没有可见的结果，这通常意味着它返回None。
- en: The `doctest` module ignores anything in the file that isn't part of a test,
    which means that you can put explanatory text, HTML, line-art diagrams, or whatever
    else strikes your fancy in between your tests. We took advantage of this in the
    previous `doctest` to add an explanatory sentence before the test itself.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`doctest`模块忽略文件中不属于测试的部分，这意味着你可以在测试之间放置解释性文本、HTML、行图或其他任何你喜欢的元素。我们利用了这一点在之前的`doctest`中在测试本身之前添加了一个解释性句子。'
- en: Example – a more complex test
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例 - 一个更复杂的测试
- en: 'Add the following code to your `test.txt` file, separated from the existing
    code by at least one blank line:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到你的`test.txt`文件中，与现有代码至少隔一个空白行：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now take a moment to consider before running the test. Will it pass or fail?
    Should it pass or fail?
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行测试之前，花一点时间考虑一下。它会通过还是失败？它应该通过还是失败？
- en: Result – five tests run
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结果 - 运行了五个测试
- en: 'Just as we discussed before, run the test using the following command:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前讨论的那样，使用以下命令运行测试：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You should see a result like this:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到类似这样的结果：
- en: '![Result – five tests run](img/3211OS_02_02.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![结果 - 运行了五个测试](img/3211OS_02_02.jpg)'
- en: Because we added the new tests to the same file containing the tests from before,
    we still see the notification that three times three does not equal 10\. Now,
    though, we also see that five tests were run, which means our new tests ran and
    were successful.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们将新的测试添加到了包含之前测试的同一文件中，所以我们仍然看到通知，说三乘三不等于10。现在，尽管如此，我们还看到运行了五个测试，这意味着我们的新测试已经运行并且成功了。
- en: 'Why five tests? As far as `doctest` is concerned, we added the following three
    tests to the file:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么是五个测试？就`doctest`而言，我们向文件中添加了以下三个测试：
- en: The first one says that, when we `import sys`, nothing visible should happen
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个测试说，当我们`import sys`时，不应该有任何可见的操作
- en: The second test says that, when we define the `test_write` function, nothing
    visible should happen
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个测试说，当我们定义`test_write`函数时，不应该有任何可见的操作
- en: The third test says that, when we call the `test_write` function, `Hello` and
    `True` should appear on the console, in that order, on separate lines
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个测试说，当我们调用`test_write`函数时，`Hello`和`True`应该按顺序出现在控制台上，每行一个
- en: Since all three of these tests pass, `doctest` doesn't bother to say much about
    them. All it did was increase the number of tests reported at the bottom from
    two to five.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这三个测试都通过了，`doctest`没有对它们说太多。它所做的只是将底部报告的测试数量从两个增加到五个。
- en: Expecting exceptions
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 预期异常
- en: 'That''s all well and good for testing that things work as expected, but it
    is just as important to make sure that things fail when they''re supposed to fail.
    Put another way: sometimes your code is supposed to raise an exception, and you
    need to be able to write tests that check that behavior as well.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 对于测试预期工作正常的情况来说，这些都很好，但同样重要的是要确保当预期失败时，确实会失败。换句话说：有时你的代码应该引发异常，你需要能够编写测试来检查这种行为。
- en: Fortunately, `doctest` follows nearly the same principle in dealing with exceptions
    as it does with everything else; it looks for text that looks like a Python interactive
    session. This means it looks for text that looks like a Python exception report
    and traceback, and matches it against any exception that gets raised.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，`doctest`在处理异常时遵循的原则几乎与处理其他事情时相同；它寻找看起来像Python交互会话的文本。这意味着它寻找看起来像Python异常报告和回溯的文本，并将其与引发的任何异常进行匹配。
- en: 'The `doctest` module does handle exceptions a little differently from the way
    it handles other things. It doesn''t just match the text precisely and report
    a failure if it doesn''t match. Exception tracebacks tend to contain many details
    that are not relevant to the test, but that can change unexpectedly. The `doctest`
    module deals with this by ignoring the traceback entirely: it''s only concerned
    with the first line, `Traceback (most recent call last):`, which tells it that
    you expect an exception, and the part after the traceback, which tells it which
    exception you expect. The `doctest` module only reports a failure if one of these
    parts does not match.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`doctest`模块在处理异常时与其他事情的处理方式略有不同。它不仅仅精确匹配文本，如果不匹配则报告失败。异常回溯通常包含许多与测试无关的细节，但这些可能会意外地改变。`doctest`模块通过完全忽略回溯来处理这个问题：它只关心第一行，即`Traceback
    (most recent call last):`，这告诉它你预期会有异常，以及回溯之后的部分，这告诉它你预期哪种异常。`doctest`模块只有在这些部分之一不匹配时才会报告失败。'
- en: 'This is helpful for a second reason as well: manually figuring out what the
    traceback will look like, when you''re writing your tests, would require a significant
    amount of effort and would gain you nothing. It''s better to simply omit them.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这还有另一个好处：当你编写测试时，手动确定回溯将看起来如何需要大量的努力，而且对你来说毫无益处。最好是简单地省略它们。
- en: Example – checking for an exception
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例 – 检查异常
- en: This is yet another test that you can add to `test.txt`, this time testing some
    code that ought to raise an exception.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这又是你可以添加到`test.txt`中的另一个测试，这次测试的是应该引发异常的代码。
- en: 'Insert the following text into your `doctest` file, as always separated by
    at least one blank line:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下文本插入到你的`doctest`文件中，就像往常一样，至少空一行：
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The test is supposed to raise an exception, so it will fail if it doesn''t
    raise the exception or if it raises the wrong exception. Make sure that you have
    your mind wrapped around this: if the test code executes successfully, the test
    fails, because it expected an exception.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 测试预期会引发异常，所以如果它没有引发异常或引发了错误的异常，它将会失败。确保你理解这一点：如果测试代码执行成功，测试就会失败，因为它预期会有异常。
- en: 'Run the tests using the following doctest:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下doctest运行测试：
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Result – success at failing
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结果 – 失败成功
- en: The code contains a syntax error, which means this raises a `SyntaxError` exception,
    which in turn means that the example behaves as expected; this signifies that
    the test passes.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中包含语法错误，这意味着这会引发一个`SyntaxError`异常，这反过来又意味着示例表现如预期；这表示测试通过。
- en: '![Result – success at failing](img/3211OS_02_03.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![结果 – 失败成功](img/3211OS_02_03.jpg)'
- en: When dealing with exceptions, it is often desirable to be able to use a wildcard
    matching mechanism. The `doctest` provides this facility through its ellipsis
    directive that we'll discuss shortly.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理异常时，通常希望能够使用通配符匹配机制。`doctest`通过其省略号指令提供了这种功能，我们将在稍后讨论。
- en: Expecting blank lines
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 预期空白行
- en: The `doctest` uses the first blank line after `>>>` to identify the end of the
    expected output, so what do you do when the expected output actually contains
    a blank line?
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`doctest`使用`>>>`之后的第一个空白行来识别预期输出的结束，那么当预期输出实际上包含一个空白行时，你该怎么办？'
- en: The `doctest` handles this situation by matching a line that contains only the
    text `<BLANKLINE>` in the expected output with a real blank line in the actual
    output.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`doctest`通过匹配预期输出中只包含文本`<BLANKLINE>`的行与实际输出中的真实空白行来处理这种情况。'
- en: Controlling doctest behavior with directives
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用指令控制`doctest`行为
- en: Sometimes, the default behavior of `doctest` makes writing a particular test
    inconvenient. For example, `doctest` might look at a trivial difference between
    the expected and real outputs and wrongly conclude that the test has failed. This
    is where `doctest` directives come to the rescue. Directives are specially formatted
    comments that you can place after the source code of a test and that tell `doctest`
    to alter its default behavior in some way.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，`doctest`的默认行为使得编写特定的测试变得不方便。例如，`doctest`可能会查看预期输出和实际输出之间的细微差异，并错误地得出测试失败的结论。这就是`doctest`指令发挥作用的地方。指令是特殊格式的注释，你可以将其放置在测试源代码之后，并告诉`doctest`以某种方式改变其默认行为。
- en: A directive comment begins with `# doctest:`, after which comes a comma-separated
    list of options that either enable or disable various behaviors. To enable a behavior,
    write a `+` (plus symbol) followed by the behavior name. To disable a behavior,
    white a `–` (minus symbol) followed by the behavior name. We'll take a look at
    the several directives in the following sections.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 指令注释以`# doctest:`开头，之后是一个逗号分隔的选项列表，这些选项可以启用或禁用各种行为。要启用一种行为，请写一个`+`（加号符号）后跟行为名称。要禁用一种行为，请写一个`–`（减号符号）后跟行为名称。我们将在以下几节中查看几个指令。
- en: Ignoring part of the result
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 忽略部分结果
- en: It's fairly common that only part of the output of a test is actually relevant
    to determining whether the test passes. By using the `+ELLIPSIS` directive, you
    can make `doctest` treat the text `...` (called an ellipsis) in the expected output
    as a wildcard that will match any text in the output.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 测试的输出中只有一部分实际上是确定测试是否通过的关键。通过使用`+ELLIPSIS`指令，你可以让`doctest`将预期输出中的文本`...`（称为省略号）视为通配符，它将匹配输出中的任何文本。
- en: When you use an ellipsis, `doctest` will scan until it finds text matching whatever
    comes after the ellipsis in the expected output, and continue matching from there.
    This can lead to surprising results such as an ellipsis matching against a 0-length
    section of the actual output, or against multiple lines. For this reason, it needs
    to be used thoughtfully.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用省略号时，`doctest`会扫描直到找到与预期输出中省略号之后文本相匹配的文本，并从那里继续匹配。这可能导致令人惊讶的结果，例如省略号与实际输出的0长度部分匹配，或与多行匹配。因此，需要谨慎使用。
- en: Example – ellipsis test drive
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例 – 省略号测试驱动
- en: We're going to use the ellipsis in a few different tests to better get a feel
    of how it works. As an added bonus, these tests also show the use of `doctest`
    directives.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在几个不同的测试中使用省略号，以更好地了解其工作原理。作为额外的奖励，这些测试还展示了`doctest`指令的使用。
- en: 'Add the following code to your `test.txt` file:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到你的`test.txt`文件中：
- en: '[PRE6]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Result – ellipsis elides
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结果 – 省略号省略
- en: The tests all pass, where they would all fail without the ellipsis. The first
    and last tests, in which we checked for the presence of a specific module in `sys.modules`
    and confirmed a specific formatting while ignoring the contents of a string, demonstrate
    the kind of situation where ellipsis is really useful, because it lets you focus
    on the part of the output that is meaningful and ignore the rest of the test.
    The middle tests demonstrate how different outputs can match the same expected
    result when ellipsis is in play.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 所有测试都通过了，如果没有省略号，它们都会失败。第一个和最后一个测试，其中我们检查了`sys.modules`中是否存在特定的模块，并确认了特定的格式，同时忽略了字符串的内容，展示了省略号真正有用的场景，因为它让你可以关注输出中有意义的部分，而忽略测试的其余部分。中间的测试展示了当省略号起作用时，不同的输出如何匹配相同的预期结果。
- en: Look at the last test. Can you imagine any output that wasn't an ISO-formatted
    time stamp, but that would match the example anyway? Remember that the ellipsis
    can match any amount of text.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 看看最后一个测试。你能想象任何不是ISO格式的时间戳的输出，但仍然会匹配示例吗？记住，省略号可以匹配任何数量的文本。
- en: Ignoring white space
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 忽略空白
- en: Sometimes, white space (spaces, tabs, newlines, and their ilk) is more trouble
    than it's worth. Maybe you want to be able to break a single line of expected
    output across several lines in your test file, or maybe you're testing a system
    that uses lots of white space but doesn't convey any useful information with it.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，空白（空格、制表符、换行符及其类似物）比它带来的麻烦还要多。也许您希望能够在测试文件中将单个预期输出行的内容拆分成多行，或者也许您正在测试一个使用大量空白但不会传达任何有用信息的系统。
- en: The `doctest` gives you a way to "normalize" white space, turning any sequence
    of white space characters, in both the expected output and in the actual output,
    into a single space. It then checks whether these normalized versions match.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`doctest` 允许您“规范化”空白字符，将预期输出和实际输出中的任何空白字符序列转换为单个空格。然后它会检查这些规范化版本是否匹配。'
- en: Example – invoking normality
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例 – 调用正常化
- en: We're going to write a couple of tests that demonstrate how whitespace normalization
    works.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写一些测试来演示空白规范化是如何工作的。
- en: 'Insert the following code into your `doctest` file:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码插入到您的 `doctest` 文件中：
- en: '[PRE7]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Result – white space matches any other white space
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结果 – 空白匹配任何其他空白
- en: Both of these tests pass, in spite of the fact that the result of the first
    one has been wrapped across multiple lines to make it easy for humans to read,
    and the result of the second one has had its strange newlines and indentations
    left out, also for human convenience.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管第一个测试的结果被拆分成多行以便于人类阅读，第二个测试的结果去除了奇怪的新行和缩进，但这两个测试都通过了，这也是为了人类的便利。
- en: Notice how one of the tests inserts extra whitespace in the expected output,
    while the other one ignores extra whitespace in the actual output? When you use
    `+NORMALIZE_WHITESPACE`, you gain a lot of flexibility with regard to how things
    are formatted in the text file.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到其中一个测试在预期输出中插入了额外的空白，而另一个测试则忽略了实际输出中的额外空白？当您使用 `+NORMALIZE_WHITESPACE` 时，您在文本文件中格式化内容方面会获得很大的灵活性。
- en: Note
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You may have noted the value `39` on the last line of the last example. Why
    is that there? It's because the `write()` method returns the number of bytes that
    were written, which in this case happens to be `39`. If you're trying this example
    in an environment that maps ASCII characters to more than one byte, you will see
    a different number here; this will cause the test to fail until you change the
    expected number of bytes.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能注意到了最后一个例子中的值 `39`。为什么它在那里？这是因为 `write()` 方法返回写入的字节数，在这个例子中恰好是 `39`。如果您在一个将
    ASCII 字符映射到多个字节的环境中尝试此示例，您将在这里看到不同的数字；这将导致测试失败，直到您更改预期的字节数。
- en: Skipping an example
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跳过一个示例
- en: On some occasions, `doctest` will recognize some text as an example to be checked,
    when in truth you want it to be simply text. This situation is rarer than it might
    at first seem, because usually there's no harm in letting `doctest` check everything
    it can. In fact, usually it's very helpful to have `doctest` check everything
    it can. For those times when you want to limit what `doctest` checks, though,
    there's the `+SKIP` directive.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，`doctest` 会识别某些文本作为要检查的示例，而实际上您希望它只是普通文本。这种情况比最初看起来要少，因为通常让 `doctest`
    检查所有内容并没有什么坏处。事实上，通常让 `doctest` 检查所有内容是非常有帮助的。不过，当您想限制 `doctest` 检查的内容时，可以使用 `+SKIP`
    指令。
- en: Example – humans only
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例 – 仅人类使用
- en: 'Append the following code to your doctest file:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到您的 doctest 文件中：
- en: '[PRE8]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Result – it looks like a test, but it's not
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结果 – 它看起来像是一个测试，但实际上不是
- en: Before we added this last example to the file, `doctest` reported thirteen tests
    when we ran the file through it. After adding this code, `doctest` still reports
    thirteen tests. Adding the skip directive to the code completely removed it from
    consideration by doctest. It's not a test that passes, nor a test that fails.
    It's not a test at all.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将这个最后的例子添加到文件之前，运行文件时 `doctest` 报告了十三项测试。添加此代码后，`doctest` 仍然报告十三项测试。将跳过指令添加到代码中完全将其从
    doctest 的考虑范围中移除。它既不是一个通过测试，也不是一个失败测试。它根本不是一项测试。
- en: The other directives
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他指令
- en: There are a number of other directives that can be issued to doctest, should
    you find the need. They're not as broadly useful as the ones already mentioned,
    but the time might come when you require one or more of them.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您发现需要，可以向 doctest 发出许多其他指令。它们不像之前提到的那些指令那样广泛有用，但将来您可能需要其中之一或多个。
- en: Note
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The full documentation for all of the doctest directives can be found at [http://docs.python.org/3/library/doctest.html#doctest-options](http://docs.python.org/3/library/doctest.html#doctest-options).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 doctest 指令的完整文档可以在 [http://docs.python.org/3/library/doctest.html#doctest-options](http://docs.python.org/3/library/doctest.html#doctest-options)
    找到。
- en: 'The remaining directives of `doctest` in the Python 3.4 version are as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Python 3.4 版本中 `doctest` 的剩余指令如下：
- en: '`DONT_ACCEPT_TRUE_FOR_1`: This makes `doctest` differentiate between boolean
    values and numbers'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DONT_ACCEPT_TRUE_FOR_1`: 这使得 `doctest` 能够区分布尔值和数字'
- en: '`DONT_ACCEPT_BLANKLINE`: This removes support for the <BLANKLINE> feature'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DONT_ACCEPT_BLANKLINE`: 这移除了对 <BLANKLINE> 功能的支持'
- en: '`IGNORE_EXCEPTION_DETAIL`: This makes `doctest` only care that an exception
    is of the expected type'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IGNORE_EXCEPTION_DETAIL`: 这使得 `doctest` 只关心异常是否为预期的类型'
- en: Strictly speaking, `doctest` supports several other options that can be set
    using the directive syntax, but they don't make any sense as directives, so we'll
    ignore them here.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 严格来说，`doctest` 支持使用指令语法设置的几个其他选项，但它们作为指令没有意义，所以我们在这里忽略它们。
- en: The execution scope of doctest tests
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: doctest 测试的执行作用域
- en: 'When `doctest` is running the tests from text files, all the tests from the
    same file are run in the same execution scope. This means that, if you import
    a module or bind a variable in one test, that module or variable is still available
    in later tests. We took advantage of this fact several times in the tests written
    so far in this chapter: the `sys` module was only imported once, for example,
    although it was used in several tests.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `doctest` 从文本文件运行测试时，来自同一文件的所有测试都在相同的执行作用域中运行。这意味着，如果你在一个测试中导入了一个模块或绑定了一个变量，那么这个模块或变量在后续测试中仍然可用。我们已经在本章前面编写的测试中多次利用了这个事实：例如，`sys`
    模块只导入了一次，尽管它在几个测试中使用。
- en: This behavior is not necessarily beneficial, because tests need to be isolated
    from each other. We don't want them to contaminate each other because, if a test
    depends on something that another test does, or if it fails because of something
    that another test does, these two tests are in some sense combined into one test
    that covers a larger section of your code. You don't want that to happen, because
    then knowing which test has failed doesn't give you as much information about
    what went wrong and where it happened.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为并不一定是有益的，因为测试需要彼此隔离。我们不希望它们相互污染，因为如果某个测试依赖于另一个测试的内容，或者它失败是因为另一个测试的内容，那么这两个测试在某种程度上就合并成了一个覆盖更大代码部分的测试。你不想这种情况发生，因为这样知道哪个测试失败并不能给你提供太多关于出错原因和出错位置的信息。
- en: So, how can we give each test its own execution scope? There are a few ways
    to do it. One would be to simply place each test in its own file, along with whatever
    explanatory text that is needed. This works well in terms of functionality, but
    running the tests can be a pain unless you have a tool to find and run all of
    them for you. We'll talk about one such tool (called Nose) in a later chapter.
    Another problem with this approach is that this breaks the idea that the tests
    contribute to a human-readable document.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何为每个测试提供它自己的执行作用域呢？有几种方法可以实现。一种方法是将每个测试简单地放置在自己的文件中，以及所需的任何解释性文本。从功能上讲，这很好，但如果没有工具帮你找到并运行所有测试，运行测试可能会很痛苦。我们将在后面的章节中讨论这样一个工具（称为
    Nose）。这种方法的一个问题是，它会破坏测试对可读文档的贡献这一理念。
- en: 'Another way to give each test its own execution scope is to define each test
    within a function, as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 为每个测试提供它自己的执行作用域的另一种方法是定义一个函数内的每个测试，如下所示：
- en: '[PRE9]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: By doing this, the only thing that ends up in the shared scope is the test function
    (named `test1` here). The `frob` module and any other names bound inside the function
    are isolated with the caveat that things that happen inside imported modules are
    not isolated. If the `frob.hash()` method changes a state inside the `frob` module,
    that state will still be changed if a different test imports the `frob` module
    again.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，最终在共享作用域中结束的只有测试函数（这里命名为 `test1`）。`frob` 模块和函数内部绑定的任何其他名称都是隔离的，但有一个例外，那就是导入模块内部发生的事情不是隔离的。如果
    `frob.hash()` 方法在 `frob` 模块内部改变了一个状态，那么当不同的测试再次导入 `frob` 模块时，这个状态仍然会被改变。
- en: The third way is to exercise caution with the names you create, and be sure
    to set them to known values at the beginning of each test section. In many ways
    this is the easiest approach, but this is also the one that places the most burden
    on you, because you have to keep track of what's in the scope.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种方法是创建名称时要小心谨慎，并确保在每个测试部分的开始将它们设置为已知值。在许多方面，这是一种最简单的方法，但这也是对你要求最高的方法，因为你必须跟踪作用域中的内容。
- en: Why does `doctest` behave in this way, instead of isolating tests from each
    other? The `doctest` files are intended not just for computers to read, but also
    for humans. They often form a sort of narrative, flowing from one thing to the
    next. It would break the narrative to be constantly repeating what came before.
    In other words, this approach is a compromise between being a document and being
    a test framework, a middle ground that works for both humans and computers.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么 `doctest` 会以这种方式行为，而不是将测试彼此隔离？`doctest` 文件不仅是为了计算机阅读，也是为了人类。它们通常形成一种叙事，从一件事流向另一件事。不断地重复之前的内容会打断叙事。换句话说，这种方法是在文档和测试框架之间的一种折衷，一个既适合人类也适合计算机的中间地带。
- en: The other framework that we will study in depth in this book (called simply
    `unittest`) works at a more formal level, and enforces the separation between
    tests.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中我们将深入研究（简单地称为 `unittest`）的另一个框架在更正式的层面上工作，并强制执行测试之间的分离。
- en: Check your understanding
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查你的理解
- en: 'Once you''ve decided on your answers to these questions, check them by writing
    a test document and running it through `doctest`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你决定了这些问题的答案，通过编写一个测试文档并运行它通过 `doctest` 来检查它们：
- en: How does `doctest` recognize the beginning of a test in a document?
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`doctest` 是如何识别文档中测试的开始部分的？'
- en: How does `doctest` know when a test continues to further lines?
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`doctest` 是如何知道一个测试会继续到更多行的？'
- en: How does `doctest` recognize the beginning and end of the expected output of
    a test?
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`doctest` 是如何识别测试预期输出的开始和结束的？'
- en: How would you tell `doctest` that you want to break the expected output across
    several lines, even though that's not how the test actually outputs it?
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你会如何告诉 `doctest` 你想要将预期的输出跨越多行，即使测试实际上并不是这样输出的？
- en: Which parts of an exception report are ignored by `doctest`?
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常报告中哪些部分被 `doctest` 忽略了？
- en: When you assign a variable in a test file, which parts of the file can actually
    *see* that variable?
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你在测试文件中分配一个变量时，文件中的哪些部分实际上可以“看到”这个变量？
- en: Why do we care what code can *see* the variables created by a test?
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们为什么关心代码可以“看到”由测试创建的变量？
- en: How can we make `doctest` not care what a section of output contains?
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何让 `doctest` 不关心输出的一部分内容？
- en: Exercise – English to doctest
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习 – 英语到 doctest
- en: Time to stretch your wings a bit. I'm going to give you a description of a single
    function in English. Your job is to copy the description into a new text file,
    and then add tests that describe all the requirements in a way that the computer
    can understand and check.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候展开你的翅膀了。我将用英语给你描述一个单独的函数。你的任务是把这个描述复制到一个新的文本文件中，然后添加测试来描述所有要求，以便计算机可以理解和检查。
- en: Try to make the doctests so that they're not just for the computer. Good doctests
    tend to clarify things for human readers as well. By and large, this means that
    you present them to human readers as examples interspersed with the text.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 尽量使 doctests 不仅对计算机有用。好的 doctests 往往也会为人类读者澄清事情。总的来说，这意味着你将它们作为例子呈现给人类读者，穿插在文本中。
- en: 'Without further ado, here is the English description:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 不再拖延，以下是英语描述：
- en: '[PRE10]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: I'll give you a hint and point out that the last sentence about the function
    being slow, isn't really testable. As computers get faster, any test you write
    that depends on an arbitrary definition of "slow" will eventually fail. Also,
    there's no good way to test the difference between a slow function and a function
    stuck in an infinite loop, so there's not much point in trying. If you find yourself
    needing to do that, it's best to back off and try a different solution.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我会给你一个提示，并指出关于函数运行缓慢的最后一句话实际上是不可测试的。随着计算机变得越来越快，任何依赖于“慢”的任意定义的测试最终都会失败。此外，没有很好的方法来测试一个慢函数和一个陷入无限循环的函数之间的区别，所以尝试这样做并没有太大的意义。如果你发现自己需要这样做，最好是退一步，尝试不同的解决方案。
- en: Note
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Not being able to tell whether a function is stuck or just slow is called the
    halting problem by computer scientists. We know that it can't be solved unless
    we someday discover a fundamentally better kind of computer. Faster computers
    won't do the trick, and neither will quantum computers, so don't hold your breath.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机科学家称无法判断一个函数是卡住还是仅仅运行缓慢为“停机问题”。我们知道，除非我们有一天发现一种根本更好的计算机类型，否则这个问题是无法解决的。更快的计算机不会起作用，量子计算机也不会，所以不要抱太大希望。
- en: The next-to-last sentence also provides some difficulty, since to test it completely
    would require running every positive integer through the `fib()` function, which
    would take forever (except that the computer will eventually run out of memory
    and force Python to raise an exception). How do we deal with this sort of thing,
    then?
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 下一句也提供了一些困难，因为要完全测试它，需要将每个正整数都通过 `fib()` 函数运行，这将花费很长时间（除非计算机最终耗尽内存并迫使 Python
    抛出异常）。那么我们如何处理这类事情呢？
- en: The best solution is to check whether the condition holds true for a random
    sample of viable inputs. The `random.randrange()` and `random.choice()` functions
    in the Python standard library make that fairly easy to do.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的解决方案是检查对于一组有效的输入，条件是否成立。Python 标准库中的 `random.randrange()` 和 `random.choice()`
    函数使得这变得相对容易。
- en: Embedding doctests into docstrings
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 doctests 嵌入 docstrings
- en: It's just as easy to write doctests into docstrings as it is to write them into
    documentation files.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 将 doctests 写入 docstrings 与写入文档文件一样简单。
- en: Note
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For those who don't know, docstrings are a Python feature that allows programmers
    to embed documentation directly into their source code. The Python `help()` function
    is powered by docstrings. To learn more about docstrings, you can start with the
    Python tutorial section at [https://docs.python.org/3/tutorial/controlflow.html#documentation-strings](https://docs.python.org/3/tutorial/controlflow.html#documentation-strings).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些不知道的人来说，docstrings 是 Python 的一项特性，允许程序员将文档直接嵌入到他们的源代码中。Python 的 `help()`
    函数就是由 docstrings 驱动的。要了解更多关于 docstrings 的信息，你可以从 Python 教程部分的 [https://docs.python.org/3/tutorial/controlflow.html#documentation-strings](https://docs.python.org/3/tutorial/controlflow.html#documentation-strings)
    开始。
- en: When written in docstrings, doctests serve a slightly different purpose. They
    still let the computer check that things work as expected, but the humans who
    see them will most often be coders who use the Python interactive shell to work
    on an idea before committing it to code, or whose text editor pops up docstrings
    as they work. In that context, the most important thing a `doctest` can do is
    be informative, so docstrings aren't usually a good place for checking picky details.
    They're a great place for a `doctest` to demonstrate the proper behavior of a
    common case, though.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当在 docstrings 中编写时，doctests 扮演着略微不同的角色。它们仍然允许计算机检查事物是否按预期工作，但看到它们的人通常是使用 Python
    交互式外壳在提交代码之前在代码上工作，或者当他们在工作时文本编辑器弹出 docstrings 的程序员。在这种情况下，`doctest` 最能发挥作用的是提供信息，因此
    docstrings 通常不是检查细节的好地方。尽管如此，doctest 在演示常见情况的正确行为时是一个很好的地方。
- en: The doctests embedded in docstrings have a somewhat different execution scope
    than doctests in text files do. Instead of having a single scope for all of the
    tests in the file, `doctest` creates a single scope for each docstring. All of
    the tests that share a docstring also share an execution scope, but they're isolated
    from tests in the other docstrings.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入在 docstrings 中的 doctests 与文本文件中的 doctests 执行范围略有不同。`doctest` 不是为文件中的所有测试创建一个单一的执行范围，而是为每个
    docstring 创建一个单一的执行范围。共享相同 docstring 的所有测试也共享一个执行范围，但它们与其他 docstrings 中的测试是隔离的。
- en: The separation of each docstring into its own execution scope often means that
    we don't need to put much thought into isolating doctests when they're embedded
    in docstrings. This is fortunate, since docstrings are primarily intended for
    documentation, and the tricks required to isolate the tests might obscure the
    meaning.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 将每个 docstring 分离到自己的执行范围通常意味着我们不需要在 docstrings 中嵌入 doctests 时过多考虑隔离测试。这是幸运的，因为
    docstrings 主要用于文档，而隔离测试所需的技巧可能会掩盖其含义。
- en: Example – a doctest in a docstring
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例 - 一个嵌入在 docstring 中的 doctest
- en: We're going to embed a test right inside the Python source file that it tests,
    by placing it inside a docstring.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将直接在测试的 Python 源文件中嵌入一个测试，通过将其放置在 docstring 中来实现。
- en: 'Create a file called `test.py` containing the following code:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 `test.py` 的文件，包含以下代码：
- en: '[PRE11]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Notice the use of a raw string for the docstring (denoted by the `r` character
    before the first triple quote). Using raw strings for your docstrings is a good
    habit to get into, because you usually don't want escape sequences—for example,
    `\n` for newline— to be interpreted by the Python interpreter. You want them to
    be treated as text, so that they are correctly passed on to doctest.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 注意文档字符串（由第一个三引号前的`r`字符表示）使用了原始字符串。养成使用原始字符串作为文档字符串的习惯是个好习惯，因为你通常不希望转义序列——例如，`\n`表示换行——被Python解释器解释。你希望它们被当作文本处理，这样它们才能被正确地传递给doctest。
- en: 'Running these tests is just as easy as running the tests in a doctest document:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这些测试与在doctest文档中运行测试一样简单：
- en: '[PRE12]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Since all the tests pass, the output of this command is nothing at all. We
    can make it more interesting by adding the verbose flag to the command line:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所有测试都通过了，这个命令的输出什么都没有。我们可以通过在命令行中添加详细标志来让它更有趣：
- en: '[PRE13]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Result – the code is now self-documenting and self-testable
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结果——代码现在可以自我文档化和自我测试
- en: 'When we run the Python file through `doctest` with the verbose flag, we see
    the output, as shown in the the following screenshot:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们通过带有详细标志的`doctest`运行Python文件时，我们会看到以下截图所示的输出：
- en: '![Result – the code is now self-documenting and self-testable](img/3211OS_02_04.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![结果——代码现在可以自我文档化和自我测试](img/3211OS_02_04.jpg)'
- en: We put the `doctest` code right inside the docstring of the function it was
    testing. This is a good place for tests that also show a programmer how to do
    something. It's not a good place for detailed, low-level tests (the `doctest`
    in the docstring example code, which was quite detailed for illustrative purposes,
    is perhaps too detailed), because docstrings need to serve as API documentation—you
    can see the reason for this just by looking at the example, where the doctests
    take up most of the room in the docstring without telling the readers any more
    than they would have learned from a single test.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`doctest`代码直接放在被测试函数的文档字符串中。这是一个展示程序员如何做某事的测试的好地方。它不是一个详细、低级测试的好地方（文档字符串示例代码中的`doctest`非常详细，用于说明目的，可能过于详细），因为文档字符串需要作为API文档——只需看看示例，你就能看到原因，doctests占据了文档字符串的大部分空间，而没有告诉读者比单个测试更多的信息。
- en: Any test that will serve as good API documentation is a good candidate for including
    in the docstrings of a Python file.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 任何可以作为良好API文档的测试都是包含在Python文件文档字符串中的良好候选者。
- en: You might be wondering about the line that reads `1 items had no tests`, and
    the following line that just reads `test`. These lines are referring to the fact
    that there are no tests written in the module-level docstring. That's a little
    surprising, since we didn't include such a docstring in our source code at all,
    until you realize that, as far as Python (and thus `doctest`) is concerned, no
    docstring is the same as an empty docstring.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道那条写着“1 items had no tests”的行，以及随后的只写着“test”的行。这些行指的是模块级文档字符串中没有编写测试的事实。这有点令人惊讶，因为我们根本没在我们的源代码中包含这样的文档字符串，直到你意识到，就Python（以及因此`doctest`）而言，没有文档字符串与空文档字符串是相同的。
- en: Putting it into practice – an AVL tree
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将其付诸实践——AVL树
- en: We're going to walk step-by-step through the process of using `doctest` to create
    a testable specification for a data structure called an AVL tree. An AVL tree
    is a way to organize key-value pairs so that they can be quickly located by key.
    In other words, it's a lot like Python's built-in dictionary type. The name AVL
    references the initials of the people who invented this data structure.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将逐步介绍使用`doctest`为名为AVL树的数据结构创建可测试规范的过程。AVL树是一种组织键值对的方式，以便可以通过键快速定位。换句话说，它非常类似于Python的内置字典类型。AVL这个名字指的是发明这种数据结构的人的姓名首字母。
- en: Note
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: While AVL trees are similar to Python dictionaries, they have some significantly
    different properties. For one thing, the keys stored in an AVL tree can be iterated
    over in a sorted order with no overhead. Another difference is that, while inserting
    and removing objects in an AVL tree is slower than a Python `dict` in many cases,
    it's faster in the worst case.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然AVL树与Python字典类似，但它们有一些显著不同的特性。首先，存储在AVL树中的键可以按排序顺序迭代，且没有额外开销。另一个区别是，在AVL树中插入和删除对象通常比Python
    `dict`慢，但在最坏情况下却更快。
- en: As its name suggests, an AVL tree organizes the keys that are stored in it into
    a tree structure, with each key having up to two child keys —one child key that
    is less than the parent key by comparison, and one that is more. In the following
    figure, the `Elephant` key has two child keys, `Goose` has one, and `Aardvark`
    and `Frog` both have none.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名称所示，AVL树将存储在其中的键组织成树结构，每个键最多有两个子键——一个子键通过比较小于父键，另一个子键大于父键。在下面的图中，`Elephant`键有两个子键，`Goose`有一个，而`Aardvark`和`Frog`都没有。
- en: 'The AVL tree is special because it keeps one side of the tree from getting
    much taller than the other, which means that users can expect it to perform reliably
    and efficiently no matter what. In the following figure, the AVL tree will reorganize
    to stay balanced if `Frog` gains a child:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: AVL树是特殊的，因为它保持树的某一侧不会比另一侧高得多，这意味着用户可以期望它无论在什么情况下都能可靠和高效地执行。在下面的图中，如果`Frog`获得一个子键，AVL树将重新组织以保持平衡：
- en: '![Putting it into practice – an AVL tree](img/3211OS_02_05.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![将实践付诸行动 - AVL树](img/3211OS_02_05.jpg)'
- en: We're going to write tests for an AVL tree implementation here, rather than
    writing the implementation itself, so we're going to gloss over the details of
    *how* an AVL tree works, in favor of looking at what it should do when it works
    right.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这里编写AVL树实现的测试，而不是编写实现本身，所以我们不会详细说明AVL树是如何工作的，而是关注它正确工作时应该做什么。
- en: Note
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you want to know more about AVL trees, you will find many good references
    on the Internet. Wikipedia''s entry on this subject is a good place to start with:
    [http://en.wikipedia.org/wiki/AVL_tree](http://en.wikipedia.org/wiki/AVL_tree).'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于AVL树的信息，你将在互联网上找到许多好的参考资料。关于这个主题的维基百科条目是一个很好的起点：[http://en.wikipedia.org/wiki/AVL_tree](http://en.wikipedia.org/wiki/AVL_tree)。
- en: We're going to start with a plain-language specification, and then interject
    tests between the paragraphs. You don't have to actually type all of this into
    a text file; it is here for you to read and to think about.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一份通俗易懂的规范开始，然后在段落之间插入测试。你不需要真的将这些内容全部输入到一个文本文件中；这里提供给你是为了阅读和思考。
- en: English specification
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 英语规范
- en: The first step is to describe what the desired result should be, in normal language.
    This might be something that you do for yourself, or it might be something that
    somebody else does for you. If you're working for somebody, hopefully you and
    your employer can sit down together and work this part out.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是描述期望的结果应该是什么，用普通语言。这可能是一些你自己做的事情，或者可能是别人为你做的事情。如果你为别人工作，希望你和你的雇主可以坐下来一起完成这部分工作。
- en: In this case, there's not much to work out, because AVL trees have been fully
    described for decades. Even so, the description here isn't quite like the one
    you'd find elsewhere. This capacity for ambiguity is exactly the reason why a
    plain-language specification isn't good enough. We need an unambiguous specification,
    and that's exactly what the tests in a doctest file can give us.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，没有太多需要解决的问题，因为AVL树已经完全描述了几十年。即便如此，这里的描述并不完全像你在其他地方找到的那样。这种歧义性正是为什么纯语言规范不够好的原因。我们需要一个明确的规范，这正是doctest文件中的测试可以给我们提供的。
- en: 'The following text goes in a file called `AVL.txt`, (that you can find in its
    final form in the accompanying code archive; at this stage of the process, the
    file contains only the normal language specification):'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 以下文本将放入一个名为`AVL.txt`的文件中，（你可以在附带的代码存档中找到其最终形式；在处理过程的这个阶段，该文件只包含普通语言规范）：
- en: '[PRE14]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Node data
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 节点数据
- en: The first three paragraphs of the specification describe the member variables
    of an AVL tree node, and tell us what the valid values for the variables are.
    They also tell us how the tree height should be measured and define what a balanced
    tree means. It's our job now to take these ideas, and encode them into tests that
    the computer can eventually use to check our code.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 规范的前三段描述了AVL树节点的成员变量，并告诉我们变量的有效值是什么。它们还告诉我们如何测量树的高度，并定义平衡树是什么意思。现在我们的任务是把这些想法编码成计算机最终可以用来检查我们代码的测试。
- en: We can check these specifications by creating a node and then testing the values,
    but that would really just be a test of the constructor. It's important to test
    the constructor, but what we really want to do is to incorporate checks that the
    node variables are left in a valid state into our tests of each member function.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过创建一个节点然后测试其值来检查这些规范，但这实际上只是对构造函数的测试。测试构造函数很重要，但我们真正想要做的是将检查节点变量是否处于有效状态的检查纳入到我们对每个成员函数的测试中。
- en: 'To that end, we''ll define functions that our tests can call to check that
    the state of a node is valid. We''ll define these functions just after the third
    paragraph, because they provide extra details related to the content of the first
    three paragraphs:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这个目的，我们将定义我们的测试可以调用的函数来检查节点状态是否有效。我们将在第三段之后定义这些函数，因为它们提供了与第一、二、三段内容相关的额外细节：
- en: Note
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Notice that the node data test is written as if the AVL tree implementation
    already existed. It tries to import an `avl_tree` module containing an AVL class,
    and it tries to use the AVL class in specific ways. Of course, at the moment there
    is no `avl_tree` module, so the tests will fail. This is as it should be. All
    that the failure means is that, when the time comes to implement the tree, we
    should do so in a module called `avl_tree`, with contents that function as our
    tests assume. Part of the benefit of testing like this is being able to test-drive
    your code before you even write it.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，节点数据测试是按照AVL树实现已经存在的方式来编写的。它试图导入一个包含AVL类的`avl_tree`模块，并试图以特定的方式使用AVL类。当然，目前还没有`avl_tree`模块，所以测试将失败。这是应该的。失败只意味着，当真正到来实现树的时候，我们应该在名为`avl_tree`的模块中实现，其内容应该像我们的测试所假设的那样工作。这样测试的好处之一是能够在编写代码之前进行测试驱动。
- en: '[PRE15]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Notice that we didn't actually call these functions yet. They aren't tests,
    as such, but tools that we'll use to simplify writing tests. We define them here,
    rather than in the Python module that we're going to test, because they aren't
    conceptually part of the tested code, and because anyone who reads the tests will
    need to be able to see what the helper functions do.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们实际上还没有调用这些函数。它们不是测试，而是我们将用来简化编写测试的工具。我们在这里定义它们，而不是在我们要测试的Python模块中定义，因为它们在概念上不是测试代码的一部分，并且因为任何阅读测试的人都需要能够看到辅助函数的作用。
- en: Testing the constructor
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试构造函数
- en: 'The fourth paragraph describes the constructor of the AVL class. According
    to this paragraph, the constructor has two modes of operation: it can create a
    single initialized node, or it can create and initialize a whole tree of nodes
    based on the contents of a dictionary.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 第四段描述了AVL类的构造函数。根据这段描述，构造函数有两种操作模式：它可以创建一个初始化的单个节点，或者它可以基于字典的内容创建和初始化整个节点树。
- en: 'The test for the single node mode is easy. We''ll add it after the fourth paragraph:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 单节点模式的测试很简单。我们将在第四段之后添加它：
- en: '[PRE16]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We don't even have to write an expected result, since we wrote the function
    to raise an `AssertionError` if there's a problem and to return None if everything
    is fine. `AssertionError` is triggered by the `assert` statement in our test code,
    if the expression in the `assert` statement produces a false value.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至不需要编写预期结果，因为我们编写了函数，如果存在问题则抛出`AssertionError`，如果没有问题则返回`None`。`AssertionError`由测试代码中的`assert`语句触发，如果`assert`语句中的表达式产生一个假值。
- en: 'The test for the second mode looks just as easy, and we''ll add it right after
    the other:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种模式的测试看起来同样简单，我们将在其他测试之后添加它：
- en: '[PRE17]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: There's a bit of buried complexity here, though. In all probability, this constructor
    will function by initializing a single node and then using that node's `set` method
    to add the rest of the keys and values to the tree. This means that our second
    constructor test isn't a unit test, it's an integration test that checks the interaction
    of multiple units.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这里有一些隐藏的复杂性。几乎可以肯定，这个构造函数将通过初始化单个节点，然后使用该节点的`set`方法将剩余的键和值添加到树中来工作。这意味着我们的第二个构造函数测试不是一个单元测试，而是一个集成测试，它检查多个单元之间的交互。
- en: Specification documents often contains integration-level and system-level tests,
    so this isn't really a problem. It's something to be aware of, though, because
    if this test fails it won't necessarily show you where the problem really lies.
    Your unit tests will do that.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 规范文档通常包含集成级和系统级测试，所以这并不是真正的问题。然而，需要注意的是，如果这个测试失败，它并不一定会显示问题真正所在的地方。你的单元测试会做到这一点。
- en: Something else to notice is that we didn't check whether the constructor fails
    appropriately when given bad inputs. These tests are very important, but the English
    specification didn't mention these points at all, which means that they're not
    really among the acceptance criteria. We'll add these tests to the unit test suite
    instead.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 另一点需要注意是，我们没有检查构造函数在接收到不良输入时是否失败。这些测试非常重要，但英文规范完全没有提到这些点，这意味着它们实际上并不在验收标准中。我们将把这些测试添加到单元测试套件中。
- en: Recalculating height
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重新计算高度
- en: The `recalculate_height()` method is described in the fifth paragraph of the
    specification. To test it, we're going to need a tree for it to operate on, and
    we don't want to use the second mode of the constructor to create it —after all,
    we want this test to be independent of any errors that might exist there. We'd
    really prefer to make the test entirely independent of the constructor but, in
    this case, we need to make a small exception to the rule, since it's mighty difficult
    to create an object without calling its constructor in some way.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`recalculate_height()` 方法在规范的第五段中描述。为了测试它，我们需要一个树来操作，我们不想使用构造函数的第二种模式来创建它——毕竟，我们希望这个测试独立于可能存在的任何错误。我们真的希望使测试完全独立于构造函数，但在这个情况下，我们需要对规则做出一个小小的例外，因为不通过某种方式调用构造函数就创建一个对象是非常困难的。'
- en: 'What we''re going to do is define a function that builds a specific tree and
    returns it. This function will be useful in several of our later tests as well:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要定义一个函数，该函数构建一个特定的树并返回它。这个函数将在我们之后的几个测试中也很有用：
- en: '[PRE18]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now that we have the `make_test_tree()` function, testing `recalculate_height()`
    is easy:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了 `make_test_tree()` 函数，测试 `recalculate_height()` 就变得简单了：
- en: '[PRE19]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Making a node deletable
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使节点可删除
- en: The sixth paragraph of the specification described the `make_deletable()` method.
    You can't delete a node that has children, because that would leave the node's
    children disconnected from the rest of the tree. Consider the tree with animal
    names in it that we looked at earlier. If we delete the `Elephant` node from the
    bottom of the tree, what do we do about `Aardvark`, `Goose`, and `Frog`? If we
    delete `Goose`, how do we find `Frog` afterwards?
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 规范的第六段描述了 `make_deletable()` 方法。你不能删除有子节点的节点，因为这会使节点的小孩与树的其他部分断开连接。考虑一下我们之前看过的包含动物名称的树。如果我们从树的底部删除
    `Elephant` 节点，我们该如何处理 `Aardvark`、`Goose` 和 `Frog`？如果我们删除 `Goose`，我们之后如何找到 `Frog`？
- en: '![Making a node deletable](img/3211OS_02_05.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![使节点可删除](img/3211OS_02_05.jpg)'
- en: The way around that is to have the node swap places with its largest leaf descendant
    on the left side (or its smallest leaf descendant on the right side, but we're
    not doing it that way).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的方法是将节点与其左侧最大的叶节点后裔（或右侧最小的叶节点后裔，但我们不是那样做的）交换位置。
- en: 'We''ll test this by using the same `make_test_tree()` function that we defined
    earlier to create a new tree to work on, and then check whether `make_deletable()`
    swaps correctly:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过使用之前定义的相同 `make_test_tree()` 函数来创建一个新的树进行工作，并检查 `make_deletable()` 是否正确交换：
- en: '[PRE20]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Rotation
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 旋转
- en: The two rotate functions, described in paragraph seven of the specification,
    perform a somewhat tricky manipulation of the links in a tree. You probably found
    the plain language description of what they do a bit confusing. This is one of
    those times when a little bit of code makes a whole lot more sense than any number
    of sentences.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 规范第七段中描述的两个旋转函数对树中的链接进行了一些复杂的操作。你可能发现他们对所做操作的简单语言描述有点令人困惑。在这些时候，一点点的代码比任何数量的句子都要有意义得多。
- en: 'While tree rotation is usually defined in terms of rearranging the links between
    nodes in the tree, we''ll check whether it worked by looking at the values rather
    than by looking directly at the left and right links. This allows the implementation
    to swap the contents of nodes, rather than the nodes themselves, when it wishes.
    After all, it''s not important to the specification which operation happens, so
    we shouldn''t rule out a perfectly reasonable implementation choice:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 当前的树旋转通常是通过重新排列树中节点之间的链接来定义的，但我们将通过查看值而不是直接查看左右链接来检查它是否工作。这允许实现根据需要交换节点的内容，而不是节点本身。毕竟，对于规范来说，哪个操作发生并不重要，所以我们不应该排除一个完全合理的实现选择：
- en: '[PRE21]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Locating a node
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定位一个节点
- en: 'According to the eighth paragraph of the specification, the `locate()` method
    is expected to return a node, or raise a `KeyError` exception, depending on whether
    the key exists in the tree or not. We''ll use our specially built testing tree
    again, so that we know exactly what the tree''s structure looks like:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 根据规范的第8段，`locate()`方法预期返回一个节点，或者在键存在于树中时抛出`KeyError`异常。我们将再次使用我们专门构建的测试树，以便我们确切地知道树的结构如下：
- en: '[PRE22]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Tip
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Downloading the example code**'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从您在[http://www.packtpub.com](http://www.packtpub.com)的账户中下载您购买的所有Packt书籍的示例代码文件。如果您在其他地方购买了这本书，您可以访问[http://www.packtpub.com/support](http://www.packtpub.com/support)并注册，以便将文件直接通过电子邮件发送给您。
- en: The rest of the specification
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 规范的其余部分
- en: 'The remaining paragraphs of the specification describe higher-level functions
    that operate by calling the already described functions. This means that, until
    we learn the tricks of mock objects in [Chapter 4](ch04.html "Chapter 4. Decoupling
    Units with unittest.mock"), *Decoupling Units with unittest.mock*, we''re stuck
    with writing integration-level tests here. As I mentioned earlier, this is not
    a terrible thing to do in a specification document, so we''ll go ahead and do
    it:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 规范的剩余段落描述了通过调用已描述的函数来操作的高级函数。这意味着，在我们学习到[第4章](ch04.html "第4章。使用unittest.mock解耦单元")中模拟对象的技巧之前，我们在这里将不得不编写集成级别的测试。正如我之前提到的，在规范文档中这样做并不是什么坏事，所以我们将继续这样做：
- en: '[PRE23]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Summary
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We learned the syntax of `doctest`, and went through several examples describing
    how to use it. After that, we took a real-world specification for the AVL tree,
    and examined how to formalize it as a set of doctests, so that we could use it
    to automatically check the correctness of an implementation.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了`doctest`的语法，并探讨了几个示例，描述了如何使用它。之后，我们取了一个AVL树的现实世界规范，并检查了如何将其形式化为一系列doctests，以便我们可以用它来自动检查实现的正确性。
- en: Specifically, we covered doctest's default syntax and the directives that alter
    it, how to write doctests in text files, how to write doctests in Python docstrings,
    and what it feels like to use `doctest` to turn a specification into tests.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，我们涵盖了doctest的默认语法以及改变它的指令，如何在文本文件中编写doctests，如何在Python文档字符串中编写doctests，以及使用`doctest`将规范转换为测试的感觉。
- en: Now that we've learned about `doctest`, we're ready to talk about how to use
    `doctest` to do unit testing—the topic of the next chapter.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了`doctest`，我们就可以讨论如何使用`doctest`来进行单元测试——这是下一章的主题。
