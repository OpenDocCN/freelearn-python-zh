- en: Chapter 2. Working with doctest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first testing tool we're going to look at is called `doctest`. The name
    is short for "document testing" or perhaps a "testable document". Either way,
    it's a literate tool designed to make it easy to write tests in such a way that
    computers and humans both benefit from them. Ideally, `doctest` tests both, informs
    human readers, and tells the computer what to expect.
  prefs: []
  type: TYPE_NORMAL
- en: 'Mixing tests and documentation helps us:'
  prefs: []
  type: TYPE_NORMAL
- en: Keeps the documentation up-to-date with reality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make sure that the tests express the intended behavior
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reuse some of the efforts involved in the documentation and test creation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Where doctest performs best
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The design decisions that went into `doctest` make it particularly well suited
    to writing acceptance tests at the integration and system testing levels. This
    is because `doctest` mixes human-only text with examples that both humans and
    computers can read. This structure doesn't support or enforce any of the formalizations
    of testing, but it conveys information beautifully and it still provides the computer
    with the ability to say *that works* or *that doesn't work*. As an added bonus,
    it is about the easiest way to write tests you'll ever see.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, a `doctest` file is a truly excellent program specification
    that you can have the computer check against your actual code any time you want.
    API documentation also benefits from being written as doctests and checked alongside
    your other tests. You can even include doctests in your docstrings.
  prefs: []
  type: TYPE_NORMAL
- en: The basic idea you should be getting from all this is that `doctest` is ideal
    for uses where humans and computers will both benefit from reading them.
  prefs: []
  type: TYPE_NORMAL
- en: The doctest language
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like program source code, `doctest` tests are written in plain text. The `doctest`
    module extracts the tests and ignores the rest of the text, which means that the
    tests can be embedded in human-readable explanations or discussions. This is the
    feature that makes `doctest` suitable for uses such as program specifications.
  prefs: []
  type: TYPE_NORMAL
- en: Example – creating and running a simple doctest
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are going to create a simple `doctest` file, to show the fundamentals of
    using the tool. Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open a new text file in your editor, and name it `test.txt`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Insert the following text into the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can now run the `doctest`. At the command prompt, change to the directory
    where you saved `test.txt`. Type the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When the test is run, you should see output like this:![Example – creating and
    running a simple doctest](img/3211OS_02_01.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Result – three times three does not equal ten
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You just wrote a `doctest` file that describes a couple of arithmetic operations,
    and ran it to check whether Python behaved as the tests said it should. You ran
    the tests by telling Python to execute `doctest` on the file containing the tests.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, Python's behavior differed from the tests because, according to
    the tests, three times three equals ten. However, Python disagrees on that. As
    `doctest` expected one thing and Python did something different, `doctest` presented
    you with a nice little error report showing where to find the failed test, and
    how the actual result differed from the expected result. At the bottom of the
    report is a summary showing how many tests failed in each file tested, which is
    helpful when you have more than one file containing tests.
  prefs: []
  type: TYPE_NORMAL
- en: The syntax of doctests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You might have already figured it out from looking at the previous example:
    `doctest` recognizes tests by looking for sections of text that look like they''ve
    been copied and pasted from a Python interactive session. Anything that can be
    expressed in Python is valid within a `doctest`.'
  prefs: []
  type: TYPE_NORMAL
- en: Lines that start with a `>>>` prompt are sent to a Python interpreter. Lines
    that start with a `...` prompt are sent as continuations of the code from the
    previous line, allowing you to embed complex block statements into your doctests.
    Finally, any lines that don't start with `>>>` or `...`, up to the next blank
    line or `>>>` prompt, represent the output expected from the statement. The output
    appears as it would in an interactive Python session, including both the return
    value and anything printed to the console. If you don't have any output lines,
    `doctest` assumes it to mean that the statement is expected to have no visible
    result on the console, which usually means that it returns None.
  prefs: []
  type: TYPE_NORMAL
- en: The `doctest` module ignores anything in the file that isn't part of a test,
    which means that you can put explanatory text, HTML, line-art diagrams, or whatever
    else strikes your fancy in between your tests. We took advantage of this in the
    previous `doctest` to add an explanatory sentence before the test itself.
  prefs: []
  type: TYPE_NORMAL
- en: Example – a more complex test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Add the following code to your `test.txt` file, separated from the existing
    code by at least one blank line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Now take a moment to consider before running the test. Will it pass or fail?
    Should it pass or fail?
  prefs: []
  type: TYPE_NORMAL
- en: Result – five tests run
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Just as we discussed before, run the test using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see a result like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Result – five tests run](img/3211OS_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Because we added the new tests to the same file containing the tests from before,
    we still see the notification that three times three does not equal 10\. Now,
    though, we also see that five tests were run, which means our new tests ran and
    were successful.
  prefs: []
  type: TYPE_NORMAL
- en: 'Why five tests? As far as `doctest` is concerned, we added the following three
    tests to the file:'
  prefs: []
  type: TYPE_NORMAL
- en: The first one says that, when we `import sys`, nothing visible should happen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second test says that, when we define the `test_write` function, nothing
    visible should happen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third test says that, when we call the `test_write` function, `Hello` and
    `True` should appear on the console, in that order, on separate lines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since all three of these tests pass, `doctest` doesn't bother to say much about
    them. All it did was increase the number of tests reported at the bottom from
    two to five.
  prefs: []
  type: TYPE_NORMAL
- en: Expecting exceptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'That''s all well and good for testing that things work as expected, but it
    is just as important to make sure that things fail when they''re supposed to fail.
    Put another way: sometimes your code is supposed to raise an exception, and you
    need to be able to write tests that check that behavior as well.'
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, `doctest` follows nearly the same principle in dealing with exceptions
    as it does with everything else; it looks for text that looks like a Python interactive
    session. This means it looks for text that looks like a Python exception report
    and traceback, and matches it against any exception that gets raised.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `doctest` module does handle exceptions a little differently from the way
    it handles other things. It doesn''t just match the text precisely and report
    a failure if it doesn''t match. Exception tracebacks tend to contain many details
    that are not relevant to the test, but that can change unexpectedly. The `doctest`
    module deals with this by ignoring the traceback entirely: it''s only concerned
    with the first line, `Traceback (most recent call last):`, which tells it that
    you expect an exception, and the part after the traceback, which tells it which
    exception you expect. The `doctest` module only reports a failure if one of these
    parts does not match.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is helpful for a second reason as well: manually figuring out what the
    traceback will look like, when you''re writing your tests, would require a significant
    amount of effort and would gain you nothing. It''s better to simply omit them.'
  prefs: []
  type: TYPE_NORMAL
- en: Example – checking for an exception
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is yet another test that you can add to `test.txt`, this time testing some
    code that ought to raise an exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'Insert the following text into your `doctest` file, as always separated by
    at least one blank line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The test is supposed to raise an exception, so it will fail if it doesn''t
    raise the exception or if it raises the wrong exception. Make sure that you have
    your mind wrapped around this: if the test code executes successfully, the test
    fails, because it expected an exception.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the tests using the following doctest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Result – success at failing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The code contains a syntax error, which means this raises a `SyntaxError` exception,
    which in turn means that the example behaves as expected; this signifies that
    the test passes.
  prefs: []
  type: TYPE_NORMAL
- en: '![Result – success at failing](img/3211OS_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When dealing with exceptions, it is often desirable to be able to use a wildcard
    matching mechanism. The `doctest` provides this facility through its ellipsis
    directive that we'll discuss shortly.
  prefs: []
  type: TYPE_NORMAL
- en: Expecting blank lines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `doctest` uses the first blank line after `>>>` to identify the end of the
    expected output, so what do you do when the expected output actually contains
    a blank line?
  prefs: []
  type: TYPE_NORMAL
- en: The `doctest` handles this situation by matching a line that contains only the
    text `<BLANKLINE>` in the expected output with a real blank line in the actual
    output.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling doctest behavior with directives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, the default behavior of `doctest` makes writing a particular test
    inconvenient. For example, `doctest` might look at a trivial difference between
    the expected and real outputs and wrongly conclude that the test has failed. This
    is where `doctest` directives come to the rescue. Directives are specially formatted
    comments that you can place after the source code of a test and that tell `doctest`
    to alter its default behavior in some way.
  prefs: []
  type: TYPE_NORMAL
- en: A directive comment begins with `# doctest:`, after which comes a comma-separated
    list of options that either enable or disable various behaviors. To enable a behavior,
    write a `+` (plus symbol) followed by the behavior name. To disable a behavior,
    white a `–` (minus symbol) followed by the behavior name. We'll take a look at
    the several directives in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Ignoring part of the result
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's fairly common that only part of the output of a test is actually relevant
    to determining whether the test passes. By using the `+ELLIPSIS` directive, you
    can make `doctest` treat the text `...` (called an ellipsis) in the expected output
    as a wildcard that will match any text in the output.
  prefs: []
  type: TYPE_NORMAL
- en: When you use an ellipsis, `doctest` will scan until it finds text matching whatever
    comes after the ellipsis in the expected output, and continue matching from there.
    This can lead to surprising results such as an ellipsis matching against a 0-length
    section of the actual output, or against multiple lines. For this reason, it needs
    to be used thoughtfully.
  prefs: []
  type: TYPE_NORMAL
- en: Example – ellipsis test drive
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We're going to use the ellipsis in a few different tests to better get a feel
    of how it works. As an added bonus, these tests also show the use of `doctest`
    directives.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your `test.txt` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Result – ellipsis elides
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The tests all pass, where they would all fail without the ellipsis. The first
    and last tests, in which we checked for the presence of a specific module in `sys.modules`
    and confirmed a specific formatting while ignoring the contents of a string, demonstrate
    the kind of situation where ellipsis is really useful, because it lets you focus
    on the part of the output that is meaningful and ignore the rest of the test.
    The middle tests demonstrate how different outputs can match the same expected
    result when ellipsis is in play.
  prefs: []
  type: TYPE_NORMAL
- en: Look at the last test. Can you imagine any output that wasn't an ISO-formatted
    time stamp, but that would match the example anyway? Remember that the ellipsis
    can match any amount of text.
  prefs: []
  type: TYPE_NORMAL
- en: Ignoring white space
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, white space (spaces, tabs, newlines, and their ilk) is more trouble
    than it's worth. Maybe you want to be able to break a single line of expected
    output across several lines in your test file, or maybe you're testing a system
    that uses lots of white space but doesn't convey any useful information with it.
  prefs: []
  type: TYPE_NORMAL
- en: The `doctest` gives you a way to "normalize" white space, turning any sequence
    of white space characters, in both the expected output and in the actual output,
    into a single space. It then checks whether these normalized versions match.
  prefs: []
  type: TYPE_NORMAL
- en: Example – invoking normality
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We're going to write a couple of tests that demonstrate how whitespace normalization
    works.
  prefs: []
  type: TYPE_NORMAL
- en: 'Insert the following code into your `doctest` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Result – white space matches any other white space
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Both of these tests pass, in spite of the fact that the result of the first
    one has been wrapped across multiple lines to make it easy for humans to read,
    and the result of the second one has had its strange newlines and indentations
    left out, also for human convenience.
  prefs: []
  type: TYPE_NORMAL
- en: Notice how one of the tests inserts extra whitespace in the expected output,
    while the other one ignores extra whitespace in the actual output? When you use
    `+NORMALIZE_WHITESPACE`, you gain a lot of flexibility with regard to how things
    are formatted in the text file.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You may have noted the value `39` on the last line of the last example. Why
    is that there? It's because the `write()` method returns the number of bytes that
    were written, which in this case happens to be `39`. If you're trying this example
    in an environment that maps ASCII characters to more than one byte, you will see
    a different number here; this will cause the test to fail until you change the
    expected number of bytes.
  prefs: []
  type: TYPE_NORMAL
- en: Skipping an example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: On some occasions, `doctest` will recognize some text as an example to be checked,
    when in truth you want it to be simply text. This situation is rarer than it might
    at first seem, because usually there's no harm in letting `doctest` check everything
    it can. In fact, usually it's very helpful to have `doctest` check everything
    it can. For those times when you want to limit what `doctest` checks, though,
    there's the `+SKIP` directive.
  prefs: []
  type: TYPE_NORMAL
- en: Example – humans only
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Append the following code to your doctest file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Result – it looks like a test, but it's not
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we added this last example to the file, `doctest` reported thirteen tests
    when we ran the file through it. After adding this code, `doctest` still reports
    thirteen tests. Adding the skip directive to the code completely removed it from
    consideration by doctest. It's not a test that passes, nor a test that fails.
    It's not a test at all.
  prefs: []
  type: TYPE_NORMAL
- en: The other directives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a number of other directives that can be issued to doctest, should
    you find the need. They're not as broadly useful as the ones already mentioned,
    but the time might come when you require one or more of them.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The full documentation for all of the doctest directives can be found at [http://docs.python.org/3/library/doctest.html#doctest-options](http://docs.python.org/3/library/doctest.html#doctest-options).
  prefs: []
  type: TYPE_NORMAL
- en: 'The remaining directives of `doctest` in the Python 3.4 version are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`DONT_ACCEPT_TRUE_FOR_1`: This makes `doctest` differentiate between boolean
    values and numbers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DONT_ACCEPT_BLANKLINE`: This removes support for the <BLANKLINE> feature'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IGNORE_EXCEPTION_DETAIL`: This makes `doctest` only care that an exception
    is of the expected type'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Strictly speaking, `doctest` supports several other options that can be set
    using the directive syntax, but they don't make any sense as directives, so we'll
    ignore them here.
  prefs: []
  type: TYPE_NORMAL
- en: The execution scope of doctest tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When `doctest` is running the tests from text files, all the tests from the
    same file are run in the same execution scope. This means that, if you import
    a module or bind a variable in one test, that module or variable is still available
    in later tests. We took advantage of this fact several times in the tests written
    so far in this chapter: the `sys` module was only imported once, for example,
    although it was used in several tests.'
  prefs: []
  type: TYPE_NORMAL
- en: This behavior is not necessarily beneficial, because tests need to be isolated
    from each other. We don't want them to contaminate each other because, if a test
    depends on something that another test does, or if it fails because of something
    that another test does, these two tests are in some sense combined into one test
    that covers a larger section of your code. You don't want that to happen, because
    then knowing which test has failed doesn't give you as much information about
    what went wrong and where it happened.
  prefs: []
  type: TYPE_NORMAL
- en: So, how can we give each test its own execution scope? There are a few ways
    to do it. One would be to simply place each test in its own file, along with whatever
    explanatory text that is needed. This works well in terms of functionality, but
    running the tests can be a pain unless you have a tool to find and run all of
    them for you. We'll talk about one such tool (called Nose) in a later chapter.
    Another problem with this approach is that this breaks the idea that the tests
    contribute to a human-readable document.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way to give each test its own execution scope is to define each test
    within a function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: By doing this, the only thing that ends up in the shared scope is the test function
    (named `test1` here). The `frob` module and any other names bound inside the function
    are isolated with the caveat that things that happen inside imported modules are
    not isolated. If the `frob.hash()` method changes a state inside the `frob` module,
    that state will still be changed if a different test imports the `frob` module
    again.
  prefs: []
  type: TYPE_NORMAL
- en: The third way is to exercise caution with the names you create, and be sure
    to set them to known values at the beginning of each test section. In many ways
    this is the easiest approach, but this is also the one that places the most burden
    on you, because you have to keep track of what's in the scope.
  prefs: []
  type: TYPE_NORMAL
- en: Why does `doctest` behave in this way, instead of isolating tests from each
    other? The `doctest` files are intended not just for computers to read, but also
    for humans. They often form a sort of narrative, flowing from one thing to the
    next. It would break the narrative to be constantly repeating what came before.
    In other words, this approach is a compromise between being a document and being
    a test framework, a middle ground that works for both humans and computers.
  prefs: []
  type: TYPE_NORMAL
- en: The other framework that we will study in depth in this book (called simply
    `unittest`) works at a more formal level, and enforces the separation between
    tests.
  prefs: []
  type: TYPE_NORMAL
- en: Check your understanding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once you''ve decided on your answers to these questions, check them by writing
    a test document and running it through `doctest`:'
  prefs: []
  type: TYPE_NORMAL
- en: How does `doctest` recognize the beginning of a test in a document?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How does `doctest` know when a test continues to further lines?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How does `doctest` recognize the beginning and end of the expected output of
    a test?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How would you tell `doctest` that you want to break the expected output across
    several lines, even though that's not how the test actually outputs it?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Which parts of an exception report are ignored by `doctest`?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you assign a variable in a test file, which parts of the file can actually
    *see* that variable?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why do we care what code can *see* the variables created by a test?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can we make `doctest` not care what a section of output contains?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exercise – English to doctest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Time to stretch your wings a bit. I'm going to give you a description of a single
    function in English. Your job is to copy the description into a new text file,
    and then add tests that describe all the requirements in a way that the computer
    can understand and check.
  prefs: []
  type: TYPE_NORMAL
- en: Try to make the doctests so that they're not just for the computer. Good doctests
    tend to clarify things for human readers as well. By and large, this means that
    you present them to human readers as examples interspersed with the text.
  prefs: []
  type: TYPE_NORMAL
- en: 'Without further ado, here is the English description:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: I'll give you a hint and point out that the last sentence about the function
    being slow, isn't really testable. As computers get faster, any test you write
    that depends on an arbitrary definition of "slow" will eventually fail. Also,
    there's no good way to test the difference between a slow function and a function
    stuck in an infinite loop, so there's not much point in trying. If you find yourself
    needing to do that, it's best to back off and try a different solution.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Not being able to tell whether a function is stuck or just slow is called the
    halting problem by computer scientists. We know that it can't be solved unless
    we someday discover a fundamentally better kind of computer. Faster computers
    won't do the trick, and neither will quantum computers, so don't hold your breath.
  prefs: []
  type: TYPE_NORMAL
- en: The next-to-last sentence also provides some difficulty, since to test it completely
    would require running every positive integer through the `fib()` function, which
    would take forever (except that the computer will eventually run out of memory
    and force Python to raise an exception). How do we deal with this sort of thing,
    then?
  prefs: []
  type: TYPE_NORMAL
- en: The best solution is to check whether the condition holds true for a random
    sample of viable inputs. The `random.randrange()` and `random.choice()` functions
    in the Python standard library make that fairly easy to do.
  prefs: []
  type: TYPE_NORMAL
- en: Embedding doctests into docstrings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's just as easy to write doctests into docstrings as it is to write them into
    documentation files.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For those who don't know, docstrings are a Python feature that allows programmers
    to embed documentation directly into their source code. The Python `help()` function
    is powered by docstrings. To learn more about docstrings, you can start with the
    Python tutorial section at [https://docs.python.org/3/tutorial/controlflow.html#documentation-strings](https://docs.python.org/3/tutorial/controlflow.html#documentation-strings).
  prefs: []
  type: TYPE_NORMAL
- en: When written in docstrings, doctests serve a slightly different purpose. They
    still let the computer check that things work as expected, but the humans who
    see them will most often be coders who use the Python interactive shell to work
    on an idea before committing it to code, or whose text editor pops up docstrings
    as they work. In that context, the most important thing a `doctest` can do is
    be informative, so docstrings aren't usually a good place for checking picky details.
    They're a great place for a `doctest` to demonstrate the proper behavior of a
    common case, though.
  prefs: []
  type: TYPE_NORMAL
- en: The doctests embedded in docstrings have a somewhat different execution scope
    than doctests in text files do. Instead of having a single scope for all of the
    tests in the file, `doctest` creates a single scope for each docstring. All of
    the tests that share a docstring also share an execution scope, but they're isolated
    from tests in the other docstrings.
  prefs: []
  type: TYPE_NORMAL
- en: The separation of each docstring into its own execution scope often means that
    we don't need to put much thought into isolating doctests when they're embedded
    in docstrings. This is fortunate, since docstrings are primarily intended for
    documentation, and the tricks required to isolate the tests might obscure the
    meaning.
  prefs: []
  type: TYPE_NORMAL
- en: Example – a doctest in a docstring
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We're going to embed a test right inside the Python source file that it tests,
    by placing it inside a docstring.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file called `test.py` containing the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Notice the use of a raw string for the docstring (denoted by the `r` character
    before the first triple quote). Using raw strings for your docstrings is a good
    habit to get into, because you usually don't want escape sequences—for example,
    `\n` for newline— to be interpreted by the Python interpreter. You want them to
    be treated as text, so that they are correctly passed on to doctest.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running these tests is just as easy as running the tests in a doctest document:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Since all the tests pass, the output of this command is nothing at all. We
    can make it more interesting by adding the verbose flag to the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Result – the code is now self-documenting and self-testable
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When we run the Python file through `doctest` with the verbose flag, we see
    the output, as shown in the the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Result – the code is now self-documenting and self-testable](img/3211OS_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We put the `doctest` code right inside the docstring of the function it was
    testing. This is a good place for tests that also show a programmer how to do
    something. It's not a good place for detailed, low-level tests (the `doctest`
    in the docstring example code, which was quite detailed for illustrative purposes,
    is perhaps too detailed), because docstrings need to serve as API documentation—you
    can see the reason for this just by looking at the example, where the doctests
    take up most of the room in the docstring without telling the readers any more
    than they would have learned from a single test.
  prefs: []
  type: TYPE_NORMAL
- en: Any test that will serve as good API documentation is a good candidate for including
    in the docstrings of a Python file.
  prefs: []
  type: TYPE_NORMAL
- en: You might be wondering about the line that reads `1 items had no tests`, and
    the following line that just reads `test`. These lines are referring to the fact
    that there are no tests written in the module-level docstring. That's a little
    surprising, since we didn't include such a docstring in our source code at all,
    until you realize that, as far as Python (and thus `doctest`) is concerned, no
    docstring is the same as an empty docstring.
  prefs: []
  type: TYPE_NORMAL
- en: Putting it into practice – an AVL tree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We're going to walk step-by-step through the process of using `doctest` to create
    a testable specification for a data structure called an AVL tree. An AVL tree
    is a way to organize key-value pairs so that they can be quickly located by key.
    In other words, it's a lot like Python's built-in dictionary type. The name AVL
    references the initials of the people who invented this data structure.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While AVL trees are similar to Python dictionaries, they have some significantly
    different properties. For one thing, the keys stored in an AVL tree can be iterated
    over in a sorted order with no overhead. Another difference is that, while inserting
    and removing objects in an AVL tree is slower than a Python `dict` in many cases,
    it's faster in the worst case.
  prefs: []
  type: TYPE_NORMAL
- en: As its name suggests, an AVL tree organizes the keys that are stored in it into
    a tree structure, with each key having up to two child keys —one child key that
    is less than the parent key by comparison, and one that is more. In the following
    figure, the `Elephant` key has two child keys, `Goose` has one, and `Aardvark`
    and `Frog` both have none.
  prefs: []
  type: TYPE_NORMAL
- en: 'The AVL tree is special because it keeps one side of the tree from getting
    much taller than the other, which means that users can expect it to perform reliably
    and efficiently no matter what. In the following figure, the AVL tree will reorganize
    to stay balanced if `Frog` gains a child:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Putting it into practice – an AVL tree](img/3211OS_02_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We're going to write tests for an AVL tree implementation here, rather than
    writing the implementation itself, so we're going to gloss over the details of
    *how* an AVL tree works, in favor of looking at what it should do when it works
    right.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you want to know more about AVL trees, you will find many good references
    on the Internet. Wikipedia''s entry on this subject is a good place to start with:
    [http://en.wikipedia.org/wiki/AVL_tree](http://en.wikipedia.org/wiki/AVL_tree).'
  prefs: []
  type: TYPE_NORMAL
- en: We're going to start with a plain-language specification, and then interject
    tests between the paragraphs. You don't have to actually type all of this into
    a text file; it is here for you to read and to think about.
  prefs: []
  type: TYPE_NORMAL
- en: English specification
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first step is to describe what the desired result should be, in normal language.
    This might be something that you do for yourself, or it might be something that
    somebody else does for you. If you're working for somebody, hopefully you and
    your employer can sit down together and work this part out.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, there's not much to work out, because AVL trees have been fully
    described for decades. Even so, the description here isn't quite like the one
    you'd find elsewhere. This capacity for ambiguity is exactly the reason why a
    plain-language specification isn't good enough. We need an unambiguous specification,
    and that's exactly what the tests in a doctest file can give us.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following text goes in a file called `AVL.txt`, (that you can find in its
    final form in the accompanying code archive; at this stage of the process, the
    file contains only the normal language specification):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Node data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first three paragraphs of the specification describe the member variables
    of an AVL tree node, and tell us what the valid values for the variables are.
    They also tell us how the tree height should be measured and define what a balanced
    tree means. It's our job now to take these ideas, and encode them into tests that
    the computer can eventually use to check our code.
  prefs: []
  type: TYPE_NORMAL
- en: We can check these specifications by creating a node and then testing the values,
    but that would really just be a test of the constructor. It's important to test
    the constructor, but what we really want to do is to incorporate checks that the
    node variables are left in a valid state into our tests of each member function.
  prefs: []
  type: TYPE_NORMAL
- en: 'To that end, we''ll define functions that our tests can call to check that
    the state of a node is valid. We''ll define these functions just after the third
    paragraph, because they provide extra details related to the content of the first
    three paragraphs:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Notice that the node data test is written as if the AVL tree implementation
    already existed. It tries to import an `avl_tree` module containing an AVL class,
    and it tries to use the AVL class in specific ways. Of course, at the moment there
    is no `avl_tree` module, so the tests will fail. This is as it should be. All
    that the failure means is that, when the time comes to implement the tree, we
    should do so in a module called `avl_tree`, with contents that function as our
    tests assume. Part of the benefit of testing like this is being able to test-drive
    your code before you even write it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we didn't actually call these functions yet. They aren't tests,
    as such, but tools that we'll use to simplify writing tests. We define them here,
    rather than in the Python module that we're going to test, because they aren't
    conceptually part of the tested code, and because anyone who reads the tests will
    need to be able to see what the helper functions do.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the constructor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The fourth paragraph describes the constructor of the AVL class. According
    to this paragraph, the constructor has two modes of operation: it can create a
    single initialized node, or it can create and initialize a whole tree of nodes
    based on the contents of a dictionary.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The test for the single node mode is easy. We''ll add it after the fourth paragraph:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We don't even have to write an expected result, since we wrote the function
    to raise an `AssertionError` if there's a problem and to return None if everything
    is fine. `AssertionError` is triggered by the `assert` statement in our test code,
    if the expression in the `assert` statement produces a false value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The test for the second mode looks just as easy, and we''ll add it right after
    the other:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: There's a bit of buried complexity here, though. In all probability, this constructor
    will function by initializing a single node and then using that node's `set` method
    to add the rest of the keys and values to the tree. This means that our second
    constructor test isn't a unit test, it's an integration test that checks the interaction
    of multiple units.
  prefs: []
  type: TYPE_NORMAL
- en: Specification documents often contains integration-level and system-level tests,
    so this isn't really a problem. It's something to be aware of, though, because
    if this test fails it won't necessarily show you where the problem really lies.
    Your unit tests will do that.
  prefs: []
  type: TYPE_NORMAL
- en: Something else to notice is that we didn't check whether the constructor fails
    appropriately when given bad inputs. These tests are very important, but the English
    specification didn't mention these points at all, which means that they're not
    really among the acceptance criteria. We'll add these tests to the unit test suite
    instead.
  prefs: []
  type: TYPE_NORMAL
- en: Recalculating height
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `recalculate_height()` method is described in the fifth paragraph of the
    specification. To test it, we're going to need a tree for it to operate on, and
    we don't want to use the second mode of the constructor to create it —after all,
    we want this test to be independent of any errors that might exist there. We'd
    really prefer to make the test entirely independent of the constructor but, in
    this case, we need to make a small exception to the rule, since it's mighty difficult
    to create an object without calling its constructor in some way.
  prefs: []
  type: TYPE_NORMAL
- en: 'What we''re going to do is define a function that builds a specific tree and
    returns it. This function will be useful in several of our later tests as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have the `make_test_tree()` function, testing `recalculate_height()`
    is easy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Making a node deletable
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The sixth paragraph of the specification described the `make_deletable()` method.
    You can't delete a node that has children, because that would leave the node's
    children disconnected from the rest of the tree. Consider the tree with animal
    names in it that we looked at earlier. If we delete the `Elephant` node from the
    bottom of the tree, what do we do about `Aardvark`, `Goose`, and `Frog`? If we
    delete `Goose`, how do we find `Frog` afterwards?
  prefs: []
  type: TYPE_NORMAL
- en: '![Making a node deletable](img/3211OS_02_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The way around that is to have the node swap places with its largest leaf descendant
    on the left side (or its smallest leaf descendant on the right side, but we're
    not doing it that way).
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll test this by using the same `make_test_tree()` function that we defined
    earlier to create a new tree to work on, and then check whether `make_deletable()`
    swaps correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Rotation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The two rotate functions, described in paragraph seven of the specification,
    perform a somewhat tricky manipulation of the links in a tree. You probably found
    the plain language description of what they do a bit confusing. This is one of
    those times when a little bit of code makes a whole lot more sense than any number
    of sentences.
  prefs: []
  type: TYPE_NORMAL
- en: 'While tree rotation is usually defined in terms of rearranging the links between
    nodes in the tree, we''ll check whether it worked by looking at the values rather
    than by looking directly at the left and right links. This allows the implementation
    to swap the contents of nodes, rather than the nodes themselves, when it wishes.
    After all, it''s not important to the specification which operation happens, so
    we shouldn''t rule out a perfectly reasonable implementation choice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Locating a node
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'According to the eighth paragraph of the specification, the `locate()` method
    is expected to return a node, or raise a `KeyError` exception, depending on whether
    the key exists in the tree or not. We''ll use our specially built testing tree
    again, so that we know exactly what the tree''s structure looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Downloading the example code**'
  prefs: []
  type: TYPE_NORMAL
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the specification
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The remaining paragraphs of the specification describe higher-level functions
    that operate by calling the already described functions. This means that, until
    we learn the tricks of mock objects in [Chapter 4](ch04.html "Chapter 4. Decoupling
    Units with unittest.mock"), *Decoupling Units with unittest.mock*, we''re stuck
    with writing integration-level tests here. As I mentioned earlier, this is not
    a terrible thing to do in a specification document, so we''ll go ahead and do
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We learned the syntax of `doctest`, and went through several examples describing
    how to use it. After that, we took a real-world specification for the AVL tree,
    and examined how to formalize it as a set of doctests, so that we could use it
    to automatically check the correctness of an implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Specifically, we covered doctest's default syntax and the directives that alter
    it, how to write doctests in text files, how to write doctests in Python docstrings,
    and what it feels like to use `doctest` to turn a specification into tests.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've learned about `doctest`, we're ready to talk about how to use
    `doctest` to do unit testing—the topic of the next chapter.
  prefs: []
  type: TYPE_NORMAL
