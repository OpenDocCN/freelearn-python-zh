["```py\n\nOperation        The stack as a Python list (bold is top of stack)\nPUSH A           stack = [x,x,x,x,x,x,x,A]\nPUSH B           stack = [x,x,x,x,x,x,B,A]\nADD              stack = [x,x,x,x,x,x,x,A+B]\nPUSH C           stack = [x,x,x,x,x,x,C,A+B]\nPUSH B           stack = [x,x,x,x,x,B,C,A+B]\nSUBTRACT         stack = [x,x,x,x,x,x,C-B,A+B]\nPUSH D           stack = [x,x,x,x,x,D,C-B,A+B]\nSUBTRACT         stack = [x,x,x,x,x,x,D-C-B,A+B]\nMULTIPLY         stack = [x,x,x,x,x,x,x,(D-C-B)(A+B)]\nPULL result      stack = [x,x,x,x,x,x,x,x]\n```", "```py\n\nsp = sp – 1       # Decrement the stack pointer. Point to the next free location above TOS\nstack[sp] = A     # Load the new value, A, on the stack in this location\n```", "```py\n\nA = stack[sp]     # Retrieve the item at the top of the stack\n```", "```py\nsp = sp + 1       # Move the stack pointer down\n```", "```py\n\ny1 = stack[sp]        # Retrieve the item at the top of the stack (y1 and y2 are on the stack)\nsp = sp + 1           # Move the stack pointer down\ny2 = stack[sp]        # Retrieve the item at the top of the stack\ny3 = y1 + y2          # Add the two values\nstack[sp] = y3        # Store the result on the stack\n```", "```py\n\n                                       # Stack machine simulator\nprog = [['push',0],['push',1],['add'],   ['push',2],['push',1],           \\\n        ['sub'],   ['push',3],['sub'],   ['mul'],   ['push',4],           \\\n        ['swap'],  ['dup'],['pull',4],   ['stop']]\nstack = [0] * 8                        # 8-location stack. Stack grows to lower addresses\nmem   = [3,2,7,4,6,0]                  # Data memory (first locations are preloaded 3, 2,7, 4, 6)\nrun = True                             # Execution continues while run is true\npc = 0                                 # Program counter - initialize\nsp = 8                                 # Initialize stack pointer to 1 past end of stack\nwhile run:                             # Execute MAIN LOOP until run is false (STOP command)\n    inst = prog[pc]                    # Read the next instruction\n    pc = pc + 1                        # Increment program counter\n    if   inst[0] == 'push':            # Test for push operation\n         sp = sp - 1                   # Pre-decrement stack pointer\n         address = int(inst[1])        # Get data from memory\n         stack[sp] = mem[address]      # Store it on the stack\n    elif inst[0] == 'pull':            # Test for a pull instruction\n         address = int(inst[1])        # Get destination address\n         mem[address] = stack[sp]      # Store the item in memory\n         sp = sp + 1                   # Increment stack pointer\n    elif inst[0] == 'add':             # If operation add TOS to NOS and push result\n         p = stack[sp]\n         sp = sp + 1\n         q = stack[sp]\n         stack[sp] = p + q\n    elif inst[0] == 'sub':             # sub\n         p = stack[sp]\n         sp = sp + 1\n         q = stack[sp]\n         stack[sp] = q - p\n    elif inst[0] == 'mul':             # mul\n         p = stack[sp]\n         sp = sp + 1\n         q = stack[sp]\n         stack[sp] = p * q\n    elif inst[0] == 'div':             # div (note floor division with integer result)\n         p = stack[sp]\n         sp = sp + 1\n         q = stack[sp]\n         stack[sp] = p//q\n    elif inst[0] == 'dup':             # dup (duplicate top item on stack)\n         p = stack[sp]                 # get current TOS\n         sp = sp - 1                   # and push it on the stack to duplicate\n         stack[sp] = p\n    elif inst[0] == 'swap':            # swap (exchange top of stack and next on stack)\n         p = stack[sp]\n         q = stack[sp+1]\n         stack[sp] = q\n         stack[sp+1]=p\n    elif inst[0] == 'stop':            # stop\n         run = False\n    if sp == 8: TOS = 'empty'          # Stack elements 0 to 7\\. Element 8 is before the TOS\n    else: TOS = stack[sp]\n    print('pc =', pc-1,'sp =',sp,'TOS =',TOS,'Stack',stack,'Mem',mem,'op',inst)\n```", "```py\n\npc=0 sp=7  TOS=3 Stack [0,0,0,0,0,0,0,3] Mem [3,2,7,4,6,0] op ['push',0]\npc=1 sp=6  TOS=2 Stack [0,0,0,0,0,0,2,3] Mem [3,2,7,4,6,0] op ['push',1]\npc=2 sp=7  TOS=5 Stack [0,0,0,0,0,0,2,5] Mem [3,2,7,4,6,0] op ['add']\npc=3 sp=6  TOS=7 Stack [0,0,0,0,0,0,7,5] Mem [3,2,7,4,6,0] op ['push',2]\npc=4 sp=5  TOS=2 Stack [0,0,0,0,0,2,7,5] Mem [3,2,7,4,6,0] op ['push',1]\npc=5 sp=6  TOS=5 Stack [0,0,0,0,0,2,5,5] Mem [3,2,7,4,6,0] op ['sub']\npc=6 sp=5  TOS=4 Stack [0,0,0,0,0,4,5,5] Mem [3,2,7,4,6,0] op ['push',3]\npc=7 sp=6  TOS=1 Stack [0,0,0,0,0,4,1,5] Mem [3,2,7,4,6,0] op ['sub']\npc=8 sp=7  TOS=5 Stack [0,0,0,0,0,4,1,5] Mem [3,2,7,4,6,0] op ['mul']\npc=9 sp=6  TOS=6 Stack [0,0,0,0,0,4,6,5] Mem [3,2,7,4,6,0] op ['push',4]\npc=10 sp=6 TOS=5 Stack [0,0,0,0,0,4,5,6] Mem [3,2,7,4,6,0] op ['swap']\npc=11 sp=5 TOS=5 Stack [0,0,0,0,0,5,5,6] Mem [3,2,7,4,6,0] op ['dup']\npc=12 sp=6 TOS=5 Stack [0,0,0,0,0,5,5,6] Mem [3,2,7,4,6,5] op ['pull',5]\n```", "```py\npc=13 sp=6 TOS=5 Stack [0,0,0,0,0,5,5,6] Mem [3,2,7,4,6,5] op ['stop']\n```", "```py\nwhile run == True:\n   operation         # Body of while loop operation\n   .\n   .\nstatement            # Next operation after the while loop\n```", "```py\n\n    MAR = PC                     # PC to Memory Address Register\n    PC = PC + 1                  # Increment PC\n    MBR = Memory[MAR]            # Read instruction, copy to Memory Buffer register\n    IR = MBR                     # Copy instruction to Instruction Register\n    OpCode = IR >> 7             # Extract Op-Code frominstruction (bits 7 to 10)\n    Dir  = (IR >> 6) & 1         # Extract data direction from instruction (0 = read, 1 = write)\n    Mode = (IR >> 5) & 1         # Extract address mode from instruction (0 = literal, 1 = memory)\n    Lit = IR & 0x1F              # Extract the literal/address field from the instruction\n```", "```py\n\nif   OpCode == 0:\n     Code for case 0\nelif OpCode == 1:\n     Code for case 1\n.\n.\nelif OpCode == 7:\n     Code for case 7\n```", "```py\n\n    if OpCode == 0:              # Test for Load A or Store A instruction\n      if Dir  == 0:              # If direction bit is 0, then it's a load accumulator\n         if Mode == 0:           # Test for literal or direct memory operand\n            Acc  = Lit           # If mode is 0, then it's a literal operand\n         else:                   #If mode is 1, then it's a memory access\n            MAR = Lit            #Copy field (address) to MAR\n            MBR = Memory[MAR]    #Do a read to get the operand in MBR\n            Acc  = MBR           #and send it to the accumulator\n      else:\n          MAR = Lit              # If direction is 1 then it's a store accumulator\n          MBR = Acc              # Copy accumulator to MBR\n          Memory[MAR] = MBR      # and write MBR to memory\n```", "```py\n                                # The TC2: A primitive accumulator machine\nmnemonics = {0:'LDA/STR', 1:'ADD', 2:'SUB', 3:'CLR', 4:'BRA', 5: \\\n               'BEQ', 6:'BNE', 7:'STOP'}\ndef progSet():\n    global mem\n    mem = [0] * 32              # The memory holds both instructions and data\n  # Format  CCCDMLLLLL          # 000 LDA/STR, 001 ADD, 010 SUB, 011 CLR, 100 BRA, \\\n                                  101 BEQ, 110 BNE, 111 STOP\n    mem[0]  =  0b0000110000     # LDA 16  [A]   = M[16]\n    mem[1]  =  0b0010110001     # ADD 17  [A]   = [A] + M[17] \n    mem[2]  =  0b0001110010     # STA 18  M[18] = [A]\n    mem[3]  =  0b0100000011     # SUB #3  [A]   = [A] - 3\n    mem[4]  =  0b1010001000     # BEQ 8\n    mem[5]  =  0b0000010010     # LDA #18 [A]   = 18\n    mem[6]  =  0b0001110010     # STA 18  M[18] = [A]\n    mem[7]  =  0b0110000000     # CLR     [A]   = 0  \n    mem[8]  =  0b0000000010     # LDA #2  [A]   = 2  \n    mem[9]  =  0b0100000010     # SUB #2  [A]   = [A] - 3\n    mem[10] =  0b1010001101     # BEQ 12\n    mem[11] =  0b0000001111     # LDA #15 LDA #18 [A] = 18 Dummy not executed  \n    mem[12] =  0b1110000000     # STOP\n    mem[16] =  0b0000000100     # 4 Data for test\n    mem[17] =  0b0000000101     # 5 Data for test  \n    mem[31] =  0b1110000000     # Ensure STOP operation\n    return(mem)\nrun = True                  # run is True for code execution. Setting run to False stops the computer\nPC  = 0                     # The program counter points to the next instruction to execute. Initially 0\nz = 0                       # Initialize z-bit (note no n and c bits implemented)\nmem = progSet()\n```", "```py\n\n                                 # MAIN LOOP – FETCH/EXECUTE\nwhile run:                   # This is the fetch/execute cycle loop that continues until run is False\n    MAR    = PC                  # FETCH PC to mem Address Register\n    pcOld  = PC                  # Keep a copy of the PC for display\n    PC     = PC + 1              # Increment PC\n    MBR    = mem[MAR]            # Read the instruction, copy it to the mem Buffer Register\n    IR     = MBR                 # Copy instruction to Instruction Register – prior to decoding it\n    OpCode = (IR >> 7) & 0x7     # Extract Op-Code from instruction bits 7 to 10 by shifting masking\n    Dir    = (IR >> 6) & 1       # Extract data direction from instruction (0 = read, 1 = write)\n    Mode   = (IR >> 5) & 1       # Extract address mode from instruction (0 = literal, 1 = mem)\n    Lit     = IR & 0x1F          # Extract literal/address field (0 = address, 1= literal)\n                             # EXECUTE The EXECUTE block is an if statement, one for each opcode\n    if OpCode == 0:          # Test for LDA and STA (Dir is 0 for load acc and 1 for store in mem)\n        if Dir == 0:             # If Direction is 0, then it's a load accumulator, LDA\n            if Mode == 0:        # Test for Mode bit to select literal or direct mem operand\n                Acc = Lit        # If mode is 0, then the accumulator is loaded with L\n            else:                # If mode is 1, then read mem to get operand\n                MAR = Lit        # Literal (address) to MAR\n                MBR = mem[MAR]   # Do a read to get operand in MBR\n                Acc = MBR        # and send it to the accumulator\n        else:\n            MAR = Lit            # If Direction is 1, then it's a store accumulator\n            MBR = Acc            # Copy accumulator to MBR\n            mem[MAR] = MBR       # and write MBR to mem\n    elif OpCode == 1:              # Test for ADD to accumulator\n        if Mode == 0:              # Test for literal or direct mem operand\n            total = Acc + Lit      # If mode is 0, then it's a literal operand\n            if total == 0: z = 1   # Deal with z flag\n            else: z = 0\n        else:                      # If mode is 1, then it's a direct mem access\n            MAR = Lit              # Literal (address) to MAR\n            MBR = mem[MAR]         # Do a read to get operand in MBR\n            total = MBR + Acc      # And send it to the accumulator\n        if Dir == 0: Acc = total   # Test for destination (accumulator)\n        else: mem[MAR] = total     # Or mem\n    elif OpCode == 2:              # Test for SUB from accumulator\n        if Mode == 0:              # Test for literal or direct mem operand\n            total = Acc – Lit      # If mode is 0 then it's a literal operand\n        else:                      # If mode is 1 then it's a direct mem access\n            MAR = Lit              # Literal (address) to MAR\n            MBR = mem[MAR]         # Do a read to get operand in MBR\n            total = Lit – MBR      # and send it to the accumulator\n        if total == 0: z = 1       # Now update z bit (in all cases)\n        if Dir == 0: Acc = total   # Test for destination (accumulator)\n        else: mem[MAR] = total     # Or mem\n```", "```py\n    elif OpCode == 3:              # Test for CLR (clear Accumulator or clear mem location)\n        if Mode == 0:              # If Mode = 0 Then clear accumulator\n            Acc = 0\n        else:\n            MAR = Lit              # If Mode = 1\n            mem[MAR] = 0           # Then clear mem location mem[Literal]\n    elif OpCode == 4:              # Test for BRA Branch unconditionally\n        PC = Lit - 1          # Calculate new branch target address (-1 because PC auto increment)\n    elif OpCode == 5:              # Test for BEQ Branch on zero\n        if z == 1: PC = Lit - 1    # If z bit = 1 then calculate new branch target address\n    elif OpCode == 6:              # Test for BNE Branch on not zero\n        if z == 0: PC = Lit - 1    # If z bit = 0 calculate new branch target address\n    elif OpCode == 7:               # Test for STOP\n        run = False                 # If STOP then clear run flag to exit while loop and stop\n```", "```py\n\n# End of main fetch-execute loop\n    mnemon = mnemonics.get(OpCode)  # Get the mnemonic for printing\n    print('PC',pcOld, 'Op ',OpCode, 'Mode = ', Mode, 'Dir = ',Dir, \\\n          'mem', mem[16:19], 'z',z, 'Acc', Acc, mnemon)\n```", "```py\n\nPC 0  OpCode  0 Mode =  1 Dir =  0 mem [4, 5, 0]  z 0 Acc 4  LDA/STR\nPC 1  OpCode  1 Mode =  1 Dir =  0 mem [4, 5, 0]  z 0 Acc 9  ADD\nPC 2  OpCode  0 Mode =  1 Dir =  1 mem [4, 5, 9]  z 0 Acc 9  LDA/STR\nPC 3  OpCode  2 Mode =  0 Dir =  0 mem [4, 5, 9]  z 0 Acc 6  SUB\nPC 4  OpCode  5 Mode =  0 Dir =  0 mem [4, 5, 9]  z 0 Acc 6  BEQ\nPC 5  OpCode  0 Mode =  0 Dir =  0 mem [4, 5, 9]  z 0 Acc 18 LDA/STR\nPC 6  OpCode  0 Mode =  1 Dir =  1 mem [4, 5, 18] z 0 Acc 18 LDA/STR\nPC 7  OpCode  3 Mode =  0 Dir =  0 mem [4, 5, 18] z 0 Acc 0  CLR\nPC 8  OpCode  0 Mode =  0 Dir =  0 mem [4, 5, 18] z 0 Acc 2  LDA/STR\nPC 9  OpCode  2 Mode =  0 Dir =  0 mem [4, 5, 18] z 1 Acc 0  SUB\nPC 10 OpCode  5 Mode =  0 Dir =  0 mem [4, 5, 18] z 1 Acc 0  BEQ\nPC 12 OpCode  7 Mode =  0 Dir =  0 mem [4, 5, 18] z 1 Acc 0  STOP\n```", "```py\n\n      LDA  x\n      ADD  #1\n      STA  x\n      LDA  y\n      ADD  #1\n      STA  y\n```", "```py\n\n      LDAA #1   ; Load accumulator with 1\n      ADDM x    ; Add accumulator to memory location x\n      ADDM y    ; Add accumulator to memory location y\n```", "```py\n if OpCode == 1:                 # Test for ADDA or ADDM instruction\n    if Dir == 0:                 # Test for add to accumulator (Dir=0) or add to memory (Dir =1)\n       if Mode == 0:             # Test for ADDA literal or direct memory operand\n          Acc = Acc + Lit        # If mode is 0, then it's a literal operand\n       else:                     # If mode is 1, then it's a direct memory access\n          MAR = Lit              # Literal (address) to MAR\n          MBR = Memory[MAR]      # Do a read to get operand in MBR\n          Acc = MBR + Acc        # and send it to the accumulator\n    if Dir == 1:                 # ADDM: add to memory version of ADD\n       MAR = Lit                 # Set up the memory address\n       MBR = Memory[MAR]         # Read memory contents\n       MBR = MBR + Acc           # Add accumulator to memory\n       Memory[MAR] = MBR         # And write back the result\n```", "```py\n\nif OpCode == 3:                                # Test for the branch group\n   if Dir == 0:                                # Direction 0 for unconditional\n      if Mode == 0: PC = PC + Lit - 1          # If Mode is zero then unconditional branch\n      else: run = 0                            # If Mode is 1 then this is undefined so stop\n   else:\n      if Dir == 1:                             # If direction is 1, it's a conditional branch\n         if Mode == 0:                         # If mode is 0 then we have a BNE\n            if Z == 0: PC = PC + Lit - 1       # Branch on Z = 0 (not zero)\n         else:                                 # If Mode is 1 we have a BEQ\n            if Z == 1: PC = PC + Lit - 1       # Branch on Z = 1 (zero)\n```", "```py\n\nif OpCode == 6:                    # Test for clear mem/Acc or increment mem/Acc\n    if Dir == 0:                   # Direction = 0 for clear operation\n        if Mode == 0:              # If Mode = 0\n           Acc = 0                 # Then clear accumulator\n        else:\n           MAR = Lit               # If Mode = 1\n           Memory[MAR] = 0         # Then clear memory location\n    else:                          # Direction = 1 for increment\n        if Mode == 0:              # If Mode = 0\n           Acc = Acc + 1           # Then increment accumulator\n        else:\n           MAR = Lit               # If Mode = 1\n           MBR = Memory[MAR]       # Then increment memory location\n           MBR = MBR + 1           # Increment memory in MBR\n           Memory[MAR] = MBR       # Write back incremented memory value\n```", "```py\n\n      Code          @ Comment                        Instruction encoding\n      MOV  R0,#     @ Point to memory location 8\nNext: RND  R5       @ REPEAT: generate random value in r5\n      MOV  [R0],R5  @ store r5 at location pointed at by r0\n      DEC  R0       @ decrement r0 pointer\n      BNE  Next     @ UNTIL zero\n      EQU  X,#1     @ Vector X memory 1 to 4\n      EQU  Y,#5     @ Vector Y memory 5 to 8\n      EQU  Z,#9     @ Vector Z memory 9 to 12\n      MOV  R0,#X    @ r0 points to array X                    00 0000 0010 000 000 00000001\n      MOV  R1,#Y    @ r1 points to array Y                   00 0000 0010 001 000 00000101\n      MOV  R2,#Z    @ r2 points to array Z                      00 0000 0010 010 000 00001001\n      MOV  R3,#4    @ r3 number of elements to add in r3        00 0000 0010 011 000 00000100\nLoop: MOV  R4,[R0]  @ Get xi                            00 0000 0000 100 000 00000000\n      ADD  R4,#5    @ Add 5 to xi                         00 0001 0010 100 000 00000101\n      ADD  R4,[R1]  @ Add xi + 5 to yi Memory to reg operation    00 0001 0001 100 001 00000000\n      MOV  [R2],R4  @ Store result in array Z                 00 0000 0100 010 100 00000000\n      INC  R0       @ Increment pointer to array X             00 1100 0000 000 000 00000000\n      INC  R1       @ Increment pointer to array Y               00 1100 0000 001 000 00000000\n      INC  R2       @ Increment pointer to array Z             00 1100 0000 010 000 00000000\n      DEC  R3       @ Decrement loop counter                00 1101 0000 011 000 00000000\n      BNE  Loop     @ Continue until counter 0              01 0011 0000 000 000 00000100\n```", "```py\n\nsTab = {}                             # Symbol table for equates and labels name:integerValue\npMem = []                             # Program memory (initially empty)\ndMem = [0]*16                         # Data memory. Initialized and 16 locations\nreg  = [0]*8                          # Register set\nz,c,n = 0,0,0                         # Define and status flags: zero, carry, negative\ntestCode = \"E:\\\\AwPW\\\\TC3_NEW_1.txt\"  # Source filename on my computer\nwith open(testCode) as src:           # Open the source file containing the assembly program\n    lines = src.readlines()           # Read the program into lines\nsrc = [i[0:-1].lstrip() for i in lines ]\n                                      # Remove the /n newline from each line of the source code\nsrc = [i.split(\"@\")[0] for i in src]           # Remove comments in the code\nsrc = [i for i in src if i != '']     # Remove empty lines\nfor i in range(0,len(src)):           # Scan source code line-by-line\n    src[i] = src[i].replace(',',' ')  # Replace commas by a space\n    src[i] = src[i].upper()           # Convert to upper-case\n    src[i] = src[i].split()           # Split into tokens (label, mnemonic, operands)\nsrc1 = []                             # Set up dummy source file, initially empty\nfor i in range (0,len(src)):          # Read source and stop on first END instruction\n    src1.append(src[i])               # Append each line to dummy source file\n    if src[i][0] == 'END': break      # Stop on 'END' token\nsrc = src1                            # Copy dummy file to source (having stopped on 'END')\nfor i in range (0,len(src)):          # Deal with equates of the form EQU PQR 25\n    if src[i][0] == 'EQU':            # If the line is 3 or more tokens and first token is EQU\n        sTab[src[i][1]] = getL(src[i][2])      # Put token in symbol table as integer\nsrc = [i for i in src if i.count('EQU') == 0]  # Remove lines with \"EQU\" from source code\n```", "```py\n\nfor ic in range(0,len(src)):           # ASSEMBLY LOOP (ic = instruction counter)\n    t0,t1,t2 = '', '', ''              # Prepare to assign tokens. Initialize to null string\n    if src[ic][0][-1] != ':':          # If the first token doesn't end in colon, it's an instruction\n        j = 0                          # j = 0 forline starting with mnemonic\n    else:                              # If the first token ends in a colon it's a label\n        j = 1                          # j = 1 if mnemonic is second token\n    t0 = src[ic][j]                    # Set t0 to mnemonic j selects first or second token\n    if len(src[ic]) > 1+j: t1 = src[ic][j+1]  # Set t1 to ingle operand\n    if len(src[ic]) > 2+j: t2 = src[ic][j+2]  # Set t2 to second operand\n    tLen = len(src[ic]) - j - 1         # tLen is the number of tokens (adjusted for any label)\n```", "```py\n\nrName   = {'R0':0,'R1':1,'R2':2,'R3':3}  # Relate register name to numeric value (lookup table)\nrNamInd = {'[R0]':0,'[R1]':1,'[R2]':2,'[R3]':3}\n                                         # Look for register indirect addressing (lookup table)\niClass0 = ['STOP', 'NOP', 'END']         # Instruction class 00 mnemonic with no operands\niClass1 = ['BRA',  'BEQ', 'BNE','CZN' ]  # Instruction class 01 mnemonic with literal operand\n```", "```py\n\nif t0 in iClass0: mode = 0.\n```", "```py\n if (t1 in rNamInd) and (t2 in rName): mode = 7\n```", "```py\n\nbinC = 0                                  # Initialize binary code for this instruction to all zeros\nopCode = mnemon[t0]                       # Look up op-code in table mnemon using token t0\niClass = opCode >> 4                      # Get two most significant bits of op-code (i.e., class)\nif   t0 in iClass0:                       # If in iClass0 it's a single instruction, no operands\n    mode = 0                              # The mode is 0 for everything in this class\n    binC = (mnemon[t0] << 18)             # All fields zero except op_code\nelif t0 in iClass1:                       # If in iClass1 it's an 0p-code plus offset (e.g., branch)\n    mode = 1                              # All class 1 instruction are mode 1 (op-code plus literal)\n    binC = (mnemon[t0] << 18)+(mode << 14)+getL(t1)\n                                          # Create binary code for Class1 instruction\nelif t0 in iClass2:                       # If in iClass2 it's an op-code plus register number\n    mode = 2                              # All iClass2 instructions are mode 2\n    binC = (mnemon[t0] << 18)+(mode << 14)+(rName[t1] << 11\n                                          # Construct binary code of instruction\nelif t0 in iClass3:                       # All data-processing and movement ops in iClass3\n    if   (t1 in rName) and (t2[0] == '#'): # Look for register name and literal for mode 4\n        mode = 4\n    elif (t1 in rName) and (t2 in rName): # Look for register name and register name for mode 5\n        mode = 5\n    elif (t1 in rName) and (t2 in rNamInd):   # Look for R0,[R2]) format\n        mode = 6\n    elif (t1 in rNamInd) and (t2 in rName):   # Look for instruction format [R1],R2\n        mode = 7\n    elif (t1 in rNamInd) and (t2 in rNamInd): # Look for two register indirect names [R1],[R2]\n        mode = 8\n    elif (t1[0:2] == 'M:') and (t2 in rName):\n                                      # Look for memory address M: and reg name M:12,r4\n        mode = 9\n    elif (t1[0:2] == 'M:') and (t2 in rNamInd): # Look for M:12,[R4] format\n        mode = 10\n    elif (t1 in rName) and (t2[0:2] == 'M:'): # Look for register name and literal prefixed by M:\n        mode = 11\n    elif (t1 in rNamInd) and (t2[0:2] == 'M:'):\n                                      # Look for register indirect name and literal prefixed by M:\n        mode = 12\n```", "```py\n\n if (mode == 4) or (mode == 5) or (mode == 6) or (mode == 11):\n```", "```py\n\n if mode in [4,5,6,11]:\n```", "```py\n\nbinC = (mnemon[t0] << 18) + (mode << 14)  # Insert op_Code and mode fields in instruction\nrField1, rField2, lField = 0, 0, 0        # Calculate register and literal fields. Initialize to zero\nif mode in [4,5,6,11]: rField1 = rName[t1] # Convert register names into register numbers\nif mode in [7,8,12]:   rField1 = rNamInd[t1]\nif mode in [5,7,9]:    rField2 = rName[t2] # rField2 is second register field\nif mode in [6,8,10]:   rField2 = rNamInd[t2]\nif mode in [4,11,12]:  lField  = getL(t2)\n                                  # if (mode==4) or (mode==11) or (mode==12): lField = getL(t2)\nif mode in [9,10]:     lField  = getL(t1)\n                                  # if (mode == 9) or (mode == 10): lField = getL(t1) Literal field\n```", "```py\n\nbinC = binC + (rField1 << 11) + rField2 << 8) + lField\n                                  # Binary code with register and literal fields\npMem.append(binC)                 # Append instruction to program memory\n```", "```py\n\n### Display assembly details of each instruction for diagnostics\npcF  = \"{0:<20}\".format(\" \".join(src[ic]))    # 1\\. instruction\nicF  = 'pc = ' + \"{:<3}\".format(ic)           # 2\\. pc\nbinF = format(binC, \"024b\")                   # 3\\. Binary encoding\niClF = 'Class = '+ str(iClass)                # 4\\. instruction class\nmodF = 'mode = ' + str(mode)                  # 5\\. instruction mode. Convert mode to string\nt0F  = \"{:<5}\".format(t0)                     # 6\\. token 0 (mnemonic)\nt1F  = \"{:<5}\".format(t1)                     # 7\\. token 1 (register field 1)\nt2F  = \"{:<10}\".format(t2)                    # 8\\. token 2 (register field 2 or literal)\nprint(pcF,icF,binF,iClF,modF,t0F,'t1 =',t1F,t2F)   # Print these fields\n```", "```py\n\nif displayLevel > 4: print('Binary code =', xyz)\n```", "```py\n\nelif fun == 1:                             # ADD:\n        res = (op1 + op2)                  # Perform addition of operands\n        if thisOp == 'ADC': res = res + c  # If operation ADC then add carry bit\n```", "```py\n\nelif opClass == 1:                         # Class 1 operation instructions with literal operand\n    if    thisOp == 'BRA': pc = lit        # BRA Branch unconditionally PC = L\n    elif (thisOp == 'BEQ') and (z == 1): pc = lit    # BEQ Branch on zero\n    elif (thisOp == 'BNE') and (z == 0): pc = lit    # BNE Branch on not zero\n    elif  thisOp == 'CZN':                 # Set/clear c, z, and n flags\n        c = (lit & 0b100) >> 2             # Bit 2 of literal is c\n        z = (lit & 0b010) >> 1             # Bit 1 of literal is z\n        n = (lit & 0b001)                  # Bit 0 of literal is n\n```", "```py\n\ndef getL(lit8):                               # Convert string to integer\n    lit8v = 9999                              # Dummy default\n    if lit8[0:2]   == 'M:': lit8  = lit8[2:]  # Strip M: prefix from memory literal addresses\n    if lit8[0:1]   == '#':  lit8  = lit8[1:]  # Strip # prefix from literal addresses\n    if   type(lit8) == int: lit8v = lit8      # If integer, return it\n    elif lit8.isnumeric():  lit8v = int(lit8) # If decimal in text form convert to integer\n    elif lit8 in sTab:      lit8v = sTab[lit8]       # If in symbol table, retrieve it\n    elif lit8[0]   == '%':  lit8v = int(lit8[1:],2)  # If binary string convert to int\n    elif lit8[0:2] == '0X': lit8v = int(lit8[2:],16) # If hex string convert it to int\n    elif lit8[0]   == '-':  lit8v = -int(lit8[1:]) & 0xFF\n                                               # If decimal negative convert to signed int\n    return(lit8v)                              # Return integer corresponding to text string\n```", "```py\n\nop3 = alu(fun,op1,op2)                          # Call ALU to perform the function\nif mode in [4,5,6,11]: reg[reg1] = op3          # Writeback ALU result in op3 to a register\nelif mode in [7,8,12]: dMem[reg[reg1]] = op3    # Writeback result to mem pointed at by reg\nelif mode in [9,10]:   dMem[lit]       = op3    # Writeback result to memory\n```", "```py\n\n EQU www,#42\n MOV r0,#12\n MOV r0,#%11010\n MOV r0,#0xAF\n MOV r0,#-5\n MOV r0,M:7\n MOV r0,#www\n NOP\n STOP\n END\n```", "```py\n\nSource code                     This is the tokenized source code\n['MOV', 'R0', '#12']\n['MOV', 'R0', '#%11010']\n['MOV', 'R0', '#0XAF']\n['MOV', 'R0', '#-5']\n['MOV', 'R0', 'M:7']\n['MOV', 'R0', '#WWW']\n['NOP']\n['STOP']\n['END']\nEquate and branch table          This is the symbol table. Only one entry\nWWW      42\n```", "```py\n\nAssembly loop\nMOV R0 #12     pc=0 110000010000000000001100 Class=3 mode=4 MOV   t1=R0 #12\nMOV R0 #%11010   pc=1 1110000010000000000011010   Class=3  mode=4   MOV   t1=R0 #%11010\nMOV R0 #0XAF   pc=2 110000010000000010101111 Class=3 mode=4  MOV  t1=R0 #0XAF\nMOV R0 #-5     pc=3 110000010000000011111011 Class=3 mode=4  MOV  t1=R0 #-5\nMOV R0 M:7     pc=4 110000101100000000000111 Class=3 mode=11 MOV  t1=R0 M:7\nMOV R0 #WWW    pc=5 110000010000000000101010 Class=3 mode=4  MOV  t1=R0 #WWW\nNOP            pc=6 000000000000000000000000 Class=0 mode=0  NOP  t1 =\nSTOP           pc=7 001110000000000000000000 Class=0 mode=0  STOP t1 =\nEND            pc=8 001111000000000000000000 Class=0 mode=0  END  t1 =\n110000010000000000001100      This is the program in binary form\n110000010000000000011010\n110000010000000010101111\n110000010000000011111011\n110000101100000000000111\n110000010000000000101010\n000000000000000000000000\n001110000000000000000000\n```", "```py\n001111000000000000000000\n```", "```py\n\nEXECUTE\nMOV R0 #12     pc=0  110000010000000000001100 Class=3 mode=4  \nReg=0c 00 00 00 00 00 00 00 Mem=00 C=0 Z=0 N=0\nMOV R0 #%11010 pc=1  110000010000000000011010 Class=3 mode=4  \nReg=1a 00 00 00 00 00 00 00 Mem=00 C=0 Z=0 N=0\nMOV R0 #0XAF   pc=2  110000010000000010101111 Class=3 mode=4  \nReg=af 00 00 00 00 00 00 00 Mem=00 C=0 Z=0 N=1\nMOV R0 #-5     pc=3  110000010000000011111011 Class=3 mode=4  \nReg=fb 00 00 00 00 00 00 00 Mem=00 C=0 Z=0 N=1\nMOV R0 M:7     pc=4  110000101100000000000111 Class=3 mode=11 \nReg=07 00 00 00 00 00 00 00 Mem=00 C=0 Z=0 N=0\nMOV R0 #WWW    pc=5  110000010000000000101010 Class=3 mode=4  \nReg=2a 00 00 00 00 00 00 00 Mem=00 C=0 Z=0 N=0\nNOP            pc=6  000000000000000000000000 Class=0 mode=0  \nReg=2a 00 00 00 00 00 00 00 Mem=00 C=0 Z=0 N=0\nSTOP           pc=7  001110000000000000000000 Class=0 mode=0  \nReg=2a 00 00 00 00 00 00 00 Mem=00 C=0 Z=0 N=0\n```", "```py\n\n### TC3 CISC machine\n### Demonstration register-to-memory architecture Designed 22 January 2022.\n### Instruction formats and addressing modes\n### Mode 0:  NOP, STOP        No operand length 1\n### Mode 1:  INC R1           Single register operand\n### Mode 2:  BEQ XXX          Literal operand\n### Mode 3:  Reserved\n### Mode 4:  MOV r1,literal   Two-operand, register and literal\n### Mode 5:  MOV r1,r2        Two-operand, register to register\n### Mode 6:  MOV r1,[r2]      Two-operand, register indirect to register\n### Mode 7:  MOV [r1],r2      Two-operand, register to register indirect\n### Mode 8:  MOV [r1],[r2]    Two-operand, register indirect to register indirect\n### Mode 9:  MOV M,r2         Two-operand, register to memory address\n### Mode 10: MOV M,[r2]       Two-operand, register indirect to memory address\n### Mode 11: MOV r1,M         Two-operand, memory address to register\n### Mode 12: MOV [r1],M       Two-operand, memory address to register indirect\n### The sample test code\n###       MOV  r0,#8      @ Memory locations 1 to 8 with random numbers\n### Next: RND  r5\n###       MOV  [r0],r5\n###       DEC  r0\n###       BNE  Next\n###       EQU   X,#1      @ Vector 1\n###       EQU   Y,#5      @ Vector 5\n###       EQU   Z,#9      @ Vector 9\n###       MOV   r1,#X     @ r0 points to array X              11 0000 0100 000 000 00000001\n###       MOV   r2,#Y     @ r1 points to array Y              11 0000 0100 001 000 00000101\n###       MOV   r3,#Z     @ r2 points to array Z               11 0000 0100 010 000 00001001\n###       MOV   r4,#6     @ r4 number of elements to add      11 0000 0100 011 000 00000100\n### Loop: MOV   r5,[r1]   @ REPEAT: Get xi                 11 0000 0110 100 000 00000000\n###       ADD   r5,#6     @ Add 6 to xi                   11 0001 0100 100 000 00000101\n###       ADD   r5,[r2]   @ Add xi + 5 to yi                 11 0001 0110 100 001 00000000\n###       MOV   [r3],r5   @ Store result in array Z            11 0000 0111 010 100 00000000\n###       INC   r1        @ Increment pointer to array X        10 0000 0010 000 000 00000000\n###       INC   r2        @ Increment pointer to array Y        10 0000 0010 001 000 00000000\n###       INC   r3        @ Increment pointer to array Z          10 0000 0010 010 000 00000000\n###       DEC   r4        @ Decrement loop counter           10 0001 0010 011 000 00000000\n###       BNE   Loop      @ Continue until counter zero         01 0010 0001 000 000 00000100\n###       STOP                                        00 1111 0000 000 000 00000000\n```", "```py\n\nimport random                                 # Get library of random number operations\n### Dictionaries and variables\nmnemon  = {'MOV':48,'MOVE':48,'ADD':49,'SUB':50,'CMP':51,'NOT':52,'AND':53, \\\n           'OR':54,'EOR':55,'ONES':56, 'MRG':57,'FFO':58,'LSL':59,'LSR':60, \\\n           'ADC':61,'INC':32,'DEC':33,'RND':34,'CZN':19,'TST':36,'NOP':0,   \\\n           'BRA':16,'BEQ':17,'BNE':18,'STOP':14,'END':15}\nmnemonR = {48:'MOV',49:'ADD',50:'SUB',51:'CMP',52:'NOT',53:'AND',54:'OR',   \\\n           55:'EOR',56:'ONES',57:'MRG',58:'FFO',59:'LSL',60:'LSR',61:'ADC', \\\n           32:'INC',33:'DEC', 34:'RND',19:'CZN',36:'TST',0:'NOP',16:'BRA',  \\\n           17:'BEQ',18:'BNE',14:'STOP',15:'END'}\nrName   = {'R0':0,'R1':1,'R2':2,'R3':3,'R4':4,'R5':5,'R6':6,'R7':7} # Register tab\nrNamInd = {'[R0]':0,'[R1]':1,'[R2]':2,'[R3]':3,'[R4]':4,' \\\n           '[R5]':5,'[R6]':6,'[R7]':7}                       # Indirect registers\niClass0 = ['STOP', 'NOP','END']         # class 00 mnemonic with no operands\niClass1 = ['BRA','BEQ','BNE','CZN']     # class 01 mnemonic with literal operand\niClass2 = ['INC','DEC','RND','TST']     # class 10 mnemonic with register operand\niClass3 = ['MOV','MOVE','ADD','ADC','SUB','CMP', 'NOT','AND','OR', \\\n           'EOR','ONES','MRG','FFO','LSL','LSR']   # class 11 mnemonic two operands\nsTab = {}                              # Symbol table for equates and labels name:integerValue\npMem = []                              # Program memory (initially empty)\ndMem = [0]*16                          # Data memory\nreg  = [0]*8                           # Register set\nz,c,n = 0,0,0                          # Define and clear flags zero, carry, negative\n```", "```py\n\ndef getL(lit8):                                # Convert string to integer\n    lit8v = 9999                               # Dummy default\n    if lit8[0:2]   == 'M:': lit8  = lit8[2:]  # Strip M: prefix from memory literal addresses\n    if lit8[0:1]   == '#':  lit8  = lit8[1:]   # Strip # prefix from literal addresses\n    if   type(lit8) == int: lit8v = lit8       # If integer, return it\n    elif lit8.isnumeric():  lit8v = int(lit8)  # If decimal in text from convert to integer\n    elif lit8 in sTab:      lit8v = sTab[lit8] # If in symbol table, retrieve it\n    elif lit8[0]   == '%':  lit8v = int(lit8[1:],2)  # If binary string convert to int\n    elif lit8[0:2] == '0X': lit8v = int(lit8[2:],16) # If hex string convert to int\n    elif lit8[0]   == '-':  lit8v = -int(lit8[1:]) & 0xFF\n                                               # If decimal negative convert to signed int\n    return(lit8v)                              # Return integer corresponding to text string\ndef alu(fun,op1,op2):             # Perform arithmetic and logical operations on operands 1 and 2\n    global z,n,c                               # Make flags global\n    z,n,c = 0,0,0                              # Clear status flags initially\n    if   fun == 0: res = op2             # MOV: Perform data copy from source to destination\n    elif fun == 1:                       # ADD: Perform addition - and ensure 8 bits plus carry\n        res = (op1 + op2)                      # Do addition of operands\n        if thisOp == 'ADC': res = res + c      # If operation ADC then add carry bit\n    elif fun == 2: res = (op1 - op2)           # SUB: Perform subtraction\n    elif fun == 3: res = op1 - op2        # CMP: Same as subtract without writeback\n    elif fun == 4: res = op1 & op2        # AND: Perform bitwise AND\n    elif fun == 5: res = op1 | op2        # OR\n    elif fun == 6: res = ~op2             # NOT\n    elif fun == 7: res = op1 ^ op2        # XOR\n    elif fun == 8:\n        res = op2 << 1                    # LSL: Perform single logical shift left\n    elif fun == 9:\n        res = op2 >> 1                    # LSR: Perform single logical shift right\n    elif fun == 10:                       # ONES (Count number of 1s in register)\n       onesCount = 0                      # Clear the 1s counter\n       for i in range (0,8):        # For i = 0 to 7 (test each bit) AND with 10000000 to get msb\n           if op2 & 0x80 == 0x80:         # If msb is set\n               onesCount = onesCount + 1  # increment the 1s counter\n           op2 = op2 << 1                 # shift the operand one place left\n       res = onesCount                    # Destination operand is 1s count\n    elif fun == 11:                       # MRG (merge alternate bits of two registers)\n         t1 = op1 & 0b10101010            # Get even source operand bits\n         t2 = op2 & 0b01010101            # Get odd destination operand bits\n         res = t1 | t2                    # Merge them using an OR\n    elif fun == 12:                       # FFO (Find position of leading 1)\n        res = 8                           # Set default position 8 (i.e., leading 1 not found)\n        for i  in range (0,8):            # Examine the bits one by one\n          temp = op2 & 0x80               # AND with 10000000 to get leading bit and save\n          op2 = op2 << 1                  # Shift operand left\n          res = res - 1                   # Decrement place counter\n          if temp == 128: break           # If the last tested bit was 1 then jump out of loop\n    if res & 0xFF == 0:        z = 1      # TEST FLAGS z = 1 if bits 0 to 7 all 0\n    if res & 0x80 == 0x80:     n = 1      # If bit 7 is one, set the carry bit\n    if res & 0x100 == 0x100:   c = 1      # carry bit set if bit 8 set\n    if (thisOp == 'LSR') and (op2 & 1 == 1): c = 1\n                                          # Deal with special case of shift right (carry out is lsb)\n    return(res & 0xFF)                    # Return and ensure value eight bits\n```", "```py\n\ndef trace():                                          # Function to print execution data\n    cF   = \"{0:<20}\".format(\" \".join(src[pcOld]))     # 1\\. instruction\n    icF  = 'pc = ' + \"{:<3}\".format(pcOld)            # 2\\. pc\n    binF = format(inst, \"024b\")                       # 3\\. binary code\n    iClF = 'Class = '+ str(iClass)                    # 4\\. instruction class\n    modF = 'mode = ' + str(mode)   # 5\\. instruction mode NOTE we have to convert mode to string\n    t0F  = \"{:<5}\".format(t0)                        # 6\\. token 0 (mnemonic)\n    t1F  = \"{:<5}\".format(t1)                        # 7\\. token 1 (register field 1)\n    t2F  = \"{:<10}\".format(t2)                       # 8\\. token 2 (register field 2 or literal)\n    rF   = 'Reg = '+ ' '.join('%02x' % b for b in reg)  # 9\\. Registers in hex format\n    m    = dMem[0:11]                                # 10\\. First 10 memory locations\n    mF   = 'Mem = '+ \" \".join(\"%02x\" % b for b in m) # 11\\. Hex-formatted memory values\n    ccrF = 'C = '+ str(c) + ' Z = ' + str(z) +' N = ' + str(n) # 12\\. Condition codes\n    x = input('>>> ')                               # 13\\. Wait for keyboard input (return)\n    print(cF,icF,binF,iClF, modF, rF, mF,ccrF)      # 14\\. Print the computer status data\n    return()\ntestCode = \"E:\\\\AwPW\\\\TC3_NEW_1.txt\"  # Source filename on my computer\nwith open(testCode) as src:           # Open source file with assembly language program\n    lines = src.readlines()           # Read the program into lines\nsrc.close()                           # Close the source file\nsrc = [i[0:-1].lstrip()  for i in lines ]\n                                      # Remove the /n newline from each line of the source code\nsrc = [i.split(\"@\")[0] for i in src]  # Remove comments in the code\nsrc = [i for i in src if i != '']     # Remove empty lines\nfor i in range(0,len(src)):           # Scan source code line by line\n    src[i] = src[i].replace(',',' ')  # Replace commas by a space\n    src[i] = src[i].upper()           # Convert to upper-case\n    src[i] = src[i].split()           # Split into tokens (label, mnemonic, operands)\nsrc1 = []                             # Set up dummy source file, initially empty\nfor i in range (0,len(src)):          # Read source and stop on first END operation\n    src1.append(src[i])               # Append line to dummy source file\n    if src[i][0] == 'END': break      # Stop on 'END' token\nsrc = src1                            # Copy dummy file to source (having stopped on 'END')\nfor i in range (0,len(src)):          # Deal with equates of the form EQU PQR 25\n    if src[i][0] == 'EQU':            # If the line is 3 or more tokens and first token is EQU\n        sTab[src[i][1]] = getL(src[i][2])\n                                      # Put token in symbol table as integer\nsrc = [i for i in src if i.count(\"EQU\") == 0]\n                            # Remove lines with 'EQU' from source code (these are not instructions)\nfor i in range(0,len(src)):           # Add label addresses to symbol table\n    if src[i][0][-1] == ':':          # If first token is a label with : terminator\n        sTab.update({src[i][0][0:-1]:i}) # add it to the symbol table.\nxLm = 0                               # Length of maximum instruction (for printing)\nfor i in range (0,len(src)):          # Step through source array\n    xL = len(' '.join(src[i]))       # Get the length of each line after joining tokens\n    if xL > xLm: xLm = xL            # If xL > xLm  NOTE: This facility is not used in this version\nprint('Source code')                 # Display tokenized source code\nfor i in range(0,len(src)): print(src[i])\nprint(\"\\nEquate and branch table\\n\") # Display the symbol table\nfor x,y in sTab.items():             # Step through the symbol table dictionary structure\n    print(\"{:<8}\".format(x),y)       # Display each line as label and value\nprint('\\nAssembly loop \\n')\nfor ic in range(0,len(src)):         # ASSEMBLY LOOP (ic = instruction counter)\n    t0,t1,t2 = '','',''              # Prepare to assign tokens. Initialize to null string\n    if src[ic][0][-1] != ':':        # If the first token doesn't end in colon, its an instruction\n        j = 0                        # j = 0 for line starting with mnemonic\n    else:                            # If the first token ends in a colon it's a label\n        j = 1                        # j = 1 if mnemonic is second token\n    t0 = src[ic][j]                  # Set t0 to mnemonic\n    if len(src[ic]) > 1+j: t1 = src[ic][j+1]   # Set t1 to single operand\n    if len(src[ic]) > 2+j: t2 = src[ic][j+2]   # Set t2 to second operand\n    tLen = len(src[ic]) - j - 1      # tLen is the number of tokens (adjusted for any label)\n    binC = 0                         # Initialize binary code for this instruction to all zeros\n    opCode = mnemon[t0]              # Look up op-code in table mnemon using token t0\n    iClass = opCode >> 4             # Get two most significant bits of op-code (i.e., class)\n    if   t0 in iClass0:              # If in iClass0 it's a single instruction, no operands\n        mode = 0                     # The mode is 0 for everything in this class\n        binC = (mnemon[t0] << 18)    # All fields zero except op_code\n    elif t0 in iClass1:              # If in iClass1 it's an op-code plus offset (e.g., branch)\n        mode = 1                     # All class 1 instruction are mode 1 (op-code plus literal)\n        binC = (mnemon[t0] << 18) + (mode << 14)  + getL(t1)\n                                     # Create binary code with operation plus address (literal)\n    elif t0 in iClass2:              # If in iClass2 it's an op-code plus register number\n        mode = 2                     # All instruction are mode 2\n        binC = (mnemon[t0] << 18) + (mode << 14)  + (rName[t1] << 11)\n                                     # Create binary code\n    elif t0 in iClass3:        # Two-operand inst. All data-processing and movement ops in iClass3\n        if   (t1 in rName) and (t2[0] == '#'):\n                               # Look for register name and literal for mode 4\n            mode = 4\n        elif (t1 in rName) and (t2 in rName):\n                               # Look for register name and register name for mode 5\n            mode = 5\n        elif (t1 in rName) and (t2 in rNamInd):\n                               # Look for register name and register indirect name (r1,[r2])\n            mode = 6\n        elif (t1 in rNamInd) and (t2 in rName):\n                                     # Look for register indirect name and register ([r1],r2)\n            mode = 7\n        elif (t1 in rNamInd) and (t2 in rNamInd):\n                                     # Look for two register indirect names ([r1],[r2])\n            mode = 8\n        elif (t1[0:2] == 'M:') and (t2 in rName):\n                                     # Look for literal prefixed by M: and register name (M:12,r4)\n            mode = 9\n        elif (t1[0:2] == 'M:') and (t2 in rNamInd):\n                               # Look for literal prefixed by M: and register indirect name (M:12,[r4])\n            mode = 10\n        elif (t1 in rName) and (t2[0:2] == 'M:'):\n                                     # Look for register name and literal prefixed by M:\n            mode = 11\n        elif (t1 in rNamInd) and (t2[0:2] == 'M:'):\n                                     # Look for register indirect name and literal prefixed by M:\n            mode = 12\n        binC = (mnemon[t0] << 18) + (mode << 14)\n                                     # Insert op_Code and mode fields in the instruction\n        rField1, rField2, lField = 0, 0, 0  # Calculate register and literal fields. Initialize to zero\n        if mode in [4,5,6,11]: rField1 = rName[t1]\n                               # Convert register names into register numbers rField1is first register\n        if mode in [7,8,12]:   rField1 = rNamInd[t1]\n        if mode in [5,7,9]:    rField2 = rName[t2]   # rField2 is second register field\n        if mode in [6,8,10]:   rField2 = rNamInd[t2]\n        if mode in [4,11,12]:  lField  = getL(t2)\n                                  # if (mode == 4) or (mode == 11) or (mode == 12): Get literal\n        if mode in [9,10]:     lField  = getL(t1)\n                                  # if (mode == 9) or (mode == 10):  lField = getL(t1) Literal field\n        binC = binC+(rField1 << 11)+(rField2 << 8)+lField\n                                     # Binary code with register and literal fields added\n    pMem.append(binC)                # Append instruction to program memory in pMem\n### Display the assembly details of each instruction (this is for diagnostics)\n    pcF  = '{0:<20}'.format(' '.join(src[ic])) # 1\\. instruction\n    icF  = 'pc = ' + '{:<3}'.format(ic)        # 2\\. pc\n    binF = format(binC, '024b')                # 3\\. binary code\n    iClF = 'Class = '+ str(iClass)             # 4\\. instruction class\n    modF = 'mode = ' + str(mode)           # 5\\. instruction mode NOTE convert mode to string\n    t0F  = '{:<5}'.format(t0)              # 6\\. token 0 (mnemonic)\n    t1F  = '{:<5}'.format(t1)              # 7\\. token 1 (register field 1)\n    t2F  = '{:<10}'.format(t2)             # 8\\. token 2 (register field 2 or literal)\n    print(pcF,icF,binF,iClF,modF,t0F,'t1 =',t1F,t2F) # Print these fields\nprint('\\nEXECUTE \\n')\n### EXECUTE LOOP   # reverse assemble the binary instruction to recover the fields and execute the instruction\npc = 0                                     # Reset the program counter to 0\nrun = True                         # run flag: True to execute, False to stop (stop on END or STOP)\nwhile run == True:                         # MAIN LOOP\n    op1, op2, op3 = 0,0,0                  # Initialize data operands\n    inst = pMem[pc]        # Fetch current instruction. inst is the binary op-code executed in this cycle\n    pcOld = pc                             # Remember current pc for printing/display\n    pc = pc + 1                            # Increment program counter for next cycle\n    iClass = inst >> 22                    # Extract operation class 0 to 3 (top two bits)\n    opCode = (inst >> 18)   & 0b111111     # Extract the current op-code\n    mode   = (inst >> 14)   & 0b1111       # Extract the addressing mode\n    reg1   = (inst >> 11)   & 0b0111       # Extract register 1 number\n    reg2   = (inst >>  8)   & 0b0111       # Extract register 2 number\n    lit    = inst           & 0b11111111   # Extract the 8-bit literal in the least significant bits\n```", "```py\n\n### EXECUTE THE CODE\n    thisOp = mnemonR[opCode]               # Reverse assemble. Get mnemonic from op-code\n    if iClass == 0:                        # Class 0 no-operand instructions\n        if thisOp == 'END' or thisOp == 'STOP': run = False\n                                           # If END or STOP clear run flag to stop execution\n        if opCode == 'NOP': pass           # If NOP then do nothing and \"pass\"\n    elif iClass == 1:                      # Class 1 operation \n                                           # Class 1 branch and instr with literal operands\n        if    thisOp == 'BRA': pc = lit    # BRA Branch unconditionally PC = L\n        elif (thisOp == 'BEQ') and (z == 1): pc = lit  # BEQ Branch on zero\n        elif (thisOp == 'BNE') and (z == 0): pc = lit  # BNE Branch on not zero\n        elif thisOp == 'CZN':                          # Set/clear c, z, and n flags\n            c = (lit & 0b100) >> 2                     # Bit 2 of literal is c\n            z = (lit & 0b010) >> 1                     # Bit 1 of literal is z\n            n = (lit & 0b001)              # Bit 0 of literal is c\n    elif iClass == 2:                      # Class 0 single-register operand\n        if   thisOp == 'INC': reg[reg1] = alu(1,reg[reg1],1)\n                                           # Call ALU with second operand 1 to do increment\n        elif thisOp == 'DEC': reg[reg1] = alu(2,reg[reg1],1)   # Decrement register\n        elif thisOp == 'RND': reg[reg1] = random.randint(0,0xFF)\n                                           # Generate random number in range 0 to 0xFF\n        elif thisOp == 'TST':              # Test a register: return z and n flags. Set c to 0\n            z, n, c = 0, 0, 0                      # Set all flags to 0\n            if reg[reg1] == 0:           z = 1     # If operand 0 set z flag\n            if reg[reg1] & 0x80 == 0x80: n = 1     # If operand ms bit 1 set n bit\n    elif iClass == 3:                      # Class 3 operation: Two operands.\n        if   mode in [4,5,6,11]: op1 = reg[reg1]\n                                           # Register, literal e.g. MOVE r1,#5 or ADD r3,#0xF2\n        elif mode in [7,8,12]:   op1 = dMem[reg[reg1]]\n                                           # Register, literal e.g. MOVE r1,#5 or ADD r3,#0xF2\n        elif mode in [9,10]:     op1 = lit # MOV M:12,r3 moves register to memory\n        if   mode in [4,11,12]:  op2 = lit # Mode second operand literal\n        elif mode in [5,7,9]:    op2 = reg[reg2]\n                                           # Modes with second operand contents of register\n        elif mode in [6,8,10]:   op2 = dMem[reg[reg2]]\n                                           # Second operand pointed at by register\n        if thisOp == 'MOV' : fun = 0       # Use mnemonic to get function required by ALU\n        if thisOp == 'ADD' : fun = 1       # ADD and ADC use same function\n        if thisOp == 'ADC' : fun = 1\n        if thisOp == 'SUB' : fun = 2\n        if thisOp == 'AND' : fun = 4\n        if thisOp == 'OR'  : fun = 5\n        if thisOp == 'NOT' : fun = 6\n        if thisOp == 'EOR' : fun = 7\n        if thisOp == 'LSL' : fun = 8\n        if thisOp == 'LSR' : fun = 9\n        if thisOp == 'ONES': fun = 10\n        if thisOp == 'MRG' : fun = 11\n        if thisOp == 'FFO' : fun = 12\n        op3 = alu(fun,op1,op2)             # Call ALU to perform the function\n        if   mode in [4,5,6,11]: reg[reg1]       = op3\n                                           # Writeback ALU result in op3 result to a register\n        elif mode in [7,8,12]:   dMem[reg[reg1]] = op3\n                                            # Writeback result to mem pointed at by reg\n        elif mode in [9,10]:     dMem[lit]       = op3\n                                            # Writeback the result to memory\n    trace()                                 # Display the results line by line\n```", "```py\n\n['MOV', 'R0', '#8']\n['NEXT:', 'RND', 'R5']\n['MOV', '[R0]', 'R5']\n['DEC', 'R0']\n['BNE', 'NEXT']\n['MOV', 'R1', '#X']\n['MOV', 'R2', '#Y']\n['MOV', 'R3', '#Z']\n['MOV', 'R4', '#6']\n['LOOP:', 'MOV', 'R5', '[R1]']\n['ADD', 'R5', '#6']\n['ADD', 'R5', '[R2]']\n['MOV', '[R3]', 'R5']\n['INC', 'R1']\n['INC', 'R2']\n['INC', 'R3']\n['DEC', 'R4']\n['BNE', 'LOOP']\n['STOP', '00', '1111', '0']\n```", "```py\n\nX        1\nY        5\nZ        9\nNEXT     1\n```", "```py\nLOOP     9\n```", "```py\n\nMOV R0 #8    pc=0   110000010000000000001000 Class=3 mode=4 MOV t1=R0 #8\nNEXT: RND R5 pc=1   100010001010100000000000 Class=2 mode=2 RND   t1=R5\nMOV [R0] R5  pc=2   110000011100010100000000 Class=3 mode=7 MOV   t1=[R0]  R5\nDEC R0       pc=3   100001001000000000000000 Class=2 mode=2 DEC   t1=R0\nBNE NEXT     pc=4   010010000100000000000001 Class=1 mode=1 BNE   t1=NEXT\nMOV R1 #X    pc=5   110000010000100000000001 Class=3 mode=4 MOV   t1=R1    #X\nMOV R2 #Y    pc=6   110000010001000000000101 Class=3 mode=4 MOV   t1=R2    #Y\nMOV R3 #Z    pc=7   110000010001100000001001 Class=3 mode=4 MOV   t1=R3    #Z\nMOV R4 #6    pc=8   110000010010000000000110 Class=3 mode=4 MOV   t1=R4   #6\nLOOP: MOV R5 [R1]  pc=9   110000011010100100000000 Class=3 mode=6 MOV   t1=R5    [R1]\nADD R5 #6    pc=10  110001010010100000000110 Class=3 mode=4 ADD   t1=R5   #6\nADD R5 [R2]  pc=11  110001011010101000000000 Class=3 mode=6 ADD   t1=R5   R2]\nMOV [R3] R5  pc=12  110000011101110100000000 Class=3 mode=7 MOV   t1=[R3]  R5\nINC R1       pc=13  100000001000100000000000 Class=2 mode=2 INC   t1=R1\nINC R2       pc=14  100000001001000000000000 Class=2 mode=2 INC   t1=R2\nINC R3       pc=15  100000001001100000000000 Class=2 mode=2 INC   t1=R3\nDEC R4       pc=16  100001001010000000000000 Class=2 mode=2 DEC   t1=R4\nBNE LOOP     pc=17  010010000100000000001001 Class=1 mode=1 BNE   t1=LOOP\nSTOP 00 1111 0  pc=18  001110000000000000000000 Class=0 mode=0 STOP  t1=00    1111\n```", "```py\n\n>>> \nMOV R0 #8            pc = 0   110000010000000000001000 \nClass = 3 mode = 4 \nReg = 08 00 00 00 00 00 00 00 \nMem = 00 00 00 00 00 00 00 00 00 00 00 \nC = 0 Z = 0 N = 0\nNEXT: RND R5         pc = 1   100010001010100000000000 \nClass = 2 mode = 2 \nReg = 08 00 00 00 00 8f 00 00 \nMem = 00 00 00 00 00 00 00 00 00 00 00 \nC = 0 Z = 0 N = 0\nMOV [R0] R5         pc = 2   110000011100010100000000 \nClass = 3 mode = 7 \nReg = 08 00 00 00 00 8f 00 00 \nMem = 00 00 00 00 00 00 00 00 8f 00 00 \nC = 0 Z = 0 N = 1\nDEC R0             pc = 3   100001001000000000000000 \nClass = 2 mode = 2 \nReg = 07 00 00 00 00 8f 00 00 \nMem = 00 00 00 00 00 00 00 00 8f 00 00 \nC = 0 Z = 0 N = 0\nBNE NEXT             pc = 4   010010000100000000000001 \nClass = 1 mode = 1 \nReg = 07 00 00 00 00 8f 00 00 \nMem = 00 00 00 00 00 00 00 00 8f 00 00 \nC = 0 Z = 0 N = 0\nNEXT: RND R5         pc = 1   100010001010100000000000 \nClass = 2 mode = 2 \nReg = 07 00 00 00 00 35 00 00 \nMem = 00 00 00 00 00 00 00 00 8f 00 00 \nC = 0 Z = 0 N = 0\n```", "```py\nAllOps = {0:'clr', 1:'add',2:'sub',3:'mul'}    # just four entries to make easy reading.\n```", "```py\n\nresult,Zero,Neg,oVerflow,carry = alu(0,A,B,0,1)\n```", "```py\n\n# This function simulates an 8-bit ALU and provides 16 operations\n# It is called by alu(op,a,b,cIn,display). Op defines the ALU function\n# a,b and cIn are the two inputs and the carry in\n# If display is 1, the function prints all input and output on the terminal\n# Return values: q, z, n, v, cOut) q is the result\ndef alu(op,a,b,cIn,display):\n    allOps = {0:'clr', 1:'add',2:'sub',3:'mul',4:'div',5:'and',6:'or', \\\n              7:'not', 8:'eor', 9:'lsl',10:'lsr', 11:'adc',12:'sbc',   \\\n              13:'min',14:'max',15:'mod'}\n    a, b = a & 0xFF, b & 0xFF             # Ensure the input is 8 bits\n    cOut,z,n,v = 0,0,0,0                  # Clear all status flags\n    if   op == 0:   q = 0                 # Code 0000 clear\n    elif op == 1:   q = a + b             # Code 0001 add\n    elif op == 2:   q = a - b             # Code 0010 subtract\n    elif op == 3:   q = a * b             # Code 0011 multiply\n    elif op == 4:   q = a // b            # Code 0100 divide\n    elif op == 5:   q = a & b             # Code 0100 bitwise AND\n    elif op == 6:   q = a | b             # Code 0100bitwise OR\n    elif op == 7:   q = ~a                # Code 0111 bitwise negate (logical complement)\n    elif op == 8:   q = a ^ b             # Code 0100 bitwise EOR\n    elif op == 9:   q = a << b            # Code 0100 bitwise logical shift left b places\n    elif op == 10:  q = a >> b            # Code 0100 bitwise logical shift right b places\n    elif op == 11:  q = a + b + cIn       # Code 0100 add with carry in\n    elif op == 12:  q = a - b - cIn       # Code 0100 subtract with borrow in\n    elif op == 13:                        # Code 1101 q = minimum(a,b)\n       if a > b: q = b\n       else:     q = a\n    elif op == 14:                        # Code 1110 q = maximum(a,b)\n       if a > b: q = a                    # Note: in unsigned terms\n       else:     q = b\n    elif op == 15:                        # Code 1111 q = mod(a)\n       if a > 0b01111111: q = (~a+1)&0xFF # if a is negative q = -a (2s comp)\n       else:     q = a                    # if a is positive q =  a\n# Prepare to exit: Setup flags\n    cOut = (q&0x100)>>8                   # Carry out is bit 8\n    q    =  q & 0xFF                      # Constrain result to 8 bits\n    n    = (q & 0x80)>>7                  # AND q with 10000000 and shift right 7 times\n    if q == 0: z = 1                      # Set z bit if result zero\n    p1 = ( (a&0x80)>>7)& ((b&0x80)>>7)&~((q&0x80)>>7)\n    p2 = (~(a&0x80)>>7)&~((b&0x80)>>7)& ((q&0x80)>>7)\n    if p1 | p2 == True: v = 1             # Calculate v-bit (overflow)\n    if display == 1:                      # Display parameters and results\n       a,b = a&0xFF, b&0xFF               # Force both inputs to 8 bits\n       print('Op =',allOps[op],'Decimals: a =',a,' b =',b, \\\n             'cIn =',cIn,'Result =',q)\n       print('Flags: Z =',z, 'N =',n, 'V =',v, 'C =',cOut)\n       print('Binaries A =',format(a,'08b'), 'B =',format(b,'08b'), \\\n             'Carry in =',format(cIn,'01b'), 'Result =',format(q,'08b'))\n       print ()\n    return (q, z, n, v, cOut)             # Return c (result), and flags as a tuple\n```", "```py\n\n#### MAIN BODY\ndef literal(lit):\n    if   lit.isnumeric(): lit =  int(lit)        # If decimal convert to integer\n    elif lit[0]  == '%': lit =  int(lit[1:],2)   # If binary string convert to int\n    elif lit[0:1]== '$': lit =  int(lit[1:],16)  # If hex string convert to int\n    elif lit[0]  == '-': lit = -int(lit[1:])&0xFF # If negative convert to signed int\n    return(lit)\nopsRev = {'clr':0,'add':1,'sub':2,'mul':3,'div':4,'and':5,'or':6,     \\\n          'not':7,'eor':8,'lsl':9,'lsr':10,'adc':11,'sbc':12,         \\\n          'min':13,'max':14,'mod':15}\nx,y,op1,op2,cIn = 0,0,0,0,0                      # Dummy value prior to test in while loop\nwhile True:\n    x = input('Enter operation and values ')\n    if x == '': break                            # Exit on return\n    y = x.split()                                # Divide into tokens\n    print (y)                                    # Show the input\n    fun = opsRev[y[0]]                           # Convert function name into number\n    if len(y) > 1: op1 = literal(y[1])           # One parameter\n    if len(y) > 2: op2 = literal(y[2])           # Two parameters\n    if len(y) > 3: cIn = literal(y[3])           # Three parameters\n    q, z, n, v, cOut  = alu(fun,op1,op2,cIn,1)   # Call the ALU function\n                                                 # Repeat until return entered\n```", "```py\n\nEnter operation and values add 25 $1F\n['add', '25', '$1F']\nOperation =  add Decimals: a = 25  b = 31 cIn = 0 Result = 56\nFlags: Z = 0 N = 0 V = 0 C = 0\nBinaries A = 00011001 B = 00011111 Carry in = 0 Result = 00111000\nEnter operation and values add %11111111 1\n['add', '%11111111', '1']\nOperation =  add Decimals: a = 255  b = 1 cIn = 0 Result = 0\nFlags: Z = 1 N = 0 V = 0 C = 1\nBinaries A = 11111111 B = 00000001 Carry in = 0 Result = 00000000\nEnter operation and values add 126 2\n['add', '126', '2']\nOperation =  add Decimals: a = 126  b = 2 cIn = 0 Result = 128\nFlags: Z = 0 N = 1 V = 1 C = 0\nBinaries A = 01111110 B = 00000010 Carry in = 0 Result = 10000000\nEnter operation and values add 7 -2\n['add', '7', '-2']\nOperation =  add Decimals: a = 7  b = 254 cIn = 0 Result = 5\nFlags: Z = 0 N = 0 V = 0 C = 1\nBinaries A = 00000111 B = 11111110 Carry in = 0 Result = 00000101\nEnter operation and values add 128 -2\n['add', '128', '-2']\nOperation =  add Decimals: a = 128  b = 254 cIn = 0 Result = 126\nFlags: Z = 0 N = 0 V = 1 C = 1\nBinaries A = 10000000 B = 11111110 Carry in = 0 Result = 01111110\nEnter operation and values and $A7 %11110001\n['and', '$A7', '%11110001']\nOperation =  and Decimals: a = 167  b = 241 cIn = 0 Result = 161\nFlags: Z = 0 N = 1 V = 0 C = 0\nBinaries A = 10100111 B = 11110001 Carry in = 0 Result = 10100001\nEnter operation and values lsl %11100011 2\n['lsl', '%11100011', '2']\nOperation =  lsl Decimals: a = 227  b = 2 cIn = 0 Result = 140\nFlags: Z = 0 N = 1 V = 0 C = 1\nBinaries A = 11100011 B = 00000010 Carry in = 0 Result = 10001100\nEnter operation and values\n```", "```py\nimport re                          # Library for regular expressions for removing spaces  (See 1)\nfrom random import  *              # Random number library\nimport sys                         # Operating system call library\nfrom datetime import date          # Import date function                      (See 2)\nbPt = []                           # Breakpoint table (labels and PC values)\nbActive = 0\ntoday = date.today()               # Get today's date                         (See 2)\nprint('Simulator', today, '\\n')\ndeBug, trace, bActive  = 0, 0, 0   # Turn off debug, trace and breakpoint modes       (See 3)\nx1 = input('D for debug >>> ')     # Get command input\nif x1.upper() == 'D': deBug = 1    # Turn on debug mode if 'D' or 'd' entered\nx2 = input('T or B')               # Get command input\nx2 = x2.upper()                    # Convert to upper-case\nif x2 == 'T': trace = 1            # Turn on trace mode if 'T' or 't' entered\nelif x2 == 'B':                    # If 'B' or 'b' get breakpoints until 'Q' input          (See 4)\n    next = True\n    bActive = 1                    # Set breakpoint active mode\n    while next == True:            # Get breakpoint as either label or PC value\n        y = input('Breakpoint ')\n        y = y.upper()\n        bPt.append(y)              # Put breakpoint (upper-case) in table\n        if y == 'Q': next = False\n    if deBug == 1:                 # Display breakpoint table if in debug mode\n        print ('\\nBreakpoint table')\n        for i in range (0,len(bPt)): print(bPt[i])\n        print()\nprint()\n```", "```py\n\ndef memProc(src):                                # Memory processing   \n    global memPoint, memD                        # Deal with directives\n    for i in range(len(src)):                    # and remove directives from source code\n        if src[i][0] == '.WORD':                 # Test for .word directive\n            lit = get_lit(src[i],2)              # Get the literal value\n            sTab.update({src[i][1]:memPoint})    # Bind literal name to the memory address\n            memD[memPoint] = lit                 # Store the literal in memory\n            memPoint = memPoint + 1              # Move the memory pointer on one word\n        if src[i][0] == '.ASCII':                # .ASCII: test for an ASCII character\n            sTab.update({src[i][1]:memPoint})    # Bind name to memory address\n            character = ord(src[i][2])           # Convert character to numeric form\n            memD[memPoint] = character        # Store the character in memory as ASCII code\n            memPoint = memPoint + 1           # Move the memory pointer on\n        if src[i][0] == '.DSW':               # Test for .DSW to reserve locations in memory\n            sTab.update({src[i][1]:memPoint}) # Save name in table and bind to memory address\n            memPoint = memPoint + int(src[i][2]) # Move memory pointer by space required\n    src = [i  for i in src if i[0] != '.WORD']   # Remove .word from source\n    src = [i  for i in src if i[0] != '.ASCII']  # Remove .ASCII from source\n    src = [i  for i in src if i[0] != '.DSW']    # Remove .DSW from source\n    memD[memPoint] = 'END'                    # Add terminator to data memory (for display)\n```", "```py\n    return(src)\n```", "```py\n\ndef get_reg(pred,p):                     # Extract a register number from predicate\n    reg = pred[p]                        # Read token p is the predicate\n    if reg in sTab:                      # Check if this is a symbolic name\n        reg = sTab.get(reg)              # If symbolic name read it from symbol table\n        reg = int(reg[1:])               # Convert register name into number\n    else: reg = int(reg[1:])             # If not symbolic name convert name into number\n    return(reg)                          # Otherwise return the register number\n```", "```py\n\ndef get_lit(pred,p):                              # Extract literal from place p in predicate\n    global sTab                                   # We need the symbol table\n    lit = pred[p]                                 # Read the literal from the predicate\n    if lit in sTab:                               # If literal is in symbol table, look it up\n        lit = int(sTab.get(lit))\n    else:                                         # Convert literal format to an integer\n        if   lit[0]   == \"%\": lit = int(pred[-1][1:],2)   # If prefix % then binary\n        elif lit[0:2] == \"0X\": lit = int(pred[-1][2:],16)\n                                                     # If prefix 0X then hexadecimal\n        elif lit[0].isnumeric(): lit = int(pred[-1]) # If numeric get it\n        elif lit[0].isalpha(): lit = ord(lit)        # Convert ASCII character to integer\n        elif lit[0:2] == \"0X\": lit = int(pred[-1][2:],16)\n                                                     # If prefix 0X then hexadecimal\n        else:  lit = 0                               # Default (error) value 0\n    return(lit)\n```", "```py\n\ndef display():                                # Print the state after each instruction\n    thisOp = ' '.join(src[pcOld])             # Join this op-code's tokens into a string\n    a =[format(x,'04x') for x in r]           # Format registers into hex strings\n    b = (' ').join(a)                         # Join the hex strings with a space\n    f1 = f'{pcOld:<4}'                        # Format the PC as a string\n    f2 = f'{thisOp:<18}'                      # Format the instruction to fixed width\n    print('PC =',f1,'Reg =',b,'Z =',z,'N =',n,'C =',c,f2)       # Print the data\n```", "```py\n    return()\n```", "```py\n\ndef alu(a,b,f):    # ALU for addition/subtraction and flag calculation                    (See 6)\n# a and b are the numbers to add/subtract and f the function\n    global z,c,n                      # Make flags global\n    z,c,n = 0,0,0                     # Clear flags initially\n    if f == 1: s = a + b              # f = 1 for add\n    if f == 2: s = a - b              # f = 2 for subtract\n    s = s & 0x1FFFF                   # Constrain result to 17 bits\n    if s > 0xFFFF: c = 1              # Carry set if 17th bit 1\n    if 0x8000 & s == 0x8000 : n = 1   # Bit 15 set to 1 for negative\n    if s & 0xFFFF == 0: z = 1         # Zero flag set to 1 if bits 0-15 all 0\n    s = 0xFFFF & s                    # Ensure 16-bit result\n    return(s)\ncodes = {\"STOP\":(0,0),\"NOP\":(0,1),\"RND\":(1,4),\"BRA\":(2,5),\"BEQ\":(2,6),      \\\n         \"BNE\":(2,7),\"MOV\":(3,8),\"LDRM\":(4,9),\"LDRL\":(4,10),\"LDRI\":(7,11),  \\\n         \"LDRI+\":(7,12),\"STRM\":(4,13),\"STRI\":(7,14),\"STRI+\":(7,15),         \\\n         \"ADD\":(5,16),\"ADDL\":(6,17),\"SUB\":(5,18),\"SUBL\":(6,19),             \\\n         \"AND\":(5,20),\"ANDL\":(6,21),\"OR\":(5,22),\"ORL\":(6,23), \"EOR\":(5,24), \\\n         \"EORL\":(6,25),\"CMP\":(3,26),\"CMPL\":(4,27),\"LSL\":(3,28),             \\\n         \"LSR\":(3,29),\"ROL\":(3,30),\"ROR\": (3,31), \"BSR\":(2,32),             \\\n         \"RTS\":(0,33),\"PUSH\":(1,34),\"POP\":(1,35),\"BL\":(2,36),\"RL\":(0,37),   \\\n         \"INC\":(1,48), \"DEC\":(1,49), \"PRT\":(1,3), \"BHS\": (2,71)}\n# Style Code Format (a,b) where a is the instruction style and b is the actual op-code\n# 0     Zero operand               STOP\n# 1     Destination register operand    INC  R0\n# 2     Literal operand              BEQ  5\n# 3     Two registers: Rd, Rs1          MOV  R2,R4\n# 4     Register and literal Rd L         LDR  R6,23\n# 5     Three registers: Rd, Rs1, Rs2       ADD  R1,R2,R3\n# 6     Two registers, literal Rs, Rd1, L    ADDL R1,R2,9\n# 7     Indexed, Rd, Rs, L            LDRI R4,(R6,8)\n# 8     UNDEFINED\ntestFile = 'E:/ArchitectureWithPython/TC4_test.txt'  # Source filename on my computer\nwith open(testFile) as myFile:        # Open source file with assembly language program\n    lines = myFile.readlines()        # Read the program into lines\nmyFile.close()                        # Close the source file (not actually needed)\nlines = [i[0:-1]  for i in lines ]    # Remove the /n newline from each line of the source code\nsrc = lines                        # Copy lines to variable scr (i.e., source code)\nif deBug == 1:                     # If in debug mode print the source file           (See 3)\n    print('Debug mode: original source file')\n    for i in range(0,len(src)): print(i, src[i])    # Listing file\n```", "```py\n\nfor i in range(0,len(src)):              # Remove comments from source\n   src[i] = src[i].split('@',1)[0]       # Split line on first occurrence of @ and keep first item\nsrc = [i.strip(' ') for i in src ]          # Remove leading and trailing spaces\nsrc = [i for i in src if i != '']           # Remove blank lines\nsrc = [i.upper() for i in src]              # Convert lower- to upper-case\nsrc = [re.sub('+', ' ',i) for i in src ]    # Remove multiple spaces     1\nsrc = [i.replace(', ',' ') for i in src]    # Replace commas space by single space\nsrc = [i.replace('[','') for i in src]      # Remove [ in register indirect mode\nsrc = [i.replace(']','') for i in src]      # Remove [\nsrc = [i.replace(',',' ') for i in src]     # Replace commas by spaces\nsrc = [i for i in src if i[0] != '@']       # Remove lines with just a comment\nsrc = [i.split(' ')  for i in src]          # Tokenize\nif deBug == 1:                              # If in debug mode print the source file\n    print('\\nProcessed source file\\n')\n    [print(i) for i in src]\n# Initialize key variables\n# memP program memory, memD data memory\nsTab = {}                                   # Set up symbol table for labels and equates\nmemP = [0] * 64                             # Define program memory\nmemD = [0] * 64                             # Define data memory\nmemPoint = 0                                # memPoint points to next free  location\n[sTab.update({i[1]:i[2]}) for i in src if i[0] == '.EQU']\n                                            # Scan source file and deal with equates\nsrc = [i  for i in src if i[0] != '.EQU']   # Remove equates from source\nsrc = memProc(src)                          # Deal with memory-related directives\nfor i in range (0,len(src)):                # Insert labels in symbol table\n    if src[i][0][-1]== ':': sTab.update({src[i][0][0:-1]:i})\n                                            # Remove the colon from labels\nprint('\\nSymbol table\\n')\nfor x,y in sTab.items(): print(\"{:<8}\".format(x),y)    # Display symbol table\nif deBug == 1:\n    print(\"\\nListing with assembly directives removed\\n\")\n    for i in range(0,len(src)):             # Step through each line of code\n        z = ''                              # Create empty string for non-labels\n        if src[i][0][-1] != ':': z = '        '\n                                            # Create 8-char empty first spaced\n        for j in range(0,len(src[i])):      # Scan all tokens of instruction\n            y = src[i][j]                   # Get a token\n            y = y.ljust(8)                  # Pad it with spaces with a width of 8 characters\n            z = z + y                       # Add it to the line\n        print(str(i).ljust(3),z)            # Print line number and instruction\nif deBug == 1:                              # Display data memory for debugging\n    print(\"\\nData memory\")\n    [print(memD[i]) for i in range(0,memPoint+1)]  # print pre-loaded data in memory\n    print()\n#### MAIN ASSEMBLY LOOP\nif deBug == 1: print('Assembled instruction\\n')    # If in debug mode print heading 4\n```", "```py\n\npc = 0\nfor pc in range(0,len(src)):\n    rD,rS1,rS2,lit = 0,0,0,0                      # Initialize operand fields\n    if src[pc][0][-1] != ':':                     # Extract mnemonic and predicate\n        mnem  = src[pc][0]\n        if len(src[pc]) > 1: pred = src[pc][1:]   # Check for single mnemonic only\n        else: pred = '[]'                         # If only mnemonic with no predicate\n    else:\n        mnem  = src[pc][1]                        # For lines with a label\n        if len(src[pc]) > 2: pred = src[pc][2:]   # Get predicate if one exists\n        else: pred = '[]'                         # If only mnemonic, no pred\n    if mnem in codes:\n       opFormat = codes.get(mnem)                 # Read of op-code format of mnemonic\n```", "```py\n    else: print('Illegal opcode ERROR, mnem')     # Display error message\n```", "```py\n\n# OP-CODE FORMATS\n    if opFormat[0] == 1:            # Type 1 single register rD: inc r0\n        rD = get_reg(pred,0)\n    if opFormat[0] == 2:            # Type 2 literal operand: BEQ 24\n        lit = get_lit(pred,-1)\n    if opFormat[0] == 3:            # Type 3 two registers dD, rS1: MOV r3,R0\n        rD  = get_reg(pred,0)\n        rS1 = get_reg(pred,1)\n    if opFormat[0] == 4:            # Type 4 register and literal Rd, lit: LDRL R1,34\n        rD  = get_reg(pred,0)\n        lit = get_lit(pred,-1)\n    if opFormat[0] == 5:            # Type 5 three registers Rd, Rs1 Rs2: ADD  R1,R2,R3\n        rD  = get_reg(pred,0)\n        rS1 = get_reg(pred,1)\n        rS2 = get_reg(pred,2)\n    if opFormat[0] == 6:            # Type 6 two registers and lit Rd, Rs1 lit: ADD  R1,R2,lit\n        rD  = get_reg(pred,0)\n        rS1 = get_reg(pred,1)\n        lit = get_lit(pred,-1)\n    if opFormat[0] == 7:            # Type 7 two registers and lit Rd, Rs1 lit: LDR  R1,(R2,lit)\n        rD  = get_reg(pred,0)\n        pred[1] = pred[1].replace('(','')    # Remove brackets\n        pred[2] = pred[2].replace(')','')\n        rS1 = get_reg(pred,1)\n        lit = get_lit(pred,-1)\n    if opFormat[0] == 8:                     # Type 8 UNDEFINED\n        pass\n```", "```py\n\n    opCd     = opFormat[1] << 25    # Move op-code to left-most 7 bits\n    rDs      = rD          << 22    # Move destination reg into place\n    rS1s     = rS1         << 19    # Move source reg 1 in place\n    rS2s     = rS2         << 16    # Move source reg 2 in place\n    binCode=opCd|rDs|rS1s|rS2s|lit  # Assemble the instruction by combining fields\n    memP[pc] = binCode              # Store 32-bit binary code in program memory\n    if deBug == 1:                  # If in debug mode show the binary output of the assembler\n        a1 = f'{pc:<4}'             # Format for the PC (4 chars wide)\n        a2 = format(binCode,'032b') # Create 32-bit binary string for op-code\n        a3 = f'{mnem:<5}'           # Format the mnemonic to 5 places\n        a4 = f'{rD:<4}'             # Format source register to 4 places\n        a5 = f'{rS1:<4}'\n        a6 = f'{rS2:<4}'\n        a7 = f'{lit:<6}'\n        print('PC =',a1,a2,a3,a4,a5,a6,a7,src[pc]) # Assemble items and print them\n# CODE EXECUTE LOOP\nprint('\\nExecute code\\n')\n```", "```py\n\nr = [0] * 8                                   # Register set\nstack = [0] * 16                              # stack with 16 locations           See 7\nsp = 16                                       # stack pointer initialize to bottom of stack + 1\nlr = 0                                        # link register initialize to 0\nrun = 1                                       # run = 1 to execute code\npc = 0                                        # Initialize program counter\nz,c,n = 0,0,0                                 # Clear flag bits. Only z-bit is used\nwhile run == 1:                               # Main loop\n    instN = memP[pc]                          # Read instruction\n    pcOld = pc                                # Remember the pc (for printing)\n    pc = pc + 1                               # Point to the next instruction\n    op  = (instN >> 25) & 0b1111111           # Extract the op-code (7 most-significant bits)\n    rD  = (instN >> 22) & 0b111               # Extract the destination register\n    rS1 = (instN >> 19) & 0b111               # Extract source register 1\n    rS2 = (instN >> 16) & 0b111               # Extract source register 2\n    lit = (instN      ) & 0xFFFF              # Extract literal in least-significant 16 bits\n    rDc = r[rD]                               # Read destination register contents)\n    rS1c = r[rS1]                             # Read source register 1 contents\n    rS2c = r[rS2]                             # Read source register 2 contents\n```", "```py\n\n# Instruction execution\n    if op == 0b0000001:           # NOP   Nothing to see here ... it's NOP so just drop out\n        pass\n    if op == 0b0000100:           # RND     # RND r0 generates random number in r0\n       r[rD] = randint(0,0xFFFF)\n    if op == 0b0000101:           # BRA     # Branch to the label or literal. Absolute address\n        pc = lit\n    if op == 0b0000110:           # BEQ     # Branch on zero flag\n        if z == 1: pc = lit\n    if op == 0b0000111:           # BNE     # Branch on not zero\n        if z != 1: pc = lit\n    if op == 0b1000111:           # BHS    # Branch on unsigned higher or same     (See 8)\n        if c == 0 : pc = lit\n    if op == 0b0001000:           # MOV    # Copy one register to another\n        r[rD] = rS1c\n    if op == 0b0001001:           # LDRM    # Load register from address in memory\n        r[rD] = memD[lit]\n    if op == 0b0001010:           # LDRL    # Load register with a literal\n        r[rD] = lit\n    if op == 0b0001011:           # LDRI    # Load register indirect with offset; LDRI r1,[r2,4]\n        r[rD] = memD[rS1c + lit]\n    if op == 0b0001100:           # LDRI+   # Auto-indexed. Increment pointer after use (See 9)\n        r[rD] = memD[rS1c + lit]\n        r[rS1] = rS1c + 1\n    if op == 0b0001101:           # STRM    #\n        memD[lit] = rDc\n    if op == 0b0001110:           # STRI     # Store register indexed\n        memD[rS1c + lit] = rDc\n    if op == 0b0001111:           # STRI+    # Auto indexed\n        memD[rS1c + lit] = rDc\n        r[rS1] = rS1c + 1\n    if op == 0b0010000:           # ADD     # r1 = r2 + r3\n        r[rD] = alu(rS1c,rS2c,1)\n    if op == 0b0010001:           # ADDL    # r1 = r2 + literal\n        r[rD] = alu(rS1c,lit,1)\n    if op == 0b0010010:                    # SUB\n        r[rD] = alu(rS1c,rS2c,2)\n    if op == 0b0010011:                    # SUBL\n        r[rD] = alu(rS1c,lit,2)\n    if op == 0b0010100:                    # AND\n        r[rD] = (rS1c & rS2c) & 0xFFFF\n    if op == 0b0010101:                    # ANDL\n        r[rD] = (rS1c & lit) & 0xFFFF\n    if op == 0b0010110:                    # OR\n        r[rD] = (rS1c | rS2c) & 0xFFFF\n    if op == 0b0010111:                    # ORL\n        r[rD] = (rS1c | lit) & 0xFFFF\n    if op == 0b0011000:                    # EOR (XOR)\n        r[rD] = (rS1c ^ rS2c) & 0xFFFF\n    if op == 0b0011001:                    # EORL (XORL)\n        r[rD] = (rS1c ^ lit) & 0xFFFF\n    if op == 0b0011010:                    # CMP\n        diff = alu(rDc,rS1c,2)\n    if op == 0b0011011:                    # CMPL\n        diff = alu(rDc,lit,2)\n    if op == 0b0011100:                    # LSL\n        r[rD] = (rS1c << 1) & 0xFFFF\n    if op == 0b0011101:                    # LSR\n        r[rD] = (rS1c >> 1) & 0xFFFF\n    if op == 0b0011110:                    # ROL\n        bitLost = (rS1c & 0x8000) >> 16\n        rS1c = (rS1c << 1) & 0xFFFF\n        r[rD] = rS1c | bitLost\n    if op == 0b0011111:                    # ROR\n        bitLost = (rS1c & 0x0001)\n        rS1c = (rS1c >> 1) & 0xFFFF\n        r[rD] = rS1c | (bitLost << 16)\n```", "```py\n\n    if op == 0b0100000:    # BSR\n        sp = sp - 1\n        stack[sp] = pc\n        pc = lit\n    if op == 0b0100001:                    # RTS\n        pc = stack[sp]\n        sp = sp + 1\n    if op == 0b0100010:                    # PUSH                       (See 7)\n        sp = sp - 1\n        stack[sp] = rDc\n    if op == 0b0100011:                    # POP                        (See 7)\n        r[rD] = stack[sp]\n        sp = sp + 1\n    if op == 0b0100100:                    # BL branch with link               (See 10)\n        lr = pc\n        pc = lit\n    if op == 0b0100101:                    # RL return from link\n        pc = lr\n    if op == 0b0110000:                    # INC\n        r[rD] = alu(rDc,1,1)\n    if op == 0b0110001:                    # DEC\n        r[rD] = alu(rDc,1,2)\n    if op == 0b0000011:    # PRT r0 displays the ASCII character in register r0             See 11\n        character = chr(r[rD])\n        print(character)\n    if op == 0b0000000:                    # STOP\n        run = 0\n# END OF CODE EXECUTION Deal with display\n    if bActive ==1:                        # Are breakpoints active?\n        if src[pcOld][0] in bPt:           # If the current label or mnemonic is in the table\n            display()                      # display the data\n        if str(pcOld) in bPt:              # If the current PC (i.e., pcOld) is in the table display\n            display()\n    if trace == 1:                         # If in trace mode, display registers\n        x = input('<< ')                   # Wait for keyboard entry (any key will do)\n        display()                          # then display current operation\n    elif bActive != 1: display()           # If not trace and not breakpoints, display registers\n    if run == 0:                           # Test for end of program             See 12\n        print('End of program')            # If end, say 'Goodbye'\n        sys.exit()                         # and return\n```", "```py\n\n    @ TC4_test\n    @ 31 Oct 2021\n          .equ abc 4\n    .word aaa abc\n    .word bbb 5\n    .dsw   dataA 6             @ data area to store numbers\n    .word  end 0xFFFF\n     ldrl r0,0xF\n     addl r1,r7,2\n     bl lk\n    back: rnd r0\n           ldrl r3,dataA       @ r3 points at data area\n           ldrm r4,bbb         @ r4 contains value to store\n     ldrl r5,4                 @number of words to store\n    loop: nop                  @\n          bsr sub1\n          dec r5\n     bne loop\n     stop\n    sub1: stri r4,[r3,0]\n       inc r3\n       addl r4,r4,2\n       cmpl r4,9\n       bne skip\n       addl r4,r4,6\n    skip:  rts\n    lk: ldrl r6,%11100101\n            andl r7,r6,0xF0\n     rl\n    ```"]