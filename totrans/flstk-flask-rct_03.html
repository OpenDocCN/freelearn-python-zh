<html><head></head><body>
<div id="_idContainer036">
<h1 class="chapter-number" id="_idParaDest-43"><a id="_idTextAnchor064"/><span class="koboSpan" id="kobo.1.1">3</span></h1>
<h1 id="_idParaDest-44"><a id="_idTextAnchor065"/><span class="koboSpan" id="kobo.2.1">Managing State with React Hooks</span></h1>
<p><a id="_idTextAnchor066"/><a href="B18554_02.xhtml#_idTextAnchor038"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.3.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.4.1">, </span><em class="italic"><span class="koboSpan" id="kobo.5.1">Getting Started with React</span></em><span class="koboSpan" id="kobo.6.1">, was a great way to kick off React frontend development. </span><span class="koboSpan" id="kobo.6.2">By now, you should be familiar with project directory structures and a few other concepts in React. </span><span class="koboSpan" id="kobo.6.3">In this chapter, we will take your understanding of React’s core </span><span class="No-Break"><span class="koboSpan" id="kobo.7.1">concepts further.</span></span></p>
<p><span class="koboSpan" id="kobo.8.1">Why does this matter? </span><span class="koboSpan" id="kobo.8.2">Simple. </span><span class="koboSpan" id="kobo.8.3">You can’t be the shining light you intend to be with React development without getting a grounding in the React core features and how we use them. </span><span class="koboSpan" id="kobo.8.4">This chapter focuses on managing state with </span><span class="No-Break"><span class="koboSpan" id="kobo.9.1">React </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.10.1">Hooks</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.11.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.12.1">State in React is the medium through which we add interactivity to the user interface. </span><span class="koboSpan" id="kobo.12.2">Before React v16.8, developing class components was the only way you could add state and state transitions to </span><span class="No-Break"><span class="koboSpan" id="kobo.13.1">your components.</span></span></p>
<p><span class="koboSpan" id="kobo.14.1">Functional components were stateless; they were only able to display </span><strong class="bold"><span class="koboSpan" id="kobo.15.1">JavaScript XML </span></strong><span class="koboSpan" id="kobo.16.1">(</span><strong class="bold"><span class="koboSpan" id="kobo.17.1">JSX</span></strong><span class="koboSpan" id="kobo.18.1">) elements, that is, presentational components only. </span><span class="koboSpan" id="kobo.18.2">But with the Hooks API, you can add state and state transitions to your </span><span class="No-Break"><span class="koboSpan" id="kobo.19.1">functional components.</span></span></p>
<p><span class="koboSpan" id="kobo.20.1">In this chapter, you will come to understand various React hooks and how we use them to add statefulness to functional components. </span><span class="koboSpan" id="kobo.20.2">The building blocks of any React application are components, and making them stateful is what enhances the user experience of </span><span class="No-Break"><span class="koboSpan" id="kobo.21.1">web applications.</span></span></p>
<p><span class="koboSpan" id="kobo.22.1">By the end of this chapter, you will be able to build stateful function components with hooks such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.23.1">useState</span></strong><span class="koboSpan" id="kobo.24.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.25.1">useEffect</span></strong><span class="koboSpan" id="kobo.26.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.27.1">useContext</span></strong><span class="koboSpan" id="kobo.28.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.29.1">useMemo</span></strong><span class="koboSpan" id="kobo.30.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.31.1">useReducer</span></strong><span class="koboSpan" id="kobo.32.1">, and even be able to develop your own </span><span class="No-Break"><span class="koboSpan" id="kobo.33.1">custom Hooks.</span></span></p>
<p><span class="koboSpan" id="kobo.34.1">In this chapter, we will be covering the </span><span class="No-Break"><span class="koboSpan" id="kobo.35.1">following topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.36.1">What is a Hook </span><span class="No-Break"><span class="koboSpan" id="kobo.37.1">in React?</span></span></li>
<li><span class="koboSpan" id="kobo.38.1">Why use Hooks </span><span class="No-Break"><span class="koboSpan" id="kobo.39.1">in React?</span></span></li>
<li><span class="koboSpan" id="kobo.40.1">Using </span><strong class="source-inline"><span class="koboSpan" id="kobo.41.1">useState</span></strong><span class="koboSpan" id="kobo.42.1"> to develop </span><span class="No-Break"><span class="koboSpan" id="kobo.43.1">stateful components</span></span></li>
<li><span class="koboSpan" id="kobo.44.1">Using </span><strong class="source-inline"><span class="koboSpan" id="kobo.45.1">useEffect</span></strong><span class="koboSpan" id="kobo.46.1"> to create useful </span><span class="No-Break"><span class="koboSpan" id="kobo.47.1">side effects</span></span></li>
<li><span class="koboSpan" id="kobo.48.1">Using </span><strong class="source-inline"><span class="koboSpan" id="kobo.49.1">useContext</span></strong><span class="koboSpan" id="kobo.50.1"> to manage React applications’ </span><span class="No-Break"><span class="koboSpan" id="kobo.51.1">global state</span></span></li>
<li><span class="koboSpan" id="kobo.52.1">Using </span><strong class="source-inline"><span class="koboSpan" id="kobo.53.1">useRef</span></strong><span class="koboSpan" id="kobo.54.1"> to directly access DOM elements and persist </span><span class="No-Break"><span class="koboSpan" id="kobo.55.1">state values</span></span></li>
<li><span class="koboSpan" id="kobo.56.1">Using </span><strong class="source-inline"><span class="koboSpan" id="kobo.57.1">useReducer</span></strong><span class="koboSpan" id="kobo.58.1"> for </span><span class="No-Break"><span class="koboSpan" id="kobo.59.1">state management</span></span></li>
<li><span class="koboSpan" id="kobo.60.1">Using </span><strong class="source-inline"><span class="koboSpan" id="kobo.61.1">useMemo</span></strong><span class="koboSpan" id="kobo.62.1"> to </span><span class="No-Break"><span class="koboSpan" id="kobo.63.1">improve performance</span></span></li>
<li><span class="koboSpan" id="kobo.64.1">Using </span><strong class="source-inline"><span class="koboSpan" id="kobo.65.1">useCallback</span></strong><span class="koboSpan" id="kobo.66.1"> to avoid </span><span class="No-Break"><span class="koboSpan" id="kobo.67.1">re-rendering functions</span></span></li>
<li><span class="koboSpan" id="kobo.68.1">Using custom Hooks for </span><span class="No-Break"><span class="koboSpan" id="kobo.69.1">code reusability</span></span></li>
</ul>
<h1 id="_idParaDest-45"><a id="_idTextAnchor067"/><span class="koboSpan" id="kobo.70.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.71.1">The complete code for this chapter is available on GitHub </span><span class="No-Break"><span class="koboSpan" id="kobo.72.1">at: </span></span><a href="https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter03"><span class="No-Break"><span class="koboSpan" id="kobo.73.1">https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter03</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.74.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.75.1">Due to page count constraints, the code blocks have been snipped. </span><span class="koboSpan" id="kobo.75.2">Please refer to GitHub for the full </span><span class="No-Break"><span class="koboSpan" id="kobo.76.1">source code.</span></span></p>
<h1 id="_idParaDest-46"><a id="_idTextAnchor068"/><span class="koboSpan" id="kobo.77.1">What is a Hook in React?</span></h1>
<p><span class="koboSpan" id="kobo.78.1">A </span><strong class="bold"><span class="koboSpan" id="kobo.79.1">hook</span></strong><span class="koboSpan" id="kobo.80.1"> is a</span><a id="_idIndexMarker131"/><span class="koboSpan" id="kobo.81.1"> special function provided by React that lets you use React core features—state and component lifecycle methods—within a function component. </span><span class="koboSpan" id="kobo.81.2">While state is an in-built object in React that adds interactivity and dynamic mechanism to components, the lifecycle tracks the phases components go through, from their initialization to their eventual demise (when a user navigates away or exits from an </span><span class="No-Break"><span class="koboSpan" id="kobo.82.1">application UI).</span></span></p>
<p><span class="koboSpan" id="kobo.83.1">There are three major cyclic phases React components go through, as explained in </span><a href="B18554_02.xhtml#_idTextAnchor038"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.84.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.85.1">, </span><em class="italic"><span class="koboSpan" id="kobo.86.1">Getting Started with React</span></em><span class="koboSpan" id="kobo.87.1">: mounting, updating, and unmounting. </span><span class="koboSpan" id="kobo.87.2">Each of these phases has what we call lifecycle methods that can be used during the rendering of </span><span class="No-Break"><span class="koboSpan" id="kobo.88.1">React components.</span></span></p>
<p><span class="koboSpan" id="kobo.89.1">We observed the presence of certain methods, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.90.1">componentWillMount()</span></strong><span class="koboSpan" id="kobo.91.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.92.1">componentDidMount()</span></strong><span class="koboSpan" id="kobo.93.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.94.1">componentWillUpdate()</span></strong><span class="koboSpan" id="kobo.95.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.96.1">componentDidUpdate()</span></strong><span class="koboSpan" id="kobo.97.1">, during the class component’s lifecycle. </span><span class="koboSpan" id="kobo.97.2">React hooks</span><a id="_idIndexMarker132"/><span class="koboSpan" id="kobo.98.1"> are used to make function components stateful without using class components’ </span><span class="No-Break"><span class="koboSpan" id="kobo.99.1">lifecycle methods.</span></span></p>
<p><span class="koboSpan" id="kobo.100.1">If you were working with stateful components before React version 16.8, you had no choice but to use class components as the only way to incorporate statefulness into </span><span class="No-Break"><span class="koboSpan" id="kobo.101.1">your components.</span></span></p>
<p><span class="koboSpan" id="kobo.102.1">Let’s look at a component</span><a id="_idIndexMarker133"/><span class="koboSpan" id="kobo.103.1"> that changes a first name to a full name when a button </span><span class="No-Break"><span class="koboSpan" id="kobo.104.1">is clicked:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.105.1">import React from 'react';class App extends React.Component{
  constructor(props) {
    super(props);
    this.state = {
      name: "Andrew",
    }
    this.updateNameState = this.updateNameState.bind(this);
  }
  updateNameState(){
    this.setState({
      name: "Andrew Peter"}
);
  }
  render() {
    return(
      &lt;div&gt;
        &lt;p&gt;{this.state.name}&lt;/p&gt;
        &lt;button onClick={this.updateNameState}&gt;Display Full
          Name&lt;/button&gt;
      &lt;/div&gt;
    );
  }
}
export default App;</span></pre>
<p><span class="koboSpan" id="kobo.106.1">Let us understand the preceding code </span><span class="No-Break"><span class="koboSpan" id="kobo.107.1">in detail:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.108.1">import React from 'react'</span></strong><span class="koboSpan" id="kobo.109.1">: This line brings React library core features into </span><span class="No-Break"><span class="koboSpan" id="kobo.110.1">the scope.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.111.1">class App extends React.Component</span></strong><span class="koboSpan" id="kobo.112.1">: This declares our </span><strong class="source-inline"><span class="koboSpan" id="kobo.113.1">class App</span></strong><span class="koboSpan" id="kobo.114.1">, which extends the React component </span><span class="No-Break"><span class="koboSpan" id="kobo.115.1">base class.</span></span></li>
<li><span class="koboSpan" id="kobo.116.1">The following snippet defines a constructor that accepts </span><strong class="source-inline"><span class="koboSpan" id="kobo.117.1">props</span></strong><span class="koboSpan" id="kobo.118.1"> as </span><span class="No-Break"><span class="koboSpan" id="kobo.119.1">an argument:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.120.1">constructor(prop) {  super(props);  this.state = {    name: "Andrew",}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.121.1">This is a normal JavaScript class construct. </span><span class="koboSpan" id="kobo.121.2">Any class that extends the base class must have a </span><strong class="source-inline"><span class="koboSpan" id="kobo.122.1">super()</span></strong><span class="koboSpan" id="kobo.123.1"> method defined. </span><span class="koboSpan" id="kobo.123.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.124.1">this.state={name:"Andrew",}</span></strong><span class="koboSpan" id="kobo.125.1"> part sets the initial state to </span><strong class="source-inline"><span class="koboSpan" id="kobo.126.1">Andrew</span></strong><span class="koboSpan" id="kobo.127.1">. </span><span class="koboSpan" id="kobo.127.2">This is the state we want to update later in </span><span class="No-Break"><span class="koboSpan" id="kobo.128.1">the code.</span></span></p></li>
<li><span class="koboSpan" id="kobo.129.1">The following snippet ensures that the function’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.130.1">this</span></strong><span class="koboSpan" id="kobo.131.1"> context will refer to the correct instance of the component </span><span class="No-Break"><span class="koboSpan" id="kobo.132.1">when called:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.133.1">this.updateNameState = this.updateNameState.bind(this);</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.134.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.135.1">updateNameState</span></strong><span class="koboSpan" id="kobo.136.1"> function is bound to the component instance </span><span class="No-Break"><span class="koboSpan" id="kobo.137.1">using </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.138.1">.bind(this)</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.139.1">.</span></span></p></li>
<li><span class="koboSpan" id="kobo.140.1">The following snippet demonstrates the state </span><span class="No-Break"><span class="koboSpan" id="kobo.141.1">updater method:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.142.1">        updateNameState(){          this.setState({            name:"Andrew Peter"          });        }</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.143.1">It is invoked in our button to set state from </span><strong class="source-inline"><span class="koboSpan" id="kobo.144.1">name:"Andrew"</span></strong><span class="koboSpan" id="kobo.145.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.146.1">name: "</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.147.1">Andrew Peter"</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.148.1">.</span></span></p></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.149.1">render()</span></strong><span class="koboSpan" id="kobo.150.1">: This is a compulsory method for every class component </span><span class="No-Break"><span class="koboSpan" id="kobo.151.1">in React.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.152.1">&lt;p&gt;{this.state.name}&lt;/p&gt;</span></strong><span class="koboSpan" id="kobo.153.1">: This sets our initial state, which is </span><strong class="source-inline"><span class="koboSpan" id="kobo.154.1">Andrew</span></strong><span class="koboSpan" id="kobo.155.1">, and returns it for our viewing </span><span class="No-Break"><span class="koboSpan" id="kobo.156.1">as JSX.</span></span></li>
<li><span class="koboSpan" id="kobo.157.1">According to the following snippet, when the button is clicked, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.158.1">updateNameState()</span></strong><span class="koboSpan" id="kobo.159.1"> class method is invoked and set to an updated state, which is </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.160.1">Andrew Peter</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.161.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.162.1">&lt;button onClick={this.updateNameState}&gt;  ChangeToFullName&lt;/button&gt;</span></pre></li>
</ul>
<p><span class="koboSpan" id="kobo.163.1">In this chapter, we will refactor the preceding code snippet to a function component using a Hook. </span><span class="koboSpan" id="kobo.163.2">But before we delve into this, let’s look at two rules guiding how we write Hooks in React </span><span class="No-Break"><span class="koboSpan" id="kobo.164.1">function </span></span><span class="No-Break"><a id="_idIndexMarker134"/></span><span class="No-Break"><span class="koboSpan" id="kobo.165.1">components:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.166.1">Rule 1</span></strong><span class="koboSpan" id="kobo.167.1">: </span><em class="italic"><span class="koboSpan" id="kobo.168.1">Hooks must only be invoked at the </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.169.1">top level.</span></em></span><p class="list-inset"><span class="koboSpan" id="kobo.170.1">You can’t call Hooks from inside conditions, loops, or nested functions. </span><span class="koboSpan" id="kobo.170.2">Rather, you are to always invoke Hooks at the top level of your </span><span class="No-Break"><span class="koboSpan" id="kobo.171.1">React function.</span></span></p></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.172.1">Rule 2</span></strong><span class="koboSpan" id="kobo.173.1">: </span><em class="italic"><span class="koboSpan" id="kobo.174.1">Hooks must only be invoked from a React </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.175.1">component function.</span></em></span><p class="list-inset"><span class="koboSpan" id="kobo.176.1">You can’t invoke</span><a id="_idIndexMarker135"/><span class="koboSpan" id="kobo.177.1"> Hooks from regular JavaScript functions, and neither can you invoke Hooks from the class component in React. </span><span class="koboSpan" id="kobo.177.2">You can only invoke Hooks from functional components. </span><span class="koboSpan" id="kobo.177.3">You can also invoke Hooks from </span><span class="No-Break"><span class="koboSpan" id="kobo.178.1">custom Hooks.</span></span></p></li>
</ul>
<h1 id="_idParaDest-47"><a id="_idTextAnchor069"/><span class="koboSpan" id="kobo.179.1">Why use Hooks in React?</span></h1>
<p><span class="koboSpan" id="kobo.180.1">In the </span><a id="_idIndexMarker136"/><span class="koboSpan" id="kobo.181.1">history of React, Hooks represented a significant shift in how we approach stateful components and manage side effects. </span><span class="koboSpan" id="kobo.181.2">Prior to Hooks, writing or refactoring class components was the primary method to enable components to exhibit interactivity and handle other side effects. </span><span class="koboSpan" id="kobo.181.3">Components serve as the building blocks of React applications’ UIs, and creating interactive interfaces necessitated the use of </span><span class="No-Break"><span class="koboSpan" id="kobo.182.1">class components.</span></span></p>
<p><span class="koboSpan" id="kobo.183.1">However, for beginners, the class syntax and structure can be challenging to understand. </span><span class="koboSpan" id="kobo.183.2">Sophie Alpert, former manager of the React team at Facebook, in her keynote (</span><em class="italic"><span class="koboSpan" id="kobo.184.1">React Today and Tomorrow</span></em><span class="koboSpan" id="kobo.185.1">) at the </span><em class="italic"><span class="koboSpan" id="kobo.186.1">2018 React </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.187.1">Conference</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.188.1">, said:</span></span></p>
<p class="author-quote"><span class="koboSpan" id="kobo.189.1">“I claim classes are hard for humans…but it’s not just humans, I claim the classes are also hard for machines”</span></p>
<p class="author-quote"><span class="koboSpan" id="kobo.190.1">– Sophie Alpert (https://bit.ly/37MQjBD)</span></p>
<p><span class="koboSpan" id="kobo.191.1">The use of </span><strong class="source-inline"><span class="koboSpan" id="kobo.192.1">thi</span><a id="_idTextAnchor070"/><span class="koboSpan" id="kobo.193.1">s</span></strong><span class="koboSpan" id="kobo.194.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.195.1">bind</span></strong><span class="koboSpan" id="kobo.196.1"> in class components adds to the list of confusion. </span><span class="koboSpan" id="kobo.196.2">While JavaScript offers both the world of </span><strong class="bold"><span class="koboSpan" id="kobo.197.1">Object-Oriented Programming</span></strong><span class="koboSpan" id="kobo.198.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.199.1">OOP</span></strong><span class="koboSpan" id="kobo.200.1">) and that of functional programming, with React class</span><a id="_idIndexMarker137"/><span class="koboSpan" id="kobo.201.1"> components, you can’t code without understanding the </span><span class="No-Break"><span class="koboSpan" id="kobo.202.1">OOP paradigm.</span></span></p>
<p><span class="koboSpan" id="kobo.203.1">This critically underscores the challenges that newcomers to the React world face. </span><span class="koboSpan" id="kobo.203.2">This was at least the case until React Hooks came into the picture. </span><span class="koboSpan" id="kobo.203.3">With Hooks, you simply write regular JavaScript functions that are easier to code, and you just have to hook into React Hooks </span><span class="No-Break"><span class="koboSpan" id="kobo.204.1">for statefulness.</span></span></p>
<p><span class="koboSpan" id="kobo.205.1">Another reason you might opt for React Hooks is the reusability of stateful logic across multiple components. </span><span class="koboSpan" id="kobo.205.2">Hooks allow you to separate stateful logic from component rendering logic, making it easier to reuse the logic in </span><span class="No-Break"><span class="koboSpan" id="kobo.206.1">different components.</span></span></p>
<p><span class="koboSpan" id="kobo.207.1">This separation ensures better modularity and reusability, as you can share your custom Hooks containing stateful logic across different React applications and with the broader React community. </span><span class="koboSpan" id="kobo.207.2">On the other hand, with class-based components, stateful logic and UI are often intertwined, which can make it harder to extract and reuse the </span><span class="No-Break"><span class="koboSpan" id="kobo.208.1">logic efficiently.</span></span></p>
<p><span class="koboSpan" id="kobo.209.1">In sum, React Hooks have triggered a new way of thinking about React component design. </span><span class="koboSpan" id="kobo.209.2">The possibility of gradual adoption in an existing code base (if you are still running on legacy React source code), makes it easy for diehard class component React developers to continue to write their stateful class components along with systematic migration of their code base to a </span><span class="No-Break"><span class="koboSpan" id="kobo.210.1">functional-oriented approach.</span></span></p>
<p><span class="koboSpan" id="kobo.211.1">The future of React is pointed toward functional component architecture. </span><span class="koboSpan" id="kobo.211.2">I can’t imagine anyone reasonably pursuing class components anymore at this stage. </span><span class="koboSpan" id="kobo.211.3">By learning about and writing function components, developers can harness the advantages of </span><a id="_idIndexMarker138"/><span class="koboSpan" id="kobo.212.1">React </span><span class="No-Break"><span class="koboSpan" id="kobo.213.1">more effectively.</span></span></p>
<p><span class="koboSpan" id="kobo.214.1">In the next section, we will start the process of developing a stateful React component using Hooks. </span><span class="koboSpan" id="kobo.214.2">We will start with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.215.1">useState</span></strong><span class="koboSpan" id="kobo.216.1"> Hook, the most popular React Hook, which brings state to </span><span class="No-Break"><span class="koboSpan" id="kobo.217.1">function components.</span></span></p>
<h1 id="_idParaDest-48"><a id="_idTextAnchor071"/><span class="koboSpan" id="kobo.218.1">Using useState to develop stateful components</span></h1>
<p><span class="koboSpan" id="kobo.219.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.220.1">useState</span></strong><span class="koboSpan" id="kobo.221.1"> Hook </span><a id="_idIndexMarker139"/><span class="koboSpan" id="kobo.222.1">allows you to manage</span><a id="_idIndexMarker140"/><span class="koboSpan" id="kobo.223.1"> state in React applications. </span><span class="koboSpan" id="kobo.223.2">Function components rely on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.224.1">useState</span></strong><span class="koboSpan" id="kobo.225.1"> Hook to add state variables to them. </span><span class="koboSpan" id="kobo.225.2">State is an object in React that can hold data information for use in React components. </span><span class="koboSpan" id="kobo.225.3">When you make a change to existing data, that change is stored as </span><span class="No-Break"><span class="koboSpan" id="kobo.226.1">a state.</span></span></p>
<p><span class="koboSpan" id="kobo.227.1">This is how it works: you pass an initial state property to </span><strong class="source-inline"><span class="koboSpan" id="kobo.228.1">useState()</span></strong><span class="koboSpan" id="kobo.229.1">, which then returns a variable with the current state value and a function to update this value. </span><span class="koboSpan" id="kobo.229.2">The following is the syntax of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.230.1">useState</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.231.1"> Hook:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.232.1">const [state, stateUpdater] = useState(initialState);</span></pre>
<p><span class="koboSpan" id="kobo.233.1">Let’s see a simplistic use case of how </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.234.1">useState</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.235.1"> works:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.236.1">import React, {useState} from 'react';const App = () =&gt; {
  const [count, setCount] = useState(0);
  const handleIncrementByTen = () =&gt; {
    setCount(count + 10);
  };
  const handleDecrementByTen = () =&gt; {
    setCount(count - 10);
  };
  const resetCountHandler = () =&gt; {
    setCount(0)
  };</span></pre>
<p><span class="koboSpan" id="kobo.237.1">The </span><a id="_idIndexMarker141"/><span class="koboSpan" id="kobo.238.1">preceding code snippet </span><a id="_idIndexMarker142"/><span class="koboSpan" id="kobo.239.1">shows how you can develop a component that has increment, decrement, and reset states. </span><span class="koboSpan" id="kobo.239.2">When the </span><strong class="source-inline"><span class="koboSpan" id="kobo.240.1">IncrementByTen</span></strong><span class="koboSpan" id="kobo.241.1"> button is clicked, the counter increases the number by </span><strong class="source-inline"><span class="koboSpan" id="kobo.242.1">10</span></strong><span class="koboSpan" id="kobo.243.1"> and when the </span><strong class="source-inline"><span class="koboSpan" id="kobo.244.1">DecrementByTen</span></strong><span class="koboSpan" id="kobo.245.1"> button is clicked, the decrement state is activated and the number decreases </span><span class="No-Break"><span class="koboSpan" id="kobo.246.1">by </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.247.1">10</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.248.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.249.1">The reset to the initial state does what it’s meant to do – it resets the value to its initial value. </span><span class="koboSpan" id="kobo.249.2">The following completes the </span><span class="No-Break"><span class="koboSpan" id="kobo.250.1">code snippet:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.251.1">  return (    &lt;div&gt;
      Initial Count: {count}
      &lt;hr /&gt;
      &lt;div&gt;
        &lt;button type="button"
          onClick={handleIncrementByTen}&gt;
          Increment by 10
        &lt;/button&gt;
        &lt;button type="button"
          onClick={handleDecrementByTen}&gt;
          Decrement by 10
        &lt;/button&gt;
        &lt;button type="button" onClick={resetCountHandler}&gt;
          Reset to Initial State
        &lt;/button&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
};
export default App;</span></pre>
<p><span class="koboSpan" id="kobo.252.1">Let’s</span><a id="_idIndexMarker143"/><span class="koboSpan" id="kobo.253.1"> understand the preceding code in</span><a id="_idIndexMarker144"/> <span class="No-Break"><span class="koboSpan" id="kobo.254.1">more detail:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.255.1">Importing </span><strong class="source-inline"><span class="koboSpan" id="kobo.256.1">useState</span></strong><span class="koboSpan" id="kobo.257.1">: To use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.258.1">useState</span></strong><span class="koboSpan" id="kobo.259.1"> Hook function, we first need to import it into our component from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.260.1">Import React, { useState } from 'react'</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.261.1">React object.</span></span></li>
<li><span class="koboSpan" id="kobo.262.1">Initializing </span><strong class="source-inline"><span class="koboSpan" id="kobo.263.1">useState</span></strong><span class="koboSpan" id="kobo.264.1">: We initialize our state by calling </span><strong class="source-inline"><span class="koboSpan" id="kobo.265.1">useState</span></strong><span class="koboSpan" id="kobo.266.1"> in our component </span><span class="No-Break"><span class="koboSpan" id="kobo.267.1">as follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.268.1">const [count, setCount] = useState(0);//using destructuring array to write a concise code.</span></pre><p class="list-inset"><strong class="source-inline"><span class="koboSpan" id="kobo.269.1">useState&lt;number&gt;</span></strong><span class="koboSpan" id="kobo.270.1"> accepts an initial state of zero (</span><strong class="source-inline"><span class="koboSpan" id="kobo.271.1">useState(0)</span></strong><span class="koboSpan" id="kobo.272.1">) and returns two values: </span><strong class="source-inline"><span class="koboSpan" id="kobo.273.1">count</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.274.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.275.1">setCount</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.276.1">:</span></span></p><ul><li><strong class="source-inline"><span class="koboSpan" id="kobo.277.1">count</span></strong><span class="koboSpan" id="kobo.278.1">: The </span><span class="No-Break"><span class="koboSpan" id="kobo.279.1">current state</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.280.1">setCount</span></strong><span class="koboSpan" id="kobo.281.1">: State updater function (this function is responsible for the new state of the </span><span class="No-Break"><span class="koboSpan" id="kobo.282.1">initial state)</span></span></li>
</ul></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.283.1">useState(0)</span></strong><span class="koboSpan" id="kobo.284.1">: </span><strong class="source-inline"><span class="koboSpan" id="kobo.285.1">useState &lt;number&gt;</span></strong><span class="koboSpan" id="kobo.286.1"> with the initial value </span><span class="No-Break"><span class="koboSpan" id="kobo.287.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.288.1">0</span></strong></span><p class="list-inset"><span class="koboSpan" id="kobo.289.1">In </span><strong class="source-inline"><span class="koboSpan" id="kobo.290.1">useState</span></strong><span class="koboSpan" id="kobo.291.1">, you can only declare a state property at a time. </span><span class="koboSpan" id="kobo.291.2">However, the data can be of any type: primitives, arrays, and </span><span class="No-Break"><span class="koboSpan" id="kobo.292.1">even objects.</span></span></p></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.293.1">Reading state</span></strong><span class="koboSpan" id="kobo.294.1">: The </span><a id="_idIndexMarker145"/><span class="koboSpan" id="kobo.295.1">following</span><a id="_idIndexMarker146"/><span class="koboSpan" id="kobo.296.1"> part of the code lets us use the state properties in the </span><span class="No-Break"><span class="koboSpan" id="kobo.297.1">rendered component:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.298.1">&lt;div&gt;      Initial Count: {count}      &lt;hr /&gt;      &lt;div&gt;        &lt;button type="button"          onClick={handleIncrementByTen}&gt;          Increment by 10        &lt;/button&gt;        &lt;button type="button"          onClick={handleDecrementByTen}&gt;          Decrement by 10        &lt;/button&gt;        &lt;button type="button"          onClick={resetCountHandler}&gt;          Reset to Initial State        &lt;/button&gt;      &lt;/div&gt;    &lt;/div&gt;</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.299.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.300.1">onClick</span></strong><span class="koboSpan" id="kobo.301.1"> event</span><a id="_idIndexMarker147"/><span class="koboSpan" id="kobo.302.1"> functions</span><a id="_idIndexMarker148"/><span class="koboSpan" id="kobo.303.1"> are added to help emit event operations for our buttons. </span><span class="koboSpan" id="kobo.303.2">When the buttons are clicked, different event functions are invoked based on the </span><span class="No-Break"><span class="koboSpan" id="kobo.304.1">expected actions.</span></span></p></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.305.1">Update state</span></strong><span class="koboSpan" id="kobo.306.1">: We use the updater function to change the value of state. </span><span class="koboSpan" id="kobo.306.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.307.1">handleIncrementByTen()</span></strong><span class="koboSpan" id="kobo.308.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.309.1">handleDecrementByTen()</span></strong><span class="koboSpan" id="kobo.310.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.311.1">resetCountHandler()</span></strong><span class="koboSpan" id="kobo.312.1"> functions are used to change the state values, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.313.1">following snippet:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.314.1">  const handleIncrementByTen = () =&gt; {    setCount(count + 10);  };  const handleDecrementByTen = () =&gt; {    setCount(count - 10);  };  const resetCountHandler = () =&gt; {    setCount(0)  };</span></pre></li>
</ul>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.315.1">useState&lt;number&gt;</span></strong><span class="koboSpan" id="kobo.316.1"> can contain </span><a id="_idIndexMarker149"/><span class="koboSpan" id="kobo.317.1">primitive and object</span><a id="_idIndexMarker150"/><span class="koboSpan" id="kobo.318.1"> data that can be accessed across React components. </span><span class="koboSpan" id="kobo.318.2">At this point, it is recommended you fire up your VS code or your preferred IDE and experiment with </span><strong class="source-inline"><span class="koboSpan" id="kobo.319.1">useState</span></strong><span class="koboSpan" id="kobo.320.1"> in developing a </span><span class="No-Break"><span class="koboSpan" id="kobo.321.1">stateful component.</span></span></p>
<h2 id="_idParaDest-49"><a id="_idTextAnchor072"/><span class="koboSpan" id="kobo.322.1">Passing state as props</span></h2>
<p><span class="koboSpan" id="kobo.323.1">State is not </span><a id="_idIndexMarker151"/><span class="koboSpan" id="kobo.324.1">limited to being used solely within the component</span><a id="_idIndexMarker152"/><span class="koboSpan" id="kobo.325.1"> where it is defined. </span><span class="koboSpan" id="kobo.325.2">You can pass state as props to child components, allowing them to display or use the parent </span><span class="No-Break"><span class="koboSpan" id="kobo.326.1">state data.</span></span></p>
<p><span class="koboSpan" id="kobo.327.1">Let’s consider the </span><span class="No-Break"><span class="koboSpan" id="kobo.328.1">following example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.329.1">import React, { useState } from 'react';const ParentComponent = () =&gt; {
  const [count, setCount] = useState(0);
  const handleIncrementByTen = () =&gt; {
    setCount(count + 10);
  };
  return (
    &lt;div&gt;
      &lt;p&gt;Parent Count: {count}&lt;/p&gt;
      &lt;ChildComponent count={count} /&gt;
      &lt;button onClick={handleIncrementByTen}&gt;Increment
      &lt;/button&gt;
    &lt;/div&gt;
  );
};
const ChildComponent = ({ count }) =&gt; {
  return &lt;p&gt;Child Count: {count}&lt;/p&gt;;
};</span></pre>
<p><span class="koboSpan" id="kobo.330.1">The preceding code shows a React function component with state using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.331.1">useState</span></strong><span class="koboSpan" id="kobo.332.1"> Hook. </span><span class="koboSpan" id="kobo.332.2">It consists of two components, </span><strong class="source-inline"><span class="koboSpan" id="kobo.333.1">ParentComponent</span></strong><span class="koboSpan" id="kobo.334.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.335.1">ChildComponent</span></strong><span class="koboSpan" id="kobo.336.1">, and demonstrates how to pass state data from the parent component to the </span><span class="No-Break"><span class="koboSpan" id="kobo.337.1">child component.</span></span></p>
<p><span class="koboSpan" id="kobo.338.1">When you</span><a id="_idIndexMarker153"/><span class="koboSpan" id="kobo.339.1"> use </span><strong class="source-inline"><span class="koboSpan" id="kobo.340.1">ParentComponent</span></strong><span class="koboSpan" id="kobo.341.1"> in your application, it will render </span><a id="_idIndexMarker154"/><span class="koboSpan" id="kobo.342.1">with an initial </span><strong class="source-inline"><span class="koboSpan" id="kobo.343.1">count: number</span></strong><span class="koboSpan" id="kobo.344.1"> of </span><strong class="source-inline"><span class="koboSpan" id="kobo.345.1">0</span></strong><span class="koboSpan" id="kobo.346.1">. </span><strong class="bold"><span class="koboSpan" id="kobo.347.1">Parent Count</span></strong><span class="koboSpan" id="kobo.348.1"> will display the current value of parent </span><strong class="source-inline"><span class="koboSpan" id="kobo.349.1">count: number</span></strong><span class="koboSpan" id="kobo.350.1">, and </span><strong class="bold"><span class="koboSpan" id="kobo.351.1">Child Count</span></strong><span class="koboSpan" id="kobo.352.1"> (rendered by </span><strong class="source-inline"><span class="koboSpan" id="kobo.353.1">ChildComponent</span></strong><span class="koboSpan" id="kobo.354.1">) will also display the same value as it receives it via the </span><strong class="source-inline"><span class="koboSpan" id="kobo.355.1">count</span></strong><span class="koboSpan" id="kobo.356.1"> prop. </span><span class="koboSpan" id="kobo.356.2">When you click the </span><strong class="bold"><span class="koboSpan" id="kobo.357.1">Increment</span></strong><span class="koboSpan" id="kobo.358.1"> button, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.359.1">count</span></strong><span class="koboSpan" id="kobo.360.1"> state will increase by </span><strong class="source-inline"><span class="koboSpan" id="kobo.361.1">10</span></strong><span class="koboSpan" id="kobo.362.1">, and both counts will reflect the same </span><span class="No-Break"><span class="koboSpan" id="kobo.363.1">updated value.</span></span></p>
<h2 id="_idParaDest-50"><a id="_idTextAnchor073"/><span class="koboSpan" id="kobo.364.1">Conditional rendering with state</span></h2>
<p><strong class="bold"><span class="koboSpan" id="kobo.365.1">Conditional rendering with state</span></strong><span class="koboSpan" id="kobo.366.1"> in React allows you to show or hide specific parts of the user </span><a id="_idIndexMarker155"/><span class="koboSpan" id="kobo.367.1">interface based on the values of state variables. </span><span class="koboSpan" id="kobo.367.2">By using</span><a id="_idIndexMarker156"/><span class="koboSpan" id="kobo.368.1"> conditionals, you can control what content or components are displayed depending on the current state of </span><span class="No-Break"><span class="koboSpan" id="kobo.369.1">your application.</span></span></p>
<p><span class="koboSpan" id="kobo.370.1">This technique can be useful for creating dynamic and interactive user interfaces. </span><span class="koboSpan" id="kobo.370.2">Imagine having a </span><strong class="bold"><span class="koboSpan" id="kobo.371.1">Login</span></strong><span class="koboSpan" id="kobo.372.1"> button that turns into a </span><strong class="bold"><span class="koboSpan" id="kobo.373.1">Logout</span></strong><span class="koboSpan" id="kobo.374.1"> button once the user is logged in. </span><span class="koboSpan" id="kobo.374.2">That’s a classic example of conditional rendering! </span><span class="koboSpan" id="kobo.374.3">When you click the button, React will automatically update the UI to reflect the new state, making it super responsive. </span><span class="koboSpan" id="kobo.374.4">Oh, and that’s </span><span class="No-Break"><span class="koboSpan" id="kobo.375.1">not all!</span></span></p>
<p><span class="koboSpan" id="kobo.376.1">You can even use this magic to toggle the visibility of different elements, such as showing or hiding a cool modal or drop-down menu based on user actions. </span><span class="koboSpan" id="kobo.376.2">For instance, let’s say you have the </span><strong class="source-inline"><span class="koboSpan" id="kobo.377.1">isLoggedIn</span></strong><span class="koboSpan" id="kobo.378.1"> state variable, and you want to display different content based on whether the user is logged in </span><span class="No-Break"><span class="koboSpan" id="kobo.379.1">or not.</span></span></p>
<p><span class="koboSpan" id="kobo.380.1">The following code demonstrates how you can implement this with the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.381.1">useState</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.382.1"> Hook:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.383.1">import React, { useState } from 'react';const Dashboard = () =&gt; {
  const [isLoggedIn, setIsLoggedIn] = useState(false);
  const handleLogin = () =&gt; {
    setIsLoggedIn(true);
  };
  const handleLogout = () =&gt; {
    setIsLoggedIn(false);
  };
  return (
    &lt;div&gt;
      {isLoggedIn ? </span><span class="koboSpan" id="kobo.383.2">(
        &lt;button onClick={handleLogout}&gt;Logout&lt;/button&gt;
      ) : (
        &lt;button onClick={handleLogin}&gt;Login&lt;/button&gt;
      )}
      {isLoggedIn &amp;&amp; &lt;p&gt;Hey friend, welcome!&lt;/p&gt;}
      {!isLoggedIn &amp;&amp; &lt;p&gt;Please log in to continue.&lt;/p&gt;}
    &lt;/div&gt;
  );
};</span></pre>
<p><span class="koboSpan" id="kobo.384.1">The</span><a id="_idIndexMarker157"/><span class="koboSpan" id="kobo.385.1"> preceding code demonstrates a React component</span><a id="_idIndexMarker158"/><span class="koboSpan" id="kobo.386.1"> called </span><strong class="source-inline"><span class="koboSpan" id="kobo.387.1">Dashboard</span></strong><span class="koboSpan" id="kobo.388.1">. </span><span class="koboSpan" id="kobo.388.2">It’s all about handling user authentication and showing personalized messages to </span><span class="No-Break"><span class="koboSpan" id="kobo.389.1">the user.</span></span></p>
<p><span class="koboSpan" id="kobo.390.1">Inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.391.1">Dashboard</span></strong><span class="koboSpan" id="kobo.392.1"> component, we have the </span><strong class="source-inline"><span class="koboSpan" id="kobo.393.1">isLoggedIn</span></strong><span class="koboSpan" id="kobo.394.1"> state variable, which is managed using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.395.1">useState</span></strong><span class="koboSpan" id="kobo.396.1"> Hook. </span><span class="koboSpan" id="kobo.396.2">This variable keeps track of whether the user is currently logged in or not. </span><span class="koboSpan" id="kobo.396.3">When the component first renders, the initial state of </span><strong class="source-inline"><span class="koboSpan" id="kobo.397.1">isLoggedIn</span></strong><span class="koboSpan" id="kobo.398.1"> is set to false, indicating that the user is not </span><span class="No-Break"><span class="koboSpan" id="kobo.399.1">logged in.</span></span></p>
<p><span class="koboSpan" id="kobo.400.1">Now, let’s dive into the magic of conditional rendering! </span><span class="koboSpan" id="kobo.400.2">When you look at the JSX inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.401.1">return</span></strong><span class="koboSpan" id="kobo.402.1"> statement, you’ll see some interesting stuff happening. </span><span class="koboSpan" id="kobo.402.2">We use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.403.1">{}</span></strong><span class="koboSpan" id="kobo.404.1"> curly braces to wrap </span><span class="No-Break"><span class="koboSpan" id="kobo.405.1">our conditionals.</span></span></p>
<p><span class="koboSpan" id="kobo.406.1">If </span><strong class="source-inline"><span class="koboSpan" id="kobo.407.1">isLoggedIn</span></strong><span class="koboSpan" id="kobo.408.1"> is </span><strong class="source-inline"><span class="koboSpan" id="kobo.409.1">true</span></strong><span class="koboSpan" id="kobo.410.1">, we display a </span><strong class="bold"><span class="koboSpan" id="kobo.411.1">Logout</span></strong><span class="koboSpan" id="kobo.412.1"> button, and if it’s false, we show a </span><strong class="bold"><span class="koboSpan" id="kobo.413.1">Login</span></strong><span class="koboSpan" id="kobo.414.1"> button. </span><span class="koboSpan" id="kobo.414.2">Depending on the state, the appropriate button will be rendered, and each button has an </span><strong class="source-inline"><span class="koboSpan" id="kobo.415.1">onClick</span></strong><span class="koboSpan" id="kobo.416.1"> event that triggers the respective </span><strong class="source-inline"><span class="koboSpan" id="kobo.417.1">handleLogin</span></strong><span class="koboSpan" id="kobo.418.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.419.1">handleLogout</span></strong><span class="koboSpan" id="kobo.420.1"> function. </span><span class="koboSpan" id="kobo.420.2">The fun doesn’t </span><span class="No-Break"><span class="koboSpan" id="kobo.421.1">end there!</span></span></p>
<p><span class="koboSpan" id="kobo.422.1">We also use more conditional rendering with </span><strong class="source-inline"><span class="koboSpan" id="kobo.423.1">isLoggedIn</span></strong><span class="koboSpan" id="kobo.424.1"> to display a personalized message for the user. </span><span class="koboSpan" id="kobo.424.2">When </span><strong class="source-inline"><span class="koboSpan" id="kobo.425.1">isLoggedIn</span></strong><span class="koboSpan" id="kobo.426.1"> is </span><strong class="source-inline"><span class="koboSpan" id="kobo.427.1">true</span></strong><span class="koboSpan" id="kobo.428.1">, we show a warm greeting such as </span><strong class="bold"><span class="koboSpan" id="kobo.429.1">Hey friend, welcome!</span></strong><span class="koboSpan" id="kobo.430.1">, and when it’s false, we kindly ask the user to log in to continue. </span><span class="koboSpan" id="kobo.430.2">So polite, right? </span><span class="koboSpan" id="kobo.430.3">When the user clicks the </span><strong class="bold"><span class="koboSpan" id="kobo.431.1">Login</span></strong><span class="koboSpan" id="kobo.432.1"> button, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.433.1">handleLogin</span></strong><span class="koboSpan" id="kobo.434.1"> function gets called, and </span><span class="No-Break"><span class="koboSpan" id="kobo.435.1">guess what?</span></span></p>
<p><span class="koboSpan" id="kobo.436.1">It sets </span><strong class="source-inline"><span class="koboSpan" id="kobo.437.1">isLoggedIn</span></strong><span class="koboSpan" id="kobo.438.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.439.1">true</span></strong><span class="koboSpan" id="kobo.440.1">, indicating </span><a id="_idIndexMarker159"/><span class="koboSpan" id="kobo.441.1">that the user is now logged in! </span><span class="koboSpan" id="kobo.441.2">Likewise, when the </span><a id="_idIndexMarker160"/><span class="koboSpan" id="kobo.442.1">user clicks the </span><strong class="bold"><span class="koboSpan" id="kobo.443.1">Logout</span></strong><span class="koboSpan" id="kobo.444.1"> button, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.445.1">handleLogout</span></strong><span class="koboSpan" id="kobo.446.1"> function is triggered, and it sets </span><strong class="source-inline"><span class="koboSpan" id="kobo.447.1">isLoggedIn</span></strong><span class="koboSpan" id="kobo.448.1"> back to </span><strong class="source-inline"><span class="koboSpan" id="kobo.449.1">false</span></strong><span class="koboSpan" id="kobo.450.1">, meaning the user is now </span><span class="No-Break"><span class="koboSpan" id="kobo.451.1">logged out.</span></span></p>
<p><span class="koboSpan" id="kobo.452.1">In the next section, we will examine another Hook in React, </span><strong class="source-inline"><span class="koboSpan" id="kobo.453.1">useEffect</span></strong><span class="koboSpan" id="kobo.454.1">. </span><span class="koboSpan" id="kobo.454.2">It is widely used to manipulate the DOM and fetch data from </span><span class="No-Break"><span class="koboSpan" id="kobo.455.1">external sources.</span></span></p>
<h1 id="_idParaDest-51"><a id="_idTextAnchor074"/><span class="koboSpan" id="kobo.456.1">Using useEffect to create side effects</span></h1>
<p><span class="koboSpan" id="kobo.457.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.458.1">useEffect</span></strong><span class="koboSpan" id="kobo.459.1"> Hook </span><a id="_idIndexMarker161"/><span class="koboSpan" id="kobo.460.1">allows you to fetch data from external sources, update the DOM tree, and set up a data subscription. </span><span class="koboSpan" id="kobo.460.2">These operations are called side effects. </span><span class="koboSpan" id="kobo.460.3">In the class component, you have what we call lifecycle methods that can execute operations based on the phase of the component-rendering process. </span><strong class="source-inline"><span class="koboSpan" id="kobo.461.1">useEffect</span></strong><span class="koboSpan" id="kobo.462.1"> accepts two arguments: a function and an </span><span class="No-Break"><span class="koboSpan" id="kobo.463.1">optional dependency.</span></span></p>
<p><span class="koboSpan" id="kobo.464.1">It is important to note that </span><strong class="source-inline"><span class="koboSpan" id="kobo.465.1">useEffect</span></strong><span class="koboSpan" id="kobo.466.1"> does the work of the old </span><strong class="source-inline"><span class="koboSpan" id="kobo.467.1">componentDidMount</span></strong><span class="koboSpan" id="kobo.468.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.469.1">componentDidUpdate</span></strong><span class="koboSpan" id="kobo.470.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.471.1">componentWillUnmount</span></strong><span class="koboSpan" id="kobo.472.1"> in one place. </span><span class="koboSpan" id="kobo.472.2">Using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.473.1">useEffect</span></strong><span class="koboSpan" id="kobo.474.1"> Hook shortens the amount of code you have to write in a function component to achieve the same </span><span class="No-Break"><span class="koboSpan" id="kobo.475.1">side effects.</span></span></p>
<p><span class="koboSpan" id="kobo.476.1">The following is the syntax for the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.477.1">useEffects</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.478.1"> Hook:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.479.1">- useEffect(&lt;function&gt;, &lt;dependency&gt;)useEffect(() =&gt; {
  // This callback function implementation is either to
     update DOM, fetch data from external sources, or to
     manage subscription that happens here.
</span><span class="koboSpan" id="kobo.479.2">}, [dependency]);</span></pre>
<p><span class="koboSpan" id="kobo.480.1">Let’s dive</span><a id="_idIndexMarker162"/><span class="koboSpan" id="kobo.481.1"> into an example of using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.482.1">useEffect</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.483.1"> Hook:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.484.1">import React, { useEffect, useState } from 'react';const App = () =&gt; {
const [data, setData] = useState([]);
    const API_URL = "https://dummyjson.com/users";
      useEffect(() =&gt; {
        fetchSpeakers();
    }, []);
     return (
        &lt;ul&gt;
      {data.map(item =&gt; (
        &lt;li key={item.id}&gt;
          {item.firstName} {item.lastName}
        &lt;/li&gt;
      ))}
    &lt;/ul&gt;);
};
export default App;</span></pre>
<p><span class="koboSpan" id="kobo.485.1">In the </span><a id="_idIndexMarker163"/><span class="koboSpan" id="kobo.486.1">preceding code, we are fetching data from an external API source using </span><strong class="source-inline"><span class="koboSpan" id="kobo.487.1">useEffect</span></strong><span class="koboSpan" id="kobo.488.1">. </span><span class="koboSpan" id="kobo.488.2">For this example, we have used fake API data from </span><strong class="source-inline"><span class="koboSpan" id="kobo.489.1">https://dummyjson.com/users</span></strong><span class="koboSpan" id="kobo.490.1">. </span><span class="koboSpan" id="kobo.490.2">By the time we get to the backend development section of this book (</span><a href="B18554_09.xhtml#_idTextAnchor186"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.491.1">Chapter 9</span></em></span></a><span class="koboSpan" id="kobo.492.1">, </span><em class="italic"><span class="koboSpan" id="kobo.493.1">API Development and Documentation</span></em><span class="koboSpan" id="kobo.494.1">), we will be developing custom API endpoints. </span><span class="koboSpan" id="kobo.494.2">Next, we will use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.495.1">useEffect()</span></strong><span class="koboSpan" id="kobo.496.1"> Hook to call the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.497.1">fetchSpeakers</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.498.1"> function.</span></span></p>
<p><span class="koboSpan" id="kobo.499.1">Refer to GitHub for the full code and have a look at the </span><span class="No-Break"><span class="koboSpan" id="kobo.500.1">following points:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.501.1">import React, { useEffect, useState } from 'react';</span></strong><span class="koboSpan" id="kobo.502.1">: This line allows us to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.503.1">useEffect</span></strong><span class="koboSpan" id="kobo.504.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.505.1">useState</span></strong><span class="koboSpan" id="kobo.506.1"> APIs from the </span><span class="No-Break"><span class="koboSpan" id="kobo.507.1">React library.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.508.1">const [data, setData] = useState([]);</span></strong><span class="koboSpan" id="kobo.509.1">: In this line, we have declared a state object set with an empty array as the </span><span class="No-Break"><span class="koboSpan" id="kobo.510.1">initial data.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.511.1">useEffect(()=&gt;{...}, [])</span></strong><span class="koboSpan" id="kobo.512.1">: This part of the code represents a signature set that fetches data from the specified external source. </span><span class="koboSpan" id="kobo.512.2">The second argument in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.513.1">useEffect</span></strong><span class="koboSpan" id="kobo.514.1"> function, the dependency </span><strong class="source-inline"><span class="koboSpan" id="kobo.515.1">[]</span></strong><span class="koboSpan" id="kobo.516.1">, is set to an empty array. </span><span class="koboSpan" id="kobo.516.2">The empty array ensures </span><strong class="source-inline"><span class="koboSpan" id="kobo.517.1">useEffect()</span></strong><span class="koboSpan" id="kobo.518.1"> renders just once, the first time, </span><span class="No-Break"><span class="koboSpan" id="kobo.519.1">on mounting.</span></span><p class="list-inset"><span class="koboSpan" id="kobo.520.1">To have it render depending on state changes, you would have to pass the state through the dependency array. </span><span class="koboSpan" id="kobo.520.2">With this, you are able to prevent the constant unnecessary re-rendering of the component unless the dependency </span><span class="No-Break"><span class="koboSpan" id="kobo.521.1">state changes.</span></span></p></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.522.1">fetchSpeakers():Promise&lt;Speaker[]&gt;</span></strong><span class="koboSpan" id="kobo.523.1"> inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.524.1">useEffect</span></strong><span class="koboSpan" id="kobo.525.1"> Hook is a call to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.526.1">fetchSpeakers</span></strong><span class="koboSpan" id="kobo.527.1"> function. </span><span class="koboSpan" id="kobo.527.2">This function is an asynchronous function that fetches data from a mocked remote API and sets the data in the component’s state using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.528.1">setData</span></strong><span class="koboSpan" id="kobo.529.1"> function. </span><span class="koboSpan" id="kobo.529.2">The empty dependency array </span><strong class="source-inline"><span class="koboSpan" id="kobo.530.1">[]</span></strong><span class="koboSpan" id="kobo.531.1"> passed as the second argument to </span><strong class="source-inline"><span class="koboSpan" id="kobo.532.1">useEffect</span></strong><span class="koboSpan" id="kobo.533.1"> indicates that the effect should only run once when the component is mounted and never again </span><span class="No-Break"><span class="koboSpan" id="kobo.534.1">after that.</span></span><p class="list-inset"><span class="koboSpan" id="kobo.535.1">Since there are no dependencies listed, the effect won’t be triggered by changes in any props or state variables. </span><span class="koboSpan" id="kobo.535.2">This is why it behaves like the </span><strong class="source-inline"><span class="koboSpan" id="kobo.536.1">componentDidMount</span></strong><span class="koboSpan" id="kobo.537.1"> lifecycle method, as it runs only once when the component is </span><span class="No-Break"><span class="koboSpan" id="kobo.538.1">first rendered.</span></span></p></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.539.1">const API_URL = "https://dummyjson.com/users";</span></strong><span class="koboSpan" id="kobo.540.1">: The </span><strong class="source-inline"><span class="koboSpan" id="kobo.541.1">API_URL</span></strong><span class="koboSpan" id="kobo.542.1"> variable is set to hold the endpoint information about the </span><span class="No-Break"><span class="koboSpan" id="kobo.543.1">external source.</span></span></li>
<li><span class="koboSpan" id="kobo.544.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.545.1">try… catch</span></strong><span class="koboSpan" id="kobo.546.1"> code block </span><a id="_idIndexMarker164"/><span class="koboSpan" id="kobo.547.1">is set to execute the code and console error if there is an error fetching data from </span><span class="No-Break"><span class="koboSpan" id="kobo.548.1">the endpoint:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.549.1">  const fetchSpeakers = async () =&gt; {    try {      const response = await           fetch(API_URL);      const data = await response.json();      setData(data.users);    } catch (error) {      console.log("error", error);    }  };</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.550.1">This preceding code snippet used the web browser </span><strong class="source-inline"><span class="koboSpan" id="kobo.551.1">fetch()</span></strong><span class="koboSpan" id="kobo.552.1"> API to fetch the data from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.553.1">API_URL</span></strong><span class="koboSpan" id="kobo.554.1"> endpoint. </span><span class="koboSpan" id="kobo.554.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.555.1">try… catch</span></strong><span class="koboSpan" id="kobo.556.1"> code block is set to execute the code and console error if there is an error fetching data from </span><span class="No-Break"><span class="koboSpan" id="kobo.557.1">the endpoint.</span></span></p></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.558.1">map()</span></strong><span class="koboSpan" id="kobo.559.1"> is set on the data to loop through the object array data and display the newly created array from the function invocation on every array element </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.560.1">item: Speaker</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.561.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.562.1">{data.map(item =&gt; (        &lt;li key={item.id}&gt;          {item.firstName} {item.lastName}        &lt;/li&gt;      ))}</span></pre></li>
</ul>
<p><span class="koboSpan" id="kobo.563.1">Let’s update </span><a id="_idIndexMarker165"/><span class="koboSpan" id="kobo.564.1">the </span><strong class="source-inline"><span class="koboSpan" id="kobo.565.1">useEffect</span></strong><span class="koboSpan" id="kobo.566.1"> Hook function of the preceding code and add a state to its dependency and a </span><strong class="source-inline"><span class="koboSpan" id="kobo.567.1">Cleanup</span></strong><span class="koboSpan" id="kobo.568.1"> function. </span><span class="koboSpan" id="kobo.568.2">Adding a </span><strong class="source-inline"><span class="koboSpan" id="kobo.569.1">Cleanup</span></strong><span class="koboSpan" id="kobo.570.1"> function inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.571.1">useEffect</span></strong><span class="koboSpan" id="kobo.572.1"> hook serves a crucial purpose in </span><span class="No-Break"><span class="koboSpan" id="kobo.573.1">React applications.</span></span></p>
<p><span class="koboSpan" id="kobo.574.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.575.1">cleanup</span></strong><span class="koboSpan" id="kobo.576.1"> function is executed when the component unmounts or when the dependencies listed in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.577.1">useEffect</span></strong><span class="koboSpan" id="kobo.578.1"> hook change. </span><span class="koboSpan" id="kobo.578.2">Its main use is to perform cleanup tasks, freeing up resources, and preventing potential memory leaks or unexpected behavior in </span><span class="No-Break"><span class="koboSpan" id="kobo.579.1">the application.</span></span></p>
<p><span class="koboSpan" id="kobo.580.1">Now, update the preceding </span><strong class="source-inline"><span class="koboSpan" id="kobo.581.1">useEffect()</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.582.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.583.1">useEffect(() =&gt; {    const fetchData = async () =&gt; {
      const fetchedData = await fetchSpeakers();
      if (isMounted) {
        setData(fetchedData);
      }
    };
    fetchData();
    // Cleanup function
    return () =&gt; {
      isMounted = false;
    };
  }, [data]) ;// Adding data state as a dependency</span></pre>
<p><span class="koboSpan" id="kobo.584.1">The preceding code uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.585.1">useEffect</span></strong><span class="koboSpan" id="kobo.586.1"> Hook to fetch data from an API (</span><strong class="source-inline"><span class="koboSpan" id="kobo.587.1">fetchSpeakers</span></strong><span class="koboSpan" id="kobo.588.1">) and update the data state with the fetched result. </span><span class="koboSpan" id="kobo.588.2">It employs an </span><strong class="source-inline"><span class="koboSpan" id="kobo.589.1">isMounted</span></strong><span class="koboSpan" id="kobo.590.1"> flag </span><a id="_idIndexMarker166"/><span class="koboSpan" id="kobo.591.1">to prevent setting the state after the component has unmounted, effectively avoiding potential issues. </span><span class="koboSpan" id="kobo.591.2">The data fetching effect runs whenever the </span><strong class="source-inline"><span class="koboSpan" id="kobo.592.1">data</span></strong><span class="koboSpan" id="kobo.593.1"> state changes, and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.594.1">Cleanup</span></strong><span class="koboSpan" id="kobo.595.1"> function sets the </span><strong class="source-inline"><span class="koboSpan" id="kobo.596.1">isMounted</span></strong><span class="koboSpan" id="kobo.597.1"> flag to false when the </span><span class="No-Break"><span class="koboSpan" id="kobo.598.1">component unmounts.</span></span></p>
<p><span class="koboSpan" id="kobo.599.1">In sum, we have seen how </span><strong class="source-inline"><span class="koboSpan" id="kobo.600.1">useEffect</span></strong><span class="koboSpan" id="kobo.601.1"> could be used for side effect operation in a function component by fetching data from an external source. </span><span class="koboSpan" id="kobo.601.2">Next, we will look at how we can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.602.1">useContext</span></strong><span class="koboSpan" id="kobo.603.1"> Hook to better manage the global state in </span><span class="No-Break"><span class="koboSpan" id="kobo.604.1">React applications.</span></span></p>
<h1 id="_idParaDest-52"><a id="_idTextAnchor075"/><span class="koboSpan" id="kobo.605.1">Using useContext to manage global state in React applications</span></h1>
<p><span class="koboSpan" id="kobo.606.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.607.1">useContext</span></strong><span class="koboSpan" id="kobo.608.1"> Hook is </span><a id="_idIndexMarker167"/><span class="koboSpan" id="kobo.609.1">used to share application state data across the component tree without having to pass props down explicitly at every component level. </span><span class="koboSpan" id="kobo.609.2">To put it simply, </span><strong class="source-inline"><span class="koboSpan" id="kobo.610.1">useContext</span></strong><span class="koboSpan" id="kobo.611.1"> is a way to manage React applications’ global state. </span><span class="koboSpan" id="kobo.611.2">Remember, we used the </span><strong class="source-inline"><span class="koboSpan" id="kobo.612.1">useState</span></strong><span class="koboSpan" id="kobo.613.1"> Hook to manage local state in the </span><em class="italic"><span class="koboSpan" id="kobo.614.1">Using useState to develop stateful </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.615.1">components</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.616.1"> section.</span></span></p>
<p><span class="koboSpan" id="kobo.617.1">However, as React project requirements expand in scope, it will be ineffective to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.618.1">useState</span></strong><span class="koboSpan" id="kobo.619.1"> Hook alone in passing state data in deeply nested components. </span><span class="koboSpan" id="kobo.619.2">The following is the syntax for the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.620.1">useContext</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.621.1"> Hook:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.622.1">const Context = useContext(initialValue);</span></pre>
<p><span class="koboSpan" id="kobo.623.1">Briefly, we will discuss </span><em class="italic"><span class="koboSpan" id="kobo.624.1">props drilling</span></em><span class="koboSpan" id="kobo.625.1"> to understand the challenges it poses. </span><span class="koboSpan" id="kobo.625.2">Afterward, we’ll delve into the implementation of the context API, which addresses </span><span class="No-Break"><span class="koboSpan" id="kobo.626.1">these issues.</span></span></p>
<h2 id="_idParaDest-53"><a id="_idTextAnchor076"/><span class="koboSpan" id="kobo.627.1">Understanding props drilling</span></h2>
<p><span class="koboSpan" id="kobo.628.1">Let’s examine how you might</span><a id="_idIndexMarker168"/><span class="koboSpan" id="kobo.629.1"> pass data as props down a component hierarchy without the use of </span><strong class="source-inline"><span class="koboSpan" id="kobo.630.1">useContext</span></strong><span class="koboSpan" id="kobo.631.1">. </span><span class="koboSpan" id="kobo.631.2">The following code snippet shows how we pass data to inner deeply nested components without the use </span><span class="No-Break"><span class="koboSpan" id="kobo.632.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.633.1">useContext</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.634.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.635.1">  import React, {useState } from 'react';const App = () =&gt; {
  const [speakerName]= useState("Fred Morris");
  return (
    &lt;div&gt;
      &lt;h2&gt;This is Parent Component&lt;/h2&gt;
      &lt;ImmediateChildComponent speakerName={speakerName} /&gt;
    &lt;/div&gt;
    );
    }
    function ImmediateChildComponent({speakerName}) {
      return (
        &lt;div&gt;
          &lt;h2&gt;This is an immediate Child
            Component&lt;/h2&gt;&lt;hr/&gt;
          &lt;GrandChildComponent speakerName={speakerName} /&gt;
        &lt;/div&gt;
      );
    }
  }
export default App;</span></pre>
<p><span class="koboSpan" id="kobo.636.1">The preceding code</span><a id="_idIndexMarker169"/><span class="koboSpan" id="kobo.637.1"> displays the name of a speaker in a function comprising nested components. </span><span class="koboSpan" id="kobo.637.2">The full source code is </span><span class="No-Break"><span class="koboSpan" id="kobo.638.1">on GitHub.</span></span></p>
<p><span class="koboSpan" id="kobo.639.1">Let us understand the code in </span><span class="No-Break"><span class="koboSpan" id="kobo.640.1">more detail:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.641.1">const [speakerName]= useState</span></strong><span class="koboSpan" id="kobo.642.1">: This line is used to set the default state </span><span class="No-Break"><span class="koboSpan" id="kobo.643.1">for </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.644.1">speakerName</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.645.1">.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.646.1">&lt;App /&gt;</span></strong><span class="koboSpan" id="kobo.647.1"> is a parent component that passes state using </span><strong class="source-inline"><span class="koboSpan" id="kobo.648.1">{speakerName}</span></strong><span class="koboSpan" id="kobo.649.1"> as props for the state needed in  </span><strong class="source-inline"><span class="koboSpan" id="kobo.650.1">&lt;</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.651.1">GrandChildComponent /&gt;</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.652.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.653.1">  return (    &lt;div&gt;      &lt;h2&gt;This is Parent Component&lt;/h2&gt;      &lt;ImmediateChildComponent        speakerName={speakerName}    &lt;/div&gt;    );</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.654.1">The parent</span><a id="_idIndexMarker170"/><span class="koboSpan" id="kobo.655.1"> has to pass through the </span><strong class="source-inline"><span class="koboSpan" id="kobo.656.1">&lt;ImmediateChildComponent /&gt;</span></strong><span class="koboSpan" id="kobo.657.1"> component to reach </span><strong class="source-inline"><span class="koboSpan" id="kobo.658.1">&lt;GrandChildComponent  /&gt;</span></strong><span class="koboSpan" id="kobo.659.1"> nested lower in the hierarchy. </span><span class="koboSpan" id="kobo.659.2">This becomes even more cumbersome when you have five or more intermediary components before we get to the actual component that needs the </span><span class="No-Break"><span class="koboSpan" id="kobo.660.1">state information.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.661.1">This is the problem </span><strong class="source-inline"><span class="koboSpan" id="kobo.662.1">useContext</span></strong><span class="koboSpan" id="kobo.663.1"> tries to solve. </span><span class="koboSpan" id="kobo.663.2">The following code shows the intermediate component and the final </span><strong class="source-inline"><span class="koboSpan" id="kobo.664.1">GrandChildComponent: React.FC&lt;Props&gt;</span></strong><span class="koboSpan" id="kobo.665.1"> where the states </span><span class="No-Break"><span class="koboSpan" id="kobo.666.1">are required:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.667.1">function ImmediateChildComponent({speakerName}) {      return (        &lt;div&gt;          &lt;h2&gt;This is an immediate Child            Component&lt;/h2&gt;&lt;hr/&gt;          &lt;GrandChildComponent            speakerName={speakerName}   /&gt;        &lt;/div&gt;      );    }    function GrandChildComponent({speakerName}) {      return (        &lt;div&gt;          &lt;h3&gt;This is a Grand Child Component&lt;/h3&gt;          &lt;h4&gt;Speakers Name: {speakerName}&lt;/h4&gt;        &lt;/div&gt;      );}</span></pre></li>
</ul>
<p><span class="koboSpan" id="kobo.668.1">Let’s now </span><a id="_idIndexMarker171"/><span class="koboSpan" id="kobo.669.1">look at how </span><strong class="source-inline"><span class="koboSpan" id="kobo.670.1">useContext</span></strong><span class="koboSpan" id="kobo.671.1"> can be used to solve the preceding problem by maintaining a global state where different components can communicate without causing prop drilling issues </span><span class="No-Break"><span class="koboSpan" id="kobo.672.1">in React.</span></span></p>
<h2 id="_idParaDest-54"><a id="_idTextAnchor077"/><span class="koboSpan" id="kobo.673.1">Using useContext to solve the props drilling problem</span></h2>
<p><span class="koboSpan" id="kobo.674.1">With </span><strong class="source-inline"><span class="koboSpan" id="kobo.675.1">useContext</span></strong><span class="koboSpan" id="kobo.676.1">, you will </span><a id="_idIndexMarker172"/><span class="koboSpan" id="kobo.677.1">understand how you can pass state data across components without manually doing so with props. </span><span class="koboSpan" id="kobo.677.2">The following code shows how </span><strong class="source-inline"><span class="koboSpan" id="kobo.678.1">useContext</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.679.1">is used:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.680.1">import React, {useState, useContext,createContext } from  'react';
const context = createContext(null);
const App = () =&gt; {
const [speakerName]= useState("Fred Morris");
  return (
    &lt;context.Provider value={{ speakerName}}&gt;
            &lt;h1&gt;This is Parent Component&lt;/h1&gt;
            &lt;ImmediateChildComponent  /&gt;
      &lt;/context.Provider&gt;
        );}
function ImmediateChildComponent() {
    return (
      &lt;div&gt;
        &lt;h2&gt;This is an immediate Child Component&lt;/h2&gt;
        &lt;hr/&gt;
        &lt;GrandChildComponent  /&gt;
      &lt;/div&gt;);
}
}
  export default App;</span></pre>
<p><span class="koboSpan" id="kobo.681.1">Let us</span><a id="_idIndexMarker173"/><span class="koboSpan" id="kobo.682.1"> understand the preceding code in detail. </span><span class="koboSpan" id="kobo.682.2">Refer to GitHub for the full </span><span class="No-Break"><span class="koboSpan" id="kobo.683.1">source code:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.684.1">import React, {useState, useContext,createContext } from 'react';</span></strong><span class="koboSpan" id="kobo.685.1">: This line allows us to make use of </span><strong class="source-inline"><span class="koboSpan" id="kobo.686.1">useState</span></strong><span class="koboSpan" id="kobo.687.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.688.1">useContext</span></strong><span class="koboSpan" id="kobo.689.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.690.1">createContext</span></strong><span class="koboSpan" id="kobo.691.1"> from the </span><span class="No-Break"><span class="koboSpan" id="kobo.692.1">React library.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.693.1">const context = createContext(null);</span></strong><span class="koboSpan" id="kobo.694.1">: This line creates </span><strong class="source-inline"><span class="koboSpan" id="kobo.695.1">Context&lt;ContextType&gt;</span></strong><span class="koboSpan" id="kobo.696.1"> and allows us to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.697.1">Provider:</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.698.1">React.FC&lt;ProviderProps|null&gt;</span></strong><span class="koboSpan" id="kobo.699.1"> with </span><strong class="source-inline"><span class="koboSpan" id="kobo.700.1">null</span></strong><span class="koboSpan" id="kobo.701.1"> as the initial value. </span><span class="koboSpan" id="kobo.701.2">Note that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.702.1">null</span></strong><span class="koboSpan" id="kobo.703.1"> default value could also be any value provided to us by the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.704.1">createContext</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.705.1"> function.</span></span></li>
<li><span class="koboSpan" id="kobo.706.1">The </span><a id="_idIndexMarker174"/><span class="koboSpan" id="kobo.707.1">context provider envelopes the child component and makes the state values available, </span><span class="No-Break"><span class="koboSpan" id="kobo.708.1">as follows:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.709.1">        return (          &lt;context.Provider value={{ speakerName }}&gt;            &lt;h1&gt;This is Parent Component&lt;/h1&gt;            &lt;ImmediateChildComponent  /&gt;          &lt;/context.Provider&gt;        );</span></pre></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.710.1">const {speakerName} = useContext(context);</span></strong><span class="koboSpan" id="kobo.711.1">: In this line, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.712.1">useContext</span></strong><span class="koboSpan" id="kobo.713.1"> Hook to have access to </span><strong class="source-inline"><span class="koboSpan" id="kobo.714.1">context</span></strong><span class="koboSpan" id="kobo.715.1"> in </span><strong class="source-inline"><span class="koboSpan" id="kobo.716.1">&lt;</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.717.1">GrandChildComponent /&gt;</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.718.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.719.1">function GrandChildComponent():React.FC&lt;Props&gt; {  const {speakerName} = useContext(context);      return (        &lt;div&gt;          &lt;h3&gt;This is a Grand Child Component&lt;/h3&gt;          &lt;h4&gt;Speaker's Name: {speakerName}&lt;/h4&gt;        &lt;/div&gt;      );</span></pre></li>
</ul>
<p><span class="koboSpan" id="kobo.720.1">In sum, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.721.1">useContext</span></strong><span class="koboSpan" id="kobo.722.1"> Hook </span><a id="_idIndexMarker175"/><span class="koboSpan" id="kobo.723.1">enables us to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.724.1">context</span></strong><span class="koboSpan" id="kobo.725.1"> in function components no matter how nested the component hierarchy may be. </span><span class="koboSpan" id="kobo.725.2">This is always required in complex React applications where the state data may be needed across global application states. </span><span class="koboSpan" id="kobo.725.3">With </span><strong class="source-inline"><span class="koboSpan" id="kobo.726.1">useContext</span></strong><span class="koboSpan" id="kobo.727.1">, we are able to share the information state that was passed as props without the direct interference of the </span><span class="No-Break"><span class="koboSpan" id="kobo.728.1">intermediate components.</span></span></p>
<p><span class="koboSpan" id="kobo.729.1">Next, we will delve into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.730.1">useRef</span></strong><span class="koboSpan" id="kobo.731.1"> Hook and explore how it can be effectively utilized in a </span><span class="No-Break"><span class="koboSpan" id="kobo.732.1">React component.</span></span></p>
<h1 id="_idParaDest-55"><a id="_idTextAnchor078"/><span class="koboSpan" id="kobo.733.1">Using useRef to directly access DOM elements and persist state values</span></h1>
<p><span class="koboSpan" id="kobo.734.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.735.1">useRef</span></strong><span class="koboSpan" id="kobo.736.1"> Hook</span><a id="_idIndexMarker176"/><span class="koboSpan" id="kobo.737.1"> allows you to access DOM</span><a id="_idIndexMarker177"/><span class="koboSpan" id="kobo.738.1"> elements directly in React and is used to persist state values across re-renders. </span><span class="koboSpan" id="kobo.738.2">React, as a powerful library for UI, has a lot of novel concepts (virtual DOM design patterns, event handling, attribute manipulation) we can use to access and manipulate DOM elements without the use of traditional </span><span class="No-Break"><span class="koboSpan" id="kobo.739.1">DOM methods.</span></span></p>
<p><span class="koboSpan" id="kobo.740.1">This declarative approach to DOM is one of the reasons React is so popular. </span><span class="koboSpan" id="kobo.740.2">However, with </span><strong class="source-inline"><span class="koboSpan" id="kobo.741.1">useRef</span></strong><span class="koboSpan" id="kobo.742.1">, we can directly access DOM elements and freely manipulate them without consequence. </span><span class="koboSpan" id="kobo.742.2">The team at React felt that with </span><strong class="source-inline"><span class="koboSpan" id="kobo.743.1">useRef</span></strong><span class="koboSpan" id="kobo.744.1">, developers’ present and future cravings for direct DOM access might be met despite the React abstraction on top of </span><span class="No-Break"><span class="koboSpan" id="kobo.745.1">the DOM.</span></span></p>
<p><span class="koboSpan" id="kobo.746.1">There are two core uses </span><span class="No-Break"><span class="koboSpan" id="kobo.747.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.748.1">useRef</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.749.1">:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.750.1">Accessing DOM </span><span class="No-Break"><span class="koboSpan" id="kobo.751.1">elements directly</span></span></li>
<li><span class="koboSpan" id="kobo.752.1">Persisting state values that do not trigger the re-rendering of React components </span><span class="No-Break"><span class="koboSpan" id="kobo.753.1">when updated</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.754.1">If you are interested in how many times a component re-renders upon update, we can use either </span><strong class="source-inline"><span class="koboSpan" id="kobo.755.1">useState</span></strong><span class="koboSpan" id="kobo.756.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.757.1">useRef</span></strong><span class="koboSpan" id="kobo.758.1">. </span><span class="koboSpan" id="kobo.758.2">But it will be a bad idea to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.759.1">useState</span></strong><span class="koboSpan" id="kobo.760.1">. </span><span class="koboSpan" id="kobo.760.2">Using this might leave users stuck in an infinite loop of re-rendering since </span><strong class="source-inline"><span class="koboSpan" id="kobo.761.1">useState</span></strong><span class="koboSpan" id="kobo.762.1"> re-renders on every update of </span><span class="No-Break"><span class="koboSpan" id="kobo.763.1">its values.</span></span></p>
<p><span class="koboSpan" id="kobo.764.1">However, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.765.1">useRef</span></strong><span class="koboSpan" id="kobo.766.1"> Hook shines in this scenario as it can store state values across components re-rendering without triggering the </span><span class="No-Break"><span class="koboSpan" id="kobo.767.1">re-render mechanism.</span></span></p>
<p><span class="koboSpan" id="kobo.768.1">Let’s dive into a use case for </span><strong class="source-inline"><span class="koboSpan" id="kobo.769.1">useRef</span></strong><span class="koboSpan" id="kobo.770.1"> in the form of autofocusing an input field on a </span><span class="No-Break"><span class="koboSpan" id="kobo.771.1">rendered component:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.772.1">import React, {useRef} from 'react';const App = () =&gt; {
    const inputRef = useRef(null);
    const clickButton = () =&gt; {
      inputRef.current.focus();
    };
    return (
      &lt;&gt;
        &lt;input ref={inputRef} type="text" /&gt;
        &lt;button onClick={clickButton}&gt;click to Focus on
          input&lt;/button&gt;
      &lt;/&gt;
    );
  }
export default App</span></pre>
<p><span class="koboSpan" id="kobo.773.1">Let us </span><a id="_idIndexMarker178"/><span class="koboSpan" id="kobo.774.1">understand the preceding</span><a id="_idIndexMarker179"/><span class="koboSpan" id="kobo.775.1"> code </span><span class="No-Break"><span class="koboSpan" id="kobo.776.1">in detail:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.777.1">const inputRef = useRef(null);</span></strong><span class="koboSpan" id="kobo.778.1">: This line creates a reference for the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.779.1">useRef</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.780.1"> function</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.781.1">&lt;input ref={inputRef} type="text" /&gt;</span></strong><span class="koboSpan" id="kobo.782.1">: In this line, </span><strong class="source-inline"><span class="koboSpan" id="kobo.783.1">ref</span></strong><span class="koboSpan" id="kobo.784.1"> is added to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.785.1">input</span></strong><span class="koboSpan" id="kobo.786.1"> element to make use of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.787.1">useRef()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.788.1"> Hook</span></span></li>
<li><span class="koboSpan" id="kobo.789.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.790.1">onClick</span></strong><span class="koboSpan" id="kobo.791.1"> event is added to the button, which makes use of </span><strong class="source-inline"><span class="koboSpan" id="kobo.792.1">inputRef &lt;button onClick={clickButton}&gt;click</span></strong><span class="koboSpan" id="kobo.793.1"> to focus </span><span class="No-Break"><span class="koboSpan" id="kobo.794.1">on </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.795.1">input&lt;/button&gt;</span></strong></span></li>
</ul>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.796.1">useState</span></strong><span class="koboSpan" id="kobo.797.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.798.1">useRef</span></strong><span class="koboSpan" id="kobo.799.1"> are very similar in the sense that they hold state values. </span><span class="koboSpan" id="kobo.799.2">However, </span><strong class="source-inline"><span class="koboSpan" id="kobo.800.1">useState</span></strong><span class="koboSpan" id="kobo.801.1"> re-renders each time its values change, while </span><strong class="source-inline"><span class="koboSpan" id="kobo.802.1">useRef</span></strong><span class="koboSpan" id="kobo.803.1"> does not trigger </span><span class="No-Break"><span class="koboSpan" id="kobo.804.1">a re-render.</span></span></p>
<p><span class="koboSpan" id="kobo.805.1">Let’s move on to the next Hook, </span><strong class="source-inline"><span class="koboSpan" id="kobo.806.1">useReducer</span></strong><span class="koboSpan" id="kobo.807.1">. </span><span class="koboSpan" id="kobo.807.2">It is another hook to manage complex states in </span><span class="No-Break"><span class="koboSpan" id="kobo.808.1">React applications.</span></span></p>
<h1 id="_idParaDest-56"><a id="_idTextAnchor079"/><span class="koboSpan" id="kobo.809.1">Using useReducer for state management</span></h1>
<p><span class="koboSpan" id="kobo.810.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.811.1">useReducer</span></strong><span class="koboSpan" id="kobo.812.1"> hook is a </span><a id="_idIndexMarker180"/><span class="koboSpan" id="kobo.813.1">state management hook in a </span><a id="_idIndexMarker181"/><span class="koboSpan" id="kobo.814.1">React application. </span><span class="koboSpan" id="kobo.814.2">It is quite a bit more robust than the </span><strong class="source-inline"><span class="koboSpan" id="kobo.815.1">useState</span></strong><span class="koboSpan" id="kobo.816.1"> hook we discussed earlier in this chapter as it separates the state management logic in the function component from the </span><span class="No-Break"><span class="koboSpan" id="kobo.817.1">component-rendering logic.</span></span></p>
<p><span class="koboSpan" id="kobo.818.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.819.1">useState</span></strong><span class="koboSpan" id="kobo.820.1"> hook encapsulates the state management function with component rendering logic, which may become complex to handle in a large React project with the need for complex state management. </span><span class="koboSpan" id="kobo.820.2">The following is the syntax </span><span class="No-Break"><span class="koboSpan" id="kobo.821.1">for </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.822.1">useReducer</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.823.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.824.1">`const [state, dispatch] = useReducer(reducer, initialState)</span></pre>
<p><span class="koboSpan" id="kobo.825.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.826.1">useReducer</span></strong><span class="koboSpan" id="kobo.827.1"> hook accepts two arguments – the reducer, which is a function, and the initial application state. </span><span class="koboSpan" id="kobo.827.2">The Hook then returns two array values – the current state and the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.828.1">Dispatch</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.829.1"> function.</span></span></p>
<p><span class="koboSpan" id="kobo.830.1">Basically, we need to understand these core concepts </span><span class="No-Break"><span class="koboSpan" id="kobo.831.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.832.1">useReducer</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.833.1">:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.834.1">State</span></strong><span class="koboSpan" id="kobo.835.1">: This refers to mutable data that can be changed over time. </span><strong class="source-inline"><span class="koboSpan" id="kobo.836.1">State</span></strong><span class="koboSpan" id="kobo.837.1"> doesn’t have to be an object; it could also be an array </span><span class="No-Break"><span class="koboSpan" id="kobo.838.1">or number.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.839.1">Dispatch</span></strong><span class="koboSpan" id="kobo.840.1">: This is a function that allows us to modify the state. </span><strong class="source-inline"><span class="koboSpan" id="kobo.841.1">Dispatch</span></strong><span class="koboSpan" id="kobo.842.1"> is used to trigger the action that changes </span><span class="No-Break"><span class="koboSpan" id="kobo.843.1">the state.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.844.1">Reducer</span></strong><span class="koboSpan" id="kobo.845.1">: This is a function that handles the business logic of how the state could </span><span class="No-Break"><span class="koboSpan" id="kobo.846.1">be modified.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.847.1">IntialState</span></strong><span class="koboSpan" id="kobo.848.1">: This refers to the initial state of </span><span class="No-Break"><span class="koboSpan" id="kobo.849.1">the applications.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.850.1">Action</span></strong><span class="koboSpan" id="kobo.851.1">: This is an object with a set of properties. </span><span class="koboSpan" id="kobo.851.2">Type is a </span><span class="No-Break"><span class="koboSpan" id="kobo.852.1">required property.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.853.1">Payload</span></strong><span class="koboSpan" id="kobo.854.1">: This refers to the data of interest in a chunk of </span><span class="No-Break"><span class="koboSpan" id="kobo.855.1">network data.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.856.1">With </span><a id="_idIndexMarker182"/><span class="koboSpan" id="kobo.857.1">these core concepts explained, we also</span><a id="_idIndexMarker183"/><span class="koboSpan" id="kobo.858.1"> need to understand one more thing: the main purpose of </span><strong class="source-inline"><span class="koboSpan" id="kobo.859.1">useReducer</span></strong><span class="koboSpan" id="kobo.860.1"> is to manage complex multiple states in such a way that the logic for state management is separated from the component view functionality. </span><span class="koboSpan" id="kobo.860.2">We will elaborate more on this with a </span><span class="No-Break"><span class="koboSpan" id="kobo.861.1">practical example.</span></span></p>
<p><span class="koboSpan" id="kobo.862.1">Let’s dive in to see the use case </span><span class="No-Break"><span class="koboSpan" id="kobo.863.1">for </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.864.1">useReducer</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.865.1">:</span></span></p>
<p><span class="koboSpan" id="kobo.866.1">The</span><a id="_idIndexMarker184"/><span class="koboSpan" id="kobo.867.1"> following snippet will show how you </span><a id="_idIndexMarker185"/><span class="koboSpan" id="kobo.868.1">can use </span><strong class="source-inline"><span class="koboSpan" id="kobo.869.1">useReducer</span></strong><span class="koboSpan" id="kobo.870.1"> to manage different state properties. </span><span class="koboSpan" id="kobo.870.2">We will be working with an event schedule component. </span><span class="koboSpan" id="kobo.870.3">In the following code snippet, we are fetching the data from fake JSON </span><span class="No-Break"><span class="koboSpan" id="kobo.871.1">API data.</span></span></p>
<p><span class="koboSpan" id="kobo.872.1">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.873.1">src</span></strong><span class="koboSpan" id="kobo.874.1"> directory, create </span><strong class="source-inline"><span class="koboSpan" id="kobo.875.1">src/db.json</span></strong><span class="koboSpan" id="kobo.876.1"> and paste in this </span><span class="No-Break"><span class="koboSpan" id="kobo.877.1">data object:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.878.1">{    "schedules":    [
        {
            "id":1,
            "time":"10.00 AM",
            "speaker": "Juliet Abert",
            "subjectTitle":"Intro to React Hooks",
            "venue":"Auditorium C"
        },
        {
            "id":2,
            "time":"12.00 AM",
            "speaker": "Andrew Wilson",
            "subjectTitle":"React Performance Optimization"
            ,"venue":"Auditorium A"
        },
        {
            "id":3,
            "time":"2.00 PM",
            "speaker": "Lewis Hooper",
            "subjectTitle":"Intro to JavaScript",
            "venue":"Auditorium B"
        }
    ]
}</span></pre>
<p><span class="koboSpan" id="kobo.879.1">To install the </span><a id="_idIndexMarker186"/><span class="koboSpan" id="kobo.880.1">JSON server for mocking backend services, in </span><a id="_idIndexMarker187"/><span class="koboSpan" id="kobo.881.1">the terminal, enter the </span><span class="No-Break"><span class="koboSpan" id="kobo.882.1">following command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.883.1">npm i –g json-server</span></pre>
<p><span class="koboSpan" id="kobo.884.1">Start the server on port </span><strong class="source-inline"><span class="koboSpan" id="kobo.885.1">8000</span></strong><span class="koboSpan" id="kobo.886.1"> with the </span><span class="No-Break"><span class="koboSpan" id="kobo.887.1">following command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.888.1">json-server --watch db.json --port=8000</span></pre>
<p><span class="koboSpan" id="kobo.889.1">Once the JSON server is started, the following will appear in </span><span class="No-Break"><span class="koboSpan" id="kobo.890.1">your terminal:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.891.1">Loading db.json  Done 
  Resources
  http://localhost:8000/schedules 
  Home
  http://localhost:8000</span></pre>
<p><span class="koboSpan" id="kobo.892.1">Add the following snippet </span><span class="No-Break"><span class="koboSpan" id="kobo.893.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.894.1">App.js</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.895.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.896.1">import { useReducer, useEffect } from 'react';import axios from "axios";
const initialState = {
  isLoading: false,
  error: null,
  data: null,
};
const reducer = (state, action) =&gt; {
  switch (action.type) {
    case "getEventSchedule":
      return {
        ...state,
        isLoading: true,
        error: null,
      };
              &lt;/ul&gt;
    &lt;/div&gt;
  );
};
export default App;</span></pre>
<p><span class="koboSpan" id="kobo.897.1">The full source </span><a id="_idIndexMarker188"/><span class="koboSpan" id="kobo.898.1">code can be found on GitHub. </span><span class="koboSpan" id="kobo.898.2">Let’s</span><a id="_idIndexMarker189"/><span class="koboSpan" id="kobo.899.1"> examine the </span><span class="No-Break"><span class="koboSpan" id="kobo.900.1">code snippet:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.901.1">The initial state properties of the component are </span><span class="No-Break"><span class="koboSpan" id="kobo.902.1">first specified:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.903.1">const initialState = {isLoading: false,error: null,data: null,};</span></pre></li>
<li><span class="koboSpan" id="kobo.904.1">Then, we </span><a id="_idIndexMarker190"/><span class="koboSpan" id="kobo.905.1">define </span><a id="_idIndexMarker191"/><span class="koboSpan" id="kobo.906.1">the </span><strong class="source-inline"><span class="koboSpan" id="kobo.907.1">Reducer</span></strong><span class="koboSpan" id="kobo.908.1"> function as </span><strong class="source-inline"><span class="koboSpan" id="kobo.909.1">const reducer = (state, action) =&gt; {}</span></strong><span class="koboSpan" id="kobo.910.1">.</span><p class="list-inset"><span class="koboSpan" id="kobo.911.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.912.1">Reducer</span></strong><span class="koboSpan" id="kobo.913.1"> function takes two arguments: </span><strong class="source-inline"><span class="koboSpan" id="kobo.914.1">state</span></strong><span class="koboSpan" id="kobo.915.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.916.1">action</span></strong><span class="koboSpan" id="kobo.917.1">. </span><span class="koboSpan" id="kobo.917.2">Then the action through the </span><strong class="source-inline"><span class="koboSpan" id="kobo.918.1">type</span></strong><span class="koboSpan" id="kobo.919.1"> property defines the logic of the state. </span><span class="koboSpan" id="kobo.919.2">In this case, the switch runs through a series of conditional action-based operations and returns a specific </span><span class="No-Break"><span class="koboSpan" id="kobo.920.1">action type.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.921.1">The </span><a id="_idIndexMarker192"/><span class="koboSpan" id="kobo.922.1">action-type properties</span><a id="_idIndexMarker193"/><span class="koboSpan" id="kobo.923.1"> specified in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.924.1">reducer</span></strong><span class="koboSpan" id="kobo.925.1"> function, for instance, </span><strong class="source-inline"><span class="koboSpan" id="kobo.926.1">getEventSchedule</span></strong><span class="koboSpan" id="kobo.927.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.928.1">getEventScheduleSuccess</span></strong><span class="koboSpan" id="kobo.929.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.930.1">getEventScheduleFailure</span></strong><span class="koboSpan" id="kobo.931.1">, allow us to modify the state of the component based on the state of the </span><span class="No-Break"><span class="koboSpan" id="kobo.932.1">action type.</span></span></p></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.933.1">getEventSchedule&lt;EventSchedule[]&gt;</span></strong><span class="koboSpan" id="kobo.934.1"> accepts all the properties of </span><strong class="source-inline"><span class="koboSpan" id="kobo.935.1">initalState</span></strong><span class="koboSpan" id="kobo.936.1">, and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.937.1">isLoading</span></strong><span class="koboSpan" id="kobo.938.1"> property is set to </span><strong class="source-inline"><span class="koboSpan" id="kobo.939.1">true</span></strong><span class="koboSpan" id="kobo.940.1"> because we are fetching this </span><span class="No-Break"><span class="koboSpan" id="kobo.941.1">state data:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.942.1">case "getEventSchedule":      return {        ...state,{/*accepts other initial State          properties*/}        isLoading: true, {/*change the initial state          of isLoading*/}      };</span></pre></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.943.1">getEventScheduleSuccess</span></strong><span class="koboSpan" id="kobo.944.1"> will be invoked when the </span><strong class="source-inline"><span class="koboSpan" id="kobo.945.1">data</span></strong><span class="koboSpan" id="kobo.946.1"> property is modified through the returned data in </span><strong class="source-inline"><span class="koboSpan" id="kobo.947.1">action.payload: EventSchedule[]</span></strong><span class="koboSpan" id="kobo.948.1">, and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.949.1">isLoading</span></strong><span class="koboSpan" id="kobo.950.1"> property is set back </span><span class="No-Break"><span class="koboSpan" id="kobo.951.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.952.1">false</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.953.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.954.1">    case "getEventScheduleSuccess":      return {        ...state,        isLoading: false,        data: action.payload,{/*we have useful          returned data at this state*/}      };</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.955.1">And if </span><a id="_idIndexMarker194"/><span class="koboSpan" id="kobo.956.1">there is no returned data, </span><strong class="source-inline"><span class="koboSpan" id="kobo.957.1">getEventScheduleFailure</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.958.1">:Action</span></strong><a id="_idIndexMarker195"/><span class="koboSpan" id="kobo.959.1"> is invoked and an error </span><span class="No-Break"><span class="koboSpan" id="kobo.960.1">is displayed:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.961.1">.catch(() =&gt; {  dispatch({ type: "getEventScheduleFailure" });});</span></pre></li>
<li><span class="koboSpan" id="kobo.962.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.963.1">App()</span></strong><span class="koboSpan" id="kobo.964.1"> component handles the view part of the component state where </span><strong class="source-inline"><span class="koboSpan" id="kobo.965.1">useReducer()</span></strong><span class="koboSpan" id="kobo.966.1"> is defined </span><span class="No-Break"><span class="koboSpan" id="kobo.967.1">and executed:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.968.1">const [state, dispatch] = useReducer(reducer, initialState);</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.969.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.970.1">useReducer()</span></strong><span class="koboSpan" id="kobo.971.1"> accepts two arguments—</span><strong class="source-inline"><span class="koboSpan" id="kobo.972.1">reducer</span></strong><span class="koboSpan" id="kobo.973.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.974.1">initialState</span></strong><span class="koboSpan" id="kobo.975.1">—and returns two array variables: </span><strong class="source-inline"><span class="koboSpan" id="kobo.976.1">state</span></strong><span class="koboSpan" id="kobo.977.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.978.1">dispatch</span></strong><span class="koboSpan" id="kobo.979.1">. </span><span class="koboSpan" id="kobo.979.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.980.1">state</span></strong><span class="koboSpan" id="kobo.981.1"> variable holds the state object and </span><strong class="source-inline"><span class="koboSpan" id="kobo.982.1">dispatch</span></strong><span class="koboSpan" id="kobo.983.1"> is a function that allows the reducer to update the state based on the invoked type of action in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.984.1">reducer</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.985.1"> function.</span></span></p></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.986.1">useEffect()</span></strong><span class="koboSpan" id="kobo.987.1"> is invoked to fetch the schedule data from the </span><span class="No-Break"><span class="koboSpan" id="kobo.988.1">endpoint specified:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.989.1">useEffect(() =&gt; {  dispatch({ type:"getEventSchedule" });  axios.get("http://localhost:8000/schedules/")    .then((response) =&gt; {      console.log("response", response);      dispatch({ type: "getEventScheduleSuccess",        payload: response.data });    })</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.990.1">Inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.991.1">useEffect()</span></strong><span class="koboSpan" id="kobo.992.1"> body, </span><strong class="source-inline"><span class="koboSpan" id="kobo.993.1">dispatch()</span></strong><span class="koboSpan" id="kobo.994.1"> is triggered based on the type of action. </span><span class="koboSpan" id="kobo.994.2">The object type is specified: </span><strong class="source-inline"><span class="koboSpan" id="kobo.995.1">dispatch({ </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.996.1">type:"getEventSchedule" });</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.997.1">.</span></span></p></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.998.1">axios()</span></strong><span class="koboSpan" id="kobo.999.1"> is invoked to fetch the endpoint data </span><span class="No-Break"><span class="koboSpan" id="kobo.1000.1">with </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1001.1">axios.get("http://localhost:8000/schedules/")</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1002.1">.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1003.1">When the</span><a id="_idIndexMarker196"/><span class="koboSpan" id="kobo.1004.1"> type of action is </span><strong class="source-inline"><span class="koboSpan" id="kobo.1005.1">getEventScheduleSuccess</span></strong><span class="koboSpan" id="kobo.1006.1">, we expect</span><a id="_idIndexMarker197"/><span class="koboSpan" id="kobo.1007.1"> returned data, thus the payload property – </span><strong class="source-inline"><span class="koboSpan" id="kobo.1008.1">dispatch({ type: "getEventScheduleSuccess", payload: </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1009.1">response.data })</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1010.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1011.1">The following snippet handles the error that may occur from this </span><span class="No-Break"><span class="koboSpan" id="kobo.1012.1">promise-based request:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1013.1">.catch(() =&gt; {  dispatch({ type: "getEventScheduleFailure" });
});</span></pre>
<p><span class="koboSpan" id="kobo.1014.1">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1015.1">App()</span></strong><span class="koboSpan" id="kobo.1016.1"> component </span><strong class="source-inline"><span class="koboSpan" id="kobo.1017.1">return</span></strong><span class="koboSpan" id="kobo.1018.1"> construct, we render schedules to the screen with the </span><span class="No-Break"><span class="koboSpan" id="kobo.1019.1">following snippet:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1020.1">            &lt;h2&gt;Event Schedules&lt;/h2&gt;            {state.isLoading &amp;&amp; &lt;div&gt;Loading...&lt;/div&gt;}
            {state.error &amp;&amp; &lt;div&gt;{state.error}&lt;/div&gt;}
            {state.dat</span><a id="_idTextAnchor080"/><span class="koboSpan" id="kobo.1021.1">a &amp;&amp; state.data.length === 0
              &amp;&amp;   &lt;div&gt;No schedules available.&lt;/div&gt;}
            &lt;ul&gt;
              {state.data &amp;&amp; state.data.map(({ id, time,
                speaker, subjectTitle, venue }) =&gt; (
                &lt;li key={id}&gt;
                  Time: {time} &lt;br /&gt;
                  Speaker: {speaker}&lt;br /&gt;
                  Subject: {subjectTitle}&lt;br /&gt;
                  Venue: {venue}
                &lt;/li&gt;
              ))}
            &lt;/ul&gt;</span></pre>
<p><span class="koboSpan" id="kobo.1022.1">We</span><a id="_idIndexMarker198"/><span class="koboSpan" id="kobo.1023.1"> check whether </span><strong class="source-inline"><span class="koboSpan" id="kobo.1024.1">initialState :State</span></strong><span class="koboSpan" id="kobo.1025.1"> is in the</span><a id="_idIndexMarker199"/><span class="koboSpan" id="kobo.1026.1"> loading state and display </span><strong class="source-inline"><span class="koboSpan" id="kobo.1027.1">&lt;div&gt;Loading…&lt;/div&gt;</span></strong><span class="koboSpan" id="kobo.1028.1">. </span><span class="koboSpan" id="kobo.1028.2">If the error state is </span><strong class="source-inline"><span class="koboSpan" id="kobo.1029.1">true</span></strong><span class="koboSpan" id="kobo.1030.1">, we display the error. </span><span class="koboSpan" id="kobo.1030.2">If there is no data to fetch, we display the appropriate message. </span><span class="koboSpan" id="kobo.1030.3">We also check the data state and ensure we have data to display. </span><span class="koboSpan" id="kobo.1030.4">Now, start the server if it’s not running, with </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1031.1">npm start</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1032.1">:</span></span></p>
<p><span class="koboSpan" id="kobo.1033.1">The following screenshot shows an example implementation </span><span class="No-Break"><span class="koboSpan" id="kobo.1034.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1035.1">useReducer</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1036.1">.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer033">
<span class="koboSpan" id="kobo.1037.1"><img alt="Figure 3.1 – Screenshot showing the effect of the useReducer Hook" src="image/Figure_3.1_B18554.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1038.1">Figure 3.1 – Screenshot showing the effect of the useReducer Hook</span></p>
<p><span class="koboSpan" id="kobo.1039.1">We have seen how we can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1040.1">useReducer</span></strong><span class="koboSpan" id="kobo.1041.1"> Hook to manage advanced multiple states in React. </span><span class="koboSpan" id="kobo.1041.2">In the next section, we will examine what </span><strong class="source-inline"><span class="koboSpan" id="kobo.1042.1">useMemo</span></strong><span class="koboSpan" id="kobo.1043.1"> is and how we can use it to improve performance in </span><span class="No-Break"><span class="koboSpan" id="kobo.1044.1">React applications.</span></span></p>
<h1 id="_idParaDest-57"><a id="_idTextAnchor081"/><span class="koboSpan" id="kobo.1045.1">Using useMemo to improve performance</span></h1>
<p><span class="koboSpan" id="kobo.1046.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1047.1">useMemo</span></strong><span class="koboSpan" id="kobo.1048.1"> Hook is part of the core </span><a id="_idIndexMarker200"/><span class="koboSpan" id="kobo.1049.1">APIs in React geared toward improving the performance of </span><a id="_idIndexMarker201"/><span class="koboSpan" id="kobo.1050.1">React applications. </span><span class="koboSpan" id="kobo.1050.2">It uses a technique known in software development </span><span class="No-Break"><span class="koboSpan" id="kobo.1051.1">as </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1052.1">memoization</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1053.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1054.1">This is an optimization technique used to enhance the performance of software by keeping in memory the results of resource-intensive computation function calls and sending back the cached output when the same inputs are used subsequently. </span><span class="koboSpan" id="kobo.1054.2">So, why is </span><strong class="source-inline"><span class="koboSpan" id="kobo.1055.1">useMemo</span></strong><span class="koboSpan" id="kobo.1056.1"> important in React application development? </span><strong class="source-inline"><span class="koboSpan" id="kobo.1057.1">useMemo</span></strong><span class="koboSpan" id="kobo.1058.1"> solves two performance problems for a </span><span class="No-Break"><span class="koboSpan" id="kobo.1059.1">React developer.</span></span></p>
<h2 id="_idParaDest-58"><a id="_idTextAnchor082"/><span class="koboSpan" id="kobo.1060.1">Prevents unnecessary component re-rendering</span></h2>
<p><span class="koboSpan" id="kobo.1061.1">It memoizes the return value of a function for computations that consume a lot of resources by sending back a cached function result upon subsequent requests without a </span><span class="No-Break"><span class="koboSpan" id="kobo.1062.1">state update.</span></span></p>
<p><span class="koboSpan" id="kobo.1063.1">Let’s dive into a use case for </span><strong class="source-inline"><span class="koboSpan" id="kobo.1064.1">useMemo</span></strong><span class="koboSpan" id="kobo.1065.1"> to better understand how it can be used in React. </span><span class="koboSpan" id="kobo.1065.2">This snippet shows how a component re-renders on every character search. </span><span class="koboSpan" id="kobo.1065.3">With a large application that has over 20,000 users, this could result in </span><span class="No-Break"><span class="koboSpan" id="kobo.1066.1">performance issues.</span></span></p>
<p><span class="koboSpan" id="kobo.1067.1">First, we’ll see what the code looks like </span><span class="No-Break"><span class="koboSpan" id="kobo.1068.1">without </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1069.1">useMemo</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1070.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1071.1">import React, { useState} from 'react';const speakers = [
  {id: 10, name: "John Lewis"},
  { id: 11, name: "Mable Newton"},
];
const App = () =&gt; {
  const [text, setText] = useState("");
  const [searchTerm, setSearchTerm] = useState("");
  const onChangeText = (e) =&gt; {
    setText(e.target.value);
  };
  console.log("Text", text);
  const handleClick = (e) =&gt; {
    setSearchTerm(e.target.value);
  };
  console.log("Search Term", text);
  ));
  });
  return (
      &lt;div&gt;
        ---
    &lt;/div&gt;
  );
};
export default App;</span></pre>
<p><span class="koboSpan" id="kobo.1072.1">The following</span><a id="_idIndexMarker202"/><span class="koboSpan" id="kobo.1073.1"> screenshot shows the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1074.1">list</span></strong><span class="koboSpan" id="kobo.1075.1"> component re-rendering on every </span><span class="No-Break"><span class="koboSpan" id="kobo.1076.1">character search:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer034">
<span class="koboSpan" id="kobo.1077.1"><img alt="Figure 3.2 – A console showing components re-rendering" src="image/Figure_3.2_B18554.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1078.1">Figure 3.2 – A console showing components re-rendering</span></p>
<p><span class="koboSpan" id="kobo.1079.1">Let’s go through the</span><a id="_idIndexMarker203"/><span class="koboSpan" id="kobo.1080.1"> implementation of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1081.1">useMemo</span></strong><span class="koboSpan" id="kobo.1082.1"> Hook and gain insights into how developers can significantly enhance performance and optimize resource usage in React applications, ensuring that expensive computations are only executed </span><span class="No-Break"><span class="koboSpan" id="kobo.1083.1">when necessary:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.1084.1">Hypothetical data source</span></strong><span class="koboSpan" id="kobo.1085.1">: </span><strong class="source-inline"><span class="koboSpan" id="kobo.1086.1">speakers</span></strong><span class="koboSpan" id="kobo.1087.1"> is declared to hold the array of </span><span class="No-Break"><span class="koboSpan" id="kobo.1088.1">object data:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1089.1">const speakers = [  {id: 10, name: "John Lewis"},  { id: 11, name: "Mable Newton"},];</span></pre></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.1090.1">Variables to state</span></strong><span class="koboSpan" id="kobo.1091.1">: </span><strong class="source-inline"><span class="koboSpan" id="kobo.1092.1">text</span></strong><span class="koboSpan" id="kobo.1093.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1094.1">searchTerm</span></strong><span class="koboSpan" id="kobo.1095.1"> are declared with their setter methods as </span><span class="No-Break"><span class="koboSpan" id="kobo.1096.1">state variables:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1097.1">const [text, setText] = useState("");const [searchTerm, setSearchTerm] = useState("");</span></pre></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1098.1">onChange</span></strong><span class="koboSpan" id="kobo.1099.1"> handler: This event handler updates the initial state to the </span><span class="No-Break"><span class="koboSpan" id="kobo.1100.1">current state:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1101.1">const handleClick = (e) =&gt; {    setSearchTerm(e.target.value);  };</span></pre></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.1102.1">Function to filter speakers</span></strong><span class="koboSpan" id="kobo.1103.1">: The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1104.1">filteredSpeakers</span></strong><span class="koboSpan" id="kobo.1105.1"> function is used to filter an array of speakers based on </span><strong class="source-inline"><span class="koboSpan" id="kobo.1106.1">searchTerm</span></strong><span class="koboSpan" id="kobo.1107.1"> using a case-insensitive search. </span><span class="koboSpan" id="kobo.1107.2">With this filtering, you are able to optimize the performance of filtering by memoizing the </span><span class="No-Break"><span class="koboSpan" id="kobo.1108.1">filtered results:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1109.1">const filteredSpeakers = speakers.filter((speaker) =&gt; {  console.log("Filtering speakers...");  return speaker.name.toLowerCase()    .includes(searchTerm.toLowerCase());}</span></pre></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.1110.1">Output to screen</span></strong><span class="koboSpan" id="kobo.1111.1">: This </span><a id="_idIndexMarker204"/><span class="koboSpan" id="kobo.1112.1">shows the result of rendering the component with the effect </span><span class="No-Break"><span class="koboSpan" id="kobo.1113.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1114.1">useMemo</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1115.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1116.1">&lt;div&gt;  &lt;input type="text" onChange={onChangeText} /&gt;  &lt;button onClick={handleClick}&gt;Search&lt;/button&gt;&lt;/div&gt;{filteredSpeakers.map((filteredSpeaker) =&gt; (  &lt;li key={filteredSpeaker.id}&gt;    {filteredSpeaker.name}&lt;/li&gt;))}&lt;/div&gt;</span></pre></li>
</ul>
<p><span class="koboSpan" id="kobo.1117.1">As you can see in the preceding snippet, the dependency property for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1118.1">speaker</span></strong><span class="koboSpan" id="kobo.1119.1"> component hasn’t changed. </span><span class="koboSpan" id="kobo.1119.2">There is no need for re-rendering, but the console shows us that there </span><span class="No-Break"><span class="koboSpan" id="kobo.1120.1">is re-rendering.</span></span></p>
<p><span class="koboSpan" id="kobo.1121.1">Now let’s see what the code looks like with </span><strong class="source-inline"><span class="koboSpan" id="kobo.1122.1">useMemo</span></strong><span class="koboSpan" id="kobo.1123.1">. </span><span class="koboSpan" id="kobo.1123.2">Update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1124.1">filteredSpeakers</span></strong><span class="koboSpan" id="kobo.1125.1"> function in the preceding code with the </span><span class="No-Break"><span class="koboSpan" id="kobo.1126.1">following snippet:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1127.1">  const filteredSpeakers = useMemo( () =&gt;    speakers.filter((speaker) =&gt; {
    console.log("Filtering speakers...");
    return speaker.name.toLowerCase()
      .includes(searchTerm.toLowerCase());
  },[searchTerm]));</span></pre>
<p><span class="koboSpan" id="kobo.1128.1">The preceding snippet shows the use of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1129.1">useMemo</span></strong><span class="koboSpan" id="kobo.1130.1"> on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1131.1">filteredSpeakers</span></strong><span class="koboSpan" id="kobo.1132.1"> function. </span><span class="koboSpan" id="kobo.1132.2">This function only executes once the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1133.1">searchTerm</span></strong><span class="koboSpan" id="kobo.1134.1"> state changes. </span><span class="koboSpan" id="kobo.1134.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1135.1">filteredSpeakers</span></strong><span class="koboSpan" id="kobo.1136.1"> function is not expected to run when the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1137.1">text</span></strong><span class="koboSpan" id="kobo.1138.1"> state changes, because that is </span><a id="_idIndexMarker205"/><span class="koboSpan" id="kobo.1139.1">obviously not a dependency in the dependency array for the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1140.1">useMemo</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1141.1"> Hook.</span></span></p>
<p><span class="koboSpan" id="kobo.1142.1">Next, we will explore </span><strong class="source-inline"><span class="koboSpan" id="kobo.1143.1">useCallback</span></strong><span class="koboSpan" id="kobo.1144.1">. </span><span class="koboSpan" id="kobo.1144.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1145.1">useCallback</span></strong><span class="koboSpan" id="kobo.1146.1"> Hook is similar to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1147.1">useMemo</span></strong><span class="koboSpan" id="kobo.1148.1"> Hook in making React applications performant. </span><span class="koboSpan" id="kobo.1148.2">Both </span><strong class="source-inline"><span class="koboSpan" id="kobo.1149.1">useCallback</span></strong><span class="koboSpan" id="kobo.1150.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1151.1">useMemo</span></strong><span class="koboSpan" id="kobo.1152.1"> optimize React applications. </span><span class="koboSpan" id="kobo.1152.2">Let’s dive in to understand </span><strong class="source-inline"><span class="koboSpan" id="kobo.1153.1">useCallback</span></strong><span class="koboSpan" id="kobo.1154.1"> in avoiding the re-rendering of </span><span class="No-Break"><span class="koboSpan" id="kobo.1155.1">component functions.</span></span></p>
<h1 id="_idParaDest-59"><a id="_idTextAnchor083"/><span class="koboSpan" id="kobo.1156.1">Using useCallback to avoid re-rendering functions</span></h1>
<p><span class="koboSpan" id="kobo.1157.1">In React </span><a id="_idIndexMarker206"/><span class="koboSpan" id="kobo.1158.1">function components, there is an additional optimization Hook called </span><strong class="source-inline"><span class="koboSpan" id="kobo.1159.1">useCallback</span></strong><span class="koboSpan" id="kobo.1160.1">. </span><span class="koboSpan" id="kobo.1160.2">It shares functionality with </span><strong class="source-inline"><span class="koboSpan" id="kobo.1161.1">useMemo</span></strong><span class="koboSpan" id="kobo.1162.1">, with a slight difference in output behavior in terms of what is returned. </span><span class="koboSpan" id="kobo.1162.2">In </span><strong class="source-inline"><span class="koboSpan" id="kobo.1163.1">useCallback</span></strong><span class="koboSpan" id="kobo.1164.1">, a memoized function is returned, while </span><strong class="source-inline"><span class="koboSpan" id="kobo.1165.1">useMemo</span></strong><span class="koboSpan" id="kobo.1166.1"> returns memoized returned values of </span><span class="No-Break"><span class="koboSpan" id="kobo.1167.1">the function.</span></span></p>
<p><span class="koboSpan" id="kobo.1168.1">Like </span><strong class="source-inline"><span class="koboSpan" id="kobo.1169.1">useMemo</span></strong><span class="koboSpan" id="kobo.1170.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1171.1">useCallback</span></strong><span class="koboSpan" id="kobo.1172.1"> is invoked when one of its dependencies is updated inside the function component. </span><span class="koboSpan" id="kobo.1172.2">This ensures that the functional components are not necessarily re-rendered constantly. </span><span class="koboSpan" id="kobo.1172.3">There are key highlights </span><span class="No-Break"><span class="koboSpan" id="kobo.1173.1">for </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1174.1">useCallback</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1175.1">:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.1176.1">A memoized callback function is returned in </span><strong class="source-inline"><span class="koboSpan" id="kobo.1177.1">useCallback</span></strong><span class="koboSpan" id="kobo.1178.1">. </span><span class="koboSpan" id="kobo.1178.2">This improves the performance of the React application based on </span><span class="No-Break"><span class="koboSpan" id="kobo.1179.1">memoization techniques.</span></span></li>
<li><span class="koboSpan" id="kobo.1180.1">The change in the dependencies of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1181.1">useCallback</span></strong><span class="koboSpan" id="kobo.1182.1"> Hook determines whether it will update </span><span class="No-Break"><span class="koboSpan" id="kobo.1183.1">or not.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1184.1">Right now, let’s dive into a simple use case of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1185.1">useCallback</span></strong><span class="koboSpan" id="kobo.1186.1"> for </span><span class="No-Break"><span class="koboSpan" id="kobo.1187.1">deeper understanding.</span></span></p>
<p><span class="koboSpan" id="kobo.1188.1">The following snippet displays a list of speakers to simulate the high computation requirements to consider the usage of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1189.1">useCallback</span></strong><span class="koboSpan" id="kobo.1190.1"> for performance optimization. </span><span class="koboSpan" id="kobo.1190.2">Also, it is important to note that this illustration is by no means sufficient enough as a use case to demonstrate real-life performance bottleneck scenarios, but it comes in handy to explain </span><span class="No-Break"><span class="koboSpan" id="kobo.1191.1">this scenario.</span></span></p>
<p><span class="koboSpan" id="kobo.1192.1">Assuming we have a huge list of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1193.1">speakers</span></strong><span class="koboSpan" id="kobo.1194.1"> components to handle displaying and searching for speakers, without the use of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1195.1">useCallback</span></strong><span class="koboSpan" id="kobo.1196.1">, we will discover for every character search in the input field, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1197.1">App</span></strong><span class="koboSpan" id="kobo.1198.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1199.1">List</span></strong><span class="koboSpan" id="kobo.1200.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1201.1">ListItem</span></strong><span class="koboSpan" id="kobo.1202.1"> will be </span><span class="No-Break"><span class="koboSpan" id="kobo.1203.1">re-rendered needlessly.</span></span></p>
<p><span class="koboSpan" id="kobo.1204.1">The</span><a id="_idIndexMarker207"/><span class="koboSpan" id="kobo.1205.1"> complete snippet can be found at </span><a href="https://github.com/PacktPublishing/Full-Stack-Flask-and-React/blob/main/Chapter03/08"><span class="koboSpan" id="kobo.1206.1">https://github.com/PacktPublishing/Full-Stack-Flask-and-React/blob/main/Chapter03/08</span></a><span class="koboSpan" id="kobo.1207.1"> in the book’s </span><span class="No-Break"><span class="koboSpan" id="kobo.1208.1">GitHub repository:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1209.1">import React, {useState,useCallback} from 'react';  const handleRemoveSpeaker = useCallback(
    (id) =&gt; setSpeakers(speakers.filter((user) =&gt;
      user.id !== id)),
    [speakers]
  );</span></pre>
<p><span class="koboSpan" id="kobo.1210.1">The preceding code snippet demonstrates </span><strong class="source-inline"><span class="koboSpan" id="kobo.1211.1">useCallback</span></strong><span class="koboSpan" id="kobo.1212.1">. </span><span class="koboSpan" id="kobo.1212.2">The code structure is essentially similar to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1213.1">useMemo</span></strong><span class="koboSpan" id="kobo.1214.1">, except that </span><strong class="source-inline"><span class="koboSpan" id="kobo.1215.1">useCallback</span></strong><span class="koboSpan" id="kobo.1216.1"> is wrapped around the function we intend to cache </span><span class="No-Break"><span class="koboSpan" id="kobo.1217.1">or memoize.</span></span></p>
<p><span class="koboSpan" id="kobo.1218.1">In the following figure, we see how the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1219.1">App</span></strong><span class="koboSpan" id="kobo.1220.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1221.1">List</span></strong><span class="koboSpan" id="kobo.1222.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1223.1">ListItem</span></strong><span class="koboSpan" id="kobo.1224.1"> components re-render with every character search in the search </span><span class="No-Break"><span class="koboSpan" id="kobo.1225.1">input box.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer035">
<span class="koboSpan" id="kobo.1226.1"><img alt="Figure 3.3 – Screenshot showing the usage of useCallback" src="image/Figure_3.3_B18554.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1227.1">Figure 3.3 – Screenshot showing the usage of useCallback</span></p>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.1228.1">handleRemoveSpeaker: React.FC&lt;ButtonProps&gt;</span></strong><span class="koboSpan" id="kobo.1229.1"> is optimized with </span><strong class="source-inline"><span class="koboSpan" id="kobo.1230.1">useCallback</span></strong><span class="koboSpan" id="kobo.1231.1"> to prevent the re-rendering of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1232.1">List</span></strong><span class="koboSpan" id="kobo.1233.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1234.1">ListItem</span></strong><span class="koboSpan" id="kobo.1235.1"> components due to a change in the state of the search input. </span><span class="koboSpan" id="kobo.1235.2">The re-rendering of components is expected if users of the application click on the </span><strong class="bold"><span class="koboSpan" id="kobo.1236.1">Add a Speaker</span></strong><span class="koboSpan" id="kobo.1237.1"> or </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1238.1">Remove</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1239.1"> buttons.</span></span></p>
<p><span class="koboSpan" id="kobo.1240.1">There is </span><a id="_idIndexMarker208"/><span class="koboSpan" id="kobo.1241.1">one major problem the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1242.1">useCallback</span></strong><span class="koboSpan" id="kobo.1243.1"> Hook solves in React: preventing unnecessary re-rendering of components due to a referential </span><span class="No-Break"><span class="koboSpan" id="kobo.1244.1">equality check.</span></span></p>
<p><span class="koboSpan" id="kobo.1245.1">Next, we will dissect the use of custom Hooks to separate the business logic of the component from the rendering function. </span><span class="koboSpan" id="kobo.1245.2">This allows function reusability and a better organization of code in a </span><span class="No-Break"><span class="koboSpan" id="kobo.1246.1">React application.</span></span></p>
<h1 id="_idParaDest-60"><a id="_idTextAnchor084"/><span class="koboSpan" id="kobo.1247.1">Using custom Hooks for code reusability</span></h1>
<p><span class="koboSpan" id="kobo.1248.1">We have extensively discussed some of the in-built Hooks in React. </span><span class="koboSpan" id="kobo.1248.2">Hooks have been part of the core React library since v16.8, which allows React components to exhibit statefulness without a class-based approach. </span><span class="koboSpan" id="kobo.1248.3">Hooks such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.1249.1">useState</span></strong><span class="koboSpan" id="kobo.1250.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1251.1">useEffect</span></strong><span class="koboSpan" id="kobo.1252.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1253.1">UseMemo</span></strong><span class="koboSpan" id="kobo.1254.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1255.1">useRef</span></strong><span class="koboSpan" id="kobo.1256.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1257.1">useContext</span></strong><span class="koboSpan" id="kobo.1258.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1259.1">useCallback</span></strong><span class="koboSpan" id="kobo.1260.1"> are specific functions to manage state, share stateful logic, and allow other interactions with React </span><span class="No-Break"><span class="koboSpan" id="kobo.1261.1">core APIs.</span></span></p>
<p><span class="koboSpan" id="kobo.1262.1">Now let’s understand what a custom Hook is and the benefits we can get from </span><span class="No-Break"><span class="koboSpan" id="kobo.1263.1">using them.</span></span></p>
<p><strong class="bold"><span class="koboSpan" id="kobo.1264.1">Custom Hooks</span></strong><span class="koboSpan" id="kobo.1265.1"> are </span><a id="_idIndexMarker209"/><span class="koboSpan" id="kobo.1266.1">normal JavaScript functions whose name starts with </span><strong class="source-inline"><span class="koboSpan" id="kobo.1267.1">use</span></strong><span class="koboSpan" id="kobo.1268.1"> and that usually invoke one or more in-built React Hooks. </span><span class="koboSpan" id="kobo.1268.2">For instance, custom Hooks could be named anything as long as it starts with </span><em class="italic"><span class="koboSpan" id="kobo.1269.1">use</span></em><span class="koboSpan" id="kobo.1270.1">, for instance, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1271.1">useCustomHook</span></strong><span class="koboSpan" id="kobo.1272.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1273.1">useFetchSpeakers</span></strong><span class="koboSpan" id="kobo.1274.1">, or </span><strong class="source-inline"><span class="koboSpan" id="kobo.1275.1">useUpdateDatabase</span></strong><span class="koboSpan" id="kobo.1276.1">. </span><span class="koboSpan" id="kobo.1276.2">Conventionally, there must be </span><strong class="source-inline"><span class="koboSpan" id="kobo.1277.1">use</span></strong><span class="koboSpan" id="kobo.1278.1"> in front of your custom </span><span class="No-Break"><span class="koboSpan" id="kobo.1279.1">Hook name.</span></span></p>
<p><span class="koboSpan" id="kobo.1280.1">So why should you </span><a id="_idIndexMarker210"/><span class="koboSpan" id="kobo.1281.1">want to build your own custom Hooks? </span><span class="koboSpan" id="kobo.1281.2">Let’s examine some of the reasons experienced React developers build </span><span class="No-Break"><span class="koboSpan" id="kobo.1282.1">custom Hooks:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.1283.1">As a React developer, you are going to write a ton of functions to solve problems in your React projects. </span><span class="koboSpan" id="kobo.1283.2">And if the best React practices are not followed, some of those functions are going to be repeated so often in many components of your project. </span><span class="koboSpan" id="kobo.1283.3">With a custom Hook, you can reuse stateful logic across several components in </span><span class="No-Break"><span class="koboSpan" id="kobo.1284.1">your project.</span></span></li>
<li><span class="koboSpan" id="kobo.1285.1">Custom Hooks encourage the separation of concerns between state logic functions and view layers </span><span class="No-Break"><span class="koboSpan" id="kobo.1286.1">of components.</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.1287.1">Easy debugging.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1288.1">Let’s see an implementation example of </span><span class="No-Break"><span class="koboSpan" id="kobo.1289.1">custom Hooks:</span></span></p>
<p><span class="koboSpan" id="kobo.1290.1">Inside </span><strong class="source-inline"><span class="koboSpan" id="kobo.1291.1">App.js</span></strong><span class="koboSpan" id="kobo.1292.1">, enter </span><span class="No-Break"><span class="koboSpan" id="kobo.1293.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1294.1">import React from 'react';import useFetchSpeakers from "./useFetchSpeakers";
const App = () =&gt; {
  const API_URL = "https://dummyjson.com/users";
  const [data] = useFetchSpeakers(API_URL);
  return (
    &lt;&gt;
      &lt;ul&gt;
        {data.map((item) =&gt; (
          &lt;li key={item.id}&gt;
            {item.firstName} {item.lastName}
          &lt;/li&gt;
        ))}
      &lt;/ul&gt;
    &lt;/&gt;
  );
};
export default App;</span></pre>
<p><span class="koboSpan" id="kobo.1295.1">Now, let’s </span><a id="_idIndexMarker211"/><span class="koboSpan" id="kobo.1296.1">break the preceding </span><span class="No-Break"><span class="koboSpan" id="kobo.1297.1">snippet down:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1298.1">import useFetchSpeakers from "./useFetchSpeakers"</span></strong><span class="koboSpan" id="kobo.1299.1"> brings the custom Hook into scope in this application. </span><span class="koboSpan" id="kobo.1299.2">Like any other Hook, we use </span><em class="italic"><span class="koboSpan" id="kobo.1300.1">use</span></em><span class="koboSpan" id="kobo.1301.1"> as part of the </span><span class="No-Break"><span class="koboSpan" id="kobo.1302.1">naming convention.</span></span></li>
<li><span class="koboSpan" id="kobo.1303.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1304.1">useFetchSpeakers</span></strong><span class="koboSpan" id="kobo.1305.1"> Hook returns the data variable state, based on </span><strong class="source-inline"><span class="koboSpan" id="kobo.1306.1">API_URL : string</span></strong><span class="koboSpan" id="kobo.1307.1"> passed as the endpoint. </span><span class="koboSpan" id="kobo.1307.2">This endpoint as an argument is passed to the custom </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1308.1">useFetchSpeakers</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1309.1"> Hook.</span></span></li>
<li><span class="koboSpan" id="kobo.1310.1">We then iterate over the data objects with </span><strong class="source-inline"><span class="koboSpan" id="kobo.1311.1">map()</span></strong><span class="koboSpan" id="kobo.1312.1"> to display the returned </span><strong class="source-inline"><span class="koboSpan" id="kobo.1313.1">firstName:string</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1314.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1315.1">lastName:string</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1316.1">.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1317.1">Inside </span><strong class="source-inline"><span class="koboSpan" id="kobo.1318.1">useFetchSpeakers.js</span></strong><span class="koboSpan" id="kobo.1319.1">, we </span><a id="_idIndexMarker212"/><span class="koboSpan" id="kobo.1320.1">define the custom Hook function with its locally </span><span class="No-Break"><span class="koboSpan" id="kobo.1321.1">managed state:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1322.1">import { useEffect, useState } from 'react';const useFetchSpeakers = (url) =&gt; {
  const [data, setData] = useState([]);
  useEffect(() =&gt; {
    const fetchSpeakers = async () =&gt; {
      try {
        const response = await fetch(url);
        const data = await response.json();
        setData(data.users);
      } catch (error) {
        console.log("error", error);
      }
    };
    fetchSpeakers();
  }, [url]);
  return [data];
};
export default useFetchSpeakers;</span></pre>
<p><span class="koboSpan" id="kobo.1323.1">In the </span><a id="_idIndexMarker213"/><span class="koboSpan" id="kobo.1324.1">preceding snippet, the following steps </span><span class="No-Break"><span class="koboSpan" id="kobo.1325.1">were involved:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.1326.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1327.1">useFetchSpeakers</span></strong><span class="koboSpan" id="kobo.1328.1"> custom Hook signature is defined. </span><span class="koboSpan" id="kobo.1328.2">It accepts </span><strong class="source-inline"><span class="koboSpan" id="kobo.1329.1">url</span></strong><span class="koboSpan" id="kobo.1330.1"> as </span><span class="No-Break"><span class="koboSpan" id="kobo.1331.1">an argument.</span></span></li>
<li><span class="koboSpan" id="kobo.1332.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1333.1">useFetchSpeakers</span></strong><span class="koboSpan" id="kobo.1334.1"> Hook uses </span><strong class="source-inline"><span class="koboSpan" id="kobo.1335.1">useEffect()</span></strong><span class="koboSpan" id="kobo.1336.1"> to asynchronously fetch data from an endpoint – the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1337.1">url</span></strong><span class="koboSpan" id="kobo.1338.1"> argument passed into the </span><span class="No-Break"><span class="koboSpan" id="kobo.1339.1">custom Hook.</span></span></li>
<li><span class="koboSpan" id="kobo.1340.1">A promise is returned with </span><em class="italic"><span class="koboSpan" id="kobo.1341.1">jsonified</span></em><span class="koboSpan" id="kobo.1342.1"> result data, which is made available to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1343.1">setData(data.users)</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1344.1"> state.</span></span></li>
<li><span class="koboSpan" id="kobo.1345.1">It has a dependency (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1346.1">url</span></strong><span class="koboSpan" id="kobo.1347.1">) that causes the component to re-render the component </span><a id="_idIndexMarker214"/><span class="koboSpan" id="kobo.1348.1">state upon any change in </span><span class="No-Break"><span class="koboSpan" id="kobo.1349.1">the data.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.1350.1">With this, you can see how the custom Hook allows the logic part of the component to be separated from the rendering part, and how code reusability is encouraged </span><span class="No-Break"><span class="koboSpan" id="kobo.1351.1">and implemented.</span></span></p>
<h1 id="_idParaDest-61"><a id="_idTextAnchor085"/><span class="koboSpan" id="kobo.1352.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.1353.1">In this chapter, we have been able to understand Hooks as a new mind shift in how we add statefulness to components in React. </span><span class="koboSpan" id="kobo.1353.2">Prior to Hooks, only class components could offer us stateful functionalities. </span><span class="koboSpan" id="kobo.1353.3">With React 16.8, we are now able to develop stateful functional components in React applications that are more elegant </span><span class="No-Break"><span class="koboSpan" id="kobo.1354.1">and concise.</span></span></p>
<p><span class="koboSpan" id="kobo.1355.1">The learning curve is easy as we can leverage our understanding of regular JavaScript functions and develop function components to power user interfaces for our web applications. </span><span class="koboSpan" id="kobo.1355.2">With Hooks in React, user and developer experiences have been </span><span class="No-Break"><span class="koboSpan" id="kobo.1356.1">greatly improved.</span></span></p>
<p><span class="koboSpan" id="kobo.1357.1">In the next chapter, we will focus extensively on how we can leverage React APIs to fetch data from external sources into our web applications. </span><span class="koboSpan" id="kobo.1357.2">Most of the applications we use today rely heavily on external data. </span><span class="koboSpan" id="kobo.1357.3">Undoubtedly, React shines well in </span><span class="No-Break"><span class="koboSpan" id="kobo.1358.1">this domain.</span></span></p>
</div>
</body></html>