<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-43"><a id="_idTextAnchor064"/>3</h1>
<h1 id="_idParaDest-44"><a id="_idTextAnchor065"/>Managing State with React Hooks</h1>
<p><a id="_idTextAnchor066"/><a href="B18554_02.xhtml#_idTextAnchor038"><em class="italic">Chapter 2</em></a>, <em class="italic">Getting Started with React</em>, was a great way to kick off React frontend development. By now, you should be familiar with project directory structures and a few other concepts in React. In this chapter, we will take your understanding of React’s core concepts further.</p>
<p>Why does this matter? Simple. You can’t be the shining light you intend to be with React development without getting a grounding in the React core features and how we use them. This chapter focuses on managing state with React <strong class="bold">Hooks</strong>.</p>
<p>State in React is the medium through which we add interactivity to the user interface. Before React v16.8, developing class components was the only way you could add state and state transitions to your components.</p>
<p>Functional components were stateless; they were only able to display <strong class="bold">JavaScript XML </strong>(<strong class="bold">JSX</strong>) elements, that is, presentational components only. But with the Hooks API, you can add state and state transitions to your functional components.</p>
<p>In this chapter, you will come to understand various React hooks and how we use them to add statefulness to functional components. The building blocks of any React application are components, and making them stateful is what enhances the user experience of web applications.</p>
<p>By the end of this chapter, you will be able to build stateful function components with hooks such as <code>useState</code>, <code>useEffect</code>, <code>useContext</code>, <code>useMemo</code>, and <code>useReducer</code>, and even be able to develop your own custom Hooks.</p>
<p>In this chapter, we will be covering the following topics:</p>
<ul>
<li>What is a Hook in React?</li>
<li>Why use Hooks in React?</li>
<li>Using <code>useState</code> to develop stateful components</li>
<li>Using <code>useEffect</code> to create useful side effects</li>
<li>Using <code>useContext</code> to manage React applications’ global state</li>
<li>Using <code>useRef</code> to directly access DOM elements and persist state values</li>
<li>Using <code>useReducer</code> for state management</li>
<li>Using <code>useMemo</code> to improve performance</li>
<li>Using <code>useCallback</code> to avoid re-rendering functions</li>
<li>Using custom Hooks for code reusability</li>
</ul>
<h1 id="_idParaDest-45"><a id="_idTextAnchor067"/>Technical requirements</h1>
<p>The complete code for this chapter is available on GitHub at: <a href="https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter03">https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter03</a>.</p>
<p>Due to page count constraints, the code blocks have been snipped. Please refer to GitHub for the full source code.</p>
<h1 id="_idParaDest-46"><a id="_idTextAnchor068"/>What is a Hook in React?</h1>
<p>A <strong class="bold">hook</strong> is a<a id="_idIndexMarker131"/> special function provided by React that lets you use React core features—state and component lifecycle methods—within a function component. While state is an in-built object in React that adds interactivity and dynamic mechanism to components, the lifecycle tracks the phases components go through, from their initialization to their eventual demise (when a user navigates away or exits from an application UI).</p>
<p>There are three major cyclic phases React components go through, as explained in <a href="B18554_02.xhtml#_idTextAnchor038"><em class="italic">Chapter 2</em></a>, <em class="italic">Getting Started with React</em>: mounting, updating, and unmounting. Each of these phases has what we call lifecycle methods that can be used during the rendering of React components.</p>
<p>We observed the presence of certain methods, such as <code>componentWillMount()</code>, <code>componentDidMount()</code>, <code>componentWillUpdate()</code>, and <code>componentDidUpdate()</code>, during the class component’s lifecycle. React hooks<a id="_idIndexMarker132"/> are used to make function components stateful without using class components’ lifecycle methods.</p>
<p>If you were working with stateful components before React version 16.8, you had no choice but to use class components as the only way to incorporate statefulness into your components.</p>
<p>Let’s look at a component<a id="_idIndexMarker133"/> that changes a first name to a full name when a button is clicked:</p>
<pre class="source-code">import React from 'react';class App extends React.Component{
  constructor(props) {
    super(props);
    this.state = {
      name: "Andrew",
    }
    this.updateNameState = this.updateNameState.bind(this);
  }
  updateNameState(){
    this.setState({
      name: "Andrew Peter"}
);
  }
  render() {
    return(
      &lt;div&gt;
        &lt;p&gt;{this.state.name}&lt;/p&gt;
        &lt;button onClick={this.updateNameState}&gt;Display Full
          Name&lt;/button&gt;
      &lt;/div&gt;
    );
  }
}
export default App;</pre>
<p>Let us understand the preceding code in detail:</p>
<ul>
<li><code>import React from 'react'</code>: This line brings React library core features into the scope.</li>
<li><code>class App extends React.Component</code>: This declares our <code>class App</code>, which extends the React component base class.</li>
<li>The following snippet defines a constructor that accepts <code>props</code> as an argument:<pre class="source-code">constructor(prop) {  super(props);  this.state = {    name: "Andrew",}</pre><p class="list-inset">This is a normal JavaScript class construct. Any class that extends the base class must have a <code>super()</code> method defined. The <code>this.state={name:"Andrew",}</code> part sets the initial state to <code>Andrew</code>. This is the state we want to update later in the code.</p></li>
<li>The following snippet ensures that the function’s <code>this</code> context will refer to the correct instance of the component when called:<pre class="source-code">this.updateNameState = this.updateNameState.bind(this);</pre><p class="list-inset">The <code>updateNameState</code> function is bound to the component instance using <code>.bind(this)</code>.</p></li>
<li>The following snippet demonstrates the state updater method:<pre class="source-code">        updateNameState(){          this.setState({            name:"Andrew Peter"          });        }</pre><p class="list-inset">It is invoked in our button to set state from <code>name:"Andrew"</code> to <code>name: "</code><code>Andrew Peter"</code>.</p></li>
<li><code>render()</code>: This is a compulsory method for every class component in React.</li>
<li><code>&lt;p&gt;{this.state.name}&lt;/p&gt;</code>: This sets our initial state, which is <code>Andrew</code>, and returns it for our viewing as JSX.</li>
<li>According to the following snippet, when the button is clicked, the <code>updateNameState()</code> class method is invoked and set to an updated state, which is <code>Andrew Peter</code>:<pre class="source-code">&lt;button onClick={this.updateNameState}&gt;  ChangeToFullName&lt;/button&gt;</pre></li>
</ul>
<p>In this chapter, we will refactor the preceding code snippet to a function component using a Hook. But before we delve into this, let’s look at two rules guiding how we write Hooks in React function <a id="_idIndexMarker134"/>components:</p>
<ul>
<li><strong class="bold">Rule 1</strong>: <em class="italic">Hooks must only be invoked at the </em><em class="italic">top level.</em><p class="list-inset">You can’t call Hooks from inside conditions, loops, or nested functions. Rather, you are to always invoke Hooks at the top level of your React function.</p></li>
<li><strong class="bold">Rule 2</strong>: <em class="italic">Hooks must only be invoked from a React </em><em class="italic">component function.</em><p class="list-inset">You can’t invoke<a id="_idIndexMarker135"/> Hooks from regular JavaScript functions, and neither can you invoke Hooks from the class component in React. You can only invoke Hooks from functional components. You can also invoke Hooks from custom Hooks.</p></li>
</ul>
<h1 id="_idParaDest-47"><a id="_idTextAnchor069"/>Why use Hooks in React?</h1>
<p>In the <a id="_idIndexMarker136"/>history of React, Hooks represented a significant shift in how we approach stateful components and manage side effects. Prior to Hooks, writing or refactoring class components was the primary method to enable components to exhibit interactivity and handle other side effects. Components serve as the building blocks of React applications’ UIs, and creating interactive interfaces necessitated the use of class components.</p>
<p>However, for beginners, the class syntax and structure can be challenging to understand. Sophie Alpert, former manager of the React team at Facebook, in her keynote (<em class="italic">React Today and Tomorrow</em>) at the <em class="italic">2018 React </em><em class="italic">Conference</em>, said:</p>
<p class="author-quote">“I claim classes are hard for humans…but it’s not just humans, I claim the classes are also hard for machines”</p>
<p class="author-quote">– Sophie Alpert (https://bit.ly/37MQjBD)</p>
<p>The use of <code>thi<a id="_idTextAnchor070"/>s</code> and <code>bind</code> in class components adds to the list of confusion. While JavaScript offers both the world of <strong class="bold">Object-Oriented Programming</strong> (<strong class="bold">OOP</strong>) and that of functional programming, with React class<a id="_idIndexMarker137"/> components, you can’t code without understanding the OOP paradigm.</p>
<p>This critically underscores the challenges that newcomers to the React world face. This was at least the case until React Hooks came into the picture. With Hooks, you simply write regular JavaScript functions that are easier to code, and you just have to hook into React Hooks for statefulness.</p>
<p>Another reason you might opt for React Hooks is the reusability of stateful logic across multiple components. Hooks allow you to separate stateful logic from component rendering logic, making it easier to reuse the logic in different components.</p>
<p>This separation ensures better modularity and reusability, as you can share your custom Hooks containing stateful logic across different React applications and with the broader React community. On the other hand, with class-based components, stateful logic and UI are often intertwined, which can make it harder to extract and reuse the logic efficiently.</p>
<p>In sum, React Hooks have triggered a new way of thinking about React component design. The possibility of gradual adoption in an existing code base (if you are still running on legacy React source code), makes it easy for diehard class component React developers to continue to write their stateful class components along with systematic migration of their code base to a functional-oriented approach.</p>
<p>The future of React is pointed toward functional component architecture. I can’t imagine anyone reasonably pursuing class components anymore at this stage. By learning about and writing function components, developers can harness the advantages of <a id="_idIndexMarker138"/>React more effectively.</p>
<p>In the next section, we will start the process of developing a stateful React component using Hooks. We will start with the <code>useState</code> Hook, the most popular React Hook, which brings state to function components.</p>
<h1 id="_idParaDest-48"><a id="_idTextAnchor071"/>Using useState to develop stateful components</h1>
<p>The <code>useState</code> Hook <a id="_idIndexMarker139"/>allows you to manage<a id="_idIndexMarker140"/> state in React applications. Function components rely on the <code>useState</code> Hook to add state variables to them. State is an object in React that can hold data information for use in React components. When you make a change to existing data, that change is stored as a state.</p>
<p>This is how it works: you pass an initial state property to <code>useState()</code>, which then returns a variable with the current state value and a function to update this value. The following is the syntax of the <code>useState</code> Hook:</p>
<pre class="source-code">const [state, stateUpdater] = useState(initialState);</pre>
<p>Let’s see a simplistic use case of how <code>useState</code> works:</p>
<pre class="source-code">import React, {useState} from 'react';const App = () =&gt; {
  const [count, setCount] = useState(0);
  const handleIncrementByTen = () =&gt; {
    setCount(count + 10);
  };
  const handleDecrementByTen = () =&gt; {
    setCount(count - 10);
  };
  const resetCountHandler = () =&gt; {
    setCount(0)
  };</pre>
<p>The <a id="_idIndexMarker141"/>preceding code snippet <a id="_idIndexMarker142"/>shows how you can develop a component that has increment, decrement, and reset states. When the <code>IncrementByTen</code> button is clicked, the counter increases the number by <code>10</code> and when the <code>DecrementByTen</code> button is clicked, the decrement state is activated and the number decreases by <code>10</code>.</p>
<p>The reset to the initial state does what it’s meant to do – it resets the value to its initial value. The following completes the code snippet:</p>
<pre class="source-code">  return (    &lt;div&gt;
      Initial Count: {count}
      &lt;hr /&gt;
      &lt;div&gt;
        &lt;button type="button"
          onClick={handleIncrementByTen}&gt;
          Increment by 10
        &lt;/button&gt;
        &lt;button type="button"
          onClick={handleDecrementByTen}&gt;
          Decrement by 10
        &lt;/button&gt;
        &lt;button type="button" onClick={resetCountHandler}&gt;
          Reset to Initial State
        &lt;/button&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  );
};
export default App;</pre>
<p>Let’s<a id="_idIndexMarker143"/> understand the preceding code in<a id="_idIndexMarker144"/> more detail:</p>
<ul>
<li>Importing <code>useState</code>: To use the <code>useState</code> Hook function, we first need to import it into our component from the <code>Import React, { useState } from 'react'</code> React object.</li>
<li>Initializing <code>useState</code>: We initialize our state by calling <code>useState</code> in our component as follows:<pre class="source-code">const [count, setCount] = useState(0);//using destructuring array to write a concise code.</pre><p class="list-inset"><code>useState&lt;number&gt;</code> accepts an initial state of zero (<code>useState(0)</code>) and returns two values: <code>count</code> and <code>setCount</code>:</p><ul><li><code>count</code>: The current state</li>
<li><code>setCount</code>: State updater function (this function is responsible for the new state of the initial state)</li>
</ul></li>
<li><code>useState(0)</code>: <code>useState &lt;number&gt;</code> with the initial value of <code>0</code><p class="list-inset">In <code>useState</code>, you can only declare a state property at a time. However, the data can be of any type: primitives, arrays, and even objects.</p></li>
<li><code>onClick</code> event<a id="_idIndexMarker147"/> functions<a id="_idIndexMarker148"/> are added to help emit event operations for our buttons. When the buttons are clicked, different event functions are invoked based on the expected actions.</p></li>
<li><code>handleIncrementByTen()</code>, <code>handleDecrementByTen()</code>, and <code>resetCountHandler()</code> functions are used to change the state values, as shown in the following snippet:<pre class="source-code">  const handleIncrementByTen = () =&gt; {    setCount(count + 10);  };  const handleDecrementByTen = () =&gt; {    setCount(count - 10);  };  const resetCountHandler = () =&gt; {    setCount(0)  };</pre></li>
</ul>
<p><code>useState&lt;number&gt;</code> can contain <a id="_idIndexMarker149"/>primitive and object<a id="_idIndexMarker150"/> data that can be accessed across React components. At this point, it is recommended you fire up your VS code or your preferred IDE and experiment with <code>useState</code> in developing a stateful component.</p>
<h2 id="_idParaDest-49"><a id="_idTextAnchor072"/>Passing state as props</h2>
<p>State is not <a id="_idIndexMarker151"/>limited to being used solely within the component<a id="_idIndexMarker152"/> where it is defined. You can pass state as props to child components, allowing them to display or use the parent state data.</p>
<p>Let’s consider the following example:</p>
<pre class="source-code">import React, { useState } from 'react';const ParentComponent = () =&gt; {
  const [count, setCount] = useState(0);
  const handleIncrementByTen = () =&gt; {
    setCount(count + 10);
  };
  return (
    &lt;div&gt;
      &lt;p&gt;Parent Count: {count}&lt;/p&gt;
      &lt;ChildComponent count={count} /&gt;
      &lt;button onClick={handleIncrementByTen}&gt;Increment
      &lt;/button&gt;
    &lt;/div&gt;
  );
};
const ChildComponent = ({ count }) =&gt; {
  return &lt;p&gt;Child Count: {count}&lt;/p&gt;;
};</pre>
<p>The preceding code shows a React function component with state using the <code>useState</code> Hook. It consists of two components, <code>ParentComponent</code> and <code>ChildComponent</code>, and demonstrates how to pass state data from the parent component to the child component.</p>
<p>When you<a id="_idIndexMarker153"/> use <code>ParentComponent</code> in your application, it will render <a id="_idIndexMarker154"/>with an initial <code>count: number</code> of <code>0</code>. <code>count: number</code>, and <code>ChildComponent</code>) will also display the same value as it receives it via the <code>count</code> prop. When you click the <code>count</code> state will increase by <code>10</code>, and both counts will reflect the same updated value.</p>
<h2 id="_idParaDest-50"><a id="_idTextAnchor073"/>Conditional rendering with state</h2>
<p><strong class="bold">Conditional rendering with state</strong> in React allows you to show or hide specific parts of the user <a id="_idIndexMarker155"/>interface based on the values of state variables. By using<a id="_idIndexMarker156"/> conditionals, you can control what content or components are displayed depending on the current state of your application.</p>
<p>This technique can be useful for creating dynamic and interactive user interfaces. Imagine having a <strong class="bold">Login</strong> button that turns into a <strong class="bold">Logout</strong> button once the user is logged in. That’s a classic example of conditional rendering! When you click the button, React will automatically update the UI to reflect the new state, making it super responsive. Oh, and that’s not all!</p>
<p>You can even use this magic to toggle the visibility of different elements, such as showing or hiding a cool modal or drop-down menu based on user actions. For instance, let’s say you have the <code>isLoggedIn</code> state variable, and you want to display different content based on whether the user is logged in or not.</p>
<p>The following code demonstrates how you can implement this with the <code>useState</code> Hook:</p>
<pre class="source-code">import React, { useState } from 'react';const Dashboard = () =&gt; {
  const [isLoggedIn, setIsLoggedIn] = useState(false);
  const handleLogin = () =&gt; {
    setIsLoggedIn(true);
  };
  const handleLogout = () =&gt; {
    setIsLoggedIn(false);
  };
  return (
    &lt;div&gt;
      {isLoggedIn ? (
        &lt;button onClick={handleLogout}&gt;Logout&lt;/button&gt;
      ) : (
        &lt;button onClick={handleLogin}&gt;Login&lt;/button&gt;
      )}
      {isLoggedIn &amp;&amp; &lt;p&gt;Hey friend, welcome!&lt;/p&gt;}
      {!isLoggedIn &amp;&amp; &lt;p&gt;Please log in to continue.&lt;/p&gt;}
    &lt;/div&gt;
  );
};</pre>
<p>The<a id="_idIndexMarker157"/> preceding code demonstrates a React component<a id="_idIndexMarker158"/> called <code>Dashboard</code>. It’s all about handling user authentication and showing personalized messages to the user.</p>
<p>Inside the <code>Dashboard</code> component, we have the <code>isLoggedIn</code> state variable, which is managed using the <code>useState</code> Hook. This variable keeps track of whether the user is currently logged in or not. When the component first renders, the initial state of <code>isLoggedIn</code> is set to false, indicating that the user is not logged in.</p>
<p>Now, let’s dive into the magic of conditional rendering! When you look at the JSX inside the <code>return</code> statement, you’ll see some interesting stuff happening. We use the <code>{}</code> curly braces to wrap our conditionals.</p>
<p>If <code>isLoggedIn</code> is <code>true</code>, we display a <code>onClick</code> event that triggers the respective <code>handleLogin</code> or <code>handleLogout</code> function. The fun doesn’t end there!</p>
<p>We also use more conditional rendering with <code>isLoggedIn</code> to display a personalized message for the user. When <code>isLoggedIn</code> is <code>true</code>, we show a warm greeting such as <code>handleLogin</code> function gets called, and guess what?</p>
<p>It sets <code>isLoggedIn</code> to <code>true</code>, indicating <a id="_idIndexMarker159"/>that the user is now logged in! Likewise, when the <a id="_idIndexMarker160"/>user clicks the <code>handleLogout</code> function is triggered, and it sets <code>isLoggedIn</code> back to <code>false</code>, meaning the user is now logged out.</p>
<p>In the next section, we will examine another Hook in React, <code>useEffect</code>. It is widely used to manipulate the DOM and fetch data from external sources.</p>
<h1 id="_idParaDest-51"><a id="_idTextAnchor074"/>Using useEffect to create side effects</h1>
<p>The <code>useEffect</code> Hook <a id="_idIndexMarker161"/>allows you to fetch data from external sources, update the DOM tree, and set up a data subscription. These operations are called side effects. In the class component, you have what we call lifecycle methods that can execute operations based on the phase of the component-rendering process. <code>useEffect</code> accepts two arguments: a function and an optional dependency.</p>
<p>It is important to note that <code>useEffect</code> does the work of the old <code>componentDidMount</code>, <code>componentDidUpdate</code>, and <code>componentWillUnmount</code> in one place. Using the <code>useEffect</code> Hook shortens the amount of code you have to write in a function component to achieve the same side effects.</p>
<p>The following is the syntax for the <code>useEffects</code> Hook:</p>
<pre class="source-code">- useEffect(&lt;function&gt;, &lt;dependency&gt;)useEffect(() =&gt; {
  // This callback function implementation is either to
     update DOM, fetch data from external sources, or to
     manage subscription that happens here.
}, [dependency]);</pre>
<p>Let’s dive<a id="_idIndexMarker162"/> into an example of using the <code>useEffect</code> Hook:</p>
<pre class="source-code">import React, { useEffect, useState } from 'react';const App = () =&gt; {
const [data, setData] = useState([]);
    const API_URL = "https://dummyjson.com/users";
      useEffect(() =&gt; {
        fetchSpeakers();
    }, []);
     return (
        &lt;ul&gt;
      {data.map(item =&gt; (
        &lt;li key={item.id}&gt;
          {item.firstName} {item.lastName}
        &lt;/li&gt;
      ))}
    &lt;/ul&gt;);
};
export default App;</pre>
<p>In the <a id="_idIndexMarker163"/>preceding code, we are fetching data from an external API source using <code>useEffect</code>. For this example, we have used fake API data from <code>https://dummyjson.com/users</code>. By the time we get to the backend development section of this book (<a href="B18554_09.xhtml#_idTextAnchor186"><em class="italic">Chapter 9</em></a>, <em class="italic">API Development and Documentation</em>), we will be developing custom API endpoints. Next, we will use the <code>useEffect()</code> Hook to call the <code>fetchSpeakers</code> function.</p>
<p>Refer to GitHub for the full code and have a look at the following points:</p>
<ul>
<li><code>import React, { useEffect, useState } from 'react';</code>: This line allows us to use <code>useEffect</code> and <code>useState</code> APIs from the React library.</li>
<li><code>const [data, setData] = useState([]);</code>: In this line, we have declared a state object set with an empty array as the initial data.</li>
<li><code>useEffect(()=&gt;{...}, [])</code>: This part of the code represents a signature set that fetches data from the specified external source. The second argument in the <code>useEffect</code> function, the dependency <code>[]</code>, is set to an empty array. The empty array ensures <code>useEffect()</code> renders just once, the first time, on mounting.<p class="list-inset">To have it render depending on state changes, you would have to pass the state through the dependency array. With this, you are able to prevent the constant unnecessary re-rendering of the component unless the dependency state changes.</p></li>
<li><code>fetchSpeakers():Promise&lt;Speaker[]&gt;</code> inside the <code>useEffect</code> Hook is a call to the <code>fetchSpeakers</code> function. This function is an asynchronous function that fetches data from a mocked remote API and sets the data in the component’s state using the <code>setData</code> function. The empty dependency array <code>[]</code> passed as the second argument to <code>useEffect</code> indicates that the effect should only run once when the component is mounted and never again after that.<p class="list-inset">Since there are no dependencies listed, the effect won’t be triggered by changes in any props or state variables. This is why it behaves like the <code>componentDidMount</code> lifecycle method, as it runs only once when the component is first rendered.</p></li>
<li><code>const API_URL = "https://dummyjson.com/users";</code>: The <code>API_URL</code> variable is set to hold the endpoint information about the external source.</li>
<li>The <code>try… catch</code> code block <a id="_idIndexMarker164"/>is set to execute the code and console error if there is an error fetching data from the endpoint:<pre class="source-code">  const fetchSpeakers = async () =&gt; {    try {      const response = await           fetch(API_URL);      const data = await response.json();      setData(data.users);    } catch (error) {      console.log("error", error);    }  };
fetch()</strong> API to fetch the data from the <code>API_URL</code> endpoint. The <code>try… catch</code> code block is set to execute the code and console error if there is an error fetching data from the endpoint.</pre></li>
<li><code>map()</code> is set on the data to loop through the object array data and display the newly created array from the function invocation on every array element <code>item: Speaker</code>:<pre class="source-code">{data.map(item =&gt; (        &lt;li key={item.id}&gt;          {item.firstName} {item.lastName}        &lt;/li&gt;      ))}</pre></li>
</ul>
<p>Let’s update <a id="_idIndexMarker165"/>the <code>useEffect</code> Hook function of the preceding code and add a state to its dependency and a <code>Cleanup</code> function. Adding a <code>Cleanup</code> function inside the <code>useEffect</code> hook serves a crucial purpose in React applications.</p>
<p>The <code>cleanup</code> function is executed when the component unmounts or when the dependencies listed in the <code>useEffect</code> hook change. Its main use is to perform cleanup tasks, freeing up resources, and preventing potential memory leaks or unexpected behavior in the application.</p>
<p>Now, update the preceding <code>useEffect()</code> as follows:</p>
<pre class="source-code">useEffect(() =&gt; {    const fetchData = async () =&gt; {
      const fetchedData = await fetchSpeakers();
      if (isMounted) {
        setData(fetchedData);
      }
    };
    fetchData();
    // Cleanup function
    return () =&gt; {
      isMounted = false;
    };
  }, [data]) ;// Adding data state as a dependency</pre>
<p>The preceding code uses the <code>useEffect</code> Hook to fetch data from an API (<code>fetchSpeakers</code>) and update the data state with the fetched result. It employs an <code>isMounted</code> flag <a id="_idIndexMarker166"/>to prevent setting the state after the component has unmounted, effectively avoiding potential issues. The data fetching effect runs whenever the <code>data</code> state changes, and the <code>Cleanup</code> function sets the <code>isMounted</code> flag to false when the component unmounts.</p>
<p>In sum, we have seen how <code>useEffect</code> could be used for side effect operation in a function component by fetching data from an external source. Next, we will look at how we can use the <code>useContext</code> Hook to better manage the global state in React applications.</p>
<h1 id="_idParaDest-52"><a id="_idTextAnchor075"/>Using useContext to manage global state in React applications</h1>
<p>The <code>useContext</code> Hook is <a id="_idIndexMarker167"/>used to share application state data across the component tree without having to pass props down explicitly at every component level. To put it simply, <code>useContext</code> is a way to manage React applications’ global state. Remember, we used the <code>useState</code> Hook to manage local state in the <em class="italic">Using useState to develop stateful </em><em class="italic">components</em> section.</p>
<p>However, as React project requirements expand in scope, it will be ineffective to use the <code>useState</code> Hook alone in passing state data in deeply nested components. The following is the syntax for the <code>useContext</code> Hook:</p>
<pre class="source-code">const Context = useContext(initialValue);</pre>
<p>Briefly, we will discuss <em class="italic">props drilling</em> to understand the challenges it poses. Afterward, we’ll delve into the implementation of the context API, which addresses these issues.</p>
<h2 id="_idParaDest-53"><a id="_idTextAnchor076"/>Understanding props drilling</h2>
<p>Let’s examine how you might<a id="_idIndexMarker168"/> pass data as props down a component hierarchy without the use of <code>useContext</code>. The following code snippet shows how we pass data to inner deeply nested components without the use of <code>useContext</code>:</p>
<pre class="source-code">  import React, {useState } from 'react';const App = () =&gt; {
  const [speakerName]= useState("Fred Morris");
  return (
    &lt;div&gt;
      &lt;h2&gt;This is Parent Component&lt;/h2&gt;
      &lt;ImmediateChildComponent speakerName={speakerName} /&gt;
    &lt;/div&gt;
    );
    }
    function ImmediateChildComponent({speakerName}) {
      return (
        &lt;div&gt;
          &lt;h2&gt;This is an immediate Child
            Component&lt;/h2&gt;&lt;hr/&gt;
          &lt;GrandChildComponent speakerName={speakerName} /&gt;
        &lt;/div&gt;
      );
    }
  }
export default App;</pre>
<p>The preceding code<a id="_idIndexMarker169"/> displays the name of a speaker in a function comprising nested components. The full source code is on GitHub.</p>
<p>Let us understand the code in more detail:</p>
<ul>
<li><code>const [speakerName]= useState</code>: This line is used to set the default state for <code>speakerName</code>.</li>
<li><code>&lt;App /&gt;</code> is a parent component that passes state using <code>{speakerName}</code> as props for the state needed in  <code>&lt;</code><code>GrandChildComponent /&gt;</code>:<pre class="source-code">  return (    &lt;div&gt;      &lt;h2&gt;This is Parent Component&lt;/h2&gt;      &lt;ImmediateChildComponent        speakerName={speakerName}    &lt;/div&gt;    );</pre><p class="list-inset">The parent<a id="_idIndexMarker170"/> has to pass through the <code>&lt;ImmediateChildComponent /&gt;</code> component to reach <code>&lt;GrandChildComponent  /&gt;</code> nested lower in the hierarchy. This becomes even more cumbersome when you have five or more intermediary components before we get to the actual component that needs the state information.</p><p class="list-inset">This is the problem <code>useContext</code> tries to solve. The following code shows the intermediate component and the final <code>GrandChildComponent: React.FC&lt;Props&gt;</code> where the states are required:</p><pre class="source-code">function ImmediateChildComponent({speakerName}) {      return (        &lt;div&gt;          &lt;h2&gt;This is an immediate Child            Component&lt;/h2&gt;&lt;hr/&gt;          &lt;GrandChildComponent            speakerName={speakerName}   /&gt;        &lt;/div&gt;      );    }    function GrandChildComponent({speakerName}) {      return (        &lt;div&gt;          &lt;h3&gt;This is a Grand Child Component&lt;/h3&gt;          &lt;h4&gt;Speakers Name: {speakerName}&lt;/h4&gt;        &lt;/div&gt;      );}</pre></li>
</ul>
<p>Let’s now <a id="_idIndexMarker171"/>look at how <code>useContext</code> can be used to solve the preceding problem by maintaining a global state where different components can communicate without causing prop drilling issues in React.</p>
<h2 id="_idParaDest-54"><a id="_idTextAnchor077"/>Using useContext to solve the props drilling problem</h2>
<p>With <code>useContext</code>, you will <a id="_idIndexMarker172"/>understand how you can pass state data across components without manually doing so with props. The following code shows how <code>useContext</code> is used:</p>
<pre class="source-code">import React, {useState, useContext,createContext } from  'react';
const context = createContext(null);
const App = () =&gt; {
const [speakerName]= useState("Fred Morris");
  return (
    &lt;context.Provider value={{ speakerName}}&gt;
            &lt;h1&gt;This is Parent Component&lt;/h1&gt;
            &lt;ImmediateChildComponent  /&gt;
      &lt;/context.Provider&gt;
        );}
function ImmediateChildComponent() {
    return (
      &lt;div&gt;
        &lt;h2&gt;This is an immediate Child Component&lt;/h2&gt;
        &lt;hr/&gt;
        &lt;GrandChildComponent  /&gt;
      &lt;/div&gt;);
}
}
  export default App;</pre>
<p>Let us<a id="_idIndexMarker173"/> understand the preceding code in detail. Refer to GitHub for the full source code:</p>
<ul>
<li><code>import React, {useState, useContext,createContext } from 'react';</code>: This line allows us to make use of <code>useState</code>, <code>useContext</code>, and <code>createContext</code> from the React library.</li>
<li><code>const context = createContext(null);</code>: This line creates <code>Context&lt;ContextType&gt;</code> and allows us to use <code>Provider:</code> <code>React.FC&lt;ProviderProps|null&gt;</code> with <code>null</code> as the initial value. Note that the <code>null</code> default value could also be any value provided to us by the <code>createContext</code> function.</li>
<li>The <a id="_idIndexMarker174"/>context provider envelopes the child component and makes the state values available, as follows:<pre class="source-code">        return (          &lt;context.Provider value={{ speakerName }}&gt;            &lt;h1&gt;This is Parent Component&lt;/h1&gt;            &lt;ImmediateChildComponent  /&gt;          &lt;/context.Provider&gt;        );</pre></li>
<li><code>const {speakerName} = useContext(context);</code>: In this line, we use the <code>useContext</code> Hook to have access to <code>context</code> in <code>&lt;</code><code>GrandChildComponent /&gt;</code>:<pre class="source-code">function GrandChildComponent():React.FC&lt;Props&gt; {  const {speakerName} = useContext(context);      return (        &lt;div&gt;          &lt;h3&gt;This is a Grand Child Component&lt;/h3&gt;          &lt;h4&gt;Speaker's Name: {speakerName}&lt;/h4&gt;        &lt;/div&gt;      );</pre></li>
</ul>
<p>In sum, the <code>useContext</code> Hook <a id="_idIndexMarker175"/>enables us to use <code>context</code> in function components no matter how nested the component hierarchy may be. This is always required in complex React applications where the state data may be needed across global application states. With <code>useContext</code>, we are able to share the information state that was passed as props without the direct interference of the intermediate components.</p>
<p>Next, we will delve into the <code>useRef</code> Hook and explore how it can be effectively utilized in a React component.</p>
<h1 id="_idParaDest-55"><a id="_idTextAnchor078"/>Using useRef to directly access DOM elements and persist state values</h1>
<p>The <code>useRef</code> Hook<a id="_idIndexMarker176"/> allows you to access DOM<a id="_idIndexMarker177"/> elements directly in React and is used to persist state values across re-renders. React, as a powerful library for UI, has a lot of novel concepts (virtual DOM design patterns, event handling, attribute manipulation) we can use to access and manipulate DOM elements without the use of traditional DOM methods.</p>
<p>This declarative approach to DOM is one of the reasons React is so popular. However, with <code>useRef</code>, we can directly access DOM elements and freely manipulate them without consequence. The team at React felt that with <code>useRef</code>, developers’ present and future cravings for direct DOM access might be met despite the React abstraction on top of the DOM.</p>
<p>There are two core uses of <code>useRef</code>:</p>
<ul>
<li>Accessing DOM elements directly</li>
<li>Persisting state values that do not trigger the re-rendering of React components when updated</li>
</ul>
<p>If you are interested in how many times a component re-renders upon update, we can use either <code>useState</code> or <code>useRef</code>. But it will be a bad idea to use <code>useState</code>. Using this might leave users stuck in an infinite loop of re-rendering since <code>useState</code> re-renders on every update of its values.</p>
<p>However, the <code>useRef</code> Hook shines in this scenario as it can store state values across components re-rendering without triggering the re-render mechanism.</p>
<p>Let’s dive into a use case for <code>useRef</code> in the form of autofocusing an input field on a rendered component:</p>
<pre class="source-code">import React, {useRef} from 'react';const App = () =&gt; {
    const inputRef = useRef(null);
    const clickButton = () =&gt; {
      inputRef.current.focus();
    };
    return (
      &lt;&gt;
        &lt;input ref={inputRef} type="text" /&gt;
        &lt;button onClick={clickButton}&gt;click to Focus on
          input&lt;/button&gt;
      &lt;/&gt;
    );
  }
export default App</pre>
<p>Let us <a id="_idIndexMarker178"/>understand the preceding<a id="_idIndexMarker179"/> code in detail:</p>
<ul>
<li><code>const inputRef = useRef(null);</code>: This line creates a reference for the <code>useRef</code> function</li>
<li><code>&lt;input ref={inputRef} type="text" /&gt;</code>: In this line, <code>ref</code> is added to the <code>input</code> element to make use of the <code>useRef()</code> Hook</li>
<li>The <code>onClick</code> event is added to the button, which makes use of <code>inputRef &lt;button onClick={clickButton}&gt;click</code> to focus on <code>input&lt;/button&gt;</code></li>
</ul>
<p><code>useState</code> and <code>useRef</code> are very similar in the sense that they hold state values. However, <code>useState</code> re-renders each time its values change, while <code>useRef</code> does not trigger a re-render.</p>
<p>Let’s move on to the next Hook, <code>useReducer</code>. It is another hook to manage complex states in React applications.</p>
<h1 id="_idParaDest-56"><a id="_idTextAnchor079"/>Using useReducer for state management</h1>
<p>The <code>useReducer</code> hook is a <a id="_idIndexMarker180"/>state management hook in a <a id="_idIndexMarker181"/>React application. It is quite a bit more robust than the <code>useState</code> hook we discussed earlier in this chapter as it separates the state management logic in the function component from the component-rendering logic.</p>
<p>The <code>useState</code> hook encapsulates the state management function with component rendering logic, which may become complex to handle in a large React project with the need for complex state management. The following is the syntax for <code>useReducer</code>:</p>
<pre class="source-code">`const [state, dispatch] = useReducer(reducer, initialState)</pre>
<p>The <code>useReducer</code> hook accepts two arguments – the reducer, which is a function, and the initial application state. The Hook then returns two array values – the current state and the <code>Dispatch</code> function.</p>
<p>Basically, we need to understand these core concepts in <code>useReducer</code>:</p>
<ul>
<li><code>State</code>: This refers to mutable data that can be changed over time. <code>State</code> doesn’t have to be an object; it could also be an array or number.</li>
<li><code>Dispatch</code>: This is a function that allows us to modify the state. <code>Dispatch</code> is used to trigger the action that changes the state.</li>
<li><code>Reducer</code>: This is a function that handles the business logic of how the state could be modified.</li>
<li><code>IntialState</code>: This refers to the initial state of the applications.</li>
<li><code>Action</code>: This is an object with a set of properties. Type is a required property.</li>
<li><code>Payload</code>: This refers to the data of interest in a chunk of network data.</li>
</ul>
<p>With <a id="_idIndexMarker182"/>these core concepts explained, we also<a id="_idIndexMarker183"/> need to understand one more thing: the main purpose of <code>useReducer</code> is to manage complex multiple states in such a way that the logic for state management is separated from the component view functionality. We will elaborate more on this with a practical example.</p>
<p>Let’s dive in to see the use case for <code>useReducer</code>:</p>
<p>The<a id="_idIndexMarker184"/> following snippet will show how you <a id="_idIndexMarker185"/>can use <code>useReducer</code> to manage different state properties. We will be working with an event schedule component. In the following code snippet, we are fetching the data from fake JSON API data.</p>
<p>In the <code>src</code> directory, create <code>src/db.json</code> and paste in this data object:</p>
<pre class="source-code">{    "schedules":    [
        {
            "id":1,
            "time":"10.00 AM",
            "speaker": "Juliet Abert",
            "subjectTitle":"Intro to React Hooks",
            "venue":"Auditorium C"
        },
        {
            "id":2,
            "time":"12.00 AM",
            "speaker": "Andrew Wilson",
            "subjectTitle":"React Performance Optimization"
            ,"venue":"Auditorium A"
        },
        {
            "id":3,
            "time":"2.00 PM",
            "speaker": "Lewis Hooper",
            "subjectTitle":"Intro to JavaScript",
            "venue":"Auditorium B"
        }
    ]
}</pre>
<p>To install the <a id="_idIndexMarker186"/>JSON server for mocking backend services, in <a id="_idIndexMarker187"/>the terminal, enter the following command:</p>
<pre class="console">npm i –g json-server</pre>
<p>Start the server on port <code>8000</code> with the following command:</p>
<pre class="console">json-server --watch db.json --port=8000</pre>
<p>Once the JSON server is started, the following will appear in your terminal:</p>
<pre class="console">Loading db.json  Done 
  Resources
  http://localhost:8000/schedules 
  Home
  http://localhost:8000</pre>
<p>Add the following snippet to <code>App.js</code>:</p>
<pre class="source-code">import { useReducer, useEffect } from 'react';import axios from "axios";
const initialState = {
  isLoading: false,
  error: null,
  data: null,
};
const reducer = (state, action) =&gt; {
  switch (action.type) {
    case "getEventSchedule":
      return {
        ...state,
        isLoading: true,
        error: null,
      };
              &lt;/ul&gt;
    &lt;/div&gt;
  );
};
export default App;</pre>
<p>The full source <a id="_idIndexMarker188"/>code can be found on GitHub. Let’s<a id="_idIndexMarker189"/> examine the code snippet:</p>
<ul>
<li>The initial state properties of the component are first specified:<pre class="source-code">const initialState = {isLoading: false,error: null,data: null,};</pre></li>
<li>Then, we <a id="_idIndexMarker190"/>define <a id="_idIndexMarker191"/>the <code>Reducer</code> function as <code>const reducer = (state, action) =&gt; {}</code>.<p class="list-inset">The <code>Reducer</code> function takes two arguments: <code>state</code> and <code>action</code>. Then the action through the <code>type</code> property defines the logic of the state. In this case, the switch runs through a series of conditional action-based operations and returns a specific action type.</p><p class="list-inset">The <a id="_idIndexMarker192"/>action-type properties<a id="_idIndexMarker193"/> specified in the <code>reducer</code> function, for instance, <code>getEventSchedule</code>, <code>getEventScheduleSuccess</code>, and <code>getEventScheduleFailure</code>, allow us to modify the state of the component based on the state of the action type.</p></li>
<li><code>getEventSchedule&lt;EventSchedule[]&gt;</code> accepts all the properties of <code>initalState</code>, and the <code>isLoading</code> property is set to <code>true</code> because we are fetching this state data:<pre class="source-code">case "getEventSchedule":      return {        ...state,{/*accepts other initial State          properties*/}        isLoading: true, {/*change the initial state          of isLoading*/}      };</pre></li>
<li><code>getEventScheduleSuccess</code> will be invoked when the <code>data</code> property is modified through the returned data in <code>action.payload: EventSchedule[]</code>, and the <code>isLoading</code> property is set back to <code>false</code>:<pre class="source-code">    case "getEventScheduleSuccess":      return {        ...state,        isLoading: false,        data: action.payload,{/*we have useful          returned data at this state*/}      };</pre><p class="list-inset">And if <a id="_idIndexMarker194"/>there is no returned data, <code>getEventScheduleFailure</code> <code>:Action</code><a id="_idIndexMarker195"/> is invoked and an error is displayed:</p><pre class="source-code">.catch(() =&gt; {  dispatch({ type: "getEventScheduleFailure" });});</pre></li>
<li>The <code>App()</code> component handles the view part of the component state where <code>useReducer()</code> is defined and executed:<pre class="source-code">const [state, dispatch] = useReducer(reducer, initialState);</pre><p class="list-inset">The <code>useReducer()</code> accepts two arguments—<code>reducer</code> and <code>initialState</code>—and returns two array variables: <code>state</code> and <code>dispatch</code>. The <code>state</code> variable holds the state object and <code>dispatch</code> is a function that allows the reducer to update the state based on the invoked type of action in the <code>reducer</code> function.</p></li>
<li><code>useEffect()</code> is invoked to fetch the schedule data from the endpoint specified:<pre class="source-code">useEffect(() =&gt; {  dispatch({ type:"getEventSchedule" });  axios.get("http://localhost:8000/schedules/")    .then((response) =&gt; {      console.log("response", response);      dispatch({ type: "getEventScheduleSuccess",        payload: response.data });    })</pre><p class="list-inset">Inside the <code>useEffect()</code> body, <code>dispatch()</code> is triggered based on the type of action. The object type is specified: <code>dispatch({ </code><code>type:"getEventSchedule" });</code>.</p></li>
<li><code>axios()</code> is invoked to fetch the endpoint data with <code>axios.get("http://localhost:8000/schedules/")</code>.</li>
</ul>
<p>When the<a id="_idIndexMarker196"/> type of action is <code>getEventScheduleSuccess</code>, we expect<a id="_idIndexMarker197"/> returned data, thus the payload property – <code>dispatch({ type: "getEventScheduleSuccess", payload: </code><code>response.data })</code>.</p>
<p>The following snippet handles the error that may occur from this promise-based request:</p>
<pre class="source-code">.catch(() =&gt; {  dispatch({ type: "getEventScheduleFailure" });
});</pre>
<p>In the <code>App()</code> component <code>return</code> construct, we render schedules to the screen with the following snippet:</p>
<pre class="source-code">            &lt;h2&gt;Event Schedules&lt;/h2&gt;            {state.isLoading &amp;&amp; &lt;div&gt;Loading...&lt;/div&gt;}
            {state.error &amp;&amp; &lt;div&gt;{state.error}&lt;/div&gt;}
            {state.dat<a id="_idTextAnchor080"/>a &amp;&amp; state.data.length === 0
              &amp;&amp;   &lt;div&gt;No schedules available.&lt;/div&gt;}
            &lt;ul&gt;
              {state.data &amp;&amp; state.data.map(({ id, time,
                speaker, subjectTitle, venue }) =&gt; (
                &lt;li key={id}&gt;
                  Time: {time} &lt;br /&gt;
                  Speaker: {speaker}&lt;br /&gt;
                  Subject: {subjectTitle}&lt;br /&gt;
                  Venue: {venue}
                &lt;/li&gt;
              ))}
            &lt;/ul&gt;</pre>
<p>We<a id="_idIndexMarker198"/> check whether <code>initialState :State</code> is in the<a id="_idIndexMarker199"/> loading state and display <code>&lt;div&gt;Loading…&lt;/div&gt;</code>. If the error state is <code>true</code>, we display the error. If there is no data to fetch, we display the appropriate message. We also check the data state and ensure we have data to display. Now, start the server if it’s not running, with <code>npm start</code>:</p>
<p>The following screenshot shows an example implementation of <code>useReducer</code>.</p>
<div><div><img alt="Figure 3.1 – Screenshot showing the effect of the useReducer Hook" src="img/Figure_3.1_B18554.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.1 – Screenshot showing the effect of the useReducer Hook</p>
<p>We have seen how we can use the <code>useReducer</code> Hook to manage advanced multiple states in React. In the next section, we will examine what <code>useMemo</code> is and how we can use it to improve performance in React applications.</p>
<h1 id="_idParaDest-57"><a id="_idTextAnchor081"/>Using useMemo to improve performance</h1>
<p>The <code>useMemo</code> Hook is part of the core <a id="_idIndexMarker200"/>APIs in React geared toward improving the performance of <a id="_idIndexMarker201"/>React applications. It uses a technique known in software development as <strong class="bold">memoization</strong>.</p>
<p>This is an optimization technique used to enhance the performance of software by keeping in memory the results of resource-intensive computation function calls and sending back the cached output when the same inputs are used subsequently. So, why is <code>useMemo</code> important in React application development? <code>useMemo</code> solves two performance problems for a React developer.</p>
<h2 id="_idParaDest-58"><a id="_idTextAnchor082"/>Prevents unnecessary component re-rendering</h2>
<p>It memoizes the return value of a function for computations that consume a lot of resources by sending back a cached function result upon subsequent requests without a state update.</p>
<p>Let’s dive into a use case for <code>useMemo</code> to better understand how it can be used in React. This snippet shows how a component re-renders on every character search. With a large application that has over 20,000 users, this could result in performance issues.</p>
<p>First, we’ll see what the code looks like without <code>useMemo</code>:</p>
<pre class="source-code">import React, { useState} from 'react';const speakers = [
  {id: 10, name: "John Lewis"},
  { id: 11, name: "Mable Newton"},
];
const App = () =&gt; {
  const [text, setText] = useState("");
  const [searchTerm, setSearchTerm] = useState("");
  const onChangeText = (e) =&gt; {
    setText(e.target.value);
  };
  console.log("Text", text);
  const handleClick = (e) =&gt; {
    setSearchTerm(e.target.value);
  };
  console.log("Search Term", text);
  ));
  });
  return (
      &lt;div&gt;
        ---
    &lt;/div&gt;
  );
};
export default App;</pre>
<p>The following<a id="_idIndexMarker202"/> screenshot shows the <code>list</code> component re-rendering on every character search:</p>
<div><div><img alt="Figure 3.2 – A console showing components re-rendering" src="img/Figure_3.2_B18554.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.2 – A console showing components re-rendering</p>
<p>Let’s go through the<a id="_idIndexMarker203"/> implementation of the <code>useMemo</code> Hook and gain insights into how developers can significantly enhance performance and optimize resource usage in React applications, ensuring that expensive computations are only executed when necessary:</p>
<ul>
<li><code>speakers</code> is declared to hold the array of object data:<pre class="source-code">const speakers = [  {id: 10, name: "John Lewis"},  { id: 11, name: "Mable Newton"},];</pre></li>
<li><code>text</code> and <code>searchTerm</code> are declared with their setter methods as state variables:<pre class="source-code">const [text, setText] = useState("");const [searchTerm, setSearchTerm] = useState("");</pre></li>
<li><code>onChange</code> handler: This event handler updates the initial state to the current state:<pre class="source-code">const handleClick = (e) =&gt; {    setSearchTerm(e.target.value);  };</pre></li>
<li><code>filteredSpeakers</code> function is used to filter an array of speakers based on <code>searchTerm</code> using a case-insensitive search. With this filtering, you are able to optimize the performance of filtering by memoizing the filtered results:<pre class="source-code">const filteredSpeakers = speakers.filter((speaker) =&gt; {  console.log("Filtering speakers...");  return speaker.name.toLowerCase()    .includes(searchTerm.toLowerCase());}</pre></li>
<li><code>useMemo</code>:<pre class="source-code">&lt;div&gt;  &lt;input type="text" onChange={onChangeText} /&gt;  &lt;button onClick={handleClick}&gt;Search&lt;/button&gt;&lt;/div&gt;{filteredSpeakers.map((filteredSpeaker) =&gt; (  &lt;li key={filteredSpeaker.id}&gt;    {filteredSpeaker.name}&lt;/li&gt;))}&lt;/div&gt;</pre></li>
</ul>
<p>As you can see in the preceding snippet, the dependency property for the <code>speaker</code> component hasn’t changed. There is no need for re-rendering, but the console shows us that there is re-rendering.</p>
<p>Now let’s see what the code looks like with <code>useMemo</code>. Update the <code>filteredSpeakers</code> function in the preceding code with the following snippet:</p>
<pre class="source-code">  const filteredSpeakers = useMemo( () =&gt;    speakers.filter((speaker) =&gt; {
    console.log("Filtering speakers...");
    return speaker.name.toLowerCase()
      .includes(searchTerm.toLowerCase());
  },[searchTerm]));</pre>
<p>The preceding snippet shows the use of <code>useMemo</code> on the <code>filteredSpeakers</code> function. This function only executes once the <code>searchTerm</code> state changes. The <code>filteredSpeakers</code> function is not expected to run when the <code>text</code> state changes, because that is <a id="_idIndexMarker205"/>obviously not a dependency in the dependency array for the <code>useMemo</code> Hook.</p>
<p>Next, we will explore <code>useCallback</code>. The <code>useCallback</code> Hook is similar to the <code>useMemo</code> Hook in making React applications performant. Both <code>useCallback</code> and <code>useMemo</code> optimize React applications. Let’s dive in to understand <code>useCallback</code> in avoiding the re-rendering of component functions.</p>
<h1 id="_idParaDest-59"><a id="_idTextAnchor083"/>Using useCallback to avoid re-rendering functions</h1>
<p>In React <a id="_idIndexMarker206"/>function components, there is an additional optimization Hook called <code>useCallback</code>. It shares functionality with <code>useMemo</code>, with a slight difference in output behavior in terms of what is returned. In <code>useCallback</code>, a memoized function is returned, while <code>useMemo</code> returns memoized returned values of the function.</p>
<p>Like <code>useMemo</code>, <code>useCallback</code> is invoked when one of its dependencies is updated inside the function component. This ensures that the functional components are not necessarily re-rendered constantly. There are key highlights for <code>useCallback</code>:</p>
<ul>
<li>A memoized callback function is returned in <code>useCallback</code>. This improves the performance of the React application based on memoization techniques.</li>
<li>The change in the dependencies of the <code>useCallback</code> Hook determines whether it will update or not.</li>
</ul>
<p>Right now, let’s dive into a simple use case of <code>useCallback</code> for deeper understanding.</p>
<p>The following snippet displays a list of speakers to simulate the high computation requirements to consider the usage of <code>useCallback</code> for performance optimization. Also, it is important to note that this illustration is by no means sufficient enough as a use case to demonstrate real-life performance bottleneck scenarios, but it comes in handy to explain this scenario.</p>
<p>Assuming we have a huge list of <code>speakers</code> components to handle displaying and searching for speakers, without the use of <code>useCallback</code>, we will discover for every character search in the input field, <code>App</code>, <code>List</code>, and <code>ListItem</code> will be re-rendered needlessly.</p>
<p>The<a id="_idIndexMarker207"/> complete snippet can be found at <a href="https://github.com/PacktPublishing/Full-Stack-Flask-and-React/blob/main/Chapter03/08">https://github.com/PacktPublishing/Full-Stack-Flask-and-React/blob/main/Chapter03/08</a> in the book’s GitHub repository:</p>
<pre class="source-code">import React, {useState,useCallback} from 'react';  const handleRemoveSpeaker = useCallback(
    (id) =&gt; setSpeakers(speakers.filter((user) =&gt;
      user.id !== id)),
    [speakers]
  );</pre>
<p>The preceding code snippet demonstrates <code>useCallback</code>. The code structure is essentially similar to <code>useMemo</code>, except that <code>useCallback</code> is wrapped around the function we intend to cache or memoize.</p>
<p>In the following figure, we see how the <code>App</code>, <code>List</code>, and <code>ListItem</code> components re-render with every character search in the search input box.</p>
<div><div><img alt="Figure 3.3 – Screenshot showing the usage of useCallback" src="img/Figure_3.3_B18554.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.3 – Screenshot showing the usage of useCallback</p>
<p><code>handleRemoveSpeaker: React.FC&lt;ButtonProps&gt;</code> is optimized with <code>useCallback</code> to prevent the re-rendering of the <code>List</code> and <code>ListItem</code> components due to a change in the state of the search input. The re-rendering of components is expected if users of the application click on the <strong class="bold">Add a Speaker</strong> or <strong class="bold">Remove</strong> buttons.</p>
<p>There is <a id="_idIndexMarker208"/>one major problem the <code>useCallback</code> Hook solves in React: preventing unnecessary re-rendering of components due to a referential equality check.</p>
<p>Next, we will dissect the use of custom Hooks to separate the business logic of the component from the rendering function. This allows function reusability and a better organization of code in a React application.</p>
<h1 id="_idParaDest-60"><a id="_idTextAnchor084"/>Using custom Hooks for code reusability</h1>
<p>We have extensively discussed some of the in-built Hooks in React. Hooks have been part of the core React library since v16.8, which allows React components to exhibit statefulness without a class-based approach. Hooks such as <code>useState</code>, <code>useEffect</code>, <code>UseMemo</code>, <code>useRef</code>, <code>useContext</code>, and <code>useCallback</code> are specific functions to manage state, share stateful logic, and allow other interactions with React core APIs.</p>
<p>Now let’s understand what a custom Hook is and the benefits we can get from using them.</p>
<p><code>use</code> and that usually invoke one or more in-built React Hooks. For instance, custom Hooks could be named anything as long as it starts with <em class="italic">use</em>, for instance, <code>useCustomHook</code>, <code>useFetchSpeakers</code>, or <code>useUpdateDatabase</code>. Conventionally, there must be <code>use</code> in front of your custom Hook name.</p>
<p>So why should you <a id="_idIndexMarker210"/>want to build your own custom Hooks? Let’s examine some of the reasons experienced React developers build custom Hooks:</p>
<ul>
<li>As a React developer, you are going to write a ton of functions to solve problems in your React projects. And if the best React practices are not followed, some of those functions are going to be repeated so often in many components of your project. With a custom Hook, you can reuse stateful logic across several components in your project.</li>
<li>Custom Hooks encourage the separation of concerns between state logic functions and view layers of components.</li>
<li>Easy debugging.</li>
</ul>
<p>Let’s see an implementation example of custom Hooks:</p>
<p>Inside <code>App.js</code>, enter the following:</p>
<pre class="source-code">import React from 'react';import useFetchSpeakers from "./useFetchSpeakers";
const App = () =&gt; {
  const API_URL = "https://dummyjson.com/users";
  const [data] = useFetchSpeakers(API_URL);
  return (
    &lt;&gt;
      &lt;ul&gt;
        {data.map((item) =&gt; (
          &lt;li key={item.id}&gt;
            {item.firstName} {item.lastName}
          &lt;/li&gt;
        ))}
      &lt;/ul&gt;
    &lt;/&gt;
  );
};
export default App;</pre>
<p>Now, let’s <a id="_idIndexMarker211"/>break the preceding snippet down:</p>
<ul>
<li><code>import useFetchSpeakers from "./useFetchSpeakers"</code> brings the custom Hook into scope in this application. Like any other Hook, we use <em class="italic">use</em> as part of the naming convention.</li>
<li>The <code>useFetchSpeakers</code> Hook returns the data variable state, based on <code>API_URL : string</code> passed as the endpoint. This endpoint as an argument is passed to the custom <code>useFetchSpeakers</code> Hook.</li>
<li>We then iterate over the data objects with <code>map()</code> to display the returned <code>firstName:string</code> and <code>lastName:string</code>.</li>
</ul>
<p>Inside <code>useFetchSpeakers.js</code>, we <a id="_idIndexMarker212"/>define the custom Hook function with its locally managed state:</p>
<pre class="source-code">import { useEffect, useState } from 'react';const useFetchSpeakers = (url) =&gt; {
  const [data, setData] = useState([]);
  useEffect(() =&gt; {
    const fetchSpeakers = async () =&gt; {
      try {
        const response = await fetch(url);
        const data = await response.json();
        setData(data.users);
      } catch (error) {
        console.log("error", error);
      }
    };
    fetchSpeakers();
  }, [url]);
  return [data];
};
export default useFetchSpeakers;</pre>
<p>In the <a id="_idIndexMarker213"/>preceding snippet, the following steps were involved:</p>
<ol>
<li>The <code>useFetchSpeakers</code> custom Hook signature is defined. It accepts <code>url</code> as an argument.</li>
<li>The <code>useFetchSpeakers</code> Hook uses <code>useEffect()</code> to asynchronously fetch data from an endpoint – the <code>url</code> argument passed into the custom Hook.</li>
<li>A promise is returned with <em class="italic">jsonified</em> result data, which is made available to the <code>setData(data.users)</code> state.</li>
<li>It has a dependency (<code>url</code>) that causes the component to re-render the component <a id="_idIndexMarker214"/>state upon any change in the data.</li>
</ol>
<p>With this, you can see how the custom Hook allows the logic part of the component to be separated from the rendering part, and how code reusability is encouraged and implemented.</p>
<h1 id="_idParaDest-61"><a id="_idTextAnchor085"/>Summary</h1>
<p>In this chapter, we have been able to understand Hooks as a new mind shift in how we add statefulness to components in React. Prior to Hooks, only class components could offer us stateful functionalities. With React 16.8, we are now able to develop stateful functional components in React applications that are more elegant and concise.</p>
<p>The learning curve is easy as we can leverage our understanding of regular JavaScript functions and develop function components to power user interfaces for our web applications. With Hooks in React, user and developer experiences have been greatly improved.</p>
<p>In the next chapter, we will focus extensively on how we can leverage React APIs to fetch data from external sources into our web applications. Most of the applications we use today rely heavily on external data. Undoubtedly, React shines well in this domain.</p>
</div>
</body></html>