- en: Gesture-Controlled Robotic Vehicle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous few chapters, you have learned a lot about sensors—what they
    do and how they work. The number of sensors on this planet is simply out of bonds.
    It's ever increasing, and while you are reading this book, there could be some
    new sensor being launched by some country across the world. This might make you
    wonder, do you have to learn about all of these sensors coming out on the market
    every single day?
  prefs: []
  type: TYPE_NORMAL
- en: Thankfully, as you have learned, these sensors are more or less similar and
    work on a limited set of protocols. This makes working with new sensors easy.
    You might think that we have covered most of our basic sensors. However, that
    wouldn't be true—as we are yet to learn one of the most important sensors when
    it comes to the balancing of robots. These are accelerometers and gyroscope. These
    two sensors are not only present in all of these robots that have anything to
    do with balancing, but they have also found their way into our mobile devices.
    So, now let's learn about the basics of these sensors.
  prefs: []
  type: TYPE_NORMAL
- en: Accelerometers and gyroscope
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's first start with accelerometers. As the name suggests, these are meant
    to measure acceleration in any body. Hence, whenever there is any acceleration
    in any body, then the accelerometers have the work to sense that acceleration
    and give the corresponding reading.
  prefs: []
  type: TYPE_NORMAL
- en: A gyroscope is a device that uses Earth's gravity to help determine orientation
    of the robot. An accelerometer is a device designed to measure non-gravitational acceleration.
    Whenever there is any acceleration, the crystals in the accelerometer excite and
    provide a voltage corresponding to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main difference between these devices is simple: the gyroscope can sense
    rotation, whereas the accelerometer cannot. In a way, the accelerometer can gauge
    the orientation of a stationary item with relation to Earth''s surface. When accelerating
    in a particular direction, the accelerometer is unable to distinguish between
    that and the acceleration provided through Earth''s gravitational pull. The gyroscope
    measures the rate of rotation around a particular axis. In comparison, the accelerometer
    measures linear acceleration.'
  prefs: []
  type: TYPE_NORMAL
- en: Here in this chapter, we will be using a sensor called MPU 6050, which is one
    of the most common sensors that has both the accelerometers and gyroscope built
    into one single package.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ca5ef65f-b25b-4056-a746-1ed045b8f809.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Preceding is a photograph of it. As you can see, it has **SCL** and **SDA**
    lines. Hence, you can be sure that this sensor works on I2C protocol. This is
    cool because we have already had a good experience working with I2C type sensors.
  prefs: []
  type: TYPE_NORMAL
- en: Interfacing the inertial measurement unit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MPU 6050 is a three-axis accelerometer and three-axis gyroscope. It works on
    I2C, but the interesting thing about this sensor is that it has a different address
    for different sensors. What did you just say? Different address for different
    sensors. Isn't it one single sensor?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, yes it is, but if you see the internal construction of the sensor, then
    you would find that for every different axis, the data is being stored in different
    registers from where we can acquire the data at our disposal. Hence, if you require
    just the reading of x axis of accelerometer, then you can do so efficiently rather
    than getting a whole long string of different values. Now connecting this sensor
    is super easy. All you have to do is to power it up using Raspberry Pi and simply
    connect the I2C pins over, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1568df83-88d0-4155-af55-7066bd7a6eb2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once the wiring is done, go ahead and upload the following code. Once you do
    so, run and see what you get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now it''s time to see what we have done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In this lines, we are defining a function called `MPU_Init()`. This will be
    used to initialize the **inertial measurement unit** (**IMU**) sensor. In this
    function, we are using a method called `write_byte_data()` from the library `bus`.
    What it does is that it writes the data to a specific register declared in the
    argument. The data written using this function would be of a byte in size. Now
    we are declaring `Device_Address`. That is, the data written would be on the connected
    device''s address. The second argument `SMPLRT_DIV` will tell the address of the
    register in hexadecimal. Hence, the value of `SMPLRT_DIV` would be used as the
    address. The last argument is the data that needs to be written, which in our
    case is `7`. Similarly, the following would be the values passed to the device:'
  prefs: []
  type: TYPE_NORMAL
- en: '`PWR_MGMT_1`: `1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CONFIG`: `0`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GYRO_CONFIG`: `24`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`INT_ENABLE`: `1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These values would be required to set up the sensor. What these values are
    doing is not of an importance to us at this point. However, if you wish to know,
    then you can use the data sheet of the IMU MPU 6050 and get what all these registers
    are doing in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are defining a function called `read_raw_data(addr)` reading the address
    from the device and then register where we are reading the address from is `addr` for
    the `high` variable and `addr+1` for the `low` variable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Once the data has been acquired then it is being processed by the following
    statement `value = ((high << 8) | low)` what this does is that shifts the value
    of the high variable hence if the data of the variable high in binary is `10111011`,
    `(high <<8)` would transform this value to `1011101100000000`. Once that is done
    the and operator would add the eight digit value to the newly calculated value
    of high. Making the output a 16 bit integer. Now you must be thinking why did
    we do this?
  prefs: []
  type: TYPE_NORMAL
- en: 'The value which is being given by the MPU 6050 for any reading is 16 bit. However
    the registers of MPU 6050 are 8 bit in size. Now what MPU 6050 does is that it
    stores the value of any sensor in the registers based on the position of the bits.
    That is the most significant 8 bits would be stored in the first address and the
    rest of the least significant 8 bits would be stored in the next address that
    is `addr+1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As we understood in the last line, the output data from the sensor would be
    in a 16 bit format. When the sensor would be in the normal position this reading
    would be lying somewhere in the middle. If the value is more than the middle reading
    we would subtract the value by `65535`, hence providing us a negative value for
    every value which is over the middle reading. This would give us a sense of direction
    without doing much brain work. If the values are positive the tilt is in one direction
    and if negative then in other direction.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have defined the function called `read_raw_data()` we can start
    reading the data from different sensors. These sensors would be saving the data
    onto different addresses. These lists of addresses we have mentioned earlier.
    Hence by passing that data to the function we can get to know the reading of every
    single sensor. All these readings are being calculated and the data is stored
    in a variable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In this line we are simply printing the values of each of the variables corresponding
    to each of the sensors.
  prefs: []
  type: TYPE_NORMAL
- en: Now once you run this code you will see the values of each of the sensors coming
    out and this will change as you change the orientation or acceleration. Explore
    the reading and how they are changing in respect to movement. I'm sure it would
    give you a plentiful idea about the sensor. So go ahead and enjoy!
  prefs: []
  type: TYPE_NORMAL
- en: Gesture-controlled car
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have seen how we can extract the data from IMU. Now its time to put that
    data to work. In this chapter we will be controlling our robotic vehicle just
    with the tilt of our hand. So in essence it will be a gesture-controlled robotic
    vehicle. Now to do so, lets go ahead and connect the Raspberry Pi as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d83d3c7d-116d-459d-854e-7405ea002e87.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Make sure you attach a sufficiently long wire for the sensor, do not exceed
    1 meter at any point and use it as a remote control for your vehicle. Once connected
    upload the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As you would have seen the code is almost the same till the time we reach the
    `while True` loop. Thereafter we have done a small trick. So let's see what it
    is.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: When the accelerometer is in the middle or in the flat lying position the value
    would be close to `32768`, which would be the central reading. Hence to find out
    what percentage we have tilted front or back we are using this line. To do that
    we are dividing it by `327`. What it does is, it gives a reading in between `0` -
    `100`. For example, if raw reading is `gryo_x` = `21000`, `gyro_x/327` = `64.22`.
    Now `64.22` would be reading of tilt in the percentage value.  This is important
    step for us as, this reading will help us determine the `DutyCycle` that we have
    to provide to the motors drivers.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This step is very simple, what we have done is simply taken a threshold for
    the readings beyond which the PWM would be provided to the motors. The `DutyCycle`
    for the PWM being provided to the motors would be directly proportional to the
    angle of tilt.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Just like we did before, in case the tilt is in another direction, then the
    motor drivers pins corresponding to the rear direction would be made high making
    it go backwards. The speed as before would be proportional to the tilt.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In this line, we are making the robotic vehicle turn in one direction. As before,
    due to the percentage value of tilt the `DutyCycle` will change and hence change
    the rate of turn. As you can see the robot's wheels will turn opposite to each
    other, hence the turn will be made while being on its axis.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes while using various libraries, the raw outputs can vary. To make sure
    your code works fine, firstly see the raw readings which you are getting. Once
    you get the readings write on a piece of paper what are the flat-line reading
    and maximum and minimum readings. These readings can change based on the made
    of the sensors as well. (There are a lot of counterfeits that does not give the
    same readings.) Once you see the entire span of the reading then you can make
    the desirable adjustment to the algorithms and make it work.
  prefs: []
  type: TYPE_NORMAL
- en: Go ahead, see how you can control it just by your hand gestures.
  prefs: []
  type: TYPE_NORMAL
- en: Making it more advanced
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter we have seen that we are making the car turn in any
    of the directions just based on our hand movements, however there is a problem
    with the previous code. Firstly the car is moving in one direction at a time,
    that is it's going either forward or backward or turning left or right.
  prefs: []
  type: TYPE_NORMAL
- en: 'It was not able to make a banking turn based on the hand gestures itself. To
    make it capable of doing so, we need to make the code even smarter. The overall
    connections to the robot would be exactly the same. But the code would be slightly
    different, so let''s see what it is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s see all the changes we have done to the code. The entire sensing
    mechanism is the same, however, data processing has a major overhaul. So let''s
    see what it is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now here we are comparing the value of `Ax`. If the value of `Ax > 20` then
    the code below it would run. We have done this because, the accelerometer is extremely
    sensitive and can sense slightest vibration. Due to this there can be erroneous
    output. So to filter it we have a threshold value of `20`. That is till the time
    the accelerometer is 20% tilted, this code will not come into effect. Similarly
    we are doing this for the y axis as well. Once that is done that percentage value
    is given to the line `dc1 = Ax - Ay`. What this is doing is taking the tilt in
    x axis which is the forward axis and subtracting it with movement of *Y*. In the
    second line we are doing the same thing with the other side of the motors however
    rather than subtracting the value of *Y* we are adding it. Hence what it would
    do is to create a difference of speed in between the speed of motors on the opposite
    ends. This speed difference would be directly proposal to the angular tilt of
    the *Y* axis. Hence more the tilt, the more would be the change in the speed and
    more would be the angle of the turn.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In the next line what we have done is that we have made a condition for the
    tilt on the other side of the accelerometer by sensing `Ay < -20`. If the value
    is smaller than `-20` then the following algorithm would come into play.
  prefs: []
  type: TYPE_NORMAL
- en: Here the lines are exactly the same. However the mathematical operators have
    been inverted. Hence  for the first motor, instead of subtracting the value of
    *Y* now we are adding it. On the other hand for the second motor rather than adding
    the value we are subtracting it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Finally, if the value of `Ax` is greater than `20` but the value of `Ay` is
    between `-20` and `+20` then we will assume that the car has to go straight. Hence
    the value of the `Ax` is directly getting passed on to both the motors, making
    it go entirely straight.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have understood on how accelerometer and gyros functions.
    We have taken the raw data of the gyro and accelerometer and utilized it to make
    a gesture-controlled robot. Finally, onto the next and final chapter of the book,
    where we will continue our journey with the most exciting chapter you were looking
    forward to.
  prefs: []
  type: TYPE_NORMAL
