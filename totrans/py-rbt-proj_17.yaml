- en: Gesture-Controlled Robotic Vehicle
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 手势控制机器人车辆
- en: In the previous few chapters, you have learned a lot about sensors—what they
    do and how they work. The number of sensors on this planet is simply out of bonds.
    It's ever increasing, and while you are reading this book, there could be some
    new sensor being launched by some country across the world. This might make you
    wonder, do you have to learn about all of these sensors coming out on the market
    every single day?
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的几章中，你已经学到了很多关于传感器的内容——它们的作用以及它们是如何工作的。这个星球上的传感器数量简直无法计数。它一直在增加，当你阅读这本书的时候，可能某个国家正在推出一些新的传感器。这可能会让你想，你是否需要每天学习市场上出现的所有这些传感器？
- en: Thankfully, as you have learned, these sensors are more or less similar and
    work on a limited set of protocols. This makes working with new sensors easy.
    You might think that we have covered most of our basic sensors. However, that
    wouldn't be true—as we are yet to learn one of the most important sensors when
    it comes to the balancing of robots. These are accelerometers and gyroscope. These
    two sensors are not only present in all of these robots that have anything to
    do with balancing, but they have also found their way into our mobile devices.
    So, now let's learn about the basics of these sensors.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，正如你所学的，这些传感器在某种程度上是相似的，并且基于有限的协议集。这使得与新的传感器合作变得容易。你可能认为我们已经涵盖了大部分的基本传感器。然而，这并不准确——因为我们还没有学习到与机器人平衡最重要的传感器。这些是加速度计和陀螺仪。这两个传感器不仅存在于所有与平衡有关的机器人中，而且它们也进入了我们的移动设备。所以，现在让我们来了解这些传感器的基本知识。
- en: Accelerometers and gyroscope
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加速度计和陀螺仪
- en: Let's first start with accelerometers. As the name suggests, these are meant
    to measure acceleration in any body. Hence, whenever there is any acceleration
    in any body, then the accelerometers have the work to sense that acceleration
    and give the corresponding reading.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先从加速度计开始。正如其名所示，这些设备是用来测量任何物体上的加速度的。因此，每当任何物体上有加速度时，加速度计就有工作来感知这种加速度并提供相应的读数。
- en: A gyroscope is a device that uses Earth's gravity to help determine orientation
    of the robot. An accelerometer is a device designed to measure non-gravitational acceleration.
    Whenever there is any acceleration, the crystals in the accelerometer excite and
    provide a voltage corresponding to it.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 陀螺仪是一种利用地球重力帮助确定机器人方向的设备。加速度计是一种设计用来测量非重力加速度的设备。每当有加速度时，加速度计中的晶体就会激发并提供与加速度相对应的电压。
- en: 'The main difference between these devices is simple: the gyroscope can sense
    rotation, whereas the accelerometer cannot. In a way, the accelerometer can gauge
    the orientation of a stationary item with relation to Earth''s surface. When accelerating
    in a particular direction, the accelerometer is unable to distinguish between
    that and the acceleration provided through Earth''s gravitational pull. The gyroscope
    measures the rate of rotation around a particular axis. In comparison, the accelerometer
    measures linear acceleration.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这些设备之间的主要区别很简单：陀螺仪可以感知旋转，而加速度计则不能。从某种意义上说，加速度计可以测量静止物体相对于地球表面的方向。当向特定方向加速时，加速度计无法区分这是由于地球的重力提供的加速度还是由于加速本身。
- en: Here in this chapter, we will be using a sensor called MPU 6050, which is one
    of the most common sensors that has both the accelerometers and gyroscope built
    into one single package.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用一个名为MPU 6050的传感器，这是具有加速度计和陀螺仪的常见传感器之一，它们集成在一个单一包中。
- en: '![](img/ca5ef65f-b25b-4056-a746-1ed045b8f809.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ca5ef65f-b25b-4056-a746-1ed045b8f809.jpg)'
- en: Preceding is a photograph of it. As you can see, it has **SCL** and **SDA**
    lines. Hence, you can be sure that this sensor works on I2C protocol. This is
    cool because we have already had a good experience working with I2C type sensors.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 上图是它的照片。正如你所见，它有**SCL**和**SDA**线。因此，你可以确信这个传感器是基于I2C协议工作的。这很酷，因为我们已经与I2C类型的传感器有了良好的合作经验。
- en: Interfacing the inertial measurement unit
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接口惯性测量单元
- en: MPU 6050 is a three-axis accelerometer and three-axis gyroscope. It works on
    I2C, but the interesting thing about this sensor is that it has a different address
    for different sensors. What did you just say? Different address for different
    sensors. Isn't it one single sensor?
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: MPU 6050是一个三轴加速度计和三轴陀螺仪。它基于I2C协议工作，但这个传感器有趣的地方在于它为不同的传感器有不同的地址。你刚才说什么？不同传感器的不同地址。难道这不是一个单一的传感器吗？
- en: 'Well, yes it is, but if you see the internal construction of the sensor, then
    you would find that for every different axis, the data is being stored in different
    registers from where we can acquire the data at our disposal. Hence, if you require
    just the reading of x axis of accelerometer, then you can do so efficiently rather
    than getting a whole long string of different values. Now connecting this sensor
    is super easy. All you have to do is to power it up using Raspberry Pi and simply
    connect the I2C pins over, as shown in the following diagram:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，是的，但是如果你看到传感器的内部结构，你会发现对于每个不同的轴，数据都存储在不同的寄存器中，我们可以从那里获取所需的数据。因此，如果你只需要读取加速度计的x轴，你可以这样做，而不是获取一长串不同的值。现在连接这个传感器非常简单。你所要做的就是使用Raspberry
    Pi给它供电，并简单地连接I2C引脚，如图所示：
- en: '![](img/1568df83-88d0-4155-af55-7066bd7a6eb2.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1568df83-88d0-4155-af55-7066bd7a6eb2.png)'
- en: 'Once the wiring is done, go ahead and upload the following code. Once you do
    so, run and see what you get:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成接线，继续上传以下代码。一旦这样做，运行并查看你得到的结果：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now it''s time to see what we have done:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候看看我们做了什么：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In this lines, we are defining a function called `MPU_Init()`. This will be
    used to initialize the **inertial measurement unit** (**IMU**) sensor. In this
    function, we are using a method called `write_byte_data()` from the library `bus`.
    What it does is that it writes the data to a specific register declared in the
    argument. The data written using this function would be of a byte in size. Now
    we are declaring `Device_Address`. That is, the data written would be on the connected
    device''s address. The second argument `SMPLRT_DIV` will tell the address of the
    register in hexadecimal. Hence, the value of `SMPLRT_DIV` would be used as the
    address. The last argument is the data that needs to be written, which in our
    case is `7`. Similarly, the following would be the values passed to the device:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些行中，我们定义了一个名为`MPU_Init()`的函数。这个函数将被用来初始化**惯性测量单元**（**IMU**）传感器。在这个函数中，我们使用来自`bus`库的`write_byte_data()`方法。它的作用是将数据写入在参数中声明的特定寄存器。使用此函数写入的数据大小为字节。现在我们声明了`Device_Address`。也就是说，写入的数据将位于连接的设备地址上。第二个参数`SMPLRT_DIV`将告诉寄存器的地址是十六进制的。因此，`SMPLRT_DIV`的值将用作地址。最后一个参数是需要写入的数据，在我们的例子中是`7`。同样，以下是将传递给设备的值：
- en: '`PWR_MGMT_1`: `1`'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PWR_MGMT_1`: `1`'
- en: '`CONFIG`: `0`'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CONFIG`: `0`'
- en: '`GYRO_CONFIG`: `24`'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GYRO_CONFIG`: `24`'
- en: '`INT_ENABLE`: `1`'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`INT_ENABLE`: `1`'
- en: 'These values would be required to set up the sensor. What these values are
    doing is not of an importance to us at this point. However, if you wish to know,
    then you can use the data sheet of the IMU MPU 6050 and get what all these registers
    are doing in detail:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这些值是设置传感器所必需的。这些值的作用对我们目前来说并不重要。然而，如果你想知道的话，你可以使用IMU MPU 6050的数据表，以详细了解所有这些寄存器都在做什么：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, we are defining a function called `read_raw_data(addr)` reading the address
    from the device and then register where we are reading the address from is `addr` for
    the `high` variable and `addr+1` for the `low` variable.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个名为`read_raw_data(addr)`的函数，它从设备读取地址，然后我们读取地址的寄存器是`addr`用于`high`变量，`addr+1`用于`low`变量。
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Once the data has been acquired then it is being processed by the following
    statement `value = ((high << 8) | low)` what this does is that shifts the value
    of the high variable hence if the data of the variable high in binary is `10111011`,
    `(high <<8)` would transform this value to `1011101100000000`. Once that is done
    the and operator would add the eight digit value to the newly calculated value
    of high. Making the output a 16 bit integer. Now you must be thinking why did
    we do this?
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦获取了数据，它就会通过以下语句`value = ((high << 8) | low)`进行处理，这个操作是将`high`变量的值左移，因此如果`high`变量的二进制数据是`10111011`，`(high
    << 8)`会将这个值转换为`1011101100000000`。完成这个操作后，与操作符会将八个数字的值添加到新计算出的`high`变量的值上。使得输出成为一个16位整数。现在你可能想知道我们为什么要这样做？
- en: 'The value which is being given by the MPU 6050 for any reading is 16 bit. However
    the registers of MPU 6050 are 8 bit in size. Now what MPU 6050 does is that it
    stores the value of any sensor in the registers based on the position of the bits.
    That is the most significant 8 bits would be stored in the first address and the
    rest of the least significant 8 bits would be stored in the next address that
    is `addr+1`:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: MPU 6050为任何读数提供的值是16位的。然而，MPU 6050的寄存器大小是8位的。现在MPU 6050所做的是根据位的位置将任何传感器的值存储在寄存器中。也就是说，最重要的8位将存储在第一个地址，其余的最不重要的8位将存储在下一个地址，即`addr+1`：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As we understood in the last line, the output data from the sensor would be
    in a 16 bit format. When the sensor would be in the normal position this reading
    would be lying somewhere in the middle. If the value is more than the middle reading
    we would subtract the value by `65535`, hence providing us a negative value for
    every value which is over the middle reading. This would give us a sense of direction
    without doing much brain work. If the values are positive the tilt is in one direction
    and if negative then in other direction.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一行所理解的，传感器的输出数据将以16位格式。当传感器处于正常位置时，这个读数将位于中间某个位置。如果值超过中间读数，我们将通过`65535`减去该值，因此为每个超过中间读数的值提供一个负值。这将给我们一个方向感，而不需要做太多的脑力劳动。如果值是正的，倾斜方向是向一个方向，如果是负的，则是向另一个方向。
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now that we have defined the function called `read_raw_data()` we can start
    reading the data from different sensors. These sensors would be saving the data
    onto different addresses. These lists of addresses we have mentioned earlier.
    Hence by passing that data to the function we can get to know the reading of every
    single sensor. All these readings are being calculated and the data is stored
    in a variable.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了名为`read_raw_data()`的函数，我们可以开始从不同的传感器读取数据。这些传感器会将数据保存到不同的地址。我们之前提到的就是这些地址。因此，通过将这些数据传递给函数，我们可以了解每个传感器的读数。所有这些读数都在被计算，并且数据被存储在一个变量中。
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this line we are simply printing the values of each of the variables corresponding
    to each of the sensors.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一行，我们只是简单地打印出每个传感器对应的每个变量的值。
- en: Now once you run this code you will see the values of each of the sensors coming
    out and this will change as you change the orientation or acceleration. Explore
    the reading and how they are changing in respect to movement. I'm sure it would
    give you a plentiful idea about the sensor. So go ahead and enjoy!
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你运行这段代码，你会看到每个传感器的值都会显示出来，并且当你改变方向或加速度时，这些值会发生变化。探索这些读数以及它们如何随着运动而变化。我相信这会给你关于传感器的很多想法。所以，继续前进，享受吧！
- en: Gesture-controlled car
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 手势控制汽车
- en: 'We have seen how we can extract the data from IMU. Now its time to put that
    data to work. In this chapter we will be controlling our robotic vehicle just
    with the tilt of our hand. So in essence it will be a gesture-controlled robotic
    vehicle. Now to do so, lets go ahead and connect the Raspberry Pi as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何从IMU中提取数据。现在是时候将数据投入使用。在本章中，我们将通过手的倾斜来控制我们的机器人车辆。所以本质上，它将是一个手势控制的机器人车辆。现在为了做到这一点，让我们继续并按照以下方式连接Raspberry
    Pi：
- en: '![](img/d83d3c7d-116d-459d-854e-7405ea002e87.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d83d3c7d-116d-459d-854e-7405ea002e87.png)'
- en: 'Make sure you attach a sufficiently long wire for the sensor, do not exceed
    1 meter at any point and use it as a remote control for your vehicle. Once connected
    upload the following code:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 确保为传感器连接足够长的线，在任何地方都不要超过1米，并将其用作你车辆的遥控器。一旦连接，上传以下代码：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As you would have seen the code is almost the same till the time we reach the
    `while True` loop. Thereafter we have done a small trick. So let's see what it
    is.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，代码在到达`while True`循环之前几乎是一样的。之后我们做了一点小技巧。那么让我们看看它是什么。
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: When the accelerometer is in the middle or in the flat lying position the value
    would be close to `32768`, which would be the central reading. Hence to find out
    what percentage we have tilted front or back we are using this line. To do that
    we are dividing it by `327`. What it does is, it gives a reading in between `0` -
    `100`. For example, if raw reading is `gryo_x` = `21000`, `gyro_x/327` = `64.22`.
    Now `64.22` would be reading of tilt in the percentage value.  This is important
    step for us as, this reading will help us determine the `DutyCycle` that we have
    to provide to the motors drivers.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当加速度计处于中间或水平放置的位置时，其值将接近`32768`，这将是一个中心读取值。因此，为了找出我们向前或向后倾斜了多少百分比，我们使用这一行。为了做到这一点，我们将其除以`327`。它所做的就是，在`0`至`100`之间给出一个读取值。例如，如果原始读取值是`gryo_x`
    = `21000`，则`gyro_x/327` = `64.22`。现在`64.22`将是倾斜的百分比读取值。这对于我们来说是一个重要的步骤，因为这个读取值将帮助我们确定必须提供给电机驱动器的`DutyCycle`。
- en: '[PRE9]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This step is very simple, what we have done is simply taken a threshold for
    the readings beyond which the PWM would be provided to the motors. The `DutyCycle`
    for the PWM being provided to the motors would be directly proportional to the
    angle of tilt.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这一步非常简单，我们所做的是为读取值设置一个阈值，超过这个阈值就会向电机提供PWM信号。提供给电机的PWM的`DutyCycle`将与倾斜角度成正比。
- en: '[PRE10]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Just like we did before, in case the tilt is in another direction, then the
    motor drivers pins corresponding to the rear direction would be made high making
    it go backwards. The speed as before would be proportional to the tilt.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们之前做的那样，如果倾斜方向相反，那么对应后向方向的电机驱动引脚将被置为高电平，使其向后移动。速度与之前一样，将成正比于倾斜角度。
- en: '[PRE11]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this line, we are making the robotic vehicle turn in one direction. As before,
    due to the percentage value of tilt the `DutyCycle` will change and hence change
    the rate of turn. As you can see the robot's wheels will turn opposite to each
    other, hence the turn will be made while being on its axis.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一行，我们使机器人车辆向一个方向转弯。和之前一样，由于倾斜的百分比值，`DutyCycle`会改变，从而改变转弯速度。正如你所看到的，机器人的车轮会相对转动，因此转弯将在其轴上完成。
- en: Sometimes while using various libraries, the raw outputs can vary. To make sure
    your code works fine, firstly see the raw readings which you are getting. Once
    you get the readings write on a piece of paper what are the flat-line reading
    and maximum and minimum readings. These readings can change based on the made
    of the sensors as well. (There are a lot of counterfeits that does not give the
    same readings.) Once you see the entire span of the reading then you can make
    the desirable adjustment to the algorithms and make it work.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 有时在使用各种库时，原始输出可能会变化。为了确保你的代码运行良好，首先查看你得到的原始读取值。一旦你得到读取值，就在一张纸上写下这些值：平稳线读取值、最大读取值和最小读取值。这些读取值可能会根据传感器的材质而变化。（有许多假冒产品不会给出相同的读取值。）一旦你看到了整个读取范围，你就可以对算法进行所需的调整，使其工作。
- en: Go ahead, see how you can control it just by your hand gestures.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 试试看，看看你如何仅通过手势来控制它。
- en: Making it more advanced
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使其更加先进
- en: In the previous chapter we have seen that we are making the car turn in any
    of the directions just based on our hand movements, however there is a problem
    with the previous code. Firstly the car is moving in one direction at a time,
    that is it's going either forward or backward or turning left or right.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们看到了我们如何仅基于我们的手势使汽车向任何方向转弯，然而之前的代码存在一个问题。首先，汽车一次只能向一个方向移动，即它要么向前或向后移动，要么向左或向右转弯。
- en: 'It was not able to make a banking turn based on the hand gestures itself. To
    make it capable of doing so, we need to make the code even smarter. The overall
    connections to the robot would be exactly the same. But the code would be slightly
    different, so let''s see what it is:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 它本身无法根据手势进行转弯。为了使其能够这样做，我们需要使代码更加智能。与机器人的整体连接将完全相同。但是代码会有所不同，让我们看看具体是什么：
- en: '[PRE12]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now let''s see all the changes we have done to the code. The entire sensing
    mechanism is the same, however, data processing has a major overhaul. So let''s
    see what it is:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看我们对代码所做的所有更改。整个传感机制保持不变，但是数据处理进行了重大改进。那么，让我们看看具体是什么：
- en: '[PRE13]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now here we are comparing the value of `Ax`. If the value of `Ax > 20` then
    the code below it would run. We have done this because, the accelerometer is extremely
    sensitive and can sense slightest vibration. Due to this there can be erroneous
    output. So to filter it we have a threshold value of `20`. That is till the time
    the accelerometer is 20% tilted, this code will not come into effect. Similarly
    we are doing this for the y axis as well. Once that is done that percentage value
    is given to the line `dc1 = Ax - Ay`. What this is doing is taking the tilt in
    x axis which is the forward axis and subtracting it with movement of *Y*. In the
    second line we are doing the same thing with the other side of the motors however
    rather than subtracting the value of *Y* we are adding it. Hence what it would
    do is to create a difference of speed in between the speed of motors on the opposite
    ends. This speed difference would be directly proposal to the angular tilt of
    the *Y* axis. Hence more the tilt, the more would be the change in the speed and
    more would be the angle of the turn.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们正在比较`Ax`的值。如果`Ax > 20`，则下面的代码将运行。我们之所以这样做，是因为加速度计极其敏感，可以感知到最微小的振动。因此，可能会出现错误输出。所以为了过滤它，我们有一个`20`的阈值。也就是说，直到加速度计倾斜20%，这个代码都不会生效。同样，我们也在y轴上这样做。一旦完成，这个百分比值就给了`dc1
    = Ax - Ay`这一行。这个操作是在x轴的倾斜度上，也就是前进轴，减去*Y*的移动。在第二行，我们对电机的另一侧做同样的操作，然而，我们不是减去*Y*的值，而是加上它。因此，它将产生电机两端速度的差异。这个速度差异将直接与*Y*轴的角倾斜度相关。因此，倾斜度越大，速度变化越大，转弯角度也越大。
- en: '[PRE14]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the next line what we have done is that we have made a condition for the
    tilt on the other side of the accelerometer by sensing `Ay < -20`. If the value
    is smaller than `-20` then the following algorithm would come into play.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一行，我们为加速度计另一侧的倾斜度设置了一个条件，通过检测`Ay < -20`。如果值小于`-20`，则以下算法将生效。
- en: Here the lines are exactly the same. However the mathematical operators have
    been inverted. Hence  for the first motor, instead of subtracting the value of
    *Y* now we are adding it. On the other hand for the second motor rather than adding
    the value we are subtracting it.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，这些行完全相同。然而，数学运算符已经被反转。因此，对于第一个电机，我们不再减去*Y*的值，而是现在加上它。另一方面，对于第二个电机，我们不是加值，而是减去它。
- en: '[PRE15]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Finally, if the value of `Ax` is greater than `20` but the value of `Ay` is
    between `-20` and `+20` then we will assume that the car has to go straight. Hence
    the value of the `Ax` is directly getting passed on to both the motors, making
    it go entirely straight.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果`Ax`的值大于`20`，但`Ay`的值在`-20`到`+20`之间，那么我们将假设汽车需要直行。因此，`Ax`的值将直接传递给两个电机，使其完全直行。
- en: Summary
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have understood on how accelerometer and gyros functions.
    We have taken the raw data of the gyro and accelerometer and utilized it to make
    a gesture-controlled robot. Finally, onto the next and final chapter of the book,
    where we will continue our journey with the most exciting chapter you were looking
    forward to.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经了解了加速度计和陀螺仪的工作原理。我们使用了陀螺仪和加速度计的原始数据，并将其用于制作一个手势控制机器人。最后，进入书的下一章和最后一章，我们将继续我们的旅程，这一章是你最期待的精彩章节。
