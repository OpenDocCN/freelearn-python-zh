- en: '11'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Object Modifiers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A major part of creating 3D content consists of editing geometries by adding
    and removing the vertices, edges, and faces of a model, or displacing the existing
    ones.
  prefs: []
  type: TYPE_NORMAL
- en: '**Object modifiers** can perform these actions via non-destructive edits that
    affect the appearance of an object but not its internal data. They can be used
    for generative modeling, and without them, animation would be impossible, because
    deforming an object would require changing the geometric data at every frame.'
  prefs: []
  type: TYPE_NORMAL
- en: Object modifiers are like the F-Modifiers treated in [*Chapter 8*](B18375_08.xhtml#_idTextAnchor206),
    but they present a greater variety in purpose and attributes.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding and using object modifiers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Script deformation modifiers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating armatures and meshes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will use Blender and Visual Studio Code in this chapter. The examples created
    in this chapter can be found at the following URL: [https://github.com/PacktPublishing/Python-Scripting-in-Blender/tree/main/ch11](https://github.com/PacktPublishing/Python-Scripting-in-Blender/tree/main/ch11).'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding object modifiers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Object modifiers change the displayed status of an object without altering its
    geometric data. We met something similar in [*Chapter 8*](B18375_08.xhtml#_idTextAnchor206),
    when we applied effects to animation F-Curves without changing their keyframes.
  prefs: []
  type: TYPE_NORMAL
- en: Like F-Modifiers, they can be stacked on each other and accessed in Python as
    a collection property.
  prefs: []
  type: TYPE_NORMAL
- en: Modifiers can be added manually, but their creation and setup can be scripted
    as well. Before we delve into the API, let’s take a look at how to create them
    in the **Modifiers** properties.
  prefs: []
  type: TYPE_NORMAL
- en: Adding modifiers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Object modifiers are created in the **Modifiers** tab of **Properties** using
    the **Add Modifier** drop-down button. The tab is marked with the icon of a wrench.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.1: Adding modifiers in Blender](img/Figure_11.01_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.1: Adding modifiers in Blender'
  prefs: []
  type: TYPE_NORMAL
- en: 'Clicking **Add Modifier** displays the available options. They change according
    to the object type: curves don’t have as many modifiers as meshes, while nongeometric
    types such as empty or cameras can’t have any modifiers at all.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Though their number has grown with time, all modifiers are grouped into four
    categories:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Modify** – Affects data that won’t be displayed directly, such as vertex
    groups'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Generate** – Adds or removes geometry to or from an object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deform** – Changes the shape of an object without adding or removing vertices,
    edges, or faces'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Physics** – Brings the result of physics simulations to the object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 11.2: Clicking Add Modifier displays the available types](img/Figure_11.02_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.2: Clicking Add Modifier displays the available types'
  prefs: []
  type: TYPE_NORMAL
- en: The interface displays one column per category, with several modifier types
    for each of the four. Even modifier types from the same category differ a lot
    from each other and present different sets of attributes.
  prefs: []
  type: TYPE_NORMAL
- en: To better understand how modifiers work, we can create one in the interface
    and see how that affects an object’s geometry. For example, adding a **Subdivision
    Surface** modifier to an object makes it smoother by creating additional polygons.
  prefs: []
  type: TYPE_NORMAL
- en: Subdividing an object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Mesh objects are polygonal; that is, they consist of flat faces and sharp edges.
    That works well for simple solids like a cube, but not for smooth surfaces such
    as a sphere, or most real-life objects.
  prefs: []
  type: TYPE_NORMAL
- en: To give an illusion of smoothness, we subdivide the polygons of a mesh until
    they approximate a continuous surface.
  prefs: []
  type: TYPE_NORMAL
- en: The downside is that geometries that are too dense are problematic; they require
    more disk space and are not easy to model or edit. For that reason, rather than
    storing additional mesh data, we generate smooth geometry using the **Subdivision**
    **Surface** modifier.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.3: The blocky model on the left is smoothed using Subdivision Surface](img/Figure_11.03_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.3: The blocky model on the left is smoothed using Subdivision Surface'
  prefs: []
  type: TYPE_NORMAL
- en: This modifier splits every edge into two, generating new polygons from those
    divisions. By default, an algorithm named **Catmull-Clark** smoothens the result
    while preserving the overall shape.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can add a subdivision to a model with the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open Blender or go back to the default scene via **File | New |** **General**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the default **Cube** shape and make it active.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Modifiers** tab, click **Add Modifier** and select **Subdivision Surface**
    at the bottom of the **Generate** column.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A new entry appears in the **Modifiers** properties. We can see the parameters
    of the **Subdivision** modifier.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.4: Subdivision Surface properties](img/Figure_11.04_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.4: Subdivision Surface properties'
  prefs: []
  type: TYPE_NORMAL
- en: Increasing the number in `3` makes our **Cube** look much like a ball.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Clicking the **Simple** button disables the smoothing: the object is still
    subdivided, but its shape doesn’t change.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Even if enabling **Simple** doesn’t alter its shape, our object is still subdivided.
    That can be useful to other modifiers that can be added after **Subdivision**,
    as they will have more geometry to deform.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that our **Cube** has been subdivided, we will be able to alter its shape
    using a second modifier: **Cast**.'
  prefs: []
  type: TYPE_NORMAL
- en: Changing the object’s shape using Cast
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With our **Subdivision** modifier still in place, we can add a new modifier
    to alter the object’s shape:'
  prefs: []
  type: TYPE_NORMAL
- en: In the **Modifiers** tab, click **Add Modifier** and select **Cast** at the
    top of the **Deform** column. Another modifier shows up under **Subdivision**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the `Cylinder` and the `1.0`. Our geometry is now a cylinder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The two modifiers are displayed one on top of the other. Starting from the top,
    each modifier acts as the input of the next one. For this reason, the modifiers
    column is also called the **modifiers stack**.
  prefs: []
  type: TYPE_NORMAL
- en: Using modifiers, we have made our original object look like a cylinder, but
    that change can be reversed, or even animated. Moving the `0.0` and `1.0`, our
    object transitions from its original shape to the one set in **Cast**.
  prefs: []
  type: TYPE_NORMAL
- en: We can replicate the preceding steps in Python scripts using Blender’s API.
  prefs: []
  type: TYPE_NORMAL
- en: Adding modifiers in Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Python class of Blender objects contains a `modifiers` attribute. Like all
    collections, `modifiers` provides the `new` method, which creates and returns
    new items. By using `new`, we can automate the setup of modifiers using Python.
  prefs: []
  type: TYPE_NORMAL
- en: Finding collection-type items
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Object.modifiers.new` takes two arguments: `name` and `type`. The first will
    be displayed in the modifier properties in the interface, while `type` specifies
    which kind of modifier we want to create. The `type` argument must belong to the
    list of available types, or it will cause an error. Available types are listed
    in the API documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.blender.org/api/3.3/bpy_types_enum_items/object_modifier_type_items.xhtml](https://docs.blender.org/api/3.3/bpy_types_enum_items/object_modifier_type_items.xhtml)'
  prefs: []
  type: TYPE_NORMAL
- en: 'But we can also get them from Blender itself. These commands will list the
    modifier keywords in Blender’s Python console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'There’s another way to get a modifier keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: Use the **Add Modifier** button in the interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Look for the argument of the `modifier_add` operator in the **Info** log. It’s
    part of the **Scripting** workspace, as we know from [*Chapter 1*](B18375_01.xhtml#_idTextAnchor014).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.5: Blender info log after adding Subdivision Surface](img/Figure_11.05_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.5: Blender info log after adding Subdivision Surface'
  prefs: []
  type: TYPE_NORMAL
- en: For instance, the keyword for the `'SUBSURF'`.
  prefs: []
  type: TYPE_NORMAL
- en: Using modifiers.new
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since `modifiers.new` returns the created modifier, we can store the return
    value and replicate all the steps from the previous *Understanding object* *modifiers*
    section.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll see how to add a `bpy` and add a subdivision to increase the available
    geometry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `subdiv` variable contains the new `subdiv`’s attributes.
  prefs: []
  type: TYPE_NORMAL
- en: If we are looking for the Python counterpart of an attribute we can see in the
    interface, we can resort to **Python Tooltips** and **Developer Extra**, the two
    options in **Edit** > **Preferences** from the top-bar menu. We learned about
    them in the *Useful features for Python* section in [*Chapter 2*](B18375_02.xhtml#_idTextAnchor033).
  prefs: []
  type: TYPE_NORMAL
- en: If tooltips are enabled, hovering the mouse on the `levels`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.6: Subdivision attributes path displayed in tooltips](img/Figure_11.06_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.6: Subdivision attributes path displayed in tooltips'
  prefs: []
  type: TYPE_NORMAL
- en: 'To increase the object’s poly count without altering its shape, we set `subdiv.levels`
    to `3` and `subdivision_type` to `''SIMPLE''`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have enough polygons to deform our object. We add a `''CAST''` modifier
    and reshape it to a cylinder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '**Subdivision Surface** and **Cast** are self-sufficient, as they don’t require
    other objects besides the one they are affecting. Other modifiers rely on data
    from ancillary objects.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will set up a modifier that depends on a deformer object.
  prefs: []
  type: TYPE_NORMAL
- en: Deformation objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Many deformers translate a change from one object to another. That allows us
    to deform a complex object by manipulating a simpler one. Here are a few notable
    examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Curve** – Deforms a mesh along a curve object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lattice** – Transfers the changes from a regular grid to a mesh'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Armature** – Transfers the pose of an articulated structure to a mesh'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Surface Deform** – Transfers the deformation from one mesh to another'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The object used by a modifier can be set using the `modifier.object` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: The **Armature** modifier reproduces the limb movements using a structure of
    **bones**, so it requires a special type of object that can be posed.
  prefs: []
  type: TYPE_NORMAL
- en: A **Lattice** modifier, on the other hand, relies on the internal coordinates
    of a grid, which are specific to **Lattice** object types.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, we will see how to add lattice deformation to an object.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Lattice modifier
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To use lattice deformation, we need geometry to deform and an object of type
    lattice. We can use Blender’s mascot, the monkey **Suzanne**:'
  prefs: []
  type: TYPE_NORMAL
- en: Open Blender or go back to the default scene via **File** | **New** | **General**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete the default **Cube** shape by pressing **Canc** or **X** | **Delete**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a monkey head to the scene using **Add** | **Mesh** | **Monkey**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a lattice to the scene by using **Add** | **Lattice**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A lattice was added to the scene. By default, it is smaller than Suzanne, so
    we need to scale it up:'
  prefs: []
  type: TYPE_NORMAL
- en: With the lattice still selected, press `S` to scale. Drag the mouse or press
    `2` to double its size.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select Suzanne to add a modifier. In the **Modifiers** tab, Use **Add Modifier**
    | **Lattice**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Lattice** modifier, click the **Object** property and select the **Lattice**
    object from the options.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Editing the Lattice object changes Suzanne’s shape:'
  prefs: []
  type: TYPE_NORMAL
- en: Select **Lattice** in **3D Viewport**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press the *Tab* key to switch to **Edit Mode**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select one or more lattice vertices.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Press *G* and drag the mouse to move the selection: a lattice deformation is
    applied to Suzanne.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.7: Mesh deformed by a lattice cage](img/Figure_11.07_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.7: Mesh deformed by a lattice cage'
  prefs: []
  type: TYPE_NORMAL
- en: Automating these steps with Python can make the process much easier. In the
    next section, we will write an operator that sets up a lattice deformation in
    one click.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the Latte Express add-on
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Latte Express** add-on creates a new lattice around the active object
    and sets up the modifier.
  prefs: []
  type: TYPE_NORMAL
- en: It’s useful for creating basic rigs for cartoon deformation, or stylized objects.
    The add-on consists of an operator class and a menu entry.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the environment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We create a Python script for our add-on:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `PythonScriptingBlender/ch11/addons` folder. We can use the file manager
    or the file tab of our programmer editor, for example, **VS Code**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new file in that folder and name it `lattice_express.py`. We can do
    that using the file manager or the **New File** button in an IDE.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the file in your editor of choice.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the `PythonScriptingBlender/ch11` in the Blender **File Paths** preferences
    and restart Blender.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we can write the add-on and load it in Blender.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the Latte Express information
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Like other add-ons, Latte Express starts with a blank line, followed by the
    `bl_info` dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Then we proceed with the add-on classes and interface, in this case, a simple
    operator.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the Latte Express operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We need to import the `bpy` module, so that we can create a new operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The operator requires an active object, so the condition in `poll` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Creating a lattice object requires lattice data first, so inside `execute`,
    we call `bpy.data.lattices.new` and use its return value in `bpy.data.objects.new`.
    We name the new object and data after the active object, even if that’s not required.
    Finally, we add the lattice to the scene by linking it to the current collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s scale the lattice so that it fits our object. We can get its size from
    the `dimensions` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We match the lattice position with the center of the active geometry. We can
    get the object location from the world matrix as we learned in [*Chapter 4*](B18375_04.xhtml#_idTextAnchor075):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: That alone would not work on objects that have their transform pivot away from
    their geometry center, so we must find the actual midpoint of our object.
  prefs: []
  type: TYPE_NORMAL
- en: Finding the center of a model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To create a lattice that matches the location and size of an object, we must
    find the median point of its vertices, but we don’t have to look at all the components.
    We can find the center of the object’s **bounding box**.
  prefs: []
  type: TYPE_NORMAL
- en: A bounding box is an imaginary parallelepiped that contains all the object geometry.
    We can display it by activating **Bound** in the **Object** properties.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.8: An object’s bounding box with coordinate indices added on top](img/Figure_11.8_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.8: An object’s bounding box with coordinate indices added on top'
  prefs: []
  type: TYPE_NORMAL
- en: The bounding box is found in Python via the `bound_box` attribute. It’s a list
    of eight coordinates, and we can find the center by interpolating two opposite
    corners.
  prefs: []
  type: TYPE_NORMAL
- en: The center of a box is found in the middle of its diagonals, so we want to mediate
    between the lower-left-back corner and the top-right-forward corner. We know the
    indices of those points from *Figure 11**.8*. They are `0` and `6`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: A better way to find those two corners is by using the `min` and `max` functions.
  prefs: []
  type: TYPE_NORMAL
- en: One of the two extremes has the lowest `x`, `y`, `z` values, and the other one
    has the highest. In other words, the components of the lower corner have the lowest
    sum, and those of the higher corner have the highest.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Python, `min` and `max` return the lower and higher value in a list, but
    we can supply a different criterion, in this case, `sum`, using the `key` argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'To find the midpoint between two vectors, we can use the linear interpolation
    method (`lerp`) from the `Vector` class. In the `import` section, we need to add
    this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in `execute`, we interpolate the two coordinates. The first argument
    of `lerp` can be any triplet, so we convert only one of the two corners to the
    `Vector` type. Since we are looking for the point sitting halfway between the
    two corners, we provide a factor of `0.5` as the second argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We add `ob_center` to `ob_translation` to center the lattice to the geometry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Our lattice, centered and scaled, can now be used to deform the object. We
    can use it inside a new modifier and return `{''FINISHED''}` to exit the operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Now that the operator is finished, we can add a menu entry for using it.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a Create Lattice menu item
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We define a function to add `LatteExpress` to a menu. Using the `MOD_LATTICE`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, we need to register the new Blender class and function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We can refresh the add-on preferences and enable **Latte Express**.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Latte Express add-on
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once we have set the `ch11` folder, we will be able to activate **Latte Express**
    in the **Add-ons** preferences.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.9: Enabling the Latte Express add-on](img/Figure_11.09_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.9: Enabling the Latte Express add-on'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our add-on makes the task of setting up a lattice deformation easier. Let’s
    see how the workflow from the previous section, *Deformation objects*, has improved:'
  prefs: []
  type: TYPE_NORMAL
- en: Open Blender or go back to the default scene via **File** | **New** | **General**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete the default **Cube** shape by pressing **Canc** or **X** | **Delete**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a monkey head to the scene using **Add** | **Mesh** | **Monkey**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the mouse right-click to open the object menu in the **3D Viewport**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Create Lattice on** **Active Object**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A lattice is created, centered, and scaled on the active object, while a modifier
    is set up. Besides automating the task, using this add-on gives better accuracy,
    as the lattice is scaled according to the object’s exact dimensions.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will add more control over the geometry and lattice
    subdivision.
  prefs: []
  type: TYPE_NORMAL
- en: Improving Latte Express options
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some objects might not have enough polygons for the lattice deformation to work
    properly. We encountered a similar condition at the beginning of this chapter,
    in the *Understanding object modifiers* section, where we applied a **Subdivision
    Surface** modifier to our **Cube** shape before we could reshape it into a cylinder
    using a **Cast** modifier.
  prefs: []
  type: TYPE_NORMAL
- en: The resolution of lattice objects can also be increased to get more control
    over the deformation.
  prefs: []
  type: TYPE_NORMAL
- en: For those reasons, we will add object subdivision and lattice resolution options
    to our operator.
  prefs: []
  type: TYPE_NORMAL
- en: Adding object subdivisions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We add a subdivide option to `BoolProperty`. Since we will also set a `SUBSURF`
    modifier, we add `IntProperty` for the subdivision levels.
  prefs: []
  type: TYPE_NORMAL
- en: 'We add `bl_options = {''REGISTER'', ''UNDO''}` to display the operator panel.
    The declaration of **LatteExpress** becomes as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The `execute` method takes these options into account, creating a `SUBSURF`
    modifier if `add_subsurf` is `True`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '**Subdivision Surface** has an additional attribute for rendering subdivision
    levels. We have set both to the same value to make sure that the Viewport and
    the rendered images look the same.'
  prefs: []
  type: TYPE_NORMAL
- en: Changing lattice resolution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Lattices don’t have polygons or subdivision modifiers, but they have resolution
    parameters to add more divisions along the three axes.
  prefs: []
  type: TYPE_NORMAL
- en: The `points_u`, `points_v`, and `points_w` attributes set the number of divisions
    across its *x*, *y*, and *z* axes.
  prefs: []
  type: TYPE_NORMAL
- en: 'We add a property to influence the grid resolution. We use `IntVectorProperty`
    for those three attributes and set its subtype to `''XYZ''` so that they are displayed
    like coordinates. The minimum value for resolution coordinates is `1`, while we
    use `3` as default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Because of the way the lattice is implemented, changing the resolution before
    creating the lattice object changes the starting dimensions of a lattice. To avoid
    that, we only set `points_u`, `points_v`, and `points_w` after `latt_obj` is created.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, the lattice section becomes as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Now that we are adding subdivisions, the lattice grid will present internal
    vertices, that is, control points that end up being inside the lattice. We don’t
    want that because we are using the lattice as an external cage.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we set `use_outside` of the lattice data to `True`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: After that, the `execute` method continues as before, linking `latt_obj` to
    `context.collection.objects`, setting its location and scale, and creating the
    object modifiers before it returns `{'FINISHED'}`.
  prefs: []
  type: TYPE_NORMAL
- en: If we save the script and use *F3* -> **Reload Scripts** and launch **Create
    Lattice on Active Object**, we’ll see the options for the lattice resolution.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.10: A 5x3x3 lattice created with Latte Express](img/Figure_11.10_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.10: A 5x3x3 lattice created with Latte Express'
  prefs: []
  type: TYPE_NORMAL
- en: Lattice grids add quick deformations without requiring additional data in the
    deformed object. Deformers such as **Armature**, the modifier used for articulated
    characters, require the assignment of **vertex groups** to work properly.
  prefs: []
  type: TYPE_NORMAL
- en: Using armature deformers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Armatures are deformation objects like lattices, but instead of using a grid,
    they rely on the translation, rotation, and scale of sub-objects called **bones**,
    in analogy with the human skeleton.
  prefs: []
  type: TYPE_NORMAL
- en: By default, bones are represented as octahedral sticks. Armatures can switch
    to **Pose Mode**, a special Blender mode in which bones can be animated individually
    using the techniques learned in [*Chapter 7*](B18375_07.xhtml#_idTextAnchor171).
  prefs: []
  type: TYPE_NORMAL
- en: The setup of an **Armature** modifier might take some extra steps but is similar
    to the one used for lattices.
  prefs: []
  type: TYPE_NORMAL
- en: Adding armature objects to the scene
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To acquire familiarity with the bones, we will create a simple armature for
    **Suzanne**’s geometry:'
  prefs: []
  type: TYPE_NORMAL
- en: Open Blender or go back to the default scene via **File** | **New** | **General**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete the default **Cube** shape by pressing **Canc** or **X** | **Delete**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a monkey head to the scene using **Add** | **Mesh** | **Monkey**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add an armature to the scene using **Add** | **Armature** | **Single Bone**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At this point, we should see the tip of an octahedral bone on top of **Suzanne**’s
    head. Since most of the bone is hidden inside the model, we can press the *Z*
    key and switch to the wireframe display.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.11: An armature bone inside a geometry, with a wireframe display](img/Figure_11.11_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.11: An armature bone inside a geometry, with a wireframe display'
  prefs: []
  type: TYPE_NORMAL
- en: We could set up an **Armature** modifier right away, but armatures usually have
    more than one bone. For instance, we can add bones to the ears.
  prefs: []
  type: TYPE_NORMAL
- en: Adding armature bones
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To have a better view while we create new bones, we can press the *1* key or
    use **View** | **Viewpoint** | **Front** from the top-bar menu, then we can press
    the *.* key, or **View** | **Frame Selected**, to center the view.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the armature as the active object, we switch to **Edit Mode** by pressing
    *Tab* or using the drop-down box on the top left. Then, always in front view,
    we can add bone to the ears using the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a new bone using the *Shift* + *A* combination or **Add** | **Single Bone**
    from the top-bar menu. The new bone is added on top of the existing one.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the bones to select one of them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press *R*, then type `50`, and press *Enter* to rotate the bone toward the right-hand
    side of the screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press *G*, then *X* to move it horizontally, and type `1`. Then, press *Enter*
    to move the bone toward Suzanne’s left ear.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press *G*, then *Z* to move the bone vertically and type `0.2`. Then, press
    *Enter* to move the bone slightly downward.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Blender has a naming convention for left and right bones. To add the `.L` suffix
    to the left ear bone, we select **Armature** | **Names** | **Auto-Name Left/Right**
    from the top-bar menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To create a bone for the other ear, we select **Armature** | **Symmetrize**
    from the top-bar menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The resulting armature should resemble a trident. The exact position of the
    bones is not important for the sake of this example.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.12: Ear bones for Blender’s Suzanne](img/Figure_11.12_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.12: Ear bones for Blender’s Suzanne'
  prefs: []
  type: TYPE_NORMAL
- en: With three bones in place, we can go back to **Object Mode** by pressing *Tab*
    and go back to the **Solid** view by pressing *Z*. Now, we can bind our geometry
    to the armature.
  prefs: []
  type: TYPE_NORMAL
- en: Binding objects to armatures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As mentioned earlier, **Armature** deformers require additional information:
    each vertex should be assigned to one or more bones with a process called **weight
    painting**. It’s a manual task for riggers, but we can use Blender automatic weights
    for a quick result:'
  prefs: []
  type: TYPE_NORMAL
- en: In **Object Mode**, select the Suzanne object in **3D Viewport**, then keep
    the *Shift* key pressed and select the armature too.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press *Ctrl* + *P* to open the **Set Parent** menu and pick **With Automatic
    Weights**. Or select **Object** | **Parent** | **With Automatic Weights** from
    the top-bar menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Beware the outliner
  prefs: []
  type: TYPE_NORMAL
- en: 'If you use **Outliner** for selecting objects, keep in mind that its policy
    is different:'
  prefs: []
  type: TYPE_NORMAL
- en: In **Viewport**, the last selected of multiple objects is the active object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In **Outliner**, the first selected of multiple objects is the active object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To parent an object to an armature, we either select the object and then the
    armature in **Viewport**, or first the armature and then the object in **Outliner**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can deform our mesh by posing the armature bones:'
  prefs: []
  type: TYPE_NORMAL
- en: Select **Armature** and press *Ctrl* + *Tab*, or use the drop-down box on the
    top left of the screen and switch to **Pose Mode**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select any bone, then move, rotate, or scale it by using the *G*, *R*, and *S*
    keys.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.13: Armature deformation in Blender](img/Figure_11.13_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.13: Armature deformation in Blender'
  prefs: []
  type: TYPE_NORMAL
- en: Bones are a soft, controllable way to deform a model. Lattice grids can be deformed
    with armatures too, so we can create and set up an armature in **Latte Express**.
  prefs: []
  type: TYPE_NORMAL
- en: Scripting a lattice armature
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Armatures are the recommended way for animating in Blender as they support linking
    across different `.blend` files and other advanced animation features.
  prefs: []
  type: TYPE_NORMAL
- en: Binding a lattice to an armature allows you to animate deformations without
    switching to **Edit Mode** to edit grid vertices.
  prefs: []
  type: TYPE_NORMAL
- en: Adding an armature condition
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We want armatures to be an optional feature, so we can add another property
    for that. We set its default value to `True`, so an armature is created unless
    it’s set otherwise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Inside the `execute` method, we check for this value and proceed accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Adding an armature to the scene
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Armatures are created in the same way as lattices and other objects:'
  prefs: []
  type: TYPE_NORMAL
- en: Create new data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new object using the data created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Even if it is not strictly required, we set the new armature as the parent of
    the lattice to ensure consistency between their transforms.
  prefs: []
  type: TYPE_NORMAL
- en: 'If `add_armature` is `False`, we set the lattice location right away. Otherwise,
    we create a new armature. The underlying code takes over soon after we’ve got
    the object median point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the armature is part of the scene, we can parent the lattice to it and
    move it to where the object is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'It’s common to have the armature’s transform pivot under the affected geometry,
    so when an armature is at its resting position, the deformed character will be
    above ground level. Therefore, we move the armature to half the object height
    below the center, using the third coordinate of `dimensions`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The lattice, on the other hand, should be centered on the geometry, so we bring
    it up by the same amount:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Now that the armature and lattice are placed, we need to create some bones.
  prefs: []
  type: TYPE_NORMAL
- en: Creating edit bones
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create the bones manually, we select the armature and switch to **Edit Mode**.
    In Python, the same steps are performed with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We pass `False` to the `toggle` argument of `mode_set`, because we are not switching
    back and forth between modes.
  prefs: []
  type: TYPE_NORMAL
- en: We will add as many bones as the lattice vertical sections. For instance, a
    lattice with a vertical resolution of `3` can be rigged with three bones.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.14: Rigging a lattice with armature bones](img/Figure_11.14_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.14: Rigging a lattice with armature bones'
  prefs: []
  type: TYPE_NORMAL
- en: We get the number of levels from the `grid_levels` property. Each bone starts
    from the lower section and stops at the next. The last bone pops outside the lattice.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get the optimal length, we divide the object height by the number of internal
    bones, i.e., one bone less than `grid_levels`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We use a `for` loop to add an `range` function. We add a two-digit suffix to
    each bone name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Each bone has a start point (`head`) and an endpoint (`tail`). Since the armature’s
    origin matches the first section of the lattice, the first bone has the coordinates
    `0,` `0, 0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second bone should have a higher position to make room for the previous
    bone length, and so on, so the expression for each bone head is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The `tail` part of the bone adds one `bone_length` to the `head[2]` coordinate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: To assign the lattice vertices to the bones, we must collect which vertices
    belong to the current level based on their `Z` coordinate.
  prefs: []
  type: TYPE_NORMAL
- en: Assigning vertices to bones
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For each lattice point, we compare the third coordinate (`co[2]`) with the relative
    height of the current section. *Relative* means that the first section is at a
    height of `0.0`, the last is at `1.0`, the one in the middle is at `0.5`, and
    so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python indices start from `0`, so the index of the last section is the number
    of sections minus `1`. Keeping that in mind, here’s how we can get the relative
    height of each level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Lattice points are relative to the center, and the size of one side of the
    lattice is `1.0`, so the vertical coordinate of the lowest point is `-0.5`. For
    that reason, we lower `rel_height` by `0.5` units:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'To assign vertices, we need a list of their indices, which we store in the
    `vert_ids` list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: In this list, we need to store the identifier number of the lattice points,
    not their coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: The lattice data points are an ordered collection, so their identifier is their
    ordinal index; that is, the first point is identified by index `1`, the second
    point has index `2`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Python, we can get the ordinal of the iterated items using `enumerate`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We can create a vertex group named after each bone and assign vertices using
    the `add` method. We also supply a weight of `1.0`, because we are not blending
    the assignment between two groups, and set `''REPLACE''` as a condition, because
    we are not adding nor subtracting from a previous assignment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Creating the bones and assigning their influence is the hard part of the process.
    Now we can create the modifiers.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Armature modifier
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We add a new Armature modifier to `latt_obj` via the `modifiers.new` method,
    and we use `arm_obj` as its deformer object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we leave `''POSE''`, so that the user can animate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: At this point, `LattExpress` creates a lattice deformer and animation bones
    in one click. As an optional step, we can create custom shapes for displaying
    the bones.
  prefs: []
  type: TYPE_NORMAL
- en: Adding custom bone shapes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Armature bones are effective deformers, but we have experienced a major drawback
    for ourselves in the *Using armature deformers* section: bones tend to be hidden
    by the deformed geometry.'
  prefs: []
  type: TYPE_NORMAL
- en: There are a few workarounds, such as activating the **In Front** attribute in
    the **Armature** properties and using **X-Ray** or **Wireframe** views.
  prefs: []
  type: TYPE_NORMAL
- en: Another gimmick consists in displaying special widgets by assigning mesh objects
    to the bone’s **Custom** **Shape** attribute.
  prefs: []
  type: TYPE_NORMAL
- en: Creating mesh objects in Python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, we must create a new mesh. A mesh consists of vertex coordinates, plus
    edges or faces that connect vertices.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.15: Vertex coordinates of a 2D square](img/Figure_11.15_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.15: Vertex coordinates of a 2D square'
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we create a wireframe square and use it as a bone widget. Blender
    bones expand upon their `Y` axis, so the horizontal coordinates of our bones that
    are placed vertically are `X` and `Z`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We build our list of vertices. We aim for a side length of `1.0`, a measure
    easy to scale. For that reason, each side will go from a `-0.5` to a `0.5` coordinate,
    or the other way around. If `X` and `Z` are the first and last coordinates, this
    is our vertex list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need a list of edges. An edge is a pair of vertex indices, each representing
    the two vertices that are going to connect. The four edges of a square connect
    vertex `0` to `1`, `1` to `2`, vertex `2` to `3`, and `3` to `0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'We can create new mesh data from Python lists using the `from_pydata` method.
    Since we don’t need faces in a control widget, the third argument is an empty
    list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'We add the mesh to the scene:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can assign the widget shape to the **pose bones** of our armature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: With a side length of `1.0`, our widget could be hidden as well, so we scale
    it to match the `dimensions` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Keeping in mind that a bone’s up direction is the `Y` axis, but Blender’s up
    direction is `Z`, we set the `Z` custom shape scale to the `Y` dimension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Blender scales the displayed custom shape by the length of the bone, so we
    divide the scale by the bone length:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The armature created in our script is ready. We will tidy the scene and exit
    the operator.
  prefs: []
  type: TYPE_NORMAL
- en: Storing bones is bad for your variables!
  prefs: []
  type: TYPE_NORMAL
- en: Armature bones are represented by different Python entities depending on the
    current mode. When the armature is in `EditBone` from the armature data `edit_bones`
    collection is used. When the armature is in `PoseBone` from the `pose.bones` object
    `is` used.
  prefs: []
  type: TYPE_NORMAL
- en: These collections are rebuilt every time the armature is updated, storing them
    in variables while they are changed can cause crashes.
  prefs: []
  type: TYPE_NORMAL
- en: Finalizing the setup
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If an armature is created, we hide the widget mesh and the lattice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The last steps of `execute` are the same as before: we create a lattice modifier
    for the deformed object, unselect the geometry, and finish:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Reloading the scripts and launching **Create Lattice on Active Object** will
    create a full animation setup complete with armature and bone shapes.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.16: Suzanne deformed via animation controls](img/Figure_11.16_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.16: Suzanne deformed via animation controls'
  prefs: []
  type: TYPE_NORMAL
- en: This add-on can still be improved. For instance, we could build oval shapes
    for our animation controls or tidy the `execute` method by moving some of the
    code to specific functions, but since it satisfies its initial purpose, we can
    consider it finished.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have learned how to alter objects using modifiers and how to bind modifiers
    to animate objects. We have also gained a deeper understanding of how object data
    works and how objects of different types are created, linked to the scene, and
    integrated.
  prefs: []
  type: TYPE_NORMAL
- en: Using this knowledge, we have coded a production tool that can be used to deform
    any object.
  prefs: []
  type: TYPE_NORMAL
- en: In the next and final chapter of this book, [*Chapter 12*](B18375_12.xhtml#_idTextAnchor304),
    we will explore the last step of a 3D pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Do modifiers alter the object’s data?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do we add modifiers to an object?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do modifiers rely on other objects besides the ones they deform?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True or false: We can change the resolution of lattice data before or after
    we create its lattice object with no consequences.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do we add bones to an armature in Python?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True or false: There is only one bone collection property.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True or false: Only objects of type mesh can be deformed by armatures.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Blender has modes. Does the current mode have consequences on whether we can
    add or remove data in our script?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do we create a mesh using Python?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
