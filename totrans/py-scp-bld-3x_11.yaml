- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Object Modifiers
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象修饰符
- en: A major part of creating 3D content consists of editing geometries by adding
    and removing the vertices, edges, and faces of a model, or displacing the existing
    ones.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 创建3D内容的主要部分包括通过添加和删除模型的顶点、边和面，或移动现有的面来编辑几何形状。
- en: '**Object modifiers** can perform these actions via non-destructive edits that
    affect the appearance of an object but not its internal data. They can be used
    for generative modeling, and without them, animation would be impossible, because
    deforming an object would require changing the geometric data at every frame.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '**对象修饰符**可以通过非破坏性编辑执行这些操作，这些编辑会影响对象的外观，但不会影响其内部数据。它们可用于生成建模，没有它们，动画将无法进行，因为变形对象需要改变每一帧的几何数据。'
- en: Object modifiers are like the F-Modifiers treated in [*Chapter 8*](B18375_08.xhtml#_idTextAnchor206),
    but they present a greater variety in purpose and attributes.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 对象修饰符类似于在[*第8章*](B18375_08.xhtml#_idTextAnchor206)中处理的F-修饰符，但它们在目的和属性上具有更大的多样性。
- en: 'In this chapter, we will cover the following:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Understanding and using object modifiers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解和使用对象修饰符
- en: Script deformation modifiers
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 脚本变形修饰符
- en: Generating armatures and meshes
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成骨架和网格
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'We will use Blender and Visual Studio Code in this chapter. The examples created
    in this chapter can be found at the following URL: [https://github.com/PacktPublishing/Python-Scripting-in-Blender/tree/main/ch11](https://github.com/PacktPublishing/Python-Scripting-in-Blender/tree/main/ch11).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用Blender和Visual Studio Code。本章创建的示例可以在以下URL找到：[https://github.com/PacktPublishing/Python-Scripting-in-Blender/tree/main/ch11](https://github.com/PacktPublishing/Python-Scripting-in-Blender/tree/main/ch11)。
- en: Understanding object modifiers
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解对象修饰符
- en: Object modifiers change the displayed status of an object without altering its
    geometric data. We met something similar in [*Chapter 8*](B18375_08.xhtml#_idTextAnchor206),
    when we applied effects to animation F-Curves without changing their keyframes.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 对象修饰符改变对象的显示状态，而不改变其几何数据。我们在[*第8章*](B18375_08.xhtml#_idTextAnchor206)中遇到了类似的情况，当时我们在不改变关键帧的情况下对动画F-曲线应用了效果。
- en: Like F-Modifiers, they can be stacked on each other and accessed in Python as
    a collection property.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 与F-修饰符一样，它们可以堆叠在一起，并在Python中以集合属性的形式访问。
- en: Modifiers can be added manually, but their creation and setup can be scripted
    as well. Before we delve into the API, let’s take a look at how to create them
    in the **Modifiers** properties.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 修饰符可以手动添加，但它们的创建和设置也可以通过脚本进行。在我们深入研究API之前，让我们看看如何在**修饰符**属性中创建它们。
- en: Adding modifiers
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加修饰符
- en: Object modifiers are created in the **Modifiers** tab of **Properties** using
    the **Add Modifier** drop-down button. The tab is marked with the icon of a wrench.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 对象修饰符是在**属性**的**修饰符**选项卡中使用**添加修饰符**下拉按钮创建的。该选项卡带有扳手的图标。
- en: '![Figure 11.1: Adding modifiers in Blender](img/Figure_11.01_B18375.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图11.1：在Blender中添加修饰符](img/Figure_11.01_B18375.jpg)'
- en: 'Figure 11.1: Adding modifiers in Blender'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.1：在Blender中添加修饰符
- en: 'Clicking **Add Modifier** displays the available options. They change according
    to the object type: curves don’t have as many modifiers as meshes, while nongeometric
    types such as empty or cameras can’t have any modifiers at all.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**添加修饰符**显示可用选项。它们根据对象类型而变化：曲线没有像网格那么多的修饰符，而像空或相机这样的非几何类型根本不能有任何修饰符。
- en: 'Though their number has grown with time, all modifiers are grouped into four
    categories:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管随着时间的推移它们的数量有所增加，但所有修饰符都被分为四个类别：
- en: '**Modify** – Affects data that won’t be displayed directly, such as vertex
    groups'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**修改** – 影响不会直接显示的数据，例如顶点组'
- en: '**Generate** – Adds or removes geometry to or from an object'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**生成** – 向或从对象添加或删除几何形状'
- en: '**Deform** – Changes the shape of an object without adding or removing vertices,
    edges, or faces'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**变形** – 不添加或删除顶点、边或面，改变对象的形状'
- en: '**Physics** – Brings the result of physics simulations to the object'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**物理** – 将物理模拟的结果应用于对象'
- en: '![Figure 11.2: Clicking Add Modifier displays the available types](img/Figure_11.02_B18375.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图11.2：点击添加修饰符显示可用类型](img/Figure_11.02_B18375.jpg)'
- en: 'Figure 11.2: Clicking Add Modifier displays the available types'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.2：点击添加修饰符显示可用类型
- en: The interface displays one column per category, with several modifier types
    for each of the four. Even modifier types from the same category differ a lot
    from each other and present different sets of attributes.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 界面显示每个类别一列，每个类别有四种修饰符类型。即使是同一类别的修饰符类型也彼此差异很大，并呈现不同的属性集。
- en: To better understand how modifiers work, we can create one in the interface
    and see how that affects an object’s geometry. For example, adding a **Subdivision
    Surface** modifier to an object makes it smoother by creating additional polygons.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解修改器的工作原理，我们可以在界面中创建一个修改器并查看它如何影响对象的几何形状。例如，向对象添加一个 **细分曲面** 修改器可以通过创建额外的多边形使其更加平滑。
- en: Subdividing an object
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 细分对象
- en: Mesh objects are polygonal; that is, they consist of flat faces and sharp edges.
    That works well for simple solids like a cube, but not for smooth surfaces such
    as a sphere, or most real-life objects.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 网格对象是多边形的；也就是说，它们由平面面和锐利的边缘组成。这对于像立方体这样的简单实体很好，但不适用于像球体或大多数现实生活中的物体这样的光滑表面。
- en: To give an illusion of smoothness, we subdivide the polygons of a mesh until
    they approximate a continuous surface.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 为了产生平滑的错觉，我们细分网格的多边形，直到它们近似于连续的表面。
- en: The downside is that geometries that are too dense are problematic; they require
    more disk space and are not easy to model or edit. For that reason, rather than
    storing additional mesh data, we generate smooth geometry using the **Subdivision**
    **Surface** modifier.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，过于密集的几何体是有问题的；它们需要更多的磁盘空间，并且不易于建模或编辑。因此，而不是存储额外的网格数据，我们使用 **细分** **曲面** 修改器生成平滑的几何形状。
- en: '![Figure 11.3: The blocky model on the left is smoothed using Subdivision Surface](img/Figure_11.03_B18375.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.3：左侧的块状模型使用细分曲面进行了平滑](img/Figure_11.03_B18375.jpg)'
- en: 'Figure 11.3: The blocky model on the left is smoothed using Subdivision Surface'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.3：左侧的块状模型使用细分曲面进行了平滑
- en: This modifier splits every edge into two, generating new polygons from those
    divisions. By default, an algorithm named **Catmull-Clark** smoothens the result
    while preserving the overall shape.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 此修改器将每个边缘分成两个，从这些分割中生成新的多边形。默认情况下，一个名为 **Catmull-Clark** 的算法在保持整体形状的同时平滑结果。
- en: 'We can add a subdivision to a model with the following steps:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下步骤向模型添加细分：
- en: Open Blender or go back to the default scene via **File | New |** **General**.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 Blender 或通过 **文件 | 新建 |** **通用** 返回默认场景。
- en: Select the default **Cube** shape and make it active.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择默认的 **Cube** 形状并将其激活。
- en: In the **Modifiers** tab, click **Add Modifier** and select **Subdivision Surface**
    at the bottom of the **Generate** column.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **修改器** 选项卡中，点击 **添加修改器** 并在 **生成** 列的底部选择 **细分曲面**。
- en: A new entry appears in the **Modifiers** properties. We can see the parameters
    of the **Subdivision** modifier.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **修改器** 属性中出现了新的条目。我们可以看到 **细分** 修改器的参数。
- en: '![Figure 11.4: Subdivision Surface properties](img/Figure_11.04_B18375.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.4：细分曲面属性](img/Figure_11.04_B18375.jpg)'
- en: 'Figure 11.4: Subdivision Surface properties'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.4：细分曲面属性
- en: Increasing the number in `3` makes our **Cube** look much like a ball.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `3` 中的数字增加会使我们的 **Cube** 看起来更像一个球体。
- en: 'Clicking the **Simple** button disables the smoothing: the object is still
    subdivided, but its shape doesn’t change.'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **简单** 按钮禁用平滑：对象仍然细分，但其形状不会改变。
- en: Even if enabling **Simple** doesn’t alter its shape, our object is still subdivided.
    That can be useful to other modifiers that can be added after **Subdivision**,
    as they will have more geometry to deform.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 即使启用 **简单** 不会改变其形状，我们的对象仍然是细分的。这对于在 **细分** 之后添加的其他修改器可能很有用，因为它们将有更多的几何形状可以变形。
- en: 'Now that our **Cube** has been subdivided, we will be able to alter its shape
    using a second modifier: **Cast**.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对 **Cube** 进行了细分，我们将能够使用第二个修改器：**铸模** 来改变其形状。
- en: Changing the object’s shape using Cast
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用铸模改变对象的形状
- en: 'With our **Subdivision** modifier still in place, we can add a new modifier
    to alter the object’s shape:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 **细分** 修改器仍然在位的情况下，我们可以添加一个新的修改器来改变对象的形状：
- en: In the **Modifiers** tab, click **Add Modifier** and select **Cast** at the
    top of the **Deform** column. Another modifier shows up under **Subdivision**.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **修改器** 选项卡中，点击 **添加修改器** 并在 **变形** 列的顶部选择 **铸模**。在 **细分** 下方出现另一个修改器。
- en: Change the `Cylinder` and the `1.0`. Our geometry is now a cylinder.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改 `Cylinder` 和 `1.0`。现在我们的几何体是一个圆柱体。
- en: The two modifiers are displayed one on top of the other. Starting from the top,
    each modifier acts as the input of the next one. For this reason, the modifiers
    column is also called the **modifiers stack**.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个修改器是重叠显示的。从顶部开始，每个修改器都作为下一个修改器的输入。因此，修改器列也被称为 **修改器堆栈**。
- en: Using modifiers, we have made our original object look like a cylinder, but
    that change can be reversed, or even animated. Moving the `0.0` and `1.0`, our
    object transitions from its original shape to the one set in **Cast**.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 使用修改器，我们已经使我们的原始对象看起来像圆柱体，但这种变化可以被撤销，甚至可以动画化。移动`0.0`和`1.0`，我们的对象从其原始形状过渡到**Cast**中设置的形状。
- en: We can replicate the preceding steps in Python scripts using Blender’s API.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用Blender的API在Python脚本中重复前面的步骤。
- en: Adding modifiers in Python
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Python中添加修改器
- en: The Python class of Blender objects contains a `modifiers` attribute. Like all
    collections, `modifiers` provides the `new` method, which creates and returns
    new items. By using `new`, we can automate the setup of modifiers using Python.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Blender对象的Python类包含一个`modifiers`属性。像所有集合一样，`modifiers`提供了`new`方法，该方法创建并返回新项。通过使用`new`，我们可以使用Python自动化修改器的设置。
- en: Finding collection-type items
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查找集合类型项
- en: '`Object.modifiers.new` takes two arguments: `name` and `type`. The first will
    be displayed in the modifier properties in the interface, while `type` specifies
    which kind of modifier we want to create. The `type` argument must belong to the
    list of available types, or it will cause an error. Available types are listed
    in the API documentation:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`Object.modifiers.new`接受两个参数：`name`和`type`。第一个将在界面中的修改器属性中显示，而`type`指定我们想要创建哪种类型的修改器。`type`参数必须属于可用类型的列表，否则将导致错误。可用类型在API文档中列出：'
- en: '[https://docs.blender.org/api/3.3/bpy_types_enum_items/object_modifier_type_items.xhtml](https://docs.blender.org/api/3.3/bpy_types_enum_items/object_modifier_type_items.xhtml)'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.blender.org/api/3.3/bpy_types_enum_items/object_modifier_type_items.xhtml](https://docs.blender.org/api/3.3/bpy_types_enum_items/object_modifier_type_items.xhtml)'
- en: 'But we can also get them from Blender itself. These commands will list the
    modifier keywords in Blender’s Python console:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们也可以从Blender本身获取它们。这些命令将在Blender的Python控制台中列出修改器关键字：
- en: '[PRE0]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'There’s another way to get a modifier keyword:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种获取修改器关键字的方法：
- en: Use the **Add Modifier** button in the interface.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用界面中的**添加修改器**按钮。
- en: Look for the argument of the `modifier_add` operator in the **Info** log. It’s
    part of the **Scripting** workspace, as we know from [*Chapter 1*](B18375_01.xhtml#_idTextAnchor014).
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Info**日志中查找`modifier_add`操作符的参数。它属于**脚本**工作区，正如我们从[*第1章*](B18375_01.xhtml#_idTextAnchor014)所知。
- en: '![Figure 11.5: Blender info log after adding Subdivision Surface](img/Figure_11.05_B18375.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图11.5：添加细分表面后的Blender信息日志](img/Figure_11.05_B18375.jpg)'
- en: 'Figure 11.5: Blender info log after adding Subdivision Surface'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.5：添加细分表面后的Blender信息日志
- en: For instance, the keyword for the `'SUBSURF'`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`'SUBSURF'`的关键字。
- en: Using modifiers.new
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`modifiers.new`
- en: Since `modifiers.new` returns the created modifier, we can store the return
    value and replicate all the steps from the previous *Understanding object* *modifiers*
    section.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`modifiers.new`返回创建的修改器，我们可以存储返回值并重复之前*理解对象* *修改器*部分的全部步骤。
- en: 'We’ll see how to add a `bpy` and add a subdivision to increase the available
    geometry:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到如何添加`bpy`并添加细分以增加可用的几何形状：
- en: '[PRE1]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `subdiv` variable contains the new `subdiv`’s attributes.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`subdiv`变量包含新`subdiv`的属性。'
- en: If we are looking for the Python counterpart of an attribute we can see in the
    interface, we can resort to **Python Tooltips** and **Developer Extra**, the two
    options in **Edit** > **Preferences** from the top-bar menu. We learned about
    them in the *Useful features for Python* section in [*Chapter 2*](B18375_02.xhtml#_idTextAnchor033).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在界面上看到一个属性的Python对应物，我们可以求助于**Python工具提示**和**开发者额外**，这两个选项在**编辑** > **首选项**从顶部菜单。我们在[*第2章*](B18375_02.xhtml#_idTextAnchor033)的*有用的Python功能*部分了解过它们。
- en: If tooltips are enabled, hovering the mouse on the `levels`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果启用了工具提示，将鼠标悬停在`levels`上。
- en: '![Figure 11.6: Subdivision attributes path displayed in tooltips](img/Figure_11.06_B18375.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图11.6：在工具提示中显示的细分属性路径](img/Figure_11.06_B18375.jpg)'
- en: 'Figure 11.6: Subdivision attributes path displayed in tooltips'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.6：在工具提示中显示的细分属性路径
- en: 'To increase the object’s poly count without altering its shape, we set `subdiv.levels`
    to `3` and `subdivision_type` to `''SIMPLE''`:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在不改变其形状的情况下增加对象的顶点数，我们将`subdiv.levels`设置为`3`并将`subdivision_type`设置为`'SIMPLE'`：
- en: '[PRE2]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now we have enough polygons to deform our object. We add a `''CAST''` modifier
    and reshape it to a cylinder:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有足够的多边形来变形我们的对象。我们添加一个`'CAST'`修改器，将其重塑为圆柱体：
- en: '[PRE3]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '**Subdivision Surface** and **Cast** are self-sufficient, as they don’t require
    other objects besides the one they are affecting. Other modifiers rely on data
    from ancillary objects.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '**细分曲面**和**投射**是自给自足的，因为它们不需要除了它们影响的对象之外的其他对象。其他修改器依赖于辅助对象的数据。'
- en: In the next section, we will set up a modifier that depends on a deformer object.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将设置一个依赖于变形器对象的修改器。
- en: Deformation objects
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变形对象
- en: 'Many deformers translate a change from one object to another. That allows us
    to deform a complex object by manipulating a simpler one. Here are a few notable
    examples:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 许多变形器将一个对象的变化转换到另一个对象。这允许我们通过操作一个更简单的对象来变形一个复杂对象。以下是一些显著的例子：
- en: '**Curve** – Deforms a mesh along a curve object'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**曲线** – 沿着曲线对象变形网格'
- en: '**Lattice** – Transfers the changes from a regular grid to a mesh'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**晶格** – 将常规网格的变化传递到网格'
- en: '**Armature** – Transfers the pose of an articulated structure to a mesh'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**骨架** – 将一个可动结构的姿态传递到网格'
- en: '**Surface Deform** – Transfers the deformation from one mesh to another'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**表面变形** – 将一个网格的变形传递到另一个网格'
- en: The object used by a modifier can be set using the `modifier.object` attribute.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`modifier.object`属性设置修改器使用的对象。
- en: The **Armature** modifier reproduces the limb movements using a structure of
    **bones**, so it requires a special type of object that can be posed.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '**骨架**修改器使用**骨骼**结构重现肢体运动，因此它需要一个可以摆姿势的特殊类型的对象。'
- en: A **Lattice** modifier, on the other hand, relies on the internal coordinates
    of a grid, which are specific to **Lattice** object types.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，**晶格**修改器依赖于网格的内部坐标，这些坐标是特定于**晶格**对象类型的。
- en: As an example, we will see how to add lattice deformation to an object.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 作为例子，我们将看到如何将晶格变形添加到对象中。
- en: Using the Lattice modifier
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用晶格修改器
- en: 'To use lattice deformation, we need geometry to deform and an object of type
    lattice. We can use Blender’s mascot, the monkey **Suzanne**:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用晶格变形，我们需要一个要变形的几何体和一个晶格类型的对象。我们可以使用Blender的吉祥物，猴子**Suzanne**：
- en: Open Blender or go back to the default scene via **File** | **New** | **General**.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Blender或通过**文件** | **新建** | **通用**返回默认场景。
- en: Delete the default **Cube** shape by pressing **Canc** or **X** | **Delete**.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过按**取消**或**X** | **删除**删除默认的**立方体**形状。
- en: Add a monkey head to the scene using **Add** | **Mesh** | **Monkey**.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**添加** | **网格** | **猴子**将猴子头添加到场景中。
- en: Add a lattice to the scene by using **Add** | **Lattice**.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**添加** | **晶格**将晶格添加到场景中。
- en: 'A lattice was added to the scene. By default, it is smaller than Suzanne, so
    we need to scale it up:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 已将晶格添加到场景中。默认情况下，它比Suzanne小，因此我们需要将其放大：
- en: With the lattice still selected, press `S` to scale. Drag the mouse or press
    `2` to double its size.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在选择晶格后，按`S`键进行缩放。拖动鼠标或按`2`键将其大小加倍。
- en: Select Suzanne to add a modifier. In the **Modifiers** tab, Use **Add Modifier**
    | **Lattice**.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择Suzanne以添加修改器。在**修改器**选项卡中，使用**添加修改器** | **晶格**。
- en: In the **Lattice** modifier, click the **Object** property and select the **Lattice**
    object from the options.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**晶格**修改器中，单击**对象**属性并从选项中选择**晶格**对象。
- en: 'Editing the Lattice object changes Suzanne’s shape:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑晶格对象会改变Suzanne的形状：
- en: Select **Lattice** in **3D Viewport**.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**3D视图**中选择**晶格**。
- en: Press the *Tab* key to switch to **Edit Mode**.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下*Tab*键切换到**编辑模式**。
- en: Select one or more lattice vertices.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个或多个晶格顶点。
- en: 'Press *G* and drag the mouse to move the selection: a lattice deformation is
    applied to Suzanne.'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下*G*键并拖动鼠标以移动选择：对Suzanne应用晶格变形。
- en: '![Figure 11.7: Mesh deformed by a lattice cage](img/Figure_11.07_B18375.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![图11.7：由晶格笼变形的网格](img/Figure_11.07_B18375.jpg)'
- en: 'Figure 11.7: Mesh deformed by a lattice cage'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.7：由晶格笼变形的网格
- en: Automating these steps with Python can make the process much easier. In the
    next section, we will write an operator that sets up a lattice deformation in
    one click.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Python自动化这些步骤可以使过程更加简单。在下一节中，我们将编写一个一键设置晶格变形的操作符。
- en: Writing the Latte Express add-on
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写Latte Express附加组件
- en: The **Latte Express** add-on creates a new lattice around the active object
    and sets up the modifier.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**Latte Express**附加组件在活动对象周围创建一个新的晶格并设置修改器。'
- en: It’s useful for creating basic rigs for cartoon deformation, or stylized objects.
    The add-on consists of an operator class and a menu entry.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 它对于创建基本的卡通变形或风格化对象的骨架很有用。附加组件由一个操作符类和一个菜单项组成。
- en: Setting the environment
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置环境
- en: 'We create a Python script for our add-on:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为我们的附加组件创建一个Python脚本：
- en: Create a `PythonScriptingBlender/ch11/addons` folder. We can use the file manager
    or the file tab of our programmer editor, for example, **VS Code**.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`PythonScriptingBlender/ch11/addons`文件夹中创建一个。我们可以使用文件管理器或我们的程序员编辑器的文件选项卡，例如，**VS
    Code**。
- en: Create a new file in that folder and name it `lattice_express.py`. We can do
    that using the file manager or the **New File** button in an IDE.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在该文件夹中创建一个新文件，并将其命名为`lattice_express.py`。我们可以使用文件管理器或IDE中的**新建文件**按钮来完成此操作。
- en: Open the file in your editor of choice.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您选择的编辑器中打开该文件。
- en: Set the `PythonScriptingBlender/ch11` in the Blender **File Paths** preferences
    and restart Blender.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Blender的**文件路径**首选项中将`PythonScriptingBlender/ch11`设置为，并重新启动Blender。
- en: Now we can write the add-on and load it in Blender.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以编写插件并将其加载到Blender中。
- en: Writing the Latte Express information
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写Latte Express信息
- en: 'Like other add-ons, Latte Express starts with a blank line, followed by the
    `bl_info` dictionary:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如同其他插件一样，Latte Express从一个空行开始，后面跟着`bl_info`字典：
- en: '[PRE4]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Then we proceed with the add-on classes and interface, in this case, a simple
    operator.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们继续编写插件类和界面，在这种情况下，一个简单的操作符。
- en: Writing the Latte Express operator
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写Latte Express操作符
- en: 'We need to import the `bpy` module, so that we can create a new operator:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要导入`bpy`模块，这样我们才能创建一个新的操作符：
- en: '[PRE5]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The operator requires an active object, so the condition in `poll` is as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 操作符需要一个活动对象，因此`poll`中的条件如下：
- en: '[PRE6]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Creating a lattice object requires lattice data first, so inside `execute`,
    we call `bpy.data.lattices.new` and use its return value in `bpy.data.objects.new`.
    We name the new object and data after the active object, even if that’s not required.
    Finally, we add the lattice to the scene by linking it to the current collection:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 创建晶格对象首先需要晶格数据，因此在`execute`函数内部，我们调用`bpy.data.lattices.new`并使用其返回值在`bpy.data.objects.new`中。即使这不是必需的，我们也按照活动对象命名新的对象和数据。最后，我们将晶格通过链接到当前集合添加到场景中：
- en: '[PRE7]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Let’s scale the lattice so that it fits our object. We can get its size from
    the `dimensions` attribute:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们调整晶格的大小，使其适合我们的对象。我们可以从`dimensions`属性中获取其大小：
- en: '[PRE8]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We match the lattice position with the center of the active geometry. We can
    get the object location from the world matrix as we learned in [*Chapter 4*](B18375_04.xhtml#_idTextAnchor075):'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将晶格位置与活动几何中心匹配。我们可以从世界矩阵中获取对象位置，正如我们在[*第4章*](B18375_04.xhtml#_idTextAnchor075)中学到的：
- en: '[PRE9]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: That alone would not work on objects that have their transform pivot away from
    their geometry center, so we must find the actual midpoint of our object.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 仅此还不够，对于其变换枢轴远离几何中心的物体，这不会起作用，因此我们必须找到我们对象的实际中点。
- en: Finding the center of a model
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 寻找模型中心
- en: To create a lattice that matches the location and size of an object, we must
    find the median point of its vertices, but we don’t have to look at all the components.
    We can find the center of the object’s **bounding box**.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个与对象位置和大小匹配的晶格，我们必须找到其顶点的中点，但不必查看所有组件。我们可以找到对象的**边界框**中心。
- en: A bounding box is an imaginary parallelepiped that contains all the object geometry.
    We can display it by activating **Bound** in the **Object** properties.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 边界框是一个包含所有对象几何形状的想象中的平行六面体。我们可以通过在**对象**属性中激活**边界**来显示它。
- en: '![Figure 11.8: An object’s bounding box with coordinate indices added on top](img/Figure_11.8_B18375.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![图11.8：带有坐标索引的对象边界框](img/Figure_11.8_B18375.jpg)'
- en: 'Figure 11.8: An object’s bounding box with coordinate indices added on top'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.8：带有坐标索引的对象边界框
- en: The bounding box is found in Python via the `bound_box` attribute. It’s a list
    of eight coordinates, and we can find the center by interpolating two opposite
    corners.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，边界框是通过`bound_box`属性找到的。它是一个包含八个坐标的列表，我们可以通过插值两个对角顶点来找到中心。
- en: The center of a box is found in the middle of its diagonals, so we want to mediate
    between the lower-left-back corner and the top-right-forward corner. We know the
    indices of those points from *Figure 11**.8*. They are `0` and `6`, respectively.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 箱子的中心位于其对角线的中间，因此我们想要在左下后角和右上前角之间进行调解。我们知道这些点的索引来自**图11**。8*。它们分别是`0`和`6`。
- en: A better way to find those two corners is by using the `min` and `max` functions.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 找到这两个角落的一个更好的方法是使用`min`和`max`函数。
- en: One of the two extremes has the lowest `x`, `y`, `z` values, and the other one
    has the highest. In other words, the components of the lower corner have the lowest
    sum, and those of the higher corner have the highest.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 两个极端之一具有最低的`x`、`y`、`z`值，另一个具有最高的。换句话说，较低角落的分量具有最低的总和，而较高角落的分量具有最高的总和。
- en: 'In Python, `min` and `max` return the lower and higher value in a list, but
    we can supply a different criterion, in this case, `sum`, using the `key` argument:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，`min`和`max`返回列表中的最小和最大值，但我们可以提供不同的标准，在这种情况下，使用`sum`，通过`key`参数：
- en: '[PRE10]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To find the midpoint between two vectors, we can use the linear interpolation
    method (`lerp`) from the `Vector` class. In the `import` section, we need to add
    this line:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到两个向量之间的中点，我们可以使用`Vector`类中的线性插值方法（`lerp`）。在`import`部分，我们需要添加以下行：
- en: '[PRE11]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then, in `execute`, we interpolate the two coordinates. The first argument
    of `lerp` can be any triplet, so we convert only one of the two corners to the
    `Vector` type. Since we are looking for the point sitting halfway between the
    two corners, we provide a factor of `0.5` as the second argument:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`execute`中，我们插值两个坐标。`lerp`的第一个参数可以是任何三元组，所以我们只将两个角中的一个转换为`Vector`类型。因为我们正在寻找位于两个角之间中点的点，所以我们提供一个因子`0.5`作为第二个参数：
- en: '[PRE12]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We add `ob_center` to `ob_translation` to center the lattice to the geometry:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`ob_center`添加到`ob_translation`中，以便将晶格中心对齐到几何形状：
- en: '[PRE13]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Our lattice, centered and scaled, can now be used to deform the object. We
    can use it inside a new modifier and return `{''FINISHED''}` to exit the operator:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的中心和缩放后的晶格现在可以用来变形物体。我们可以在新的修改器中使用它，并返回`{'FINISHED'}`以退出操作：
- en: '[PRE14]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now that the operator is finished, we can add a menu entry for using it.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在操作器已完成，我们可以添加一个菜单项来使用它。
- en: Adding a Create Lattice menu item
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加创建晶格菜单项
- en: 'We define a function to add `LatteExpress` to a menu. Using the `MOD_LATTICE`:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义一个函数将`LatteExpress`添加到菜单中。使用`MOD_LATTICE`：
- en: '[PRE15]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Of course, we need to register the new Blender class and function:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们需要注册新的Blender类和函数：
- en: '[PRE16]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We can refresh the add-on preferences and enable **Latte Express**.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以刷新插件首选项并启用**Latte Express**。
- en: Using the Latte Express add-on
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Latte Express插件
- en: Once we have set the `ch11` folder, we will be able to activate **Latte Express**
    in the **Add-ons** preferences.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们设置了`ch11`文件夹，我们就可以在**Add-ons**首选项中激活**Latte Express**。
- en: '![Figure 11.9: Enabling the Latte Express add-on](img/Figure_11.09_B18375.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![图11.9：启用Latte Express插件](img/Figure_11.09_B18375.jpg)'
- en: 'Figure 11.9: Enabling the Latte Express add-on'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.9：启用Latte Express插件
- en: 'Our add-on makes the task of setting up a lattice deformation easier. Let’s
    see how the workflow from the previous section, *Deformation objects*, has improved:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的插件使得设置晶格变形的任务变得更加容易。让我们看看上一节，*变形对象*的工作流程是如何改进的：
- en: Open Blender or go back to the default scene via **File** | **New** | **General**.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过**File** | **New** | **General**打开Blender或返回默认场景。
- en: Delete the default **Cube** shape by pressing **Canc** or **X** | **Delete**.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过按**Canc**或**X** | **Delete**删除默认的**Cube**形状。
- en: Add a monkey head to the scene using **Add** | **Mesh** | **Monkey**.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**Add** | **Mesh** | **Monkey**将猴子头添加到场景中。
- en: Use the mouse right-click to open the object menu in the **3D Viewport**.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用鼠标右键在**3D Viewport**中打开对象菜单。
- en: Select **Create Lattice on** **Active Object**.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**在活动对象上创建晶格**。
- en: A lattice is created, centered, and scaled on the active object, while a modifier
    is set up. Besides automating the task, using this add-on gives better accuracy,
    as the lattice is scaled according to the object’s exact dimensions.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 晶格在活动物体上创建、居中并缩放，同时设置了一个修改器。除了自动化任务外，使用此插件还能提供更好的精度，因为晶格是根据物体的精确尺寸进行缩放的。
- en: In the next section, we will add more control over the geometry and lattice
    subdivision.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将添加更多对几何形状和晶格细分的控制。
- en: Improving Latte Express options
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改进Latte Express选项
- en: Some objects might not have enough polygons for the lattice deformation to work
    properly. We encountered a similar condition at the beginning of this chapter,
    in the *Understanding object modifiers* section, where we applied a **Subdivision
    Surface** modifier to our **Cube** shape before we could reshape it into a cylinder
    using a **Cast** modifier.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 一些物体可能没有足够的面数，使得晶格变形无法正常工作。我们在本章开头，在*理解对象修改器*部分遇到了类似的情况，当时我们在**Cube**形状上应用了一个**Subdivision
    Surface**修改器，然后才能使用**Cast**修改器将其重塑为圆柱体。
- en: The resolution of lattice objects can also be increased to get more control
    over the deformation.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 晶格物体的分辨率也可以增加，以获得对变形的更多控制。
- en: For those reasons, we will add object subdivision and lattice resolution options
    to our operator.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些原因，我们将向我们的操作员添加对象细分和晶格分辨率选项。
- en: Adding object subdivisions
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加对象细分
- en: We add a subdivide option to `BoolProperty`. Since we will also set a `SUBSURF`
    modifier, we add `IntProperty` for the subdivision levels.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们向`BoolProperty`添加一个细分选项。由于我们还将设置`SUBSURF`修改器，我们添加`IntProperty`用于细分级别。
- en: 'We add `bl_options = {''REGISTER'', ''UNDO''}` to display the operator panel.
    The declaration of **LatteExpress** becomes as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加`bl_options = {'REGISTER', 'UNDO'}`以显示操作面板。**LatteExpress**的声明如下：
- en: '[PRE17]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `execute` method takes these options into account, creating a `SUBSURF`
    modifier if `add_subsurf` is `True`:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`execute`方法考虑了这些选项，如果`add_subsurf`为`True`，则创建一个`SUBSURF`修改器：'
- en: '[PRE18]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '**Subdivision Surface** has an additional attribute for rendering subdivision
    levels. We have set both to the same value to make sure that the Viewport and
    the rendered images look the same.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '**细分曲面**有一个额外的属性用于渲染细分级别。我们将这两个值都设置为相同的值，以确保视口和渲染图像看起来相同。'
- en: Changing lattice resolution
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 改变晶格分辨率
- en: Lattices don’t have polygons or subdivision modifiers, but they have resolution
    parameters to add more divisions along the three axes.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 晶格没有多边形或细分修改器，但它们有三个轴的分辨率参数，可以添加更多的细分。
- en: The `points_u`, `points_v`, and `points_w` attributes set the number of divisions
    across its *x*, *y*, and *z* axes.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`points_u`、`points_v`和`points_w`属性设置了其在*x*、*y*和*z*轴上的细分数量。'
- en: 'We add a property to influence the grid resolution. We use `IntVectorProperty`
    for those three attributes and set its subtype to `''XYZ''` so that they are displayed
    like coordinates. The minimum value for resolution coordinates is `1`, while we
    use `3` as default:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加一个属性以影响网格分辨率。我们使用`IntVectorProperty`为这三个属性，并将其子类型设置为`'XYZ'`，以便它们像坐标一样显示。分辨率坐标的最小值是`1`，而我们将默认值设置为`3`：
- en: '[PRE19]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Because of the way the lattice is implemented, changing the resolution before
    creating the lattice object changes the starting dimensions of a lattice. To avoid
    that, we only set `points_u`, `points_v`, and `points_w` after `latt_obj` is created.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 由于晶格的实现方式，在创建晶格对象之前更改分辨率会改变晶格的起始尺寸。为了避免这种情况，我们只在`latt_obj`创建后设置`points_u`、`points_v`和`points_w`。
- en: 'So, the lattice section becomes as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，晶格部分如下：
- en: '[PRE20]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now that we are adding subdivisions, the lattice grid will present internal
    vertices, that is, control points that end up being inside the lattice. We don’t
    want that because we are using the lattice as an external cage.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们正在添加细分，晶格网格将呈现内部顶点，即最终位于晶格内部的控制点。我们不希望这样，因为我们使用晶格作为外部笼子。
- en: 'So, we set `use_outside` of the lattice data to `True`:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将晶格数据的`use_outside`设置为`True`：
- en: '[PRE21]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: After that, the `execute` method continues as before, linking `latt_obj` to
    `context.collection.objects`, setting its location and scale, and creating the
    object modifiers before it returns `{'FINISHED'}`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，`execute`方法继续执行，将`latt_obj`链接到`context.collection.objects`，设置其位置和缩放，并在返回`{'FINISHED'}`之前创建对象修改器。
- en: If we save the script and use *F3* -> **Reload Scripts** and launch **Create
    Lattice on Active Object**, we’ll see the options for the lattice resolution.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们保存脚本并使用*F3* -> **重新加载脚本**并启动**在活动对象上创建晶格**，我们将看到晶格分辨率的选项。
- en: '![Figure 11.10: A 5x3x3 lattice created with Latte Express](img/Figure_11.10_B18375.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![图11.10：使用Latte Express创建的5x3x3晶格](img/Figure_11.10_B18375.jpg)'
- en: 'Figure 11.10: A 5x3x3 lattice created with Latte Express'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.10：使用Latte Express创建的5x3x3晶格
- en: Lattice grids add quick deformations without requiring additional data in the
    deformed object. Deformers such as **Armature**, the modifier used for articulated
    characters, require the assignment of **vertex groups** to work properly.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 晶格网格添加快速变形，而无需在变形对象中添加额外的数据。例如**骨骼**这样的变形器，用于关节人物的修改器，需要分配**顶点组**才能正常工作。
- en: Using armature deformers
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用轴网变形器
- en: Armatures are deformation objects like lattices, but instead of using a grid,
    they rely on the translation, rotation, and scale of sub-objects called **bones**,
    in analogy with the human skeleton.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 轴网是类似于晶格的变形对象，但它们不是使用网格，而是依赖于称为**骨骼**的子对象的平移、旋转和缩放，这与人类的骨骼相似。
- en: By default, bones are represented as octahedral sticks. Armatures can switch
    to **Pose Mode**, a special Blender mode in which bones can be animated individually
    using the techniques learned in [*Chapter 7*](B18375_07.xhtml#_idTextAnchor171).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，骨骼以八面体棒的形式表示。轴网可以切换到**姿态模式**，这是一种特殊的Blender模式，其中可以使用在[*第7章*](B18375_07.xhtml#_idTextAnchor171)中学到的技术单独动画化骨骼。
- en: The setup of an **Armature** modifier might take some extra steps but is similar
    to the one used for lattices.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 设置 **骨架** 修改器可能需要一些额外的步骤，但与用于网格的步骤类似。
- en: Adding armature objects to the scene
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将骨架对象添加到场景中
- en: 'To acquire familiarity with the bones, we will create a simple armature for
    **Suzanne**’s geometry:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 为了熟悉骨骼，我们将为 **Suzanne** 的几何形状创建一个简单的骨架：
- en: Open Blender or go back to the default scene via **File** | **New** | **General**.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 Blender 或通过 **文件** | **新建** | **通用** 返回默认场景。
- en: Delete the default **Cube** shape by pressing **Canc** or **X** | **Delete**.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过按 **取消** 或 **X** | **删除** 删除默认的 **立方体** 形状。
- en: Add a monkey head to the scene using **Add** | **Mesh** | **Monkey**.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 **添加** | **网格** | **猴子** 将猴子头添加到场景中。
- en: Add an armature to the scene using **Add** | **Armature** | **Single Bone**.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 **添加** | **骨架** | **单个骨骼** 将骨架添加到场景中。
- en: At this point, we should see the tip of an octahedral bone on top of **Suzanne**’s
    head. Since most of the bone is hidden inside the model, we can press the *Z*
    key and switch to the wireframe display.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们应该在 **Suzanne** 的头上看到八面体骨骼的尖端。由于大部分骨骼都隐藏在模型内部，我们可以按 *Z* 键并切换到线框显示。
- en: '![Figure 11.11: An armature bone inside a geometry, with a wireframe display](img/Figure_11.11_B18375.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.11：一个位于几何形状内部的骨架，带有线框显示](img/Figure_11.11_B18375.jpg)'
- en: 'Figure 11.11: An armature bone inside a geometry, with a wireframe display'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.11：一个位于几何形状内部的骨架，带有线框显示
- en: We could set up an **Armature** modifier right away, but armatures usually have
    more than one bone. For instance, we can add bones to the ears.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以立即设置一个 **骨架** 修改器，但骨架通常不止一个骨骼。例如，我们可以向耳朵添加骨骼。
- en: Adding armature bones
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加骨架骨骼
- en: To have a better view while we create new bones, we can press the *1* key or
    use **View** | **Viewpoint** | **Front** from the top-bar menu, then we can press
    the *.* key, or **View** | **Frame Selected**, to center the view.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在创建新骨骼时获得更好的视图，我们可以按 *1* 键或从顶部菜单栏选择 **视图** | **视点** | **前视图**，然后按 *.* 键，或选择
    **视图** | **选择框**，以将视图居中。
- en: 'With the armature as the active object, we switch to **Edit Mode** by pressing
    *Tab* or using the drop-down box on the top left. Then, always in front view,
    we can add bone to the ears using the following steps:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 将骨架作为活动对象，我们通过按 *Tab* 键或使用左上角的下拉菜单切换到 **编辑模式**。然后，始终在前视图中，我们可以按照以下步骤向耳朵添加骨骼：
- en: Add a new bone using the *Shift* + *A* combination or **Add** | **Single Bone**
    from the top-bar menu. The new bone is added on top of the existing one.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 *Shift* + *A* 组合键或从顶部菜单栏选择 **添加** | **单个骨骼** 来添加一个新的骨骼。新骨骼被添加到现有骨骼的上方。
- en: Click on the bones to select one of them.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击骨骼以选择其中一个。
- en: Press *R*, then type `50`, and press *Enter* to rotate the bone toward the right-hand
    side of the screen.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下 *R* 键，然后输入 `50`，再按 *Enter* 键将骨骼向屏幕右侧旋转。
- en: Press *G*, then *X* to move it horizontally, and type `1`. Then, press *Enter*
    to move the bone toward Suzanne’s left ear.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按 *G* 键，然后按 *X* 键水平移动它并输入 `1`。然后，按 *Enter* 键将骨骼移向 Suzanne 的左耳。
- en: Press *G*, then *Z* to move the bone vertically and type `0.2`. Then, press
    *Enter* to move the bone slightly downward.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按 *G* 键，然后按 *Z* 键垂直移动骨骼并输入 `0.2`。然后，按 *Enter* 键将骨骼稍微向下移动。
- en: Blender has a naming convention for left and right bones. To add the `.L` suffix
    to the left ear bone, we select **Armature** | **Names** | **Auto-Name Left/Right**
    from the top-bar menu.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Blender 为左右骨骼有一个命名约定。为了给左耳骨骼添加 `.L` 后缀，我们从顶部菜单栏选择 **骨架** | **名称** | **自动命名左右**。
- en: To create a bone for the other ear, we select **Armature** | **Symmetrize**
    from the top-bar menu.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要为另一只耳朵创建骨骼，我们从顶部菜单栏选择 **骨架** | **对称化**。
- en: The resulting armature should resemble a trident. The exact position of the
    bones is not important for the sake of this example.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的骨架应该类似于三叉戟。在这个例子中，骨骼的确切位置并不重要。
- en: '![Figure 11.12: Ear bones for Blender’s Suzanne](img/Figure_11.12_B18375.jpg)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.12：Blender 的 Suzanne 的耳骨](img/Figure_11.12_B18375.jpg)'
- en: 'Figure 11.12: Ear bones for Blender’s Suzanne'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.12：Blender 的 Suzanne 的耳骨
- en: With three bones in place, we can go back to **Object Mode** by pressing *Tab*
    and go back to the **Solid** view by pressing *Z*. Now, we can bind our geometry
    to the armature.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 放置好三个骨骼后，我们可以通过按 *Tab* 键回到 **对象模式**，再按 *Z* 键回到 **实体** 视图。现在，我们可以将我们的几何形状绑定到骨架上。
- en: Binding objects to armatures
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将对象绑定到骨架上
- en: 'As mentioned earlier, **Armature** deformers require additional information:
    each vertex should be assigned to one or more bones with a process called **weight
    painting**. It’s a manual task for riggers, but we can use Blender automatic weights
    for a quick result:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，**轴网**变形器需要额外的信息：每个顶点都应该通过称为**权重绘制**的过程分配给一个或多个骨骼。对于绑定师来说这是一项手动任务，但我们可以使用Blender的自动权重来快速得到结果：
- en: In **Object Mode**, select the Suzanne object in **3D Viewport**, then keep
    the *Shift* key pressed and select the armature too.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**对象模式**中，在**3D视口**中选择Suzanne对象，然后按住*Shift*键并选择轴网。
- en: Press *Ctrl* + *P* to open the **Set Parent** menu and pick **With Automatic
    Weights**. Or select **Object** | **Parent** | **With Automatic Weights** from
    the top-bar menu.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按*Ctrl* + *P*打开**设置父对象**菜单并选择**使用自动权重**。或者从顶部菜单选择**对象** | **父对象** | **使用自动权重**。
- en: Beware the outliner
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 小心大纲视图
- en: 'If you use **Outliner** for selecting objects, keep in mind that its policy
    is different:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用**大纲视图**来选择对象，请注意其策略是不同的：
- en: In **Viewport**, the last selected of multiple objects is the active object
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在**视口**中，多个对象中最后选择的对象是活动对象
- en: In **Outliner**, the first selected of multiple objects is the active object
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在**大纲视图**中，多个对象中第一个选择的对象是活动对象
- en: To parent an object to an armature, we either select the object and then the
    armature in **Viewport**, or first the armature and then the object in **Outliner**.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 要将对象绑定到轴网上，我们可以在**视口**中先选择对象然后选择轴网，或者先在**大纲视图**中选择轴网然后选择对象。
- en: 'Now we can deform our mesh by posing the armature bones:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以通过摆动轴网骨骼来变形我们的网格：
- en: Select **Armature** and press *Ctrl* + *Tab*, or use the drop-down box on the
    top left of the screen and switch to **Pose Mode**.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**轴网**并按*Ctrl* + *Tab*，或者使用屏幕左上角的下拉框切换到**姿态模式**。
- en: Select any bone, then move, rotate, or scale it by using the *G*, *R*, and *S*
    keys.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择任何骨骼，然后使用*G*、*R*和*S*键移动、旋转或缩放它。
- en: '![Figure 11.13: Armature deformation in Blender](img/Figure_11.13_B18375.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![图11.13：Blender中的轴网变形](img/Figure_11.13_B18375.jpg)'
- en: 'Figure 11.13: Armature deformation in Blender'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.13：Blender中的轴网变形
- en: Bones are a soft, controllable way to deform a model. Lattice grids can be deformed
    with armatures too, so we can create and set up an armature in **Latte Express**.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 骨骼是变形模型的一种柔软、可控的方式。轴网网格也可以用轴网变形，因此我们可以在**Latte Express**中创建和设置轴网。
- en: Scripting a lattice armature
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写网格轴网脚本
- en: Armatures are the recommended way for animating in Blender as they support linking
    across different `.blend` files and other advanced animation features.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 轴网是Blender中动画推荐的途径，因为它们支持在不同`.blend`文件和其他高级动画功能之间进行链接。
- en: Binding a lattice to an armature allows you to animate deformations without
    switching to **Edit Mode** to edit grid vertices.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 将轴网绑定到轴网上可以使您在不切换到**编辑模式**编辑网格顶点的情况下进行变形动画。
- en: Adding an armature condition
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加轴网条件
- en: 'We want armatures to be an optional feature, so we can add another property
    for that. We set its default value to `True`, so an armature is created unless
    it’s set otherwise:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望轴网是一个可选功能，因此我们可以为它添加另一个属性。我们将其默认值设置为`True`，所以除非另行设置，否则将创建轴网：
- en: '[PRE22]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Inside the `execute` method, we check for this value and proceed accordingly.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在`execute`方法内部，我们检查这个值并根据情况继续操作。
- en: Adding an armature to the scene
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将轴网添加到场景中
- en: 'Armatures are created in the same way as lattices and other objects:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 轴网是以与轴网和其他对象相同的方式创建的：
- en: Create new data.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建新数据。
- en: Create a new object using the data created.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用创建的数据创建新对象。
- en: Even if it is not strictly required, we set the new armature as the parent of
    the lattice to ensure consistency between their transforms.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 即使不是严格必需的，我们也将新轴网设置为轴网的父对象，以确保它们变换之间的一致性。
- en: 'If `add_armature` is `False`, we set the lattice location right away. Otherwise,
    we create a new armature. The underlying code takes over soon after we’ve got
    the object median point:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`add_armature`为`False`，我们立即设置轴网的位置。否则，我们创建一个新的轴网。底层代码在我们得到对象中点后不久接管：
- en: '[PRE23]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Once the armature is part of the scene, we can parent the lattice to it and
    move it to where the object is:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦轴网成为场景的一部分，我们可以将其父对象设置为轴网并将其移动到对象所在的位置：
- en: '[PRE24]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'It’s common to have the armature’s transform pivot under the affected geometry,
    so when an armature is at its resting position, the deformed character will be
    above ground level. Therefore, we move the armature to half the object height
    below the center, using the third coordinate of `dimensions`:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，骨架的变换枢轴位于受影响的几何体下方，因此当骨架处于其静止位置时，变形的角色将位于地面以上。因此，我们使用 `dimensions` 的第三个坐标将骨架移动到中心下方对象高度的一半：
- en: '[PRE25]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The lattice, on the other hand, should be centered on the geometry, so we bring
    it up by the same amount:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，晶格应该位于几何体中心，因此我们将其提升相同的量：
- en: '[PRE26]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now that the armature and lattice are placed, we need to create some bones.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 现在骨架和晶格已经放置好了，我们需要创建一些骨骼。
- en: Creating edit bones
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建编辑骨骼
- en: 'To create the bones manually, we select the armature and switch to **Edit Mode**.
    In Python, the same steps are performed with the following:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 为了手动创建骨骼，我们选择骨架并切换到 **编辑模式**。在 Python 中，执行相同的步骤如下：
- en: '[PRE27]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We pass `False` to the `toggle` argument of `mode_set`, because we are not switching
    back and forth between modes.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 `False` 传递给 `mode_set` 函数的 `toggle` 参数，因为我们不是在模式之间来回切换。
- en: We will add as many bones as the lattice vertical sections. For instance, a
    lattice with a vertical resolution of `3` can be rigged with three bones.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加与晶格垂直部分数量相同的骨骼。例如，具有 `3` 个垂直分辨率的晶格可以用三根骨骼绑定。
- en: '![Figure 11.14: Rigging a lattice with armature bones](img/Figure_11.14_B18375.jpg)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.14：使用骨架骨骼绑定晶格](img/Figure_11.14_B18375.jpg)'
- en: 'Figure 11.14: Rigging a lattice with armature bones'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.14：使用骨架骨骼绑定晶格
- en: We get the number of levels from the `grid_levels` property. Each bone starts
    from the lower section and stops at the next. The last bone pops outside the lattice.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从 `grid_levels` 属性中获取级别的数量。每个骨骼从下部分开始，到下一部分结束。最后一根骨骼会超出晶格。
- en: 'To get the optimal length, we divide the object height by the number of internal
    bones, i.e., one bone less than `grid_levels`:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得最佳长度，我们将对象高度除以内部骨骼的数量，即 `grid_levels` 减去一个骨骼：
- en: '[PRE28]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We use a `for` loop to add an `range` function. We add a two-digit suffix to
    each bone name:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用一个 `for` 循环来添加一个 `range` 函数。我们给每个骨骼名称添加一个两位数的后缀：
- en: '[PRE29]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Each bone has a start point (`head`) and an endpoint (`tail`). Since the armature’s
    origin matches the first section of the lattice, the first bone has the coordinates
    `0,` `0, 0`.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 每个骨骼都有一个起点（`头`）和一个终点（`尾`）。由于骨架的起点与晶格的第一部分相匹配，第一根骨骼的坐标为 `0,` `0, 0`。
- en: 'The second bone should have a higher position to make room for the previous
    bone length, and so on, so the expression for each bone head is as follows:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 第二根骨骼应该有更高的位置以留出前一根骨骼的长度，依此类推，因此每个骨骼头的表达式如下：
- en: '[PRE30]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `tail` part of the bone adds one `bone_length` to the `head[2]` coordinate:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 骨骼的 `尾` 部分将 `head[2]` 坐标增加一个 `bone_length`：
- en: '[PRE31]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: To assign the lattice vertices to the bones, we must collect which vertices
    belong to the current level based on their `Z` coordinate.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将晶格顶点分配给骨骼，我们必须根据它们的 `Z` 坐标收集属于当前级别的顶点。
- en: Assigning vertices to bones
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分配顶点到骨骼
- en: For each lattice point, we compare the third coordinate (`co[2]`) with the relative
    height of the current section. *Relative* means that the first section is at a
    height of `0.0`, the last is at `1.0`, the one in the middle is at `0.5`, and
    so on.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个晶格点，我们比较第三个坐标（`co[2]`）与当前部分的相对高度。*相对* 意味着第一部分的高度为 `0.0`，最后一部分为 `1.0`，中间的部分为
    `0.5`，依此类推。
- en: 'Python indices start from `0`, so the index of the last section is the number
    of sections minus `1`. Keeping that in mind, here’s how we can get the relative
    height of each level:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: Python 索引从 `0` 开始，所以最后一部分的索引是部分数量减 `1`。考虑到这一点，以下是获取每个级别的相对高度的方法：
- en: '[PRE32]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Lattice points are relative to the center, and the size of one side of the
    lattice is `1.0`, so the vertical coordinate of the lowest point is `-0.5`. For
    that reason, we lower `rel_height` by `0.5` units:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 晶格点相对于中心，晶格的一边大小为 `1.0`，所以最低点的垂直坐标为 `-0.5`。因此，我们将 `rel_height` 降低 `0.5` 单位：
- en: '[PRE33]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'To assign vertices, we need a list of their indices, which we store in the
    `vert_ids` list:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 为了分配顶点，我们需要一个包含它们索引的列表，我们将它存储在 `vert_ids` 列表中：
- en: '[PRE34]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In this list, we need to store the identifier number of the lattice points,
    not their coordinates.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个列表中，我们需要存储晶格点的标识符编号，而不是它们的坐标。
- en: The lattice data points are an ordered collection, so their identifier is their
    ordinal index; that is, the first point is identified by index `1`, the second
    point has index `2`, and so on.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 晶格数据点是按顺序排列的，因此它们的标识符是它们的序号索引；也就是说，第一个点由索引`1`标识，第二个点有索引`2`，依此类推。
- en: 'In Python, we can get the ordinal of the iterated items using `enumerate`:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，我们可以使用`enumerate`来获取迭代项的序号：
- en: '[PRE35]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We can create a vertex group named after each bone and assign vertices using
    the `add` method. We also supply a weight of `1.0`, because we are not blending
    the assignment between two groups, and set `''REPLACE''` as a condition, because
    we are not adding nor subtracting from a previous assignment:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为每个骨骼创建一个以骨骼命名的顶点组，并使用`add`方法分配顶点。我们还提供一个`1.0`的权重，因为我们不是在两个组之间混合分配，并将`'REPLACE'`作为条件，因为我们不是从先前的分配中添加或减去：
- en: '[PRE36]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Creating the bones and assigning their influence is the hard part of the process.
    Now we can create the modifiers.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 创建骨骼并分配它们的影响是这个过程中的难点。现在我们可以创建修改器。
- en: Creating the Armature modifier
  id: totrans-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建骨架修改器
- en: 'We add a new Armature modifier to `latt_obj` via the `modifiers.new` method,
    and we use `arm_obj` as its deformer object:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过`modifiers.new`方法向`latt_obj`添加一个新的骨架修改器，并使用`arm_obj`作为其变形对象：
- en: '[PRE37]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Finally, we leave `''POSE''`, so that the user can animate:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们保留`'POSE'`，这样用户就可以进行动画制作：
- en: '[PRE38]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: At this point, `LattExpress` creates a lattice deformer and animation bones
    in one click. As an optional step, we can create custom shapes for displaying
    the bones.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，`LattExpress`一键创建晶格变形器和动画骨骼。作为一个可选步骤，我们可以为显示骨骼创建自定义形状。
- en: Adding custom bone shapes
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加自定义骨骼形状
- en: 'Armature bones are effective deformers, but we have experienced a major drawback
    for ourselves in the *Using armature deformers* section: bones tend to be hidden
    by the deformed geometry.'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 骨架骨骼是有效的变形器，但在*使用骨架变形器*部分，我们为自己体验到了一个主要的缺点：骨骼往往被变形几何体隐藏。
- en: There are a few workarounds, such as activating the **In Front** attribute in
    the **Armature** properties and using **X-Ray** or **Wireframe** views.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种解决方案，例如在**骨架**属性中激活**在前**属性，并使用**X-Ray**或**线框**视图。
- en: Another gimmick consists in displaying special widgets by assigning mesh objects
    to the bone’s **Custom** **Shape** attribute.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个技巧是通过将网格对象分配给骨骼的**自定义** **形状**属性来显示特殊的小部件。
- en: Creating mesh objects in Python
  id: totrans-308
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Python中创建网格对象
- en: First, we must create a new mesh. A mesh consists of vertex coordinates, plus
    edges or faces that connect vertices.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须创建一个新的网格。一个网格由顶点坐标组成，以及连接顶点的边或面。
- en: '![Figure 11.15: Vertex coordinates of a 2D square](img/Figure_11.15_B18375.jpg)'
  id: totrans-310
  prefs: []
  type: TYPE_IMG
  zh: '![图11.15：2D正方形的顶点坐标](img/Figure_11.15_B18375.jpg)'
- en: 'Figure 11.15: Vertex coordinates of a 2D square'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.15：2D正方形的顶点坐标
- en: In this example, we create a wireframe square and use it as a bone widget. Blender
    bones expand upon their `Y` axis, so the horizontal coordinates of our bones that
    are placed vertically are `X` and `Z`.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建一个线框正方形并将其用作骨骼小部件。Blender骨骼在`Y`轴上扩展，所以放置垂直的骨骼的水平坐标是`X`和`Z`。
- en: 'We build our list of vertices. We aim for a side length of `1.0`, a measure
    easy to scale. For that reason, each side will go from a `-0.5` to a `0.5` coordinate,
    or the other way around. If `X` and `Z` are the first and last coordinates, this
    is our vertex list:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 我们构建我们的顶点列表。我们希望边长为`1.0`，这是一个易于缩放的度量。因此，每一边将从`-0.5`到`0.5`的坐标，或者反过来。如果`X`和`Z`是第一个和最后一个坐标，这就是我们的顶点列表：
- en: '[PRE39]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Next, we need a list of edges. An edge is a pair of vertex indices, each representing
    the two vertices that are going to connect. The four edges of a square connect
    vertex `0` to `1`, `1` to `2`, vertex `2` to `3`, and `3` to `0`:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要一个边的列表。边是一对顶点索引，每个索引代表将要连接的两个顶点。正方形的四条边将顶点`0`连接到`1`，`1`连接到`2`，顶点`2`连接到`3`，`3`连接到`0`：
- en: '[PRE40]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We can create new mesh data from Python lists using the `from_pydata` method.
    Since we don’t need faces in a control widget, the third argument is an empty
    list:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`from_pydata`方法从Python列表创建新的网格数据。由于我们不需要控制小部件中的面，第三个参数是一个空列表：
- en: '[PRE41]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We add the mesh to the scene:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将网格添加到场景中：
- en: '[PRE42]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now, we can assign the widget shape to the **pose bones** of our armature:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以将小部件形状分配给我们的骨架的**姿态骨骼**：
- en: '[PRE43]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: With a side length of `1.0`, our widget could be hidden as well, so we scale
    it to match the `dimensions` object.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 以`1.0`的边长，我们的小部件也可以被隐藏，所以我们将其缩放以匹配`dimensions`对象。
- en: 'Keeping in mind that a bone’s up direction is the `Y` axis, but Blender’s up
    direction is `Z`, we set the `Z` custom shape scale to the `Y` dimension:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到骨骼的向上方向是 `Y` 轴，而 Blender 的向上方向是 `Z`，我们将 `Z` 自定义形状比例设置为 `Y` 维度：
- en: '[PRE44]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Blender scales the displayed custom shape by the length of the bone, so we
    divide the scale by the bone length:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: Blender 通过骨骼的长度来缩放显示的自定义形状，所以我们通过骨骼长度来除以缩放：
- en: '[PRE45]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The armature created in our script is ready. We will tidy the scene and exit
    the operator.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 我们脚本中创建的骨架已经准备好了。我们将整理场景并退出操作员。
- en: Storing bones is bad for your variables!
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 存储骨骼对你的变量有害！
- en: Armature bones are represented by different Python entities depending on the
    current mode. When the armature is in `EditBone` from the armature data `edit_bones`
    collection is used. When the armature is in `PoseBone` from the `pose.bones` object
    `is` used.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 骨架骨骼由不同的 Python 实体表示，具体取决于当前模式。当骨架处于 `EditBone` 模式时，使用骨架数据的 `edit_bones` 集合。当骨架处于
    `PoseBone` 模式时，使用 `pose.bones` 对象的 `is`。
- en: These collections are rebuilt every time the armature is updated, storing them
    in variables while they are changed can cause crashes.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 这些集合每次骨架更新时都会重建，在它们改变时存储在变量中可能会导致崩溃。
- en: Finalizing the setup
  id: totrans-332
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 完成设置
- en: 'If an armature is created, we hide the widget mesh and the lattice:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 如果创建了骨架，我们将隐藏小部件网格和晶格：
- en: '[PRE46]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The last steps of `execute` are the same as before: we create a lattice modifier
    for the deformed object, unselect the geometry, and finish:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '`execute` 的最后步骤与之前相同：我们为变形对象创建晶格修改器，取消选择几何体，并完成：'
- en: '[PRE47]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Reloading the scripts and launching **Create Lattice on Active Object** will
    create a full animation setup complete with armature and bone shapes.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 重新加载脚本并启动 **在活动对象上创建晶格** 将创建一个完整的动画设置，包括骨架和骨骼形状。
- en: '![Figure 11.16: Suzanne deformed via animation controls](img/Figure_11.16_B18375.jpg)'
  id: totrans-338
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.16：通过动画控制变形的 Suzanne](img/Figure_11.16_B18375.jpg)'
- en: 'Figure 11.16: Suzanne deformed via animation controls'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.16：通过动画控制变形的 Suzanne
- en: This add-on can still be improved. For instance, we could build oval shapes
    for our animation controls or tidy the `execute` method by moving some of the
    code to specific functions, but since it satisfies its initial purpose, we can
    consider it finished.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 此插件仍然可以改进。例如，我们可以为我们的动画控制构建椭圆形形状，或者通过将一些代码移动到特定函数中来整理 `execute` 方法，但既然它满足了其初始目的，我们可以认为它是完成的。
- en: Summary
  id: totrans-341
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We have learned how to alter objects using modifiers and how to bind modifiers
    to animate objects. We have also gained a deeper understanding of how object data
    works and how objects of different types are created, linked to the scene, and
    integrated.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习了如何使用修改器改变对象，以及如何将修改器绑定到动画对象。我们还对对象数据的工作原理以及不同类型的对象是如何创建、链接到场景和集成的有了更深入的了解。
- en: Using this knowledge, we have coded a production tool that can be used to deform
    any object.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些知识，我们已经编写了一个可以用来变形任何对象的制作工具。
- en: In the next and final chapter of this book, [*Chapter 12*](B18375_12.xhtml#_idTextAnchor304),
    we will explore the last step of a 3D pipeline.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的下一章和最后一章 [*第 12 章*](B18375_12.xhtml#_idTextAnchor304)，我们将探索 3D 管道的最后一步。
- en: Questions
  id: totrans-345
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Do modifiers alter the object’s data?
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改器是否会改变对象的数据？
- en: How do we add modifiers to an object?
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何向对象添加修改器？
- en: Do modifiers rely on other objects besides the ones they deform?
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改器是否依赖于除了它们变形之外的其他对象？
- en: 'True or false: We can change the resolution of lattice data before or after
    we create its lattice object with no consequences.'
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对或错：我们可以在创建晶格对象之前或之后更改晶格数据的分辨率，而不会产生任何后果。
- en: How do we add bones to an armature in Python?
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何在 Python 中向骨架添加骨骼？
- en: 'True or false: There is only one bone collection property.'
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对或错：只有一个骨骼集合属性。
- en: 'True or false: Only objects of type mesh can be deformed by armatures.'
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对或错：只有网格类型的对象可以通过骨架变形。
- en: Blender has modes. Does the current mode have consequences on whether we can
    add or remove data in our script?
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Blender 有模式。当前模式是否会影响我们是否能在脚本中添加或删除数据？
- en: How do we create a mesh using Python?
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何使用 Python 创建网格？
