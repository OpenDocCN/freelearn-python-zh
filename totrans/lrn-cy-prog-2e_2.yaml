- en: Chapter 2. Understanding Cython
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 2 章。理解 Cython
- en: As I mentioned previously, there are a number of methods of using Cython. As
    the basics are very familiar to any Python programmer, it's important to review
    the linking models before getting into the programming language. This is what
    drives the design of applications when using Cython.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前提到的，有几种使用 Cython 的方法。由于基础知识对任何 Python 程序员来说都非常熟悉，因此在进入编程语言之前，回顾链接模型非常重要。这是使用
    Cython 时驱动应用程序设计的原因。
- en: Next, we will get more familiar with the Cython programming language constructs,
    namely, the distinction between `cdef` and `cpdef`. Then, we will look at getting
    the most out of Cython by interfacing directly with native C types. Later in this
    book, we will see that it's possible to use native C++ STL container types. This
    is where you will gain the optimizations in execution, as no Python runtime is
    required to work with native types.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将更熟悉 Cython 编程语言构造，即 `cdef` 和 `cpdef` 之间的区别。然后，我们将探讨如何通过直接与原生 C 类型接口来充分利用
    Cython。在本书的后面部分，我们将看到可以使用原生 C++ STL 容器类型。这就是您将获得执行优化之处，因为不需要 Python 运行时来与原生类型一起工作。
- en: Finally, we will see how easy it is to work with callbacks to and from C and
    Python code. This is an interesting technique whereby you can offload logic from
    C code to Python.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将看到与 C 和 Python 代码之间的回调操作是多么容易。这是一种有趣的技术，您可以使用它将逻辑从 C 代码卸载到 Python。
- en: 'Therefore, in this chapter, we will be diving into the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在本章中，我们将深入探讨以下主题：
- en: Linking models
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 链接模型
- en: Cython keyword – cdef
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cython 关键字 – cdef
- en: Typedef and function pointers
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型定义和函数指针
- en: The public keyword
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公共关键字
- en: Keyword cpdef
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关键字 cpdef
- en: Logging from C/C++ into Python
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 C/C++ 到 Python 的日志记录
- en: Using Python ConfigParser from C/C++
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 C/C++ 中使用 Python ConfigParser
- en: Callbacks from Python to C/C++
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 Python 到 C/C++ 的回调
- en: Cython PXD
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cython PXD
- en: Integration with build systems
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与构建系统的集成
- en: Linking models
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 链接模型
- en: 'Linking models are extremely important when considering how we can extend or
    embed things in native applications. There are two main linking models for Cython:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑如何扩展或嵌入原生应用程序时，链接模型非常重要。Cython 有两种主要的链接模型：
- en: 'Fully embedded Python within C/C++ code, which looks like the following screenshot:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C/C++ 代码中完全嵌入 Python，如下面的截图所示：
- en: '![Linking models](img/B04685_02_01.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![链接模型](img/B04685_02_01.jpg)'
- en: Using this method of embedding the Python runtime into a native application
    means you initiate execution of code directly from any point in your C/C++ code,
    as opposed to the [Chapter 1](ch01.html "Chapter 1. Cython Won't Bite"), *Cython
    Won't Bite* where we had to run the Python interpreter and call an import to execute
    native code.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 使用将 Python 运行时嵌入到原生应用程序中的这种方法意味着您可以直接从 C/C++ 代码的任何位置启动代码执行，而不是像在[第 1 章](ch01.html
    "第 1 章。Cython 不会咬人")*Cython 不会咬人*中那样，我们必须运行 Python 解释器并调用导入来执行原生代码。
- en: 'For the sake of completeness, here is the import model of using Cython:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完整性，这里介绍了使用 Cython 的导入模型：
- en: '![Linking models](img/B04685_02_02.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![链接模型](img/B04685_02_02.jpg)'
- en: This would be a more Pythonic approach to Cython, and will be helpful if your
    code base is mostly Python. We will review an example of the Python `lxml` module,
    which provides a Cython backend, later in this book, and we can compare it to
    the native Python backend to review the speed and execution of both code bases
    to perform the same task.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是 Cython 的更 Pythonic 方法，如果您的代码库主要是 Python，这将非常有帮助。在本书中，我们将在后面回顾 Python `lxml`
    模块的一个示例，它提供了一个 Cython 后端，我们可以将其与原生 Python 后端进行比较，以审查两个代码库执行相同任务的速度和执行情况。
- en: Cython keyword – cdef
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Cython 关键字 – cdef
- en: 'The `cdef` keyword tells the compiler that this statement is a native C type
    or native function. Remember from [Chapter 1](ch01.html "Chapter 1. Cython Won''t
    Bite"), *Cython Won''t Bite* that we used this line to declare the C prototype
    function:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`cdef` 关键字告诉编译器此语句是原生 C 类型或原生函数。记得从[第 1 章](ch01.html "第 1 章。Cython 不会咬人")*Cython
    不会咬人*中我们使用此行来声明 C 原型函数：'
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This is the line that let us wrap the native C function into a Python callable
    using the Python `def` keyword. We can use this in many contexts, for example,
    we can declare normal variables for use within a function to speed up execution:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这是让我们使用 Python `def` 关键字将原生 C 函数包装成 Python 可调用对象的行。我们可以在许多上下文中使用它，例如，我们可以声明在函数内部使用的普通变量以加快执行速度：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This is a trivial example, but it will tell the compiler that we will always
    be squaring an integer. However, for normal Python code, it's a little more complicated
    as Python has to worry a lot more about losing precision when it comes to handling
    many different types. But in this case, we know exactly what the type is and how
    it can be handled.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的例子，但它会告诉编译器我们总是会平方一个整数。然而，对于正常的Python代码来说，这要复杂一些，因为Python在处理许多不同类型时必须担心精度丢失的问题。但在这个情况下，我们知道确切的类型以及如何处理它。
- en: You might also have noticed that this is a simple `def` function, but because
    it will be fed to the Cython compiler, this will work just fine, and handle the
    typed parameter as you would expect.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能也注意到这是一个简单的`def`函数，但由于它将被传递给Cython编译器，所以它将正常工作，并像预期的那样处理类型参数。
- en: Structs
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结构体
- en: 'C structs can be worked with directly in Cython. For example, this header declares
    a simple `struct`:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在Cython中可以直接处理C结构体。例如，这个头文件声明了一个简单的`struct`：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This random `struct` will demonstrate several concepts, including working with
    an array. Firstly, we must declare the layout of the `struct` inside Cython. We
    can again use the `cdef` block syntax. Everything within that block is a `cdef`
    and will include the specified header, which is important when the output from
    the Cython compiler is compiled via GCC or Clang:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这个随机的`struct`将演示几个概念，包括处理数组。首先，我们必须在Cython中声明`struct`的布局。我们再次可以使用`cdef`块语法。该块内的所有内容都是`cdef`，并将包含指定的头文件，这在Cython编译器的输出通过GCC或Clang编译时很重要：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now that we have declared the prototype `printStruct` function, we can use
    this to verify the data outside of Cython''s scope. To work with this raw data
    type, we will make a `testStruct` Python callable, which we will invoke using
    a simple Python import:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经声明了`printStruct`函数的原型，我们可以使用这个函数来验证Cython作用域之外的数据。为了处理这个原始数据类型，我们将创建一个`testStruct`
    Python可调用对象，我们将使用简单的Python导入来调用它：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Let's look at this more closely. We firstly declare an instance of the `struct`
    on the stack. Next, we declare a C-String array of size 2\. The next lines will
    look familiar via setting each of the members of the `struct` with a value. But
    notice that we declared our string array on the stack and then set the string
    array member to this instance. This is important as Cython will rely on the programmer
    to understand memory and stack versus heap properly. But it's important to notice
    that passing strings from language to language is completely trivial.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看。我们首先在栈上声明了一个`struct`实例。接下来，我们声明了一个大小为2的C字符串数组。接下来的几行将通过设置`struct`的每个成员的值而变得熟悉。但请注意，我们是在栈上声明了字符串数组，然后将字符串数组成员设置为这个实例。这很重要，因为Cython将依赖于程序员正确理解内存和栈与堆。但重要的是要注意，在语言之间传递字符串是完全微不足道的。
- en: 'The final caveat with structs is while defining a `cdef` declaration for a
    function. If a parameter is a struct, you never declare it as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 关于结构体的最后一个注意事项是在定义函数的`cdef`声明时。如果一个参数是结构体，你永远不要如下声明：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Instead, we simply use the following:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们简单地使用以下方法：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Cython will figure it out.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Cython会自己处理。
- en: There are a few subtleties with the `testStruct` function. In Cython, we have
    the reference operator '`&`' that works just as in C. Therefore, with this `struct`
    on the stack, we can pass a pointer via the reference operator just like in C.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`testStruct`函数有几个细微之处。在Cython中，我们有引用操作符"`&`"，它的工作方式与C相同。因此，在这个栈上的`struct`中，我们可以通过引用操作符传递指针，就像在C中一样。'
- en: Note that we don't have a '`→`' operator in Cython. When accessing members inside
    the `struct` (even if it is a pointer), we simply use the '`.`' operator. Cython
    understands the context and will handle it.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Cython中没有"`→`"操作符。当访问`struct`内部的成员（即使它是一个指针）时，我们简单地使用"`.`"操作符。Cython理解上下文并将处理它。
- en: 'From the previous example and for the sake of completeness we can implement
    the `printStruct` function simply as:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的例子以及为了完整性考虑，我们可以简单地实现`printStruct`函数如下：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This demonstrates even when we initialize the C struct from within Cython code
    it''s a perfectly valid C type. A simple run of this in the downloaded code is
    as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明即使我们从Cython代码中初始化C结构体，它也是一个有效的C类型。在下载的代码中简单地运行这个例子如下：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This demonstrates that Cython can work with C structs—it initialized the C struct
    and assigned its data members, as you would expect if it was from C.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明Cython可以与C结构体一起工作——它初始化了C结构体并分配了其数据成员，就像它来自C一样。
- en: Enums
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 枚举
- en: 'Interfacing with C enums is simple. If you have the following enum in C:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 与 C 枚举的接口很简单。如果你在 C 中有以下的枚举：
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Then this can be expressed as the following Cython declaration:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，这可以表达为以下 Cython 声明：
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Then, use the following as the `cdef` declaration within our code:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在我们的代码中使用以下作为 `cdef` 声明：
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: It's a very small example, but it's important to see how simple it is.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常小的例子，但重要的是看到它是多么简单。
- en: Typedef and function pointers
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`typedef` 和函数指针'
- en: 'The `typedef` in C/C++ code allows the programmer to give a new name or alias
    to any type. For example, one could `typedef` an `int` to `myint`. Or you can
    just simply `typedef` a struct so that you don''t have to refer to the struct
    with the keyword struct every time. For example, consider this C `struct` and
    `typedef`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C/C++ 代码中的 `typedef` 允许程序员给任何类型赋予一个新名称或别名。例如，可以将 `int` `typedef` 为 `myint`。或者你可以简单地
    `typedef` 一个结构体，这样你就不必每次都使用 `struct` 关键字来引用结构体。例如，考虑以下 C `struct` 和 `typedef`：
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In Cython, this can be described by the following:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Cython 中，这可以描述如下：
- en: '[PRE13]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Note we can also `typedef` pointer types as below:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们也可以 `typedef` 指针类型如下：
- en: '[PRE14]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We can also `typedef` function C/C++ pointers, as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以 `typedef` C/C++ 函数指针，如下所示：
- en: '[PRE15]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In Cython, this will be as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Cython 中，这将如下所示：
- en: '[PRE16]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Using the function pointer is just as you would expect:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 使用函数指针正如你所期望的那样：
- en: '[PRE17]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: There is some magic going on here with function pointers as it's simply not
    safe for raw Python code to directly call a Python function or vice versa. Cython
    understands this case and will wrap things up for us to make the call safely.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些关于函数指针的魔法，因为直接从原始 Python 代码调用 Python 函数或反之亦然是不安全的。Cython 理解这种情况，并将为我们包装好以安全地调用。
- en: The public keyword
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 公共关键字
- en: 'This is a very powerful keyword in Cython. It allows any `cdef` declaration
    with the `public` modifier to output a respective C/C++ header with the relative
    declaration accessible from C/C++. For example, we can declare:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Cython 中，这是一个非常强大的关键字。它允许任何带有 `public` 修饰符的 `cdef` 声明输出相应的 C/C++ 头文件，其中相对声明可以从
    C/C++ 访问。例如，我们可以声明：
- en: '[PRE18]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Once the compiler handles this, you will have an output of `cython_input.h`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦编译器处理了这个，你将得到一个 `cython_input.h` 的输出：
- en: '[PRE19]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The main caveat, if you''re going to call the Python `public` declarations
    directly from C, is that, if your link model is fully embedded and linked against
    `libpython.so`, you need to use some boilerplate code to initialize Python correctly:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你要直接从 C 调用 Python 的 `public` 声明，主要的一个注意事项是，如果你的链接模型是完全嵌入的并且链接到 `libpython.so`，你需要使用一些样板代码来正确初始化
    Python：
- en: '[PRE20]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'And before calling anything with the function, you need to initialize the Python
    module example if you have a `cythonfile.pyx` file, and compile it with the `public`
    declarations as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用该函数之前，如果你有一个 `cythonfile.pyx` 文件，你需要初始化 Python 模块 example，并按照以下方式编译具有 `public`
    声明的代码：
- en: '[PRE21]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'You will get not only a `cythonfile.c` file, but also `cythonfile.h`, which
    declares a function called `extern void initcythonfile (void)`. So, before calling
    anything related to the Cython code, use the following:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你将不仅得到一个 `cythonfile.c` 文件，还会得到一个 `cythonfile.h` 文件，它声明了一个名为 `extern void initcythonfile
    (void)` 的函数。所以，在调用任何与 Cython 代码相关的内容之前，使用以下代码：
- en: '[PRE22]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Calling `initcythonfile` can be considered as the following in Python:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用函数之前，你可以将调用 `initcythonfile` 看作在 Python 中的以下操作：
- en: '[PRE23]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Just like the previous examples, this only affects you if you're generating
    a fully embedded Python binary. If you are simply compiling a native module, you
    will not need to do this step.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 就像之前的例子一样，这只会影响你如果正在生成一个完全嵌入的 Python 二进制文件。如果你只是编译一个本地模块，你将不需要执行此步骤。
- en: Keyword cpdef
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关键字 cpdef
- en: 'So far, we have seen two different function declarations in Cython, `def` and
    `cdef`, to define functions. There is one more declaration—`cpdef`. The `def`
    is a Python-only function, so it is only callable from Python or Cython code blocks;
    calling from C does not work. The `cdef` is the opposite; this means that it''s
    callable from C and not from Python. For example, if we create a function such
    as:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了 Cython 中的两种不同的函数声明，`def` 和 `cdef`，用于定义函数。还有一个声明——`cpdef`。`def`
    是一个仅适用于 Python 的函数，因此它只能从 Python 或 Cython 代码块中调用；从 C 调用不起作用。`cdef` 是相反的；这意味着它可以从
    C 调用，但不能从 Python 调用。例如，如果我们创建一个函数如下：
- en: '[PRE24]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'It will generate the following function prototype:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 它将生成以下函数原型：
- en: '[PRE25]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `public` keyword will make sure we generate the needed header so that we
    can call it from C. Calling from pure Python, we can work with this as if it was
    just any other Python function. The drawback of using `cpdef` is that the native
    return type is `PyObject *`, which requires you to know exactly what the return
    type is and consult the Python API documentation to access the data. I prefer
    keeping bindings between the languages simpler, as this is okay for void functions,
    and will be easier. But if you want to return the data, it can be frustrating.
    For example, from the preceding code snippet, if we know that we are returning
    an `int` type, we could use the following:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`public` 关键字将确保我们生成所需的头文件，以便我们可以从 C 中调用它。从纯 Python 调用时，我们可以像使用任何其他 Python 函数一样处理它。使用
    `cpdef` 的缺点是原生返回类型是 `PyObject *`，这要求你确切知道返回类型，并查阅 Python API 文档以访问数据。我更喜欢保持语言之间的绑定更简单，因为这对于
    void 函数来说是可行的，并且会更简单。但如果你想要返回数据，可能会很令人沮丧。例如，从前面的代码片段中，如果我们知道我们返回的是 `int` 类型，我们可以使用以下代码：'
- en: '[PRE26]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Notice the extra argument `__pyx_skip_dispatch`. As this is an implementation-specific
    argument, set this to `0`, and your call should work the way you expect, taking
    the first parameter as the argument specified. The reason we use `long` is that
    every integer in Python is represented as long. You will need to refer to [https://docs.python.org/2/c-api/](https://docs.python.org/2/c-api/)
    for any other datatypes to get the data out of `PyObject`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 注意额外的参数 `__pyx_skip_dispatch`。由于这是一个实现特定的参数，将其设置为 `0`，你的调用应该按预期工作，将第一个参数作为指定的参数。我们使用
    `long` 的原因是 Python 中的每个整数都表示为 `long`。你需要参考 [https://docs.python.org/2/c-api/](https://docs.python.org/2/c-api/)
    来获取任何其他数据类型，以便从 `PyObject` 中获取数据。
- en: Note that using a public `cpdef` Cython function isn't really a good idea. Yes,
    it means you create functions that are callable from both C/C++ and Python with
    no change. But you lose the type safety which Cython can provide and is so important.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，使用公共的 `cpdef` Cython 函数并不是一个好主意。是的，这意味着你创建了可以从 C/C++ 和 Python 中调用的函数，而且无需任何更改。但你失去了
    Cython 可以提供的类型安全，这对于非常重要。
- en: Logging from C/C++ into Python
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从 C/C++ 记录到 Python
- en: An example of everything brought together is reusing the Python logging module
    directly from C. We want a few macros, such as `info`, `error`, and `debug` that
    can all handle a variable number of arguments and works as if we are calling a
    simple `printf` method.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 将一切整合在一起的例子是直接从 C 中重用 Python 日志模块。我们希望有一些宏，例如 `info`、`error` 和 `debug`，它们可以处理可变数量的参数，并且像调用简单的
    `printf` 方法一样工作。
- en: 'To achieve this, we must make a Python logging backend for our C/C++ code.
    We need an initialization function to tell Python about our output `logfile`,
    and some wrappers for each `info`, `error`, and `debug`. We can simply write the
    public `cdef` wrappers as:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们必须为我们的 C/C++ 代码创建一个 Python 日志后端。我们需要一个初始化函数来告诉 Python 关于我们的输出 `logfile`，以及为每个
    `info`、`error` 和 `debug` 编写一些包装器。我们可以简单地写出公共的 `cdef` 包装器如下：
- en: '[PRE27]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Remember that we declare our public functions as `cdef`; if they were simply
    `def`, they wouldn''t be callable from C/C++. We can make this even more awesome
    by using C99 `__VA_ARGS__` (this allows us to pass a variable number of arguments
    to a function hence the name variable arguments, this is how `printf` works) and
    a compiler attribute that enforces argument checking like the warnings and errors
    you get from wrong format specifiers when using the `printf` family of functions.
    Now, we can declare and define our C API to use the Python logging backend:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们声明我们的公共函数为 `cdef`；如果它们只是 `def`，则不能从 C/C++ 中调用。我们可以通过使用 C99 `__VA_ARGS__`（这允许我们将可变数量的参数传递给函数，因此得名可变参数，这就是
    `printf` 的工作方式）以及一个编译器属性来强制执行参数检查，就像使用 `printf` 函数族时从错误格式说明符获得的警告和错误一样。现在，我们可以声明并定义我们的
    C API 以使用 Python 日志后端：
- en: '[PRE28]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, we need to fill out each of these functions, beginning with `SetupNativeLogging`:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要填写这些函数中的每一个，从 `SetupNativeLogging` 开始：
- en: '[PRE29]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This function is responsible for initializing Python and the Python logging
    backend module. This is equivalent to an `import` statement in Python but because
    we are in the driving seat in C we must load it natively. As well as its respective
    `initLoggingWithLogFile` so that the logger will output a log file. We can implement
    a simple C `info`, `error`, and `debug` by using the `va_list` and `vsprintf`
    family of functions to turn the argument list and format into a C string ready
    to print:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数负责初始化 Python 和 Python 日志后端模块。这相当于 Python 中的 `import` 语句，但由于我们在 C 中处于主导地位，我们必须原生地加载它。以及相应的
    `initLoggingWithLogFile`，以便记录器将输出到日志文件。我们可以通过使用 `va_list` 和 `vsprintf` 函数族将参数列表和格式转换为
    C 字符串来打印，从而实现简单的 C `info`、`error` 和 `debug`：
- en: '[PRE30]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now that we have these macros calling their respective log functions within
    C, we simply need to define the `CloseNativeLogging`, which is simple as we just
    need to close down Python:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将这些宏在 C 中调用它们各自的日志函数，我们只需要定义 `CloseNativeLogging`，这很简单，因为我们只需要关闭 Python：
- en: '[PRE31]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'By wiring all this up together, we have a very nice way of using Python within
    C/C++, as if it was nothing strange:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将这些功能连接起来，我们就有了一种非常优雅的方式在 C/C++ 中使用 Python，就像它不是什么奇怪的事情：
- en: '[PRE32]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Note that this is the fully embedded link model for Cython. I decided to wrap
    all Python-specific code within the implementation. It's very easy to see how
    you could even migrate from using an old legacy logging API to using Python logging
    to get access to the massive feature set available, such as logging, to a network
    socket.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这是 Cython 的完全嵌入链接模型。我决定将所有 Python 特定的代码包裹在实现中。你可以很容易地看到，你甚至可以从使用旧的遗留日志 API
    迁移到使用 Python 日志，以便访问大量功能，例如日志记录到网络套接字。
- en: 'Running this example, we can see the output as we would expect:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这个示例，我们可以看到预期的输出：
- en: '[PRE33]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: What's really nice here is that we have been able to preserve the line information
    from C/C++ all the way into the Python code. This example used the function wrapping
    concepts as well as the embedded linking model. No special programming tricks
    were used in this example.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 真正令人高兴的是，我们能够从 C/C++ 代码中保留行信息到 Python 代码。这个示例使用了函数包装概念以及嵌入链接模型。在这个示例中没有使用特殊的编程技巧。
- en: Using Python ConfigParser from C/C++
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 C/C++ 中使用 Python ConfigParser
- en: I really like Python's `ConfigParser` API. I find using an INI style config
    file to be very readable and nice to work with as opposed to using XML or JSON.
    There are very few cross-platform libraries available to do this. However, when
    you have Cython, all you need is Python.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我真的很喜欢 Python 的 `ConfigParser` API。我发现使用 INI 风格的配置文件比使用 XML 或 JSON 更易于阅读和操作。可用的跨平台库非常少。然而，当你有
    Cython 时，你只需要 Python。
- en: For this example, we will create a sample `INI` configuration file and write
    a simple API to access a list of sections, list of keys available in a section,
    and a way to get the value from a specified key within a section. These three
    functions will allow a programmer to access any `INI` file.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，我们将创建一个示例 `INI` 配置文件，并编写一个简单的 API 来访问部分列表、一个部分中可用的键列表，以及从指定键获取部分值的方法。这三个函数将允许程序员访问任何
    `INI` 文件。
- en: 'A sample INI file could be:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 一个示例 INI 文件可以是：
- en: '[PRE34]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'An INI file is comprised of sections within the square brackets, followed by
    keys and values. It''s a very simple way of doing configuration. Python''s API
    allows for variables and substitution depending on the flavor of the `ConfigParser`.
    Firstly, we need a way to query the list of sections within an INI file:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: INI 文件由方括号内的部分组成，后跟键和值。这是一种非常简单的配置方式。Python 的 API 允许根据 `ConfigParser` 的风味进行变量和替换。首先，我们需要一种查询
    INI 文件中部分列表的方法：
- en: '[PRE35]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'There are a few things going on here to take note of. Firstly, the following:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有几个需要注意的地方。首先，以下内容：
- en: '[PRE36]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This `public struct` declaration, as we have seen before, will be the output
    into the respective header file. This means we don''t have to define this inside
    the C/C++ code first:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，这个 `public struct` 声明将被输出到相应的头文件中。这意味着我们不需要在 C/C++ 代码中首先定义它：
- en: '[PRE37]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This function is designed to take the path to the configuration file as a string.
    It also takes the pointer to the `struct ConfigSections`. This `ConfigSections`
    structure allows us to return a list of sections back into C code safely. C is
    a very simple language and does not have any nice variable length structures like
    C++'s STL library.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数设计用来接收配置文件的路径作为字符串。它还接收指向`struct ConfigSections`的指针。这个`ConfigSections`结构允许我们安全地将部分列表返回到C代码中。C是一种非常简单的语言，没有像C++
    STL库那样的优雅的变量长度结构。
- en: 'So, we must return a pointer to a list of C-Strings and the number of strings
    in that list. Since this structure is passed as an argument, the Cython code does
    not have to allocate and return a pointer, which is less efficient and not a standard
    C approach for small structures such as this. Note that we do have to allocate
    the list of strings:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们必须返回一个指向C-String列表的指针以及该列表中的字符串数量。由于这个结构作为参数传递，Cython代码不需要分配和返回一个指针，这既不高效也不是这种小型结构的标准C方法。注意，我们确实需要分配字符串列表：
- en: '[PRE38]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'As with C++, Cython code requires an explicit cast when allocating memory with
    malloc. We will review this cast syntax later for more advanced usage. Next, we
    need to implement:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 与C++一样，Cython代码在用malloc分配内存时需要显式类型转换。我们将在稍后复习这种类型转换语法，以便进行更高级的使用。接下来，我们需要实现：
- en: '[PRE39]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'And finally, to get values from keys within sections:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了从部分内的键获取值：
- en: '[PRE40]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now that we have all these functions, we can write C code to iterate over the
    sections in any given config file, and print everything out programmatically to
    demonstrate how powerful this can be:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了所有这些函数，我们可以编写C代码来遍历任何给定配置文件中的部分，并程序化地打印出所有内容，以展示这有多么强大：
- en: '[PRE41]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Using the technique of passing reference to allocated structs on the stack,
    we eliminate a lot of memory management, but because we allocated memory to the
    arrays within each struct, we must free them. But note that we can simply return
    the value for `ParseConfigKeyFromSection`:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 使用在栈上传递已分配结构引用的技术，我们消除了大量的内存管理，但由于我们在每个结构内部的数组中分配了内存，我们必须释放它们。但请注意，我们可以简单地返回`ParseConfigKeyFromSection`的值：
- en: '[PRE42]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Note
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When returning C strings from Cython functions, we do not need to free anything,
    as this is managed by the Python garbage collector. It feels very strange to be
    able to return strings like this from Cython, but it's perfectly fine to do so.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当从Cython函数返回C字符串时，我们不需要释放任何东西，因为这是由Python垃圾回收器管理的。能够从Cython返回这样的字符串感觉非常奇怪，但这样做是完全可行的。
- en: 'Running this example, we can see:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这个示例，我们可以看到：
- en: '[PRE43]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: You can see that we successfully parsed out all sections, keys, and values from
    the INI file programmatically.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，我们成功地将所有部分、键和值从INI文件中程序化地解析出来。
- en: Callbacks from Python to C/C++
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从Python到C/C++的回调
- en: 'Callbacks are used extensively in asynchronous systems. Libraries such as libevent
    provide a powerful asynchronous core to process events. Let''s build an example
    to set a C function as a callback into a Python backend, which will notify back
    again into the C code. Firstly, we will declare a public callback function `typedef`:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 回调在异步系统中被广泛使用。例如，libevent库提供了一个强大的异步核心来处理事件。让我们构建一个示例，将C函数作为回调设置到Python后端中，这将再次通知C代码。首先，我们将声明一个公共回调函数`typedef`：
- en: '[PRE44]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'This will output a callback `typedef`. Next, we can declare a global callback
    on the stack:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出一个`callback`类型定义。接下来，我们可以在栈上声明一个全局`callback`：
- en: '[PRE45]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Once this is set, we can then notify the `callback` easily. Next, we need a
    way to set the `callback` and another to call the `callback`:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设置完成，我们就可以轻松地通知`callback`。接下来，我们需要一种设置`callback`的方法，以及一种调用`callback`的方法：
- en: '[PRE46]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Notice the `global` keyword from Python through which the compiler knows to
    use the `global` keyword and not create a temporary instance from within that
    suite:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 注意从Python传递过来的`global`关键字，编译器通过这个关键字知道使用`global`关键字，而不是在那个套件内部创建一个临时实例：
- en: '[PRE47]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The `Notify` will take an argument and pass this argument to the callback.
    Again, we need to use the `global` keyword to ensure that the compiler will use
    the proper `global` keyword. Using the cast again, we ensure that we can never
    call a null `callback`. Next, we need to declare a `callback` inside the C code:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`Notify`将接受一个参数并将这个参数传递给回调。同样，我们需要使用`global`关键字来确保编译器将使用正确的`global`关键字。再次使用类型转换，我们确保永远不会调用一个空的`callback`。接下来，我们需要在C代码内部声明一个`callback`：'
- en: '[PRE48]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Then, we can set the `callback`:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以设置`callback`：
- en: '[PRE49]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'And finally, `Notify`:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`Notify`：
- en: '[PRE50]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'This is the output we should expect:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们应该预期的输出：
- en: '[PRE51]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Later, we will use this more extensively to produce a simple Python message
    broker.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将更广泛地使用它来生成一个简单的Python消息代理。
- en: Cython PXD
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Cython PXD
- en: 'The use of PXD files is very similar to that of header files in C/C++. When
    writing bindings to any C/C++ code, it is a good practice to declare all C/C++
    interfaces within a `.pxd` file. This stands for **Python External Declarations**,
    at least it does in my mind. So, when we add blocks such as this:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: PXD文件的使用与C/C++中的头文件非常相似。当编写任何C/C++代码的绑定时，在`.pxd`文件中声明所有C/C++接口是一种良好的做法。这代表**Python外部声明**，至少在我的理解中是这样。因此，当我们添加如下块：
- en: '[PRE52]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'We can instead put this directly into a `bindings.pxd` file and import this
    at any time inside any `.pyx` file:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将此直接放入一个`bindings.pxd`文件，并在任何`.pyx`文件中的任何时间导入此文件：
- en: '[PRE53]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Notice the distinction between `cimport` for the `.pxd` files and a simple import
    for all normal Python imports.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`cimport`用于`.pxd`文件和简单导入用于所有正常Python导入之间的区别。
- en: Tip
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Cython's input filenames cannot handle dashes (`-)` in their filenames. It's
    best to try and use CamelCase, since you can't use `cimport my-import` in Python.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: Cython的输入文件名不能处理文件名中的连字符（`-`）。最好尝试使用驼峰命名法，因为在Python中不能使用`cimport my-import`。
- en: Integration with build systems
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与构建系统的集成
- en: This topic is basically dependent on the linking model that you choose if you
    are to choose the shared-library approach. I would recommend using Python `distutils`
    and if you are going for embedded Python, and if you like GNU or autotools, this
    section gives an example you can use.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您选择共享库方法，此主题基本上取决于您选择的链接模型。我建议使用Python `distutils`，如果您正在寻找嵌入式Python，并且如果您喜欢GNU或autotools，本节提供了一个您可以使用的示例。
- en: Python Distutils
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python Distutils
- en: 'When compiling a native Python module, we can use `distutils` and `cythonize`
    inside our `Setup.py` build. It''s the preferred way in Python to use Cython as
    part of the build:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 当编译本地Python模块时，我们可以在`Setup.py`构建中使用`distutils`和`cythonize`。这是Python中使用Cython作为构建部分的首选方式：
- en: '[PRE54]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This build file will support whichever version of Python you invoke the script
    with. When you run the build, your output will be of the same name of the input
    source code as a shared module in this case `sourcecode.so`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 此构建文件将支持您使用脚本的任何Python版本。当您运行构建时，您的输出将与输入源代码的同一名称相同，在这种情况下是一个共享模块`sourcecode.so`。
- en: GNU/Autotools
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GNU/Autotools
- en: 'To embed Python code within C/C++ applications using the autotools build system
    the following snippet will help you. It will use `python-config` to get the compiler
    and linker flags necessary to do so:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用autotools构建系统在C/C++应用程序中嵌入Python代码，以下代码片段将帮助您。它将使用`python-config`来获取编译器和链接器标志，以便完成此操作：
- en: '[PRE55]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'This adds the `--enable-python` switch to your configure script. You now have
    the Cython command `found` and the `PYLIBS` and `PYINCS` variables for the compilation
    flags you need to compile. Now, you need a snippet to understand how to compile
    `*.pyx` in your sources in automake:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在您的配置脚本中添加`--enable-python`开关。现在，您有了Cython命令`found`以及`PYLIBS`和`PYINCS`变量，用于编译所需的编译标志。现在，您需要一个代码片段来了解如何在automake中编译源代码中的`*.pyx`文件：
- en: '[PRE56]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: When you're comfortable with understanding where your code is and the linking
    models, embedding Python becomes very easy.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 当您对代码的位置和链接模型感到舒适时，嵌入Python变得非常容易。
- en: Summary
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: There are a lot of fundamentals of using Cython in this chapter. It's important
    to review what you want to achieve when using Cython, since the different ways
    in which it can be used affects how you design a solution. We investigated the
    differences between `def`, `cdef`, and `cpdef`. We created public C/C++ declarations
    of types and callable functions. Using these public declarations, we showed how
    Python can callback into C code. For me, reusing any Python module within native
    code is very useful and interesting. I demonstrated how I use the Python `logging`
    and `ConfigParser` modules from C code. Appreciating these simple examples, we
    will see how we can extend C/C++ projects with Python code in the next chapter.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中有很多使用Cython的基本知识。在使用Cython时，回顾您想要实现的目标非常重要，因为它的不同使用方式会影响您设计解决方案的方式。我们研究了`def`、`cdef`和`cpdef`之间的区别。我们创建了公共C/C++类型和可调用函数的声明。使用这些公共声明，我们展示了Python如何回调到C代码。对我来说，在本地代码中重用任何Python模块非常有用且有趣。我演示了如何从C代码中使用Python的`logging`和`ConfigParser`模块。欣赏这些简单的示例，我们将在下一章中看到如何使用Python代码扩展C/C++项目。
