- en: Chapter 2. Understanding Cython
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As I mentioned previously, there are a number of methods of using Cython. As
    the basics are very familiar to any Python programmer, it's important to review
    the linking models before getting into the programming language. This is what
    drives the design of applications when using Cython.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will get more familiar with the Cython programming language constructs,
    namely, the distinction between `cdef` and `cpdef`. Then, we will look at getting
    the most out of Cython by interfacing directly with native C types. Later in this
    book, we will see that it's possible to use native C++ STL container types. This
    is where you will gain the optimizations in execution, as no Python runtime is
    required to work with native types.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we will see how easy it is to work with callbacks to and from C and
    Python code. This is an interesting technique whereby you can offload logic from
    C code to Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, in this chapter, we will be diving into the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Linking models
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cython keyword – cdef
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Typedef and function pointers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The public keyword
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keyword cpdef
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logging from C/C++ into Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Python ConfigParser from C/C++
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Callbacks from Python to C/C++
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cython PXD
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integration with build systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linking models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Linking models are extremely important when considering how we can extend or
    embed things in native applications. There are two main linking models for Cython:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Fully embedded Python within C/C++ code, which looks like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Linking models](img/B04685_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Using this method of embedding the Python runtime into a native application
    means you initiate execution of code directly from any point in your C/C++ code,
    as opposed to the [Chapter 1](ch01.html "Chapter 1. Cython Won't Bite"), *Cython
    Won't Bite* where we had to run the Python interpreter and call an import to execute
    native code.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the sake of completeness, here is the import model of using Cython:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Linking models](img/B04685_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This would be a more Pythonic approach to Cython, and will be helpful if your
    code base is mostly Python. We will review an example of the Python `lxml` module,
    which provides a Cython backend, later in this book, and we can compare it to
    the native Python backend to review the speed and execution of both code bases
    to perform the same task.
  prefs: []
  type: TYPE_NORMAL
- en: Cython keyword – cdef
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `cdef` keyword tells the compiler that this statement is a native C type
    or native function. Remember from [Chapter 1](ch01.html "Chapter 1. Cython Won''t
    Bite"), *Cython Won''t Bite* that we used this line to declare the C prototype
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the line that let us wrap the native C function into a Python callable
    using the Python `def` keyword. We can use this in many contexts, for example,
    we can declare normal variables for use within a function to speed up execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This is a trivial example, but it will tell the compiler that we will always
    be squaring an integer. However, for normal Python code, it's a little more complicated
    as Python has to worry a lot more about losing precision when it comes to handling
    many different types. But in this case, we know exactly what the type is and how
    it can be handled.
  prefs: []
  type: TYPE_NORMAL
- en: You might also have noticed that this is a simple `def` function, but because
    it will be fed to the Cython compiler, this will work just fine, and handle the
    typed parameter as you would expect.
  prefs: []
  type: TYPE_NORMAL
- en: Structs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'C structs can be worked with directly in Cython. For example, this header declares
    a simple `struct`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This random `struct` will demonstrate several concepts, including working with
    an array. Firstly, we must declare the layout of the `struct` inside Cython. We
    can again use the `cdef` block syntax. Everything within that block is a `cdef`
    and will include the specified header, which is important when the output from
    the Cython compiler is compiled via GCC or Clang:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have declared the prototype `printStruct` function, we can use
    this to verify the data outside of Cython''s scope. To work with this raw data
    type, we will make a `testStruct` Python callable, which we will invoke using
    a simple Python import:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Let's look at this more closely. We firstly declare an instance of the `struct`
    on the stack. Next, we declare a C-String array of size 2\. The next lines will
    look familiar via setting each of the members of the `struct` with a value. But
    notice that we declared our string array on the stack and then set the string
    array member to this instance. This is important as Cython will rely on the programmer
    to understand memory and stack versus heap properly. But it's important to notice
    that passing strings from language to language is completely trivial.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final caveat with structs is while defining a `cdef` declaration for a
    function. If a parameter is a struct, you never declare it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead, we simply use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Cython will figure it out.
  prefs: []
  type: TYPE_NORMAL
- en: There are a few subtleties with the `testStruct` function. In Cython, we have
    the reference operator '`&`' that works just as in C. Therefore, with this `struct`
    on the stack, we can pass a pointer via the reference operator just like in C.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we don't have a '`→`' operator in Cython. When accessing members inside
    the `struct` (even if it is a pointer), we simply use the '`.`' operator. Cython
    understands the context and will handle it.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the previous example and for the sake of completeness we can implement
    the `printStruct` function simply as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This demonstrates even when we initialize the C struct from within Cython code
    it''s a perfectly valid C type. A simple run of this in the downloaded code is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This demonstrates that Cython can work with C structs—it initialized the C struct
    and assigned its data members, as you would expect if it was from C.
  prefs: []
  type: TYPE_NORMAL
- en: Enums
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Interfacing with C enums is simple. If you have the following enum in C:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Then this can be expressed as the following Cython declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, use the following as the `cdef` declaration within our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: It's a very small example, but it's important to see how simple it is.
  prefs: []
  type: TYPE_NORMAL
- en: Typedef and function pointers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `typedef` in C/C++ code allows the programmer to give a new name or alias
    to any type. For example, one could `typedef` an `int` to `myint`. Or you can
    just simply `typedef` a struct so that you don''t have to refer to the struct
    with the keyword struct every time. For example, consider this C `struct` and
    `typedef`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In Cython, this can be described by the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Note we can also `typedef` pointer types as below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also `typedef` function C/C++ pointers, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In Cython, this will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the function pointer is just as you would expect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: There is some magic going on here with function pointers as it's simply not
    safe for raw Python code to directly call a Python function or vice versa. Cython
    understands this case and will wrap things up for us to make the call safely.
  prefs: []
  type: TYPE_NORMAL
- en: The public keyword
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is a very powerful keyword in Cython. It allows any `cdef` declaration
    with the `public` modifier to output a respective C/C++ header with the relative
    declaration accessible from C/C++. For example, we can declare:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the compiler handles this, you will have an output of `cython_input.h`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The main caveat, if you''re going to call the Python `public` declarations
    directly from C, is that, if your link model is fully embedded and linked against
    `libpython.so`, you need to use some boilerplate code to initialize Python correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'And before calling anything with the function, you need to initialize the Python
    module example if you have a `cythonfile.pyx` file, and compile it with the `public`
    declarations as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'You will get not only a `cythonfile.c` file, but also `cythonfile.h`, which
    declares a function called `extern void initcythonfile (void)`. So, before calling
    anything related to the Cython code, use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Calling `initcythonfile` can be considered as the following in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Just like the previous examples, this only affects you if you're generating
    a fully embedded Python binary. If you are simply compiling a native module, you
    will not need to do this step.
  prefs: []
  type: TYPE_NORMAL
- en: Keyword cpdef
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have seen two different function declarations in Cython, `def` and
    `cdef`, to define functions. There is one more declaration—`cpdef`. The `def`
    is a Python-only function, so it is only callable from Python or Cython code blocks;
    calling from C does not work. The `cdef` is the opposite; this means that it''s
    callable from C and not from Python. For example, if we create a function such
    as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'It will generate the following function prototype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The `public` keyword will make sure we generate the needed header so that we
    can call it from C. Calling from pure Python, we can work with this as if it was
    just any other Python function. The drawback of using `cpdef` is that the native
    return type is `PyObject *`, which requires you to know exactly what the return
    type is and consult the Python API documentation to access the data. I prefer
    keeping bindings between the languages simpler, as this is okay for void functions,
    and will be easier. But if you want to return the data, it can be frustrating.
    For example, from the preceding code snippet, if we know that we are returning
    an `int` type, we could use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Notice the extra argument `__pyx_skip_dispatch`. As this is an implementation-specific
    argument, set this to `0`, and your call should work the way you expect, taking
    the first parameter as the argument specified. The reason we use `long` is that
    every integer in Python is represented as long. You will need to refer to [https://docs.python.org/2/c-api/](https://docs.python.org/2/c-api/)
    for any other datatypes to get the data out of `PyObject`.
  prefs: []
  type: TYPE_NORMAL
- en: Note that using a public `cpdef` Cython function isn't really a good idea. Yes,
    it means you create functions that are callable from both C/C++ and Python with
    no change. But you lose the type safety which Cython can provide and is so important.
  prefs: []
  type: TYPE_NORMAL
- en: Logging from C/C++ into Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An example of everything brought together is reusing the Python logging module
    directly from C. We want a few macros, such as `info`, `error`, and `debug` that
    can all handle a variable number of arguments and works as if we are calling a
    simple `printf` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'To achieve this, we must make a Python logging backend for our C/C++ code.
    We need an initialization function to tell Python about our output `logfile`,
    and some wrappers for each `info`, `error`, and `debug`. We can simply write the
    public `cdef` wrappers as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember that we declare our public functions as `cdef`; if they were simply
    `def`, they wouldn''t be callable from C/C++. We can make this even more awesome
    by using C99 `__VA_ARGS__` (this allows us to pass a variable number of arguments
    to a function hence the name variable arguments, this is how `printf` works) and
    a compiler attribute that enforces argument checking like the warnings and errors
    you get from wrong format specifiers when using the `printf` family of functions.
    Now, we can declare and define our C API to use the Python logging backend:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to fill out each of these functions, beginning with `SetupNativeLogging`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This function is responsible for initializing Python and the Python logging
    backend module. This is equivalent to an `import` statement in Python but because
    we are in the driving seat in C we must load it natively. As well as its respective
    `initLoggingWithLogFile` so that the logger will output a log file. We can implement
    a simple C `info`, `error`, and `debug` by using the `va_list` and `vsprintf`
    family of functions to turn the argument list and format into a C string ready
    to print:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have these macros calling their respective log functions within
    C, we simply need to define the `CloseNativeLogging`, which is simple as we just
    need to close down Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'By wiring all this up together, we have a very nice way of using Python within
    C/C++, as if it was nothing strange:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Note that this is the fully embedded link model for Cython. I decided to wrap
    all Python-specific code within the implementation. It's very easy to see how
    you could even migrate from using an old legacy logging API to using Python logging
    to get access to the massive feature set available, such as logging, to a network
    socket.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running this example, we can see the output as we would expect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: What's really nice here is that we have been able to preserve the line information
    from C/C++ all the way into the Python code. This example used the function wrapping
    concepts as well as the embedded linking model. No special programming tricks
    were used in this example.
  prefs: []
  type: TYPE_NORMAL
- en: Using Python ConfigParser from C/C++
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I really like Python's `ConfigParser` API. I find using an INI style config
    file to be very readable and nice to work with as opposed to using XML or JSON.
    There are very few cross-platform libraries available to do this. However, when
    you have Cython, all you need is Python.
  prefs: []
  type: TYPE_NORMAL
- en: For this example, we will create a sample `INI` configuration file and write
    a simple API to access a list of sections, list of keys available in a section,
    and a way to get the value from a specified key within a section. These three
    functions will allow a programmer to access any `INI` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'A sample INI file could be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'An INI file is comprised of sections within the square brackets, followed by
    keys and values. It''s a very simple way of doing configuration. Python''s API
    allows for variables and substitution depending on the flavor of the `ConfigParser`.
    Firstly, we need a way to query the list of sections within an INI file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'There are a few things going on here to take note of. Firstly, the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'This `public struct` declaration, as we have seen before, will be the output
    into the respective header file. This means we don''t have to define this inside
    the C/C++ code first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This function is designed to take the path to the configuration file as a string.
    It also takes the pointer to the `struct ConfigSections`. This `ConfigSections`
    structure allows us to return a list of sections back into C code safely. C is
    a very simple language and does not have any nice variable length structures like
    C++'s STL library.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we must return a pointer to a list of C-Strings and the number of strings
    in that list. Since this structure is passed as an argument, the Cython code does
    not have to allocate and return a pointer, which is less efficient and not a standard
    C approach for small structures such as this. Note that we do have to allocate
    the list of strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'As with C++, Cython code requires an explicit cast when allocating memory with
    malloc. We will review this cast syntax later for more advanced usage. Next, we
    need to implement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, to get values from keys within sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have all these functions, we can write C code to iterate over the
    sections in any given config file, and print everything out programmatically to
    demonstrate how powerful this can be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the technique of passing reference to allocated structs on the stack,
    we eliminate a lot of memory management, but because we allocated memory to the
    arrays within each struct, we must free them. But note that we can simply return
    the value for `ParseConfigKeyFromSection`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When returning C strings from Cython functions, we do not need to free anything,
    as this is managed by the Python garbage collector. It feels very strange to be
    able to return strings like this from Cython, but it's perfectly fine to do so.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running this example, we can see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: You can see that we successfully parsed out all sections, keys, and values from
    the INI file programmatically.
  prefs: []
  type: TYPE_NORMAL
- en: Callbacks from Python to C/C++
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Callbacks are used extensively in asynchronous systems. Libraries such as libevent
    provide a powerful asynchronous core to process events. Let''s build an example
    to set a C function as a callback into a Python backend, which will notify back
    again into the C code. Firstly, we will declare a public callback function `typedef`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'This will output a callback `typedef`. Next, we can declare a global callback
    on the stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Once this is set, we can then notify the `callback` easily. Next, we need a
    way to set the `callback` and another to call the `callback`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice the `global` keyword from Python through which the compiler knows to
    use the `global` keyword and not create a temporary instance from within that
    suite:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Notify` will take an argument and pass this argument to the callback.
    Again, we need to use the `global` keyword to ensure that the compiler will use
    the proper `global` keyword. Using the cast again, we ensure that we can never
    call a null `callback`. Next, we need to declare a `callback` inside the C code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can set the `callback`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, `Notify`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the output we should expect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Later, we will use this more extensively to produce a simple Python message
    broker.
  prefs: []
  type: TYPE_NORMAL
- en: Cython PXD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The use of PXD files is very similar to that of header files in C/C++. When
    writing bindings to any C/C++ code, it is a good practice to declare all C/C++
    interfaces within a `.pxd` file. This stands for **Python External Declarations**,
    at least it does in my mind. So, when we add blocks such as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'We can instead put this directly into a `bindings.pxd` file and import this
    at any time inside any `.pyx` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Notice the distinction between `cimport` for the `.pxd` files and a simple import
    for all normal Python imports.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Cython's input filenames cannot handle dashes (`-)` in their filenames. It's
    best to try and use CamelCase, since you can't use `cimport my-import` in Python.
  prefs: []
  type: TYPE_NORMAL
- en: Integration with build systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This topic is basically dependent on the linking model that you choose if you
    are to choose the shared-library approach. I would recommend using Python `distutils`
    and if you are going for embedded Python, and if you like GNU or autotools, this
    section gives an example you can use.
  prefs: []
  type: TYPE_NORMAL
- en: Python Distutils
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When compiling a native Python module, we can use `distutils` and `cythonize`
    inside our `Setup.py` build. It''s the preferred way in Python to use Cython as
    part of the build:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: This build file will support whichever version of Python you invoke the script
    with. When you run the build, your output will be of the same name of the input
    source code as a shared module in this case `sourcecode.so`.
  prefs: []
  type: TYPE_NORMAL
- en: GNU/Autotools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To embed Python code within C/C++ applications using the autotools build system
    the following snippet will help you. It will use `python-config` to get the compiler
    and linker flags necessary to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'This adds the `--enable-python` switch to your configure script. You now have
    the Cython command `found` and the `PYLIBS` and `PYINCS` variables for the compilation
    flags you need to compile. Now, you need a snippet to understand how to compile
    `*.pyx` in your sources in automake:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: When you're comfortable with understanding where your code is and the linking
    models, embedding Python becomes very easy.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a lot of fundamentals of using Cython in this chapter. It's important
    to review what you want to achieve when using Cython, since the different ways
    in which it can be used affects how you design a solution. We investigated the
    differences between `def`, `cdef`, and `cpdef`. We created public C/C++ declarations
    of types and callable functions. Using these public declarations, we showed how
    Python can callback into C code. For me, reusing any Python module within native
    code is very useful and interesting. I demonstrated how I use the Python `logging`
    and `ConfigParser` modules from C code. Appreciating these simple examples, we
    will see how we can extend C/C++ projects with Python code in the next chapter.
  prefs: []
  type: TYPE_NORMAL
