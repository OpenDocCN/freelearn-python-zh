- en: 3\. Manipulating a Database with SQLAlchemy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Learning Objectives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you will be able to:'
  prefs: []
  type: TYPE_NORMAL
- en: Use the pgAdmin tool to manage a database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manipulate a database using SQLAlchemy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create database tables using Flask-Migrate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Persist data into a database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hash confidential password data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter covers using SQLAlchemy to access a database, including building
    a model, encrypting the password, ensuring each email is unique, and then saving
    the recipe data in the database.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous chapter, we were only storing our data in application memory.
    While it is easy to code that way, the data will be gone once the server restarts.
    That is obviously not ideal because we would expect the data to be persisted even
    after a server restart or application migration and suchlike. Therefore, in this
    chapter, we will talk about persisting data in a database. We will begin by installing
    the Postgres database on our local machine. Then, we will create a database using
    pgAdmin and interact with it using the **ORM** (**Object Relational Mapping**)
    package, SQLAlchemy. ORM allows us to interact with a database by means of an
    object instead of an SQL query. After that, we will define the user and recipe
    models, link them up, and use Flask-Migrate to create the corresponding tables
    in the database. Once that part is complete, we will go through exercises to understand
    the utilization of SQLAlchemy in the Python console. Lastly, we will add the resource
    for users so that new users can be created through an API.
  prefs: []
  type: TYPE_NORMAL
- en: Databases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have probably heard of the term database before. It is basically a data
    storage system. But why do we need a system to store data? Why can't we just store
    everything in a text file and save that in the folder system? Apparently, a database
    does more than just storing data. It classifies and organizes data and helps to
    store it with less redundancy. It also makes data easier to maintain, making it
    more it secure and consistent. A database is usually managed by a **database management
    system** (**DBMS**)
  prefs: []
  type: TYPE_NORMAL
- en: Database Management System
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A DBMS is an application that maneuvers and manages a database. It facilitates
    communication between the users and the database. Users can create, use, and maintain
    the database using this application.
  prefs: []
  type: TYPE_NORMAL
- en: A DBMS is crucial for data security and integrity. Popular database software
    and DBMSs include PostgreSQL, MySQL, Microsoft SQL Server, MariaDB, and Oracle
    Database. Most DBMSs use **structured query language** (**SQL**) to insert and
    extract data.
  prefs: []
  type: TYPE_NORMAL
- en: In this book, we will be using PostgreSQL as our backend database system. And
    we will also use pgAdmin, which is a tool for managing PostgreSQL. PostgreSQL
    is a powerful, open-source object-relational database management system with a
    15-year history. It is well recognized as a result of its stability and data integrity.
  prefs: []
  type: TYPE_NORMAL
- en: SQL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**SQL** is a language that was specifically invented to manage and maneuver
    data. It can be classified further into the following types:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SELECT column1, column2 FROM table WHERE conditions`, it can query against
    the table and extracts data (`column1, column2`) that satisfies a certain condition.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`INSERT`, `UPDATE`, and `DELETE`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data Control Language** (**DCL**) for controlling data access.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although we have introduced a number of different languages here, the good thing
    is that we don't need to learn all of them. In fact, we are not going to query
    our database using SQL. We will just need to code in Python, and the ORM package
    will convert our Python code to SQL behind the scenes. It's a whole lot easier
    to work with databases nowadays.
  prefs: []
  type: TYPE_NORMAL
- en: ORM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Object Relational Mapping** (**ORM**) is a programming technique that allows
    the developer to map objects in the programming language to the data model in
    a database. There is no longer any need to use SQL to interact with a database.
    The benefit of this is that developers can code in their own programming language
    and it will work on different types of databases.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The mapping works along the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: Class in Python = the table schema in the database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attributes in a class = fields in the table schema
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Objects = rows of data in the table
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SQLAlchemy is the most popular ORM in the Python community. Next, let's delves
    further by attempting to create a database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 18: Setting Up a Smilecook Database'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Most applications nowadays require a database to store and manage data. Our
    application, Smilecook, is no exception. It is a recipe-sharing platform and is
    open to the public. Obviously, it will have to store the user data and recipe
    data. In this exercise, we will create the database administrator and set up the
    database for our Smilecook application:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To start with, we will create a role. A role is simply a concept that PostgreSQL
    uses to manage access. We can consider that as a user here. *Right-click* on **PostgreSQL
    11** under **Servers**, select **Create**, and then **Login/Group Role…**:![Figure
    3.1: Selecting Login/Group Role…'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C15309_03_01.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 3.1: Selecting Login/Group Role…'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Fill in the login name, which will be used later for connecting to the database:![Figure
    3.2: Filling in the login name'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C15309_03_02.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 3.2: Filling in the login name'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Then, select **Definition** and set the password. Click **Save**:![Figure 3.3:
    Setting the password'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C15309_03_03.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 3.3: Setting the password'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Now, go to **Privileges**, and select **Yes** for **Can login?**. This will
    allow us to log in to the database using this account:![Figure 3.4: Logging in
    to the database using the account created'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C15309_03_04.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 3.4: Logging in to the database using the account created'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: '*Right-click* on **Databases**, and create a database from there:![Figure 3.5:
    Creating the database'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C15309_03_05.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 3.5: Creating the database'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Name the database `smilecook`, and set the role that we have just created to
    **Owner**. Click **Save**:![Figure 3.6: Naming the database and setting the role'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C15309_03_06.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 3.6: Naming the database and setting the role'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Now we have created the Smilecook database, but it is empty at the moment. In
    the next exercise, we will use Flask-SQLAlchemy and Flask-Migrate to create our
    database tables. You will notice that there is no SQL query involved.
  prefs: []
  type: TYPE_NORMAL
- en: Defining Our Models
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we go into the implementation, we need to first define and understand
    the fields that we will be working with. We will cover two essential models: **User**
    and **Recipe**. Models are like schemas in the database. A model is a class and
    can be instantiated. It contains attributes that correspond to fields in database
    schemas.'
  prefs: []
  type: TYPE_NORMAL
- en: '**The user model**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The user model will be mapped to the user table in the database. The fields
    and methods we defined for our user model are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`id`: The identity of a user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`username`: The username of the user. The maximum length allowed is 80 characters.
    It can''t be null and is a unique field.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`email`: The user''s email. The maximum length allowed is 200\. It can''t be
    blank and is a unique field.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`password`: The user''s password. The maximum length allowed is 200.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`is_active`: This is to indicate whether the account is activated by email.
    It is a Boolean field with a default value of `False`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`recipes`: This doesn''t create a field in the database table. This is just
    to define the relationship with the recipe model. So, subsequently, we can get
    all recipes using `user.recipes`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`created_at`: The creation time of the user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`updated_at`: The last update time of the user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We are also going to define three methods in the user model:'
  prefs: []
  type: TYPE_NORMAL
- en: '`get_by_username`: This method is used for searching the user by username.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`get_by_email`: This method is used for searching the user by email.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`save`: This is to persist the data to the database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The recipe model**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The recipe model will be mapped to the user table in the database. The fields
    we defined for our recipe model are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`id`: The identity of a recipe.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`name`: The name of the recipe. The maximum length allowed is 100 characters.
    It can''t be null.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`description`: The description of the recipe. The maximum length allowed is
    200\.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`num_of_servings`: The number of servings. This needs to be an integer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cook_time`: The cooking time in minutes. This field only accepts an integer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`directions`: The directions of the recipe. This can have a maximum length
    of 1,000.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`is_publish`: This is to indicate whether the recipe has been published. It
    is set to `False` by default.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`created_at`: The creation time of the recipe.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`updated_at`: The last update time of the recipe.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With the model designs in our mind, we are now ready to use these models in
    our next exercise. Before that, let''s also just briefly understand some of the
    key packages that we will be using. These are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Flask-SQLAlchemy: This is a very popular ORM package that allows us to access
    objects rather than database tables for data. With ORM, we do not need to rely
    on SQL anymore.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Flask-Migrate: This is a package for database migration; it works on top of
    Alembic.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Psycopg2-binary: This is the adapter for the Postgres database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Passlib: This is a password hashing library for Python.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Exercise 19: Installing Packages and Defining Models'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This exercise is designed to install the necessary packages and define the
    user and recipe models. The user and recipe models are going to be Python classes;
    there will not be any SQL coding in this exercise. We want to show you how we
    can interact with the database by simply coding in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will add the required packages in the `requirements.txt` file. If you remember,
    by putting the package name and version in `requirements.txt`, we can install
    them in the Python virtual environment by using a single `pip` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can run the following `pip install` command to install the necessary packages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The installation result will be shown onscreen:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a `Config.py` file and type in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We can set `DEBUG = True` here for debugging purposes. As regards `SQLALCHEMY_DATABASE_URI`,
    this is the path of the database. Please replace the username and password with
    the one we created for the `pgAdmin`. Also, replace the database name as well.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, create `extensions.py` under the Smilecook project and type in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create `user.py` under the folder models and type in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Replace `recipe.py` with the following code. We are adding the import `db`
    statement here and have also modified the `Recipe` class. The code related to
    `recipe_list` is still valid here, so we are retaining that part of the code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, rewrite `app.py` with the following code. We are structuring our code in
    a more proper way, making it more readable and maintainable. First, import the
    required packages at the beginning of the code file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the `create_app()` function to create the Flask app. This will invoke `register_extensions(app)`
    to initialize SQLAlchemy and set up Flask-Migrate. It will then invoke `register_resources(app)`
    to set up resource routing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, use `app = create_app()` to create the Flask app, and use `app.run()`
    to start the application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Save `app.py` and *right-click* on it to run the application. Flask will then
    be started up and run on the localhost (**127.0.0.1**) on port 5000:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.7: Flask started on localhost'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C15309_03_07.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3.7: Flask started on localhost'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We have successfully installed the necessary ORM-related packages, and defined
    the user and recipe models. Having first installed the packages, we ran the installation
    in our virtual environment. We created `config.py`, `extensions.py`, and `user.py`
    files and replaced `app.py`. Finally, we restructured our Flask app and saw how
    well it runs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 20: Using Flask-Migrate to Build a Database Upgrade Script'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Having successfully understood how to work with our two main models, user and
    recipe, we have now built the perfect foundation. The next step is execution.
    We will use Flask-Migrate to build a script to create the user and recipe tables:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following command in the Terminal to initialize our database. This
    will create a migration repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should see the following onscreen:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should now see the following new files in PyCharm:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 3.8: New folders in PyCharm'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/C15309_03_08.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 3.8: New folders in PyCharm'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Now, run the `flask db migrate` command to create the database and tables.
    There is no need for us to use SQL here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Flask-Migrate detected two objects (`user` and `recipe`) and created two corresponding
    tables for them:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, please check `/migrations/versions/a6d248ab7b23_.py` under the `versions`
    folder. This file is created by Flask-Migrate. Note that you may get a different
    revision ID here. Please review the file before you run the flask `db` upgrade
    command. That''s because, sometimes, it may not detect every change you make to
    your models:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: There are two functions in this autogenerated file; one is upgraded, and this
    is to add the new recipe and user to the table, while the other one is downgraded,
    which is to go back to the previous version.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We will then execute the `flask db upgrade` command, which will upgrade our
    database to conform with the latest specification in our models:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This command will invoke `upgrade()` to upgrade the database:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
- en: In the future, whenever we need to upgrade the database, we can just call `flask
    db migrate` and `flask db upgrade`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Check the database tables in `pgAdmin`. Now, we can see whether the tables
    have been created in the database. Go to **smilecook** >> **Schemas** >> **Tables
    to verify**:![Figure 3.9: Checking the database tables'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C15309_03_09.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 3.9: Checking the database tables'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you see the recipe and user tables in our **Smilecook** database, this means
    you have successfully created them in Python without any SQL. Isn't that cool?!
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will try our hand at database insertion. Let's look at the following
    exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 21: Applying Database Insertion'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This exercise is designed for us to test database insertion. We will first
    create a user, and then create two recipes under that user:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Import modules in the Python console. Open the Python console at the bottom
    of PyCharm and type in the following code to import the necessary classes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create our first `user` object and save that to the database by typing in the
    following code in the Python console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, check the `user` details. Please note that the ID of the user has already
    been assigned to `1`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Since the user is persisted in the database, we will verify that there:![Figure
    3.10: Verifying the user in the database'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C15309_03_10.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 3.10: Verifying the user in the database'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: 'We can see a record there in the `user` table:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.11: Record in the user table'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C15309_03_11.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 3.11: Record in the user table'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Next, we will create two recipes using the following code. One thing to note
    is that the `user_id` attribute of the recipe is set to `user.id`. This is to
    indicate that the recipe was created by the user `Jack`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will then check whether the two recipes have been created in the database:![Figure
    3.12: Checking whether the two recipes have been created'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C15309_03_12.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 3.12: Checking whether the two recipes have been created'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: 'We will search for the user with the username `jack` in the database and get
    all the recipes created by that user in their object attribute, `recipes`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will get a list of two recipes:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can display the details of the recipes using the `for` loop. We get the
    recipe name using `recipe.name`, while we get the user''s name using `recipe.user.username`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should see the following result on the screen:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You have just learned how to command your application using the Python console.
    You have just created the user and recipe models and saved them in the database.
    The entire process is SQL-free, as you can see. Let's do an activity to reinforce
    your knowledge.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 5: Creating a User and a Recipe'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this activity, we will test our APIs by running a few more test cases. We
    want to create a new user, `Peter`, and create two recipes under him in the database.
    Let''s see if you know how to write the code for that in the Python interactive
    console:'
  prefs: []
  type: TYPE_NORMAL
- en: Import the `User` and `Recipe` classes and create the Flask app using the Python
    console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new user, `Peter`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create two recipes and assign `Peter` as the author.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 302.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If you can see that the data has successfully been created in the database,
    congratulations – you already know how to use Python console to interact with
    the database! Next, we will implement a user registration feature.
  prefs: []
  type: TYPE_NORMAL
- en: Password Hashing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Hashing is a one-way mathematical function. It requires little computing power
    to convert a plaintext string to its hash value (hashes). However, it will require
    a huge amount of computing power to retrieve the original string from the hash
    value (it''s almost impossible). Therefore, we call it a one-way function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.13: Workings of the hash function'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C15309_03_13.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 3.13: Workings of the hash function'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: With this property, a hash function is perfect for a hashing password. We will
    hash the user's password into hashes before we save it to the database so that
    it is unrecognizable and irreversible. And next time, when the user logs in, what
    the platform does is to convert the input the password to its hash value, and
    then compare that with the hash value stored in the database. That way, we can
    perform a password comparison without leaking the sensitive password information
    to others.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 22: Implement the User Registration Feature and Hash the User''s Password'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we will work on the user registration feature. We will also
    implement two functions for hashing the user''s password:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create `utils.py` under the application project folder and type in the following
    code. The code is to hash the password. We do not want to store plaintext passwords
    in our database on account of security concerns. Therefore, we will use the `passlib`
    modules for hashing. We defined two methods here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `hash_password(password)` function is for password hashing and `check_password(password,
    hashed)` is for user authentication. It hashes the user-input password and compares
    that with the one we saved in the database.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create `user.py` in the `resources` folder, and then type in the following
    code. We will first import the necessary modules and implement the `Post` method
    in `UserListResource`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When there is a client request hitting `http://localhost/users` with the HTTP
    `POST` method, the application will get the JSON formatted data in the request.
    There should be a username, email, and password.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Check whether the user already exists in the database by means of `User.get_by_user(username)`.
    If such an entry is found, that means the user has already registered and we will
    simply return an error message. We will also perform the same check on `email`
    as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once all the validations are passed, go ahead and create the user in the database.
    The password will be hashed, and the user object will be created. The user object
    will then be saved to the database using `user.save()`. Finally, the user details
    are returned in JSON format, with an `HTTP` status code of `201`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add user resource routing to `app.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Replace `from models.user import User` in `app.py` with `from resources.user
    import UserListResource`. The user model is already imported in `resources.user`,
    so there is no need to reimport that again. Please add `api.add_resource(UserListResource,
    '/users')` to the code as well.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run the application. Flask will then be started up and run on localhost (`127.0.0.1`)
    on port `5000`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 3.14: Flask started on localhost'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/C15309_03_07.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 3.14: Flask started on localhost'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: So, we have just finished the password hashing exercise. From now on, whenever
    there is a new user registered in our Smilecook application, their password will
    be hashed and stored safely in the database. Let's test and see whether that is
    the case in our next exercise.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The reason why we are not discussing the recipe resource here is that there
    will be an author ID in the recipe. The author ID will be a foreign key that links
    to the user model. We will talk about the user login function in our next chapter.
    Only after that can we get the user ID and finish the recipe resource.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 23: Testing the Application in Postman'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this exercise, we are going to test the application in Postman. We will
    first register a user account and make sure the user data is stored in the database.
    We also need to verify that the password is hashed. Having created a user, now
    let''s test our API endpoint here:'
  prefs: []
  type: TYPE_NORMAL
- en: Click on the **Collections** tab in Postman.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new collection, and name it `User`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new request, `UserList`, under that collection. You can do this by
    clicking on the `User` collection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Edit the `POST`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type in `http://localhost:5000/users` in the URL field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to the **Body** Tab, select **raw** as the datatype, and then select **JSON
    (application/json)** as the data format.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Insert the following user details and then save.:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Click **Send**. The result can be seen in the following screenshot:![Figure
    3.15: Creating a user with an existing username'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C15309_03_15.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 3.15: Creating a user with an existing username'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: You will then see the following data returned; the HTTP status is **400 BAD
    REQUEST**. We can also see the error message in the **Body** field showing that
    the username has been registered.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create another user with the details shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The result can be seen in the following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 3.16: Creating another user'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/C15309_03_16.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 3.16: Creating another user'
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: Now, the second account has been successfully created.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Check the data in the database as follows:![Figure 3.17: Checking the data
    in the database'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C15309_03_17.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 3.17: Checking the data in the database'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Now, we can see a new user record created in the database table. And you can
    see that the password is hashed.
  prefs: []
  type: TYPE_NORMAL
- en: By doing this testing exercise, we can be assured that our user registration
    workflow is functioning well. And, most importantly, user passwords are kept as
    the hash value in the database. That is a much safer way to store a password,
    as even the database administrator can't see it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 6: Upgrading and Downgrading a Database'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this activity, we will upgrade and downgrade our database to simulate a
    scenario where we need to add an attribute under the `user` class, but later we
    change our mind and need to remove it. The following are the high-level steps
    that we need to perform in order to complete this activity:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new attribute to the `user` class. This attribute should be called `bio`
    and will be a string that represents information about the user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the `flask db migrate` command to create the database and tables.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, check `/migrations/versions/6971bd62ec60_.py` under the `versions` folder.
    This file is created by Flask-Migrate.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Execute the `flask db upgrade` command to upgrade our database to conform with
    the latest specification in our models.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check whether the new field is created in the database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the `downgrade` command to remove the new field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check whether the field has been removed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H4
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 303.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If you see that the new field has been removed, that means you have successfully
    downgraded the database in Python without writing any SQL. And don't forget to
    delete the user model's bio attribute in models/user.py, also delete the script
    that we created which is `a6d248ab7b23.py` in migrations/versions folder. You
    have just learned a very useful skill that you will probably need frequently in
    the future. One tip for you is that you should back up your database prior to
    any database schema update. This is to ensure the data won't get lost.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we built the Postgres database locally and learned how to use
    the pgAdmin tool to manage it. Then, through the SQLAlchemy module, we developed
    an object library to manipulate the database. This is much easier than using SQL
    syntax directly. And, as long as we define the relationship between models, we
    can easily get the information we want. This results in higher code readability,
    fewer lines of code, and the elimination of repetitive SQL. We then use Flask-Migrate
    to build all the data tables. Then, when we migrate the database in the future,
    we simply need two commands – `flask db migrate` and `flask db upgrade`; it's
    simple and easy. Although Flask-Migrate can help us to set up and migrate a database
    more easily, in a production environment, performing this kind of migration still
    requires extra due diligence. We should always back up the database to safeguard
    our precious data.
  prefs: []
  type: TYPE_NORMAL
- en: During development, we should frequently test our code to make sure it is behaving
    as expected. We shouldn't wait till the end to perform big-bang testing. We can
    unit test our functions and API endpoints, once they are complete. Using the Python
    console to perform this kind of simple test is recommended. Iteratively testing
    our application can also foster the best programming practice. This forces us
    to think about how we can structure our code in an elegant manner and avoid technical
    debt accumulation.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we created an API for user registration. In the next chapter, we will
    work on user login and recipe creation for authenticated users.
  prefs: []
  type: TYPE_NORMAL
