<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Threads and Networking</h1>
                </header>
            
            <article>
                
<p>In this chapter, we will extend the functionality of our Python GUI using threads, queues, and network connections.</p>
<div class="packt_infobox">A <kbd>tkinter</kbd> GUI is a single-threaded application. Every function that involves sleep or wait time has to be called in a separate thread; otherwise, the <kbd>tkinter</kbd> GUI freezes.</div>
<p>When we run our Python GUI, in Windows Task Manager, we can see that a new <kbd>python.exe</kbd> process has been launched. When we give our Python GUI a <kbd>.pyw</kbd> extension, then the process created will be <kbd>python.pyw</kbd>, which can be seen in Task Manager as well.</p>
<p>When a process is created, the process automatically creates a main thread to run our application. This is called a <em>single-threaded application</em>.</p>
<div class="packt_infobox"><span>Single-threaded processes contain the execution of instructions in a single sequence. In other words, one command is processed at a time.</span></div>
<p>For our Python GUI, a single-threaded application will lead to our GUI becoming frozen as soon as we call a longer-running task, such as clicking a button that has a sleep time of a few seconds. In order to keep our GUI responsive, we have to use <em>multithreading</em>, and this is what we will study in this chapter.</p>
<div class="packt_tip">Our GUI runs in a single thread. Knowing how to use multiple threads is an important concept for GUI development.</div>
<p>We can also create multiple processes by creating multiple instances of our Python GUI, as can be seen in Task Manager, where we can see several <kbd>python.exe</kbd> processes running at the same time.</p>
<div class="packt_infobox">Processes are isolated from each other by design and do not share common data. In order to communicate between separate processes, we have to use <strong>Inter-Process Communication</strong> (<strong>IPC</strong>), which is an advanced technique. Threads, on the other hand, do share common data, code, and files, which makes communication between threads within the same process much easier than when using IPC. A great expl<span>anation of threads can be found at</span> <span class="URLPACKT"><a href="https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/4_Threads.html">https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSyste</a></span><span class="URLPACKT"><a href="https://www.cs.uic.edu/~jbell/CourseNotes/OperatingSystems/4_Threads.html">ms/4_Threads.html</a>.</span></div>
<p>In this chapter, we will learn how to keep our Python GUI responsive and keep it from freezing. Having this knowledge is essential when creating working GUIs, and knowing how to create threads and use queues increases your programming skills.</p>
<p>We will also use TCP/IP to connect our GUI to a network. In addition to that, we will read a URL web page, which is also a networking component on the internet.</p>
<p>Here is the overview of Python modules for this chapter:</p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="Images/4b53775b-8917-4182-a184-de7f64017f2d.png" style="width:17.33em;height:24.25em;" width="312" height="436"/></div>
<p>We will create threads, queues, and TCP/IP sockets using Python 3.7 or later.</p>
<p>To sum it up, we will cover the following recipes:</p>
<ul>
<li>How to create multiple threads</li>
<li>Starting a thread</li>
<li>Stopping a thread</li>
<li>How to use queues</li>
<li>Passing queues among different modules</li>
<li>Using dialog widgets to copy files to your network</li>
<li>Using TCP/IP to communicate via networks</li>
<li>Using <kbd>urlopen</kbd> to read data from websites</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to create multiple threads</h1>
                </header>
            
            <article>
                
<p>Multiple threads are necessary in order to keep our GUI responsive. Without running of our GUI program using multiple threads, our application will freeze and possibly crash.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Multiple threads run within the same computer process memory space. There is no need for IPC, which would complicate our code. In this recipe, we will avoid IPC by using threads.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it…</h1>
                </header>
            
            <article>
                
<p>First, we will increase the size of our <kbd>ScrolledText</kbd> widget, making it larger. Let's increase <kbd>scrol_w</kbd> to <kbd>40</kbd> and <kbd>scrol_h</kbd> to <kbd>10</kbd>.</p>
<p>We will start by using the latest code from <a href="42e25c40-ea12-4805-aa6c-2303e6ea36d0.xhtml">Chapter 5</a>, <em><span class="item-title">Matplotlib Charts</span></em>:</p>
<ol>
<li>Open <kbd>Ch04_Code.GUI_OOP_class_imported_tooltip.py</kbd> and save it as <kbd><span>GUI_multiple_threads.py</span></kbd>.</li>
</ol>
<p> </p>
<ol start="2">
<li>Make the changes shown in the following code:</li>
</ol>
<pre style="padding-left: 60px"># Using a scrolled Text control <br/>scrol_w = 40; scrol_h = 10     # increase sizes<br/>self.scrol = scrolledtext.ScrolledText(mighty, width=scrol_w, <br/>height=scrol_h, wrap=tk.WORD)<br/>self.scrol.grid(column=0, row=3, sticky='WE', columnspan=3)</pre>
<ol start="3">
<li>Modify <kbd>self.spin.grid</kbd> to use <kbd>sticky</kbd>:</li>
</ol>
<pre style="padding-left: 60px"># Adding a Spinbox widget<br/>self.spin = Spinbox(mighty, values=(1, 2, 4, 42, 100), width=5, <br/>bd=9, command=self._spin) <br/>self.spin.grid(column=0, row=2, sticky='W') # align left, use sticky</pre>
<ol start="4">
<li>Increase the <kbd><span>width</span></kbd> size of <kbd>Entry</kbd>:</li>
</ol>
<pre style="padding-left: 60px"># Adding a Textbox Entry widget<br/>self.name = tk.StringVar()<br/>self.name_entered = ttk.Entry(mighty, width=24, <br/># increase width<br/>textvariable=self.name)<br/>self.name_entered.grid(column=0, row=1, sticky='W')</pre>
<ol start="5">
<li><span>Increase the</span> <kbd>width</kbd> size of <kbd>Combobox</kbd> to <kbd>14</kbd>:</li>
</ol>
<pre style="padding-left: 60px">ttk.Label(mighty, text="Choose a number:").grid(column=1, row=0)<br/>number = tk.StringVar()<br/>self.number_chosen = ttk.Combobox(mighty, width=14, <br/># increase width<br/>textvariable=number, state='readonly')<br/>self.number_chosen['values'] = (1, 2, 4, 42, 100)<br/>self.number_chosen.grid(column=1, row=1)<br/>self.number_chosen.current(0)</pre>
<ol start="6">
<li>Run the code and observe the output:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="Images/e5924910-7719-43f2-9db4-e1a0de6b3c1a.png" style="width:27.42em;height:19.50em;" width="378" height="269"/></p>
<ol start="7">
<li>Import <kbd>Thread</kbd> from <span>Python's</span> built-in <kbd>threading</kbd> module:</li>
</ol>
<pre style="padding-left: 60px">#======================<br/># imports<br/>#======================<br/>import tkinter as tk<br/>...<br/>from threading import Thread</pre>
<ol start="8">
<li>Add the <kbd>method_in_a_thread</kbd> <span>method:</span></li>
</ol>
<pre style="padding-left: 60px">class OOP(): <br/>    def method_in_a_thread(self):<br/>        print('Hi, how are you?')</pre>
<ol start="9">
<li>Create a thread as follows:</li>
</ol>
<pre style="padding-left: 60px">#======================<br/># Start GUI<br/>#======================<br/>oop = OOP()<br/><br/># Running methods in Threads<br/>run_thread = Thread(target=oop.method_in_a_thread)  # create Thread<br/><br/>oop.win.mainloop()</pre>
<ol start="10">
<li>Set a breakpoint or use a <kbd>print</kbd> statement for the <kbd>run_thread</kbd> variable:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="aligncenter size-full image-border" src="Images/1cbec86d-a956-41d1-a024-04d66060b70f.png" width="477" height="73"/></div>
<p>Let's go behind the scenes to understand the code better.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works…</h1>
                </header>
            
            <article>
                
<p>After our first changes in <em>step 2</em> to <span><kbd>GUI_multiple_threads.py</kbd>, w</span>hen we run the resulting GUI, the <kbd>Spinbox</kbd> widget is center-aligned in relation to the <kbd>Entry</kbd> widget above it, which does not look good. We'll change this by left-aligning the widget. We add <kbd>sticky='W'</kbd> to the <kbd>grid</kbd> control to left-align the <kbd>Spinbox</kbd> widget.</p>
<p>The GUI could still look better, so next, we increase the size of the <kbd>Entry</kbd> widget to get a more balanced GUI layout. After that, we also increase the <kbd>Combobox</kbd> widget. <span>Running the modified and improved code results in a larger GUI, which we will use for this recipe and for the following recipes.</span></p>
<p><span>In order to create and use threads in Python, we have to import the</span> <kbd>Thread</kbd> <span>class from the</span> <kbd>threading</kbd> <span>module.</span> <span>After adding the <kbd>method_in_a_thread</kbd> method, we can now call our threaded method in the code, sav</span><span>ing the instance in a variable called <kbd>run_thread</kbd>.</span></p>
<p>Now we have a method that is threaded, but when we run the code, nothing gets printed to the console!</p>
<div class="packt_infobox">We have to start the thread first before it can run, and the next recipe will show us how to do this.</div>
<p>However, setting a breakpoint after the GUI main event loop proves that we did indeed create a thread object, as can be seen in the Eclipse IDE debugger.</p>
<p>In this recipe, we prepared our GUI to use threads by first increasing the GUI size so we can see the results printed to the <kbd>ScrolledText</kbd> widget in a better way. We then imported the <kbd>Thread</kbd> class from the Python <kbd>threading</kbd> module. Next, we created a method that we call in a thread from within our GUI.</p>
<p class="mce-root"/>
<p><span>Let's move on to the next recipe.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Starting a thread</h1>
                </header>
            
            <article>
                
<p>This recipe will show us how to start a thread. It will also demonstrate why threads are necessary to keep our GUI responsive during long-running tasks.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Let's first see what happens when we call a function or a method of our GUI that has <kbd>sleep</kbd> associated with it without using threads.</p>
<div class="packt_infobox">We are using <kbd>sleep</kbd> here to simulate a real-world application that might have to wait for a web server or database to respond, a large file transfer, or complex computations to complete its task. <kbd>sleep</kbd> is a very realistic placeholder and shows the principle involved.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it…</h1>
                </header>
            
            <article>
                
<p>Adding a loop into our button callback method with some <kbd>sleep</kbd> time results in our GUI becoming unresponsive and, when we try to close the GUI, things get even worse.</p>
<ol>
<li>Open <span><kbd>GUI_multiple_threads.py</kbd> and save it as</span> <kbd>GUI_multiple_threads_sleep_freeze.py</kbd>.</li>
<li>Make the following changes to the code:</li>
</ol>
<pre style="padding-left: 60px"># Button callback<br/>def click_me(self): <br/>    self.action.configure(text='Hello ' + self.name.get() + ' ' <br/>    + self.number_chosen.get())<br/>    # Non-threaded code with sleep freezes the GUI<br/>    for idx in range(10):<br/>        sleep(5)<br/>        self.scrol.insert(tk.INSERT, str(idx) + 'n')</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<ol start="3">
<li>Running the preceding code results in the following screenshot:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="Images/ecfd95d7-7a1a-47a7-92cf-9c6a281ae72e.png" style="width:30.75em;height:21.00em;" width="379" height="258"/></p>
<ol start="4">
<li>Let's move the creation of the thread into its own method and then call this method from the button callback method:
<ol>
<li>Open <kbd><span>GUI_multiple_threads_sleep_freeze.py</span></kbd> <span>and save it as <kbd>GUI_multiple_threads_starting_a_thread.py</kbd></span>.</li>
<li>Add the following code:</li>
</ol>
</li>
</ol>
<pre style="padding-left: 120px"># Running methods in Threads<br/>def create_thread(self):<br/>    self.run_thread = Thread(target=self.method_in_a_thread) <br/>    self.run_thread.start()              # start the thread<br/><br/># Button callback<br/>def click_me(self): <br/>    self.action.configure(text='Hello ' + self.name.get())<br/>    self.create_thread()</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<ol start="5">
<li>Run the code and observe the output. Running the code now no longer freezes our GUI:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full image-border" src="Images/6fd3862f-eef9-49e0-b897-e56fc308af42.png" style="width:26.92em;height:30.42em;" width="507" height="574"/></div>
<p style="padding-left: 60px">We can print the instance of the thread by following these steps:</p>
<ul>
<li style="list-style-type: none">
<ol>
<li>Open <kbd>GUI_multiple_threads_starting_a_thread.py</kbd><span>.</span></li>
<li>Add a <kbd>print</kbd> statement to the code:</li>
</ol>
</li>
</ul>
<pre style="padding-left: 120px"># Running methods in Threads<br/>def create_thread(self):<br/>    self.run_thread = <br/>    Thread(target=self.method_in_a_thread) <br/>    self.run_thread.start()              # start the thread<br/>    print(self.run_thread)</pre>
<ol start="6">
<li>Clicking the button now creates the following printout:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="aligncenter size-full image-border" src="Images/7c5a3578-bcb5-4797-8672-31e2550089fe.png" style="width:17.00em;height:5.50em;" width="285" height="92"/></div>
<ol start="7">
<li>On clicking the button several times, you get the following output:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="aligncenter size-full image-border" src="Images/4b267cee-2239-4678-9b00-28ccabc349b2.png" style="width:16.75em;height:9.75em;" width="286" height="167"/></div>
<ol start="8">
<li>Move the code with <kbd>sleep</kbd> into a loop in the <kbd>method_in_a_thread</kbd> method:</li>
</ol>
<pre style="padding-left: 60px">def method_in_a_thread(self):<br/>    print('Hi, how are you?')<br/>    for idx in range(10):<br/>        sleep(5)<br/>        self.scrol.insert(tk.INSERT, str(idx) + 'n')</pre>
<ol start="9">
<li>Click the button, change tabs, and then click on other widgets:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="Images/ce438601-2e1f-4ab8-b21f-2b5b49d6aaa4.png" style="width:19.75em;height:16.08em;" width="379" height="308"/></p>
<p><span>Let's go behind the scenes to understand the code better.</span></p>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works…</h1>
                </header>
            
            <article>
                
<p>In <span><kbd>GUI_multiple_threads_sleep_freeze.py</kbd>, we added a <kbd>sleep</kbd> statement and noticed how our GUI became unresponsive.</span></p>
<div class="packt_infobox">If we wait long enough, the method will eventually complete, but during this time, none of our GUI widgets respond to click events. We solve this problem by using threads.</div>
<p class="mce-root">Unlike regular Python functions and methods, we have to <kbd>start</kbd> a method that will be run in its own thread! This is what we did next in <span><kbd>GUI_multiple_threads_starting_a_thread.py</kbd></span>. Clicking the button now results in the <kbd>create_thread</kbd> method being called, which, in turn, calls the <kbd>method_in_a_thread</kbd> method.</p>
<p>First, we create a thread and target it at a method. Next, we start the thread that runs the targeted method in a new thread. <span>Running the code now no longer freezes our GUI.</span></p>
<div class="packt_infobox"><span>The GUI itself runs in its own thread, which is the main thread of the application.</span></div>
<p><span>When we click the button several times, we can see that each thread gets assigned a unique name and ID.</span> <span>After moving the code with</span> <kbd>sleep</kbd> <span>into a loop in the</span> <kbd>method_in_a_thread</kbd> <span>method, we are able to verify that threads really do solve our problem.</span></p>
<p><span>When clicking the button, while the numbers are being printed into the</span> <kbd>ScrolledText</kbd> <span>widget with a five-second delay, we can click around anywhere in our GUI, switch tabs, and so on. Our GUI has become responsive again because we are using threads!</span></p>
<p>In this recipe, we called the methods of our GUI class in their own threads and learned that we have to start the threads. Otherwise, the thread gets created but just sits there waiting for us to run its target method. Also, we noticed that each thread gets assigned a unique name and ID. And finally, we simulated long-running tasks by inserting a <kbd>sleep</kbd> statement into our code, which showed us that threads can indeed solve our problem.</p>
<p><span>Let's move on to the next recipe.</span></p>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Stopping a thread</h1>
                </header>
            
            <article>
                
<p>We have to start a thread to actually make it do something by calling the <kbd>start()</kbd> method so, intuitively, we expect there to be a matching <kbd>stop()</kbd> method, but there is no such thing. In this recipe, we will learn how to run a thread as a background task, which is called a <em>daemon</em>. When closing the main thread, which is our GUI, all daemons will automatically be stopped as well.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>When we call methods in a thread, we can also pass arguments and keyword arguments to the method. We start this recipe by doing exactly that. We will start with the code from the previous recipe.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it…</h1>
                </header>
            
            <article>
                
<p>By adding <kbd>args=[8]</kbd> to the thread constructor and modifying the targeted method to expect arguments, we can pass arguments to the threaded methods. The parameter to <kbd>args</kbd> has to be a sequence, so we will wrap our number in a Python list. Let's go through the process:</p>
<ol>
<li>Open <kbd>GUI_multiple_threads_starting_a_thread.<span>py</span></kbd> and save it as <span><kbd>GUI_multiple_threads_stopping_a_thread.py</kbd></span>.</li>
<li><span>Change</span> <span><kbd>run_thread</kbd> to</span> <span><kbd>self.run_thread</kbd> and <kbd>arg=[8]</kbd></span><span>:</span></li>
</ol>
<pre style="padding-left: 60px"># Running methods in Threads <br/>def create_thread(self):<br/>    self.run_thread = Thread(target=self.method_in_a_thread, <br/>    args=[8]) <br/>    self.run_thread.start() <br/>    print(self.run_thread)<br/>print('createThread():', self.run_thread.isAlive())</pre>
<ol start="3">
<li>Add <kbd>num_of_loops</kbd> as a new argument to <kbd>method_in_a_thread</kbd>:</li>
</ol>
<pre style="padding-left: 60px">def method_in_a_thread(self, num_of_loops=10): <br/>    for idx in range(num_of_loops): <br/>        sleep(1) <br/>        self.scrol.insert(tk.INSERT, str(idx) + 'n') <br/>    sleep(1) <br/>    print('method_in_a_thread():', self.run_thread.isAlive())</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<ol start="4">
<li>Run the code, click the button, and then close the GUI:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="Images/21acf656-06a6-4577-b10f-51817b202b84.png" style="width:39.75em;height:33.50em;" width="605" height="510"/></p>
<ol start="5">
<li>Add <kbd>self.run_thread.setDaemon(True)</kbd> to the code:</li>
</ol>
<pre style="padding-left: 60px"># Running methods in Threads <br/>def create_thread(self):<br/>    self.run_thread = Thread(target=self.method_in_a_thread, <br/>    args=[8]) <br/>    self.run_thread.setDaemon(True)         # &lt;=== add this line<br/>    self.run_thread.start()<br/>    print(self.run_thread)</pre>
<p class="mce-root"/>
<ol start="6">
<li>Run the modified code, click the button, and then close the GUI:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="Images/3b911aad-f77e-43d9-9f06-1c182121ef82.png" style="width:39.25em;height:16.75em;" width="590" height="252"/></p>
<p>Let's now see how the recipe works!</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works…</h1>
                </header>
            
            <article>
                
<p>In the following code, <kbd>run_thread</kbd> is a local variable, which we only access within the scope of the method inside which we created <kbd>run_thread</kbd>:</p>
<pre># Running methods in Threads <br/>def create_thread(self):<br/>    run_thread = Thread(target=self.method_in_a_thread, args=[8]) <br/>    run_thread.start()</pre>
<p>By turning the local variable into a class instance attribute, we can then check if the thread is still running by calling <kbd>isAlive</kbd> on it from another method. In <kbd><span>GUI_multiple_threads_stopping_a_thread.py</span></kbd><span>, we have elevated our local</span> <kbd>run_thread</kbd> <span>variable to an instance attribute of our class. This enables us to access the</span> <kbd>self.run_thread</kbd> <span>variable from any method in our class.</span></p>
<p><span>When we click the button and then exit the GUI before the thread has finished,</span> <span>we get a</span> runtime error.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>Threads are expected to finish their assigned task, so when we close the GUI before the thread has completed, according to the error, Python tells us that the thread we started is not in the main event loop. We can solve this by turning the thread into a <em>daemon</em>, which will then execute as a background task. What this gives us is that as soon as we close our GUI, which is our main thread that starts other threads, the daemon threads will cleanly exit. We do this by calling the <kbd>setDaemon(True)</kbd> method on the thread before we start the thread.</p>
<p><span>When we now click the button and exit our GUI before the thread has completed its assigned task, we no longer get any errors.</span> While there is a <kbd>start</kbd> method to make threads run, surprisingly there isn't really an equivalent stop method.</p>
<p>In this recipe, we are running a method in a thread, which prints numbers to our <kbd>ScrolledText</kbd> widget. When we exit our GUI, we are no longer interested in the thread that used to print to our widget, so by turning the thread into a <em>daemon</em>, we can exit our GUI cleanly.</p>
<p><span>Let's move on to the next recipe.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to use queues</h1>
                </header>
            
            <article>
                
<p>A Python queue is a data structure that implements the <strong>First In, First Out</strong> (<strong>FIFO</strong>) paradigm, basically working like a pipe. You shovel something into the pipe on one side and it falls out on the other side of the pipe.</p>
<p>The main difference between this queue shoveling and shoveling mud into physical pipes is that, in Python queues, things do not get mixed up. You put one unit in, and that unit comes back out on the other side. Next, you place another unit in (say, for example, an instance of a class), and this entire unit will come back out on the other end as one piece. It comes back out at the other end in the exact order we inserted code into the queue.</p>
<div class="packt_infobox">A queue is not a stack in which we push and pop data. A stack is a <strong>Last In, First Out</strong> (<strong>LIFO</strong>) data structure.</div>
<p>Queues are containers that hold data being fed into the queue from potentially different data sources. We can have different clients providing data to the queue whenever those clients have data available. Whichever client is ready to send data to our queue sends it, and we can then display this data in a widget or send it forward to other modules.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Using multiple threads to complete assigned tasks in a queue is very useful when receiving the final results of processing and displaying them. The data is inserted at one end of the queue and then comes out of the other end in an ordered fashion, FIFO.</p>
<p>Our GUI might have five different button widgets such that each kicks off a different task that we want to display in our GUI in a widget (for example, a <kbd>ScrolledText</kbd> widget). These five different tasks take a different amount of time to complete.</p>
<p>Whenever a task has completed, we immediately need to know this and display this information in our GUI. By creating a shared Python queue and having the five tasks write their results to this queue, we can display the result of whichever task has been completed immediately using the FIFO approach.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>As our GUI is ever-increasing in its functionality and usefulness, it starts to talk to networks, processes, and websites, and will eventually have to wait for data to be made available for the GUI to display.</p>
<p>Creating queues in Python solves the problem of waiting for data to be displayed inside our GUI.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it…</h1>
                </header>
            
            <article>
                
<p>In order to create queues in Python, we have to import the <kbd>Queue</kbd> class from the <kbd>queue</kbd> module. Add the following statement toward the top of the GUI module:</p>
<ol>
<li>Open <kbd>GUI_multiple_threads_starting_a_thread.<span>py</span></kbd> and save it as <kbd><span>GUI_queues.py</span></kbd>.</li>
<li>Make the following changes to the code:</li>
</ol>
<pre style="padding-left: 60px">from threading import Thread <br/>from queue import Queue</pre>
<ol start="3">
<li>Add the following method:</li>
</ol>
<pre style="padding-left: 60px">def use_queues(self): <br/>    gui_queue = Queue()        # create queue instance <br/>    print(gui_queue)           # print instance</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<ol start="4">
<li>Modify the <kbd>click_me</kbd> method:</li>
</ol>
<pre style="padding-left: 60px"># Button callback<br/>def click_me(self): <br/>    self.action.configure(text='Hello ' + self.name.get())<br/>    self.create_thread()<br/>    self.use_queues()</pre>
<ol start="5">
<li>Run the preceding code and observe the output as illustrated in the following screenshot:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="aligncenter size-full image-border" src="Images/e872e17c-7ae7-4d25-b4f1-2daef454f306.png" style="width:37.75em;height:8.92em;" width="590" height="140"/></div>
<ol start="6">
<li>Modify <kbd>use_queues</kbd> to use <kbd>put</kbd> and <kbd>get</kbd>:</li>
</ol>
<pre style="padding-left: 60px"># Create Queue instance   <br/>def use_queues(self):<br/>    gui_queue = Queue() <br/>    print(gui_queue)<br/>    gui_queue.put('Message from a queue') <br/>    print(gui_queue.get())</pre>
<ol start="7">
<li>Run the preceding code <span>and observe the output, as illustrated</span> <span>in the following screenshot</span>:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="aligncenter size-full image-border" src="Images/eec7e109-b773-429b-b631-d15519251f45.png" style="width:25.58em;height:16.58em;" width="363" height="235"/></div>
<ol start="8">
<li>Write a loop to place many messages into <kbd>Queue</kbd>:</li>
</ol>
<pre style="padding-left: 60px"># Create Queue instance <br/>def use_queues(self):<br/>    gui_queue = Queue() <br/>    print(gui_queue)<br/>    for idx in range(10):<br/>        gui_queue.put('Message from a queue: ' + str(idx))<br/>    print(gui_queue.get())</pre>
<ol start="9">
<li>Run the preceding code:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="aligncenter size-full image-border" src="Images/03a2a616-a142-4804-be58-29d29dcffc44.png" style="width:37.00em;height:5.83em;" width="650" height="103"/></div>
<ol start="10">
<li>Add a <kbd>while</kbd> loop:</li>
</ol>
<pre style="padding-left: 60px"># Create Queue instance <br/>def use_queues(self):<br/>    gui_queue = Queue() <br/>    print(gui_queue)<br/>    for idx in range(10):<br/>        gui_queue.put('Message from a queue: ' + str(idx))<br/>    while True: <br/>        print(gui_queue.get())</pre>
<ol start="11">
<li>Run the preceding code to see the following result:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="aligncenter size-full image-border" src="Images/dc9c5e41-1042-480e-ac21-ba99b95023c4.png" style="width:27.00em;height:20.33em;" width="586" height="440"/></div>
<p>Now, let's consider the scenario of the endless loop:</p>
<ol>
<li>Open <kbd><span>GUI_queues.py</span></kbd> and save it as <kbd><span>GUI_queues_put_get_loop_endless_threaded.py</span></kbd>.</li>
<li>Make the following changes to start <kbd>self.run_thread</kbd> as a background daemon thread:</li>
</ol>
<pre style="padding-left: 60px"># Running methods in Threads <br/>def create_thread(self):<br/>    self.run_thread = Thread(target=self.method_in_a_thread, <br/>    args=[8])                    <br/>    self.run_thread.setDaemon(True) <br/>    self.run_thread.start()<br/><br/>    # start queue in its own thread<br/>    write_thread = Thread(target=self.use_queues, daemon=True)<br/>    write_thread.start()</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<ol start="3">
<li><span>In the</span> <kbd>click_me</kbd> <span>method, we comment out</span> <kbd>self.use_queues()</kbd> <span>and now call</span> <kbd>self.create_thread()</kbd> <span>instead:</span></li>
</ol>
<pre style="padding-left: 60px"># Button callback<br/>def click_me(self): <br/>    self.action.configure(text='Hello ' + self.name.get())<br/>    self.create_thread()<br/>    # now started as a thread in create_thread()<br/>    # self.use_queues()</pre>
<ol start="4">
<li>Run the code to see the following result:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="aligncenter size-full image-border" src="Images/bcc41345-1ff2-4803-9cbb-7f79f277af56.png" style="width:34.25em;height:29.08em;" width="590" height="501"/></div>
<p><span>Let's go behind the scenes to understand the code better.</span></p>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works…</h1>
                </header>
            
            <article>
                
<p>In <span><kbd>GUI_queues.py</kbd>, we first add <kbd>import</kbd> statements and then create a new method to create <kbd>Queue</kbd>.</span> <span>We call the method within our button click event.</span></p>
<div class="packt_infobox"><span>In the code, we create a local</span> <kbd>Queue</kbd> <span>instance that is only accessible within this method. If we wish to access this queue from other places, we have to turn it into an instance attribute of our class by using the</span> <kbd>self</kbd> <span>keyword, which binds the local variable to the entire class, making it available from any other method within our class. In Python, we often create class instance variables in the</span> <kbd>__init__(self)</kbd> <span>method, but Python is very pragmatic and enables us to create those attributes anywhere in the code.</span></div>
<p><span>Now we have an instance of a queue. We can see that this works by printing it out.</span></p>
<p><span>In order to put the data into the queue, we use the</span> <kbd>put</kbd> <span>command. In order to get the data out of the queue, we use the</span> <kbd>get</kbd> <span>command.</span></p>
<p><span>Running the code results in the message first being placed in</span> <kbd>Queue</kbd><span>, then being taken out of</span> <kbd>Queue</kbd><span>, and then being printed to the console.</span> <span>We have placed 10 messages into</span> <kbd>Queue</kbd><span>, but we are only getting the first one out. The other messages are still inside</span> <kbd>Queue</kbd><span>, waiting to be taken out in a FIFO fashion.</span> <span>In order to get all the messages that have been placed into</span> <kbd>Queue</kbd> <span>out, we can create an endless loop.</span></p>
<div class="packt_infobox">While this code works, unfortunately, it freezes our GUI. In order to fix this, we have to call the method in its own thread, as we did in the previous recipes.</div>
<p>We do this in <span><kbd>GUI_queues_put_get_loop_endless_threaded.py</kbd>.</span></p>
<p><span>When we now click the button, the GUI no longer freezes and the code works.</span> We created <kbd>Queue</kbd> and placed messages into one side of <kbd>Queue</kbd> in a FIFO fashion. We got the messages out of <kbd>Queue</kbd> and then printed them to the console (<kbd>stdout</kbd>). We realized that we have to call the method in its own thread <span>because, otherwise, our GUI might freeze.</span></p>
<p><span>Let's move on to the next recipe.</span></p>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Passing queues among different modules</h1>
                </header>
            
            <article>
                
<p>In this recipe, we will pass queues around different modules. As our GUI code increases in complexity, we want to separate the GUI components from the business logic, separating them out into different modules. Modularization allows us to <span>reuse</span> code and also makes the code more readable.</p>
<p>Once the data to be displayed in our GUI comes from different data sources, we will face latency issues, which is what queues solve. By passing instances of <kbd>Queue</kbd> among different Python modules, we are separating the different concerns of the modules' functionalities.</p>
<div class="packt_infobox">The GUI code ideally would only be concerned with creating and displaying widgets and data.<br/>
<br/>
The business logic modules' job is only to do the business logic and supply the resulting data to the GUI.</div>
<p>We have to combine the two elements, ideally using as few relationships among the different modules as possible, reducing code interdependence.</p>
<div class="packt_infobox">The coding principle of avoiding unnecessary dependencies is usually called <em>loose coupling</em>. This is a very important principle and I strongly encourage you to look into it, understand it, and apply it to your own coding projects.</div>
<p>In order to understand the significance of <em>loose coupling</em>, we can draw some boxes on a whiteboard or a piece of paper. One box represents our GUI class and code, while the other boxes represent business logic, databases, and so on.</p>
<p>Next, we draw lines between the boxes, graphing out the interdependencies between those boxes, which are our Python modules, as shown here:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/61dc851a-e4f2-423e-89aa-42e8016a91bf.png" style="width:10.50em;height:6.75em;" width="374" height="241"/></p>
<p>While these three boxes connected via three lines might look a little simple, this is what you really would draw on a whiteboard in a software team meeting. I have left out any labels, but one box could be labeled <strong>UI</strong>, another <strong>database</strong>, and a third <strong>business processing logic</strong>.</p>
<div class="packt_infobox">The fewer lines we have between our Python boxes, the more <em>loosely coupled</em> our design is.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>In the previous recipe, <em>How to use queues</em>, we started to use queues. In this recipe, we will pass instances of <kbd>Queue</kbd> from our main GUI thread to other Python modules, which will enable us to write to the <kbd>ScrolledText</kbd> widget from another module while keeping our GUI responsive.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it…</h1>
                </header>
            
            <article>
                
<ol>
<li>First, we create a new Python module in our project. Let's call it <kbd>Queues.py</kbd>. We'll place a function into it (no OOP necessary yet). Sequentially, we can state it as follows:
<ol>
<li>Create a new Python module and name it <kbd><span>Queues.py</span></kbd>.</li>
<li>Write the following code into this module to place messages into the instance queue:</li>
</ol>
</li>
</ol>
<pre style="padding-left: 120px">def write_to_scrol(inst):<br/>    print('hi from Queue', inst)<br/>    for idx in range(10): <br/>        inst.gui_queue.put('Message from a queue: ' + <br/> str(idx)) <br/>    inst.create_thread(6)</pre>
<p class="mce-root"/>
<ol start="2">
<li>The next steps show how we shall import this newly created module:
<ol>
<li>Open <kbd>GUI_queues_put_get_loop_endless_threaded.py</kbd> <span>and save it as</span> <span><kbd>GUI_passing_queues_member.py</kbd></span><span><span>.</span></span></li>
<li>Make the following changes to invoke the function from the module we are importing:</li>
</ol>
</li>
</ol>
<pre style="padding-left: 120px">import Ch06_Code.Queues as bq    # bq; background queue<br/><br/>class OOP(): <br/>    # Button callback <br/>    def click_me(self): <br/>        # Passing in the current class instance (self) <br/>        print(self) <br/>        bq.write_to_scrol(self)</pre>
<ol start="3">
<li>In <span><kbd>GUI_passing_queues_member.py</kbd>, create an instance of <kbd>Queue</kbd>:</span></li>
</ol>
<pre style="padding-left: 60px">class OOP(): <br/>    def __init__(self): <br/>        # Create a Queue <br/>        self.gui_queue = Queue()</pre>
<ol start="4">
<li>Modify the <kbd>use_queues</kbd> method:</li>
</ol>
<pre style="padding-left: 60px">def use_queues(self): <br/>    # Now using a class instance member Queue <br/>    while True: <br/>        print(self.gui_queue.get())</pre>
<ol start="5">
<li>Running the code yields the following result:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="aligncenter size-full image-border" src="Images/437cc42c-7d33-46aa-9255-d96eaa75cf9d.png" style="width:28.58em;height:38.58em;" width="458" height="620"/></div>
<p><span>Let's go behind the scenes to understand the code better.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works…</h1>
                </header>
            
            <article>
                
<p>First, we create a new Python module, <kbd>Queues.py</kbd>. The <kbd>write_to_scrol</kbd> function within it accepts an instance of a class. We use this instance to access the methods and attributes of the class.</p>
<div class="packt_infobox">Here, we are relying on the knowledge that our class instance has the two methods we are accessing within the function.</div>
<p>In <span><kbd>GUI_passing_queues_member.py</kbd>, we first import the <kbd>Queues</kbd> module, alias it to <kbd>bq</kbd>, and then we use it to call the function residing in the <kbd>Queues</kbd> module.</span></p>
<div class="packt_infobox">Aliasing the module to <kbd>bq</kbd> is probably not the best name. I meant it to mean <em>background queue</em> because it runs threads as daemons in the background. I am not changing the alias in this third edition as I have used it in the first two editions of this book, for reasons of consistency.</div>
<p><span>In the <kbd>click_me</kbd> button callback method, we are passing <kbd>self</kbd> into this function.</span> <span>This enables us to use all of the GUI methods from another Python module.</span></p>
<p>The imported module contains the <kbd>write_to_scrol</kbd> function we are calling:</p>
<pre>    def write_to_scrol(inst): <br/>        print('hi from Queue', inst) <br/>        inst.create_thread(6)</pre>
<p><span>By passing in a self-reference from the class instance to the function that the class is calling in another module, we now have access to all our GUI elements from other Python modules.</span></p>
<p><kbd>gui_queue</kbd> is an instance attribute and <kbd>create_thread</kbd> is a method, and both are defined in <span><kbd>GUI_passing_queues_member.py</kbd>, and we are accessing them via the passed-in self-reference inside the <kbd>Queues</kbd> module.</span></p>
<p><span>W</span>e c<span>reate</span> <kbd>Queue</kbd> <span>as an instance attribute of our class, placing a reference to it in the</span> <kbd>__init__</kbd> <span>method of the <kbd>GUI_passing_queues_member.py</kbd> class.</span></p>
<p>Now we can put messages into the queue from our new module by simply using the passed-in class reference to our GUI. Notice <kbd>inst.gui_queue.put</kbd> in the <span><kbd>Queues.py</kbd> code:</span></p>
<pre>    def write_to_scrol(inst): <br/>        print('hi from Queue', inst) <br/>        for idx in range(10): <br/>            inst.gui_queue.put('Message from a queue: ' + str(idx)) <br/>        inst.create_thread(6)</pre>
<p><span>After we modified the <kbd>use_queues</kbd> method, the</span> <kbd>create_thread</kbd> <span>method in our GUI code only reads from the</span> <kbd>Queue</kbd><span>, which got filled in by the business logic residing in our new module, which has separated the logic from our GUI module.</span></p>
<p>In order to separate the GUI widgets from the functionality that expresses the business logic, we created a class, made a queue an instance attribute of this class, and, by passing an instance of the class into a function residing in a different Python module, we now have access to all the GUI widgets, as well as the queue.</p>
<p class="mce-root"/>
<div class="packt_infobox"><span>This is the magic of OOP. In the middle of a class, we pass ourselves into a function we are calling from within the class using the</span> <kbd>self</kbd> <span>keyword.</span></div>
<p>This recipe is an example of when it makes sense to program in OOP.</p>
<p><span>Let's move on to the next recipe.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Using dialog widgets to copy files to your network</h1>
                </header>
            
            <article>
                
<p>This recipe shows us how to copy files from your local hard drive to a network location. We will do this by using one of Python's <kbd>tkinter</kbd> built-in dialogs, which enables us to browse our hard drive. We can then select a file to be copied.</p>
<p>This recipe also shows us how to make <kbd>Entry</kbd> widgets read-only and to default <kbd>Entry</kbd> to a specified location, which speeds up the browsing of our hard drive.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>We will extend <span class="packt_screen">Tab 2</span> of the GUI we were building in the previous recipe, <em>Passing queues among different modules</em>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it…</h1>
                </header>
            
            <article>
                
<p>Add the following code to the GUI in the <kbd>create_widgets()</kbd> method toward the bottom, where we created <span class="packt_screen">Tab Control 2</span>. The parent of the new widget frame is <kbd>tab2</kbd>, which we created at the very beginning of the <kbd>create_widgets()</kbd> method. As long as you place the following code physically under the creation of <kbd>tab2</kbd>, it will work:</p>
<ol>
<li>Open <kbd><span>GUI_passing_queues_member.py</span></kbd> and save it as <span><kbd>GUI_copy_files.py</kbd></span>.</li>
<li>Make the following changes:</li>
</ol>
<pre style="padding-left: 60px">########################################################### <br/>def create_widgets(self): <br/>    # Create Tab Control<br/>    tabControl = ttk.Notebook(self.win)   <br/>    # Add a second tab<br/>    tab2 = ttk.Frame(tabControl)           <br/>    # Make second tab visible<br/>    tabControl.add(tab2, text='Tab 2')     <br/><br/># Create Manage Files Frame  <br/>mngFilesFrame = ttk.LabelFrame(tab2, text=' Manage Files: ') <br/>mngFilesFrame.grid(column=0, row=1, sticky='WE', padx=10, pady=5) <br/><br/># Button Callback <br/>def getFileName(): <br/>    print('hello from getFileName') <br/><br/># Add Widgets to Manage Files Frame <br/>lb = ttk.Button(mngFilesFrame, text="Browse to File...", <br/>command=getFileName) <br/>lb.grid(column=0, row=0, sticky=tk.W)  <br/><br/>file = tk.StringVar() <br/>self.entryLen = scrol_w <br/>self.fileEntry = ttk.Entry(mngFilesFrame, width=self.entryLen, <br/>textvariable=file) <br/>self.fileEntry.grid(column=1, row=0, sticky=tk.W) <br/><br/>logDir = tk.StringVar() <br/>self.netwEntry = ttk.Entry(mngFilesFrame, <br/>width=self.entryLen, textvariable=logDir) <br/>self.netwEntry.grid(column=1, row=1, sticky=tk.W)  <br/><br/>def copyFile(): <br/>    import shutil <br/>    src = self.fileEntry.get() <br/>    file = src.split('/')[-1] <br/>    dst = self.netwEntry.get() + ''+ file <br/>    try: <br/>        shutil.copy(src, dst) <br/>        msg.showinfo('Copy File to Network', 'Succes: <br/>        File copied.') <br/>    except FileNotFoundError as err: <br/>        msg.showerror('Copy File to Network', '*** Failed to copy <br/>        file! ***\n\n' + str(err)) <br/>    except Exception as ex: <br/>        msg.showerror('Copy File to Network', '*** Failed to copy <br/>        file! ***\n\n' + str(ex)) <br/><br/>cb = ttk.Button(mngFilesFrame, text="Copy File To : ", <br/>command=copyFile) <br/>cb.grid(column=0, row=1, sticky=tk.E) <br/><br/># Add some space around each label <br/>for child in mngFilesFrame.winfo_children(): <br/>    child.grid_configure(padx=6, pady=6)</pre>
<ol start="3">
<li>Running the code creates the following GUI:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="Images/8347b6be-7b48-44df-a0c4-c0849731a102.png" style="width:23.67em;height:23.08em;" width="378" height="368"/></p>
<ol start="4">
<li>Click the <span class="packt_screen">Browse to File...</span> <span>button</span><span>:</span></li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="aligncenter size-full image-border" src="Images/5ce731b5-969c-4d48-ab42-0378efd326e5.png" style="width:26.92em;height:6.17em;" width="345" height="79"/></div>
<ul>
<li style="list-style-type: none">
<ol>
<li>Open <kbd><span>GUI_copy_files.py</span></kbd>.</li>
<li>Add the following two <kbd>import</kbd> statements:</li>
</ol>
</li>
</ul>
<pre style="padding-left: 120px">from tkinter import filedialog as fd <br/>from os import path</pre>
<p class="mce-root"/>
<ol start="5">
<li>Create the following function:</li>
</ol>
<pre style="padding-left: 60px">def getFileName(): <br/>    print('hello from getFileName') <br/>    fDir  = path.dirname(__file__) <br/>    fName = fd.askopenfilename(parent=self.win, initialdir=fDir)</pre>
<ol start="6">
<li>Run the code and click the <span class="packt_screen">Browse To</span> button:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="Images/82704756-3891-4b5f-85b4-742074b272b2.png" style="width:45.50em;height:29.75em;" width="665" height="435"/></p>
<ol start="7">
<li>Add the following two lines of code to the creation of the <kbd>Entry</kbd> widget:</li>
</ol>
<pre style="padding-left: 60px"># Adding a Textbox Entry widget <br/>self.name = tk.StringVar()<br/>self.name_entered = ttk.Entry(mighty, width=24, textvariable=self.name)<br/>self.name_entered.grid(column=0, row=1, sticky='W') <br/>self.name_entered.delete(0, tk.END)<br/>self.name_entered.insert(0, '&lt; default name &gt;')</pre>
<p class="mce-root"/>
<ol start="8">
<li>Run the code and see the following result:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="aligncenter size-full image-border" src="Images/5ca24e3f-24e2-487a-a5fd-6d5a726d191b.png" style="width:29.25em;height:13.92em;" width="396" height="188"/></div>
<ol start="9">
<li>Now, open <kbd><span>GUI_copy_files.py</span></kbd> and add the following code:</li>
</ol>
<pre style="padding-left: 60px"># Module level GLOBALS <br/>GLOBAL_CONST = 42 <br/>fDir   = path.dirname(__file__) <br/>netDir = fDir + 'Backup' <br/><br/>def __init__(self): <br/>    self.createWidgets()        <br/>    self.defaultFileEntries() <br/><br/>def defaultFileEntries(self): <br/>    self.fileEntry.delete(0, tk.END) <br/>    self.fileEntry.insert(0, fDir)  <br/>    if len(fDir) &gt; self.entryLen: <br/>        self.fileEntry.config(width=len(fDir) + 3) <br/>        self.fileEntry.config(state='readonly') <br/><br/>    self.netwEntry.delete(0, tk.END) <br/>    self.netwEntry.insert(0, netDir)  <br/>    if len(netDir) &gt; self.entryLen: <br/>        self.netwEntry.config(width=len(netDir) + 3)</pre>
<p class="mce-root"/>
<ol start="10">
<li>Running <kbd>GUI_copy_files.py</kbd> results in the following screenshot:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="Images/2756175f-0bf5-4ea8-a098-aee15a687d4b.png" style="width:40.17em;height:21.67em;" width="679" height="367"/></p>
<ol start="11">
<li>Open <kbd><span>GUI_copy_files.py</span></kbd> and add the following code:</li>
</ol>
<pre style="padding-left: 60px"># Module level GLOBALS <br/>GLOBAL_CONST = 42 <br/><br/>from os import makedirs <br/>fDir   = path.dirname(__file__) <br/>netDir = fDir + 'Backup'  <br/>if not path.exists(netDir): <br/>    makedirs(netDir, exist_ok = True)</pre>
<p style="padding-left: 60px"><span>Once we click the button that invokes the</span> <kbd>copyFile()</kbd> <span>function, we import the required module.</span></p>
<ol start="12">
<li>Open <kbd><span>GUI_copy_files.py</span></kbd> and add the following code:</li>
</ol>
<pre style="padding-left: 60px">from tkinter import messagebox as msg<br/>def copyFile(): <br/>    import shutil                   #import module within function<br/>    src = self.fileEntry.get() <br/>    file = src.split('/')[-1] <br/>    dst = self.netwEntry.get() + ''+ file <br/>    try: <br/>        shutil.copy(src, dst) <br/>        msg.showinfo('Copy File to Network', 'Succes: File <br/>        copied.') <br/>    except FileNotFoundError as err: <br/>        msg.showerror('Copy File to Network', <br/>        '*** Failed to copy file! ***\n\n' + str(err)) <br/>    except Exception as ex: <br/>        msg.showerror('Copy File to Network', <br/>        '*** Failed to copy file! ***\n\n' + str(ex))</pre>
<ol start="13">
<li>Run the code, browse to a file, and click the <span class="packt_screen">Copy</span> button:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="aligncenter size-full image-border" src="Images/a7baa723-878c-4235-b7c3-57b70c3ff9d4.png" style="width:51.58em;height:20.33em;" width="993" height="391"/></div>
<ol start="14">
<li>Run the code, but don't browse and click the <span class="packt_screen">Copy</span> button:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="Images/f30c5437-aac1-4a63-962c-29eaac6b9960.png" style="width:28.83em;height:12.17em;" width="448" height="189"/></p>
<p class="mce-root"/>
<ol start="15">
<li>Open <kbd><span>GUI_copy_files.py</span></kbd> and save it as <kbd><span>GUI_copy_files_limit.py</span></kbd><span>.</span></li>
<li>Add the following code:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="aligncenter size-full image-border" src="Images/58658b51-0c57-414c-a60a-f9a6e7079baa.png" style="width:41.83em;height:18.08em;" width="675" height="292"/></div>
<ol start="17">
<li class="packt_figure CDPAlignLeft CDPAlign">Run the preceding code to observe the output, as illustrated <span>in the following screenshot</span>:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="Images/d9997425-532d-4e48-acdb-f41a70221cf4.png" style="width:20.17em;height:20.75em;" width="359" height="369"/></p>
<p><span>Let's go behind the scenes to understand the code better.</span></p>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works…</h1>
                </header>
            
            <article>
                
<p>In <span><kbd>GUI_copy_files.py</kbd>, we</span> add two buttons and two entries to <span class="packt_screen">Tab 2</span> of our GUI. We are not yet implementing the functionality of our button callback function.</p>
<p><span>Clicking the</span> <span class="packt_screen">Browse to File...</span> <span>button currently prints</span> <kbd>hello from getFileName</kbd> <span>to the console.</span> <span>We can use the <kbd>tkinter</kbd> built-in file dialogs after adding the <kbd>import</kbd> statements.</span></p>
<p><span>We can now use the dialogs in our code. Instead of hardcoding a path, we can use Python's</span> <kbd>os</kbd> <span>module to find the full path to where our GUI module resides. Clicking the <span class="packt_screen">Browse to File...</span> button now opens up the <kbd>askopenfilename</kbd> dialog.</span> We can now open a file in this directory or browse to a different directory. After selecting a file and clicking the <span class="packt_screen">Open</span> button in the dialog, we will save the full path to the file in the <kbd>fName</kbd> local variable.</p>
<p>It would be nice if, when we opened our Python <kbd>askopenfilename</kbd> dialog widget, we would automatically default to a directory so that we would not have to browse all the way to where we were looking for a particular file to be opened. It is best to demonstrate how to do this by going back to our GUI <span class="packt_screen">Tab 1</span>, which is what we will do next.</p>
<p>We can default the values into <kbd>Entry</kbd> widgets. Back on our <span class="packt_screen">Tab 1</span>, this is very easy. <span>When we now run the GUI, the</span> <kbd>name_entered</kbd> <span>entry has a default value.</span> <span>We can get the full path to the module we are using, and then we can create a new subfolder just below it. We can do this as a module-level global variable, or we can create the subfolder within a method.</span></p>
<p>We set the defaults for both the <kbd>Entry</kbd> widgets and, after setting them, we make the local file <kbd>Entry</kbd> widget read-only.</p>
<div class="packt_infobox">This order is important. We have to first populate the entry before we make it read-only.</div>
<p>We are also selecting <span class="packt_screen">Tab 2</span> before calling the main event loop and no longer set the focus into the <kbd>Entry</kbd> of <span class="packt_screen">Tab 1</span>. Calling <kbd>select</kbd> on our <kbd>notebook</kbd> of <span><kbd>tkinter</kbd> </span>is zero-based, so by passing in the value of <kbd>1</kbd>, we select <span class="packt_screen">Tab 2</span>:</p>
<pre>    # Place cursor into name Entry <br/>    # name_entered.focus()                 # commented out             <br/>    tabControl.select(1)                   # displayTab 2 at GUI startup </pre>
<p>As we are not all on the same network, this recipe uses the local hard drive in place of a network.</p>
<p class="mce-root"/>
<p>A <strong>UNC</strong> path is a <strong>Universal Naming Convention</strong>, and what this means is that by using double backslashes instead of the typical <kbd>C:\</kbd>, we can access a server on a network.</p>
<div class="packt_infobox">You just have to use the UNC and replace <kbd>C:\</kbd> with <kbd>\\&lt;servername&gt;\&lt;folder&gt;</kbd>.</div>
<p>This example can be used to back up our code to a backup directory, which we can create if it does not exist by using <kbd>os.makedirs</kbd>. After selecting a file to copy to somewhere else, we import the Python <kbd>shutil</kbd> module. We need the full path to the source of the file to be copied and a network or local directory path, and then we append the filename to the path where we will copy it using <kbd>shutil.copy</kbd>.</p>
<div class="packt_infobox"><kbd>shutil</kbd> is shorthand notation for shell utility.</div>
<p>We also give feedback to the user via a message box to indicate whether the copying succeeded or failed. In order to do this, we import <kbd>messagebox</kbd> and alias it to <kbd>msg</kbd>.</p>
<p>In the next code, we mix two different approaches of where to place our <kbd>import</kbd> statements. In Python, we have some flexibility that other languages do not provide. We typically place all of the <kbd>import</kbd> statements toward the very top of each of our Python modules so that it is clear which modules we are importing. At the same time, a modern coding approach is to place the creation of variables close to the function or method where they are first being used.</p>
<p>In the code, we import the message box at the top of our Python module, but then we also import the <kbd>shutil</kbd> Python module in a function. Why would we wish to do this? Does this even work? The answer is yes, it does work, and we are placing this <kbd>import</kbd> statement into a function because this is the only place in our code where we actually do need this module.</p>
<p>If we never call this method, then we will never import the module this method requires. In a sense, you can view this technique as the <strong>lazy initialization design pattern</strong>. If we don't need it, we don't import it until we really do require it in our Python code. The idea here is that our entire code might require, let's say, 20 different modules. At runtime, which modules are really needed depends upon the user interaction. If we never call the <kbd>copyFile()</kbd> function, then there is no need to import <kbd>shutil</kbd>.</p>
<p class="mce-root"/>
<p><span>When we now run our GUI, browse to a file, and click</span> <span class="packt_screen">Copy</span><span>, the file is copied to the location we specified in our Entry widget.</span></p>
<p>If the file does not exist or we forgot to browse to a file and are trying to copy the entire parent folder, the code will let us know this as well because we are using Python's built-in exception handling capabilities.</p>
<p><span>Our new</span> <kbd>Entry</kbd> <span>widgets did expand the width of the GUI. While it is sometimes nice to be able to see the entire path, at the same time, it pushes other widgets, making our GUI look not so good. We can solve this by restricting the width parameter of our</span> <kbd>Entry</kbd> <span>widgets. We do this in <kbd>GUI_copy_files_limit.py</kbd>.</span> <span>This results in a limited GUI size. We can right-arrow in the enabled</span> <kbd>Entry</kbd> <span>widget to get to the end of this widget.</span></p>
<p>We are copying files from our local hard drive to a network by using the Python shell utility. As most of us are not connected to the same local area network, we simulate the copying by backing up our code to a different local folder.</p>
<p>We are using one of <kbd>tkinter</kbd> dialog controls, and by defaulting the directory paths, we can increase our efficiency in copying files.</p>
<p><span>Let's move on to the next recipe.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Using TCP/IP to communicate via networks</h1>
                </header>
            
            <article>
                
<p>This recipe shows you how to use <kbd>sockets</kbd> to communicate via <em>TCP/IP</em>. In order to achieve this, we need both an <em>IP address</em> and a <em>port number</em>.</p>
<p>In order to keep things simple and independent of changing internet IP addresses, we will create our own local TCP/IP server and client, and we will learn how to connect the client to the server and read data via a TCP/IP connection.</p>
<p>We will integrate this networking capability into our GUI by using the queues we created in the previous recipes.</p>
<div class="packt_infobox"><strong>TCP<span>/</span>IP</strong> <span>short for <strong>Transmission Control Protocol/Internet Protocol</strong>, which is a set of networking protocols that allows two or more computers to communicate.</span></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>We will create a new Python module, which will be the TCP server.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it…</h1>
                </header>
            
            <article>
                
<p>One way to implement a TCP server in Python is to inherit from the <kbd>socketserver</kbd> module. We subclass <kbd>BaseRequestHandler</kbd> and then override the inherited <kbd>handle</kbd> method. In very few lines of Python code, we can implement a TCP server:</p>
<ol>
<li>Create a new Python module and save it as <kbd>TCP_Server.py</kbd><span>.</span></li>
<li>Add the following code to create the TCP server and a <kbd>start</kbd> function:</li>
</ol>
<pre style="padding-left: 60px">from socketserver import BaseRequestHandler, TCPServer <br/><br/>class RequestHandler(BaseRequestHandler): <br/>    # override base class handle method <br/>    def handle(self): <br/>        print('Server connected to: ', self.client_address) <br/>        while True: <br/>            rsp = self.request.recv(512) <br/>            if not rsp: break <br/>            self.request.send(b'Server received: ' + rsp) <br/><br/>def start_server(): <br/>    server = TCPServer(('', 24000), RequestHandler) <br/>    server.serve_forever()</pre>
<ol start="3">
<li>Open <span><kbd>Queues.py</kbd> and add the following code to create a socket and use it:</span></li>
</ol>
<pre style="padding-left: 60px"># using TCP/IP<br/>from socket import socket, AF_INET, SOCK_STREAM <br/><br/>def write_to_scrol_TCP(inst): <br/>    print('hi from Queue', inst) <br/>    sock = socket(AF_INET, SOCK_STREAM) <br/>    sock.connect(('localhost', 24000)) <br/>    for idx in range(10): <br/>    sock.send(b'Message from a queue: ' + bytes(str(idx).encode()) ) <br/>        recv = sock.recv(8192).decode() <br/>        inst.gui_queue.put(recv)       <br/>    inst.create_thread(6)</pre>
<p class="mce-root"/>
<ol start="4">
<li>Open <kbd>GUI_copy_files_limit.py</kbd> and save it as <kbd><span>GUI_TCP_IP.py</span></kbd>.</li>
<li>Add the following code to start the TCP server in its own thread:</li>
</ol>
<pre style="padding-left: 60px">class OOP(): <br/>    def __init__(self): <br/>        # Start TCP/IP server in its own thread <br/>        svrT = Thread(target=start_server, daemon=True) <br/>        svrT.start()</pre>
<ol start="6">
<li>Run the code and click <span>the</span> <span class="packt_screen">Click Me!</span> <span>button on <span class="packt_screen">Tab 1</span></span>:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="aligncenter size-full image-border" src="Images/2a300a1c-026c-4aa3-aa69-a5e7e4abaaa3.png" style="width:71.08em;height:30.25em;" width="853" height="363"/></div>
<p><span>Let's go behind the scenes to understand the code better.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works…</h1>
                </header>
            
            <article>
                
<p>In <span><kbd>TCP_Server.py</kbd>, w</span>e are passing our <kbd>RequestHandler</kbd> class into a <kbd>TCPServer</kbd> initializer. The empty single quotes are a shortcut for localhost, which is our own PC. This is the IP address of <kbd>127.0.0.1</kbd>. The second item in the tuple is the <em>port number</em>. We can choose any port number that is not in use on our local PC.</p>
<div class="packt_infobox">We have to make sure that we are using the same port on the client side of the TCP connection; otherwise, we would not be able to connect to the server.</div>
<p>Of course, we have to start the server first before clients can connect to it. We will modify our <kbd>Queues.py</kbd> module to become the TCP client. When we now click the <span class="packt_screen">Click Me!</span> button, we are calling <kbd>bq.write_to_scrol_TCP(self)</kbd>, which then creates the socket and connection.</p>
<p>This is all the code we need to talk to the TCP server. In this example, we are simply sending some bytes to the server and the server sends them back, prepending some strings before returning the response.</p>
<div class="packt_infobox">This shows the principle of how TCP communications via networks work.</div>
<p>Once we know how to connect to a remote server via TCP/IP, we will use whatever commands are designed by the protocol of the program we are interested in communicating with. The first step is to connect before we can send commands to specific applications residing on a server.</p>
<p>In the <kbd><span>write_to_scrol_TCP</span></kbd> function, we use the same loop as before, but now we will send the messages to the TCP server. The server modifies the received message and then sends it back to us. Next, we place it into the GUI class instance queue, which, as in the previous recipes, runs in its own thread:</p>
<pre>sock.send(b'Message from a queue: ' + bytes(str(idx).encode()) )</pre>
<p>Note the <kbd>b</kbd> character before the string and then the rest of the required casting.</p>
<p>We start the TCP server in its own thread in the initializer of the OOP class.</p>
<div class="packt_infobox">In Python 3, we send strings over sockets in binary format. Adding the integer index now becomes a little bit convoluted as we have to cast it to a string, encode it, and then cast the encoded string into bytes!</div>
<p>Clicking the <span class="packt_screen">Click Me!</span> button on <span class="packt_screen">Tab 1</span> now creates the output in our <kbd>ScrolledText</kbd> widget as well as on the console, and the response because of the use of threads is very fast. We created a TCP server to simulate connecting to a server in our local area network or on the internet. We turned our queues module into a TCP client. We are running both the queue and the server in their own background thread, which keeps our GUI very responsive.</p>
<p><span>Let's move on to the next recipe.</span></p>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Using urlopen to read data from websites</h1>
                </header>
            
            <article>
                
<p>This recipe shows how we can easily read entire web pages by using some of Python's built-in modules. We will display the web page data first in its raw format and then decode it, and then we will display it in our GUI.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>We will read the data from a web page and then display it in the <kbd>ScrolledText</kbd> widget of our GUI.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it…</h1>
                </header>
            
            <article>
                
<p>First, we create a new Python module and name it <kbd>URL.py</kbd>. We then import the required functionality to read web pages using Python. We can do this in very few lines of code:</p>
<ol>
<li>Create a new module and name it <kbd><span>URL.py</span></kbd>.</li>
<li>Add the following code to open and read the URL:</li>
</ol>
<pre style="padding-left: 60px">from urllib.request import urlopen <br/>link = 'http://python.org/'  <br/>try:<br/>    http_rsp = urlopen(link)<br/>    print(http_rsp)<br/>    html = http_rsp.read()<br/>    print(html)<br/>    html_decoded = html.decode()<br/>    print(html_decoded) <br/>except Exception as ex:<br/>    print('*** Failed to get Html! ***\n\n' + str(ex)) <br/>else:<br/>    return html_decoded</pre>
<p class="mce-root"/>
<ol start="3">
<li>Run the preceding code and observe the following output:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="aligncenter size-full image-border" src="Images/300c4819-faeb-4a64-9f03-b8687d639cbe.png" style="width:41.92em;height:18.08em;" width="600" height="259"/></div>
<p class="mce-root"/>
<ol start="4">
<li>Compare the result to the official Python web page we just read:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="aligncenter size-full image-border" src="Images/9c82a0c1-eabe-40f5-af94-b4f73ac47a10.png" style="width:53.00em;height:34.42em;" width="880" height="571"/></div>
<p>Let's consider the next scenario:</p>
<ol>
<li>Open <kbd>URL.py</kbd><span>.</span></li>
<li>Place the code into a function:</li>
</ol>
<pre style="padding-left: 60px">from urllib.request import urlopen <br/>link = 'http://python.org/'  <br/><br/>def get_html():<br/>    try:<br/>        http_rsp = urlopen(link)<br/>        print(http_rsp)<br/>        html = http_rsp.read()<br/>        print(html)<br/>        html_decoded = html.decode()<br/>        print(html_decoded) <br/>    except Exception as ex:<br/>        print('*** Failed to get Html! ***\n\n' + str(ex)) <br/>    else:<br/>        return html_decoded</pre>
<ol start="3">
<li>Open <span><kbd>GUI_TCP_IP.py</kbd> from the previous recipe and save it as <kbd>GUI_URL.py</kbd></span><span>.</span></li>
<li>Import the <kbd>URL</kbd> <span>module and modify the</span> <kbd>click_me</kbd> <span>method:</span></li>
</ol>
<pre style="padding-left: 60px">import Ch06_Code.URL as url<br/><br/># Button callback <br/>def click_me(self): <br/>    self.action.configure(text='Hello ' + self.name.get())<br/>    bq.write_to_scrol(self) <br/>    sleep(2)<br/>    html_data = url.get_html()<br/>    print(html_data)<br/>    self.scrol.insert(tk.INSERT, html_data)</pre>
<p class="mce-root"/>
<ol start="5">
<li>Run the code, the output of which is as follows:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="Images/3ea25447-fbef-40de-a100-8e46dcf4881d.png" style="width:27.33em;height:26.00em;" width="387" height="368"/></p>
<div class="CDPAlignCenter CDPAlign"/>
<p class="mce-root">The next section talks about the process in detail.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works…</h1>
                </header>
            
            <article>
                
<p>We wrap the <kbd>URL.py</kbd> code in a <kbd>try...except</kbd> block similar to Java and C#. This is a modern approach to coding, which Python supports. Whenever we have code that might not complete, we can experiment with this code and, if it works, all is fine. If the block of code in the <kbd>try...except</kbd> block does not work, the Python interpreter will throw one of several possible exceptions, which we can then catch. Once we have caught the exception, we can decide what to do next.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<p>There is a hierarchy of exceptions in Python, and we can also create our own classes that inherit from and extend the Python exception classes. In the following code, we are mainly concerned that the URL we are trying to open might not be available, so we wrap our code within a <kbd>try...except</kbd> code block. If the code succeeds in opening the requested URL, all is fine. If it fails, maybe because our internet connection is down, we fall into the exception part of the code and print out that an exception has occurred.</p>
<div class="packt_infobox"><span>You can read more about Python exception handling at <a href="https://docs.python.org/3.7/library/exceptions.html">https://docs.python.org/3.7/library/exceptions.html</a>.</span></div>
<p>By calling <kbd>urlopen</kbd> on the official Python website, we get the entire data as one long string. The first <kbd>print</kbd> statement prints this long string out to the console. We then call <kbd>decode</kbd> on the result, and this time we get a little over 1,000 lines of web data, including some white space. We also print out <kbd>type</kbd> for calling <kbd>urlopen</kbd>, which is an <kbd>http.client.HTTPResponse</kbd> object. Actually, we print it out first.</p>
<p>Next, we display this data in our GUI inside the <kbd>ScrolledText</kbd> widget. In order to do so, we have to connect our new module, which reads the data from the web page to our GUI. In order to do this, we need a reference to our GUI, and one way to do this is by tying our new module to the <span class="packt_screen">Tab 1</span> button callback. We can return the decoded HTML data from the Python web page to the <kbd>Button</kbd> widget, which we can then place into the <kbd>ScrolledText</kbd> control.</p>
<p><span>We turn our <kbd>URL.py</kbd> code into a function and return the data to the calling code.</span> <span>We can now write the data from our button callback method to the</span> <kbd>ScrolledText</kbd> <span>control by first importing the new module and then inserting the data into the widget. We also give it some sleep after the call to</span> <kbd>write_to_scrol.</kbd></p>
<p>In <span><kbd>GUI_URL.py</kbd>, the HTML data is now displayed in our GUI widget.</span></p>


            </article>

            
        </section>
    </div>



  </body></html>