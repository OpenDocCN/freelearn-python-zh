- en: Chapter 7. Optimization Techniques
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 7 章。优化技术
- en: 'In this chapter, we will learn how to optimize our Python code to get better
    responsive programs. But, before we dive into this, I would like to stress that
    do not optimize until it is necessary. A better-readable program has a better
    life and maintainability than a tersely-optimized program. First, we will take
    a look at simple optimization tricks to keep a program optimized. We should have
    knowledge about them so that we can apply easy optimizations from the start. Then,
    we will look at profiling to find bottlenecks in the current program and apply
    optimizations where we need them. As a last resort, we can compile in the C language
    and provide functionality as an extension to Python. Here is the gist of topics
    that we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何优化我们的 Python 代码以获得更好的响应性程序。但是，在我们深入之前，我想强调的是，只有在必要时才进行优化。一个可读性更好的程序比一个简洁优化的程序有更好的生命周期和可维护性。首先，我们将看看简单的优化技巧以保持程序优化。我们应该了解它们，这样我们就可以从开始就应用简单的优化。然后，我们将查看分析以找到当前程序中的瓶颈并应用所需的优化。作为最后的手段，我们可以用
    C 语言编译并提供作为 Python 扩展的功能。以下是我们将涵盖的主题概要：
- en: Writing optimized code
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写优化代码
- en: Profiling to find bottlenecks
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析以找到瓶颈
- en: Using fast libraries
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用快速库
- en: Using C speeds
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 C 速度
- en: Writing optimized code
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写优化代码
- en: '**Key 1: Easy optimizations for code.**'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键 1：代码的简单优化。**'
- en: 'We should pay close attention to not use loops inside loops, giving us quadratic
    behavior. We can use built-ins, such as map, ZIP, and reduce, instead of using
    loops if possible. For example, in the following code, the one with map is faster
    because the looping is implicit and done at C level. By plotting their run times
    respectively on graph as `test 1` and `test 2`, we see that it is nearly constant
    for PyPy but reduces a lot for CPython, as follows:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该特别注意不要在循环内部使用循环，这会导致我们得到二次行为。如果可能的话，我们可以使用内置函数，如 map、ZIP 和 reduce，而不是使用循环。例如，在下面的代码中，使用
    map 的版本更快，因为循环是隐式的，并且在 C 级别执行。通过将它们的运行时间分别绘制在图上作为 `test 1` 和 `test 2`，我们看到 PyPy
    几乎是恒定的，但对于 CPython 来说减少了很大，如下所示：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The following image is a graphical representation of the preceding code:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图像是前面代码的图形表示：
- en: '![Writing optimized code](img/B04885_07_01.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![编写优化代码](img/B04885_07_01.jpg)'
- en: 'Generators should be used, when the result that is consumed is averagely smaller
    than the total result consumed. In other words, the result that is generated in
    the end may not be used. They also serve to conserve memory because no temporary
    result is stored but generated on demand. In the following example, `sqrt_5` creates
    a generator, while `sqrt_6` creates a list. The `use_combo` instance breaks out
    of the loop of iteration after a given number of iterations. Test 1 runs `use_combo(sqrt_5,range(10),5)`
    and all results are consumed from iterator, whereas test 2 is for the `use_combo(sqrt_6,range(10),5)`
    generator. Test 1 should take more time than test 2 as it creates results for
    all ranges of inputs. Tests 3, and 4 are run with a range of `25`, and tests 5,
    and 6 are run with a range of `100`. As it can be seen, the time consumption variation
    increases with no of elements in the list:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当消耗的结果平均小于消耗的总结果时，应使用生成器。换句话说，最终生成的结果可能不会被使用。它们还用于节省内存，因为不会存储临时结果，而是在需要时生成。在下面的示例中，`sqrt_5`
    创建了一个生成器，而 `sqrt_6` 创建了一个列表。`use_combo` 实例在给定次数的迭代后跳出迭代循环。Test 1 运行 `use_combo(sqrt_5,range(10),5)`
    并从迭代器中消耗所有结果，而 test 2 是针对 `use_combo(sqrt_6,range(10),5)` 生成器的。Test 1 应该比 test
    2 花更多的时间，因为它为所有输入范围创建了结果。测试 3 和 4 使用 `25` 的范围运行，测试 5 和 6 使用 `100` 的范围运行。正如所见，时间消耗的变化随着列表中元素数量的增加而增加：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The following image is the graphical representation of the preceding code:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图像是前面代码的图形表示：
- en: '![Writing optimized code](img/B04885_07_02.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![编写优化代码](img/B04885_07_02.jpg)'
- en: 'When we are inside a loop and reference an outside namespace variable, it is
    first searched in local, then nonlocal, followed by global, and then built-in
    scopes. If the number of repetitions are more, then such overheads add up. We
    can reduce namespace lookup by making such global/built-in objects available in
    the local namespace. For example, in the following code snippet, `sqrt_7(test2)`
    will be faster `than sqrt_1(test1)` because of the same reasons:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在循环内部引用外部命名空间变量时，它首先在局部中搜索，然后是非局部，接着是全局，最后是内置作用域。如果重复次数更多，那么这样的开销会累加。我们可以通过使这样的全局/内置对象在局部命名空间中可用来减少命名空间查找。例如，在下面的代码片段中，`sqrt_7(test2)`
    由于相同的原因会比 `sqrt_1(test1)` 快：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The following image is the graphical representation of the preceding code:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图像是前面代码的图形表示：
- en: '![Writing optimized code](img/B04885_07_03.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![编写优化代码](img/B04885_07_03.jpg)'
- en: 'The cost of subclassing is not much and subclassing doesn''t make method calls
    slower even if common sense says that it will take lot of time to look a method
    up on the inheritance hierarchy. Let''s take the following example:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 子类化的成本不高，即使常识认为在继承层次结构中查找方法会花费很多时间，子类化也不会使方法调用变慢。让我们看以下示例：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here, if we call `get_sqrt` on the `Actual(case1)` class, we need to search
    it seven levels deep in its base classes, whereas for the `Actual2(case2)` class
    it is present on the class itself. The following graph is our plot for both scenarios:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，如果我们对`Actual(case1)`类调用`get_sqrt`，我们需要在其基类中搜索七层才能找到它，而对于`Actual2(case2)`类，它直接存在于类本身。下面的图表是这两种情况下的图表：
- en: '![Writing optimized code](img/B04885_07_04.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![编写优化代码](img/B04885_07_04.jpg)'
- en: 'Also, if we are using too many checks in the program logic for return codes
    or error conditions, we should see how many such checks are really needed. We
    can write the program logic without using any checks and then get the errors in
    the exception handling logic. This makes the code easy to understand. As in the
    following example, the `getf_1` function uses checks to filter out error conditions,
    but too many checks are making code hard to understand. The other `get_f2` function
    is the same application logic or algorithm with exception handling. For test 1
    `(get_f1)` and test 2 `(get_f2)`, no file is present, so all exceptions are raised.
    In this scenario, the exception handling logic, that is test 2, takes more time.
    For test 3 `(get_f1)` and test 4 `(get_f2)`, the file and key are present; hence,
    no error is raised. In this case, test 4 takes less time, as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果我们程序逻辑中使用了过多的检查来处理返回代码或错误条件，我们应该看看实际上需要多少这样的检查。我们可以先不使用任何检查来编写程序逻辑，然后在异常处理逻辑中获取错误。这使得代码更容易理解。例如，下面的`getf_1`函数使用检查来过滤错误条件，但过多的检查使得代码难以理解。另一个`get_f2`函数具有相同的应用逻辑或算法，但使用了异常处理。对于测试1（`get_f1`）和测试2（`get_f2`），没有文件存在，因此所有异常都被触发。在这种情况下，异常处理逻辑，即测试2，花费了更多的时间。对于测试3（`get_f1`）和测试4（`get_f2`），文件和键存在；因此，没有错误被触发。在这种情况下，测试4花费的时间更少，如下所示：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The following image is the graphical representation of the preceding code:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图像是前面代码的图形表示：
- en: '![Writing optimized code](img/B04885_07_05.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![编写优化代码](img/B04885_07_05.jpg)'
- en: 'Function calling has overheads and if the performance bottlenecks can be removed
    by reducing function calls, we should do so. Typically, functions call in loops.
    In the following example, when we wrote logic inline, it took less time. Also,
    for PyPy such effects are less in general as most called functions in loops are
    generally called with the same type of arguments; hence, they get compiled. Any
    further call to these functions is like calling a C language function:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 函数调用有开销，如果通过减少函数调用可以消除性能瓶颈，我们应该这样做。通常，函数在循环中调用。在以下示例中，当我们直接编写逻辑时，它花费的时间更少。此外，对于PyPy，这种效果通常较小，因为大多数在循环中调用的函数通常使用相同类型的参数调用；因此，它们被编译。对这些函数的任何进一步调用就像调用C语言函数一样：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The following image is the graphical representation of the preceding code:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图像是前面代码的图形表示：
- en: '![Writing optimized code](img/B04885_07_06.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![编写优化代码](img/B04885_07_06.jpg)'
- en: Profiling to find bottlenecks
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能瓶颈分析
- en: '**Key 2: Identifying application performance bottlenecks.**'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键点2：识别应用程序性能瓶颈。**'
- en: 'We should not rely on our intuition on how to optimize application. There are
    two major ways for logic slowdown; one is CPU time taken, and the second is the
    wait for results from some other entity. By profiling, we can find out such cases
    in which we can tweak logic, and language syntax to get better performance on
    the same hardware. The following code is a `showtime` decorator that I use to
    calculate the time taken to call a function. It is simple and effective to get
    rapid answers:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不应该依赖我们的直觉来优化应用程序。逻辑缓慢主要有两种方式；一种是CPU时间，另一种是等待来自其他实体的结果。通过分析，我们可以找出可以调整逻辑和语言语法的案例，以在相同硬件上获得更好的性能。以下是一个`showtime`装饰器，我使用它来计算函数调用的耗时。它简单而有效，可以快速得到答案：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This will give us the following output:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给出以下输出：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'When profiling a single large function that does a lot of stuff, we may need
    to know on what particular line we are spending the most time. This query can
    be answered using the `line_profiler` module. You can get it with `pip install
    line_profiler`. It shows the time that is spent per line. To get results, we should
    decorate the function with a special profile decorator that will be used by `line_profiler`:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当分析单个大型函数时，该函数执行了大量操作，我们可能需要知道我们花费最多时间的是哪一行。这个问题可以通过使用`line_profiler`模块来回答。你可以使用`pip
    install line_profiler`来获取它。它显示了每行花费的时间。要获取结果，我们应该用特殊的profile装饰器装饰函数，该装饰器将由`line_profiler`使用：
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This will give us the following output:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给出以下输出：
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Another way of profiling is using the `kernprof` program that is supplied with
    the `line_profiler` module. We have to decorate the function to be a profiler
    by the `@profile` decorator and run the program, as shown in the following code
    snippet:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种分析方法是使用`line_profiler`模块提供的`kernprof`程序。我们必须使用`@profile`装饰器将函数装饰为分析器，并运行程序，如下面的代码片段所示：
- en: '[PRE10]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The output for this will be as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 此输出的结果如下：
- en: '[PRE11]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Memory profilers are a very good tool to estimate memory consumption in a program.
    To profile a function, simply decorate it with profile and run the program like
    this:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 内存分析器是估计程序内存消耗的一个非常好的工具。要分析一个函数，只需用profile装饰它，然后像这样运行程序：
- en: '[PRE12]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To get details on the command line, use the following code:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 要在命令行上获取详细信息，请使用以下代码：
- en: '[PRE13]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We can also use it to debug long-running programs. The following code is for
    a simple socket server. It adds lists to the global lists variable, which never
    gets deleted. Saving contents in `simple_serv.py` is as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以用它来调试长时间运行的程序。以下代码是一个简单的套接字服务器。它将列表添加到全局列表变量中，该变量永远不会被删除。在`simple_serv.py`中保存内容如下：
- en: '[PRE14]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, run the program via profiler as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通过以下方式运行程序，使用分析器：
- en: '[PRE15]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Put some bogus hits to the server. I used the `netcat` utility:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 向服务器发送一些无效的请求。我使用了`netcat`实用程序：
- en: '[PRE16]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Kill the server after some time and plot the memory consumed over time with
    the following code:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在一段时间后杀死服务器，并使用以下代码绘制随时间消耗的内存：
- en: '[PRE17]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We get a good graph showing us memory consumption over time:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了一张很好的图表，显示了随时间变化的内存消耗：
- en: '![Profiling to find bottlenecks](img/B04885_07_07.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![分析以找到瓶颈](img/B04885_07_07.jpg)'
- en: Other than getting program memory consumption, we may be interested in objects
    carrying spaces. Objgraph ([https://pypi.python.org/pypi/objgraph](https://pypi.python.org/pypi/objgraph))
    is able to graph object links for your programs. Guppy ([https://pypi.python.org/pypi/guppy/](https://pypi.python.org/pypi/guppy/))
    is another package that has heapy, which is a heap analysis tool. It is very helpful
    to see the number of objects on heap for a running program. As of this writing,
    it was only available for Python 2\. For analysis of a long-running process, Dowser
    ([https://pypi.python.org/pypi/dowser](https://pypi.python.org/pypi/dowser)) is
    also a good choice. We can use Dowser to see the memory consumption to run Celery
    or a WSGI server. Django-Dowser is good and provides the same functionality as
    an app, but as the name suggests, it only works with Django.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 除了获取程序内存消耗外，我们还可能对携带空格的对象感兴趣。Objgraph ([https://pypi.python.org/pypi/objgraph](https://pypi.python.org/pypi/objgraph))
    能够为你的程序绘制对象链接图。Guppy ([https://pypi.python.org/pypi/guppy/](https://pypi.python.org/pypi/guppy/))
    是另一个包含heapy的包，heapy是一个堆分析工具。对于查看运行程序中堆上的对象数量非常有帮助。截至本文写作时，它仅适用于Python 2。对于分析长时间运行的过程，Dowser
    ([https://pypi.python.org/pypi/dowser](https://pypi.python.org/pypi/dowser)) 也是一个不错的选择。我们可以使用Dowser来查看Celery或WSGI服务器的内存消耗。Django-Dowser很好，并且提供了一个与应用程序相同的功能，但正如其名所示，它仅与Django兼容。
- en: Using fast libraries
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用快速库
- en: '**Key 3: Use easy drop-in faster libraries.**'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键3：使用易于替换的快速库。**'
- en: There are libraries out there that can help a lot in optimizing code, rather
    than writing some optimized routines yourself. For example, if we have a list
    that needs to be fast at FIFO, we may use the `blist` package. We can use C versions
    of libraries, such as `cStringIO` (faster StringIO), `ujson` (faster JSON handling),
    `numpy` (math, and vectors), and `lxml` (XML handling). Most of the libraries
    that are listed here are just a Python wrapper over C libraries. You only need
    to search once for your problem domain. Other than this, we can make a C, or C++
    library interface with Python very easily, which is also our next topic.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多库可以帮助优化代码，而不是自己编写一些优化例程。例如，如果我们有一个需要快速 FIFO 的列表，我们可能会使用 `blist` 包。我们可以使用库的
    C 版本，如 `cStringIO`（比 StringIO 更快）、`ujson`（比 JSON 处理更快）、`numpy`（数学和向量）和 `lxml`（XML
    处理）。这里列出的大多数库只是 C 库的 Python 封装。您只需为您的问题域搜索一次。除此之外，我们还可以非常容易地用 Python 创建 C 或 C++
    库接口，这也是我们下一个话题。
- en: Using C speeds
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 C 加速
- en: '**Key 4: Running at C speeds.**'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键 4：以 C 速度运行。**'
- en: SWIG
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SWIG
- en: 'SWIG is an interface compiler that connects programs written in C, and C++
    with scripting languages. We can use SWIG to call C, C++ compiled in Python. Let''s
    say that we have a factorial computing library in C, with source code in the `fact.c`
    file and the corresponding `fact.h` header file:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: SWIG 是一个接口编译器，它将 C 和 C++ 编写的程序与脚本语言连接起来。我们可以使用 SWIG 在 Python 中调用编译好的 C 和 C++。假设我们有一个在
    C 中编写的阶乘计算库，源代码在 `fact.c` 文件中，相应的头文件是 `fact.h`：
- en: 'The source code in `fact.c` is as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`fact.c` 中的源代码如下：'
- en: '[PRE18]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The source code in `fact.h` is as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`fact.h` 中的源代码如下：'
- en: '[PRE19]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, we need to write an interface file for SWIG, which tells it what it needs
    to be exposed to Python:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要为 SWIG 编写一个接口文件，告诉它需要暴露给 Python 的内容：
- en: '[PRE20]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Here, module indicates the module name for the Python library, and `SWIG_FILE_WITH_INIT`
    indicates that the resulting C code should be built with a Python extension. The
    content in `{% %}` is used in the C wrap code that is generated. We have three
    files, `fact.c`, `fact.h`, and `fact.i`, in directory. We run SWIG to generate
    `wrapper_code` as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，模块表示 Python 库的模块名称，而 `SWIG_FILE_WITH_INIT` 表示生成的 C 代码应该与 Python 扩展一起构建。`{%
    %}` 中的内容用于生成的 C 封装代码。我们在目录中有三个文件，`fact.c`、`fact.h` 和 `fact.i`。我们运行 SWIG 生成 `wrapper_code`，如下所示：
- en: '[PRE21]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `-O` option is used for optimizations and `-py3` is for Python 3 specific
    features.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`-O` 选项用于优化，`-py3` 是用于 Python 3 特定功能的。'
- en: 'This generates `fact.py` and `fact_wrap.c`. The `fact.py` is a Python module
    and `fact_wrap.c` is the glue code between C and Python:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成 `fact.py` 和 `fact_wrap.c`。`fact.py` 是一个 Python 模块，而 `fact_wrap.c` 是 C 和
    Python 之间的粘合代码：
- en: '[PRE22]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Here, I have to include my `python.h` path to compile it. This will generate
    `fact.o` and `fact_wrap.o`. Now, the last part is to create a dynamic linked library,
    as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我必须包含我的 `python.h` 路径以编译它。这将生成 `fact.o` 和 `fact_wrap.o`。现在，最后一部分是创建动态链接库，如下所示：
- en: '[PRE23]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `_fact.so` file is used by the `fact.py` to run C functions. Now, we can
    use the fact module in our Python programs:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`_fact.so` 文件被 `fact.py` 用于运行 C 函数。现在，我们可以在我们的 Python 程序中使用 fact 模块：'
- en: '[PRE24]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: CFFI
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CFFI
- en: The **C Foreign Function Interface** (**CFFI**) for Python is one tool that
    looks the best to me because of the easy setup and interface. It works on an ABI
    and API level.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的 **C 外部函数接口**（**CFFI**）是我认为最好的一个工具，因为它设置简单，界面友好。它在 ABI 和 API 层面上工作。
- en: 'Using our factorial C programs here as well, we first create a shared library
    for the code:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们的阶乘 C 程序，我们首先为代码创建一个共享库：
- en: '[PRE25]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, we have a `_fact.so` shared library object in our current directory. To
    load this in the Python environment, we can perform this action which is very
    straightforward. We should have header files for the library so that we can use
    declarations. Install the CFFI package from distribution or pip that is needed
    for this, as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们在当前目录中有一个 `_fact.so` 共享库对象。要在 Python 环境中加载它，我们可以执行以下非常直接的操作。我们应该有库的头文件，以便我们可以使用声明。按照以下方式从发行版或
    pip 安装所需的 CFFI 包：
- en: '[PRE26]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We can reduce import times for the module if we do not call `cdef` in the import
    modules. We can write another `setup_fact_ffi.py` module that gives us a `fact_ffi.py`
    module with the compiled information. Hence, the load times decrease a lot:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在导入模块时不调用 `cdef`，我们可以减少模块的导入时间。我们可以编写另一个 `setup_fact_ffi.py` 模块，它给我们一个带有编译信息的
    `fact_ffi.py` 模块。因此，加载时间大大减少：
- en: '[PRE27]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We now can use this module to get `ffi` and load our shared library as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用此模块来获取 `ffi` 并加载我们的共享库，如下所示：
- en: '[PRE28]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Until this point, as we were using a precompiled shared library, we didn't need
    a compiler. Let's suppose that there is this small C function that you need in
    Python, and you do not want to write another .c file for it, then this is how
    it can be done. You can also extend it to shared libraries as well.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，因为我们使用的是预编译的共享库，所以我们不需要编译器。假设你需要在Python中使用这个小的C函数，而你不想为它再写一个.c文件，那么可以这样操作。你还可以将其扩展到共享库。
- en: 'First, we define a `build_ffi.py` file, which will compile and create a module
    for us:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义一个`build_ffi.py`文件，它将为我们编译并创建一个模块：
- en: '[PRE29]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'When we run Python `fact_build.py`, this will create a `_fact_cffi.cpython-34m.so`
    module. To use it, we have to import it and use the `lib` variable to access the
    module:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行Python的`fact_build.py`时，这将创建一个`_fact_cffi.cpython-34m.so`模块。要使用它，我们必须导入它并使用`lib`变量来访问模块：
- en: '[PRE30]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Cython
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Cython
- en: Cython is like a superset of Python in which we can optionally give static declarations.
    The source code is compiled to C/C++ extension modules.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Cython类似于Python的超集，在其中我们可以选择性地提供静态声明。源代码被编译成C/C++扩展模块。
- en: 'We write our old factorial program in `fact_cpy.pyx` as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将旧的阶乘程序写入`fact_cpy.pyx`，如下所示：
- en: '[PRE31]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Here `cpdef` is the function declaration for CPython that creates a Python function
    and conversion logic for arguments, and a C function that actually executes. `cpdef`
    is defining the data type for the res variable, which helps in speedup.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`cpdef`是CPython的函数声明，它创建一个Python函数和参数转换逻辑，以及一个实际执行的C函数。`cpdef`定义了res变量的数据类型，这有助于加速。
- en: 'We have to create a `setup.py` file to compile this code into an extension
    module (we can directly use it by using `pyximport` but we will leave that for
    now). The contents for the `setup.py` file will be as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须创建一个`setup.py`文件来将此代码编译成扩展模块（我们可以直接使用`pyximport`，但现在我们将留到以后）。`setup.py`文件的内容如下：
- en: '[PRE32]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now to build the module, all we have to do is type in the following command,
    and we get a `fact_cpy.cpython-34m.so` file in the current directory:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在要构建模块，我们只需输入以下命令，我们就会在当前目录中得到一个`fact_cpy.cpython-34m.so`文件：
- en: '[PRE33]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Using this in Python is as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中使用此方法如下：
- en: '[PRE34]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Summary
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we saw various techniques that are used to optimize and profile
    code. I will, again, point out that we should always focus on first writing the
    correct program, then writing test cases for it, and then optimizing it. We should
    write code with optimizations that we know at that time or without optimization
    the first time, and we should hunt for them only if we need them from a business
    perspective. Compiling a C module can give a good speedup for CPU-intensive tasks.
    Also, we can give up GIL in C modules, which can also help us in increasing performance.
    But, all of this was on single system. Now, in the next chapter, we will see how
    we can improve performance when the tricks that were discussed in this chapter
    are not sufficient for a real-life scenario.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了各种用于优化和性能分析的技巧。我再次指出，我们应该始终首先编写正确的程序，然后为其编写测试用例，最后再进行优化。我们应该编写当时我们知道如何优化的代码，或者第一次不进行优化，只有在从业务角度需要时才去寻找优化。编译C模块可以为CPU密集型任务提供良好的加速。此外，我们可以在C模块中放弃GIL，这也有助于提高性能。但是，所有这些都只是在单系统上。现在，在下一章中，我们将看到当本章讨论的技巧不足以应对现实场景时，我们如何提高性能。
