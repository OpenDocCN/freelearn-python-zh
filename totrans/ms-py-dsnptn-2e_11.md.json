["```py\nclass MyClass:\n    def method1(self):\n        pass\n    def method2(self):\n        pass\ndef top_level_function():\n    pass\n```", "```py\nclass MyClass:\n    def method1(self):\n        pass\n    def method2(self):\n        pass\ndef top_level_function():\n    pass\n```", "```py\nimport os, sys\nimport numpy as np\nfrom mymodule import myfunction\n```", "```py\nimport os\nimport sys\nimport numpy as np\nfrom mymodule import myfunction\n```", "```py\ndef calculateSum(a, b):\n    return a + b\nclass my_class:\n    pass\nmaxValue = 100\n```", "```py\ndef calculate_sum(a, b):\n    return a + b\nclass MyClass:\n    pass\nMAX_VALUE = 100\n```", "```py\n#This is a poorly formatted block comment.\ndef foo():  #This is a poorly formatted inline comment.\n    pass\n```", "```py\n# This is a block comment.\n# It spans multiple lines.\ndef foo():\n    pass  # This is an inline comment.\n```", "```py\nfrom collections import UserList\nclass CustomListA(UserList):\n    pass\nclass CustomListB(UserList):\n    pass\n```", "```py\ndef compare(obj):\n    if type(obj) in (CustomListA, CustomListB):\n        print(\"It's a custom list!\")\n    else:\n        print(\"It's a something else!\")\n```", "```py\ndef better_compare(obj):\n    if isinstance(obj, UserList):\n        print(\"It's a custom list!\")\n    else:\n        print(\"It's a something else!\")\n```", "```py\nobj1 = CustomListA([1, 2, 3])\nobj2 = CustomListB([\"a\", \"b\", \"c\"])\ncompare(obj1)\ncompare(obj2)\nbetter_compare(obj1)\nbetter_compare(obj2)\n```", "```py\nIt's a custom list!\nIt's a custom list!\nIt's a custom list!\nIt's a custom list!\n```", "```py\ndef manipulate(mylist=[]):\n    mylist.append(\"test\")\n    return mylist\n```", "```py\ndef better_manipulate(mylist=None):\n    if not mylist:\n        mylist = []\n    mylist.append(\"test\")\n    return mylist\n```", "```py\nif __name__ == \"__main__\":\n    print(\"function manipulate()\")\n    print(manipulate())\n    print(manipulate())\n    print(manipulate())\n    print(\"function better_manipulate()\")\n    print(better_manipulate())\n    print(better_manipulate())\n```", "```py\nfunction manipulate()\n['test']\n['test', 'test']\n['test', 'test', 'test']\nfunction better_manipulate()\n['test']\n\"test\" string several times in the list returned; the string is accumulating because each subsequent time the function has been called, the mylist argument kept its previous value instead of being reset to the empty list. But, with the recommended solution, we see with the result that we get the expected behavior.\n\t\t\tAccessing a protected member from outside a class\n\t\t\tAccessing a protected member (an attribute prefixed with `_`) of a class from outside that class usually calls for trouble since the creator of that class did not intend this member to be exposed. Someone maintaining the code could change or rename that attribute later down the road, and parts of the code accessing it could result in unexpected behavior.\n\t\t\tIf you have code that accesses a protected member that way, the recommended practice is to refactor that code so that it is part of the public interface of the class.\n\t\t\tTo demonstrate this, let’s define a `Book` class with two protected attributes, `_title` and `_author`, as follows:\n\n```", "```py\n\n\t\t\tNow, let’s create another class, `BetterBook`, with the same attributes and a `presentation_line()` method that accesses the `_title` and `_author` attributes and returns a concatenated string based on them. The class definition is as follows:\n\n```", "```py\n\n\t\t\tFinally, in the code for testing both classes, we get and print the presentation line for an instance of each class, accessing the protected members for the first one (instance of `Book`) and calling the `presentation_line()` method for the second one (instance of `BetterBook`), as follows:\n\n```", "```py\n\n\t\t\tThe complete code is in the `ch11/ protected_member_of_class.py` file. Running the `python ch11/ protected_member_of_class.py` command gives the following output:\n\n```", "```py\n\n\t\t\tThis shows that we get the same result, without any error, in both cases, but using the `presentation_line()` method, as done in the case of the second class, is the best practice. The `_title` and `_author` attributes are protected, so it is not recommended to call them directly. The developer could change those attributes in the future. That is why they must be encapsulated in a public method.\n\t\t\tAlso, it is good practice to provide an attribute that encapsulates each protected member of the class using the `@property` decorator, as we have seen in the *Techniques for achieving encapsulation* section of [*Chapter 1*](B21896_01.xhtml#_idTextAnchor017), *Foundational* *Design Principles*.\n\t\t\tMaintainability anti-patterns\n\t\t\tThese anti-patterns make your code difficult to understand or maintain over time. We are going to discuss several anti-patterns that should be avoided for better quality in your Python application or library’s code base. We will focus on the following points:\n\n\t\t\t\t*   Using a wildcard import\n\t\t\t\t*   **Look Before You Leap** (**LBYL**) versus **Easier to Ask for Forgiveness than** **Permission** (**EAFP**)\n\t\t\t\t*   Overusing inheritance and tight coupling\n\t\t\t\t*   Using global variables for sharing data between functions\n\n\t\t\tAs mentioned for the previous category of anti-patterns, using tools such as Flake8 as part of your developer workflow can be handy to help find some of those potential issues when they are already present in your code.\n\t\t\tUsing a wildcard import\n\t\t\tThis way of importing (`from mymodule import *`) can clutter the namespace and make it difficult to determine where an imported variable or function came from. Also, the code may end up with bugs because of name collision.\n\t\t\tThe best practice is to use specific imports or import the module itself to maintain clarity.\n\t\t\tLBYL versus EAFP\n\t\t\tLBYL often leads to more cluttered code, while EAFP makes use of Python’s handling of exceptions and tends to be cleaner.\n\t\t\tFor example, we may want to check if a file exists, before opening it, with code such as the following:\n\n```", "```py\n\n\t\t\tThis is LBYL, and when new to Python, you would think that it is the right way to treat such situations. But in Python, it is recommended to favor EAFP, where appropriate, for cleaner, more Pythonic code. So, the recommended way for the expected result would give the following code:\n\n```", "```py\n\n\t\t\tAs a demonstration, let’s write a `test_open_file()` function that uses the LBYL approach, as follows:\n\n```", "```py\n\n\t\t\tThen, we add a function that uses the recommended approach:\n\n```", "```py\n\n\t\t\tWe can then test these functions with the following code:\n\n```", "```py\n\n\t\t\tYou can check the complete code of the example in the `ch11/lbyl_vs_eafp.py` file, and running it should give the following output:\n\n```", "```py\nclass GrandParent:\n    pass\nclass Parent(GrandParent):\n    pass\nclass Child(Parent):\n    Pass\n```", "```py\nclass Parent:\n    pass\nclass Child:\n    def __init__(self, parent):\n        self.parent = parent\n```", "```py\n# Global variable\ncounter = 0\ndef increment():\n    global counter\n    counter += 1\ndef reset():\n    global counter\n    counter = 0\n```", "```py\nclass Counter:\n    def __init__(self):\n        self.counter = 0\n    def increment(self):\n        self.counter += 1\n    def reset(self):\n        self.counter = 0\n```", "```py\nif __name__ == \"__main__\":\n    c = Counter()\n    print(f\"Counter value: {c.counter}\")\n    c.increment()\n    print(f\"Counter value: {c.counter}\")\n    c.reset()\n```", "```py\nCounter value: 0\nCounter value: 1\n```", "```py\ndef concatenate(string_list):\n    result = \"\"\n    for item in string_list:\n        result += item\n    return result\n```", "```py\ndef better_concatenate(string_list):\n    result = \"\".join(string_list)\n    return result\n```", "```py\nif __name__ == \"__main__\":\n    string_list = [\"Abc\", \"Def\", \"Ghi\"]\n    print(concatenate(string_list))\n    print(better_concatenate(string_list))\n```", "```py\nAbcDefGhi\n.join() is the recommended practice for performance reasons.\n\t\t\tUsing global variables for caching\n\t\t\tUsing global variables for caching can seem like a quick and easy solution but often leads to poor maintainability, potential data consistency issues, and difficulties in managing the cache life cycle effectively. A more robust approach involves using specialized caching libraries designed to handle these aspects more efficiently.\n\t\t\tIn this example (in the `ch11/caching/using_global_var.py` file), a global dictionary is used to cache results from a function that simulates a time-consuming operation (for example, a database query) done in the `perform_expensive_operation()` function. The complete code for this demonstration is as follows:\n\n```", "```py\n\n\t\t\tTesting the code by running the `python ch11/caching/using_global_var.py` command gives the following output:\n\n```", "```py\nimport random\nimport time\nfrom functools import lru_cache\n@lru_cache(maxsize=100)\ndef get_data(user_id):\n    return perform_expensive_operation(user_id)\ndef perform_expensive_operation(user_id):\n    time.sleep(random.uniform(0.5, 2.0))\n    user_data = {\n        1: {\"name\": \"Alice\", \"email\": \"alice@example.com\"},\n        2: {\"name\": \"Bob\", \"email\": \"bob@example.com\"},\n        3: {\"name\": \"Charlie\", \"email\": \"charlie@example.com\"},\n    }\n    result = user_data.get(user_id, {\"error\": \"User not found\"})\n    return result\nif __name__ == \"__main__\":\n    print(get_data(1))\n    print(get_data(1))\n    print(get_data(2))\n    print(get_data(99))\n```", "```py\n{'name': 'Alice', 'email': 'alice@example.com'}\n{'name': 'Alice', 'email': 'alice@example.com'}\n{'name': 'Bob', 'email': 'bob@example.com'}\n{'error': 'User not found'}\n```", "```py\n\n```", "```py\n\n```"]