<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Massimo Di Pierro</h1></div></div></div><div><img src="img/B08180_12_01.jpg" alt="Massimo Di Pierro"/></div><p>Massimo Di Pierro<a id="id144" class="indexterm"/> is an Italian web developer, data science expert, and lecturer. For the last 15 years, Massimo has been a professor for the School of Computing at DePaul University in Chicago. He is the inventor and lead developer of web2py, an <a id="id145" class="indexterm"/>open source web application framework written in Python. Massimo is a regular contributor to open source Python projects around the world and has published <a id="id146" class="indexterm"/>three books on Python, including <em>Annotated Algorithms in Python</em>. His active work in the Python community has seen him elected a member of the Python Software Foundation (PSF).</p><div><blockquote class="blockquote"><p>
<strong>Discussion themes: web2py, Python books, v2.7/v3.x.</strong>
</p><p>
<strong>Catch up with Massimo Di Pierro here: @mdipierro</strong>
</p></blockquote></div><p>
<strong>Mike Driscoll</strong>: How <a id="id147" class="indexterm"/>did you become a computer programmer?</p><p>
<strong>Massimo Di Pierro</strong>: So I am a physicist, but I actually started computer programming when I was in middle school. My dad had the IBM PC at home. He was a COBOL programmer and he was mostly working with accounting software.</p><p>When <a id="id148" class="indexterm"/>I was 13 years old, my dad gave a lecture on COBOL. I went with him and he thought I was just tagging along, but I understood what he was saying and something clicked. My dad then got me a Commodore 64 and I started programming in BASIC first, and Pascal later.</p><p>
<strong>Driscoll</strong>: So how did you get into the Python language?</p><p>
<strong>Di Pierro</strong>: That was much later. I was doing my Ph.D. in the UK and I was mostly programming in Fortran, C, and C++. My work was on lattice quantum chromodynamics and my machine was a Cray T3E. That was when I started learning Python. At the time, it was mostly used as a tool to automate the processing of file and scripting maintenance tasks. By 2004, it had become my favorite language.</p><p>
<strong>Driscoll</strong>: Was <a id="id149" class="indexterm"/>there some epiphany that made you decide that Python was your favorite language, or were you just using the language so much?</p><p>
<strong>Di Pierro</strong>: So, at the time, a lot of the libraries that exist today were either not available, or not as mature.</p><p>The thing that I really liked about Python was that I could do introspection: I could ask a function what its arguments were. So using Python, I could write code that would understand itself to some extent.</p><div><blockquote class="blockquote"><p>
<strong>Di Pierro: 'Using Python, I could write code that would understand itself to some extent.'</strong>
</p></blockquote></div><p>I remember doing something similar in BASIC many years before, but I could not easily do that in a language like C++. I really liked the idea of writing a program that could rewrite itself. For example, I have written a library called <a id="id150" class="indexterm"/>OCL that allows me to decorate some simple functions in Python, and they get converted at runtime, in C or OpenCL, and run at a higher speed (it uses PyOpenCL).</p><p>
<strong>Driscoll</strong>: So what made you <a id="id151" class="indexterm"/>create web2py?</p><p>
<strong>Di Pierro</strong>: So web2py<a id="id152" class="indexterm"/> started in 2007. At that time, the two most popular Python frameworks were Django and TurboGears. I had two needs: I wanted to teach web development in the model-view-controller architecture, and for myself I needed to build some web apps.</p><p>I was evaluating <a id="id153" class="indexterm"/>Django and TurboGears, and I had been using Django for some time. I had built a <a id="id154" class="indexterm"/>content management system for the United Nations in Django, as pro bono work with the university. So I knew Django pretty well, but I thought that Django was verbose and kind of difficult to teach as a first framework.</p><p>In order to be able to prime in Django for example, you needed to have some familiarity with the Bash shell and some system administration tools. A lot of my students at that time did not have that experience. So I wanted to teach web development in Python, but for me to go through all the tools to get to that point was too much work. I needed a framework that would download a file, start, and do everything through the web interface.</p><div><blockquote class="blockquote"><p>
<strong>Di Pierro: 'I needed a framework that would download a file, start, and do everything through the web interface.'</strong>
</p></blockquote></div><p>I also worked in TurboGears, which in many ways I liked better than Django. But TurboGears was going through a big transition. It was a framework assembled out of components, and a lot of the components were being replaced, because they were not being maintained.</p><p>TurboGears<a id="id155" class="indexterm"/> did not appear to have a stable API and therefore it was not suitable for me as a teaching tool. So I decided to apply what I had learned, and build a framework which, in my opinion, was simpler to start with. I never thought that framework would become as popular as it did.</p><div><blockquote class="blockquote"><p>
<strong>Di Pierro: 'I decided to apply what I had learned, and build a framework which, in my opinion, was simpler to start with.'</strong>
</p></blockquote></div><p>
<strong>Driscoll</strong>: So what do you consider <a id="id156" class="indexterm"/>to be the most important lesson that you learned while you were creating web2py?</p><p>
<strong>Di Pierro</strong>: The most important lesson that I learned was the importance of building a community. I got to know a lot of people by working with them remotely, although many of them I have still never met.</p><p>When I started <a id="id157" class="indexterm"/>web2py I was not familiar with collaboration tools like Git. The first version of web2py used Launchpad. I remember having interactions where people just sent me emails offering their help or making suggestions. I was not prepared for that.</p><div><blockquote class="blockquote"><p>
<strong>Di Pierro: 'I still consider it a critical skill being able to collaborate with people remotely, even if you don't know them personally.'</strong>
</p></blockquote></div><p>I didn't know exactly how to handle collaboration for many years. Today, I still consider it a critical skill being able to collaborate with people remotely, even if you don't know them personally. I mean, eventually I got to know them and trust them a lot. Some of the people I trust the most are people I met through web2py.</p><p>
<strong>Driscoll</strong>: Are there any features that you've seen in FaaS or Django that you think would be good in web2py?</p><p>
<strong>Di Pierro</strong>: web2py<a id="id158" class="indexterm"/> owes a lot to Django, as many ideas came from it, as well as from other frameworks. Yet, we added into web2py many features that Django did not have at the time. For example, stronger default security settings, like always escaping strings by default. The frameworks have very different philosophies.</p><p>There are many projects that use Django and each one has a different name and its own maintainers. They are very advanced and very well maintained. In web2py, we try to keep everything in one package, so that we don't have a big ecosystem outside of the framework.</p><div><blockquote class="blockquote"><p>
<strong>Di Pierro: 'web2py owes a lot to Django, as many ideas came from it, as well as from other frameworks.'</strong>
</p></blockquote></div><p>There are many ideas from web2py that originated in other frameworks, but I believe that we improved on some of those ideas. For example, the mechanism for form generation and processing in web2py is not unique but, when it was developed, it was better than the competition.</p><p>The model-view-controller design architecture was mostly taken from Django and the URL mapping was also very similar. For the latter, we gave it default routing rules, like in Ruby on Rails. For the template language, we decided that we didn't want a domain-specific language. Instead, we wanted pure Python in templates, which is kind of the same model as the ERB template language in Ruby on Rails, but using the Python language.</p><p>There are other features, that were added later in web2py that were also inspired by other frameworks. For example, one thing I liked from Flask was this idea of thread-local variables. So thread-local would allow any module to access the current request object, the current response object, or the current session, even if the code was rooted in a module which was imported from somewhere else. I liked the way Flask handled that.</p><p>So there are definitely many ideas that came from other frameworks and I think there's been a lot of learning from each other. Not everybody admits that, but I'm happy to admit it.</p><div><blockquote class="blockquote"><p>
<strong>Di Pierro: 'There's been a lot of learning from each other. Not everybody admits that, but I'm happy to admit it.'</strong>
</p></blockquote></div><p>
<strong>Driscoll</strong>: So I saw that you<a id="id159" class="indexterm"/> started self-publishing books. How did that happen?</p><p>
<strong>Di Pierro</strong>: I'm an academic, so I'm supposed to write papers and write books. Because I was writing documentation for software, it was extremely important for me to have the ability to update the content of a book quickly. Self-publishing allows that.</p><p>I really believe in open source, not just for code, but in general for educational content. I self-publish my books almost at cost and I make them available for free download. For me, making the content up-to-date and available quickly is the priority.</p><p>Moreover, if I write a book, then it is because I want people to read it, not because I think there is a profit to be made. In the end, the validation of the content comes from the readers and not from the publisher. So I found that self-publishing was ideal for me. That said, once you're done with a book, then you don't want to touch it too much. Instead, you want to write another book!</p><p>
<strong>Driscoll</strong>: Did you have any challenges <a id="id160" class="indexterm"/>that you needed to overcome when you were writing your books?</p><p>
<strong>Di Pierro</strong>: Well, first of all, I'm not a native English speaker. So I can write, but I tend to make a lot of mistakes. It takes me forever to review things and make sure that they are fixed.</p><div><blockquote class="blockquote"><p>
<strong>Di Pierro: 'Even if I consider myself an expert, that does not mean that I know everything about a subject.'</strong>
</p></blockquote></div><p>Another challenge is that even if I consider myself an expert, that does not mean that I know everything about a subject. I always have a process, which is to write the code first. Then I look at the code and I turn the code into a paper or a book. In that way, I manage to make the text consistent with the code examples. If you change the code after you've written the text, then sometimes the text gets out of sync, so I really try to make sure that my examples are as good and as complete as possible.</p><p>One challenge surrounding<a id="id161" class="indexterm"/> the book <em>web2py</em> was that I had a lot of people submitting pull requests to the book on GitHub. They initially contributed by making small corrections, but now sometimes they contribute quite substantially.</p><p>Keeping track of contributors was difficult, because I knew their GitHub names, but I couldn't acknowledge them as people properly. People always send me code, but they never submit the pull request in the acknowledgements section. It's work for me to figure out who these people are to acknowledge them.</p><p>
<strong>Driscoll</strong>: So as a scientist, or a teacher, how <a id="id162" class="indexterm"/>do you see Python helping the scientific community?</p><p>
<strong>Di Pierro</strong>: I can see that Python has been growing a lot and especially within the scientific community. In particular, I've seen growth with all of the machine learning stuff that's been coming out, such as sklearn, TensorFlow, and Keras.</p><p>I remember when I started teaching 15 years ago, people didn't know what Python was. Some colleagues were objecting to a switch from Java to Python as the primary teaching language. Python was considered by many to be "only a scripting language" and something very specialized.</p><div><blockquote class="blockquote"><p>
<strong>Di Pierro: 'Python was considered by many to be "only a scripting language" and something very specialized.'</strong>
</p></blockquote></div><p>Today, in almost every class we teach, whether it's a neural network class, a machine learning class, or a data analysis class, almost everybody uses Python. So things have really changed a lot in that respect.</p><div><blockquote class="blockquote"><p>
<strong>Di Pierro: 'The major problem I see is that the relation between Python 2 and Python 3 is still an issue.'</strong>
</p></blockquote></div><p>The major problem I see is that the relation between Python 2 and Python 3 is still an issue. At DePaul University, we use Python 3 almost everywhere, whereas the industry still uses mostly Python 2 everywhere, which is a problem sometimes.</p><p>Another issue is that very few people use the new async logic that is available in Python 3. I think Python's new async logic is really powerful, but it's not as friendly as JavaScript's async logic. People who really like event-driven async programming tend to prefer JavaScript (and Node.js) over Python.</p><div><blockquote class="blockquote"><p>
<strong>Di Pierro: 'I think Python's new async logic is really powerful, but it's not as friendly as JavaScript's async logic.'</strong>
</p></blockquote></div><p>
<strong>Driscoll</strong>: I'm actually a little bit concerned about these other companies that are starting to support Python 2. What do you think is going to happen to these splinter groups, that are following Anaconda or Intel, if they continue to support Python 2 instead of 3?</p><p>
<strong>Di Pierro</strong>: Well, I don't argue about the fact that <a id="id163" class="indexterm"/>Python 3 is a better language than Python 2, but I think that migration from Python 2 to Python 3 is difficult. It cannot be completely automated and often it requires understanding the code. People do not want to touch things that currently work.</p><div><blockquote class="blockquote"><p>
<strong>Di Pierro: 'I don't argue about the fact that Python 3 is a better language than Python 2, but I think that migration from Python 2 to Python 3 is difficult.'</strong>
</p></blockquote></div><p>For example, the <code class="literal">str</code> function in Python 2 converts to a string of bytes, but in Python 3, it converts to Unicode. So this makes it impossible to switch from Python 2 to Python 3, without actually going through the code and understanding what type of input is being passed to the function, and what kind of output is expected.</p><p>A naïve conversion may work very well as long as you don't have any strange characters in your input (like byte sequences that do not map into Unicode). When that happens, you don't know if the code is doing what it was supposed to do originally or not. Consider banks, for example. They have huge codebases in Python, which have been developed and tested over many years. They are not going to switch easily because it is difficult to justify that cost. Consider this: some banks still use COBOL.</p><p>There are tools to help with the transition<a id="id164" class="indexterm"/> from Python 2 to Python 3. I'm not really an expert on those tools, so a lot of the problems I see may have a solution that I'm not aware of. But I still found that each time I had to convert code, this process was not as straightforward as I would like.</p><p>
<strong>Driscoll</strong>: Do you see Python having any <a id="id165" class="indexterm"/>challenges in its adoption by data science?</p><p>
<strong>Di Pierro</strong>: I think that data scientists love Python. The major competitor is R and I get the impression that R is more popular among economists and statisticians. But I don't think R is more popular because it's better, only because it has been around longer and it is more focused.</p><p>R has been around for a long time and people know what they can do with R. The people who know the language well don't see the need to learn something different. R has always been focused on data science specifically, so people in that community are more familiar with that language.</p><div><blockquote class="blockquote"><p>
<strong>Di Pierro: 'I see Python being adopted more and more and eventually becoming more popular than R for data science.'</strong>
</p></blockquote></div><p>I would compare R not so much with Python as a language, but with the pandas library. I think that Python plus pandas makes a compelling case in a comparison with R. That, in fact, is what I am using right now in a machine learning class. But I see Python being adopted more and more and eventually becoming more popular than R for data science. I've no doubt that will happen.</p><p>
<strong>Driscoll</strong>: Thank you, Massimo Di Pierro.</p></div></body></html>