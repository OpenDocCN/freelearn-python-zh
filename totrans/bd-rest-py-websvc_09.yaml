- en: Chapter 9.  Developing RESTful APIs with Tornado
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 9 章：使用 Tornado 开发 RESTful API
- en: 'In this chapter, we will work with Tornado to create a RESTful Web API and
    start working with this lightweight Web framework. We will cover the following
    topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用 Tornado 创建 RESTful 网络API，并开始使用这个轻量级网络框架。我们将涵盖以下主题：
- en: Designing a RESTful API to interact with slow sensors and actuators
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计一个与慢速传感器和执行器交互的 RESTful API
- en: Understanding the tasks performed by each `HTTP` method
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解每个 `HTTP` 方法执行的任务
- en: Setting up a virtual environment with Tornado
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Tornado 设置虚拟环境
- en: Declaring status codes for the responses
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明响应的状态码
- en: Creating the classes that represent a drone
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建表示无人机的类
- en: Writing request handlers
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写请求处理器
- en: Mapping URL patterns to request handlers
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 URL 模式映射到请求处理器
- en: Making HTTP requests to the Tornado API
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向 Tornado API 发送 HTTP 请求
- en: Working with command-line tools - curl and HTTPie
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用命令行工具 - curl 和 HTTPie
- en: Working with GUI tools - Postman and others
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 GUI 工具 - Postman 以及其他工具
- en: Designing a RESTful API to interact with slow sensors and actuators
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计一个与慢速传感器和执行器交互的 RESTful API
- en: Imagine that we have to create a RESTful API to control a drone, also known
    as an **Unmanned Aerial Vehicle** (**UAV**). The drone is an IoT device that interacts
    with many sensors and actuators, including digital electronic speed controllers
    linked to engines, propellers, and servomotors.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们必须创建一个 RESTful API 来控制无人机，也称为**无人驾驶飞行器**（**UAV**）。无人机是一个物联网设备，与许多传感器和执行器交互，包括与发动机、螺旋桨和伺服电机连接的数字电子速度控制器。
- en: The IoT device has limited resources, and therefore, we have to use a lightweight
    Web framework. Our API doesn't need to interact with a database. We don't need
    a heavyweight Web framework like Django, and we want to be able to process many
    requests without blocking the Web server. We need the Web server to provide us
    with good scalability while consuming limited resources. Thus, our choice is to
    use Tornado, the open source version of FriendFeed's Web server.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 物联网设备资源有限，因此我们必须使用轻量级网络框架。我们的 API 不需要与数据库交互。我们不需要像 Django 这样的重型网络框架，我们希望能够在不阻塞
    Web 服务器的情况下处理许多请求。我们需要 Web 服务器为我们提供良好的可扩展性，同时消耗有限的资源。因此，我们的选择是使用 Tornado，这是 FriendFeed
    Web 服务器的开源版本。
- en: The IoT device is capable of running Python 3.5, Tornado, and other Python packages.
    Tornado is a Python Web framework and an asynchronous networking library that
    provides excellent scalability due to its non-blocking network I/O. In addition,
    Tornado will allow us to easily and quickly build a lightweight RESTful API.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 物联网设备能够运行 Python 3.5、Tornado 以及其他 Python 包。Tornado 是一个 Python 网络框架和异步网络库，由于其非阻塞网络
    I/O，提供了出色的可扩展性。此外，Tornado 将使我们能够轻松快速地构建轻量级的 RESTful API。
- en: We have chosen Tornado because it is more lightweight than Django and it makes
    it easy for us to create an API that takes advantage of the non-blocking network
    I/O. We don't need to use an ORM, and we want to start running the RESTful API
    on the IoT device as soon as possible to allow all the teams to interact with
    it.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择 Tornado 是因为它比 Django 更轻量级，它使我们能够轻松创建一个利用非阻塞网络 I/O 的 API。我们不需要使用 ORM，并希望尽快在物联网设备上运行
    RESTful API，以便所有团队都能与之交互。
- en: We will interact with a library that allows us to run the slow I/O operations
    that interact with the sensors and actuators with an execution that happens outside
    the **Global Interpreter Lock** (**GIL**). Thus, we will be able to take advantage
    of the non-blocking feature in Tornado when a request needs to execute any of
    these slow I/O operations. In our first version of the API, we will work with
    a synchronous execution, and therefore, when an HTTP request to our API requires
    running a slow I/O operation, we will block the request processing queue until
    the slow I/O operation with either a sensor or an actuator provides a response.
    We will execute the I/O operation with a synchronous execution and Tornado won't
    be able to continue processing other incoming HTTP requests until a response is
    sent to the HTTP request.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将交互一个库，允许我们在**全局解释器锁**（**GIL**）之外执行与传感器和执行器交互的慢速 I/O 操作。因此，当请求需要执行这些慢速 I/O
    操作之一时，我们将利用 Tornado 的非阻塞特性。在我们的 API 第一个版本中，我们将使用同步执行，因此，当我们的 API 的 HTTP 请求需要运行慢速
    I/O 操作时，我们将阻塞请求处理队列，直到传感器或执行器的慢速 I/O 操作提供响应。我们将使用同步执行执行 I/O 操作，并且 Tornado 不会继续处理其他传入的
    HTTP 请求，直到向 HTTP 请求发送响应。
- en: Then, we will create a second version of our API that will take advantage of
    the non-blocking features included in Tornado, in combination with asynchronous
    operations. In the second version, when an HTTP request to our API requires running
    a slow I/O operation, we won't block the request processing queue until the slow
    I/O operation with either a sensor or an actuator provides a response. We will
    execute the I/O operation with an asynchronous execution, and Tornado will be
    able to continue processing other incoming HTTP requests.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将创建我们API的第二个版本，该版本将利用Tornado中包含的非阻塞特性，结合异步操作。在第二个版本中，当我们的API的HTTP请求需要运行慢速I/O操作时，我们不会阻塞请求处理队列，直到慢速I/O操作（与传感器或执行器）提供响应。我们将以异步执行执行I/O操作，Tornado将继续处理其他传入的HTTP请求。
- en: Tip
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: We will keep our example simple and we won't use a library to interact with
    sensors and actuators. We will just print information about the operations that
    will be performed by these sensors and actuators. However, in our second version
    of the API, we will write our code to make asynchronous calls in order to understand
    the advantages of the non-blocking features in Tornado. We will use a simplified
    set of sensors and actuators—bear in mind that drones usually have more sensors
    and actuators. Our goal is to learn how to work with Tornado to build a RESTful
    API; we don't want to become experts in building drones.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将保持示例简单，并且不会使用库与传感器和执行器交互。我们只需打印出这些传感器和执行器将要执行的操作信息。然而，在我们的API第二个版本中，我们将编写代码以进行异步调用，以便理解Tornado的非阻塞特性的优势。我们将使用简化的传感器和执行器集——请记住，无人机通常有更多的传感器和执行器。我们的目标是学习如何使用Tornado构建RESTful
    API；我们不想成为构建无人机的专家。
- en: 'Each of the following sensors and actuators will be a resource in our RESTful
    API:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 以下每个传感器和执行器都将成为我们RESTful API中的一个资源：
- en: A hexacopter, that is, a 6-rotor helicopter
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 六旋翼飞行器，即六叶旋翼直升机
- en: An altimeter (altitude sensor)
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高空计（高度传感器）
- en: A blue **LED** (**Light-Emitting Diode**)
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 蓝色**LED**（发光二极管）
- en: A white LED
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 白色LED
- en: 'The following table shows the HTTP verbs, the scope, and the semantics for
    the methods that our first version of the API must support. Each method is composed
    by an HTTP verb and a scope and all the methods have a well-defined meaning for
    all sensors and actuators. In our API, each sensor or actuator has its own unique
    URL:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了我们的API第一个版本必须支持的HTTP动词、作用域和语义。每个方法由一个HTTP动词和一个作用域组成，并且所有方法对所有传感器和执行器都有一个明确的含义。在我们的API中，每个传感器或执行器都有自己的唯一URL：
- en: '| **HTTP verb** | **Scope** | **Semantics** |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| **HTTP动词** | **作用域** | **语义** |'
- en: '| `GET` | Hexacopter | Retrieve the current hexacopter''s motor speed in RPMs
    and its status (turned on or off) |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | 六旋翼飞行器 | 获取当前六旋翼飞行器的电机速度（RPM）及其状态（开启或关闭）|'
- en: '| `PATCH` | Hexacopter | Set the current hexacopter''s motor speed in RPMs
    |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| `PATCH` | 六旋翼飞行器 | 设置当前六旋翼飞行器的电机速度（RPM）|'
- en: '| `GET` | LED | Retrieve the brightness level for a single LED |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | LED | 获取单个LED的亮度级别|'
- en: '| `PATCH` | LED | Update the brightness level for a single LED |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| `PATCH` | LED | 更新单个LED的亮度级别|'
- en: '| `GET` | Altimeter | Retrieve the current altitude in feet |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | 高空计 | 获取当前高度（英尺）|'
- en: Understanding the tasks performed by each HTTP method
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解每个HTTP方法执行的任务
- en: Let's consider that `http://localhost:8888/hexacopters/1` is the URL that identifies
    the hexacopter for our drone.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 假设`http://localhost:8888/hexacopters/1`是标识我们无人机六旋翼飞行器的URL。
- en: 'We have to compose and send an HTTP request with the following HTTP verb (`PATCH`)
    and request URL (`http://localhost:8888/hexacopters/1`) to set the hexacopter''s
    motor speed in RPMs and its status. In addition, we have to provide the JSON key-value
    pairs with the necessary field name and the value to specify the desired speed.
    As a result of the request, the server will validate the provided values for the
    field, make sure that it is a valid speed and make the necessary calls to adjust
    the speed with an asynchronous execution. After the speed for the hexacopter is
    set, the server will return a `200 OK` status code and a JSON body with the recently
    updated hexacopter values serialized to JSON:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须使用以下HTTP动词（`PATCH`）和请求URL（`http://localhost:8888/hexacopters/1`）来组合并发送一个HTTP请求，以设置六旋翼飞行器的电机速度（RPM）及其状态。此外，我们必须提供JSON键值对，包含必要的字段名和值，以指定所需的速度。作为请求的结果，服务器将验证提供的字段值，确保它是一个有效的速度，并以异步执行调用必要的操作来调整速度。在设置六旋翼飞行器的速度后，服务器将返回`200
    OK`状态码和一个JSON体，其中最近更新的六旋翼飞行器值序列化为JSON：
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We have to compose and send an HTTP request with the following HTTP verb (`GET`)
    and request URL (`http://localhost:8888/hexacopter/1`) to retrieve the current
    values for the hexacopter. The server will make the necessary calls to retrieve
    the status and the speed for the hexacopter with an asynchronous execution. As
    a result of the request, the server will return a `200 OK` status code and a JSON
    body with the serialized key-value pairs that specify the status and speed for
    the hexacopter. If a number different than 1 is specified, the server will return
    just a `404 Not Found` status:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须使用以下 HTTP 动词 (`GET`) 和请求 URL (`http://localhost:8888/hexacopter/1`) 编写并发送一个
    HTTP 请求，以检索六旋翼飞行器的当前值。服务器将以异步执行的方式调用必要的操作来检索六旋翼飞行器的状态和速度。请求的结果是，服务器将返回一个 `200
    OK` 状态码和一个包含序列化键值对的 JSON 主体，这些键值对指定了六旋翼飞行器的状态和速度。如果指定的数字不是 1，服务器将仅返回一个 `404 Not
    Found` 状态：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We have to compose and send an HTTP request with the following HTTP verb (`PATCH`)
    and request URL (`http://localhost:8888/led/{id}`) to set the brightness level
    for a specific LED whose id matches the specified numeric value in the place where
    `{id}` is written. For example, if we use the request URL `http://localhost:8888/led/1`,
    the server will set the brightness level for the led whose id matches 1\. In addition,
    we have to provide the JSON key-value pairs with the necessary field name and
    the value to specify the desired brightness level. As a result of the request,
    the server will validate the provided values for the field, make sure that it
    is a valid brightness level and make the necessary calls to adjust the brightness
    level with an asynchronous execution. After the brightness level for the LED is
    set, the server will return a `200 OK` status code and a JSON body with the recently
    updated LED values serialized to JSON:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须使用以下 HTTP 动词 (`PATCH`) 和请求 URL (`http://localhost:8888/led/{id}`) 编写并发送一个
    HTTP 请求，以设置 ID 与 `{id}` 位置指定的数值相匹配的特定 LED 的亮度级别。例如，如果我们使用请求 URL `http://localhost:8888/led/1`，服务器将为
    ID 与 1 匹配的 LED 设置亮度级别。此外，我们必须提供包含必要字段名称和值的 JSON 键值对，以指定所需的亮度级别。请求的结果是，服务器将验证提供的字段值，确保它是一个有效的亮度级别，并以异步执行的方式调用必要的操作来调整亮度级别。在设置
    LED 的亮度级别后，服务器将返回一个 `200 OK` 状态码和一个包含最近更新的 LED 值序列化为 JSON 的 JSON 主体：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We have to compose and send an HTTP request with the following HTTP verb (`GET`)
    and request URL (`http://localhost:8888/led/{id}`) to retrieve the current values
    for the LED whose id matches the specified numeric value in the place where `{id}`
    is written. For example, if we use the request URL `http://localhost:8888/led/1`,
    the server will retrieve the LED whose id matches 1\. The server will make the
    necessary calls to retrieve the values for the LED with an asynchronous execution.
    As a result of the request, the server will return a `200 OK` status code and
    a JSON body with the serialized key-value pairs that specify the values for the
    LED. If no LED matches the specified id, the server will return just a `404 Not
    Found` status:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须使用以下 HTTP 动词 (`GET`) 和请求 URL (`http://localhost:8888/led/{id}`) 编写并发送一个
    HTTP 请求，以检索 ID 与 `{id}` 位置指定的数值相匹配的 LED 的当前值。例如，如果我们使用请求 URL `http://localhost:8888/led/1`，服务器将检索
    ID 与 1 匹配的 LED。服务器将以异步执行的方式调用必要的操作来检索 LED 的值。请求的结果是，服务器将返回一个 `200 OK` 状态码和一个包含序列化键值对的
    JSON 主体，这些键值对指定了 LED 的值。如果没有 LED 与指定的 ID 匹配，服务器将仅返回一个 `404 Not Found` 状态：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We have to compose and send an HTTP request with the following HTTP verb (`GET`)
    and request URL (`http://localhost:8888/altimeter/1`) to retrieve the current
    values for the altimeter. The server will make the necessary calls to retrieve
    the values for the altimeter with an asynchronous execution. As a result of the
    request, the server will return a `200 OK` status code and a JSON body with the
    serialized key-value pairs that specify the values for the altimeter. If a number
    different than 1 is specified, the server will return just a `404 Not Found` status:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须使用以下 HTTP 动词 (`GET`) 和请求 URL (`http://localhost:8888/altimeter/1`) 编写并发送一个
    HTTP 请求，以检索高度计的当前值。服务器将以异步执行的方式调用必要的操作来检索高度计的值。请求的结果是，服务器将返回一个 `200 OK` 状态码和一个包含序列化键值对的
    JSON 主体，这些键值对指定了高度计的值。如果指定的数字不是 1，服务器将仅返回一个 `404 Not Found` 状态：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Setting up a virtual environment with Tornado
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Tornado 设置虚拟环境
- en: In [Chapter 1](ch01.html "Chapter 1. Developing RESTful APIs with Django"),
    *Developing RESTful APIs with Django*, we learned that, throughout this book,
    we were going to work with the lightweight virtual environments introduced in
    Python 3.3 and improved in Python 3.4\. Now, we will follow many steps create
    a new lightweight virtual environment to work with Tornado. It is highly recommended
    to read [Chapter 1](ch01.html "Chapter 1. Developing RESTful APIs with Django"),
    *Developing RESTful APIs with Django*, in case you don't have experience with
    lightweight virtual environments in Python. The chapter includes all the detailed
    explanations about the effects of the steps we are going to follow.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](ch01.html "第1章. 使用Django开发RESTful API")《使用Django开发RESTful API》中，我们了解到，在本书中，我们将使用Python
    3.3中引入并Python 3.4中改进的轻量级虚拟环境。现在，我们将遵循多个步骤创建一个新的轻量级虚拟环境以使用Tornado。强烈建议阅读[第1章](ch01.html
    "第1章. 使用Django开发RESTful API")《使用Django开发RESTful API》，以防你对Python中的轻量级虚拟环境没有经验。该章节包含了我们将遵循的步骤的所有详细解释。
- en: 'First, we have to select the target folder or directory for our virtual environment.
    The following is the path we will use in the example for macOS and Linux. The
    target folder for the virtual environment will be the `PythonREST/Tornado01` folder
    within our home directory. For example, if our home directory in macOS or Linux
    is `/Users/gaston`, the virtual environment will be created within `/Users/gaston/PythonREST/Tornado01`.
    You can replace the specified path with your desired path in each command:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须选择我们的虚拟环境的目标文件夹或目录。以下是我们将在示例中使用的路径，用于macOS和Linux。虚拟环境的目标文件夹将是我们主目录中的`PythonREST/Tornado01`文件夹。例如，如果我们的macOS或Linux中的主目录是`/Users/gaston`，虚拟环境将创建在`/Users/gaston/PythonREST/Tornado01`中。您可以在每个命令中将指定的路径替换为您想要的路径：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We will use the following path in the example for Windows. The target folder
    for the virtual environment will be the `PythonREST\Tornado01` folder within our
    user profile folder. For example, if our user profile folder is `C:\Users\Gaston`,
    the virtual environment will be created within `C:\Users\gaston\PythonREST\Tornado01`.
    You can replace the specified path with your desired path in each command:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例中，我们将使用以下路径，用于Windows。虚拟环境的目标文件夹将是我们用户配置文件文件夹中的`PythonREST\Tornado01`文件夹。例如，如果我们的用户配置文件文件夹是`C:\Users\Gaston`，虚拟环境将创建在`C:\Users\gaston\PythonREST\Tornado01`中。您可以在每个命令中将指定的路径替换为您想要的路径：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Open a Terminal in macOS or Linux and execute the following command to create
    a virtual environment:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在macOS或Linux中打开一个终端并执行以下命令以创建虚拟环境：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In Windows, execute the following command to create a virtual environment:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows中，执行以下命令以创建虚拟环境：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The preceding command doesn't produce any output. Now that we have created a
    virtual environment, we will run a platform-specific script to activate it. After
    we activate the virtual environment, we will install packages that will only be
    available in this virtual environment.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令不会产生任何输出。现在我们已经创建了一个虚拟环境，我们将运行一个特定平台的脚本以激活它。激活虚拟环境后，我们将安装只在此虚拟环境中可用的包。
- en: 'If your Terminal is configured to use the `bash` shell in macOS or Linux, run
    the following command to activate the virtual environment. The command also works
    for the `zsh` shell:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的终端配置为在macOS或Linux中使用`bash` shell，请运行以下命令以激活虚拟环境。该命令也适用于`zsh` shell：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If your Terminal is configured to use either the `csh` or `tcsh` shell, run
    the following command to activate the virtual environment:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的终端配置为使用`csh`或`tcsh` shell，请运行以下命令以激活虚拟环境：
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If your Terminal is configured to use either the `fish` shell, run the following
    command to activate the virtual environment:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的终端配置为使用`fish` shell，请运行以下命令以激活虚拟环境：
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In Windows, you can run either a batch file in the Command Prompt or a Windows
    PowerShell script to activate the virtual environment. If you prefer the command
    prompt, run the following command in the Windows command line to activate the
    virtual environment:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows中，您可以在命令提示符中运行批处理文件或在Windows PowerShell中运行脚本以激活虚拟环境。如果您更喜欢命令提示符，请在Windows命令行中运行以下命令以激活虚拟环境：
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If you prefer the Windows PowerShell, launch it and run the following commands
    to activate the virtual environment. However, notice that you should have scripts
    execution enabled in Windows PowerShell to be able to run the script:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您更喜欢Windows PowerShell，启动它并运行以下命令以激活虚拟环境。但是请注意，您需要在Windows PowerShell中启用脚本执行才能运行脚本：
- en: '[PRE13]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: After you activate the virtual environment, the Command Prompt will display
    the virtual environment root folder name enclosed in parentheses as a prefix of
    the default prompt to remind us that we are working in the virtual environment.
    In this case, we will see (`Tornado01`) as a prefix for the Command Prompt because
    the root folder for the activated virtual environment is `Tornado01`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在激活虚拟环境后，命令提示符将显示括号内的虚拟环境根文件夹名称作为默认提示的前缀，以提醒我们我们正在虚拟环境中工作。在这种情况下，我们将看到（`Tornado01`）作为命令提示符的前缀，因为激活的虚拟环境的根文件夹是
    `Tornado01`。
- en: 'We have created and activated a virtual environment. It is time to run many
    commands that will be the same for either macOS, Linux, or Windows. Now, we must
    run the following command to install Tornado with pip:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建并激活了虚拟环境。现在是时候运行许多命令了，这些命令对 macOS、Linux 或 Windows 都是一样的。现在，我们必须运行以下命令来使用
    pip 安装 Tornado：
- en: '[PRE14]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The last lines for the output will indicate all the packages that have been
    successfully installed, including `tornado`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的最后几行将指示所有成功安装的包，包括 `tornado`：
- en: '[PRE15]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Declaring status codes for the responses
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明响应的状态码
- en: Tornado allows us to generate responses with any status code that is included
    in the `http.HTTPStatus` dictionary. We might use this dictionary to return easy
    to understand descriptions as the status codes, such as `HTTPStatus.OK` and `HTTPStatus.NOT_FOUND`
    after importing the `HTTPStatus` dictionary from the `http` module. These names
    are easy to understand but they don't include the status code number in their
    description.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Tornado 允许我们生成包含在 `http.HTTPStatus` 字典中的任何状态码的响应。我们可能会使用这个字典来返回易于理解的状态码描述，例如在从
    `http` 模块导入 `HTTPStatus` 字典后使用 `HTTPStatus.OK` 和 `HTTPStatus.NOT_FOUND`。这些名称易于理解，但它们的描述中不包含状态码数字。
- en: We have been working with many different frameworks and micro-frameworks throughout
    the book, and therefore, we will borrow the code that declares very useful functions
    and variables related to HTTP status codes from the `status.py` file included
    in Django REST Framework, that is, the framework we have been using in the first
    chapters. The main advantage of using these variables for the HTTP status codes
    is that their names include both the number and the description. When we read
    the code, we will understand the status code number and their meaning. For example,
    instead of using `HTTPStatus.OK`, we will use `status.HTTP_200_OK`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们已经使用了许多不同的框架和微框架，因此，我们将从包含在 Django REST Framework 中的 `status.py` 文件中借用声明与
    HTTP 状态码相关的非常有用的函数和变量的代码，即我们在第一章中使用过的框架。使用这些变量作为 HTTP 状态码的主要优点是它们的名称既包含数字又包含描述。当我们阅读代码时，我们将理解状态码数字及其含义。例如，我们不会使用
    `HTTPStatus.OK`，而是使用 `status.HTTP_200_OK`。
- en: 'Create a new `status.py` file within the root folder for the recently created
    virtual environment. The following lines show the code that declares functions
    and variables with descriptive HTTP status codes in the `status.py` file, borrowed
    from the `rest_framework.status` module. We don''t want to reinvent the wheel
    and the module provides everything we need to work with HTTP status codes in our
    Tornado-based API. The code file for the sample is included in the `restful_python_chapter_09_01`
    folder:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在最近创建的虚拟环境根目录下创建一个新的 `status.py` 文件。以下行展示了在 `status.py` 文件中声明带有描述性 HTTP 状态码的函数和变量的代码，这些代码是从
    `rest_framework.status` 模块借用的。我们不希望重新发明轮子，该模块提供了我们在基于 Tornado 的 API 中处理 HTTP 状态码所需的一切。示例代码文件包含在
    `restful_python_chapter_09_01` 文件夹中：
- en: '[PRE16]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The code declares five functions that receive the HTTP status code in the code
    argument and determine to which of the following categories the status code belongs
    to: informational, success, redirect, and client error or server error categories.
    We will use the previous variables when we have to return a specific status code.
    For example, in case we have to return a `404 Not Found` status code, we will
    return `status.HTTP_404_NOT_FOUND`, instead of just `404` or `HTTPStatus.NOT_FOUND`.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 代码声明了五个函数，这些函数接收代码参数中的 HTTP 状态码，并确定状态码属于以下哪个类别：信息性、成功、重定向以及客户端错误或服务器错误类别。当我们需要返回特定的状态码时，我们将使用之前的变量。例如，如果我们需要返回
    `404 Not Found` 状态码，我们将返回 `status.HTTP_404_NOT_FOUND`，而不是仅仅 `404` 或 `HTTPStatus.NOT_FOUND`。
- en: Creating the classes that represent a drone
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建表示无人机的类
- en: We will create as many classes as we will use to represent the different components
    of a drone. In a real-life example, these classes will interact with a library
    that interacts with sensors and actuators. In order to keep our example simple,
    we will make calls to `time.sleep` to simulate interactions that take some time
    to set or get values to and from sensors and actuators.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建尽可能多的类来表示无人机不同组件。在现实生活中的例子中，这些类将与与传感器和执行器交互的库进行交互。为了使我们的示例简单，我们将调用 `time.sleep`
    来模拟设置或从传感器和执行器设置或获取值所需的时间。
- en: 'First, we will create a `Hexacopter` class that we will use to represent the
    hexacopter and a `HexacopterStatus` class that we will use to store status data
    for the hexacopter. Create a new `drone.py` file. The following lines shows all
    the necessary imports for the classes that we will create and the code that declares
    the `Hexacopter` and `HexacopterStatus` classes in the `drone.py` file. The code
    file for the sample is included in the `restful_python_chapter_09_01` folder:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个 `Hexacopter` 类，我们将使用它来表示六旋翼机，以及一个 `HexacopterStatus` 类，我们将使用它来存储六旋翼机的状态数据。创建一个新的
    `drone.py` 文件。以下行显示了我们将创建的类所需的全部导入，以及 `drone.py` 文件中声明 `Hexacopter` 和 `HexacopterStatus`
    类的代码。示例的代码文件包含在 `restful_python_chapter_09_01` 文件夹中：
- en: '[PRE17]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `HexacopterStatus` class just declares a constructor, that is, the `__init__`
    method. This method receives many arguments and uses them to initialize the attributes
    with the same names: `motor_speed` and `turned_on`.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`HexacopterStatus` 类仅声明了一个构造函数，即 `__init__` 方法。该方法接收许多参数，并使用它们以相同的名称初始化属性：`motor_speed`
    和 `turned_on`。'
- en: 'The `Hexacopter` class declares two class attributes that specify the minimum
    and maximum speed values: `MIN_SPEED` and `MAX_SPEED`. The constructor, that is,
    the `__init__` method, initializes the `motor_speed` attribute with the `MIN_SPEED`
    value and sets the `turned_on` attribute to `False`.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`Hexacopter` 类声明了两个类属性，指定最小和最大速度值：`MIN_SPEED` 和 `MAX_SPEED`。构造函数，即 `__init__`
    方法，使用 `MIN_SPEED` 值初始化 `motor_speed` 属性，并将 `turned_on` 属性设置为 `False`。'
- en: The `get_motor_speed` method returns the value of the `motor_speed` attribute.
    The `set_motor_speed` method checks whether the value for the `motor_speed` argument
    is in the valid range. In case the validation fails, the method raises a `ValueError`
    exception. Otherwise, the method sets the value of the `motor_speed` attribute
    with the received value and sets the value for the `turned_on` attribute to `True`
    if the `motor_speed` is greater than 0\. Finally, the method calls sleep to simulate
    it takes two seconds to retrieve the hexacopter status and then returns a `HexacopterStatus`
    instance initialized with the `motor_speed` and `turned_on` attribute values,
    retrieved through specific methods.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_motor_speed` 方法返回 `motor_speed` 属性的值。`set_motor_speed` 方法检查 `motor_speed`
    参数的值是否在有效范围内。如果验证失败，该方法将抛出 `ValueError` 异常。否则，该方法将使用接收到的值设置 `motor_speed` 属性的值，如果
    `motor_speed` 大于 0，则将 `turned_on` 属性的值设置为 `True`。最后，该方法调用 sleep 来模拟获取六旋翼机状态需要两秒钟，然后返回一个使用
    `motor_speed` 和 `turned_on` 属性值初始化的 `HexacopterStatus` 实例，这些值通过特定方法检索得到。'
- en: The `get_hexacopter_status` method calls sleep to simulate it takes three seconds
    to retrieve the hexacopter status and then returns a `HexacopterStatus` instance
    initialized with the `motor_speed` and `turned_on` attribute values.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_hexacopter_status` 方法调用 sleep 来模拟获取六旋翼机状态需要三秒钟，然后返回一个使用 `motor_speed`
    和 `turned_on` 属性值初始化的 `HexacopterStatus` 实例。'
- en: 'Now, we will create a `LightEmittingDiode` class that we will use to represent
    each LED. Open the previously created `drone.py` file and add the following lines.
    The code file for the sample is included in the `restful_python_chapter_09_01`
    folder:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个 `LightEmittingDiode` 类，我们将使用它来表示每个 LED。打开之前创建的 `drone.py` 文件，并添加以下行。示例的代码文件包含在
    `restful_python_chapter_09_01` 文件夹中：
- en: '[PRE18]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `LightEmittingDiode` class declares two class attributes that specify the
    minimum and maximum brightness level values: `MIN_BRIGHTNESS_LEVEL` and `MAX_BRIGHTNESS_LEVEL`.
    The constructor, that is, the `__init__` method, initializes the `brightness_level`
    attribute with the `MIN_BRIGHTNESS_LEVEL` and the `id` and `description` attributes
    with the values received in the arguments with the same names.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`LightEmittingDiode` 类声明了两个类属性，指定最小和最大亮度级别值：`MIN_BRIGHTNESS_LEVEL` 和 `MAX_BRIGHTNESS_LEVEL`。构造函数，即
    `__init__` 方法，使用 `MIN_BRIGHTNESS_LEVEL` 初始化 `brightness_level` 属性，并使用具有相同名称的参数值初始化
    `id` 和 `description` 属性。'
- en: The `get_brightness_level` method calls sleep to simulate, it takes 1 second
    to retrieve the brightness level for the wired LED and then returns the value
    of the `brightness_level` attribute.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_brightness_level`方法调用`sleep`来模拟，获取有线LED的亮度级别需要1秒钟，然后返回`brightness_level`属性的值。'
- en: The `set_brightness_level` method checks whether the value for the `brightness_level`
    argument is in the valid range. In case the validation fails, the method raises
    a `ValueError` exception. Otherwise, the method calls `sleep` to simulate it takes
    two seconds to set the new brightness level and finally sets the value of the
    `brightness_level` attribute with the received value.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`set_brightness_level`方法检查`brightness_level`参数的值是否在有效范围内。如果验证失败，该方法将引发`ValueError`异常。否则，该方法调用`sleep`来模拟设置新的亮度级别需要两秒钟，最后使用接收到的值设置`brightness_level`属性的值。'
- en: 'Now, we will create an `Altimeter` class that we will use to represent the
    altimeter. Open the previously created `drone.py` file and add the following lines.
    The code file for the sample is included in the `restful_python_chapter_09_01`
    folder:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个`Altimeter`类，我们将使用它来表示高度计。打开之前创建的`drone.py`文件，并添加以下几行。示例的代码文件包含在`restful_python_chapter_09_01`文件夹中：
- en: '[PRE19]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `Altimeter` class declares a `get_altitude` method that calls `sleep` to
    simulate it takes one second to retrieve the altitude from the altimeter and finally
    generates a random integer from 0 to `3000` (inclusive) and returns it.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`Altimeter`类声明了一个`get_altitude`方法，它调用`sleep`来模拟从高度计获取高度需要一秒钟，最后生成一个从0到`3000`（包含）的随机整数并返回它。'
- en: Finally, we will create a `Drone` class that we will use to represent the drone
    with its sensors and actuators. Open the previously created `drone.py` file and
    add the following lines. The code file for the sample is included in the `restful_python_chapter_09_01`
    folder
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将创建一个`Drone`类，我们将使用它来表示带有其传感器和执行器的无人机。打开之前创建的`drone.py`文件，并添加以下几行。示例的代码文件包含在`restful_python_chapter_09_01`文件夹中
- en: '[PRE20]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `Drone` class just declares a constructor, that is, the `__init__` method
    that creates instances of the previously declared classes that represent the different
    components for the drone. The `leds` attribute saves a dictionary that has a key-value
    pair for each `LightEmittingDiode` instance with its id and its instance.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`Drone`类仅声明了一个构造函数，即`__init__`方法，它创建了代表无人机不同组件的先前声明的类的实例。`leds`属性保存了一个字典，其中每个`LightEmittingDiode`实例都有一个键值对，包含其id和实例。'
- en: Writing request handlers
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写请求处理器
- en: The main building blocks for a RESTful API in tornado are subclasses of the
    `tornado.web.RequestHandler` class, that is, the base class for HTTP request handlers
    in Tornado. We just need to create a subclass of this class and declare the methods
    for each supported HTTP verb. We have to override the methods to handle HTTP requests.
    Then, we have to map the URL patterns to each subclass of `tornado.web.RequestHandler`
    in the `tornado.web.Application` instance that represents the Tornado Web application.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在tornado中，RESTful API的主要构建块是`tornado.web.RequestHandler`类的子类，即Tornado中HTTP请求处理器的基类。我们只需要创建这个类的子类，并声明每个支持的HTTP动词的方法。我们必须重写这些方法来处理HTTP请求。然后，我们必须将URL模式映射到代表Tornado
    Web应用的`tornado.web.Application`实例中的每个`tornado.web.RequestHandler`的子类。
- en: 'First, we will create a `HexacopterHandler` class that we will use to handle
    requests for the hexacopter resource. Create a new `api.py` file. The following
    lines show all the necessary imports for the classes that we will create and the
    code that declares the `HexacopterHandler` class in the `drone.py` file. Enter
    the next lines in the new `api.py` file. The code file for the sample is included
    in the `restful_python_chapter_09_01` folder:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个`HexacopterHandler`类，我们将使用它来处理对六旋翼资源的需求。创建一个新的`api.py`文件。以下几行展示了我们将创建的类所需的全部导入，以及`drone.py`文件中声明`HexacopterHandler`类的代码。在新的`api.py`文件中输入以下几行。示例的代码文件包含在`restful_python_chapter_09_01`文件夹中：
- en: '[PRE21]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `HexacopterHandler` class is a subclass of `tornado.web.RequestHandler`
    and declares the following two methods that will be called when the HTTP method
    with the same name arrives as a request on this HTTP handler:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`HexacopterHandler`类是`tornado.web.RequestHandler`的子类，并声明了以下两个方法，当具有相同名称的HTTP方法作为请求到达此HTTP处理器时将被调用：'
- en: '`get`: This method receives the `id` of the hexacopter whose status has to
    be retrieved in the `id` argument. If the received id doesn''t match the value
    of the `HEXACOPTER_ID` class attribute, the code calls the `self.set_status` method
    with `status.HTTP_404_NOT_FOUND` as an argument to set the status code for the
    response to `HTTP 404 Not Found`. Otherwise, the code prints a message indicating
    that it started retrieving the hexacopter''s status and calls the `drone.hexacopter.get_hexacopter_status`
    method with a synchronous execution and saves the result in the `hexacopter_status`
    variable. Then, the code writes a message indicating it finished retrieving the
    status and generates a `response` dictionary with the `''speed''` and `''turned_on''`
    keys and their values. Finally, the code calls the `self.set_status` method with
    `status.HTTP_200_OK` as an argument to set the status code for the response to
    `HTTP 200 OK` and calls the `self.write` method with the `response` dictionary
    as an argument. Because `response` is a dictionary, Tornado automatically writes
    the chunk as JSON and sets the value of the `Content-Type` header to `application/json`.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get`: 此方法通过`id`参数接收需要检索状态的六旋翼飞行器的`id`。如果接收到的`id`与`HEXACOPTER_ID`类属性的值不匹配，代码将调用`self.set_status`方法，并将`status.HTTP_404_NOT_FOUND`作为参数来设置响应的状态码为`HTTP
    404 Not Found`。否则，代码将打印一条消息，表明它开始检索六旋翼飞行器的状态，并使用同步执行调用`drone.hexacopter.get_hexacopter_status`方法，并将结果保存到`hexacopter_status`变量中。然后，代码将写入一条消息，表明它已完成状态的检索，并生成一个包含`''speed''`和`''turned_on''`键及其值的`response`字典。最后，代码将调用`self.set_status`方法，并将`status.HTTP_200_OK`作为参数来设置响应的状态码为`HTTP
    200 OK`，并调用`self.write`方法，将`response`字典作为参数。由于`response`是一个字典，Tornado自动将块写入JSON格式，并将`Content-Type`头部的值设置为`application/json`。'
- en: '`patch`: This method receives the `id` of the hexacopter that has to be updated
    or patched in the `id` argument. As it happened in the previously explained get
    method, the code returns an `HTTP 404 Not Found` in case the received id doesn''t
    match the value of the `HEXACOPTER_ID` class attribute. Otherwise, the code calls
    the `tornado.escape.json_decode` method with `self.request.body` as an argument
    to generate Python objects for the JSON string of the request body and saves the
    generated dictionary in the `request_data` variable. If the dictionary doesn''t
    include a key named `''motor_speed''`, the code returns an `HTTP 400 Bad Request`
    status code. In case there is a key, the code prints a message indicating that
    it started setting the hexacopter''s speed, calls the `drone.hexacopter.set_motor_speed`
    method with a synchronous execution and saves the result in the `hexacopter_status`
    variable. If the value specified for the motor speed is not valid, a `ValueError`
    exception will be caught and the code will return an HTTP 400 Bad Request status
    code and the validation error messages as the response body. Otherwise, the code
    writes a message indicating it finished setting the motor speed and generates
    a `response` dictionary with the `''speed''` and `''turned_on''` keys and their
    values. Finally, the code calls the `self.set_status` method with `status.HTTP_200_OK`
    as an argument to set the status code for the response to HTTP 200 OK and calls
    the `self.write` method with the `response` dictionary as an argument. Since `response`
    is a dictionary, Tornado automatically writes the chunk as JSON and sets the value
    of the `Content-Type` header to `application/json`.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`patch`: 此方法通过`id`参数接收需要更新或修补的六旋翼飞行器的`id`。正如之前解释的`get`方法中发生的情况，如果接收到的`id`与`HEXACOPTER_ID`类属性的值不匹配，代码将返回`HTTP
    404 Not Found`。否则，代码将调用`tornado.escape.json_decode`方法，并将`self.request.body`作为参数来生成请求体JSON字符串的Python对象，并将生成的字典保存到`request_data`变量中。如果字典中不包含名为`''motor_speed''`的键，代码将返回`HTTP
    400 Bad Request`状态码。如果存在该键，代码将打印一条消息，表明它开始设置六旋翼飞行器的速度，并使用同步执行调用`drone.hexacopter.set_motor_speed`方法，并将结果保存到`hexacopter_status`变量中。如果指定的电机速度值无效，将捕获`ValueError`异常，代码将返回`HTTP
    400 Bad Request`状态码，并将验证错误消息作为响应体。否则，代码将写入一条消息，表明它已完成电机速度的设置，并生成一个包含`''speed''`和`''turned_on''`键及其值的`response`字典。最后，代码将调用`self.set_status`方法，并将`status.HTTP_200_OK`作为参数来设置响应的状态码为HTTP
    200 OK，并调用`self.write`方法，将`response`字典作为参数。由于`response`是一个字典，Tornado自动将块写入JSON格式，并将`Content-Type`头部的值设置为`application/json`。'
- en: The class overrides the `SUPPORTED_METHODS` class variable with a tuple that
    indicates the class just supports the `GET` and `PATCH` methods. This way, in
    case the handler is requested a method that isn't included in the `SUPPORTED_METHODS`
    tuple, the server will automatically return a `405 Method Not Allowed` status
    code.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 该类覆盖了`SUPPORTED_METHODS`类变量，使用一个元组表示该类仅支持`GET`和`PATCH`方法。这样，如果请求的处理程序请求的不是一个包含在`SUPPORTED_METHODS`元组中的方法，服务器将自动返回`405
    Method Not Allowed`状态码。
- en: 'Now, we will create a `LedHandler` class that we will use to represent the
    LED resources. Open the previously created `api.py` file and add the following
    lines. The code file for the sample is included in the `restful_python_chapter_09_01`
    folder:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个`LedHandler`类，用于表示LED资源。打开之前创建的`api.py`文件，并添加以下行。示例的代码文件包含在`restful_python_chapter_09_01`文件夹中：
- en: '[PRE22]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `LedHandler` class is a subclass of `tornado.web.RequestHandler`. The class
    overrides the `SUPPORTED_METHODS` class variable with a tuple that indicates the
    class just supports the `GET` and `PATCH` methods. In addition, the class declares
    the following two methods that will be called when the HTTP method with the same
    name arrives as a request on this HTTP handler:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`LedHandler`类是`tornado.web.RequestHandler`的子类。该类覆盖了`SUPPORTED_METHODS`类变量，使用一个元组表示该类仅支持`GET`和`PATCH`方法。此外，该类声明了以下两个方法，当HTTP处理程序接收到具有相同名称的HTTP方法请求时，将调用这些方法：'
- en: '`get`: This method receives the `id` of the LED whose status has to be retrieved
    in the `id` argument. If the received id isn''t one of the keys of the `drone.leds`
    dictionary, the code calls the `self.set_status` method with `status.HTTP_404_NOT_FOUND`
    as an argument to set the status code for the response to `HTTP 404 Not Found`.
    Otherwise, the code retrieves the value associated with the key whose value matches
    the id in the `drone.leds` dictionary and saves the retrieved `LightEmittingDiode`
    instance in the `led` variable. The code prints a message indicating that it started
    retrieving the LED''s brightness level, calls the `led.get_brightness_level` method
    with a synchronous execution, and saves the result in the `brightness_level` variable.
    Then, the code writes a message indicating that it finished retrieving the brightness
    level and generates a `response` dictionary with the `''id''`, `''description''`,
    and `''brightness_level''` keys and their values. Finally, the code calls the
    `self.set_status` method with `status.HTTP_200_OK` as an argument to set the status
    code for the response to HTTP 200 OK and calls the `self.write` method with the
    `response` dictionary as an argument. Since `response` is a dictionary, Tornado
    automatically writes the chunk as JSON and sets the value of the `Content-Type`
    header to `application/json`.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get`：此方法接收`id`参数中要检索状态的LED的`id`。如果接收到的id不是`drone.leds`字典的键之一，代码将调用`self.set_status`方法，并将`status.HTTP_404_NOT_FOUND`作为参数来设置响应的状态码为`HTTP
    404 Not Found`。否则，代码检索与`drone.leds`字典中匹配id的键关联的值，并将检索到的`LightEmittingDiode`实例保存到`led`变量中。代码打印一条消息，表明它开始检索LED的亮度级别，然后以同步方式调用`led.get_brightness_level`方法，并将结果保存到`brightness_level`变量中。然后，代码打印一条消息，表明它已完成亮度级别的检索，并生成一个包含`''id''`、`''description''`和`''brightness_level''`键及其值的`response`字典。最后，代码调用`self.set_status`方法，并将`status.HTTP_200_OK`作为参数来设置响应的状态码为HTTP
    200 OK，并调用`self.write`方法，将`response`字典作为参数。由于`response`是一个字典，Tornado会自动将块作为JSON写入，并将`Content-Type`头部的值设置为`application/json`。'
- en: '`patch`: This method receives the id of the LED that has to be updated or patched
    in the `id` argument. As happened in the previously explained get method, the
    code returns an `HTTP 404 Not Found` in case the received id doesn''t match the
    any of the keys of the `drone.leds` dictionary. Otherwise, the code calls the
    `tornado.escape.json_decode` method with `self.request.body` as an argument to
    generate Python objects for the JSON string of the request body and saves the
    generated dictionary in the `request_data` variable. If the dictionary doesn''t
    include a key named `''brightness_level''`, the code returns an `HTTP 400 Bad
    Request` status code. In case there is a key, the code prints a message indicating
    that it started setting the LED''s brightness level, including the description
    for the LED, calls the `drone.hexacopter.set_brightness_level` method with a synchronous
    execution. If the value specified for the `brightness_level` is not valid, a `ValueError`
    exception will be caught and the code will return an `HTTP 400 Bad Request` status
    code and the validation error messages as the response body. Otherwise, the code
    writes a message indicating it finished setting the LED''s brightness value and
    generates a `response` dictionary with the `''id''`, `''description''`, and `''brightness_level''`
    keys and their values. Finally, the code calls the `self.set_status` method with
    `status.HTTP_200_OK` as an argument to set the status code for the response to
    HTTP 200 OK and calls the `self.write` method with the `response` dictionary as
    an argument. Since `response` is a dictionary, Tornado automatically writes the
    chunk as JSON and sets the value of the `Content-Type` header to `application/json`.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`patch` 方法：该方法接收需要更新或修补的 LED 的 id，作为 `id` 参数。与之前解释的 `get` 方法一样，如果接收到的 id 不匹配
    `drone.leds` 字典中的任何键，则代码返回 `HTTP 404 Not Found`。否则，代码使用 `self.request.body` 作为参数调用
    `tornado.escape.json_decode` 方法，以生成请求体 JSON 字符串的 Python 对象，并将生成的字典保存到 `request_data`
    变量中。如果字典中不包含名为 `''brightness_level''` 的键，则代码返回 `HTTP 400 Bad Request` 状态码。如果存在该键，代码将打印一条消息，表明它开始设置
    LED 的亮度级别，包括 LED 的描述，调用 `drone.hexacopter.set_brightness_level` 方法进行同步执行。如果指定的
    `brightness_level` 值无效，将捕获 `ValueError` 异常，并返回 `HTTP 400 Bad Request` 状态码以及验证错误消息作为响应体。否则，代码将写入一条消息，表明它已完成设置
    LED 的亮度值，并生成一个包含 `''id''`、`''description''` 和 `''brightness_level''` 键及其值的 `response`
    字典。最后，代码使用 `status.HTTP_200_OK` 作为参数调用 `self.set_status` 方法，将响应的状态码设置为 HTTP 200
    OK，并使用 `response` 字典作为参数调用 `self.write` 方法。由于 `response` 是一个字典，Tornado 自动将块作为
    JSON 写入，并将 `Content-Type` 标头的值设置为 `application/json`。'
- en: 'Now, we will create an `AltimeterHandler` class that we will use to represent
    the altimeter resource. Open the previously created `api.py` file and add the
    following lines. The code file for the sample is included in the `restful_python_chapter_09_01`
    folder:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个 `AltimeterHandler` 类，我们将使用它来表示高度计资源。打开之前创建的 `api.py` 文件，并添加以下行。示例的代码文件包含在
    `restful_python_chapter_09_01` 文件夹中：
- en: '[PRE23]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `AltimeterHandler` class is a subclass of `tornado.web.RequestHandler`.
    The class overrides the `SUPPORTED_METHODS` class variable with a tuple that indicates
    the class just supports the `GET` method. In addition, the class declares the
    `get` method that will be called when the HTTP method with the same name arrives
    as a request on this HTTP handler.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`AltimeterHandler` 类是 `tornado.web.RequestHandler` 的子类。该类通过一个表示仅支持 `GET` 方法的元组覆盖了
    `SUPPORTED_METHODS` 类变量。此外，该类声明了一个 `get` 方法，当以相同名称的 HTTP 方法作为请求到达此 HTTP 处理程序时，将调用该方法。'
- en: The `get` method receives the `id` of the altimeter whose altitude has to be
    retrieved in the `id` argument. If the received id doesn't match the value of
    the `ALTIMETER_ID` class attribute, the code calls the `self.set_status` method
    with `status.HTTP_404_NOT_FOUND` as an argument to set the status code for the
    response to HTTP 404 Not Found. Otherwise, the code prints a message indicating
    that it started retrieving the altimeter's altitude, calls the `drone.hexacopter.get_altitude`
    method with a synchronous execution, and saves the result in the `altitude` variable.
    Then, the code writes a message indicating it finished retrieving the altitude
    and generates a `response` dictionary with the `'altitude'` key and its value.
    Finally, the code calls the `self.set_status` method with `status.HTTP_200_OK`
    as an argument to set the status code for the response to HTTP 200 OK and calls
    the `self.write` method with the `response` dictionary as an argument. Since `response`
    is a dictionary, Tornado automatically writes the chunk as JSON and sets the value
    of the `Content-Type` header to `application/json`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`get` 方法接收 `id` 参数中要检索高度计的 `id`。如果接收到的 `id` 与 `ALTIMETER_ID` 类属性的值不匹配，代码将调用
    `self.set_status` 方法，并将 `status.HTTP_404_NOT_FOUND` 作为参数来设置响应的状态码为 HTTP 404 Not
    Found。否则，代码打印一条消息，表明它开始检索高度计的高度，调用 `drone.hexacopter.get_altitude` 方法进行同步执行，并将结果保存到
    `altitude` 变量中。然后，代码写入一条消息，表明它已完成高度检索，并生成一个包含 `''altitude''` 键及其值的 `response`
    字典。最后，代码调用 `self.set_status` 方法，并将 `status.HTTP_200_OK` 作为参数来设置响应的状态码为 HTTP 200
    OK，并调用 `self.write` 方法，将 `response` 字典作为参数。由于 `response` 是一个字典，Tornado 自动将块作为
    JSON 写入，并将 `Content-Type` 头的值设置为 `application/json`。'
- en: 'The following table shows the method of our previously created HTTP handler
    classes that we want to be executed for each combination of HTTP verb and scope:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了我们要为每个 HTTP 动词和作用域组合执行的之前创建的 HTTP 处理器类的函数：
- en: '| **HTTP verb** | **Scope** | **Class and method** |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| **HTTP verb** | **Scope** | **Class and method** |'
- en: '| `GET` | Hexacopter | `HexacopterHandler.get` |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | Hexacopter | `HexacopterHandler.get` |'
- en: '| `PATCH` | Hexacopter | `HexacopterHandler.patch` |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| `PATCH` | Hexacopter | `HexacopterHandler.patch` |'
- en: '| `GET` | LED | `LedHandler.get` |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | LED | `LedHandler.get` |'
- en: '| `PATCH` | LED | `LedHandler.patch` |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| `PATCH` | LED | `LedHandler.patch` |'
- en: '| `GET` | Altimeter | `AltimeterHandler.get` |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | Altimeter | `AltimeterHandler.get` |'
- en: If the request results in the invocation of an HTTP handler class with an unsupported
    HTTP method, Tornado will return a response with the HTTP `405 Method Not Allowed`
    status code.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果请求导致调用一个不支持 HTTP 方法的 HTTP 处理器类，Tornado 将返回一个带有 HTTP `405 Method Not Allowed`
    状态码的响应。
- en: Mapping URL patterns to request handlers
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 URL 模式映射到请求处理器
- en: 'We must map URL patterns to our previously coded subclasses of `tornado.web.RequestHandler`.
    The following lines create the main entry point for the application, initialize
    it with the URL patterns for the API, and starts listening for requests. Open
    the previously created `api.py` file and add the following lines. The code file
    for the sample is included in the `restful_python_chapter_09_01` folder:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须将 URL 模式映射到之前编写的 `tornado.web.RequestHandler` 的子类。以下行创建了应用程序的主要入口点，使用 API
    的 URL 模式对其进行初始化，并开始监听请求。打开之前创建的 `api.py` 文件并添加以下行。示例的代码文件包含在 `restful_python_chapter_09_01`
    文件夹中：
- en: '[PRE24]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The preceding code creates an instance of `tornado.web.Application` named `application`
    with the collection of request handlers that make up the Web application. The
    code passes a list of tuples to the `Application` constructor. The list is composed
    of a regular expression (`regexp`) and a `tornado.web.RequestHandler` subclass
    (`request_class`). In addition, the code sets the `debug` argument to `True` to
    enable debugging.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码创建了一个名为 `application` 的 `tornado.web.Application` 实例，其中包含构成 Web 应用程序的请求处理器集合。代码将一个元组列表传递给
    `Application` 构造函数。列表由一个正则表达式（`regexp`）和一个 `tornado.web.RequestHandler` 子类（`request_class`）组成。此外，代码将
    `debug` 参数设置为 `True` 以启用调试。
- en: The `main` method calls the `application.listen` method to build an HTTP server
    for the application with the defined rules on the specified port. In this case,
    the code specifies `8888` as the port, saved in the `port` variable, which is
    the default port for Tornado HTTP servers. Then, the call to `tornado.ioloop.IOLoop.instance().start()`
    starts the server created with the previous call to the `application.listen` method.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`main` 方法调用 `application.listen` 方法，在指定的端口上为应用程序构建一个遵循定义规则的 HTTP 服务器。在这种情况下，代码将
    `8888` 指定为端口，保存在 `port` 变量中，这是 Tornado HTTP 服务器的默认端口。然后，对 `tornado.ioloop.IOLoop.instance().start()`
    的调用启动了通过之前的 `application.listen` 方法创建的服务器。'
- en: Tip
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: As with any other Web framework, you should never enable debugging in a production
    environment.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何其他 Web 框架一样，你永远不应该在生产环境中启用调试。
- en: Making HTTP requests to the Tornado API
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向 Tornado API 发送 HTTP 请求
- en: 'Now, we can run the `api.py` script that launches Tornados''s development server
    to compose and send HTTP requests to our unsecure and simple Web API. Execute
    the following command:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以运行 `api.py` 脚本，它启动 Tornado 的开发服务器，以便我们可以编写和发送 HTTP 请求到我们的不安全且简单的 Web
    API。执行以下命令：
- en: '[PRE25]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The following lines show the output after we execute the previous command.
    The Tornado HTTP development server is listening at port `8888`:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了执行之前命令后的输出。Tornado HTTP 开发服务器正在端口 `8888` 上监听：
- en: '[PRE26]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: With the previous command, we will start the Tornado HTTP server and it will
    listen on every interface on port `8888`. Thus, if we want to make HTTP requests
    to our API from other computers or devices connected to our LAN, we don't need
    any additional configurations.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 使用之前的命令，我们将启动 Tornado HTTP 服务器，它将在每个接口上监听端口 `8888`。因此，如果我们想从连接到我们局域网的其它计算机或设备向我们的
    API 发送 HTTP 请求，我们不需要任何额外的配置。
- en: Tip
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you decide to compose and send HTTP requests from other computers or devices
    connected to the LAN, remember that you have to use the development computer's
    assigned IP address instead of `localhost`. For example, if the computer's assigned
    IPv4 IP address is `192.168.1.103`, instead of `localhost:8888`, you should use
    `192.168.1.103:8888`. Of course, you can also use the host name instead of the
    IP address. The previously explained configurations are very important because
    mobile devices might be the consumers of our RESTful APIs and we will always want
    to test the apps that make use of our APIs in our development environments.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你决定从连接到局域网的其它计算机或设备发送和发送 HTTP 请求，请记住你必须使用开发计算机分配的 IP 地址而不是 `localhost`。例如，如果计算机分配的
    IPv4 IP 地址是 `192.168.1.103`，那么你应该使用 `192.168.1.103:8888` 而不是 `localhost:8888`。当然，你也可以使用主机名而不是
    IP 地址。之前解释的配置非常重要，因为移动设备可能是我们 RESTful API 的消费者，我们总是希望在开发环境中测试使用我们 API 的应用程序。
- en: The Tornado HTTP server is running on localhost (`127.0.0.1`), listening on
    port `8888`, and waiting for our HTTP requests. Now, we will compose and send
    HTTP requests locally in our development computer or from other computer or devices
    connected to our LAN.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Tornado HTTP 服务器正在本地主机 (`127.0.0.1`) 上运行，监听端口 `8888`，等待我们的 HTTP 请求。现在，我们将在我们开发计算机本地或从连接到我们的局域网的其它计算机或设备发送
    HTTP 请求。
- en: "Working with command-line tools â\x80\x93 curl and httpie"
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用命令行工具——curl 和 httpie
- en: 'We will start composing and sending HTTP requests with the command-line tools
    we have introduced in [Chapter 1](ch01.html "Chapter 1. Developing RESTful APIs
    with Django"), *Developing RESTful APIs with Django*, curl and HTTPie. In case
    you haven''t installed HTTPie, make sure you activate the virtual environment
    and then run the following command in the terminal or Command Prompt to install
    the HTTPie package:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用我们在 [第 1 章](ch01.html "第 1 章。使用 Django 开发 RESTful API") 中介绍的命令行工具——*使用
    Django 开发 RESTful API*、curl 和 HTTPie 来编写和发送 HTTP 请求。如果你还没有安装 HTTPie，请确保激活虚拟环境，然后在终端或命令提示符中运行以下命令来安装
    HTTPie 包：
- en: '[PRE27]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Tip
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: "In case you don't remember how to activate the virtual environment that we\
    \ created for this example, read the following section in this chapter*—\x80\x94\
    Setting up the virtual environment with Django REST Framework*."
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你忘记了如何激活为我们这个示例创建的虚拟环境，请阅读本章的以下部分*——使用 Django REST Framework 设置虚拟环境*。
- en: 'Open a Cygwin terminal in Windows or a Terminal in macOS or Linux and run the
    following command. We will compose and send an HTTP request to turn on the hexacopter
    and set its motor speed to 100 RPMs:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 中打开 Cygwin 终端或在 macOS 或 Linux 中打开终端，并运行以下命令。我们将编写和发送一个 HTTP 请求来打开六旋翼飞行器并将其电机速度设置为
    100 RPM：
- en: '[PRE28]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The following is the equivalent curl command. It is very important to use the
    `-H "Content-Type: application/json"` option to indicate curl to send the data
    specified after the `-d` option as `application/json` instead of the default `application/x-www-form-urlencoded`:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '以下是对应的 `curl` 命令。非常重要的一点是使用 `-H "Content-Type: application/json"` 选项来指示 `curl`
    将 `-d` 选项之后指定的数据作为 `application/json` 而不是默认的 `application/x-www-form-urlencoded`
    发送：'
- en: '[PRE29]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The preceding commands will compose and send the following HTTP request, `PATCH
    http://localhost:8888/hexacopters/1`, with the following JSON key-value pair:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令将组合并发送以下 HTTP 请求，`PATCH http://localhost:8888/hexacopters/1`，附带以下 JSON
    键值对：
- en: '[PRE30]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The request specifies `/hexacopters/1`, and therefore, Tornado will iterate
    over the list of tuples with regular expressions and request classes and it will
    match `''/hexacopters/([0-9]+)''`. Tornado will create an instance of the `HexacopterHandler`
    class and run the `HexacopterHandler.patch` method with `1` as the value for the
    `id` argument. As the HTTP verb for the request is `PATCH`, Tornado calls the
    `patch` method. If the hexacopter''s speed is successfully set, the method returns
    an `HTTP 200 OK` status code and the key-value pairs with the speed and status
    for the recently updated hexacopter serialized to JSON in the response body. The
    following lines show an example response for the HTTP request:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 请求指定了 `/hexacopters/1`，因此，Tornado 将遍历包含正则表达式和请求类的元组列表，并匹配 `'/hexacopters/([0-9]+)'`。Tornado
    将创建 `HexacopterHandler` 类的一个实例，并使用 `1` 作为 `id` 参数的值来运行 `HexacopterHandler.patch`
    方法。由于请求的 HTTP 动词是 `PATCH`，Tornado 调用 `patch` 方法。如果成功设置了六旋翼飞行器的速度，该方法将返回 `HTTP
    200 OK` 状态码，并将速度和状态作为键值对序列化为 JSON 格式放在响应体中。以下几行显示了 HTTP 请求的一个示例响应：
- en: '[PRE31]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We will compose and send an HTTP request to retrieve the status and the motor
    speed for the hexacopter. Go back to the Cygwin terminal in Windows or the Terminal
    in macOS or Linux, and run the following command:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将组合并发送一个 HTTP 请求以检索六旋翼飞行器的状态和电机速度。回到 Windows 的 Cygwin 终端或 macOS 或 Linux 的终端，并运行以下命令：
- en: '[PRE32]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The following is the equivalent `curl` command:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对应的 `curl` 命令：
- en: '[PRE33]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The preceding commands will compose and send the following HTTP request: `GET
    http://localhost:8888/hexacopters/1`. The request specifies `/hexacopters/1`,
    and therefore, it will match `''/hexacopters/([0-9]+)''` and run the `HexacopterHandler.get`
    method with `1` as the value for the `id` argument. As the HTTP verb for the request
    is `GET`, Tornado calls the `get` method. The method retrieves the hexacopter''s
    status and generates a JSON response with the key-value pairs.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令将组合并发送以下 HTTP 请求：`GET http://localhost:8888/hexacopters/1`。请求指定了 `/hexacopters/1`，因此，它将匹配
    `'/hexacopters/([0-9]+)'` 并运行 `HexacopterHandler.get` 方法，其中 `1` 作为 `id` 参数的值。由于请求的
    HTTP 动词是 `GET`，Tornado 调用 `get` 方法。该方法检索六旋翼飞行器的状态，并生成包含键值对的 JSON 响应。
- en: 'The following lines show an example response for the HTTP request. The first
    lines show the HTTP response headers, including the status (`200 OK`) and the
    `Content-type` as (`application/json`). After the HTTP response headers, we can
    see the details of the hexacopter''s status in the JSON response:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 以下几行显示了 HTTP 请求的一个示例响应。前几行显示了 HTTP 响应头，包括状态（`200 OK`）和 `Content-type`（`application/json`）。在
    HTTP 响应头之后，我们可以在 JSON 响应中看到六旋翼飞行器的状态详情：
- en: '[PRE34]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'After we run the three requests, we will see the following lines in the window
    that is running the Tornado HTTP server. The output shows the results of executing
    the print statements that describe when the code started setting or retrieving
    information and when it finished:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们运行三个请求之后，我们将在运行 Tornado HTTP 服务器的窗口中看到以下几行。输出显示了执行描述代码何时开始设置或检索信息以及何时完成的打印语句的结果：
- en: '[PRE35]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The different methods we coded in the request handler classes end up calling
    `time.sleep` to simulate it takes some time for the operations with the hexacopter.
    In this case, our code is running with a synchronous execution, and therefore,
    each time we compose and send a request, the Tornado server is blocked until the
    operation with the hexacopter finishes and the method sends the response. We will
    create a new version of this API that will use asynchronous execution later and
    we will understand the advantages of Tornado's non-blocking features. However,
    first, we will understand how the synchronous version of the API works.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在请求处理类中编写的不同方法最终都会调用 `time.sleep` 来模拟与六旋翼无人机的操作需要一些时间。在这种情况下，我们的代码是以同步执行方式运行的，因此，每次我们编写和发送请求时，Tornado
    服务器都会被阻塞，直到与六旋翼无人机的操作完成并且方法发送响应。我们将在稍后创建此 API 的新版本，该版本将使用异步执行，我们将了解 Tornado 非阻塞功能的优点。然而，首先，我们将了解
    API 的同步版本是如何工作的。
- en: 'The following image shows two Terminal windows side-by-side on macOS. The Terminal
    window on the left-hand side is running the Tornado HTTP server and displays the
    messages printed in the methods that process the HTTP requests. The Terminal window
    on the right-hand side is running `http` commands to generate the HTTP requests.
    It is a good idea to use a similar configuration to check the output while we
    compose and send the HTTP requests:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像显示了 macOS 上并排的两个终端窗口。左侧的终端窗口正在运行 Tornado HTTP 服务器，并显示处理 HTTP 请求的方法中打印的消息。右侧的终端窗口正在运行
    `http` 命令以生成 HTTP 请求。在编写和发送 HTTP 请求时检查输出，使用类似的配置是一个好主意：
- en: "![Working with command-line tools â\x80\x93 curl and httpie](img/image_09_001.jpg)"
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![使用命令行工具 – curl 和 httpie](img/image_09_001.jpg)'
- en: 'Now, we will compose and send an HTTP request to retrieve a hexacopter that
    doesn''t exist. Remember that we just have one hexacopter in our drone. Run the
    following command to try to retrieve the status for an hexacopter with an invalid
    id. We must make sure that the utilities display the headers as part of the response
    to see the returned status code:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将编写和发送一个 HTTP 请求以检索一个不存在的六旋翼无人机。请记住，我们只有一个六旋翼无人机。运行以下命令尝试检索具有无效 `id` 的六旋翼无人机的状态。我们必须确保实用程序将标题作为响应的一部分显示，以便查看返回的状态码：
- en: '[PRE36]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The following is the equivalent `curl` command:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对应的 `curl` 命令：
- en: '[PRE37]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The previous commands will compose and send the following HTTP request: `GET
    http://localhost:8888/hexacopters/8`. The request is the same as the previous
    one we have analyzed, with a different number for the `id` parameter. The server
    will run the `HexacopterHandler.get` method with `8` as the value for the `id`
    argument. The `id` is not equal to 1, and therefore, the code will return an HTTP
    `404 Not Found` status code. The following lines show an example header response
    for the HTTP request:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令将组合并发送以下 HTTP 请求：`GET http://localhost:8888/hexacopters/8`。该请求与之前我们分析过的请求相同，只是
    `id` 参数的数字不同。服务器将使用 `8` 作为 `id` 参数的值来运行 `HexacopterHandler.get` 方法。`id` 不等于 1，因此，代码将返回
    HTTP `404 Not Found` 状态码。以下行显示了 HTTP 请求的一个示例响应头：
- en: '[PRE38]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Working with GUI tools - Postman and others
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 GUI 工具 - Postman 及其他
- en: 'So far, we have been working with two Terminal-based or command-line tools
    to compose and send HTTP requests to our Tornado HTTP server-cURL and HTTPie.
    Now, we will work with one of the GUI tools we used when composing and sending
    HTTP requests to the Django development server and the Flask development server:
    Postman.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在使用两个基于终端或命令行的工具来编写和发送 HTTP 请求到我们的 Tornado HTTP 服务器 - cURL 和 HTTPie。现在，我们将使用我们在编写和发送
    HTTP 请求到 Django 开发服务器和 Flask 开发服务器时使用的 GUI 工具之一：Postman。
- en: Now, we will use the **Builder** tab in Postman to easily compose and send HTTP
    requests to `localhost:8888` and test the RESTful API with this GUI tool. Remember
    that Postman doesn't support curl-like shorthands for localhost, and therefore,
    we cannot use the same shorthands we have been using when composing requests with
    curl and HTTPie.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用 Postman 中的 **Builder** 选项卡轻松地组合和发送 HTTP 请求到 `localhost:8888`，并使用此 GUI
    工具测试 RESTful API。请记住，Postman 不支持 curl 类型的本地主机缩写，因此，我们无法在用 curl 和 HTTPie 编写请求时使用相同的缩写。
- en: Select **GET** in the drop-down menu at the left-hand side of the **Enter request
    URL** textbox and enter `localhost:8888/leds/1` in this textbox at the right-hand
    side of the dropdown. Now, click on **Send** and Postman will display the status
    (`200 OK`), the time it took for the request to be processed and the response
    body with all the games formatted as JSON with syntax highlighting (**Pretty**
    view).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在**输入请求URL**文本框左侧的下拉菜单中选择**GET**，并在右侧的文本框中输入`localhost:8888/leds/1`。现在，点击**发送**，Postman将显示状态（`200
    OK`）、请求处理所需的时间以及以JSON格式显示并带有语法高亮的响应体（**美化**视图）。
- en: 'The following screenshot shows the JSON response body in Postman for the HTTP
    GET request:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了Postman中HTTP GET请求的JSON响应体：
- en: '![Working with GUI tools - Postman and others](img/image_09_002.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![使用GUI工具 - Postman和其他](img/image_09_002.jpg)'
- en: 'Click on **Headers** on the right-hand side of **Body** and **Cookies** to
    read the response headers. The following screenshot shows the layout for the response
    headers that Postman displays for the previous response. Note that Postman displays
    the **Status** at the right-hand side of the response and doesn''t include it
    as the first line of the Headers, as it happened when we worked with both the
    cURL and HTTPie utilities:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**Body**右侧的**头部**和**Cookies**以读取响应头部。以下截图显示了Postman为之前响应显示的响应头部布局。请注意，Postman在响应右侧显示**状态**，并且不将其作为头部第一行，这与我们使用cURL和HTTPie工具时的情况不同：
- en: '![Working with GUI tools - Postman and others](img/image_09_003.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![使用GUI工具 - Postman和其他](img/image_09_003.jpg)'
- en: 'Now, we will use the **Builder** tab in Postman to compose and send an HTTP
    request to create a new message, specifically, a PATCH request. Follow the next
    steps:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用Postman的**Builder**标签来编写并发送一个创建新消息的HTTP请求，具体来说，是一个PATCH请求。按照以下步骤操作：
- en: Select **PATCH** from the drop-down menu on the left-hand side of the **Enter
    request URL** textbox and enter `localhost:8888/leds/1` in this textbox at the
    right-hand side of the dropdown.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**输入请求URL**文本框左侧的下拉菜单中选择**PATCH**，并在右侧的文本框中输入`localhost:8888/leds/1`。
- en: Click on **Body** on the right-hand side of **Authorization** and **Headers**,
    within the panel that composes the request.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击请求面板右侧的**Body**，以在**Authorization**和**Headers**右侧点击。
- en: Activate the **raw** radio button and select `JSON (application/json)` in the
    dropdown on the right-hand side of the **binary** radio button. Postman will automatically
    add a `Content-type = application/json` header, and therefore, you will notice
    the **Headers** tab will be renamed to **Headers (1)**, indicating us that there
    is one key-value pair specified for the request headers.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 激活**原始**单选按钮，并在**二进制**单选按钮右侧的下拉菜单中选择`JSON (application/json)`。Postman将自动添加`Content-type
    = application/json`头信息，因此，你会注意到**头部**标签将被重命名为**头部（1）**，这表明我们已为请求头部指定了一个键值对。
- en: 'Enter the following lines in the textbox below the radio buttons, within the
    **Body** tab:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Body**标签下方的文本框中输入以下行：
- en: '[PRE39]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The following screenshot shows the request body in Postman:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了Postman中的请求体：
- en: '![Working with GUI tools - Postman and others](img/image_09_004.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![使用GUI工具 - Postman和其他](img/image_09_004.jpg)'
- en: We followed the necessary steps to create an HTTP `PATCH` request with a JSON
    body that specifies the necessary key-value pairs to create a new game. Click
    on **Send** and Postman will display the Status (`200 OK`), the time it took for
    the request to be processed, and the response body with the recently added game
    formatted as JSON with syntax highlighting (**Pretty** view). The following screenshot
    shows the JSON response body in Postman for the HTTP POST request.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遵循了必要的步骤来创建一个带有JSON体、指定创建新游戏所需键值对的HTTP `PATCH`请求。点击**发送**，Postman将显示状态（`200
    OK`）、请求处理所需的时间以及以JSON格式显示并带有语法高亮的最近添加的游戏响应体（**美化**视图）。以下截图显示了Postman中HTTP POST请求的JSON响应体。
- en: '![Working with GUI tools - Postman and others](img/image_09_005.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![使用GUI工具 - Postman和其他](img/image_09_005.jpg)'
- en: The Tornado HTTP server is listening on every interface on port `8888`, and
    therefore, we can also use apps that can compose and send HTTP requests from mobile
    devices to work with the RESTful API. For example, we can work with the previously
    introduced iCurlHTTP app on iOS devices such as iPad Pro and iPhone. In Android
    devices, we can work with the previously introduced HTTP Request App.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: Tornado HTTP服务器正在监听所有接口的`8888`端口，因此，我们也可以使用能够从移动设备组成并发送HTTP请求的应用程序来与RESTful
    API一起工作。例如，我们可以在iPad Pro和iPhone等iOS设备上使用之前介绍的iCurlHTTP应用程序。在Android设备上，我们可以使用之前介绍的HTTP
    Request应用程序。
- en: "The following screenshot shows the results of composing and sending the following\
    \ HTTP request with the iCurlHTTP appâ\x80\x94`GET http://192.168.2.3:8888/altimeters/1`.\
    \ Remember that you have to perform the previously explained configurations in\
    \ your LAN and router to be able to access the Flask development server from other\
    \ devices connected to your LAN. In this case, the IP assigned to the computer\
    \ running the Tornado HTTP server is `192.168.2.3`, and therefore, you must replace\
    \ this IP with the IP assigned to your development computer:"
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了使用iCurlHTTP应用程序组成并发送以下HTTP请求的结果——`GET http://192.168.2.3:8888/altimeters/1`。请记住，你必须在你的LAN和路由器中执行之前解释的配置，才能从连接到你的LAN的其他设备访问Flask开发服务器。在这种情况下，运行Tornado
    HTTP服务器的计算机分配的IP地址是`192.168.2.3`，因此，你必须将此IP替换为分配给你的开发计算机的IP地址：
- en: '![Working with GUI tools - Postman and others](img/image_09_006.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![使用GUI工具 - Postman和其他工具](img/image_09_006.jpg)'
- en: Test your knowledge
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试你的知识
- en: 'The main building blocks for a RESTful API in Tornado are subclasses of which
    the following classes:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Tornado中RESTful API的主要构建块是以下类的子类：
- en: '`tornado.web.GenericHandler`'
  id: totrans-191
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`tornado.web.GenericHandler`'
- en: '`tornado.web.RequestHandler`'
  id: totrans-192
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`tornado.web.RequestHandler`'
- en: '`tornado.web.IncomingHTTPRequestHandler`'
  id: totrans-193
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`tornado.web.IncomingHTTPRequestHandler`'
- en: 'If we just want to support the `GET` and `PATCH` methods, we can override the
    `SUPPORTED_METHODS` class variable with which of the following values:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们只想支持`GET`和`PATCH`方法，我们可以用以下哪个值覆盖`SUPPORTED_METHODS`类变量：
- en: '`("GET", "PATCH")`'
  id: totrans-195
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`("GET", "PATCH")`'
- en: '` {0: "GET", 1: "PATCH"}`'
  id: totrans-196
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '` {0: "GET", 1: "PATCH"}`'
- en: '`{"GET": True, "PATCH": True, "POST": False, "PUT": False}`'
  id: totrans-197
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`{"GET": True, "PATCH": True, "POST": False, "PUT": False}`'
- en: 'The list of tuples for a the `tornado.Web.Application` constructor is composed
    of:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`tornado.Web.Application`构造函数的元组列表由以下组成：'
- en: A regular expression (`regexp`) and a `tornado.web.RequestHandler` subclass
    (`request_class`).
  id: totrans-199
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个正则表达式（`regexp`）和一个`tornado.web.RequestHandler`子类（`request_class`）。
- en: A regular expression (`regexp`) and a `tornado.web.GenericHandler` subclass
    (`request_class`).
  id: totrans-200
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个正则表达式（`regexp`）和一个`tornado.web.GenericHandler`子类（`request_class`）。
- en: A regular expression (`regexp`) and a `tornado.web.IncomingHTTPRequestHandler`
    subclass (`request_class`).
  id: totrans-201
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个正则表达式（`regexp`）和一个`tornado.web.IncomingHTTPRequestHandler`子类（`request_class`）。
- en: 'When we call the `self.write` method with a dictionary as an argument in a
    request handler, Tornado:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们在请求处理器中调用`self.write`方法并将字典作为参数时，Tornado：
- en: Automatically writes the chunk as JSON but we have to manually set the value
    of the `Content-Type` header to `application/json`.
  id: totrans-203
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 自动将块写入JSON格式，但我们必须手动将`Content-Type`头部的值设置为`application/json`。
- en: Requires us to use the `json.dumps` method and set the value of the `Content-Type`
    header to `application/json`.
  id: totrans-204
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 需要我们使用`json.dumps`方法并将`Content-Type`头部的值设置为`application/json`。
- en: Automatically writes the chunk as JSON and sets the value of the `Content-Type`
    header to `application/json`.
  id: totrans-205
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 自动将块写入JSON格式，并将`Content-Type`头部的值设置为`application/json`。
- en: 'A calls to the `tornado.escape.json_decode` method with `self.request.body`
    as an argument in a request handler:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在请求处理器中调用`tornado.escape.json_decode`方法，并将`self.request.body`作为参数：
- en: Generates Python objects for the JSON string of the request body and returns
    the generated tuple.
  id: totrans-207
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为请求体的JSON字符串生成Python对象，并返回生成的元组。
- en: Generates Python objects for the JSON string of the request body and returns
    the generated dictionary.
  id: totrans-208
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为请求体的JSON字符串生成Python对象，并返回生成的字典。
- en: Generates Python objects for the JSON string of the request body and returns
    the generated list.
  id: totrans-209
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为请求体的JSON字符串生成Python对象，并返回生成的列表。
- en: Summary
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we designed a RESTful API to interact with slow sensors and
    actuators. We defined the requirements for our API, understood the tasks performed
    by each HTTP method, and set up a virtual environment with Tornado.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们设计了一个RESTful API来与慢速传感器和执行器交互。我们定义了API的要求，理解了每个HTTP方法执行的任务，并使用Tornado设置了一个虚拟环境。
- en: We created the classes that represent a drone and wrote code to simulate slow
    I/O operations that are called for each HTTP request method, wrote classes that
    represent request handlers and process the different HTTP requests, and configured
    the URL patterns to route URLs to request handlers and their methods.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了代表无人机的类，并编写了代码来模拟每个HTTP请求方法所需的慢速I/O操作，编写了代表请求处理器并处理不同HTTP请求的类，并配置了URL模式以将URL路由到请求处理器及其方法。
- en: Finally, we started Tornado development server, used command-line tools to compose
    and send HTTP requests to our RESTful API, and analyzed how each HTTP requests
    was processed in our code. We also worked with GUI tools to compose and send HTTP
    requests.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们启动了Tornado开发服务器，使用命令行工具来组合并发送HTTP请求到我们的RESTful API，并分析了我们的代码中每个HTTP请求的处理方式。我们还使用GUI工具来组合并发送HTTP请求。
- en: Now that we understand the basics of Tornado to create RESTful APIs, we will
    take advantage of the non-blocking features combined with asynchronous operations
    in Tornado in a new version for the API, which is what we are going to discuss
    in the next chapter.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了Tornado的基本知识以创建RESTful API，我们将利用Tornado的非阻塞特性结合异步操作在API的新版本中，这就是我们将在下一章中讨论的内容。
