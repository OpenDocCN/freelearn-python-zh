- en: Chapter 9.  Developing RESTful APIs with Tornado
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will work with Tornado to create a RESTful Web API and
    start working with this lightweight Web framework. We will cover the following
    topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Designing a RESTful API to interact with slow sensors and actuators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the tasks performed by each `HTTP` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up a virtual environment with Tornado
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Declaring status codes for the responses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the classes that represent a drone
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing request handlers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mapping URL patterns to request handlers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making HTTP requests to the Tornado API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with command-line tools - curl and HTTPie
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with GUI tools - Postman and others
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing a RESTful API to interact with slow sensors and actuators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine that we have to create a RESTful API to control a drone, also known
    as an **Unmanned Aerial Vehicle** (**UAV**). The drone is an IoT device that interacts
    with many sensors and actuators, including digital electronic speed controllers
    linked to engines, propellers, and servomotors.
  prefs: []
  type: TYPE_NORMAL
- en: The IoT device has limited resources, and therefore, we have to use a lightweight
    Web framework. Our API doesn't need to interact with a database. We don't need
    a heavyweight Web framework like Django, and we want to be able to process many
    requests without blocking the Web server. We need the Web server to provide us
    with good scalability while consuming limited resources. Thus, our choice is to
    use Tornado, the open source version of FriendFeed's Web server.
  prefs: []
  type: TYPE_NORMAL
- en: The IoT device is capable of running Python 3.5, Tornado, and other Python packages.
    Tornado is a Python Web framework and an asynchronous networking library that
    provides excellent scalability due to its non-blocking network I/O. In addition,
    Tornado will allow us to easily and quickly build a lightweight RESTful API.
  prefs: []
  type: TYPE_NORMAL
- en: We have chosen Tornado because it is more lightweight than Django and it makes
    it easy for us to create an API that takes advantage of the non-blocking network
    I/O. We don't need to use an ORM, and we want to start running the RESTful API
    on the IoT device as soon as possible to allow all the teams to interact with
    it.
  prefs: []
  type: TYPE_NORMAL
- en: We will interact with a library that allows us to run the slow I/O operations
    that interact with the sensors and actuators with an execution that happens outside
    the **Global Interpreter Lock** (**GIL**). Thus, we will be able to take advantage
    of the non-blocking feature in Tornado when a request needs to execute any of
    these slow I/O operations. In our first version of the API, we will work with
    a synchronous execution, and therefore, when an HTTP request to our API requires
    running a slow I/O operation, we will block the request processing queue until
    the slow I/O operation with either a sensor or an actuator provides a response.
    We will execute the I/O operation with a synchronous execution and Tornado won't
    be able to continue processing other incoming HTTP requests until a response is
    sent to the HTTP request.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we will create a second version of our API that will take advantage of
    the non-blocking features included in Tornado, in combination with asynchronous
    operations. In the second version, when an HTTP request to our API requires running
    a slow I/O operation, we won't block the request processing queue until the slow
    I/O operation with either a sensor or an actuator provides a response. We will
    execute the I/O operation with an asynchronous execution, and Tornado will be
    able to continue processing other incoming HTTP requests.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will keep our example simple and we won't use a library to interact with
    sensors and actuators. We will just print information about the operations that
    will be performed by these sensors and actuators. However, in our second version
    of the API, we will write our code to make asynchronous calls in order to understand
    the advantages of the non-blocking features in Tornado. We will use a simplified
    set of sensors and actuators—bear in mind that drones usually have more sensors
    and actuators. Our goal is to learn how to work with Tornado to build a RESTful
    API; we don't want to become experts in building drones.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each of the following sensors and actuators will be a resource in our RESTful
    API:'
  prefs: []
  type: TYPE_NORMAL
- en: A hexacopter, that is, a 6-rotor helicopter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An altimeter (altitude sensor)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A blue **LED** (**Light-Emitting Diode**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A white LED
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following table shows the HTTP verbs, the scope, and the semantics for
    the methods that our first version of the API must support. Each method is composed
    by an HTTP verb and a scope and all the methods have a well-defined meaning for
    all sensors and actuators. In our API, each sensor or actuator has its own unique
    URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **HTTP verb** | **Scope** | **Semantics** |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | Hexacopter | Retrieve the current hexacopter''s motor speed in RPMs
    and its status (turned on or off) |'
  prefs: []
  type: TYPE_TB
- en: '| `PATCH` | Hexacopter | Set the current hexacopter''s motor speed in RPMs
    |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | LED | Retrieve the brightness level for a single LED |'
  prefs: []
  type: TYPE_TB
- en: '| `PATCH` | LED | Update the brightness level for a single LED |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | Altimeter | Retrieve the current altitude in feet |'
  prefs: []
  type: TYPE_TB
- en: Understanding the tasks performed by each HTTP method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's consider that `http://localhost:8888/hexacopters/1` is the URL that identifies
    the hexacopter for our drone.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have to compose and send an HTTP request with the following HTTP verb (`PATCH`)
    and request URL (`http://localhost:8888/hexacopters/1`) to set the hexacopter''s
    motor speed in RPMs and its status. In addition, we have to provide the JSON key-value
    pairs with the necessary field name and the value to specify the desired speed.
    As a result of the request, the server will validate the provided values for the
    field, make sure that it is a valid speed and make the necessary calls to adjust
    the speed with an asynchronous execution. After the speed for the hexacopter is
    set, the server will return a `200 OK` status code and a JSON body with the recently
    updated hexacopter values serialized to JSON:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We have to compose and send an HTTP request with the following HTTP verb (`GET`)
    and request URL (`http://localhost:8888/hexacopter/1`) to retrieve the current
    values for the hexacopter. The server will make the necessary calls to retrieve
    the status and the speed for the hexacopter with an asynchronous execution. As
    a result of the request, the server will return a `200 OK` status code and a JSON
    body with the serialized key-value pairs that specify the status and speed for
    the hexacopter. If a number different than 1 is specified, the server will return
    just a `404 Not Found` status:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We have to compose and send an HTTP request with the following HTTP verb (`PATCH`)
    and request URL (`http://localhost:8888/led/{id}`) to set the brightness level
    for a specific LED whose id matches the specified numeric value in the place where
    `{id}` is written. For example, if we use the request URL `http://localhost:8888/led/1`,
    the server will set the brightness level for the led whose id matches 1\. In addition,
    we have to provide the JSON key-value pairs with the necessary field name and
    the value to specify the desired brightness level. As a result of the request,
    the server will validate the provided values for the field, make sure that it
    is a valid brightness level and make the necessary calls to adjust the brightness
    level with an asynchronous execution. After the brightness level for the LED is
    set, the server will return a `200 OK` status code and a JSON body with the recently
    updated LED values serialized to JSON:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We have to compose and send an HTTP request with the following HTTP verb (`GET`)
    and request URL (`http://localhost:8888/led/{id}`) to retrieve the current values
    for the LED whose id matches the specified numeric value in the place where `{id}`
    is written. For example, if we use the request URL `http://localhost:8888/led/1`,
    the server will retrieve the LED whose id matches 1\. The server will make the
    necessary calls to retrieve the values for the LED with an asynchronous execution.
    As a result of the request, the server will return a `200 OK` status code and
    a JSON body with the serialized key-value pairs that specify the values for the
    LED. If no LED matches the specified id, the server will return just a `404 Not
    Found` status:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We have to compose and send an HTTP request with the following HTTP verb (`GET`)
    and request URL (`http://localhost:8888/altimeter/1`) to retrieve the current
    values for the altimeter. The server will make the necessary calls to retrieve
    the values for the altimeter with an asynchronous execution. As a result of the
    request, the server will return a `200 OK` status code and a JSON body with the
    serialized key-value pairs that specify the values for the altimeter. If a number
    different than 1 is specified, the server will return just a `404 Not Found` status:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Setting up a virtual environment with Tornado
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 1](ch01.html "Chapter 1. Developing RESTful APIs with Django"),
    *Developing RESTful APIs with Django*, we learned that, throughout this book,
    we were going to work with the lightweight virtual environments introduced in
    Python 3.3 and improved in Python 3.4\. Now, we will follow many steps create
    a new lightweight virtual environment to work with Tornado. It is highly recommended
    to read [Chapter 1](ch01.html "Chapter 1. Developing RESTful APIs with Django"),
    *Developing RESTful APIs with Django*, in case you don't have experience with
    lightweight virtual environments in Python. The chapter includes all the detailed
    explanations about the effects of the steps we are going to follow.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we have to select the target folder or directory for our virtual environment.
    The following is the path we will use in the example for macOS and Linux. The
    target folder for the virtual environment will be the `PythonREST/Tornado01` folder
    within our home directory. For example, if our home directory in macOS or Linux
    is `/Users/gaston`, the virtual environment will be created within `/Users/gaston/PythonREST/Tornado01`.
    You can replace the specified path with your desired path in each command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We will use the following path in the example for Windows. The target folder
    for the virtual environment will be the `PythonREST\Tornado01` folder within our
    user profile folder. For example, if our user profile folder is `C:\Users\Gaston`,
    the virtual environment will be created within `C:\Users\gaston\PythonREST\Tornado01`.
    You can replace the specified path with your desired path in each command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Open a Terminal in macOS or Linux and execute the following command to create
    a virtual environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In Windows, execute the following command to create a virtual environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command doesn't produce any output. Now that we have created a
    virtual environment, we will run a platform-specific script to activate it. After
    we activate the virtual environment, we will install packages that will only be
    available in this virtual environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'If your Terminal is configured to use the `bash` shell in macOS or Linux, run
    the following command to activate the virtual environment. The command also works
    for the `zsh` shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'If your Terminal is configured to use either the `csh` or `tcsh` shell, run
    the following command to activate the virtual environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'If your Terminal is configured to use either the `fish` shell, run the following
    command to activate the virtual environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In Windows, you can run either a batch file in the Command Prompt or a Windows
    PowerShell script to activate the virtual environment. If you prefer the command
    prompt, run the following command in the Windows command line to activate the
    virtual environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If you prefer the Windows PowerShell, launch it and run the following commands
    to activate the virtual environment. However, notice that you should have scripts
    execution enabled in Windows PowerShell to be able to run the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: After you activate the virtual environment, the Command Prompt will display
    the virtual environment root folder name enclosed in parentheses as a prefix of
    the default prompt to remind us that we are working in the virtual environment.
    In this case, we will see (`Tornado01`) as a prefix for the Command Prompt because
    the root folder for the activated virtual environment is `Tornado01`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have created and activated a virtual environment. It is time to run many
    commands that will be the same for either macOS, Linux, or Windows. Now, we must
    run the following command to install Tornado with pip:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The last lines for the output will indicate all the packages that have been
    successfully installed, including `tornado`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Declaring status codes for the responses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tornado allows us to generate responses with any status code that is included
    in the `http.HTTPStatus` dictionary. We might use this dictionary to return easy
    to understand descriptions as the status codes, such as `HTTPStatus.OK` and `HTTPStatus.NOT_FOUND`
    after importing the `HTTPStatus` dictionary from the `http` module. These names
    are easy to understand but they don't include the status code number in their
    description.
  prefs: []
  type: TYPE_NORMAL
- en: We have been working with many different frameworks and micro-frameworks throughout
    the book, and therefore, we will borrow the code that declares very useful functions
    and variables related to HTTP status codes from the `status.py` file included
    in Django REST Framework, that is, the framework we have been using in the first
    chapters. The main advantage of using these variables for the HTTP status codes
    is that their names include both the number and the description. When we read
    the code, we will understand the status code number and their meaning. For example,
    instead of using `HTTPStatus.OK`, we will use `status.HTTP_200_OK`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new `status.py` file within the root folder for the recently created
    virtual environment. The following lines show the code that declares functions
    and variables with descriptive HTTP status codes in the `status.py` file, borrowed
    from the `rest_framework.status` module. We don''t want to reinvent the wheel
    and the module provides everything we need to work with HTTP status codes in our
    Tornado-based API. The code file for the sample is included in the `restful_python_chapter_09_01`
    folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The code declares five functions that receive the HTTP status code in the code
    argument and determine to which of the following categories the status code belongs
    to: informational, success, redirect, and client error or server error categories.
    We will use the previous variables when we have to return a specific status code.
    For example, in case we have to return a `404 Not Found` status code, we will
    return `status.HTTP_404_NOT_FOUND`, instead of just `404` or `HTTPStatus.NOT_FOUND`.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating the classes that represent a drone
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will create as many classes as we will use to represent the different components
    of a drone. In a real-life example, these classes will interact with a library
    that interacts with sensors and actuators. In order to keep our example simple,
    we will make calls to `time.sleep` to simulate interactions that take some time
    to set or get values to and from sensors and actuators.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will create a `Hexacopter` class that we will use to represent the
    hexacopter and a `HexacopterStatus` class that we will use to store status data
    for the hexacopter. Create a new `drone.py` file. The following lines shows all
    the necessary imports for the classes that we will create and the code that declares
    the `Hexacopter` and `HexacopterStatus` classes in the `drone.py` file. The code
    file for the sample is included in the `restful_python_chapter_09_01` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The `HexacopterStatus` class just declares a constructor, that is, the `__init__`
    method. This method receives many arguments and uses them to initialize the attributes
    with the same names: `motor_speed` and `turned_on`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Hexacopter` class declares two class attributes that specify the minimum
    and maximum speed values: `MIN_SPEED` and `MAX_SPEED`. The constructor, that is,
    the `__init__` method, initializes the `motor_speed` attribute with the `MIN_SPEED`
    value and sets the `turned_on` attribute to `False`.'
  prefs: []
  type: TYPE_NORMAL
- en: The `get_motor_speed` method returns the value of the `motor_speed` attribute.
    The `set_motor_speed` method checks whether the value for the `motor_speed` argument
    is in the valid range. In case the validation fails, the method raises a `ValueError`
    exception. Otherwise, the method sets the value of the `motor_speed` attribute
    with the received value and sets the value for the `turned_on` attribute to `True`
    if the `motor_speed` is greater than 0\. Finally, the method calls sleep to simulate
    it takes two seconds to retrieve the hexacopter status and then returns a `HexacopterStatus`
    instance initialized with the `motor_speed` and `turned_on` attribute values,
    retrieved through specific methods.
  prefs: []
  type: TYPE_NORMAL
- en: The `get_hexacopter_status` method calls sleep to simulate it takes three seconds
    to retrieve the hexacopter status and then returns a `HexacopterStatus` instance
    initialized with the `motor_speed` and `turned_on` attribute values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will create a `LightEmittingDiode` class that we will use to represent
    each LED. Open the previously created `drone.py` file and add the following lines.
    The code file for the sample is included in the `restful_python_chapter_09_01`
    folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The `LightEmittingDiode` class declares two class attributes that specify the
    minimum and maximum brightness level values: `MIN_BRIGHTNESS_LEVEL` and `MAX_BRIGHTNESS_LEVEL`.
    The constructor, that is, the `__init__` method, initializes the `brightness_level`
    attribute with the `MIN_BRIGHTNESS_LEVEL` and the `id` and `description` attributes
    with the values received in the arguments with the same names.'
  prefs: []
  type: TYPE_NORMAL
- en: The `get_brightness_level` method calls sleep to simulate, it takes 1 second
    to retrieve the brightness level for the wired LED and then returns the value
    of the `brightness_level` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: The `set_brightness_level` method checks whether the value for the `brightness_level`
    argument is in the valid range. In case the validation fails, the method raises
    a `ValueError` exception. Otherwise, the method calls `sleep` to simulate it takes
    two seconds to set the new brightness level and finally sets the value of the
    `brightness_level` attribute with the received value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will create an `Altimeter` class that we will use to represent the
    altimeter. Open the previously created `drone.py` file and add the following lines.
    The code file for the sample is included in the `restful_python_chapter_09_01`
    folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `Altimeter` class declares a `get_altitude` method that calls `sleep` to
    simulate it takes one second to retrieve the altitude from the altimeter and finally
    generates a random integer from 0 to `3000` (inclusive) and returns it.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we will create a `Drone` class that we will use to represent the drone
    with its sensors and actuators. Open the previously created `drone.py` file and
    add the following lines. The code file for the sample is included in the `restful_python_chapter_09_01`
    folder
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `Drone` class just declares a constructor, that is, the `__init__` method
    that creates instances of the previously declared classes that represent the different
    components for the drone. The `leds` attribute saves a dictionary that has a key-value
    pair for each `LightEmittingDiode` instance with its id and its instance.
  prefs: []
  type: TYPE_NORMAL
- en: Writing request handlers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main building blocks for a RESTful API in tornado are subclasses of the
    `tornado.web.RequestHandler` class, that is, the base class for HTTP request handlers
    in Tornado. We just need to create a subclass of this class and declare the methods
    for each supported HTTP verb. We have to override the methods to handle HTTP requests.
    Then, we have to map the URL patterns to each subclass of `tornado.web.RequestHandler`
    in the `tornado.web.Application` instance that represents the Tornado Web application.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will create a `HexacopterHandler` class that we will use to handle
    requests for the hexacopter resource. Create a new `api.py` file. The following
    lines show all the necessary imports for the classes that we will create and the
    code that declares the `HexacopterHandler` class in the `drone.py` file. Enter
    the next lines in the new `api.py` file. The code file for the sample is included
    in the `restful_python_chapter_09_01` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The `HexacopterHandler` class is a subclass of `tornado.web.RequestHandler`
    and declares the following two methods that will be called when the HTTP method
    with the same name arrives as a request on this HTTP handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '`get`: This method receives the `id` of the hexacopter whose status has to
    be retrieved in the `id` argument. If the received id doesn''t match the value
    of the `HEXACOPTER_ID` class attribute, the code calls the `self.set_status` method
    with `status.HTTP_404_NOT_FOUND` as an argument to set the status code for the
    response to `HTTP 404 Not Found`. Otherwise, the code prints a message indicating
    that it started retrieving the hexacopter''s status and calls the `drone.hexacopter.get_hexacopter_status`
    method with a synchronous execution and saves the result in the `hexacopter_status`
    variable. Then, the code writes a message indicating it finished retrieving the
    status and generates a `response` dictionary with the `''speed''` and `''turned_on''`
    keys and their values. Finally, the code calls the `self.set_status` method with
    `status.HTTP_200_OK` as an argument to set the status code for the response to
    `HTTP 200 OK` and calls the `self.write` method with the `response` dictionary
    as an argument. Because `response` is a dictionary, Tornado automatically writes
    the chunk as JSON and sets the value of the `Content-Type` header to `application/json`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`patch`: This method receives the `id` of the hexacopter that has to be updated
    or patched in the `id` argument. As it happened in the previously explained get
    method, the code returns an `HTTP 404 Not Found` in case the received id doesn''t
    match the value of the `HEXACOPTER_ID` class attribute. Otherwise, the code calls
    the `tornado.escape.json_decode` method with `self.request.body` as an argument
    to generate Python objects for the JSON string of the request body and saves the
    generated dictionary in the `request_data` variable. If the dictionary doesn''t
    include a key named `''motor_speed''`, the code returns an `HTTP 400 Bad Request`
    status code. In case there is a key, the code prints a message indicating that
    it started setting the hexacopter''s speed, calls the `drone.hexacopter.set_motor_speed`
    method with a synchronous execution and saves the result in the `hexacopter_status`
    variable. If the value specified for the motor speed is not valid, a `ValueError`
    exception will be caught and the code will return an HTTP 400 Bad Request status
    code and the validation error messages as the response body. Otherwise, the code
    writes a message indicating it finished setting the motor speed and generates
    a `response` dictionary with the `''speed''` and `''turned_on''` keys and their
    values. Finally, the code calls the `self.set_status` method with `status.HTTP_200_OK`
    as an argument to set the status code for the response to HTTP 200 OK and calls
    the `self.write` method with the `response` dictionary as an argument. Since `response`
    is a dictionary, Tornado automatically writes the chunk as JSON and sets the value
    of the `Content-Type` header to `application/json`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The class overrides the `SUPPORTED_METHODS` class variable with a tuple that
    indicates the class just supports the `GET` and `PATCH` methods. This way, in
    case the handler is requested a method that isn't included in the `SUPPORTED_METHODS`
    tuple, the server will automatically return a `405 Method Not Allowed` status
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will create a `LedHandler` class that we will use to represent the
    LED resources. Open the previously created `api.py` file and add the following
    lines. The code file for the sample is included in the `restful_python_chapter_09_01`
    folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The `LedHandler` class is a subclass of `tornado.web.RequestHandler`. The class
    overrides the `SUPPORTED_METHODS` class variable with a tuple that indicates the
    class just supports the `GET` and `PATCH` methods. In addition, the class declares
    the following two methods that will be called when the HTTP method with the same
    name arrives as a request on this HTTP handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '`get`: This method receives the `id` of the LED whose status has to be retrieved
    in the `id` argument. If the received id isn''t one of the keys of the `drone.leds`
    dictionary, the code calls the `self.set_status` method with `status.HTTP_404_NOT_FOUND`
    as an argument to set the status code for the response to `HTTP 404 Not Found`.
    Otherwise, the code retrieves the value associated with the key whose value matches
    the id in the `drone.leds` dictionary and saves the retrieved `LightEmittingDiode`
    instance in the `led` variable. The code prints a message indicating that it started
    retrieving the LED''s brightness level, calls the `led.get_brightness_level` method
    with a synchronous execution, and saves the result in the `brightness_level` variable.
    Then, the code writes a message indicating that it finished retrieving the brightness
    level and generates a `response` dictionary with the `''id''`, `''description''`,
    and `''brightness_level''` keys and their values. Finally, the code calls the
    `self.set_status` method with `status.HTTP_200_OK` as an argument to set the status
    code for the response to HTTP 200 OK and calls the `self.write` method with the
    `response` dictionary as an argument. Since `response` is a dictionary, Tornado
    automatically writes the chunk as JSON and sets the value of the `Content-Type`
    header to `application/json`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`patch`: This method receives the id of the LED that has to be updated or patched
    in the `id` argument. As happened in the previously explained get method, the
    code returns an `HTTP 404 Not Found` in case the received id doesn''t match the
    any of the keys of the `drone.leds` dictionary. Otherwise, the code calls the
    `tornado.escape.json_decode` method with `self.request.body` as an argument to
    generate Python objects for the JSON string of the request body and saves the
    generated dictionary in the `request_data` variable. If the dictionary doesn''t
    include a key named `''brightness_level''`, the code returns an `HTTP 400 Bad
    Request` status code. In case there is a key, the code prints a message indicating
    that it started setting the LED''s brightness level, including the description
    for the LED, calls the `drone.hexacopter.set_brightness_level` method with a synchronous
    execution. If the value specified for the `brightness_level` is not valid, a `ValueError`
    exception will be caught and the code will return an `HTTP 400 Bad Request` status
    code and the validation error messages as the response body. Otherwise, the code
    writes a message indicating it finished setting the LED''s brightness value and
    generates a `response` dictionary with the `''id''`, `''description''`, and `''brightness_level''`
    keys and their values. Finally, the code calls the `self.set_status` method with
    `status.HTTP_200_OK` as an argument to set the status code for the response to
    HTTP 200 OK and calls the `self.write` method with the `response` dictionary as
    an argument. Since `response` is a dictionary, Tornado automatically writes the
    chunk as JSON and sets the value of the `Content-Type` header to `application/json`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, we will create an `AltimeterHandler` class that we will use to represent
    the altimeter resource. Open the previously created `api.py` file and add the
    following lines. The code file for the sample is included in the `restful_python_chapter_09_01`
    folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `AltimeterHandler` class is a subclass of `tornado.web.RequestHandler`.
    The class overrides the `SUPPORTED_METHODS` class variable with a tuple that indicates
    the class just supports the `GET` method. In addition, the class declares the
    `get` method that will be called when the HTTP method with the same name arrives
    as a request on this HTTP handler.
  prefs: []
  type: TYPE_NORMAL
- en: The `get` method receives the `id` of the altimeter whose altitude has to be
    retrieved in the `id` argument. If the received id doesn't match the value of
    the `ALTIMETER_ID` class attribute, the code calls the `self.set_status` method
    with `status.HTTP_404_NOT_FOUND` as an argument to set the status code for the
    response to HTTP 404 Not Found. Otherwise, the code prints a message indicating
    that it started retrieving the altimeter's altitude, calls the `drone.hexacopter.get_altitude`
    method with a synchronous execution, and saves the result in the `altitude` variable.
    Then, the code writes a message indicating it finished retrieving the altitude
    and generates a `response` dictionary with the `'altitude'` key and its value.
    Finally, the code calls the `self.set_status` method with `status.HTTP_200_OK`
    as an argument to set the status code for the response to HTTP 200 OK and calls
    the `self.write` method with the `response` dictionary as an argument. Since `response`
    is a dictionary, Tornado automatically writes the chunk as JSON and sets the value
    of the `Content-Type` header to `application/json`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table shows the method of our previously created HTTP handler
    classes that we want to be executed for each combination of HTTP verb and scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **HTTP verb** | **Scope** | **Class and method** |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | Hexacopter | `HexacopterHandler.get` |'
  prefs: []
  type: TYPE_TB
- en: '| `PATCH` | Hexacopter | `HexacopterHandler.patch` |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | LED | `LedHandler.get` |'
  prefs: []
  type: TYPE_TB
- en: '| `PATCH` | LED | `LedHandler.patch` |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | Altimeter | `AltimeterHandler.get` |'
  prefs: []
  type: TYPE_TB
- en: If the request results in the invocation of an HTTP handler class with an unsupported
    HTTP method, Tornado will return a response with the HTTP `405 Method Not Allowed`
    status code.
  prefs: []
  type: TYPE_NORMAL
- en: Mapping URL patterns to request handlers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We must map URL patterns to our previously coded subclasses of `tornado.web.RequestHandler`.
    The following lines create the main entry point for the application, initialize
    it with the URL patterns for the API, and starts listening for requests. Open
    the previously created `api.py` file and add the following lines. The code file
    for the sample is included in the `restful_python_chapter_09_01` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code creates an instance of `tornado.web.Application` named `application`
    with the collection of request handlers that make up the Web application. The
    code passes a list of tuples to the `Application` constructor. The list is composed
    of a regular expression (`regexp`) and a `tornado.web.RequestHandler` subclass
    (`request_class`). In addition, the code sets the `debug` argument to `True` to
    enable debugging.
  prefs: []
  type: TYPE_NORMAL
- en: The `main` method calls the `application.listen` method to build an HTTP server
    for the application with the defined rules on the specified port. In this case,
    the code specifies `8888` as the port, saved in the `port` variable, which is
    the default port for Tornado HTTP servers. Then, the call to `tornado.ioloop.IOLoop.instance().start()`
    starts the server created with the previous call to the `application.listen` method.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As with any other Web framework, you should never enable debugging in a production
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: Making HTTP requests to the Tornado API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we can run the `api.py` script that launches Tornados''s development server
    to compose and send HTTP requests to our unsecure and simple Web API. Execute
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The following lines show the output after we execute the previous command.
    The Tornado HTTP development server is listening at port `8888`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: With the previous command, we will start the Tornado HTTP server and it will
    listen on every interface on port `8888`. Thus, if we want to make HTTP requests
    to our API from other computers or devices connected to our LAN, we don't need
    any additional configurations.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you decide to compose and send HTTP requests from other computers or devices
    connected to the LAN, remember that you have to use the development computer's
    assigned IP address instead of `localhost`. For example, if the computer's assigned
    IPv4 IP address is `192.168.1.103`, instead of `localhost:8888`, you should use
    `192.168.1.103:8888`. Of course, you can also use the host name instead of the
    IP address. The previously explained configurations are very important because
    mobile devices might be the consumers of our RESTful APIs and we will always want
    to test the apps that make use of our APIs in our development environments.
  prefs: []
  type: TYPE_NORMAL
- en: The Tornado HTTP server is running on localhost (`127.0.0.1`), listening on
    port `8888`, and waiting for our HTTP requests. Now, we will compose and send
    HTTP requests locally in our development computer or from other computer or devices
    connected to our LAN.
  prefs: []
  type: TYPE_NORMAL
- en: "Working with command-line tools â\x80\x93 curl and httpie"
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will start composing and sending HTTP requests with the command-line tools
    we have introduced in [Chapter 1](ch01.html "Chapter 1. Developing RESTful APIs
    with Django"), *Developing RESTful APIs with Django*, curl and HTTPie. In case
    you haven''t installed HTTPie, make sure you activate the virtual environment
    and then run the following command in the terminal or Command Prompt to install
    the HTTPie package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: "In case you don't remember how to activate the virtual environment that we\
    \ created for this example, read the following section in this chapter*—\x80\x94\
    Setting up the virtual environment with Django REST Framework*."
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a Cygwin terminal in Windows or a Terminal in macOS or Linux and run the
    following command. We will compose and send an HTTP request to turn on the hexacopter
    and set its motor speed to 100 RPMs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the equivalent curl command. It is very important to use the
    `-H "Content-Type: application/json"` option to indicate curl to send the data
    specified after the `-d` option as `application/json` instead of the default `application/x-www-form-urlencoded`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding commands will compose and send the following HTTP request, `PATCH
    http://localhost:8888/hexacopters/1`, with the following JSON key-value pair:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The request specifies `/hexacopters/1`, and therefore, Tornado will iterate
    over the list of tuples with regular expressions and request classes and it will
    match `''/hexacopters/([0-9]+)''`. Tornado will create an instance of the `HexacopterHandler`
    class and run the `HexacopterHandler.patch` method with `1` as the value for the
    `id` argument. As the HTTP verb for the request is `PATCH`, Tornado calls the
    `patch` method. If the hexacopter''s speed is successfully set, the method returns
    an `HTTP 200 OK` status code and the key-value pairs with the speed and status
    for the recently updated hexacopter serialized to JSON in the response body. The
    following lines show an example response for the HTTP request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We will compose and send an HTTP request to retrieve the status and the motor
    speed for the hexacopter. Go back to the Cygwin terminal in Windows or the Terminal
    in macOS or Linux, and run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the equivalent `curl` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding commands will compose and send the following HTTP request: `GET
    http://localhost:8888/hexacopters/1`. The request specifies `/hexacopters/1`,
    and therefore, it will match `''/hexacopters/([0-9]+)''` and run the `HexacopterHandler.get`
    method with `1` as the value for the `id` argument. As the HTTP verb for the request
    is `GET`, Tornado calls the `get` method. The method retrieves the hexacopter''s
    status and generates a JSON response with the key-value pairs.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following lines show an example response for the HTTP request. The first
    lines show the HTTP response headers, including the status (`200 OK`) and the
    `Content-type` as (`application/json`). After the HTTP response headers, we can
    see the details of the hexacopter''s status in the JSON response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'After we run the three requests, we will see the following lines in the window
    that is running the Tornado HTTP server. The output shows the results of executing
    the print statements that describe when the code started setting or retrieving
    information and when it finished:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The different methods we coded in the request handler classes end up calling
    `time.sleep` to simulate it takes some time for the operations with the hexacopter.
    In this case, our code is running with a synchronous execution, and therefore,
    each time we compose and send a request, the Tornado server is blocked until the
    operation with the hexacopter finishes and the method sends the response. We will
    create a new version of this API that will use asynchronous execution later and
    we will understand the advantages of Tornado's non-blocking features. However,
    first, we will understand how the synchronous version of the API works.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following image shows two Terminal windows side-by-side on macOS. The Terminal
    window on the left-hand side is running the Tornado HTTP server and displays the
    messages printed in the methods that process the HTTP requests. The Terminal window
    on the right-hand side is running `http` commands to generate the HTTP requests.
    It is a good idea to use a similar configuration to check the output while we
    compose and send the HTTP requests:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Working with command-line tools â\x80\x93 curl and httpie](img/image_09_001.jpg)"
  prefs: []
  type: TYPE_IMG
- en: 'Now, we will compose and send an HTTP request to retrieve a hexacopter that
    doesn''t exist. Remember that we just have one hexacopter in our drone. Run the
    following command to try to retrieve the status for an hexacopter with an invalid
    id. We must make sure that the utilities display the headers as part of the response
    to see the returned status code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the equivalent `curl` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous commands will compose and send the following HTTP request: `GET
    http://localhost:8888/hexacopters/8`. The request is the same as the previous
    one we have analyzed, with a different number for the `id` parameter. The server
    will run the `HexacopterHandler.get` method with `8` as the value for the `id`
    argument. The `id` is not equal to 1, and therefore, the code will return an HTTP
    `404 Not Found` status code. The following lines show an example header response
    for the HTTP request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Working with GUI tools - Postman and others
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So far, we have been working with two Terminal-based or command-line tools
    to compose and send HTTP requests to our Tornado HTTP server-cURL and HTTPie.
    Now, we will work with one of the GUI tools we used when composing and sending
    HTTP requests to the Django development server and the Flask development server:
    Postman.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will use the **Builder** tab in Postman to easily compose and send HTTP
    requests to `localhost:8888` and test the RESTful API with this GUI tool. Remember
    that Postman doesn't support curl-like shorthands for localhost, and therefore,
    we cannot use the same shorthands we have been using when composing requests with
    curl and HTTPie.
  prefs: []
  type: TYPE_NORMAL
- en: Select **GET** in the drop-down menu at the left-hand side of the **Enter request
    URL** textbox and enter `localhost:8888/leds/1` in this textbox at the right-hand
    side of the dropdown. Now, click on **Send** and Postman will display the status
    (`200 OK`), the time it took for the request to be processed and the response
    body with all the games formatted as JSON with syntax highlighting (**Pretty**
    view).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the JSON response body in Postman for the HTTP
    GET request:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with GUI tools - Postman and others](img/image_09_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on **Headers** on the right-hand side of **Body** and **Cookies** to
    read the response headers. The following screenshot shows the layout for the response
    headers that Postman displays for the previous response. Note that Postman displays
    the **Status** at the right-hand side of the response and doesn''t include it
    as the first line of the Headers, as it happened when we worked with both the
    cURL and HTTPie utilities:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with GUI tools - Postman and others](img/image_09_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, we will use the **Builder** tab in Postman to compose and send an HTTP
    request to create a new message, specifically, a PATCH request. Follow the next
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Select **PATCH** from the drop-down menu on the left-hand side of the **Enter
    request URL** textbox and enter `localhost:8888/leds/1` in this textbox at the
    right-hand side of the dropdown.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Body** on the right-hand side of **Authorization** and **Headers**,
    within the panel that composes the request.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Activate the **raw** radio button and select `JSON (application/json)` in the
    dropdown on the right-hand side of the **binary** radio button. Postman will automatically
    add a `Content-type = application/json` header, and therefore, you will notice
    the **Headers** tab will be renamed to **Headers (1)**, indicating us that there
    is one key-value pair specified for the request headers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter the following lines in the textbox below the radio buttons, within the
    **Body** tab:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the request body in Postman:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with GUI tools - Postman and others](img/image_09_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We followed the necessary steps to create an HTTP `PATCH` request with a JSON
    body that specifies the necessary key-value pairs to create a new game. Click
    on **Send** and Postman will display the Status (`200 OK`), the time it took for
    the request to be processed, and the response body with the recently added game
    formatted as JSON with syntax highlighting (**Pretty** view). The following screenshot
    shows the JSON response body in Postman for the HTTP POST request.
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with GUI tools - Postman and others](img/image_09_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The Tornado HTTP server is listening on every interface on port `8888`, and
    therefore, we can also use apps that can compose and send HTTP requests from mobile
    devices to work with the RESTful API. For example, we can work with the previously
    introduced iCurlHTTP app on iOS devices such as iPad Pro and iPhone. In Android
    devices, we can work with the previously introduced HTTP Request App.
  prefs: []
  type: TYPE_NORMAL
- en: "The following screenshot shows the results of composing and sending the following\
    \ HTTP request with the iCurlHTTP appâ\x80\x94`GET http://192.168.2.3:8888/altimeters/1`.\
    \ Remember that you have to perform the previously explained configurations in\
    \ your LAN and router to be able to access the Flask development server from other\
    \ devices connected to your LAN. In this case, the IP assigned to the computer\
    \ running the Tornado HTTP server is `192.168.2.3`, and therefore, you must replace\
    \ this IP with the IP assigned to your development computer:"
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with GUI tools - Postman and others](img/image_09_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Test your knowledge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The main building blocks for a RESTful API in Tornado are subclasses of which
    the following classes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`tornado.web.GenericHandler`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`tornado.web.RequestHandler`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`tornado.web.IncomingHTTPRequestHandler`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If we just want to support the `GET` and `PATCH` methods, we can override the
    `SUPPORTED_METHODS` class variable with which of the following values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`("GET", "PATCH")`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '` {0: "GET", 1: "PATCH"}`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`{"GET": True, "PATCH": True, "POST": False, "PUT": False}`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The list of tuples for a the `tornado.Web.Application` constructor is composed
    of:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A regular expression (`regexp`) and a `tornado.web.RequestHandler` subclass
    (`request_class`).
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A regular expression (`regexp`) and a `tornado.web.GenericHandler` subclass
    (`request_class`).
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A regular expression (`regexp`) and a `tornado.web.IncomingHTTPRequestHandler`
    subclass (`request_class`).
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When we call the `self.write` method with a dictionary as an argument in a
    request handler, Tornado:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Automatically writes the chunk as JSON but we have to manually set the value
    of the `Content-Type` header to `application/json`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Requires us to use the `json.dumps` method and set the value of the `Content-Type`
    header to `application/json`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Automatically writes the chunk as JSON and sets the value of the `Content-Type`
    header to `application/json`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A calls to the `tornado.escape.json_decode` method with `self.request.body`
    as an argument in a request handler:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Generates Python objects for the JSON string of the request body and returns
    the generated tuple.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Generates Python objects for the JSON string of the request body and returns
    the generated dictionary.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Generates Python objects for the JSON string of the request body and returns
    the generated list.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we designed a RESTful API to interact with slow sensors and
    actuators. We defined the requirements for our API, understood the tasks performed
    by each HTTP method, and set up a virtual environment with Tornado.
  prefs: []
  type: TYPE_NORMAL
- en: We created the classes that represent a drone and wrote code to simulate slow
    I/O operations that are called for each HTTP request method, wrote classes that
    represent request handlers and process the different HTTP requests, and configured
    the URL patterns to route URLs to request handlers and their methods.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we started Tornado development server, used command-line tools to compose
    and send HTTP requests to our RESTful API, and analyzed how each HTTP requests
    was processed in our code. We also worked with GUI tools to compose and send HTTP
    requests.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand the basics of Tornado to create RESTful APIs, we will
    take advantage of the non-blocking features combined with asynchronous operations
    in Tornado in a new version for the API, which is what we are going to discuss
    in the next chapter.
  prefs: []
  type: TYPE_NORMAL
