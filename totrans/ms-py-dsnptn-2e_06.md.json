["```py\nquotes = (\n    \"A man is not complete until he is married. Then he is finished.\",\n    \"As I said before, I never repeat myself.\",\n    \"Behind a successful man is an exhausted woman.\",\n    \"Black holes really suck...\",\n    \"Facts are stubborn things.\",\n)\n```", "```py\nclass QuoteModel:\n    def get_quote(self, n):\n        try:\n            value = quotes[n]\n        except IndexError as err:\n            value = \"Not found!\"\n        return value\n```", "```py\nclass QuoteTerminalView:\n    def show(self, quote):\n        print(f'And the quote is: \"{quote}\"')\n    def error(self, msg):\n        print(f\"Error: {msg}\")\n    def select_quote(self):\n        return input(\"Which quote number would you like to see? \")\n```", "```py\nclass QuoteTerminalController:\n    def __init__(self):\n        self.model = QuoteModel()\n        self.view = QuoteTerminalView()\n    def run(self):\n        valid_input = False\n        while not valid_input:\n            try:\n                n = self.view.select_quote()\n                n = int(n)\n                valid_input = True\n            except ValueError as err:\n                self.view.error(f\"Incorrect index '{n}'\")\n        quote = self.model.get_quote(n)\n        self.view.show(quote)\n```", "```py\ndef main():\n    controller = QuoteTerminalController()\n    while True:\n        controller.run()\n```", "```py\nWhich quote number would you like to see? 3\nAnd the quote is: \"Black holes really suck...\"\nWhich quote number would you like to see? 2\nAnd the quote is: \"Behind a successful man is an exhausted woman.\"\nWhich quote number would you like to see? 6\nAnd the quote is: \"Not found!\"\nWhich quote number would you like to see? 4\nAnd the quote is: \"Facts are stubborn things.\"\nWhich quote number would you like to see? 3\nAnd the quote is: \"Black holes really suck...\"\nWhich quote number would you like to see? 1\nAnd the quote is: \"As I said before, I never repeat myself.\"\n```", "```py\nsyntax = \"proto3\";\npackage payment;\n// The payment service definition.\nservice PaymentService {\n  // Processes a payment\n  rpc ProcessPayment (PaymentRequest) returns (PaymentResponse) {}\n}\n// The request message containing payment details.\nmessage PaymentRequest {\n  string order_id = 1;\n  double amount = 2;\n  string currency = 3;\n  string user_id = 4;\n}\n// The response message containing the result of the payment process.\nmessage PaymentResponse {\n  string payment_id = 1;\n  string status = 2; // e.g., \"SUCCESS\", \"FAILED\"\n}\n```", "```py\ncd ch06/microservices/grpc), and then we run the following command:\n\n```", "```py\nfrom concurrent.futures import ThreadPoolExecutor\nimport grpc\nimport payment_pb2\nimport payment_pb2_grpc\nclass PaymentServiceImpl(payment_pb2_grpc.PaymentServiceServicer):\n    def ProcessPayment(self, request, context):\n        return payment_pb2.PaymentResponse(payment_id=\"12345\", status=\"SUCCESS\")\n```", "```py\ndef main():\n    print(\"Payment Processing Service ready!\")\n    server = grpc.server(ThreadPoolExecutor(max_workers=10))\n    payment_pb2_grpc.add_PaymentServiceServicer_to_server(PaymentServiceImpl(), server)\n    server.add_insecure_port(\"[::]:50051\")\n    server.start()\n    server.wait_for_termination()\n```", "```py\nimport grpc\nimport payment_pb2\nimport payment_pb2_grpc\nwith grpc.insecure_channel(\"localhost:50051\") as chan:\n    stub = payment_pb2_grpc.PaymentServiceStub(chan)\n    resp = stub.ProcessPayment(\n        payment_pb2.PaymentRequest(\n            order_id=\"order123\",\n            amount=99.99,\n            currency=\"USD\",\n            user_id=\"user456\",\n        )\n    )\n    print(\"Payment Service responded.\")\n    print(f\"Response status: {resp.status}\")\n```", "```py\npython ch06/microservices/grpc/payment_service.py\n```", "```py\nch06/microservices/grpc/client.py file):\n\n```", "```py\n\n\t\t\tIn the terminal where you have run the client code, you should get the following output:\n\n```", "```py\n\n\t\t\tThis output is what is expected.\n\t\t\tNote that while gRPC is a powerful choice for Microservices communication, other approaches such as **REST over HTTP** can also be used, especially when human readability or web integration is a priority. However, gRPC provides advantages in terms of performance and support for streaming requests and responses, and it was interesting to introduce it with this example.\n\t\t\tImplementing the microservices pattern – an LLM service using Lanarky\n\t\t\tLanarky is a web framework that builds upon the FastAPI framework, to provide batteries for building Microservices that use **large language** **models** (**LLMs**).\n\t\t\tWe will follow the *Getting started* instructions from the website ([https://lanarky.ajndkr.com](https://lanarky.ajndkr.com)) to showcase a microservice backed by Lanarky. To be able to test the example, you need to set the `OPENAI_API_KEY` environment variable to use OpenAI. Visit [https://openai.com](https://openai.com) and follow the instructions to get your API key.\n\t\t\tThe LLM service code starts by importing the modules we need:\n\n```", "```py\n\n\t\t\tBefore starting the actual application code, you need to pass the OpenAI API key, which is used by Lanarky’s code via the `os.environ` object. For example, pass the value of the secret key via this line:\n\n```", "```py\n\n\t\t\tSecurity practice\n\t\t\tIt is recommended that you pass secret keys to the code, by setting an environment variable in your shell.\n\t\t\tThen, we create an `app` object, an instance of the `Lanarky` class, and the `router` object that will be used for the definition of the service’s routes, as is conventional with FastAPI. This router is an instance of the `OpenAPIRouter` class provided by the Lanarky framework:\n\n```", "```py\n\n\t\t\tNext, we provide a `chat()` function for the `/chat` route, when there is a `POST` request, as follows:\n\n```", "```py\n\n\t\t\tFinally, we associate the router to the FastAPI application (standard FastAPI convention) and we run the FastAPI application (our service) using `uvicorn.run()`, as follows:\n\n```", "```py\n\n\t\t\tTo finalize this demonstration implementation, we can write client code to interact with the service. The code for that part is as follows:\n\n```", "```py\n\n\t\t\tTo test the example, similarly to the previous one (where we tested a gRPC-based microservice), open a terminal, and run the LLM service code (in the `ch06/microservices/lanarky/llm_service.py` file) using the following command:\n\n```", "```py\n\n\t\t\tYou should get an output like the following:\n\n```", "```py\n\n\t\t\tThen, open a second terminal to run the client program, using the following command:\n\n```", "```py\n\n\t\t\tYou should get the following output:\n\n```", "```py\n\n\t\t\tNow, you can continue sending messages via the client program, and wait for the service to come back with the completion, as you would do via the ChatGPT interface.\n\t\t\tFor example, see the following code:\n\n```", "```py\n\n\t\t\tThe Serverless pattern\n\t\t\tThe Serverless pattern abstracts server management, allowing developers to focus solely on code. Cloud providers handle the scaling and execution based on event triggers, such as HTTP requests, file uploads, or database modifications.\n\t\t\t![Figure 6.3 – The Serverless pattern](img/B21896_06_03.jpg)\n\n\t\t\tFigure 6.3 – The Serverless pattern\n\t\t\tThe Serverless pattern is particularly useful for Microservices, APIs, and event-driven architectures.\n\t\t\tReal-world examples\n\t\t\tThere are several examples we can think of for the Serverless pattern. Here are some of them:\n\n\t\t\t\t*   **Automated data backups**: Serverless functions can be scheduled to automatically back up important data to cloud storage\n\t\t\t\t*   **Image processing**: Whenever a user uploads an image, a serverless function can automatically resize, compress, or apply filters to the image\n\t\t\t\t*   **PDF generation for E-commerce receipts**: After a purchase is made, a serverless function generates a PDF receipt and emails it to the customer\n\n\t\t\tUse cases for the Serverless pattern\n\t\t\tThere are two types of use cases the Serverless pattern can be used for.\n\t\t\tFirst, Serverless is useful for handling event-driven architectures where specific functions need to be executed in response to events, such as doing image processing (cropping, resizing) or dynamic PDF generation.\n\t\t\tThe second type of architecture where Serverless can be used is **Microservices**. Each microservice can be a serverless function, making it easier to manage and scale.\n\t\t\tSince we have already discussed the Microservices pattern in the previous section, we are going to focus on how to implement the first use case.\n\t\t\tImplementing the Serverless pattern\n\t\t\tLet’s see a simple example using AWS Lambda to create a function that squares a number. AWS Lambda is Amazon’s serverless **compute** service, which runs code in response to triggers such as changes in data, shifts in system state, or actions by users.\n\t\t\tThere is no need to add more complexity since there’s already enough to get right with the Serverless architecture itself and AWS Lambda’s deployment details.\n\t\t\tFirst, we need to write the Python code for the function. We create a `lambda_handler()` function, which takes two parameters, `event` and `context`. In our case, the input number is accessed as a value of the “number” key in the event dictionary. We take the square of that value and we return a a string containing the expected result. The code is as follows:\n\n```", "```py\n\n\t\t\tOnce we have the Python function, we need to deploy it so that it can be invoked as an AWS Lambda function. For our learning, instead of going through the procedure of deploying to AWS infrastructure, we can use a method that consists of testing things locally. This is what the `LocalStack` Python package allows us to do. Once it is installed, from your environment, you can start LocalStack inside a Docker container by running the available executable in your Python environment, using the command:\n\n```", "```py\nawslocal tool (a Python module we need to install). Once installed, we can use this program to deploy the Lambda function into the “local stack” AWS infrastructure. This is done, in our case, using the following command:\n\n```", "```py\n\n\t\t\tAdapt to your Python version\n\t\t\tAt the time of writing, this was tested with Python 3.11\\. You must adapt this command to your Python version.\n\t\t\tYou can test the Lambda function, providing an input using the `payload.json` file, using the command:\n\n```", "```py\nawslocal, running the following command:\n\n```", "```py\ncurl -X POST \\\n    'http://iu4s187onr1oabg50dbvm77bk6r5sunk.lambda-url.us-east-1.localhost.localstack.cloud:4566/' \\\n    -H 'Content-Type: application/json' \\\n    -d '{\"number\": 6}'\n```", "```py\nclass Account:\n    def __init__(self):\n        self.balance = 0\n        self.events = []\n    def apply_event(self, event):\n        if event[\"type\"] == \"deposited\":\n            self.balance += event[\"amount\"]\n        elif event[\"type\"] == \"withdrawn\":\n            self.balance -= event[\"amount\"]\n        self.events.append(event)\n```", "```py\n    def deposit(self, amount):\n        event = {\"type\": \"deposited\", \"amount\": amount}\n        self.apply_event(event)\n    def withdraw(self, amount):\n        event = {\"type\": \"withdrawn\", \"amount\": amount}\n        self.apply_event(event)\n```", "```py\ndef main():\n    account = Account()\n    account.deposit(100)\n    account.deposit(50)\n    account.withdraw(30)\n    account.deposit(30)\n    for evt in account.events:\n        print(evt)\n    print(f\"Balance: {account.balance}\")\n```", "```py\n{'type': 'deposited', 'amount': 100}\n{'type': 'deposited', 'amount': 50}\n{'type': 'withdrawn', 'amount': 30}\n{'type': 'deposited', 'amount': 30}\nBalance: 150\n```", "```py\nfrom eventsourcing.domain import Aggregate, event\nfrom eventsourcing.application import Application\n```", "```py\nclass InventoryItem(Aggregate):\n    @event(\"ItemCreated\")\n    def __init__(self, name, quantity=0):\n        self.name = name\n        self.quantity = quantity\n    @event(\"QuantityIncreased\")\n    def increase_quantity(self, amount):\n        self.quantity += amount\n    @event(\"QuantityDecreased\")\n    def decrease_quantity(self, amount):\n        self.quantity -= amount\n```", "```py\nclass InventoryApp(Application):\n    def create_item(self, name, quantity):\n        item = InventoryItem(name, quantity)\n        self.save(item)\n        return item.id\n```", "```py\n    def increase_item_quantity(self, item_id, amount):\n        item = self.repository.get(item_id)\n        item.increase_quantity(amount)\n        self.save(item)\n    def decrease_item_quantity(self, item_id, amount):\n        item = self.repository.get(item_id)\n        item.decrease_quantity(amount)\n        self.save(item)\n```", "```py\ndef main():\n    app = InventoryApp()\n    # Create a new item\n    item_id = app.create_item(\"Laptop\", 10)\n    # Increase quantity\n    app.increase_item_quantity(item_id, 5)\n    # Decrease quantity\n    app.decrease_item_quantity(item_id, 3)\n    notifs = app.notification_log.select(start=1, limit=5)\n    notifs = [notif.state for notif in notifs]\n    for notif in notifs:\n        print(notif.decode())\n```", "```py\n{\"timestamp\":{\"_type_\":\"datetime_iso\",\"_data_\":\"2024-03-18T08:05:10.583875+00:00\"},\"originator_topic\":\"__main__:InventoryItem\",\"name\":\"Laptop\",\"quantity\":10}\n{\"timestamp\":{\"_type_\":\"datetime_iso\",\"_data_\":\"2024-03-18T08:05:10.584818+00:00\"},\"amount\":5}\neventsourcing library, which makes it easier to implement this type of application.\n\t\t\tOther architectural design patterns\n\t\t\tYou may encounter documentation about other architectural design patterns. Here are three other patterns:\n\n\t\t\t\t*   **Event-Driven Architecture (EDA)**: This pattern emphasizes the production, detection, consumption of, and reaction to events. EDA is highly adaptable and scalable, making it suitable for environments where systems need to react to significant events in real time.\n\t\t\t\t*   **Command Query Responsibility Segregation (CQRS)**: This pattern separates the models for reading and writing data, allowing for more scalable and maintainable architectures, especially when there are clear distinctions between operations that mutate data and those that only read data.\n\t\t\t\t*   **Clean Architecture**: This pattern proposes a way to organize code such that it encapsulates the business logic but keeps it separate from the interfaces through which the application is exposed to users or other systems. It emphasizes the use of dependency inversion to drive the decoupling of software components.\n\n\t\t\tSummary\n\t\t\tIn this chapter, we explored several foundational architectural design patterns that are pivotal in modern software development, each useful for different requirements and solving unique challenges.\n\t\t\tWe first covered the MVC pattern, which promotes the separation of concerns by dividing the application into three interconnected components. This separation allows for more manageable, scalable, and testable code by isolating the UI, the data, and the logic that connects the two.\n\t\t\tThen, we looked at the Microservices pattern, which takes a different approach by structuring an application as a collection of small, independent services, each responsible for a specific business function. This pattern enhances scalability, flexibility, and ease of deployment, making it an ideal choice for complex, evolving applications that need to rapidly adapt to changing business requirements.\n\t\t\tNext, we looked at the Serverless pattern, which shifts the focus from server management to pure business logic by leveraging cloud services to execute code snippets in response to events. This pattern offers significant cost savings, scalability, and productivity benefits by abstracting the underlying infrastructure, allowing developers to concentrate on writing code that adds direct value.\n\t\t\tAfterward, we went over the Event Sourcing pattern, which offers another way to handle data changes in an application by storing each change as a sequence of events. This not only provides a robust audit trail and enables complex business functionalities but also allows the system to reconstruct past states, offering invaluable insights into the data life cycle and changes over time.\n\t\t\tLastly, we touched upon other architectural design patterns, such as CQRS and Clean Architecture. Each offers unique advantages and addresses different aspects of software design and architecture. Even if we could not dive deep into these patterns, they complement the developer’s toolkit for building well-structured and maintainable systems.\n\t\t\tIn the next chapter, we will discuss concurrency and asynchronous patterns and techniques to help our program manage multiple operations simultaneously or move on to other tasks while waiting for operations to complete.\n\n```", "```py\n\n```", "```py\n\n```", "```py\n\n```", "```py\n\n```"]