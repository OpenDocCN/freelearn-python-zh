- en: '*Chapter 6:* Working with Data – Variables'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第6章：处理数据 – 变量*'
- en: In previous chapters, we stated that a program is something that takes data
    as input and performs operations on it to produce new data. So, handling data
    is crucial in any application, regardless of whether it is used for accounting
    or whether it is a game.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们提到程序是某种接受数据作为输入并在其上执行操作以产生新数据的东西。因此，处理数据在任何应用程序中都是至关重要的，无论它是用于会计还是游戏。
- en: When we work with data, it must be stored in the computer's memory, and this
    is done with **variables**. It is variables that let us store and retrieve data.
    In this chapter, we will get to know variables, see how they work, and, in the
    end, look at some operations that we can perform on them.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们处理数据时，它必须存储在计算机的内存中，这是通过**变量**来实现的。是变量让我们能够存储和检索数据。在本章中，我们将了解变量，了解它们的工作原理，最后看看我们可以对它们执行的一些操作。
- en: 'In this chapter, you will learn about the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习以下内容：
- en: Declaring and initializing variables
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明和初始化变量
- en: Understanding data types and applying them to variables
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解数据类型并将它们应用于变量
- en: Using composite types to handle multiple values
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用复合类型处理多个值
- en: Performing operations on variables using operators
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用运算符对变量进行操作
- en: Operating on numbers and manipulating strings
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对数字进行操作和字符串操作
- en: When programming, we need to work with data, and that data will be stored in
    the computer's memory. To be able to use this data, we need to have a way to reference
    where in the memory the data is. This is done by using a nice abstraction called
    variables. Variables hide the difficult stuff, such as working with memory addresses,
    and give us easy access to data by letting us assign a name to it. Let's see how
    this works.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在编程时，我们需要处理数据，这些数据将被存储在计算机的内存中。为了能够使用这些数据，我们需要有一种方式来引用数据在内存中的位置。这是通过使用一个称为变量的美好抽象来实现的。变量隐藏了困难的部分，比如处理内存地址，并允许我们通过给它命名来轻松访问数据。让我们看看它是如何工作的。
- en: Declaring and initializing variables
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明和初始化变量
- en: When writing programs, we continuously work with data. As we are using this
    data, we need a way to keep track of it. To do this, we use variables. Let's look
    at how this works in the following sections.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写程序时，我们持续与数据打交道。当我们使用这些数据时，我们需要一种方式来跟踪它们。为此，我们使用变量。让我们在以下部分看看它是如何工作的。
- en: Understanding variables
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解变量
- en: 'To understand what a variable is, we can start with some code where we assign
    a value to a variable:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解变量是什么，我们可以从一些代码开始，其中我们将一个值赋给一个变量：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, we have the value `13`, which is a whole number. Usually, in programming,
    we refer to these as integers as they can be both positive and negative. Different
    programming languages treat integer values differently. Most languages will specify
    how much memory an integer will use. Let's assume that this size is 4 bytes, which
    is a common size used to store an integer value. Remember that one byte is 8 bits
    and that each bit can be either `0` or `1`. With 4 bytes, we have 4 times 8 bits,
    which is 32 zeros or ones, at our disposal.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个值`13`，它是一个整数。通常，在编程中，我们把这些称为整数，因为它们可以是正数也可以是负数。不同的编程语言对整数值的处理方式不同。大多数语言都会指定整数将使用多少内存。让我们假设这个大小是4字节，这是存储整数值常用的一个大小。记住，一个字节是8位，每一位可以是`0`或`1`。有4个字节，我们就有4乘以8位，即32个零或一，可供我们使用。
- en: To store `13` in the computer's memory, the programming language will need to
    reserve enough space—4 bytes, in our case.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要在计算机内存中存储`13`，编程语言需要预留足够的空间——在我们的例子中是4字节。
- en: 'Each byte of computer memory has an address. A memory address works like a
    street address; it is used to help us navigate to the correct location:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机内存的每个字节都有一个地址。内存地址就像一个街道地址；它被用来帮助我们导航到正确的位置：
- en: '![Figure 6.1 – Part of the computer''s memory. Each square is a byte and has
    a unique address](img/B15554_06_01.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图6.1 – 计算机内存的一部分。每个方块是一个字节，并且有一个唯一的地址](img/B15554_06_01.jpg)'
- en: Figure 6.1 – Part of the computer's memory. Each square is a byte and has a
    unique address
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1 – 计算机内存的一部分。每个方块是一个字节，并且有一个唯一的地址
- en: In our example, 4 bytes that are not occupied by something else need to be located.
    These bytes need to be in continuous order.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，需要找到4个没有被其他东西占用的字节。这些字节需要连续排列。
- en: 'The address of the first byte in this sequence is of interest to us. The programming
    language knows that we are storing an integer value at this location, and it knows
    how many bytes an integer occupies, so the first address is enough to locate this
    integer. The following diagram shows this:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这个序列中第一个字节的地址对我们来说很有意义。编程语言知道我们在该位置存储了一个整数值，并且它知道一个整型数据需要多少字节，所以第一个地址就足够定位这个整型数据。下面的图展示了这一点：
- en: '![](img/B15554_06_02.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15554_06_02.jpg)'
- en: Figure 6.2 – The programming language reserves enough space in memory for an
    integer value to be stored
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2 – 编程语言在内存中为整型值存储预留了足够的空间
- en: 'When writing a program, we don''t want to remember numeric memory addresses,
    so we give this memory address a name. It is up to us, as programmers, to come
    up with this name, and we should pick a name that describes the data that we are
    storing. We will talk more about what considerations we need to make when naming
    variables soon:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当编写程序时，我们不想记住数字内存地址，所以我们给这个内存地址起一个名字。作为程序员，这是我们的责任，我们应该选择一个能够描述我们存储的数据的名称。我们很快就会讨论在命名变量时需要考虑的因素：
- en: '![Figure 6.3 – The first address in the reserved sequence is given a name—in
    this case, x](img/B15554_06_03.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图6.3 – 保留序列中的第一个地址被赋予了一个名称——在这个例子中，是x](img/B15554_06_03.jpg)'
- en: Figure 6.3 – The first address in the reserved sequence is given a name—in this
    case, x
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3 – 保留序列中的第一个地址被赋予了一个名称——在这个例子中，是x
- en: 'Now that we have enough room for the reserved integer value and a name that
    can be used to refer to this memory address, the actual value can be stored at
    this memory location. This value will be stored in binary format. We talked about
    binary numbers in [*Chapter 1*](B15554_01_Final_NM_ePub.xhtml#_idTextAnchor016),
    *Introduction to Computer Programs*. In the preceding code snippet, we wanted
    to save the value `13`, and `13` in binary is `1101`. All of the bits preceding
    this value are filled with zeros. As you can see in the following diagram, one
    byte would have been enough, but as many languages have a fixed size for its integer
    type, all the bytes will be reserved, regardless of whether we need them:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有足够的空间来存储保留的整数值和一个可以用来引用这个内存地址的名称，实际的值可以存储在这个内存位置。这个值将以二进制格式存储。我们曾在[*第一章*](B15554_01_Final_NM_ePub.xhtml#_idTextAnchor016)，“计算机程序简介”中讨论过二进制数。在先前的代码片段中，我们想要保存的值是`13`，而`13`的二进制表示是`1101`。这个值之前的所有位都填充了零。正如你在下面的图中可以看到，一个字节就足够了，但许多语言为其整型数据类型设定了固定的大小，所以无论我们是否需要，所有的字节都将被保留：
- en: '![Figure 6.4 – The binary representation of the value we want to be stored
    is inserted at this memory location](img/B15554_06_04.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图6.4 – 我们想要存储的值的二进制表示被插入到这个内存位置](img/B15554_06_04.jpg)'
- en: Figure 6.4 – The binary representation of the value we want to be stored is
    inserted at this memory location
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4 – 我们想要存储的值的二进制表示被插入到这个内存位置
- en: Now, the value is stored in memory and we have a name that refers to this location.
    We can use this name to access this value.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，值已经存储在内存中，我们有一个指向这个位置的名称。我们可以使用这个名称来访问这个值。
- en: We call `x` in our example a variable. A variable consists of several things.
    It has a name, which is `x` in our sample. It also has a type. The type defines
    how much memory the data needs. We wanted to store an integer and we assumed that
    the language we are using has decided to use 4 bytes for integers. This is the
    size of this variable. We also know that if an integer has a fixed size, there
    is a maximum value that it can store. Later in this chapter, we will talk about
    this limitation.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们称`x`为变量。一个变量由几个部分组成。它有一个名称，在我们的示例中是`x`。它还有一个类型。类型定义了数据需要多少内存。我们想要存储一个整型，我们假设我们使用的语言已经决定为整型使用4个字节。这是这个变量的大小。我们还知道，如果一个整型有固定的大小，它能够存储的最大值是有限的。在本章的后面部分，我们将讨论这个限制。
- en: We also need to explore how we can name our variables and what types they can
    have. Let's start with the names.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要探索如何命名我们的变量以及它们可以有哪些类型。让我们从名称开始。
- en: Naming variables
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 变量命名
- en: The name we give a variable should reflect what data it represents, so if we
    use a variable to store an email address, a good name would be `email`, whereas
    `b45` would be rather lousy.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们给变量取的名字应该反映它所代表的数据，所以如果我们用一个变量来存储电子邮件地址，一个好的名字会是`email`，而`b45`则不太合适。
- en: 'The syntax of each language has rules for how we can name our variables. Some
    standard rules for naming variables are as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 每种语言的语法都有关于如何命名变量的规则。以下是一些命名变量的标准规则：
- en: It must begin with a letter of the alphabet or an underscore (`_`).
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它必须以字母表中的字母或下划线（`_`）开头。
- en: After the first character, the name can contain letters, underscores, and numbers.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第一个字符之后，名称可以包含字母、下划线和数字。
- en: You cannot use names that are used as keywords in the language—that is, words
    that are reserved by the language, such as `for`, `if`, and `else`.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不能使用语言中用作关键字的名字——也就是说，被语言保留的单词，如`for`、`if`和`else`。
- en: Spaces or other special characters, such as `+`, `-`, and `*`, are not allowed
    to be part of the name.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空格或其他特殊字符，如`+`、`-`和`*`，不允许作为名称的一部分。
- en: 'Some examples of legal and illegal names are as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 一些合法和不合法名称的示例如下：
- en: '![Table 6.1](img/B15554_Table_6.1.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![表6.1](img/B15554_Table_6.1.jpg)'
- en: Table 6.1
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 表6.1
- en: Many languages are also case sensitive when it comes to variable names. What
    that means is that the `name`, `Name`, and `nAmE` variables will be treated as
    three different variables.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 许多语言在变量名方面也是大小写敏感的。这意味着`name`、`Name`和`nAmE`变量将被视为三个不同的变量。
- en: Many languages will also have what is known as naming conventions when it comes
    to how we construct and format variable names. There are also conventions for
    how to create names that are made up of more than one word. We will study these
    conventions next.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到如何构造和格式化变量名时，许多语言也会有什么被称为命名约定。还有关于如何创建由多个单词组成的名称的约定。我们将在下一节研究这些约定。
- en: Camel case
  id: totrans-45
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 驼峰命名法
- en: 'Camel case is where the words that make up a name are separated by an uppercase
    letter that starts each word. There are two sub-types—**upper camel case** (also
    known as **Pascal case**) and **lower camel case** (also known as **Dromedary
    case**). Some examples of variable names using upper camel case are as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 驼峰命名法是指组成名称的单词之间由一个首字母大写的字母分隔。有两种子类型——**大驼峰命名法**（也称为**帕斯卡命名法**）和**小驼峰命名法**（也称为**骆驼命名法**）。以下是一些使用大驼峰命名法的变量名示例：
- en: '`FirstName`'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FirstName`'
- en: '`EmailAddress`'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EmailAddress`'
- en: '`ZipCode`'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ZipCode`'
- en: 'The same names would look like this in lower camel case:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的名字在驼峰命名法中会看起来像这样：
- en: '`firstName`'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`firstName`'
- en: '`emailAddress`'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`emailAddress`'
- en: '`zipCode`'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`zipCode`'
- en: As we can see, the first variant capitalizes all of the first letters of the
    words that make up a name, whereas the second variant leaves the first word in
    lowercase and only uses uppercase with the second word's first letter.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，第一个变体将组成名称的单词的第一个字母全部大写，而第二个变体将第一个单词保持小写，并且只使用第二个单词的第一个字母大写。
- en: Languages that recommend this naming convention are Java, C#, and Pascal.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 推荐使用这种命名约定的语言包括Java、C#和Pascal。
- en: Snake case
  id: totrans-56
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 蛇形命名法
- en: 'Separating words with an underscore is called snake case. When using this convention,
    we only use lowercase letters and separate words with an underscore character.
    Using this casing for the same variable names as the preceding examples would
    look like this:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 使用下划线分隔单词称为蛇形命名法。当使用这种约定时，我们只使用小写字母，并用下划线字符分隔单词。使用这种格式与前面示例相同的变量名将看起来如下：
- en: '`first_name`'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`first_name`'
- en: '`email_address`'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`email_address`'
- en: '`zip_code`'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`zip_code`'
- en: Languages that use this convention for naming variables include Python, Ruby,
    C, and C++, in some circumstances.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种命名约定为变量命名的语言包括Python、Ruby、C和C++，在某些情况下。
- en: What does it mean when we say a language has a convention for naming variables?
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们说一种语言有变量命名约定时，这意味着什么？
- en: Naming conventions
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命名约定
- en: Usually, a naming convention is a recommended way for naming things, such as
    variables. This means that we can break these rules and the program will still
    work. However, there are several good reasons for us to obey these recommendations.
    One could be that if many programmers are involved in writing some code, the style
    will be consistent and, therefore, more straightforward to interpret for human
    readers.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，命名约定是命名事物（如变量）的推荐方式。这意味着我们可以打破这些规则，程序仍然可以工作。然而，我们有几个很好的理由去遵守这些建议。其中一个可能是，如果许多程序员参与编写一些代码，风格将是一致的，因此对于人类读者来说更容易理解。
- en: Some software companies have their own naming conventions. This is typically
    the case when the language itself has a weak or non-existing convention.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 一些软件公司有自己的命名约定。这通常是在语言本身没有或存在较弱约定的情况下。
- en: When coming across a new language, we should always learn its conventions. If
    you work on several projects that use different programming languages, it can
    be tricky to remember what convention to use.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当遇到一种新的语言时，我们应该始终学习其约定。如果你在多个使用不同编程语言的项目上工作，记住使用哪种约定可能会很棘手。
- en: Read more about naming conventions in [*Chapter 12*](B15554_12_Final_NM_ePub.xhtml#_idTextAnchor186),
    *Code Quality* in the *Using code conventions* section.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第12章*](B15554_12_Final_NM_ePub.xhtml#_idTextAnchor186)中了解更多关于命名约定的信息，*代码质量*在*使用代码约定*部分。
- en: Now that we know how to name a variable, let's explore the different types that
    a variable can have.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何命名一个变量，让我们探索变量可以具有的不同类型。
- en: Primitive data types
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原始数据类型
- en: Every variable has both a name and a type. The type defines what kind of data
    can be stored in the variable. Typically, a language will have some built-in types,
    called primitive or basic types, to handle a single value.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 每个变量都有一个名称和一个类型。类型定义了可以在变量中存储的数据类型。通常，一种语言将有一些内置类型，称为原始类型或基本类型，用于处理单个值。
- en: Primitive types can be divided into two categories—Boolean and numeric—which
    we will look at next.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 原始类型可以分为两大类——布尔型和数值型，我们将在下一节中探讨。
- en: Boolean type
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 布尔类型
- en: In [*Chapter 1*](B15554_01_Final_NM_ePub.xhtml#_idTextAnchor016)*, Introduction
    to Computer Programs*, we talked about George Bool and his Boolean algebra. This
    defined how we can combine values of `true` and `false` with `and`, `or`, and
    `not`. To be able to use these values in our programs, we have a type that is
    named after Bool, called Boolean. A variable that uses this type can only have
    one of two values—`true` or `false`. For languages that have these types, we use
    the actual `true` and `false` words.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第1章*](B15554_01_Final_NM_ePub.xhtml#_idTextAnchor016)中，我们讨论了乔治·布尔和他的布尔代数。这定义了我们可以如何使用`and`、`or`和`not`将`true`和`false`的值组合起来。为了能够在我们的程序中使用这些值，我们有一个以布尔命名的类型，称为布尔型。使用这种类型的变量只能有两个值之一——`true`或`false`。对于具有这些类型的语言，我们使用实际的`true`和`false`单词。
- en: Languages that have this type either call it `Boolean` or just `bool`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 具有这种类型的语言要么称之为`Boolean`，要么简单地称之为`bool`。
- en: Numeric type
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数值类型
- en: Numeric types fall into one of two categories—integer types and floating-point
    types. We will look at them in detail, next.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 数值类型可以分为两类——整数类型和浮点类型。我们将在下一节中详细探讨。
- en: Integer data types
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 整数数据类型
- en: The first question you could ask yourself here is why are we talking about types
    in plural when it comes to integers? You could argue that data is either an integer
    or not. As it turns out, many languages will have several types for representing
    integer values and the reason for this has to do with how much memory is used
    for the data and how that data should be interpreted.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你在这里可以问自己的第一个问题是，为什么当我们谈到整数时，我们会用复数来谈论类型？你可以争辩说数据要么是整数，要么不是。实际上，许多语言将会有几种类型来表示整数值，而原因与数据使用的内存量以及如何解释这些数据有关。
- en: As we saw earlier in this chapter, a language will define how much memory to
    use when storing data in a variable. When working with integers, we might only
    work with small values in a predefined range, such as the age of a human, or the
    values might be huge, such as the distance between stars.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章前面所述，一种语言将定义在变量中存储数据时使用多少内存。当处理整数时，我们可能只处理预定义范围内的较小值，例如人类的年龄，或者值可能非常大，例如恒星之间的距离。
- en: If we think about the characteristics of the data we are working with, we will
    discover that it has natural limitations. The age of a human, for example, will
    never have a negative value, and if we take the highest human age recorded (122
    years, at the time of writing) and add some years to be on the safe side, we could
    state that a valid human age will fall into the range of 0 to 150\. One byte—remember
    that one byte is 8 bits (8 zeros or ones)—can work with numbers in the range 0
    to 255, so that is more than enough to store human age.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们考虑我们正在处理的数据的特征，我们会发现它有自然限制。例如，人类的年龄永远不会是负数，如果我们考虑记录的最高人类年龄（写作时为122岁）并添加一些年份以确保安全，我们可以声明有效的人类年龄将落在0到150的范围内。一个字节——记住一个字节是8位（8个零或一）——可以处理0到255范围内的数字，所以这已经足够存储人类年龄了。
- en: If we instead talk about the distance between us and other stars, we have a
    different range of values. The closest star, except for our own sun, are the two
    stars in the Alpha Centauri system. They are just over 4 lightyears away. The
    furthest star that we have observed, known by the name MACS J1149+2223 Lensed
    Star 1, is 9 billion lightyears away. So, if we are working with these values,
    we still would not need any negative numbers and the range would be between 4
    and 9,000,000,000.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们谈论我们与其他恒星之间的距离，我们会有一个不同的数值范围。除了我们自己的太阳之外，最近的两颗恒星是半人马座阿尔法星系中的两颗恒星。它们距离我们刚好超过4光年。我们观测到的最远的恒星，名为MACS
    J1149+2223透镜星1，距离我们900亿光年。因此，如果我们使用这些值，我们仍然不需要任何负数，范围将在4到900,000,000之间。
- en: Sometimes, we need to work with both negative and positive numbers—for example,
    if we are writing some accounting software.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，我们需要同时处理正数和负数——例如，如果我们正在编写一些会计软件。
- en: This means that integer values can have different properties, and for that reason,
    we have more than one integer type so that we can find one that fits our needs.
    As we don't need any negative numbers and the maximum won't ever exceed 150 as
    a value for human age, a type that can work with huge or negative numbers would
    be a waste of the computer's memory.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着整数值可以有不同的属性，因此我们有多于一种的整数类型，这样我们就可以找到一个适合我们需求的类型。由于我们不需要任何负数，并且最大值永远不会超过150（作为人类年龄的值），一个可以处理巨大或负数的类型将是计算机内存的浪费。
- en: With this knowledge, programming languages are often implemented with several
    different integer types that differ in how much memory (measured in bytes) they
    will use to represent a value. The programmer's task is to pick one that matches
    the properties for the data that will be handled by the variable that has this
    type.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这些知识，编程语言通常会实现几种不同的整数类型，它们在表示值时使用的内存（以字节为单位）不同。程序员的任务是选择一个与变量将处理的数据属性相匹配的类型。
- en: 'Different languages will have a different set of integer types, but here are
    some typical integer types, their sizes, and the range of values that they can
    handle:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的语言将会有不同的整数类型集，但这里有一些典型的整数类型、它们的尺寸以及它们可以处理的值范围：
- en: '![Table 6.2](img/B15554_Table_6.2.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![表6.2](img/B15554_Table_6.2.jpg)'
- en: Table 6.2
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 表6.2
- en: As you can see, all the preceding types include negative as well as positive
    values. Representing both will limit how a type can serve large numbers. Taking
    human age as an example again, we will see that the byte type wouldn't really
    work as although it has a maximum value of 127, it has 128 negative values that
    we would never use.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，所有前面的类型都包括负数和正数。同时表示两者将限制类型服务大数的能力。再次以人类年龄为例，我们会看到字节类型实际上并不适用，尽管它的最大值是127，但它有128个我们永远不会使用的负值。
- en: The reason why we have this restriction has to do with how negative numbers
    are represented.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有这种限制的原因与负数的表示方式有关。
- en: Signed and unsigned integers
  id: totrans-90
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 有符号和无符号整数
- en: If we look at the smallest type in the preceding table—the byte—and think about
    how negative numbers can be represented, we will see that we have a problem. When
    working with binary numbers, we have several bits that can store either `0` or
    `1`, but we don't have any other values, so we can't just insert a minus sign
    to indicate that this is a negative number. Instead, one of the following three
    methods can be used.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看前表中最小的类型——字节——并思考如何表示负数，我们会发现一个问题。在处理二进制数时，我们有几个位可以存储`0`或`1`，但我们没有其他值，所以我们不能简单地插入一个负号来表示这是一个负数。相反，可以使用以下三种方法之一。
- en: Let's see how they work.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看它们是如何工作的。
- en: Signed Magnitude Representation (SMR)
  id: totrans-93
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 有符号位表示法（SMR）
- en: 'Even if the name is a bit complicated, this is the easiest way to represent
    negative values in binary form. Imagine that we are working with one byte that
    gives us eight bits to represent a value. However, if we assign one of the bits
    to represent whether this is a positive or negative value, we are left with just
    seven bits for the actual value:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 即使名字有点复杂，这是在二进制形式中表示负值的最简单方法。想象一下，我们正在使用一个字节，它给我们8位来表示一个值。然而，如果我们将其中一位用于表示这是一个正数还是负数，我们就只剩下7位来表示实际值：
- en: '![Figure 6.5 – A byte using only 7 bits to represent a value—127, in this case](img/B15554_06_05.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图6.5 – 使用仅7位表示值的字节——在这个例子中是127](img/B15554_06_05.jpg)'
- en: Figure 6.5 – A byte using only 7 bits to represent a value—127, in this case
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.5 – 使用仅7位表示值的字节——在这个例子中是127
- en: 'If we use the bit to the left in the preceding diagram—often referred to as
    the most significant bit as it is the bit representing the highest value—to represent
    whether the rest should be considered either positive or negative, the rest of
    the bits can form a maximum value of `127`:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用前面图中的最左边的位——通常被称为最高位，因为它代表的是最高值——来表示其余部分应该被视为正数还是负数，其余的位可以形成一个最大值为 `127`
    的值：
- en: '![Figure 6.6 – Using the most significant bit to represent a positive value—29,
    in this case](img/B15554_06_06.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图6.6 – 使用最高位来表示正值—29，在这种情况下](img/B15554_06_06.jpg)'
- en: Figure 6.6 – Using the most significant bit to represent a positive value—29,
    in this case
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.6 – 使用最高位来表示正值—29，在这种情况下
- en: 'If we designate the first position to indicate whether this is a positive or
    a negative value, we can use `0` to show that this is a positive value and `1`
    to show that this is a negative one:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们指定第一个位置来表示这是一个正数还是负数，我们可以用 `0` 来表示这是一个正数，用 `1` 来表示这是一个负数：
- en: '![Figure 6.7 – Using the most significant bit to represent a negative value,
    -29, in this case](img/B15554_06_07.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![图6.7 – 使用最高位来表示负值-29](img/B15554_06_07.jpg)'
- en: Figure 6.7 – Using the most significant bit to represent a negative value, -29,
    in this case
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.7 – 使用最高位来表示负值，-29，在这种情况下
- en: Using this technique, we have a range of values from `-127` to `127` using a
    single byte. We will also have two representations for 0—positive and negative.
    This is one disadvantage of this method and a reason why it is not used so often.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种技术，我们可以用一个字节表示从 `-127` 到 `127` 的值范围。我们还将有0的两种表示——正的和负的。这是这种方法的一个缺点，也是它不常被使用的原因。
- en: Another problem with this technique is found when performing mathematical operations,
    such as addition, on two values that use SMR.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术的一个问题出现在对使用SMR的两个值执行数学运算，如加法时。
- en: '*Figures 6.8 to 6.12* illustrate what happens if we add `3` and `c` together
    if we have used SMR to represent a negative value. To understand the diagrams,
    imagine that you add two decimal numbers. If you want to add `495` and `572`,
    we will put one above the other and start to add them column by column:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6.8至6.12*展示了如果我们使用SMR来表示一个负数，将 `3` 和 `c` 相加会发生什么。为了理解这些图表，想象一下你加两个十进制数。如果你想加
    `495` 和 `572`，我们将它们一个放在另一个上面，并开始逐列相加：'
- en: '![](img/B15554_06_31.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15554_06_31.jpg)'
- en: 'We then do the same for the next column, but as we get a value larger than
    `9`, we have to carry:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们对下一列做同样的处理，但是当我们得到一个大于 `9` 的值时，我们必须进行进位：
- en: '![](img/B15554_06_32.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15554_06_32.jpg)'
- en: 'When adding the last column, we use the carried number as part of the numbers
    we add:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当加到最后一个列时，我们将进位数作为我们加的数字的一部分：
- en: '![](img/B15554_06_33.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B15554_06_33.jpg)'
- en: We can apply the same principle for adding binary numbers. The only difference
    is that we now work with just two digits. So, instead of `10`, we will need to
    carry a value as soon as the result is greater than 1\. Now, when adding two bits
    that can be either `0` or `1`, we only end up with three different results—0,
    1, or 2 (in decimal). If we consider that we need to add two values and one potential
    carried value, the maximum will be 1 + 1 + 1 = `3`. Now that we know the maximum
    value we can possibly get (3), we can translate it into binary. `3` in binary
    is `11`. This means that our possible results will be 0, 1, 10, and 11\. 0 and
    1 fit within a single bit, but `10` and `11` do not, so here, we will need to
    carry 1.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将同样的原则应用于二进制数的加法。唯一的区别是我们现在只处理两个数字。所以，当结果大于 `1` 时，我们只需要一秒钟就可以进位。现在，当我们加两个可以是
    `0` 或 `1` 的位时，我们最终只会得到三种不同的结果——0、1或2（十进制）。如果我们考虑我们需要加两个值和一个可能的进位值，最大值将是 1 + 1
    + 1 = `3`。现在我们知道我们可以得到的最大值（3），我们可以将其转换为二进制。`3` 的二进制是 `11`。这意味着我们的可能结果将是 0、1、10
    和 11。0 和 1 可以在一个位内表示，但 `10` 和 `11` 不能，所以在这里，我们需要进位 1。
- en: 'As guidance, let''s use a table to convert between decimal and binary values:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 作为指导，让我们用一个表格来在十进制和二进制值之间进行转换：
- en: '![Table 6.3](img/B15554_Table_6.3.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![表6.3](img/B15554_Table_6.3.jpg)'
- en: Table 6.3
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 表6.3
- en: 'Let''s also see another table that helps us understand how binary addition
    works:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再看看另一个表格，它有助于我们理解二进制加法是如何工作的：
- en: '![Table 6.4](img/B15554_Table_6.4.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![表6.4](img/B15554_Table_6.4.jpg)'
- en: Table 6.4
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 表6.4
- en: As you can see, the last three operations resulted in two digits, so all of
    them will result in a carry.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，最后三个操作的结果是两位数，所以所有这些都会产生进位。
- en: 'Let''s see how we can apply this principle when adding binary numbers:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何将这个原则应用于二进制数的加法：
- en: '![Figure 6.8 – Adding two values, 3 and -3, where the negative number is represented
    using SMR](img/B15554_06_08.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![图6.8 – 加两个值，3和-3，其中负数使用SMR表示](img/B15554_06_08.jpg)'
- en: Figure 6.8 – Adding two values, 3 and -3, where the negative number is represented
    using SMR
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.8 – 加两个值，3和-3，其中负数使用SMR表示
- en: 'When we want to add two binary numbers, we do the same thing that we did with
    decimal numbers. The only difference is that we can only handle results that are
    0 or 1\. If the result is 2, we need to carry 1 to the next position:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要加两个二进制数时，我们做的是与十进制数相同的事情。唯一的区别是我们只能处理结果为0或1的情况。如果结果是2，我们需要将1进位到下一个位置：
- en: '![Figure 6.9 – Step one is to add the two rightmost bits—1 + 1 = 2](img/B15554_06_09.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![图6.9 – 第一步是加上两个最右边的位—1 + 1 = 2](img/B15554_06_09.jpg)'
- en: Figure 6.9 – Step one is to add the two rightmost bits—1 + 1 = 2
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.9 – 第一步是加上两个最右边的位—1 + 1 = 2
- en: From the preceding diagram, we can see that as 2 in binary is 10, we insert
    0 at this location and carry 1.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的图中，我们可以看到，因为二进制中的2是10，我们在这一位置插入0并进位1。
- en: 'This means that in the next step, we have three values—1 + 1 + 1\. As the result
    will be 3, which is 11 in binary, we insert a 1 in this position and carry 1 to
    the next round:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着在下一步，我们有三个值—1 + 1 + 1。因为结果将是3，二进制表示为11，我们在这一位置插入1并将1进位到下一轮：
- en: '![Figure 6.10 – Repeating the operation for the next two bits](img/B15554_06_10.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![图6.10 – 对下两个位重复操作](img/B15554_06_10.jpg)'
- en: Figure 6.10 – Repeating the operation for the next two bits
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.10 – 对下两个位重复操作
- en: 'In this example, we now have several positions where we add zeros together,
    but we must remember that we have carried 1 the first time:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们现在有几个位置是加零，但我们必须记住我们第一次已经进位了1：
- en: '![Figure 6.11 – For the third pair of bits, we are adding two zeros with the
    carry](img/B15554_06_11.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![图6.11 – 对于第三对位，我们在加两个零的同时带有进位](img/B15554_06_11.jpg)'
- en: Figure 6.11 – For the third pair of bits, we are adding two zeros with the carry
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.11 – 对于第三对位，我们在加两个零的同时带有进位
- en: 'We can now repeat this all the way to the last position. This is our sign bit:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以一直重复这个过程到最末位。这是我们符号位：
- en: '![Figure 6.12 – The next four bits are just zeros with no carry, so they will
    all result in zeros](img/B15554_06_12.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![图6.12 – 接下来的四个位都是零，没有进位，所以它们都将产生零](img/B15554_06_12.jpg)'
- en: Figure 6.12 – The next four bits are just zeros with no carry, so they will
    all result in zeros
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.12 – 接下来的四个位都是零，没有进位，所以它们都将产生零
- en: 'As we are adding a positive value (3) with a negative value (-3), we have `0`
    at this position for the first value and `1` in the second to indicate that the
    value is negative. As 0 + 1 is 1, this indicates that the result is negative:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在加一个正数（3）和一个负数（-3），在这个位置上第一个值是`0`，第二个值是`1`以表示该值是负数。因为0 + 1是1，这表明结果是负数：
- en: '![Figure 6.12 – When we add the bit used as a sign bit, the result will be
    1, indicating that the result is negative](img/B15554_06_13.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![图6.12 – 当我们加用作符号位的位时，结果将是1，表示结果是负数](img/B15554_06_13.jpg)'
- en: Figure 6.12 – When we add the bit used as a sign bit, the result will be 1,
    indicating that the result is negative
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.12 – 当我们加用作符号位的位时，结果将是1，表示结果是负数
- en: To our surprise, we discover that the result of adding 3 and -3 is not 0 as
    we expected but -6, as we have 4 plus 2, which is 6, and 1 at the first position,
    indicating that this is a negative number.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 令我们惊讶的是，我们发现3和-3相加的结果不是我们预期的0，而是-6，因为我们有4加上2等于6，第一个位置是1，表示这是一个负数。
- en: This is another reason why this method is not used that often.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是为什么这种方法不常被使用的原因之一。
- en: Ones' complement
  id: totrans-140
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 反码
- en: Another approach to representing negative numbers that will address the problem
    we saw when we tried to add a positive and a negative value is the use of something
    called ones' complement. It also uses the most significant bit (the leftmost bit
    in our illustrations) as the sign bit but stores negative numbers differently
    compared to SMR.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种表示负数的方法是使用所谓的“反码”，它也使用最高有效位（在我们的插图中最左边的位）作为符号位，但与SMR不同地存储负数。
- en: 'If we have a positive value, we can use 3 again as an example, and if we store
    it in a byte, we get 0000 0011, as we can see here:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一个正数，我们可以用3作为例子，如果我们将其存储在一个字节中，我们得到0000 0011，正如我们在这里看到的：
- en: '![Figure 6.13 – Storing positive 3 in a byte](img/B15554_06_14.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图6.13 – 在字节中存储正数3](img/B15554_06_14.jpg)'
- en: Figure 6.13 – Storing positive 3 in a byte
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.13 – 在字节中存储正数3
- en: 'To store -3, we flip all the bits, so 0 becomes 1 and vice versa, as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 要存储-3，我们需要翻转所有位，所以0变成1，反之亦然，如下所示：
- en: '![Figure 6.14 – Storing -3 using ones'' complement. All values are the opposite
    of when we store positive 3](img/B15554_06_15.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![图6.14 – 使用补码存储-3。所有值都与存储正3时的值相反](img/B15554_06_15.jpg)'
- en: Figure 6.14 – Storing -3 using ones' complement. All values are the opposite
    of when we store positive 3
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.14 – 使用补码存储-3。所有值都与存储正3时的值相反
- en: 'As we can see, all the bits are the opposite compared to when we stored a positive
    3\. When this number is interpreted, the sign bit is checked first. If it is 1,
    all the other bits are then flipped to form the actual value. This might seem
    like a strange thing to do, but let''s see what happens when we add the two together:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，所有位与存储正3时的位相反。当这个数字被解释时，首先检查符号位。如果是1，则将所有其他位翻转以形成实际值。这看起来可能有些奇怪，但让我们看看当我们把两个数相加会发生什么：
- en: '![Figure 6.15 – Adding 3 and -3 where the negative number is represented using
    ones'' complement](img/B15554_06_16.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![图6.15 – 使用补码表示的负数相加3和-3](img/B15554_06_16.jpg)'
- en: Figure 6.15 – Adding 3 and -3 where the negative number is represented using
    ones' complement
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.15 – 使用补码表示的负数相加3和-3
- en: 'As we can see in the preceding diagram, we add 1 and 0 for each location. The
    result will, therefore, be 1 in every position, as we can see here:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，我们对每个位置加1和0。因此，结果将在每个位置上都是1，正如我们在这里看到的：
- en: '![Figure 6.16 – The result of adding the two bytes will be 1 in all locations](img/B15554_06_17.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![图6.16 – 将两个字节相加的结果将在所有位置上为1](img/B15554_06_17.jpg)'
- en: Figure 6.16 – The result of adding the two bytes will be 1 in all locations
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.16 – 将两个字节相加的结果将在所有位置上为1
- en: 'As we have 1 for the signed bit, this means that we have a negative result,
    so all the other bits need to be flipped and the result will be -0\. Now, this
    is better as 3 + (-3) is 0, but negative 0 does not mean anything. This means
    that this method also has the same problem as SMR, where we have two representations
    of the value 0—one positive and one negative:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们有符号位为1，这意味着我们有一个负结果，所以所有其他位都需要翻转，结果将是-0。现在，这更好，因为3 + (-3)等于0，但负0没有意义。这意味着这种方法也和SMR一样有相同的问题，即我们有两个表示值0的方式——一个正数和一个负数：
- en: '![Figure 6.17 – As the sign bit is 1, all the other bits need to be flipped,
    forming negative 0](img/B15554_06_18.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![图6.17 – 由于符号位为1，所有其他位都需要翻转，形成负0](img/B15554_06_18.jpg)'
- en: Figure 6.17 – As the sign bit is 1, all the other bits need to be flipped, forming
    negative 0
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.17 – 由于符号位为1，所有其他位都需要翻转，形成负0
- en: Let's see whether we can tackle this problem and find a representation that
    works.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们是否可以解决这个问题，并找到一个有效的表示方法。
- en: Two's complement
  id: totrans-158
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 补码
- en: To solve the problem of two zeros in ones' complement, a third method for representing
    integer values exists, which is called two's complement. It works in the same
    way as ones' complement but with a twist.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决补码中的两个零问题，存在一种表示整数值的第三种方法，称为补码。它的工作方式与补码相同，但略有不同。
- en: The first step is to use ones' complement to represent a negative number, which
    takes the positive value and flips all the bits. But when that is done, we add
    1 to the result. Now, this might seem like we are messing the result up totally,
    but as we will see, it solves the problem with the double zero representation.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是使用补码来表示一个负数，这需要取正值的位并翻转所有位。但是，当这样做之后，我们向结果中加1。现在，这可能会让人觉得我们完全搞砸了结果，但正如我们将看到的，它解决了双零表示的问题。
- en: 'See *figures 6.18 to 6.21* to see how this works:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅*图6.18至6.21*以了解这是如何工作的：
- en: '![Figure 6.18 – Representing the value 3 in a byte](img/B15554_06_19.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![图6.18 – 在字节中表示值3](img/B15554_06_19.jpg)'
- en: Figure 6.18 – Representing the value 3 in a byte
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.18 – 在字节中表示值3
- en: 'Representing a positive value is done just the same as before. However, when
    dealing with negative numbers, we do things differently:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 正值的表示与之前相同。然而，当处理负数时，我们采取不同的做法：
- en: '![Figure 6.19 – Representing -3 in the two''s complement form](img/B15554_06_20.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![图6.19 – 使用补码形式表示-3](img/B15554_06_20.jpg)'
- en: Figure 6.19 – Representing -3 in the two's complement form
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.19 – 使用补码形式表示-3
- en: 'Here, we take all the bits from the positive representation and flip them,
    so 0 becomes 1 and vice versa:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们从正表示法中取出所有位并翻转它们，所以0变成1，反之亦然：
- en: '![Figure 6.20 – When adding 3 and -3, we do what we did before. 1 + 1 = 10,
    so 0 goes to this position and 1 is carried](img/B15554_06_21.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![图6.20 – 当加上3和-3时，我们做的是之前做过的事情。1 + 1 = 10，所以0移动到这个位置，1被进位](img/B15554_06_21.jpg)'
- en: Figure 6.20 – When adding 3 and -3, we do what we did before. 1 + 1 = 10, so
    0 goes to this position and 1 is carried
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.20 – 当加上3和-3时，我们做的是之前做过的事情。1 + 1 = 10，所以0移动到这个位置，1被进位
- en: 'Adding the bits together is done in the same way as before:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 添加位的方式与之前相同：
- en: '![Figure 6.21 – For all positions, we have 1 carry, so we will add 1 + 1 +
    0 = 10](img/B15554_06_22.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![图6.21 – 对于所有位置，我们都有一个进位，所以我们将1 + 1 + 0 = 10相加](img/B15554_06_22.jpg)'
- en: Figure 6.21 – For all positions, we have 1 carry, so we will add 1 + 1 + 0 =
    10
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.21 – 对于所有位置，我们都有一个进位，所以我们将1 + 1 + 0 = 10相加
- en: When adding the sign bit to the left, we get a carry. The two's complement method
    states that this carry should be discarded.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 当在左边加上符号位时，我们会得到一个进位。二进制补码方法指出，这个进位应该被丢弃。
- en: We can see that the result of this operation is a byte with only zeros, giving
    us a single representation of 0 as a result.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，这个操作的结果是一个只有零的字节，给我们提供了一个0的单个表示。
- en: As two's complement solves both the problem with the binary representation of
    zero and the problem of adding two values together, this is the one that is most
    frequently used.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 由于二进制补码解决了零的二进制表示问题和两个值相加的问题，因此这是最常使用的方法。
- en: Unsigned integers
  id: totrans-176
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 无符号整数
- en: Some languages will let us work with integer types that use all bits as values.
    This allows us to work with only positive integers, but they can, on the other
    hand, be twice as big because we use all the bits to store values.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 一些语言允许我们使用所有位作为值的整型。这使我们能够只处理正整数，但另一方面，它们可以大两倍，因为我们使用所有位来存储值。
- en: Not all numerical values are integers, so let's now look at another group of
    numerical data types—floating-point types.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有数值都是整数，因此现在让我们看看另一组数值数据类型——浮点类型。
- en: Floating-point types
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 浮点类型
- en: 'Representing floating-point numbers using the binary form is tricky, and as
    a programmer, we soon discover some oddities that relate to this. Let''s look
    at the following code:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 使用二进制形式表示浮点数是棘手的，作为程序员，我们很快就会发现一些与这个问题相关的奇怪之处。让我们看看以下代码：
- en: '[PRE1]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We would expect the result stored in the variable result to be `0.3`, but in
    many languages, this will instead be something like `0.30000000000000004`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们预计变量result中存储的结果应该是`0.3`，但在许多语言中，这将是类似`0.30000000000000004`的东西。
- en: The reason we get odd results like this is that we try to represent a decimal
    floating-point number as a binary floating-point number. We will not go into too
    much detail about how floating-point numbers are represented in a computer as
    it will get a bit complicated. If you want to learn how this is done, you can
    search for it online and see lots of detailed explanations for how it works.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到这种奇怪结果的原因是我们试图将十进制浮点数表示为二进制浮点数。我们不会过多地详细介绍计算机中浮点数的表示方式，因为这会变得有点复杂。如果你想知道这是如何完成的，你可以在网上搜索并看到很多关于它是如何工作的详细解释。
- en: But what we will do is to think about the problem the computer faces when dealing
    with a binary representation of a decimal number.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们将思考计算机在处理十进制数的二进制表示时面临的问题。
- en: 'In our decimal positional system, each position in a number has a value, as
    we saw earlier. This is just as true for floating-point numbers as for integers.
    For a floating-point number, the positions have values, as illustrated:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的十进制位制中，每个数位都有一个值，就像我们之前看到的那样。这对于浮点数和整数都是一样的。对于浮点数，位置也有值，如下所示：
- en: '![Figure 6.22 – The values that the different positions have in the decimal
    system, to the left and right of the decimal point](img/B15554_06_23.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![图6.22 – 十进制系统中不同位置在十进制点左边的值](img/B15554_06_23.jpg)'
- en: Figure 6.22 – The values that the different positions have in the decimal system,
    to the left and right of the decimal point
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.22 – 十进制系统中不同位置在十进制点左边的值
- en: 'Using this system makes it easy for us to store a value—for example, one-tenth
    can be written as 0.1\. In binary, the positions are as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个系统使我们能够轻松地存储一个值——例如，十分之一可以写成0.1\. 在二进制中，位置如下：
- en: '![Figure 6.23 – The values that the different locations have in the binary
    system,'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.23 – 二进制系统中不同位置在十进制点左边的值](img/B15554_06_24.jpg)'
- en: to the left and right of the decimal point](img/B15554_06_24.jpg)
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在十进制点左边的值](img/B15554_06_24.jpg)
- en: Figure 6.23 – The values that the different locations have in the binary system,
    to the left and right of the decimal point
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.23 – 在二进制系统中，不同位置相对于小数点的值
- en: As we can see, no value represents one-tenth, so something else needs to be
    done. What computers do is store floating-point values in scientific notation.
    Representing the `300` decimal value in scientific form come to ![](img/Formula_06_001.png).
    The computer does this but in binary form and divides the value into three parts.
    The first is the sign, just as we saw for integer values. The second part is the
    exponent used and the last part is called the mantissa. The mantissa is the decimal
    part of a logarithm to base 10 (that is, a decimal number). If that means nothing
    to you, don't worry. You don't need to understand the math to be able to use floating-point
    numbers. However, we must understand why numbers don't always come out the way
    we expect them to.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，没有任何值代表十分之一，所以需要做些其他事情。计算机的做法是以科学记数法存储浮点数值。将十进制值`300`表示为科学记数法，结果为![公式_06_001](img/Formula_06_001.png)。计算机以二进制形式执行此操作，并将值分为三部分。第一部分是符号，就像我们为整数值所看到的那样。第二部分是使用的指数，最后一部分称为尾数。尾数是10为底的对数的十进制部分（即十进制数）。如果这对您来说毫无意义，请不要担心。您不需要理解数学就能使用浮点数。然而，我们必须了解为什么数字并不总是以我们期望的方式出现。
- en: To illustrate this, we can think about what happens if we calculate 1/3\. We
    will get `0.333333333…`, where we will have an infinite number of threes. The
    same thing happened when we tried to represent `0.1` using binary numbers. The
    result will be a value that goes on forever in the binary form. The problem is
    that the computer does not have an infinite amount of memory, so when the amount
    that is assigned to this type runs out, it will just stop, which means that we
    will not have an accurate representation of the number. That is why we got `0.30000000000000004`
    instead of `0.3` when we added `0.1` and `0.2` together in the preceding example.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一点，我们可以考虑如果我们计算1/3会发生什么。我们将得到`0.333333333…`，其中我们将有一个无限数量的3。当我们尝试用二进制数表示`0.1`时，也会发生同样的事情。结果将是一个在二进制形式中无限延续的值。问题是计算机没有无限的内存，所以当分配给此类型的内存用尽时，它就会停止，这意味着我们将无法准确地表示这个数字。这就是为什么在前面的例子中，当我们把`0.1`和`0.2`相加时，我们得到了`0.30000000000000004`而不是`0.3`。
- en: Without going into the math of how floating-point numbers are represented, we
    need to understand the two most frequent types for representing them that we find
    in programming. They are usually called **float** and **double**.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 不深入探讨浮点数表示的数学，我们需要了解编程中用于表示它们的两种最常见类型。它们通常被称为**浮点数**和**双精度浮点数**。
- en: The difference between them is that a float will usually use 32 bits and a double
    will use 64 bits. This means that the double has more memory to use before it
    chops off a number. It is named double because it has double precision compared
    to the float type.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 它们之间的区别在于，浮点数通常使用32位，而双精度浮点数使用64位。这意味着双精度浮点数在截断数字之前有更多的内存可以使用。它被称为双精度，因为它与浮点数类型相比具有双精度。
- en: What we can learn from this is that if precision matters in our application,
    we should use a double, but if not, we can use a float. If, for example, we want
    to store outside temperatures, a float will be fine to use as we never deal with
    that many decimals.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个例子中我们可以学到的是，如果精度在我们的应用中很重要，我们应该使用双精度浮点数，如果不是，我们可以使用浮点数。例如，如果我们想存储室外温度，使用浮点数就足够了，因为我们永远不会处理那么多的十进制数。
- en: We can now work with integer and floating-point numbers, but sometimes we want
    to represent other kinds of values, such as complex numbers.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以处理整数和浮点数，但有时我们想要表示其他类型的值，例如复数。
- en: Some programming languages have a special type for working with complex numbers.
    Some examples of languages that use this type are Go, C++, Python, and Ruby.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 一些编程语言有专门用于处理复数的特殊类型。使用此类型的语言示例包括Go、C++、Python和Ruby。
- en: There is also another numeric type, even if we often think of it as something
    else—the character type.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一种数值类型，尽管我们通常认为它是其他东西——字符类型。
- en: 'A character that is a letter, a punctation mark, or any other character that
    we can come up with can be represented as a number. Many programming languages
    will provide a special type that is meant to handle a single character, but under
    the hood, it is an integer type. It is treated in a different way than the other
    numeric types that we have seen, as we can assign not only numbers to it but also
    characters, surrounded by some quotation marks—often single quotes. It can look
    something like this:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 一个字母、标点符号或任何我们可以想到的其他字符都可以表示为一个数字。许多编程语言将提供一个特殊类型，旨在处理单个字符，但在底层，它是一个整数字符类型。它以与我们之前看到的其他数值类型不同的方式处理，因为我们不仅可以向它分配数字，还可以分配被某些引号包围的字符——通常是单引号。它可以看起来像这样：
- en: '[PRE2]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, we assign the `a` character to a variable called `character_a`. The character
    is surrounded by single quotes to indicate that this is a character and not a
    variable named `a`. What happens is that the numerical value for this character
    is assigned to the variable. The character value for lowercase `a` is `97`, so
    in this case, that is what will be stored in the variable.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将`a`字符分配给一个名为`character_a`的变量。字符被单引号包围，以表示这是一个字符而不是名为`a`的变量。发生的事情是，这个字符的数值被分配给变量。小写`a`的字符值是`97`，所以在这种情况下，这就是将被存储在变量中的内容。
- en: 'To print the content of the variable to the screen, type the following code:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 要将变量的内容打印到屏幕上，请输入以下代码：
- en: '[PRE3]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We will see `a` printed, not `97`, as the programming language will know that
    this is a character type and not a normal numeric type and will translate the
    numerical value back to the character representation again.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到打印出`a`，而不是`97`，因为编程语言将知道这是一个字符类型而不是普通数值类型，并将数值值转换回字符表示。
- en: Sometimes, we need to store more than one value at a time. Then, we can use
    what are called **composite types**.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，我们需要同时存储多个值。然后，我们可以使用所谓的**复合类型**。
- en: Composite type
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复合类型
- en: A composite type is a data type that is made up of more than one value. There
    are situations when keeping several related values together makes sense. In our
    everyday life, we do this often. A shopping list is an example. Instead of having
    several papers, each one having one item we need to buy, we store all the items
    on one piece of paper and call this a list.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 复合类型是由多个值组成的数据类型。在某些情况下，将几个相关值放在一起是有意义的。在我们的日常生活中，我们经常这样做。购物清单就是一个例子。我们不是用几张纸，每张纸上有我们需要购买的一个物品，而是将所有物品存储在一张纸上，称之为列表。
- en: This is how a composite type works in programming as well. We have several types
    that all have some specific characteristics. The first one can be used when we
    want to represent a sequence or list of things. This is often called an array.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是编程中复合类型的工作方式。我们有几种类型，它们都具有一些特定的特性。第一种类型在我们想要表示一系列或列表时可以使用。这通常被称为数组。
- en: An array—also called a vector, list, or sequence—is a data type that stores
    several elements. This number can be fixed or flexible.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 数组——也称为向量、列表或序列——是一种存储多个元素的数据类型。这个数量可以是固定的或灵活的。
- en: Fixed array
  id: totrans-211
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 固定数组
- en: When we have a fixed size array, we say how many slots we want it to have when
    we create it. This size will not change. If we create an array that can store
    10 integers, it will reserve space for 10 integers, even if we only use 3 or 5.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有一个固定大小的数组时，我们在创建它时说明我们想要它有多少个槽位。这个大小不会改变。如果我们创建一个可以存储10个整数的数组，它将预留10个整数的空间，即使我们只使用了3个或5个。
- en: 'Typically, we would create a fixed-size array as follows:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们会创建一个固定大小的数组，如下所示：
- en: '[PRE4]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, we say that we want an array that can store 10 integers and we call it
    `numbers`. We are not storing any values in the array, so we say that these 10
    locations are unassigned, but we have space in memory reserved for us, and we
    have a name that we can use to access this space.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们想要一个可以存储10个整数的数组，我们称它为`numbers`。我们目前没有在数组中存储任何值，所以我们说这10个位置是未分配的，但我们已经为我们在内存中预留了空间，并且我们有一个可以用来访问这个空间的名称。
- en: We can see this as if we have 10 different variables. The only difference is
    that we store all 10 variables under the same name.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将其视为我们有10个不同的变量。唯一的区别是我们将所有10个变量存储在同一个名称下。
- en: We will now need a way to address these variables individually. This is done
    by indexing.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要一种方法来单独地引用这些变量。这是通过索引来完成的。
- en: 'We can index into the array by using its name and an index value:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用其名称和一个索引值来索引数组：
- en: '[PRE5]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here, we store `44` at position `2` in the array. You might think that position
    `2` is the second value in the array, but it is actually the third. The reason
    for this is that the index starts at 0, as shown:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们在数组的`2`号位置存储了`44`。你可能认为位置`2`是数组中的第二个值，但实际上它是第三个。原因在于索引是从0开始的，如下所示：
- en: '![Figure 6.24 – Inserting 44 at index 2 will place the value in the third position
    of the array](img/B15554_06_25.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![图6.24 – 在索引2处插入44将值放置在数组的第三个位置](img/B15554_06_25.jpg)'
- en: Figure 6.24 – Inserting 44 at index 2 will place the value in the third position
    of the array
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.24 – 在索引2处插入44将值放置在数组的第三个位置
- en: The reason that the indexing starts at 0 and not 1 is that we can think of the
    name that we used for this array as a reference to the first location in the array.
    When using an index, we say how many places we should move forward. So, `numbers[2]`
    means we start at the first location and move forward 2 integers in memory. That
    is the location you should store the value at.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 索引从0开始而不是1的原因是，我们可以将这个数组使用的名称视为对数组中第一个位置的引用。当使用索引时，我们说的是我们应该向前移动多少个位置。所以，`numbers[2]`意味着我们从第一个位置开始，在内存中向前移动2个整数。这就是你应该存储值的位置。
- en: 'We can also retrieve a value from a given index, as follows:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以从给定的索引中检索一个值，如下所示：
- en: '[PRE6]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The preceding code prints the value that is located at index `2`, which is the
    third value in the array.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码打印出位于索引`2`的值，这是数组中的第三个值。
- en: Having an array of a fixed size can be problematic as it is not always the case
    that we know how many values we need to store. If this is the case, then we can
    use another type of array that can grow and shrink as we use it. This is sometimes
    called a dynamic array.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有一个固定大小的数组可能会出现问题，因为我们并不总是知道我们需要存储多少个值。如果这种情况发生，那么我们可以使用另一种类型的数组，这种数组可以根据我们的使用情况动态增长和缩小。这有时被称为动态数组。
- en: Dynamic array
  id: totrans-228
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 动态数组
- en: 'A dynamic array (or list, vector, or sequence) is an array that can grow and
    shrink as we use it. Initially, this kind of array will be empty when we first
    create it, but we can then add and remove things from it as we go along. How we
    create these arrays will differ from language to language, but it can look something
    like this:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 动态数组（或列表、向量或序列）是一种可以随着使用情况动态增长和缩小的数组。最初，当我们首次创建这种类型的数组时，它将是空的，但我们可以随后添加和移除其中的内容。创建这些数组的方法会因语言而异，但可能看起来像这样：
- en: '[PRE7]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, we are creating an empty dynamic array.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们创建了一个空的动态数组。
- en: 'We can now add and remove things from this array:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以添加和移除数组中的内容：
- en: '[PRE8]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, we first add three values—`10`, `11`, and `12`. Values are usually added
    at the end, so they will be stored in the `10`, `11`, `12` order.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们首先添加了三个值——`10`，`11`和`12`。通常，值会被添加到末尾，所以它们将按照`10`，`11`，`12`的顺序存储。
- en: On the last line, we remove the `11` value. The array now has the `10` and `12`
    values.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一行，我们移除了`11`这个值。现在数组中只有`10`和`12`这两个值。
- en: 'Often, we will have different ways to dictate where in this array new values
    should be added and removed. We might, for example, be able to do something like
    this:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们会有不同的方法来指定新值应该添加到数组的哪个位置以及应该从哪个位置移除。例如，我们可能能够做如下操作：
- en: '[PRE9]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'From the preceding code, we can see the following:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中，我们可以看到以下内容：
- en: We add the `10` value to the back of the empty array.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将`10`这个值添加到空数组的后面。
- en: Then, we add the `11` value to the beginning of the array. We now have `11`,
    `10`.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将`11`这个值添加到数组的开头。现在我们有`11`，`10`。
- en: Then, we add `12` to the back, giving us `11`, `10`, `12`.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们在后面添加`12`，得到`11`，`10`，`12`。
- en: In the last line, we add `13` to the front of the array. We now have the `13`,
    `11`, `10`, and `12` values.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在最后一行，我们将`13`添加到数组的开头。现在我们有`13`，`11`，`10`和`12`这些值。
- en: We can often use an index, just as with a fixed size array, to retrieve individual
    values from a dynamic array. The problem is that we need to keep track of how
    many items we currently have in the array. This is important because if you have
    an array of let's say five things and you say that you want to get item number
    10, you are looking outside the array and your programming language will most
    likely halt the execution of the program as you are doing something that is considered
    illegal (according to your language, that is.)
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常可以使用索引，就像在固定大小的数组中一样，从动态数组中检索单个值。问题是我们需要跟踪数组中当前有多少个项。这很重要，因为如果你有一个包含五个元素的数组，而你想要获取第10个元素，你就是在数组外部查找，你的编程语言很可能会因为执行了非法操作（根据你的语言来说）而停止程序执行。
- en: Dynamic arrays come at another cost as well. When we create a fixed-size array,
    a big enough chunk of memory will be found, and we can then go ahead and use this.
    All the items in the array must come sequentially in memory because that is what
    makes indexing work. As we saw, the name of the array will tell us the starting
    location for this array, and we then use an index to say how many steps into the
    memory we need to move to come to the correct place.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 动态数组也有其代价。当我们创建一个固定大小的数组时，会找到一个足够大的内存块，然后我们可以继续使用它。数组中的所有项目都必须在内存中按顺序排列，因为这是索引工作的基础。正如我们所看到的，数组的名称将告诉我们这个数组的起始位置，然后我们使用索引来表示我们需要在内存中移动多少步才能到达正确的位置。
- en: When using a dynamic array, this might be a problem. If we add item after item,
    we will eventually hit a memory location where something else is located. Our
    array will now need to move to another location that is big enough for all the
    values we already had in it, plus the new value that we want to add. As a programmer,
    this is not a usual task. The language does this for us, but copying all the old
    values from the original location to this location will take time. This is the
    cost we pay for the freedom of having a structure that can grow and shrink depending
    on our needs.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用动态数组时，这可能会成为一个问题。如果我们一个接一个地添加项目，我们最终会到达一个已经存放其他东西的内存位置。现在我们的数组需要移动到另一个足够大的位置，以便存放我们已有的所有值，以及我们想要添加的新值。作为程序员，这不是一个常见的任务。语言会为我们完成这个任务，但将所有旧值从原始位置复制到这个位置将花费时间。这就是我们为拥有一个可以根据我们的需求增长和缩小的结构所付出的代价。
- en: Most programming languages will only let you store data of the same type in
    an array. There are a few, however, that will allow you to mix the types as you
    wish.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数编程语言只允许你在数组中存储相同类型的数据。然而，有一些语言允许你按需混合类型。
- en: Sometimes, we want to store values that are related in another way—let's say
    information about a person. Then, we can use what is called a record.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们想要存储以另一种方式相关联的值——比如说关于一个人的信息。然后，我们可以使用所谓的记录。
- en: The record type
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 记录类型
- en: If you are writing an application and you want to represent information about,
    say, customers, you will first need to decide what information you want to handle.
    This might be the customer's first and last name, a street address, a city, a
    ZIP code, and so on. This might include data of different types. It would also
    be handy if you could retrieve the different items with the help of a name.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在编写一个应用程序，并且你想表示关于客户的信息，你首先需要决定你想要处理哪些信息。这可能包括客户的首姓和姓氏、街道地址、城市、邮政编码等等。这可能包括不同类型的数据。如果你能够通过名称检索不同的项目，那将非常有用。
- en: 'Records are sometimes called structures or structs. To use them, we first need
    to define what they look like. This can look something like this:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 记录有时也被称为结构体或struct。要使用它们，我们首先需要定义它们的形状。这可能看起来像这样：
- en: '[PRE10]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: What we are doing here is defining a new type called `Person`. One variable
    of this type can store a first name, last name, street address, city, and ZIP
    code.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里所做的定义了一个新的类型叫做`Person`。这种类型的一个变量可以存储一个名字、姓氏、街道地址、城市和邮政编码。
- en: 'Creating a variable of this type might look something like this:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 创建这种类型的变量可能看起来像这样：
- en: '[PRE11]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We now have a variable called `person1`, but we do not store any data in it
    yet. Doing so might look like this:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个名为`person1`的变量，但我们还没有在其中存储任何数据。这样做可能看起来像这样：
- en: '[PRE12]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'All the information we have about this person is now stored in the `person1`
    variable. We can now create other `person` variables to store information about
    other people:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个人的所有信息现在都存储在`person1`变量中。我们现在可以创建其他`person`变量来存储其他人的信息：
- en: '[PRE13]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We can also retrieve the data stored within these variables, as follows:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以检索存储在这些变量中的数据，如下所示：
- en: '[PRE14]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The output of this will be as follows:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出的结果如下所示：
- en: '[PRE15]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here, we have a relationship between a variable name, `firstName`, for example,
    and some data—`Anna`, `Bob`, and `Colette`. We know about this relationship beforehand,
    so the record structure is perfect for us. Sometimes, we might not know what we
    will get, but the data might still come in pairs. Then, we can use another data
    type known as a dictionary.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个变量名`firstName`（例如）与一些数据——`Anna`、`Bob`和`Colette`之间的关系。我们事先知道这种关系，因此记录结构对我们来说非常合适。有时，我们可能不知道我们会得到什么，但数据可能仍然以成对的形式出现。然后，我们可以使用另一种称为字典的数据类型。
- en: The dictionary type
  id: totrans-264
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字典类型
- en: A dictionary (also known as a map, hash map, or associative array) is a collection
    type that uses key-value pairs. The key needs to be a unique value that we can
    use to retrieve the value that is associated with it.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 字典（也称为映射、哈希表或关联数组）是一种使用键值对的集合类型。键需要是一个唯一的值，我们可以用它来检索与其关联的值。
- en: A colon often separates the key and the value.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 冒号通常用于分隔键和值。
- en: 'They might look something like this:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 它们可能看起来像这样：
- en: '[PRE16]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here, we are using the name of some famous books as the keys, and the value
    associated with each key is the author of that book. As we stated before, the
    key needs to be unique. If we reuse the key and assign another value to it, the
    old value will be overwritten by the new one.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用一些著名书籍的名字作为键，与每个键关联的值是那本书的作者。正如我们之前所述，键需要是唯一的。如果我们重复使用键并为其分配另一个值，旧值将被新值覆盖。
- en: 'We can access the values—the names of the authors, in our case—by using the
    key as an index:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用键作为索引来访问值——在我们的例子中是作者的名字：
- en: '[PRE17]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This will give the following output:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给出以下输出：
- en: '[PRE18]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'As it is only the key that needs to be unique, we can have multiple items that
    have the same value. We can, for example, add a book to the dictionary as follows:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 由于只需要键是唯一的，我们可以有多个具有相同值的项。例如，我们可以将一本书添加到字典中如下：
- en: '[PRE19]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We now have two values containing `Charles Dickens`, but they are associated
    with two different and unique keys.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有两个包含`Charles Dickens`的值，但它们与两个不同且唯一的键相关联。
- en: Sometimes, we have other reasons for storing unique values. We might want to
    represent what in mathematics is known as finite sets. For that, we also have
    the set type.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们存储唯一值有其他原因。我们可能想表示数学中已知的有限集。为此，我们也有集合类型。
- en: The set type
  id: totrans-278
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 集合类型
- en: A set is a composite type that will store unique values without any order. As
    this type is unordered, we cannot retrieve items from it with an index. This is
    usually not a problem as this type is often used to test for membership. You might,
    for example, have two sets with some values in them and would like to know which
    values occur in both sets.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 集合是一种复合类型，它将存储唯一值而不按顺序排列。由于这种类型是无序的，我们不能通过索引从它中检索项目。这通常不是问题，因为这种类型通常用于测试成员资格。例如，你可能有包含一些值的两个集合，并想知道哪些值出现在两个集合中。
- en: 'Let''s see how we might create these two sets and then print the values that
    occur in both:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何创建这两个集合，然后打印出两个集合中出现的值：
- en: '[PRE20]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In set theory, an intersection between two sets are the values that exists in
    both sets.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在集合理论中，两个集合之间的交集是存在于两个集合中的值。
- en: 'The output of this will be as follows:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出如下所示：
- en: '[PRE21]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This output is represented as follows:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出如下所示：
- en: '![Figure 6.25 – Representation of two sets that has an intersection of 2 and
    9 as'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.25 – 两个集合的表示，这两个集合的交集是2和9，因为这些值存在于两个集合中](img/B15554_06_26.jpg)'
- en: these two values exist in both sets](img/B15554_06_26.jpg)
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个值存在于两个集合中](img/B15554_06_26.jpg)
- en: Figure 6.25 – Representation of two sets that has an intersection of 2 and 9
    as these two values exist in both sets
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.25 – 两个集合的表示，这两个集合的交集是2和9，因为这些值存在于两个集合中
- en: Sometimes, we want to create a new type so that we can dictate what values can
    be assigned to variables that are of this type. For this, we have enumeration.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们想要创建一个新的类型，以便我们可以指定可以分配给这种类型的变量的值。为此，我们有枚举。
- en: Enumeration
  id: totrans-290
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 枚举
- en: Enumeration, often called just **enum**, is an enumerated type with distinct
    values. We can use this to create our types and dictate what values can be assigned
    to a variable that has this type.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举，通常简称为**枚举**，是一种具有唯一值的枚举类型。我们可以使用它来创建我们的类型并指定可以分配给具有此类型的变量的值。
- en: 'It can look something like this:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 它可能看起来像这样：
- en: '[PRE22]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '`TrafficLight` is now a type and we can use it to create variables:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '`TrafficLight`现在是一个类型，我们可以用它来创建变量：'
- en: '[PRE23]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'As both `light1` and `light2` are of the `TrafficLight` type, we can only assign
    the things we described inside this type:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`light1`和`light2`都是`TrafficLight`类型，我们只能分配在这个类型内部描述的事物：
- en: '[PRE24]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Behind the scenes, there are numerical values associated with each of the items
    in the enum. In our case, `red` will be `0`, `yellow` is `1`, and `green` is `2`.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，每个枚举项都与一个数值相关联。在我们的例子中，`red`将是`0`，`yellow`是`1`，`green`是`2`。
- en: Now, we have seen that we can work with Boolean values, numbers, characters,
    and different composite types, but you might notice that we're missing one type.
    We have still not seen a type that can handle text. It is time to look at strings.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经看到我们可以处理布尔值、数字、字符和不同的复合类型，但你可能会注意到我们缺少一种类型。我们还没有看到一种可以处理文本的类型。是时候看看字符串了。
- en: Strings
  id: totrans-300
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符串
- en: A string is a composite type as it is stored as an array of characters. Most
    languages will use double quotes to designate that something is a string and will
    use single quotes for single characters. Some languages will let you use either
    single or double quotes for both types. Here, we will use double quotes for strings
    and single quotes when we only have a single character.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串是一种复合类型，因为它被存储为字符数组。大多数语言将使用双引号来指定某物是一个字符串，并将使用单引号来表示单个字符。有些语言允许你为这两种类型都使用单引号或双引号。在这里，我们将使用双引号来表示字符串，当只有一个字符时使用单引号。
- en: 'Usually, we will not consider a string an array. We can create a string as
    follows:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们不会将字符串视为数组。我们可以创建一个字符串，如下所示：
- en: '[PRE25]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Here, we created a variable of the string type, called `greeting`, and assigned
    a `Hello there` value to it. Behind the scenes, an array of characters will be
    created and each character in the string will be assigned to one location in this
    array, as shown:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个字符串类型的变量，名为 `greeting`，并将其值设为 `Hello there`。在幕后，将创建一个字符数组，字符串中的每个字符都将分配到这个数组中的一个位置，如下所示：
- en: '![Figure 6.26 – The Hello there string stored as an array, where each item
    is a character](img/B15554_06_27.jpg)'
  id: totrans-305
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.26 – 存储为字符数组的 "Hello there" 字符串](img/B15554_06_27.jpg)'
- en: Figure 6.26 – The Hello there string stored as an array, where each item is
    a character
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.26 – 存储为字符数组的 "Hello there" 字符串
- en: 'As a string is an array of characters, we can use an index to access individual
    characters. As an example, let''s print the character at position `7`, which is
    the eighth character:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 由于字符串是字符数组，我们可以使用索引来访问单个字符。例如，让我们打印位置 `7` 的字符，这是第八个字符：
- en: '[PRE26]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The output will be as follows:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE27]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Now that we can handle data in different formats, we can move on to do something
    with this data. It is time to look at operators.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够以不同的格式处理数据，我们可以继续对这些数据进行操作。是时候看看操作符了。
- en: Operators – things we can do with variables
  id: totrans-312
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作符 – 我们可以对变量执行的操作
- en: In [*Chapter 5*](B15554_05_Final_NM_ePub.xhtml#_idTextAnchor081)*, Sequence
    – The Basic Building Block of a Computer Program*, we talked about how a statement
    is made up of expressions and that expressions can be made up of operations or
    operands.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第 5 章*](B15554_05_Final_NM_ePub.xhtml#_idTextAnchor081)*，序列 – 计算机程序的基本构建块*
    中，我们讨论了语句是由表达式组成的，以及表达式可以由操作或操作数组成。
- en: 'Let''s see an example of this. Here, we will create two variables and assign
    a value to each of them. Then, we will add the two values together and store the
    result in a new variable:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个例子。在这里，我们将创建两个变量，并给每个变量赋值。然后，我们将这两个值相加，并将结果存储在一个新变量中：
- en: '[PRE28]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In line one, we created a variable called `number1` and assigned a value of
    `10` to it. We now know that this means several things:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行，我们创建了一个名为 `number1` 的变量，并将其值设为 `10`。我们现在知道这意味着几件事情：
- en: The variable name is `number1`.
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量名是 `number1`。
- en: As it is assigned an integer, it must be of an `integer` type.
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于它被分配了一个整数，因此它必须是 `integer` 类型。
- en: The `=` sign is an operator, taking whatever is on the right and assigning it
    to what we have on the left.
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等号 `=` 是一个操作符，它将右侧的内容赋值给左侧的内容。
- en: Somewhere in the computer's memory, enough space for an integer has been reserved.
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在计算机内存的某个地方，已经为整数预留了足够的空间。
- en: The name, `number1`, will act as an alias for this address.
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名称 `number1` 将作为这个地址的别名。
- en: We then do the same thing in line two, the only difference being that we have
    another name for the variable, `number2`, and we assign it another value, `15`.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在第二行做同样的事情，唯一的区别是我们给变量起了一个不同的名字，`number2`，并给它赋了另一个值，`15`。
- en: On the third line, we use the addition operator. This operator has two operands—`number1`
    and `number2`. It will now extract the values in these two variables, add them
    together, and return the result.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三行，我们使用了加法操作符。这个操作符有两个操作数——`number1` 和 `number2`。现在，它将提取这两个变量中的值，将它们相加，并返回结果。
- en: This operation will result in a value of `25`, which is what will be assigned
    to the variable result. As a result of the addition operation giving us another
    integer, we now also know that the variable result will also have the `integer`
    type.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at some operators for basic arithmetic.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: Arithmetic operators
  id: totrans-326
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Most programming languages share the symbols used for basic arithmetic operations.
    Refer to the following table to see the most common ones:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 6.5](img/B15554_Table_6.5.jpg)'
  id: totrans-328
  prefs: []
  type: TYPE_IMG
- en: Table 6.5
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: The last one, the modulus operator, might not be familiar to you. It is often
    used in programming as it has some features that can be handy when working with
    numbers. We can illustrate what it does with a simple example. If we calculated
    `16/13`, we would get a result of `1.230769…`. The integer part, `1`, tells us
    that `13` goes once into `16`. What the modulus operator does is tells us how
    much there is left to get to `16`. So, if `13` goes once into `16`, we must add
    `3` to `13` to get to `16`.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: We would express that with `16 % 13` and get a result of `3`. If you have not
    worked with modulus before, I suggest you search it up online to get an understanding
    of how it works as it is something that you will find very useful as a programmer.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: Next up, we have some operators that we can use to compare things.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: Relational operators
  id: totrans-333
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Relational operators are used when we want to compare two values. They can
    be equal or not equal. We might want to know whether one value is greater than
    the other. The following table lists the relational operators that are typically
    found in programming languages:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 6.6](img/B15554_Table_6.6.jpg)'
  id: totrans-335
  prefs: []
  type: TYPE_IMG
- en: Table 6.6
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: With these operators, we can compare two values, but sometimes we have more
    values to compare. In this case, we will need logical operators.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: Logical operators
  id: totrans-338
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'These operators are used to represent `and`, `or`, and `not`. Some languages
    will use these exact words to represent them, but others will have special signs
    for them. They are used in statements such as `if the age is greater than 12`
    and `age is less than 20`. In code, that would look something like this:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The three operators we can use are as follows:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 6.7](img/B15554_Table_6.7.jpg)'
  id: totrans-342
  prefs: []
  type: TYPE_IMG
- en: Table 6.7
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: Most languages will have more operators than the ones we have seen here. We
    will not cover them here as some are combination operators, which is a combination
    of two of the operators we have seen here, and others are specialized for one
    or a few languages.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: Next up, we will look at two different ways that variables can be stored in
    memory and why that concerns us.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: The concept of values and reference variables
  id: totrans-346
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are two ways that a variable can store its value in memory. We could think
    of these ways as direct and indirect. This might sound strange, but let's use
    an analogy to explain.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: 'The variables that directly store their data are like boxes. When we create
    them, we can think of them as a box that has the name of the variable stuck to
    it with a label. We can store the value inside the box and look in the box later
    to see what value is in there. Variables that store their values like this are
    called **value variables**:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.27 – A variable that stores its data by value is like a box](img/B15554_06_28.jpg)'
  id: totrans-349
  prefs: []
  type: TYPE_IMG
- en: Figure 6.27 – A variable that stores its data by value is like a box
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: 'Variables that use indirect storage will act as an index card in a library.
    It will not store the book but will have the location where it is stored, so it
    only contains the address to where in memory the actual value is. Variables that
    store values like this are called **reference variables**:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.28 – Variables that store data by reference are like a library index
    card](img/B15554_06_29.jpg)'
  id: totrans-352
  prefs: []
  type: TYPE_IMG
- en: Figure 6.28 – Variables that store data by reference are like a library index
    card
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: Let's see how they both work.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: Value variables
  id: totrans-355
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When we create a variable—or declare it, as we would usually say—of a type,
    several things will happen, as we saw at the beginning of this chapter. Let''s
    see what will happen when the following code line is executed:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As we now know, a chunk of memory that is large enough to host an integer is
    located, and this location has an address. The name we give the variable—`x`,
    in the preceding example—is just an alias for this address. It is much easier
    for us to remember that a variable called `firstName` stores a name instead of
    having to remember that the first name was at the `38892819283` address.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: When our code is interpreted or compiled, the variable name is changed to the
    actual address, but that is luckily not anything that we will ever see. As this
    is a variable that stores its data by value, there is a direct relationship between
    where the data is and the variable name.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: Reference variables
  id: totrans-360
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When it comes to reference variables, there is an extra step between the variable
    name and where the data is. Let''s see what happens when we create a reference
    variable with another code example:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: '`weather = "Sunny"`'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, the data will still need to be stored somewhere, so a memory
    location for it is found and as before, the address of where this is is noted.
    However, the difference is that the variable name is not an alias for this address.
    Instead, the address for where the data is is stored at another location in memory
    and the variable is an alias for that location. The following diagram illustrates
    this:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.29 – A variable named weather as a reference variable](img/B15554_06_30.jpg)'
  id: totrans-364
  prefs: []
  type: TYPE_IMG
- en: Figure 6.29 – A variable named weather as a reference variable
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: This might seem pointless. Why can't we store the text string at the location
    pointed out by the `weather` variable? What is the point of this extra step? The
    answer is efficiency. In a program, we need to pass data around. The data that
    we have in a variable in one part of the program needs to be passed along to another
    part. Imagine that the data stored is much larger than the short text string in
    the preceding example; the actual passing of the data would mean that we need
    to make a copy of all the data. This takes some time, and we will now have two
    copies of the data, which will use twice as much memory. If a variable is of this
    reference type, we will not need to copy all the data. In the preceding example,
    this will mean that we will not need to copy `Sunny`. Instead, the `weather` variable
    contains the address to where this data is, so it can just pass the address.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: How a language uses these two types will differ from language to language. When
    learning a new language, it is vital to learn how it works with value and reference
    variables.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have covered lots of things related to variables, we are now ready
    to use them. We will now see how we can work with numbers, and after that, we
    will look at text strings.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: Working with numbers
  id: totrans-369
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Numbers are essential in computer programs. We use them to represent real-world
    concepts, such as the number of items in a shopping cart, the weight of a package,
    and the distance to a location. We also use them to represent internal things
    within our program, such as the number of characters in a name so that we can
    calculate whether it will fit on an address label if we print it. The point is,
    we use numbers all the time, so let's see what we can do with them.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we can do basic arithmetic, such as addition, subtraction, multiplication,
    and division, as in the following code snippet:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In this example, we have two ages and we are calculating the medium age.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: 'We often use numbers as counters of things. What this means is that we will
    use them to keep track of how many times we have done something. This means that
    we need to increase (and sometimes decrease) them by 1\. We could do this as follows:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: To understand what happens here, we need to look to the right of the `=` sign
    first. Here, we have a variable called `count`. As this is just a line that is
    ripped out of its context, we can assume that it already has a value stored. This
    value is now used, and we add `1` to it. The result of this addition is then stored
    back in the variable count, and we have increased its value by 1.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: 'As this is such a common thing to do in programming, some shorthands for this
    have been developed. As we are using the same variable on both sides of the `=`
    operator, we can skip one of them and instead use a different operator that looks
    something like this:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This is the same as in the last example, but just shorter. We can read it as
    taking the value that is stored by the `count` variable, adding `1` to it, and
    storing the result back in `count`.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: 'Some languages have taken this further and shortened this even more:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Again, the result will be the same as the other two. We can read this as increasing
    the value stored in `count` by `1`.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: 'All of the three examples we just saw can, of course, be done with subtraction
    too, as shown:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: When working with numbers, they can either be stored in a variable, as with
    `count`, or digits directly in the code, as is the case with `1` in the preceding
    examples.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, we will work with more complex mathematical formulas and do several
    things in one single line.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: 'We could have something like the following:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_06_002.png)'
  id: totrans-388
  prefs: []
  type: TYPE_IMG
- en: How would we write that in a program?
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: First, `x`, `a`, and `b` are variables in mathematics and will be variables
    in our program, too. `a + 3` and `7 – b` must be done before we can divide. We
    use an equation such as this as a recipe to calculate something. To use it, we
    insert some values for `a` and `b`. Then, we do the math, and `x` will be the
    result.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: 'In our program, we can, therefore, assume that `a` and `b` have some values
    given to them earlier in the program. So, let''s see how we can let the computer
    do the math for us:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Adding parentheses means that what is inside of them will be calculated first.
    So, if we imagine some values for `a` and `b`—let's say `a = 3` and `b = 4`—then
    `a + 3` will be calculated first, so we have `3 + 3 = 6`. Then, `7 – b` will be
    calculated, so `7 – 4 = 3`. At this point, we can imagine that `a + 3` is replaced
    by `6` and `7 – b` by `3`; we are left with `6 / 3`. The result, `2`, will be
    stored in `x`.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: If basic algebra is not enough for us, most programming languages come with
    a vast library of mathematical functions that we can use, such as cosine, tangent,
    square root, and absolute value.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: Another data type that programmers use a lot is strings. Let's look at some
    of the things we can do with them.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: Manipulating strings
  id: totrans-396
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A string is a sequence of characters, and a character does not have to be a
    letter, it can be punctuation marks, a space, a hyphen, or any other character
    we can produce using a computer. A string can also contain digits.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we must understand is that a string only containing digits
    will not be the same as if it were an integer. Look at the following code:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Notice the quotation marks around the digits in the last number. This turns
    it into a string. The first one, `numberA`, will be of the `integer` type, so
    it can be used for counting and other mathematical operations. For the computer,
    the second one is just as much a number as the word `dog` is—that is, not at all.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: When working with strings, there are several typical things we can do with them.
    Let's look at some frequent string operations.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: String concatenation
  id: totrans-402
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When we take two strings and add them together to form a new string, we call
    it concatenation. How this is done will differ a bit from language to language,
    but often, we can use the `+` operator, as in the following example:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Here, we have two strings—`day` and `break`. The quote marks tell us that they
    are strings. They will now be concatenated into a new string that is stored in
    the `word` variable. This variable will contain the `daybreak` word.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: Splitting strings
  id: totrans-406
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes, we want to split a string into multiple strings. To do this, we will
    often use a delimiter inside the string, which we can use to indicate where the
    string should be divided. Let's assume that we have a string that contains a first
    name and last name and that the names are separated by a comma, such as `Sue,Smith`.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: 'If that is stored in a variable called `name`, in some languages, we could
    do something like this:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: As usual, we will begin by looking at the right side of the `=` operator. Here,
    we say that we have a string in a variable called `name`. We want to break up
    this string into two parts, so we use `split`. Inside the parentheses, we see
    a string. Again, we know that it is a string because it has quote marks and contains
    a comma. This is the character that will be used for the split. All characters
    that precede the comma inside the variable name will be sent to the first variable
    to the left, `firstName`. Everything after the comma will be sent to the second
    variable, `lastName`. The comma itself that is inside the variable name will be
    discarded.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also important to note that the content of the variable name has not
    changed, so if we peek into the variables after this line has executed, we can
    see that they contain the following:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The result can also be an array that contains the two strings. This would look
    something like the following:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The `splitName` variable will now be an array that contains two strings. Remember
    that the first position in an array is `0`, and in that location, we will find
    the `Sue` string, and at position `1`, we will find `Smith`.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: Substrings
  id: totrans-416
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Substrings are used when we take part of a string to form a new string. How
    this is done will change from language to language. Here are some examples of
    what it might look like if we want to extract the `car` substring out of the `phonocardiogram`
    string.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we store `phonocardiogram` in a variable, as follows:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'In some languages, we can then do something like this:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This will begin extracting the substring from location `5` in the string. Just
    as with arrays, the counting will start at `0`. As the letter `c` is the sixth
    letter, the index we use will be `5`. Then, as per the code given, we end at `8`.
    But that looks like we went one letter too far. Commonly, we use two values as
    the start and end index. The first will state where to start and the second will
    point out the first things that are outside the range. We can read the preceding
    example as starting at location `5` and stopping at location `8` without including
    it.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: After this line has executed, the `newWord` variable will contain the `car`
    string, and as before, the `word` variable will be unchanged.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: 'Other languages will do something like the following instead:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Here, we use `substr` instead of square brackets. Also, note that `5` and `8`
    are separated by a comma here and that we used a semicolon in the first example.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: 'A third variant would look something like this:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: In languages that use this form, the second value indicates how many characters
    we want instead of the end index. However, the result will be the same.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: Case conversion
  id: totrans-430
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Converting string casing is something we often want to do. The reason for this
    can, for example, be so that we can ask the user of our program to enter a text
    command, and then we will need to check what command the user entered. As an example,
    we can imagine that they entered the following commands:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: '`Start`'
  id: totrans-432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Pause`'
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Stop`'
  id: totrans-434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will need to compare what the user wrote against these strings, but we have
    a problem. When we compare strings, they need to be cased the same to be equal.
    This means that `start`, `Start`, and `START` will all be different.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: 'We can''t compare all the combinations as they would be rather too many. For
    just the `start` word, we have the following variants:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: '`start`'
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Start`'
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`STart`'
  id: totrans-439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`StArt`'
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`STArt`'
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SRArT`'
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sTART`'
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`starT`'
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We could go on, but instead, let's just convert a string into either all uppercase
    or all lowercase. Then, we will know what form the string has.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: 'We can do this as follows:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Alternatively, the string can be converted as follows:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '`lower` and `upper` will not change the original string that is inside the
    variable answer, but instead will create a new lowercase or uppercase version
    of this string. We will store this new version back into the variable, and by
    doing so, we will overwrite the old string with the new version where we know
    how it is cased.'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: We have seen a few examples of things we can do with strings. This not all we
    can do, but consider these as some examples of some frequent operations that we
    can perform on strings.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-452
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered one of the two main pillars that programming rests
    on—how we can store, retrieve, and change data in the computer's memory using
    variables.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: We learned that a variable has a name and a data type and that the type of the
    variable dictates what can be stored in it and how much memory it will use. We
    also learned how we could concisely name our variables and that there are naming
    conventions that we can use for guidance.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: With that covered, we then talked about primary or primitive data types and
    saw that numbers are handled either as integers or floating-point numbers, which
    are further divided into different sizes, so we can pick a type that suits our
    needs and make sure we don't waste memory space.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: Some data naturally comes in a sequence or in natural groups. For this data,
    we used a composite data type, and we saw that this type lets us work with groups
    of data.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: We then talked about what operators are and how we can perform operations on
    variables using them, as well as what common operators are and some examples of
    how to use them.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: A variable can be stored in memory either as a value or reference type. We learned
    that when it is stored as a value, the data it stores is located at the memory
    address of the variable. A reference variable does not save its value directly
    but stores an address to where the data can be found.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: We used variables with numbers and performed some basic operations on them using
    our operators. In the end, we turned our attention to strings and looked at how
    we can manipulate them.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will introduce logic to our programs with proper selection
    so that we can do things only if a condition is met. We will also see how we can
    repeat the same thing several times with the help of loops.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
