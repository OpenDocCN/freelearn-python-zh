- en: '*Chapter 6:* Working with Data – Variables'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In previous chapters, we stated that a program is something that takes data
    as input and performs operations on it to produce new data. So, handling data
    is crucial in any application, regardless of whether it is used for accounting
    or whether it is a game.
  prefs: []
  type: TYPE_NORMAL
- en: When we work with data, it must be stored in the computer's memory, and this
    is done with **variables**. It is variables that let us store and retrieve data.
    In this chapter, we will get to know variables, see how they work, and, in the
    end, look at some operations that we can perform on them.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn about the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Declaring and initializing variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding data types and applying them to variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using composite types to handle multiple values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performing operations on variables using operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operating on numbers and manipulating strings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When programming, we need to work with data, and that data will be stored in
    the computer's memory. To be able to use this data, we need to have a way to reference
    where in the memory the data is. This is done by using a nice abstraction called
    variables. Variables hide the difficult stuff, such as working with memory addresses,
    and give us easy access to data by letting us assign a name to it. Let's see how
    this works.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Declaring and initializing variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When writing programs, we continuously work with data. As we are using this
    data, we need a way to keep track of it. To do this, we use variables. Let's look
    at how this works in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To understand what a variable is, we can start with some code where we assign
    a value to a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have the value `13`, which is a whole number. Usually, in programming,
    we refer to these as integers as they can be both positive and negative. Different
    programming languages treat integer values differently. Most languages will specify
    how much memory an integer will use. Let's assume that this size is 4 bytes, which
    is a common size used to store an integer value. Remember that one byte is 8 bits
    and that each bit can be either `0` or `1`. With 4 bytes, we have 4 times 8 bits,
    which is 32 zeros or ones, at our disposal.
  prefs: []
  type: TYPE_NORMAL
- en: To store `13` in the computer's memory, the programming language will need to
    reserve enough space—4 bytes, in our case.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each byte of computer memory has an address. A memory address works like a
    street address; it is used to help us navigate to the correct location:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1 – Part of the computer''s memory. Each square is a byte and has
    a unique address](img/B15554_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.1 – Part of the computer's memory. Each square is a byte and has a
    unique address
  prefs: []
  type: TYPE_NORMAL
- en: In our example, 4 bytes that are not occupied by something else need to be located.
    These bytes need to be in continuous order.
  prefs: []
  type: TYPE_NORMAL
- en: 'The address of the first byte in this sequence is of interest to us. The programming
    language knows that we are storing an integer value at this location, and it knows
    how many bytes an integer occupies, so the first address is enough to locate this
    integer. The following diagram shows this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15554_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.2 – The programming language reserves enough space in memory for an
    integer value to be stored
  prefs: []
  type: TYPE_NORMAL
- en: 'When writing a program, we don''t want to remember numeric memory addresses,
    so we give this memory address a name. It is up to us, as programmers, to come
    up with this name, and we should pick a name that describes the data that we are
    storing. We will talk more about what considerations we need to make when naming
    variables soon:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.3 – The first address in the reserved sequence is given a name—in
    this case, x](img/B15554_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.3 – The first address in the reserved sequence is given a name—in this
    case, x
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have enough room for the reserved integer value and a name that
    can be used to refer to this memory address, the actual value can be stored at
    this memory location. This value will be stored in binary format. We talked about
    binary numbers in [*Chapter 1*](B15554_01_Final_NM_ePub.xhtml#_idTextAnchor016),
    *Introduction to Computer Programs*. In the preceding code snippet, we wanted
    to save the value `13`, and `13` in binary is `1101`. All of the bits preceding
    this value are filled with zeros. As you can see in the following diagram, one
    byte would have been enough, but as many languages have a fixed size for its integer
    type, all the bytes will be reserved, regardless of whether we need them:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.4 – The binary representation of the value we want to be stored
    is inserted at this memory location](img/B15554_06_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.4 – The binary representation of the value we want to be stored is
    inserted at this memory location
  prefs: []
  type: TYPE_NORMAL
- en: Now, the value is stored in memory and we have a name that refers to this location.
    We can use this name to access this value.
  prefs: []
  type: TYPE_NORMAL
- en: We call `x` in our example a variable. A variable consists of several things.
    It has a name, which is `x` in our sample. It also has a type. The type defines
    how much memory the data needs. We wanted to store an integer and we assumed that
    the language we are using has decided to use 4 bytes for integers. This is the
    size of this variable. We also know that if an integer has a fixed size, there
    is a maximum value that it can store. Later in this chapter, we will talk about
    this limitation.
  prefs: []
  type: TYPE_NORMAL
- en: We also need to explore how we can name our variables and what types they can
    have. Let's start with the names.
  prefs: []
  type: TYPE_NORMAL
- en: Naming variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The name we give a variable should reflect what data it represents, so if we
    use a variable to store an email address, a good name would be `email`, whereas
    `b45` would be rather lousy.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax of each language has rules for how we can name our variables. Some
    standard rules for naming variables are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: It must begin with a letter of the alphabet or an underscore (`_`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After the first character, the name can contain letters, underscores, and numbers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You cannot use names that are used as keywords in the language—that is, words
    that are reserved by the language, such as `for`, `if`, and `else`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spaces or other special characters, such as `+`, `-`, and `*`, are not allowed
    to be part of the name.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Some examples of legal and illegal names are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 6.1](img/B15554_Table_6.1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Table 6.1
  prefs: []
  type: TYPE_NORMAL
- en: Many languages are also case sensitive when it comes to variable names. What
    that means is that the `name`, `Name`, and `nAmE` variables will be treated as
    three different variables.
  prefs: []
  type: TYPE_NORMAL
- en: Many languages will also have what is known as naming conventions when it comes
    to how we construct and format variable names. There are also conventions for
    how to create names that are made up of more than one word. We will study these
    conventions next.
  prefs: []
  type: TYPE_NORMAL
- en: Camel case
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Camel case is where the words that make up a name are separated by an uppercase
    letter that starts each word. There are two sub-types—**upper camel case** (also
    known as **Pascal case**) and **lower camel case** (also known as **Dromedary
    case**). Some examples of variable names using upper camel case are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`FirstName`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EmailAddress`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ZipCode`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The same names would look like this in lower camel case:'
  prefs: []
  type: TYPE_NORMAL
- en: '`firstName`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`emailAddress`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`zipCode`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we can see, the first variant capitalizes all of the first letters of the
    words that make up a name, whereas the second variant leaves the first word in
    lowercase and only uses uppercase with the second word's first letter.
  prefs: []
  type: TYPE_NORMAL
- en: Languages that recommend this naming convention are Java, C#, and Pascal.
  prefs: []
  type: TYPE_NORMAL
- en: Snake case
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Separating words with an underscore is called snake case. When using this convention,
    we only use lowercase letters and separate words with an underscore character.
    Using this casing for the same variable names as the preceding examples would
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`first_name`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`email_address`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`zip_code`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Languages that use this convention for naming variables include Python, Ruby,
    C, and C++, in some circumstances.
  prefs: []
  type: TYPE_NORMAL
- en: What does it mean when we say a language has a convention for naming variables?
  prefs: []
  type: TYPE_NORMAL
- en: Naming conventions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Usually, a naming convention is a recommended way for naming things, such as
    variables. This means that we can break these rules and the program will still
    work. However, there are several good reasons for us to obey these recommendations.
    One could be that if many programmers are involved in writing some code, the style
    will be consistent and, therefore, more straightforward to interpret for human
    readers.
  prefs: []
  type: TYPE_NORMAL
- en: Some software companies have their own naming conventions. This is typically
    the case when the language itself has a weak or non-existing convention.
  prefs: []
  type: TYPE_NORMAL
- en: When coming across a new language, we should always learn its conventions. If
    you work on several projects that use different programming languages, it can
    be tricky to remember what convention to use.
  prefs: []
  type: TYPE_NORMAL
- en: Read more about naming conventions in [*Chapter 12*](B15554_12_Final_NM_ePub.xhtml#_idTextAnchor186),
    *Code Quality* in the *Using code conventions* section.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how to name a variable, let's explore the different types that
    a variable can have.
  prefs: []
  type: TYPE_NORMAL
- en: Primitive data types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every variable has both a name and a type. The type defines what kind of data
    can be stored in the variable. Typically, a language will have some built-in types,
    called primitive or basic types, to handle a single value.
  prefs: []
  type: TYPE_NORMAL
- en: Primitive types can be divided into two categories—Boolean and numeric—which
    we will look at next.
  prefs: []
  type: TYPE_NORMAL
- en: Boolean type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [*Chapter 1*](B15554_01_Final_NM_ePub.xhtml#_idTextAnchor016)*, Introduction
    to Computer Programs*, we talked about George Bool and his Boolean algebra. This
    defined how we can combine values of `true` and `false` with `and`, `or`, and
    `not`. To be able to use these values in our programs, we have a type that is
    named after Bool, called Boolean. A variable that uses this type can only have
    one of two values—`true` or `false`. For languages that have these types, we use
    the actual `true` and `false` words.
  prefs: []
  type: TYPE_NORMAL
- en: Languages that have this type either call it `Boolean` or just `bool`.
  prefs: []
  type: TYPE_NORMAL
- en: Numeric type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Numeric types fall into one of two categories—integer types and floating-point
    types. We will look at them in detail, next.
  prefs: []
  type: TYPE_NORMAL
- en: Integer data types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first question you could ask yourself here is why are we talking about types
    in plural when it comes to integers? You could argue that data is either an integer
    or not. As it turns out, many languages will have several types for representing
    integer values and the reason for this has to do with how much memory is used
    for the data and how that data should be interpreted.
  prefs: []
  type: TYPE_NORMAL
- en: As we saw earlier in this chapter, a language will define how much memory to
    use when storing data in a variable. When working with integers, we might only
    work with small values in a predefined range, such as the age of a human, or the
    values might be huge, such as the distance between stars.
  prefs: []
  type: TYPE_NORMAL
- en: If we think about the characteristics of the data we are working with, we will
    discover that it has natural limitations. The age of a human, for example, will
    never have a negative value, and if we take the highest human age recorded (122
    years, at the time of writing) and add some years to be on the safe side, we could
    state that a valid human age will fall into the range of 0 to 150\. One byte—remember
    that one byte is 8 bits (8 zeros or ones)—can work with numbers in the range 0
    to 255, so that is more than enough to store human age.
  prefs: []
  type: TYPE_NORMAL
- en: If we instead talk about the distance between us and other stars, we have a
    different range of values. The closest star, except for our own sun, are the two
    stars in the Alpha Centauri system. They are just over 4 lightyears away. The
    furthest star that we have observed, known by the name MACS J1149+2223 Lensed
    Star 1, is 9 billion lightyears away. So, if we are working with these values,
    we still would not need any negative numbers and the range would be between 4
    and 9,000,000,000.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, we need to work with both negative and positive numbers—for example,
    if we are writing some accounting software.
  prefs: []
  type: TYPE_NORMAL
- en: This means that integer values can have different properties, and for that reason,
    we have more than one integer type so that we can find one that fits our needs.
    As we don't need any negative numbers and the maximum won't ever exceed 150 as
    a value for human age, a type that can work with huge or negative numbers would
    be a waste of the computer's memory.
  prefs: []
  type: TYPE_NORMAL
- en: With this knowledge, programming languages are often implemented with several
    different integer types that differ in how much memory (measured in bytes) they
    will use to represent a value. The programmer's task is to pick one that matches
    the properties for the data that will be handled by the variable that has this
    type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Different languages will have a different set of integer types, but here are
    some typical integer types, their sizes, and the range of values that they can
    handle:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 6.2](img/B15554_Table_6.2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Table 6.2
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, all the preceding types include negative as well as positive
    values. Representing both will limit how a type can serve large numbers. Taking
    human age as an example again, we will see that the byte type wouldn't really
    work as although it has a maximum value of 127, it has 128 negative values that
    we would never use.
  prefs: []
  type: TYPE_NORMAL
- en: The reason why we have this restriction has to do with how negative numbers
    are represented.
  prefs: []
  type: TYPE_NORMAL
- en: Signed and unsigned integers
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If we look at the smallest type in the preceding table—the byte—and think about
    how negative numbers can be represented, we will see that we have a problem. When
    working with binary numbers, we have several bits that can store either `0` or
    `1`, but we don't have any other values, so we can't just insert a minus sign
    to indicate that this is a negative number. Instead, one of the following three
    methods can be used.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see how they work.
  prefs: []
  type: TYPE_NORMAL
- en: Signed Magnitude Representation (SMR)
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Even if the name is a bit complicated, this is the easiest way to represent
    negative values in binary form. Imagine that we are working with one byte that
    gives us eight bits to represent a value. However, if we assign one of the bits
    to represent whether this is a positive or negative value, we are left with just
    seven bits for the actual value:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.5 – A byte using only 7 bits to represent a value—127, in this case](img/B15554_06_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.5 – A byte using only 7 bits to represent a value—127, in this case
  prefs: []
  type: TYPE_NORMAL
- en: 'If we use the bit to the left in the preceding diagram—often referred to as
    the most significant bit as it is the bit representing the highest value—to represent
    whether the rest should be considered either positive or negative, the rest of
    the bits can form a maximum value of `127`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.6 – Using the most significant bit to represent a positive value—29,
    in this case](img/B15554_06_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.6 – Using the most significant bit to represent a positive value—29,
    in this case
  prefs: []
  type: TYPE_NORMAL
- en: 'If we designate the first position to indicate whether this is a positive or
    a negative value, we can use `0` to show that this is a positive value and `1`
    to show that this is a negative one:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.7 – Using the most significant bit to represent a negative value,
    -29, in this case](img/B15554_06_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.7 – Using the most significant bit to represent a negative value, -29,
    in this case
  prefs: []
  type: TYPE_NORMAL
- en: Using this technique, we have a range of values from `-127` to `127` using a
    single byte. We will also have two representations for 0—positive and negative.
    This is one disadvantage of this method and a reason why it is not used so often.
  prefs: []
  type: TYPE_NORMAL
- en: Another problem with this technique is found when performing mathematical operations,
    such as addition, on two values that use SMR.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figures 6.8 to 6.12* illustrate what happens if we add `3` and `c` together
    if we have used SMR to represent a negative value. To understand the diagrams,
    imagine that you add two decimal numbers. If you want to add `495` and `572`,
    we will put one above the other and start to add them column by column:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15554_06_31.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We then do the same for the next column, but as we get a value larger than
    `9`, we have to carry:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15554_06_32.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'When adding the last column, we use the carried number as part of the numbers
    we add:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15554_06_33.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We can apply the same principle for adding binary numbers. The only difference
    is that we now work with just two digits. So, instead of `10`, we will need to
    carry a value as soon as the result is greater than 1\. Now, when adding two bits
    that can be either `0` or `1`, we only end up with three different results—0,
    1, or 2 (in decimal). If we consider that we need to add two values and one potential
    carried value, the maximum will be 1 + 1 + 1 = `3`. Now that we know the maximum
    value we can possibly get (3), we can translate it into binary. `3` in binary
    is `11`. This means that our possible results will be 0, 1, 10, and 11\. 0 and
    1 fit within a single bit, but `10` and `11` do not, so here, we will need to
    carry 1.
  prefs: []
  type: TYPE_NORMAL
- en: 'As guidance, let''s use a table to convert between decimal and binary values:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 6.3](img/B15554_Table_6.3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Table 6.3
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s also see another table that helps us understand how binary addition
    works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 6.4](img/B15554_Table_6.4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Table 6.4
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the last three operations resulted in two digits, so all of
    them will result in a carry.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how we can apply this principle when adding binary numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.8 – Adding two values, 3 and -3, where the negative number is represented
    using SMR](img/B15554_06_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.8 – Adding two values, 3 and -3, where the negative number is represented
    using SMR
  prefs: []
  type: TYPE_NORMAL
- en: 'When we want to add two binary numbers, we do the same thing that we did with
    decimal numbers. The only difference is that we can only handle results that are
    0 or 1\. If the result is 2, we need to carry 1 to the next position:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.9 – Step one is to add the two rightmost bits—1 + 1 = 2](img/B15554_06_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.9 – Step one is to add the two rightmost bits—1 + 1 = 2
  prefs: []
  type: TYPE_NORMAL
- en: From the preceding diagram, we can see that as 2 in binary is 10, we insert
    0 at this location and carry 1.
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that in the next step, we have three values—1 + 1 + 1\. As the result
    will be 3, which is 11 in binary, we insert a 1 in this position and carry 1 to
    the next round:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.10 – Repeating the operation for the next two bits](img/B15554_06_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.10 – Repeating the operation for the next two bits
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we now have several positions where we add zeros together,
    but we must remember that we have carried 1 the first time:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.11 – For the third pair of bits, we are adding two zeros with the
    carry](img/B15554_06_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.11 – For the third pair of bits, we are adding two zeros with the carry
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now repeat this all the way to the last position. This is our sign bit:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.12 – The next four bits are just zeros with no carry, so they will
    all result in zeros](img/B15554_06_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.12 – The next four bits are just zeros with no carry, so they will
    all result in zeros
  prefs: []
  type: TYPE_NORMAL
- en: 'As we are adding a positive value (3) with a negative value (-3), we have `0`
    at this position for the first value and `1` in the second to indicate that the
    value is negative. As 0 + 1 is 1, this indicates that the result is negative:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.12 – When we add the bit used as a sign bit, the result will be
    1, indicating that the result is negative](img/B15554_06_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.12 – When we add the bit used as a sign bit, the result will be 1,
    indicating that the result is negative
  prefs: []
  type: TYPE_NORMAL
- en: To our surprise, we discover that the result of adding 3 and -3 is not 0 as
    we expected but -6, as we have 4 plus 2, which is 6, and 1 at the first position,
    indicating that this is a negative number.
  prefs: []
  type: TYPE_NORMAL
- en: This is another reason why this method is not used that often.
  prefs: []
  type: TYPE_NORMAL
- en: Ones' complement
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another approach to representing negative numbers that will address the problem
    we saw when we tried to add a positive and a negative value is the use of something
    called ones' complement. It also uses the most significant bit (the leftmost bit
    in our illustrations) as the sign bit but stores negative numbers differently
    compared to SMR.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we have a positive value, we can use 3 again as an example, and if we store
    it in a byte, we get 0000 0011, as we can see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.13 – Storing positive 3 in a byte](img/B15554_06_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.13 – Storing positive 3 in a byte
  prefs: []
  type: TYPE_NORMAL
- en: 'To store -3, we flip all the bits, so 0 becomes 1 and vice versa, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.14 – Storing -3 using ones'' complement. All values are the opposite
    of when we store positive 3](img/B15554_06_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.14 – Storing -3 using ones' complement. All values are the opposite
    of when we store positive 3
  prefs: []
  type: TYPE_NORMAL
- en: 'As we can see, all the bits are the opposite compared to when we stored a positive
    3\. When this number is interpreted, the sign bit is checked first. If it is 1,
    all the other bits are then flipped to form the actual value. This might seem
    like a strange thing to do, but let''s see what happens when we add the two together:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.15 – Adding 3 and -3 where the negative number is represented using
    ones'' complement](img/B15554_06_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.15 – Adding 3 and -3 where the negative number is represented using
    ones' complement
  prefs: []
  type: TYPE_NORMAL
- en: 'As we can see in the preceding diagram, we add 1 and 0 for each location. The
    result will, therefore, be 1 in every position, as we can see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.16 – The result of adding the two bytes will be 1 in all locations](img/B15554_06_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.16 – The result of adding the two bytes will be 1 in all locations
  prefs: []
  type: TYPE_NORMAL
- en: 'As we have 1 for the signed bit, this means that we have a negative result,
    so all the other bits need to be flipped and the result will be -0\. Now, this
    is better as 3 + (-3) is 0, but negative 0 does not mean anything. This means
    that this method also has the same problem as SMR, where we have two representations
    of the value 0—one positive and one negative:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.17 – As the sign bit is 1, all the other bits need to be flipped,
    forming negative 0](img/B15554_06_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.17 – As the sign bit is 1, all the other bits need to be flipped, forming
    negative 0
  prefs: []
  type: TYPE_NORMAL
- en: Let's see whether we can tackle this problem and find a representation that
    works.
  prefs: []
  type: TYPE_NORMAL
- en: Two's complement
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To solve the problem of two zeros in ones' complement, a third method for representing
    integer values exists, which is called two's complement. It works in the same
    way as ones' complement but with a twist.
  prefs: []
  type: TYPE_NORMAL
- en: The first step is to use ones' complement to represent a negative number, which
    takes the positive value and flips all the bits. But when that is done, we add
    1 to the result. Now, this might seem like we are messing the result up totally,
    but as we will see, it solves the problem with the double zero representation.
  prefs: []
  type: TYPE_NORMAL
- en: 'See *figures 6.18 to 6.21* to see how this works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.18 – Representing the value 3 in a byte](img/B15554_06_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.18 – Representing the value 3 in a byte
  prefs: []
  type: TYPE_NORMAL
- en: 'Representing a positive value is done just the same as before. However, when
    dealing with negative numbers, we do things differently:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.19 – Representing -3 in the two''s complement form](img/B15554_06_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.19 – Representing -3 in the two's complement form
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we take all the bits from the positive representation and flip them,
    so 0 becomes 1 and vice versa:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.20 – When adding 3 and -3, we do what we did before. 1 + 1 = 10,
    so 0 goes to this position and 1 is carried](img/B15554_06_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.20 – When adding 3 and -3, we do what we did before. 1 + 1 = 10, so
    0 goes to this position and 1 is carried
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding the bits together is done in the same way as before:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.21 – For all positions, we have 1 carry, so we will add 1 + 1 +
    0 = 10](img/B15554_06_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.21 – For all positions, we have 1 carry, so we will add 1 + 1 + 0 =
    10
  prefs: []
  type: TYPE_NORMAL
- en: When adding the sign bit to the left, we get a carry. The two's complement method
    states that this carry should be discarded.
  prefs: []
  type: TYPE_NORMAL
- en: We can see that the result of this operation is a byte with only zeros, giving
    us a single representation of 0 as a result.
  prefs: []
  type: TYPE_NORMAL
- en: As two's complement solves both the problem with the binary representation of
    zero and the problem of adding two values together, this is the one that is most
    frequently used.
  prefs: []
  type: TYPE_NORMAL
- en: Unsigned integers
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Some languages will let us work with integer types that use all bits as values.
    This allows us to work with only positive integers, but they can, on the other
    hand, be twice as big because we use all the bits to store values.
  prefs: []
  type: TYPE_NORMAL
- en: Not all numerical values are integers, so let's now look at another group of
    numerical data types—floating-point types.
  prefs: []
  type: TYPE_NORMAL
- en: Floating-point types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Representing floating-point numbers using the binary form is tricky, and as
    a programmer, we soon discover some oddities that relate to this. Let''s look
    at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We would expect the result stored in the variable result to be `0.3`, but in
    many languages, this will instead be something like `0.30000000000000004`.
  prefs: []
  type: TYPE_NORMAL
- en: The reason we get odd results like this is that we try to represent a decimal
    floating-point number as a binary floating-point number. We will not go into too
    much detail about how floating-point numbers are represented in a computer as
    it will get a bit complicated. If you want to learn how this is done, you can
    search for it online and see lots of detailed explanations for how it works.
  prefs: []
  type: TYPE_NORMAL
- en: But what we will do is to think about the problem the computer faces when dealing
    with a binary representation of a decimal number.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our decimal positional system, each position in a number has a value, as
    we saw earlier. This is just as true for floating-point numbers as for integers.
    For a floating-point number, the positions have values, as illustrated:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.22 – The values that the different positions have in the decimal
    system, to the left and right of the decimal point](img/B15554_06_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.22 – The values that the different positions have in the decimal system,
    to the left and right of the decimal point
  prefs: []
  type: TYPE_NORMAL
- en: 'Using this system makes it easy for us to store a value—for example, one-tenth
    can be written as 0.1\. In binary, the positions are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.23 – The values that the different locations have in the binary
    system,'
  prefs: []
  type: TYPE_NORMAL
- en: to the left and right of the decimal point](img/B15554_06_24.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.23 – The values that the different locations have in the binary system,
    to the left and right of the decimal point
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, no value represents one-tenth, so something else needs to be
    done. What computers do is store floating-point values in scientific notation.
    Representing the `300` decimal value in scientific form come to ![](img/Formula_06_001.png).
    The computer does this but in binary form and divides the value into three parts.
    The first is the sign, just as we saw for integer values. The second part is the
    exponent used and the last part is called the mantissa. The mantissa is the decimal
    part of a logarithm to base 10 (that is, a decimal number). If that means nothing
    to you, don't worry. You don't need to understand the math to be able to use floating-point
    numbers. However, we must understand why numbers don't always come out the way
    we expect them to.
  prefs: []
  type: TYPE_NORMAL
- en: To illustrate this, we can think about what happens if we calculate 1/3\. We
    will get `0.333333333…`, where we will have an infinite number of threes. The
    same thing happened when we tried to represent `0.1` using binary numbers. The
    result will be a value that goes on forever in the binary form. The problem is
    that the computer does not have an infinite amount of memory, so when the amount
    that is assigned to this type runs out, it will just stop, which means that we
    will not have an accurate representation of the number. That is why we got `0.30000000000000004`
    instead of `0.3` when we added `0.1` and `0.2` together in the preceding example.
  prefs: []
  type: TYPE_NORMAL
- en: Without going into the math of how floating-point numbers are represented, we
    need to understand the two most frequent types for representing them that we find
    in programming. They are usually called **float** and **double**.
  prefs: []
  type: TYPE_NORMAL
- en: The difference between them is that a float will usually use 32 bits and a double
    will use 64 bits. This means that the double has more memory to use before it
    chops off a number. It is named double because it has double precision compared
    to the float type.
  prefs: []
  type: TYPE_NORMAL
- en: What we can learn from this is that if precision matters in our application,
    we should use a double, but if not, we can use a float. If, for example, we want
    to store outside temperatures, a float will be fine to use as we never deal with
    that many decimals.
  prefs: []
  type: TYPE_NORMAL
- en: We can now work with integer and floating-point numbers, but sometimes we want
    to represent other kinds of values, such as complex numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Some programming languages have a special type for working with complex numbers.
    Some examples of languages that use this type are Go, C++, Python, and Ruby.
  prefs: []
  type: TYPE_NORMAL
- en: There is also another numeric type, even if we often think of it as something
    else—the character type.
  prefs: []
  type: TYPE_NORMAL
- en: 'A character that is a letter, a punctation mark, or any other character that
    we can come up with can be represented as a number. Many programming languages
    will provide a special type that is meant to handle a single character, but under
    the hood, it is an integer type. It is treated in a different way than the other
    numeric types that we have seen, as we can assign not only numbers to it but also
    characters, surrounded by some quotation marks—often single quotes. It can look
    something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Here, we assign the `a` character to a variable called `character_a`. The character
    is surrounded by single quotes to indicate that this is a character and not a
    variable named `a`. What happens is that the numerical value for this character
    is assigned to the variable. The character value for lowercase `a` is `97`, so
    in this case, that is what will be stored in the variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'To print the content of the variable to the screen, type the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We will see `a` printed, not `97`, as the programming language will know that
    this is a character type and not a normal numeric type and will translate the
    numerical value back to the character representation again.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, we need to store more than one value at a time. Then, we can use
    what are called **composite types**.
  prefs: []
  type: TYPE_NORMAL
- en: Composite type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A composite type is a data type that is made up of more than one value. There
    are situations when keeping several related values together makes sense. In our
    everyday life, we do this often. A shopping list is an example. Instead of having
    several papers, each one having one item we need to buy, we store all the items
    on one piece of paper and call this a list.
  prefs: []
  type: TYPE_NORMAL
- en: This is how a composite type works in programming as well. We have several types
    that all have some specific characteristics. The first one can be used when we
    want to represent a sequence or list of things. This is often called an array.
  prefs: []
  type: TYPE_NORMAL
- en: An array—also called a vector, list, or sequence—is a data type that stores
    several elements. This number can be fixed or flexible.
  prefs: []
  type: TYPE_NORMAL
- en: Fixed array
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When we have a fixed size array, we say how many slots we want it to have when
    we create it. This size will not change. If we create an array that can store
    10 integers, it will reserve space for 10 integers, even if we only use 3 or 5.
  prefs: []
  type: TYPE_NORMAL
- en: 'Typically, we would create a fixed-size array as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here, we say that we want an array that can store 10 integers and we call it
    `numbers`. We are not storing any values in the array, so we say that these 10
    locations are unassigned, but we have space in memory reserved for us, and we
    have a name that we can use to access this space.
  prefs: []
  type: TYPE_NORMAL
- en: We can see this as if we have 10 different variables. The only difference is
    that we store all 10 variables under the same name.
  prefs: []
  type: TYPE_NORMAL
- en: We will now need a way to address these variables individually. This is done
    by indexing.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can index into the array by using its name and an index value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we store `44` at position `2` in the array. You might think that position
    `2` is the second value in the array, but it is actually the third. The reason
    for this is that the index starts at 0, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.24 – Inserting 44 at index 2 will place the value in the third position
    of the array](img/B15554_06_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.24 – Inserting 44 at index 2 will place the value in the third position
    of the array
  prefs: []
  type: TYPE_NORMAL
- en: The reason that the indexing starts at 0 and not 1 is that we can think of the
    name that we used for this array as a reference to the first location in the array.
    When using an index, we say how many places we should move forward. So, `numbers[2]`
    means we start at the first location and move forward 2 integers in memory. That
    is the location you should store the value at.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also retrieve a value from a given index, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code prints the value that is located at index `2`, which is the
    third value in the array.
  prefs: []
  type: TYPE_NORMAL
- en: Having an array of a fixed size can be problematic as it is not always the case
    that we know how many values we need to store. If this is the case, then we can
    use another type of array that can grow and shrink as we use it. This is sometimes
    called a dynamic array.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic array
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A dynamic array (or list, vector, or sequence) is an array that can grow and
    shrink as we use it. Initially, this kind of array will be empty when we first
    create it, but we can then add and remove things from it as we go along. How we
    create these arrays will differ from language to language, but it can look something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are creating an empty dynamic array.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now add and remove things from this array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Here, we first add three values—`10`, `11`, and `12`. Values are usually added
    at the end, so they will be stored in the `10`, `11`, `12` order.
  prefs: []
  type: TYPE_NORMAL
- en: On the last line, we remove the `11` value. The array now has the `10` and `12`
    values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Often, we will have different ways to dictate where in this array new values
    should be added and removed. We might, for example, be able to do something like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'From the preceding code, we can see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: We add the `10` value to the back of the empty array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we add the `11` value to the beginning of the array. We now have `11`,
    `10`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we add `12` to the back, giving us `11`, `10`, `12`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the last line, we add `13` to the front of the array. We now have the `13`,
    `11`, `10`, and `12` values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can often use an index, just as with a fixed size array, to retrieve individual
    values from a dynamic array. The problem is that we need to keep track of how
    many items we currently have in the array. This is important because if you have
    an array of let's say five things and you say that you want to get item number
    10, you are looking outside the array and your programming language will most
    likely halt the execution of the program as you are doing something that is considered
    illegal (according to your language, that is.)
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic arrays come at another cost as well. When we create a fixed-size array,
    a big enough chunk of memory will be found, and we can then go ahead and use this.
    All the items in the array must come sequentially in memory because that is what
    makes indexing work. As we saw, the name of the array will tell us the starting
    location for this array, and we then use an index to say how many steps into the
    memory we need to move to come to the correct place.
  prefs: []
  type: TYPE_NORMAL
- en: When using a dynamic array, this might be a problem. If we add item after item,
    we will eventually hit a memory location where something else is located. Our
    array will now need to move to another location that is big enough for all the
    values we already had in it, plus the new value that we want to add. As a programmer,
    this is not a usual task. The language does this for us, but copying all the old
    values from the original location to this location will take time. This is the
    cost we pay for the freedom of having a structure that can grow and shrink depending
    on our needs.
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages will only let you store data of the same type in
    an array. There are a few, however, that will allow you to mix the types as you
    wish.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, we want to store values that are related in another way—let's say
    information about a person. Then, we can use what is called a record.
  prefs: []
  type: TYPE_NORMAL
- en: The record type
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are writing an application and you want to represent information about,
    say, customers, you will first need to decide what information you want to handle.
    This might be the customer's first and last name, a street address, a city, a
    ZIP code, and so on. This might include data of different types. It would also
    be handy if you could retrieve the different items with the help of a name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Records are sometimes called structures or structs. To use them, we first need
    to define what they look like. This can look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: What we are doing here is defining a new type called `Person`. One variable
    of this type can store a first name, last name, street address, city, and ZIP
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating a variable of this type might look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We now have a variable called `person1`, but we do not store any data in it
    yet. Doing so might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'All the information we have about this person is now stored in the `person1`
    variable. We can now create other `person` variables to store information about
    other people:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also retrieve the data stored within these variables, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have a relationship between a variable name, `firstName`, for example,
    and some data—`Anna`, `Bob`, and `Colette`. We know about this relationship beforehand,
    so the record structure is perfect for us. Sometimes, we might not know what we
    will get, but the data might still come in pairs. Then, we can use another data
    type known as a dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: The dictionary type
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A dictionary (also known as a map, hash map, or associative array) is a collection
    type that uses key-value pairs. The key needs to be a unique value that we can
    use to retrieve the value that is associated with it.
  prefs: []
  type: TYPE_NORMAL
- en: A colon often separates the key and the value.
  prefs: []
  type: TYPE_NORMAL
- en: 'They might look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are using the name of some famous books as the keys, and the value
    associated with each key is the author of that book. As we stated before, the
    key needs to be unique. If we reuse the key and assign another value to it, the
    old value will be overwritten by the new one.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can access the values—the names of the authors, in our case—by using the
    key as an index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This will give the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'As it is only the key that needs to be unique, we can have multiple items that
    have the same value. We can, for example, add a book to the dictionary as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We now have two values containing `Charles Dickens`, but they are associated
    with two different and unique keys.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, we have other reasons for storing unique values. We might want to
    represent what in mathematics is known as finite sets. For that, we also have
    the set type.
  prefs: []
  type: TYPE_NORMAL
- en: The set type
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A set is a composite type that will store unique values without any order. As
    this type is unordered, we cannot retrieve items from it with an index. This is
    usually not a problem as this type is often used to test for membership. You might,
    for example, have two sets with some values in them and would like to know which
    values occur in both sets.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how we might create these two sets and then print the values that
    occur in both:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In set theory, an intersection between two sets are the values that exists in
    both sets.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of this will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This output is represented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.25 – Representation of two sets that has an intersection of 2 and
    9 as'
  prefs: []
  type: TYPE_NORMAL
- en: these two values exist in both sets](img/B15554_06_26.jpg)
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.25 – Representation of two sets that has an intersection of 2 and 9
    as these two values exist in both sets
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, we want to create a new type so that we can dictate what values can
    be assigned to variables that are of this type. For this, we have enumeration.
  prefs: []
  type: TYPE_NORMAL
- en: Enumeration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Enumeration, often called just **enum**, is an enumerated type with distinct
    values. We can use this to create our types and dictate what values can be assigned
    to a variable that has this type.
  prefs: []
  type: TYPE_NORMAL
- en: 'It can look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '`TrafficLight` is now a type and we can use it to create variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'As both `light1` and `light2` are of the `TrafficLight` type, we can only assign
    the things we described inside this type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Behind the scenes, there are numerical values associated with each of the items
    in the enum. In our case, `red` will be `0`, `yellow` is `1`, and `green` is `2`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we have seen that we can work with Boolean values, numbers, characters,
    and different composite types, but you might notice that we're missing one type.
    We have still not seen a type that can handle text. It is time to look at strings.
  prefs: []
  type: TYPE_NORMAL
- en: Strings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A string is a composite type as it is stored as an array of characters. Most
    languages will use double quotes to designate that something is a string and will
    use single quotes for single characters. Some languages will let you use either
    single or double quotes for both types. Here, we will use double quotes for strings
    and single quotes when we only have a single character.
  prefs: []
  type: TYPE_NORMAL
- en: 'Usually, we will not consider a string an array. We can create a string as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we created a variable of the string type, called `greeting`, and assigned
    a `Hello there` value to it. Behind the scenes, an array of characters will be
    created and each character in the string will be assigned to one location in this
    array, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.26 – The Hello there string stored as an array, where each item
    is a character](img/B15554_06_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.26 – The Hello there string stored as an array, where each item is
    a character
  prefs: []
  type: TYPE_NORMAL
- en: 'As a string is an array of characters, we can use an index to access individual
    characters. As an example, let''s print the character at position `7`, which is
    the eighth character:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Now that we can handle data in different formats, we can move on to do something
    with this data. It is time to look at operators.
  prefs: []
  type: TYPE_NORMAL
- en: Operators – things we can do with variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [*Chapter 5*](B15554_05_Final_NM_ePub.xhtml#_idTextAnchor081)*, Sequence
    – The Basic Building Block of a Computer Program*, we talked about how a statement
    is made up of expressions and that expressions can be made up of operations or
    operands.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see an example of this. Here, we will create two variables and assign
    a value to each of them. Then, we will add the two values together and store the
    result in a new variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'In line one, we created a variable called `number1` and assigned a value of
    `10` to it. We now know that this means several things:'
  prefs: []
  type: TYPE_NORMAL
- en: The variable name is `number1`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As it is assigned an integer, it must be of an `integer` type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `=` sign is an operator, taking whatever is on the right and assigning it
    to what we have on the left.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Somewhere in the computer's memory, enough space for an integer has been reserved.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The name, `number1`, will act as an alias for this address.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We then do the same thing in line two, the only difference being that we have
    another name for the variable, `number2`, and we assign it another value, `15`.
  prefs: []
  type: TYPE_NORMAL
- en: On the third line, we use the addition operator. This operator has two operands—`number1`
    and `number2`. It will now extract the values in these two variables, add them
    together, and return the result.
  prefs: []
  type: TYPE_NORMAL
- en: This operation will result in a value of `25`, which is what will be assigned
    to the variable result. As a result of the addition operation giving us another
    integer, we now also know that the variable result will also have the `integer`
    type.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at some operators for basic arithmetic.
  prefs: []
  type: TYPE_NORMAL
- en: Arithmetic operators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Most programming languages share the symbols used for basic arithmetic operations.
    Refer to the following table to see the most common ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 6.5](img/B15554_Table_6.5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Table 6.5
  prefs: []
  type: TYPE_NORMAL
- en: The last one, the modulus operator, might not be familiar to you. It is often
    used in programming as it has some features that can be handy when working with
    numbers. We can illustrate what it does with a simple example. If we calculated
    `16/13`, we would get a result of `1.230769…`. The integer part, `1`, tells us
    that `13` goes once into `16`. What the modulus operator does is tells us how
    much there is left to get to `16`. So, if `13` goes once into `16`, we must add
    `3` to `13` to get to `16`.
  prefs: []
  type: TYPE_NORMAL
- en: We would express that with `16 % 13` and get a result of `3`. If you have not
    worked with modulus before, I suggest you search it up online to get an understanding
    of how it works as it is something that you will find very useful as a programmer.
  prefs: []
  type: TYPE_NORMAL
- en: Next up, we have some operators that we can use to compare things.
  prefs: []
  type: TYPE_NORMAL
- en: Relational operators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Relational operators are used when we want to compare two values. They can
    be equal or not equal. We might want to know whether one value is greater than
    the other. The following table lists the relational operators that are typically
    found in programming languages:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 6.6](img/B15554_Table_6.6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Table 6.6
  prefs: []
  type: TYPE_NORMAL
- en: With these operators, we can compare two values, but sometimes we have more
    values to compare. In this case, we will need logical operators.
  prefs: []
  type: TYPE_NORMAL
- en: Logical operators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'These operators are used to represent `and`, `or`, and `not`. Some languages
    will use these exact words to represent them, but others will have special signs
    for them. They are used in statements such as `if the age is greater than 12`
    and `age is less than 20`. In code, that would look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The three operators we can use are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 6.7](img/B15554_Table_6.7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Table 6.7
  prefs: []
  type: TYPE_NORMAL
- en: Most languages will have more operators than the ones we have seen here. We
    will not cover them here as some are combination operators, which is a combination
    of two of the operators we have seen here, and others are specialized for one
    or a few languages.
  prefs: []
  type: TYPE_NORMAL
- en: Next up, we will look at two different ways that variables can be stored in
    memory and why that concerns us.
  prefs: []
  type: TYPE_NORMAL
- en: The concept of values and reference variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are two ways that a variable can store its value in memory. We could think
    of these ways as direct and indirect. This might sound strange, but let's use
    an analogy to explain.
  prefs: []
  type: TYPE_NORMAL
- en: 'The variables that directly store their data are like boxes. When we create
    them, we can think of them as a box that has the name of the variable stuck to
    it with a label. We can store the value inside the box and look in the box later
    to see what value is in there. Variables that store their values like this are
    called **value variables**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.27 – A variable that stores its data by value is like a box](img/B15554_06_28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.27 – A variable that stores its data by value is like a box
  prefs: []
  type: TYPE_NORMAL
- en: 'Variables that use indirect storage will act as an index card in a library.
    It will not store the book but will have the location where it is stored, so it
    only contains the address to where in memory the actual value is. Variables that
    store values like this are called **reference variables**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.28 – Variables that store data by reference are like a library index
    card](img/B15554_06_29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.28 – Variables that store data by reference are like a library index
    card
  prefs: []
  type: TYPE_NORMAL
- en: Let's see how they both work.
  prefs: []
  type: TYPE_NORMAL
- en: Value variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When we create a variable—or declare it, as we would usually say—of a type,
    several things will happen, as we saw at the beginning of this chapter. Let''s
    see what will happen when the following code line is executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: As we now know, a chunk of memory that is large enough to host an integer is
    located, and this location has an address. The name we give the variable—`x`,
    in the preceding example—is just an alias for this address. It is much easier
    for us to remember that a variable called `firstName` stores a name instead of
    having to remember that the first name was at the `38892819283` address.
  prefs: []
  type: TYPE_NORMAL
- en: When our code is interpreted or compiled, the variable name is changed to the
    actual address, but that is luckily not anything that we will ever see. As this
    is a variable that stores its data by value, there is a direct relationship between
    where the data is and the variable name.
  prefs: []
  type: TYPE_NORMAL
- en: Reference variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When it comes to reference variables, there is an extra step between the variable
    name and where the data is. Let''s see what happens when we create a reference
    variable with another code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`weather = "Sunny"`'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, the data will still need to be stored somewhere, so a memory
    location for it is found and as before, the address of where this is is noted.
    However, the difference is that the variable name is not an alias for this address.
    Instead, the address for where the data is is stored at another location in memory
    and the variable is an alias for that location. The following diagram illustrates
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.29 – A variable named weather as a reference variable](img/B15554_06_30.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.29 – A variable named weather as a reference variable
  prefs: []
  type: TYPE_NORMAL
- en: This might seem pointless. Why can't we store the text string at the location
    pointed out by the `weather` variable? What is the point of this extra step? The
    answer is efficiency. In a program, we need to pass data around. The data that
    we have in a variable in one part of the program needs to be passed along to another
    part. Imagine that the data stored is much larger than the short text string in
    the preceding example; the actual passing of the data would mean that we need
    to make a copy of all the data. This takes some time, and we will now have two
    copies of the data, which will use twice as much memory. If a variable is of this
    reference type, we will not need to copy all the data. In the preceding example,
    this will mean that we will not need to copy `Sunny`. Instead, the `weather` variable
    contains the address to where this data is, so it can just pass the address.
  prefs: []
  type: TYPE_NORMAL
- en: How a language uses these two types will differ from language to language. When
    learning a new language, it is vital to learn how it works with value and reference
    variables.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have covered lots of things related to variables, we are now ready
    to use them. We will now see how we can work with numbers, and after that, we
    will look at text strings.
  prefs: []
  type: TYPE_NORMAL
- en: Working with numbers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Numbers are essential in computer programs. We use them to represent real-world
    concepts, such as the number of items in a shopping cart, the weight of a package,
    and the distance to a location. We also use them to represent internal things
    within our program, such as the number of characters in a name so that we can
    calculate whether it will fit on an address label if we print it. The point is,
    we use numbers all the time, so let's see what we can do with them.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we can do basic arithmetic, such as addition, subtraction, multiplication,
    and division, as in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we have two ages and we are calculating the medium age.
  prefs: []
  type: TYPE_NORMAL
- en: 'We often use numbers as counters of things. What this means is that we will
    use them to keep track of how many times we have done something. This means that
    we need to increase (and sometimes decrease) them by 1\. We could do this as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: To understand what happens here, we need to look to the right of the `=` sign
    first. Here, we have a variable called `count`. As this is just a line that is
    ripped out of its context, we can assume that it already has a value stored. This
    value is now used, and we add `1` to it. The result of this addition is then stored
    back in the variable count, and we have increased its value by 1.
  prefs: []
  type: TYPE_NORMAL
- en: 'As this is such a common thing to do in programming, some shorthands for this
    have been developed. As we are using the same variable on both sides of the `=`
    operator, we can skip one of them and instead use a different operator that looks
    something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This is the same as in the last example, but just shorter. We can read it as
    taking the value that is stored by the `count` variable, adding `1` to it, and
    storing the result back in `count`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some languages have taken this further and shortened this even more:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Again, the result will be the same as the other two. We can read this as increasing
    the value stored in `count` by `1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'All of the three examples we just saw can, of course, be done with subtraction
    too, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: When working with numbers, they can either be stored in a variable, as with
    `count`, or digits directly in the code, as is the case with `1` in the preceding
    examples.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, we will work with more complex mathematical formulas and do several
    things in one single line.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could have something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Formula_06_002.png)'
  prefs: []
  type: TYPE_IMG
- en: How would we write that in a program?
  prefs: []
  type: TYPE_NORMAL
- en: First, `x`, `a`, and `b` are variables in mathematics and will be variables
    in our program, too. `a + 3` and `7 – b` must be done before we can divide. We
    use an equation such as this as a recipe to calculate something. To use it, we
    insert some values for `a` and `b`. Then, we do the math, and `x` will be the
    result.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our program, we can, therefore, assume that `a` and `b` have some values
    given to them earlier in the program. So, let''s see how we can let the computer
    do the math for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Adding parentheses means that what is inside of them will be calculated first.
    So, if we imagine some values for `a` and `b`—let's say `a = 3` and `b = 4`—then
    `a + 3` will be calculated first, so we have `3 + 3 = 6`. Then, `7 – b` will be
    calculated, so `7 – 4 = 3`. At this point, we can imagine that `a + 3` is replaced
    by `6` and `7 – b` by `3`; we are left with `6 / 3`. The result, `2`, will be
    stored in `x`.
  prefs: []
  type: TYPE_NORMAL
- en: If basic algebra is not enough for us, most programming languages come with
    a vast library of mathematical functions that we can use, such as cosine, tangent,
    square root, and absolute value.
  prefs: []
  type: TYPE_NORMAL
- en: Another data type that programmers use a lot is strings. Let's look at some
    of the things we can do with them.
  prefs: []
  type: TYPE_NORMAL
- en: Manipulating strings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A string is a sequence of characters, and a character does not have to be a
    letter, it can be punctuation marks, a space, a hyphen, or any other character
    we can produce using a computer. A string can also contain digits.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we must understand is that a string only containing digits
    will not be the same as if it were an integer. Look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Notice the quotation marks around the digits in the last number. This turns
    it into a string. The first one, `numberA`, will be of the `integer` type, so
    it can be used for counting and other mathematical operations. For the computer,
    the second one is just as much a number as the word `dog` is—that is, not at all.
  prefs: []
  type: TYPE_NORMAL
- en: When working with strings, there are several typical things we can do with them.
    Let's look at some frequent string operations.
  prefs: []
  type: TYPE_NORMAL
- en: String concatenation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When we take two strings and add them together to form a new string, we call
    it concatenation. How this is done will differ a bit from language to language,
    but often, we can use the `+` operator, as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have two strings—`day` and `break`. The quote marks tell us that they
    are strings. They will now be concatenated into a new string that is stored in
    the `word` variable. This variable will contain the `daybreak` word.
  prefs: []
  type: TYPE_NORMAL
- en: Splitting strings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes, we want to split a string into multiple strings. To do this, we will
    often use a delimiter inside the string, which we can use to indicate where the
    string should be divided. Let's assume that we have a string that contains a first
    name and last name and that the names are separated by a comma, such as `Sue,Smith`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If that is stored in a variable called `name`, in some languages, we could
    do something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: As usual, we will begin by looking at the right side of the `=` operator. Here,
    we say that we have a string in a variable called `name`. We want to break up
    this string into two parts, so we use `split`. Inside the parentheses, we see
    a string. Again, we know that it is a string because it has quote marks and contains
    a comma. This is the character that will be used for the split. All characters
    that precede the comma inside the variable name will be sent to the first variable
    to the left, `firstName`. Everything after the comma will be sent to the second
    variable, `lastName`. The comma itself that is inside the variable name will be
    discarded.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also important to note that the content of the variable name has not
    changed, so if we peek into the variables after this line has executed, we can
    see that they contain the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The result can also be an array that contains the two strings. This would look
    something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The `splitName` variable will now be an array that contains two strings. Remember
    that the first position in an array is `0`, and in that location, we will find
    the `Sue` string, and at position `1`, we will find `Smith`.
  prefs: []
  type: TYPE_NORMAL
- en: Substrings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Substrings are used when we take part of a string to form a new string. How
    this is done will change from language to language. Here are some examples of
    what it might look like if we want to extract the `car` substring out of the `phonocardiogram`
    string.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we store `phonocardiogram` in a variable, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'In some languages, we can then do something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: This will begin extracting the substring from location `5` in the string. Just
    as with arrays, the counting will start at `0`. As the letter `c` is the sixth
    letter, the index we use will be `5`. Then, as per the code given, we end at `8`.
    But that looks like we went one letter too far. Commonly, we use two values as
    the start and end index. The first will state where to start and the second will
    point out the first things that are outside the range. We can read the preceding
    example as starting at location `5` and stopping at location `8` without including
    it.
  prefs: []
  type: TYPE_NORMAL
- en: After this line has executed, the `newWord` variable will contain the `car`
    string, and as before, the `word` variable will be unchanged.
  prefs: []
  type: TYPE_NORMAL
- en: 'Other languages will do something like the following instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Here, we use `substr` instead of square brackets. Also, note that `5` and `8`
    are separated by a comma here and that we used a semicolon in the first example.
  prefs: []
  type: TYPE_NORMAL
- en: 'A third variant would look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: In languages that use this form, the second value indicates how many characters
    we want instead of the end index. However, the result will be the same.
  prefs: []
  type: TYPE_NORMAL
- en: Case conversion
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Converting string casing is something we often want to do. The reason for this
    can, for example, be so that we can ask the user of our program to enter a text
    command, and then we will need to check what command the user entered. As an example,
    we can imagine that they entered the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Start`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Pause`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Stop`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will need to compare what the user wrote against these strings, but we have
    a problem. When we compare strings, they need to be cased the same to be equal.
    This means that `start`, `Start`, and `START` will all be different.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can''t compare all the combinations as they would be rather too many. For
    just the `start` word, we have the following variants:'
  prefs: []
  type: TYPE_NORMAL
- en: '`start`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Start`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`STart`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`StArt`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`STArt`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SRArT`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sTART`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`starT`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We could go on, but instead, let's just convert a string into either all uppercase
    or all lowercase. Then, we will know what form the string has.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can do this as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, the string can be converted as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '`lower` and `upper` will not change the original string that is inside the
    variable answer, but instead will create a new lowercase or uppercase version
    of this string. We will store this new version back into the variable, and by
    doing so, we will overwrite the old string with the new version where we know
    how it is cased.'
  prefs: []
  type: TYPE_NORMAL
- en: We have seen a few examples of things we can do with strings. This not all we
    can do, but consider these as some examples of some frequent operations that we
    can perform on strings.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered one of the two main pillars that programming rests
    on—how we can store, retrieve, and change data in the computer's memory using
    variables.
  prefs: []
  type: TYPE_NORMAL
- en: We learned that a variable has a name and a data type and that the type of the
    variable dictates what can be stored in it and how much memory it will use. We
    also learned how we could concisely name our variables and that there are naming
    conventions that we can use for guidance.
  prefs: []
  type: TYPE_NORMAL
- en: With that covered, we then talked about primary or primitive data types and
    saw that numbers are handled either as integers or floating-point numbers, which
    are further divided into different sizes, so we can pick a type that suits our
    needs and make sure we don't waste memory space.
  prefs: []
  type: TYPE_NORMAL
- en: Some data naturally comes in a sequence or in natural groups. For this data,
    we used a composite data type, and we saw that this type lets us work with groups
    of data.
  prefs: []
  type: TYPE_NORMAL
- en: We then talked about what operators are and how we can perform operations on
    variables using them, as well as what common operators are and some examples of
    how to use them.
  prefs: []
  type: TYPE_NORMAL
- en: A variable can be stored in memory either as a value or reference type. We learned
    that when it is stored as a value, the data it stores is located at the memory
    address of the variable. A reference variable does not save its value directly
    but stores an address to where the data can be found.
  prefs: []
  type: TYPE_NORMAL
- en: We used variables with numbers and performed some basic operations on them using
    our operators. In the end, we turned our attention to strings and looked at how
    we can manipulate them.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will introduce logic to our programs with proper selection
    so that we can do things only if a condition is met. We will also see how we can
    repeat the same thing several times with the help of loops.
  prefs: []
  type: TYPE_NORMAL
