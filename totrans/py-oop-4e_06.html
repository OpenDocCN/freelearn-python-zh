<html><head></head><body>
  <div><h1 class="chapterNumber">6</h1>
    <h1 id="_idParaDest-116" class="chapterTitle">Abstract Base Classes and Operator Overloading</h1>
    <p class="normal">We often need to make a distinction between concrete classes that have a complete set of attributes and methods, and an abstract class that is missing some details. This parallels the philosophical idea of abstraction as a way to summarize complexities. We might say that a sailboat and an airplane have a common, abstract relationship of being vehicles, but the details of how they move are distinct.</p>
    <p class="normal">In Python, we have two approaches to defining similar things:</p>
    <ul>
      <li class="bullet"><strong class="keyword">Duck typing</strong>: When two class definitions have the same attributes and methods, then instances of the two classes have the same protocol and can be used interchangeably. We often say, "When I see a bird that walks like a duck and swims like a duck and quacks like a duck, I call that bird a duck."</li>
      <li class="bullet"><strong class="keyword">Inheritance</strong>: When two class definitions have common aspects, a subclass can share common features of a superclass. The implementation details of the two classes may vary, but the classes should be interchangeable when we use the common features defined by the superclass.</li>
    </ul>
    <p class="normal">We can take inheritance one step further. We can have superclass definitions that are abstract: this means they aren't directly useable by themselves, but can be used through inheritance to create concrete classes.</p>
    <p class="normal">We have to acknowledge a terminology problem around the terms <em class="italic">base class</em> and <em class="italic">superclass</em>. This is confusing because they're synonyms. There are two parallel metaphors here, and we flip back and forth between them. Sometimes, we'll use the "base class is a foundation" metaphor, where another class builds on it via inheritance. Other times, we'll use the "concrete class extends a superclass" metaphor. The "super" class is superior to the concrete class; it's typically drawn above it on a UML class diagram, and it needs to be defined first. For example:</p>
    <figure class="mediaobject"><img src="img/B17070_06_01.png" alt="Diagram  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 6.1: Abstract base class</p>
    <p class="normal">Our base class, named <code class="Code-In-Text--PACKT-">BaseClass</code> here, has a special class, <code class="Code-In-Text--PACKT-">abc.ABC</code>, as a parent class. This provides some special metaclass features that help make sure the concrete classes have replaced the abstractions. In this diagram, we have added a big "A" circle to mark the class as abstract. This bit of decoration is optional, and often unhelpful, so we won't use it in other diagrams. The slanted font is another hint that the class is abstract. </p>
    <p class="normal">The diagram shows an abstract method, <code class="Code-In-Text--PACKT-">a_method()</code>, which doesn't have a defined body. A subclass must provide this. Again, a slanted font is used for the method name to provide a hint that it's abstract. The two concrete subclasses provide this missing method.</p>
    <p class="normal">In this chapter, we'll cover the following topics:</p>
    <ul>
      <li class="bullet">Creating an abstract base class </li>
      <li class="bullet">ABCs and type hints</li>
      <li class="bullet">The <code class="Code-In-Text--PACKT-">collections.abc</code> module</li>
      <li class="bullet">Creating your own abstract base class</li>
      <li class="bullet">Demystifying the magic – looking under the hood at the implementation of an ABC</li>
      <li class="bullet">Operator overloading</li>
      <li class="bullet">Extending built-ins</li>
      <li class="bullet">Metaclasses</li>
    </ul>
    <p class="normal">The case study in this chapter will build on the case study material in previous chapters. We'll be able to look closely at different ways to partition data among training sets and testing sets. </p>
    <p class="normal">We'll start by looking at how we use an abstract class and create a concrete class from it. </p>
    <h1 id="_idParaDest-117" class="title">Creating an abstract base class</h1>
    <p class="normal">Imagine we<a id="_idIndexMarker373"/> are creating a media player with third-party plugins. It is advisable to create an abstract base class (ABC) in this case to document what API the third-party plugins should provide (documentation is one of the stronger use cases for ABCs). </p>
    <p class="normal">The general design is to have a common feature, like <code class="Code-In-Text--PACKT-">play()</code>, that applies to a number of classes. We don't want to pick some particular media format to use as a superclass; it seems somehow wrong to claim that some format is foundational, and all others are derived from it. </p>
    <p class="normal">We'd prefer to define the media player as an <em class="italic">abstraction</em>. Each unique kind of media file format can provide a <em class="italic">concrete</em> implementation of the abstraction. </p>
    <p class="normal">The <code class="Code-In-Text--PACKT-">abc</code> module provides the tools to do this. Here's an abstract class that requires a subclass to provide a concrete method and a concrete property to be useful:</p>
    <pre class="programlisting code"><code class="hljs-code">class MediaLoader(abc.ABC):
    @abc.abstractmethod
    def play(self) -&gt; None:
        ...
    @property
    @abc.abstractmethod
    def ext(self) -&gt; str:
        ...
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">abc.ABC</code> class introduces a <strong class="keyword">metaclass</strong> – a class used to build the concrete class definitions. Python's default metaclass<a id="_idIndexMarker374"/> is named <code class="Code-In-Text--PACKT-">type</code>. The default metaclass doesn't check for abstract methods when we try to create an instance. The <code class="Code-In-Text--PACKT-">abc.ABC</code> class includes an extension to the <code class="Code-In-Text--PACKT-">type</code> metaclass to prevent us from creating instances of classes that are not fully defined.</p>
    <p class="normal">There are two <a id="_idIndexMarker375"/>decorators used to describe the placeholders in the abstraction. The example shows <code class="Code-In-Text--PACKT-">@abc.abstractmethod</code> and a combination of <code class="Code-In-Text--PACKT-">@property</code> and <code class="Code-In-Text--PACKT-">@abc.abstractmethod</code>. Python uses decorators widely to make modifications to the general nature of the method or function. In this case, it provides additional details used by the metaclass that was included by the <code class="Code-In-Text--PACKT-">ABC</code> class. Because we marked a method or property as abstract, any subclass of this class must implement that method or property in order to be a useful, concrete implementation.</p>
    <p class="normal">The bodies of the methods are actually <code class="Code-In-Text--PACKT-">...</code> . This three-dot token, the ellipsis, really is valid Python syntax. It's not a placeholder used only in this book; it's the Python code to remind everyone a useful body needs to be written in order to create a working, concrete subclass.</p>
    <p class="normal">We've used the <code class="Code-In-Text--PACKT-">@property</code> decorator on the <code class="Code-In-Text--PACKT-">ext()</code> method, also. Our intent for the <code class="Code-In-Text--PACKT-">ext</code> property is to provide a simple class-level variable with a string literal value. It's helpful to describe this as an <code class="Code-In-Text--PACKT-">@property</code> to allow the implementation to choose between a simple variable and a method that implements the property. A simple variable in the concrete class will meet the expectations of the abstract class at runtime and will also help <strong class="" style="font-style: italic;">mypy</strong> to check the code for consistent use of types. A method could be used as an alternative to a simple attribute variable in case some more sophisticated computation is required.</p>
    <p class="normal">One of the consequences of marking these properties is the class now has a new special attribute, <code class="Code-In-Text--PACKT-">__abstractmethods__</code>. This attribute lists all of the names that need to be filled in to create a concrete class: </p>
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; MediaLoader.__abstractmethods__
frozenset({'ext', 'play'})
</code></pre>
    <p class="normal">See what happens if you implement a subclass? We'll look at an example that doesn't supply concrete implementations for the abstractions. We'll also look at an example that does supply the required attribute:</p>
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; class Wav(MediaLoader): 
...     pass 
... 
&gt;&gt;&gt; x = Wav() 
Traceback (most recent call last): 
  File "&lt;stdin&gt;", line 1, in &lt;module&gt; 
TypeError: Can't instantiate abstract class Wav with abstract methods ext, play 
&gt;&gt;&gt; class Ogg(MediaLoader): 
...     ext = '.ogg' 
...     def play(self): 
...         pass 
... 
&gt;&gt;&gt; o = Ogg() 
</code></pre>
    <p class="normal">The definition of <a id="_idIndexMarker376"/>a <code class="Code-In-Text--PACKT-">Wav</code> subclass fails to implement either of the abstract attributes. When we try to create an instance of the <code class="Code-In-Text--PACKT-">Wav</code> class, an exception is raised. Because this subclass of <code class="Code-In-Text--PACKT-">MediaLoader</code> is still abstract, it is not possible to instantiate the class. The class is still a potentially useful abstract class, but you'd have to subclass it and fill in the abstract placeholders before it can actually do anything. </p>
    <p class="normal">The <code class="Code-In-Text--PACKT-">Ogg</code> subclass supplies both attributes, so it – at the least – can instantiate cleanly. It's true, the body of the <code class="Code-In-Text--PACKT-">play()</code> method doesn't do very much. What's important is that all of the placeholders were filled, making <code class="Code-In-Text--PACKT-">Ogg</code> a concrete subclass of the abstract <code class="Code-In-Text--PACKT-">MediaLoader</code> class.</p>
    <div><p class="Information-Box--PACKT-">There's a subtle issue with using a class-level variable for the preferred media file extension. Because the <code class="Code-In-Text--PACKT-">ext</code> attribute is a variable, it can be updated. Using <code class="Code-In-Text--PACKT-">o.ext = '.xyz'</code> is not expressly prohibited. Python doesn't have an easy, obvious way to create read-only attributes. We often rely on documentation to explain the consequences of changing the value of the <code class="Code-In-Text--PACKT-">ext</code> attribute.</p>
    </div>
    <p class="normal">This has clear advantages when creating a complex application. The use of abstraction like this makes it very easy for <strong class="" style="font-style: italic;">mypy</strong> to conclude that a class does (or does not) have the required methods and attributes. </p>
    <p class="normal">This also mandates a certain amount of fussy importing to be sure that the module has access to the necessary abstract base classes for an application. One of the advantages of duck typing is the ability to avoid complex imports and still create a useful class that can act polymorphically with peer classes. This advantage is often outweighed by the ability of the <code class="Code-In-Text--PACKT-">abc.ABC</code> class definition to support type checking via <strong class="" style="font-style: italic;">mypy</strong>, and to also do a runtime check for completeness of a subclass definition. The <code class="Code-In-Text--PACKT-">abc.ABC</code> class also provides far more useful error messages when something is wrong. </p>
    <p class="normal">One important use case for ABCs is the <code class="Code-In-Text--PACKT-">collections</code> module. This module defines the built-in generic collections using a sophisticated set of base classes and mixins.</p>
    <h2 id="_idParaDest-118" class="title">The ABCs of collections </h2>
    <p class="normal">A really comprehensive use of the abstract base classes in the Python standard library lives in the <code class="Code-In-Text--PACKT-">collections</code> module. The <a id="_idIndexMarker377"/>collections we use are extensions of the <code class="Code-In-Text--PACKT-">Collection</code> abstract class. <code class="Code-In-Text--PACKT-">Collection</code> is an extension of an even more fundamental abstraction, <code class="Code-In-Text--PACKT-">Container</code>.</p>
    <p class="normal">Since the foundation is the <code class="Code-In-Text--PACKT-">Container</code> class, let's inspect it in the Python interpreter to see what methods this class requires:</p>
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; from collections.abc import Container
&gt;&gt;&gt; Container.__abstractmethods__ 
frozenset({'__contains__'})
</code></pre>
    <p class="normal">So, the <code class="Code-In-Text--PACKT-">Container</code> class has exactly one abstract method that needs to be implemented, <code class="Code-In-Text--PACKT-">__contains__()</code>. You can issue <code class="Code-In-Text--PACKT-">help(Container.__contains__)</code> to see what the function signature should look like:</p>
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; help(Container.__contains__)
Help on function __contains__ in module collections.abc:
__contains__(self, x)
</code></pre>
    <p class="normal">We can see that <code class="Code-In-Text--PACKT-">__contains__()</code> needs to take a single argument. Unfortunately, the help file doesn't tell us much about what that argument should be, but it's pretty obvious from the name of the ABC and the single method it implements that this argument is the value the user is checking to see whether the container holds.</p>
    <p class="normal">This <code class="Code-In-Text--PACKT-">__contains__()</code> special method implements the Python <code class="Code-In-Text--PACKT-">in</code> operator. This method is implemented by <code class="Code-In-Text--PACKT-">set</code>, <code class="Code-In-Text--PACKT-">list</code>, <code class="Code-In-Text--PACKT-">str</code>, <code class="Code-In-Text--PACKT-">tuple</code>, and <code class="Code-In-Text--PACKT-">dict</code>. However, we can also define a silly container that tells us whether a given value is in the set of odd integers:</p>
    <pre class="programlisting code"><code class="hljs-code">from collections.abc import Container
class OddIntegers:
    def __contains__(self, x: int) -&gt; bool:
        return x % 2 != 0
</code></pre>
    <p class="normal">We've used the modulo test for oddity. If the remainder of <code class="Code-In-Text--PACKT-">x</code> divided by two is zero, then <code class="Code-In-Text--PACKT-">x</code> was even, otherwise <code class="Code-In-Text--PACKT-">x</code> was odd. </p>
    <p class="normal">Here's the interesting part: we can instantiate an <code class="Code-In-Text--PACKT-">OddContainer</code> object and determine that, even though we did not extend <code class="Code-In-Text--PACKT-">Container</code>, the class behaves as a <code class="Code-In-Text--PACKT-">Container</code> object:</p>
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; odd = OddIntegers()
&gt;&gt;&gt; isinstance(odd, Container)
True
&gt;&gt;&gt; issubclass(OddIntegers, Container)
True
</code></pre>
    <p class="normal">And that is <a id="_idIndexMarker378"/>why duck typing is way more awesome than classical polymorphism. We can create is-a relationships without the overhead of writing the code to set up inheritance (or worse, multiple inheritance).</p>
    <p class="normal">One cool thing about the <code class="Code-In-Text--PACKT-">Container</code> ABC is that any class that implements it gets to use the <code class="Code-In-Text--PACKT-">in</code> keyword for free. In fact, <code class="Code-In-Text--PACKT-">in</code> is just syntax sugar that delegates to the <code class="Code-In-Text--PACKT-">__contains__()</code> method. Any class that has a <code class="Code-In-Text--PACKT-">__contains__()</code> method is a <code class="Code-In-Text--PACKT-">Container</code> and can therefore be queried by the <code class="Code-In-Text--PACKT-">in</code> keyword. For example:</p>
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; odd = OddIntegers()
&gt;&gt;&gt; 1 in odd
True
&gt;&gt;&gt; 2 in odd
False
&gt;&gt;&gt; 3 in odd
True
</code></pre>
    <p class="normal">The real value here is the ability to create new kinds of collections that are completely compatible with Python's built-in generic collections. We could, for example, create a dictionary that uses a binary tree structure to retain keys instead of a hashed lookup. We'd start with the <code class="Code-In-Text--PACKT-">Mapping</code> abstract base class definitions, but change the algorithms that support methods like <code class="Code-In-Text--PACKT-">__getitem__()</code>, <code class="Code-In-Text--PACKT-">__setitem__()</code>, and <code class="Code-In-Text--PACKT-">__delitem__()</code>. </p>
    <p class="normal">Python's duck typing works (in part) via the <code class="Code-In-Text--PACKT-">isinstance()</code> and <code class="Code-In-Text--PACKT-">issubclass()</code> built-in functions. These functions are used to determine class relationships. They rely on two internal methods that classes can provide: <code class="Code-In-Text--PACKT-">__instancecheck__()</code> and <code class="Code-In-Text--PACKT-">__subclasscheck__()</code>. An ABC class can provide a <code class="Code-In-Text--PACKT-">__subclasshook__()</code> method, which is used by the <code class="Code-In-Text--PACKT-">__subclasscheck__() </code>method to assert that a given class is a proper subclass of the abstract base class. The details are a bit beyond this book; consider this a signpost pointing out the path that needs to be followed when creating novel classes that need to live side by side with built-in classes.</p>
    <h2 id="_idParaDest-119" class="title">Abstract base classes and type hints</h2>
    <p class="normal">The concept of an abstract base class is closely tied to the idea of a generic class. An abstract base class<a id="_idIndexMarker379"/> is often generic with respect to some detail that is supplied by a concrete implementation.</p>
    <p class="normal">Most of Python's generic classes – classes like <code class="Code-In-Text--PACKT-">list</code>, <code class="Code-In-Text--PACKT-">dict</code>, and <code class="Code-In-Text--PACKT-">set</code> – can be used as type hints, and these hints can be parameterized to narrow the domain. There's a world of difference between <code class="Code-In-Text--PACKT-">list[Any]</code> and <code class="Code-In-Text--PACKT-">list[int]</code>; the value <code class="Code-In-Text--PACKT-">["a", 42, 3.14]</code> is valid for the first type hint, but invalid for the other. This concept of <em class="italic">parameterizing</em> the generic type to make it more specific often applies to abstract classes, also.</p>
    <p class="normal">For this to work, you'll often need to incorporate <code class="Code-In-Text--PACKT-">from __future__ import annotations</code> as the very first line of code. This modifies the behavior of Python to permit function and variable annotations to parameterize these standard collections. </p>
    <p class="normal">Generic classes and abstract base classes are not the same thing. The two concepts overlap, but are distinct:</p>
    <ul>
      <li class="bullet">Generic classes<a id="_idIndexMarker380"/> have an implicit relationship with <code class="Code-In-Text--PACKT-">Any</code>. This often needs to be narrowed using type parameters, like <code class="Code-In-Text--PACKT-">list[int]</code>. The list class is concrete, and when we want to extend it, we'll need to plug in a class name to replace the <code class="Code-In-Text--PACKT-">Any</code> type. The Python interpreter does not use generic class hints in any way; they are only checked by static analysis tools<a id="_idIndexMarker381"/> such as <strong class="" style="font-style: italic;">mypy</strong>.</li>
      <li class="bullet">Abstract classes <a id="_idIndexMarker382"/>have placeholders instead of one or more methods. These placeholder methods require a design decision that supplies a concrete implementation. These classes are not completely defined. When we extend it, we'll need to provide a concrete method implementation. This is checked by <strong class="" style="font-style: italic;">mypy</strong>. That's not all. If we don't provide the missing methods, the interpreter will raise a runtime exception when we try to create an instance of an abstract class.</li>
    </ul>
    <p class="normal">Some classes can be both abstract and generic. As noted above, the type parameter helps <strong class="" style="font-style: italic;">mypy</strong> understand our intention, but isn't required. The concrete implementation is required.</p>
    <p class="normal">Another concept that's adjacent to abstract classes is the <strong class="keyword">protocol</strong>. This is the essence of how duck typing <a id="_idIndexMarker383"/>works: when two classes have the same batch of methods, they both adhere to a common <a id="_idIndexMarker384"/>protocol. Any time we see classes with similar methods, there's a common protocol; this may be formalized with a type hint.</p>
    <p class="normal">Consider objects that can be hashed. Immutable classes implement the <code class="Code-In-Text--PACKT-">__hash__()</code> method, including strings, integers, and tuples. Generally, mutable classes don't implement the <code class="Code-In-Text--PACKT-">__hash__()</code> method; this includes classes like <code class="Code-In-Text--PACKT-">list</code>, <code class="Code-In-Text--PACKT-">dict</code>, and <code class="Code-In-Text--PACKT-">set</code>. This one method is the <code class="Code-In-Text--PACKT-">Hashable</code> protocol. If we attempt to write a type hint like <code class="Code-In-Text--PACKT-">dict[list[int], list[str]]</code>, then <strong class="" style="font-style: italic;">mypy</strong> will object that <code class="Code-In-Text--PACKT-">list[int]</code> can't be used as a key. It can't be a key because the given type, <code class="Code-In-Text--PACKT-">list[int]</code>, doesn't implement the <code class="Code-In-Text--PACKT-">Hashable</code> protocol. At runtime, the attempt to create a dictionary item with a mutable key will fail for the same reason: a list doesn't implement the required method.</p>
    <p class="normal">The essence of creating ABCs is defined in the <code class="Code-In-Text--PACKT-">abc</code> module. We'll look at how this works later. For now, we want to make use of abstract classes, and that means using the definitions in the <code class="Code-In-Text--PACKT-">collections</code> module.</p>
    <h2 id="_idParaDest-120" class="title">The collections.abc module</h2>
    <p class="normal">One prominent<a id="_idIndexMarker385"/> use of abstract base classes is in the <code class="Code-In-Text--PACKT-">collections.abc</code> module. This module provides the abstract base class definitions for Python's built-in collections. This is how <code class="Code-In-Text--PACKT-">list</code>, <code class="Code-In-Text--PACKT-">set</code>, and <code class="Code-In-Text--PACKT-">dict</code> (and a few others) can be built from individual component definitions.</p>
    <p class="normal">We can use the definitions to build our own unique data structures in ways that overlap with built-in structures. We can also use the definitions when we want to write a type hint for a specific feature of a data structure, without being overly specific about alternative implementations that might also be acceptable.</p>
    <p class="normal">The definitions in <code class="Code-In-Text--PACKT-">collections.abc</code> don't – trivially – include <code class="Code-In-Text--PACKT-">list</code>, <code class="Code-In-Text--PACKT-">set</code>, or <code class="Code-In-Text--PACKT-">dict</code>. Instead, the module provides definitions like <code class="Code-In-Text--PACKT-">MutableSequence</code>, <code class="Code-In-Text--PACKT-">MutableMapping</code>, and <code class="Code-In-Text--PACKT-">MutableSet</code>, which are – in effect – abstract base classes for which the <code class="Code-In-Text--PACKT-">list</code>, <code class="Code-In-Text--PACKT-">dict</code>, or <code class="Code-In-Text--PACKT-">set</code> classes we use are the concrete implementations. Let's follow the various aspects of the definition of <code class="Code-In-Text--PACKT-">Mapping</code> back to their origins. Python's <code class="Code-In-Text--PACKT-">dict</code> class is a concrete implementation of <code class="Code-In-Text--PACKT-">MutableMapping</code>. The abstraction comes from the idea of mapping a key to a value. The <code class="Code-In-Text--PACKT-">MutableMapping</code> class depends on the <code class="Code-In-Text--PACKT-">Mapping</code> definition, an immutable, frozen dictionary, potentially optimized for lookups. Let's follow the relationships among these abstractions. </p>
    <p class="normal">Here's the path we want to follow:</p>
    <figure class="mediaobject"><img src="img/B17070_06_02.png" alt="Diagram  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 6.2: The Mapping abstractions</p>
    <p class="normal">Starting in<a id="_idIndexMarker386"/> the middle, we <a id="_idIndexMarker387"/>can see the <code class="Code-In-Text--PACKT-">Mapping</code> definition depends on the <code class="Code-In-Text--PACKT-">Collection </code>class definition. The definition of the <code class="Code-In-Text--PACKT-">Collection</code> abstract class, in turn, depends on three other abstract base classes: <code class="Code-In-Text--PACKT-">Sized</code>, <code class="Code-In-Text--PACKT-">Iterable</code>, and <code class="Code-In-Text--PACKT-">Container</code>. Each of these abstractions demands specific methods. </p>
    <p class="normal">If we're going to create a lookup-only dictionary – a concrete <code class="Code-In-Text--PACKT-">Mapping</code> implementation – we'll need to implement at least the following methods:</p>
    <ul>
      <li class="bullet">The <code class="Code-In-Text--PACKT-">Sized</code> abstraction requires an implementation for the <code class="Code-In-Text--PACKT-">__len__()</code> method. This lets an<a id="_idIndexMarker388"/> instance of our class respond to the <code class="Code-In-Text--PACKT-">len()</code> function with a useful answer.</li>
      <li class="bullet">The <code class="Code-In-Text--PACKT-">Iterable</code> abstraction requires an implementation for the <code class="Code-In-Text--PACKT-">__iter__() </code>method. This lets an object work with the <code class="Code-In-Text--PACKT-">for</code> statement and the <code class="Code-In-Text--PACKT-">iter()</code> function. In <em class="chapterRef">Chapter 10</em>, <em class="italic">The Iterator Pattern</em>, we'll revisit this topic.</li>
      <li class="bullet">The <code class="Code-In-Text--PACKT-">Container</code> abstraction requires an implementation for the <code class="Code-In-Text--PACKT-">__contains__()</code> method. This permits the <code class="Code-In-Text--PACKT-">in</code> and <code class="Code-In-Text--PACKT-">not in</code> operators to work.</li>
      <li class="bullet">The <code class="Code-In-Text--PACKT-">Collection</code> abstraction combines <code class="Code-In-Text--PACKT-">Sized</code>, <code class="Code-In-Text--PACKT-">Iterable</code>, and <code class="Code-In-Text--PACKT-">Container </code>without introducing additional <a id="_idIndexMarker389"/>abstract methods.</li>
      <li class="bullet">The <code class="Code-In-Text--PACKT-">Mapping</code> abstraction, based on <code class="Code-In-Text--PACKT-">Collection</code>, requires, among other things, <code class="Code-In-Text--PACKT-">__getitem__()</code>, <code class="Code-In-Text--PACKT-">__iter__()</code>, and <code class="Code-In-Text--PACKT-">__len__()</code>. It has a default definition for <code class="Code-In-Text--PACKT-">__contains__()</code>, based on whatever <code class="Code-In-Text--PACKT-">__iter__()</code> method we provide. The <code class="Code-In-Text--PACKT-">Mapping</code> definition will provide a few other methods, also.</li>
    </ul>
    <p class="normal">This list of methods comes directly from the abstract relationships in the base classes. By building our new dictionary-like immutable class from these abstractions, we can be sure that our class will collaborate seamlessly with other Python generic classes.</p>
    <p class="normal">When we look at the documentation in <a href="https://docs.python.org/3.9/library/collections.abc.html">https://docs.python.org/3.9/library/collections.abc.html</a>, we see the page is dominated by a table showing abstract class definitions and the definitions they depend on. There's a lattice of dependencies showing overlap among the class definitions. It's this overlap that allows us to use a <code class="Code-In-Text--PACKT-">for</code> statement to iterate through every kind of collection that implements the <code class="Code-In-Text--PACKT-">Iterable</code> abstract base class.</p>
    <p class="normal">Let's define our own immutable <code class="Code-In-Text--PACKT-">Mapping</code> object implementation by extending the abstract classes. The goal is to be able to load our dictionary-like mapping once with keys and values, and then use it to map the keys to their values. Since we aren't going to allow any updates, we can apply a variety of algorithms to make it very fast as well as very compact.</p>
    <p class="normal">The goal is a class with a type hint like the following:</p>
    <pre class="programlisting code"><code class="hljs-code">BaseMapping = abc.Mapping[Comparable, Any]
</code></pre>
    <p class="normal">We're going to create a dictionary-like mapping from some key to – well – an object of any possible type. We've defined the key with the type <code class="Code-In-Text--PACKT-">Comparable</code> because we want to be able to compare the keys and sort them into order. Searching through a list in order is often more efficient than searching a list that's not in order.</p>
    <p class="normal">We'll look at the core of a <code class="Code-In-Text--PACKT-">Lookup</code> class definition first. We'll return to the <code class="Code-In-Text--PACKT-">Comparable</code> class definition after solidifying the essentials of a new kind of mapping from keys to values.</p>
    <p class="normal">When we look at ways we can construct a dictionary, we see that a dictionary can be built from two different kinds of data structures. Our new mapping has to have this same flexibility. The two structures are exemplified by the following:</p>
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; x = dict({"a": 42, "b": 7, "c": 6})
&gt;&gt;&gt; y = dict([("a", 42), ("b", 7), ("c", 6)])
&gt;&gt;&gt; x == y
True
</code></pre>
    <p class="normal">We can build a mapping from an existing mapping, or we can build a mapping from a sequence of two-tuples with keys and values. This means there are two separate definitions for <code class="Code-In-Text--PACKT-">__init__()</code>:</p>
    <ul>
      <li class="bullet"><code class="Code-In-Text--PACKT-">def __init__(self, source: BaseMapping) -&gt; None</code></li>
      <li class="bullet"><code class="Code-In-Text--PACKT-">def __init__(self, source: Iterable[tuple[Comparable, Any]]) -&gt; None</code></li>
    </ul>
    <p class="normal">These two definitions <a id="_idIndexMarker390"/>have distinct type hints. To make it clear to <strong class="" style="font-style: italic;">mypy</strong>, we need to provide <strong class="keyword">overloaded</strong> method definitions. This is done with a special decoration from the <code class="Code-In-Text--PACKT-">typing</code> module, <code class="Code-In-Text--PACKT-">@overload</code>. We'll provide two method definitions with the two alternatives; after these, we'll provide the real method definition that does the useful work. Because these are type hints, they're not <em class="italic">required</em>. They're wordy, and they help us be sure we've got a sensible implementation.</p>
    <p class="normal">Here's the first part of the <code class="Code-In-Text--PACKT-">Lookup</code> class definition. We'll break this into pieces because the <code class="Code-In-Text--PACKT-">__init__()</code> method needs to cover these two cases defined by the alternative overloads:</p>
    <pre class="programlisting code"><code class="hljs-code">BaseMapping = abc.Mapping[Comparable, Any]
class Lookup(BaseMapping):
    @overload
    def __init__(
          self, 
          source: Iterable[tuple[Comparable, Any]]
    ) -&gt; None:
        ...
    @overload
    def __init__(self, source: BaseMapping) -&gt; None:
        ...
    def __init__(
          self, 
          source: Union[Iterable[              tuple[Comparable, Any]]
              BaseMapping,
              None] = None,
    ) -&gt; None:
        sorted_pairs: Sequence[tuple[Comparable, Any]]
        if isinstance(source, Sequence):
            sorted_pairs = sorted(source)
        elif isinstance(source, abc.Mapping):
            sorted_pairs = sorted(source.items())
        else:
            sorted_pairs = []
        self.key_list = [p[0] for p in sorted_pairs]
        self.value_list = [p[1] for p in sorted_pairs]
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">__init__()</code> method<a id="_idIndexMarker391"/> needs to handle three cases for loading a mapping. This means building the values from a sequence of pairs, or building the values from another mapping object, or creating an empty sequence of values. We need to separate the keys from the values and put them into two parallel lists. A sorted list of keys can be rapidly searched to find a match. The sorted list of values is returned when we get a key's value from the mapping.</p>
    <p class="normal">Here are the imports needed: </p>
    <pre class="programlisting code"><code class="hljs-code">from __future__ import annotations
from collections import abc
from typing import Protocol, Any, overload, Union
import bisect
from typing import Iterator, Iterable, Sequence, Mapping
</code></pre>
    <p class="normal">Here are the other abstract methods that are defined by the <code class="Code-In-Text--PACKT-">@abstractmethod</code> decorator. We provide the following concrete implementations:</p>
    <pre class="programlisting code"><code class="hljs-code">    def __len__(self) -&gt; int:
        return len(self.key_list)
    def __iter__(self) -&gt; Iterator[Comparable]:
        return iter(self.key_list)
    def __contains__(self, key: object) -&gt; bool:
        index = bisect.bisect_left(self.key_list, key)
        return key == self.key_list[index]
    def __getitem__(self, key: Comparable) -&gt; Any:
        index = bisect.bisect_left(self.key_list, key)
        if key == self.key_list[index]:
            return self.value_list[index]
        raise KeyError(key)
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">__len__()</code>, <code class="Code-In-Text--PACKT-">__iter__()</code>, and <code class="Code-In-Text--PACKT-">__contains__()</code> methods are required by the <code class="Code-In-Text--PACKT-">Sized</code>, <code class="Code-In-Text--PACKT-">Iterable</code>, and <code class="Code-In-Text--PACKT-">Container</code> abstract classes. The <code class="Code-In-Text--PACKT-">Collection</code> abstract class combines the other three without introducing any new abstract methods.</p>
    <p class="normal">The <code class="Code-In-Text--PACKT-">__getitem__()</code> is required to be a <code class="Code-In-Text--PACKT-">Mapping</code>. Without it, we can't retrieve an individual value for a given key. </p>
    <p class="normal">The use of the <code class="Code-In-Text--PACKT-">bisect</code> module is one way to find a specific value rapidly in a sorted list of keys. The <code class="Code-In-Text--PACKT-">bisect.bisect_left()</code> function finds the spot where a key belongs in a list. If the key is there, we can return the value to which it maps. If the key is not there, we can raise the <code class="Code-In-Text--PACKT-">KeyError</code> exception.</p>
    <p class="normal">Note that the <code class="Code-In-Text--PACKT-">__contains__()</code> definition<a id="_idIndexMarker392"/> has the <code class="Code-In-Text--PACKT-">object</code> class as the type hint, unlike the other methods. This is required because Python's <code class="Code-In-Text--PACKT-">in</code> operation needs to support any kind of object, even ones that don't obviously support the <code class="Code-In-Text--PACKT-">Comparable</code> protocol.</p>
    <p class="normal">Here's how it looks when we use our shiny new <code class="Code-In-Text--PACKT-">Lookup</code> class:</p>
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; x = Lookup(
...     [
...         ["z", "Zillah"],
...         ["a", "Amy"],
...         ["c", "Clara"],
...         ["b", "Basil"],
...     ]
... )
&gt;&gt;&gt; x["c"]
'Clara'
</code></pre>
    <p class="normal">This collection, generally, behaves a bit like a dictionary. There are a number of dict-like aspects we can't use, though, because we chose an abstract base class that didn't describe the full set of methods for the <code class="Code-In-Text--PACKT-">dict</code> class.</p>
    <p class="normal">If we try something like this:</p>
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; x["m"] = "Maud"
</code></pre>
    <p class="normal">We'll get an exception that spells out the limitation of the class we built:</p>
    <pre class="programlisting con"><code class="hljs-con">TypeError: 'Lookup' object does not support item assignment
</code></pre>
    <p class="normal">This exception is consistent with the rest of our design. An update to this object means inserting an item at the correct position to maintain a sorted order. Shuffling a large list around gets expensive; if we need to update the lookup collection, we should consider other data structures like a Red-Black tree. But, for the pure search operation using the bisect algorithm, this performs nicely. </p>
    <p class="normal">We skipped over the <a id="_idIndexMarker393"/>definition of the <code class="Code-In-Text--PACKT-">Comparable</code> class. This defines the minimum set of features – the protocol – for the keys. It's a way to formalize the comparison rules required to keep the keys for the mapping in order. This helps <strong class="" style="font-style: italic;">mypy</strong> confirm that objects we try to use as keys really can be compared:</p>
    <pre class="programlisting code"><code class="hljs-code">from typing import Protocol, Any
class Comparable(Protocol):
    def __eq__(self, other: Any) -&gt; bool: ...
    def __ne__(self, other: Any) -&gt; bool: ...
    def __le__(self, other: Any) -&gt; bool: ...
    def __lt__(self, other: Any) -&gt; bool: ...
    def __ge__(self, other: Any) -&gt; bool: ...
    def __gt__(self, other: Any) -&gt; bool: ...
</code></pre>
    <p class="normal">There's no implementation. This definition is used to introduce a new type hint. Because it's a hint, we provide <code class="Code-In-Text--PACKT-">...</code> as the body for the methods, since the bodies will be provided by existing class definitions like <code class="Code-In-Text--PACKT-">str</code> and <code class="Code-In-Text--PACKT-">int</code>.</p>
    <p class="normal">Note that we don't rely on items having a hash code. This is an interesting extension to the built-in <code class="Code-In-Text--PACKT-">dict</code> class, which requires the keys be hashable.</p>
    <p class="normal">The general approach to using abstract classes is this:</p>
    <ol>
      <li class="numbered">Find a class that does most of what you need.</li>
      <li class="numbered">Identify the methods in the <code class="Code-In-Text--PACKT-">collections.abc</code> definitions that are marked as <em class="italic">abstract</em>. The documentation often gives a lot of information, but you'll also have to look at the source.</li>
      <li class="numbered">Subclass the abstract class, filling in the missing methods.</li>
      <li class="numbered">While it can help to make a checklist of the methods, there are tools to help with this. Creating a unit test (we'll cover testing in <em class="chapterRef">Chapter 13</em>, <em class="italic">Testing Object-Oriented Programs</em>) means you need to create an instance of your new class. If you haven't defined all the abstract methods, this will raise an exception. Using <strong class="" style="font-style: italic;">mypy</strong> will also spot abstract methods that aren't properly defined in the concrete subclass.</li>
    </ol>
    <p class="normal">This is a powerful way to reuse code when we choose the abstractions well; a person can form a mental model of the class without knowing all of the details. It's also a powerful way to create closely related classes that can easily be examined by <strong class="" style="font-style: italic;">mypy</strong>. Beyond those two advantages, the formality of marking a method as abstract gives us a runtime assurance that the concrete subclass really does implement all the required methods.</p>
    <p class="normal">Now that we've seen how to use an abstract base class, let's look at defining a new abstraction.</p>
    <h2 id="_idParaDest-121" class="title">Creating your own abstract base class</h2>
    <p class="normal">We have two general <a id="_idIndexMarker394"/>paths to creating classes that are similar: we can leverage duck typing or we can define common abstractions. When we leverage duck typing, we can formalize the related types by creating a type hint using a protocol definition to enumerate the common methods, or a <code class="Code-In-Text--PACKT-">Union[]</code> to enumerate the common types. </p>
    <p class="normal">There are an almost unlimited number of influencing factors that suggest one or the other approach. While duck typing offers the most flexibility, we may sacrifice the ability to use <strong class="" style="font-style: italic;">mypy</strong>. An abstract base class definition can be wordy and potentially confusing.</p>
    <p class="normal">We'll tackle a small problem. We want to build a simulation of games that involve polyhedral dice. These are the dice including four, six, eight, twelve, and twenty sides. The six-sided dice are conventional cubes. Some sets of dice include 10-sided dice, which are cool, but aren't – technically – a <em class="italic">regular</em> polyhedron; they're two sets of five "kite-shaped" faces.</p>
    <p class="normal">One question that comes up is how best to simulate rolls of these different shaped dice. There are three readily available sources of random data in Python: the <code class="Code-In-Text--PACKT-">random</code> module, the <code class="Code-In-Text--PACKT-">os</code> module, and the <code class="Code-In-Text--PACKT-">secrets</code> module. If we turn to third-party modules, we can add in cryptographic libraries like <code class="Code-In-Text--PACKT-">pynacl</code>, which offer yet more random number capabilities.</p>
    <p class="normal">Rather than bake the choice of random number generator into a class, we can define an abstract class that has the general features of a die. A concrete subclass can supply the missing randomization capability. The random module has a very flexible generator. The <code class="Code-In-Text--PACKT-">os</code> module's capability is limited, but involves using an <em class="italic">entropy collector</em> to increase randomness. Flexibility and high entropy are generally combined by cryptographic generators.</p>
    <p class="normal">To create our<a id="_idIndexMarker395"/> dice-rolling abstraction, we'll need the <code class="Code-In-Text--PACKT-">abc</code> module. This is<a id="_idIndexMarker396"/> distinct from the <code class="Code-In-Text--PACKT-">collections.abc</code> module. The <code class="Code-In-Text--PACKT-">abc</code> module has the foundational definitions for abstract classes:</p>
    <pre class="programlisting code"><code class="hljs-code">import abc
class Die(abc.ABC):
    def __init__(self) -&gt; None:
        self.face: int
        self.roll()
    @abc.abstractmethod
    def roll(self) -&gt; None:
        ...
    def __repr__(self) -&gt; str:
        return f"{self.face}"
</code></pre>
    <p class="normal">We've defined a class that inherits from the <code class="Code-In-Text--PACKT-">abc.ABC</code> class. Using <code class="Code-In-Text--PACKT-">ABC</code> as the parent class assures us that any attempt to create an instance of the <code class="Code-In-Text--PACKT-">Die</code> class directly will raise a <code class="Code-In-Text--PACKT-">TypeError</code> exception. This is a runtime exception; it's also checked by <strong class="" style="font-style: italic;">mypy</strong>.</p>
    <p class="normal">We've marked a method, <code class="Code-In-Text--PACKT-">roll()</code>, as abstract with the <code class="Code-In-Text--PACKT-">@abc.abstract</code> decorator. This isn't a very complex method, but any subclass should match this abstract definition. This is only checked by <strong class="" style="font-style: italic;">mypy</strong>. Of course, if we make a mess of the concrete implementation, things are likely to break at runtime. Consider this mess of code:</p>
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; class Bad(Die):
...     def roll(self, a: int, b: int) -&gt; float:
...         return (a+b)/2
</code></pre>
    <p class="normal">This will raise a <code class="Code-In-Text--PACKT-">TypeError</code> exception at runtime. The problem is caused by the base class <code class="Code-In-Text--PACKT-">__init__()</code> not providing the <code class="Code-In-Text--PACKT-">a</code> and <code class="Code-In-Text--PACKT-">b</code> parameters to this strange-looking <code class="Code-In-Text--PACKT-">roll()</code> method. This is valid Python code, but it doesn't make sense in this context. The method will also generate <strong class="" style="font-style: italic;">mypy</strong> errors, providing ample warning the method definition doesn't match the abstraction.</p>
    <p class="normal">Here's what two proper extensions to the <code class="Code-In-Text--PACKT-">Die</code> class look like:</p>
    <pre class="programlisting code"><code class="hljs-code">class D4(Die):
    def roll(self) -&gt; None:
        self.face = random.choice((1, 2, 3, 4))
class D6(Die):
    def roll(self) -&gt; None:
        self.face = random.randint(1, 6)
</code></pre>
    <p class="normal">We've provided <a id="_idIndexMarker397"/>methods that provide a suitable definition for the abstract<a id="_idIndexMarker398"/> placeholder in the <code class="Code-In-Text--PACKT-">Die</code> class. They use vastly different approaches to selecting a random value. The four-sided die uses <code class="Code-In-Text--PACKT-">random.choice()</code>. The six-sided die – the common cube most people know – uses <code class="Code-In-Text--PACKT-">random.randint()</code>. </p>
    <p class="normal">Let's go a step further and create another abstract class. This one will represent a handful of dice. Again, we have a number of candidate solutions, and we can use an abstract class to defer the final design choices.</p>
    <p class="normal">The interesting part of this design is the differences in the rules for games with handfuls of dice. In some games, the rules require the player to roll all the dice. The rules for a lot of games with two dice require the player to roll both dice. In other games, the rules allow players to save dice, and re-roll selected dice. In some games, like Yacht, the players are allowed at most two re-rolls. In other games, like Zilch, they are allowed to re-roll until they elect to save their score or roll something invalid and lose all their points, scoring zilch (hence the name).</p>
    <p class="normal">These are dramatically different rules that apply to a simple list of <code class="Code-In-Text--PACKT-">Die</code> instances. Here's a class that leaves the roll implementation as an abstraction: </p>
    <pre class="programlisting code"><code class="hljs-code">class Dice(abc.ABC):
    def __init__(self, n: int, die_class: Type[Die]) -&gt; None:
        self.dice = [die_class() for _ in range(n)]
    @abc.abstractmethod
    def roll(self) -&gt; None:
        ...
    @property
    def total(self) -&gt; int:
        return sum(d.face for d in self.dice)
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">__init__()</code> method expects an integer, <code class="Code-In-Text--PACKT-">n</code>, and the class used to create <code class="Code-In-Text--PACKT-">Die</code> instances, named <code class="Code-In-Text--PACKT-">die_class</code>. The type hint is <code class="Code-In-Text--PACKT-">Type[Die]</code>, telling <strong class="" style="font-style: italic;">mypy</strong> to be on the lookout for any subclass of the abstract base class <code class="Code-In-Text--PACKT-">Die</code>. We don't expect an instance of any of the <code class="Code-In-Text--PACKT-">Die</code> subclasses; we expect the class object itself. We'd expect to see <code class="Code-In-Text--PACKT-">SomeDice(6, D6)</code> to create a list of six instances of the <code class="Code-In-Text--PACKT-">D6</code> class.</p>
    <p class="normal">We've defined the collection of <code class="Code-In-Text--PACKT-">Die</code> instances as a list because that seems simple. Some games will identify dice by their position when saving some dice and rerolling the remainder of the dice, and the integer list indices seem useful for that.</p>
    <p class="normal">This subclass<a id="_idIndexMarker399"/> implements the <a id="_idIndexMarker400"/>roll-all-the-dice rule:</p>
    <pre class="programlisting code"><code class="hljs-code">class SimpleDice(Dice):
    def roll(self) -&gt; None:
        for d in self.dice:
            d.roll()
</code></pre>
    <p class="normal">Each time the application evaluates <code class="Code-In-Text--PACKT-">roll()</code>, all the dice are updated. It looks like this:</p>
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; sd = SimpleDice(6, D6)
&gt;&gt;&gt; sd.roll()
&gt;&gt;&gt; sd.total
23
</code></pre>
    <p class="normal">The object, <code class="Code-In-Text--PACKT-">sd</code>, is an instance of the concrete class, <code class="Code-In-Text--PACKT-">SimpleDice</code>, built from the abstract class, <code class="Code-In-Text--PACKT-">Dice</code>. The instance of <code class="Code-In-Text--PACKT-">SimpleDice</code> contains six instances of the <code class="Code-In-Text--PACKT-">D6</code> class. This, too, is a concrete class built from the abstract class <code class="Code-In-Text--PACKT-">Die</code>. </p>
    <p class="normal">Here's another subclass that provides a dramatically different set of methods. Some of these fill in the spaces left by abstract methods. Others, however, are unique to the subclass:</p>
    <pre class="programlisting code"><code class="hljs-code">class YachtDice(Dice):
    def __init__(self) -&gt; None:
        super().__init__(5, D6)
        self.saved: Set[int] = set()
    def saving(self, positions: Iterable[int]) -&gt; "YachtDice":
        if not all(0 &lt;= n &lt; 6 for n in positions):
            raise ValueError("Invalid position")
        self.saved = set(positions)
        return self
    def roll(self) -&gt; None:
        for n, d in enumerate(self.dice):
            if n not in self.saved:
                d.roll()
        self.saved = set()
</code></pre>
    <p class="normal">We've created a set of<a id="_idIndexMarker401"/> saved positions. This is initially empty. We can use the <code class="Code-In-Text--PACKT-">saving()</code> method to provide an iterable collection of integers as positions to save. It works like this:</p>
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; sd = YachtDice()
&gt;&gt;&gt; sd.roll()
&gt;&gt;&gt; sd.dice
[2, 2, 2, 6, 1]
&gt;&gt;&gt; sd.saving([0, 1, 2]).roll()
&gt;&gt;&gt; sd.dice
[2, 2, 2, 6, 6]
</code></pre>
    <p class="normal">We improved the <a id="_idIndexMarker402"/>hand from three of a kind to a full house. </p>
    <p class="normal">In both cases, the <code class="Code-In-Text--PACKT-">Die</code> class and the <code class="Code-In-Text--PACKT-">Dice</code> class, it's not clear that the <code class="Code-In-Text--PACKT-">abc.ABC</code> base class and the presence of an <code class="Code-In-Text--PACKT-">@abc.abstractmethod</code> decoration is dramatically better than providing a concrete base class with a common set of default definitions.</p>
    <p class="normal">In some languages, the abstraction-based definition is required. In Python, because of duck typing, abstraction is optional. In cases where it clarifies the design intent, use it. In cases where it seems fussy and little more than overhead, set it aside. </p>
    <p class="normal">Because it's used to define the collections, we'll often use the <code class="Code-In-Text--PACKT-">collection.abc</code> names in type hints to describe the protocols objects must follow. In less common cases, we'll leverage the <code class="Code-In-Text--PACKT-">collections.abc</code> abstractions to create our own unique collections.</p>
    <h2 id="_idParaDest-122" class="title">Demystifying the magic</h2>
    <p class="normal">We've used <a id="_idIndexMarker403"/>abstract base classes and it's clear they're doing a lot of work for us. Let's look inside the class to see some of what's going on:</p>
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; from dice import Die
&gt;&gt;&gt; Die.__abstractmethods__
frozenset({'roll'})
&gt;&gt;&gt; Die.roll.__isabstractmethod__
True
</code></pre>
    <p class="normal">The abstract method, <code class="Code-In-Text--PACKT-">roll()</code>, is tracked in a specially named attribute, <code class="Code-In-Text--PACKT-">__abstractmethods__</code>, of the class. This suggests what the <code class="Code-In-Text--PACKT-">@abc.abstractmethod</code> decorator does. This decorator sets <code class="Code-In-Text--PACKT-">__isabstractmethod__</code> to mark the method. When Python finally builds the class from the various methods and attributes, the list of abstractions is also collected to create a class-level set of methods that must be implemented.</p>
    <p class="normal">Any subclass<a id="_idIndexMarker404"/> that extends <code class="Code-In-Text--PACKT-">Die</code> will also inherit this <code class="Code-In-Text--PACKT-">__abstractmethods__</code> set. When methods are defined inside the subclass, names are removed from the set as Python builds the class from the definitions. We can only create instances of a class where the set of abstract methods in the class is empty.</p>
    <p class="normal">Central to this is the way classes are created: a class builds objects. This is the essence of most of object-oriented programming. But what is a class?</p>
    <ol>
      <li class="numbered" value="1">A class is another object with two very limited jobs: it has the special methods used to create and manage instances of the class, and it also acts as a container for the method definitions for objects of the class. We think of building class objects with the <code class="Code-In-Text--PACKT-">class</code> statement, which leaves open the question of how the <code class="Code-In-Text--PACKT-">class</code> statement builds the <code class="Code-In-Text--PACKT-">class</code> object.</li>
      <li class="numbered">The <code class="Code-In-Text--PACKT-">type</code> class is the internal object that builds our application classes. When we enter the code for a class, the details of construction are actually the responsibility of methods of the <code class="Code-In-Text--PACKT-">type</code> class. After <code class="Code-In-Text--PACKT-">type</code> has created our application class, our class then creates the application objects that solve our problem.</li>
    </ol>
    <p class="normal">The <code class="Code-In-Text--PACKT-">type</code> object is called the <strong class="keyword">metaclass</strong>, the <a id="_idIndexMarker405"/>class used to build classes. This means every class object is an instance of <code class="Code-In-Text--PACKT-">type</code>. Most of the time, we're perfectly happy with letting a <code class="Code-In-Text--PACKT-">class</code> statement be handled by the <code class="Code-In-Text--PACKT-">type</code> class so our application code can run. There's one place, however, where we might want to change how <code class="Code-In-Text--PACKT-">type</code> works.</p>
    <p class="normal">Because <code class="Code-In-Text--PACKT-">type</code> is itself a class, it can be extended. A class <code class="Code-In-Text--PACKT-">abc.ABCMeta</code> extends the <code class="Code-In-Text--PACKT-">type</code> class to check for methods decorated with <code class="Code-In-Text--PACKT-">@abstractmethod</code>. When we extend <code class="Code-In-Text--PACKT-">abc.ABC</code>, we're creating a new class that uses the <code class="Code-In-Text--PACKT-">ABCMeta</code> metaclass. We can see this in the value of the special <code class="Code-In-Text--PACKT-">__mro__</code> attribute of the <code class="Code-In-Text--PACKT-">ABCMeta</code> class; this attribute lists the classes used for resolving <a id="_idIndexMarker406"/>method names (<strong class="keyword">MRO</strong> is <strong class="keyword">Method Resolution Order</strong>). This special attribute lists the following classes to be searched for a given attribute: the <code class="Code-In-Text--PACKT-">abc.ABCMeta</code> class, the <code class="Code-In-Text--PACKT-">type</code> class, and finally the <code class="Code-In-Text--PACKT-">object</code> class.</p>
    <p class="normal">We can use the <code class="Code-In-Text--PACKT-">ABCMeta</code> metaclass explicitly when we create a new class, if we want:</p>
    <pre class="programlisting code"><code class="hljs-code">class DieM(metaclass=abc.ABCMeta):
    def __init__(self) -&gt; None:
        self.face: int
        self.roll()
    @abc.abstractmethod
    def roll(self) -&gt; None:
        ...
</code></pre>
    <p class="normal">We've <a id="_idIndexMarker407"/>used <code class="Code-In-Text--PACKT-">metaclass</code> as a keyword parameter when defining the components that make up a class. This means the <code class="Code-In-Text--PACKT-">abc.ABCMeta</code> extension to type will be used to create the final class object.</p>
    <p class="normal">Now that we've seen how classes are built, we can consider other things we can do when creating and extending classes. Python exposes the binding between the syntactic operators, like the <code class="Code-In-Text--PACKT-">/</code> operator, and the methods of the implementing class. This allows the <code class="Code-In-Text--PACKT-">float</code> and <code class="Code-In-Text--PACKT-">int</code> classes to do different things with the <code class="Code-In-Text--PACKT-">/</code> operator, but it can also be used for quite different purposes. For example, the <code class="Code-In-Text--PACKT-">pathlib.Path</code> class, which we will discuss in <em class="chapterRef">Chapter 9</em>, <em class="italic">Strings, Serialization, and File Paths</em>, also makes use of the <code class="Code-In-Text--PACKT-">/</code> operator.</p>
    <h1 id="_idParaDest-123" class="title">Operator overloading</h1>
    <p class="normal">Python's operators, <code class="Code-In-Text--PACKT-">+</code>, <code class="Code-In-Text--PACKT-">/</code>, <code class="Code-In-Text--PACKT-">-</code>, <code class="Code-In-Text--PACKT-">*</code>, and so on, are implemented by special methods on classes. We can apply Python<a id="_idIndexMarker408"/> operators more widely than the built-in numbers and collection types. Doing this can be called "overloading" the operators: letting them work with more than the built-in types.</p>
    <p class="normal">Looking back at the <em class="italic">The collections.abc module</em> section, earlier in this chapter, we dropped a hint about how Python connects some built-in features with our classes. When we look at the <code class="Code-In-Text--PACKT-">collections.abc.Collection</code> class, it is the abstract base class for all <code class="Code-In-Text--PACKT-">Sized</code>, <code class="Code-In-Text--PACKT-">Iterable</code>, <code class="Code-In-Text--PACKT-">Containers</code>; it requires three methods that enable two built-in functions and one built-in operator:</p>
    <ul>
      <li class="bullet">The <code class="Code-In-Text--PACKT-">__len__()</code> method is used by the built-in <code class="Code-In-Text--PACKT-">len()</code> function. </li>
      <li class="bullet">The <code class="Code-In-Text--PACKT-">__iter__()</code> method is used by the built-in <code class="Code-In-Text--PACKT-">iter()</code> function, which means it's used by the <code class="Code-In-Text--PACKT-">for</code> statement.</li>
      <li class="bullet">The <code class="Code-In-Text--PACKT-">__contains__()</code> method is used by the built-in <code class="Code-In-Text--PACKT-">in</code> operator. This operator is implemented by methods of built-in classes.</li>
    </ul>
    <p class="normal">It's not wrong to imagine the built-in <code class="Code-In-Text--PACKT-">len()</code> function has this definition:</p>
    <pre class="programlisting code"><code class="hljs-code">def len(object: Sized) -&gt; int:
    return object.__len__()
</code></pre>
    <p class="normal">When we ask for <code class="Code-In-Text--PACKT-">len(x)</code>, it's doing the same thing as <code class="Code-In-Text--PACKT-">x.__len__()</code>, but is shorter, easier to read, and easier to remember. Similarly, <code class="Code-In-Text--PACKT-">iter(y)</code> is effectively <code class="Code-In-Text--PACKT-">y.__iter__()</code>. And an expression like <code class="Code-In-Text--PACKT-">z in S</code> is evaluated as if it was <code class="Code-In-Text--PACKT-">S.__contains__(z)</code>.</p>
    <p class="normal">And yes, with a few exceptions, all of Python works this way. We write pleasant, easy-to-read expressions that are transformed into special methods. The only exceptions are the logic operations: <code class="Code-In-Text--PACKT-">and</code>, <code class="Code-In-Text--PACKT-">or</code>, <code class="Code-In-Text--PACKT-">not</code>, and <code class="Code-In-Text--PACKT-">if-else</code>. These don't map directly to special method definitions.</p>
    <p class="normal">Because almost all of Python relies on the special methods, it means we can change their behavior to add features. We can overload the operators with new data types. One prominent example of this is in the <code class="Code-In-Text--PACKT-">pathlib</code> module:</p>
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; from pathlib import Path
&gt;&gt;&gt; home = Path.home()
&gt;&gt;&gt; home / "miniconda3" / "envs"
PosixPath('/Users/slott/miniconda3/envs')
</code></pre>
    <p class="normal">Note: Your results will <a id="_idIndexMarker409"/>vary, depending on your operating system and your username.</p>
    <p class="normal">What doesn't vary is that the <code class="Code-In-Text--PACKT-">/</code> operator is used to connect a <code class="Code-In-Text--PACKT-">Path</code> object with string objects to create a new <code class="Code-In-Text--PACKT-">Path</code> object.</p>
    <p class="normal">The <code class="Code-In-Text--PACKT-">/</code> operator is implemented by the <code class="Code-In-Text--PACKT-">__truediv__()</code> and <code class="Code-In-Text--PACKT-">__rtruediv__()</code> methods. In order to make operations commutative, Python has two places to look for an implementation. Given an expression of <code class="Code-In-Text--PACKT-">A </code><em class="italic">op</em><code class="Code-In-Text--PACKT-"> B</code>, where <em class="italic">op</em> is any of the Python operators like <code class="Code-In-Text--PACKT-">__add__</code> for <code class="Code-In-Text--PACKT-">+</code>, Python does the following checks for special methods to implement the operator:</p>
    <ol>
      <li class="numbered" value="1">There's a special case when <code class="Code-In-Text--PACKT-">B</code> is a proper subclass of <code class="Code-In-Text--PACKT-">A</code>. In those rare cases, the order is reversed so <code class="Code-In-Text--PACKT-">B.__r</code><em class="italic">op</em><code class="Code-In-Text--PACKT-">__(A)</code> can be tried before any of the others. This lets the subclass <code class="Code-In-Text--PACKT-">B</code> override an operation from superclass <code class="Code-In-Text--PACKT-">A</code>. </li>
      <li class="numbered">Try <code class="Code-In-Text--PACKT-">A.__</code><em class="italic">op</em><code class="Code-In-Text--PACKT-">__(B)</code>. If this returns a value that's not the special <code class="Code-In-Text--PACKT-">NotImplemented</code> value, this is the result. For a <code class="Code-In-Text--PACKT-">Path</code> object expression like <code class="Code-In-Text--PACKT-">home / "miniconda3"</code>, this is effectively <code class="Code-In-Text--PACKT-">home.__truediv__("miniconda3")</code>. A new <code class="Code-In-Text--PACKT-">Path</code> object is built from the old <code class="Code-In-Text--PACKT-">Path</code> object and the string.</li>
      <li class="numbered">Try <code class="Code-In-Text--PACKT-">B.__r</code><em class="italic">op</em><code class="Code-In-Text--PACKT-">__(A)</code>. This might be the <code class="Code-In-Text--PACKT-">__radd__()</code> method for the reverse addition implementation. If this method returns a value other than the <code class="Code-In-Text--PACKT-">NotImplemented</code> value, this is the result. Note that the operand ordering is reversed. For commutative operations, like addition and multiplication, this does not matter. For non-commutative operations, like subtraction and division, the change in ordering needs to be reflected in the implementation.</li>
    </ol>
    <p class="normal">Let's return to our <a id="_idIndexMarker410"/>handful of dice example. We can implement a <code class="Code-In-Text--PACKT-">+</code> operator to add a <code class="Code-In-Text--PACKT-">Die</code> instance to a collection of <code class="Code-In-Text--PACKT-">Dice</code>. We'll start with a base definition of a class that contains a heterogenous handful of different kinds of dice. Check the previous <code class="Code-In-Text--PACKT-">Dice</code> class, which assumed homogenous dice. This isn't an abstract class; it has a definition of <code class="Code-In-Text--PACKT-">roll</code> that re-rolls all the dice. We'll start with some basics and then incorporate the <code class="Code-In-Text--PACKT-">__add__()</code> special method:</p>
    <pre class="programlisting code"><code class="hljs-code">class DDice:
    def __init__(self, *die_class: Type[Die]) -&gt; None:
        self.dice = [dc() for dc in die_class]
        self.adjust: int = 0
    def plus(self, adjust: int = 0) -&gt; "DDice":
        self.adjust = adjust
        return self
    def roll(self) -&gt; None:
        for d in self.dice:
            d.roll()
    @property
    def total(self) -&gt; int:
        return sum(d.face for d in self.dice) + self.adjust
</code></pre>
    <p class="normal">This shouldn't be much of a surprise. It looks a lot like the <code class="Code-In-Text--PACKT-">Dice</code> class defined above. We've added an <code class="Code-In-Text--PACKT-">adjust</code> attribute set by the <code class="Code-In-Text--PACKT-">plus()</code> method so we can use <code class="Code-In-Text--PACKT-">DDice(D6, D6, D6).plus(2)</code>. It fits better with <a id="_idIndexMarker411"/>some tabletop role-playing games (TTRPGs).</p>
    <p class="normal">Also, recall that we provide the types of the dice to the <code class="Code-In-Text--PACKT-">DDice</code> class, not instances of the dice. We use the class object, <code class="Code-In-Text--PACKT-">D6</code>, not a <code class="Code-In-Text--PACKT-">Die</code> instance, created by an expression like <code class="Code-In-Text--PACKT-">D6()</code>. The instances of the classes are created by <code class="Code-In-Text--PACKT-">DDice</code> in the <code class="Code-In-Text--PACKT-">__init__()</code> method.</p>
    <p class="normal">Here's the cool part: we can use the plus operator with <code class="Code-In-Text--PACKT-">DDice</code> objects, <code class="Code-In-Text--PACKT-">Die</code> classes, and integers to define a complex roll of the dice:</p>
    <pre class="programlisting code"><code class="hljs-code">def __add__(self, die_class: Any) -&gt; "DDice":
    if isinstance(die_class, type) and issubclass(die_class, Die):
        new_classes = [type(d) for d in self.dice] + [die_class]
        new = DDice(*new_classes).plus(self.adjust)
        return new
    elif isinstance(die_class, int):
        new_classes = [type(d) for d in self.dice]
        new = DDice(*new_classes).plus(die_class)
        return new
    else:
        return NotImplemented
def __radd__(self, die_class: Any) -&gt; "DDice":
    if isinstance(die_class, type) and issubclass(die_class, Die):
        new_classes = [die_class] + [type(d) for d in self.dice]
        new = DDice(*new_classes).plus(self.adjust)
        return new
    elif isinstance(die_class, int):
        new_classes = [type(d) for d in self.dice]
        new = DDice(*new_classes).plus(die_class)
        return new
    else:
        return NotImplemented
</code></pre>
    <p class="normal">These two methods are<a id="_idIndexMarker412"/> similar in many ways. We check for three separate kinds of <code class="Code-In-Text--PACKT-">+</code> operations: </p>
    <ul>
      <li class="bullet">If the argument value, <code class="Code-In-Text--PACKT-">die_class</code>, is a type, and it's a subclass of the <code class="Code-In-Text--PACKT-">Die</code> class, then we're adding another <code class="Code-In-Text--PACKT-">Die</code> object to a <code class="Code-In-Text--PACKT-">DDice</code> collection. It's an expression like <code class="Code-In-Text--PACKT-">DDice(D6) + D6 + D6</code>. The semantics of most operator implementations is to create a new object from the previous objects.</li>
      <li class="bullet">If the argument value is an integer, then we're adding an adjustment to a set of dice. This is something like <code class="Code-In-Text--PACKT-">DDice(D6, D6, D6) + 2</code>.</li>
      <li class="bullet">If the argument value is neither a subclass of <code class="Code-In-Text--PACKT-">Die</code> nor an integer, then something else is going on, and this class doesn't have an implementation. This may be some kind of bug, or it might be that the other class involved in the operation can provide an implementation; returning <code class="Code-In-Text--PACKT-">NotImplemented</code> gives the other object a chance at performing the operation.</li>
    </ul>
    <p class="normal">Because we've provided <code class="Code-In-Text--PACKT-">__radd__()</code> as well as <code class="Code-In-Text--PACKT-">__add__()</code>, these operations are commutative. We can use expressions like <code class="Code-In-Text--PACKT-">D6 + DDice(D6) + D6</code> and <code class="Code-In-Text--PACKT-">2 + DDice(D6, D6)</code>.</p>
    <p class="normal">We need to make specific <code class="Code-In-Text--PACKT-">isinstance()</code> checks because Python operators are completely generic, and the expected type hint must be <code class="Code-In-Text--PACKT-">Any</code>. We can only narrow down the applicable types through runtime checks. The <strong class="" style="font-style: italic;">mypy</strong> program is astute about following the branching logic to confirm that an integer object was properly used in an integer context.</p>
    <p class="normal">"But wait," you say. "My favorite game has rules that call for 3d6+2." This is shorthand for rolling three six-sided dice and adding two to the result. In many TTRPGs, this kind of abbreviation is used to summarize the dice.</p>
    <p class="normal">Can we add <a id="_idIndexMarker413"/>multiplication to do this? There's no reason why not. For multiplication, we only need to worry about integers. <code class="Code-In-Text--PACKT-">D6 * D6</code> isn't used in any of the rules, but <code class="Code-In-Text--PACKT-">3*D6 </code>matches the text of most TTRPG rules nicely:</p>
    <pre class="programlisting code"><code class="hljs-code">def __mul__(self, n: Any) -&gt; "DDice":
    if isinstance(n, int):
        new_classes = [type(d) for d in self.dice for _ in range(n)]
        return DDice(*new_classes).plus(self.adjust)
    else:
        return NotImplemented
def __rmul__(self, n: Any) -&gt; "DDice":
    if isinstance(n, int):
        new_classes = [type(d) for d in self.dice for _ in range(n)]
        return DDice(*new_classes).plus(self.adjust)
    else:
        return NotImplemented
</code></pre>
    <p class="normal">These two methods follow a similar design pattern to the <code class="Code-In-Text--PACKT-">__add__()</code> and <code class="Code-In-Text--PACKT-">__radd__()</code> methods. For each existing <code class="Code-In-Text--PACKT-">Die</code> subclass, we'll create several instances of the class. This lets us use <code class="Code-In-Text--PACKT-">3 * DDice(D6) + 2</code> as an expression to define a dice-rolling rule. The Python operator precedence rules still apply, so the <code class="Code-In-Text--PACKT-">3 * DDice(D6)</code> portion is evaluated first.</p>
    <p class="normal">Python's use of the various <code class="Code-In-Text--PACKT-">__</code><em class="italic">op</em><code class="Code-In-Text--PACKT-">__()</code> and <code class="Code-In-Text--PACKT-">__r</code><em class="italic">op</em><code class="Code-In-Text--PACKT-">__()</code> methods works out extremely well for applying the various operators to objects that are immutable: strings, numbers, and tuples being the primary examples. Our handful of dice presents a bit of a head-scratcher because the state of the individual dice can change. What's important is that we treat the composition of the hand as immutable. Each operation on a <code class="Code-In-Text--PACKT-">DDice</code> object creates a new <code class="Code-In-Text--PACKT-">DDice</code> instance.</p>
    <p class="normal">What about mutable objects? When we write an assignment statement like <code class="Code-In-Text--PACKT-">some_list += [some_item]</code>, we're mutating the value of the <code class="Code-In-Text--PACKT-">some_list</code> object. The <code class="Code-In-Text--PACKT-">+=</code> statement does the same thing as the more complex expression <code class="Code-In-Text--PACKT-">some_list.extend([some_item])</code>. Python supports this with operators with names like <code class="Code-In-Text--PACKT-">__iadd__()</code> and <code class="Code-In-Text--PACKT-">__imul__()</code>. These are "in-place" operations, designed to mutate objects.</p>
    <p class="normal">For example, consider: </p>
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; y = DDice(D6, D6)
&gt;&gt;&gt; y += D6
</code></pre>
    <p class="normal">This can be processed one of two ways:</p>
    <ul>
      <li class="bullet">If <code class="Code-In-Text--PACKT-">DDice</code> implements <code class="Code-In-Text--PACKT-">__iadd__()</code>, this becomes <code class="Code-In-Text--PACKT-">y.__iadd__(D6)</code>. The object can mutate itself in place.</li>
      <li class="bullet">If <code class="Code-In-Text--PACKT-">DDice</code> does not implement <code class="Code-In-Text--PACKT-">__iadd__()</code>, this is <code class="Code-In-Text--PACKT-">y = y.__add__(D6)</code>. The object creates a new, immutable object, and that's given the old object's variable name. This lets us do things like <code class="Code-In-Text--PACKT-">string_variable += "."</code>. Under the hood, <code class="Code-In-Text--PACKT-">string_variable</code> is not mutated; it's replaced.</li>
    </ul>
    <p class="normal">If it makes sense for an<a id="_idIndexMarker414"/> object to be mutable, we can support in-place mutation of a <code class="Code-In-Text--PACKT-">DDice</code> object with this method:</p>
    <pre class="programlisting code"><code class="hljs-code">def __iadd__(self, die_class: Any) -&gt; "DDice":
    if isinstance(die_class, type) and issubclass(die_class, Die):
        self.dice += [die_class()]
        return self
    elif isinstance(die_class, int):
        self.adjust += die_class
        return self
    else:
        return NotImplemented
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">__iadd__()</code> method appends to the internal collection of dice. It follows rules similar to the <code class="Code-In-Text--PACKT-">__add__()</code> methods: when a class is provided, an instance is created, and it's added to the <code class="Code-In-Text--PACKT-">self.dice</code> list; if an integer is provided, it's added to the <code class="Code-In-Text--PACKT-">self.adjust</code> value. </p>
    <p class="normal">We can now perform incremental changes to a single dice-rolling rule. We can mutate the state of a single <code class="Code-In-Text--PACKT-">DDice</code> object using assignment statements. Because the object mutates, we aren't creating a lot of copies of the object. The creation of complex dice looks like this:</p>
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; y = DDice(D6, D6)
&gt;&gt;&gt; y += D6
&gt;&gt;&gt; y += 2
</code></pre>
    <p class="normal">This builds the 3d6+2 dice roller in incremental pieces. </p>
    <p class="normal">The use of the internal<a id="_idIndexMarker415"/> special method names allows for seamless integration with other Python features. We can build classes using <code class="Code-In-Text--PACKT-">collections.abc</code> that fit with existing collections. We can override the methods implementing the Python operators to create easy-to-use syntax.</p>
    <p class="normal">We can leverage the special method names to add features to Python's built-in generic collections. We'll turn to that topic next.</p>
    <h1 id="_idParaDest-124" class="title">Extending built-ins</h1>
    <p class="normal">Python has two collections of <a id="_idIndexMarker416"/>built-ins that we might want to extend. We can broadly classify these into the following:</p>
    <ul>
      <li class="bullet">Immutable objects, including<a id="_idIndexMarker417"/> numbers, strings, bytes, and tuples. These will often have extended operators defined. In the <em class="italic">Operator overloading</em> section of this chapter, we looked at how we can provide arithmetic operations for objects of the <code class="Code-In-Text--PACKT-">Dice</code> class.</li>
      <li class="bullet">Mutable collections, including<a id="_idIndexMarker418"/> sets, lists, and dictionaries. When we look at the definitions in <code class="Code-In-Text--PACKT-">collections.abc</code>, these are sized, iterable containers, three distinct aspects that we might want to focus on. In <em class="italic">The collections.abc module</em> section of this chapter, we looked at creating an extension to the <code class="Code-In-Text--PACKT-">Mapping</code> abstract base class.</li>
    </ul>
    <p class="normal">There are other built-in types, but these two groupings are generally applicable to a variety of problems. For example, we could create a dictionary that rejects duplicate values.</p>
    <p class="normal">The built-in dictionary always updates the value associated with a key. This can lead to odd-looking code that works. For example:</p>
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; d = {"a": 42, "a": 3.14}
&gt;&gt;&gt; d
{'a': 3.14}
</code></pre>
    <p class="normal">And: </p>
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; {1: "one", True: "true"}
{1: 'true'}
</code></pre>
    <p class="normal">These are well-defined behaviors. It may be odd-looking to provide two keys in the expression but have only one key in the result, but the rules for building dictionaries make these inevitable and correct results.</p>
    <p class="normal">We may, however, not like <a id="_idIndexMarker419"/>the behavior of silently ignoring a key. It may make our application needlessly complex to worry about the possibility of duplicates. Let's create a new kind of dictionary that won't update items once they've been loaded.</p>
    <p class="normal">Studying <code class="Code-In-Text--PACKT-">collections.abc</code>, we need to extend a mapping, with a changed definition of <code class="Code-In-Text--PACKT-">__setitem__()</code> to prevent updating an existing key. Working at the interactive Python prompt, we can try this:</p>
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; from typing import Dict, Hashable, Any, Mapping, Iterable
&gt;&gt;&gt; class NoDupDict(Dict[Hashable, Any]):
...     def __setitem__(self, key, value) -&gt; None:
...         if key in self:
...             raise ValueError(f"duplicate {key!r}")
...         super().__setitem__(key, value)
</code></pre>
    <p class="normal">And when we put it to use, we see the following:</p>
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; nd = NoDupDict()
&gt;&gt;&gt; nd["a"] = 1
&gt;&gt;&gt; nd["a"] = 2
Traceback (most recent call last):
  ...
  File "&lt;doctest examples.md[10]&gt;", line 1, in &lt;module&gt;
    nd["a"] = 2
  File "&lt;doctest examples.md[7]&gt;", line 4, in __setitem__
    raise ValueError(f"duplicate {key!r}")
ValueError: duplicate 'a'
</code></pre>
    <p class="normal">We're not done, but we're off to a good start. This dictionary rejects duplicates under some circumstances.</p>
    <p class="normal">However, it isn't blocking duplicate keys when we try to construct a dictionary from another dictionary. We don't want this to work:</p>
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; NoDupDict({"a": 42, "a": 3.14})
{'a': 3.14}
</code></pre>
    <p class="normal">So we've got some work to do. Some expressions properly raise exceptions, where as other expressions still silently ignore duplicate keys.</p>
    <p class="normal">The basic problem is that not all methods that set items are using <code class="Code-In-Text--PACKT-">__setitem__()</code>. To alleviate the above problems, we'll need to override <code class="Code-In-Text--PACKT-">__init__()</code> as well.</p>
    <p class="normal">We'll also need to add type hints to our initial draft. This will let us leverage <strong class="" style="font-style: italic;">mypy</strong> to confirm that our <a id="_idIndexMarker420"/>implementation will work in general. Here's a version with <code class="Code-In-Text--PACKT-">__init__()</code> added:</p>
    <pre class="programlisting code"><code class="hljs-code">from __future__ import annotations
from typing import cast, Any, Union, Tuple, Dict, Iterable, Mapping
from collections import Hashable
DictInit = Union[
    Iterable[Tuple[Hashable, Any]],     Mapping[Hashable, Any], 
    None]
class NoDupDict(Dict[Hashable, Any]):
    def __setitem__(self, key: Hashable, value: Any) -&gt; None:
        if key in self:
            raise ValueError(f"duplicate {key!r}")
        super().__setitem__(key, value)
    def __init__(self, init: DictInit = None, **kwargs: Any) -&gt; None:
        if isinstance(init, Mapping):
            super().__init__(init, **kwargs)
        elif isinstance(init, Iterable):
            for k, v in cast(Iterable[Tuple[Hashable, Any]], init):
                self[k] = v
        elif init is None:
            super().__init__(**kwargs)
        else:
            super().__init__(init, **kwargs)
</code></pre>
    <p class="normal">This version of the <code class="Code-In-Text--PACKT-">NoDupDict</code> class implements an <code class="Code-In-Text--PACKT-">__init__()</code> method that will work with a variety of data types. We enumerated the various types using the <code class="Code-In-Text--PACKT-">DictInit</code> type hint. This includes a sequence of <em class="italic">key-value</em> pairs, as well as another mapping. In the case of a sequence of key-value pairs, we can use the previously defined <code class="Code-In-Text--PACKT-">__setitem__()</code> to raise an exception in the event of duplicate key values.</p>
    <p class="normal">This covers the initialization use cases, but – still – doesn't cover every method that can update a mapping. We still have to implement <code class="Code-In-Text--PACKT-">update()</code>, <code class="Code-In-Text--PACKT-">setdefault()</code>, <code class="Code-In-Text--PACKT-">_</code><code class="Code-In-Text--PACKT-">_or__()</code>, and <code class="Code-In-Text--PACKT-">__ior__()</code> to extend all the methods that can mutate a dictionary. While this is a pile of work to create, the work is encapsulated in a dictionary subclass that we can use in our application. This subclass is completely compatible with built-in classes; it implements many methods we didn't write, and it has one extra feature we did write.</p>
    <p class="normal">We've built a more<a id="_idIndexMarker421"/> complex dictionary that extends the core features of a Python <code class="Code-In-Text--PACKT-">dict</code> class. Our version adds a feature to reject duplicates. We've also touched on the use of <code class="Code-In-Text--PACKT-">abc.ABC</code> (and <code class="Code-In-Text--PACKT-">abc.ABCMeta</code>) to create abstract base classes. There are times when we might want to take more direct control of the mechanics of creating a new class. We'll turn next to metaclasses.</p>
    <h1 id="_idParaDest-125" class="title">Metaclasses</h1>
    <p class="normal">As we noted earlier, creating a<a id="_idIndexMarker422"/> new class involves work done by the <code class="Code-In-Text--PACKT-">type</code> class. The job of the <code class="Code-In-Text--PACKT-">type</code> class is to create an empty class object so the various definitions and attributes assignment statements will build the final, usable class we need for our application.</p>
    <p class="normal">Here's how it works:</p>
    <figure class="mediaobject"><img src="img/B17070_06_03.png" alt="Diagram  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 6.3: How type creates MyClass</p>
    <p class="normal">The <code class="Code-In-Text--PACKT-">class</code> statement is <a id="_idIndexMarker423"/>used to locate the appropriate metaclass; if no special <code class="Code-In-Text--PACKT-">metaclass=</code> is provided, then the <code class="Code-In-Text--PACKT-">type</code> class is used. The <code class="Code-In-Text--PACKT-">type</code> class will prepare a new, empty dictionary, called a namespace, and then the various statements in the class populate this container with attributes and method definitions. Finally, the "new" step completes creation of the class; this is generally where we can make our changes.</p>
    <p class="normal">Here's a diagram showing how we can use a new class, SpecialMeta, to tap into the way <code class="Code-In-Text--PACKT-">type</code> builds a new class for us:</p>
    <figure class="mediaobject"><img src="img/B17070_06_04.png" alt="Diagram  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 6.4: Extending the type class</p>
    <p class="normal">If we <a id="_idIndexMarker424"/>use the <code class="Code-In-Text--PACKT-">metaclass=</code> option when creating a class, we change the metaclass that's used. In the preceding diagram, <code class="Code-In-Text--PACKT-">SpecialMeta</code> is a subclass of the <code class="Code-In-Text--PACKT-">type</code> class, and it can do some special processing for our class definitions.</p>
    <p class="normal">While there are some clever things we can do with this technique, it's important to keep metaclasses in perspective. They change the way class objects are built, with the potential to redefine what it means to be a class. This can drastically shift the foundation of Pythonic object-oriented programming. It can lead to frustration when people reading and maintaining the code can't figure out why something works; it should not be undertaken lightly.</p>
    <p class="normal">Let's look at a metaclass that builds a few small features into a class definition for us. Let's continue to extend the dice simulation examples from earlier in this chapter. We may have a number of classes of die, each an instance of the abstract base class <code class="Code-In-Text--PACKT-">Die</code>. We'd like them all to have an audit log surrounding the <code class="Code-In-Text--PACKT-">roll()</code> method supplied by the implementation. We'd like to track each roll separately, perhaps so someone can review them for their statistical validity.</p>
    <p class="normal">Because we don't want to force the programmers of various kinds of dice to include any extra or new code, we prefer to add logging to the abstract base class for all <code class="Code-In-Text--PACKT-">Die</code> classes, and also adjust the concrete implementation of the <code class="Code-In-Text--PACKT-">roll()</code> method to create logging output.</p>
    <p class="normal">This is a tall order. It's <a id="_idIndexMarker425"/>made a little more challenging because we're working with abstract classes. This requires some care to disentangle abstract class construction from concrete class construction. We don't want to force programmers to change their concrete <code class="Code-In-Text--PACKT-">Die</code> class definitions.</p>
    <p class="normal">To solve this problem using metaclasses, we need to do three things to each concrete <code class="Code-In-Text--PACKT-">Die</code>-related class that gets built:</p>
    <ol>
      <li class="numbered" value="1">Extend the <code class="Code-In-Text--PACKT-">ABCMeta</code> metaclass. We need to support the <code class="Code-In-Text--PACKT-">@abc.abstractmethod</code> decoration, so we want all the existing metaclass features from the built-in <code class="Code-In-Text--PACKT-">type</code> metaclass.</li>
      <li class="numbered">Inject a <code class="Code-In-Text--PACKT-">logger</code> attribute into each class. It's common to have the logger name match the class name; this is easy to do in a metaclass. We can create the logger as part of the class, prior to any instances of the class being created.</li>
      <li class="numbered">Wrap the concrete <code class="Code-In-Text--PACKT-">roll()</code> method into a function that uses the programmer's supplied <code class="Code-In-Text--PACKT-">roll()</code> method, but also writes a message to the logger. This is similar to the way a method decorator works.</li>
    </ol>
    <p class="normal">The metaclass definition needs a <code class="Code-In-Text--PACKT-">__new__()</code> method to make slight adjustments to the way the final class is built. We don't need to extend the <code class="Code-In-Text--PACKT-">__prepare__()</code> method. Our <code class="Code-In-Text--PACKT-">__new__()</code> method will use <code class="Code-In-Text--PACKT-">abc.ABCMeta.__new__()</code> to build the final class object. This <code class="Code-In-Text--PACKT-">ABCMeta</code> class will decide if the object is concrete or remains abstract because <code class="Code-In-Text--PACKT-">roll()</code> was not defined:</p>
    <pre class="programlisting code"><code class="hljs-code">import logging
from functools import wraps
from typing import Type, Any
class DieMeta(abc.ABCMeta):
    def __new__(
        metaclass: Type[type],
        name: str,
        bases: tuple[type, ...],
        namespace: dict[str, Any],
        **kwargs: Any,
    ) -&gt; "DieMeta":
        if "roll" in namespace and not getattr(
            namespace["roll"], "__isabstractmethod__", False
        ):
            namespace.setdefault("logger", logging.getLogger(name))
            original_method = namespace["roll"]
            @wraps(original_method)
            def logged_roll(self: "DieLog") -&gt; None:
                original_method(self)
                self.logger.info(f"Rolled {self.face}")
            namespace["roll"] = logged_roll
        new_object = cast(
            "DieMeta", abc.ABCMeta.__new__(
                 metaclass, name, bases, namespace)
        )
        return new_object
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">__new__()</code> method is<a id="_idIndexMarker426"/> given a bewildering pile of argument values:</p>
    <ul>
      <li class="bullet">The <code class="Code-In-Text--PACKT-">metaclass</code> parameter is a reference to the metaclass doing the work. Python doesn't generally create and use instances of metaclasses. Instead, the metaclass itself is passed as a parameter to each method. It's a bit like the <code class="Code-In-Text--PACKT-">self</code> value provided to an object, but it's the class, not an instance of a class.</li>
      <li class="bullet">The <code class="Code-In-Text--PACKT-">name</code> parameter is the name of the target class, taken from the original <code class="Code-In-Text--PACKT-">class</code> statement. </li>
      <li class="bullet">The <code class="Code-In-Text--PACKT-">bases</code> parameter is the list of base classes. These are the mixins, sorted into method resolution order. In this example, it will be the superclass we'll define that uses this metaclass, <code class="Code-In-Text--PACKT-">DieLog</code>, shown shortly below.</li>
      <li class="bullet">The <code class="Code-In-Text--PACKT-">namespace</code> parameter is a dictionary that was started by the <code class="Code-In-Text--PACKT-">__prepare__()</code> method of the built-in <code class="Code-In-Text--PACKT-">type</code> class. The dictionary was updated when the body of the class was executed; <code class="Code-In-Text--PACKT-">def</code> statements and assignment statements will create items in this dictionary. When we get to the <code class="Code-In-Text--PACKT-">__new__()</code> method, the methods (and variables) of the class are staged here, waiting to build the final class object.</li>
      <li class="bullet">The <code class="Code-In-Text--PACKT-">kwargs</code> parameter will have any keyword arguments provided as part of the class definition. If we used a statement like <code class="Code-In-Text--PACKT-">class D6L(DieLog, otherparam="something")</code> to create a new class, then the <code class="Code-In-Text--PACKT-">otherparam</code> would be one of the <code class="Code-In-Text--PACKT-">kwargs</code> to <code class="Code-In-Text--PACKT-">__new__()</code>.</li>
    </ul>
    <p class="normal">The <code class="Code-In-Text--PACKT-">__new__()</code> method must return the new class definition. Generally, this is the result of using the superclass <code class="Code-In-Text--PACKT-">__new__()</code> method to build the class object. In our case, the superclass method is <code class="Code-In-Text--PACKT-">abc.ABCMeta.__new__()</code>.</p>
    <p class="normal">Within this method, the <code class="Code-In-Text--PACKT-">if</code> statement checks to see if the class being built defined the needed <code class="Code-In-Text--PACKT-">roll()</code> method. If the<a id="_idIndexMarker427"/> method is marked with the <code class="Code-In-Text--PACKT-">@abc.abstractmethod</code> decorator, then the method will have an attribute of <code class="Code-In-Text--PACKT-">__isabstractmethod__</code> and the value of the attribute will be <code class="Code-In-Text--PACKT-">True</code>. For a concrete method – without a decorator – there will be no <code class="Code-In-Text--PACKT-">__isabstractmethod__</code> attribute value. The condition confirms there's a <code class="Code-In-Text--PACKT-">roll()</code> method and if that <code class="Code-In-Text--PACKT-">roll()</code> method is concrete.</p>
    <p class="normal">For classes with a concrete <code class="Code-In-Text--PACKT-">roll()</code> method, we'll add <code class="Code-In-Text--PACKT-">"logger"</code> to the namespace that was built, providing a default value of an appropriately named logger. If a logger is already present, we'll leave it in place.</p>
    <p class="normal">Next, <code class="Code-In-Text--PACKT-">namespace["roll"]</code> picks out the function defined in the concrete class, the <code class="Code-In-Text--PACKT-">roll</code> method. We'll define a replacement method, <code class="Code-In-Text--PACKT-">logged_roll</code>. To be sure the new <code class="Code-In-Text--PACKT-">logged_roll()</code> method looks like the original method, we've used the <code class="Code-In-Text--PACKT-">@wraps</code> decorator. This will copy the original method name and docstring onto the new method, making it look like the definition originally present in the class. This is put back into the namespace so it can be incorporated into the new class.</p>
    <p class="normal">Finally, we evaluate <code class="Code-In-Text--PACKT-">abc.ABCMeta.__new__()</code> with the metaclass, the class name, the base classes, and the namespace that we modified if there was a concrete implementation of the <code class="Code-In-Text--PACKT-">roll()</code> method. The <code class="Code-In-Text--PACKT-">__new__()</code> operation finalizes the class, doing all the original Python housekeeping.</p>
    <p class="normal">It can be awkward to use a metaclass; for this reason, it's common to provide a superclass that uses the metaclass. This means our application can extend the superclass without having to fuss around with an extra <code class="Code-In-Text--PACKT-">metaclass=</code> parameter in the class definition:</p>
    <pre class="programlisting code"><code class="hljs-code">class DieLog(metaclass=DieMeta):
    logger: logging.Logger
    def __init__(self) -&gt; None:
        self.face: int
        self.roll()
    @abc.abstractmethod
    def roll(self) -&gt; None:
        ...
    def __repr__(self) -&gt; str:
        return f"{self.face}"
</code></pre>
    <p class="normal">This superclass, <code class="Code-In-Text--PACKT-">DieLog</code>, is built by the metaclass. Any subclass of this class will also be built by the metaclass.</p>
    <p class="normal">Now, our application <a id="_idIndexMarker428"/>can create subclasses of <code class="Code-In-Text--PACKT-">DieLog</code>, without having to worry about the details of the metaclass: we don't have to remember to include <code class="Code-In-Text--PACKT-">metaclass=</code> in the definition. Our final application classes are quite streamlined:</p>
    <pre class="programlisting code"><code class="hljs-code">class D6L(DieLog):
    def roll(self) -&gt; None:
        """Some documentation on D6L"""
        self.face = random.randrange(1, 7)
</code></pre>
    <p class="normal">We've created a dice roller here that logs each roll in a logger named after the class. Here's how it looks logging to the console:</p>
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; import sys
&gt;&gt;&gt; logging.basicConfig(stream=sys.stdout, level=logging.INFO)
&gt;&gt;&gt; d2 = D6L()
INFO:D6L:Rolled 1
&gt;&gt;&gt; d2.face
1
</code></pre>
    <p class="normal">The details of the logging aspect of this <code class="Code-In-Text--PACKT-">D6L</code> class are completely divorced from the application-specific processing of this class. We can change the metaclass to change details of the logging, knowing that all of the relevant application classes will be changed when the metaclass changes.</p>
    <p class="normal">Since a metaclass changes how a class is built, there are no boundaries on the kinds of things a metaclass can do. The common advice is to keep the metaclass features very small because they're obscure. As written, the <code class="Code-In-Text--PACKT-">logged_roll()</code> method of the metaclass will discard any return value from the concrete <code class="Code-In-Text--PACKT-">roll()</code> method in a subclass.</p>
    <h1 id="_idParaDest-126" class="title">Case study</h1>
    <p class="normal">We'll refine our<a id="_idIndexMarker429"/> case study in this chapter. Previously, in <em class="chapterRef">Chapter 2</em>, <em class="italic">Objects in Python</em>, we talked in a vague way about loading the training data and splitting it into two clumps – the training set and the testing set. In <em class="chapterRef">Chapter 5</em>, <em class="italic">When to Use Object-Oriented Programming</em>, we looked at ways to deserialize the source file into <code class="Code-In-Text--PACKT-">Sample</code> instances.</p>
    <p class="normal">In this chapter, we want to look further at this operation of using the raw data to create a number of <code class="Code-In-Text--PACKT-">TrainingKnownSample</code> instances separate from a number of <code class="Code-In-Text--PACKT-">TestingKnownSample</code> instances. In the previous chapter, we identified four cases for sample objects, shown in the following table:</p>
    <table id="table001-2" class="No-Table-Style _idGenTablePara-1">
      <colgroup>
        <col/>
        <col/>
        <col/>
      </colgroup>
      <thead>
        <tr class="No-Table-Style">
          <td class="No-Table-Style"/>
          <td class="No-Table-Style">
            <p class="Table-Column-Heading--PACKT-">Known</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Heading--PACKT-">Unknown</p>
          </td>
        </tr>
      </thead>
      <tbody>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Heading--PACKT-">Unclassified</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Training data</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Sample waiting to be classified</p>
          </td>
        </tr>
        <tr class="No-Table-Style">
          <td class="No-Table-Style">
            <p class="Table-Column-Heading--PACKT-">Classified</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Testing data</p>
          </td>
          <td class="No-Table-Style">
            <p class="Table-Column-Content--PACKT-">Classified sample</p>
          </td>
        </tr>
      </tbody>
    </table>
    <p class="normal">When looking at the known samples, classified by a Botanist, we need to split the data into two separate classes. We'll use a variety of approaches to do this, including a number of overloaded comparison operations.</p>
    <p class="normal">Our training data sorting can be approached from two distinct directions:</p>
    <ul>
      <li class="bullet">We can ingest all the raw data, then distribute it into two collections for later use</li>
      <li class="bullet">During the process of ingestion, we can make selections among the collections</li>
    </ul>
    <p class="normal">The net effect is the same. Working with an entire collection can be relatively simple, while using a great deal of memory. Processing items individually can be more complex, without requiring as much memory.</p>
    <p class="normal">We'll start by building some sophisticated collections. The first will be a list that tracks two sublists.</p>
    <h2 id="_idParaDest-127" class="title">Extending the list class with two sublists</h2>
    <p class="normal">We can extend the <a id="_idIndexMarker430"/>built-in <code class="Code-In-Text--PACKT-">list</code> class to add some features. It's important to note that extending built-in types can be tricky because the type hints for these types are sometimes surprisingly complex.</p>
    <p class="normal">Python's built-in structures like <code class="Code-In-Text--PACKT-">list</code> have a variety of initialization alternatives:</p>
    <ul>
      <li class="bullet">We can use <code class="Code-In-Text--PACKT-">list()</code> to create an empty list</li>
      <li class="bullet">We can use <code class="Code-In-Text--PACKT-">list(x)</code> to create a list from an iterable source of data</li>
    </ul>
    <p class="normal">To make this clear to <strong class="" style="font-style: italic;">mypy</strong>, we need to use the <code class="Code-In-Text--PACKT-">@overload</code> decorator; this will expose the two distinct ways the <code class="Code-In-Text--PACKT-">list</code> class <code class="Code-In-Text--PACKT-">__init__()</code> method is used:</p>
    <pre class="programlisting code"><code class="hljs-code">class SamplePartition(List[SampleDict], abc.ABC):
    @overload
    def __init__(self, *, training_subset: float = 0.80) -&gt; None:
        ...
    @overload
    def __init__(
        self,
        iterable: Optional[Iterable[SampleDict]] = None,
        *,
        training_subset: float = 0.80,
    ) -&gt; None:
        ...
    def __init__(
        self,
        iterable: Optional[Iterable[SampleDict]] = None,
        *,
        training_subset: float = 0.80,
    ) -&gt; None:
        self.training_subset = training_subset
        if iterable:
            super().__init__(iterable)
        else:
            super().__init__()
    @abc.abstractproperty
    @property
    def training(self) -&gt; List[TrainingKnownSample]:
        ...
    @abc.abstractproperty
    @property
    def testing(self) -&gt; List[TestingKnownSample]:
        ...
</code></pre>
    <p class="normal">We've defined two overloads for the <code class="Code-In-Text--PACKT-">__init__()</code> method; these are the formalisms to tell <strong class="" style="font-style: italic;">mypy</strong> what our intent is. The first overload is <code class="Code-In-Text--PACKT-">__init__()</code> with no positional parameters. This<a id="_idIndexMarker431"/> should create an empty list of <code class="Code-In-Text--PACKT-">SampleDict</code> objects. The second overload is <code class="Code-In-Text--PACKT-">__init__()</code> with an iterable source of <code class="Code-In-Text--PACKT-">SampleDict</code> objects as the only positional parameter. The lonely <code class="Code-In-Text--PACKT-">*</code> separates parameters where the argument value can be provided positionally from parameters where the argument value must be provided as a keyword. The <code class="Code-In-Text--PACKT-">training_subset</code> parameter will stand out from the ordinary list-like initializer.</p>
    <p class="normal">The third definition is the actual implementation. This definition of the <code class="Code-In-Text--PACKT-">__init__()</code> method lacks the <code class="Code-In-Text--PACKT-">@overload</code> decorator. The implementation uses the superclass'<code class="Code-In-Text--PACKT-"> </code><code class="Code-In-Text--PACKT-">__init__()</code> method to build a <code class="Code-In-Text--PACKT-">List[SampleDict]</code> object. A subclass might want to extend this method to partition the data when creating a <code class="Code-In-Text--PACKT-">SamplePartition</code> object.</p>
    <p class="normal">The intent is to be able to subclass this with a class having a name like <code class="Code-In-Text--PACKT-">SomeSamplePartition</code>, and use <code class="Code-In-Text--PACKT-">data = SomeSamplePartition(data, training_subset=0.67)</code> to create an object, <code class="Code-In-Text--PACKT-">data</code>, which is a list with a few extra features.</p>
    <p class="normal">Since this is a superclass, we haven't provided a definition for the <code class="Code-In-Text--PACKT-">training</code> or <code class="Code-In-Text--PACKT-">testing</code> properties. Each algorithm can have different implementations of the methods that provide values for these attributes.</p>
    <p class="normal">This depends on the following <code class="Code-In-Text--PACKT-">SampleDict</code> definition:</p>
    <pre class="programlisting code"><code class="hljs-code">class SampleDict(TypedDict):
    sepal_length: float
    sepal_width: float
    petal_length: float
    petal_width: float
    species: str
</code></pre>
    <p class="normal">This tells <strong class="" style="font-style: italic;">mypy</strong> that we're working with a dictionary that has only the five supplied keys and no others. This can support some validation to check that literal key values match this set.</p>
    <p class="normal">Let's look at some subclasses that provide different partitioning strategies. We'll start with one that shuffles and cuts, like a deck of cards.</p>
    <h2 id="_idParaDest-128" class="title">A shuffling strategy for partitioning</h2>
    <p class="normal">One alternative<a id="_idIndexMarker432"/> is to shuffle and cut a list – precisely the way a deck of cards is shuffled and cut before a game. We can use <code class="Code-In-Text--PACKT-">random.shuffle()</code> to handle the randomized shuffling. The cut is – in a way – a hyperparameter. How large should the training set be compared to the testing set? Suggestions for knowledgeable data scientists include 80% to 20%, 67% to 33%, and an even 50% to 50% split. Because expert opinion varies, we need to provide a way for a scientist to adjust the partition ratio. </p>
    <p class="normal">We'll make the split a feature of the class. We can create separate subclasses to implement alternative splits. Here's a shuffling implementation:</p>
    <pre class="programlisting code"><code class="hljs-code">class ShufflingSamplePartition(SamplePartition):
    def __init__(
        self,
        iterable: Optional[Iterable[SampleDict]] = None,
        *,
        training_subset: float = 0.80,
    ) -&gt; None:
        super().__init__(iterable, training_subset=training_subset)
        self.split: Optional[int] = None
    def shuffle(self) -&gt; None:
        if not self.split:
            random.shuffle(self)
            self.split = int(len(self) * self.training_subset)
    @property
    def training(self) -&gt; List[TrainingKnownSample]:
        self.shuffle()
        return [TrainingKnownSample(**sd) for sd in self[: self.split]]
    @property
    def testing(self) -&gt; List[TestingKnownSample]:
        self.shuffle()
        return [TestingKnownSample(**sd) for sd in self[self.split :]]
</code></pre>
    <p class="normal">Since we're extending the <code class="Code-In-Text--PACKT-">SamplePartition</code> superclass, we can leverage the overloaded <code class="Code-In-Text--PACKT-">__init__()</code> method definitions. For this subclass, we need to provide a concrete implementation compatible with the superclass. </p>
    <p class="normal">The two <a id="_idIndexMarker433"/>properties, <code class="Code-In-Text--PACKT-">training</code> and <code class="Code-In-Text--PACKT-">testing</code>, both make use of an internal <code class="Code-In-Text--PACKT-">shuffle() </code>method. This method uses the split attribute to make sure it will shuffle the samples exactly one time. In addition to tracking whether or not the data is shuffled, the <code class="Code-In-Text--PACKT-">self.split</code> attribute also shows where to split the samples into training and test subsets.</p>
    <p class="normal">The <code class="Code-In-Text--PACKT-">training</code> and <code class="Code-In-Text--PACKT-">testing</code> properties also use Python list slicing to subdivide the raw <code class="Code-In-Text--PACKT-">SampleDict</code> objects, and build useful <code class="Code-In-Text--PACKT-">TrainingKnownSample</code> and <code class="Code-In-Text--PACKT-">TestingKnownSample</code> objects from the raw data. These rely on a list comprehension to apply a class constructor, for example <code class="Code-In-Text--PACKT-">TrainingKnownSample</code>, to the dictionary of row values in a subset of the list, <code class="Code-In-Text--PACKT-">self[: self.split]]</code>. The list comprehension saves us from building a list with a <code class="Code-In-Text--PACKT-">for</code> statement and a bunch of <code class="Code-In-Text--PACKT-">append()</code> operations. We'll look at even more variations of this in <em class="chapterRef">Chapter 10</em>, <em class="italic">The Iterator Pattern</em>.</p>
    <p class="normal">Because this depends on the <code class="Code-In-Text--PACKT-">random</code> module, the results are difficult to predict, making testing needless complex. Many data scientists want the data shuffled, but they also want reproducible results. By setting <code class="Code-In-Text--PACKT-">random.seed()</code> to a fixed value, we can create random, but reproducible, collections of samples. </p>
    <p class="normal">This works as follows:</p>
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; import random
&gt;&gt;&gt; from model import ShufflingSamplePartition
&gt;&gt;&gt; from pprint import pprint
&gt;&gt;&gt; data = [
...     {
...         "sepal_length": i + 0.1,
...         "sepal_width": i + 0.2,
...         "petal_length": i + 0.3,
...         "petal_width": i + 0.4,
...         "species": f"sample {i}",
...     }
...     for i in range(10)
... ]
&gt;&gt;&gt; random.seed(42)
&gt;&gt;&gt; ssp = ShufflingSamplePartition(data)
&gt;&gt;&gt; pprint(ssp.testing)
[TestingKnownSample(sepal_length=0.1, sepal_width=0.2, petal_length=0.3, petal_width=0.4, species='sample 0', classification=None, ),
 TestingKnownSample(sepal_length=1.1, sepal_width=1.2, petal_length=1.3, petal_width=1.4, species='sample 1', classification=None, )]
</code></pre>
    <p class="normal">With a random seed of <code class="Code-In-Text--PACKT-">42</code>, we always get the same two samples in the testing set.</p>
    <p class="normal">This allows us to build the initial list in a variety of ways. We can, for example, append data items to an empty list, like this:</p>
    <pre class="programlisting code"><code class="hljs-code">ssp = ShufflingSamplePartition(training_subset=0.67)
for row in data:
    ssp.append(row)
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">SamplePartition</code> subclass<a id="_idIndexMarker434"/> of <code class="Code-In-Text--PACKT-">list</code> will inherit all the methods of the parent class. This allows us to make changes to the internal state of the list prior to extracting the training and testing subsets. We've added the sizing parameter as a keyword-only parameter to make sure it's clearly separated from the list object used to initialize the list.</p>
    <h2 id="_idParaDest-129" class="title">An incremental strategy for partitioning</h2>
    <p class="normal">We have an <a id="_idIndexMarker435"/>alternative to splitting a single list after it's been built. Instead of extending the <code class="Code-In-Text--PACKT-">list</code> class to provide two sub-lists, we can reframe the problem slightly. Let's define a subclass of <code class="Code-In-Text--PACKT-">SamplePartition</code> that makes a random choice between testing and training on each <code class="Code-In-Text--PACKT-">SampleDict</code> object that is presented via initialization, or the <code class="Code-In-Text--PACKT-">append()</code> or <code class="Code-In-Text--PACKT-">extend()</code> methods.</p>
    <p class="normal">Here's an abstraction that summarizes our thinking on this. We'll have three methods for building a list, and two properties that will provide the training and testing sets, as below. We don't inherit from <code class="Code-In-Text--PACKT-">List</code> because we're not providing any other list-like features, not even <code class="Code-In-Text--PACKT-">__len__()</code>. The class has only five methods, as shown:</p>
    <pre class="programlisting code"><code class="hljs-code">class DealingPartition(abc.ABC):
    @abc.abstractmethod
    def __init__(
        self,
        items: Optional[Iterable[SampleDict]],
        *,
        training_subset: Tuple[int, int] = (8, 10),
    ) -&gt; None:
        ...
    @abc.abstractmethod
    def extend(self, items: Iterable[SampleDict]) -&gt; None:
        ...
    @abc.abstractmethod
    def append(self, item: SampleDict) -&gt; None:
        ...
    @property
    @abc.abstractmethod
    def training(self) -&gt; List[TrainingKnownSample]:
        ...
    @property
    @abc.abstractmethod
    def testing(self) -&gt; List[TestingKnownSample]:
        ...
</code></pre>
    <p class="normal">This definition has no concrete implementations. It provides five placeholders where methods can be defined to implement the necessary dealing algorithm. We've changed the definition of the <code class="Code-In-Text--PACKT-">training_subset</code> parameter slightly from the previous example. Here, we've defined it as two integers. This lets us count and deal incrementally.</p>
    <p class="normal">Here's how we<a id="_idIndexMarker436"/> can extend this to create a concrete subclass that wraps two internal collections. We'll break this into two parts – first, building the collections, and then building the properties to expose the values of the collections:</p>
    <pre class="programlisting code"><code class="hljs-code">class CountingDealingPartition(DealingPartition):
    def __init__(
        self,
        items: Optional[Iterable[SampleDict]],
        *,
        training_subset: Tuple[int, int] = (8, 10),
    ) -&gt; None:
        self.training_subset = training_subset
        self.counter = 0
        self._training: List[TrainingKnownSample] = []
        self._testing: List[TestingKnownSample] = []
        if items:
            self.extend(items)
    def extend(self, items: Iterable[SampleDict]) -&gt; None:
        for item in items:
            self.append(item)
    def append(self, item: SampleDict) -&gt; None:
        n, d = self.training_subset
        if self.counter % d &lt; n:
            self._training.append(TrainingKnownSample(**item))
        else:
            self._testing.append(TestingKnownSample(**item))
        self.counter += 1
</code></pre>
    <p class="normal">We've defined an initializer that sets the initial state of two empty collections. Then, it uses the <code class="Code-In-Text--PACKT-">extend()</code> method to build the collections from a source iterable, if it's provided. </p>
    <p class="normal">The <code class="Code-In-Text--PACKT-">extend()</code> method <a id="_idIndexMarker437"/>relies on the <code class="Code-In-Text--PACKT-">append()</code> method to allocate a <code class="Code-In-Text--PACKT-">SampleDict</code> instance to either the testing or training subsets. The <code class="Code-In-Text--PACKT-">append()</code> method actually does all the work. It counts the items and makes a decision based on some modulo arithmetic.</p>
    <p class="normal">The training subset is defined as a fraction; we've shown it defined as a tuple, (8, 10), with a comment suggesting this means 8/10 or 80% training, the remainder for testing. For a given counter value, <em class="italic">c</em>, if <em class="italic">c </em><em class="italic">&lt; 8 (mod 10)</em>, we'll call it training, while if <em class="italic">c </em><em class="italic">≥</em><em class="italic"> 8 (mod 10)</em>, we'll call it testing.</p>
    <p class="normal">Here are the remaining two methods that are used to expose the values of the two internal list objects:</p>
    <pre class="programlisting code"><code class="hljs-code">    @property
    def training(self) -&gt; List[TrainingKnownSample]:
        return self._training
    @property
    def testing(self) -&gt; List[TestingKnownSample]:
        return self._testing
</code></pre>
    <p class="normal">To an extent, these<a id="_idIndexMarker438"/> can be seen as useless. It's common in Python to simply name the two internal collections <code class="Code-In-Text--PACKT-">self.training</code> and <code class="Code-In-Text--PACKT-">self.testing</code>. If we use attributes, we don't really need these property methods.</p>
    <p class="normal">We've seen two class designs to partition the source data into testing and training subsets. One version relies on random numbers for shuffling, while the other doesn't rely on a random number generator. There are, of course, other combinations of random-based selection and incremental distribution of items that we've left as exercises for the reader. </p>
    <h1 id="_idParaDest-130" class="title">Recall</h1>
    <p class="normal">Here are some of the key points in this chapter:</p>
    <ul>
      <li class="bullet">Using abstract base class definitions is a way to create class definitions with placeholders. This is a handy technique, and can be somewhat clearer than using <code class="Code-In-Text--PACKT-">raise NotImplementedError</code> in unimplemented methods.</li>
      <li class="bullet">ABCs and type hints provide ways to create class definitions. An ABC is a type hint that can help to clarify the essential features we need from an object. It's common, for example, to use <code class="Code-In-Text--PACKT-">Iterable[X]</code> to emphasize that we need one aspect of a class implementation.</li>
      <li class="bullet">The <code class="Code-In-Text--PACKT-">collections.abc</code> module defines abstract base classes for Python's built-in collections. When we want to make our own unique collect class that can integrate seamlessly with Python, we need to start with the definitions from this module.</li>
      <li class="bullet">Creating your own abstract base class leverages the <code class="Code-In-Text--PACKT-">abc</code> module. The <code class="Code-In-Text--PACKT-">abc.ABC</code> class definition is often a perfect starting point for creating an abstract base class.</li>
      <li class="bullet">The bulk of the work is done by the <code class="Code-In-Text--PACKT-">type</code> class. It's helpful to review this class to understand how classes are created by the methods of <code class="Code-In-Text--PACKT-">type</code>.</li>
      <li class="bullet">Python operators are implemented by special methods in classes. We can – in a way – "overload" an operator by defining appropriate special methods so that the operator works with objects of our unique class.</li>
      <li class="bullet">Extending built-ins is done via a subclass that modifies the behavior of a built-in type. We'll often use <code class="Code-In-Text--PACKT-">super()</code> to leverage the built-in behavior.</li>
      <li class="bullet">We can implement our own metaclasses to change – in a fundamental way – how Python class objects are built.</li>
    </ul>
    <h1 id="_idParaDest-131" class="title">Exercises</h1>
    <p class="normal">We've looked at the concept of defining abstract classes to define some – but not all – common features of two objects. Take a quick look around to see how you can apply these principles to your own work. A script can often be restated as a class; each major step of the work a separate method. Do you have similar-looking scripts that – perhaps – share a common abstract definition? Another place to find things that are partially related is in the classes that describe data files. A spreadsheet file often has small variations in layout; this suggests they have a common abstract relationship, but a method needs to be part of an extension to handle the variations in the layouts.</p>
    <p class="normal">When we think about the <code class="Code-In-Text--PACKT-">DDice</code> class, there's yet another enhancement that would be nice. Right now, the operators are all defined for <code class="Code-In-Text--PACKT-">DDice</code> instances only. In order to create a hand of dice, we need to – somewhere – use a <code class="Code-In-Text--PACKT-">DDice</code> constructor. This leads to <code class="Code-In-Text--PACKT-">3*DDice(D6)+2</code>, which seems to be needlessly wordy.</p>
    <p class="normal">It would be nicer to be able to write <code class="Code-In-Text--PACKT-">3*d6+1</code>. This implies some changes to the design: </p>
    <ol>
      <li class="numbered" value="1">Since we can't (easily) apply operators to classes, we have to work with instances of classes. We've assumed <code class="Code-In-Text--PACKT-">d6 = D6()</code> was used to create a <code class="Code-In-Text--PACKT-">Die</code> instance that can be an operand.</li>
      <li class="numbered">The <code class="Code-In-Text--PACKT-">Die</code> class needs a <code class="Code-In-Text--PACKT-">__mul__()</code> method and an <code class="Code-In-Text--PACKT-">__rmul__()</code> method. When we multiply a <code class="Code-In-Text--PACKT-">Die</code> instance by an integer, this will create a <code class="Code-In-Text--PACKT-">DDice</code> instance populated with the die's type, <code class="Code-In-Text--PACKT-">DDice(type(self))</code>. This is because <code class="Code-In-Text--PACKT-">DDice</code> expects a type and it creates its own instances from the type.</li>
    </ol>
    <p class="normal">This creates a circular relationship between <code class="Code-In-Text--PACKT-">Die</code> and <code class="Code-In-Text--PACKT-">DDice</code>. It doesn't present any real problems because both definitions are in the same module. We can use strings in the type hints, so having a <code class="Code-In-Text--PACKT-">Die</code> method use a type hint of <code class="Code-In-Text--PACKT-">-&gt; "DDice"</code> works out nicely. The <strong class="" style="font-style: italic;">mypy</strong> program can use strings for forward references to types that haven't been defined yet.</p>
    <p class="normal">Now, look back over some of the examples we looked at in previous chapters. Can we leverage an abstract class definition to perhaps simplify the various ways in which <code class="Code-In-Text--PACKT-">Sample</code> instances need to behave?</p>
    <p class="normal">Look at the <code class="Code-In-Text--PACKT-">DieMeta</code> example. As written, the <code class="Code-In-Text--PACKT-">logged_roll()</code> method of the metaclass will discard any return value from the concrete <code class="Code-In-Text--PACKT-">roll()</code> method in a subclass. This may not be appropriate in all cases. What kind of rewrite is required to make the metaclass method wrapper return a value from the wrapped method? Does this change the <code class="Code-In-Text--PACKT-">DieLog</code> superclass definition? </p>
    <p class="normal">Can we use the superclass to provide a logger? (It seems like the answer is a resounding "yes.")</p>
    <p class="normal">More importantly, can we use a decorator to provide logging for a concrete <code class="Code-In-Text--PACKT-">roll()</code> method? Write this decorator. Then consider whether or not we can trust developers to include this decorator. Should we trust other developers to use the framework correctly? While we can imagine developers forgetting to include the decorator, we can also imagine unit tests to confirm that log entries are written. Which seems better: a visible decorator with a unit test or a metaclass that tweaks code invisibly? </p>
    <p class="normal">In the case study, we defined the testing and training properties as<code class="Code-In-Text--PACKT-"> Iterable[SampleDict]</code> instead of <code class="Code-In-Text--PACKT-">List[SampleDict]</code>. When we look at <code class="Code-In-Text--PACKT-">collections.abc</code>, we see that a <code class="Code-In-Text--PACKT-">List</code> is a <code class="Code-In-Text--PACKT-">Sequence</code> that is a subclass of the <code class="Code-In-Text--PACKT-">Iterable</code> base class. Can you see advantages to distinguishing between these three levels of abstraction? If <code class="Code-In-Text--PACKT-">Iterable</code> works in general, should we always use iterables? What aspects distinguish <code class="Code-In-Text--PACKT-">Sequence</code> from <code class="Code-In-Text--PACKT-">Iterable</code>? Do the different collections of features have any impact on the classes in the case study?</p>
    <h1 id="_idParaDest-132" class="title">Summary</h1>
    <p class="normal">In this chapter, we focused on identifying objects, especially objects that are not immediately apparent; objects that manage and control. Objects should have both data and behaviors, but properties can be used to blur the distinction between the two. The DRY principle is an important indicator of code quality, and inheritance and composition can be applied to reduce code duplication.</p>
    <p class="normal">In the next two chapters, we'll cover several of the built-in Python data structures and objects, focusing on their object-oriented properties and how they can be extended or adapted.</p>
  </div>
</body></html>