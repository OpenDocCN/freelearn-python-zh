- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Type-Enhanced Python: Strengthening Clean Architecture'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [*Chapter 2*](Chapter_02.xhtml#_idTextAnchor040) we explored the SOLID principles
    and their application in Python, establishing a foundation for maintainable and
    flexible code. Building on this, we now turn to a powerful feature in Python:
    **type hinting**.'
  prefs: []
  type: TYPE_NORMAL
- en: While Python’s dynamic typing offers flexibility, it can sometimes lead to unexpected
    errors in complex projects. Type hinting provides a solution, combining the benefits
    of dynamic typing with the robustness of static type checking.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter explores how type hinting enhances Clean Architecture implementations,
    making code more self-documenting and less error-prone. We’ll see how type hints
    support SOLID principles, particularly in creating clear interfaces and reinforcing
    the Dependency Inversion Principle.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll begin with the role of type awareness in Python’s dynamic environment,
    then delve into practical aspects of Python’s typing system. Finally, we’ll explore
    automated static type-checking tools for early issue detection.
  prefs: []
  type: TYPE_NORMAL
- en: By the chapter’s end, you’ll understand how to effectively use type hints in
    Python projects, writing code that’s more robust, maintainable, and aligned with
    Clean Architecture principles. This knowledge will be crucial as we progress to
    building complex, scalable systems in later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding type awareness in Python’s dynamic environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leveraging Python’s typing system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leveraging automated static type-checking tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s begin our exploration of Python type hinting and its role in strengthening
    Clean Architecture implementations.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code examples presented in this chapter and throughout the rest of the book
    are tested with Python 3.13\. All examples can be found in the book’s accompanying
    GitHub repository at [https://github.com/PacktPublishing/Clean-Architecture-with-Python](https://github.com/PacktPublishing/Clean-Architecture-with-Python).
    This chapter does refer to **Visual Studio Code** (**VS Code**). VS Code can be
    downloaded from [https://code.visualstudio.com/download](https://code.visualstudio.com/download).
  prefs: []
  type: TYPE_NORMAL
- en: Understanding type awareness in Python’s dynamic environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To fully appreciate Python’s type system, it’s important to distinguish between
    dynamically typed languages like Python and statically typed languages like Java
    or C++. In statically typed languages, variables have a fixed type that’s determined
    at compile time. Python, as a dynamically typed language, allows variables to
    change types during runtime, offering great flexibility but also introducing potential
    challenges. This dynamic typing is both a blessing and a challenge when implementing
    Clean Architecture. While it offers flexibility and rapid development, it can
    also lead to unclear interfaces and hidden dependencies, issues that Clean Architecture
    aims to address. In this section, we’ll explore how type awareness can enhance
    our Clean Architecture implementations without sacrificing Python’s dynamic nature.
  prefs: []
  type: TYPE_NORMAL
- en: Evolution of typing in Python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python’s approach to typing has evolved significantly over time. While originally
    a purely dynamically typed language, Python introduced optional static typing
    with the addition of type hinting syntax in Python 3.5 (2015) via PEP 484\. This
    introduction was motivated by the growing complexity of Python applications, particularly
    in large-scale projects where Clean Architecture principles are most beneficial.
  prefs: []
  type: TYPE_NORMAL
- en: This standardization of type hints through PEP 484 marked a significant milestone
    in Python’s evolution, providing a unified approach to adding type information
    to Python code. It paved the way for the broader adoption of static type checking
    in the Python ecosystem and the development of various tools and IDEs that leverage
    this type hinting information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python’s approach to type hinting is part of a broader trend in dynamic languages.
    JavaScript, for instance, has seen the rise of TypeScript, a typed superset of
    JavaScript that compiles to plain JavaScript. While both Python and TypeScript
    aim to bring the benefits of static typing to dynamic languages, their approaches
    differ:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Integration**: Python’s type hints are built into the language itself, whereas
    TypeScript is a separate language that compiles to JavaScript'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Optionality**: Python’s type hints are entirely optional and can be gradually
    adopted, while TypeScript enforces type-checking more strictly'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The success of TypeScript in the JavaScript ecosystem further validates the
    value of adding type information to dynamic languages. Both Python’s type hints
    and TypeScript demonstrate how combining the flexibility of dynamic typing with
    the robustness of static typing can lead to more maintainable and scalable codebases.
  prefs: []
  type: TYPE_NORMAL
- en: The evolution of type hinting in Python was driven by several important factors.
    It significantly improves code readability and serves as a form of self-documentation,
    making it easier for developers to understand the intended use of variables and
    functions. This enhanced clarity is particularly valuable in maintaining Clean
    Architecture’s separation of concerns. Type hints also enable better **integrated
    development environment** (**IDE**) and tool support, facilitating more accurate
    code completion and error detection. This improved tooling support is crucial
    when working with complex architectures, helping developers navigate between different
    layers and components more efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, type hinting makes refactoring and maintaining large codebases
    considerably easier. In the context of Clean Architecture, where we strive to
    create systems that are adaptable to change, this benefit is particularly significant.
  prefs: []
  type: TYPE_NORMAL
- en: Type hints act as a safety net during large-scale refactoring efforts, helping
    to ensure that changes in one part of the system don’t inadvertently break interfaces
    or expectations in another part.
  prefs: []
  type: TYPE_NORMAL
- en: Perhaps most importantly for our Clean Architecture implementations, type hints
    allow us to catch certain types of errors earlier in the development process.
    By making our intentions explicit through type annotations, we can identify potential
    issues at design time or during static analysis, rather than encountering them
    at runtime. This early error detection aligns perfectly with Clean Architecture’s
    goal of creating robust, maintainable systems.
  prefs: []
  type: TYPE_NORMAL
- en: As we delve deeper into the specifics of type hinting in the following sections,
    keep in mind that these features are tools to enhance our Python implementations
    of Clean Architecture. They offer a way to make our architectural boundaries more
    explicit and our code more self-documenting, all while retaining the flexibility
    and expressiveness that make Python such a powerful language for software development.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic typing versus type hinting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To understand the significance of type hints in Python, it’s crucial to distinguish
    between Python’s fundamental dynamic typing and the role of type hints. These
    two concepts serve different purposes and operate at different stages of the development
    process.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic typing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In a dynamically typed language such as Python, variables can hold values of
    any type, and these types can change during runtime. This flexibility is a core
    feature of Python. Let’s look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This flexibility allows for rapid development and expressive code but can lead
    to runtime errors if not managed carefully. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the `add_numbers` function works as expected when given two integers,
    but raises a `TypeError` when given an integer and a string. This error only occurs
    at runtime, which can be problematic if it’s in a critical part of your application
    or if it’s not caught by your testing process.
  prefs: []
  type: TYPE_NORMAL
- en: Type hinting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Type hints allow developers to annotate variables and function parameters in
    addition to returning values with their expected types. Regarding type hints,
    let’s revisit our simple function to add numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s break down the type hinting syntax used in this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '`a: int` and `b: int`: These annotations indicate that both `a` and `b` are
    expected to be integers. The colon (`:`) is used to separate the parameter name
    from its type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-> int:` This arrow notation after the function’s parameter list specifies
    the return type. In this case, it indicates that `add_numbers` is expected to
    return an integer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These type annotations provide clear information about the function’s expected
    inputs and output, making the code more self-documenting and easier to understand.
  prefs: []
  type: TYPE_NORMAL
- en: 'Key points about type hints include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: They don’t affect Python’s runtime behavior. Python remains dynamically typed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They serve as documentation, making code intentions clearer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They enable static analysis tools to catch potential type-related errors before
    runtime.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They improve IDE support for code completion and refactoring.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type hints unlock the power of static analysis tools to catch potential errors
    before runtime. While Python itself provides the syntax for type hints, it doesn’t
    enforce them at runtime. The Python interpreter treats type hints as decorative
    metadata. It’s third-party tools such as *mypy* or *pyright* that perform the
    actual static type checking. These tools analyze your code without executing it,
    using the type hints to infer and check types across your entire codebase. They
    can be run as standalone commands, integrated into IDEs for real-time feedback,
    or incorporated into continuous integration pipelines, allowing for type-checking
    at various stages of development.
  prefs: []
  type: TYPE_NORMAL
- en: In the *Leveraging automated static type checking tools* section of this chapter,
    we’ll dive deeper into how to use these tools, to perform static type checking
    across your entire codebase at key points in the developer workflow.
  prefs: []
  type: TYPE_NORMAL
- en: Type awareness in Clean Architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The introduction of type hints is particularly relevant to Clean Architecture.
    In the previous chapter, we discussed the importance of clear interfaces and dependency
    inversion. Type hints can play a crucial role in achieving these goals, making
    our architectural boundaries more explicit and easier to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider how type hints can enhance the `Shape` example we introduced in [*Chapter
    2*](Chapter_02.xhtml#_idTextAnchor040), here with a more complete utilization
    of type hints:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s take a closer look at this example:'
  prefs: []
  type: TYPE_NORMAL
- en: The `area` method in the `Shape` class is annotated to return a `float`, clearly
    communicating the expected return type for all shape implementations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Rectangle` and `Circle` classes specify that their constructors expect
    `float` parameters and return `None`. This `-> None` annotation explicitly indicates
    that constructors don’t return a value, which is implicit in Python but made clear
    through type hinting.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The concrete `area` methods in `Rectangle` and `Circle` are annotated to return
    `float`, adhering to the contract defined in the `Shape` abstract base class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `AreaCalculator` class explicitly states that its `calculate_area` method
    expects a `Shape` object as an argument and returns a `float`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These type hints make the interfaces more explicit, helping to maintain Clean
    Architecture’s boundaries between components. It’s important to note that these
    type hints don’t enforce anything at runtime. Rather, they serve as documentation
    and enable static analysis tools to catch potential type errors before execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'They provide several benefits in a Clean Architecture context:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Clear interfaces**: Type hints make the contracts between different layers
    of your architecture explicit. In our example, it’s clear that any `Shape` must
    have an `area` method that returns a `float`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dependency inversion**: They help enforce the Dependency Rule by clearly
    defining the abstract interfaces that higher-level modules depend on. The `AreaCalculator`
    depends on the abstract `Shape`, not on concrete implementations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Testability**: Type hints make it easier to create and use mock objects that
    conform to expected interfaces. For testing, we could easily create a mock `Shape`
    that adheres to the documented interface requirements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Maintainability**: As your project grows, type hints serve as living documentation,
    making it easier for developers to understand and modify the code. They provide
    immediate insight into the expected types of method parameters and return values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By leveraging type hints in this way, we create a more robust implementation
    of Clean Architecture. The explicitly documented interfaces and clear dependencies
    make our code more self-documenting and help catch type-related issues early through
    static analysis. As we build more complex systems, these benefits compound, resulting
    in a codebase that’s easier to understand, modify, and extend. In the next section,
    we’ll explore some challenges and considerations to keep in mind when integrating
    type hints into your Clean Architecture designs.
  prefs: []
  type: TYPE_NORMAL
- en: Challenges and considerations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When leveraging type hints in your Python projects, it’s important to be aware
    of several key considerations:'
  prefs: []
  type: TYPE_NORMAL
- en: They don’t replace the need for proper testing and error handling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There’s a learning curve for developers new to static typing concepts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Planned incorporation into your team’s development workflow and **continuous
    integration, continuous deployment** (**CI/CD**) pipeline is essential for successful
    adoption
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we delve deeper into Python’s typing system in the following sections and
    the remainder of the book, we’ll explore how to leverage these features to create
    more robust, maintainable, and self-documenting Clean Architecture implementations.
    We’ll see how type awareness can help us create clearer boundaries between architectural
    layers, make our dependencies more explicit, and catch potential issues earlier
    in the development process.
  prefs: []
  type: TYPE_NORMAL
- en: Remember, the goal is not to turn Python into a statically typed language but
    to use type awareness as a tool to enhance our Clean Architecture designs. By
    the end of this chapter, you’ll have a solid understanding of how to balance Python’s
    dynamic nature with the benefits of type awareness in your Clean Architecture
    implementations.
  prefs: []
  type: TYPE_NORMAL
- en: Leveraging Python’s typing system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the realm of Clean Architecture, the role of a robust type system extends
    far beyond simple error prevention. It serves as a powerful tool for expressing
    and enforcing architectural boundaries, supporting key principles such as abstraction,
    polymorphism, and dependency inversion. Python’s typing system, when leveraged
    effectively, becomes an invaluable asset in implementing these crucial concepts.
  prefs: []
  type: TYPE_NORMAL
- en: As we start to consider more advanced features of Python’s typing system, we’ll
    see how they can significantly enhance our Clean Architecture implementations.
    These features allow us to create more expressive and precise interfaces between
    different layers of our application, leading to code that is not only more robust
    but also more self-documenting and maintainable.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll explore a range of typing features, from type aliases
    and union types to literal and `TypedDict` types. We’ll then see how these can
    be applied to support SOLID principles in our Clean Architecture designs. By the
    end of this section, you’ll have a comprehensive understanding of how to use Python’s
    type system to create cleaner, more maintainable architectural boundaries.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start with a review of basic type hinting, then delve into more advanced
    features, and finally see how these features support SOLID principles in the context
    of Clean Architecture.
  prefs: []
  type: TYPE_NORMAL
- en: 'Basic type hinting: from simple types to containers'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ve already seen how to use basic type hints for simple types. Let’s quickly
    recap the syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For integers: `count: int`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For floating-point numbers: `price: float`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For strings: `name: str`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For booleans: `is_active: bool`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For function annotations: follow the `def function_name(parameter: type) ->
    return_type:` pattern'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let’s look at how we can use type hints with container types such as lists
    and dictionaries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s take a closer look at this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`list[str]` indicates that items should be a list of strings'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`list[int]` specifies that quantities should be a list of integers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-> dict[str, int]` tells us that the function returns a dictionary with string
    keys and integer values'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These type hints provide clear information about the expected structure of the
    input and output data, which is particularly valuable in Clean Architecture, where
    we often deal with complex data structures passing between different layers of
    the application.
  prefs: []
  type: TYPE_NORMAL
- en: '**Why do I sometimes see** `list` **and other times** `List` **in Python code?**'
  prefs: []
  type: TYPE_NORMAL
- en: You might notice that some Python code uses `list` (lowercase) while other code
    uses `List` (capitalized) for type annotations. This is because support for built-in
    generic types was introduced in Python 3.9\. Before that, you needed to import
    the `List` stand-in type from the typing package. For code in Python 3.9+, you
    can simply use built-in collection names such as `list` and `dict`.
  prefs: []
  type: TYPE_NORMAL
- en: In Clean Architecture, such type hints are especially useful when defining interfaces
    between different layers of the application. They provide a clear contract for
    data passing between the Domain layer, use cases, and external interfaces, helping
    to maintain clean boundaries and reduce the risk of data inconsistencies.
  prefs: []
  type: TYPE_NORMAL
- en: As we move forward, we’ll see how more advanced typing features can further
    enhance our ability to express complex relationships and constraints, supporting
    robust Clean Architecture implementations in Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sequence: flexibility in collection types'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Sequence** type hint from the typing module is a powerful tool for expressing
    collections in a way that aligns well with the SOLID principles, particularly
    the Liskov Substitution Principle and the Open–Closed Principle.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example demonstrating its use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Using `Sequence` instead of a specific type such as `List` or `Tuple` offers
    several advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Liskov Substitution Principle**: `Sequence` allows the function to work with
    any sequence type (lists, tuples, and custom sequence classes) without breaking
    the contract'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Open–Closed Principle**: The `calculate_total` function is open for extension
    (it can work with new sequence types) but closed for modification (we don’t need
    to change the function to support new types)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Interface Segregation Principle**: By using `Sequence`, we’re only requiring
    the minimal interface needed (iteration over elements), rather than committing
    to a specific collection type with potentially unnecessary methods'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In Clean Architecture, the `Sequence` type hint proves valuable across various
    layers. In the Use Case layer, it facilitates processing collections of entities
    or value objects. In the Interface Adapters layer, it enables flexible APIs that
    work with various collection types. In the Domain layer, `Sequence` expresses
    the need for a collection without specifying its implementation, maintaining separation
    of concerns. This versatility makes `Sequence` a powerful tool for creating adaptable
    and maintainable Clean Architecture implementations in Python.
  prefs: []
  type: TYPE_NORMAL
- en: Union and Optional types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Clean Architecture, we often need to handle multiple possible types or optional
    values, especially at the boundaries between layers. **Union types** and **Optional
    types** are perfect for these scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '`Union` types allow a value to be one of several types, while `Optional` is
    a shorthand for `Union[Some_Type, None]`. These constructs are particularly useful
    in Clean Architecture for creating flexible interfaces between layers while maintaining
    type safety.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It should be noted that in Python 3.10+, the union syntax was simplified to
    a concise literal use of the pipe character (`|`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding line would be simplified to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Literal types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Literal types** allow us to specify exact values that a variable can take.
    This is especially useful in Clean Architecture for enforcing specific values
    at interface boundaries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '`Literal` types help in creating more precise interfaces, reducing the chance
    of invalid data propagating through the system. This aligns well with Clean Architecture’s
    emphasis on clear boundaries and contracts between layers.'
  prefs: []
  type: TYPE_NORMAL
- en: Type aliases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Type aliases** help in simplifying complex type annotations, making our code
    more readable and maintainable. This is particularly useful in Clean Architecture
    when dealing with complex domain models or data transfer objects.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s take a closer look at this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`UserDict` is a type alias for `dict[str, str]`, representing a user object
    with string keys and values'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UserList` is a type alias for `list[UserDict]`, representing a list of user
    dictionaries'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type aliases provide more readable names for complex types, improving code clarity
    without creating new types. They enable us to write code that is both expressive
    and aligned with the principles of Clean Architecture, promoting separation of
    concerns, maintainability, and clarity.
  prefs: []
  type: TYPE_NORMAL
- en: NewType
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**NewType** creates distinct types, providing additional type safety. This
    is valuable in Clean Architecture for defining clear domain concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '`NewType` creates distinct types that are recognized by static type checkers,
    preventing accidental mixing of similar but conceptually different values. This
    helps catch potential errors early in the development process and enhances the
    overall type safety of your Clean Architecture implementation.'
  prefs: []
  type: TYPE_NORMAL
- en: Both type aliases and `NewType` align well with Clean Architecture principles
    by improving code readability, ensuring type safety across layer boundaries, and
    clearly defining domain concepts. This leads to more expressive, type-safe, and
    maintainable Clean Architecture implementations in Python.
  prefs: []
  type: TYPE_NORMAL
- en: The Any type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The **Any type** is a special type hint that essentially tells the type checker
    to allow any type. It’s used when you want to indicate that a variable can be
    of any type, or when you’re dealing with code where the type is genuinely not
    known or could vary widely.  We can see its use in this general logging example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In Clean Architecture, we generally aim to be as specific as possible about
    types, especially at layer boundaries. The `Any` type should be seen as a last
    resort, often indicating a need for refactoring or a more specific type definition.
    It’s most appropriate when interfacing with external systems where the type is
    truly unknown or highly variable. Within your own code, see the use of `Any` as
    a signal to refactor the code to the use of specific types versus the use of the
    catch-all `Any` type.
  prefs: []
  type: TYPE_NORMAL
- en: These advanced typing features provide powerful tools for implementing Clean
    Architecture in Python. They allow us to create more expressive, precise, and
    self-documenting interfaces between different layers of our application. As we
    move forward, we’ll explore how these features can be applied to support SOLID
    principles in our Clean Architecture designs.
  prefs: []
  type: TYPE_NORMAL
- en: Leveraging automated static type-checking tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we’ve explored Python’s typing system and its benefits for Clean Architecture,
    it’s crucial to understand how to effectively apply these type hints in practice.
    Python, being a dynamically typed language, doesn’t enforce type-checking at runtime.
    This is where automated static type-checking tools come into play, bridging the
    gap between Python’s dynamic nature and the benefits of static typing. This approach
    offers several key benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Early error detection**: Catch type-related issues before runtime, reducing
    the likelihood of bugs in production'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Improved code quality**: Enforce consistent use of types across your project,
    leading to more robust and self-documenting code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Enhanced refactoring**: Make large-scale code changes with more confidence,
    as the type checker can identify many of the places that need to be updated'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Better IDE support**: Enable more accurate code completion, navigation, and
    refactoring tools in your development environment'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These benefits are particularly valuable in Clean Architecture implementations,
    where maintaining clear boundaries between layers and ensuring the correctness
    of data flow is paramount.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll focus on how to leverage these automated tools to enforce
    type consistency, catch errors early, and improve the overall development experience.
    We’ll use `mypy`’s command line interface (CLI) but then use another tool as an
    extension to the VS Code IDE.
  prefs: []
  type: TYPE_NORMAL
- en: The mypy CLI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Mypy is a powerful static type checker that can be run directly from the command
    line. This makes it easy to integrate into your development workflow and deployment
    pipelines. Let’s walk through how to use `mypy` and interpret its output.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you’ll need to install `mypy`. Since it’s a Python module, you can easily
    install it using `pip`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Once installed, you can use `mypy` to check your Python files for type errors.
    Let’s look at a simple example. Assume you have a Python file named `user_service.py`
    with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'To check this file with `mypy`, run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s break down what `mypy` is telling us:'
  prefs: []
  type: TYPE_NORMAL
- en: It identifies the file (`user_service.py`) and the line number (`9`) where the
    error occurs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It describes the error: we’re passing a string (`"123"`) to `get_user`, but
    the function expects an integer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It categorizes the error as an `[arg-type]` issue, indicating a problem with
    argument types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This output is incredibly valuable. It catches a type mismatch that could lead
    to runtime errors, allowing us to fix it before the code is even executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can correct the error by changing `user = get_user("123")` to `user = get_user(123)`
    and then rerun mypy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Now, `mypy` reports no issues, confirming that our type annotations are consistent
    with how we’re using the functions.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring mypy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While `mypy` works well out of the box, you can customize its behavior using
    a configuration file. This is particularly useful for large projects or when you
    want to gradually adopt type checking.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file named `mypy.ini` in your project root:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This configuration does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Ignores missing imports, which is useful when working with third-party libraries
    without type stubs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enables strict checking of `Optional` types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Warns about redundant type casts and unused `type: ignore` comments'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Warns when a function returns `Any` implicitly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Alerts you to unreachable code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With this configuration, `mypy` will provide more comprehensive checking, helping
    you catch a wider range of potential issues in your Clean Architecture implementation.
  prefs: []
  type: TYPE_NORMAL
- en: By regularly running `mypy` as part of your development process, you can catch
    type-related issues early, ensuring that your Clean Architecture layers interact
    correctly and maintain their intended boundaries.
  prefs: []
  type: TYPE_NORMAL
- en: The configuration options for `mypy` are vast and can be tailored to fit the
    needs of your specific project. For a complete list of available options and their
    descriptions, refer to the official `mypy` documentation at [https://mypy.readthedocs.io/en/stable/config_file.html](https://mypy.readthedocs.io/en/stable/config_file.html).
  prefs: []
  type: TYPE_NORMAL
- en: Mypy in deployment pipelines
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Integrating `mypy` into your deployment pipeline is a crucial step in ensuring
    type consistency across your project, especially in a Clean Architecture context
    where maintaining clear boundaries between layers is paramount.
  prefs: []
  type: TYPE_NORMAL
- en: 'While the specific implementation details may vary depending on your chosen
    CI/CD tool, the fundamental concept remains the same: run `mypy` as part of your
    automated checks before deploying your code. Given that `mypy` operates via a
    straightforward CLI, incorporating it into most deployment pipelines is relatively
    straightforward.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, you might run `mypy` checks in the following instances:'
  prefs: []
  type: TYPE_NORMAL
- en: After each commit push
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As part of pull request validation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before merging into the main branch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prior to deploying to staging or production environments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This approach helps catch type-related issues early in the development process,
    reducing the likelihood of type errors making their way into production.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, here’s a simple GitHub Actions workflow that runs `mypy` followed
    by unit tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This workflow does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Triggers on push or pull request events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sets up a Python environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installs necessary dependencies (including `mypy` and `pytest`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Runs `mypy` on the entire project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Runs the project’s unit tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By including `mypy` in your deployment pipeline, you ensure that all code changes
    are type-checked before they’re integrated, helping maintain the integrity of
    your Clean Architecture implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Remember, while this example uses GitHub Actions, the principle applies to any
    CI/CD tool. The key is to run mypy as part of your automated checks, leveraging
    its CLI to integrate smoothly into your existing deployment processes.
  prefs: []
  type: TYPE_NORMAL
- en: Leveraging type hints in IDEs for improved development experience
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While having a deployment pipeline with type checking is essential for maintaining
    code quality, the most effective approach involves catching type issues in real
    time as the code is being written. This immediate feedback allows developers to
    address type inconsistencies instantly, reducing the time and effort spent on
    fixing issues later in the development process.
  prefs: []
  type: TYPE_NORMAL
- en: Modern IDEs have embraced this approach, leveraging type hints to provide an
    enhanced coding experience with immediate type-checking feedback. While this functionality
    is available in most popular Python IDEs, we’ll focus on VS Code as our primary
    example due to its widespread use and robust Python support.
  prefs: []
  type: TYPE_NORMAL
- en: In VS Code, the **Pylance** extension has become the preferred tool for Python
    type checking. Pylance, which uses `pyright` as its type-checking engine, integrates
    seamlessly into VS Code, offering real-time type-checking along with other advanced
    features that significantly improve the Python development experience.
  prefs: []
  type: TYPE_NORMAL
- en: 'With Pylance installed in VS Code, developers receive instant visual cues regarding
    any type issues:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1: VS Code with the Pylance extension installed](img/B31577_03_1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.1: VS Code with the Pylance extension installed'
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 3.1*, we see that the use of a string where an integer is expected
    is decorated in the IDE editor with a precise explanation of what the issue is.
  prefs: []
  type: TYPE_NORMAL
- en: This real-time feedback creates a powerful synergy with the type hints we’ve
    incorporated into our Clean Architecture implementation. It allows developers
    to maintain strict type consistency across architectural boundaries as they code,
    rather than relying solely on post-development checks.
  prefs: []
  type: TYPE_NORMAL
- en: You can install the Pylance extension from the VS Code marketplace ([https://marketplace.visualstudio.com/items?itemName=ms-python.vscode-pylance](https://marketplace.visualstudio.com/items?itemName=ms-python.vscode-pylance)),
    in addition to reading more about its features and configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Additional type-checking features
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While real-time feedback and deployment pipeline checks are crucial, there are
    additional features that can enhance your type-checking workflow.
  prefs: []
  type: TYPE_NORMAL
- en: The Problems tab in VS Code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: VS Code offers a **Problems** tab that aggregates all issues in your code, including
    type errors detected by Pylance. This tab provides a comprehensive overview of
    type inconsistencies across your project.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2: VS Code Problems tab](img/B31577_03_2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.2: VS Code Problems tab'
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 3.2*, we see the aggregation of the types checks we saw inline earlier.
    Developers can use this tab as a final check before committing code, ensuring
    no type issues are overlooked.
  prefs: []
  type: TYPE_NORMAL
- en: Git pre-commit hooks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Git supports pre-commit hooks, allowing you to run checks automatically before
    each commit. You can configure these hooks to run `mypy` and unit tests, preventing
    commits that introduce type errors or break existing functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information on setting up Git hooks, refer to the official Git documentation:
    [https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks](https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks)'
  prefs: []
  type: TYPE_NORMAL
- en: By incorporating these additional features into your workflow, you create multiple
    layers of type-checking in your development process. This comprehensive approach
    helps maintain the integrity of your Clean Architecture implementation, catching
    type inconsistencies at every stage from writing code to committing changes.
  prefs: []
  type: TYPE_NORMAL
- en: Gradual adoption strategy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Introducing static type checking in Python projects can sometimes face resistance,
    particularly from developers accustomed to Python’s dynamic nature. To ensure
    a smooth transition, it’s crucial to work collaboratively with your team, clearly
    communicating the rationale and benefits of type hinting.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a strategy for gradual adoption:'
  prefs: []
  type: TYPE_NORMAL
- en: Conduct a team meeting to discuss and formulate a plan for incorporating type
    checking.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Implement a policy requiring type hints for all new code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Minimize initial disruption by configuring `mypy` to ignore specific modules
    or packages. This can be done in the `mypy` configuration file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create scheduled maintenance tasks to progressively add type hints to existing
    code, prioritizing critical paths.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'By employing these tools and strategies, you can substantially improve the
    robustness and maintainability of your Clean Architecture implementations. The
    most effective approach combines checks at various stages: real-time feedback
    in the IDE, pre-commit hooks, and validation in the deployment pipeline. This
    multi-layered strategy ensures early error detection, enhances code navigation,
    and maintains consistent type checking throughout the development life cycle.
    Ultimately, this comprehensive approach leads to more reliable, maintainable,
    and scalable Python applications, fully leveraging the power of Python’s type
    system in your Clean Architecture projects.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored type awareness in Python’s dynamic environment
    and its role in strengthening Clean Architecture implementations. We learned how
    to leverage Python’s typing system and type hints to create more robust, self-documenting
    code and discovered the value of automated static type-checking tools in catching
    errors early.
  prefs: []
  type: TYPE_NORMAL
- en: You gained skills in implementing type hints in functions, classes, and variables,
    improving code clarity and reliability. You also learned how to set up and use
    static type-checking tools such as `mypy` to verify type consistency in your projects.
    These skills are fundamental to creating maintainable and scalable Clean Architecture
    implementations in Python, enhancing code quality and alignment with Clean Architecture
    principles.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, *Domain-Driven Design: Crafting the Core Business Logic*,
    we’ll build upon type-enhanced Python and the SOLID principles from [*Chapter
    2*](Chapter_02.xhtml#_idTextAnchor040). We’ll explore the Domain layer of Clean
    Architecture, learning how to model and implement core business logic that’s independent
    of external concerns. Using a personal task management application as an example,
    we’ll apply type awareness techniques and SOLID principles to create a robust,
    well-structured domain model, setting the stage for a truly clean and maintainable
    architecture.'
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Python Type Checking (Guide)* ([https://realpython.com/python-type-checking/](https://realpython.com/python-type-checking/))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Type Hints Cheat Sheet* ([https://mypy.readthedocs.io/en/stable/cheat_sheet_py3.html](https://mypy.readthedocs.io/en/stable/cheat_sheet_py3.html))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Continuous Integration with Python: An Introduction* ([https://realpython.com/python-continuous-integration/](https://realpython.com/python-continuous-integration/))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
