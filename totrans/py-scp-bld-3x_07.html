<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-166"><a id="_idTextAnchor171"/>7</h1>
<h1 id="_idParaDest-167"><a id="_idTextAnchor172"/>The Animation System</h1>
<p>3D owes much of its popularity to the production of animated content. Its many advantages in terms of performance, quality, and scalability made it ubiquitous in motion pictures, cartoons, feature animation, and video games. With that comes the need for custom tools to ease animation-related tasks.</p>
<p>Most applications handle animation similarly, in part inherited from hand-drawn workflows: a sequence is broken into frames, whose rapid succession creates the illusion of motion.</p>
<p>A programmer working in 3D will have to account for animated values changing over time, and how such data is stored.</p>
<p>That might change in the future, but at the time of writing, animation involves a huge amount of manual work, leaving much room for automation.</p>
<p>In this chapter, you will get acquainted with the Blender animation process, learn how to access animation data in Python, and build one tool that sets the playback range and another that animates objects.</p>
<p>This chapter will cover the following topics:</p>
<ul>
<li>Understanding the animation system</li>
<li>Changing the playback settings</li>
<li>Creating animations with Python</li>
</ul>
<h1 id="_idParaDest-168"><a id="_idTextAnchor173"/>Technical requirements</h1>
<p>We will use Blender and Visual Studio Code in this chapter. The examples created in this chapter can be found at <a href="https://github.com/PacktPublishing/Python-Scripting-in-Blender/tree/main/ch7">https://github.com/PacktPublishing/Python-Scripting-in-Blender/tree/main/ch7</a>.</p>
<h1 id="_idParaDest-169"><a id="_idTextAnchor174"/>Understanding the animation system</h1>
<p>While animations <a id="_idIndexMarker467"/>consist of a sequence of frames, only one frame is displayed on the screen at one time. Animators can scroll through these frames and play their animation like a video:</p>
<div><div><img alt="Figure 7.1: Playing an animation in Blender" height="904" src="img/Figure_7.01_B18375.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.1: Playing an animation in Blender</p>
<p>The animation <strong class="bold">Timeline</strong>, at the bottom of the screen in the <strong class="bold">Layout</strong> workspace, controls and displays the current frame and the start/end of the sequence. It provides immediate visual feedback and is essential to animation.</p>
<h2 id="_idParaDest-170"><a id="_idTextAnchor175"/>Timeline and Current Frame</h2>
<p>A <strong class="bold">Timeline</strong> is a Blender <a id="_idIndexMarker468"/>area for playing animations and changing the playback settings. It is marked with a clock icon and, because of its importance, is in more than one workspace: <strong class="bold">Animation</strong>, <strong class="bold">Layout</strong>, <strong class="bold">Rendering</strong>, and <strong class="bold">Compositing</strong> display a timeline.</p>
<p>In addition to the frame <strong class="bold">Start</strong> and <strong class="bold">End</strong> values, there is a slider for the <strong class="bold">Current Frame</strong> area and a button bar with <strong class="bold">Media Controls</strong>:</p>
<div><div><img alt="Figure 7.2: Blender’s animation Timeline" height="134" src="img/Figure_7.02_B18375.jpg" width="1587"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.2: Blender’s animation Timeline</p>
<p>Besides frame <a id="_idIndexMarker469"/>range and controls, the timeline displays the <strong class="bold">keyframes</strong> – that is, frames that contain changes in the object properties.</p>
<p>The frame <a id="_idIndexMarker470"/>range information, which is relevant to other tasks, such as <strong class="bold">Rendering</strong>, is an attribute of the scene that can be also set in the scene properties.</p>
<h2 id="_idParaDest-171"><a id="_idTextAnchor176"/>Duration and Frame Rate</h2>
<p>The duration <a id="_idIndexMarker471"/>of the current scene can be set in the <strong class="bold">Format</strong> and <strong class="bold">Frame Range</strong> panels in the <strong class="bold">Output</strong> properties, the second tab starting from above, marked with a printer icon.</p>
<p class="callout-heading">One scene, four tabs!</p>
<p class="callout">There are so many scene properties that they span the first four tabs. It can be confusing because all of them read <strong class="bold">Scene</strong> in their headers.</p>
<p class="callout">These four categories are as follows:</p>
<p class="callout"> - <strong class="bold">Render</strong>, marked with a TV icon</p>
<p class="callout"> - <strong class="bold">Output</strong>, with a printer icon</p>
<p class="callout"> - <strong class="bold">View Layers</strong>, whose icon is a stack of pictures</p>
<p class="callout"> - <strong class="bold">Scene</strong>, whose icon represents a cone and a sphere</p>
<p class="callout">Only the <strong class="bold">Output</strong> properties contain animation-related settings.</p>
<p>The <strong class="bold">Frame Rate</strong> property displays how many frames are contained in 1 second of animation and <a id="_idIndexMarker472"/>is also known as <strong class="bold">frames per </strong><strong class="bold">second</strong> (<strong class="bold">FPS</strong>).</p>
<p>The default <a id="_idIndexMarker473"/>value is <code>24 FPS</code>, the historical rate for feature films. Because of the frequency of the power grid, footage for American TV is usually shot at <code>30</code> FPS, while European TVs use <code>25</code> FPS. Motion capture or video game animations may have higher rates, such as <code>60</code> FPS:</p>
<div><div><img alt="Figure 7.3: Scene range attributes" height="606" src="img/Figure_7.03_B18375.jpg" width="465"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.3: Scene range attributes</p>
<p>Raising the <strong class="bold">Frame Rate</strong> value makes the animation play more frames per second, so it shortens the playback duration as more frames are spent in less time.</p>
<p>While the graphic interface allows the animator to either pick a frame rate from a list of presets or display an additional property for custom values, in Python, <code>fps</code> is a numeric attribute of the <code>scene.render</code> properties:</p>
<pre class="source-code">
&gt;&gt;&gt; import bpy
&gt;&gt;&gt; bpy.context.scene.render.fps
24</pre>
<p>By default, the first frame of a scene, <code>1</code> while the last frame, <code>250</code>. These values are arbitrary and are changed to the planned duration of a specific shot.</p>
<p>The first and last frame of the scene can be accessed in Python as scene attributes:</p>
<pre class="source-code">
&gt;&gt;&gt; import bpy
&gt;&gt;&gt; bpy.context.scene.frame_start
1
&gt;&gt;&gt; bpy.context.scene.frame_end
250</pre>
<p><code>1</code>. It can be <a id="_idIndexMarker474"/>increased so that not all frames are rendered, a feature used by render managers to test the overall state of a sequence:</p>
<pre class="source-code">
&gt;&gt;&gt; import bpy
&gt;&gt;&gt; bpy.context.scene.frame_step
1</pre>
<p>While the start, end, and step of the sequence are available in the <strong class="bold">Output</strong> properties as well, the <strong class="bold">current frame</strong> and the <strong class="bold">preview range</strong> are displayed only in the <strong class="bold">Timeline</strong> view.</p>
<h2 id="_idParaDest-172"><a id="_idTextAnchor177"/>Current frame and preview range</h2>
<p>Like <code>frame_start</code>, <code>frame_end</code>, and <code>frame_step</code>, the current frame is exposed as a Python <a id="_idIndexMarker475"/>attribute of the scene:</p>
<pre class="source-code">
&gt;&gt;&gt; import bpy
&gt;&gt;&gt; bpy.context.scene.frame_current
1</pre>
<p>In the <strong class="bold">Timeline</strong> view, the button with a stopwatch icon on the left of <strong class="bold">Start</strong>/<strong class="bold">End</strong> toggles the preview range. It displays an alternate range, different from the render settings:</p>
<div><div><img alt="Figure 7.4: Enabling the preview range in the Timeline view" height="134" src="img/Figure_7.04_B18375.jpg" width="1587"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.4: Enabling the preview range in the Timeline view</p>
<p>The region <a id="_idIndexMarker476"/>outside the preview range is marked in dark orange. Animators turn on the preview range to restrict the playback when they are working on a part of their assigned sequence.</p>
<p>In Python, we can access <code>frame_preview_start</code> and <code>frame_preview_end</code> like so:</p>
<pre class="source-code">
&gt;&gt;&gt; import bpy
&gt;&gt;&gt; bpy.context.scene.frame_preview_start
1
&gt;&gt;&gt; bpy.context.scene.frame_preview_end
250</pre>
<p>All the frames between <code>start</code> and <code>end</code> make the animated sequence, but not all frames must store information. Those that do are the keyframes of the animation.</p>
<h2 id="_idParaDest-173"><a id="_idTextAnchor178"/>Animation keyframes</h2>
<p>The position of objects at a certain <a id="_idIndexMarker477"/>moment is stored as <strong class="bold">keyframes</strong>. In this section, we will <a id="_idIndexMarker478"/>provide a brief overview of how keyframes are created and retrieved in the user interface, as well as with Python instructions.</p>
<h3>Adding keyframes in Blender</h3>
<p>There are <a id="_idIndexMarker479"/>at least two ways to set keyframes in Blender:</p>
<ul>
<li>Right-click on a property, then click on <strong class="bold">Insert Keyframe(s)</strong> from the context menu</li>
<li>Press <strong class="bold">I</strong> in the Viewport to display the <strong class="bold">Insert Keyframe Menu</strong> area and select a property to animate</li>
</ul>
<p>We can make changes and insert keyframes at different times to create an animation.</p>
<h3>Animating objects</h3>
<p>To get more <a id="_idIndexMarker480"/>familiar with animations, we can open Blender and add keyframes for the location of the default cube:</p>
<ol>
<li>Open Blender and select an object. If there are none in the scene, we can use <strong class="bold">Add</strong> | <strong class="bold">Mesh</strong> | <strong class="bold">Cube</strong> from the top menu.</li>
<li>Press the <em class="italic">N</em> key to display the properties of the active object.</li>
<li>Right-click on any of the <strong class="bold">Location</strong> attributes.</li>
<li>Select <strong class="bold">Insert Keyframes</strong>.</li>
</ol>
<p>However, one keyframe is not enough to make the cube move on the screen. To create a proper animation, we need to do the following:</p>
<ol>
<li>Set a new value for the <code>24</code>.</li>
<li>Move the cube to a new location by pressing the <em class="italic">G</em> key and panning the mouse.</li>
<li>Confirm the new position by left-clicking or pressing the <em class="italic">Enter</em> key.</li>
<li>Press <code>I</code> to insert a <strong class="bold">Location</strong> keyframe.</li>
</ol>
<p>We can play our animation by pressing the <em class="italic">spacebar</em> or clicking the <strong class="bold">Play</strong> button. In some instances, we might want to restrict the frame range to watch our animation in loops. We can set the sequence’s <strong class="bold">Start</strong> and <strong class="bold">End</strong> manually, or we can write an add-on that sets them for us.</p>
<h1 id="_idParaDest-174"><a id="_idTextAnchor179"/>Writing the Action to Range add-on</h1>
<p>Animators <a id="_idIndexMarker481"/>set the first and last frames of the scene according to the duration of the shot. If there are animated objects, this add-on can set the playback range automatically.</p>
<p>This operator will allow you to choose between the render and preview range.</p>
<h2 id="_idParaDest-175"><a id="_idTextAnchor180"/>Setting the environment</h2>
<p>Let’s create <a id="_idIndexMarker482"/>a folder for this chapter in our project. Then, in the <code>ch7</code> folder as our <strong class="bold">Scripts Folder</strong>. We must restart Blender to update its search paths.</p>
<p>Our add-on contains an operator, like the ones from <a href="B18375_03.xhtml#_idTextAnchor049"><em class="italic">Chapter 3</em></a>, and <a href="B18375_04.xhtml#_idTextAnchor075"><em class="italic">Chapter 4</em></a>:</p>
<ol>
<li>Select <code>PythonScriptingBlender/ch7/addons</code>.</li>
<li>Create a new file by clicking the <strong class="bold">New </strong><strong class="bold">File</strong> icon.</li>
<li>Name the new file <code>action_to_range.py</code>.</li>
<li>Open the file by double-clicking it.</li>
</ol>
<p>We can now start writing our first animation add-on.</p>
<h2 id="_idParaDest-176"><a id="_idTextAnchor181"/>Writing the Action to Range information</h2>
<p>The operator <a id="_idIndexMarker483"/>will be invoked <a id="_idIndexMarker484"/>from the <strong class="bold">View</strong> menu of the <strong class="bold">Timeline</strong> view, as reported in the location information:</p>
<pre class="source-code">
bl_info = {
    "name": "Action to Range",
    "author": "John Packt",
    "version": (1, 0),
    "blender": (3, 00, 0),
    "location": <code>"Timeline &gt; View &gt; Action to Scene Range"</code>
    "description": " Action Duration to Scene Range",
    "category": "Learning",
}</pre>
<p>The next steps are as follows:</p>
<ol>
<li>Writing the operator.</li>
<li>Writing its menu entry.</li>
<li>Registering the classes and user interface.</li>
</ol>
<p>Let’s <a id="_idIndexMarker485"/>start with the operator <a id="_idIndexMarker486"/>class and its information.</p>
<h2 id="_idParaDest-177"><a id="_idTextAnchor182"/>Writing the Action to Range operator</h2>
<p>As <a id="_idIndexMarker487"/>usual, the <code>ActionToSceneRange</code> operator <a id="_idIndexMarker488"/>derives from <code>bpy.types.Operator</code> and starts with the <code>bl_*</code> identifiers:</p>
<pre class="source-code">
import bpy
class ActionToSceneRange(bpy.types.Operator):
    """Set Playback range to current action Start/End"""
    bl_idname = "anim.action_to_range"
    bl_label = "Action Range to Scene"
    bl_description = "Transfer action range to scene range"
    bl_options = {'REGISTER', 'UNDO'}</pre>
<p>As noted in the <em class="italic">Understanding the animation system</em> section, there are two frame range settings in the scene: the main one affects the scene render, while the preview range only affects the Viewport playback.</p>
<p>We want a parameter to switch between the two. We will use a <code>BooleanProperty</code> so that we can affect either the main or preview range:</p>
<pre class="source-code">
    <code>use_preview</code>: bpy.props.<code>BoolProperty</code>(default=False)</pre>
<p>That’s all for the static part of the operator. Adding a <code>poll</code> and an <code>execute</code> method will allow the operator to run.</p>
<h2 id="_idParaDest-178"><a id="_idTextAnchor183"/>Writing the operator methods</h2>
<p>As we <a id="_idIndexMarker489"/>learned in <a href="B18375_03.xhtml#_idTextAnchor049"><em class="italic">Chapter 3</em></a>, the <code>poll</code> method returns <code>False</code> when the conditions for running the <a id="_idIndexMarker490"/>operator are not met; it’s <code>True</code> otherwise. We need to determine the operator requirements and put them in Python form.</p>
<h3>Checking the requirements in the poll() method</h3>
<p>To get <a id="_idIndexMarker491"/>the range of the active animation, we must verify the following conditions:</p>
<ul>
<li>There should be an active object</li>
<li>The active object must be animated</li>
</ul>
<p>When an object is animated, its keyframes are grouped into an <strong class="bold">action</strong>, which, in turn, becomes the active action in the object’s <strong class="bold">animation data</strong>.</p>
<p>We will explore these entities in more depth in the next section, <em class="italic">Accessing animation data in Python</em>. For now, we can just test their existence in the following code:</p>
<pre class="source-code">
    @classmethod
    def poll(cls, context):
        obj = context.object
        if <code>not obj</code>:
            return False
        if <code>not obj.animation_data</code>:
            return False
        if <code>not obj.animation_data.action</code>:
            return False
        return True</pre>
<p>When any of the <code>not</code> conditions are met, the operator is grayed out in the interface. Otherwise, the operator can be launched, and that will run its <code>execute</code> method.</p>
<h3>Writing the execute method</h3>
<p>The <code>execute</code> method performs the operator activity. It does the following:</p>
<ol>
<li>Finds the frame range of the current action</li>
<li>Sets the first and last frame of the scene accordingly</li>
<li>Fits the new frame range in the timeline visually</li>
</ol>
<p>We already <a id="_idIndexMarker492"/>know how to access the active object’s action. Its <code>frame_range</code> attribute contains the first and last frame of the action:</p>
<pre class="source-code">
    def execute(self, context):
        anim_data = context.object.animation_data
        <code>first, last</code> = anim_data.action.<code>frame_range</code></pre>
<p>We get the current <code>scene</code> and perform <em class="italic">step 2</em>. If the timeline preview range is used, we should set the preview start/end frames. Frame values are stored as decimal floats, and we need to convert them into integers before using them for the <code>frame*</code> attributes:</p>
<pre class="source-code">
        scn = context.scene
        if self.<code>use_preview</code>:
            scn.frame_<code>preview</code>_start = <code>int</code>(first)
            scn.frame_<code>preview</code>_end = <code>int</code>(last)</pre>
<p>Otherwise, we must set the standard <code>frame_start</code> and <code>frame_end</code> of the scene:</p>
<pre class="source-code">
        else:
            scn.frame_start = <code>int</code>(first)
            scn.frame_end = <code>int</code>(last)</pre>
<p>Now that we have set our values, we can invoke <code>ops.action.view_all()</code> to fit the <strong class="bold">Timeline</strong> view to the new range, and finish the execution:</p>
<pre class="source-code">
        bpy.ops.action.view_all()
        return {'FINISHED'}</pre>
<p>We need to add <code>'UNDO'</code> to <code>bl_options</code> to affect the operator attributes after the execution, as we learned in <a href="B18375_04.xhtml#_idTextAnchor075"><em class="italic">Chapter 4</em></a>:</p>
<pre class="source-code">
bl_options = {'REGISTER', 'UNDO'}</pre>
<p>Unfortunately, operators <a id="_idIndexMarker493"/>that are launched outside of the <code>use_preview</code> to <code>False</code>.</p>
<p>To work around that, we can create two entries in the <strong class="bold">Timeline</strong> | <strong class="bold">View</strong> menu.</p>
<h2 id="_idParaDest-179"><a id="_idTextAnchor184"/>Writing the menu function</h2>
<p>In <a href="B18375_03.xhtml#_idTextAnchor049"><em class="italic">Chapter 3</em></a>, we learned that adding a function to a menu class allows us to add elements to its layout.</p>
<p>Also, in <a href="B18375_05.xhtml#_idTextAnchor100"><em class="italic">Chapter 5</em></a>, we learned that operator properties are <a id="_idIndexMarker494"/>returned by the <code>layout.operator</code> function and can be set programmatically.</p>
<p>Combining <a id="_idIndexMarker495"/>these two techniques, we can create two menu entries that invoke the same operator, but we only enable <code>use_preview</code> on one of the two. This way, we end up with two menu items. They execute the same operator but with different settings and outcomes.</p>
<p>To make sure that the difference is reflected in the operator label, we can change it using the <code>text=</code> parameter:</p>
<pre class="source-code">
def view_menu_items(self, context):
    <code>props</code> = self.layout.operator(
                         <code>ActionToSceneRange</code>.bl_idname,
                         text=ActionToSceneRange.bl_label <code>+</code>
                              <code>" (preview)"</code>)
    <code>props.use_preview</code> = True</pre>
<p>We have added <code>" (preview)"</code> to the operator label so that it’s clear that this is a variant of the <code>ActionToSceneRange</code> operator.</p>
<p>The default entry affects the actual scene range, so there is no need to specify the text label explicitly:</p>
<pre class="source-code">
    props = self.layout.operator(
                         ActionToSceneRange.bl_idname
                         )
    props.use_preview = False</pre>
<p>Menu entries are <a id="_idIndexMarker496"/>displayed with a <strong class="bold">Last In First Out</strong> (<strong class="bold">LIFO</strong>) policy. We <a id="_idIndexMarker497"/>added the (preview) item first, so it will be displayed <a id="_idIndexMarker498"/>after the default <strong class="bold">Action to Scene </strong><strong class="bold">Range</strong> entry.</p>
<p class="callout-heading">It won’t default forever!</p>
<p class="callout"><code>ActionToSceneRange.use_preview</code> is already <code>False</code> by default, but we set <code>props.use_preview</code> to <code>False</code> anyway in <code>view_menu_items</code>.</p>
<p class="callout">Unless <code>is_skip_save</code> is used for a property, the default value only affects the first execution of an operator. From then on, the last user choice becomes the new default.</p>
<p class="callout">If an element of the interface matches specific operator settings, then we should set them explicitly in the code.</p>
<p>Now that we’ve created the elements of the add-on, we need to register the operator and menu entries. Then, it will be ready to go.</p>
<h2 id="_idParaDest-180"><a id="_idTextAnchor185"/>Finishing the add-on</h2>
<p>We need the <a id="_idIndexMarker499"/>class name of the <strong class="bold">Timeline</strong> | <strong class="bold">View</strong> menu. To find it, we can look up the Python source of the Blender interface.</p>
<h3>Finding a menu’s Python class</h3>
<p>We can <a id="_idIndexMarker500"/>right-click the <strong class="bold">Timeline</strong> | <strong class="bold">View</strong> menu and select <strong class="bold">Edit Source</strong> to find its Python name:</p>
<div><div><img alt="Figure 7.5: Opening Timeline | View" height="270" src="img/Figure_7.05_B18375.jpg" width="618"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.5: Opening Timeline | View</p>
<p>Then, in the <code>space_time.py</code> in the <strong class="bold">Text </strong><strong class="bold">Editor</strong> area:</p>
<div><div><img alt="Figure 7.6: space_time.py as a loaded text block" height="211" src="img/Figure_7.06_B18375.jpg" width="825"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.6: space_time.py as a loaded text block</p>
<p>The script found in the <code>menu()</code> function is the class name we are looking for:</p>
<pre class="source-code">
        sub.menu("<code>TIME_MT_view</code>")</pre>
<p>We can use this name in our <code>register()</code> function.</p>
<h3>Writing the register/unregister functions</h3>
<p>We can <a id="_idIndexMarker501"/>use <code>register_class</code> to add <code>ActionToSceneRange</code> to the Blender operators, and we can append our items to <code>TIME_MT_view</code> to display our new entries in the <strong class="bold">Timeline</strong> | <strong class="bold">View</strong> menu:</p>
<pre class="source-code">
def register():
    bpy.utils.register_class(<code>ActionToSceneRange</code>)
    bpy.types.<code>TIME_MT_view.append</code>(view_menu_items)</pre>
<p>Likewise, when the add-on is disabled, <code>unregister()</code> removes our items from the menu <a id="_idIndexMarker502"/>and the operator from Blender:</p>
<pre class="source-code">
def unregister():
    bpy.types.TIME_MT_view.<code>remove</code>(view_menu_items)
    bpy.utils.unregister_class(ActionToSceneRange)</pre>
<p>Now, the operator is ready. We can use it on the cube we animated earlier in this chapter or open one of the files contained in <code>ch7/_scenes_</code>.</p>
<h2 id="_idParaDest-181"><a id="_idTextAnchor186"/>Enabling and running</h2>
<p>If the <code>PythonScriptingBlender/ch7</code> folder was added to the <code>scripts</code> path, we can <a id="_idIndexMarker503"/>find and <a id="_idIndexMarker504"/>enable <strong class="bold">Action to Range</strong> in the <strong class="bold">Add-ons</strong> preferences:</p>
<div><div><img alt="Figure 7.7: Enabling the Action to Range add-on" height="384" src="img/Figure_7.07_B18375.jpg" width="992"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.7: Enabling the Action to Range add-on</p>
<p>If the add-on was installed correctly, we will find two new entries in <strong class="bold">Timeline</strong> | <strong class="bold">View</strong>:</p>
<div><div><img alt="Figure 7.8: Action to Scene Range and its “preview” variant" height="208" src="img/Figure_7.08_B18375.jpg" width="623"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.8: Action to Scene Range and its “preview” variant</p>
<p>Clicking <strong class="bold">Action to Scene Range</strong> sets <a id="_idIndexMarker505"/>the scene range <a id="_idIndexMarker506"/>to 1-24, while <strong class="bold">Action to Scene Range (preview)</strong> sets the preview range.</p>
<p>Since we have set <code>bl_options = {'REGISTER', 'UNDO'}</code> in the properties, we’ll look at how this operator supports the <strong class="bold">Adjust Last </strong><strong class="bold">Operation</strong> window.</p>
<h3>Changing the parameters of the last operation</h3>
<p>We <a id="_idIndexMarker507"/>can use <strong class="bold">Edit</strong> | <strong class="bold">Adjust Last Operation</strong> from the top menu bar to change the options in the last execution retroactively:</p>
<div><div><img alt="Figure 7.9: Changing the outcome of the last operation" height="563" src="img/Figure_7.09_B18375.jpg" width="795"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.9: Changing the outcome of the last operation</p>
<p>A small window will appear, displaying the operator properties. Turning <code>use_preview</code> on and off changes the result of the operation:</p>
<div><div><img alt="Figure 7.10: The Action to Scene Range properties window" height="634" src="img/Figure_7.10_B18375.jpg" width="1136"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.10: The Action to Scene Range properties window</p>
<p>The add-on <a id="_idIndexMarker508"/>is finished, but when it comes to recentering the <code>bpy.ops.action.view_all()</code>, a timeline operator. It is fine to call other operators in <code>execute</code>, but they can place additional restrictions on the validity of the context, so we must consider that their <code>poll</code> method might halt our script’s execution.</p>
<p>For instance, by adding our operator to the <code>action.view_all()</code>, which requires it, will never fail.</p>
<p>But what if the <code>F3</code> <code>RuntimeError</code>:</p>
<div><div><img alt="Figure 7.11: Our script causes an error if the timeline is not displayed" height="714" src="img/Figure_7.11_B18375.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.11: Our script causes an error if the timeline is not displayed</p>
<p>We can <a id="_idIndexMarker509"/>just warn the user or check the presence timelines in our <code>poll</code> method, but usually, the best practice is as follows:</p>
<ul>
<li>Use a <code>try</code> statement when calling other operators</li>
<li>If possible, if a <code>RuntimeError</code> occurs, create an alternate <code>context</code> for running the other operator</li>
</ul>
<p>This way, even if something goes wrong, our operator will carry on with its task.</p>
<h2 id="_idParaDest-182"><a id="_idTextAnchor187"/>Fixing context for other operators</h2>
<p>We can prevent a Python script from stopping in case of errors by using <code>try</code> and <code>catch</code> statements. The code that risks causing errors goes under the <code>try</code> indent block, while the <a id="_idIndexMarker510"/>code to execute in case a specific error happens goes under the <code>except </code><code>ErrorType</code> indent.</p>
<p>In our case, the error message was raised when <code>RuntimeError</code>:</p>
<pre class="source-code">
RuntimeError: Operator bpy.ops.action.view_all.poll() failed, context is incorrect</pre>
<p>To get past this issue, we must provide a plan B inside an <code>except RuntimeError</code> block. If we don’t want to do anything, we can use the empty <code>pass</code> instruction:</p>
<pre class="source-code">
try:
    bpy.ops.action.view_all()
except <code>RuntimeError</code>:
    <code>pass</code></pre>
<p>But we can do better: we can look for a timeline in the window, override <code>context</code>, and pass it to the operator.</p>
<p>In <a href="B18375_05.xhtml#_idTextAnchor100"><em class="italic">Chapter 5</em></a>, we learned that a Blender window is split into <code>screen</code>, <code>areas</code>, and <code>regions</code>. From the documentation, we know that timeline editors are of the <code>'</code><code>DOPESHEET_EDITOR'</code> type.</p>
<p>There might be more windows open. For each of them, we can get the screen attribute:</p>
<pre class="source-code">
    for window in <code>context.window_manager</code>.windows:
        screen = window.<code>screen</code></pre>
<p>Then, we must look for a <code>'DOPESHEET_EDITOR'</code> among <code>areas</code> of the screen:</p>
<pre class="source-code">
        for area in screen.<code>areas</code>:
            if area.<code>type</code> != <code>'DOPESHEET_EDITOR'</code>:
                <code>continue</code></pre>
<p>By skipping <a id="_idIndexMarker511"/>every area that is <em class="italic">not</em> a <code>'DOPESHEET_EDITOR'</code>, we can ensure that the following lines are executed only if the area is a timeline. We need to look for its main region, which is of the <code>'</code><code>WINDOW'</code> type:</p>
<pre class="source-code">
            for region in area.<code>regions</code>:
                if region.<code>type == 'WINDOW'</code>:</pre>
<p>The timeline’s <code>window</code>, <code>area</code>, and <code>region</code> are fed to <code>context.temp_override</code> inside a <code>with</code> statement.</p>
<p>In Python, <code>with</code> sets a condition that stays valid inside its scope – that is, indented lines of code. There, we can call <code>bpy.ops.action.view_all()</code>:</p>
<pre class="source-code">
                    <code>with</code> context.temp_override(
                                            window=<code>window</code>,
                                            area=<code>area</code>,
                                            region=<code>region</code>):
                        bpy.ops.action.<code>view_all()</code>
                    <code>break</code>
                <code>break</code>
    return {'FINISHED'}</pre>
<p>The two <code>break</code> statements stop the search after a timeline is found. We have made sure that <code>view_all</code> is called only if its conditions are met.</p>
<p>Our add-on automated a tedious operation by checking the action frame range, without looking into <a id="_idIndexMarker512"/>the keyframes it contains. To understand how we can access and manipulate the animation data, next, we will learn how keyframes are displayed and edited.</p>
<h1 id="_idParaDest-183"><a id="_idTextAnchor188"/>Editing keyframes</h1>
<p>Animation software gives visual cues of keyframe distribution. In Blender, keyframes are displayed with <a id="_idIndexMarker513"/>special colors in the interface and as diamond widgets in the animation editors.</p>
<p>Animated properties have colored backgrounds. If the current frame is a keyframe, the background is yellow; otherwise, it is green:</p>
<div><div><img alt="Figure 7.12: Location is animated; the current frame is the keyframe for X and Y" height="138" src="img/Figure_7.12_B18375.jpg" width="278"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.12: Location is animated; the current frame is the keyframe for X and Y</p>
<p>Keyframes of the selected objects are displayed as diamonds in the <strong class="bold">Timeline</strong> editor:</p>
<div><div><img alt="Figure 7.13: The animation Timeline. Frames 1 and 24 have keyframes" height="187" src="img/Figure_7.13_B18375.jpg" width="1584"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.13: The animation Timeline. Frames 1 and 24 have keyframes</p>
<p>Blender transitions from one keyframe to the other by tracing a graph between them. These graphs are referred to as <strong class="bold">animation curves</strong> or <strong class="bold">f-curves</strong>.</p>
<h2 id="_idParaDest-184"><a id="_idTextAnchor189"/>Animation curves and the Graph Editor</h2>
<p>Like most <a id="_idIndexMarker514"/>animation software, Blender generates a transition between two animated values by inbetweening two or more keyframes. A keyframe contains two elements – a moment in time and the value of a property at that moment.</p>
<p>These changes <a id="_idIndexMarker515"/>in value over time are represented in the <strong class="bold">Graph Editor</strong> area, a coordinate system where the horizontal axis is the frame number and the vertical axis is the animated value at each frame:</p>
<div><div><img alt="Figure 7.14: Values over time as animation curves in the Graph Editor" height="468" src="img/Figure_7.14_B18375.jpg" width="1134"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.14: Values over time as animation curves in the Graph Editor</p>
<p>A keyframe created at frame <code>1</code> that sets a property to <code>0</code> is displayed as a dot with coordinates of <code>(</code><code>1, 0)</code>.</p>
<p>Blender interpolates the transition between one keyframe and another. The transition between a keyframe <a id="_idIndexMarker516"/>and its neighbors is an <strong class="bold">F-Curve</strong> – that is, a continuous graph that connects two keyframes smoothly.</p>
<p class="callout-heading">Say his F-name!</p>
<p class="callout">F-curves are named after James Ferguson, a researcher at The Boeing Company who, in 1964, published a paper named <em class="italic">Multivariable Curve Interpolation</em>. His interpolation formulas have fueled the advancements in modern computer graphics.</p>
<p>This way, every <em class="italic">animation curve</em>, or <em class="italic">F-Curve</em>, contains both the keyframes set by the animator and the transition generated by Blender, acting both as storage for the animation data and the interpolator that fills the parts where they are missing.</p>
<p>Interpolations can make use of straight lines connecting the points, or curve lines with tangent <a id="_idIndexMarker517"/>handles – that is, <strong class="bold">Bezier</strong> curves.</p>
<p>Setting a <strong class="bold">Location</strong> keyframe creates curves for the <strong class="bold">X</strong>, <strong class="bold">Y</strong>, and <strong class="bold">Z</strong> channels.</p>
<p>Animation curves <a id="_idIndexMarker518"/>are displayed in the <strong class="bold">Graph Editor</strong> area. We can select <strong class="bold">Graph Editor</strong> from the drop-down list on the left of any area header:</p>
<div><div><img alt="Figure 7.15: Selecting the Graph Editor as the content of a Blender area" height="393" src="img/Figure_7.15_B18375.jpg" width="1130"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.15: Selecting the Graph Editor as the content of a Blender area</p>
<p>The f-curves of an animation are stored in <strong class="bold">actions</strong>, which are the top containers in the animation data.</p>
<p>The structure of the animation data can be summed up as <strong class="bold">Action</strong> | <strong class="bold">F-Curves</strong> | <strong class="bold">Keyframes</strong>.</p>
<p>Traversing this hierarchy is done differently via Python, where we can retrieve the animation values in our scripts.</p>
<h1 id="_idParaDest-185"><a id="_idTextAnchor190"/>Accessing animation data in Python</h1>
<p>Let’s switch <a id="_idIndexMarker519"/>to the <strong class="bold">Scripting Workspace</strong> area to <a id="_idIndexMarker520"/>familiarize ourselves with the animation system API.</p>
<h2 id="_idParaDest-186"><a id="_idTextAnchor191"/>Adding keyframes in Python</h2>
<p>The Python <a id="_idIndexMarker521"/>class of every animatable object provides a method <a id="_idIndexMarker522"/>that we can use to insert keyframes, named <code>keyframe_insert</code>. It is very similar to the <code>data_path</code> string for specifying which property to animate. Optional parameters such as <code>index</code> and <code>frame</code> allow us to specify one of the channels of an aggregate property or a frame different from the current one:</p>
<pre class="source-code">
keyframe_insert(data_path,
                index=- 1,
                frame=bpy.context.scene.frame_current,
[…]
Returns
        Success of keyframe insertion.</pre>
<p>The following <a id="_idIndexMarker523"/>lines set a keyframe for the active object’s <a id="_idIndexMarker524"/>location to <code>10.0, 10.0, 10.0</code> at frame <code>1</code>:</p>
<pre class="source-code">
&gt;&gt;&gt; import bpy
&gt;&gt;&gt; bpy.context.object.<code>location</code> = 10.0, 10.0, 10.0
&gt;&gt;&gt; bpy.context.object.<code>keyframe_insert</code>(<code>'location'</code>, <code>frame=1</code>)
True</pre>
<p>Animation requires a value to change over time, so just one keyframe is not enough. We will set another value for frame 24:</p>
<pre class="source-code">
&gt;&gt;&gt; bpy.context.object.location = <code>-10.0</code>, <code>-10.0</code>, <code>-10.0</code>
&gt;&gt;&gt; bpy.context.object.keyframe_insert('location',frame=<code>24</code>)
True</pre>
<p>We have only set a keyframe at the start and one at the end of our animation, but by default, Blender generates a transition between two neighbor keyframes so that the object will move a little bit at each of the frames between 1 and 24.</p>
<p>Our object starts at the <code>10.0, 10.0, 10.0</code> coordinates of the <code>-10.0, -</code><code>10.0, -10.0</code>.</p>
<p>Geometrically speaking, these coordinates mark the front top-right corner and bottom-left corner of a cube, implying that the motion happened along the diagonal of the three-dimensional space.</p>
<h2 id="_idParaDest-187"><a id="_idTextAnchor192"/>Retrieving keyframes in Python</h2>
<p>If the <a id="_idIndexMarker525"/>active object has keyframes, we can traverse its <code>animation_data</code>:</p>
<pre class="source-code">
&gt;&gt;&gt; bpy.context.object.<code>animation_data</code>
bpy.data.objects['Cube']...AnimData</pre>
<p>Since <code>animation_data</code> contains the current action, all its f-curves, and keyframes, we are <a id="_idIndexMarker526"/>going to use this container a lot. It can be convenient to store it as a variable as this way, we can avoid long lines of code while we gather the data. Here’s how we get the current <code>action</code>:</p>
<pre class="source-code">
&gt;&gt;&gt; <code>anim_data</code> = bpy.context.object.animation_data
&gt;&gt;&gt; anim_data.<code>action</code>
bpy.data.actions['CubeAction']</pre>
<p>From the action, we can retrieve the list of animation <code>fcurves</code>:</p>
<pre class="source-code">
&gt;&gt;&gt; action = anim_data.action
&gt;&gt;&gt; anim_data.action.<code>fcurves</code>
bpy.data.actions['CubeAction'].fcurves</pre>
<p>For each curve, we can get the animated <code>data_path</code>. A data path identifies where a property is stored in Blender, but some properties, such as <code>location</code>, require an animation curve for each channel – for example, one curve for the <em class="italic">x</em>, one for <em class="italic">y</em>, and one for the <em class="italic">z</em> coordinate. For that reason, f-curves also have the <code>array_index</code> attribute, a number that designates the animated channel of an aggregate property. If we animate the three channels of <code>location</code> and scroll through the f-curves using Python, we will find three curves with the same path, <code>'location'</code>, each with a different index:</p>
<pre class="source-code">
&gt;&gt;&gt; fcurves = anim_data.action.fcurves
&gt;&gt;&gt; for fc in fcurves:
...     print(fc.data_path, fc.array_index)
...
location 0
location 1
location 2</pre>
<p>Every <code>keyframe_point</code> stores two <a id="_idIndexMarker527"/>coordinates in the <code>co</code> attribute. The <a id="_idIndexMarker528"/>first is the frame number, while the second is the value of that frame:</p>
<pre class="source-code">
&gt;&gt;&gt; for fc in fcurves:
...     print(fc.data_path, fc.array_index)
...     for kf in fc.keyframe_points:
...        frame, value = kf.co
...        print("\t frame", frame, "value", value)
location 0
    frame 1.0 value 0.0
    frame 24.0 value 0.2
location 1
    frame 1.0 value 0.0
    frame 24.0 value 4.0
location 2
    frame 1.0 value 0.0
    frame 24.0 value 3.0</pre>
<p>While the current, first, and last frames of the scene are stored as integers, <code>co[0]</code> is a <code>float</code>. This allows us to insert animations between adjacent frames (subframe animation).</p>
<p>The curve interpolation mode is stored in the keyframe’s <code>interpolation</code> attribute. The most used interpolations are as follows:</p>
<ul>
<li><code>'CONSTANT'</code>: No interpolation</li>
<li><code>'LINEAR'</code>: Interpolation using straight lines</li>
<li><code>'BEZIER'</code>: Interpolation using curves, weighted with <em class="italic">handles</em></li>
</ul>
<p>Bezier curves, named after the French engineer Pierre Bèzier, are widely used in computer <a id="_idIndexMarker529"/>graphics because of their smooth and controllable <a id="_idIndexMarker530"/>behavior. They are the default interpolation in Blender. The current <code>interpolation</code> between a keyframe and its neighbors is stored as an attribute of the keyframe:</p>
<pre class="source-code">
&gt;&gt;&gt; kf.interpolation
'BEZIER'</pre>
<p>Points of a Bezier curve have two additional coordinates – a left handle and a right one, both of which affect the interpolated path. To support curve interpolation, Blender keyframes contain two additional coordinates stored as the <code>handle_left</code> and <code>handle_right</code> attributes. Exactly like the <code>co</code> attribute, the curve handles are two-dimensional points:</p>
<pre class="source-code">
&gt;&gt;&gt; kf.handle_left
Vector((16.0, 10.0))
&gt;&gt;&gt; kf.handle_right
Vector((31.0, 10.0))</pre>
<p>Blender supports other interpolations. They cover very specific cases and at the time of writing, they are not much used in animation. They are named after the mathematical function used in their computation, and they are described in the API documentation at <a href="https://docs.blender.org/api/3.2/bpy.types.Keyframe.xhtml">https://docs.blender.org/api/3.2/bpy.types.Keyframe.xhtml</a> and #bpy.types.Keyframe.interpolation:</p>
<ul>
<li><code>QUAD</code>: Quadratic easing</li>
<li><code>CUBIC</code>: Cubic easing</li>
<li><code>QUART</code>: Quartic easing</li>
<li><code>QUINT</code>: Quintic easing</li>
<li><code>SINE</code>: Sinusoidal easing (weakest, almost linear but with a slight curvature)</li>
<li><code>EXPO</code>: Exponential easing (dramatic)</li>
<li><code>CIRC</code>: Circular easing (strongest and most dynamic)</li>
<li><code>BACK</code>: Cubic easing with overshoot and settle</li>
<li><code>BOUNCE</code>: Exponentially decaying parabolic bounce, like when objects collide</li>
<li><code>ELASTIC</code>: Exponentially decaying sine wave, like an elastic band</li>
</ul>
<p>We will <a id="_idIndexMarker531"/>get back to keyframes at the end of this chapter; in the <a id="_idIndexMarker532"/>meantime, we will build a tool that sets the scene playback based on the duration of the current animation.</p>
<p>In these examples, our script uses the attributes of existing animations. In the next section, we are going to create animations with Python.</p>
<h1 id="_idParaDest-188"><a id="_idTextAnchor193"/>Writing the Vert Runner add-on</h1>
<p>In this section, we will write an add-on that animates the selected objects along the geometry of <a id="_idIndexMarker533"/>the active object. The animation will trace a path that connects the vertices of a mesh, hence the name <em class="italic">Vert Runner</em>:</p>
<div><div><img alt="Figure 7.16: Animating a toy along the vertices of a path" height="928" src="img/Figure_7.16_B18375.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.16: Animating a toy along the vertices of a path</p>
<p>This can be a basis for procedural walks or patrols, motion effects, or any other case where we have a geometrical path.</p>
<p>In this <a id="_idIndexMarker534"/>operator, the selected objects and the active ones are treated differently: the active object is the reference geometry on which the selected objects are moved.</p>
<h2 id="_idParaDest-189"><a id="_idTextAnchor194"/>Setting the environment</h2>
<p>Let’s start <a id="_idIndexMarker535"/>by adding a new script to our add-ons directory:</p>
<ol>
<li>Select <code>PythonScriptingBlender/ch7/addons</code> in <strong class="bold">VS Code</strong>.</li>
<li>Create a new file by clicking on the <strong class="bold">New </strong><strong class="bold">File</strong> icon.</li>
<li>Name the new file <code>vert_runner.py</code>.</li>
<li>Open the file by double-clicking it.</li>
</ol>
<p>As usual, we will start with the add-on information.</p>
<h2 id="_idParaDest-190"><a id="_idTextAnchor195"/>Writing the Vert Runner information</h2>
<p>Our new <a id="_idIndexMarker536"/>operator can be invoked by <a id="_idIndexMarker537"/>selecting <code>location</code> information:</p>
<pre class="source-code">
bl_info = {
    "name": "Vert Runner",
    "author": "John Packt",
    "version": (1, 0),
    "blender": (3, 00, 0),
    "location": <code>"Object &gt; Animation &gt; Vert Runner"</code>
    "description": "Run on vertices of the active object",
    "category": "Learning",
}</pre>
<p>We will <a id="_idIndexMarker538"/>proceed with the usual steps:</p>
<ol>
<li>Writing <a id="_idIndexMarker539"/>the operator</li>
<li>Writing the menu entry</li>
<li>Registering the classes and interface</li>
</ol>
<h2 id="_idParaDest-191"><a id="_idTextAnchor196"/>Writing the Vert Runner operator</h2>
<p>After the <a id="_idIndexMarker540"/><code>import</code> section, we must <a id="_idIndexMarker541"/>create the <code>VertRunner</code> class and its <code>bl_*</code> identifiers:</p>
<pre class="source-code">
import bpy
class <code>VertRunner</code>(bpy.types.Operator):
    """Run over vertices of the active object"""
    bl_idname = "object.vert_runner"
    bl_label = "Vertex Runner"
    bl_description = "Animate along verts of active object"
    bl_options = {'REGISTER', 'UNDO'}</pre>
<p>We set the distance between each keyframe with an <code>Integer</code> property:</p>
<pre class="source-code">
    step: bpy.props.IntProperty(default=12)</pre>
<p>The next step is writing the <code>poll</code> and <code>execute</code> methods of this operator.</p>
<h2 id="_idParaDest-192"><a id="_idTextAnchor197"/>Writing the operator methods</h2>
<p>We will <a id="_idIndexMarker542"/>write the <code>poll</code> method based on what is needed to run the desired operations.</p>
<h3>Requirements to check in the poll() method</h3>
<p>To animate <a id="_idIndexMarker543"/>the selected objects over the geometry of the active object, we need the following:</p>
<ul>
<li>An active object</li>
<li>Mesh data</li>
<li>Selected objects</li>
</ul>
<p>Using these conditions, to have the <code>poll()</code> method return <code>False</code>, they translate to the following:</p>
<pre class="source-code">
    @classmethod
    def poll(cls, context):
        obj = context.object
        if not<code> obj</code>:
            return False
        if not <code>obj.type == 'MESH'</code>:
            return False
        if not <code>len(context.selected_objects) &gt; 1</code>:
            return False
        return True</pre>
<p>If none of the <code>return False</code> conditions are met, the poll is successful. In that case, the operator can run its execute method.</p>
<h3>Writing the execute() method</h3>
<p>Breaking <a id="_idIndexMarker544"/>the operator’s goal into steps, we should do the following:</p>
<ol>
<li>Get a list of patrol points; in this case, the vertices of the active object.</li>
<li>Scroll through the selected objects.</li>
<li>Move them through the patrol points and set the keyframes.</li>
</ol>
<p>We will start by storing the active object’s vertices in a <code>list</code>:</p>
<pre class="source-code">
    def execute(self, context):
        verts = list(context.object.data.vertices)</pre>
<p>When <a id="_idIndexMarker545"/>we iterate through the selected objects, we should make sure to skip the active one, which is likely selected:</p>
<pre class="source-code">
        for ob in context.selected_objects:
            if <code>ob == context.active_object</code>:
                <code>continue</code></pre>
<p>Then, we must iterate through the vertices list and set keyframes for each coordinate, starting with the current frame. We must advance the <code>frame</code> number at every iteration:</p>
<pre class="source-code">
            frame = context.scene.frame_current
            for vert in verts:
                <code>ob.location</code> = <code>vert.co</code>
                ob.<code>keyframe_insert</code>('location', frame=frame)
                frame <code>+= self.step</code>
        return {'FINISHED'}</pre>
<p>When the for loop is over, we must return a <code>'FINISHED'</code> state and exit the operator. Now that the <code>VertRunner</code> class is complete, we can work on its menu entry.</p>
<h2 id="_idParaDest-193"><a id="_idTextAnchor198"/>Writing the menu and register functions</h2>
<p>Since menu <a id="_idIndexMarker546"/>elements are displayed in reverse order, we must add a <code>separator</code> first:</p>
<pre class="source-code">
def anim_menu_func(self, context):
    self.layout.<code>separator</code>()
    self.layout.<code>operator</code>(VertRunner.bl_idname,
                         text=VertRunner.bl_label)</pre>
<p>Now, it’s time to register the operator and menu so that it can run from the interface:</p>
<pre class="source-code">
def register():
    bpy.utils.register_class(VertRunner)
    bpy.types.VIEW3D_MT_object_animation.append(
                                            anim_menu_func)
def unregister():
    bpy.types.VIEW3D_MT_object_animation.remove(
                                            anim_menu_func)
    bpy.utils.unregister_class(VertRunner)</pre>
<p>If we <a id="_idIndexMarker547"/>refresh the <strong class="bold">Add-ons</strong> list, we will see <strong class="bold">Vert Runner</strong> in the <strong class="bold">Learning</strong> category. Enabling it adds <strong class="bold">Vert Runner</strong> to the <strong class="bold">Object</strong> | <strong class="bold">Animation</strong> menu:</p>
<div><div><img alt="Figure 7.17: Object | Animation | Vert Runner animates the selected objects" height="768" src="img/Figure_7.17_B18375.jpg" width="1366"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.17: Object | Animation | Vert Runner animates the selected objects</p>
<p>Using <strong class="bold">Vert Runner</strong> after selecting at least two objects will animate the selected objects along the vertices of the active object. We can add an option to make the animation cyclic and animate the object rotation.</p>
<h2 id="_idParaDest-194"><a id="_idTextAnchor199"/>Creating cyclic animations</h2>
<p>Sometimes, we want the first and last frame of an animation to match so that we can watch it <a id="_idIndexMarker548"/>in loops – for instance, an endless clip of a character running in circles.</p>
<p>In our case, an object passes through all the points of a mesh, starting with the first and ending with the last vertex, so the first and last frames of the animation will differ.</p>
<p>To create an animation cycle, we need to add the extra step of going back to the first coordinates after we have passed the last vertex.</p>
<p>The user must be able to choose whether they want a cyclic animation or not, so we will add an option to our operator. The <code>loop</code> attribute is a Boolean property – it can be enabled and disabled when the operator is run:</p>
<pre class="source-code">
class VertRunner(bpy.types.Operator):
    """Run over the vertices of the active object"""
    bl_idname = "object.vert_runner"
    bl_label = "Vert Runner"
    bl_description = "Animate along verts of active object"
    bl_options = {'REGISTER', 'UNDO'}
    step: bpy.props.IntProperty(default=12)
    <code>loop</code>: bpy.props.<code>BoolProperty</code>(default=True)</pre>
<p>The implementation is very easy: adding a copy of its first element at the end of <code>verts</code> brings the objects back to their initial position at the end of the animation:</p>
<pre class="source-code">
        if self.loop:
            verts.append(verts[0])</pre>
<p>Animating rotations is slightly more complex. With the help of a little math, at each frame, we can orient the object toward its next destination.</p>
<h2 id="_idParaDest-195"><a id="_idTextAnchor200"/>Adding rotations</h2>
<p>The math behind rotations can be challenging at first, but since we just want to rotate the objects <a id="_idIndexMarker549"/>around their <em class="italic">Z</em>-axes, we can use basic <strong class="bold">trigonometry</strong>.</p>
<p>In trigonometry, angles can <a id="_idIndexMarker550"/>be represented as arcs of a circle of radius 1 and consequently, maximum length equal to two times π. The letter π (spelled pi) is the ratio between a circle and its diameter. Its approximate value is <code>3.14</code>.</p>
<p>Trigonometry is a framework that contains many useful functions regarding the relationships between angles, segments, and rotations. Among them, there is a function that answers the question we are posing – that is, how do we rotate an object so that it faces toward a point?</p>
<h3>Representing rotation arcs</h3>
<p>Imagine rotating an object toward a point of known <em class="italic">X</em> and <em class="italic">Y</em> coordinates. If the rotation traces an <a id="_idIndexMarker551"/>arc over an imaginary circle, we can consider the <code>y</code> coordinate of our point as the <em class="italic">height</em> of that arc. This dimension <a id="_idIndexMarker552"/>is called the <strong class="bold">sine</strong> of the angle, and it is very useful when comparing angles and lengths.</p>
<p>The inverse of <em class="italic">sine</em> is called <strong class="bold">arcsine</strong>. It is of <a id="_idIndexMarker553"/>interest to us because it is the rotation associated with a sine. In other words, if we want to measure an angle and we know its <em class="italic">sine</em>, we can find the rotation using the following expression:</p>
<pre class="source-code">
<code>rotation = arcsin(sine)</code></pre>
<p>We know the sine, which is the <code>y</code> coordinate of the point we want to look at:</p>
<div><div><img alt="Figure 7.18: Trigonometric representation of a look-at rotation" height="853" src="img/Figure_7.18_B18375.jpg" width="853"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.18: Trigonometric representation of a look-at rotation</p>
<p>So, <em class="italic">arcsine</em> is the <a id="_idIndexMarker554"/>trigonometric function we are looking for. It is shortened as <code>asin</code> in Python, and to use it, we must import it from the <code>math</code> module.</p>
<h3>Implementing rotation</h3>
<p>In trigonometry, we express <a id="_idIndexMarker555"/>rotations in <code>3.14</code> in our code, we can import the <code>pi</code> constant from the <code>math</code> module. So, besides <code>asin</code>, we need <code>pi</code> as well so that our import section looks like this:</p>
<pre class="source-code">
import bpy
from math import <code>asin</code>
from math import <code>pi</code></pre>
<p>We will write the <code>VertRunner.aim_to_point</code> method to address object rotations separately. The first step to do that is subtracting the current position from the target coordinates so that we can get a direction:</p>
<pre class="source-code">
    def <code>aim_to_point</code>(self, <code>ob</code>, <code>point_co</code>):
        """Orient object to look at coordinates"""
        <code>direction</code> = point_co – ob.location</pre>
<p>Then, we must normalize the direction so that the result is not affected by distance:</p>
<pre class="source-code">
        direction.<code>normalize</code>()</pre>
<p>The look-at <a id="_idIndexMarker557"/>rotation is returned by <code>asin(direction.y)</code>, but there is a catch: arcsine always assumes that it must cover the right-hand side of the circle – that is, positive values of <code>direction.x</code>. What happens when our direction falls on the other side?</p>
<div><div><img alt="Figure 7.19: Look-at rotation for negative values of x" height="730" src="img/Figure_7.19_B18375.jpg" width="754"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.19: Look-at rotation for negative values of x</p>
<p>In that case, we can get to the other side of the circle by subtracting <code>pi</code> from the <code>asin</code> result since <code>pi</code> measures half of a unitary circumference length:</p>
<pre class="source-code">
        arc = asin(direction.y)
        if direction.x &lt; 0:
            arc = pi – arc</pre>
<p>We must also account for the fact that, in Blender, objects at rest look in the opposite direction of the <em class="italic">Y</em>-axis, so we must add a 90 degrees clockwise rotation to the result.</p>
<p>In radians, that’s <code>pi / </code><code>2</code>:</p>
<pre class="source-code">
        arc += pi / 2</pre>
<p>At this <a id="_idIndexMarker558"/>point, <code>arc</code> contains the rotation we are looking for. We could use it right away, but there is still a problem: there are two ways to interpolate from one rotation to another.</p>
<h3>Finding the shortest arc</h3>
<p>Imagine rotating an object from 30° to 330°. The quickest way to do this is via a counterclockwise <a id="_idIndexMarker559"/>rotation that passes through 0° and stops at -30°, which is equivalent to 330°. The longest way is by passing clockwise from 30° to 180° and then, finally, 330°:</p>
<div><div><img alt="Figure 7.20: Short and long arcs of rotation from 30 to 330 degrees" height="618" src="img/Figure_7.20_B18375.jpg" width="654"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.20: Short and long arcs of rotation from 30 to 330 degrees</p>
<p>Both are a valid transition from 30° to 330°, but we might want to prefer the shortest rotation: doing otherwise would cause an object to spin on itself.</p>
<p>To find the shortest arc away from the current rotation, we must store three possibilities in a tuple – the target orient, the same value after a complete clockwise rotation, and the same value rotated counterclockwise:</p>
<pre class="source-code">
    arcs = (<code>arc</code>, arc <code>+ 2*pi</code>, arc <code>- 2*pi</code>)</pre>
<p>Then, we must store the absolute rotational differences using a list comprehension. From there, we can get the shortest arc using <code>min</code>:</p>
<pre class="source-code">
    diffs = [<code>abs</code>(ob.rotation_euler.z - <code>a</code>) for <code>a</code> in <code>arcs</code>]
    <code>shortest</code> = min(diffs)</pre>
<p>We must <a id="_idIndexMarker560"/>use the arc associated with the minimum difference. Using that as a condition of the <code>next</code> statement, we can find it and assign it to <code>rotation_euler.z</code>:</p>
<pre class="source-code">
    res = <code>next</code>(a for <code>i</code>, a in enumerate(arcs)
               if <code>diffs[i]</code> == <code>shortest</code>)
    ob.rotation_euler.z = res</pre>
<p>We can now animate rotations using the <code>aim_to_point</code> method inside <code>execute</code>.</p>
<h3>Putting everything together</h3>
<p>The final <a id="_idIndexMarker561"/>version of <code>execute</code> is only slightly different. It starts in the same way: gathering the list of vertices, adding the first vertex again if we are animating a cycle, and skipping the active object:</p>
<pre class="source-code">
  def execute(self, context):
      verts = list(context.object.data.vertices)
      if self.loop:
          verts.append(verts[0])
      for ob in context.selected_objects:
          if ob == context.active_object:
            continue</pre>
<p>Our orient method is based on the current object position, so before we start animating, we must move the object to the end of the path:</p>
<pre class="source-code">
      ob.location = context.object.data.vertices[-1].co</pre>
<p>This way, when the animation starts, <code>aim_to_point</code> orients the object toward the first vertex. Now, we must insert keyframes for <code>rotation_euler.z</code> as well and repeat the process until all the points have been reached. After that, we can finish the execution:</p>
<pre class="source-code">
      frame = context.scene.frame_current
      for vert in verts:
          self.<code>aim_to_point</code>(ob, vert.co)
          ob.<code>keyframe_insert('rotation_euler'</code>,
                             frame=frame, index=2)
          ob.location = vert.co
          ob.keyframe_insert('location', frame=frame)
          frame += self.step
  return {'FINISHED'}</pre>
<p>By enabling <strong class="bold">Vert Runner</strong> in the add-ons list or updating the scripts if it was enabled already, we can <a id="_idIndexMarker562"/>test our add-on on any pair of objects.</p>
<h2 id="_idParaDest-196"><a id="_idTextAnchor201"/>Using Vert Runner</h2>
<p>We can use <a id="_idIndexMarker563"/>this operator on every couple of objects. There is a peculiar entry among the solids available in Blender – a stylized head of a <strong class="bold">Monkey</strong> jokingly inserted among more common shapes such as <strong class="bold">Cube</strong>, <strong class="bold">Plane</strong>, <strong class="bold">Sphere</strong>, and so on. The monkey’s head, affectionately named <strong class="bold">Suzanne</strong>, makes rotations easier to visualize because of its obvious front side, so using it to test our add-on is a natural choice:</p>
<ol>
<li>Add a monkey head to the scene via <strong class="bold">Add</strong> | <strong class="bold">Mesh</strong> | <strong class="bold">Monkey</strong> from the Viewport menu bar.</li>
<li>Add any other mesh to the scene or use the Cube shape from the default scene if present.</li>
<li>Keeping <em class="italic">Shift</em> pressed (multiple selection), select the monkey, then select the object to use as an animation guide.</li>
<li>From the Viewport menu bar, select <strong class="bold">Object</strong> | <strong class="bold">Animation</strong> | <strong class="bold">Vert Runner</strong>.</li>
<li>Play the animation with <em class="italic">Alt</em> + <em class="italic">A</em> or by clicking the media control button.</li>
</ol>
<p>The cube will pass through each vertex of <a id="_idTextAnchor202"/>the active object. Speed and cyclic animation can be toggled in the options.</p>
<p>Though relatively simple, this tool can <a id="_idTextAnchor203"/>be expanded and generate motion for vehicles or even articulated characters.</p>
<p>Programming for <a id="_idIndexMarker564"/>animation generally comes down to converting an intuitive concept, such as looking toward a direction, into mathematical terms, like we did when extrapolating rotations. Plus, we have investigated the geometry structure and gained access to the vertex coordinates.</p>
<p>This brings us to the end of this chapter, where we learned how to affect the animation settings and the animation of objects.</p>
<h1 id="_idParaDest-197"><a id="_idTextAnchor204"/>Summary</h1>
<p>In this chapter, we became familiar with object animation, learned how animations are created and stored, and looked at which scene settings are directly related to the animation system. We also learned how animation can be partly automated and approached from a geometric perspective, with a glimpse at the trigonometric representation of rotation angles.</p>
<p>Being able to automate part of the animation process is a valuable skill. Sometimes, the math involved might emerge and require solving, but we should not fear that, as math usually comes with a set of ready-to-use solutions for most ordinary use cases.</p>
<p>We have just started our journey into generated animation, which will continue in <a href="B18375_08.xhtml#_idTextAnchor206"><em class="italic">Chapter 8</em></a>, where we will learn how to enrich animation curves with procedural effects.</p>
<h1 id="_idParaDest-198"><a id="_idTextAnchor205"/>Questions</h1>
<ol>
<li>How are animated values stored?</li>
<li>Can one animation curve contain the keyframes of an entire Vector property?</li>
<li>How are animation curves grouped?</li>
<li>The current frame number is 1. Without changing that setting, can we insert a keyframe at frame 4 using the user interface?</li>
<li>The current frame number is 1. Without changing that setting, can we insert a keyframe at frame 4 using the Python API?</li>
<li>Does a smooth motion require a keyframe on every frame?</li>
<li>How are keyframes interpolated?</li>
<li>Are there more ways to interpolate two rotations?</li>
</ol>
</div>
</div></body></html>