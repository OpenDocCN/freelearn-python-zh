<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer154">
<h1 class="chapter-number" id="_idParaDest-166"><a id="_idTextAnchor171"/>7</h1>
<h1 id="_idParaDest-167"><a id="_idTextAnchor172"/>The Animation System</h1>
<p>3D owes much of its popularity to the production of animated content. Its many advantages in terms of performance, quality, and scalability made it ubiquitous in motion pictures, cartoons, feature animation, and video games. With that comes the need for custom tools to ease <span class="No-Break">animation-related tasks.</span></p>
<p>Most applications handle animation similarly, in part inherited from hand-drawn workflows: a sequence is broken into frames, whose rapid succession creates the illusion <span class="No-Break">of motion.</span></p>
<p>A programmer working in 3D will have to account for animated values changing over time, and how such data <span class="No-Break">is stored.</span></p>
<p>That might change in the future, but at the time of writing, animation involves a huge amount of manual work, leaving much room <span class="No-Break">for automation.</span></p>
<p>In this chapter, you will get acquainted with the Blender animation process, learn how to access animation data in Python, and build one tool that sets the playback range and another that <span class="No-Break">animates objects.</span></p>
<p>This chapter will cover the <span class="No-Break">following topics:</span></p>
<ul>
<li>Understanding the <span class="No-Break">animation system</span></li>
<li>Changing the <span class="No-Break">playback settings</span></li>
<li>Creating animations <span class="No-Break">with Python</span></li>
</ul>
<h1 id="_idParaDest-168"><a id="_idTextAnchor173"/>Technical requirements</h1>
<p>We will use Blender and Visual Studio Code in this chapter. The examples created in this chapter can be found <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Python-Scripting-in-Blender/tree/main/ch7"><span class="No-Break">https://github.com/PacktPublishing/Python-Scripting-in-Blender/tree/main/ch7</span></a><span class="No-Break">.</span></p>
<h1 id="_idParaDest-169"><a id="_idTextAnchor174"/>Understanding the animation system</h1>
<p>While animations <a id="_idIndexMarker467"/>consist of a sequence of frames, only one frame is displayed on the screen at one time. Animators can scroll through these frames and play their animation like <span class="No-Break">a video:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer134">
<img alt="Figure 7.1: Playing an animation in Blender" height="904" src="image/Figure_7.01_B18375.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.1: Playing an animation in Blender</p>
<p>The animation <strong class="bold">Timeline</strong>, at the bottom of the screen in the <strong class="bold">Layout</strong> workspace, controls and displays the current frame and the start/end of the sequence. It provides immediate visual feedback and is essential <span class="No-Break">to animation.</span></p>
<h2 id="_idParaDest-170"><a id="_idTextAnchor175"/>Timeline and Current Frame</h2>
<p>A <strong class="bold">Timeline</strong> is a Blender <a id="_idIndexMarker468"/>area for playing animations and changing the playback settings. It is marked with a clock icon and, because of its importance, is in more than one workspace: <strong class="bold">Animation</strong>, <strong class="bold">Layout</strong>, <strong class="bold">Rendering</strong>, and <strong class="bold">Compositing</strong> display <span class="No-Break">a timeline.</span></p>
<p>In addition to the frame <strong class="bold">Start</strong> and <strong class="bold">End</strong> values, there is a slider for the <strong class="bold">Current Frame</strong> area and a button bar with <span class="No-Break"><strong class="bold">Media Controls</strong></span><span class="No-Break">:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer135">
<img alt="Figure 7.2: Blender’s animation Timeline" height="134" src="image/Figure_7.02_B18375.jpg" width="1587"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.2: Blender’s animation Timeline</p>
<p>Besides frame <a id="_idIndexMarker469"/>range and controls, the timeline displays the <strong class="bold">keyframes</strong> – that is, frames that contain changes in the <span class="No-Break">object properties.</span></p>
<p>The frame <a id="_idIndexMarker470"/>range information, which is relevant to other tasks, such as <strong class="bold">Rendering</strong>, is an attribute of the scene that can be also set in the <span class="No-Break">scene properties.</span></p>
<h2 id="_idParaDest-171"><a id="_idTextAnchor176"/>Duration and Frame Rate</h2>
<p>The duration <a id="_idIndexMarker471"/>of the current scene can be set in the <strong class="bold">Format</strong> and <strong class="bold">Frame Range</strong> panels in the <strong class="bold">Output</strong> properties, the second tab starting from above, marked with a <span class="No-Break">printer icon.</span></p>
<p class="callout-heading">One scene, four tabs!</p>
<p class="callout">There are so many scene properties that they span the first four tabs. It can be confusing because all of them read <strong class="bold">Scene</strong> in <span class="No-Break">their headers.</span></p>
<p class="callout">These four categories are <span class="No-Break">as follows:</span></p>
<p class="callout"> - <strong class="bold">Render</strong>, marked with a <span class="No-Break">TV icon</span></p>
<p class="callout"> - <strong class="bold">Output</strong>, with a <span class="No-Break">printer icon</span></p>
<p class="callout"> - <strong class="bold">View Layers</strong>, whose icon is a stack <span class="No-Break">of pictures</span></p>
<p class="callout"> - <strong class="bold">Scene</strong>, whose icon represents a cone and <span class="No-Break">a sphere</span></p>
<p class="callout">Only the <strong class="bold">Output</strong> properties contain <span class="No-Break">animation-related settings.</span></p>
<p>The <strong class="bold">Frame Rate</strong> property displays how many frames are contained in 1 second of animation and <a id="_idIndexMarker472"/>is also known as <strong class="bold">frames per </strong><span class="No-Break"><strong class="bold">second</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">FPS</strong></span><span class="No-Break">).</span></p>
<p>The default <a id="_idIndexMarker473"/>value is <strong class="source-inline">24 FPS</strong>, the historical rate for feature films. Because of the frequency of the power grid, footage for American TV is usually shot at <strong class="source-inline">30</strong> FPS, while European TVs use <strong class="source-inline">25</strong> FPS. Motion capture or video game animations may have higher rates, such as <span class="No-Break"><strong class="source-inline">60</strong></span><span class="No-Break"> FPS:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer136">
<img alt="Figure 7.3: Scene range attributes" height="606" src="image/Figure_7.03_B18375.jpg" width="465"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.3: Scene range attributes</p>
<p>Raising the <strong class="bold">Frame Rate</strong> value makes the animation play more frames per second, so it shortens the playback duration as more frames are spent in <span class="No-Break">less time.</span></p>
<p>While the graphic interface allows the animator to either pick a frame rate from a list of presets or display an additional property for custom values, in Python, <strong class="source-inline">fps</strong> is a numeric attribute of the <span class="No-Break"><strong class="source-inline">scene.render</strong></span><span class="No-Break"> properties:</span></p>
<pre class="source-code">
&gt;&gt;&gt; import bpy
&gt;&gt;&gt; bpy.context.scene.render.fps
24</pre>
<p>By default, the first frame of a scene, <strong class="bold">Frame Start</strong>, is set to <strong class="source-inline">1</strong> while the last frame, <strong class="bold">Frame End</strong>, is set to <strong class="source-inline">250</strong>. These values are arbitrary and are changed to the planned duration of a <span class="No-Break">specific shot.</span></p>
<p>The first and last frame of the scene can be accessed in Python as <span class="No-Break">scene attributes:</span></p>
<pre class="source-code">
&gt;&gt;&gt; import bpy
&gt;&gt;&gt; bpy.context.scene.frame_start
1
&gt;&gt;&gt; bpy.context.scene.frame_end
250</pre>
<p><strong class="bold">Frame Step</strong> is the gap between one rendered frame and the next and is usually set to <strong class="source-inline">1</strong>. It can be <a id="_idIndexMarker474"/>increased so that not all frames are rendered, a feature used by render managers to test the overall state of <span class="No-Break">a sequence:</span></p>
<pre class="source-code">
&gt;&gt;&gt; import bpy
&gt;&gt;&gt; bpy.context.scene.frame_step
1</pre>
<p>While the start, end, and step of the sequence are available in the <strong class="bold">Output</strong> properties as well, the <strong class="bold">current frame</strong> and the <strong class="bold">preview range</strong> are displayed only in the <span class="No-Break"><strong class="bold">Timeline</strong></span><span class="No-Break"> view.</span></p>
<h2 id="_idParaDest-172"><a id="_idTextAnchor177"/>Current frame and preview range</h2>
<p>Like <strong class="source-inline">frame_start</strong>, <strong class="source-inline">frame_end</strong>, and <strong class="source-inline">frame_step</strong>, the current frame is exposed as a Python <a id="_idIndexMarker475"/>attribute of <span class="No-Break">the scene:</span></p>
<pre class="source-code">
&gt;&gt;&gt; import bpy
&gt;&gt;&gt; bpy.context.scene.frame_current
1</pre>
<p>In the <strong class="bold">Timeline</strong> view, the button with a stopwatch icon on the left of <strong class="bold">Start</strong>/<strong class="bold">End</strong> toggles the preview range. It displays an alternate range, different from the <span class="No-Break">render settings:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer137">
<img alt="Figure 7.4: Enabling the preview range in the Timeline view" height="134" src="image/Figure_7.04_B18375.jpg" width="1587"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.4: Enabling the preview range in the Timeline view</p>
<p>The region <a id="_idIndexMarker476"/>outside the preview range is marked in dark orange. Animators turn on the preview range to restrict the playback when they are working on a part of their <span class="No-Break">assigned sequence.</span></p>
<p>In Python, we can access <strong class="source-inline">frame_preview_start</strong> and <strong class="source-inline">frame_preview_end</strong> <span class="No-Break">like so:</span></p>
<pre class="source-code">
&gt;&gt;&gt; import bpy
&gt;&gt;&gt; bpy.context.scene.frame_preview_start
1
&gt;&gt;&gt; bpy.context.scene.frame_preview_end
250</pre>
<p>All the frames between <strong class="source-inline">start</strong> and <strong class="source-inline">end</strong> make the animated sequence, but not all frames must store information. Those that do are the keyframes of <span class="No-Break">the animation.</span></p>
<h2 id="_idParaDest-173"><a id="_idTextAnchor178"/>Animation keyframes</h2>
<p>The position of objects at a certain <a id="_idIndexMarker477"/>moment is stored as <strong class="bold">keyframes</strong>. In this section, we will <a id="_idIndexMarker478"/>provide a brief overview of how keyframes are created and retrieved in the user interface, as well as with <span class="No-Break">Python instructions.</span></p>
<h3>Adding keyframes in Blender</h3>
<p>There are <a id="_idIndexMarker479"/>at least two ways to set keyframes <span class="No-Break">in Blender:</span></p>
<ul>
<li>Right-click on a property, then click on <strong class="bold">Insert Keyframe(s)</strong> from the <span class="No-Break">context menu</span></li>
<li>Press <strong class="bold">I</strong> in the Viewport to display the <strong class="bold">Insert Keyframe Menu</strong> area and select a property <span class="No-Break">to animate</span></li>
</ul>
<p>We can make changes and insert keyframes at different times to create <span class="No-Break">an animation.</span></p>
<h3>Animating objects</h3>
<p>To get more <a id="_idIndexMarker480"/>familiar with animations, we can open Blender and add keyframes for the location of the <span class="No-Break">default cube:</span></p>
<ol>
<li>Open Blender and select an object. If there are none in the scene, we can use <strong class="bold">Add</strong> | <strong class="bold">Mesh</strong> | <strong class="bold">Cube</strong> from the <span class="No-Break">top menu.</span></li>
<li>Press the <em class="italic">N</em> key to display the properties of the <span class="No-Break">active object.</span></li>
<li>Right-click on any of the <span class="No-Break"><strong class="bold">Location</strong></span><span class="No-Break"> attributes.</span></li>
<li>Select <span class="No-Break"><strong class="bold">Insert Keyframes</strong></span><span class="No-Break">.</span></li>
</ol>
<p>However, one keyframe is not enough to make the cube move on the screen. To create a proper animation, we need to do <span class="No-Break">the following:</span></p>
<ol>
<li>Set a new value for the <strong class="bold">Current Frame</strong> field – for <span class="No-Break">instance, </span><span class="No-Break"><strong class="source-inline">24</strong></span><span class="No-Break">.</span></li>
<li>Move the cube to a new location by pressing the <em class="italic">G</em> key and panning <span class="No-Break">the mouse.</span></li>
<li>Confirm the new position by left-clicking or pressing the <span class="No-Break"><em class="italic">Enter</em></span><span class="No-Break"> key.</span></li>
<li>Press <strong class="source-inline">I</strong> to insert a <span class="No-Break"><strong class="bold">Location</strong></span><span class="No-Break"> keyframe.</span></li>
</ol>
<p>We can play our animation by pressing the <em class="italic">spacebar</em> or clicking the <strong class="bold">Play</strong> button. In some instances, we might want to restrict the frame range to watch our animation in loops. We can set the sequence’s <strong class="bold">Start</strong> and <strong class="bold">End</strong> manually, or we can write an add-on that sets them <span class="No-Break">for us.</span></p>
<h1 id="_idParaDest-174"><a id="_idTextAnchor179"/>Writing the Action to Range add-on</h1>
<p>Animators <a id="_idIndexMarker481"/>set the first and last frames of the scene according to the duration of the shot. If there are animated objects, this add-on can set the playback <span class="No-Break">range automatically.</span></p>
<p>This operator will allow you to choose between the render and <span class="No-Break">preview range.</span></p>
<h2 id="_idParaDest-175"><a id="_idTextAnchor180"/>Setting the environment</h2>
<p>Let’s create <a id="_idIndexMarker482"/>a folder for this chapter in our project. Then, in the <strong class="bold">Blender Preferences</strong> area, we need to set the <strong class="source-inline">ch7</strong> folder as our <strong class="bold">Scripts Folder</strong>. We must restart Blender to update its <span class="No-Break">search paths.</span></p>
<p>Our add-on contains an operator, like the ones from <a href="B18375_03.xhtml#_idTextAnchor049"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>, and <a href="B18375_04.xhtml#_idTextAnchor075"><span class="No-Break"><em class="italic">Chapter 4</em></span></a><span class="No-Break">:</span></p>
<ol>
<li><span class="No-Break">Select </span><span class="No-Break"><strong class="source-inline">PythonScriptingBlender/ch7/addons</strong></span><span class="No-Break">.</span></li>
<li>Create a new file by clicking the <strong class="bold">New </strong><span class="No-Break"><strong class="bold">File</strong></span><span class="No-Break"> icon.</span></li>
<li>Name the new <span class="No-Break">file </span><span class="No-Break"><strong class="source-inline">action_to_range.py</strong></span><span class="No-Break">.</span></li>
<li>Open the file by <span class="No-Break">double-clicking it.</span></li>
</ol>
<p>We can now start writing our first <span class="No-Break">animation add-on.</span></p>
<h2 id="_idParaDest-176"><a id="_idTextAnchor181"/>Writing the Action to Range information</h2>
<p>The operator <a id="_idIndexMarker483"/>will be invoked <a id="_idIndexMarker484"/>from the <strong class="bold">View</strong> menu of the <strong class="bold">Timeline</strong> view, as reported in the <span class="No-Break">location information:</span></p>
<pre class="source-code">
bl_info = {
    "name": "Action to Range",
    "author": "John Packt",
    "version": (1, 0),
    "blender": (3, 00, 0),
    "location": <strong class="source-inline">"Timeline &gt; View &gt; Action to Scene Range"</strong>
    "description": " Action Duration to Scene Range",
    "category": "Learning",
}</pre>
<p>The next steps are <span class="No-Break">as follows:</span></p>
<ol>
<li>Writing <span class="No-Break">the operator.</span></li>
<li>Writing its <span class="No-Break">menu entry.</span></li>
<li>Registering the classes and <span class="No-Break">user interface.</span></li>
</ol>
<p>Let’s <a id="_idIndexMarker485"/>start with the operator <a id="_idIndexMarker486"/>class and <span class="No-Break">its information.</span></p>
<h2 id="_idParaDest-177"><a id="_idTextAnchor182"/>Writing the Action to Range operator</h2>
<p>As <a id="_idIndexMarker487"/>usual, the <strong class="source-inline">ActionToSceneRange</strong> operator <a id="_idIndexMarker488"/>derives from <strong class="source-inline">bpy.types.Operator</strong> and starts with the <span class="No-Break"><strong class="source-inline">bl_*</strong></span><span class="No-Break"> identifiers:</span></p>
<pre class="source-code">
import bpy
class ActionToSceneRange(bpy.types.Operator):
    """Set Playback range to current action Start/End"""
    bl_idname = "anim.action_to_range"
    bl_label = "Action Range to Scene"
    bl_description = "Transfer action range to scene range"
    bl_options = {'REGISTER', 'UNDO'}</pre>
<p>As noted in the <em class="italic">Understanding the animation system</em> section, there are two frame range settings in the scene: the main one affects the scene render, while the preview range only affects the <span class="No-Break">Viewport playback.</span></p>
<p>We want a parameter to switch between the two. We will use a <strong class="source-inline">BooleanProperty</strong> so that we can affect either the main or <span class="No-Break">preview range:</span></p>
<pre class="source-code">
    <strong class="source-inline">use_preview</strong>: bpy.props.<strong class="source-inline">BoolProperty</strong>(default=False)</pre>
<p>That’s all for the static part of the operator. Adding a <strong class="source-inline">poll</strong> and an <strong class="source-inline">execute</strong> method will allow the operator <span class="No-Break">to run.</span></p>
<h2 id="_idParaDest-178"><a id="_idTextAnchor183"/>Writing the operator methods</h2>
<p>As we <a id="_idIndexMarker489"/>learned in <a href="B18375_03.xhtml#_idTextAnchor049"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>, the <strong class="source-inline">poll</strong> method returns <strong class="source-inline">False</strong> when the conditions for running the <a id="_idIndexMarker490"/>operator are not met; it’s <strong class="source-inline">True</strong> otherwise. We need to determine the operator requirements and put them in <span class="No-Break">Python form.</span></p>
<h3>Checking the requirements in the poll() method</h3>
<p>To get <a id="_idIndexMarker491"/>the range of the active animation, we must verify the <span class="No-Break">following conditions:</span></p>
<ul>
<li>There should be an <span class="No-Break">active object</span></li>
<li>The active object must <span class="No-Break">be animated</span></li>
</ul>
<p>When an object is animated, its keyframes are grouped into an <strong class="bold">action</strong>, which, in turn, becomes the active action in the object’s <span class="No-Break"><strong class="bold">animation data</strong></span><span class="No-Break">.</span></p>
<p>We will explore these entities in more depth in the next section, <em class="italic">Accessing animation data in Python</em>. For now, we can just test their existence in the <span class="No-Break">following code:</span></p>
<pre class="source-code">
    @classmethod
    def poll(cls, context):
        obj = context.object
        if <strong class="source-inline">not obj</strong>:
            return False
        if <strong class="source-inline">not obj.animation_data</strong>:
            return False
        if <strong class="source-inline">not obj.animation_data.action</strong>:
            return False
        return True</pre>
<p>When any of the <strong class="source-inline">not</strong> conditions are met, the operator is grayed out in the interface. Otherwise, the operator can be launched, and that will run its <span class="No-Break"><strong class="source-inline">execute</strong></span><span class="No-Break"> method.</span></p>
<h3>Writing the execute method</h3>
<p>The <strong class="source-inline">execute</strong> method performs the operator activity. It does <span class="No-Break">the following:</span></p>
<ol>
<li>Finds the frame range of the <span class="No-Break">current action</span></li>
<li>Sets the first and last frame of the <span class="No-Break">scene accordingly</span></li>
<li>Fits the new frame range in the <span class="No-Break">timeline visually</span></li>
</ol>
<p>We already <a id="_idIndexMarker492"/>know how to access the active object’s action. Its <strong class="source-inline">frame_range</strong> attribute contains the first and last frame of <span class="No-Break">the action:</span></p>
<pre class="source-code">
    def execute(self, context):
        anim_data = context.object.animation_data
        <strong class="source-inline">first, last</strong> = anim_data.action.<strong class="source-inline">frame_range</strong></pre>
<p>We get the current <strong class="source-inline">scene</strong> and perform <em class="italic">step 2</em>. If the timeline preview range is used, we should set the preview start/end frames. Frame values are stored as decimal floats, and we need to convert them into integers before using them for the <span class="No-Break"><strong class="source-inline">frame*</strong></span><span class="No-Break"> attributes:</span></p>
<pre class="source-code">
        scn = context.scene
        if self.<strong class="source-inline">use_preview</strong>:
            scn.frame_<strong class="source-inline">preview</strong>_start = <strong class="source-inline">int</strong>(first)
            scn.frame_<strong class="source-inline">preview</strong>_end = <strong class="source-inline">int</strong>(last)</pre>
<p>Otherwise, we must set the standard <strong class="source-inline">frame_start</strong> and <strong class="source-inline">frame_end</strong> of <span class="No-Break">the scene:</span></p>
<pre class="source-code">
        else:
            scn.frame_start = <strong class="source-inline">int</strong>(first)
            scn.frame_end = <strong class="source-inline">int</strong>(last)</pre>
<p>Now that we have set our values, we can invoke <strong class="source-inline">ops.action.view_all()</strong> to fit the <strong class="bold">Timeline</strong> view to the new range, and finish <span class="No-Break">the execution:</span></p>
<pre class="source-code">
        bpy.ops.action.view_all()
        return {'FINISHED'}</pre>
<p>We need to add <strong class="source-inline">'UNDO'</strong> to <strong class="source-inline">bl_options</strong> to affect the operator attributes after the execution, as we learned in <a href="B18375_04.xhtml#_idTextAnchor075"><span class="No-Break"><em class="italic">Chapter 4</em></span></a><span class="No-Break">:</span></p>
<pre class="source-code">
bl_options = {'REGISTER', 'UNDO'}</pre>
<p>Unfortunately, operators <a id="_idIndexMarker493"/>that are launched outside of the <strong class="bold">3D Viewport</strong> area or the <strong class="bold">Graph Editor</strong> area don’t display the <strong class="bold">Operator Panel</strong> area, thus preventing the user from switching <strong class="source-inline">use_preview</strong> <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">False</strong></span><span class="No-Break">.</span></p>
<p>To work around that, we can create two entries in the <strong class="bold">Timeline</strong> | <span class="No-Break"><strong class="bold">View</strong></span><span class="No-Break"> menu.</span></p>
<h2 id="_idParaDest-179"><a id="_idTextAnchor184"/>Writing the menu function</h2>
<p>In <a href="B18375_03.xhtml#_idTextAnchor049"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>, we learned that adding a function to a menu class allows us to add elements to <span class="No-Break">its layout.</span></p>
<p>Also, in <a href="B18375_05.xhtml#_idTextAnchor100"><span class="No-Break"><em class="italic">Chapter 5</em></span></a>, we learned that operator properties are <a id="_idIndexMarker494"/>returned by the <strong class="source-inline">layout.operator</strong> function and can be <span class="No-Break">set programmatically.</span></p>
<p>Combining <a id="_idIndexMarker495"/>these two techniques, we can create two menu entries that invoke the same operator, but we only enable <strong class="source-inline">use_preview</strong> on one of the two. This way, we end up with two menu items. They execute the same operator but with different settings <span class="No-Break">and outcomes.</span></p>
<p>To make sure that the difference is reflected in the operator label, we can change it using the <span class="No-Break"><strong class="source-inline">text=</strong></span><span class="No-Break"> parameter:</span></p>
<pre class="source-code">
def view_menu_items(self, context):
    <strong class="source-inline">props</strong> = self.layout.operator(
                         <strong class="source-inline">ActionToSceneRange</strong>.bl_idname,
                         text=ActionToSceneRange.bl_label <strong class="source-inline">+</strong>
                              <strong class="source-inline">" (preview)"</strong>)
    <strong class="source-inline">props.use_preview</strong> = True</pre>
<p>We have added <strong class="source-inline">" (preview)"</strong> to the operator label so that it’s clear that this is a variant of the <span class="No-Break"><strong class="source-inline">ActionToSceneRange</strong></span><span class="No-Break"> operator.</span></p>
<p>The default entry affects the actual scene range, so there is no need to specify the text <span class="No-Break">label explicitly:</span></p>
<pre class="source-code">
    props = self.layout.operator(
                         ActionToSceneRange.bl_idname
                         )
    props.use_preview = False</pre>
<p>Menu entries are <a id="_idIndexMarker496"/>displayed with a <strong class="bold">Last In First Out</strong> (<strong class="bold">LIFO</strong>) policy. We <a id="_idIndexMarker497"/>added the (preview) item first, so it will be displayed <a id="_idIndexMarker498"/>after the default <strong class="bold">Action to Scene </strong><span class="No-Break"><strong class="bold">Range</strong></span><span class="No-Break"> entry.</span></p>
<p class="callout-heading">It won’t default forever!</p>
<p class="callout"><strong class="source-inline">ActionToSceneRange.use_preview</strong> is already <strong class="source-inline">False</strong> by default, but we set <strong class="source-inline">props.use_preview</strong> to <strong class="source-inline">False</strong> anyway <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">view_menu_items</strong></span><span class="No-Break">.</span></p>
<p class="callout">Unless <strong class="source-inline">is_skip_save</strong> is used for a property, the default value only affects the first execution of an operator. From then on, the last user choice becomes the <span class="No-Break">new default.</span></p>
<p class="callout">If an element of the interface matches specific operator settings, then we should set them explicitly in <span class="No-Break">the code.</span></p>
<p>Now that we’ve created the elements of the add-on, we need to register the operator and menu entries. Then, it will be ready <span class="No-Break">to go.</span></p>
<h2 id="_idParaDest-180"><a id="_idTextAnchor185"/>Finishing the add-on</h2>
<p>We need the <a id="_idIndexMarker499"/>class name of the <strong class="bold">Timeline</strong> | <strong class="bold">View</strong> menu. To find it, we can look up the Python source of the <span class="No-Break">Blender interface.</span></p>
<h3>Finding a menu’s Python class</h3>
<p>We can <a id="_idIndexMarker500"/>right-click the <strong class="bold">Timeline</strong> | <strong class="bold">View</strong> menu and select <strong class="bold">Edit Source</strong> to find its <span class="No-Break">Python name:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer138">
<img alt="Figure 7.5: Opening Timeline | View" height="270" src="image/Figure_7.05_B18375.jpg" width="618"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.5: Opening Timeline | View</p>
<p>Then, in the <strong class="bold">Scripting</strong> workspace, select <strong class="source-inline">space_time.py</strong> in the <strong class="bold">Text </strong><span class="No-Break"><strong class="bold">Editor</strong></span><span class="No-Break"> area:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer139">
<img alt="Figure 7.6: space_time.py as a loaded text block" height="211" src="image/Figure_7.06_B18375.jpg" width="825"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.6: space_time.py as a loaded text block</p>
<p>The script found in the <strong class="bold">Text Editor</strong> area contains the instructions for the <strong class="bold">Timeline</strong> interface. Since we have loaded it by right-clicking on its element, in the editor, the text has been scrolled down to the part where the <strong class="bold">Timeline</strong> | <strong class="bold">View</strong> menu was added. The argument of the <strong class="source-inline">menu()</strong> function is the class name we are <span class="No-Break">looking for:</span></p>
<pre class="source-code">
        sub.menu("<strong class="source-inline">TIME_MT_view</strong>")</pre>
<p>We can use this name in our <span class="No-Break"><strong class="source-inline">register()</strong></span><span class="No-Break"> function.</span></p>
<h3>Writing the register/unregister functions</h3>
<p>We can <a id="_idIndexMarker501"/>use <strong class="source-inline">register_class</strong> to add <strong class="source-inline">ActionToSceneRange</strong> to the Blender operators, and we can append our items to <strong class="source-inline">TIME_MT_view</strong> to display our new entries in the <strong class="bold">Timeline</strong> | <span class="No-Break"><strong class="bold">View</strong></span><span class="No-Break"> menu:</span></p>
<pre class="source-code">
def register():
    bpy.utils.register_class(<strong class="source-inline">ActionToSceneRange</strong>)
    bpy.types.<strong class="source-inline">TIME_MT_view.append</strong>(view_menu_items)</pre>
<p>Likewise, when the add-on is disabled, <strong class="source-inline">unregister()</strong> removes our items from the menu <a id="_idIndexMarker502"/>and the operator <span class="No-Break">from Blender:</span></p>
<pre class="source-code">
def unregister():
    bpy.types.TIME_MT_view.<strong class="source-inline">remove</strong>(view_menu_items)
    bpy.utils.unregister_class(ActionToSceneRange)</pre>
<p>Now, the operator is ready. We can use it on the cube we animated earlier in this chapter or open one of the files contained <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">ch7/_scenes_</strong></span><span class="No-Break">.</span></p>
<h2 id="_idParaDest-181"><a id="_idTextAnchor186"/>Enabling and running</h2>
<p>If the <strong class="source-inline">PythonScriptingBlender/ch7</strong> folder was added to the <strong class="source-inline">scripts</strong> path, we can <a id="_idIndexMarker503"/>find and <a id="_idIndexMarker504"/>enable <strong class="bold">Action to Range</strong> in the <span class="No-Break"><strong class="bold">Add-ons</strong></span><span class="No-Break"> preferences:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer140">
<img alt="Figure 7.7: Enabling the Action to Range add-on" height="384" src="image/Figure_7.07_B18375.jpg" width="992"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.7: Enabling the Action to Range add-on</p>
<p>If the add-on was installed correctly, we will find two new entries in <strong class="bold">Timeline</strong> | <span class="No-Break"><strong class="bold">View</strong></span><span class="No-Break">:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer141">
<img alt="Figure 7.8: Action to Scene Range and its “preview” variant" height="208" src="image/Figure_7.08_B18375.jpg" width="623"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.8: Action to Scene Range and its “preview” variant</p>
<p>Clicking <strong class="bold">Action to Scene Range</strong> sets <a id="_idIndexMarker505"/>the scene range <a id="_idIndexMarker506"/>to 1-24, while <strong class="bold">Action to Scene Range (preview)</strong> sets the <span class="No-Break">preview range.</span></p>
<p>Since we have set <strong class="source-inline">bl_options = {'REGISTER', 'UNDO'}</strong> in the properties, we’ll look at how this operator supports the <strong class="bold">Adjust Last </strong><span class="No-Break"><strong class="bold">Operation</strong></span><span class="No-Break"> window.</span></p>
<h3>Changing the parameters of the last operation</h3>
<p>We <a id="_idIndexMarker507"/>can use <strong class="bold">Edit</strong> | <strong class="bold">Adjust Last Operation</strong> from the top menu bar to change the options in the last <span class="No-Break">execution retroactively:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer142">
<img alt="Figure 7.9: Changing the outcome of the last operation" height="563" src="image/Figure_7.09_B18375.jpg" width="795"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.9: Changing the outcome of the last operation</p>
<p>A small window will appear, displaying the operator properties. Turning <strong class="source-inline">use_preview</strong> on and off changes the result of <span class="No-Break">the operation:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer143">
<img alt="Figure 7.10: The Action to Scene Range properties window" height="634" src="image/Figure_7.10_B18375.jpg" width="1136"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.10: The Action to Scene Range properties window</p>
<p>The add-on <a id="_idIndexMarker508"/>is finished, but when it comes to recentering the <strong class="bold">Timeline</strong> view, our execute function calls <strong class="source-inline">bpy.ops.action.view_all()</strong>, a timeline operator. It is fine to call other operators in <strong class="source-inline">execute</strong>, but they can place additional restrictions on the validity of the context, so we must consider that their <strong class="source-inline">poll</strong> method might halt our <span class="No-Break">script’s execution.</span></p>
<p>For instance, by adding our operator to the <strong class="bold">Timeline</strong> | <strong class="bold">View</strong> menu, we could think that a timeline will always be present and that resorting to <strong class="source-inline">action.view_all()</strong>, which requires it, will <span class="No-Break">never fail.</span></p>
<p>But what if the <strong class="source-inline">F3</strong> <strong class="bold">Search Bar</strong> area is used, and the user launches <strong class="bold">Action to Frame Range</strong> even if the <strong class="bold">Timeline</strong> view is not displayed in the interface? In that case, our script will halt with <span class="No-Break">a </span><span class="No-Break"><strong class="source-inline">RuntimeError</strong></span><span class="No-Break">:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer144">
<img alt="Figure 7.11: Our script causes an error if the timeline is not displayed" height="714" src="image/Figure_7.11_B18375.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.11: Our script causes an error if the timeline is not displayed</p>
<p>We can <a id="_idIndexMarker509"/>just warn the user or check the presence timelines in our <strong class="source-inline">poll</strong> method, but usually, the best practice is <span class="No-Break">as follows:</span></p>
<ul>
<li>Use a <strong class="source-inline">try</strong> statement when calling <span class="No-Break">other operators</span></li>
<li>If possible, if a <strong class="source-inline">RuntimeError</strong> occurs, create an alternate <strong class="source-inline">context</strong> for running the <span class="No-Break">other operator</span></li>
</ul>
<p>This way, even if something goes wrong, our operator will carry on with <span class="No-Break">its task.</span></p>
<h2 id="_idParaDest-182"><a id="_idTextAnchor187"/>Fixing context for other operators</h2>
<p>We can prevent a Python script from stopping in case of errors by using <strong class="source-inline">try</strong> and <strong class="source-inline">catch</strong> statements. The code that risks causing errors goes under the <strong class="source-inline">try</strong> indent block, while the <a id="_idIndexMarker510"/>code to execute in case a specific error happens goes under the <strong class="source-inline">except </strong><span class="No-Break"><strong class="source-inline">ErrorType</strong></span><span class="No-Break"> indent.</span></p>
<p>In our case, the error message was raised when <strong class="bold">Action to Range</strong> ran with no <strong class="bold">Timeline</strong> in view. This specifies <span class="No-Break">a </span><span class="No-Break"><strong class="source-inline">RuntimeError</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
RuntimeError: Operator bpy.ops.action.view_all.poll() failed, context is incorrect</pre>
<p>To get past this issue, we must provide a plan B inside an <strong class="source-inline">except RuntimeError</strong> block. If we don’t want to do anything, we can use the empty <span class="No-Break"><strong class="source-inline">pass</strong></span><span class="No-Break"> instruction:</span></p>
<pre class="source-code">
try:
    bpy.ops.action.view_all()
except <strong class="source-inline">RuntimeError</strong>:
    <strong class="source-inline">pass</strong></pre>
<p>But we can do better: we can look for a timeline in the window, override <strong class="source-inline">context</strong>, and pass it to <span class="No-Break">the operator.</span></p>
<p>In <a href="B18375_05.xhtml#_idTextAnchor100"><span class="No-Break"><em class="italic">Chapter 5</em></span></a>, we learned that a Blender window is split into <strong class="source-inline">screen</strong>, <strong class="source-inline">areas</strong>, and <strong class="source-inline">regions</strong>. From the documentation, we know that timeline editors are of the <strong class="source-inline">'</strong><span class="No-Break"><strong class="source-inline">DOPESHEET_EDITOR'</strong></span><span class="No-Break"> type.</span></p>
<p>There might be more windows open. For each of them, we can get the <span class="No-Break">screen attribute:</span></p>
<pre class="source-code">
    for window in <strong class="source-inline">context.window_manager</strong>.windows:
        screen = window.<strong class="source-inline">screen</strong></pre>
<p>Then, we must look for a <strong class="source-inline">'DOPESHEET_EDITOR'</strong> among <strong class="source-inline">areas</strong> of <span class="No-Break">the screen:</span></p>
<pre class="source-code">
        for area in screen.<strong class="source-inline">areas</strong>:
            if area.<strong class="source-inline">type</strong> != <strong class="source-inline">'DOPESHEET_EDITOR'</strong>:
                <strong class="source-inline">continue</strong></pre>
<p>By skipping <a id="_idIndexMarker511"/>every area that is <em class="italic">not</em> a <strong class="source-inline">'DOPESHEET_EDITOR'</strong>, we can ensure that the following lines are executed only if the area is a timeline. We need to look for its main region, which is of the <strong class="source-inline">'</strong><span class="No-Break"><strong class="source-inline">WINDOW'</strong></span><span class="No-Break"> type:</span></p>
<pre class="source-code">
            for region in area.<strong class="source-inline">regions</strong>:
                if region.<strong class="source-inline">type == 'WINDOW'</strong>:</pre>
<p>The timeline’s <strong class="source-inline">window</strong>, <strong class="source-inline">area</strong>, and <strong class="source-inline">region</strong> are fed to <strong class="source-inline">context.temp_override</strong> inside a <span class="No-Break"><strong class="source-inline">with</strong></span><span class="No-Break"> statement.</span></p>
<p>In Python, <strong class="source-inline">with</strong> sets a condition that stays valid inside its scope – that is, indented lines of code. There, we can <span class="No-Break">call </span><span class="No-Break"><strong class="source-inline">bpy.ops.action.view_all()</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
                    <strong class="source-inline">with</strong> context.temp_override(
                                            window=<strong class="source-inline">window</strong>,
                                            area=<strong class="source-inline">area</strong>,
                                            region=<strong class="source-inline">region</strong>):
                        bpy.ops.action.<strong class="source-inline">view_all()</strong>
                    <strong class="source-inline">break</strong>
                <strong class="source-inline">break</strong>
    return {'FINISHED'}</pre>
<p>The two <strong class="source-inline">break</strong> statements stop the search after a timeline is found. We have made sure that <strong class="source-inline">view_all</strong> is called only if its conditions <span class="No-Break">are met.</span></p>
<p>Our add-on automated a tedious operation by checking the action frame range, without looking into <a id="_idIndexMarker512"/>the keyframes it contains. To understand how we can access and manipulate the animation data, next, we will learn how keyframes are displayed <span class="No-Break">and edited.</span></p>
<h1 id="_idParaDest-183"><a id="_idTextAnchor188"/>Editing keyframes</h1>
<p>Animation software gives visual cues of keyframe distribution. In Blender, keyframes are displayed with <a id="_idIndexMarker513"/>special colors in the interface and as diamond widgets in the <span class="No-Break">animation editors.</span></p>
<p>Animated properties have colored backgrounds. If the current frame is a keyframe, the background is yellow; otherwise, it <span class="No-Break">is green:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer145">
<img alt="Figure 7.12: Location is animated; the current frame is the keyframe for X and Y" height="138" src="image/Figure_7.12_B18375.jpg" width="278"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.12: Location is animated; the current frame is the keyframe for X and Y</p>
<p>Keyframes of the selected objects are displayed as diamonds in the <span class="No-Break"><strong class="bold">Timeline</strong></span><span class="No-Break"> editor:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer146">
<img alt="Figure 7.13: The animation Timeline. Frames 1 and 24 have keyframes" height="187" src="image/Figure_7.13_B18375.jpg" width="1584"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.13: The animation Timeline. Frames 1 and 24 have keyframes</p>
<p>Blender transitions from one keyframe to the other by tracing a graph between them. These graphs are referred to as <strong class="bold">animation curves</strong> <span class="No-Break">or </span><span class="No-Break"><strong class="bold">f-curves</strong></span><span class="No-Break">.</span></p>
<h2 id="_idParaDest-184"><a id="_idTextAnchor189"/>Animation curves and the Graph Editor</h2>
<p>Like most <a id="_idIndexMarker514"/>animation software, Blender generates a transition between two animated values by inbetweening two or more keyframes. A keyframe contains two elements – a moment in time and the value of a property at <span class="No-Break">that moment.</span></p>
<p>These changes <a id="_idIndexMarker515"/>in value over time are represented in the <strong class="bold">Graph Editor</strong> area, a coordinate system where the horizontal axis is the frame number and the vertical axis is the animated value at <span class="No-Break">each frame:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer147">
<img alt="Figure 7.14: Values over time as animation curves in the Graph Editor" height="468" src="image/Figure_7.14_B18375.jpg" width="1134"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.14: Values over time as animation curves in the Graph Editor</p>
<p>A keyframe created at frame <strong class="source-inline">1</strong> that sets a property to <strong class="source-inline">0</strong> is displayed as a dot with coordinates of <strong class="source-inline">(</strong><span class="No-Break"><strong class="source-inline">1, 0)</strong></span><span class="No-Break">.</span></p>
<p>Blender interpolates the transition between one keyframe and another. The transition between a keyframe <a id="_idIndexMarker516"/>and its neighbors is an <strong class="bold">F-Curve</strong> – that is, a continuous graph that connects two <span class="No-Break">keyframes smoothly.</span></p>
<p class="callout-heading">Say his F-name!</p>
<p class="callout">F-curves are named after James Ferguson, a researcher at The Boeing Company who, in 1964, published a paper named <em class="italic">Multivariable Curve Interpolation</em>. His interpolation formulas have fueled the advancements in modern <span class="No-Break">computer graphics.</span></p>
<p>This way, every <em class="italic">animation curve</em>, or <em class="italic">F-Curve</em>, contains both the keyframes set by the animator and the transition generated by Blender, acting both as storage for the animation data and the interpolator that fills the parts where they <span class="No-Break">are missing.</span></p>
<p>Interpolations can make use of straight lines connecting the points, or curve lines with tangent <a id="_idIndexMarker517"/>handles – that is, <span class="No-Break"><strong class="bold">Bezier</strong></span><span class="No-Break"> curves.</span></p>
<p>Setting a <strong class="bold">Location</strong> keyframe creates curves for the <strong class="bold">X</strong>, <strong class="bold">Y</strong>, and <span class="No-Break"><strong class="bold">Z</strong></span><span class="No-Break"> channels.</span></p>
<p>Animation curves <a id="_idIndexMarker518"/>are displayed in the <strong class="bold">Graph Editor</strong> area. We can select <strong class="bold">Graph Editor</strong> from the drop-down list on the left of any <span class="No-Break">area header:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer148">
<img alt="Figure 7.15: Selecting the Graph Editor as the content of a Blender area" height="393" src="image/Figure_7.15_B18375.jpg" width="1130"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.15: Selecting the Graph Editor as the content of a Blender area</p>
<p>The f-curves of an animation are stored in <strong class="bold">actions</strong>, which are the top containers in the <span class="No-Break">animation data.</span></p>
<p>The structure of the animation data can be summed up as <strong class="bold">Action</strong> | <strong class="bold">F-Curves</strong> | <span class="No-Break"><strong class="bold">Keyframes</strong></span><span class="No-Break">.</span></p>
<p>Traversing this hierarchy is done differently via Python, where we can retrieve the animation values in <span class="No-Break">our scripts.</span></p>
<h1 id="_idParaDest-185"><a id="_idTextAnchor190"/>Accessing animation data in Python</h1>
<p>Let’s switch <a id="_idIndexMarker519"/>to the <strong class="bold">Scripting Workspace</strong> area to <a id="_idIndexMarker520"/>familiarize ourselves with the animation <span class="No-Break">system API.</span></p>
<h2 id="_idParaDest-186"><a id="_idTextAnchor191"/>Adding keyframes in Python</h2>
<p>The Python <a id="_idIndexMarker521"/>class of every animatable object provides a method <a id="_idIndexMarker522"/>that we can use to insert keyframes, named <strong class="source-inline">keyframe_insert</strong>. It is very similar to the <strong class="bold">Insert Keyframe</strong> menu and requires a <strong class="source-inline">data_path</strong> string for specifying which property to animate. Optional parameters such as <strong class="source-inline">index</strong> and <strong class="source-inline">frame</strong> allow us to specify one of the channels of an aggregate property or a frame different from the <span class="No-Break">current one:</span></p>
<pre class="source-code">
keyframe_insert(data_path,
                index=- 1,
                frame=bpy.context.scene.frame_current,
[…]
Returns
        Success of keyframe insertion.</pre>
<p>The following <a id="_idIndexMarker523"/>lines set a keyframe for the active object’s <a id="_idIndexMarker524"/>location to <strong class="source-inline">10.0, 10.0, 10.0</strong> at <span class="No-Break">frame </span><span class="No-Break"><strong class="source-inline">1</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
&gt;&gt;&gt; import bpy
&gt;&gt;&gt; bpy.context.object.<strong class="source-inline">location</strong> = 10.0, 10.0, 10.0
&gt;&gt;&gt; bpy.context.object.<strong class="source-inline">keyframe_insert</strong>(<strong class="source-inline">'location'</strong>, <strong class="source-inline">frame=1</strong>)
True</pre>
<p>Animation requires a value to change over time, so just one keyframe is not enough. We will set another value for <span class="No-Break">frame 24:</span></p>
<pre class="source-code">
&gt;&gt;&gt; bpy.context.object.location = <strong class="source-inline">-10.0</strong>, <strong class="source-inline">-10.0</strong>, <strong class="source-inline">-10.0</strong>
&gt;&gt;&gt; bpy.context.object.keyframe_insert('location',frame=<strong class="source-inline">24</strong>)
True</pre>
<p>We have only set a keyframe at the start and one at the end of our animation, but by default, Blender generates a transition between two neighbor keyframes so that the object will move a little bit at each of the frames between 1 <span class="No-Break">and 24.</span></p>
<p>Our object starts at the <strong class="source-inline">10.0, 10.0, 10.0</strong> coordinates of the <strong class="bold">x</strong>, <strong class="bold">y</strong>, and <strong class="bold">z</strong> space and transitions smoothly toward <strong class="source-inline">-10.0, -</strong><span class="No-Break"><strong class="source-inline">10.0, -10.0</strong></span><span class="No-Break">.</span></p>
<p>Geometrically speaking, these coordinates mark the front top-right corner and bottom-left corner of a cube, implying that the motion happened along the diagonal of the <span class="No-Break">three-dimensional space.</span></p>
<h2 id="_idParaDest-187"><a id="_idTextAnchor192"/>Retrieving keyframes in Python</h2>
<p>If the <a id="_idIndexMarker525"/>active object has keyframes, we can traverse <span class="No-Break">its </span><span class="No-Break"><strong class="source-inline">animation_data</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
&gt;&gt;&gt; bpy.context.object.<strong class="source-inline">animation_data</strong>
bpy.data.objects['Cube']...AnimData</pre>
<p>Since <strong class="source-inline">animation_data</strong> contains the current action, all its f-curves, and keyframes, we are <a id="_idIndexMarker526"/>going to use this container a lot. It can be convenient to store it as a variable as this way, we can avoid long lines of code while we gather the data. Here’s how we get the <span class="No-Break">current </span><span class="No-Break"><strong class="source-inline">action</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
&gt;&gt;&gt; <strong class="source-inline">anim_data</strong> = bpy.context.object.animation_data
&gt;&gt;&gt; anim_data.<strong class="source-inline">action</strong>
bpy.data.actions['CubeAction']</pre>
<p>From the action, we can retrieve the list of <span class="No-Break">animation </span><span class="No-Break"><strong class="source-inline">fcurves</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
&gt;&gt;&gt; action = anim_data.action
&gt;&gt;&gt; anim_data.action.<strong class="source-inline">fcurves</strong>
bpy.data.actions['CubeAction'].fcurves</pre>
<p>For each curve, we can get the animated <strong class="source-inline">data_path</strong>. A data path identifies where a property is stored in Blender, but some properties, such as <strong class="source-inline">location</strong>, require an animation curve for each channel – for example, one curve for the <em class="italic">x</em>, one for <em class="italic">y</em>, and one for the <em class="italic">z</em> coordinate. For that reason, f-curves also have the <strong class="source-inline">array_index</strong> attribute, a number that designates the animated channel of an aggregate property. If we animate the three channels of <strong class="source-inline">location</strong> and scroll through the f-curves using Python, we will find three curves with the same path, <strong class="source-inline">'location'</strong>, each with a <span class="No-Break">different index:</span></p>
<pre class="source-code">
&gt;&gt;&gt; fcurves = anim_data.action.fcurves
&gt;&gt;&gt; for fc in fcurves:
...     print(fc.data_path, fc.array_index)
...
location 0
location 1
location 2</pre>
<p>Every <strong class="source-inline">keyframe_point</strong> stores two <a id="_idIndexMarker527"/>coordinates in the <strong class="source-inline">co</strong> attribute. The <a id="_idIndexMarker528"/>first is the frame number, while the second is the value of <span class="No-Break">that frame:</span></p>
<pre class="source-code">
&gt;&gt;&gt; for fc in fcurves:
...     print(fc.data_path, fc.array_index)
...     for kf in fc.keyframe_points:
...        frame, value = kf.co
...        print("\t frame", frame, "value", value)
location 0
    frame 1.0 value 0.0
    frame 24.0 value 0.2
location 1
    frame 1.0 value 0.0
    frame 24.0 value 4.0
location 2
    frame 1.0 value 0.0
    frame 24.0 value 3.0</pre>
<p>While the current, first, and last frames of the scene are stored as integers, <strong class="source-inline">co[0]</strong> is a <strong class="source-inline">float</strong>. This allows us to insert animations between adjacent frames (<span class="No-Break">subframe animation).</span></p>
<p>The curve interpolation mode is stored in the keyframe’s <strong class="source-inline">interpolation</strong> attribute. The most used interpolations are <span class="No-Break">as follows:</span></p>
<ul>
<li><strong class="source-inline">'CONSTANT'</strong>: <span class="No-Break">No interpolation</span></li>
<li><strong class="source-inline">'LINEAR'</strong>: Interpolation using <span class="No-Break">straight lines</span></li>
<li><strong class="source-inline">'BEZIER'</strong>: Interpolation using curves, weighted <span class="No-Break">with </span><span class="No-Break"><em class="italic">handles</em></span></li>
</ul>
<p>Bezier curves, named after the French engineer Pierre Bèzier, are widely used in computer <a id="_idIndexMarker529"/>graphics because of their smooth and controllable <a id="_idIndexMarker530"/>behavior. They are the default interpolation in Blender. The current <strong class="source-inline">interpolation</strong> between a keyframe and its neighbors is stored as an attribute of <span class="No-Break">the keyframe:</span></p>
<pre class="source-code">
&gt;&gt;&gt; kf.interpolation
'BEZIER'</pre>
<p>Points of a Bezier curve have two additional coordinates – a left handle and a right one, both of which affect the interpolated path. To support curve interpolation, Blender keyframes contain two additional coordinates stored as the <strong class="source-inline">handle_left</strong> and <strong class="source-inline">handle_right</strong> attributes. Exactly like the <strong class="source-inline">co</strong> attribute, the curve handles are <span class="No-Break">two-dimensional points:</span></p>
<pre class="source-code">
&gt;&gt;&gt; kf.handle_left
Vector((16.0, 10.0))
&gt;&gt;&gt; kf.handle_right
Vector((31.0, 10.0))</pre>
<p>Blender supports other interpolations. They cover very specific cases and at the time of writing, they are not much used in animation. They are named after the mathematical function used in their computation, and they are described in the API documentation at <a href="https://docs.blender.org/api/3.2/bpy.types.Keyframe.xhtml">https://docs.blender.org/api/3.2/bpy.types.Keyframe.xhtml</a> <span class="No-Break">and </span><span class="No-Break">#bpy.types.Keyframe.interpolation</span><span class="No-Break">:</span></p>
<ul>
<li><strong class="source-inline">QUAD</strong>: <span class="No-Break">Quadratic easing</span></li>
<li><strong class="source-inline">CUBIC</strong>: <span class="No-Break">Cubic easing</span></li>
<li><strong class="source-inline">QUART</strong>: <span class="No-Break">Quartic easing</span></li>
<li><strong class="source-inline">QUINT</strong>: <span class="No-Break">Quintic easing</span></li>
<li><strong class="source-inline">SINE</strong>: Sinusoidal easing (weakest, almost linear but with a <span class="No-Break">slight curvature)</span></li>
<li><strong class="source-inline">EXPO</strong>: Exponential <span class="No-Break">easing (dramatic)</span></li>
<li><strong class="source-inline">CIRC</strong>: Circular easing (strongest and <span class="No-Break">most dynamic)</span></li>
<li><strong class="source-inline">BACK</strong>: Cubic easing with overshoot <span class="No-Break">and settle</span></li>
<li><strong class="source-inline">BOUNCE</strong>: Exponentially decaying parabolic bounce, like when <span class="No-Break">objects collide</span></li>
<li><strong class="source-inline">ELASTIC</strong>: Exponentially decaying sine wave, like an <span class="No-Break">elastic band</span></li>
</ul>
<p>We will <a id="_idIndexMarker531"/>get back to keyframes at the end of this chapter; in the <a id="_idIndexMarker532"/>meantime, we will build a tool that sets the scene playback based on the duration of the <span class="No-Break">current animation.</span></p>
<p>In these examples, our script uses the attributes of existing animations. In the next section, we are going to create animations <span class="No-Break">with Python.</span></p>
<h1 id="_idParaDest-188"><a id="_idTextAnchor193"/>Writing the Vert Runner add-on</h1>
<p>In this section, we will write an add-on that animates the selected objects along the geometry of <a id="_idIndexMarker533"/>the active object. The animation will trace a path that connects the vertices of a mesh, hence the name <span class="No-Break"><em class="italic">Vert Runner</em></span><span class="No-Break">:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer149">
<img alt="Figure 7.16: Animating a toy along the vertices of a path" height="928" src="image/Figure_7.16_B18375.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.16: Animating a toy along the vertices of a path</p>
<p>This can be a basis for procedural walks or patrols, motion effects, or any other case where we have a <span class="No-Break">geometrical path.</span></p>
<p>In this <a id="_idIndexMarker534"/>operator, the selected objects and the active ones are treated differently: the active object is the reference geometry on which the selected objects <span class="No-Break">are moved.</span></p>
<h2 id="_idParaDest-189"><a id="_idTextAnchor194"/>Setting the environment</h2>
<p>Let’s start <a id="_idIndexMarker535"/>by adding a new script to our <span class="No-Break">add-ons directory:</span></p>
<ol>
<li>Select <strong class="source-inline">PythonScriptingBlender/ch7/addons</strong> in <span class="No-Break"><strong class="bold">VS Code</strong></span><span class="No-Break">.</span></li>
<li>Create a new file by clicking on the <strong class="bold">New </strong><span class="No-Break"><strong class="bold">File</strong></span><span class="No-Break"> icon.</span></li>
<li>Name the new <span class="No-Break">file </span><span class="No-Break"><strong class="source-inline">vert_runner.py</strong></span><span class="No-Break">.</span></li>
<li>Open the file by <span class="No-Break">double-clicking it.</span></li>
</ol>
<p>As usual, we will start with the <span class="No-Break">add-on information.</span></p>
<h2 id="_idParaDest-190"><a id="_idTextAnchor195"/>Writing the Vert Runner information</h2>
<p>Our new <a id="_idIndexMarker536"/>operator can be invoked by <a id="_idIndexMarker537"/>selecting <strong class="bold">Object</strong> | <strong class="bold">Animation</strong> | <strong class="bold">Vert Runner</strong> from the menu bar of the <strong class="bold">3D Viewport</strong> area. This will be our <span class="No-Break"><strong class="source-inline">location</strong></span><span class="No-Break"> information:</span></p>
<pre class="source-code">
bl_info = {
    "name": "Vert Runner",
    "author": "John Packt",
    "version": (1, 0),
    "blender": (3, 00, 0),
    "location": <strong class="source-inline">"Object &gt; Animation &gt; Vert Runner"</strong>
    "description": "Run on vertices of the active object",
    "category": "Learning",
}</pre>
<p>We will <a id="_idIndexMarker538"/>proceed with the <span class="No-Break">usual steps:</span></p>
<ol>
<li>Writing <a id="_idIndexMarker539"/><span class="No-Break">the operator</span></li>
<li>Writing the <span class="No-Break">menu entry</span></li>
<li>Registering the classes <span class="No-Break">and interface</span></li>
</ol>
<h2 id="_idParaDest-191"><a id="_idTextAnchor196"/>Writing the Vert Runner operator</h2>
<p>After the <a id="_idIndexMarker540"/><strong class="source-inline">import</strong> section, we must <a id="_idIndexMarker541"/>create the <strong class="source-inline">VertRunner</strong> class and its <span class="No-Break"><strong class="source-inline">bl_*</strong></span><span class="No-Break"> identifiers:</span></p>
<pre class="source-code">
import bpy
class <strong class="source-inline">VertRunner</strong>(bpy.types.Operator):
    """Run over vertices of the active object"""
    bl_idname = "object.vert_runner"
    bl_label = "Vertex Runner"
    bl_description = "Animate along verts of active object"
    bl_options = {'REGISTER', 'UNDO'}</pre>
<p>We set the distance between each keyframe with an <span class="No-Break"><strong class="source-inline">Integer</strong></span><span class="No-Break"> property:</span></p>
<pre class="source-code">
    step: bpy.props.IntProperty(default=12)</pre>
<p>The next step is writing the <strong class="source-inline">poll</strong> and <strong class="source-inline">execute</strong> methods of <span class="No-Break">this operator.</span></p>
<h2 id="_idParaDest-192"><a id="_idTextAnchor197"/>Writing the operator methods</h2>
<p>We will <a id="_idIndexMarker542"/>write the <strong class="source-inline">poll</strong> method based on what is needed to run the <span class="No-Break">desired operations.</span></p>
<h3>Requirements to check in the poll() method</h3>
<p>To animate <a id="_idIndexMarker543"/>the selected objects over the geometry of the active object, we need <span class="No-Break">the following:</span></p>
<ul>
<li>An <span class="No-Break">active object</span></li>
<li><span class="No-Break">Mesh data</span></li>
<li><span class="No-Break">Selected objects</span></li>
</ul>
<p>Using these conditions, to have the <strong class="source-inline">poll()</strong> method return <strong class="source-inline">False</strong>, they translate to <span class="No-Break">the following:</span></p>
<pre class="source-code">
    @classmethod
    def poll(cls, context):
        obj = context.object
        if not<strong class="source-inline"> obj</strong>:
            return False
        if not <strong class="source-inline">obj.type == 'MESH'</strong>:
            return False
        if not <strong class="source-inline">len(context.selected_objects) &gt; 1</strong>:
            return False
        return True</pre>
<p>If none of the <strong class="source-inline">return False</strong> conditions are met, the poll is successful. In that case, the operator can run its <span class="No-Break">execute method.</span></p>
<h3>Writing the execute() method</h3>
<p>Breaking <a id="_idIndexMarker544"/>the operator’s goal into steps, we should do <span class="No-Break">the following:</span></p>
<ol>
<li>Get a list of patrol points; in this case, the vertices of the <span class="No-Break">active object.</span></li>
<li>Scroll through the <span class="No-Break">selected objects.</span></li>
<li>Move them through the patrol points and set <span class="No-Break">the keyframes.</span></li>
</ol>
<p>We will start by storing the active object’s vertices in <span class="No-Break">a </span><span class="No-Break"><strong class="source-inline">list</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
    def execute(self, context):
        verts = list(context.object.data.vertices)</pre>
<p>When <a id="_idIndexMarker545"/>we iterate through the selected objects, we should make sure to skip the active one, which is <span class="No-Break">likely selected:</span></p>
<pre class="source-code">
        for ob in context.selected_objects:
            if <strong class="source-inline">ob == context.active_object</strong>:
                <strong class="source-inline">continue</strong></pre>
<p>Then, we must iterate through the vertices list and set keyframes for each coordinate, starting with the current frame. We must advance the <strong class="source-inline">frame</strong> number at <span class="No-Break">every iteration:</span></p>
<pre class="source-code">
            frame = context.scene.frame_current
            for vert in verts:
                <strong class="source-inline">ob.location</strong> = <strong class="source-inline">vert.co</strong>
                ob.<strong class="source-inline">keyframe_insert</strong>('location', frame=frame)
                frame <strong class="source-inline">+= self.step</strong>
        return {'FINISHED'}</pre>
<p>When the for loop is over, we must return a <strong class="source-inline">'FINISHED'</strong> state and exit the operator. Now that the <strong class="source-inline">VertRunner</strong> class is complete, we can work on its <span class="No-Break">menu entry.</span></p>
<h2 id="_idParaDest-193"><a id="_idTextAnchor198"/>Writing the menu and register functions</h2>
<p>Since menu <a id="_idIndexMarker546"/>elements are displayed in reverse order, we must add a <span class="No-Break"><strong class="source-inline">separator</strong></span><span class="No-Break"> first:</span></p>
<pre class="source-code">
def anim_menu_func(self, context):
    self.layout.<strong class="source-inline">separator</strong>()
    self.layout.<strong class="source-inline">operator</strong>(VertRunner.bl_idname,
                         text=VertRunner.bl_label)</pre>
<p>Now, it’s time to register the operator and menu so that it can run from <span class="No-Break">the interface:</span></p>
<pre class="source-code">
def register():
    bpy.utils.register_class(VertRunner)
    bpy.types.VIEW3D_MT_object_animation.append(
                                            anim_menu_func)
def unregister():
    bpy.types.VIEW3D_MT_object_animation.remove(
                                            anim_menu_func)
    bpy.utils.unregister_class(VertRunner)</pre>
<p>If we <a id="_idIndexMarker547"/>refresh the <strong class="bold">Add-ons</strong> list, we will see <strong class="bold">Vert Runner</strong> in the <strong class="bold">Learning</strong> category. Enabling it adds <strong class="bold">Vert Runner</strong> to the <strong class="bold">Object</strong> | <span class="No-Break"><strong class="bold">Animation</strong></span><span class="No-Break"> menu:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer150">
<img alt="Figure 7.17: Object | Animation | Vert Runner animates the selected objects" height="768" src="image/Figure_7.17_B18375.jpg" width="1366"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.17: Object | Animation | Vert Runner animates the selected objects</p>
<p>Using <strong class="bold">Vert Runner</strong> after selecting at least two objects will animate the selected objects along the vertices of the active object. We can add an option to make the animation cyclic and animate the <span class="No-Break">object rotation.</span></p>
<h2 id="_idParaDest-194"><a id="_idTextAnchor199"/>Creating cyclic animations</h2>
<p>Sometimes, we want the first and last frame of an animation to match so that we can watch it <a id="_idIndexMarker548"/>in loops – for instance, an endless clip of a character running <span class="No-Break">in circles.</span></p>
<p>In our case, an object passes through all the points of a mesh, starting with the first and ending with the last vertex, so the first and last frames of the animation <span class="No-Break">will differ.</span></p>
<p>To create an animation cycle, we need to add the extra step of going back to the first coordinates after we have passed the <span class="No-Break">last vertex.</span></p>
<p>The user must be able to choose whether they want a cyclic animation or not, so we will add an option to our operator. The <strong class="source-inline">loop</strong> attribute is a Boolean property – it can be enabled and disabled when the operator <span class="No-Break">is run:</span></p>
<pre class="source-code">
class VertRunner(bpy.types.Operator):
    """Run over the vertices of the active object"""
    bl_idname = "object.vert_runner"
    bl_label = "Vert Runner"
    bl_description = "Animate along verts of active object"
    bl_options = {'REGISTER', 'UNDO'}
    step: bpy.props.IntProperty(default=12)
    <strong class="source-inline">loop</strong>: bpy.props.<strong class="source-inline">BoolProperty</strong>(default=True)</pre>
<p>The implementation is very easy: adding a copy of its first element at the end of <strong class="source-inline">verts</strong> brings the objects back to their initial position at the end of <span class="No-Break">the animation:</span></p>
<pre class="source-code">
        if self.loop:
            verts.append(verts[0])</pre>
<p>Animating rotations is slightly more complex. With the help of a little math, at each frame, we can orient the object toward its <span class="No-Break">next destination.</span></p>
<h2 id="_idParaDest-195"><a id="_idTextAnchor200"/>Adding rotations</h2>
<p>The math behind rotations can be challenging at first, but since we just want to rotate the objects <a id="_idIndexMarker549"/>around their <em class="italic">Z</em>-axes, we can use <span class="No-Break">basic </span><span class="No-Break"><strong class="bold">trigonometry</strong></span><span class="No-Break">.</span></p>
<p>In trigonometry, angles can <a id="_idIndexMarker550"/>be represented as arcs of a circle of radius 1 and consequently, maximum length equal to two times π. The letter π (spelled pi) is the ratio between a circle and its diameter. Its approximate value <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">3.14</strong></span><span class="No-Break">.</span></p>
<p>Trigonometry is a framework that contains many useful functions regarding the relationships between angles, segments, and rotations. Among them, there is a function that answers the question we are posing – that is, how do we rotate an object so that it faces toward <span class="No-Break">a point?</span></p>
<h3>Representing rotation arcs</h3>
<p>Imagine rotating an object toward a point of known <em class="italic">X</em> and <em class="italic">Y</em> coordinates. If the rotation traces an <a id="_idIndexMarker551"/>arc over an imaginary circle, we can consider the <strong class="source-inline">y</strong> coordinate of our point as the <em class="italic">height</em> of that arc. This dimension <a id="_idIndexMarker552"/>is called the <strong class="bold">sine</strong> of the angle, and it is very useful when comparing angles <span class="No-Break">and lengths.</span></p>
<p>The inverse of <em class="italic">sine</em> is called <strong class="bold">arcsine</strong>. It is of <a id="_idIndexMarker553"/>interest to us because it is the rotation associated with a sine. In other words, if we want to measure an angle and we know its <em class="italic">sine</em>, we can find the rotation using the <span class="No-Break">following expression:</span></p>
<pre class="source-code">
<strong class="source-inline">rotation = arcsin(sine)</strong></pre>
<p>We know the sine, which is the <strong class="source-inline">y</strong> coordinate of the point we want to <span class="No-Break">look at:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer151">
<img alt="Figure 7.18: Trigonometric representation of a look-at rotation" height="853" src="image/Figure_7.18_B18375.jpg" width="853"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.18: Trigonometric representation of a look-at rotation</p>
<p>So, <em class="italic">arcsine</em> is the <a id="_idIndexMarker554"/>trigonometric function we are looking for. It is shortened as <strong class="source-inline">asin</strong> in Python, and to use it, we must import it from the <span class="No-Break"><strong class="source-inline">math</strong></span><span class="No-Break"> module.</span></p>
<h3>Implementing rotation</h3>
<p>In trigonometry, we express <a id="_idIndexMarker555"/>rotations in <strong class="bold">radians</strong> – that is, arc lengths that are multiples of π. Rather <a id="_idIndexMarker556"/>than writing down our approximation of π as <strong class="source-inline">3.14</strong> in our code, we can import the <strong class="source-inline">pi</strong> constant from the <strong class="source-inline">math</strong> module. So, besides <strong class="source-inline">asin</strong>, we need <strong class="source-inline">pi</strong> as well so that our import section looks <span class="No-Break">like this:</span></p>
<pre class="source-code">
import bpy
from math import <strong class="source-inline">asin</strong>
from math import <strong class="source-inline">pi</strong></pre>
<p>We will write the <strong class="source-inline">VertRunner.aim_to_point</strong> method to address object rotations separately. The first step to do that is subtracting the current position from the target coordinates so that we can get <span class="No-Break">a direction:</span></p>
<pre class="source-code">
    def <strong class="source-inline">aim_to_point</strong>(self, <strong class="source-inline">ob</strong>, <strong class="source-inline">point_co</strong>):
        """Orient object to look at coordinates"""
        <strong class="source-inline">direction</strong> = point_co – ob.location</pre>
<p>Then, we must normalize the direction so that the result is not affected <span class="No-Break">by distance:</span></p>
<pre class="source-code">
        direction.<strong class="source-inline">normalize</strong>()</pre>
<p>The look-at <a id="_idIndexMarker557"/>rotation is returned by <strong class="source-inline">asin(direction.y)</strong>, but there is a catch: arcsine always assumes that it must cover the right-hand side of the circle – that is, positive values of <strong class="source-inline">direction.x</strong>. What happens when our direction falls on the <span class="No-Break">other side?</span></p>
<div>
<div class="IMG---Figure" id="_idContainer152">
<img alt="Figure 7.19: Look-at rotation for negative values of x" height="730" src="image/Figure_7.19_B18375.jpg" width="754"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.19: Look-at rotation for negative values of x</p>
<p>In that case, we can get to the other side of the circle by subtracting <strong class="source-inline">pi</strong> from the <strong class="source-inline">asin</strong> result since <strong class="source-inline">pi</strong> measures half of a unitary <span class="No-Break">circumference length:</span></p>
<pre class="source-code">
        arc = asin(direction.y)
        if direction.x &lt; 0:
            arc = pi – arc</pre>
<p>We must also account for the fact that, in Blender, objects at rest look in the opposite direction of the <em class="italic">Y</em>-axis, so we must add a 90 degrees clockwise rotation to <span class="No-Break">the result.</span></p>
<p>In radians, that’s <strong class="source-inline">pi / </strong><span class="No-Break"><strong class="source-inline">2</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
        arc += pi / 2</pre>
<p>At this <a id="_idIndexMarker558"/>point, <strong class="source-inline">arc</strong> contains the rotation we are looking for. We could use it right away, but there is still a problem: there are two ways to interpolate from one rotation <span class="No-Break">to another.</span></p>
<h3>Finding the shortest arc</h3>
<p>Imagine rotating an object from 30° to 330°. The quickest way to do this is via a counterclockwise <a id="_idIndexMarker559"/>rotation that passes through 0° and stops at -30°, which is equivalent to 330°. The longest way is by passing clockwise from 30° to 180° and then, <span class="No-Break">finally, 330°:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer153">
<img alt="Figure 7.20: Short and long arcs of rotation from 30 to 330 degrees" height="618" src="image/Figure_7.20_B18375.jpg" width="654"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.20: Short and long arcs of rotation from 30 to 330 degrees</p>
<p>Both are a valid transition from 30° to 330°, but we might want to prefer the shortest rotation: doing otherwise would cause an object to spin <span class="No-Break">on itself.</span></p>
<p>To find the shortest arc away from the current rotation, we must store three possibilities in a tuple – the target orient, the same value after a complete clockwise rotation, and the same value <span class="No-Break">rotated counterclockwise:</span></p>
<pre class="source-code">
    arcs = (<strong class="source-inline">arc</strong>, arc <strong class="source-inline">+ 2*pi</strong>, arc <strong class="source-inline">- 2*pi</strong>)</pre>
<p>Then, we must store the absolute rotational differences using a list comprehension. From there, we can get the shortest arc <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">min</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
    diffs = [<strong class="source-inline">abs</strong>(ob.rotation_euler.z - <strong class="source-inline">a</strong>) for <strong class="source-inline">a</strong> in <strong class="source-inline">arcs</strong>]
    <strong class="source-inline">shortest</strong> = min(diffs)</pre>
<p>We must <a id="_idIndexMarker560"/>use the arc associated with the minimum difference. Using that as a condition of the <strong class="source-inline">next</strong> statement, we can find it and assign it <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">rotation_euler.z</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
    res = <strong class="source-inline">next</strong>(a for <strong class="source-inline">i</strong>, a in enumerate(arcs)
               if <strong class="source-inline">diffs[i]</strong> == <strong class="source-inline">shortest</strong>)
    ob.rotation_euler.z = res</pre>
<p>We can now animate rotations using the <strong class="source-inline">aim_to_point</strong> method <span class="No-Break">inside </span><span class="No-Break"><strong class="source-inline">execute</strong></span><span class="No-Break">.</span></p>
<h3>Putting everything together</h3>
<p>The final <a id="_idIndexMarker561"/>version of <strong class="source-inline">execute</strong> is only slightly different. It starts in the same way: gathering the list of vertices, adding the first vertex again if we are animating a cycle, and skipping the <span class="No-Break">active object:</span></p>
<pre class="source-code">
  def execute(self, context):
      verts = list(context.object.data.vertices)
      if self.loop:
          verts.append(verts[0])
      for ob in context.selected_objects:
          if ob == context.active_object:
            continue</pre>
<p>Our orient method is based on the current object position, so before we start animating, we must move the object to the end of <span class="No-Break">the path:</span></p>
<pre class="source-code">
      ob.location = context.object.data.vertices[-1].co</pre>
<p>This way, when the animation starts, <strong class="source-inline">aim_to_point</strong> orients the object toward the first vertex. Now, we must insert keyframes for <strong class="source-inline">rotation_euler.z</strong> as well and repeat the process until all the points have been reached. After that, we can finish <span class="No-Break">the execution:</span></p>
<pre class="source-code">
      frame = context.scene.frame_current
      for vert in verts:
          self.<strong class="source-inline">aim_to_point</strong>(ob, vert.co)
          ob.<strong class="source-inline">keyframe_insert('rotation_euler'</strong>,
                             frame=frame, index=2)
          ob.location = vert.co
          ob.keyframe_insert('location', frame=frame)
          frame += self.step
  return {'FINISHED'}</pre>
<p>By enabling <strong class="bold">Vert Runner</strong> in the add-ons list or updating the scripts if it was enabled already, we can <a id="_idIndexMarker562"/>test our add-on on any pair <span class="No-Break">of objects.</span></p>
<h2 id="_idParaDest-196"><a id="_idTextAnchor201"/>Using Vert Runner</h2>
<p>We can use <a id="_idIndexMarker563"/>this operator on every couple of objects. There is a peculiar entry among the solids available in Blender – a stylized head of a <strong class="bold">Monkey</strong> jokingly inserted among more common shapes such as <strong class="bold">Cube</strong>, <strong class="bold">Plane</strong>, <strong class="bold">Sphere</strong>, and so on. The monkey’s head, affectionately named <strong class="bold">Suzanne</strong>, makes rotations easier to visualize because of its obvious front side, so using it to test our add-on is a <span class="No-Break">natural choice:</span></p>
<ol>
<li>Add a monkey head to the scene via <strong class="bold">Add</strong> | <strong class="bold">Mesh</strong> | <strong class="bold">Monkey</strong> from the Viewport <span class="No-Break">menu bar.</span></li>
<li>Add any other mesh to the scene or use the Cube shape from the default scene <span class="No-Break">if present.</span></li>
<li>Keeping <em class="italic">Shift</em> pressed (multiple selection), select the monkey, then select the object to use as an <span class="No-Break">animation guide.</span></li>
<li>From the Viewport menu bar, select <strong class="bold">Object</strong> | <strong class="bold">Animation</strong> | <span class="No-Break"><strong class="bold">Vert Runner</strong></span><span class="No-Break">.</span></li>
<li>Play the animation with <em class="italic">Alt</em> + <em class="italic">A</em> or by clicking the media <span class="No-Break">control button.</span></li>
</ol>
<p>The cube will pass through each vertex of <a id="_idTextAnchor202"/>the active object. Speed and cyclic animation can be toggled in <span class="No-Break">the options.</span></p>
<p>Though relatively simple, this tool can <a id="_idTextAnchor203"/>be expanded and generate motion for vehicles or even <span class="No-Break">articulated characters.</span></p>
<p>Programming for <a id="_idIndexMarker564"/>animation generally comes down to converting an intuitive concept, such as looking toward a direction, into mathematical terms, like we did when extrapolating rotations. Plus, we have investigated the geometry structure and gained access to the <span class="No-Break">vertex coordinates.</span></p>
<p>This brings us to the end of this chapter, where we learned how to affect the animation settings and the animation <span class="No-Break">of objects.</span></p>
<h1 id="_idParaDest-197"><a id="_idTextAnchor204"/>Summary</h1>
<p>In this chapter, we became familiar with object animation, learned how animations are created and stored, and looked at which scene settings are directly related to the animation system. We also learned how animation can be partly automated and approached from a geometric perspective, with a glimpse at the trigonometric representation of <span class="No-Break">rotation angles.</span></p>
<p>Being able to automate part of the animation process is a valuable skill. Sometimes, the math involved might emerge and require solving, but we should not fear that, as math usually comes with a set of ready-to-use solutions for most ordinary <span class="No-Break">use cases.</span></p>
<p>We have just started our journey into generated animation, which will continue in <a href="B18375_08.xhtml#_idTextAnchor206"><span class="No-Break"><em class="italic">Chapter 8</em></span></a>, where we will learn how to enrich animation curves with <span class="No-Break">procedural effects.</span></p>
<h1 id="_idParaDest-198"><a id="_idTextAnchor205"/>Questions</h1>
<ol>
<li>How are animated <span class="No-Break">values stored?</span></li>
<li>Can one animation curve contain the keyframes of an entire <span class="No-Break">Vector property?</span></li>
<li>How are animation <span class="No-Break">curves grouped?</span></li>
<li>The current frame number is 1. Without changing that setting, can we insert a keyframe at frame 4 using the <span class="No-Break">user interface?</span></li>
<li>The current frame number is 1. Without changing that setting, can we insert a keyframe at frame 4 using the <span class="No-Break">Python API?</span></li>
<li>Does a smooth motion require a keyframe on <span class="No-Break">every frame?</span></li>
<li>How are <span class="No-Break">keyframes interpolated?</span></li>
<li>Are there more ways to interpolate <span class="No-Break">two rotations?</span></li>
</ol>
</div>
</div></body></html>