["```py\n    input = list(range(10))\n    for i, _ in enumerate(input):\n        input[i] += 1 \n```", "```py\n    insert bisect\n    collection = [1, 2, 4, 5, 6]\n    bisect.bisect(collection, 3)\n    # Result: 2\n```", "```py\n    def index_bisect(a, x):\n      'Locate the leftmost value exactly equal to x'\n      i = bisect.bisect_left(a, x)\n      if i != len(a) and a[i] == x:\n      return i\n      raise ValueError\n```", "```py\n    hash(\"hello\")\n    # Result: -1182655621190490452\n    # To restrict the number to be a certain range you can\n      use\n    # the modulo (%) operator\n      hash(\"hello\") % 10\n    # Result: 8\n```", "```py\n    def counter_dict(items): \n        counter = {} \n        for item in items: \n            if item not in counter: \n                counter[item] = 1 \n            else: \n                counter[item] += 1 \n        return counter\n```", "```py\n    from collections import defaultdict\n    def counter_defaultdict(items):\n        counter = defaultdict(int)\n        for item in items:\n            counter[item] += 1\n        return counter\n```", "```py\n    from collections import Counter\n    counter = Counter(items)\n```", "```py\n    docs = [\"the cat is under the table\",\n            \"the dog is under the table\",\n            \"cats and dogs smell roses\",\n            \"Carla eats an apple\"]\n```", "```py\n    matches = [doc for doc in docs if \"table\" in doc]\n```", "```py\n    # Building an index\n    index = {}\n    for i, doc in enumerate(docs):\n        # We iterate over each term in the document\n        for word in doc.split():\n            # We build a list containing the indices \n            # where the term appears\n            if word not in index:\n                index[word] = [i]\n            else:\n                index[word].append(i)\n```", "```py\n    results = index[\"table\"]\n    result_documents = [docs[i] for i in results]\n```", "```py\n    # create a list that contains duplicates\n    x = list(range(1000)) + list(range(500))\n    # the set *x_unique* will contain only \n    # the unique elements in x\n    x_unique = set(x)\n```", "```py\n    # Building an index using sets\n    index = {}\n    for i, doc in enumerate(docs):\n        # We iterate over each term in the document\n        for word in doc.split():\n            # We build a set containing the indices \n            # where the term appears\n            if word not in index:\n                index[word] = {i}\n            else:\n                index[word].add(i)\n\n    # Querying the documents containing both \"cat\" and\n        \"table\"\n    index['cat'].intersection(index['table'])\n```", "```py\n    import heapq\n    collection = [10, 3, 3, 4, 5, 6]\n    heapq.heapify(collection)\n```", "```py\n    heapq.heappop(collection)\n    # Returns: 3\n```", "```py\n    heapq.heappush(collection, 1)\n```", "```py\n    from queue import PriorityQueue\n    queue = PriorityQueue()\n    for element in collection:\n        queue.put(element)\n    queue.get()\n    # Returns: 3\n```", "```py\n    queue = PriorityQueue()\n    queue.put((3, \"priority 3\"))\n    queue.put((2, \"priority 2\"))\n    queue.put((1, \"priority 1\"))\n    queue.get()\n    # Returns: (1, \"priority 1\")\n```", "```py\n    from random import choice\n    from string import ascii_uppercase\n    def random_string(length):\n     \"\"\"Produce a random string made of *length* uppercase \\\n        ascii characters\"\"\"\n     return ''.join(choice(ascii_uppercase) for i in \\\n       range(length))\n```", "```py\n    strings = [random_string(32) for i in range(10000)]\n    matches = [s for s in strings if s.startswith('AA')]\n```", "```py\n    %timeit [s for s in strings if s.startswith('AA')]\n    1000 loops, best of 3: 1.76 ms per loop\n```", "```py\n    from patricia import trie\n    strings_dict = {s:0 for s in strings} \n    # A dictionary where all values are 0\n    strings_trie = trie(**strings_dict)\n```", "```py\n    matches = list(strings_trie.iter('AA'))\n```", "```py\n    %timeit list(strings_trie.iter('AA'))\n    10000 loops, best of 3: 60.1 µs per loop\n```", "```py\n    from functools import lru_cache\n    @lru_cache()\n    def sum2(a, b):\n        print(\"Calculating {} + {}\".format(a, b))\n        return a + b\n    print(sum2(1, 2))\n    # Output: \n    # Calculating 1 + 2\n    # 3\n    print(sum2(1, 2))\n    # Output: \n    # 3\n```", "```py\n    @lru_cache(max_size=16)\n    def sum2(a, b):\n        ...\n```", "```py\n    sum2.cache_info()\n    # Output: CacheInfo(hits=0, misses=1, maxsize=128,\n      currsize=1)\n    sum2.cache_clear()\n```", "```py\n    def fibonacci(n):\n        if n < 1:\n            return 1\n        else:\n            return fibonacci(n - 1) + fibonacci(n - 2)\n    # Non-memoized version\n    %timeit fibonacci(20)\n    100 loops, best of 3: 5.57 ms per loop\n```", "```py\n    import timeit\n    setup_code = '''\n    from functools import lru_cache\n    from __main__ import fibonacci\n    fibonacci_memoized = lru_cache(maxsize=None)(fibonacci)'''\n    results = timeit.repeat('fibonacci_memoized(20)',\n                            setup=setup_code,\n                            repeat=1000,\n                            number=1)\n    print(\"Fibonacci took {:.2f} us\".format(min(results)))\n    # Output: Fibonacci took 0.01 us\n```", "```py\n    from joblib import Memory\n    memory = Memory(cachedir='/path/to/cachedir')\n    @memory.cache\n    def sum2(a, b):\n        return a + b\n```", "```py\n    def loop(): \n        res = [] \n        for i in range(100000): \n            res.append(i * i) \n        return sum(res) \n    def comprehension(): \n        return sum([i * i for i in range(100000)]) \n    def generator(): \n        return sum(i * i for i in range(100000)) \n    %timeit loop() \n    100 loops, best of 3: 16.1 ms per loop \n    %timeit comprehension() \n    100 loops, best of 3: 10.1 ms per loop \n    %timeit generator() \n    100 loops, best of 3: 12.4 ms per loop \n```", "```py\n    def loop(): \n        res = {} \n        for i in range(100000): \n            res[i] = i\n        return res\n    def comprehension(): \n        return {i: i for i in range(100000)}\n    %timeit loop() \n    100 loops, best of 3: 13.2 ms per loop \n    %timeit comprehension() \n    100 loops, best of 3: 12.8 ms per loop\n```", "```py\n    def map_comprehension(numbers):\n        a = [n * 2 for n in numbers]\n        b = [n ** 2 for n in a]\n        c = [n ** 0.33 for n in b]\n        return max(c)\n```", "```py\n    def map_normal(numbers):\n        a = map(lambda n: n * 2, numbers)\n        b = map(lambda n: n ** 2, a)\n        c = map(lambda n: n ** 0.33, b)\n        return max(c)\n```", "```py\n    %load_ext memory_profiler\n    numbers = range(1000000)\n    %memit map_comprehension(numbers)\n    peak memory: 166.33 MiB, increment: 102.54 MiB\n    %memit map_normal(numbers)\n    peak memory: 71.04 MiB, increment: 0.00 MiB\n```"]