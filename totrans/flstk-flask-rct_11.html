<html><head></head><body>
<div id="_idContainer097">
<h1 class="chapter-number" id="_idParaDest-199"><a id="_idTextAnchor232"/><span class="koboSpan" id="kobo.1.1">11</span></h1>
<h1 id="_idParaDest-200"><a id="_idTextAnchor233"/><span class="koboSpan" id="kobo.2.1">Fetching and Displaying Data in a React-Flask Application</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In the preceding chapter, you were able to successfully integrate the React frontend into the Flask backend. </span><span class="koboSpan" id="kobo.3.2">This is a significant milestone in the journey of a full stack web developer. </span><span class="koboSpan" id="kobo.3.3">In this chapter, you will build on what you have learned and dive deeper into data fetching in a full stack </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">web application.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">Data fetching is important in a web application because it allows the application to retrieve data from a backend server, API, or database and display that data to a user. </span><span class="koboSpan" id="kobo.5.2">Without the ability to fetch data, a web application would be limited to displaying only hardcoded data, which would not be very useful or dynamic. </span><span class="koboSpan" id="kobo.5.3">By fetching data from a backend server or API, the application can display up-to-date, dynamic data to </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">the user.</span></span></p>
<p><span class="koboSpan" id="kobo.7.1">In addition, data fetching is often used in combination with user interactions and updates to the data, allowing the </span><a id="_idIndexMarker751"/><span class="koboSpan" id="kobo.8.1">application to perform actions such as inserting, updating, or deleting data in a database or API. </span><span class="koboSpan" id="kobo.8.2">This allows the application to be more interactive and responsive to the </span><span class="No-Break"><span class="koboSpan" id="kobo.9.1">user’s actions.</span></span></p>
<p><span class="koboSpan" id="kobo.10.1">In this chapter, you will learn about the intricacies of data fetching and its vital role in web applications, and more importantly, how it concerns integrating the React frontend with the Flask backend. </span><span class="koboSpan" id="kobo.10.2">You will learn about the role of data fetching in enabling web applications to fetch data from a backend server or API, ensuring the display of current and </span><span class="No-Break"><span class="koboSpan" id="kobo.11.1">dynamic information.</span></span></p>
<p><span class="koboSpan" id="kobo.12.1">We will discuss the use of data fetching in combination with user interactions to perform actions such as retrieving, inserting, updating, or deleting data in a database or API. </span><span class="koboSpan" id="kobo.12.2">Lastly, we will discuss how you can manage pagination in </span><span class="No-Break"><span class="koboSpan" id="kobo.13.1">React–Flask applications.</span></span></p>
<p><span class="koboSpan" id="kobo.14.1">By the end of this chapter, you will understand how to add data to a database, display database data, and how pagination is handled in a React–Flask </span><span class="No-Break"><span class="koboSpan" id="kobo.15.1">web application.</span></span></p>
<p><span class="koboSpan" id="kobo.16.1">In this chapter, we’ll be covering the </span><span class="No-Break"><span class="koboSpan" id="kobo.17.1">following topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.18.1">Fetching and displaying data – the </span><span class="No-Break"><span class="koboSpan" id="kobo.19.1">React–Flask approach</span></span></li>
<li><span class="koboSpan" id="kobo.20.1">Adding data to a database – the </span><span class="No-Break"><span class="koboSpan" id="kobo.21.1">React–Flask approach</span></span></li>
<li><span class="koboSpan" id="kobo.22.1">Editing data – the </span><span class="No-Break"><span class="koboSpan" id="kobo.23.1">React–Flask approach</span></span></li>
<li><span class="koboSpan" id="kobo.24.1">Deleting data from a database – the </span><span class="No-Break"><span class="koboSpan" id="kobo.25.1">React–Flask approach</span></span></li>
<li><span class="koboSpan" id="kobo.26.1">Managing pagination in a </span><span class="No-Break"><span class="koboSpan" id="kobo.27.1">React–Flask application</span></span></li>
</ul>
<h1 id="_idParaDest-201"><a id="_idTextAnchor234"/><span class="koboSpan" id="kobo.28.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.29.1">The The complete code for this chapter is available on GitHub </span><span class="No-Break"><span class="koboSpan" id="kobo.30.1">at: </span></span><a href="https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter11"><span class="No-Break"><span class="koboSpan" id="kobo.31.1">https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter11</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.32.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.33.1">Owing to the page-count constraints, some of the code blocks have been snipped. </span><span class="koboSpan" id="kobo.33.2">Please refer to GitHub for the </span><span class="No-Break"><span class="koboSpan" id="kobo.34.1">complete code.</span></span></p>
<h1 id="_idParaDest-202"><a id="_idTextAnchor235"/><span class="koboSpan" id="kobo.35.1">Fetching and displaying data – the React-Flask approach</span></h1>
<p><span class="koboSpan" id="kobo.36.1">In this chapter, first, we will be fetching data on speakers and displaying it to the users of the application. </span><span class="koboSpan" id="kobo.36.2">But </span><a id="_idIndexMarker752"/><span class="koboSpan" id="kobo.37.1">before heading into that, let’s do some </span><a id="_idIndexMarker753"/><span class="koboSpan" id="kobo.38.1">code restructuring. </span><span class="koboSpan" id="kobo.38.2">You will need to </span><a id="_idIndexMarker754"/><span class="koboSpan" id="kobo.39.1">restructure the backend to accommodate the growing </span><strong class="source-inline"><span class="koboSpan" id="kobo.40.1">app.py</span></strong><span class="koboSpan" id="kobo.41.1"> file contents in the </span><a id="_idIndexMarker755"/><span class="koboSpan" id="kobo.42.1">project directory. </span><span class="koboSpan" id="kobo.42.2">Dividing the code into different components improves the overall structure and organization of </span><span class="No-Break"><span class="koboSpan" id="kobo.43.1">the application.</span></span></p>
<p><span class="koboSpan" id="kobo.44.1">Rather than having the entire code in a single module, you can structure your code to separate concerns. </span><span class="koboSpan" id="kobo.44.2">We’ll discuss more on code structuring for larger applications in </span><a href="B18554_14.xhtml#_idTextAnchor285"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.45.1">Chapter 14</span></em></span></a><span class="koboSpan" id="kobo.46.1">, </span><em class="italic"><span class="koboSpan" id="kobo.47.1">Modular Architecture – The Power of Blueprints</span></em><span class="koboSpan" id="kobo.48.1">. </span><span class="koboSpan" id="kobo.48.2">With this code split, developers can easily locate and modify specific parts of the code base without affecting other components. </span><span class="koboSpan" id="kobo.48.3">This modular approach also promotes </span><span class="No-Break"><span class="koboSpan" id="kobo.49.1">code reusability.</span></span></p>
<p><span class="koboSpan" id="kobo.50.1">Now, back to the code, you will add </span><strong class="source-inline"><span class="koboSpan" id="kobo.51.1">models.py</span></strong><span class="koboSpan" id="kobo.52.1"> to the backend project directory (</span><strong class="source-inline"><span class="koboSpan" id="kobo.53.1">bizza/backend/models.py</span></strong><span class="koboSpan" id="kobo.54.1">) to house all the models for database interaction. </span><span class="koboSpan" id="kobo.54.2">This will help us to separate application concerns. </span><span class="koboSpan" id="kobo.54.3">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.55.1">app.py</span></strong><span class="koboSpan" id="kobo.56.1"> file will be used to handle endpoints and their associated logic, while the </span><strong class="source-inline"><span class="koboSpan" id="kobo.57.1">models.py</span></strong><span class="koboSpan" id="kobo.58.1"> file contains the application </span><span class="No-Break"><span class="koboSpan" id="kobo.59.1">data models.</span></span></p>
<p><span class="koboSpan" id="kobo.60.1">The restructured </span><strong class="source-inline"><span class="koboSpan" id="kobo.61.1">app.py</span></strong><span class="koboSpan" id="kobo.62.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.63.1">models.py</span></strong><span class="koboSpan" id="kobo.64.1"> files can be found on GitHub </span><span class="No-Break"><span class="koboSpan" id="kobo.65.1">at </span></span><a href="https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter11"><span class="No-Break"><span class="koboSpan" id="kobo.66.1">https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter11</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.67.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.68.1">Essentially, we will simulate an admin page for our </span><em class="italic"><span class="koboSpan" id="kobo.69.1">Bizza</span></em><span class="koboSpan" id="kobo.70.1"> application so that we can create, display, and edit speaker data, and manage pagination via the admin page. </span><span class="koboSpan" id="kobo.70.2">At this point, we are setting up an admin page for demonstration purposes only; we are not going to bother ourselves with data validation, authentication, and </span><span class="No-Break"><span class="koboSpan" id="kobo.71.1">authorization implementations.</span></span></p>
<p><span class="koboSpan" id="kobo.72.1">In this section, the focus will be to learn how to retrieve data from the backend and display it in the React frontend. </span><span class="koboSpan" id="kobo.72.2">Being able to display data from a database is important because it allows </span><a id="_idIndexMarker756"/><span class="koboSpan" id="kobo.73.1">you to present the data to users in a visual and </span><a id="_idIndexMarker757"/><span class="koboSpan" id="kobo.74.1">interactive way. </span><span class="koboSpan" id="kobo.74.2">By displaying data in a </span><a id="_idIndexMarker758"/><span class="koboSpan" id="kobo.75.1">web application, you can create a user-friendly interface that allows </span><a id="_idIndexMarker759"/><span class="koboSpan" id="kobo.76.1">users to view, search, filter, and manipulate the data </span><span class="No-Break"><span class="koboSpan" id="kobo.77.1">as needed.</span></span></p>
<p><span class="koboSpan" id="kobo.78.1">You need to fetch and display data in order to create a functional and useful web application that makes use of data stored in a database. </span><span class="koboSpan" id="kobo.78.2">To retrieve data from the backend, we will use Axios for making network requests. </span><span class="koboSpan" id="kobo.78.3">You can use Axios to make a </span><strong class="source-inline"><span class="koboSpan" id="kobo.79.1">GET</span></strong><span class="koboSpan" id="kobo.80.1"> request to the backend server and retrieve the data </span><span class="No-Break"><span class="koboSpan" id="kobo.81.1">you need.</span></span></p>
<p><span class="koboSpan" id="kobo.82.1">Let’s delve into how we can retrieve a list of speakers and their details from the backend and display it in the admin page of our </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.83.1">Bizza</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.84.1"> application.</span></span></p>
<h2 id="_idParaDest-203"><a id="_idTextAnchor236"/><span class="koboSpan" id="kobo.85.1">Retrieving the speakers’ list from Flask</span></h2>
<p><span class="koboSpan" id="kobo.86.1">The Flask backend</span><a id="_idIndexMarker760"/><span class="koboSpan" id="kobo.87.1"> will manage the list of speakers and their details with a simple API. </span><span class="koboSpan" id="kobo.87.2">In </span><strong class="source-inline"><span class="koboSpan" id="kobo.88.1">models.py</span></strong><span class="koboSpan" id="kobo.89.1">, add the following code to create the </span><strong class="source-inline"><span class="koboSpan" id="kobo.90.1">Speaker</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.91.1">model class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.92.1">from datetime import datetimeclass Speaker(db.Model):
    __tablename__ = 'speakers'
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(100), nullable=False)
    email = db.Column(db.String(100), nullable=False)
    company = db.Column(db.String(100), nullable=False)
    position = db.Column(db.String(100), nullable=False)
    bio = db.Column(db.String(200), nullable=False)
    speaker_avatar = db.Column(db.String(100),
        nullable=True)
    created_at = db.Column(db.DateTime,
        default=datetime.utcnow)
    updated_at = db.Column(db.DateTime,
        default=datetime.utcnow, onupdate=datetime.utcnow)
    def __repr__(self):
        return f'&lt;Speaker {self.name}&gt;'
    def serialize(self):
        return {
            'id': self.id,
            'name': self.name,
            'email': self.email,
            'company': self.company,
            'position': self.position,
            'bio': self.bio,
            'speaker_avatar': self.speaker_avatar,
            'created_at': self.created_at.isoformat(),
            'updated_at': self.updated_at.isoformat()
        }</span></pre>
<p><span class="koboSpan" id="kobo.93.1">The preceding code defines a </span><strong class="source-inline"><span class="koboSpan" id="kobo.94.1">Speaker</span></strong><span class="koboSpan" id="kobo.95.1"> model and has the </span><strong class="source-inline"><span class="koboSpan" id="kobo.96.1">__repr__()</span></strong><span class="koboSpan" id="kobo.97.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.98.1">serialize()</span></strong><span class="koboSpan" id="kobo.99.1"> methods. </span><span class="koboSpan" id="kobo.99.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.100.1">__repr__</span></strong><span class="koboSpan" id="kobo.101.1"> method is a built-in method in Python that is used to create a string representation of an object. </span><span class="koboSpan" id="kobo.101.2">In this case, it is used to create a string representation of a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.102.1">Speaker</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.103.1"> object.</span></span></p>
<p><span class="koboSpan" id="kobo.104.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.105.1">serialize()</span></strong><span class="koboSpan" id="kobo.106.1"> method is used to convert the </span><strong class="source-inline"><span class="koboSpan" id="kobo.107.1">Speaker</span></strong><span class="koboSpan" id="kobo.108.1"> object into a dictionary format that can be easily </span><a id="_idIndexMarker761"/><span class="koboSpan" id="kobo.109.1">converted into JSON. </span><span class="koboSpan" id="kobo.109.2">This is useful when you need to return the </span><strong class="source-inline"><span class="koboSpan" id="kobo.110.1">Speaker</span></strong><span class="koboSpan" id="kobo.111.1"> object as a response to an </span><span class="No-Break"><span class="koboSpan" id="kobo.112.1">API endpoint.</span></span></p>
<p><span class="koboSpan" id="kobo.113.1">The method returns a dictionary containing all the properties of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.114.1">Speaker</span></strong><span class="koboSpan" id="kobo.115.1"> object such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.116.1">id</span></strong><span class="koboSpan" id="kobo.117.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.118.1">name</span></strong><span class="koboSpan" id="kobo.119.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.120.1">email</span></strong><span class="koboSpan" id="kobo.121.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.122.1">company</span></strong><span class="koboSpan" id="kobo.123.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.124.1">position</span></strong><span class="koboSpan" id="kobo.125.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.126.1">bio</span></strong><span class="koboSpan" id="kobo.127.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.128.1">speaker_avatar</span></strong><span class="koboSpan" id="kobo.129.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.130.1">created_at</span></strong><span class="koboSpan" id="kobo.131.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.132.1">updated_at</span></strong><span class="koboSpan" id="kobo.133.1">. </span><span class="koboSpan" id="kobo.133.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.134.1">created_at</span></strong><span class="koboSpan" id="kobo.135.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.136.1">updated_at</span></strong><span class="koboSpan" id="kobo.137.1"> properties are converted into string format using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.138.1">isoformat()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.139.1"> method.</span></span></p>
<p><span class="koboSpan" id="kobo.140.1">Now, let’s create the endpoint to handle the logic for displaying the </span><span class="No-Break"><span class="koboSpan" id="kobo.141.1">speakers’ data:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.142.1">@app.route('/api/v1/speakers', methods=['GET'])def get_speakers():
    speakers = Speaker.query.all()
    if not speakers:
        return jsonify({"error": "No speakers found"}), 404
    return jsonify([speaker.serialize() for speaker in
        speakers]), 200</span></pre>
<p><span class="koboSpan" id="kobo.143.1">The preceding code retrieves the list of speakers from the database with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.144.1">get_speakers()</span></strong><span class="koboSpan" id="kobo.145.1"> function. </span><span class="koboSpan" id="kobo.145.2">Now, you need to update the React frontend directory to consume the API speakers </span><span class="No-Break"><span class="koboSpan" id="kobo.146.1">list endpoint.</span></span></p>
<h2 id="_idParaDest-204"><a id="_idTextAnchor237"/><span class="koboSpan" id="kobo.147.1">Displaying data in React</span></h2>
<p><span class="koboSpan" id="kobo.148.1">In the React frontend, you </span><a id="_idIndexMarker762"/><span class="koboSpan" id="kobo.149.1">need to create a route that renders a component </span><a id="_idIndexMarker763"/><span class="koboSpan" id="kobo.150.1">at the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.151.1">http://127.0.0.1:3000/admin</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.152.1"> path.</span></span></p>
<p><span class="koboSpan" id="kobo.153.1">The following snippet will create the routing system for </span><span class="No-Break"><span class="koboSpan" id="kobo.154.1">the admin:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.155.1">const router = createBrowserRouter([  {
    path: "/admin",
    element: &lt;AdminPage/&gt;,
    children: [
      {
        path: "/admin/dashboard",
        element: &lt;Dashboard /&gt;,
      },
      {
        path: "/admin/speakers",
        element: &lt;Speakers /&gt;,
      },
      {
        path: "/admin/venues",
        element: &lt;Venues /&gt;,
      },
      {
        path: "/admin/events",
        element: &lt;Events /&gt;,
      },
      {
        path: "/admin/schedules",
        element: &lt;Schedules /&gt;,
      },
      {
        path: "/admin/sponsors",
        element: &lt;Sponsors /&gt;,
      },
    ],
  },
]);</span></pre>
<p><span class="koboSpan" id="kobo.156.1">Let’s now create </span><strong class="source-inline"><span class="koboSpan" id="kobo.157.1">AdminPage</span></strong><span class="koboSpan" id="kobo.158.1"> in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.159.1">/src/pages/Admin/AdminPage/AdminPage.jsx</span></strong><span class="koboSpan" id="kobo.160.1"> file. </span><strong class="source-inline"><span class="koboSpan" id="kobo.161.1">AdminPage</span></strong><span class="koboSpan" id="kobo.162.1"> will serve as an index </span><a id="_idIndexMarker764"/><span class="koboSpan" id="kobo.163.1">component page for the admin and render necessary </span><a id="_idIndexMarker765"/><span class="koboSpan" id="kobo.164.1">components, including the CRUD operations </span><span class="No-Break"><span class="koboSpan" id="kobo.165.1">for speakers.</span></span></p>
<p><span class="koboSpan" id="kobo.166.1">Add the following code </span><span class="No-Break"><span class="koboSpan" id="kobo.167.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.168.1">AdminPage.jsx</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.169.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.170.1">import React from "react";import { Outlet } from "react-router-dom";
import Sidebar from
    "../../../components/admin/Sidebar/Sidebar";
import './AdminPage.css'
const AdminPage = () =&gt; {
    return (
        &lt;div className="container"&gt;
            &lt;div&gt;&lt;Navbar/&gt;&lt;/div&gt;
            &lt;div&gt;&lt;Outlet /&gt;&lt;/div&gt;
        &lt;/div&gt;
    );
};
export default AdminPage;</span></pre>
<p><span class="koboSpan" id="kobo.171.1">The preceding code shows the </span><strong class="source-inline"><span class="koboSpan" id="kobo.172.1">AdminPage</span></strong><span class="koboSpan" id="kobo.173.1"> component, which represents the structure and content of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.174.1">admin</span></strong><span class="koboSpan" id="kobo.175.1"> page. </span><span class="koboSpan" id="kobo.175.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.176.1">Sidebar</span></strong><span class="koboSpan" id="kobo.177.1"> component is imported and rendered as a child component </span><a id="_idIndexMarker766"/><span class="koboSpan" id="kobo.178.1">to render a list of sidebar menus for the admin. </span><span class="koboSpan" id="kobo.178.2">Then, we have </span><a id="_idIndexMarker767"/><span class="koboSpan" id="kobo.179.1">the </span><strong class="source-inline"><span class="koboSpan" id="kobo.180.1">Outlet</span></strong><span class="koboSpan" id="kobo.181.1"> component imported from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.182.1">react-router-dom</span></strong><span class="koboSpan" id="kobo.183.1"> package, which is used to render the content specific to the </span><span class="No-Break"><span class="koboSpan" id="kobo.184.1">current route.</span></span></p>
<p><span class="koboSpan" id="kobo.185.1">Next, we will create a data-fetching component for viewing the list of speakers in </span><span class="No-Break"><span class="koboSpan" id="kobo.186.1">the database.</span></span></p>
<h3><span class="koboSpan" id="kobo.187.1">Displaying the speakers list with the ViewSpeakers component</span></h3>
<p><span class="koboSpan" id="kobo.188.1">We will start </span><a id="_idIndexMarker768"/><span class="koboSpan" id="kobo.189.1">the CRUD operations </span><a id="_idIndexMarker769"/><span class="koboSpan" id="kobo.190.1">on speakers with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.191.1">ViewSpeakers</span></strong><span class="koboSpan" id="kobo.192.1"> component that will handle the display of the speakers’ data from the backend to the </span><span class="No-Break"><span class="koboSpan" id="kobo.193.1">admin users.</span></span></p>
<p><span class="koboSpan" id="kobo.194.1">First, we will create a module named </span><strong class="source-inline"><span class="koboSpan" id="kobo.195.1">SpeakersAPI.js</span></strong><span class="koboSpan" id="kobo.196.1"> to handle all the API calls. </span><span class="koboSpan" id="kobo.196.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.197.1">SpeakersAPI.js</span></strong><span class="koboSpan" id="kobo.198.1"> module encapsulates the API calls, abstracting away the low-level details of making HTTP requests. </span><span class="koboSpan" id="kobo.198.2">This will also allow other parts of the application to interact with the API in a more straightforward manner, without having to deal with the intricacies of the Axios library directly. </span><span class="koboSpan" id="kobo.198.3">Overall, you tend to benefit from having this separate module handle the API calls as it promotes code organization, reusability, error handling, header management, and the scalability and maintainability of the </span><span class="No-Break"><span class="koboSpan" id="kobo.199.1">code base.</span></span></p>
<p><span class="koboSpan" id="kobo.200.1">Let’s now dig into the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.201.1">SpeakersAPI</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.202.1"> module.</span></span></p>
<p><span class="koboSpan" id="kobo.203.1">Inside </span><a id="_idIndexMarker770"/><span class="koboSpan" id="kobo.204.1">the </span><strong class="source-inline"><span class="koboSpan" id="kobo.205.1">bizza/frontend/src</span></strong><span class="koboSpan" id="kobo.206.1"> project </span><a id="_idIndexMarker771"/><span class="koboSpan" id="kobo.207.1">directory, create </span><strong class="source-inline"><span class="koboSpan" id="kobo.208.1">SpeakersAPI.js</span></strong><span class="koboSpan" id="kobo.209.1"> and add the </span><span class="No-Break"><span class="koboSpan" id="kobo.210.1">following snippet:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.211.1">import axios from 'axios';const API_URL = 'http://localhost:5000/api/v1';
// Function to handle errors
const handleErrors = (error) =&gt; {
    if (error.response) {
    // The request was made and the server responded with a
       status code
    console.error('API Error:', error.response.status,
        error.response.data);
    } else if (error.request) {
    // The request was made but no response was received
    console.error('API Error: No response received',
        error.request);
    } else {
    // Something else happened while making the request
    console.error('API Error:', error.message);
    }
    throw error;
};
// Function to set headers with Content-Type:
   application/json
const setHeaders = () =&gt; {
    axios.defaults.headers.common['Content-Type'] =
        'application/json';
};
// Function to get speakers
export const getSpeakers = async () =&gt; {
    try {
        setHeaders();
        const response =
            await axios.get(`${API_URL}/speakers`);
        return response.data;
    } catch (error) {
        handleErrors(error);
    }
};</span></pre>
<p><span class="koboSpan" id="kobo.212.1">The preceding</span><a id="_idIndexMarker772"/><span class="koboSpan" id="kobo.213.1"> code sets up </span><a id="_idIndexMarker773"/><span class="koboSpan" id="kobo.214.1">a basic configuration for making HTTP requests to an API using Axios and provides a function to retrieve speakers from the API. </span><span class="koboSpan" id="kobo.214.2">It handles errors and sets the necessary headers for </span><span class="No-Break"><span class="koboSpan" id="kobo.215.1">the requests.</span></span></p>
<p><span class="koboSpan" id="kobo.216.1">Next, we will define the </span><strong class="source-inline"><span class="koboSpan" id="kobo.217.1">ViewSpeakers</span></strong><span class="koboSpan" id="kobo.218.1"> component and make use of the preceding </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.219.1">SpeakersAPI</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.220.1"> module.</span></span></p>
<p><span class="koboSpan" id="kobo.221.1">Inside </span><strong class="source-inline"><span class="koboSpan" id="kobo.222.1">src/pages/Admin/Speakers/</span></strong><span class="koboSpan" id="kobo.223.1">, create the </span><strong class="source-inline"><span class="koboSpan" id="kobo.224.1">ViewSpeakers.js</span></strong><span class="koboSpan" id="kobo.225.1"> component and add the </span><span class="No-Break"><span class="koboSpan" id="kobo.226.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.227.1">import React, { useEffect, useState } from 'react';import { getSpeakers } from
    '../../../services/SpeakersAPI';
const ViewSpeakers = () =&gt; {
    const [speakers, setSpeakers] = useState([]);
    const [isLoading, setIsLoading] = useState(true);
    const [error, setError] = useState(null);
    const fetchSpeakers = async () =&gt; {
        try {
            const speakerData = await getSpeakers();
            setSpeakers(speakerData);
            setIsLoading(false);
        } catch (error) {
            setError(error.message);
            setIsLoading(false);
        }
    };
    useEffect(() =&gt; {
        fetchSpeakers();
    }, []);</span></pre>
<p><span class="koboSpan" id="kobo.228.1">The preceding code sets up a React component called </span><strong class="source-inline"><span class="koboSpan" id="kobo.229.1">ViewSpeakers</span></strong><span class="koboSpan" id="kobo.230.1"> that fetches speaker data </span><a id="_idIndexMarker774"/><span class="koboSpan" id="kobo.231.1">using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.232.1">getSpeakers</span></strong><span class="koboSpan" id="kobo.233.1"> function and updates the component’s state accordingly. </span><span class="koboSpan" id="kobo.233.2">It handles loading and </span><a id="_idIndexMarker775"/><span class="koboSpan" id="kobo.234.1">error states and triggers the data-fetching process when the component is mounted. </span><span class="koboSpan" id="kobo.234.2">The full code for </span><strong class="source-inline"><span class="koboSpan" id="kobo.235.1">ViewSpeakers.js</span></strong><span class="koboSpan" id="kobo.236.1"> can be found in the </span><span class="No-Break"><span class="koboSpan" id="kobo.237.1">GitHub repository.</span></span></p>
<p><span class="koboSpan" id="kobo.238.1">Next, we will explore how we can add data to the database using the </span><span class="No-Break"><span class="koboSpan" id="kobo.239.1">Flask–React approach.</span></span></p>
<h1 id="_idParaDest-205"><a id="_idTextAnchor238"/><span class="koboSpan" id="kobo.240.1">Adding data to a database – the React–Flask approach</span></h1>
<p><span class="koboSpan" id="kobo.241.1">We add data to a database to store and organize information that can be easily accessed, managed, </span><a id="_idIndexMarker776"/><span class="koboSpan" id="kobo.242.1">and updated. </span><span class="koboSpan" id="kobo.242.2">It is one of the ways to persistently </span><a id="_idIndexMarker777"/><span class="koboSpan" id="kobo.243.1">store data, and knowing how to do it is a key requirement for any full stack developer. </span><span class="koboSpan" id="kobo.243.2">This knowledge allows you to build dynamic and interactive web applications. </span><span class="koboSpan" id="kobo.243.3">You then have the means to efficiently retrieve and use the data for various purposes, such as reporting, analysis, and </span><span class="No-Break"><span class="koboSpan" id="kobo.244.1">decision making.</span></span></p>
<h2 id="_idParaDest-206"><a id="_idTextAnchor239"/><span class="koboSpan" id="kobo.245.1">Adding data to Flask</span></h2>
<p><span class="koboSpan" id="kobo.246.1">Now, let’s create </span><a id="_idIndexMarker778"/><span class="koboSpan" id="kobo.247.1">an endpoint to handle the logic for adding spe</span><a id="_idTextAnchor240"/><span class="koboSpan" id="kobo.248.1">aker </span><a id="_idIndexMarker779"/><span class="koboSpan" id="kobo.249.1">data to </span><span class="No-Break"><span class="koboSpan" id="kobo.250.1">the database:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.251.1">    @app.route('/api/v1/speakers', methods=['POST'])    def add_speaker():
        data = request.get_json()
        name = data.get('name')
        email = data.get('email')
        company = data.get('company')
        position = data.get('position')
        bio = data.get('bio')
        avatar = request.files.get('speaker_avatar')
        # Save the uploaded avatar
        if avatar and allowed_file(avatar.filename):
            filename = secure_filename(avatar.filename)
            avatar.save(os.path.join(app.config[
                'UPLOAD_FOLDER'], filename))
        else:
            filename = 'default-avatar.jpg'
        if not name or not email or not company or not
            position or not bio:
            return jsonify({"error": "All fields are
                required"}), 400
        existing_speaker =
            Speaker.query.filter_by(email=email).first()
        if existing_speaker:
            return jsonify({"error": "Speaker with that
                email already exists"}), 409
        speaker = Speaker(name=name, email=email,
            company=company, position=position, bio=bio,
                speaker_avatar=avatar)
        db.session.add(speaker)
        db.session.commit()
        return jsonify(speaker.serialize()), 201
  # Function to check if the file extension is allowed
    def allowed_file(filename):
        </span><a id="_idTextAnchor241"/><span class="koboSpan" id="kobo.252.1">return '.' </span><span class="koboSpan" id="kobo.252.2">in filename and \
            filen</span><a id="_idTextAnchor242"/><span class="koboSpan" id="kobo.253.1">ame.rsplit('.', 1)[1].lower(
            ) in app.config['ALLOWED_EXTENSIONS']</span></pre>
<p><span class="koboSpan" id="kobo.254.1">The preceding </span><a id="_idIndexMarker780"/><span class="koboSpan" id="kobo.255.1">code defines a </span><strong class="source-inline"><span class="koboSpan" id="kobo.256.1">/api/v1/speakers</span></strong><span class="koboSpan" id="kobo.257.1"> route that defines an API </span><a id="_idIndexMarker781"/><span class="koboSpan" id="kobo.258.1">route that handles a </span><strong class="source-inline"><span class="koboSpan" id="kobo.259.1">POST</span></strong><span class="koboSpan" id="kobo.260.1"> request to add a new speaker. </span><span class="koboSpan" id="kobo.260.2">It extracts the required speaker information from the request, validates the data, saves the avatar file if provided, checks for duplicate emails, creates a new speaker object, adds it to the database, and returns a response with the created </span><span class="No-Break"><span class="koboSpan" id="kobo.261.1">speaker’s data.</span></span></p>
<p><span class="koboSpan" id="kobo.262.1">The preceding code shows the </span><strong class="source-inline"><span class="koboSpan" id="kobo.263.1">add_speaker</span></strong><span class="koboSpan" id="kobo.264.1"> function that is executed when a </span><strong class="source-inline"><span class="koboSpan" id="kobo.265.1">POST</span></strong><span class="koboSpan" id="kobo.266.1"> request is made to the </span><span class="No-Break"><span class="koboSpan" id="kobo.267.1">specified route.</span></span></p>
<p><span class="koboSpan" id="kobo.268.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.269.1">add_speaker</span></strong><span class="koboSpan" id="kobo.270.1"> function retrieves the JSON data from the request using </span><strong class="source-inline"><span class="koboSpan" id="kobo.271.1">request.get_json()</span></strong><span class="koboSpan" id="kobo.272.1"> and extracts the </span><a id="_idIndexMarker782"/><span class="koboSpan" id="kobo.273.1">speaker’s name, email, company, position, bio, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.274.1">speaker_avatar</span></strong><span class="koboSpan" id="kobo.275.1"> (an uploaded file) from </span><span class="No-Break"><span class="koboSpan" id="kobo.276.1">the data.</span></span></p>
<p><span class="koboSpan" id="kobo.277.1">If a </span><strong class="source-inline"><span class="koboSpan" id="kobo.278.1">speaker_avatar</span></strong><span class="koboSpan" id="kobo.279.1"> is provided and the file extension is allowed (after being checked by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.280.1">allowed_file</span></strong><span class="koboSpan" id="kobo.281.1"> function), the avatar file is saved to the server’s upload folder with a secure filename. </span><span class="koboSpan" id="kobo.281.2">Otherwise, a default avatar filename </span><span class="No-Break"><span class="koboSpan" id="kobo.282.1">is assigned.</span></span></p>
<p><span class="koboSpan" id="kobo.283.1">The function then checks whether all the required fields (</span><strong class="source-inline"><span class="koboSpan" id="kobo.284.1">name</span></strong><span class="koboSpan" id="kobo.285.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.286.1">email</span></strong><span class="koboSpan" id="kobo.287.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.288.1">company</span></strong><span class="koboSpan" id="kobo.289.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.290.1">position</span></strong><span class="koboSpan" id="kobo.291.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.292.1">bio</span></strong><span class="koboSpan" id="kobo.293.1">) have been provided. </span><span class="koboSpan" id="kobo.293.2">If any of the fields are missing, it returns a JSON response with an error message and a status code of </span><strong class="source-inline"><span class="koboSpan" id="kobo.294.1">400</span></strong><span class="koboSpan" id="kobo.295.1"> (</span><span class="No-Break"><span class="koboSpan" id="kobo.296.1">bad request).</span></span></p>
<p><span class="koboSpan" id="kobo.297.1">Next, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.298.1">add_speaker()</span></strong><span class="koboSpan" id="kobo.299.1"> function queries the database to check whether a speaker with the same email already exists. </span><span class="koboSpan" id="kobo.299.2">If a speaker with the same email is found, it returns a JSON response with an error message and a status code of </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.300.1">409</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.301.1"> (Conflict).</span></span></p>
<p><span class="koboSpan" id="kobo.302.1">If the speaker is </span><a id="_idIndexMarker783"/><span class="koboSpan" id="kobo.303.1">new (no existing speaker with the same email), a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.304.1">Speaker</span></strong><span class="koboSpan" id="kobo.305.1"> object </span><a id="_idIndexMarker784"/><span class="koboSpan" id="kobo.306.1">is created with the provided information, including the avatar file. </span><span class="koboSpan" id="kobo.306.2">The speaker is then added to the database session </span><span class="No-Break"><span class="koboSpan" id="kobo.307.1">and committed.</span></span></p>
<p><span class="koboSpan" id="kobo.308.1">Finally, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.309.1">add_speaker()</span></strong><span class="koboSpan" id="kobo.310.1"> function returns a JSON response with the serialized speaker data and a status code of </span><strong class="source-inline"><span class="koboSpan" id="kobo.311.1">201</span></strong><span class="koboSpan" id="kobo.312.1"> (Created) to indicate a successful speaker creation. </span><span class="koboSpan" id="kobo.312.2">The code also includes a helper function, </span><strong class="source-inline"><span class="koboSpan" id="kobo.313.1">allowed_file</span></strong><span class="koboSpan" id="kobo.314.1">, that checks whether a given filename has an allowed file extension based on the </span><span class="No-Break"><span class="koboSpan" id="kobo.315.1">application’s configuration.</span></span></p>
<p><span class="koboSpan" id="kobo.316.1">Next, we are going to set up the React component to add the speaker data to </span><span class="No-Break"><span class="koboSpan" id="kobo.317.1">the backend.</span></span></p>
<h2 id="_idParaDest-207"><a id="_idTextAnchor243"/><span class="koboSpan" id="kobo.318.1">Adding the speaker data to the backend using the CreateSpeaker component</span></h2>
<p><span class="koboSpan" id="kobo.319.1">In this section, we will add </span><a id="_idIndexMarker785"/><span class="koboSpan" id="kobo.320.1">speaker data to the backend. </span><span class="koboSpan" id="kobo.320.2">We will create a component called </span><strong class="source-inline"><span class="koboSpan" id="kobo.321.1">CreateSpeaker</span></strong><span class="koboSpan" id="kobo.322.1">. </span><span class="koboSpan" id="kobo.322.2">This component will handle the form inputs for adding a new speaker </span><a id="_idIndexMarker786"/><span class="koboSpan" id="kobo.323.1">and send the data to the backend API </span><span class="No-Break"><span class="koboSpan" id="kobo.324.1">for storage.</span></span></p>
<p><span class="koboSpan" id="kobo.325.1">First, we will add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.326.1">AddSpeaker</span></strong><span class="koboSpan" id="kobo.327.1"> function to the API call service </span><span class="No-Break"><span class="koboSpan" id="kobo.328.1">module </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.329.1">SpeakersAPI.js</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.330.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.331.1">// API function to add a speakerexport const addSpeaker = (speakerData) =&gt; {
    const url = `${API_URL}/speakers`;
    return axios
        .post(url, speakerData, { headers: addHeaders() })
        .then((response) =&gt; response.data)
        .catch(handleErrors);
};</span></pre>
<p><span class="koboSpan" id="kobo.332.1">The preceding code provides an </span><strong class="source-inline"><span class="koboSpan" id="kobo.333.1">addSpeaker</span></strong><span class="koboSpan" id="kobo.334.1"> function that utilizes Axios to send a </span><strong class="source-inline"><span class="koboSpan" id="kobo.335.1">POST</span></strong><span class="koboSpan" id="kobo.336.1"> request to the backend API for adding a new speaker. </span><span class="koboSpan" id="kobo.336.2">It handles the request, response, and error </span><span class="No-Break"><span class="koboSpan" id="kobo.337.1">cases appropriately.</span></span></p>
<p><span class="koboSpan" id="kobo.338.1">Now we will create the </span><strong class="source-inline"><span class="koboSpan" id="kobo.339.1">CreateSpeaker.js</span></strong><span class="koboSpan" id="kobo.340.1"> component inside </span><strong class="source-inline"><span class="koboSpan" id="kobo.341.1">src/pages/Admin/Speakers</span></strong><span class="koboSpan" id="kobo.342.1"> and add the </span><span class="No-Break"><span class="koboSpan" id="kobo.343.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.344.1">import React, { useState } from 'react';import { addSpeaker } from
    '../../../services/SpeakersAPI'LP;
import { useNavigate } from 'react-router-dom';
const CreateSpeaker = () =&gt; {
    const [name, setName] = useState('');
{/* Rest of inputs states */}
    const [isLoading, setIsLoading] = useState(false);
    const [error, setError] = useState(null);
    const [successMessage, setSuccessMessage] =
        useState('');
    const navigate = useNavigate();
    const handleSubmit = async (event) =&gt; {
        event.preventDefault();
        setIsLoading(true);
        setError(null);
        try {
            ...
</span><span class="koboSpan" id="kobo.344.2">            await addSpeaker(formData);
            setIsLoading(false);
            // Reset the form fields
            setName('');
            setEmail('');
            setCompany('');
            setPosition('');
            setBio('');
            setAvatar(null);
            // Display a success message
            ...
</span><span class="koboSpan" id="kobo.344.3">        )}
        &lt;/div&gt;
    );
};
export default CreateSpeaker;</span></pre>
<p><span class="koboSpan" id="kobo.345.1">The preceding code defines a </span><strong class="source-inline"><span class="koboSpan" id="kobo.346.1">CreateSpeaker</span></strong><span class="koboSpan" id="kobo.347.1"> component that handles the creation of a new speaker. </span><span class="koboSpan" id="kobo.347.2">It </span><a id="_idIndexMarker787"/><span class="koboSpan" id="kobo.348.1">manages form input values, avatar file selection, loading state, error messages, and success messages. </span><span class="koboSpan" id="kobo.348.2">When </span><a id="_idIndexMarker788"/><span class="koboSpan" id="kobo.349.1">the form is submitted, the component sends the data to the backend API and handles the </span><span class="No-Break"><span class="koboSpan" id="kobo.350.1">response accordingly:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.351.1">The component imports necessary dependencies, including </span><strong class="source-inline"><span class="koboSpan" id="kobo.352.1">React</span></strong><span class="koboSpan" id="kobo.353.1">, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.354.1">useState</span></strong><span class="koboSpan" id="kobo.355.1"> hook, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.356.1">addSpeaker</span></strong><span class="koboSpan" id="kobo.357.1"> function from </span><strong class="source-inline"><span class="koboSpan" id="kobo.358.1">SpeakersAPI</span></strong><span class="koboSpan" id="kobo.359.1">, and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.360.1">useNavigate</span></strong><span class="koboSpan" id="kobo.361.1"> hook </span><span class="No-Break"><span class="koboSpan" id="kobo.362.1">from </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.363.1">react-router-dom</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.364.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.365.1">Inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.366.1">CreateSpeaker</span></strong><span class="koboSpan" id="kobo.367.1"> component, it sets up state variables using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.368.1">useState</span></strong><span class="koboSpan" id="kobo.369.1"> hook to store the form input values (</span><strong class="source-inline"><span class="koboSpan" id="kobo.370.1">name</span></strong><span class="koboSpan" id="kobo.371.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.372.1">email</span></strong><span class="koboSpan" id="kobo.373.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.374.1">company</span></strong><span class="koboSpan" id="kobo.375.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.376.1">position</span></strong><span class="koboSpan" id="kobo.377.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.378.1">bio</span></strong><span class="koboSpan" id="kobo.379.1">), the avatar file, loading state, error message, and success message. </span><span class="koboSpan" id="kobo.379.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.380.1">CreateSpeaker</span></strong><span class="koboSpan" id="kobo.381.1"> component also uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.382.1">useNavigate</span></strong><span class="koboSpan" id="kobo.383.1"> hook to </span><span class="No-Break"><span class="koboSpan" id="kobo.384.1">handle navigation.</span></span></li>
<li><span class="koboSpan" id="kobo.385.1">The component defines a </span><strong class="source-inline"><span class="koboSpan" id="kobo.386.1">handleSubmit</span></strong><span class="koboSpan" id="kobo.387.1"> function that is triggered when the form is submitted. </span><span class="koboSpan" id="kobo.387.2">It first prevents the default form submission behavior. </span><span class="koboSpan" id="kobo.387.3">Then, it sets the loading state to true and clears any previous error messages. </span><span class="koboSpan" id="kobo.387.4">Within the </span><strong class="source-inline"><span class="koboSpan" id="kobo.388.1">handleSubmit</span></strong><span class="koboSpan" id="kobo.389.1"> function, the component constructs a </span><strong class="source-inline"><span class="koboSpan" id="kobo.390.1">FormData</span></strong><span class="koboSpan" id="kobo.391.1"> object and appends the form input values and the avatar file </span><span class="No-Break"><span class="koboSpan" id="kobo.392.1">to it.</span></span></li>
<li><span class="koboSpan" id="kobo.393.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.394.1">addSpeaker</span></strong><span class="koboSpan" id="kobo.395.1"> function (imported from </span><strong class="source-inline"><span class="koboSpan" id="kobo.396.1">SpeakersAPI</span></strong><span class="koboSpan" id="kobo.397.1">) is called with the constructed </span><strong class="source-inline"><span class="koboSpan" id="kobo.398.1">FormData</span></strong><span class="koboSpan" id="kobo.399.1"> object, which sends a </span><strong class="source-inline"><span class="koboSpan" id="kobo.400.1">POST</span></strong><span class="koboSpan" id="kobo.401.1"> request to the backend API to create a </span><span class="No-Break"><span class="koboSpan" id="kobo.402.1">new speaker.</span></span></li>
<li><span class="koboSpan" id="kobo.403.1">If the request is successful, the loading state is set to false, and the form input values are reset. </span><span class="koboSpan" id="kobo.403.2">A success message is displayed, and the user is navigated to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.404.1">/speakers</span></strong><span class="koboSpan" id="kobo.405.1"> page. </span><span class="koboSpan" id="kobo.405.2">If an error occurs during the API request, the loading state is set to false, and the error message is stored in </span><span class="No-Break"><span class="koboSpan" id="kobo.406.1">the state.</span></span></li>
<li><span class="koboSpan" id="kobo.407.1">The component also includes a </span><strong class="source-inline"><span class="koboSpan" id="kobo.408.1">handleAvatarChange</span></strong><span class="koboSpan" id="kobo.409.1"> function to update the avatar state variable when a file is selected in the avatar </span><span class="No-Break"><span class="koboSpan" id="kobo.410.1">input field.</span></span></li>
<li><span class="koboSpan" id="kobo.411.1">The component’s </span><a id="_idIndexMarker789"/><span class="koboSpan" id="kobo.412.1">rendered function returns JSX elements, including a form with form </span><a id="_idIndexMarker790"/><span class="koboSpan" id="kobo.413.1">inputs and a submit button. </span><span class="koboSpan" id="kobo.413.2">It also displays error and success messages based on the respective </span><span class="No-Break"><span class="koboSpan" id="kobo.414.1">state variables.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.415.1">Now, let’s move to the next section to explore how data can be edited in a </span><span class="No-Break"><span class="koboSpan" id="kobo.416.1">React–Flask application.</span></span></p>
<h1 id="_idParaDest-208"><a id="_idTextAnchor244"/><span class="koboSpan" id="kobo.417.1">Editing data – the React–Flask approach</span></h1>
<p><span class="koboSpan" id="kobo.418.1">In addition to displaying </span><a id="_idIndexMarker791"/><span class="koboSpan" id="kobo.419.1">and adding data, it’s also important for a web application to allow the user to edit data. </span><span class="koboSpan" id="kobo.419.2">In this section, you will learn how to implement data editing in a React-Flask </span><span class="No-Break"><span class="koboSpan" id="kobo.420.1">web application.</span></span></p>
<h2 id="_idParaDest-209"><a id="_idTextAnchor245"/><span class="koboSpan" id="kobo.421.1">Editing data in Flask</span></h2>
<p><span class="koboSpan" id="kobo.422.1">Now, let’s add the </span><a id="_idIndexMarker792"/><span class="koboSpan" id="kobo.423.1">endpoint to handle the logic for updating the speaker </span><a id="_idIndexMarker793"/><span class="koboSpan" id="kobo.424.1">data in the database. </span><span class="koboSpan" id="kobo.424.2">Add the following code </span><span class="No-Break"><span class="koboSpan" id="kobo.425.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.426.1">app.py</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.427.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.428.1">from flask import jsonify, requestfrom werkzeug.utils import secure_filename
@app.route('/api/v1/speakers/&lt;int:speaker_id&gt;',
    methods=['PUT'])
def update_speaker(speaker_id):
    data = request.get_json()
    name = data.get('name')
    email = data.get('email')
    company = data.get('company')
    position = data.get('position')
    bio = data.get('bio')
    avatar = request.files.get('speaker_avatar')
    speaker = Speaker.query.get(speaker_id)
    if not speaker:
        return jsonify({"error": "Speaker not found"}), 404
    if not all([name, email, company, position, bio]):
        return jsonify({"error": "All fields are
            required"}), 400
    if email != speaker.email:
        existing_speaker =
            Speaker.query.filter_by(email=email).first()</span></pre>
<p><span class="koboSpan" id="kobo.429.1">The preceding code </span><a id="_idIndexMarker794"/><span class="koboSpan" id="kobo.430.1">defines a new route for updating a speaker’s information </span><a id="_idIndexMarker795"/><span class="koboSpan" id="kobo.431.1">at the </span><strong class="source-inline"><span class="koboSpan" id="kobo.432.1">/api/v1/speakers/int:speaker_id</span></strong><span class="koboSpan" id="kobo.433.1"> endpoint that accepts a </span><strong class="source-inline"><span class="koboSpan" id="kobo.434.1">PUT</span></strong><span class="koboSpan" id="kobo.435.1"> request. </span><span class="koboSpan" id="kobo.435.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.436.1">@app.route</span></strong><span class="koboSpan" id="kobo.437.1"> decorator is used to define the endpoint, and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.438.1">methods</span></strong><span class="koboSpan" id="kobo.439.1"> parameter is set to </span><strong class="source-inline"><span class="koboSpan" id="kobo.440.1">['PUT']</span></strong><span class="koboSpan" id="kobo.441.1"> to specify that this route should only accept </span><strong class="source-inline"><span class="koboSpan" id="kobo.442.1">PUT</span></strong><span class="koboSpan" id="kobo.443.1"> requests. </span><span class="koboSpan" id="kobo.443.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.444.1">&lt;int:speaker_id&gt;</span></strong><span class="koboSpan" id="kobo.445.1"> part of the endpoint is a path parameter, which allows the route to accept a speaker ID as part of </span><span class="No-Break"><span class="koboSpan" id="kobo.446.1">the URL.</span></span></p>
<p><span class="koboSpan" id="kobo.447.1">The code defines the </span><strong class="source-inline"><span class="koboSpan" id="kobo.448.1">update_speaker</span></strong><span class="koboSpan" id="kobo.449.1"> function, which takes in a </span><strong class="source-inline"><span class="koboSpan" id="kobo.450.1">speaker_id</span></strong><span class="koboSpan" id="kobo.451.1"> parameter that corresponds to the path parameter in </span><span class="No-Break"><span class="koboSpan" id="kobo.452.1">the endpoint.</span></span></p>
<p><span class="koboSpan" id="kobo.453.1">The code first gets the JSON payload of the request and extracts the speaker’s information from it. </span><span class="koboSpan" id="kobo.453.2">Then, you retrieve the speaker’s information from the database using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.454.1">Speaker.query.get(speaker_id)</span></strong><span class="koboSpan" id="kobo.455.1"> method. </span><span class="koboSpan" id="kobo.455.2">The function queries the database to retrieve the existing speaker object based on the provided </span><strong class="source-inline"><span class="koboSpan" id="kobo.456.1">speaker_id</span></strong><span class="koboSpan" id="kobo.457.1">. </span><span class="koboSpan" id="kobo.457.2">If the speaker is not found, it returns a JSON response with an error message and a status code of </span><strong class="source-inline"><span class="koboSpan" id="kobo.458.1">404</span></strong><span class="koboSpan" id="kobo.459.1"> (</span><span class="No-Break"><span class="koboSpan" id="kobo.460.1">Not Found).</span></span></p>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.461.1">update_speaker()</span></strong><span class="koboSpan" id="kobo.462.1"> checks whether all the required fields (</span><strong class="source-inline"><span class="koboSpan" id="kobo.463.1">name</span></strong><span class="koboSpan" id="kobo.464.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.465.1">email</span></strong><span class="koboSpan" id="kobo.466.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.467.1">company</span></strong><span class="koboSpan" id="kobo.468.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.469.1">position</span></strong><span class="koboSpan" id="kobo.470.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.471.1">bio</span></strong><span class="koboSpan" id="kobo.472.1">) have been provided. </span><span class="koboSpan" id="kobo.472.2">If any of the fields are missing, it returns a JSON response with an error message and a status code of </span><strong class="source-inline"><span class="koboSpan" id="kobo.473.1">400</span></strong><span class="koboSpan" id="kobo.474.1"> (</span><span class="No-Break"><span class="koboSpan" id="kobo.475.1">Bad Request).</span></span></p>
<p><span class="koboSpan" id="kobo.476.1">If there is an exception in saving the image, it will delete the previous avatar image and return an error </span><a id="_idIndexMarker796"/><span class="koboSpan" id="kobo.477.1">message and status code. </span><span class="koboSpan" id="kobo.477.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.478.1">update_speaker</span></strong><span class="koboSpan" id="kobo.479.1"> function </span><a id="_idIndexMarker797"/><span class="koboSpan" id="kobo.480.1">then updates the speaker’s information in the database. </span><span class="koboSpan" id="kobo.480.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.481.1">update_speaker</span></strong><span class="koboSpan" id="kobo.482.1"> function attempts to commit the changes to the database; if it fails, it will roll back the transaction and return an error message and status code </span><span class="No-Break"><span class="koboSpan" id="kobo.483.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.484.1">500</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.485.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.486.1">Finally, if all goes well, the code returns the updated speaker’s information as a JSON object and a status code </span><span class="No-Break"><span class="koboSpan" id="kobo.487.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.488.1">200</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.489.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.490.1">Next, we will create the React component to handle updating a </span><span class="No-Break"><span class="koboSpan" id="kobo.491.1">speaker’s data.</span></span></p>
<h2 id="_idParaDest-210"><a id="_idTextAnchor246"/><span class="koboSpan" id="kobo.492.1">Displaying the edited data in React</span></h2>
<p><span class="koboSpan" id="kobo.493.1">In this section, we </span><a id="_idIndexMarker798"/><span class="koboSpan" id="kobo.494.1">will provide the functionality to edit speakers’ information. </span><span class="koboSpan" id="kobo.494.2">To edit data in React, we can modify the component’s state with the updated values and reflect those changes in the user interface. </span><span class="koboSpan" id="kobo.494.3">We will start by adding the </span><strong class="source-inline"><span class="koboSpan" id="kobo.495.1">UpdateSpeaker</span></strong><span class="koboSpan" id="kobo.496.1"> component. </span><span class="koboSpan" id="kobo.496.2">In </span><strong class="source-inline"><span class="koboSpan" id="kobo.497.1">frontend/src/pages/Admin/Speakers/UpdateSpeaker.js</span></strong><span class="koboSpan" id="kobo.498.1">, add the </span><span class="No-Break"><span class="koboSpan" id="kobo.499.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.500.1">import React, { useState, useEffect } from 'react';import { updateSpeaker } from
    '../../../services/SpeakersAPI';
import { useNavigate } from 'react-router-dom';
const UpdateSpeaker = ({ speakerId }) =&gt; {
    const [name, setName] = useState('');
    const [email, setEmail] = useState('');
    const [company, setCompany] = useState('');
    const [position, setPosition] = useState('');
    const [bio, setBio] = useState('');
    const [isLoading, setIsLoading] = useState(false);
    const [error, setError] = useState(null);
    const [successMessage, setSuccessMessage] =
        useState('');
    const navigate=useNavigate();
    useEffect(() =&gt; {
        // Fetch the speaker data based on speakerId
        fetchSpeaker();
    }, [speakerId]);
    const fetchSpeaker = async () =&gt; {
        try {
            // Fetch the speaker data from the backend
                based on speakerId
            const speakerData =
                await getSpeaker(speakerId);
            setName(speakerData.name);
            setEmail(speakerData.email);
            setCompany(speakerData.company);
            setPosition(speakerData.position);
            setBio(speakerData.bio);
        } catch (error) {
            setError(error.message);
        }
    };
{/* The rest of the code snippet can be found on GitHub */}</span></pre>
<p><span class="koboSpan" id="kobo.501.1">The preceding code defines a component called </span><strong class="source-inline"><span class="koboSpan" id="kobo.502.1">UpdateSpeaker</span></strong><span class="koboSpan" id="kobo.503.1">. </span><span class="koboSpan" id="kobo.503.2">The component allows a user to update the information of a speaker by making a </span><strong class="source-inline"><span class="koboSpan" id="kobo.504.1">PUT</span></strong><span class="koboSpan" id="kobo.505.1"> request to the server using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.506.1">updateSpeaker</span></strong><span class="koboSpan" id="kobo.507.1"> function from the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.508.1">SpeakersAPI.js</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.509.1"> file.</span></span></p>
<p><span class="koboSpan" id="kobo.510.1">The component starts by importing </span><strong class="source-inline"><span class="koboSpan" id="kobo.511.1">React</span></strong><span class="koboSpan" id="kobo.512.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.513.1">useState</span></strong><span class="koboSpan" id="kobo.514.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.515.1">useEffect</span></strong><span class="koboSpan" id="kobo.516.1"> from the React library and </span><strong class="source-inline"><span class="koboSpan" id="kobo.517.1">updateSpeaker</span></strong><span class="koboSpan" id="kobo.518.1"> from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.519.1">SpeakersAPI.js</span></strong><span class="koboSpan" id="kobo.520.1"> module. </span><span class="koboSpan" id="kobo.520.2">When the form is submitted, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.521.1">handleSubmit</span></strong><span class="koboSpan" id="kobo.522.1"> function is called; it calls the </span><strong class="source-inline"><span class="koboSpan" id="kobo.523.1">updateSpeaker</span></strong><span class="koboSpan" id="kobo.524.1"> function from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.525.1">SpeakersAPI.js</span></strong><span class="koboSpan" id="kobo.526.1"> file and passes in </span><strong class="source-inline"><span class="koboSpan" id="kobo.527.1">speakerId</span></strong><span class="koboSpan" id="kobo.528.1"> and an </span><a id="_idIndexMarker799"/><span class="koboSpan" id="kobo.529.1">object containing the updated speaker’s information. </span><span class="koboSpan" id="kobo.529.2">If the request is successful, it sets the success state to true and if there is an error, it sets the error state </span><span class="No-Break"><span class="koboSpan" id="kobo.530.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.531.1">error.message</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.532.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.533.1">Now, you need to update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.534.1">SpeakersAPI.js</span></strong><span class="koboSpan" id="kobo.535.1"> file in </span><strong class="source-inline"><span class="koboSpan" id="kobo.536.1">src/services/SpeakersAPI.js</span></strong><span class="koboSpan" id="kobo.537.1"> to add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.538.1">updateSpeaker</span></strong><span class="koboSpan" id="kobo.539.1"> API </span><span class="No-Break"><span class="koboSpan" id="kobo.540.1">call function:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.541.1">// API function to update a speakerexport const updateSpeaker = (speakerId, speakerData) =&gt; {
    const url = `${API_URL}/speakers/${speakerId}`;
    return axios
        .put(url, speakerData, { headers: addHeaders() })
        .then((response) =&gt; response.data)
        .catch(handleErrors);
};</span></pre>
<p><span class="koboSpan" id="kobo.542.1">The preceding code defines an </span><strong class="source-inline"><span class="koboSpan" id="kobo.543.1">updateSpeaker</span></strong><span class="koboSpan" id="kobo.544.1"> API function used for updating a speaker’s information on </span><span class="No-Break"><span class="koboSpan" id="kobo.545.1">the backend:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.546.1">The function takes two parameters: </span><strong class="source-inline"><span class="koboSpan" id="kobo.547.1">speakerId</span></strong><span class="koboSpan" id="kobo.548.1"> (representing the ID of the speaker to be updated) and </span><strong class="source-inline"><span class="koboSpan" id="kobo.549.1">speakerData</span></strong><span class="koboSpan" id="kobo.550.1"> (an object containing the updated </span><span class="No-Break"><span class="koboSpan" id="kobo.551.1">speaker information).</span></span></li>
<li><span class="koboSpan" id="kobo.552.1">It constructs the URL for the API endpoint by appending </span><strong class="source-inline"><span class="koboSpan" id="kobo.553.1">speakerId</span></strong><span class="koboSpan" id="kobo.554.1"> to the </span><span class="No-Break"><span class="koboSpan" id="kobo.555.1">base URL.</span></span></li>
<li><span class="koboSpan" id="kobo.556.1">The function uses the Axios library to send a </span><strong class="source-inline"><span class="koboSpan" id="kobo.557.1">PUT</span></strong><span class="koboSpan" id="kobo.558.1"> request to the constructed URL, passing </span><strong class="source-inline"><span class="koboSpan" id="kobo.559.1">speakerData</span></strong><span class="koboSpan" id="kobo.560.1"> as the request payload and including the appropriate headers using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.561.1">addHeaders</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.562.1"> function.</span></span></li>
<li><span class="koboSpan" id="kobo.563.1">If the request is</span><a id="_idIndexMarker800"/><span class="koboSpan" id="kobo.564.1"> successful, it returns the response data. </span><span class="koboSpan" id="kobo.564.2">If an error occurs during the request, it catches the error and calls the </span><strong class="source-inline"><span class="koboSpan" id="kobo.565.1">handleErrors</span></strong><span class="koboSpan" id="kobo.566.1"> function to handle and propagate </span><span class="No-Break"><span class="koboSpan" id="kobo.567.1">the error.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.568.1">Next, you will learn how to delete speaker data from </span><span class="No-Break"><span class="koboSpan" id="kobo.569.1">the database.</span></span></p>
<h1 id="_idParaDest-211"><a id="_idTextAnchor247"/><span class="koboSpan" id="kobo.570.1">Deleting data from a database – the React–Flask approach</span></h1>
<p><span class="koboSpan" id="kobo.571.1">Deleting data from </span><a id="_idIndexMarker801"/><span class="koboSpan" id="kobo.572.1">a database involves removing one or more records or rows from a table. </span><span class="koboSpan" id="kobo.572.2">In this section, you are going to learn how to handle delete requests in a React–Flask </span><span class="No-Break"><span class="koboSpan" id="kobo.573.1">web application.</span></span></p>
<h2 id="_idParaDest-212"><a id="_idTextAnchor248"/><span class="koboSpan" id="kobo.574.1">Handling delete requests in Flask</span></h2>
<p><span class="koboSpan" id="kobo.575.1">Let’s create the </span><a id="_idIndexMarker802"/><span class="koboSpan" id="kobo.576.1">endpoint to handle the logic for deleting </span><a id="_idIndexMarker803"/><span class="koboSpan" id="kobo.577.1">speaker data from </span><span class="No-Break"><span class="koboSpan" id="kobo.578.1">the database:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.579.1">@app.route('/api/v1/speakers/&lt;int:speaker_id&gt;',    methods=['DELETE'])
def delete_speaker(speaker_id):
    speaker = Speaker.query.get_or_404(speaker_id)
    if not current_user.has_permission("delete_speaker"):
        abort(http.Forbidden("You do not have permission to
            delete this speaker"))
    events =
        Event.query.filter_by(speaker_id=speaker_id).all()
    if events:
        abort(http.Conflict("This speaker has associated
            events, please delete them first"))
    try:
        if speaker.speaker_avatar:
            speaker_avatar.delete(speaker.speaker_avatar)
        with db.session.begin():
            db.session.delete(speaker)
    except Exception:
        abort(http.InternalServerError("Error while
            deleting speaker"))
    return jsonify({"message": "Speaker deleted
        successfully"}), http.OK</span></pre>
<p><span class="koboSpan" id="kobo.580.1">The preceding </span><a id="_idIndexMarker804"/><span class="koboSpan" id="kobo.581.1">code defines an API route for deleting a speaker, performs </span><a id="_idIndexMarker805"/><span class="koboSpan" id="kobo.582.1">the necessary checks, deletes the speaker from the database, handles errors, and returns an </span><span class="No-Break"><span class="koboSpan" id="kobo.583.1">appropriate response.</span></span></p>
<p><span class="koboSpan" id="kobo.584.1">Next, we will explore the React component for handling delete requests from </span><span class="No-Break"><span class="koboSpan" id="kobo.585.1">the frontend.</span></span></p>
<h2 id="_idParaDest-213"><a id="_idTextAnchor249"/><span class="koboSpan" id="kobo.586.1">Handling delete requests in React</span></h2>
<p><span class="koboSpan" id="kobo.587.1">When building a React application, you can handle a delete request to remove a speaker resource by creating </span><a id="_idIndexMarker806"/><span class="koboSpan" id="kobo.588.1">a component that interacts with the backend API. </span><span class="koboSpan" id="kobo.588.2">This </span><a id="_idIndexMarker807"/><span class="koboSpan" id="kobo.589.1">component will send the delete request to the appropriate endpoint, handle any potential errors, and update the component’s state accordingly to reflect the deletion of the </span><span class="No-Break"><span class="koboSpan" id="kobo.590.1">speaker resource.</span></span></p>
<p><span class="koboSpan" id="kobo.591.1">Let’s start by creating a </span><strong class="source-inline"><span class="koboSpan" id="kobo.592.1">DeleteSpeaker</span></strong><span class="koboSpan" id="kobo.593.1"> component. </span><span class="koboSpan" id="kobo.593.2">In </span><strong class="source-inline"><span class="koboSpan" id="kobo.594.1">frontend/src/pages/Admin/Speakers/DeleteSpeaker.js</span></strong><span class="koboSpan" id="kobo.595.1">, add the </span><span class="No-Break"><span class="koboSpan" id="kobo.596.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.597.1">import React, { useState, useEffect } from "react";import { useParams, useNavigate } from "react-router-dom";
import { deleteSpeaker } from "./api/SpeakersAPI";
const DeleteSpeaker = () =&gt; {
    const { speakerId } = useParams();
    const navigate = useNavigate();
    const [error, setError] = useState("");
    const [isLoading, setIsLoading] = useState(false);
    const handleDelete = async () =&gt; {
        try {
            setIsLoading(true);
            await deleteSpeaker(speakerId);
            setIsLoading(false);
            navigate("/speakers"); // Redirect to speakers
                                      list after successful
                                      deletion
        } catch (err) {
            setIsLoading(false);
            setError("Failed to delete speaker.");
        }
    };
    useEffect(() =&gt; {
        return () =&gt; {
            // Clear error message on component unmount
            setError("");
        };
    }, []);
    return (
        &lt;div&gt;
            {error &amp;&amp; &lt;p className="error"&gt;{error}&lt;/p&gt;}
            &lt;p&gt;Are you sure you want to delete this
                speaker?&lt;/p&gt;
            &lt;button onClick={handleDelete}
                disabled={isLoading}&gt;
                {isLoading ? </span><span class="koboSpan" id="kobo.597.2">"Deleting..." </span><span class="koboSpan" id="kobo.597.3">: "Delete
                Speaker"}
            &lt;/button&gt;
        &lt;/div&gt;
    );
};
export default DeleteSpeaker;</span></pre>
<p><span class="koboSpan" id="kobo.598.1">The preceding code defines a component that allows users to delete a speaker by </span><strong class="source-inline"><span class="koboSpan" id="kobo.599.1">id</span></strong><span class="koboSpan" id="kobo.600.1">. </span><span class="koboSpan" id="kobo.600.2">The component starts by importing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.601.1">useParams</span></strong><span class="koboSpan" id="kobo.602.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.603.1">useNavigate</span></strong><span class="koboSpan" id="kobo.604.1"> hooks from </span><strong class="source-inline"><span class="koboSpan" id="kobo.605.1">react-router-dom</span></strong><span class="koboSpan" id="kobo.606.1"> to extract the </span><strong class="source-inline"><span class="koboSpan" id="kobo.607.1">speakerId</span></strong><span class="koboSpan" id="kobo.608.1"> value from the URL. </span><span class="koboSpan" id="kobo.608.2">It also imports the </span><strong class="source-inline"><span class="koboSpan" id="kobo.609.1">deleteSpeaker</span></strong><span class="koboSpan" id="kobo.610.1"> function from </span><strong class="source-inline"><span class="koboSpan" id="kobo.611.1">src/services/SpeakersAPI.js</span></strong><span class="koboSpan" id="kobo.612.1"> to handle the deletion of the speaker with an API call on the backend. </span><span class="koboSpan" id="kobo.612.2">The component then uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.613.1">useState</span></strong><span class="koboSpan" id="kobo.614.1"> hook to initialize two state variables: </span><strong class="source-inline"><span class="koboSpan" id="kobo.615.1">error</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.616.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.617.1">success</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.618.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.619.1">The component has a single button that, when clicked, triggers the </span><strong class="source-inline"><span class="koboSpan" id="kobo.620.1">handleDelete</span></strong><span class="koboSpan" id="kobo.621.1"> function. </span><span class="koboSpan" id="kobo.621.2">This function</span><a id="_idIndexMarker808"/><span class="koboSpan" id="kobo.622.1"> prevents the default form submission behavior </span><a id="_idIndexMarker809"/><span class="koboSpan" id="kobo.623.1">and then calls the </span><strong class="source-inline"><span class="koboSpan" id="kobo.624.1">deleteSpeaker</span></strong><span class="koboSpan" id="kobo.625.1"> function passing in </span><strong class="source-inline"><span class="koboSpan" id="kobo.626.1">speakerId</span></strong><span class="koboSpan" id="kobo.627.1"> as an argument. </span><span class="koboSpan" id="kobo.627.2">If the deletion is successful, it sets the success state to true; otherwise, it sets the error state to the error message returned from the API. </span><span class="koboSpan" id="kobo.627.3">The component then renders a message to indicate whether the deletion was successful or there was </span><span class="No-Break"><span class="koboSpan" id="kobo.628.1">an error.</span></span></p>
<p><span class="koboSpan" id="kobo.629.1">Now, you need to update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.630.1">SpeakersAPI.js</span></strong><span class="koboSpan" id="kobo.631.1"> file in </span><strong class="source-inline"><span class="koboSpan" id="kobo.632.1">src/api/SpeakersAPI.js</span></strong><span class="koboSpan" id="kobo.633.1"> to add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.634.1">deleteSpeaker</span></strong><span class="koboSpan" id="kobo.635.1"> API </span><span class="No-Break"><span class="koboSpan" id="kobo.636.1">call function:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.637.1">// API function to delete a speakerexport const deleteSpeaker = async (speakerId) =&gt; {
    const url = `/api/v1/speakers/${speakerId}`;
    try {
        const speakerResponse = await axios.get(url);
        const speaker = speakerResponse.data;
        if (!speaker) {
            throw new Error("Speaker not found");
        }
      const eventsResponse = await
          axios.get(`/api/v1/events?speakerId=${speakerId}`
          );
      const events = eventsResponse.data;
      if (events.length &gt; 0) {
        throw new Error("This speaker has associated
            events, please delete them first");
      }
      await axios.delete(url);
      return speaker;
    } catch (err) {
        if (err.response) {
            const { status, data } = err.response;
            throw new Error(`${status}: ${data.error}`);
        } else if (err.request) {
            throw new Error('Error: No response received
                from server');
        } else {
            throw new Error(err.message);
        }
    }
};</span></pre>
<p><span class="koboSpan" id="kobo.638.1">The preceding </span><a id="_idIndexMarker810"/><span class="koboSpan" id="kobo.639.1">code defines a </span><strong class="source-inline"><span class="koboSpan" id="kobo.640.1">deleteSpeaker</span></strong><span class="koboSpan" id="kobo.641.1"> function that takes </span><a id="_idIndexMarker811"/><span class="koboSpan" id="kobo.642.1">in a </span><strong class="source-inline"><span class="koboSpan" id="kobo.643.1">speakerId</span></strong><span class="koboSpan" id="kobo.644.1"> as its parameter. </span><span class="koboSpan" id="kobo.644.2">The function uses the Axios library to make HTTP requests to the server. </span><span class="koboSpan" id="kobo.644.3">The function starts by trying to get the speaker details from the server by making a </span><strong class="source-inline"><span class="koboSpan" id="kobo.645.1">GET</span></strong><span class="koboSpan" id="kobo.646.1"> request to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.647.1">/</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.648.1">api/v1/speakers/{speakerId}</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.649.1"> endpoint.</span></span></p>
<p><span class="koboSpan" id="kobo.650.1">It then checks whether the speaker exists. </span><span class="koboSpan" id="kobo.650.2">If the speaker doesn’t exist, the function throws an error with the message </span><strong class="bold"><span class="koboSpan" id="kobo.651.1">Speaker not found</span></strong><span class="koboSpan" id="kobo.652.1">. </span><span class="koboSpan" id="kobo.652.2">If the speaker exists, the function makes a </span><strong class="source-inline"><span class="koboSpan" id="kobo.653.1">GET</span></strong><span class="koboSpan" id="kobo.654.1"> request to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.655.1">/api/v1/events?speakerId=${speakerId}</span></strong><span class="koboSpan" id="kobo.656.1"> endpoint to get a list of events associated with the speaker. </span><span class="koboSpan" id="kobo.656.2">It then checks whether the length of events is greater than </span><strong class="source-inline"><span class="koboSpan" id="kobo.657.1">0</span></strong><span class="koboSpan" id="kobo.658.1">. </span><span class="koboSpan" id="kobo.658.2">If so, it throws an error with the message, </span><strong class="bold"><span class="koboSpan" id="kobo.659.1">This speaker has associated events, please delete </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.660.1">them first</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.661.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.662.1">Finally, the function makes a </span><strong class="source-inline"><span class="koboSpan" id="kobo.663.1">DELETE</span></strong><span class="koboSpan" id="kobo.664.1"> request to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.665.1">/api/v1/speakers/{speakerId}</span></strong><span class="koboSpan" id="kobo.666.1"> endpoint to delete the speaker. </span><span class="koboSpan" id="kobo.666.2">If there’s an error during the</span><a id="_idIndexMarker812"/><span class="koboSpan" id="kobo.667.1"> process, the function checks the error and throws an appropriate error message. </span><span class="koboSpan" id="kobo.667.2">The function then exports the </span><strong class="source-inline"><span class="koboSpan" id="kobo.668.1">deleteSpeaker</span></strong><span class="koboSpan" id="kobo.669.1"> function so it can be </span><a id="_idIndexMarker813"/><span class="koboSpan" id="kobo.670.1"> imported and used in other parts of </span><span class="No-Break"><span class="koboSpan" id="kobo.671.1">the application.</span></span></p>
<p><span class="koboSpan" id="kobo.672.1">Next, we will discuss how pagination can be handled in the </span><span class="No-Break"><span class="koboSpan" id="kobo.673.1">React–Flask application.</span></span></p>
<h1 id="_idParaDest-214"><a id="_idTextAnchor250"/><span class="koboSpan" id="kobo.674.1">Managing pagination in a React–Flask application</span></h1>
<p><span class="koboSpan" id="kobo.675.1">When working with a large dataset, it’s important to implement pagination to make the large dataset </span><a id="_idIndexMarker814"/><span class="koboSpan" id="kobo.676.1">more manageable for the user. </span><span class="koboSpan" id="kobo.676.2">Pagination is a technique used to divide a large set of data into smaller, more manageable </span><a id="_idIndexMarker815"/><span class="koboSpan" id="kobo.677.1">chunks called </span><strong class="bold"><span class="koboSpan" id="kobo.678.1">pages</span></strong><span class="koboSpan" id="kobo.679.1">. </span><span class="koboSpan" id="kobo.679.2">Each page contains a subset of the </span><a id="_idIndexMarker816"/><span class="koboSpan" id="kobo.680.1">total data, allowing users to navigate through the data in a </span><span class="No-Break"><span class="koboSpan" id="kobo.681.1">controlled manner.</span></span></p>
<p><span class="koboSpan" id="kobo.682.1">Pagination provides a way to present large datasets efficiently, improves performance, and enhances the user experience by making data more accessible. </span><span class="koboSpan" id="kobo.682.2">In this section, you will learn how to implement pagination in a React–Flask web application. </span><span class="koboSpan" id="kobo.682.3">To implement pagination, you will need to make some changes to the backend server to handle </span><span class="No-Break"><span class="koboSpan" id="kobo.683.1">pagination requests.</span></span></p>
<p><span class="koboSpan" id="kobo.684.1">You can use the Flask-SQLAlchemy library to handle pagination on the backend. </span><span class="koboSpan" id="kobo.684.2">On the Flask backend, you can implement pagination for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.685.1">speaker</span></strong><span class="koboSpan" id="kobo.686.1"> model using the Flask-SQLAlchemy library’s pagination feature. </span><span class="koboSpan" id="kobo.686.2">Let’s delve into how you can implement pagination for the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.687.1">Speaker</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.688.1"> model.</span></span></p>
<p><span class="koboSpan" id="kobo.689.1">Update </span><strong class="source-inline"><span class="koboSpan" id="kobo.690.1">get_speakers()</span></strong><span class="koboSpan" id="kobo.691.1"> with the following code in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.692.1">app.py</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.693.1"> file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.694.1">from flask_sqlalchemy import Pagination@app.route('/api/v1/speakers', methods=['GET'])
def get_speakers():
    page = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', 10, type=int)
    speakers = Speaker.query.paginate(page, per_page,
        False)
    if not speakers.items:
        return jsonify({"error": "No speakers found"}), 404
    return jsonify({
        'speakers': [speaker.serialize() for speaker in
            speakers.items],
        'total_pages': speakers.pages,
        'total_items': speakers.total
    }), 200</span></pre>
<p><span class="koboSpan" id="kobo.695.1">In the preceding code, we are using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.696.1">paginate()</span></strong><span class="koboSpan" id="kobo.697.1"> method from Flask-SQLAlchemy to add the pagination functionality to the speakers’ collection. </span><span class="koboSpan" id="kobo.697.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.698.1">page</span></strong><span class="koboSpan" id="kobo.699.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.700.1">per_page</span></strong><span class="koboSpan" id="kobo.701.1"> arguments are passed in as query parameters in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.702.1">GET</span></strong><span class="koboSpan" id="kobo.703.1"> request. </span><span class="koboSpan" id="kobo.703.2">The default value for </span><strong class="source-inline"><span class="koboSpan" id="kobo.704.1">page</span></strong><span class="koboSpan" id="kobo.705.1"> is </span><strong class="source-inline"><span class="koboSpan" id="kobo.706.1">1</span></strong><span class="koboSpan" id="kobo.707.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.708.1">per_page</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.709.1">is </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.710.1">10</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.711.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.712.1">For the React </span><a id="_idIndexMarker817"/><span class="koboSpan" id="kobo.713.1">frontend, you can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.714.1">useState</span></strong><span class="koboSpan" id="kobo.715.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.716.1">useEffect</span></strong><span class="koboSpan" id="kobo.717.1"> hooks </span><a id="_idIndexMarker818"/><span class="koboSpan" id="kobo.718.1">to handle pagination in a </span><span class="No-Break"><span class="koboSpan" id="kobo.719.1">functional component.</span></span></p>
<p><span class="koboSpan" id="kobo.720.1">Let’s modify the </span><strong class="source-inline"><span class="koboSpan" id="kobo.721.1">ViewSpeakers</span></strong><span class="koboSpan" id="kobo.722.1"> components and add pagination functionality to </span><span class="No-Break"><span class="koboSpan" id="kobo.723.1">the component:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.724.1">import React, { useState, useEffect } from 'react';import { getSpeakers } from
    '../../../services/SpeakersAPI';
const ViewSpeakers = () =&gt; {
    const [speakers, setSpeakers] = useState([]);
    const [currentPage, setCurrentPage] = useState(1);
    const [speakersPerPage] = useState(10);
    const [isLoading, setIsLoading] = useState(false);
    const [error, setError] = useState(null);
    useEffect(() =&gt; {
        fetchSpeakers();
    }, []);
};
export default ViewSpeakers;</span></pre>
<p><span class="koboSpan" id="kobo.725.1">The preceding code defines a component that displays a list of speakers using pagination. </span><span class="koboSpan" id="kobo.725.2">The component makes use of React hooks to manage its state. </span><span class="koboSpan" id="kobo.725.3">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.726.1">speakers</span></strong><span class="koboSpan" id="kobo.727.1"> state variable is used to store the list of speakers, and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.728.1">page</span></strong><span class="koboSpan" id="kobo.729.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.730.1">perPage</span></strong><span class="koboSpan" id="kobo.731.1"> state variables are used to store the current page number and the number of items to be displayed per </span><span class="No-Break"><span class="koboSpan" id="kobo.732.1">page, respectively.</span></span></p>
<p><span class="koboSpan" id="kobo.733.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.734.1">useEffect</span></strong><span class="koboSpan" id="kobo.735.1"> hook is used to fetch the speakers from the server when the component is mounted and </span><a id="_idIndexMarker819"/><span class="koboSpan" id="kobo.736.1">whenever the </span><strong class="source-inline"><span class="koboSpan" id="kobo.737.1">page</span></strong><span class="koboSpan" id="kobo.738.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.739.1">perPage</span></strong><span class="koboSpan" id="kobo.740.1"> state variables change. </span><span class="koboSpan" id="kobo.740.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.741.1">fetchSpeakers</span></strong><span class="koboSpan" id="kobo.742.1"> function uses the Axios </span><a id="_idIndexMarker820"/><span class="koboSpan" id="kobo.743.1">library to make a </span><strong class="source-inline"><span class="koboSpan" id="kobo.744.1">GET</span></strong><span class="koboSpan" id="kobo.745.1"> request to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.746.1">'/api/v1/speakers?page=${page}&amp;per_page=${perPage}'</span></strong><span class="koboSpan" id="kobo.747.1"> endpoint, passing in the current page number and the number of items per page as </span><span class="No-Break"><span class="koboSpan" id="kobo.748.1">query parameters.</span></span></p>
<p><span class="koboSpan" id="kobo.749.1">The response data is then stored in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.750.1">speakers</span></strong><span class="koboSpan" id="kobo.751.1"> state variable. </span><span class="koboSpan" id="kobo.751.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.752.1">ViewSpeakers</span></strong><span class="koboSpan" id="kobo.753.1"> component then maps through the speakers’ array and displays the name and email of each speaker. </span><span class="koboSpan" id="kobo.753.2">The component also includes two buttons, one for navigating to the </span><a id="_idIndexMarker821"/><span class="koboSpan" id="kobo.754.1">previous page and one for navigating </span><a id="_idIndexMarker822"/><span class="koboSpan" id="kobo.755.1">to the </span><span class="No-Break"><span class="koboSpan" id="kobo.756.1">next page.</span></span></p>
<p><span class="koboSpan" id="kobo.757.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.758.1">onClick</span></strong><span class="koboSpan" id="kobo.759.1"> handlers of these buttons update the page state variable accordingly, and the </span><strong class="bold"><span class="koboSpan" id="kobo.760.1">Previous</span></strong><span class="koboSpan" id="kobo.761.1"> button is also disabled if the current page is </span><strong class="source-inline"><span class="koboSpan" id="kobo.762.1">1</span></strong><span class="koboSpan" id="kobo.763.1"> to prevent the user from navigating to a non-existent </span><span class="No-Break"><span class="koboSpan" id="kobo.764.1">previous page.</span></span></p>
<h1 id="_idParaDest-215"><a id="_idTextAnchor251"/><span class="koboSpan" id="kobo.765.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.766.1">In this chapter, we discussed in detail how you can fetch and display data in a React–Flask web application. </span><span class="koboSpan" id="kobo.766.2">We examined one of the ways fetching and displaying data is handled. </span><span class="koboSpan" id="kobo.766.3">You were able to work from the backend in defining the </span><strong class="source-inline"><span class="koboSpan" id="kobo.767.1">Speaker</span></strong><span class="koboSpan" id="kobo.768.1"> model class and implement various endpoints to handle data fetching from the database, and adding, updating, and deleting data </span><span class="No-Break"><span class="koboSpan" id="kobo.769.1">on it.</span></span></p>
<p><span class="koboSpan" id="kobo.770.1">We used the Axios library to send a request to the Flask backend, which then retrieved the data from a database and returned it to the frontend in a response. </span><span class="koboSpan" id="kobo.770.2">The React frontend then processed the response and displayed the data to the end user. </span><span class="koboSpan" id="kobo.770.3">Lastly, we implemented pagination as a way to present large datasets efficiently and to improve the performance of React–Flack web </span><span class="No-Break"><span class="koboSpan" id="kobo.771.1">application projects.</span></span></p>
<p><span class="koboSpan" id="kobo.772.1">Next, we are going to discuss authentication and authorization in a React–Flask application and examine the best practices to ensure that your application is secure and ready </span><span class="No-Break"><span class="koboSpan" id="kobo.773.1">for production.</span></span></p>
</div>
</body></html>