<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-199"><a id="_idTextAnchor232"/>11</h1>
<h1 id="_idParaDest-200"><a id="_idTextAnchor233"/>Fetching and Displaying Data in a React-Flask Application</h1>
<p>In the preceding chapter, you were able to successfully integrate the React frontend into the Flask backend. This is a significant milestone in the journey of a full stack web developer. In this chapter, you will build on what you have learned and dive deeper into data fetching in a full stack web application.</p>
<p>Data fetching is important in a web application because it allows the application to retrieve data from a backend server, API, or database and display that data to a user. Without the ability to fetch data, a web application would be limited to displaying only hardcoded data, which would not be very useful or dynamic. By fetching data from a backend server or API, the application can display up-to-date, dynamic data to the user.</p>
<p>In addition, data fetching is often used in combination with user interactions and updates to the data, allowing the <a id="_idIndexMarker751"/>application to perform actions such as inserting, updating, or deleting data in a database or API. This allows the application to be more interactive and responsive to the user’s actions.</p>
<p>In this chapter, you will learn about the intricacies of data fetching and its vital role in web applications, and more importantly, how it concerns integrating the React frontend with the Flask backend. You will learn about the role of data fetching in enabling web applications to fetch data from a backend server or API, ensuring the display of current and dynamic information.</p>
<p>We will discuss the use of data fetching in combination with user interactions to perform actions such as retrieving, inserting, updating, or deleting data in a database or API. Lastly, we will discuss how you can manage pagination in React–Flask applications.</p>
<p>By the end of this chapter, you will understand how to add data to a database, display database data, and how pagination is handled in a React–Flask web application.</p>
<p>In this chapter, we’ll be covering the following topics:</p>
<ul>
<li>Fetching and displaying data – the React–Flask approach</li>
<li>Adding data to a database – the React–Flask approach</li>
<li>Editing data – the React–Flask approach</li>
<li>Deleting data from a database – the React–Flask approach</li>
<li>Managing pagination in a React–Flask application</li>
</ul>
<h1 id="_idParaDest-201"><a id="_idTextAnchor234"/>Technical requirements</h1>
<p>The The complete code for this chapter is available on GitHub at: <a href="https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter11">https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter11</a>.</p>
<p>Owing to the page-count constraints, some of the code blocks have been snipped. Please refer to GitHub for the complete code.</p>
<h1 id="_idParaDest-202"><a id="_idTextAnchor235"/>Fetching and displaying data – the React-Flask approach</h1>
<p>In this chapter, first, we will be fetching data on speakers and displaying it to the users of the application. But <a id="_idIndexMarker752"/>before heading into that, let’s do some <a id="_idIndexMarker753"/>code restructuring. You will need to <a id="_idIndexMarker754"/>restructure the backend to accommodate the growing <code>app.py</code> file contents in the <a id="_idIndexMarker755"/>project directory. Dividing the code into different components improves the overall structure and organization of the application.</p>
<p>Rather than having the entire code in a single module, you can structure your code to separate concerns. We’ll discuss more on code structuring for larger applications in <a href="B18554_14.xhtml#_idTextAnchor285"><em class="italic">Chapter 14</em></a>, <em class="italic">Modular Architecture – The Power of Blueprints</em>. With this code split, developers can easily locate and modify specific parts of the code base without affecting other components. This modular approach also promotes code reusability.</p>
<p>Now, back to the code, you will add <code>models.py</code> to the backend project directory (<code>bizza/backend/models.py</code>) to house all the models for database interaction. This will help us to separate application concerns. The <code>app.py</code> file will be used to handle endpoints and their associated logic, while the <code>models.py</code> file contains the application data models.</p>
<p>The restructured <code>app.py</code> and <code>models.py</code> files can be found on GitHub at <a href="https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter11">https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter11</a>.</p>
<p>Essentially, we will simulate an admin page for our <em class="italic">Bizza</em> application so that we can create, display, and edit speaker data, and manage pagination via the admin page. At this point, we are setting up an admin page for demonstration purposes only; we are not going to bother ourselves with data validation, authentication, and authorization implementations.</p>
<p>In this section, the focus will be to learn how to retrieve data from the backend and display it in the React frontend. Being able to display data from a database is important because it allows <a id="_idIndexMarker756"/>you to present the data to users in a visual and <a id="_idIndexMarker757"/>interactive way. By displaying data in a <a id="_idIndexMarker758"/>web application, you can create a user-friendly interface that allows <a id="_idIndexMarker759"/>users to view, search, filter, and manipulate the data as needed.</p>
<p>You need to fetch and display data in order to create a functional and useful web application that makes use of data stored in a database. To retrieve data from the backend, we will use Axios for making network requests. You can use Axios to make a <code>GET</code> request to the backend server and retrieve the data you need.</p>
<p>Let’s delve into how we can retrieve a list of speakers and their details from the backend and display it in the admin page of our <em class="italic">Bizza</em> application.</p>
<h2 id="_idParaDest-203"><a id="_idTextAnchor236"/>Retrieving the speakers’ list from Flask</h2>
<p>The Flask backend<a id="_idIndexMarker760"/> will manage the list of speakers and their details with a simple API. In <code>models.py</code>, add the following code to create the <code>Speaker</code> model class:</p>
<pre class="source-code">from datetime import datetimeclass Speaker(db.Model):
    __tablename__ = 'speakers'
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(100), nullable=False)
    email = db.Column(db.String(100), nullable=False)
    company = db.Column(db.String(100), nullable=False)
    position = db.Column(db.String(100), nullable=False)
    bio = db.Column(db.String(200), nullable=False)
    speaker_avatar = db.Column(db.String(100),
        nullable=True)
    created_at = db.Column(db.DateTime,
        default=datetime.utcnow)
    updated_at = db.Column(db.DateTime,
        default=datetime.utcnow, onupdate=datetime.utcnow)
    def __repr__(self):
        return f'&lt;Speaker {self.name}&gt;'
    def serialize(self):
        return {
            'id': self.id,
            'name': self.name,
            'email': self.email,
            'company': self.company,
            'position': self.position,
            'bio': self.bio,
            'speaker_avatar': self.speaker_avatar,
            'created_at': self.created_at.isoformat(),
            'updated_at': self.updated_at.isoformat()
        }</pre>
<p>The preceding code defines a <code>Speaker</code> model and has the <code>__repr__()</code> and <code>serialize()</code> methods. The <code>__repr__</code> method is a built-in method in Python that is used to create a string representation of an object. In this case, it is used to create a string representation of a <code>Speaker</code> object.</p>
<p>The <code>serialize()</code> method is used to convert the <code>Speaker</code> object into a dictionary format that can be easily <a id="_idIndexMarker761"/>converted into JSON. This is useful when you need to return the <code>Speaker</code> object as a response to an API endpoint.</p>
<p>The method returns a dictionary containing all the properties of the <code>Speaker</code> object such as <code>id</code>, <code>name</code>, <code>email</code>, <code>company</code>, <code>position</code>, <code>bio</code>, <code>speaker_avatar</code>, <code>created_at</code>, and <code>updated_at</code>. The <code>created_at</code> and <code>updated_at</code> properties are converted into string format using the <code>isoformat()</code> method.</p>
<p>Now, let’s create the endpoint to handle the logic for displaying the speakers’ data:</p>
<pre class="source-code">@app.route('/api/v1/speakers', methods=['GET'])def get_speakers():
    speakers = Speaker.query.all()
    if not speakers:
        return jsonify({"error": "No speakers found"}), 404
    return jsonify([speaker.serialize() for speaker in
        speakers]), 200</pre>
<p>The preceding code retrieves the list of speakers from the database with the <code>get_speakers()</code> function. Now, you need to update the React frontend directory to consume the API speakers list endpoint.</p>
<h2 id="_idParaDest-204"><a id="_idTextAnchor237"/>Displaying data in React</h2>
<p>In the React frontend, you <a id="_idIndexMarker762"/>need to create a route that renders a component <a id="_idIndexMarker763"/>at the <code>http://127.0.0.1:3000/admin</code> path.</p>
<p>The following snippet will create the routing system for the admin:</p>
<pre class="source-code">const router = createBrowserRouter([  {
    path: "/admin",
    element: &lt;AdminPage/&gt;,
    children: [
      {
        path: "/admin/dashboard",
        element: &lt;Dashboard /&gt;,
      },
      {
        path: "/admin/speakers",
        element: &lt;Speakers /&gt;,
      },
      {
        path: "/admin/venues",
        element: &lt;Venues /&gt;,
      },
      {
        path: "/admin/events",
        element: &lt;Events /&gt;,
      },
      {
        path: "/admin/schedules",
        element: &lt;Schedules /&gt;,
      },
      {
        path: "/admin/sponsors",
        element: &lt;Sponsors /&gt;,
      },
    ],
  },
]);</pre>
<p>Let’s now create <code>AdminPage</code> in the <code>/src/pages/Admin/AdminPage/AdminPage.jsx</code> file. <code>AdminPage</code> will serve as an index <a id="_idIndexMarker764"/>component page for the admin and render necessary <a id="_idIndexMarker765"/>components, including the CRUD operations for speakers.</p>
<p>Add the following code to <code>AdminPage.jsx</code>:</p>
<pre class="source-code">import React from "react";import { Outlet } from "react-router-dom";
import Sidebar from
    "../../../components/admin/Sidebar/Sidebar";
import './AdminPage.css'
const AdminPage = () =&gt; {
    return (
        &lt;div className="container"&gt;
            &lt;div&gt;&lt;Navbar/&gt;&lt;/div&gt;
            &lt;div&gt;&lt;Outlet /&gt;&lt;/div&gt;
        &lt;/div&gt;
    );
};
export default AdminPage;</pre>
<p>The preceding code shows the <code>AdminPage</code> component, which represents the structure and content of the <code>admin</code> page. The <code>Sidebar</code> component is imported and rendered as a child component <a id="_idIndexMarker766"/>to render a list of sidebar menus for the admin. Then, we have <a id="_idIndexMarker767"/>the <code>Outlet</code> component imported from the <code>react-router-dom</code> package, which is used to render the content specific to the current route.</p>
<p>Next, we will create a data-fetching component for viewing the list of speakers in the database.</p>
<h3>Displaying the speakers list with the ViewSpeakers component</h3>
<p>We will start <a id="_idIndexMarker768"/>the CRUD operations <a id="_idIndexMarker769"/>on speakers with the <code>ViewSpeakers</code> component that will handle the display of the speakers’ data from the backend to the admin users.</p>
<p>First, we will create a module named <code>SpeakersAPI.js</code> to handle all the API calls. The <code>SpeakersAPI.js</code> module encapsulates the API calls, abstracting away the low-level details of making HTTP requests. This will also allow other parts of the application to interact with the API in a more straightforward manner, without having to deal with the intricacies of the Axios library directly. Overall, you tend to benefit from having this separate module handle the API calls as it promotes code organization, reusability, error handling, header management, and the scalability and maintainability of the code base.</p>
<p>Let’s now dig into the <code>SpeakersAPI</code> module.</p>
<p>Inside <a id="_idIndexMarker770"/>the <code>bizza/frontend/src</code> project <a id="_idIndexMarker771"/>directory, create <code>SpeakersAPI.js</code> and add the following snippet:</p>
<pre class="source-code">import axios from 'axios';const API_URL = 'http://localhost:5000/api/v1';
// Function to handle errors
const handleErrors = (error) =&gt; {
    if (error.response) {
    // The request was made and the server responded with a
       status code
    console.error('API Error:', error.response.status,
        error.response.data);
    } else if (error.request) {
    // The request was made but no response was received
    console.error('API Error: No response received',
        error.request);
    } else {
    // Something else happened while making the request
    console.error('API Error:', error.message);
    }
    throw error;
};
// Function to set headers with Content-Type:
   application/json
const setHeaders = () =&gt; {
    axios.defaults.headers.common['Content-Type'] =
        'application/json';
};
// Function to get speakers
export const getSpeakers = async () =&gt; {
    try {
        setHeaders();
        const response =
            await axios.get(`${API_URL}/speakers`);
        return response.data;
    } catch (error) {
        handleErrors(error);
    }
};</pre>
<p>The preceding<a id="_idIndexMarker772"/> code sets up <a id="_idIndexMarker773"/>a basic configuration for making HTTP requests to an API using Axios and provides a function to retrieve speakers from the API. It handles errors and sets the necessary headers for the requests.</p>
<p>Next, we will define the <code>ViewSpeakers</code> component and make use of the preceding <code>SpeakersAPI</code> module.</p>
<p>Inside <code>src/pages/Admin/Speakers/</code>, create the <code>ViewSpeakers.js</code> component and add the following code:</p>
<pre class="source-code">import React, { useEffect, useState } from 'react';import { getSpeakers } from
    '../../../services/SpeakersAPI';
const ViewSpeakers = () =&gt; {
    const [speakers, setSpeakers] = useState([]);
    const [isLoading, setIsLoading] = useState(true);
    const [error, setError] = useState(null);
    const fetchSpeakers = async () =&gt; {
        try {
            const speakerData = await getSpeakers();
            setSpeakers(speakerData);
            setIsLoading(false);
        } catch (error) {
            setError(error.message);
            setIsLoading(false);
        }
    };
    useEffect(() =&gt; {
        fetchSpeakers();
    }, []);</pre>
<p>The preceding code sets up a React component called <code>ViewSpeakers</code> that fetches speaker data <a id="_idIndexMarker774"/>using the <code>getSpeakers</code> function and updates the component’s state accordingly. It handles loading and <a id="_idIndexMarker775"/>error states and triggers the data-fetching process when the component is mounted. The full code for <code>ViewSpeakers.js</code> can be found in the GitHub repository.</p>
<p>Next, we will explore how we can add data to the database using the Flask–React approach.</p>
<h1 id="_idParaDest-205"><a id="_idTextAnchor238"/>Adding data to a database – the React–Flask approach</h1>
<p>We add data to a database to store and organize information that can be easily accessed, managed, <a id="_idIndexMarker776"/>and updated. It is one of the ways to persistently <a id="_idIndexMarker777"/>store data, and knowing how to do it is a key requirement for any full stack developer. This knowledge allows you to build dynamic and interactive web applications. You then have the means to efficiently retrieve and use the data for various purposes, such as reporting, analysis, and decision making.</p>
<h2 id="_idParaDest-206"><a id="_idTextAnchor239"/>Adding data to Flask</h2>
<p>Now, let’s create <a id="_idIndexMarker778"/>an endpoint to handle the logic for adding spe<a id="_idTextAnchor240"/>aker <a id="_idIndexMarker779"/>data to the database:</p>
<pre class="source-code">    @app.route('/api/v1/speakers', methods=['POST'])    def add_speaker():
        data = request.get_json()
        name = data.get('name')
        email = data.get('email')
        company = data.get('company')
        position = data.get('position')
        bio = data.get('bio')
        avatar = request.files.get('speaker_avatar')
        # Save the uploaded avatar
        if avatar and allowed_file(avatar.filename):
            filename = secure_filename(avatar.filename)
            avatar.save(os.path.join(app.config[
                'UPLOAD_FOLDER'], filename))
        else:
            filename = 'default-avatar.jpg'
        if not name or not email or not company or not
            position or not bio:
            return jsonify({"error": "All fields are
                required"}), 400
        existing_speaker =
            Speaker.query.filter_by(email=email).first()
        if existing_speaker:
            return jsonify({"error": "Speaker with that
                email already exists"}), 409
        speaker = Speaker(name=name, email=email,
            company=company, position=position, bio=bio,
                speaker_avatar=avatar)
        db.session.add(speaker)
        db.session.commit()
        return jsonify(speaker.serialize()), 201
  # Function to check if the file extension is allowed
    def allowed_file(filename):
        <a id="_idTextAnchor241"/>return '.' in filename and \
            filen<a id="_idTextAnchor242"/>ame.rsplit('.', 1)[1].lower(
            ) in app.config['ALLOWED_EXTENSIONS']</pre>
<p>The preceding <a id="_idIndexMarker780"/>code defines a <code>/api/v1/speakers</code> route that defines an API <a id="_idIndexMarker781"/>route that handles a <code>POST</code> request to add a new speaker. It extracts the required speaker information from the request, validates the data, saves the avatar file if provided, checks for duplicate emails, creates a new speaker object, adds it to the database, and returns a response with the created speaker’s data.</p>
<p>The preceding code shows the <code>add_speaker</code> function that is executed when a <code>POST</code> request is made to the specified route.</p>
<p>The <code>add_speaker</code> function retrieves the JSON data from the request using <code>request.get_json()</code> and extracts the <a id="_idIndexMarker782"/>speaker’s name, email, company, position, bio, and <code>speaker_avatar</code> (an uploaded file) from the data.</p>
<p>If a <code>speaker_avatar</code> is provided and the file extension is allowed (after being checked by the <code>allowed_file</code> function), the avatar file is saved to the server’s upload folder with a secure filename. Otherwise, a default avatar filename is assigned.</p>
<p>The function then checks whether all the required fields (<code>name</code>, <code>email</code>, <code>company</code>, <code>position</code>, and <code>bio</code>) have been provided. If any of the fields are missing, it returns a JSON response with an error message and a status code of <code>400</code> (bad request).</p>
<p>Next, the <code>add_speaker()</code> function queries the database to check whether a speaker with the same email already exists. If a speaker with the same email is found, it returns a JSON response with an error message and a status code of <code>409</code> (Conflict).</p>
<p>If the speaker is <a id="_idIndexMarker783"/>new (no existing speaker with the same email), a new <code>Speaker</code> object <a id="_idIndexMarker784"/>is created with the provided information, including the avatar file. The speaker is then added to the database session and committed.</p>
<p>Finally, the <code>add_speaker()</code> function returns a JSON response with the serialized speaker data and a status code of <code>201</code> (Created) to indicate a successful speaker creation. The code also includes a helper function, <code>allowed_file</code>, that checks whether a given filename has an allowed file extension based on the application’s configuration.</p>
<p>Next, we are going to set up the React component to add the speaker data to the backend.</p>
<h2 id="_idParaDest-207"><a id="_idTextAnchor243"/>Adding the speaker data to the backend using the CreateSpeaker component</h2>
<p>In this section, we will add <a id="_idIndexMarker785"/>speaker data to the backend. We will create a component called <code>CreateSpeaker</code>. This component will handle the form inputs for adding a new speaker <a id="_idIndexMarker786"/>and send the data to the backend API for storage.</p>
<p>First, we will add the <code>AddSpeaker</code> function to the API call service module <code>SpeakersAPI.js</code>:</p>
<pre class="source-code">// API function to add a speakerexport const addSpeaker = (speakerData) =&gt; {
    const url = `${API_URL}/speakers`;
    return axios
        .post(url, speakerData, { headers: addHeaders() })
        .then((response) =&gt; response.data)
        .catch(handleErrors);
};</pre>
<p>The preceding code provides an <code>addSpeaker</code> function that utilizes Axios to send a <code>POST</code> request to the backend API for adding a new speaker. It handles the request, response, and error cases appropriately.</p>
<p>Now we will create the <code>CreateSpeaker.js</code> component inside <code>src/pages/Admin/Speakers</code> and add the following code:</p>
<pre class="source-code">import React, { useState } from 'react';import { addSpeaker } from
    '../../../services/SpeakersAPI'LP;
import { useNavigate } from 'react-router-dom';
const CreateSpeaker = () =&gt; {
    const [name, setName] = useState('');
{/* Rest of inputs states */}
    const [isLoading, setIsLoading] = useState(false);
    const [error, setError] = useState(null);
    const [successMessage, setSuccessMessage] =
        useState('');
    const navigate = useNavigate();
    const handleSubmit = async (event) =&gt; {
        event.preventDefault();
        setIsLoading(true);
        setError(null);
        try {
            ...
            await addSpeaker(formData);
            setIsLoading(false);
            // Reset the form fields
            setName('');
            setEmail('');
            setCompany('');
            setPosition('');
            setBio('');
            setAvatar(null);
            // Display a success message
            ...
        )}
        &lt;/div&gt;
    );
};
export default CreateSpeaker;</pre>
<p>The preceding code defines a <code>CreateSpeaker</code> component that handles the creation of a new speaker. It <a id="_idIndexMarker787"/>manages form input values, avatar file selection, loading state, error messages, and success messages. When <a id="_idIndexMarker788"/>the form is submitted, the component sends the data to the backend API and handles the response accordingly:</p>
<ul>
<li>The component imports necessary dependencies, including <code>React</code>, the <code>useState</code> hook, the <code>addSpeaker</code> function from <code>SpeakersAPI</code>, and the <code>useNavigate</code> hook from <code>react-router-dom</code>.</li>
<li>Inside the <code>CreateSpeaker</code> component, it sets up state variables using the <code>useState</code> hook to store the form input values (<code>name</code>, <code>email</code>, <code>company</code>, <code>position</code>, and <code>bio</code>), the avatar file, loading state, error message, and success message. The <code>CreateSpeaker</code> component also uses the <code>useNavigate</code> hook to handle navigation.</li>
<li>The component defines a <code>handleSubmit</code> function that is triggered when the form is submitted. It first prevents the default form submission behavior. Then, it sets the loading state to true and clears any previous error messages. Within the <code>handleSubmit</code> function, the component constructs a <code>FormData</code> object and appends the form input values and the avatar file to it.</li>
<li>The <code>addSpeaker</code> function (imported from <code>SpeakersAPI</code>) is called with the constructed <code>FormData</code> object, which sends a <code>POST</code> request to the backend API to create a new speaker.</li>
<li>If the request is successful, the loading state is set to false, and the form input values are reset. A success message is displayed, and the user is navigated to the <code>/speakers</code> page. If an error occurs during the API request, the loading state is set to false, and the error message is stored in the state.</li>
<li>The component also includes a <code>handleAvatarChange</code> function to update the avatar state variable when a file is selected in the avatar input field.</li>
<li>The component’s <a id="_idIndexMarker789"/>rendered function returns JSX elements, including a form with form <a id="_idIndexMarker790"/>inputs and a submit button. It also displays error and success messages based on the respective state variables.</li>
</ul>
<p>Now, let’s move to the next section to explore how data can be edited in a React–Flask application.</p>
<h1 id="_idParaDest-208"><a id="_idTextAnchor244"/>Editing data – the React–Flask approach</h1>
<p>In addition to displaying <a id="_idIndexMarker791"/>and adding data, it’s also important for a web application to allow the user to edit data. In this section, you will learn how to implement data editing in a React-Flask web application.</p>
<h2 id="_idParaDest-209"><a id="_idTextAnchor245"/>Editing data in Flask</h2>
<p>Now, let’s add the <a id="_idIndexMarker792"/>endpoint to handle the logic for updating the speaker <a id="_idIndexMarker793"/>data in the database. Add the following code to <code>app.py</code>:</p>
<pre class="source-code">from flask import jsonify, requestfrom werkzeug.utils import secure_filename
@app.route('/api/v1/speakers/&lt;int:speaker_id&gt;',
    methods=['PUT'])
def update_speaker(speaker_id):
    data = request.get_json()
    name = data.get('name')
    email = data.get('email')
    company = data.get('company')
    position = data.get('position')
    bio = data.get('bio')
    avatar = request.files.get('speaker_avatar')
    speaker = Speaker.query.get(speaker_id)
    if not speaker:
        return jsonify({"error": "Speaker not found"}), 404
    if not all([name, email, company, position, bio]):
        return jsonify({"error": "All fields are
            required"}), 400
    if email != speaker.email:
        existing_speaker =
            Speaker.query.filter_by(email=email).first()</pre>
<p>The preceding code <a id="_idIndexMarker794"/>defines a new route for updating a speaker’s information <a id="_idIndexMarker795"/>at the <code>/api/v1/speakers/int:speaker_id</code> endpoint that accepts a <code>PUT</code> request. The <code>@app.route</code> decorator is used to define the endpoint, and the <code>methods</code> parameter is set to <code>['PUT']</code> to specify that this route should only accept <code>PUT</code> requests. The <code>&lt;int:speaker_id&gt;</code> part of the endpoint is a path parameter, which allows the route to accept a speaker ID as part of the URL.</p>
<p>The code defines the <code>update_speaker</code> function, which takes in a <code>speaker_id</code> parameter that corresponds to the path parameter in the endpoint.</p>
<p>The code first gets the JSON payload of the request and extracts the speaker’s information from it. Then, you retrieve the speaker’s information from the database using the <code>Speaker.query.get(speaker_id)</code> method. The function queries the database to retrieve the existing speaker object based on the provided <code>speaker_id</code>. If the speaker is not found, it returns a JSON response with an error message and a status code of <code>404</code> (Not Found).</p>
<p><code>update_speaker()</code> checks whether all the required fields (<code>name</code>, <code>email</code>, <code>company</code>, <code>position</code>, and <code>bio</code>) have been provided. If any of the fields are missing, it returns a JSON response with an error message and a status code of <code>400</code> (Bad Request).</p>
<p>If there is an exception in saving the image, it will delete the previous avatar image and return an error <a id="_idIndexMarker796"/>message and status code. The <code>update_speaker</code> function <a id="_idIndexMarker797"/>then updates the speaker’s information in the database. The <code>update_speaker</code> function attempts to commit the changes to the database; if it fails, it will roll back the transaction and return an error message and status code of <code>500</code>.</p>
<p>Finally, if all goes well, the code returns the updated speaker’s information as a JSON object and a status code of <code>200</code>.</p>
<p>Next, we will create the React component to handle updating a speaker’s data.</p>
<h2 id="_idParaDest-210"><a id="_idTextAnchor246"/>Displaying the edited data in React</h2>
<p>In this section, we <a id="_idIndexMarker798"/>will provide the functionality to edit speakers’ information. To edit data in React, we can modify the component’s state with the updated values and reflect those changes in the user interface. We will start by adding the <code>UpdateSpeaker</code> component. In <code>frontend/src/pages/Admin/Speakers/UpdateSpeaker.js</code>, add the following code:</p>
<pre class="source-code">import React, { useState, useEffect } from 'react';import { updateSpeaker } from
    '../../../services/SpeakersAPI';
import { useNavigate } from 'react-router-dom';
const UpdateSpeaker = ({ speakerId }) =&gt; {
    const [name, setName] = useState('');
    const [email, setEmail] = useState('');
    const [company, setCompany] = useState('');
    const [position, setPosition] = useState('');
    const [bio, setBio] = useState('');
    const [isLoading, setIsLoading] = useState(false);
    const [error, setError] = useState(null);
    const [successMessage, setSuccessMessage] =
        useState('');
    const navigate=useNavigate();
    useEffect(() =&gt; {
        // Fetch the speaker data based on speakerId
        fetchSpeaker();
    }, [speakerId]);
    const fetchSpeaker = async () =&gt; {
        try {
            // Fetch the speaker data from the backend
                based on speakerId
            const speakerData =
                await getSpeaker(speakerId);
            setName(speakerData.name);
            setEmail(speakerData.email);
            setCompany(speakerData.company);
            setPosition(speakerData.position);
            setBio(speakerData.bio);
        } catch (error) {
            setError(error.message);
        }
    };
{/* The rest of the code snippet can be found on GitHub */}</pre>
<p>The preceding code defines a component called <code>UpdateSpeaker</code>. The component allows a user to update the information of a speaker by making a <code>PUT</code> request to the server using the <code>updateSpeaker</code> function from the <code>SpeakersAPI.js</code> file.</p>
<p>The component starts by importing <code>React</code>, <code>useState</code>, and <code>useEffect</code> from the React library and <code>updateSpeaker</code> from the <code>SpeakersAPI.js</code> module. When the form is submitted, the <code>handleSubmit</code> function is called; it calls the <code>updateSpeaker</code> function from the <code>SpeakersAPI.js</code> file and passes in <code>speakerId</code> and an <a id="_idIndexMarker799"/>object containing the updated speaker’s information. If the request is successful, it sets the success state to true and if there is an error, it sets the error state to <code>error.message</code>.</p>
<p>Now, you need to update the <code>SpeakersAPI.js</code> file in <code>src/services/SpeakersAPI.js</code> to add the <code>updateSpeaker</code> API call function:</p>
<pre class="source-code">// API function to update a speakerexport const updateSpeaker = (speakerId, speakerData) =&gt; {
    const url = `${API_URL}/speakers/${speakerId}`;
    return axios
        .put(url, speakerData, { headers: addHeaders() })
        .then((response) =&gt; response.data)
        .catch(handleErrors);
};</pre>
<p>The preceding code defines an <code>updateSpeaker</code> API function used for updating a speaker’s information on the backend:</p>
<ul>
<li>The function takes two parameters: <code>speakerId</code> (representing the ID of the speaker to be updated) and <code>speakerData</code> (an object containing the updated speaker information).</li>
<li>It constructs the URL for the API endpoint by appending <code>speakerId</code> to the base URL.</li>
<li>The function uses the Axios library to send a <code>PUT</code> request to the constructed URL, passing <code>speakerData</code> as the request payload and including the appropriate headers using the <code>addHeaders</code> function.</li>
<li>If the request is<a id="_idIndexMarker800"/> successful, it returns the response data. If an error occurs during the request, it catches the error and calls the <code>handleErrors</code> function to handle and propagate the error.</li>
</ul>
<p>Next, you will learn how to delete speaker data from the database.</p>
<h1 id="_idParaDest-211"><a id="_idTextAnchor247"/>Deleting data from a database – the React–Flask approach</h1>
<p>Deleting data from <a id="_idIndexMarker801"/>a database involves removing one or more records or rows from a table. In this section, you are going to learn how to handle delete requests in a React–Flask web application.</p>
<h2 id="_idParaDest-212"><a id="_idTextAnchor248"/>Handling delete requests in Flask</h2>
<p>Let’s create the <a id="_idIndexMarker802"/>endpoint to handle the logic for deleting <a id="_idIndexMarker803"/>speaker data from the database:</p>
<pre class="source-code">@app.route('/api/v1/speakers/&lt;int:speaker_id&gt;',    methods=['DELETE'])
def delete_speaker(speaker_id):
    speaker = Speaker.query.get_or_404(speaker_id)
    if not current_user.has_permission("delete_speaker"):
        abort(http.Forbidden("You do not have permission to
            delete this speaker"))
    events =
        Event.query.filter_by(speaker_id=speaker_id).all()
    if events:
        abort(http.Conflict("This speaker has associated
            events, please delete them first"))
    try:
        if speaker.speaker_avatar:
            speaker_avatar.delete(speaker.speaker_avatar)
        with db.session.begin():
            db.session.delete(speaker)
    except Exception:
        abort(http.InternalServerError("Error while
            deleting speaker"))
    return jsonify({"message": "Speaker deleted
        successfully"}), http.OK</pre>
<p>The preceding <a id="_idIndexMarker804"/>code defines an API route for deleting a speaker, performs <a id="_idIndexMarker805"/>the necessary checks, deletes the speaker from the database, handles errors, and returns an appropriate response.</p>
<p>Next, we will explore the React component for handling delete requests from the frontend.</p>
<h2 id="_idParaDest-213"><a id="_idTextAnchor249"/>Handling delete requests in React</h2>
<p>When building a React application, you can handle a delete request to remove a speaker resource by creating <a id="_idIndexMarker806"/>a component that interacts with the backend API. This <a id="_idIndexMarker807"/>component will send the delete request to the appropriate endpoint, handle any potential errors, and update the component’s state accordingly to reflect the deletion of the speaker resource.</p>
<p>Let’s start by creating a <code>DeleteSpeaker</code> component. In <code>frontend/src/pages/Admin/Speakers/DeleteSpeaker.js</code>, add the following code:</p>
<pre class="source-code">import React, { useState, useEffect } from "react";import { useParams, useNavigate } from "react-router-dom";
import { deleteSpeaker } from "./api/SpeakersAPI";
const DeleteSpeaker = () =&gt; {
    const { speakerId } = useParams();
    const navigate = useNavigate();
    const [error, setError] = useState("");
    const [isLoading, setIsLoading] = useState(false);
    const handleDelete = async () =&gt; {
        try {
            setIsLoading(true);
            await deleteSpeaker(speakerId);
            setIsLoading(false);
            navigate("/speakers"); // Redirect to speakers
                                      list after successful
                                      deletion
        } catch (err) {
            setIsLoading(false);
            setError("Failed to delete speaker.");
        }
    };
    useEffect(() =&gt; {
        return () =&gt; {
            // Clear error message on component unmount
            setError("");
        };
    }, []);
    return (
        &lt;div&gt;
            {error &amp;&amp; &lt;p className="error"&gt;{error}&lt;/p&gt;}
            &lt;p&gt;Are you sure you want to delete this
                speaker?&lt;/p&gt;
            &lt;button onClick={handleDelete}
                disabled={isLoading}&gt;
                {isLoading ? "Deleting..." : "Delete
                Speaker"}
            &lt;/button&gt;
        &lt;/div&gt;
    );
};
export default DeleteSpeaker;</pre>
<p>The preceding code defines a component that allows users to delete a speaker by <code>id</code>. The component starts by importing the <code>useParams</code> and <code>useNavigate</code> hooks from <code>react-router-dom</code> to extract the <code>speakerId</code> value from the URL. It also imports the <code>deleteSpeaker</code> function from <code>src/services/SpeakersAPI.js</code> to handle the deletion of the speaker with an API call on the backend. The component then uses the <code>useState</code> hook to initialize two state variables: <code>error</code> and <code>success</code>.</p>
<p>The component has a single button that, when clicked, triggers the <code>handleDelete</code> function. This function<a id="_idIndexMarker808"/> prevents the default form submission behavior <a id="_idIndexMarker809"/>and then calls the <code>deleteSpeaker</code> function passing in <code>speakerId</code> as an argument. If the deletion is successful, it sets the success state to true; otherwise, it sets the error state to the error message returned from the API. The component then renders a message to indicate whether the deletion was successful or there was an error.</p>
<p>Now, you need to update the <code>SpeakersAPI.js</code> file in <code>src/api/SpeakersAPI.js</code> to add the <code>deleteSpeaker</code> API call function:</p>
<pre class="source-code">// API function to delete a speakerexport const deleteSpeaker = async (speakerId) =&gt; {
    const url = `/api/v1/speakers/${speakerId}`;
    try {
        const speakerResponse = await axios.get(url);
        const speaker = speakerResponse.data;
        if (!speaker) {
            throw new Error("Speaker not found");
        }
      const eventsResponse = await
          axios.get(`/api/v1/events?speakerId=${speakerId}`
          );
      const events = eventsResponse.data;
      if (events.length &gt; 0) {
        throw new Error("This speaker has associated
            events, please delete them first");
      }
      await axios.delete(url);
      return speaker;
    } catch (err) {
        if (err.response) {
            const { status, data } = err.response;
            throw new Error(`${status}: ${data.error}`);
        } else if (err.request) {
            throw new Error('Error: No response received
                from server');
        } else {
            throw new Error(err.message);
        }
    }
};</pre>
<p>The preceding <a id="_idIndexMarker810"/>code defines a <code>deleteSpeaker</code> function that takes <a id="_idIndexMarker811"/>in a <code>speakerId</code> as its parameter. The function uses the Axios library to make HTTP requests to the server. The function starts by trying to get the speaker details from the server by making a <code>GET</code> request to the <code>/</code><code>api/v1/speakers/{speakerId}</code> endpoint.</p>
<p>It then checks whether the speaker exists. If the speaker doesn’t exist, the function throws an error with the message <code>GET</code> request to the <code>/api/v1/events?speakerId=${speakerId}</code> endpoint to get a list of events associated with the speaker. It then checks whether the length of events is greater than <code>0</code>. If so, it throws an error with the message, <strong class="bold">This speaker has associated events, please delete </strong><strong class="bold">them first</strong>.</p>
<p>Finally, the function makes a <code>DELETE</code> request to the <code>/api/v1/speakers/{speakerId}</code> endpoint to delete the speaker. If there’s an error during the<a id="_idIndexMarker812"/> process, the function checks the error and throws an appropriate error message. The function then exports the <code>deleteSpeaker</code> function so it can be <a id="_idIndexMarker813"/> imported and used in other parts of the application.</p>
<p>Next, we will discuss how pagination can be handled in the React–Flask application.</p>
<h1 id="_idParaDest-214"><a id="_idTextAnchor250"/>Managing pagination in a React–Flask application</h1>
<p>When working with a large dataset, it’s important to implement pagination to make the large dataset <a id="_idIndexMarker814"/>more manageable for the user. Pagination is a technique used to divide a large set of data into smaller, more manageable <a id="_idIndexMarker815"/>chunks called <strong class="bold">pages</strong>. Each page contains a subset of the <a id="_idIndexMarker816"/>total data, allowing users to navigate through the data in a controlled manner.</p>
<p>Pagination provides a way to present large datasets efficiently, improves performance, and enhances the user experience by making data more accessible. In this section, you will learn how to implement pagination in a React–Flask web application. To implement pagination, you will need to make some changes to the backend server to handle pagination requests.</p>
<p>You can use the Flask-SQLAlchemy library to handle pagination on the backend. On the Flask backend, you can implement pagination for the <code>speaker</code> model using the Flask-SQLAlchemy library’s pagination feature. Let’s delve into how you can implement pagination for the <code>Speaker</code> model.</p>
<p>Update <code>get_speakers()</code> with the following code in the <code>app.py</code> file:</p>
<pre class="source-code">from flask_sqlalchemy import Pagination@app.route('/api/v1/speakers', methods=['GET'])
def get_speakers():
    page = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', 10, type=int)
    speakers = Speaker.query.paginate(page, per_page,
        False)
    if not speakers.items:
        return jsonify({"error": "No speakers found"}), 404
    return jsonify({
        'speakers': [speaker.serialize() for speaker in
            speakers.items],
        'total_pages': speakers.pages,
        'total_items': speakers.total
    }), 200</pre>
<p>In the preceding code, we are using the <code>paginate()</code> method from Flask-SQLAlchemy to add the pagination functionality to the speakers’ collection. The <code>page</code> and <code>per_page</code> arguments are passed in as query parameters in the <code>GET</code> request. The default value for <code>page</code> is <code>1</code> and <code>per_page</code> is <code>10</code>.</p>
<p>For the React <a id="_idIndexMarker817"/>frontend, you can use the <code>useState</code> and <code>useEffect</code> hooks <a id="_idIndexMarker818"/>to handle pagination in a functional component.</p>
<p>Let’s modify the <code>ViewSpeakers</code> components and add pagination functionality to the component:</p>
<pre class="source-code">import React, { useState, useEffect } from 'react';import { getSpeakers } from
    '../../../services/SpeakersAPI';
const ViewSpeakers = () =&gt; {
    const [speakers, setSpeakers] = useState([]);
    const [currentPage, setCurrentPage] = useState(1);
    const [speakersPerPage] = useState(10);
    const [isLoading, setIsLoading] = useState(false);
    const [error, setError] = useState(null);
    useEffect(() =&gt; {
        fetchSpeakers();
    }, []);
};
export default ViewSpeakers;</pre>
<p>The preceding code defines a component that displays a list of speakers using pagination. The component makes use of React hooks to manage its state. The <code>speakers</code> state variable is used to store the list of speakers, and the <code>page</code> and <code>perPage</code> state variables are used to store the current page number and the number of items to be displayed per page, respectively.</p>
<p>The <code>useEffect</code> hook is used to fetch the speakers from the server when the component is mounted and <a id="_idIndexMarker819"/>whenever the <code>page</code> or <code>perPage</code> state variables change. The <code>fetchSpeakers</code> function uses the Axios <a id="_idIndexMarker820"/>library to make a <code>GET</code> request to the <code>'/api/v1/speakers?page=${page}&amp;per_page=${perPage}'</code> endpoint, passing in the current page number and the number of items per page as query parameters.</p>
<p>The response data is then stored in the <code>speakers</code> state variable. The <code>ViewSpeakers</code> component then maps through the speakers’ array and displays the name and email of each speaker. The component also includes two buttons, one for navigating to the <a id="_idIndexMarker821"/>previous page and one for navigating <a id="_idIndexMarker822"/>to the next page.</p>
<p>The <code>onClick</code> handlers of these buttons update the page state variable accordingly, and the <code>1</code> to prevent the user from navigating to a non-existent previous page.</p>
<h1 id="_idParaDest-215"><a id="_idTextAnchor251"/>Summary</h1>
<p>In this chapter, we discussed in detail how you can fetch and display data in a React–Flask web application. We examined one of the ways fetching and displaying data is handled. You were able to work from the backend in defining the <code>Speaker</code> model class and implement various endpoints to handle data fetching from the database, and adding, updating, and deleting data on it.</p>
<p>We used the Axios library to send a request to the Flask backend, which then retrieved the data from a database and returned it to the frontend in a response. The React frontend then processed the response and displayed the data to the end user. Lastly, we implemented pagination as a way to present large datasets efficiently and to improve the performance of React–Flack web application projects.</p>
<p>Next, we are going to discuss authentication and authorization in a React–Flask application and examine the best practices to ensure that your application is secure and ready for production.</p>
</div>
</body></html>