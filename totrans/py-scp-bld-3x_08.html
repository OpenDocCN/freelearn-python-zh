<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-199"><a id="_idTextAnchor206"/>8</h1>
<h1 id="_idParaDest-200"><a id="_idTextAnchor207"/>Animation Modifiers</h1>
<p>Animation curves, or F-Curves, can be altered by modifiers without having their keyframes changed. This way, cinematic or motion effects can replace the initial curve completely or add to its original value.</p>
<p>The output of a modifier can be the input of another modifier, which, when combined, allows us to build complex results on top of simple animations.</p>
<p>Python scripts can be used to help automate this and streamline the workflow.</p>
<p>Changing a parameter affects the modifier’s result, while its overall <strong class="bold">Influence </strong>can be reduced using the slider in the modifier interface.</p>
<p>In this chapter, you will learn how to add modifiers to animation F-Curves with your scripts and how to change their parameters.</p>
<p>This chapter will cover the following topics:</p>
<ul>
<li>Understanding F-Curve Modifiers in the Blender UI</li>
<li>Adding F-Curve Modifiers via Python</li>
<li>Using F-Curve Modifiers in our add-ons</li>
</ul>
<h1 id="_idParaDest-201"><a id="_idTextAnchor208"/>Technical requirements</h1>
<p>We will use Blender and Visual Studio Code in this chapter. The examples created in this chapter can be found at <a href="https://github.com/PacktPublishing/Python-Scripting-in-Blender/tree/main/ch8">https://github.com/PacktPublishing/Python-Scripting-in-Blender/tree/main/ch8</a>.</p>
<h1 id="_idParaDest-202"><a id="_idTextAnchor209"/>Using F-Curve Modifiers</h1>
<p>Modifiers for <a id="_idIndexMarker565"/>animation curves, called <strong class="bold">F-Curve Modifiers</strong> or <strong class="bold">F-Modifiers</strong>, add <a id="_idIndexMarker566"/>non-destructive changes to animations <a id="_idIndexMarker567"/>while preserving their original data. We examined similar functionality in <strong class="bold">Object Constraints</strong> in <a href="B18375_04.xhtml#_idTextAnchor075"><em class="italic">Chapter 4</em></a>, where we learned how to affect an object’s position without changing the values stored in its channels.</p>
<p>Like object <a id="_idIndexMarker568"/>constraints, F-Modifiers are exposed to Python scripts through a collection property.</p>
<p>Before we delve into how F-Modifiers are scripted, we will have a look at how to create them in the <strong class="bold">Graph Editor</strong>.</p>
<h2 id="_idParaDest-203"><a id="_idTextAnchor210"/>Adding F-Curve Modifiers in the Graph Editor</h2>
<p>We will now <a id="_idIndexMarker569"/>look at how to add variation <a id="_idIndexMarker570"/>to an animated object using F-Curve Modifiers.</p>
<p>For this example, we will use the <code>ani_loop.blend</code> scene, from the accompanying <code>PythonScriptingBlender/ch8/_scenes_</code> folder, but you can use any scene.</p>
<p>The animation along the <em class="italic">8</em>-shaped path in <code>ani_loop.blend</code> wasn’t created by hand: it was generated using the <strong class="bold">Vert Runner</strong> add-on developed in <a href="B18375_07.xhtml#_idTextAnchor171"><em class="italic">Chapter 7</em></a>.</p>
<p>We will add some variation to the path of an animated object by creating an F-Curve Modifier in <strong class="bold">Graph Editor</strong>:</p>
<ol>
<li>Select an animated object.</li>
<li>Change one of the UI areas to <strong class="bold">Graph Editor</strong>. A good place is the left Viewport in the <strong class="bold">Animation Workspace</strong>.</li>
<li>In the <strong class="bold">Graph Editor</strong> left panel, select the <strong class="bold">X </strong><strong class="bold">Location</strong> channel.</li>
<li>Press <em class="italic">N</em> to display the property tabs. Make sure that the <strong class="bold">Graph Editor</strong> has focus and is large enough, or the tabs will not show up.</li>
<li>In the right panel of the<strong class="bold"> Graph Editor</strong>, select the <strong class="bold">Modifiers</strong> tab.</li>
<li>From the <strong class="bold">Modifiers</strong> tab, select a modifier from the <strong class="bold">Add Modifier</strong> menu. In this example, we will use the <strong class="bold">Stepped </strong><strong class="bold">Interpolation </strong>modifier.</li>
</ol>
<div><div><img alt="Figure 8.1: Adding curve modifiers in the Graph Editor" height="516" src="img/Figure_8.01_B18375.jpg" width="1096"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.1: Adding curve modifiers in the Graph Editor</p>
<p>The animation <a id="_idIndexMarker571"/>curve for <strong class="bold">Z Location</strong> changes <a id="_idIndexMarker572"/>to a stepped graph. If we play the animation now, we will see the object proceeding in little jumps rather than smoothly, as before.</p>
<div><div><img alt="Figure 8.2: Stepped modifier applied on a smooth curve" height="516" src="img/Figure_8.02_B18375.jpg" width="1096"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.2: Stepped modifier applied on a smooth curve</p>
<p>The Blender manual describes modifiers in detail on the <strong class="bold">F-Curve </strong><strong class="bold">Modifiers</strong> page:</p>
<p><a href="https://docs.blender.org/manual/en/3.2/editors/graph_editor/fcurves/modifiers.xhtml%0D">docs.blender.org/manual/en/3.2/editors/graph_editor/fcurves/modifiers.xhtml</a></p>
<p>There are seven available types. The first two generate curves based on mathematical formulas:</p>
<ul>
<li><strong class="bold">Generator</strong>: Expressions for lines, parabolas, and curves of higher degrees</li>
<li><strong class="bold">Built-in</strong>: Trigonometric and logarithmic formulas</li>
</ul>
<p>The other five cover some basic animation tasks:</p>
<ul>
<li><strong class="bold">Envelope</strong>: Control points for editing the overall shape of the curve</li>
<li><strong class="bold">Cyclic</strong>: To repeat animations in loops after their last frame</li>
<li><strong class="bold">Noise</strong>: Adds random jitter to the animation</li>
<li><strong class="bold">Limits</strong>: Limits the animation values to a range</li>
<li><strong class="bold">Stepped Interpolation</strong>: Converts smooth animation to jerky motion</li>
</ul>
<p>Like constraints, modifiers <a id="_idIndexMarker573"/>of an F-Curve are exposed <a id="_idIndexMarker574"/>to Python as a collection. We can use the <code>fcurve.modifiers.new</code> method to add new modifiers via scripting.</p>
<h2 id="_idParaDest-204"><a id="_idTextAnchor211"/>Adding F-Curve Modifiers in Python</h2>
<p>The <code>fcurve.modifiers.new(type)</code> method creates a new modifier according to the type <a id="_idIndexMarker575"/>provided in the argument. It returns the new modifier.</p>
<p>With the <a id="_idIndexMarker576"/>exception of <code>FNGENERATOR</code> and <code>STEPPED</code>, modifiers of a given type are created using the type name in uppercase letters:</p>
<pre class="source-code">
type <a id="_idTextAnchor212"/>(enum in ['GENERATOR', 'FNGENERATOR', 'ENVELOPE', 'CYCLES', 'NOISE', 'LIMITS', 'STEPPED'])</pre>
<p>So, to add a <code>'STEPPED'</code> modifier to the <code>2</code>), we use the following:</p>
<pre class="source-code">
&gt;&gt;&gt; import bpy
&gt;&gt;&gt; anim_data = bpy.context.object.animation_data
&gt;&gt;&gt; m = anim_data.action.fcurves[<strong class="bold">2</strong>].modifiers.<strong class="bold">new</strong>('STEPPED')</pre>
<p>Likewise, a modifier can be removed using the <code>fcurve.modifiers.remove</code> method. This time, the Python instance of the modifier must be used as an argument:</p>
<pre class="source-code">
&gt;&gt;&gt; anim_data.action.fcurves[2].modifiers.remove(m)</pre>
<p>Now that <a id="_idIndexMarker577"/>we have learned where F-Modifiers can <a id="_idIndexMarker578"/>be found, how they work, and how to add more of them, both in the user interface and the Python Console, we can use this knowledge in our scripts.</p>
<p>The add-on we will write in the next section allows us to create shaky animations using F-Modifiers.</p>
<h1 id="_idParaDest-205"><a id="_idTextAnchor213"/>Writing the Shaker add-on</h1>
<p>The <strong class="bold">Shaker</strong> add-on <a id="_idIndexMarker579"/>creates a shaky effect on the active object by adding noise modifiers to its animation curves.</p>
<p>There are cases when we want to add some shaking to a motion. For instance, directors often use a <em class="italic">camera shake</em> to suggest an object being bumped or hit. Another use case is the bumpy motion of a vehicle, or hairs and feathers in a windy environment. The Python script we are going to write will contain an operator and a menu function for quick execution.</p>
<h2 id="_idParaDest-206"><a id="_idTextAnchor214"/>Setting up the environment</h2>
<p>We first create <a id="_idIndexMarker580"/>a Python script for our add-on:</p>
<ol>
<li>Create the <code>PythonScriptingBlender/ch8/addons</code> folder. We can use the file manager or the <strong class="bold">File</strong> tab of our code editor, such as <strong class="bold">VS Code</strong>.</li>
<li>Create a new file in that folder and name it <code>object_shaker.py</code>. We can use the file manager or the <strong class="bold">New File</strong> button of our code editor.</li>
<li>Open the file in your editor of choice.</li>
<li>Set the <code>PythonScriptingBlender/ch8</code> in the Blender <strong class="bold">File </strong><strong class="bold">Paths</strong> preferences.</li>
</ol>
<p>Now, we will start writing the add-on code as usual.</p>
<h2 id="_idParaDest-207"><a id="_idTextAnchor215"/>Writing the Shaker add-on info</h2>
<p>We will add <a id="_idIndexMarker581"/>our new operator, <code>location</code> attribute of the add-on info:</p>
<pre class="source-code">
bl_info = {
    "name": "<code>Object Shaker</code>",
    "author": "Packt Man",
    "version": (1, 0),
    "blender": (3, 00, 0),
    "description": "Add Shaky motion to active object",
    "location": "<code>Object Right Click -&gt; Add Object Shake</code>",
    "category": "Learning",
}</pre>
<h2 id="_idParaDest-208"><a id="_idTextAnchor216"/>Writing the Add Object Shake operator class</h2>
<p>We import <a id="_idIndexMarker582"/>the <code>bpy</code> module, then write the <code>bl_*</code> identifiers of <code>Object Shaker</code>:</p>
<pre class="source-code">
import bpy
class <code>ObjectShaker</code>(bpy.types.Operator):
    """Set Playback range to current action Start/End"""
    bl_idname = "object.shaker_animation"
    bl_label = "Add Object Shake"
    bl_description = "Add Shake Motion to Active Object"
    bl_options = {'REGISTER', 'UNDO'}</pre>
<p>This operator needs two float parameters:</p>
<ul>
<li>Noise <code>duration</code> in seconds</li>
<li>Noise <code>strength</code>, that is, how much this modifier contributes to the animation</li>
</ul>
<p><code>duration</code> should be a positive number: there is no such thing as a negative amount of time. So, we set <code>0.0</code> as the property minimum. The amount of shaking, on the other hand, could <a id="_idIndexMarker583"/>benefit from values below <code>0.0</code> or above <code>1.0</code>. It’s a more peculiar circumstance in which we still want to set the range of values from <code>0.0</code> to <code>1.0</code> as the ordinary condition, but we don’t want to prevent the user from going beyond those limits if they want to. We can set limits that apply to the slider but accept an out-of-range numerical input using the <code>soft_min</code> and <code>soft_max</code> parameters.</p>
<h3>Adding limits and soft limits to properties</h3>
<p>Normally, the influence, or <code>strength</code>, of the modifier, should range between <code>0.0</code> and <code>1.0</code> (meaning no influence and full influence, respectively) but using values outside that range has <a id="_idIndexMarker584"/>a multiplicative effect. For instance, an influence of <code>2.0</code> doubles the modifier’s contribution.</p>
<p>Soft limits for Blender properties are useful in this case: <code>min</code>, <code>max</code>, <code>soft_min</code>, and <code>soft_max</code> limit the range of the slider in the interface, but while <code>min</code> and <code>max</code> never accept any number exceeding their range, <code>soft_min</code> and <code>soft_max</code> allow the user to click on the slider and type any value they wish using the keyboard.</p>
<p>Values exceeding the initial <code>soft_min</code> and <code>soft_max</code> parameters are considered valid input and become the new range of the slider:</p>
<pre class="source-code">
    duration: bpy.props.FloatProperty(default=1.0, <code>min=0</code>)
    strenght: bpy.props.FloatProperty(default=1.0,
                                      <code>soft_min=0</code>,
                                      <code>soft_max=1.0</code>)</pre>
<p>Now, we can write the <code>poll</code> method for verifying the conditions and the <code>execute</code> method to perform the action of adding noise.</p>
<h2 id="_idParaDest-209"><a id="_idTextAnchor217"/>Writing the operator methods</h2>
<p>Besides the <a id="_idIndexMarker585"/>usual <code>poll</code> and <code>execute</code> methods, we will write a utility function for finding the F-Curve of a given property.</p>
<h3>Writing the poll method</h3>
<p>The condition <a id="_idIndexMarker586"/>for the <code>poll</code> method is very simple – the operator can be invoked if there is an active object:</p>
<pre class="source-code">
    @classmethod
    def poll(cls, context):
        return bool(context.object)</pre>
<p>We need an <a id="_idIndexMarker587"/>animated property to add a noise modifier. If it is already animated, we pick the existing animation curve, otherwise, we create a new one. This operation can be implemented as a separate function, named <code>get_fcurve</code>, which takes <code>data_path</code> as an argument and returns its animation curve. It creates a new curve if it doesn’t exist yet.</p>
<h3>Writing the get_fcurve method</h3>
<p>We delegate <a id="_idIndexMarker588"/>the task of finding or creating a property animation curve to the <code>get_fcurve</code> function. Since it will be <a id="_idIndexMarker589"/>used by the <code>ObjectShaker</code> operator alone, we write it as a class method, with <code>self</code> as its first argument. We might want to use it on more than one property and object, so we also pass the object to inspect and <code>data_path</code> of the property to animate. In case of vector properties, we pass the <code>index</code> component as well. We use <code>obj</code> rather than <code>object</code> as a parameter name because the latter represents the Python basic class, a term we don’t want to override.</p>
<p>We know from <a href="B18375_07.xhtml#_idTextAnchor171"><em class="italic">Chapter 7</em></a>, that F-Curves belong to an action, and our operator adds noise to the current action, so this function will look for the <code>action</code> attribute of the object’s animation data. Before we run <code>get_fcurve</code>, we should make sure that such an action exists, so, in line with the <em class="italic">Defensive Programming</em> practice learned in <a href="B18375_06.xhtml#_idTextAnchor129"><em class="italic">Chapter 6</em></a>, we use <code>assert</code> to halt the script if, for unforeseen reasons, no current action is found:</p>
<pre class="source-code">
    def get_fcurve(self, <code>obj</code>, <code>data_path</code>, <code>index</code>):
        """Returns F-Curve of given data_path/index"""
        action = obj.animation_data.action
        <code>assert action</code></pre>
<p>Now we <a id="_idIndexMarker590"/>need to return the F-Curve that animates the <code>data_path</code> instance provided as an argument, and create <a id="_idIndexMarker591"/>it if it doesn’t exist. We can attempt its creation using <code>try</code>, a statement learned in the <em class="italic">Improving our code</em> section of <a href="B18375_03.xhtml#_idTextAnchor049"><em class="italic">Chapter 3</em></a>.</p>
<p>Trying to create two F-Curves with the same path causes a <code>RuntimeError</code> error, which, in a <code>try</code> statement, triggers the <code>except</code> clause. By looking for existing curves only if we need to, our code will be leaner and slightly faster.</p>
<p>Under the <code>except</code> statement, we use the <code>next</code> function on a conditional <em class="italic">iterator</em>, that is, a sequence of objects that satisfy our criteria, in this case, a matching <code>data_path</code> and <code>index</code>:</p>
<pre class="source-code">
        <code>try</code>:
            crv = action.fcurves.new(data_path,index=index)
        <code>except RuntimeError</code>:
            crv = <code>next</code>(fc for fc in action.fcurves
                       if fc.data_path == <code>data_path</code> and
                          fc.array_index == <code>index</code>)</pre>
<p>In either case, we will end up with the <code>crv</code> variable containing the F-Curve we are looking for. We could have used a <code>for</code> loop to iterate <code>action.fcurves</code>, but the <code>next</code> function provides a valid and compact alternative.</p>
<h4>Scrolling through collections efficiently</h4>
<p>The <code>next</code> function <a id="_idIndexMarker592"/>returns the first valid element of a sequence. For example, typing <code>next(action.fcurves)</code> simply gives the first curve of an action. The argument of <code>next</code> can be any iterator, though, not just a list or a collection. Since iterators can contain conditional statements such as <code>if</code>, <code>next</code> can be a concise and performant alternative to <code>for</code> loops.</p>
<p>While <code>fc for fc in action.fcurves</code> scrolls all the elements of <code>fcurves</code>, the conditions on <code>fc.data_path</code> and <code>fc.array_index</code> ensure that the first curve that complies with those requirements is returned.</p>
<p>If no curve <a id="_idIndexMarker593"/>is found, <code>next</code> fails with a <code>StopIteration</code> error, but we know that it will not happen: an existing curve brought us to the <code>except</code> block of this <code>try</code> statement in the first place. So, either under the <code>try</code> block or under <code>except</code>, the <code>crv</code> variable now contains the F-Curve we are looking for. Before we add a modifier to it, we must make sure that it contains at least one keyframe.</p>
<h4>Ensuring the presence of keyframes</h4>
<p>At this point, we have stored an animation curve in the <code>crv</code> variable, but we must look for its keyframe points, or it will not be evaluated. If the <code>keyframe_points</code> collection is empty, we add <a id="_idIndexMarker594"/>keyframes to it by using <code>keyframe_points.insert</code>. We will use the current frame and value as arguments:</p>
<pre class="source-code">
        if <code>not</code> crv.<code>keyframe_points</code>:
            crv.keyframe_points.<code>insert</code>(
                         frame=context.scene.<code>frame_current</code>,
                         value=<code>getattr</code>(obj,
                                       <code>data_path</code>)<code>[index]</code>)</pre>
<p>Now that we have an animation curve and it is guaranteed to support modifiers, we can return the <code>crv</code> variable and exit the <code>get_fcurve</code> function:</p>
<pre class="source-code">
        return crv</pre>
<p>This function will be called in the <code>execute</code> method, the last missing piece of the operator.</p>
<h3>Writing the execute method</h3>
<p>If our object <a id="_idIndexMarker595"/>has not been animated yet, we create new <code>animation_data</code>, otherwise, we <a id="_idIndexMarker596"/>store the existing data in the <code>anim</code> variable:</p>
<pre class="source-code">
    def execute(self, context):
        <code>if not</code> context.object.animation_data:
            anim = context.object.animation_data_create()
        <code>else</code>:
            anim = context.object.animation_data</pre>
<p>Likewise, we <a id="_idIndexMarker597"/>should create a <a id="_idIndexMarker598"/>new action if there isn’t one yet or get the current one. In either case, it is going to be stored in the <code>action</code> variable:</p>
<pre class="source-code">
        if not anim.action:
            action = bpy.data.actions.new('ShakeMotion')
            anim.action = action
        else:
            action = anim_data.action</pre>
<p>Now, it’s finally time to add some shaking motion. First, we need to express the duration of the effect in frames, rather than seconds. To do that, we multiply the <code>duration</code> parameter by the frames-per-second of the scene. Once we have the duration in frames, we divide it by half to center the object shake around the current frame; half of the frames will be played before it, while the second half will be played afterward:</p>
<pre class="source-code">
        fps = context.scene.render.fps
        duration_frames = <code>self.duration * fps / 2</code>
        current = context.scene.frame_current
        start = current – duration_frames
        end = current + duration_frames</pre>
<p>The next step is looking for the animation curves that we want to alter: <code>location</code> Z, <code>rotation_euler</code> X, and <code>rotation_euler</code> Y. We need these ones specifically as they represent the up-down shake, yaw shake, and pitch shake of a camera, respectively.</p>
<p>If they don’t exist, our <code>get_fcurve</code> method creates and returns them:</p>
<pre class="source-code">
        <code>z</code>_loc_crv = self.<code>get_fcurve</code>(context,
                                    'location',
                                    index=<code>2</code>)
        <code>x</code>_rot_crv = self.<code>get_fcurve</code>(context,
                                    'rotation_euler',
                                    index=<code>0</code>)
        <code>y</code>_rot_crv = self.<code>get_fcurve</code>(context,
                                    'rotation_euler',
                                    index=<code>1</code>)</pre>
<p>Since F-Modifiers are specific to each curve, we create a <code>NOISE</code> modifier for each of them. We <a id="_idIndexMarker599"/>use a <code>for</code> loop to create all three at once. The noise <code>strength</code> value, a float attribute, can be set directly from the <code>strength</code> parameter <a id="_idIndexMarker600"/>of the operator, while we computed the <code>start</code> and <code>end</code> values for the noise earlier:</p>
<pre class="source-code">
        <code>for crv</code> in z_loc_crv, y_rot_crv, x_rot_crv:
            noise = crv.modifiers.new(<code>'NOISE'</code>)
            noise.<code>strength</code> = self.<code>strenght</code>
            noise.<code>use_restricted_range</code> = True
            noise.frame_start = start
            noise.frame_end = end
        return {'FINISHED'}</pre>
<p>We have turned <code>use_restricted_range</code> on to limit the noise in our <code>start</code> and <code>end</code> frames: the <code>frame_start</code> and <code>frame_end</code> attributes would have no effect otherwise. Once we have set F-Modifiers for the three curves, we can finally exit the method.</p>
<p>Now that our operator is complete, we can add a menu item to the interface and the <code>register</code>/<code>unregister</code> functions.</p>
<h2 id="_idParaDest-210"><a id="_idTextAnchor218"/>Adding menu items</h2>
<p>As we learned <a id="_idIndexMarker601"/>when writing interfaces, a menu function takes <code>self</code> and <code>context</code> as arguments.</p>
<p>Inside the menu function, we add a separator and the <code>ObjectShaker</code> operator to <code>self.layout</code>:</p>
<pre class="source-code">
def m_items(self, context):
    self.layout.separator()
    <code>self.layout.operator</code>(ObjectShaker.<code>bl_idname</code>)</pre>
<p>This function can then be added to any menu, but since our operator affects the animation of object transforms, we can use the right-click menu displayed by the Viewport in <strong class="bold">Object Mode</strong>.</p>
<h2 id="_idParaDest-211"><a id="_idTextAnchor219"/>Finding the class names of context menus</h2>
<p>The API <a id="_idIndexMarker602"/>documentation doesn’t contain a list of all menus. We can look for them in <code>bpy.types</code>, which contains all the Blender classes, and keep in mind that the class name we are looking for starts with <code>VIEW3D_MT</code> and ends with <code>_context_menu</code>.</p>
<p>We can use these criteria in a <em class="italic">list comprehension</em>, that is, a list-like object delimited by square brackets that, like the <code>next</code> function we have met earlier in this section, is built with a conditional iterator. We can run it in Blender’s <strong class="bold">Python Console</strong>:</p>
<pre class="source-code">
&gt;&gt;&gt; [c for c in dir(bpy.types) if
     c.endswith('context_menu')]</pre>
<p>Among the listed context menus, we find <code>VIEW3D_MT_object_context_menu</code>:</p>
<pre class="source-code">
['ASSETBROWSER_MT_context_menu',
...
['VIEW3D_MT_edit_metaball_context_menu', 'VIEW3D_MT_gpencil_edit_context_menu', 'VIEW3D_MT_object_context_menu', 'VIEW3D_MT_particle_context_menu',
...</pre>
<p>In returning the results that match the <code>context_menu</code> suffix, our list comprehension acted <a id="_idIndexMarker603"/>almost like a small search engine. To filter the result even further, we can add an <code>"object"</code> string as a requirement to filter the output to one result:</p>
<pre class="source-code">
[c for c in dir(bpy.types)if c.endswith('context_menu')
                          and 'object' in c]</pre>
<p>This list comprehension narrows the results down to the object context menu only:</p>
<pre class="source-code">
&gt;&gt;&gt; [c for c in dir(bpy.types)if c.endswith('context_menu')
...                           and 'object' in c]
['VIEW3D_MT_object_context_menu']</pre>
<p>Now that we know which menu class to use, we can move to registering the add-on.</p>
<h2 id="_idParaDest-212"><a id="_idTextAnchor220"/>Registering the Shaker add-on</h2>
<p>Enabling the <a id="_idIndexMarker604"/>add-on produces these two results:</p>
<ul>
<li>Adds the <code>ObjectShaker</code> class to Blender</li>
<li>Adds the <code>m_items</code> function to the object right-click menu</li>
</ul>
<p>Each of those tasks happen in the <code>register</code> function:</p>
<pre class="source-code">
def register():
    bpy.utils.register_class(<code>ObjectShaker</code>)
    bpy.types.<code>VIEW3D_MT_object_context_menu</code>.append(m_items)</pre>
<p>Following the same logic, when the add-on is disabled, its code is purged from Blender, upon which <code>m_items</code> should be removed from the menu and <code>ObjectShaker</code> from the registered classes. Failing to do so would leave orphan entities in Blender. The <code>unregister</code> function takes care of that:</p>
<pre class="source-code">
def unregister():
    bpy.types.VIEW3D_MT_object_context_menu.remove(m_items)
    bpy.utils.unregister_class(ObjectShaker)</pre>
<p>We can refresh <a id="_idIndexMarker605"/>the add-ons using the <strong class="bold">Refresh</strong> button in the <strong class="bold">Add-ons</strong> preferences and enable <strong class="bold">Object Shaker</strong> from the <strong class="bold">Learning</strong> category. When the add-on is enabled, the <strong class="bold">Add Object Shake</strong> option appears in the given object’s right-click menu.</p>
<h2 id="_idParaDest-213"><a id="_idTextAnchor221"/>Using the Shaker add-on</h2>
<p>Using our <a id="_idIndexMarker606"/>add-on, we can add a shaking motion to any object by following these steps:</p>
<ol>
<li>Make the object active.</li>
<li>Right-click (or press <code>W</code> if <strong class="bold">Select with Mouse Button</strong> was set to<a id="_idTextAnchor222"/> <strong class="bold">Right</strong> in <strong class="bold">Preferences</strong> | <strong class="bold">Keymap</strong>).</li>
<li>Select <strong class="bold">Add Object Shake</strong> from the menu.</li>
<li>Adjust the <strong class="bold">duration</strong> and <strong class="bold">strength</strong> values in the <strong class="bold">Execution </strong>panel.</li>
</ol>
<p>Like with the <em class="italic">Action Range add-on</em> from <a href="B18375_07.xhtml#_idTextAnchor171"><em class="italic">Chapter 7</em></a>, the selected amount of <strong class="bold">duration</strong> and <a id="_idTextAnchor223"/><strong class="bold">strength</strong> can be changed after execution using <strong class="bold">Edit</strong> | <strong class="bold">Adjust Last Operation</strong> from the top bar.</p>
<p>We have created a tool that adds a procedural behavior to an object using animation modifiers. This is a valuable shortcut when animating with Python. Moreover, it introduces us to the concept of a non-destructive modifier, that is, adding parametric changes that can be removed or edited at will.</p>
<h1 id="_idParaDest-214"><a id="_idTextAnchor224"/>Summary</h1>
<p>We have learned how to create animation effects for our scenes and have seen how we can convert an idea into a procedural tool. Artists and technical animators can come up with convoluted conceptual configurations, which we can turn into quick-setup operators following the process outlined in this chapter.</p>
<p>Using the animation system is a convenient way to implement parametric behaviors, as it relies on the application update logic and produces fast, reliable outputs.</p>
<p>We will explore a similar but more powerful technique in <a href="B18375_09.xhtml#_idTextAnchor226"><em class="italic">Chapter 9</em></a>, thus completing our overview of the animation system.</p>
<h1 id="_idParaDest-215"><a id="_idTextAnchor225"/>Questions</h1>
<ol>
<li>What do we mean by non-destructive modifiers?</li>
<li>Do modifiers change the keyframe points of a curve?</li>
<li>Can we add animation modifiers to non-animated objects?</li>
<li>How do we make sure that a property is animated?</li>
<li>What is a parameter soft limit?</li>
<li>In which cases do we use soft rather than strong limits?</li>
<li>How can we look for a class name in Python?</li>
</ol>
</div>
</div></body></html>