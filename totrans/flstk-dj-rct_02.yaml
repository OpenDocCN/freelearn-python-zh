- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Authentication and Authorization using JWTs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we’ll dive deeper into Django and its architecture. We’ll be
    working with **models**, **serializers**, and **viewsets** to create an API that
    can receive HTTP requests as well as return a response. This will be done by building
    an authentication and authorization system using **JSON Web Tokens** (**JWTs**)
    to allow users to create an account, log in, and log out.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you’ll be able to create Django models, write Django
    serializers and validation, write viewsets to handle your API requests, expose
    your viewsets via the Django REST routers, create an authentication and authorization
    system based on JWTs, and understand what a JWT is and how it helps with authentication
    and permissions.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be covering the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding JWTs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Organizing a project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a user model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing the user registration feature
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding the login feature
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refresh logic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this chapter, you’ll need to have Insomnia installed on your machine to
    make requests to the API we’ll be building.
  prefs: []
  type: TYPE_NORMAL
- en: You can also find the code of this chapter at [https://github.com/PacktPublishing/Full-stack-Django-and-React/tree/chap2](https://github.com/PacktPublishing/Full-stack-Django-and-React/tree/chap2).
  prefs: []
  type: TYPE_NORMAL
- en: Understanding JWTs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before writing the authentication feature, let’s explain what a JWT is. As mentioned
    earlier, **JWT** stands for **JSON Web Token**. It’s one of the most used means
    of authentication in web applications but also helps with authorization and information
    exchanges.
  prefs: []
  type: TYPE_NORMAL
- en: According to RFC 7519, a JWT is a JSON object defined as a safe way of transmitting
    information between two parties. Information transmitted by JWT is digitally signed
    so it can be verified and trusted.
  prefs: []
  type: TYPE_NORMAL
- en: 'A JWT contains three parts—a header (`x`), a payload (`y`), and a signature
    (`z`)—that are separated by a dot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '**Header**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The header of the JWT consists of two parts: the type of token and the signing
    algorithm being used. The signing algorithm is used to ensure that the message
    is authentic and not altered.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of a header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Signing algorithms are algorithms used to sign tokens issued for your application
    or API.
  prefs: []
  type: TYPE_NORMAL
- en: '**Payload**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The payload is the second part that contains the claims. According to the official
    JWT documentation ([https://jwt.io/introduction](https://jwt.io/introduction)),
    claims are statements about an entity (typically, the user) and additional data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of a payload:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we have three claims: the ID of the user, the name
    of the user, and also a Boolean for the type of user.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Signature**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The signature of a JWT is the encoded header, the encoded payload plus a secret,
    and an algorithm specified in the header, all of them combined and signed.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, it’s possible to create a signature the following way using the
    RSA algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The role of the signature is to track whether information has been changed.
  prefs: []
  type: TYPE_NORMAL
- en: But how are JWTs actually used in authentication?
  prefs: []
  type: TYPE_NORMAL
- en: Understanding how JWTs are used in authentication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Each time a user successfully logs in, a JWT is created and returned. The JWT
    will be represented as credentials used to access protected resources. The fact
    that it’s possible to store data in a JWT makes it vulnerable. That’s why you
    should specify an expiration time when creating a JWT.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this book, we’ll be using JWTs in two ways. To make it simple, we’ll have
    two types of tokens:'
  prefs: []
  type: TYPE_NORMAL
- en: '**An access token**: Used to access resources and handle authorization'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A refresh token**: Used to retrieve a new access token'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: But why use two tokens? As we stated earlier, a JWT is generated when users
    log in. Moreover, JWTs used to access resources should have a short lifespan.
    This means that after the JWT has expired, the user has to log in again and again
    – and no user wants the login page to appear every 5 minutes.
  prefs: []
  type: TYPE_NORMAL
- en: That’s where a refresh token is useful. It’ll contain the essential information
    needed to verify the user and generate a new access token.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand the purpose of JWTs, let’s learn more about models in
    Django while creating the user model.
  prefs: []
  type: TYPE_NORMAL
- en: Organizing a project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When working with Django, you’ll have to create many apps to handle different
    parts of a project. For example, you can have a different application for authentication,
    and another for payments or articles. To have a clean and well-organized project,
    we can create a Django application that will contain all the apps we will create
    for this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the root of the project, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'A new application will be created. Remove all the files in this app except
    for the `apps.py` file and the `__init__.py` file. Inside `apps.py`, add the following
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: core/apps.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Register the apps in the `setting.py` file of the project:'
  prefs: []
  type: TYPE_NORMAL
- en: CoreRoot/settings.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '`INSTALLED_APPS` is a Django settings configuration, which is a list of Django
    apps within a project.'
  prefs: []
  type: TYPE_NORMAL
- en: We can now create the user application with confidence and write our first model.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a user model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unless you are creating a simple web application, there is little chance of
    avoiding the necessity to interact with a database, particularly having an account
    feature that requires users to register or log in to use your web application.
  prefs: []
  type: TYPE_NORMAL
- en: Before talking about the account feature, let’s learn more about Django models
    and what problems they resolve.
  prefs: []
  type: TYPE_NORMAL
- en: What are Django models?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you need to connect your application to a database, particularly **SQL**,
    the first assumption that comes to mind is that you’ll have to work directly with
    the database via SQL queries – and if that’s true, it can be fun, but it’s not
    the same for everyone; some developers may find SQL complex. You are no longer
    focusing on writing the application logic in your own language. Some tasks can
    become repetitive, such as writing SQL scripts to create tables, getting entries
    from the database, or inserting or updating data.
  prefs: []
  type: TYPE_NORMAL
- en: As you’ll see, the more the code base evolves, the more difficult it becomes
    to maintain both simple and complex SQL queries in your code base. This is more
    of an issue if you are working with multiple databases, which will require you
    to learn many SQL languages. For example, there are a lot of SQL databases and
    each one implements SQL in its own way.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, in Django, this messy issue is solved by using a Django model
    to access the database. This doesn’t mean that you don’t have to write SQL queries:
    it’s just that you don’t have to use SQL at all unless you want to.'
  prefs: []
  type: TYPE_NORMAL
- en: Django models provide **object-relational mapping** (**ORM**) to the underlying
    database. ORM is a tool that simplifies database programming by providing a simple
    mapping between the object and the database. Then, you don’t necessarily need
    to know the database structure or write complex SQL queries to manipulate or retrieve
    data from the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, creating a table in SQL will require writing a long SQL query.
    Doing this in Python will just require writing a class inheriting from the `django.db`
    package (*Figure 2**.1*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1 – Comparison between the Django ORM and SQL queries](img/Figure_2.1_B18221.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.1 – Comparison between the Django ORM and SQL queries
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding figure, you can see the SQL statement, which requires some
    knowledge of the syntax, as well as the fields and the options. The second code
    from the Django ORM does exactly the same thing but in a more Pythonic and less
    verbose manner.
  prefs: []
  type: TYPE_NORMAL
- en: 'Writing models with Django comes with several advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Simplicity**: Writing queries in Python may not be as clear as writing in
    SQL, but it’s less error-prone and more efficient, as you don’t have to control
    which type of database you are working with before trying to understand the code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Consistency**: SQL is inconsistent across different databases. Working with
    Django models creates an abstraction and helps you focus on the most important
    tasks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tracking**: It’s even easier to track database design changes working with
    Django models. It’s done by reading migration files written in Python. We’ll discuss
    this more in the next chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Notice that you also have access to model managers. Django Manager is a class
    that behaves as an interface through which Django models interact with databases.
    Every Django model, by default, inherits the `models.Manager` class that comes
    with the necessary methods to make **Create, Read, Update and Delete** (**CRUD**)
    operations on the table in the database.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a better understanding of Django models, let’s create the first
    model in this project, the `User` model. Working with our first model, we’ll also
    learn how to use the basic methods of the Django ORM to perform CRUD operations.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the User model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous section, we saw how a model is represented as a class and how
    this can basically be created as a table in the database.
  prefs: []
  type: TYPE_NORMAL
- en: Talking about the `User` model, Django comes with a pre-built-in `User` model
    class that you can use for basic authentication or a session. It actually provides
    an authentication feature you can use to quickly add authentication and authorization
    to your projects.
  prefs: []
  type: TYPE_NORMAL
- en: While it’s great for most use cases, it has its limitations. For example, in
    this book, we are building a social media web application. The user in this application
    will have some bio or even an avatar. Why not also have a phone number for **two-factor**
    **authentication** (**2FA**)?
  prefs: []
  type: TYPE_NORMAL
- en: Actually, the `User` model of Django doesn’t come with these fields. This means
    we’ll need to extend it and have our own user model. This also means that we will
    have to add custom methods to the manager for creating a user and a superuser.
    This will speed up the coding process. In Django, a superuser is a user with administrator
    permission.
  prefs: []
  type: TYPE_NORMAL
- en: Before creating the model, we actually need an application, and to register
    it. A Django application is a submodule of a Django project. It’s a Python package
    structured to work in a Django project and share Django conventions such as containing
    files or submodules such as `models`, `tests`, `urls`, and `views`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the user application
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To start a new application in this project, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This will create a new package (directory) containing new files. Here’s the
    structure of the directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now confidently start writing the `User` model. Here is the structure
    of the `User` table we want to have in the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.2 – User table structure](img/Figure_2.2_B18221.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.2 – User table structure
  prefs: []
  type: TYPE_NORMAL
- en: 'And here’s the code concerning the `User` table structure:'
  prefs: []
  type: TYPE_NORMAL
- en: core/user/models.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `models` module from Django provides some field utilities that can be used
    to write fields and add some rules. For example, `CharField` represents the type
    of field to create in the `User` table, similar to `BooleanField`. `EmailField`
    is also `CharField` but rewritten to validate the email that is passed as a value
    to this field.
  prefs: []
  type: TYPE_NORMAL
- en: We also set the `EMAIL_FIELD` as the email, and `USERNAME_FIELD` as the username.
    This will help us have two fields for login. The username can be the actual username
    of a user or just the email address used for registration.
  prefs: []
  type: TYPE_NORMAL
- en: We also have methods such as `name`, which is basically a model property. Then,
    it can be accessed anywhere on a `User` object, such as `user.name`. We are also
    rewriting the `__str__` method to return a string that can help us quickly identify
    a `User` object.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the user and superuser
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next, let’s write `UserManager` so we can have methods to create a user and
    a superuser:'
  prefs: []
  type: TYPE_NORMAL
- en: core/user/models.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: For the `create_user` method, we are basically making sure that fields such
    as `password`, `email`, `username`, `first_name`, and `last_name` are not `None`.
    If everything is good, we can confidently call the model, set a password, and
    save the user in the table.
  prefs: []
  type: TYPE_NORMAL
- en: This is done using the `save()` method.
  prefs: []
  type: TYPE_NORMAL
- en: '`create_superuser` also behaves in accordance with the `create_user` method
    – and it’s quite normal because, after all, a superuser is just a user with admin
    privileges, and also fields such as `is_superuser` and `is_staff` set to `True`.
    Once it’s done, we save the new `User` object in the database and return the user.'
  prefs: []
  type: TYPE_NORMAL
- en: See the `save` method as a way to commit changes made to the `User` object to
    the database.
  prefs: []
  type: TYPE_NORMAL
- en: The model is written and now we need to run migrations to create the table in
    the database.
  prefs: []
  type: TYPE_NORMAL
- en: Running migrations and testing the model
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before running the migrations, we need to register the user application in `INSTALLED_APPS`
    in `CoreRoot/settings.py`.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s rewrite the `apps.py` file of the user. It contains the app configs
    that Django will use to locate the application. Let’s also add a label for the
    application:'
  prefs: []
  type: TYPE_NORMAL
- en: core/user/apps.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s register the application now in the `INSTALLED_APPS` setting:'
  prefs: []
  type: TYPE_NORMAL
- en: CoreRoot/settings.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to tell Django to use this `User` model for the authentication
    user model. In the `settings.py` file, add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: CoreRoot/settings.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Great – we can now create the first migration for the user app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll have a similar output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s migrate this modification to the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The table is created in the database. Let’s use the Django shell to play with
    the newly created model a little bit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s import the model and add a dict containing the data needed to create
    a user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Great – we’ve just written the model and created the first user. However, a
    web browser won’t directly read the user data from our database – and worse, we
    are working with a Python native object, and a browser or a client reaching our
    server to make requests mostly supports JSON or XML. One idea would be to use
    the `json` library, but we are dealing with a complex data structure; complex
    data structures can be easily handled with serializers.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s write serializers in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Writing UserSerializer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A serializer allows us to convert complex Django complex data structures such
    as `QuerySet` or model instances into Python native objects that can be easily
    converted to JSON or XML format. However, a serializer also serializes JSON or
    XML to native Python. `serializers` package you can use to write serializers and
    also validations when API calls are made to an endpoint using this serializer.
    Let’s install the DRF package and make some configurations first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Don’t forget to add the following to the `requirements.txt` file:'
  prefs: []
  type: TYPE_NORMAL
- en: requirements.txt
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We are also adding `django-filter` for data filtering support. Let’s add `rest_framework`
    to the `INSTALLED_APPS` setting:'
  prefs: []
  type: TYPE_NORMAL
- en: CoreRoot/settings.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `core/user` directory, create a file called `serializers.py`. This file
    will contain the `UserSerializer` class:'
  prefs: []
  type: TYPE_NORMAL
- en: core/user/serializers.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `UserSerializer` class inherits from the `serializers.ModelSerialzer` class.
    It’s a class inheriting from the `serializers.Serializer` class but has deep integrations
    for supporting a model. It’ll automatically match the field of the model to have
    the correct validations for each one.
  prefs: []
  type: TYPE_NORMAL
- en: For example, we’ve stated that the email is unique. Then, every time someone
    registers and enters an email address that already exists in the database, they
    will receive an error message concerning this.
  prefs: []
  type: TYPE_NORMAL
- en: The `fields` attribute contains all the fields that can be read or written.
    Then, we also have the `read_only` fields. These fields are only readable. This
    means that they can’t be modified and it’s definitely better like that. Why give
    the external user the possibility to modify the `created`, `updated`, or `id`
    fields?
  prefs: []
  type: TYPE_NORMAL
- en: Now that `UserSerializer` is available, we can now write `viewset`.
  prefs: []
  type: TYPE_NORMAL
- en: Writing UserViewset
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we know, Django at its core is based on the **Model-View-Template** (**MVT**)
    architecture. The model communicates with the views (or controllers) and the template
    displays responses or redirects requests to the views.
  prefs: []
  type: TYPE_NORMAL
- en: However, when Django is coupled with DRF, the model can be directly connected
    to the view. However, as good practice, use a serializer between a model and a
    viewset. This really helps with validation and also some important checks.
  prefs: []
  type: TYPE_NORMAL
- en: So, what is a viewset then? DRF provides a class named `APIView` from which
    a lot of classes from DRF inherit to perform CRUD operations. Therefore, a viewset
    is simply a class-based view that can handle all the basic HTTP requests—`GET`,
    `POST`, `PUT`, `DELETE`, and `PATCH`—without hardcoding any CRUD logic here.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the `viewset` user, we are only allowing the `PATCH` and `GET` methods.
    Here’s what the endpoints will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Method** | **URL** | **Result** |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | `/``api/user/` | Lists all the users |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | `/``api/user/user_pk/` | Retrieves a specific user |'
  prefs: []
  type: TYPE_TB
- en: '| `PATCH` | `/``api/user/user_pk/` | Modifies a user |'
  prefs: []
  type: TYPE_TB
- en: Table 1.1 – Endpoints
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s write the viewset. Inside the `user` directory, rename the `view` file
    `viewsets.py` and add the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: core/user/viewsets.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The only methods allowed here are `GET` and `PUT`. We also set `serializer_class`
    and `permission_classes` to `AllowAny`, which means that anybody can access these
    viewsets. We also rewrite two methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`get_queryset`: This method is used by the viewset to get a list of all the
    users. This method will be called when `/user/` is hit with a `GET` request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`get_object`: This method is used by the viewset to get one user. This method
    is called when a `GET` or `PUT` request is made on the `/user/id/` endpoint, with
    `id` representing the ID of the user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There we have the `User` viewset – but there is no endpoint yet to make it work.
    Well, let’s add a router now.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a router
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Routers allow you to quickly declare all of the common routes for a given controller;
    the next code snippet shows a viewset to which we will be adding a router.
  prefs: []
  type: TYPE_NORMAL
- en: At the root of the apps project (`core`), create a file named `routers.py`.
  prefs: []
  type: TYPE_NORMAL
- en: 'And let’s add the code:'
  prefs: []
  type: TYPE_NORMAL
- en: core/routers.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'To register a route for a viewset, the `register()` method needs two arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The prefix**: Representing the name of the endpoint, basically'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The viewset**: Only representing a valid viewset class'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `basename` argument is optional but it’s a good practice to use one, as
    it helps for readability and also helps Django for URL registry purposes.
  prefs: []
  type: TYPE_NORMAL
- en: The router is now added; we can make some requests to the API using Insomnia.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Insomnia is a REST client tool used to make requests to RESTful API. With Insomnia,
    you can manage and create your requests elegantly. It offers support for cookie
    management, environment variables, code generation, and authentication.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before doing that, make sure to have the server running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Let’s make a request to `http://127.0.0.1:8000/api/user/`, a `GET` request.
    Look at the following screenshot and make sure to have the same URL – or you can
    replace `127.0.0.1` with `localhost --`, next to the **Send** button.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.3 – Listing all users](img/Figure_2.3_B18221.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.3 – Listing all users
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, we have a list of users created. Let’s also make a `GET` request
    to retrieve the first user using this URL: `/api/user/<id>/`.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.4 – Retrieving a user](img/Figure_2.4_B18221.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.4 – Retrieving a user
  prefs: []
  type: TYPE_NORMAL
- en: We have now a `User` object. This endpoint also allows `PATCH` requests. Let’s
    set the `last_name` value for this user to `Hey`. Change the type of request to
    `PATCH` and add a JSON body.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.5 – Modifying a user without permissions](img/Figure_2.5_B18221.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.5 – Modifying a user without permissions
  prefs: []
  type: TYPE_NORMAL
- en: 'Although it’s working, it’s actually a very bad scenario. We can’t have users
    modify other user names or data. A solution is to change the permission on the
    `permission_classes` attribute in the `UserViewSet` class:'
  prefs: []
  type: TYPE_NORMAL
- en: core/user/viewsets.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Let’s try the `PATCH` request again.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.6 – Modifying a user without permissions](img/Figure_2.6_B18221.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.6 – Modifying a user without permissions
  prefs: []
  type: TYPE_NORMAL
- en: We normally have a `401` status, an indication of an authentication issue. Basically,
    it means that an authentication header should be provided. They are more permissions
    to add concerning interactions with users, but let’s discuss this in later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Great. Now that we are done with the user application, we can confidently move
    on to adding a login and registration feature to the project.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the user registration feature
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before accessing protected data, the user needs to be authenticated. This comes
    with the assumption that there is a registration system to create an account and
    credentials.
  prefs: []
  type: TYPE_NORMAL
- en: To make things simpler, if the registration of a user is successful, we will
    provide credentials, here JWTs, so the user won’t have to log in again to start
    a session – a win for user experience.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s install a package that will handle JWT authentication for us.
    The `djangorestframework-simplejwt` package is a JWT authentication plugin for
    DRF:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The package covers the most common use case of JWT, and in this case here,
    it facilitates the creation and management of access tokens, as well as refreshing
    tokens. Before working with this package, there are some configurations needed
    in the `settings.py` file. We need to register the app in `INSTALLED_APPS` and
    specify `DEFAULT_AUTHENTICATION_CLASSES` in the `REST_FRAMEWORK` dict:'
  prefs: []
  type: TYPE_NORMAL
- en: CoreRoot/settings.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we need to write a registration serializer, but before that, let’s create
    a new application called `auth` in the `core` app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: It’ll contain all the logic concerning logging in, registration, logging out,
    and a lot more.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we did earlier for the user application, let’s rewrite the `apps.py` file
    and register the application in the `INSTALLED_APPS` settings:'
  prefs: []
  type: TYPE_NORMAL
- en: core/auth/apps.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Remove the `admin.py` and `models.py` files from the `auth` directory, as we
    won’t be working with them. For registration and login, we’ll have many serializers
    and viewsets, so let’s organize the code accordingly. Create a Python package
    called `serializers` and another one called `viewsets`. Make sure that these new
    directories have an `__init__.py` file. Here’s how your `auth` app tree should
    look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the `serializers` directory, create a file called `register.py`. It’ll
    contain the code for `RegisterSerializer`, which is the name of the registration
    serializer class:'
  prefs: []
  type: TYPE_NORMAL
- en: core/auth/serializers/register.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, `RegisterSerializer` is a subclass of `UserSerializer`. This
    is really helpful, as we don’t need to rewrite fields again.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we don’t need to revalidate fields such as `email` or `password`. As we
    declared these fields with some conditions, Django will automatically handle their
    validation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we can add the viewset and register it in the `register.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: core/auth/viewsets/register.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Nothing really new here – we are using attributes from the `ViewSet` class.
    We are also rewriting the `create` method to add access and refresh tokens in
    the body of the response. The `djangorestframework-simplejwt` package provides
    utilities we can use to directly generate tokens. That’s what `RefreshToken.for_user(user)`
    does.
  prefs: []
  type: TYPE_NORMAL
- en: 'And the final step – let’s register the viewset in the `routers.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: core/routers.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Great! Let’s test the new endpoint with Insomnia. In the collection of requests
    for this project, create a new `POST` request. The URL will be as follows: `localhost:8000/api/auth/register/`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As a body for the request, you can pass the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'With that, send the request. You should have a response similar to that shown
    in *Figure 2**.6* with a `201` `HTTP` status:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.7 – Registering a user](img/Figure_2.7_B18221.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.7 – Registering a user
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see what happens if we try to create a user with the same email and username.
    Hit the `400` error.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.8 – Registering a user with the same email and username](img/Figure_2.8_B18221.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.8 – Registering a user with the same email and username
  prefs: []
  type: TYPE_NORMAL
- en: 'Great. We are now sure that the endpoint behaves as we wish. The next step
    will be to add the login endpoint following the same process: writing the serializer
    and the viewset, and then registering the route.'
  prefs: []
  type: TYPE_NORMAL
- en: Adding the login feature
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The login feature will require the email or the username with the password.
    Using the `djangorestframework-simplejwt` package, which provides a serializer
    called `TokenObtainPairSerializer`, we’ll write a serializer to check for user
    authentication but also return a response containing access and refresh tokens.
    For this, we will rewrite the validate method from the `TokenObtainPairSerializer`
    class. Inside the `core/auth/serializers` directory, create a new file called
    `login.py` (this file will contain `LoginSerializer`, a subclass of `TokenObtainPairSerializer`):'
  prefs: []
  type: TYPE_NORMAL
- en: core/auth/serializers/login.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: We are surcharging the `validate` method from the `TokenObtainPairSerializer`
    class to adapt it to our needs. That’s why `super` is helpful here. It’s a built-in
    method in Python that returns a temporary object that can be used to access the
    class methods of the base class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we use `user` to retrieve access and refresh tokens. Once the serializer
    is written, don’t forget to import it to the `__init__.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: core/auth/serializers/__init__.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to add the viewset. We’ll call this viewset `LoginViewset`.
    As we are not directly interacting with a model here, we’ll just be using the
    `viewsets.ViewSet` class:'
  prefs: []
  type: TYPE_NORMAL
- en: core/auth/viewsets/login.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the viewset to the `__init__.py` file of the `viewsets` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now import it and register it in the `routers.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: core/routers.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The endpoint for login will be available at `/auth/login/`. Let’s try a request
    with Insomnia.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the body of the request I’ll use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '![Figure 2.9 – Login with user credentials](img/Figure_2.9_B18221.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.9 – Login with user credentials
  prefs: []
  type: TYPE_NORMAL
- en: The login feature is ready and working like a charm – but we have a little bit
    of an issue. The access token expires in 5 minutes. Basically, to get a new access
    token, the user will have to log in again. Let’s see how we can use the refresh
    token to request a new access token without logging in again.
  prefs: []
  type: TYPE_NORMAL
- en: Refresh logic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`djangorestframework-simplejwt` provides a refresh logic feature. As you’ve
    noticed, we’ve been generating refresh tokens and returning them as responses
    every time registration or login is completed. We’ll just inherit the class from
    `TokenRefreshView` and transform it into a viewset.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `auth/viewsets`, add a new file called `refresh.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: core/auth/viewsets/refresh.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Now add the class in the `__init__.py` file.
  prefs: []
  type: TYPE_NORMAL
- en: core/auth/viewsets/__init__.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'And now register it in the `routers.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: core/routers.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Great – let’s test the new endpoint at `/auth/refresh/` to get a new token.
    It’ll be a `POST` request with the refresh token in the body of the request, and
    you will receive a new access token in the response:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.10 – Requesting for a new access token](img/Figure_2.10_B18221.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.10 – Requesting for a new access token
  prefs: []
  type: TYPE_NORMAL
- en: Great – we’ve just learned how to implement refresh token logic in the application.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to write an authentication system based on JWT
    for a Django application using DRF and `djangorestframework-simplejwt`. We also
    learned how to extend classes and rewrite the functions.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll add the `posts` feature. Our users will be able to
    create a post that can be viewed and liked by other users.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is a JWT?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is Django Rest Framework?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a model?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a serializer?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a viewset?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a router?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the usage of a refresh token?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
