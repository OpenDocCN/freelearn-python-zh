- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Authentication and Authorization using JWTs
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用JWT进行认证和授权
- en: In this chapter, we’ll dive deeper into Django and its architecture. We’ll be
    working with **models**, **serializers**, and **viewsets** to create an API that
    can receive HTTP requests as well as return a response. This will be done by building
    an authentication and authorization system using **JSON Web Tokens** (**JWTs**)
    to allow users to create an account, log in, and log out.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将更深入地探讨Django及其架构。我们将使用**模型**、**序列化器**和**视图集**来创建一个可以接收HTTP请求并返回响应的API。这将通过构建一个使用**JSON
    Web Tokens**（JWT）的认证和授权系统来实现，以允许用户创建账户、登录和登出。
- en: By the end of this chapter, you’ll be able to create Django models, write Django
    serializers and validation, write viewsets to handle your API requests, expose
    your viewsets via the Django REST routers, create an authentication and authorization
    system based on JWTs, and understand what a JWT is and how it helps with authentication
    and permissions.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将能够创建Django模型、编写Django序列化器和验证、编写视图集来处理API请求、通过Django REST路由器公开视图集、基于JWT创建认证和授权系统，并理解JWT是什么以及它如何帮助进行认证和权限管理。
- en: 'We will be covering the following topics in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下主题：
- en: Understanding JWTs
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解JWT
- en: Organizing a project
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组织项目
- en: Creating a user model
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建用户模型
- en: Writing the user registration feature
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写用户注册功能
- en: Adding the login feature
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加登录功能
- en: Refresh logic
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 刷新逻辑
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For this chapter, you’ll need to have Insomnia installed on your machine to
    make requests to the API we’ll be building.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章内容，您需要在您的机器上安装Insomnia来向我们将要构建的API发送请求。
- en: You can also find the code of this chapter at [https://github.com/PacktPublishing/Full-stack-Django-and-React/tree/chap2](https://github.com/PacktPublishing/Full-stack-Django-and-React/tree/chap2).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以在[https://github.com/PacktPublishing/Full-stack-Django-and-React/tree/chap2](https://github.com/PacktPublishing/Full-stack-Django-and-React/tree/chap2)找到本章的代码。
- en: Understanding JWTs
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解JWT
- en: Before writing the authentication feature, let’s explain what a JWT is. As mentioned
    earlier, **JWT** stands for **JSON Web Token**. It’s one of the most used means
    of authentication in web applications but also helps with authorization and information
    exchanges.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写认证功能之前，让我们解释一下JWT是什么。如前所述，**JWT**代表**JSON Web Token**。它是网络应用程序中最常用的认证方式之一，同时也帮助进行授权和信息交换。
- en: According to RFC 7519, a JWT is a JSON object defined as a safe way of transmitting
    information between two parties. Information transmitted by JWT is digitally signed
    so it can be verified and trusted.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 根据RFC 7519，JWT是一个JSON对象，被定义为在双方之间安全传输信息的方式。JWT传输的信息是数字签名的，因此可以被验证和信任。
- en: 'A JWT contains three parts—a header (`x`), a payload (`y`), and a signature
    (`z`)—that are separated by a dot:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: JWT包含三个部分——一个头部（`x`）、一个负载（`y`）和一个签名（`z`），它们由点分隔：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '**Header**'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**头部**'
- en: 'The header of the JWT consists of two parts: the type of token and the signing
    algorithm being used. The signing algorithm is used to ensure that the message
    is authentic and not altered.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: JWT的头部由两部分组成：令牌类型和使用的签名算法。签名算法用于确保消息的真实性且未被篡改。
- en: 'Here’s an example of a header:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个头部的示例：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Signing algorithms are algorithms used to sign tokens issued for your application
    or API.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 签名算法是用于为您的应用程序或API签发令牌的算法。
- en: '**Payload**'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**负载**'
- en: The payload is the second part that contains the claims. According to the official
    JWT documentation ([https://jwt.io/introduction](https://jwt.io/introduction)),
    claims are statements about an entity (typically, the user) and additional data.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 负载是包含声明的第二部分。根据官方JWT文档([https://jwt.io/introduction](https://jwt.io/introduction))，声明是关于一个实体（通常是用户）及其附加数据的陈述。
- en: 'Here’s an example of a payload:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个负载的示例：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the preceding example, we have three claims: the ID of the user, the name
    of the user, and also a Boolean for the type of user.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们有三个声明：用户的ID、用户的名字，以及一个表示用户类型的布尔值。
- en: '**Signature**'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**签名**'
- en: The signature of a JWT is the encoded header, the encoded payload plus a secret,
    and an algorithm specified in the header, all of them combined and signed.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: JWT的签名是由编码的头部、编码的负载加上一个密钥，以及头部中指定的算法组合并签名而成的。
- en: 'For example, it’s possible to create a signature the following way using the
    RSA algorithm:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，可以使用RSA算法以下方式创建签名：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The role of the signature is to track whether information has been changed.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 签名的作用是跟踪信息是否被更改。
- en: But how are JWTs actually used in authentication?
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 但JWT实际上是如何在身份验证中使用的呢？
- en: Understanding how JWTs are used in authentication
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解JWT在身份验证中的应用
- en: Each time a user successfully logs in, a JWT is created and returned. The JWT
    will be represented as credentials used to access protected resources. The fact
    that it’s possible to store data in a JWT makes it vulnerable. That’s why you
    should specify an expiration time when creating a JWT.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 每次用户成功登录时，都会创建并返回一个JWT。JWT将作为用于访问受保护资源的凭证。由于可以在JWT中存储数据，这使得它容易受到攻击。这就是为什么在创建JWT时应该指定一个过期时间。
- en: 'In this book, we’ll be using JWTs in two ways. To make it simple, we’ll have
    two types of tokens:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们将以两种方式使用JWT。为了简单起见，我们将有两种类型的令牌：
- en: '**An access token**: Used to access resources and handle authorization'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**访问令牌**：用于访问资源和处理授权'
- en: '**A refresh token**: Used to retrieve a new access token'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**刷新令牌**：用于获取新的访问令牌'
- en: But why use two tokens? As we stated earlier, a JWT is generated when users
    log in. Moreover, JWTs used to access resources should have a short lifespan.
    This means that after the JWT has expired, the user has to log in again and again
    – and no user wants the login page to appear every 5 minutes.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 但为什么使用两个令牌呢？正如我们之前所述，JWT是在用户登录时生成的。此外，用于访问资源的JWT应该有很短的生命周期。这意味着JWT过期后，用户必须一次又一次地登录——而且没有用户希望登录页面每5分钟就出现一次。
- en: That’s where a refresh token is useful. It’ll contain the essential information
    needed to verify the user and generate a new access token.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是刷新令牌有用的地方。它将包含验证用户和生成新访问令牌所需的基本信息。
- en: Now that we understand the purpose of JWTs, let’s learn more about models in
    Django while creating the user model.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了JWT的目的，让我们在创建用户模型的同时，更多地了解Django中的模型以及它们解决的问题。
- en: Organizing a project
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组织项目
- en: When working with Django, you’ll have to create many apps to handle different
    parts of a project. For example, you can have a different application for authentication,
    and another for payments or articles. To have a clean and well-organized project,
    we can create a Django application that will contain all the apps we will create
    for this book.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用Django工作时，你需要创建许多应用程序来处理项目的不同部分。例如，你可以为身份验证有一个不同的应用程序，为支付或文章有另一个应用程序。为了有一个干净且组织良好的项目，我们可以创建一个Django应用程序，它将包含我们将为这本书创建的所有应用程序。
- en: 'At the root of the project, run the following command:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目的根目录下，运行以下命令：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'A new application will be created. Remove all the files in this app except
    for the `apps.py` file and the `__init__.py` file. Inside `apps.py`, add the following
    line:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 将创建一个新的应用程序。删除此应用程序中除`apps.py`文件和`__init__.py`文件之外的所有文件。在`apps.py`内部，添加以下行：
- en: core/apps.py
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: core/apps.py
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Register the apps in the `setting.py` file of the project:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目的`setting.py`文件中注册应用程序：
- en: CoreRoot/settings.py
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: CoreRoot/settings.py
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`INSTALLED_APPS` is a Django settings configuration, which is a list of Django
    apps within a project.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`INSTALLED_APPS`是Django设置配置，它是一个项目内Django应用程序的列表。'
- en: We can now create the user application with confidence and write our first model.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以自信地创建用户应用程序并编写我们的第一个模型。
- en: Creating a user model
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建用户模型
- en: Unless you are creating a simple web application, there is little chance of
    avoiding the necessity to interact with a database, particularly having an account
    feature that requires users to register or log in to use your web application.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你正在创建一个简单的Web应用程序，否则很难避免与数据库交互的必要性，尤其是拥有需要用户注册或登录才能使用你的Web应用程序的账户功能。
- en: Before talking about the account feature, let’s learn more about Django models
    and what problems they resolve.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论账户功能之前，让我们更多地了解Django模型以及它们解决的问题。
- en: What are Django models?
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Django模型是什么？
- en: If you need to connect your application to a database, particularly **SQL**,
    the first assumption that comes to mind is that you’ll have to work directly with
    the database via SQL queries – and if that’s true, it can be fun, but it’s not
    the same for everyone; some developers may find SQL complex. You are no longer
    focusing on writing the application logic in your own language. Some tasks can
    become repetitive, such as writing SQL scripts to create tables, getting entries
    from the database, or inserting or updating data.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要将你的应用程序连接到数据库，尤其是**SQL**，首先想到的假设是你将不得不直接通过SQL查询与数据库进行交互——如果这是真的，那可能很有趣，但并非对每个人来说都是如此；一些开发者可能会发现SQL很复杂。你不再专注于用你自己的语言编写应用程序逻辑。一些任务可能会变得重复，例如编写SQL脚本来创建表、从数据库中获取条目或插入或更新数据。
- en: As you’ll see, the more the code base evolves, the more difficult it becomes
    to maintain both simple and complex SQL queries in your code base. This is more
    of an issue if you are working with multiple databases, which will require you
    to learn many SQL languages. For example, there are a lot of SQL databases and
    each one implements SQL in its own way.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，随着代码库的不断发展，维护代码库中的简单和复杂 SQL 查询变得越来越困难。如果你正在使用多个数据库，这个问题会更加严重，这需要你学习许多
    SQL 语言。例如，有许多 SQL 数据库，每个数据库都以自己的方式实现 SQL。
- en: 'Fortunately, in Django, this messy issue is solved by using a Django model
    to access the database. This doesn’t mean that you don’t have to write SQL queries:
    it’s just that you don’t have to use SQL at all unless you want to.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，在 Django 中，这个问题通过使用 Django 模型来访问数据库得到了解决。这并不意味着你不需要编写 SQL 查询：只是说，除非你想这么做，否则你不必使用
    SQL。
- en: Django models provide **object-relational mapping** (**ORM**) to the underlying
    database. ORM is a tool that simplifies database programming by providing a simple
    mapping between the object and the database. Then, you don’t necessarily need
    to know the database structure or write complex SQL queries to manipulate or retrieve
    data from the database.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Django 模型为底层数据库提供了 **对象关系映射**（**ORM**）。ORM 是一个工具，通过提供对象和数据库之间简单的映射来简化数据库编程。然后，你不必一定知道数据库结构或编写复杂的
    SQL 查询来操作或从数据库中检索数据。
- en: 'For example, creating a table in SQL will require writing a long SQL query.
    Doing this in Python will just require writing a class inheriting from the `django.db`
    package (*Figure 2**.1*):'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在 SQL 中创建一个表需要编写一个长的 SQL 查询。在 Python 中做这件事只需要编写一个继承自 `django.db` 包的类（*图 2.1*）：
- en: '![Figure 2.1 – Comparison between the Django ORM and SQL queries](img/Figure_2.1_B18221.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.1 – Django ORM 与 SQL 查询的比较](img/Figure_2.1_B18221.jpg)'
- en: Figure 2.1 – Comparison between the Django ORM and SQL queries
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1 – Django ORM 与 SQL 查询的比较
- en: In the preceding figure, you can see the SQL statement, which requires some
    knowledge of the syntax, as well as the fields and the options. The second code
    from the Django ORM does exactly the same thing but in a more Pythonic and less
    verbose manner.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，你可以看到 SQL 语句，它需要一些语法知识，以及字段和选项。Django ORM 的第二个代码块做了完全相同的事情，但以更 Pythonic
    和更简洁的方式。
- en: 'Writing models with Django comes with several advantages:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Django 编写模型具有几个优点：
- en: '**Simplicity**: Writing queries in Python may not be as clear as writing in
    SQL, but it’s less error-prone and more efficient, as you don’t have to control
    which type of database you are working with before trying to understand the code.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简洁性**：在 Python 中编写查询可能不如在 SQL 中编写清晰，但它更不容易出错，也更高效，因为你不需要在尝试理解代码之前控制你正在使用的数据库类型。'
- en: '**Consistency**: SQL is inconsistent across different databases. Working with
    Django models creates an abstraction and helps you focus on the most important
    tasks.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一致性**：SQL 在不同的数据库之间是不一致的。使用 Django 模型创建了一个抽象层，有助于你专注于最重要的任务。'
- en: '**Tracking**: It’s even easier to track database design changes working with
    Django models. It’s done by reading migration files written in Python. We’ll discuss
    this more in the next chapter.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**跟踪**：与 Django 模型一起工作，跟踪数据库设计变更甚至更容易。这是通过阅读用 Python 编写的迁移文件来完成的。我们将在下一章中进一步讨论这个问题。'
- en: Notice that you also have access to model managers. Django Manager is a class
    that behaves as an interface through which Django models interact with databases.
    Every Django model, by default, inherits the `models.Manager` class that comes
    with the necessary methods to make **Create, Read, Update and Delete** (**CRUD**)
    operations on the table in the database.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你还可以访问模型管理器。Django 管理器是一个类，它作为一个接口，通过它 Django 模型与数据库交互。每个 Django 模型默认继承自
    `models.Manager` 类，该类提供了在数据库表上执行 **创建、读取、更新和删除**（**CRUD**）操作所必需的方法。
- en: Now that we have a better understanding of Django models, let’s create the first
    model in this project, the `User` model. Working with our first model, we’ll also
    learn how to use the basic methods of the Django ORM to perform CRUD operations.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对 Django 模型有了更好的理解，让我们在这个项目中创建第一个模型，即 `User` 模型。通过使用我们的第一个模型，我们还将学习如何使用
    Django ORM 的基本方法来执行 CRUD 操作。
- en: Writing the User model
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写用户模型
- en: In the previous section, we saw how a model is represented as a class and how
    this can basically be created as a table in the database.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分中，我们看到了模型是如何作为一个类来表示的，以及它基本上可以创建为数据库中的表。
- en: Talking about the `User` model, Django comes with a pre-built-in `User` model
    class that you can use for basic authentication or a session. It actually provides
    an authentication feature you can use to quickly add authentication and authorization
    to your projects.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 谈到`User`模型，Django自带一个预构建的`User`模型类，你可以用它来进行基本认证或会话。它实际上提供了一个认证功能，你可以用它快速为你的项目添加认证和授权。
- en: While it’s great for most use cases, it has its limitations. For example, in
    this book, we are building a social media web application. The user in this application
    will have some bio or even an avatar. Why not also have a phone number for **two-factor**
    **authentication** (**2FA**)?
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这对于大多数用例来说都很棒，但它也有其局限性。例如，在这本书中，我们正在构建一个社交媒体网络应用程序。这个应用程序中的用户将有一些简介或甚至一个头像。为什么不能也有一个电话号码用于**双因素****认证**（2FA）呢？
- en: Actually, the `User` model of Django doesn’t come with these fields. This means
    we’ll need to extend it and have our own user model. This also means that we will
    have to add custom methods to the manager for creating a user and a superuser.
    This will speed up the coding process. In Django, a superuser is a user with administrator
    permission.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，Django的`User`模型并没有包含这些字段。这意味着我们需要扩展它并拥有自己的用户模型。这也意味着我们还需要为创建用户和超级用户添加自定义方法到管理器中。这将加快编码过程。在Django中，超级用户是具有管理员权限的用户。
- en: Before creating the model, we actually need an application, and to register
    it. A Django application is a submodule of a Django project. It’s a Python package
    structured to work in a Django project and share Django conventions such as containing
    files or submodules such as `models`, `tests`, `urls`, and `views`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建模型之前，我们实际上需要一个应用程序，并注册它。Django应用程序是Django项目的子模块。它是一个Python包，旨在在Django项目中工作并遵循Django约定，例如包含文件或子模块，如`models`、`tests`、`urls`和`views`。
- en: Creating the user application
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建用户应用程序
- en: 'To start a new application in this project, run the following command:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 要在这个项目中启动一个新的应用程序，请运行以下命令：
- en: '[PRE7]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This will create a new package (directory) containing new files. Here’s the
    structure of the directory:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个包含新文件的新包（目录）。以下是目录结构：
- en: '[PRE8]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We can now confidently start writing the `User` model. Here is the structure
    of the `User` table we want to have in the database:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以自信地开始编写`User`模型。以下是我们在数据库中想要拥有的`User`表的结构：
- en: '![Figure 2.2 – User table structure](img/Figure_2.2_B18221.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图2.2 – 用户表结构](img/Figure_2.2_B18221.jpg)'
- en: Figure 2.2 – User table structure
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2 – 用户表结构
- en: 'And here’s the code concerning the `User` table structure:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是关于`User`表结构的代码：
- en: core/user/models.py
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: core/user/models.py
- en: '[PRE9]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `models` module from Django provides some field utilities that can be used
    to write fields and add some rules. For example, `CharField` represents the type
    of field to create in the `User` table, similar to `BooleanField`. `EmailField`
    is also `CharField` but rewritten to validate the email that is passed as a value
    to this field.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Django的`models`模块提供了一些字段工具，可以用来编写字段并添加一些规则。例如，`CharField`代表在`User`表中创建的字段类型，类似于`BooleanField`。`EmailField`也是`CharField`，但被重新编写以验证传递给此字段的电子邮件值。
- en: We also set the `EMAIL_FIELD` as the email, and `USERNAME_FIELD` as the username.
    This will help us have two fields for login. The username can be the actual username
    of a user or just the email address used for registration.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将`EMAIL_FIELD`设置为电子邮件，将`USERNAME_FIELD`设置为用户名。这将帮助我们有两个登录字段。用户名可以是用户的实际用户名，也可以是用于注册的电子邮件地址。
- en: We also have methods such as `name`, which is basically a model property. Then,
    it can be accessed anywhere on a `User` object, such as `user.name`. We are also
    rewriting the `__str__` method to return a string that can help us quickly identify
    a `User` object.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有像`name`这样的方法，这基本上是一个模型属性。然后，它可以在`User`对象的任何地方访问，例如`user.name`。我们还在重新编写`__str__`方法，以便返回一个可以帮助我们快速识别`User`对象的字符串。
- en: Creating the user and superuser
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建用户和超级用户
- en: 'Next, let’s write `UserManager` so we can have methods to create a user and
    a superuser:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们编写`UserManager`，这样我们就可以有创建用户和超级用户的方法：
- en: core/user/models.py
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: core/user/models.py
- en: '[PRE10]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: For the `create_user` method, we are basically making sure that fields such
    as `password`, `email`, `username`, `first_name`, and `last_name` are not `None`.
    If everything is good, we can confidently call the model, set a password, and
    save the user in the table.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`create_user`方法，我们基本上确保字段如`password`、`email`、`username`、`first_name`和`last_name`不是`None`。如果一切正常，我们可以自信地调用模型，设置密码，并将用户保存到表中。
- en: This is done using the `save()` method.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过使用`save()`方法完成的。
- en: '`create_superuser` also behaves in accordance with the `create_user` method
    – and it’s quite normal because, after all, a superuser is just a user with admin
    privileges, and also fields such as `is_superuser` and `is_staff` set to `True`.
    Once it’s done, we save the new `User` object in the database and return the user.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`create_superuser`也遵循`create_user`方法的操作——这是非常正常的，因为毕竟，超级用户只是一个具有管理员权限的用户，并且`is_superuser`和`is_staff`字段也设置为`True`。一旦完成，我们将新的`User`对象保存到数据库中并返回用户。'
- en: See the `save` method as a way to commit changes made to the `User` object to
    the database.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下`save`方法，它将`User`对象所做的更改提交到数据库。
- en: The model is written and now we need to run migrations to create the table in
    the database.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 模型已编写，现在我们需要运行迁移以在数据库中创建表。
- en: Running migrations and testing the model
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行迁移并测试模型
- en: Before running the migrations, we need to register the user application in `INSTALLED_APPS`
    in `CoreRoot/settings.py`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行迁移之前，我们需要在`CoreRoot/settings.py`中的`INSTALLED_APPS`中注册用户应用程序。
- en: 'First, let’s rewrite the `apps.py` file of the user. It contains the app configs
    that Django will use to locate the application. Let’s also add a label for the
    application:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们重写用户的`apps.py`文件。它包含Django将用于定位应用程序的应用程序配置。我们还要为应用程序添加一个标签：
- en: core/user/apps.py
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: core/user/apps.py
- en: '[PRE11]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let’s register the application now in the `INSTALLED_APPS` setting:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在在`INSTALLED_APPS`设置中注册应用程序：
- en: CoreRoot/settings.py
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: CoreRoot/settings.py
- en: '[PRE12]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We also need to tell Django to use this `User` model for the authentication
    user model. In the `settings.py` file, add the following line:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要告诉Django使用这个`User`模型作为认证用户模型。在`settings.py`文件中，添加以下行：
- en: CoreRoot/settings.py
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: CoreRoot/settings.py
- en: '[PRE13]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Great – we can now create the first migration for the user app:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了——我们现在可以为用户应用程序创建第一个迁移：
- en: '[PRE14]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You’ll have a similar output:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 您将得到类似的输出：
- en: '[PRE15]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Let’s migrate this modification to the database:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将此修改迁移到数据库中：
- en: '[PRE16]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The table is created in the database. Let’s use the Django shell to play with
    the newly created model a little bit:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 表已创建在数据库中。让我们使用Django shell来稍微玩一下新创建的模型：
- en: '[PRE17]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Let’s import the model and add a dict containing the data needed to create
    a user:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们导入模型并添加一个包含创建用户所需数据的字典：
- en: '[PRE18]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Great – we’ve just written the model and created the first user. However, a
    web browser won’t directly read the user data from our database – and worse, we
    are working with a Python native object, and a browser or a client reaching our
    server to make requests mostly supports JSON or XML. One idea would be to use
    the `json` library, but we are dealing with a complex data structure; complex
    data structures can be easily handled with serializers.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了——我们刚刚编写了模型并创建了第一个用户。然而，网络浏览器不会直接从我们的数据库中读取用户数据——更糟糕的是，我们正在处理一个Python原生对象，而大多数浏览器或客户端在向我们的服务器发出请求时主要支持JSON或XML。一个想法是使用`json`库，但我们正在处理一个复杂的数据结构；复杂的数据结构可以很容易地通过序列化器处理。
- en: Let’s write serializers in the next section.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下一节编写序列化器。
- en: Writing UserSerializer
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写UserSerializer
- en: 'A serializer allows us to convert complex Django complex data structures such
    as `QuerySet` or model instances into Python native objects that can be easily
    converted to JSON or XML format. However, a serializer also serializes JSON or
    XML to native Python. `serializers` package you can use to write serializers and
    also validations when API calls are made to an endpoint using this serializer.
    Let’s install the DRF package and make some configurations first:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 序列化器允许我们将复杂的Django数据结构，如`QuerySet`或模型实例，转换为Python原生对象，这些对象可以轻松地转换为JSON或XML格式。然而，序列化器也可以将JSON或XML序列化为原生Python。您可以使用`serializers`包来编写序列化器，并在使用此序列化器对端点进行API调用时进行验证。让我们先安装DRF包并进行一些配置：
- en: '[PRE19]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Don’t forget to add the following to the `requirements.txt` file:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记将以下内容添加到`requirements.txt`文件中：
- en: requirements.txt
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: requirements.txt
- en: '[PRE20]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We are also adding `django-filter` for data filtering support. Let’s add `rest_framework`
    to the `INSTALLED_APPS` setting:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还添加了`django-filter`以支持数据过滤。让我们将`rest_framework`添加到`INSTALLED_APPS`设置中：
- en: CoreRoot/settings.py
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: CoreRoot/settings.py
- en: '[PRE21]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In the `core/user` directory, create a file called `serializers.py`. This file
    will contain the `UserSerializer` class:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在`core/user`目录中，创建一个名为`serializers.py`的文件。此文件将包含`UserSerializer`类：
- en: core/user/serializers.py
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: core/user/serializers.py
- en: '[PRE22]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `UserSerializer` class inherits from the `serializers.ModelSerialzer` class.
    It’s a class inheriting from the `serializers.Serializer` class but has deep integrations
    for supporting a model. It’ll automatically match the field of the model to have
    the correct validations for each one.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`UserSerializer`类继承自`serializers.ModelSerializer`类。这是一个继承自`serializers.Serializer`类的类，但它具有对支持模型的深度集成。它将自动将模型的字段与正确的验证匹配。'
- en: For example, we’ve stated that the email is unique. Then, every time someone
    registers and enters an email address that already exists in the database, they
    will receive an error message concerning this.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们已声明电子邮件是唯一的。那么，每次有人注册并输入数据库中已存在的电子邮件地址时，他们都会收到关于此的错误消息。
- en: The `fields` attribute contains all the fields that can be read or written.
    Then, we also have the `read_only` fields. These fields are only readable. This
    means that they can’t be modified and it’s definitely better like that. Why give
    the external user the possibility to modify the `created`, `updated`, or `id`
    fields?
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`fields`属性包含所有可读或可写的字段。然后，我们还有只读字段。这意味着它们不能被修改，这样当然更好。为什么给外部用户修改`created`、`updated`或`id`字段的可能性呢？'
- en: Now that `UserSerializer` is available, we can now write `viewset`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在有了`UserSerializer`，我们可以编写`viewset`了。
- en: Writing UserViewset
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写UserViewset
- en: As we know, Django at its core is based on the **Model-View-Template** (**MVT**)
    architecture. The model communicates with the views (or controllers) and the template
    displays responses or redirects requests to the views.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所知，Django的核心是基于**模型-视图-模板**（**MVT**）架构。模型与视图（或控制器）通信，模板显示响应或将请求重定向到视图。
- en: However, when Django is coupled with DRF, the model can be directly connected
    to the view. However, as good practice, use a serializer between a model and a
    viewset. This really helps with validation and also some important checks.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当Django与DRF结合使用时，模型可以直接连接到视图。但是，作为良好的实践，在模型和视图集之间使用序列化器。这确实有助于验证，也进行了一些重要的检查。
- en: So, what is a viewset then? DRF provides a class named `APIView` from which
    a lot of classes from DRF inherit to perform CRUD operations. Therefore, a viewset
    is simply a class-based view that can handle all the basic HTTP requests—`GET`,
    `POST`, `PUT`, `DELETE`, and `PATCH`—without hardcoding any CRUD logic here.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，什么是视图集呢？DRF提供了一个名为`APIView`的类，许多DRF的类都从这个类继承以执行CRUD操作。因此，视图集就是一个基于类的视图，它可以处理所有基本的HTTP请求——`GET`、`POST`、`PUT`、`DELETE`和`PATCH`——而不需要在这里硬编码任何CRUD逻辑。
- en: 'For the `viewset` user, we are only allowing the `PATCH` and `GET` methods.
    Here’s what the endpoints will look like:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`viewset`用户，我们只允许`PATCH`和`GET`方法。以下是端点将看起来像什么：
- en: '| **Method** | **URL** | **Result** |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **URL** | **结果** |'
- en: '| `GET` | `/``api/user/` | Lists all the users |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | `/api/user/` | 列出所有用户 |'
- en: '| `GET` | `/``api/user/user_pk/` | Retrieves a specific user |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | `/api/user/user_pk/` | 获取特定用户 |'
- en: '| `PATCH` | `/``api/user/user_pk/` | Modifies a user |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| `PATCH` | `/api/user/user_pk/` | 修改用户 |'
- en: Table 1.1 – Endpoints
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 表1.1 – 端点
- en: 'Let’s write the viewset. Inside the `user` directory, rename the `view` file
    `viewsets.py` and add the following content:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写视图集。在`user`目录中，将`view`文件重命名为`viewsets.py`并添加以下内容：
- en: core/user/viewsets.py
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: core/user/viewsets.py
- en: '[PRE23]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The only methods allowed here are `GET` and `PUT`. We also set `serializer_class`
    and `permission_classes` to `AllowAny`, which means that anybody can access these
    viewsets. We also rewrite two methods:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这里允许的方法只有`GET`和`PUT`。我们还设置了`serializer_class`和`permission_classes`为`AllowAny`，这意味着任何人都可以访问这些视图集。我们还重写了两个方法：
- en: '`get_queryset`: This method is used by the viewset to get a list of all the
    users. This method will be called when `/user/` is hit with a `GET` request.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get_queryset`：这个方法由视图集用来获取所有用户的列表。当使用`GET`请求访问`/user/`时，这个方法会被调用。'
- en: '`get_object`: This method is used by the viewset to get one user. This method
    is called when a `GET` or `PUT` request is made on the `/user/id/` endpoint, with
    `id` representing the ID of the user.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get_object`：这个方法由视图集用来获取一个用户。当对`/user/id/`端点进行`GET`或`PUT`请求时，这个方法会被调用。'
- en: There we have the `User` viewset – but there is no endpoint yet to make it work.
    Well, let’s add a router now.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在那里有`User`视图集——但是还没有端点来使其工作。好吧，现在让我们添加一个路由器。
- en: Adding a router
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加路由器
- en: Routers allow you to quickly declare all of the common routes for a given controller;
    the next code snippet shows a viewset to which we will be adding a router.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 路由器允许您快速声明给定控制器所有常见的路由；下面的代码片段显示了一个我们将添加路由器的视图集。
- en: At the root of the apps project (`core`), create a file named `routers.py`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `core` 项目的根目录下创建一个名为 `routers.py` 的文件。
- en: 'And let’s add the code:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们添加代码：
- en: core/routers.py
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: core/routers.py
- en: '[PRE24]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'To register a route for a viewset, the `register()` method needs two arguments:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 为视图集注册路由时，`register()` 方法需要两个参数：
- en: '**The prefix**: Representing the name of the endpoint, basically'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**前缀**：表示端点的名称，基本上'
- en: '**The viewset**: Only representing a valid viewset class'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视图集**：仅表示一个有效的视图集类'
- en: The `basename` argument is optional but it’s a good practice to use one, as
    it helps for readability and also helps Django for URL registry purposes.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`basename` 参数是可选的，但使用它是良好的实践，因为它有助于可读性，并且也有助于 Django 进行 URL 注册。'
- en: The router is now added; we can make some requests to the API using Insomnia.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 路由器现在已添加；我们可以使用 Insomnia 向 API 发送一些请求。
- en: Important note
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Insomnia is a REST client tool used to make requests to RESTful API. With Insomnia,
    you can manage and create your requests elegantly. It offers support for cookie
    management, environment variables, code generation, and authentication.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: Insomnia 是一个 REST 客户端工具，用于向 RESTful API 发送请求。使用 Insomnia，您可以优雅地管理和创建请求。它提供对
    cookie 管理、环境变量、代码生成和身份验证的支持。
- en: 'Before doing that, make sure to have the server running:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在做之前，请确保服务器正在运行：
- en: '[PRE25]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Let’s make a request to `http://127.0.0.1:8000/api/user/`, a `GET` request.
    Look at the following screenshot and make sure to have the same URL – or you can
    replace `127.0.0.1` with `localhost --`, next to the **Send** button.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们向 `http://127.0.0.1:8000/api/user/` 发送一个 `GET` 请求。查看下面的截图，并确保使用相同的 URL –
    或者你可以将 `127.0.0.1` 替换为 `localhost --`，在 **发送** 按钮旁边。
- en: '![Figure 2.3 – Listing all users](img/Figure_2.3_B18221.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.3 – 列出所有用户](img/Figure_2.3_B18221.jpg)'
- en: Figure 2.3 – Listing all users
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.3 – 列出所有用户
- en: 'As you can see, we have a list of users created. Let’s also make a `GET` request
    to retrieve the first user using this URL: `/api/user/<id>/`.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们创建了一个用户列表。现在，让我们也使用此 URL 发送一个 `GET` 请求来检索第一个用户：`/api/user/<id>/`。
- en: '![Figure 2.4 – Retrieving a user](img/Figure_2.4_B18221.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.4 – 获取用户](img/Figure_2.4_B18221.jpg)'
- en: Figure 2.4 – Retrieving a user
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.4 – 获取用户
- en: We have now a `User` object. This endpoint also allows `PATCH` requests. Let’s
    set the `last_name` value for this user to `Hey`. Change the type of request to
    `PATCH` and add a JSON body.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个 `User` 对象。此端点还允许 `PATCH` 请求。让我们将此用户的 `last_name` 值设置为 `Hey`。将请求类型更改为
    `PATCH` 并添加一个 JSON 主体。
- en: '![Figure 2.5 – Modifying a user without permissions](img/Figure_2.5_B18221.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.5 – 无权限修改用户](img/Figure_2.5_B18221.jpg)'
- en: Figure 2.5 – Modifying a user without permissions
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.5 – 无权限修改用户
- en: 'Although it’s working, it’s actually a very bad scenario. We can’t have users
    modify other user names or data. A solution is to change the permission on the
    `permission_classes` attribute in the `UserViewSet` class:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '虽然它正在工作，但实际上这是一个非常糟糕的场景。我们不能让用户修改其他用户的名称或数据。一个解决方案是更改 `UserViewSet` 类中的 `permission_classes`
    属性上的权限。 '
- en: core/user/viewsets.py
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: core/user/viewsets.py
- en: '[PRE26]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Let’s try the `PATCH` request again.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次尝试 `PATCH` 请求。
- en: '![Figure 2.6 – Modifying a user without permissions](img/Figure_2.6_B18221.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.6 – 无权限修改用户](img/Figure_2.6_B18221.jpg)'
- en: Figure 2.6 – Modifying a user without permissions
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.6 – 无权限修改用户
- en: We normally have a `401` status, an indication of an authentication issue. Basically,
    it means that an authentication header should be provided. They are more permissions
    to add concerning interactions with users, but let’s discuss this in later chapters.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常会有一个 `401` 状态码，这是身份验证问题的指示。基本上，这意味着应该提供一个身份验证头。有关与用户交互的权限，我们还有更多要添加的内容，但让我们在后面的章节中讨论这个问题。
- en: Great. Now that we are done with the user application, we can confidently move
    on to adding a login and registration feature to the project.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了。现在我们已经完成了用户应用程序，我们可以自信地继续向项目中添加登录和注册功能。
- en: Writing the user registration feature
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写用户注册功能
- en: Before accessing protected data, the user needs to be authenticated. This comes
    with the assumption that there is a registration system to create an account and
    credentials.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在访问受保护的数据之前，用户需要进行身份验证。这假设存在一个注册系统来创建账户和凭证。
- en: To make things simpler, if the registration of a user is successful, we will
    provide credentials, here JWTs, so the user won’t have to log in again to start
    a session – a win for user experience.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使事情更简单，如果用户注册成功，我们将提供凭证，这里是JWT，这样用户就不需要再次登录来开始会话——这是用户体验的胜利。
- en: 'First, let’s install a package that will handle JWT authentication for us.
    The `djangorestframework-simplejwt` package is a JWT authentication plugin for
    DRF:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们安装一个将为我们处理JWT认证的包。`djangorestframework-simplejwt`包是DRF的JWT认证插件：
- en: '[PRE27]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The package covers the most common use case of JWT, and in this case here,
    it facilitates the creation and management of access tokens, as well as refreshing
    tokens. Before working with this package, there are some configurations needed
    in the `settings.py` file. We need to register the app in `INSTALLED_APPS` and
    specify `DEFAULT_AUTHENTICATION_CLASSES` in the `REST_FRAMEWORK` dict:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 该包涵盖了JWT最常见的使用场景，在此案例中，它简化了访问令牌和刷新令牌的创建与管理。在使用此包之前，需要在`settings.py`文件中进行一些配置。我们需要在`INSTALLED_APPS`中注册应用，并在`REST_FRAMEWORK`字典中指定`DEFAULT_AUTHENTICATION_CLASSES`：
- en: CoreRoot/settings.py
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: CoreRoot/settings.py
- en: '[PRE28]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'First, we need to write a registration serializer, but before that, let’s create
    a new application called `auth` in the `core` app:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要编写一个注册序列化器，但在那之前，让我们在`core`应用中创建一个名为`auth`的新应用：
- en: '[PRE29]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: It’ll contain all the logic concerning logging in, registration, logging out,
    and a lot more.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 它将包含有关登录、注册、注销以及更多逻辑的所有逻辑。
- en: 'As we did earlier for the user application, let’s rewrite the `apps.py` file
    and register the application in the `INSTALLED_APPS` settings:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前为用户应用所做的那样，让我们重写`apps.py`文件，并在`INSTALLED_APPS`设置中注册应用：
- en: core/auth/apps.py
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: core/auth/apps.py
- en: '[PRE30]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Remove the `admin.py` and `models.py` files from the `auth` directory, as we
    won’t be working with them. For registration and login, we’ll have many serializers
    and viewsets, so let’s organize the code accordingly. Create a Python package
    called `serializers` and another one called `viewsets`. Make sure that these new
    directories have an `__init__.py` file. Here’s how your `auth` app tree should
    look:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 从`auth`目录中删除`admin.py`和`models.py`文件，因为我们不会使用它们。对于注册和登录，我们将有许多序列化器和视图集，所以让我们相应地组织代码。创建一个名为`serializers`的Python包和另一个名为`viewsets`的包。确保这些新目录都有一个`__init__.py`文件。这是你的`auth`应用树应该看起来像这样：
- en: '[PRE31]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Inside the `serializers` directory, create a file called `register.py`. It’ll
    contain the code for `RegisterSerializer`, which is the name of the registration
    serializer class:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在`serializers`目录内，创建一个名为`register.py`的文件。它将包含`RegisterSerializer`的代码，这是注册序列化器类的名称：
- en: core/auth/serializers/register.py
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: core/auth/serializers/register.py
- en: '[PRE32]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: As you can see, `RegisterSerializer` is a subclass of `UserSerializer`. This
    is really helpful, as we don’t need to rewrite fields again.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`RegisterSerializer`是`UserSerializer`的子类。这非常有帮助，因为我们不需要再次重写字段。
- en: Here, we don’t need to revalidate fields such as `email` or `password`. As we
    declared these fields with some conditions, Django will automatically handle their
    validation.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们不需要重新验证诸如`email`或`password`之类的字段。因为我们声明了这些字段并附加了一些条件，Django将自动处理它们的验证。
- en: 'Next, we can add the viewset and register it in the `register.py` file:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以在`register.py`文件中添加视图集并注册它：
- en: core/auth/viewsets/register.py
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: core/auth/viewsets/register.py
- en: '[PRE33]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Nothing really new here – we are using attributes from the `ViewSet` class.
    We are also rewriting the `create` method to add access and refresh tokens in
    the body of the response. The `djangorestframework-simplejwt` package provides
    utilities we can use to directly generate tokens. That’s what `RefreshToken.for_user(user)`
    does.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有真正的新内容——我们正在使用`ViewSet`类的属性。我们还重写了`create`方法，在响应体中添加访问和刷新令牌。`djangorestframework-simplejwt`包提供了我们可以直接生成令牌的实用工具。这就是`RefreshToken.for_user(user)`所做的事情。
- en: 'And the final step – let’s register the viewset in the `routers.py` file:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步——让我们在`routers.py`文件中注册视图集：
- en: core/routers.py
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: core/routers.py
- en: '[PRE34]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Great! Let’s test the new endpoint with Insomnia. In the collection of requests
    for this project, create a new `POST` request. The URL will be as follows: `localhost:8000/api/auth/register/`.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！让我们用Insomnia测试新的端点。在此项目的请求集合中创建一个新的`POST`请求。URL如下：`localhost:8000/api/auth/register/`。
- en: 'As a body for the request, you can pass the following:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 作为请求的主体，您可以传递以下内容：
- en: '[PRE35]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'With that, send the request. You should have a response similar to that shown
    in *Figure 2**.6* with a `201` `HTTP` status:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，发送请求。你应该得到一个类似于*图2**.6中所示，带有`201` `HTTP`状态的响应：
- en: '![Figure 2.7 – Registering a user](img/Figure_2.7_B18221.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![图2.7 – 注册用户](img/Figure_2.7_B18221.jpg)'
- en: Figure 2.7 – Registering a user
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.7 – 注册用户
- en: Let’s see what happens if we try to create a user with the same email and username.
    Hit the `400` error.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如果我们尝试使用相同的电子邮件和用户名创建用户会发生什么。会触发`400`错误。
- en: '![Figure 2.8 – Registering a user with the same email and username](img/Figure_2.8_B18221.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![图2.8 – 使用相同的电子邮件和用户名注册用户](img/Figure_2.8_B18221.jpg)'
- en: Figure 2.8 – Registering a user with the same email and username
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.8 – 使用相同的电子邮件和用户名注册用户
- en: 'Great. We are now sure that the endpoint behaves as we wish. The next step
    will be to add the login endpoint following the same process: writing the serializer
    and the viewset, and then registering the route.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了。我们现在可以确信端点的行为符合我们的期望。下一步将是添加登录端点，按照相同的流程：编写序列化器和视图集，然后注册路由。
- en: Adding the login feature
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加登录功能
- en: 'The login feature will require the email or the username with the password.
    Using the `djangorestframework-simplejwt` package, which provides a serializer
    called `TokenObtainPairSerializer`, we’ll write a serializer to check for user
    authentication but also return a response containing access and refresh tokens.
    For this, we will rewrite the validate method from the `TokenObtainPairSerializer`
    class. Inside the `core/auth/serializers` directory, create a new file called
    `login.py` (this file will contain `LoginSerializer`, a subclass of `TokenObtainPairSerializer`):'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 登录功能将需要电子邮件或用户名和密码。使用提供名为`TokenObtainPairSerializer`的序列化器的`djangorestframework-simplejwt`包，我们将编写一个序列化器来检查用户认证，并返回包含访问和刷新令牌的响应。为此，我们将重写`TokenObtainPairSerializer`类中的`validate`方法。在`core/auth/serializers`目录内，创建一个名为`login.py`的新文件（此文件将包含`LoginSerializer`，它是`TokenObtainPairSerializer`的子类）：
- en: core/auth/serializers/login.py
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: core/auth/serializers/login.py
- en: '[PRE36]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We are surcharging the `validate` method from the `TokenObtainPairSerializer`
    class to adapt it to our needs. That’s why `super` is helpful here. It’s a built-in
    method in Python that returns a temporary object that can be used to access the
    class methods of the base class.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`validate`方法从`TokenObtainPairSerializer`类中提取出来，以适应我们的需求。这就是为什么`super`在这里很有帮助。它是Python中的一个内置方法，返回一个临时对象，可以用来访问基类的类方法。
- en: 'Then, we use `user` to retrieve access and refresh tokens. Once the serializer
    is written, don’t forget to import it to the `__init__.py` file:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用`user`来检索访问和刷新令牌。一旦序列化器编写完成，不要忘记将其导入到`__init__.py`文件中：
- en: core/auth/serializers/__init__.py
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: core/auth/serializers/__init__.py
- en: '[PRE37]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The next step is to add the viewset. We’ll call this viewset `LoginViewset`.
    As we are not directly interacting with a model here, we’ll just be using the
    `viewsets.ViewSet` class:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是添加视图集。我们将把这个视图集命名为`LoginViewset`。由于我们在这里不是直接与模型交互，我们只需使用`viewsets.ViewSet`类：
- en: core/auth/viewsets/login.py
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: core/auth/viewsets/login.py
- en: '[PRE38]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Add the viewset to the `__init__.py` file of the `viewsets` directory:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 将视图集添加到`viewsets`目录的`__init__.py`文件中：
- en: '[PRE39]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We can now import it and register it in the `routers.py` file:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以导入它并在`routers.py`文件中注册它：
- en: core/routers.py
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: core/routers.py
- en: '[PRE40]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The endpoint for login will be available at `/auth/login/`. Let’s try a request
    with Insomnia.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 登录端点将在`/auth/login/`处可用。让我们用Insomnia尝试一个请求。
- en: 'Here’s the body of the request I’ll use:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我将使用的请求体的主体：
- en: '[PRE41]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '![Figure 2.9 – Login with user credentials](img/Figure_2.9_B18221.jpg)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![图2.9 – 使用用户凭据登录](img/Figure_2.9_B18221.jpg)'
- en: Figure 2.9 – Login with user credentials
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.9 – 使用用户凭据登录
- en: The login feature is ready and working like a charm – but we have a little bit
    of an issue. The access token expires in 5 minutes. Basically, to get a new access
    token, the user will have to log in again. Let’s see how we can use the refresh
    token to request a new access token without logging in again.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 登录功能已经准备好并且运行得很好——但我们遇到了一点小问题。访问令牌在5分钟后过期。基本上，为了获取新的访问令牌，用户将不得不再次登录。让我们看看我们如何使用刷新令牌来请求新的访问令牌而无需再次登录。
- en: Refresh logic
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 刷新逻辑
- en: '`djangorestframework-simplejwt` provides a refresh logic feature. As you’ve
    noticed, we’ve been generating refresh tokens and returning them as responses
    every time registration or login is completed. We’ll just inherit the class from
    `TokenRefreshView` and transform it into a viewset.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`djangorestframework-simplejwt`提供了刷新逻辑功能。正如你所注意到的，我们每次完成注册或登录时都会生成刷新令牌并将其作为响应返回。我们将从`TokenRefreshView`类继承并转换成视图集。'
- en: 'In `auth/viewsets`, add a new file called `refresh.py`:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在`auth/viewsets`中，添加一个名为`refresh.py`的新文件：
- en: core/auth/viewsets/refresh.py
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: core/auth/viewsets/refresh.py
- en: '[PRE42]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Now add the class in the `__init__.py` file.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将类添加到`__init__.py`文件中。
- en: core/auth/viewsets/__init__.py
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: core/auth/viewsets/__init__.py
- en: '[PRE43]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'And now register it in the `routers.py` file:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将其注册到`routers.py`文件中：
- en: core/routers.py
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: core/routers.py
- en: '[PRE44]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Great – let’s test the new endpoint at `/auth/refresh/` to get a new token.
    It’ll be a `POST` request with the refresh token in the body of the request, and
    you will receive a new access token in the response:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了——让我们测试新的端点`/auth/refresh/`以获取新的令牌。这将是一个带有请求体中刷新令牌的`POST`请求，你将在响应中收到新的访问令牌：
- en: '![Figure 2.10 – Requesting for a new access token](img/Figure_2.10_B18221.jpg)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![图2.10 – 请求新的访问令牌](img/Figure_2.10_B18221.jpg)'
- en: Figure 2.10 – Requesting for a new access token
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.10 – 请求新的访问令牌
- en: Great – we’ve just learned how to implement refresh token logic in the application.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了——我们刚刚学习了如何在应用程序中实现刷新令牌逻辑。
- en: Summary
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to write an authentication system based on JWT
    for a Django application using DRF and `djangorestframework-simplejwt`. We also
    learned how to extend classes and rewrite the functions.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用DRF和`djangorestframework-simplejwt`为Django应用程序编写基于JWT的认证系统。我们还学习了如何扩展类和重写函数。
- en: In the next chapter, we’ll add the `posts` feature. Our users will be able to
    create a post that can be viewed and liked by other users.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将添加`posts`功能。我们的用户将能够创建一个可以被其他用户查看和点赞的帖子。
- en: Questions
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is a JWT?
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: JWT是什么？
- en: What is Django Rest Framework?
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Django Rest Framework是什么？
- en: What is a model?
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模型是什么？
- en: What is a serializer?
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 序列化器是什么？
- en: What is a viewset?
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 视图集是什么？
- en: What is a router?
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 路由器是什么？
- en: What is the usage of a refresh token?
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 刷新令牌的用途是什么？
