- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Crafting an Interpreter – First Steps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we’ll take our first steps toward constructing a computer simulator
    by constructing a very primitive simulator that can execute only a single instruction.
    Once we’ve taken this step, we can move on by gradually enhancing this simulator.
  prefs: []
  type: TYPE_NORMAL
- en: 'The key topics that we’ll cover in this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Designing a minimal computer with one instruction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing a simple simulator that can decode and execute several instructions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The instruction set of a general-purpose computer called TC1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handing bits in Python (Boolean operations)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decoding an instruction in binary form into its component parts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Executing an instruction after it has been decoded
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arithmetic operations in a computer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing functions in Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Branch and flow control instructions in computer instruction sets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collectively, these topics cover three areas. Some topics expand our knowledge
    of Python to help us construct a simulator. Some topics introduce the instruction
    set of a typical digital computer that we call TC1 (TC1 simply means *Teaching
    Computer 1*). Some topics cover the actual design of TC1 in Python.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will introduce the computer simulator and look at some basic building
    blocks. The actual simulator will be presented in [*Chapter 6*](B19624_06.xhtml#_idTextAnchor091).
  prefs: []
  type: TYPE_NORMAL
- en: Technical Requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can find the programs used in this chapter on GitHub at [https://github.com/PacktPublishing/Practical-Computer-Architecture-with-Python-and-ARM/tree/main/Chapter04](https://github.com/PacktPublishing/Practical-Computer-Architecture-with-Python-and-ARM/tree/main/Chapter04).
  prefs: []
  type: TYPE_NORMAL
- en: An ultra-primitive one-instruction computer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our first *one-instruction interpreter* demonstrates both instruction decoding
    and execution, which are key to all simulators. This computer has a memory with
    nine locations, `mem[0]` to `mem[8]`, arranged as a list of integers. The contents
    of the memory are preset to `mem = [4,6,1,2,7,8,4,4,5]`. The memory locations
    are 0 to 8 and are read left to right in the list; for example, memory location
    0 contains a value of 4, location 1 contains a value of 6, and location 8 contains
    a value of 5.
  prefs: []
  type: TYPE_NORMAL
- en: 'The computer has an array of eight registers, `r[0]` to `r[7]`. These are specified
    in Python via the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The single instruction we are going to execute is `add r[4],mem[3],mem[7]`.
    This instruction adds the contents of memory location 3 to the contents of memory
    location 7 and puts the sum in register 4\. We have chosen to begin with a single-instruction
    computer because it can be expressed in a few lines of Python code and yet it
    performs many of the actions required of a real computer simulator.
  prefs: []
  type: TYPE_NORMAL
- en: We have defined this add memory to memory operation as a demonstration. It’s
    not part of any real computer language. Interestingly, it’s more complex than
    most real computer instructions because it uses memory-to-memory operations rather
    than register-to-register operations.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to write the Python code necessary to read this instruction in
    text form and carry out the action it defines. The two shaded lines in the following
    code take this instruction and split it into a list of tokens that can be processed.
    A token is an element in an instruction (just as a sentence in English can be
    split into tokens that we call words). The tokens here are `'add'`, `'r[4]'`,
    `'mem[3]'`, and `'mem[7]'`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This instruction reads the contents of `mem[3]`, which is 2; reads the contents
    of `mem[7]`, which is 4; adds them together to get 2 + 4 = 6; and then stores
    the value 6 in register 4\. After this instruction has been executed, the value
    of register `r[4]` should be 6:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `inst1 = inst.replace(' ',',')` operation takes the instruction and replaces
    a space with a comma to get `'add r[4],mem[3],mem[7]'`.This is now a string with
    the tokens separated by commas.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to create a list of tokens so that we can access the individual
    components of the instruction. The effect of `inst2 = inst1.split('','')` is to
    create a list of strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The `split()` method takes a string and creates a list of strings using the
    delimiter specified as a parameter. If `y = x.split(''!'')`, the value of `y`
    is a list of strings and the separator is `!`. An example of the use of `split()`
    is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `token2 = inst2[2]` line gives `token2 = 'mem[3]'`; that is, the fourth
    token.
  prefs: []
  type: TYPE_NORMAL
- en: The `value2 = int(token2[4])` line gives `value2 = 3` because the second slice
    is the 3 in the `'mem[3]'` string. Note that we use the `int()` function to convert
    the characters 4, 3, and 7 into integer values. When going from strings to numeric
    operations, you have to remember to convert between character and integer types.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we execute this program, we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve introduced the fundamental components of a simulator, the next
    step is to construct a computer that can handle more instructions, albeit a tiny
    subset of typical operations. However, this is a subset that includes all categories
    of real computer operations.
  prefs: []
  type: TYPE_NORMAL
- en: Building a simple computer interpreter in Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can take the concept of a simulator a step further and execute a program
    with multiple instructions using the concepts we just developed. Consecutive instructions
    are executed by reading them from program memory, one by one, and using a program
    counter to keep track of where we are in the program.
  prefs: []
  type: TYPE_NORMAL
- en: Please be aware of a possible source of confusion when we refer to a *program*.
    We are writing a program in the high-level language Python to simulate a computer.
    That simulated computer runs a program written in assembly language. Consequently,
    the term program can refer to two different entities. It should be clear from
    the context which one we are referring to.
  prefs: []
  type: TYPE_NORMAL
- en: Note that pseudocode is not a computer language, but a method of expressing
    a computer algorithm in almost plain English. So, a piece of pseudocode can represent
    either a high-level language such as Python or an assembly language.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, the source program of assembly language instructions
    is expressed as a Python list, where each instruction is a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The effect of these instructions is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: To simplify the Python code, we’ve used spaces as separators – for example,
    `LDRL r0,0` is written as `LDRL` `r0 0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Real computers store assembly language instructions as strings of 32- or 64-bit
    binary numbers. We’re going to directly execute the assembly language instructions
    from the text string to avoid having to translate text into binary and then interpret
    the binary as instructions. Here, we have one goal: to demonstrate how a program
    is executed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The computer on which the preceding assembly-level code runs has only a handful
    of instructions, although it is very easy to add extra instructions. Throughout
    this text, the term *opcode* or operation code indicates the binary code (or text
    version) of an assembly language instruction such as `ADD` or `BNE`. The structure
    of the simulator program in pseudocode is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This assembly language program, `prog` (provided as a list in the simulator
    code), uses a conditional branch, `BNE 2`, to jump back to instruction 2 if the
    previous operation result was not 0\. The assembly language version in the Python
    program in the following section uses a symbolic name, `Loop`, to indicate the
    target of the branch, but the actual code uses a literal 2\. We will look at how
    symbolic names such as `Loop` are handled later.
  prefs: []
  type: TYPE_NORMAL
- en: Python code for a primitive simulator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following is the Python code for this simulator. The initial series of
    comments on lines 0 to 6 show the assembly language pro :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The interesting part of the code is extracting the operands from the instruction.
    Consider the `ADDL r1 r2 3` instruction, which means add a literal to the source
    register and put the sum in the destination register. The destination register
    is `r1`, the source register is `r2`, and the literal is `3`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Python `inst = inst.split('' '')` operation converts a string into a list
    of substrings using a space as a separator. Therefore, the new value of `inst`
    is the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We can now examine the four fields of this list; for example, `inst[0] = 'ADDL'`
    gives us the actual instruction mnemonic.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose we want to get the contents of the source register, `r2`. The source
    register is in the third position in the list at `['ADDL', 'r1', 'r2', '3']`;
    that is, `inst[2]`. Let’s write `rS1 = inst[2]`. The value of `rS1` is `'r2'`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We want the register number (that is, 2) as an integer, so we have to get the
    second character of r2 and convert it into an integer. We can do this in the following
    way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We can combine these two expressions into one as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The tiny computer we have created executed only five different instructions,
    but it includes many of the most important components of a real computer. This
    computer directly executes instructions from their assembly language form, rather
    than from their binary code. The next step is to look a little more closely at
    instruction sets before we can build a more realistic machine.
  prefs: []
  type: TYPE_NORMAL
- en: Having constructed a simulator, the next step is to look at the type of instructions
    a computer can execute.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will develop an instruction set for the TC1 computer.
    As well as providing a practical example of instruction set design, we will demonstrate
    how instructions are divided into multiple fields and each field supplies some
    information about the current instruction.
  prefs: []
  type: TYPE_NORMAL
- en: The TC1 instruction set
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we will introduce the key component of our demonstration computer:
    its instruction set. This computer, TC1, has many of the functions of a real computer
    and is easy to understand and modify. We will begin by introducing the TC1 instruction
    set encoding.'
  prefs: []
  type: TYPE_NORMAL
- en: To simplify this, we can use separate programs and data memories. This departure
    from the traditional von Neuman model allows us to have a 32-bit program memory
    and a 16-bit data memory. Moreover, we don’t have to worry about accidentally
    putting data in the middle of the program area.
  prefs: []
  type: TYPE_NORMAL
- en: A typical instruction has several fields; for example, operation code, registers,
    and literals (that is, constants). However, the number of bits in each field must
    add up to the total length of the instruction.
  prefs: []
  type: TYPE_NORMAL
- en: Modern computers normally employ different formats for each class of instruction.
    This optimizes the allocation of op-codes to bits; for example, a branch instruction
    may have a 4-bit opcode and a 28-bit literal field, whereas a data-processing
    instruction may have a 17-bit opcode and three 5-bit register-select fields.
  prefs: []
  type: TYPE_NORMAL
- en: For the sake of simplicity, the TC1 computer has a single, fixed format. All
    instructions have the same number of fields, and fields are the same size for
    each instruction. An instruction, as shown in *Figure 4**.1*, is made up of an
    operation *class* plus an opcode, three register fields, and a literal field.
    *Figure 4**.1* shows the opcode field as 7 bits, with a 2-bit opcode class and
    a 5-bit actual opcode.
  prefs: []
  type: TYPE_NORMAL
- en: 'The structure of this instruction format is inefficient because if an instruction
    does not access a register, the three register select fields are wasted. In a
    three-register instruction such as ADD rd,rS1,rS2, the rd register is the destination,
    rS1 is source register 1, and rS2 is source register 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 – TC1 instruction format (RISC style)](img/Figure_4.01_B19624.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.1 – TC1 instruction format (RISC style)
  prefs: []
  type: TYPE_NORMAL
- en: We devote 16 bits to the literal field so that we can load a constant into memory
    with a single instruction. That leaves 32 - 16 = 16 bits to allocate to all the
    other fields.
  prefs: []
  type: TYPE_NORMAL
- en: TC1 has a three-register format, which is typical of load and store computers
    such as ARM and MIPS. If we have eight registers, it takes 3 x 3 = 9 bits to specify
    all three registers. After allocating 16 bits to the literal and 9 bits to the
    register selection, we are left with 32 - (16 + 9) = 7 bits to specify up to 128
    different possible instructions (27 = 128).
  prefs: []
  type: TYPE_NORMAL
- en: 'The opcode field itself is divided into four categories or classes, which take
    two bits, leaving 7- 2 = 5 for the instructions in each category. *Table 4.1*
    defines the categories (class) of instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Class** | **Group** | **Comments** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0 0 | Special operation | Operations that perform functions such as `STOP`
    or read the keyboard |'
  prefs: []
  type: TYPE_TB
- en: '| 0 1 | Data transfer | Operations that copy data from one place to another
    |'
  prefs: []
  type: TYPE_TB
- en: '| 1 0 | Data processing | Arithmetic and logic data-processing operations |'
  prefs: []
  type: TYPE_TB
- en: '| 1 1 | Flow control | Operations that control the sequencing of instructions,
    such as `BEQ` |'
  prefs: []
  type: TYPE_TB
- en: Table 4.1 – TC1 instruction classes
  prefs: []
  type: TYPE_NORMAL
- en: '*Table 4.2* illustrates the TC1 instruction set. The first column (`01 00001`
    loads a register with the contents of a memory location. The leftmost two bits
    are separated to indicate the instruction group:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Binary Code** | **Operation** | **Mnemonic** | **Instruction Format****rrr
    = Rd, aaa = rS1, bbb =** **rS2** | **Code** **Format** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `00 00000` | Stop operation | STOP | 00 00000 000 000 000 0 | 0 0 0 0 |'
  prefs: []
  type: TYPE_TB
- en: '| `00 00001` | No operation | NOP | 00 00001 000 000 000 0 | 0 0 0 0 |'
  prefs: []
  type: TYPE_TB
- en: '| `00` `00 010` | Get a char from the keyboard | GET r0 | 00 00010 rrr 000
    000 0 | 1 0 0 0 |'
  prefs: []
  type: TYPE_TB
- en: '| `00 00011` | Get a random character | RND r0 | 00 00011 rrr 000 000 L | 1
    0 0 1 |'
  prefs: []
  type: TYPE_TB
- en: '| `00 00100` | Swap bytes in the register | SWAP r0 | 00 00100 rrr 000 000
    0 | 1 0 0 0 |'
  prefs: []
  type: TYPE_TB
- en: '| `00 01000` | Print a hex value in the register | PRT r0 | 00 01000 rrr 000
    000 0 | 1 0 0 0 |'
  prefs: []
  type: TYPE_TB
- en: '| `00 11111` | Terminate program | END | 00 11111 000 000 000 0 | 0 0 0 0 |'
  prefs: []
  type: TYPE_TB
- en: '| `01 00000` | Load register from register | MOV r0,r1 | 01 00000 rrr aaa 000
    0 | 1 1 0 0 |'
  prefs: []
  type: TYPE_TB
- en: '| `01 00001` | Load register from memory | LDRM r0,L | 01 00001 rrr 000 000
    L | 1 0 0 1 |'
  prefs: []
  type: TYPE_TB
- en: '| `01 00010` | Load register with literal | LDRL r0,L | 01 00010 rrr 000 000
    L | 1 0 0 1 |'
  prefs: []
  type: TYPE_TB
- en: '| `01 00011` | Load register indirect | LDRI r0,[r1,L] | 01 00011 rrr aaa 000
    L | 1 1 0 1 |'
  prefs: []
  type: TYPE_TB
- en: '| `01 00100` | Store register in memory | STRM r0,L | 01 00100 rrr 000 000
    L | 1 0 0 1 |'
  prefs: []
  type: TYPE_TB
- en: '| `01 00101` | Store register indirect | STRI r0,[r1,L] | 01 00101 rrr aaa
    000 L | 1 1 0 1 |'
  prefs: []
  type: TYPE_TB
- en: '| `10 00000` | Add register to register | ADD r0,r1,r2 | 10 00000 rrr aaa bbb
    0 | 1 1 1 0 |'
  prefs: []
  type: TYPE_TB
- en: '| `10 00001` | Add register to literal | ADDL r0,r1,L | 10 00001 rrr aaa 000
    L | 1 1 0 1 |'
  prefs: []
  type: TYPE_TB
- en: '| `10 00010` | Subtract register from register | SUB r0,r1,r2 | 10 00010 rrr
    aaa bbb 0 | 1 1 1 0 |'
  prefs: []
  type: TYPE_TB
- en: '| `10 00011` | Subtract literal from register | SUBL r0,r1,L | 10 00011 rrr
    aaa 000 L | 1 1 0 1 |'
  prefs: []
  type: TYPE_TB
- en: '| `10 00100` | Multiply register by register | MUL r0,r1,r2 | 10 00100 rrr
    aaa bbb 0 | 1 1 1 0 |'
  prefs: []
  type: TYPE_TB
- en: '| `10 00101` | Multiply literal by register | MULL r0,r1,L | 10 00101 rrr aaa
    000 L | 1 1 0 1 |'
  prefs: []
  type: TYPE_TB
- en: '| `10 00110` | Divide register by register | DIV r0,r1,r2 | 10 00110 rrr aaa
    bbb 0 | 1 1 1 0 |'
  prefs: []
  type: TYPE_TB
- en: '| `10 00111` | Divide register by literal | DIVL r0,r1,L | 10 00111 rrr aaa
    000 L | 1 1 0 1 |'
  prefs: []
  type: TYPE_TB
- en: '| `10 01000` | Mod register by register | MOD r0,r1,r2 | 10 01000 rrr aaa bbb
    0 | 1 1 1 0 |'
  prefs: []
  type: TYPE_TB
- en: '| `10 01001` | Mod register by literal | MOD r0,r1,L | 10 01001 rrr aaa 000
    L | 1 1 0 1 |'
  prefs: []
  type: TYPE_TB
- en: '| `10 01010` | AND register to register | AND r0,r1,r2 | 10 01000 rrr aaa bbb
    0 | 1 1 1 0 |'
  prefs: []
  type: TYPE_TB
- en: '| `10 01011` | AND register to literal | ANDL r0,r1,L | 10 01001 rrr aaa 000
    L | 1 1 0 1 |'
  prefs: []
  type: TYPE_TB
- en: '| `10 01100` | OR register to register | OR r0,r1,r2 | 10 01010 rrr aaa bbb
    0 | 1 1 1 0 |'
  prefs: []
  type: TYPE_TB
- en: '| `10 01101` | OR register to literal | ORL r0,r1,L | 10 01011 rrr aaa 000
    L | 1 1 0 1 |'
  prefs: []
  type: TYPE_TB
- en: '| `10 01110` | EOR register to register | EOR r0,r1,r2 | 10 01010 rrr aaa bbb
    0 | 1 1 1 0 |'
  prefs: []
  type: TYPE_TB
- en: '| `10 01111` | EOR register to literal | EORL r0,r1,L | 10 01011 rrr aaa 000
    L | 1 1 0 1 |'
  prefs: []
  type: TYPE_TB
- en: '| `10 10000` | NOT register | NOT r0 | 10 10000 rrr 000 000 0 | 1 0 0 0 |'
  prefs: []
  type: TYPE_TB
- en: '| `10 10010` | Increment register | INC r0 | 10 10010 rrr 000 000 0 | 1 0 0
    0 |'
  prefs: []
  type: TYPE_TB
- en: '| `10 10011` | Decrement register | DEC r0 | 10 10011 rrr 000 000 0 | 1 0 0
    0 |'
  prefs: []
  type: TYPE_TB
- en: '| `10 10100` | Compare register with register | CMP r0,r1 | 10 10100 rrr aaa
    000 0 | 1 1 0 0 |'
  prefs: []
  type: TYPE_TB
- en: '| `10 10101` | Compare register with literal | CMPL r0,L | 10 10101 rrr 000
    000 L | 1 0 0 1 |'
  prefs: []
  type: TYPE_TB
- en: '| `10 10110` | Add with carry | ADC r0,r1,r2 | 10 10110 rrr aaa bbb 0 | 1 1
    1 0 |'
  prefs: []
  type: TYPE_TB
- en: '| `10 10111` | Subtract with borrow | SBC r0,r1,r2 | 10 10111 rrr aaa bbb 0
    | 1 1 1 0 |'
  prefs: []
  type: TYPE_TB
- en: '| `10 11000` | Logical shift left | LSL r0,L | 10 10000 rrr 000 000 0 | 1 0
    0 1 |'
  prefs: []
  type: TYPE_TB
- en: '| `10 11001` | Logical shift left literal | LSLL r0,L | 10 10000 rrr 000 000
    L | 1 0 0 1 |'
  prefs: []
  type: TYPE_TB
- en: '| `10 11010` | Logical shift right | LSR r0,L | 10 10001 rrr 000 000 0 | 1
    0 0 1 |'
  prefs: []
  type: TYPE_TB
- en: '| `10 11011` | Logical shift right literal | LSRL r0,L | 10 10001 rrr 000 000
    L | 1 0 0 1 |'
  prefs: []
  type: TYPE_TB
- en: '| `10 11100` | Rotate left | ROL r0,L | 10 10010 rrr 000 000 0 | 1 0 0 1 |'
  prefs: []
  type: TYPE_TB
- en: '| `10 11101` | Rotate left literal | ROLL r0,L | 10 10010 rrr 000 000 L | 1
    0 0 1 |'
  prefs: []
  type: TYPE_TB
- en: '| `10 11110` | Rotate right | ROR r0,L | 10 10010 rrr 000 000 0 | 1 0 0 1 |'
  prefs: []
  type: TYPE_TB
- en: '| `10 11111` | Rotate right literal | RORL r0,L | 10 10010 rrr 000 000 L |
    1 0 0 1 |'
  prefs: []
  type: TYPE_TB
- en: '| `11 00000` | Branch unconditionally | BRA L | 11 00000 000 000 000 L | 0
    0 0 1 |'
  prefs: []
  type: TYPE_TB
- en: '| `11 00001` | Branch on zero | BEQ L | 11 00001 000 000 000 L | 0 0 0 1 |'
  prefs: []
  type: TYPE_TB
- en: '| `11 00010` | Branch on not zero | BNE L | 11 00010 000 000 000 L | 0 0 0
    1 |'
  prefs: []
  type: TYPE_TB
- en: '| `11 00011` | Branch on minus | BMI L | 11 00011 000 000 000 L | 0 0 0 1 |'
  prefs: []
  type: TYPE_TB
- en: '| `11 00100` | Branch to subroutine | BSR L | 11 00100 000 000 000 L | 0 0
    0 1 |'
  prefs: []
  type: TYPE_TB
- en: '| `11 00101` | Return from subroutine | RTS | 11 00101 000 000 000 0 | 0 0
    0 0 |'
  prefs: []
  type: TYPE_TB
- en: '| `11 00110` | Decrement and branch on not ٠ | DBNE r0,L | 11 00110 rrr 000
    000 L | 1 0 0 1 |'
  prefs: []
  type: TYPE_TB
- en: '| `11 00111` | Decrement and branch on zero | DBEQ r0,L | 11 00111 rrr 000
    000 L | 1 0 0 1 |'
  prefs: []
  type: TYPE_TB
- en: '| `11 01000` | Push register on the stack | PUSH r0 | 11 01000 rrr 000 000
    0 | 1 0 0 0 |'
  prefs: []
  type: TYPE_TB
- en: '| `11 01001` | Pull register off the stack | PULL r0 | 11 01001 rrr 000 000
    0 | 1 0 0 0 |'
  prefs: []
  type: TYPE_TB
- en: Table 4.2 – TC1 Instruction encoding (the 4 code format bits are not part of
    the opcode)
  prefs: []
  type: TYPE_NORMAL
- en: The rightmost column is called `1001` tells the assembler that the instruction
    requires a destination register and a 16-bit literal. Code 0000 tells us that
    the instruction contains no operands at all.
  prefs: []
  type: TYPE_NORMAL
- en: We chose these instructions to demonstrate a range of operations. Many of these
    instructions are typical of a RISC computer such as ARM (that is, we don’t include
    operations on data in memory). Note that later, we’ll introduce a simulator for
    a memory-to-register instruction set that allows operations such as `ADD r1,12`,
    where `12` is a memory location.
  prefs: []
  type: TYPE_NORMAL
- en: Some instructions in *Table 4.2* don’t exist on a real computer; for example,
    read a character from the keyboard. We added that to simplify debugging and experimentation.
    Similarly, TC1 can generate a random number, a feature not found in most computer
    instruction sets. However, it’s useful for generating random test data. Some instructions,
    such as subroutine calls and returns, implement more sophisticated operations,
    which we shall encounter later.
  prefs: []
  type: TYPE_NORMAL
- en: The column labeled `L` indicates a literal value (that is, a 16-bit constant).
  prefs: []
  type: TYPE_NORMAL
- en: The fourth column (`rrr`, `aaa`, and `bbb` show the location of the three register
    select fields. The rightmost field (`0` or `L`) represents 16 bits of the literal.
    We show `0` if all bits are 0, and `L` if a 16-bit literal is required by the
    instruction. If a register field is not required, the corresponding field is filled
    with zeros (although it doesn’t matter what value these bits are because they
    are not used by the instruction).
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember that the four bits in the rightmost column are not part of the opcode
    or instruction itself. These bits show which fields are required by the current
    instruction: the destination register (`rrr`), the source 1 register (`aaa`),
    the source 2 register (`bb`), and the literal, `L`. For example, code `1100` indicates
    that the instruction has a destination register and a single source register.'
  prefs: []
  type: TYPE_NORMAL
- en: Explaining some of the instructions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some of the instructions in *Table 4.2* are typical of real processors. Several
    instructions have been included to provide useful facilities such as generating
    a random number for testing purposes. This section describes several of the instructions
    in *Table 4.2*.
  prefs: []
  type: TYPE_NORMAL
- en: '`STOP` terminates instruction processing. Most modern computers don’t have
    an explicit `STOP` operation.'
  prefs: []
  type: TYPE_NORMAL
- en: '`NOP` does nothing other than advance the program counter. It’s a dummy operation
    that is useful as a marker in code, a placeholder for future code, or as an aid
    to testing.'
  prefs: []
  type: TYPE_NORMAL
- en: '`GET` reads data from the keyboard and offers a simple way of getting input
    from the keyboard into a register. This is useful when testing programs and is
    not a normal computer instruction.'
  prefs: []
  type: TYPE_NORMAL
- en: '`RND` generates a random number. It’s not in computer instruction sets but
    provides an excellent means of generating data internally when testing your code.'
  prefs: []
  type: TYPE_NORMAL
- en: '`SWAP` exchanges upper- and lower-order bytes – for example, `0x1234` becomes
    `0x3412`.'
  prefs: []
  type: TYPE_NORMAL
- en: The load and store instructions move data between memory and registers. The
    difference between members of this class is the direction (store is computer-to-memory,
    while load is memory-to-computer), size (some computers allow byte, 16-bit, or
    32-bit transfers), and addressing mode (using a literal value, an absolute address,
    or an address from a register).
  prefs: []
  type: TYPE_NORMAL
- en: '`MOV` copies one register to another – for example, `MOV r3,r1` copies the
    contents of `r1` to `r3`. `MOV` is, essentially, an a load register with register
    (LDRR) instruction.'
  prefs: []
  type: TYPE_NORMAL
- en: '`LDRL` loads a register with a literal value – for example, `LDRL r3,20` loads
    register `r3` with `20`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`LDRM` loads a register with the contents of a memory location specified by
    a literal address. `LDRM r1,42` loads `r1` with the contents of memory location
    `42`. This instruction does not exist on modern RISC processors. Most modern processors
    do not allow you to access an absolute memory address,'
  prefs: []
  type: TYPE_NORMAL
- en: '`LDRI`, the load register indexed (or load register indirect) instruction,
    loads a register with the contents of a memory location specified by the contents
    of a register plus a literal address. `LDRM r2,[r3,10]` loads `r2` with the contents
    of the memory location whose address is given by the contents of `r3` plus `10`.
    This instruction is the standard RISC load operation.'
  prefs: []
  type: TYPE_NORMAL
- en: '`STRM`, the store register memory instruction, stores a register at the location
    specified by a literal address. `STRM r2,15` stores register `r2` at memory location
    `15`. RISC processors don’t implement this instruction.'
  prefs: []
  type: TYPE_NORMAL
- en: '`STRI`, the store register indexed instruction, stores a register at the location
    specified by a register plus a literal. `STRI r2,[r6,8]` stores `r2` at the memory
    location whose address is `r6` plus `8`.'
  prefs: []
  type: TYPE_NORMAL
- en: The `STR`, `STRM`, and `STRI` instructions are anomalous because they write
    the source and destination operands in the reverse order to `LDR` (and all other
    processor operations); that is, if you write `LDR r0,PQR`, you should write `STR
    PQR,r0` to indicate the reverse data flow. But, by custom and practice, we don’t.
  prefs: []
  type: TYPE_NORMAL
- en: '`DBNE` We added the decrement and branch on not zero instruction for fun because
    it reminds me of my old Motorola days. The 68000 was a powerful microprocessor
    (at the time) with a 32-bit architecture. It has a decrement and branch instruction
    that is used at the end of a loop. On each pass around the loop, the specified
    register is decremented, and a branch back to a label is made if the counter is
    not -1\. `DBNE r0,L` decrements `r0` and branches to the line numbered `L` if
    the count is not zero.'
  prefs: []
  type: TYPE_NORMAL
- en: Register indirect addressing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Two instructions require a special mention because they are concerned not with
    operations on data but with accessing data in memory. These are `LDRI` and `STRI`,
    both of which use register indirect addressing. In *Table 4.2,* the `0b0100011`
    opcode corresponds to `LDRI` (that is, load register *indirect*). This instruction
    doesn’t give you the actual address of the operand; it tells you where the address
    can be found. The register indirect addressing mode is also called pointer-based
    or indexed addressing. The operand address in memory is given by the contents
    of a register plus an offset; that is, `r[rD]=mem[r[rS1]+lit]`. If we use bold
    and shading, we can make its interpretation a little easier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '*Figure 4**.2* demonstrates the effect of the `LDRI r1,[r0,3]` TC1 instruction,
    where pointer register `r0` contains 100 and the operand is accessed at memory
    address 100 + 3 = 103:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2 – Register indirect addressing](img/Figure_4.02_B19624.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.2 – Register indirect addressing
  prefs: []
  type: TYPE_NORMAL
- en: 'This addressing mode lets you modify addresses while the program is running
    (because you can change the contents of the pointer, `r0`). Pointer-based addressing
    makes it possible to step through a list of items, element by element, simply
    by incrementing the pointer. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We access the element pointed at by `r2` (in this case, the offset is `0`).
    The next line increments `r2` to point to the next element. If this sequence is
    executed in a loop, the data will be accessed element by element.
  prefs: []
  type: TYPE_NORMAL
- en: Computers implement both arithmetic and Boolean (logical) operations. In the
    next section, we’ll briefly look at how Python can be used to simulate logical
    operations at the assembly language level.
  prefs: []
  type: TYPE_NORMAL
- en: Bit-handling in Python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we’ll look at how Python deals with the fundamental component
    of all computer data: the bit. Because simulated computers operate at the level
    of bits, we have to look at how bits are manipulated in Python before we can construct
    a simulator that can perform logical operations such as `AND` and `OR`.'
  prefs: []
  type: TYPE_NORMAL
- en: Computers can operate on entire words as a single entity, or on the individual
    bits of a word. Consequently, we have to be able to perform both bit operations
    and word operations to simulate a computer.
  prefs: []
  type: TYPE_NORMAL
- en: Python lets you input data and display it as a binary string of bits. You can
    operate on individual bits of a string using Boolean operators, and you can shift
    the bits of a word left and right. You have all the tools you need in Python.
    We are now going to look at Python, which lets you operate on the individual bits
    of an integer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because the simulator will operate on binary numbers, we have to exploit several
    Python facilities; for example, a binary value is indicated by prefixing it with
    `0b`. If you want to use the binary equivalent of 15, you must write `0b1111`
    and use it just like a decimal number. The following two operations have the same
    effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Two important binary operators are `>>` (shift right) and `<<` (shift left).
    Shift expressions are written as `p >> q` or `p << q`, where `p` is the number
    to be operated on and `q` is the number of bit positions shifted. Consider the
    following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This shifts `x` two places left to give the new value `0b111011000`. All the
    bits have moved two places left and 0s have been entered at the right-hand end
    to fill the newly vacated positions. The shifted version of `x` now has nine bits,
    rather than seven. However, when we simulate a computer, we have to ensure that,
    whatever we do, the number of bits in a word remains constant. If a register has
    16 bits, any operation you perform on it must yield 16 bits.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can take two words and perform Boolean (bitwise) operations on them; for
    example, C = A & B ANDs together words A and B by calculating ci = ai · bi for
    each bit in the word (that is, for i = 0 to 7). Consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '| **Truth table** **for AND** |'
  prefs: []
  type: TYPE_TB
- en: '| --- |'
  prefs: []
  type: TYPE_TB
- en: '| x | y | z=x & y |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 0 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 1 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 0 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: This gives `x = 0b000001101`, because ANDing a bit with 0 gives a 0 result,
    and ANDing a bit x with 1 gives x, because 1 & 0 = 0 and 1 & 1 = 1, as the truth
    table demonstrates.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Python, hexadecimal numbers are prefixed with `0x`; for example, `0x2F1A`.
    We use hexadecimal numbers in Python programs because they are shorter than binary
    numbers. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Consider the following fragment of Python code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The output from this code is `y` `is 0b1001`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python uses more than 16 bits to represent numbers. To simulate binary arithmetic
    in TC1, we must constrain Python’s numbers to 16 bits. We have to work with the
    longer words provided by Python and chop them down to 16 or 32 bits as necessary.
    Consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Shifting the 16-bit word left two places made it an 18-bit word. ANDing it with
    the `0b1111111111111111` binary value forces it to 16 significant bits.
  prefs: []
  type: TYPE_NORMAL
- en: Operator precedence in Python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, we have to re-learn something that we learned about in high school arithmetic:
    operator precedence. When you use several operators in an expression, you have
    to be aware of operator precedence; that is, which operations are performed before
    others. For example, is 4 * 5 + 3 equal to 23 or 32? All computer languages have
    a hierarchy of operator precedence. The partial list of operator precedence for
    Python is as follows, with the highest precedence first. We often use parentheses
    to make the meaning of expressions clearer, even if it’s not required – for example,
    `(xxx << 4) & (yyy <<` `2)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we’ll look at how an instruction, which is a string of
    1s and 0s, is decoded and the appropriate operation that’s performed.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll take a major step in constructing a simulator – that is, decoding
    a machine-level binary instruction to extract information about the operation
    it is going to simulate.
  prefs: []
  type: TYPE_NORMAL
- en: Decoding and executing an instruction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we’ll look at a few examples of how instructions are encoded
    and decoded. Consider the `ADD r1,r2,r3`, operation (where the codes for registers
    `rD`, `rS1`, and `rS2` are shaded), which is defined in RTL as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[r1]` `←` `[r2] + [``r3]`'
  prefs: []
  type: TYPE_NORMAL
- en: '*Table 4.2* shows that the encoding of `ADD r1,r2,r3` is `10 00000 001 010
    011 0000000000000000`. The corresponding 4-bit format code that defines the registers
    to be used is `1110` because we use three registers and no literal field (remember
    that this 4-bit format code is not part of the opcode but is used by the assembler
    to interpret the instruction).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following Python code shows how we can decode an instruction to extract
    five variables: the operation code (`binOp`); the three registers, `rD`, `rS1`,
    and `rS2`; and a literal. Decoding is performed by shifting the bits of the instruction
    right to move the required field into the least significant position and then
    ANDing it with a mask to remove any other fields. Consider, `xxxxxxx xxx 010 xxx
    xxxxxxxxxxxxxxxx`. If we shift this string 19 places right, we get `0000000000000000000xxxxxxxxxx010`.
    The zeros have been shifted in, and the three bits we’re interested in are right-justified
    in the least significant bits. If we `AND` this with `0b111` to select only the
    three least significant bits, we get `0000000000000000000000000000010` – that
    is, the required register value is now right-justified and we can use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The shift-right operator in Python is `>>` and the bit-wise logical `AND` operator
    is `&`. The mask is expressed as a string of bits (rather than a decimal number)
    because ANDing with binary 111 is clearer than ANDing with decimal 7\. In Python,
    a binary value is preceded by 0b, so 7 is represented by `0b111`. The literal
    is ANDed with 16 ones, expressed as `0xFFFF`. We use binary for short fields,
    and hex value for long fields. It’s just personal preference.
  prefs: []
  type: TYPE_NORMAL
- en: The `binCode >> 22 & 0b111` expression shifts the bits of `binCode` 22 places
    right, and then bitwise ANDs the result with `000…000111`. Because of operator
    precedence, the shifting is performed first. Otherwise, we would have written
    `(binCode >> 22) & 0b111`. We often use parentheses, even when not strictly necessary,
    to stress operator precedence.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we extract all fields, even though they may not be required by each
    instruction. Similarly, we read all three register’s contents. This approach simplifies
    the Python code, at the cost of efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: Consider extracting the destination register field, `rrr`. Suppose that the
    instruction is `ADD r1,r2,r3`, and the opcode is `10`00000001010`011`0000000000000000\.
    We have put alternate fields in bold font and the destination field is shaded
    to make it easier to read. Performing a 22-bit right shift moves the destination
    register into the least-significant bits and leaves us with
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we perform the `AND` operation with 111 (all bits to the left are zero),
    we get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We have now isolated the first register field to get `001`, which corresponds
    to register `r1`. The final three lines of the program to decode an instruction
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: These instructions use the register addresses (`rD`, `rS1`, and `rS2`) to access
    registers; that is, the instruction specifies which registers are to be used.
    For example, if `op0 = r[5],` register `r5` is operand zero, the destination register.
    If an instruction does not specify a register, the unused field is set to zero.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once an instruction has been decoded, it can be executed. Fortunately, executing
    most instructions is remarkably easy. Consider the following examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This fragment of code demonstrates the execution of four instructions from the
    load and store (that is, memory access) group. The Python `if … elif` construct
    tests each opcode in turn. The first line compares the 7-bit opcode with the binary
    value `0100010`, which corresponds to the `LDRL` (load a register with a literal
    value) instruction. Incidentally, in the final version of TC1, we made the code
    easier to read by comparing operations with the actual mnemonic; for example,
    `'LDRL'` is easier to read than its code, `0b100010`.
  prefs: []
  type: TYPE_NORMAL
- en: If there is a match, the code following the colon is executed, `(r[rD] = lit)`.
    If not, the next line uses the `elif` command to compare the opcode with 010001\.
    If there is a match, the code after the colon is executed. In this way, the opcode
    is compared with all its possible values until a match is found.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose the instruction’s opcode is `0100010`, and the `r[rD] = lit` line is
    executed. This Python operation transfers the value of the 16-bit literal provided
    in the instruction to the destination register specified in the instruction. In
    RTL terms, it carries out `r[rD] ← lit` and is used by the programmer to load
    an integer into a register. Let’s say the binary pattern of the instruction code
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Here, the 16-bit literal is loaded into register `r6` to implement `LDRL r6,193`.
  prefs: []
  type: TYPE_NORMAL
- en: Arithmetic and logical operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The arithmetic and logical group of operations do all the work (data processing)
    in a program. They include arithmetic operations (addition, subtraction, and multiplication),
    as well as logical operations (`AND`, `OR`, `EOR`, and `NOT`). These are three-operand
    instructions, apart from `NOT`; for example, `AND r``3,r0,r5` performs a bitwise
    `AND` between the bits of `r0` and `r5`, and puts the result in `r3`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following fragment of Python code shows how TC1 interprets four instructions
    in this group. There are two pairs of instructions: addition and subtraction.
    Each pair consists of a register-to-register operation and a register-with-literal
    operation; for example, `ADD r1,r2,r3` adds the contents of registers `r2` and
    `r3` together, whereas `ADDL r1,r2,L` adds the contents of a 16-bit literal to
    the contents of register `r2`. We don’t do the arithmetic here. Instead, we call
    a function called `alu(f,a,b)` to perform the required action. The next section
    will show you how to create your own functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: If you were to write the full Python code required to execute each operation,
    it would require several lines of code per instruction. An addition operation
    such as `reg[dest] = reg[src1] + reg[src2]` appears simple enough, but there is
    more to an arithmetic operation.
  prefs: []
  type: TYPE_NORMAL
- en: To explain why, we need to discuss the role of conditional flag bits. Recall
    that computers make decisions regarding whether to execute the next instruction
    in sequence, or whether to jump to a different place in the code (that is, an
    `if…then…else` construct). The decision whether to take the `if` branch or the
    `else` branch is determined by the outcome of an arithmetic or logical operation
    (this includes compare operations).
  prefs: []
  type: TYPE_NORMAL
- en: The result of an arithmetic or logical operation is tested and used to set or
    clear condition code flags. These flags are usually the negative, zero, carry,
    and overflow flags and are written as `n`, `z`, `c`, and `v`. For example, if
    an operation is x = p – q and the result is x = 0, then the z-bit (zero bit) is
    set to 1\. Similarly, if an operation yields a result that cannot be represented
    in 16 bits, the carry bit, c, is set. Because most computers use two’s complement
    arithmetic, the negative flag, n, is set if the result is negative in two’s complement
    terms (that is, its most significant bit is 1). The v-bit indicates arithmetic
    overflow and is set if the result is out of range. This means that two positive
    numbers have been added and the result is negative, or two negative numbers have
    been added and the result is positive.
  prefs: []
  type: TYPE_NORMAL
- en: '*Table 4.3* demonstrates how 4 bits can be allocated to the numbers 0 to 15
    (unsigned) or -8 to 7 (signed two’s complement). It’s up to the programmer to
    choose the convention. However, the arithmetic remains the same for both conventions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider 0110 + 1100, which is 10010 (or 0010 in 4 bits). If we interpret these
    figures as unsigned, the calculation gives us 6 + 12 = 2, which is incorrect,
    because the result 18 cannot be represented in 4 bits. If we consider these as
    signed values, the calculation is 6 + -4 = 2 and the result is correct:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **8** | **4** | **2** | **1** | **Unsigned value** | **Signed value** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 0 | 0 | 0 | 0 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 0 | 0 | 1 | 1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 0 | 1 | 0 | 2 | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 0 | 1 | 1 | 3 | 3 |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 1 | 0 | 0 | 4 | 4 |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 1 | 0 | 1 | 5 | 5 |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 1 | 1 | 0 | 6 | 6 |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 1 | 1 | 1 | 7 | 7 |'
  prefs: []
  type: TYPE_TB
- en: '| 8 | 4 | 2 | 1 |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 0 | 0 | 0 | 8 | -8 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 0 | 0 | 1 | 9 | -7 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 0 | 1 | 0 | 10 | -6 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 0 | 1 | 1 | 11 | -5 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 1 | 0 | 0 | 12 | -4 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 1 | 0 | 1 | 13 | -3 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 1 | 1 | 0 | 14 | -2 |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 1 | 1 | 1 | 15 | -1 |'
  prefs: []
  type: TYPE_TB
- en: Table 4.3 – A representation of 4-bit values in signed and unsigned forms
  prefs: []
  type: TYPE_NORMAL
- en: Two’s complement arithmetic – a note
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There are several ways of representing negative numbers in binary arithmetic.
    One of the oldest is called sign and magnitude, where a number is prefixed by
    0 if it’s positive and 1 if it’s negative. This is not used today in binary arithmetic
    (except for floating-point numbers).
  prefs: []
  type: TYPE_NORMAL
- en: Two’s complement notation is used by almost all modern computers to represent
    signed integers. In two’s complement arithmetic, if N is a positive number in
    n bits, the value of -N is given by 2n – 1\. The two’s complement of N can be
    calculated easily by inverting the bits and adding 1\. For example, if N = `000110`
    in six bits, the value of -6 is represented by `111010`.
  prefs: []
  type: TYPE_NORMAL
- en: The advantage of two’s complement arithmetic is that addition and subtraction
    are performed in the same way. If you add a two’s complement value to another
    number, the result is correctly calculated. For example, if we add 9 (that is,
    `001001`) to the previous value of -6, we get `001001` + `111010` = `1000011`,
    which is +3 in six bits. The carry-out (in bold font) is discarded.
  prefs: []
  type: TYPE_NORMAL
- en: Zero, carry, and sign bits
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The carry and sign bits are used to determine whether a result is in range
    or out of range. In signed arithmetic, the result of a two’s complement addition
    of S = A+B is out of range, if the sign bits of A and B are both 0 and the sign
    bit of S is 1, or if the sign bits of A and B are both 1 and the sign bit of S
    is 0\. Consider addition and subtraction using four bits. Two’s complement arithmetic
    is used, and the leftmost bit is the sign bit. In each case, we’ve performed a
    two’s complement addition on signed numbers. The results give us the state of
    the flag bits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: How do we know whether a number is signed or unsigned? We don’t! There is no
    difference. If you use signed numbers, you must interpret the result as a signed
    value. If you use unsigned numbers, you must interpret the result as an unsigned
    value. For example, in four bits, 1110 is both -2 and +14, depending on how you
    look at it.
  prefs: []
  type: TYPE_NORMAL
- en: The next topic deals with how we handle groups of repetitive operations. If
    the same sequence of operations is going to be used more than once in a program,
    it makes sense to combine them into a group and invoke that group whenever you
    need it. In Python, this group of actions is called a function.
  prefs: []
  type: TYPE_NORMAL
- en: Functions in Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will now describe Python’s functions. We’ve already used functions that
    are part of the language, such as `len()`. In this section, we’ll do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Explain why functions are useful
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide an example of a function to implement an ALU
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explain how variables can be private to a function or shared between functions
    (scope)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Describe how parameters are passed to functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Describe how a function returns a result
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing the Python code to deal with each arithmetic or logical operation implemented
    by a simulator would be tedious because so much code would be replicated by individual
    instructions. Instead, we can create a Python function (that is, a subroutine
    or procedure) that carries out both the arithmetic/logic operation and the appropriate
    flag-bit setting.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider a Python function called `alu(f,p,q)` that returns an integer that
    is a function of the `f`, `p`, and `q` parameters. The operation to be performed
    is passed to the procedure as an integer, `f`. The function also updates the z
    and n flag bits. This is a simplified version of the actual function we will use
    and will provide just two operations, add and subtract, and update only two flag
    bits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The function is introduced by `def`, its name, and any parameters followed by
    a colon. The body of the function is indented. The first parameter, `f`, selects
    the operation we wish to perform (`f` = 1 for addition and 2 for subtraction).
    The next two input parameters, `p` and `q`, are the data values used by the function.
    The last line of the function returns the result to the function’s calling point.
    This function can be called by, for example, `opVal = alu(2,s1,s2)`. In this case,
    the result, `opVal`, would be the value of `s1 –` `s2`.
  prefs: []
  type: TYPE_NORMAL
- en: We also update two flag bits, `z` and `n`. Initially, both `z` and `n` are set
    to zero by `z, n = 0, 0`. (Python allows multiple assignments on the same line;
    for example, `a,b,c = 1,5,0` sets `a`, `b`, and `c` to 1, 5, and 0, respectively.)
  prefs: []
  type: TYPE_NORMAL
- en: You can pass data to a function via parameters and receive a result via `return()`.
    However, you can declare variables in a function as `global`, which means they
    can be accessed and modified as if they were part of the calling program.
  prefs: []
  type: TYPE_NORMAL
- en: '`return()` is not mandatory because some functions don’t return a value. You
    can have multiple `return()` statements in a function because you can return from
    more than one point in a function. A return can pass multiple values because Python
    permits multiple assignments on a line; for example, see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Testing for a zero result can easily be done by comparing the result, `r`, with
    0\. Testing for a negative result is harder. In two’s complement arithmetic, a
    signed value is negative if the most significant bit is 1\. We are using 16-bit
    arithmetic, so that corresponds to bit 15\. We can extract bit 15 by ANDing the
    result, `r`, with the binary value of 1000000000000000 by writing `r&0x8000` (the
    literal is expressed in hex form as 0x8000, which is mercifully shorter than the
    binary version).
  prefs: []
  type: TYPE_NORMAL
- en: 'To call the function, we can write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: We test for opcode 1000000 and call the `alu` function if it corresponds to
    `ADD`. The function is called with the `f = 1` parameter for addition; the numbers
    to be added are the contents of the two source registers. The result is loaded
    into the `r[rD]` register. In the current version of TC1, we use the opcode to
    look up the mnemonic and then apply the test if `mnemonic == 'ADD':`. This approach
    is easier to read and can use the mnemonic when displaying the output during tracing.
  prefs: []
  type: TYPE_NORMAL
- en: We have made the `z` and `n` variables global (that is, they can be changed
    by the function and accessed externally). If we didn’t make them global, we would
    have to have made them return parameters. In general, it is regarded as a better
    practice to pass variables as parameters rather than making them global.
  prefs: []
  type: TYPE_NORMAL
- en: Functions and scope
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Variables are associated with *scope* or *visibility*. If you write a program
    without functions, variables can be accessed everywhere in the program. If you
    use functions, life becomes rather more complex.
  prefs: []
  type: TYPE_NORMAL
- en: If you declare a variable in the main body, that variable will be visible in
    functions (that is, you can use it). However, you cannot change it in the function
    and then access the new value outside the function. What goes on in the function
    stays in the function. If you wish to access it from outside the function, you
    must declare it as *global*. If you write `global temp3`, then the `temp3` variable
    is the same variable both in and outside the function.
  prefs: []
  type: TYPE_NORMAL
- en: If you create a variable in a function, that variable cannot be accessed outside
    the function because it’s private to the function (a local variable). You can
    create a variable with the same name in another function or the body of the program,
    but the variable in this function has no effect on variables with the same name
    outside the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you create a variable in a function that you want to be visible outside
    the function, you have to declare it as global in the function. Consider the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'After running this code, we get the following. As you can see, the function
    changes `q` because it is global, whereas `p` does not change since it is a local
    variable in the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a summary of the rules:'
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t change it in a function, you can use it anywhere
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you declare it in a function, it’s all yours and private to the function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you want to change it in the function and use it outside the function, then
    declare it as global in the function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This means that variables such as the `z` and `n` condition code flags can
    be accessed in a function. If you wish to change them in a function, they must
    be declared as global by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: If a function returns a value, it ends with `return(whatever)`. If you don’t
    return a value from a function, the `return` statement is not necessary. However,
    we usually include a `return()` that returns nothing, and then we explicitly mark
    the end of the function.
  prefs: []
  type: TYPE_NORMAL
- en: Although the use of global variables is supported by Python, some programmers
    avoid them because global variables make it too easy to accidentally change a
    variable in a function and not notice it, leading to headaches when debugging
    a faulty program. They argue that all variables should be passed to a function
    as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll describe the very thing that makes a computer a computer
    – its ability to take two different courses of action, depending on the outcome
    of an operation.
  prefs: []
  type: TYPE_NORMAL
- en: Branches and flow control
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'All microprocessors have flow control instructions; for example, the unconditional
    branch, `BRA XYZ`, means execute the next instruction at address `XYZ`. A typical
    conditional instruction is `BNE` `XYZ`, which implements taking the branch to
    the instruction at location `XYZ`, if and only if, the z flag is not set. The
    `BNE` mnemonic means “branch on not equal” because the z-bit is evaluated by comparing
    two values using subtraction. Consider the following example, which uses the TC1
    assembly language:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Load register with a literal (`LDRL`) is used three times to load `r2` with
    0, `r0` with 5, and `r1` with 1\. In the line labeled `Loop`, we add `r2` to `r1`
    and put the result in `r2`. On its first execution, `r2` becomes 0 + 1 = 1.
  prefs: []
  type: TYPE_NORMAL
- en: The next two lines increment `r1` and decrement r0 so that `r1` becomes 2 and
    `r0` becomes 4\. When we decrement `r0`, the z-flag is set if the result is zero.
    Since r2 initially contains 5 and then 4 after decrementing, the result is not
    zero and the z-flag is not set.
  prefs: []
  type: TYPE_NORMAL
- en: When `BNE` is executed, the z-flag is tested. If it is not zero, a branch is
    taken to the line labeled `Loop` and the same batch of four instructions are executed
    again. When the `BNE` is encountered a second time, the z-bit is still zero, because
    this time the decrement went from 4 to 3\. Eventually, `r0` contains 1 and is
    decremented to 0\. The z-bit is then set. When `BNE` is next executed, the branch
    to loop is not taken, and the next instruction in the sequence, `STOP`, is executed.
    The loop is repeated 5 times. This program evaluates 1 + 2 + 3 + 4 + 5 = 15, which
    is the result in `r2`.
  prefs: []
  type: TYPE_NORMAL
- en: Branch addresses can be a little complicated. You can provide an absolute address;
    for example, `BRA 24` jumps to the instruction at memory location 24\. Most computers
    use a relative address, which is relative to the current instruction. For example,
    in this case, we would branch three instructions back from the current location
    (that is, the `BNE` instruction). So, you might think that the relative address
    is -3\. It is a negative address because it is backward from the current address.
    Since the program counter has already been incremented to point to the next instruction,
    the branch back is -4\. So, the literal field of the `BNE` loop would be -4.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following fragment of code demonstrates testing four branch instructions
    and their implementation. In this example, we are using relative addressing for
    the branch; that is, the target address is specified with respect to the program
    counter. The first branch, `BRA`, is an unconditional branch and the next value
    of `pc` is calculated. All the others are conditional branches, and `pc` is changed
    only if the required condition is met. Note that the last operation is `BMI`,
    which means branch on minus, although some call it branch on negative (which has
    the same meaning):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '`The pc` is incremented by `pc + literal`. However, since backward branches
    are represented in two’s complement form, it is necessary to `AND` the result
    with 0xFFFF to force it to 16 bits to generate the correct value. This is because
    we are simulating 16-bit arithmetic using a computer language, Python, that represents
    numbers with more than 16 bits. This is just an unfortunate consequence of computer
    arithmetic that you have to be aware of when simulating binary arithmetic.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will return to Python and extend our ability to handle
    data structures and use Python’s functions.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We started this chapter by designing a computer simulator. However, we haven’t
    created a final product yet. Instead, we looked at some of the issues involved,
    such as the nature of an instruction set and the structure of an opcode.
  prefs: []
  type: TYPE_NORMAL
- en: We examined how an instruction can be decoded and how it can be executed. We
    also took the opportunity to broaden our knowledge of Python and introduced Python’s
    bit-manipulation facilities, which let us implement machine-level instructions
    that operate on bits.
  prefs: []
  type: TYPE_NORMAL
- en: We also introduced an important component of Python, known as a function, which
    allows the programmer to create a self-contained unit of code that can be called
    to perform a specific job from many points in a program. Functions are vital to
    modern programming because they facilitate elegant design by bundling a complex
    sequence of operations into a unit, which you call to carry out a task.
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 5*](B19624_05.xhtml#_idTextAnchor075), we’ll return to Python and
    look at some topics in a little more depth – in particular, lists. Lists are probably
    Python’s most interesting and important feature.
  prefs: []
  type: TYPE_NORMAL
