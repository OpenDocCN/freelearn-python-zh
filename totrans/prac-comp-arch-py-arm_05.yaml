- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Crafting an Interpreter – First Steps
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译解释器 – 第一步
- en: In this chapter, we’ll take our first steps toward constructing a computer simulator
    by constructing a very primitive simulator that can execute only a single instruction.
    Once we’ve taken this step, we can move on by gradually enhancing this simulator.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过构建一个只能执行单个指令的非常原始的模拟器来迈出构建计算机模拟器的第一步。一旦我们迈出这一步，我们就可以通过逐步增强这个模拟器来继续前进。
- en: 'The key topics that we’ll cover in this chapter are as follows:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖的关键主题如下：
- en: Designing a minimal computer with one instruction
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用一条指令设计最小计算机
- en: Designing a simple simulator that can decode and execute several instructions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计一个可以解码和执行多个指令的简单模拟器
- en: The instruction set of a general-purpose computer called TC1
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 被称为TC1的通用计算机指令集
- en: Handing bits in Python (Boolean operations)
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Python中处理位（布尔运算）
- en: Decoding an instruction in binary form into its component parts
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将二进制形式的指令解码为其组成部分
- en: Executing an instruction after it has been decoded
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解码后执行指令
- en: Arithmetic operations in a computer
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算机中的算术运算
- en: Designing functions in Python
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Python中设计函数
- en: Branch and flow control instructions in computer instruction sets
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算机指令集中的分支和流程控制指令
- en: Collectively, these topics cover three areas. Some topics expand our knowledge
    of Python to help us construct a simulator. Some topics introduce the instruction
    set of a typical digital computer that we call TC1 (TC1 simply means *Teaching
    Computer 1*). Some topics cover the actual design of TC1 in Python.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这些主题共同涵盖了三个领域。一些主题扩展了我们对Python的了解，帮助我们构建模拟器。一些主题介绍了典型数字计算机的指令集，我们称之为TC1（TC1简单意味着*教学计算机1*）。一些主题涵盖了TC1在Python中的实际设计。
- en: This chapter will introduce the computer simulator and look at some basic building
    blocks. The actual simulator will be presented in [*Chapter 6*](B19624_06.xhtml#_idTextAnchor091).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍计算机模拟器并查看一些基本构建块。实际的模拟器将在[*第6章*](B19624_06.xhtml#_idTextAnchor091)中介绍。
- en: Technical Requirements
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find the programs used in this chapter on GitHub at [https://github.com/PacktPublishing/Practical-Computer-Architecture-with-Python-and-ARM/tree/main/Chapter04](https://github.com/PacktPublishing/Practical-Computer-Architecture-with-Python-and-ARM/tree/main/Chapter04).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub上找到本章使用的程序，链接为[https://github.com/PacktPublishing/Practical-Computer-Architecture-with-Python-and-ARM/tree/main/Chapter04](https://github.com/PacktPublishing/Practical-Computer-Architecture-with-Python-and-ARM/tree/main/Chapter04)。
- en: An ultra-primitive one-instruction computer
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个超原始的单指令计算机
- en: Our first *one-instruction interpreter* demonstrates both instruction decoding
    and execution, which are key to all simulators. This computer has a memory with
    nine locations, `mem[0]` to `mem[8]`, arranged as a list of integers. The contents
    of the memory are preset to `mem = [4,6,1,2,7,8,4,4,5]`. The memory locations
    are 0 to 8 and are read left to right in the list; for example, memory location
    0 contains a value of 4, location 1 contains a value of 6, and location 8 contains
    a value of 5.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个*单指令解释器*演示了指令解码和执行，这是所有模拟器的关键。这台计算机有一个九个位置的内存，`mem[0]`到`mem[8]`，排列成一个整数列表。内存的内容预设为`mem
    = [4,6,1,2,7,8,4,4,5]`。内存位置为0到8，在列表中从左到右读取；例如，内存位置0包含值为4，位置1包含值为6，位置8包含值为5。
- en: 'The computer has an array of eight registers, `r[0]` to `r[7]`. These are specified
    in Python via the following:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机有一个包含八个寄存器的数组，`r[0]`到`r[7]`。这些在Python中通过以下方式指定：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The single instruction we are going to execute is `add r[4],mem[3],mem[7]`.
    This instruction adds the contents of memory location 3 to the contents of memory
    location 7 and puts the sum in register 4\. We have chosen to begin with a single-instruction
    computer because it can be expressed in a few lines of Python code and yet it
    performs many of the actions required of a real computer simulator.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要执行的单一指令是`add r[4],mem[3],mem[7]`。这条指令将内存位置3的内容与内存位置7的内容相加，并将和放入寄存器4。我们选择从单指令计算机开始，因为它可以用几行Python代码表达，同时它执行了许多真实计算机模拟器所需的操作。
- en: We have defined this add memory to memory operation as a demonstration. It’s
    not part of any real computer language. Interestingly, it’s more complex than
    most real computer instructions because it uses memory-to-memory operations rather
    than register-to-register operations.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这种内存到内存的操作定义为演示。它不是任何真实计算机语言的一部分。有趣的是，它比大多数真实计算机指令更复杂，因为它使用内存到内存操作而不是寄存器到寄存器操作。
- en: We are going to write the Python code necessary to read this instruction in
    text form and carry out the action it defines. The two shaded lines in the following
    code take this instruction and split it into a list of tokens that can be processed.
    A token is an element in an instruction (just as a sentence in English can be
    split into tokens that we call words). The tokens here are `'add'`, `'r[4]'`,
    `'mem[3]'`, and `'mem[7]'`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写必要的 Python 代码来以文本形式读取这个指令并执行它定义的操作。下面代码中的两条阴影行将这个指令分割成一个可以处理的标记列表。标记是指令中的一个元素（就像英语中的句子可以被分割成我们称之为单词的标记一样）。这里的标记是
    `'add'`、`'r[4]'`、`'mem[3]'` 和 `'mem[7]'`。
- en: 'This instruction reads the contents of `mem[3]`, which is 2; reads the contents
    of `mem[7]`, which is 4; adds them together to get 2 + 4 = 6; and then stores
    the value 6 in register 4\. After this instruction has been executed, the value
    of register `r[4]` should be 6:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这个指令读取 `mem[3]` 的内容，它是 2；读取 `mem[7]` 的内容，它是 4；将它们相加得到 2 + 4 = 6；然后将值 6 存储在寄存器
    4 中。执行此指令后，寄存器 `r[4]` 的值应该是 6：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `inst1 = inst.replace(' ',',')` operation takes the instruction and replaces
    a space with a comma to get `'add r[4],mem[3],mem[7]'`.This is now a string with
    the tokens separated by commas.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`inst1 = inst.replace('' '','','')` 操作将指令中的空格替换为逗号，得到 `''add r[4],mem[3],mem[7]''`。现在这是一个由逗号分隔的标记字符串。'
- en: 'The next step is to create a list of tokens so that we can access the individual
    components of the instruction. The effect of `inst2 = inst1.split('','')` is to
    create a list of strings:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建一个标记列表，以便我们可以访问指令的各个组成部分。`inst2 = inst1.split(',')` 的效果是创建一个字符串列表：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `split()` method takes a string and creates a list of strings using the
    delimiter specified as a parameter. If `y = x.split(''!'')`, the value of `y`
    is a list of strings and the separator is `!`. An example of the use of `split()`
    is shown here:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`split()` 方法接受一个字符串，并使用指定的分隔符创建一个字符串列表。如果 `y = x.split(''!'')`，则 `y` 的值是一个字符串列表，分隔符是
    `!`。下面展示了 `split()` 的一个使用示例：'
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `token2 = inst2[2]` line gives `token2 = 'mem[3]'`; that is, the fourth
    token.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`token2 = inst2[2]` 这一行给出 `token2 = ''mem[3]''`；即第四个标记。'
- en: The `value2 = int(token2[4])` line gives `value2 = 3` because the second slice
    is the 3 in the `'mem[3]'` string. Note that we use the `int()` function to convert
    the characters 4, 3, and 7 into integer values. When going from strings to numeric
    operations, you have to remember to convert between character and integer types.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`value2 = int(token2[4])` 这一行给出 `value2 = 3`，因为第二个切片是 `''mem[3]''` 字符串中的 3。注意我们使用
    `int()` 函数将字符 4、3 和 7 转换为整数值。当从字符串到数值操作时，你必须记住在字符和整数字符类型之间进行转换。'
- en: 'If we execute this program, we get the following output:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们执行这个程序，我们会得到以下输出：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now that we’ve introduced the fundamental components of a simulator, the next
    step is to construct a computer that can handle more instructions, albeit a tiny
    subset of typical operations. However, this is a subset that includes all categories
    of real computer operations.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了模拟器的基本组件，下一步是构建一个可以处理更多指令的计算机，尽管这只是典型操作的微小子集。然而，这个子集包括了所有真实计算机操作类别。
- en: Building a simple computer interpreter in Python
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Python 中构建一个简单的计算机解释器
- en: We can take the concept of a simulator a step further and execute a program
    with multiple instructions using the concepts we just developed. Consecutive instructions
    are executed by reading them from program memory, one by one, and using a program
    counter to keep track of where we are in the program.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将模拟器的概念进一步发展，并使用我们刚刚开发的概念执行包含多个指令的程序。连续的指令通过从程序内存中逐个读取它们来执行，并使用程序计数器来跟踪我们在程序中的位置。
- en: Please be aware of a possible source of confusion when we refer to a *program*.
    We are writing a program in the high-level language Python to simulate a computer.
    That simulated computer runs a program written in assembly language. Consequently,
    the term program can refer to two different entities. It should be clear from
    the context which one we are referring to.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当我们提到一个 *程序* 时可能存在的一个混淆来源。我们正在用高级语言 Python 编写程序来模拟计算机。那个模拟计算机运行的是汇编语言编写的程序。因此，程序这个术语可以指两个不同的实体。应该从上下文中清楚我们指的是哪一个。
- en: Note that pseudocode is not a computer language, but a method of expressing
    a computer algorithm in almost plain English. So, a piece of pseudocode can represent
    either a high-level language such as Python or an assembly language.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，伪代码不是一种计算机语言，而是一种用几乎纯英语表达计算机算法的方法。因此，一段伪代码可以代表高级语言（如 Python）或汇编语言。
- en: 'In the following example, the source program of assembly language instructions
    is expressed as a Python list, where each instruction is a string:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，汇编语言指令的源程序以 Python 列表的形式表达，其中每个指令都是一个字符串：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The effect of these instructions is as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指令的效果如下：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: To simplify the Python code, we’ve used spaces as separators – for example,
    `LDRL r0,0` is written as `LDRL` `r0 0`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化 Python 代码，我们使用了空格作为分隔符——例如，`LDRL r0,0` 被写成 `LDRL` `r0 0`。
- en: 'Real computers store assembly language instructions as strings of 32- or 64-bit
    binary numbers. We’re going to directly execute the assembly language instructions
    from the text string to avoid having to translate text into binary and then interpret
    the binary as instructions. Here, we have one goal: to demonstrate how a program
    is executed.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 真实计算机将汇编语言指令存储为 32 位或 64 位二进制数字的字符串。我们将直接从文本字符串中执行汇编语言指令，以避免将文本转换为二进制，然后再将二进制作为指令进行解释。在这里，我们有一个目标：展示程序是如何执行的。
- en: 'The computer on which the preceding assembly-level code runs has only a handful
    of instructions, although it is very easy to add extra instructions. Throughout
    this text, the term *opcode* or operation code indicates the binary code (or text
    version) of an assembly language instruction such as `ADD` or `BNE`. The structure
    of the simulator program in pseudocode is as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行上述汇编级代码的计算机上，尽管添加额外指令非常容易，但只有少数指令。在整个文本中，术语 *opcode* 或操作码表示汇编语言指令（如 `ADD`
    或 `BNE`）的二元代码（或文本版本）。模拟器程序的伪代码结构如下：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This assembly language program, `prog` (provided as a list in the simulator
    code), uses a conditional branch, `BNE 2`, to jump back to instruction 2 if the
    previous operation result was not 0\. The assembly language version in the Python
    program in the following section uses a symbolic name, `Loop`, to indicate the
    target of the branch, but the actual code uses a literal 2\. We will look at how
    symbolic names such as `Loop` are handled later.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这个汇编语言程序，`prog`（在模拟器代码中作为列表提供），使用条件分支 `BNE 2`，如果前一个操作结果不是 0，则跳回指令 2。在下一段 Python
    程序中的汇编语言版本使用符号名 `Loop` 来指示分支的目标，但实际上代码使用的是字面量 2。我们将在稍后查看如何处理像 `Loop` 这样的符号名。
- en: Python code for a primitive simulator
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 原始模拟器的 Python 代码
- en: 'The following is the Python code for this simulator. The initial series of
    comments on lines 0 to 6 show the assembly language pro :'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码是此模拟器的 Python 代码。从第 0 行到第 6 行的初始注释显示了汇编语言程序：
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The interesting part of the code is extracting the operands from the instruction.
    Consider the `ADDL r1 r2 3` instruction, which means add a literal to the source
    register and put the sum in the destination register. The destination register
    is `r1`, the source register is `r2`, and the literal is `3`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的有趣部分是从指令中提取操作数。考虑 `ADDL r1 r2 3` 指令，这意味着将一个字面量加到源寄存器上，并将和放入目标寄存器。目标寄存器是 `r1`，源寄存器是
    `r2`，字面量是 `3`。
- en: 'The Python `inst = inst.split('' '')` operation converts a string into a list
    of substrings using a space as a separator. Therefore, the new value of `inst`
    is the following list:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的 `inst = inst.split(' ')` 操作使用空格作为分隔符将字符串转换为子字符串列表。因此，`inst` 的新值是以下列表：
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We can now examine the four fields of this list; for example, `inst[0] = 'ADDL'`
    gives us the actual instruction mnemonic.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以检查这个列表的四个字段；例如，`inst[0] = 'ADDL'` 给我们实际的指令助记符。
- en: Suppose we want to get the contents of the source register, `r2`. The source
    register is in the third position in the list at `['ADDL', 'r1', 'r2', '3']`;
    that is, `inst[2]`. Let’s write `rS1 = inst[2]`. The value of `rS1` is `'r2'`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要获取源寄存器的内容，`r2`。源寄存器在列表的第三个位置，`['ADDL', 'r1', 'r2', '3']`；即 `inst[2]`。让我们写下
    `rS1 = inst[2]`。`rS1` 的值是 `'r2'`。
- en: 'We want the register number (that is, 2) as an integer, so we have to get the
    second character of r2 and convert it into an integer. We can do this in the following
    way:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望将寄存器号（即 2）作为整数，因此我们必须获取 r2 的第二个字符并将其转换为整数。我们可以用以下方式做到这一点：
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We can combine these two expressions into one as follows.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这两个表达式合并为一个，如下所示。
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The tiny computer we have created executed only five different instructions,
    but it includes many of the most important components of a real computer. This
    computer directly executes instructions from their assembly language form, rather
    than from their binary code. The next step is to look a little more closely at
    instruction sets before we can build a more realistic machine.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的小型计算机只执行了五种不同的指令，但它包括了真实计算机中的许多重要组件。这台计算机直接从汇编语言形式执行指令，而不是从二进制代码执行。下一步是在我们能够构建一个更真实的机器之前，更仔细地看看指令集。
- en: Having constructed a simulator, the next step is to look at the type of instructions
    a computer can execute.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 构建了模拟器之后，下一步是看看计算机可以执行哪种类型的指令。
- en: In the next section, we will develop an instruction set for the TC1 computer.
    As well as providing a practical example of instruction set design, we will demonstrate
    how instructions are divided into multiple fields and each field supplies some
    information about the current instruction.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将为TC1计算机开发一套指令集。除了提供一个指令集设计的实际例子外，我们还将展示指令是如何被分成多个字段，并且每个字段都提供了关于当前指令的一些信息。
- en: The TC1 instruction set
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TC1指令集
- en: 'In this section, we will introduce the key component of our demonstration computer:
    its instruction set. This computer, TC1, has many of the functions of a real computer
    and is easy to understand and modify. We will begin by introducing the TC1 instruction
    set encoding.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍我们演示计算机的关键组件：其指令集。这个计算机，TC1，具有许多真实计算机的功能，易于理解和修改。我们将首先介绍TC1指令集编码。
- en: To simplify this, we can use separate programs and data memories. This departure
    from the traditional von Neuman model allows us to have a 32-bit program memory
    and a 16-bit data memory. Moreover, we don’t have to worry about accidentally
    putting data in the middle of the program area.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化，我们可以使用单独的程序和数据内存。这种与传统冯·诺伊曼模型的偏离使我们能够拥有32位的程序内存和16位的数据内存。此外，我们不必担心不小心将数据放在程序区域的中间。
- en: A typical instruction has several fields; for example, operation code, registers,
    and literals (that is, constants). However, the number of bits in each field must
    add up to the total length of the instruction.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的指令有几个字段；例如，操作码、寄存器和字面量（即常数）。然而，每个字段中的位数总和必须等于指令的总长度。
- en: Modern computers normally employ different formats for each class of instruction.
    This optimizes the allocation of op-codes to bits; for example, a branch instruction
    may have a 4-bit opcode and a 28-bit literal field, whereas a data-processing
    instruction may have a 17-bit opcode and three 5-bit register-select fields.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现代计算机通常为每类指令采用不同的格式。这优化了操作码到位的分配；例如，一个分支指令可能有一个4位的操作码和一个28位的字面量字段，而一个数据处理指令可能有一个17位的操作码和三个5位的寄存器选择字段。
- en: For the sake of simplicity, the TC1 computer has a single, fixed format. All
    instructions have the same number of fields, and fields are the same size for
    each instruction. An instruction, as shown in *Figure 4**.1*, is made up of an
    operation *class* plus an opcode, three register fields, and a literal field.
    *Figure 4**.1* shows the opcode field as 7 bits, with a 2-bit opcode class and
    a 5-bit actual opcode.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化起见，TC1计算机有一个单一、固定的格式。所有指令的字段数量相同，并且每个指令的字段大小相同。如图*图4**.1*所示，一条指令由操作*类别*加上操作码、三个寄存器字段和一个字面量字段组成。*图4**.1*显示了操作码字段为7位，其中包含2位的操作码类别和5位的实际操作码。
- en: 'The structure of this instruction format is inefficient because if an instruction
    does not access a register, the three register select fields are wasted. In a
    three-register instruction such as ADD rd,rS1,rS2, the rd register is the destination,
    rS1 is source register 1, and rS2 is source register 2:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这种指令格式的结构效率低下，因为如果一个指令不访问寄存器，那么三个寄存器选择字段就浪费了。在一个如ADD rd,rS1,rS2的三寄存器指令中，rd寄存器是目的寄存器，rS1是源寄存器1，rS2是源寄存器2：
- en: '![Figure 4.1 – TC1 instruction format (RISC style)](img/Figure_4.01_B19624.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图4.1 – TC1指令格式（RISC风格）](img/Figure_4.01_B19624.jpg)'
- en: Figure 4.1 – TC1 instruction format (RISC style)
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1 – TC1指令格式（RISC风格）
- en: We devote 16 bits to the literal field so that we can load a constant into memory
    with a single instruction. That leaves 32 - 16 = 16 bits to allocate to all the
    other fields.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将16位分配给字面量字段，以便我们可以用一条指令将常数加载到内存中。这留下了32 - 16 = 16位可以分配给所有其他字段。
- en: TC1 has a three-register format, which is typical of load and store computers
    such as ARM and MIPS. If we have eight registers, it takes 3 x 3 = 9 bits to specify
    all three registers. After allocating 16 bits to the literal and 9 bits to the
    register selection, we are left with 32 - (16 + 9) = 7 bits to specify up to 128
    different possible instructions (27 = 128).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: TC1具有三寄存器格式，这是ARM和MIPS等加载和存储计算机的典型特征。如果我们有八个寄存器，则需要3 x 3 = 9位来指定所有三个寄存器。在为立即数分配16位和为寄存器选择分配9位之后，我们剩下32
    - (16 + 9) = 7位来指定多达128种不同的可能指令（2^7 = 128）。
- en: 'The opcode field itself is divided into four categories or classes, which take
    two bits, leaving 7- 2 = 5 for the instructions in each category. *Table 4.1*
    defines the categories (class) of instructions:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 操作码字段本身分为四个类别或类别，占用两位，为每个类别的指令留下7 - 2 = 5位。*表4.1*定义了指令的类别（类别）：
- en: '| **Class** | **Group** | **Comments** |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| **班级** | **组** | **注释** |'
- en: '| --- | --- | --- |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 0 0 | Special operation | Operations that perform functions such as `STOP`
    or read the keyboard |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| 0 0 | 特殊操作 | 执行如`STOP`或读取键盘等功能的操作 |'
- en: '| 0 1 | Data transfer | Operations that copy data from one place to another
    |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| 0 1 | 数据传输 | 将数据从一个地方复制到另一个地方的操作 |'
- en: '| 1 0 | Data processing | Arithmetic and logic data-processing operations |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| 1 0 | 数据处理 | 算术和逻辑数据处理操作 |'
- en: '| 1 1 | Flow control | Operations that control the sequencing of instructions,
    such as `BEQ` |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| 1 1 | 流控制 | 控制指令序列的操作，如`BEQ` |'
- en: Table 4.1 – TC1 instruction classes
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 表4.1 – TC1指令类别
- en: '*Table 4.2* illustrates the TC1 instruction set. The first column (`01 00001`
    loads a register with the contents of a memory location. The leftmost two bits
    are separated to indicate the instruction group:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '*表4.2*展示了TC1指令集。第一列(`01 00001`)将内存位置的值加载到寄存器中。最左边的两位分开表示指令组：'
- en: '| **Binary Code** | **Operation** | **Mnemonic** | **Instruction Format****rrr
    = Rd, aaa = rS1, bbb =** **rS2** | **Code** **Format** |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| **二进制代码** | **操作** | **助记符** | **指令格式****rrr = Rd, aaa = rS1, bbb =** **rS2**
    | **代码格式** |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| `00 00000` | Stop operation | STOP | 00 00000 000 000 000 0 | 0 0 0 0 |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| `00 00000` | 停止操作 | STOP | 00 00000 000 000 000 0 | 0 0 0 0 |'
- en: '| `00 00001` | No operation | NOP | 00 00001 000 000 000 0 | 0 0 0 0 |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| `00 00001` | 无操作 | NOP | 00 00001 000 000 000 0 | 0 0 0 0 |'
- en: '| `00` `00 010` | Get a char from the keyboard | GET r0 | 00 00010 rrr 000
    000 0 | 1 0 0 0 |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `00` `00 010` | 从键盘获取字符 | GET r0 | 00 00010 rrr 000 000 0 | 1 0 0 0 |'
- en: '| `00 00011` | Get a random character | RND r0 | 00 00011 rrr 000 000 L | 1
    0 0 1 |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| `00 00011` | 获取随机字符 | RND r0 | 00 00011 rrr 000 000 L | 1 0 0 1 |'
- en: '| `00 00100` | Swap bytes in the register | SWAP r0 | 00 00100 rrr 000 000
    0 | 1 0 0 0 |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| `00 00100` | 在寄存器中交换字节 | SWAP r0 | 00 00100 rrr 000 000 0 | 1 0 0 0 |'
- en: '| `00 01000` | Print a hex value in the register | PRT r0 | 00 01000 rrr 000
    000 0 | 1 0 0 0 |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| `00 01000` | 在寄存器中打印十六进制值 | PRT r0 | 00 01000 rrr 000 000 0 | 1 0 0 0 |'
- en: '| `00 11111` | Terminate program | END | 00 11111 000 000 000 0 | 0 0 0 0 |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| `00 11111` | 终止程序 | END | 00 11111 000 000 000 0 | 0 0 0 0 |'
- en: '| `01 00000` | Load register from register | MOV r0,r1 | 01 00000 rrr aaa 000
    0 | 1 1 0 0 |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| `01 00000` | 从寄存器加载寄存器 | MOV r0,r1 | 01 00000 rrr aaa 000 0 | 1 1 0 0 |'
- en: '| `01 00001` | Load register from memory | LDRM r0,L | 01 00001 rrr 000 000
    L | 1 0 0 1 |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| `01 00001` | 从内存加载寄存器 | LDRM r0,L | 01 00001 rrr 000 000 L | 1 0 0 1 |'
- en: '| `01 00010` | Load register with literal | LDRL r0,L | 01 00010 rrr 000 000
    L | 1 0 0 1 |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `01 00010` | 用立即数加载寄存器 | LDRL r0,L | 01 00010 rrr 000 000 L | 1 0 0 1 |'
- en: '| `01 00011` | Load register indirect | LDRI r0,[r1,L] | 01 00011 rrr aaa 000
    L | 1 1 0 1 |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `01 00011` | 间接加载寄存器 | LDRI r0,[r1,L] | 01 00011 rrr aaa 000 L | 1 1 0 1
    |'
- en: '| `01 00100` | Store register in memory | STRM r0,L | 01 00100 rrr 000 000
    L | 1 0 0 1 |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| `01 00100` | 将寄存器存储到内存 | STRM r0,L | 01 00100 rrr 000 000 L | 1 0 0 1 |'
- en: '| `01 00101` | Store register indirect | STRI r0,[r1,L] | 01 00101 rrr aaa
    000 L | 1 1 0 1 |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `01 00101` | 间接存储寄存器 | STRI r0,[r1,L] | 01 00101 rrr aaa 000 L | 1 1 0 1
    |'
- en: '| `10 00000` | Add register to register | ADD r0,r1,r2 | 10 00000 rrr aaa bbb
    0 | 1 1 1 0 |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `10 00000` | 寄存器加寄存器 | ADD r0,r1,r2 | 10 00000 rrr aaa bbb 0 | 1 1 1 0 |'
- en: '| `10 00001` | Add register to literal | ADDL r0,r1,L | 10 00001 rrr aaa 000
    L | 1 1 0 1 |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `10 00001` | 将寄存器加到立即数 | ADDL r0,r1,L | 10 00001 rrr aaa 000 L | 1 1 0 1
    |'
- en: '| `10 00010` | Subtract register from register | SUB r0,r1,r2 | 10 00010 rrr
    aaa bbb 0 | 1 1 1 0 |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `10 00010` | 从寄存器减去寄存器 | SUB r0,r1,r2 | 10 00010 rrr aaa bbb 0 | 1 1 1 0
    |'
- en: '| `10 00011` | Subtract literal from register | SUBL r0,r1,L | 10 00011 rrr
    aaa 000 L | 1 1 0 1 |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `10 00011` | 从寄存器减去立即数 | SUBL r0,r1,L | 10 00011 rrr aaa 000 L | 1 1 0 1
    |'
- en: '| `10 00100` | Multiply register by register | MUL r0,r1,r2 | 10 00100 rrr
    aaa bbb 0 | 1 1 1 0 |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `10 00100` | 寄存器乘寄存器 | MUL r0,r1,r2 | 10 00100 rrr aaa bbb 0 | 1 1 1 0 |'
- en: '| `10 00101` | Multiply literal by register | MULL r0,r1,L | 10 00101 rrr aaa
    000 L | 1 1 0 1 |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `10 00101` | 立即数乘以寄存器 | MULL r0,r1,L | 10 00101 rrr aaa 000 L | 1 1 0 1 |'
- en: '| `10 00110` | Divide register by register | DIV r0,r1,r2 | 10 00110 rrr aaa
    bbb 0 | 1 1 1 0 |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `10 00110` | 寄存器除以寄存器 | DIV r0,r1,r2 | 10 00110 rrr aaa bbb 0 | 1 1 1 0 |'
- en: '| `10 00111` | Divide register by literal | DIVL r0,r1,L | 10 00111 rrr aaa
    000 L | 1 1 0 1 |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| `10 00111` | 寄存器除以立即数 | DIVL r0,r1,L | 10 00111 rrr aaa 000 L | 1 1 0 1 |'
- en: '| `10 01000` | Mod register by register | MOD r0,r1,r2 | 10 01000 rrr aaa bbb
    0 | 1 1 1 0 |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| `10 01000` | 寄存器模寄存器 | MOD r0,r1,r2 | 10 01000 rrr aaa bbb 0 | 1 1 1 0 |'
- en: '| `10 01001` | Mod register by literal | MOD r0,r1,L | 10 01001 rrr aaa 000
    L | 1 1 0 1 |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| `10 01001` | 寄存器模立即数 | MOD r0,r1,L | 10 01001 rrr aaa 000 L | 1 1 0 1 |'
- en: '| `10 01010` | AND register to register | AND r0,r1,r2 | 10 01000 rrr aaa bbb
    0 | 1 1 1 0 |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| `10 01010` | 与寄存器到寄存器 | AND r0,r1,r2 | 10 01000 rrr aaa bbb 0 | 1 1 1 0 |'
- en: '| `10 01011` | AND register to literal | ANDL r0,r1,L | 10 01001 rrr aaa 000
    L | 1 1 0 1 |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| `10 01011` | 与寄存器到立即数 | ANDL r0,r1,L | 10 01001 rrr aaa 000 L | 1 1 0 1 |'
- en: '| `10 01100` | OR register to register | OR r0,r1,r2 | 10 01010 rrr aaa bbb
    0 | 1 1 1 0 |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| `10 01100` | 或寄存器到寄存器 | OR r0,r1,r2 | 10 01010 rrr aaa bbb 0 | 1 1 1 0 |'
- en: '| `10 01101` | OR register to literal | ORL r0,r1,L | 10 01011 rrr aaa 000
    L | 1 1 0 1 |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| `10 01101` | 或寄存器到立即数 | ORL r0,r1,L | 10 01011 rrr aaa 000 L | 1 1 0 1 |'
- en: '| `10 01110` | EOR register to register | EOR r0,r1,r2 | 10 01010 rrr aaa bbb
    0 | 1 1 1 0 |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| `10 01110` | 异或寄存器到寄存器 | EOR r0,r1,r2 | 10 01010 rrr aaa bbb 0 | 1 1 1 0
    |'
- en: '| `10 01111` | EOR register to literal | EORL r0,r1,L | 10 01011 rrr aaa 000
    L | 1 1 0 1 |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| `10 01111` | 异或寄存器到立即数 | EORL r0,r1,L | 10 01011 rrr aaa 000 L | 1 1 0 1
    |'
- en: '| `10 10000` | NOT register | NOT r0 | 10 10000 rrr 000 000 0 | 1 0 0 0 |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| `10 10000` | 非寄存器 | NOT r0 | 10 10000 rrr 000 000 0 | 1 0 0 0 |'
- en: '| `10 10010` | Increment register | INC r0 | 10 10010 rrr 000 000 0 | 1 0 0
    0 |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| `10 10010` | 增加寄存器 | INC r0 | 10 10010 rrr 000 000 0 | 1 0 0 0 |'
- en: '| `10 10011` | Decrement register | DEC r0 | 10 10011 rrr 000 000 0 | 1 0 0
    0 |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| `10 10011` | 减少寄存器 | DEC r0 | 10 10011 rrr 000 000 0 | 1 0 0 0 |'
- en: '| `10 10100` | Compare register with register | CMP r0,r1 | 10 10100 rrr aaa
    000 0 | 1 1 0 0 |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| `10 10100` | 寄存器比较寄存器 | CMP r0,r1 | 10 10100 rrr aaa 000 0 | 1 1 0 0 |'
- en: '| `10 10101` | Compare register with literal | CMPL r0,L | 10 10101 rrr 000
    000 L | 1 0 0 1 |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| `10 10101` | 比较寄存器与立即数 | CMPL r0,L | 10 10101 rrr 000 000 L | 1 0 0 1 |'
- en: '| `10 10110` | Add with carry | ADC r0,r1,r2 | 10 10110 rrr aaa bbb 0 | 1 1
    1 0 |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| `10 10110` | 带进位加 | ADC r0,r1,r2 | 10 10110 rrr aaa bbb 0 | 1 1 1 0 |'
- en: '| `10 10111` | Subtract with borrow | SBC r0,r1,r2 | 10 10111 rrr aaa bbb 0
    | 1 1 1 0 |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| `10 10111` | 带借位减 | SBC r0,r1,r2 | 10 10111 rrr aaa bbb 0 | 1 1 1 0 |'
- en: '| `10 11000` | Logical shift left | LSL r0,L | 10 10000 rrr 000 000 0 | 1 0
    0 1 |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| `10 11000` | 逻辑左移 | LSL r0,L | 10 10000 rrr 000 000 0 | 1 0 0 1 |'
- en: '| `10 11001` | Logical shift left literal | LSLL r0,L | 10 10000 rrr 000 000
    L | 1 0 0 1 |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| `10 11001` | 逻辑左移立即数 | LSLL r0,L | 10 10000 rrr 000 000 L | 1 0 0 1 |'
- en: '| `10 11010` | Logical shift right | LSR r0,L | 10 10001 rrr 000 000 0 | 1
    0 0 1 |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| `10 11010` | 逻辑右移 | LSR r0,L | 10 10001 rrr 000 000 0 | 1 0 0 1 |'
- en: '| `10 11011` | Logical shift right literal | LSRL r0,L | 10 10001 rrr 000 000
    L | 1 0 0 1 |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| `10 11011` | 逻辑右移立即数 | LSRL r0,L | 10 10001 rrr 000 000 L | 1 0 0 1 |'
- en: '| `10 11100` | Rotate left | ROL r0,L | 10 10010 rrr 000 000 0 | 1 0 0 1 |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| `10 11100` | 左旋转 | ROL r0,L | 10 10010 rrr 000 000 0 | 1 0 0 1 |'
- en: '| `10 11101` | Rotate left literal | ROLL r0,L | 10 10010 rrr 000 000 L | 1
    0 0 1 |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| `10 11101` | 左旋转立即数 | ROLL r0,L | 10 10010 rrr 000 000 L | 1 0 0 1 |'
- en: '| `10 11110` | Rotate right | ROR r0,L | 10 10010 rrr 000 000 0 | 1 0 0 1 |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| `10 11110` | 右旋转 | ROR r0,L | 10 10010 rrr 000 000 0 | 1 0 0 1 |'
- en: '| `10 11111` | Rotate right literal | RORL r0,L | 10 10010 rrr 000 000 L |
    1 0 0 1 |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| `10 11111` | 右旋转立即数 | RORL r0,L | 10 10010 rrr 000 000 L | 1 0 0 1 |'
- en: '| `11 00000` | Branch unconditionally | BRA L | 11 00000 000 000 000 L | 0
    0 0 1 |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| `11 00000` | 无条件分支 | BRA L | 11 00000 000 000 000 L | 0 0 0 1 |'
- en: '| `11 00001` | Branch on zero | BEQ L | 11 00001 000 000 000 L | 0 0 0 1 |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| `11 00001` | 零条件分支 | BEQ L | 11 00001 000 000 000 L | 0 0 0 1 |'
- en: '| `11 00010` | Branch on not zero | BNE L | 11 00010 000 000 000 L | 0 0 0
    1 |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| `11 00010` | 非零条件分支 | BNE L | 11 00010 000 000 000 L | 0 0 0 1 |'
- en: '| `11 00011` | Branch on minus | BMI L | 11 00011 000 000 000 L | 0 0 0 1 |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| `11 00011` | 负条件分支 | BMI L | 11 00011 000 000 000 L | 0 0 0 1 |'
- en: '| `11 00100` | Branch to subroutine | BSR L | 11 00100 000 000 000 L | 0 0
    0 1 |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| `11 00100` | 跳转到子程序 | BSR L | 11 00100 000 000 000 L | 0 0 0 1 |'
- en: '| `11 00101` | Return from subroutine | RTS | 11 00101 000 000 000 0 | 0 0
    0 0 |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| `11 00101` | 从子程序返回 | RTS | 11 00101 000 000 000 0 | 0 0 0 0 |'
- en: '| `11 00110` | Decrement and branch on not ٠ | DBNE r0,L | 11 00110 rrr 000
    000 L | 1 0 0 1 |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| `11 00110` | 减少且非零分支 | DBNE r0,L | 11 00110 rrr 000 000 L | 1 0 0 1 |'
- en: '| `11 00111` | Decrement and branch on zero | DBEQ r0,L | 11 00111 rrr 000
    000 L | 1 0 0 1 |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| `11 00111` | 减少且零分支 | DBEQ r0,L | 11 00111 rrr 000 000 L | 1 0 0 1 |'
- en: '| `11 01000` | Push register on the stack | PUSH r0 | 11 01000 rrr 000 000
    0 | 1 0 0 0 |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| `11 01000` | 将寄存器推入堆栈 | PUSH r0 | 11 01000 rrr 000 000 0 | 1 0 0 0 |'
- en: '| `11 01001` | Pull register off the stack | PULL r0 | 11 01001 rrr 000 000
    0 | 1 0 0 0 |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| `11 01001` | 从堆栈中拉取寄存器 | PULL r0 | 11 01001 rrr 000 000 0 | 1 0 0 0 |'
- en: Table 4.2 – TC1 Instruction encoding (the 4 code format bits are not part of
    the opcode)
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 表4.2 – TC1指令编码（4个代码格式位不是操作码的一部分）
- en: The rightmost column is called `1001` tells the assembler that the instruction
    requires a destination register and a 16-bit literal. Code 0000 tells us that
    the instruction contains no operands at all.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 最右侧的列称为`1001`，告诉汇编器该指令需要目标寄存器和16位字面值。代码`0000`告诉我们该指令不包含任何操作数。
- en: We chose these instructions to demonstrate a range of operations. Many of these
    instructions are typical of a RISC computer such as ARM (that is, we don’t include
    operations on data in memory). Note that later, we’ll introduce a simulator for
    a memory-to-register instruction set that allows operations such as `ADD r1,12`,
    where `12` is a memory location.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择这些指令来展示一系列操作。许多这些指令是RISC计算机（如ARM）的典型代表（即我们不包含对内存中数据的操作）。注意，稍后我们将介绍一个内存到寄存器指令集的模拟器，它允许执行如`ADD
    r1,12`这样的操作，其中`12`是一个内存位置。
- en: Some instructions in *Table 4.2* don’t exist on a real computer; for example,
    read a character from the keyboard. We added that to simplify debugging and experimentation.
    Similarly, TC1 can generate a random number, a feature not found in most computer
    instruction sets. However, it’s useful for generating random test data. Some instructions,
    such as subroutine calls and returns, implement more sophisticated operations,
    which we shall encounter later.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 表4.2中的一些指令在真实计算机上不存在；例如，从键盘读取字符。我们添加这些指令是为了简化调试和实验。同样，TC1可以生成随机数，这是大多数计算机指令集中没有的特性。然而，它对于生成随机测试数据很有用。一些指令，如子程序调用和返回，实现了更复杂的操作，我们将在后面遇到。
- en: The column labeled `L` indicates a literal value (that is, a 16-bit constant).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 标有`L`的列表示字面值（即16位常数）。
- en: The fourth column (`rrr`, `aaa`, and `bbb` show the location of the three register
    select fields. The rightmost field (`0` or `L`) represents 16 bits of the literal.
    We show `0` if all bits are 0, and `L` if a 16-bit literal is required by the
    instruction. If a register field is not required, the corresponding field is filled
    with zeros (although it doesn’t matter what value these bits are because they
    are not used by the instruction).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 第四列（`rrr`、`aaa`和`bbb`）显示了三个寄存器选择字段的位置。最右侧的字段（`0`或`L`）表示字面值的16位。如果所有位都是0，我们显示`0`；如果指令需要16位字面值，则显示`L`。如果一个寄存器字段不是必需的，相应的字段将用零填充（尽管这些位是什么值并不重要，因为指令不会使用这些位）。
- en: 'Remember that the four bits in the rightmost column are not part of the opcode
    or instruction itself. These bits show which fields are required by the current
    instruction: the destination register (`rrr`), the source 1 register (`aaa`),
    the source 2 register (`bb`), and the literal, `L`. For example, code `1100` indicates
    that the instruction has a destination register and a single source register.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，最右侧列中的四个位不是操作码或指令本身的一部分。这些位显示了当前指令所需的字段：目标寄存器（`rrr`）、源1寄存器（`aaa`）、源2寄存器（`bb`）和字面值`L`。例如，代码`1100`表示该指令有一个目标寄存器和单个源寄存器。
- en: Explaining some of the instructions
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解释一些指令
- en: Some of the instructions in *Table 4.2* are typical of real processors. Several
    instructions have been included to provide useful facilities such as generating
    a random number for testing purposes. This section describes several of the instructions
    in *Table 4.2*.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 表4.2中的一些指令是真实处理器的典型代表。包括了一些指令以提供有用的功能，例如生成随机数以供测试使用。本节描述了表4.2中的一些指令。
- en: '`STOP` terminates instruction processing. Most modern computers don’t have
    an explicit `STOP` operation.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`STOP`终止指令处理。大多数现代计算机没有显式的`STOP`操作。'
- en: '`NOP` does nothing other than advance the program counter. It’s a dummy operation
    that is useful as a marker in code, a placeholder for future code, or as an aid
    to testing.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`NOP`除了推进程序计数器外不做任何事情。它是一个有用的占位符操作，可以作为代码中的标记、未来代码的占位符或测试的辅助。'
- en: '`GET` reads data from the keyboard and offers a simple way of getting input
    from the keyboard into a register. This is useful when testing programs and is
    not a normal computer instruction.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`GET`从键盘读取数据，并提供了一种简单的方法将键盘输入传送到寄存器。这在测试程序时很有用，但它不是一个正常的计算机指令。'
- en: '`RND` generates a random number. It’s not in computer instruction sets but
    provides an excellent means of generating data internally when testing your code.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`RND` 生成随机数。它不在计算机指令集中，但在测试代码时提供了一种生成内部数据的优秀手段。'
- en: '`SWAP` exchanges upper- and lower-order bytes – for example, `0x1234` becomes
    `0x3412`.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`SWAP` 交换高字节和低字节 – 例如，`0x1234` 变为 `0x3412`。'
- en: The load and store instructions move data between memory and registers. The
    difference between members of this class is the direction (store is computer-to-memory,
    while load is memory-to-computer), size (some computers allow byte, 16-bit, or
    32-bit transfers), and addressing mode (using a literal value, an absolute address,
    or an address from a register).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 加载和存储指令在内存和寄存器之间移动数据。这类指令成员之间的区别在于方向（存储是从计算机到内存，而加载是从内存到计算机），大小（某些计算机允许字节、16位或32位传输），以及寻址模式（使用字面值、绝对地址或寄存器地址）。
- en: '`MOV` copies one register to another – for example, `MOV r3,r1` copies the
    contents of `r1` to `r3`. `MOV` is, essentially, an a load register with register
    (LDRR) instruction.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`MOV` 将一个寄存器的内容复制到另一个寄存器 – 例如，`MOV r3,r1` 将 `r1` 的内容复制到 `r3`。`MOV` 实质上是一个加载寄存器与寄存器（LDRR）指令。'
- en: '`LDRL` loads a register with a literal value – for example, `LDRL r3,20` loads
    register `r3` with `20`.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`LDRL` 将寄存器加载为字面值 – 例如，`LDRL r3,20` 将寄存器 `r3` 加载为 `20`。'
- en: '`LDRM` loads a register with the contents of a memory location specified by
    a literal address. `LDRM r1,42` loads `r1` with the contents of memory location
    `42`. This instruction does not exist on modern RISC processors. Most modern processors
    do not allow you to access an absolute memory address,'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`LDRM` 将寄存器的内容加载到由字面值地址指定的内存位置。`LDRM r1,42` 将 `r1` 加载为内存位置 `42` 的内容。这个指令在现代RISC处理器上不存在。大多数现代处理器不允许你访问绝对内存地址，'
- en: '`LDRI`, the load register indexed (or load register indirect) instruction,
    loads a register with the contents of a memory location specified by the contents
    of a register plus a literal address. `LDRM r2,[r3,10]` loads `r2` with the contents
    of the memory location whose address is given by the contents of `r3` plus `10`.
    This instruction is the standard RISC load operation.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`LDRI` 是加载寄存器索引（或加载寄存器间接）指令，将寄存器的内容加载到由寄存器内容加字面值地址指定的内存位置。`LDRM r2,[r3,10]`
    将 `r2` 加载为地址由 `r3` 内容加 `10` 给定的内存位置的内容。这个指令是标准的RISC加载操作。'
- en: '`STRM`, the store register memory instruction, stores a register at the location
    specified by a literal address. `STRM r2,15` stores register `r2` at memory location
    `15`. RISC processors don’t implement this instruction.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`STRM` 是存储寄存器内存指令，将寄存器存储在由字面值地址指定的位置。`STRM r2,15` 将寄存器 `r2` 存储在内存位置 `15`。RISC
    处理器不实现这个指令。'
- en: '`STRI`, the store register indexed instruction, stores a register at the location
    specified by a register plus a literal. `STRI r2,[r6,8]` stores `r2` at the memory
    location whose address is `r6` plus `8`.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`STRI` 是存储寄存器索引指令，将寄存器存储在由寄存器加字面值指定的位置。`STRI r2,[r6,8]` 将 `r2` 存储在地址为 `r6`
    加 `8` 的内存位置。'
- en: The `STR`, `STRM`, and `STRI` instructions are anomalous because they write
    the source and destination operands in the reverse order to `LDR` (and all other
    processor operations); that is, if you write `LDR r0,PQR`, you should write `STR
    PQR,r0` to indicate the reverse data flow. But, by custom and practice, we don’t.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`STR`、`STRM` 和 `STRI` 指令是异常的，因为它们将源操作数和目标操作数写入的顺序与 `LDR`（以及所有其他处理器操作）相反；也就是说，如果你写
    `LDR r0,PQR`，你应该写 `STR PQR,r0` 来表示反向数据流。但是，按照惯例和实践，我们并不这样做。'
- en: '`DBNE` We added the decrement and branch on not zero instruction for fun because
    it reminds me of my old Motorola days. The 68000 was a powerful microprocessor
    (at the time) with a 32-bit architecture. It has a decrement and branch instruction
    that is used at the end of a loop. On each pass around the loop, the specified
    register is decremented, and a branch back to a label is made if the counter is
    not -1\. `DBNE r0,L` decrements `r0` and branches to the line numbered `L` if
    the count is not zero.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`DBNE` 我们添加了递减且非零分支指令是为了好玩，因为这让我想起了我的老摩托罗拉时代。68000 是一个强大的微处理器（在当时）具有32位架构。它有一个递减和分支指令，用于循环的末尾。在循环的每次迭代中，指定的寄存器都会递减，如果计数器不是-1，则返回到标签。`DBNE
    r0,L` 递减 `r0`，如果计数器不为零，则跳转到编号为 `L` 的行。'
- en: Register indirect addressing
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 寄存器间接寻址
- en: 'Two instructions require a special mention because they are concerned not with
    operations on data but with accessing data in memory. These are `LDRI` and `STRI`,
    both of which use register indirect addressing. In *Table 4.2,* the `0b0100011`
    opcode corresponds to `LDRI` (that is, load register *indirect*). This instruction
    doesn’t give you the actual address of the operand; it tells you where the address
    can be found. The register indirect addressing mode is also called pointer-based
    or indexed addressing. The operand address in memory is given by the contents
    of a register plus an offset; that is, `r[rD]=mem[r[rS1]+lit]`. If we use bold
    and shading, we can make its interpretation a little easier:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 有两条指令需要特别提及，因为它们不是关于数据操作，而是关于在内存中访问数据。这些是 `LDRI` 和 `STRI`，它们都使用寄存器间接寻址。在 *表
    4.2* 中，`0b0100011` 操作码对应于 `LDRI`（即，加载寄存器 *间接*）。这条指令并不给出操作数的实际地址；它告诉你地址在哪里可以找到。寄存器间接寻址模式也称为基于指针或索引寻址。内存中的操作数地址由寄存器的内容加上偏移量给出；即，`r[rD]=mem[r[rS1]+lit]`。如果我们使用粗体和阴影，可以使它的解释更容易一些：
- en: '[PRE13]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*Figure 4**.2* demonstrates the effect of the `LDRI r1,[r0,3]` TC1 instruction,
    where pointer register `r0` contains 100 and the operand is accessed at memory
    address 100 + 3 = 103:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4**.2* 展示了 `LDRI r1,[r0,3]` TC1 指令的效果，其中指针寄存器 `r0` 包含 100，操作数在内存地址 100 +
    3 = 103 处访问：'
- en: '![Figure 4.2 – Register indirect addressing](img/Figure_4.02_B19624.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.2 – 寄存器间接寻址](img/Figure_4.02_B19624.jpg)'
- en: Figure 4.2 – Register indirect addressing
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2 – 寄存器间接寻址
- en: 'This addressing mode lets you modify addresses while the program is running
    (because you can change the contents of the pointer, `r0`). Pointer-based addressing
    makes it possible to step through a list of items, element by element, simply
    by incrementing the pointer. Here’s an example:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这种寻址模式允许你在程序运行时修改地址（因为你可以更改指针的内容，`r0`）。基于指针的寻址使得能够逐个元素地遍历项目列表，只需递增指针即可。以下是一个例子：
- en: '[PRE14]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We access the element pointed at by `r2` (in this case, the offset is `0`).
    The next line increments `r2` to point to the next element. If this sequence is
    executed in a loop, the data will be accessed element by element.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们访问由 `r2` 指向的元素（在这种情况下，偏移量是 `0`）。下一行将 `r2` 递增以指向下一个元素。如果这个序列在循环中执行，数据将被逐个元素访问。
- en: Computers implement both arithmetic and Boolean (logical) operations. In the
    next section, we’ll briefly look at how Python can be used to simulate logical
    operations at the assembly language level.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机实现算术和布尔（逻辑）操作。在下一节中，我们将简要介绍 Python 如何在汇编语言级别模拟逻辑操作。
- en: Bit-handling in Python
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python 中的位处理
- en: 'In this section, we’ll look at how Python deals with the fundamental component
    of all computer data: the bit. Because simulated computers operate at the level
    of bits, we have to look at how bits are manipulated in Python before we can construct
    a simulator that can perform logical operations such as `AND` and `OR`.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨 Python 如何处理所有计算机数据的基本组成部分：位。因为模拟计算机在位级别上操作，我们必须在构建能够执行 `AND` 和 `OR`
    等逻辑操作的模拟器之前，查看 Python 中位是如何被操作的。
- en: Computers can operate on entire words as a single entity, or on the individual
    bits of a word. Consequently, we have to be able to perform both bit operations
    and word operations to simulate a computer.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机可以作为一个整体操作整个字，或者操作字中的单个位。因此，我们必须能够执行位操作和字操作来模拟计算机。
- en: Python lets you input data and display it as a binary string of bits. You can
    operate on individual bits of a string using Boolean operators, and you can shift
    the bits of a word left and right. You have all the tools you need in Python.
    We are now going to look at Python, which lets you operate on the individual bits
    of an integer.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: Python 允许你输入数据并将其显示为位字符串的二进制表示。你可以使用布尔运算符操作字符串的各个位，并且可以左右移位。Python 中有你需要的一切工具。我们现在将探讨
    Python，它允许你操作整数的各个位。
- en: 'Because the simulator will operate on binary numbers, we have to exploit several
    Python facilities; for example, a binary value is indicated by prefixing it with
    `0b`. If you want to use the binary equivalent of 15, you must write `0b1111`
    and use it just like a decimal number. The following two operations have the same
    effect:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 因为模拟器将在二进制数字上操作，我们必须利用几个 Python 功能；例如，二进制值通过在其前面加上 `0b` 来表示。如果你想使用 15 的二进制等效值，你必须写成
    `0b1111` 并像十进制数字一样使用它。以下两个操作具有相同的效果：
- en: '[PRE15]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Two important binary operators are `>>` (shift right) and `<<` (shift left).
    Shift expressions are written as `p >> q` or `p << q`, where `p` is the number
    to be operated on and `q` is the number of bit positions shifted. Consider the
    following example:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 两个重要的二进制运算符是 `>>`（右移）和 `<<`（左移）。移位表达式写作 `p >> q` 或 `p << q`，其中 `p` 是要操作的数，`q`
    是移位的位数。考虑以下示例：
- en: '[PRE17]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This shifts `x` two places left to give the new value `0b111011000`. All the
    bits have moved two places left and 0s have been entered at the right-hand end
    to fill the newly vacated positions. The shifted version of `x` now has nine bits,
    rather than seven. However, when we simulate a computer, we have to ensure that,
    whatever we do, the number of bits in a word remains constant. If a register has
    16 bits, any operation you perform on it must yield 16 bits.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这将 `x` 左移两位，得到新值 `0b111011000`。所有位都向左移动了两位，并在右手端输入 0 来填充新空出的位置。`x` 的移位版本现在有九位，而不是七位。然而，当我们模拟计算机时，我们必须确保无论我们做什么，字中的位数都保持不变。如果一个寄存器有
    16 位，那么你对它进行的任何操作都必须产生 16 位。
- en: 'We can take two words and perform Boolean (bitwise) operations on them; for
    example, C = A & B ANDs together words A and B by calculating ci = ai · bi for
    each bit in the word (that is, for i = 0 to 7). Consider the following:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以对两个字执行布尔（位运算）操作；例如，C = A & B 通过计算 ci = ai · bi 对字中的每个位（即，对于 i = 0 到 7）进行操作来将字
    A 和 B 连接在一起。考虑以下示例：
- en: '[PRE18]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '| **Truth table** **for AND** |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| **AND运算的真值表** |'
- en: '| --- |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| --- |'
- en: '| x | y | z=x & y |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| x | y | z=x & y |'
- en: '| 0 | 0 | 0 |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 0 |'
- en: '| 0 | 1 | 0 |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 1 | 0 |'
- en: '| 1 | 0 | 0 |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 0 | 0 |'
- en: '| 1 | 1 | 1 |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | 1 |'
- en: This gives `x = 0b000001101`, because ANDing a bit with 0 gives a 0 result,
    and ANDing a bit x with 1 gives x, because 1 & 0 = 0 and 1 & 1 = 1, as the truth
    table demonstrates.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这将 `x` 设置为 `0b000001101`，因为位与 0 进行 AND 运算会得到 0 结果，而位 x 与 1 进行 AND 运算会得到 x，因为
    1 & 0 = 0 和 1 & 1 = 1，正如真值表所示。
- en: 'In Python, hexadecimal numbers are prefixed with `0x`; for example, `0x2F1A`.
    We use hexadecimal numbers in Python programs because they are shorter than binary
    numbers. Here is an example:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，十六进制数以 `0x` 开头；例如，`0x2F1A`。我们在 Python 程序中使用十六进制数，因为它们比二进制数短。以下是一个示例：
- en: '[PRE19]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Consider the following fragment of Python code:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下 Python 代码片段：
- en: '[PRE20]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The output from this code is `y` `is 0b1001`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码的输出是 `y` `is 0b1001`。
- en: 'Python uses more than 16 bits to represent numbers. To simulate binary arithmetic
    in TC1, we must constrain Python’s numbers to 16 bits. We have to work with the
    longer words provided by Python and chop them down to 16 or 32 bits as necessary.
    Consider the following:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: Python 使用超过 16 位来表示数字。为了在 TC1 中模拟二进制算术，我们必须将 Python 的数字限制在 16 位。我们必须使用 Python
    提供的较长的字，并在必要时将它们截断到 16 或 32 位。考虑以下示例：
- en: '[PRE21]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Shifting the 16-bit word left two places made it an 18-bit word. ANDing it with
    the `0b1111111111111111` binary value forces it to 16 significant bits.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 将 16 位字左移两位使其成为 18 位字。与二进制值 `0b1111111111111111` 进行 AND 运算强制其变为 16 位有效位。
- en: Operator precedence in Python
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python 的运算符优先级
- en: 'Now, we have to re-learn something that we learned about in high school arithmetic:
    operator precedence. When you use several operators in an expression, you have
    to be aware of operator precedence; that is, which operations are performed before
    others. For example, is 4 * 5 + 3 equal to 23 or 32? All computer languages have
    a hierarchy of operator precedence. The partial list of operator precedence for
    Python is as follows, with the highest precedence first. We often use parentheses
    to make the meaning of expressions clearer, even if it’s not required – for example,
    `(xxx << 4) & (yyy <<` `2)`:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须重新学习我们在高中算术中学到的某些知识：运算符优先级。当你在表达式中使用多个运算符时，你必须注意运算符优先级；也就是说，哪些操作先于其他操作执行。例如，4
    * 5 + 3 等于 23 还是 32？所有计算机语言都有运算符优先级的层次结构。Python 的运算符优先级部分列表如下，优先级最高的排在前面。我们经常使用括号来使表达式的含义更清晰，即使这不是必需的——例如，`(xxx
    << 4) & (yyy <<` `2)`：
- en: '[PRE22]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the next section, we’ll look at how an instruction, which is a string of
    1s and 0s, is decoded and the appropriate operation that’s performed.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨如何解码一条指令，该指令是一串 1 和 0，以及执行适当的操作。
- en: Next, we’ll take a major step in constructing a simulator – that is, decoding
    a machine-level binary instruction to extract information about the operation
    it is going to simulate.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将构建模拟器迈出重大一步——即解码机器级二进制指令以提取它将要模拟的操作信息。
- en: Decoding and executing an instruction
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解码和执行指令
- en: 'In this section, we’ll look at a few examples of how instructions are encoded
    and decoded. Consider the `ADD r1,r2,r3`, operation (where the codes for registers
    `rD`, `rS1`, and `rS2` are shaded), which is defined in RTL as follows:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨一些指令编码和解码的例子。考虑`ADD r1,r2,r3`操作（其中寄存器`rD`、`rS1`和`rS2`的代码被阴影覆盖），它在RTL中的定义如下：
- en: '`[r1]` `←` `[r2] + [``r3]`'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`[r1]` `←` `[r2] + [``r3]`'
- en: '*Table 4.2* shows that the encoding of `ADD r1,r2,r3` is `10 00000 001 010
    011 0000000000000000`. The corresponding 4-bit format code that defines the registers
    to be used is `1110` because we use three registers and no literal field (remember
    that this 4-bit format code is not part of the opcode but is used by the assembler
    to interpret the instruction).'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '*表4.2* 显示了`ADD r1,r2,r3`的编码是`10 00000 001 010 011 0000000000000000`。定义要使用的寄存器的4位格式代码是`1110`，因为我们使用了三个寄存器而没有文字字段（记住，这个4位格式代码不是操作码的一部分，而是由汇编器用来解释指令的）。'
- en: 'The following Python code shows how we can decode an instruction to extract
    five variables: the operation code (`binOp`); the three registers, `rD`, `rS1`,
    and `rS2`; and a literal. Decoding is performed by shifting the bits of the instruction
    right to move the required field into the least significant position and then
    ANDing it with a mask to remove any other fields. Consider, `xxxxxxx xxx 010 xxx
    xxxxxxxxxxxxxxxx`. If we shift this string 19 places right, we get `0000000000000000000xxxxxxxxxx010`.
    The zeros have been shifted in, and the three bits we’re interested in are right-justified
    in the least significant bits. If we `AND` this with `0b111` to select only the
    three least significant bits, we get `0000000000000000000000000000010` – that
    is, the required register value is now right-justified and we can use it:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 以下Python代码展示了我们如何解码指令以提取五个变量：操作码（`binOp`）；三个寄存器，`rD`、`rS1`和`rS2`；以及一个文字。解码是通过将指令的位右移以将所需字段移动到最低有效位，然后与掩码进行与操作以移除任何其他字段来执行的。考虑`xxxxxxx
    xxx 010 xxx xxxxxxxxxxxxxxxx`。如果我们将其右移19位，我们得到`0000000000000000000xxxxxxxxxx010`。零已经被移位，我们感兴趣的三个位现在在最低有效位中右对齐。如果我们用`0b111`与它进行与操作以只选择三个最低有效位，我们得到`0000000000000000000000000000010`——也就是说，所需的寄存器值现在右对齐，我们可以使用它：
- en: '[PRE23]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The shift-right operator in Python is `>>` and the bit-wise logical `AND` operator
    is `&`. The mask is expressed as a string of bits (rather than a decimal number)
    because ANDing with binary 111 is clearer than ANDing with decimal 7\. In Python,
    a binary value is preceded by 0b, so 7 is represented by `0b111`. The literal
    is ANDed with 16 ones, expressed as `0xFFFF`. We use binary for short fields,
    and hex value for long fields. It’s just personal preference.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: Python中的右移操作符是`>>`，位逻辑与操作符是`&`。掩码以位串的形式表示（而不是十进制数），因为与二进制111进行与操作比与十进制7进行与操作更清晰。在Python中，二进制值前面有一个0b，所以7表示为`0b111`。文字与16个1进行与操作，表示为`0xFFFF`。我们使用二进制表示短字段，使用十六进制值表示长字段。这只是一种个人偏好。
- en: The `binCode >> 22 & 0b111` expression shifts the bits of `binCode` 22 places
    right, and then bitwise ANDs the result with `000…000111`. Because of operator
    precedence, the shifting is performed first. Otherwise, we would have written
    `(binCode >> 22) & 0b111`. We often use parentheses, even when not strictly necessary,
    to stress operator precedence.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`binCode >> 22 & 0b111`表达式将`binCode`的位右移22位，然后将结果与`000…000111`进行位与操作。由于操作符优先级，先进行移位操作。否则，我们会写成`(binCode
    >> 22) & 0b111`。我们经常使用括号，即使不是严格必要的，也要强调操作符优先级。'
- en: Note that we extract all fields, even though they may not be required by each
    instruction. Similarly, we read all three register’s contents. This approach simplifies
    the Python code, at the cost of efficiency.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们提取了所有字段，即使它们可能不是每个指令所必需的。同样，我们读取了三个寄存器的所有内容。这种方法简化了Python代码，但以效率为代价。
- en: Consider extracting the destination register field, `rrr`. Suppose that the
    instruction is `ADD r1,r2,r3`, and the opcode is `10`00000001010`011`0000000000000000\.
    We have put alternate fields in bold font and the destination field is shaded
    to make it easier to read. Performing a 22-bit right shift moves the destination
    register into the least-significant bits and leaves us with
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑提取目标寄存器字段，`rrr`。假设指令是`ADD r1,r2,r3`，操作码是`10`00000001010`011`0000000000000000`。我们已经用粗体字和阴影表示了交替字段，目标字段被阴影覆盖以使其更容易阅读。执行22位右移将目标寄存器移动到最低有效位，并留下
- en: '[PRE24]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, if we perform the `AND` operation with 111 (all bits to the left are zero),
    we get the following:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们用111（所有左边的位都是零）进行与操作，我们得到以下结果：
- en: '[PRE25]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We have now isolated the first register field to get `001`, which corresponds
    to register `r1`. The final three lines of the program to decode an instruction
    are as follows:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已将第一个寄存器字段隔离出来以获得 `001`，这对应于寄存器 `r1`。解码指令的程序的最后三行如下：
- en: '[PRE26]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: These instructions use the register addresses (`rD`, `rS1`, and `rS2`) to access
    registers; that is, the instruction specifies which registers are to be used.
    For example, if `op0 = r[5],` register `r5` is operand zero, the destination register.
    If an instruction does not specify a register, the unused field is set to zero.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指令使用寄存器地址（`rD`、`rS1` 和 `rS2`）来访问寄存器；即指令指定了要使用的寄存器。例如，如果 `op0 = r[5]`，寄存器 `r5`
    是操作数零，目标寄存器。如果指令没有指定寄存器，则未使用字段被设置为零。
- en: 'Once an instruction has been decoded, it can be executed. Fortunately, executing
    most instructions is remarkably easy. Consider the following examples:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦指令被解码，它就可以被执行。幸运的是，执行大多数指令非常简单。考虑以下示例：
- en: '[PRE27]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This fragment of code demonstrates the execution of four instructions from the
    load and store (that is, memory access) group. The Python `if … elif` construct
    tests each opcode in turn. The first line compares the 7-bit opcode with the binary
    value `0100010`, which corresponds to the `LDRL` (load a register with a literal
    value) instruction. Incidentally, in the final version of TC1, we made the code
    easier to read by comparing operations with the actual mnemonic; for example,
    `'LDRL'` is easier to read than its code, `0b100010`.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码片段展示了从加载和存储（即内存访问）组执行四个指令的过程。Python 的 `if … elif` 结构依次测试每个操作码。第一行将 7 位操作码与二进制值
    `0100010` 进行比较，这对应于 `LDRL`（使用立即数加载寄存器）指令。顺便提一下，在 TC1 的最终版本中，我们通过将操作与实际助记符进行比较来使代码更容易阅读；例如，`'LDRL'`
    比其代码 `0b100010` 更容易阅读。
- en: If there is a match, the code following the colon is executed, `(r[rD] = lit)`.
    If not, the next line uses the `elif` command to compare the opcode with 010001\.
    If there is a match, the code after the colon is executed. In this way, the opcode
    is compared with all its possible values until a match is found.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如果匹配成功，冒号后面的代码将被执行，`(r[rD] = lit)`。如果不匹配，下一行使用 `elif` 命令将操作码与 `010001` 进行比较。如果匹配，则执行冒号后面的代码。这样，操作码将与所有可能的值进行比较，直到找到匹配项。
- en: 'Suppose the instruction’s opcode is `0100010`, and the `r[rD] = lit` line is
    executed. This Python operation transfers the value of the 16-bit literal provided
    in the instruction to the destination register specified in the instruction. In
    RTL terms, it carries out `r[rD] ← lit` and is used by the programmer to load
    an integer into a register. Let’s say the binary pattern of the instruction code
    is as follows:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 假设指令的操作码是 `0100010`，并且执行了 `r[rD] = lit` 行。这个 Python 操作将指令中提供的 16 位立即数的值转移到指令中指定的目标寄存器。在
    RTL 术语中，它执行 `r[rD] ← lit` 并被程序员用来将整数加载到寄存器中。假设指令代码的二进制模式如下：
- en: '[PRE28]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Here, the 16-bit literal is loaded into register `r6` to implement `LDRL r6,193`.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，16 位立即数被加载到寄存器 `r6` 中以实现 `LDRL r6,193`。
- en: Arithmetic and logical operations
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 算术和逻辑操作
- en: The arithmetic and logical group of operations do all the work (data processing)
    in a program. They include arithmetic operations (addition, subtraction, and multiplication),
    as well as logical operations (`AND`, `OR`, `EOR`, and `NOT`). These are three-operand
    instructions, apart from `NOT`; for example, `AND r``3,r0,r5` performs a bitwise
    `AND` between the bits of `r0` and `r5`, and puts the result in `r3`.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 算术和逻辑操作组在一个程序中执行所有的工作（数据处理）。它们包括算术操作（加法、减法和乘法），以及逻辑操作（`AND`、`OR`、`EOR` 和 `NOT`）。这些是三操作数指令，除了
    `NOT`；例如，`AND r3,r0,r5` 在 `r0` 和 `r5` 的位之间执行位运算 `AND`，并将结果放入 `r3`。
- en: 'The following fragment of Python code shows how TC1 interprets four instructions
    in this group. There are two pairs of instructions: addition and subtraction.
    Each pair consists of a register-to-register operation and a register-with-literal
    operation; for example, `ADD r1,r2,r3` adds the contents of registers `r2` and
    `r3` together, whereas `ADDL r1,r2,L` adds the contents of a 16-bit literal to
    the contents of register `r2`. We don’t do the arithmetic here. Instead, we call
    a function called `alu(f,a,b)` to perform the required action. The next section
    will show you how to create your own functions:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 Python 代码片段展示了 TC1 如何解释这一组中的四个指令。有两个指令对：加法和减法。每一对包括一个寄存器到寄存器的操作和一个寄存器到立即数的操作；例如，`ADD
    r1,r2,r3` 将寄存器 `r2` 和 `r3` 的内容相加，而 `ADDL r1,r2,L` 将 16 位立即数的内容加到寄存器 `r2` 的内容上。这里我们不进行算术运算。相反，我们调用一个名为
    `alu(f,a,b)` 的函数来执行所需操作。下一节将展示如何创建自己的函数：
- en: '[PRE29]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: If you were to write the full Python code required to execute each operation,
    it would require several lines of code per instruction. An addition operation
    such as `reg[dest] = reg[src1] + reg[src2]` appears simple enough, but there is
    more to an arithmetic operation.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要编写执行每个运算所需的完整 Python 代码，每条指令可能需要几行代码。例如，加法运算 `reg[dest] = reg[src1] + reg[src2]`
    看起来很简单，但算术运算中还有更多内容。
- en: To explain why, we need to discuss the role of conditional flag bits. Recall
    that computers make decisions regarding whether to execute the next instruction
    in sequence, or whether to jump to a different place in the code (that is, an
    `if…then…else` construct). The decision whether to take the `if` branch or the
    `else` branch is determined by the outcome of an arithmetic or logical operation
    (this includes compare operations).
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解释原因，我们需要讨论条件标志位的作用。回想一下，计算机在决定是否按顺序执行下一条指令，或者是否跳转到代码中的不同位置（即 `if…then…else`
    结构）时做出决策。是否采取 `if` 分支或 `else` 分支的决定取决于算术或逻辑运算的结果（这包括比较运算）。
- en: The result of an arithmetic or logical operation is tested and used to set or
    clear condition code flags. These flags are usually the negative, zero, carry,
    and overflow flags and are written as `n`, `z`, `c`, and `v`. For example, if
    an operation is x = p – q and the result is x = 0, then the z-bit (zero bit) is
    set to 1\. Similarly, if an operation yields a result that cannot be represented
    in 16 bits, the carry bit, c, is set. Because most computers use two’s complement
    arithmetic, the negative flag, n, is set if the result is negative in two’s complement
    terms (that is, its most significant bit is 1). The v-bit indicates arithmetic
    overflow and is set if the result is out of range. This means that two positive
    numbers have been added and the result is negative, or two negative numbers have
    been added and the result is positive.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 算术或逻辑运算的结果会被测试并用于设置或清除条件代码标志。这些标志通常是负数标志、零标志、进位标志和溢出标志，分别表示为 `n`、`z`、`c` 和 `v`。例如，如果运算表达式是
    x = p – q，且结果为 x = 0，那么零位（零位）会被设置为 1。同样，如果运算结果无法用 16 位表示，进位位 c 会被设置。由于大多数计算机使用二进制补码算术，如果结果在二进制补码中表示为负数（即其最高位为
    1），则负数标志 n 会被设置。v 位表示算术溢出，如果结果超出范围，则该位会被设置。这意味着两个正数相加的结果为负数，或者两个负数相加的结果为正数。
- en: '*Table 4.3* demonstrates how 4 bits can be allocated to the numbers 0 to 15
    (unsigned) or -8 to 7 (signed two’s complement). It’s up to the programmer to
    choose the convention. However, the arithmetic remains the same for both conventions.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '*表 4.3* 展示了如何将 4 位分配给数字 0 到 15（无符号）或 -8 到 7（有符号二进制补码）。程序员需要选择约定。然而，两种约定下的算术运算都是相同的。'
- en: 'Consider 0110 + 1100, which is 10010 (or 0010 in 4 bits). If we interpret these
    figures as unsigned, the calculation gives us 6 + 12 = 2, which is incorrect,
    because the result 18 cannot be represented in 4 bits. If we consider these as
    signed values, the calculation is 6 + -4 = 2 and the result is correct:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑 0110 + 1100，结果是 10010（或 4 位中的 0010）。如果我们将这些数字解释为无符号数，计算结果为 6 + 12 = 2，这是不正确的，因为结果
    18 无法用 4 位表示。如果我们将这些数字解释为有符号值，计算为 6 + -4 = 2，结果是正确的：
- en: '| **8** | **4** | **2** | **1** | **Unsigned value** | **Signed value** |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| **8** | **4** | **2** | **1** | **无符号值** | **有符号值** |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| 0 | 0 | 0 | 0 | 0 | 0 |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 0 | 0 | 0 | 0 |'
- en: '| 0 | 0 | 0 | 1 | 1 | 1 |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 0 | 1 | 1 | 1 |'
- en: '| 0 | 0 | 1 | 0 | 2 | 2 |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 1 | 0 | 2 | 2 |'
- en: '| 0 | 0 | 1 | 1 | 3 | 3 |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 1 | 1 | 3 | 3 |'
- en: '| 0 | 1 | 0 | 0 | 4 | 4 |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 1 | 0 | 0 | 4 | 4 |'
- en: '| 0 | 1 | 0 | 1 | 5 | 5 |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 1 | 0 | 1 | 5 | 5 |'
- en: '| 0 | 1 | 1 | 0 | 6 | 6 |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 1 | 1 | 0 | 6 | 6 |'
- en: '| 0 | 1 | 1 | 1 | 7 | 7 |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 1 | 1 | 1 | 7 | 7 |'
- en: '| 8 | 4 | 2 | 1 |  |  |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '| 8 | 4 | 2 | 1 |  |  |'
- en: '| 1 | 0 | 0 | 0 | 8 | -8 |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 0 | 0 | 0 | 8 | -8 |'
- en: '| 1 | 0 | 0 | 1 | 9 | -7 |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 0 | 0 | 1 | 9 | -7 |'
- en: '| 1 | 0 | 1 | 0 | 10 | -6 |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 0 | 1 | 0 | 10 | -6 |'
- en: '| 1 | 0 | 1 | 1 | 11 | -5 |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 0 | 1 | 1 | 11 | -5 |'
- en: '| 1 | 1 | 0 | 0 | 12 | -4 |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | 0 | 0 | 12 | -4 |'
- en: '| 1 | 1 | 0 | 1 | 13 | -3 |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | 0 | 1 | 13 | -3 |'
- en: '| 1 | 1 | 1 | 0 | 14 | -2 |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | 1 | 0 | 14 | -2 |'
- en: '| 1 | 1 | 1 | 1 | 15 | -1 |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | 1 | 1 | 15 | -1 |'
- en: Table 4.3 – A representation of 4-bit values in signed and unsigned forms
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 表4.3——4位数值的有符号和无符号表示
- en: Two’s complement arithmetic – a note
  id: totrans-259
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 二进制补码算术——注意事项
- en: There are several ways of representing negative numbers in binary arithmetic.
    One of the oldest is called sign and magnitude, where a number is prefixed by
    0 if it’s positive and 1 if it’s negative. This is not used today in binary arithmetic
    (except for floating-point numbers).
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在二进制算术中表示负数有几种方式。其中最古老的一种称为符号和数值，其中如果数值为正，则前面加0；如果为负，则加1。这种方法今天在二进制算术中不再使用（除了浮点数之外）。
- en: Two’s complement notation is used by almost all modern computers to represent
    signed integers. In two’s complement arithmetic, if N is a positive number in
    n bits, the value of -N is given by 2n – 1\. The two’s complement of N can be
    calculated easily by inverting the bits and adding 1\. For example, if N = `000110`
    in six bits, the value of -6 is represented by `111010`.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有现代计算机都使用二进制补码表示有符号整数。在二进制补码算术中，如果N是n位中的正数，则-N的值由2^n – 1给出。N的二进制补码可以通过反转位并加1来轻松计算。例如，如果N
    = `000110`在六位中，-6的值由`111010`表示。
- en: The advantage of two’s complement arithmetic is that addition and subtraction
    are performed in the same way. If you add a two’s complement value to another
    number, the result is correctly calculated. For example, if we add 9 (that is,
    `001001`) to the previous value of -6, we get `001001` + `111010` = `1000011`,
    which is +3 in six bits. The carry-out (in bold font) is discarded.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制补码算术的优势在于加法和减法以相同的方式进行。如果你将一个二进制补码值加到另一个数上，结果会被正确计算。例如，如果我们把9（即`001001`）加到-6的前一个值上，我们得到`001001`
    + `111010` = `1000011`，这是六位中的+3。进位（粗体字体）被舍弃。
- en: Zero, carry, and sign bits
  id: totrans-263
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 零、进位和符号位
- en: 'The carry and sign bits are used to determine whether a result is in range
    or out of range. In signed arithmetic, the result of a two’s complement addition
    of S = A+B is out of range, if the sign bits of A and B are both 0 and the sign
    bit of S is 1, or if the sign bits of A and B are both 1 and the sign bit of S
    is 0\. Consider addition and subtraction using four bits. Two’s complement arithmetic
    is used, and the leftmost bit is the sign bit. In each case, we’ve performed a
    two’s complement addition on signed numbers. The results give us the state of
    the flag bits:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 进位位和符号位用于确定结果是否在范围内或超出范围。在有符号算术中，如果S = A+B的二进制补码加法的结果中，A和B的符号位都是0而S的符号位是1，或者A和B的符号位都是1而S的符号位是0，则结果超出范围。考虑使用四位进行加法和减法。使用二进制补码算术，最左边的位是符号位。在每种情况下，我们都对有符号数进行了二进制补码加法。结果给出了标志位的状态：
- en: '[PRE30]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: How do we know whether a number is signed or unsigned? We don’t! There is no
    difference. If you use signed numbers, you must interpret the result as a signed
    value. If you use unsigned numbers, you must interpret the result as an unsigned
    value. For example, in four bits, 1110 is both -2 and +14, depending on how you
    look at it.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何知道一个数是有符号的还是无符号的？我们不知道！没有区别。如果你使用有符号数，你必须将结果解释为有符号值。如果你使用无符号数，你必须将结果解释为无符号值。例如，在四位中，1110既可以表示-2也可以表示+14，这取决于你如何看待它。
- en: The next topic deals with how we handle groups of repetitive operations. If
    the same sequence of operations is going to be used more than once in a program,
    it makes sense to combine them into a group and invoke that group whenever you
    need it. In Python, this group of actions is called a function.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个主题将讨论我们如何处理重复操作组。如果程序中将要多次使用相同的操作序列，将它们组合成一个组并在需要时调用该组是有意义的。在Python中，这个动作组被称为函数。
- en: Functions in Python
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python中的函数
- en: 'We will now describe Python’s functions. We’ve already used functions that
    are part of the language, such as `len()`. In this section, we’ll do the following:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将描述Python的函数。我们已经使用了语言的一部分函数，如`len()`。在本节中，我们将做以下几件事：
- en: Explain why functions are useful
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释为什么函数是有用的
- en: Provide an example of a function to implement an ALU
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供一个实现ALU功能的示例
- en: Explain how variables can be private to a function or shared between functions
    (scope)
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释变量如何对函数是私有的或函数间共享的（作用域）
- en: Describe how parameters are passed to functions
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述如何将参数传递给函数
- en: Describe how a function returns a result
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述函数如何返回结果
- en: Writing the Python code to deal with each arithmetic or logical operation implemented
    by a simulator would be tedious because so much code would be replicated by individual
    instructions. Instead, we can create a Python function (that is, a subroutine
    or procedure) that carries out both the arithmetic/logic operation and the appropriate
    flag-bit setting.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 编写处理由模拟器实现的每个算术或逻辑操作的 Python 代码将会很繁琐，因为大量的代码会被单个指令重复。相反，我们可以创建一个 Python 函数（即子程序或过程），它执行算术/逻辑操作以及适当的标志位设置。
- en: 'Consider a Python function called `alu(f,p,q)` that returns an integer that
    is a function of the `f`, `p`, and `q` parameters. The operation to be performed
    is passed to the procedure as an integer, `f`. The function also updates the z
    and n flag bits. This is a simplified version of the actual function we will use
    and will provide just two operations, add and subtract, and update only two flag
    bits:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个名为 `alu(f,p,q)` 的 Python 函数，它返回一个整数，该整数是 `f`、`p` 和 `q` 参数的函数。要执行的操作以整数 `f`
    的形式传递给过程。该函数还更新 z 和 n 标志位。这是我们将使用的实际函数的简化版本，它将提供两个操作，加法和减法，并只更新两个标志位：
- en: '[PRE31]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The function is introduced by `def`, its name, and any parameters followed by
    a colon. The body of the function is indented. The first parameter, `f`, selects
    the operation we wish to perform (`f` = 1 for addition and 2 for subtraction).
    The next two input parameters, `p` and `q`, are the data values used by the function.
    The last line of the function returns the result to the function’s calling point.
    This function can be called by, for example, `opVal = alu(2,s1,s2)`. In this case,
    the result, `opVal`, would be the value of `s1 –` `s2`.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 函数通过 `def`、其名称和任何参数后跟冒号来引入。函数体是缩进的。第一个参数 `f` 选择我们希望执行的操作（`f` = 1 表示加法，2 表示减法）。接下来的两个输入参数
    `p` 和 `q` 是函数使用的数据值。函数的最后一行将结果返回到函数的调用点。这个函数可以通过例如 `opVal = alu(2,s1,s2)` 来调用。在这种情况下，结果
    `opVal` 将是 `s1 – s2` 的值。
- en: We also update two flag bits, `z` and `n`. Initially, both `z` and `n` are set
    to zero by `z, n = 0, 0`. (Python allows multiple assignments on the same line;
    for example, `a,b,c = 1,5,0` sets `a`, `b`, and `c` to 1, 5, and 0, respectively.)
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还更新了两个标志位，`z` 和 `n`。最初，`z` 和 `n` 都通过 `z, n = 0, 0` 被设置为零。（Python 允许在同一行进行多个赋值；例如，`a,b,c
    = 1,5,0` 将 `a`、`b` 和 `c` 分别设置为 1、5 和 0。）
- en: You can pass data to a function via parameters and receive a result via `return()`.
    However, you can declare variables in a function as `global`, which means they
    can be accessed and modified as if they were part of the calling program.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过参数将数据传递给函数，并通过 `return()` 接收结果。然而，你可以在函数中声明变量为 `global`，这意味着它们可以像调用程序的一部分一样被访问和修改。
- en: '`return()` is not mandatory because some functions don’t return a value. You
    can have multiple `return()` statements in a function because you can return from
    more than one point in a function. A return can pass multiple values because Python
    permits multiple assignments on a line; for example, see the following:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '`return()` 不是强制的，因为有些函数不返回值。一个函数中可以有多个 `return()` 语句，因为你可以从函数的多个点返回。返回可以传递多个值，因为
    Python 允许一行中的多个赋值；例如，参见以下：'
- en: '[PRE32]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Testing for a zero result can easily be done by comparing the result, `r`, with
    0\. Testing for a negative result is harder. In two’s complement arithmetic, a
    signed value is negative if the most significant bit is 1\. We are using 16-bit
    arithmetic, so that corresponds to bit 15\. We can extract bit 15 by ANDing the
    result, `r`, with the binary value of 1000000000000000 by writing `r&0x8000` (the
    literal is expressed in hex form as 0x8000, which is mercifully shorter than the
    binary version).
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 通过比较结果 `r` 与 0 来测试零结果可以很容易地完成。测试负结果则更困难。在二进制补码算术中，如果一个有符号值的最高位是 1，则该值是负数。我们使用
    16 位算术，因此这对应于位 15。我们可以通过将结果 `r` 与二进制值 1000000000000000 进行 AND 操作来提取位 15，即通过编写
    `r&0x8000`（字面量以十六进制形式表示为 0x8000，这比二进制版本要短得多）。
- en: 'To call the function, we can write the following:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用函数，我们可以编写以下代码：
- en: '[PRE33]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We test for opcode 1000000 and call the `alu` function if it corresponds to
    `ADD`. The function is called with the `f = 1` parameter for addition; the numbers
    to be added are the contents of the two source registers. The result is loaded
    into the `r[rD]` register. In the current version of TC1, we use the opcode to
    look up the mnemonic and then apply the test if `mnemonic == 'ADD':`. This approach
    is easier to read and can use the mnemonic when displaying the output during tracing.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 我们测试操作码1000000，如果它对应于`ADD`，则调用`alu`函数。该函数使用`f = 1`参数进行加法；要加的数字是两个源寄存器的内容。结果被加载到`r[rD]`寄存器中。在TC1的当前版本中，我们使用操作码查找助记符，然后如果`mnemonic
    == 'ADD'`则应用测试。这种方法更容易阅读，并且在跟踪输出时可以使用助记符。
- en: We have made the `z` and `n` variables global (that is, they can be changed
    by the function and accessed externally). If we didn’t make them global, we would
    have to have made them return parameters. In general, it is regarded as a better
    practice to pass variables as parameters rather than making them global.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将`z`和`n`变量设置为全局变量（即，它们可以被函数更改并从外部访问）。如果我们没有将它们设置为全局变量，我们就必须使它们作为返回参数。一般来说，将变量作为参数传递而不是使它们成为全局变量是一种更好的做法。
- en: Functions and scope
  id: totrans-288
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数和作用域
- en: Variables are associated with *scope* or *visibility*. If you write a program
    without functions, variables can be accessed everywhere in the program. If you
    use functions, life becomes rather more complex.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 变量与*作用域*或*可见性*相关联。如果你编写一个没有函数的程序，变量可以在程序中的任何地方访问。如果你使用函数，生活就变得相当复杂。
- en: If you declare a variable in the main body, that variable will be visible in
    functions (that is, you can use it). However, you cannot change it in the function
    and then access the new value outside the function. What goes on in the function
    stays in the function. If you wish to access it from outside the function, you
    must declare it as *global*. If you write `global temp3`, then the `temp3` variable
    is the same variable both in and outside the function.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将变量声明在主体中，该变量将在函数中可见（即，你可以使用它）。然而，你无法在函数中更改它并在函数外部访问新值。函数内部发生的事情就留在函数内部。如果你希望从函数外部访问它，你必须将其声明为*全局*。如果你编写`global
    temp3`，那么`temp3`变量在函数内外是同一个变量。
- en: If you create a variable in a function, that variable cannot be accessed outside
    the function because it’s private to the function (a local variable). You can
    create a variable with the same name in another function or the body of the program,
    but the variable in this function has no effect on variables with the same name
    outside the function.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在一个函数中创建了一个变量，该变量不能在函数外部访问，因为它对函数是私有的（一个局部变量）。你可以在另一个函数或程序体中创建具有相同名称的变量，但这个函数中的变量对函数外具有相同名称的变量没有影响。
- en: 'If you create a variable in a function that you want to be visible outside
    the function, you have to declare it as global in the function. Consider the following
    code:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在一个函数中创建了一个你希望在外部可见的变量，你必须在函数中将其声明为全局变量。考虑以下代码：
- en: '[PRE34]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'After running this code, we get the following. As you can see, the function
    changes `q` because it is global, whereas `p` does not change since it is a local
    variable in the function:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码后，我们得到以下结果。正如你所见，函数因为它是全局的而改变了`q`，而`p`没有改变，因为它在函数中是一个局部变量：
- en: '[PRE35]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Here is a summary of the rules:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是规则的总结：
- en: If you don’t change it in a function, you can use it anywhere
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你不在函数中更改它，你可以在任何地方使用它
- en: If you declare it in a function, it’s all yours and private to the function
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你在一个函数中声明它，它就属于你，并且对函数是私有的
- en: If you want to change it in the function and use it outside the function, then
    declare it as global in the function
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你希望在函数中更改它并使用它在外部，那么在函数中将其声明为全局变量
- en: 'This means that variables such as the `z` and `n` condition code flags can
    be accessed in a function. If you wish to change them in a function, they must
    be declared as global by using the following command:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着像`z`和`n`这样的条件码标志变量可以在函数中访问。如果你希望在函数中更改它们，你必须使用以下命令将它们声明为全局变量：
- en: '[PRE36]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: If a function returns a value, it ends with `return(whatever)`. If you don’t
    return a value from a function, the `return` statement is not necessary. However,
    we usually include a `return()` that returns nothing, and then we explicitly mark
    the end of the function.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个函数返回一个值，它以`return(whatever)`结束。如果你从函数中不返回值，则不需要`return`语句。然而，我们通常包括一个返回空值的`return()`，然后我们明确标记函数的结束。
- en: Although the use of global variables is supported by Python, some programmers
    avoid them because global variables make it too easy to accidentally change a
    variable in a function and not notice it, leading to headaches when debugging
    a faulty program. They argue that all variables should be passed to a function
    as a parameter.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Python支持全局变量的使用，但一些程序员避免使用它们，因为全局变量使得在函数中意外更改变量并没注意到它变得过于容易，导致在调试有缺陷的程序时头疼。他们认为所有变量都应该作为参数传递给函数。
- en: In the next section, we’ll describe the very thing that makes a computer a computer
    – its ability to take two different courses of action, depending on the outcome
    of an operation.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将描述使计算机成为计算机的真正原因——它根据操作的结果采取两种不同行动的能力。
- en: Branches and flow control
  id: totrans-305
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分支和流程控制
- en: 'All microprocessors have flow control instructions; for example, the unconditional
    branch, `BRA XYZ`, means execute the next instruction at address `XYZ`. A typical
    conditional instruction is `BNE` `XYZ`, which implements taking the branch to
    the instruction at location `XYZ`, if and only if, the z flag is not set. The
    `BNE` mnemonic means “branch on not equal” because the z-bit is evaluated by comparing
    two values using subtraction. Consider the following example, which uses the TC1
    assembly language:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 所有微处理器都有流程控制指令；例如，无条件分支 `BRA XYZ` 表示在地址 `XYZ` 执行下一个指令。一个典型的条件指令是 `BNE XYZ`，它实现如果且仅当
    z 标志未设置时，跳转到位置 `XYZ` 的指令。`BNE` 的助记符意味着“不等时分支”，因为 z 位是通过使用减法比较两个值来评估的。考虑以下使用 TC1
    汇编语言的示例：
- en: '[PRE37]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Load register with a literal (`LDRL`) is used three times to load `r2` with
    0, `r0` with 5, and `r1` with 1\. In the line labeled `Loop`, we add `r2` to `r1`
    and put the result in `r2`. On its first execution, `r2` becomes 0 + 1 = 1.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 使用文数字段加载寄存器（`LDRL`）三次，将 `r2` 加载为 0，`r0` 加载为 5，`r1` 加载为 1。在标记为 `Loop` 的行中，我们将
    `r2` 加到 `r1` 上，并将结果放入 `r2`。在其第一次执行时，`r2` 变为 0 + 1 = 1。
- en: The next two lines increment `r1` and decrement r0 so that `r1` becomes 2 and
    `r0` becomes 4\. When we decrement `r0`, the z-flag is set if the result is zero.
    Since r2 initially contains 5 and then 4 after decrementing, the result is not
    zero and the z-flag is not set.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 下两条指令增加 `r1` 的值并减少 `r0` 的值，使得 `r1` 变为 2 而 `r0` 变为 4。当我们减少 `r0` 的值时，如果结果是零，则设置
    z 标志。由于 r2 初始包含 5，然后减量后变为 4，所以结果不是零，z 标志没有被设置。
- en: When `BNE` is executed, the z-flag is tested. If it is not zero, a branch is
    taken to the line labeled `Loop` and the same batch of four instructions are executed
    again. When the `BNE` is encountered a second time, the z-bit is still zero, because
    this time the decrement went from 4 to 3\. Eventually, `r0` contains 1 and is
    decremented to 0\. The z-bit is then set. When `BNE` is next executed, the branch
    to loop is not taken, and the next instruction in the sequence, `STOP`, is executed.
    The loop is repeated 5 times. This program evaluates 1 + 2 + 3 + 4 + 5 = 15, which
    is the result in `r2`.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行 `BNE` 时，会测试 z 标志。如果它不是零，则会从标记为 `Loop` 的行进行分支，并再次执行相同的四条指令。当第二次遇到 `BNE` 时，z
    位仍然是零，因为这次减量是从 4 到 3。最终，`r0` 包含 1 并减量到 0。然后设置 z 位。当 `BNE` 下次执行时，不会执行跳转到循环，而是执行序列中的下一个指令
    `STOP`。循环重复 5 次。这个程序计算 1 + 2 + 3 + 4 + 5 = 15，这是 `r2` 中的结果。
- en: Branch addresses can be a little complicated. You can provide an absolute address;
    for example, `BRA 24` jumps to the instruction at memory location 24\. Most computers
    use a relative address, which is relative to the current instruction. For example,
    in this case, we would branch three instructions back from the current location
    (that is, the `BNE` instruction). So, you might think that the relative address
    is -3\. It is a negative address because it is backward from the current address.
    Since the program counter has already been incremented to point to the next instruction,
    the branch back is -4\. So, the literal field of the `BNE` loop would be -4.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 分支地址可能有点复杂。你可以提供一个绝对地址；例如，`BRA 24` 跳转到内存地址 24 的指令。大多数计算机使用相对地址，它是相对于当前指令的。例如，在这种情况下，我们会从当前位置（即
    `BNE` 指令）回跳三个指令。所以，你可能认为相对地址是 -3。这是一个负地址，因为它是从当前地址往回的。由于程序计数器已经增加以指向下一个指令，所以回跳是
    -4。因此，`BNE` 循环的文数字段将是 -4。
- en: 'The following fragment of code demonstrates testing four branch instructions
    and their implementation. In this example, we are using relative addressing for
    the branch; that is, the target address is specified with respect to the program
    counter. The first branch, `BRA`, is an unconditional branch and the next value
    of `pc` is calculated. All the others are conditional branches, and `pc` is changed
    only if the required condition is met. Note that the last operation is `BMI`,
    which means branch on minus, although some call it branch on negative (which has
    the same meaning):'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段演示了测试四个分支指令及其实现。在这个例子中，我们使用相对寻址来表示分支；也就是说，目标地址是相对于程序计数器指定的。第一个分支`BRA`是无条件分支，计算下一个`pc`的值。其余的都是条件分支，只有当满足所需条件时，`pc`才会改变。请注意，最后一个操作是`BMI`，表示基于负数的分支，尽管有些人称之为基于负数的分支（意思相同）：
- en: '[PRE38]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '`The pc` is incremented by `pc + literal`. However, since backward branches
    are represented in two’s complement form, it is necessary to `AND` the result
    with 0xFFFF to force it to 16 bits to generate the correct value. This is because
    we are simulating 16-bit arithmetic using a computer language, Python, that represents
    numbers with more than 16 bits. This is just an unfortunate consequence of computer
    arithmetic that you have to be aware of when simulating binary arithmetic.'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '`The pc`是通过`pc + literal`来增加的。然而，由于向后分支以二进制补码形式表示，因此需要将结果与0xFFFF进行`AND`操作，以确保它为16位并生成正确的值。这是因为我们正在使用表示超过16位数字的计算机语言Python来模拟16位算术。这仅仅是计算机算术的一个不幸后果，当你模拟二进制算术时必须注意。'
- en: In the next chapter, we will return to Python and extend our ability to handle
    data structures and use Python’s functions.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将回到Python，并扩展我们处理数据结构和使用Python函数的能力。
- en: Summary
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We started this chapter by designing a computer simulator. However, we haven’t
    created a final product yet. Instead, we looked at some of the issues involved,
    such as the nature of an instruction set and the structure of an opcode.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从设计计算机模拟器开始本章。然而，我们还没有创建最终产品。相反，我们研究了涉及的一些问题，例如指令集的性质和操作码的结构。
- en: We examined how an instruction can be decoded and how it can be executed. We
    also took the opportunity to broaden our knowledge of Python and introduced Python’s
    bit-manipulation facilities, which let us implement machine-level instructions
    that operate on bits.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 我们研究了指令的解码和执行方式。我们还趁机扩展了我们对Python的了解，并介绍了Python的位操作功能，这些功能使我们能够实现操作位级的机器指令。
- en: We also introduced an important component of Python, known as a function, which
    allows the programmer to create a self-contained unit of code that can be called
    to perform a specific job from many points in a program. Functions are vital to
    modern programming because they facilitate elegant design by bundling a complex
    sequence of operations into a unit, which you call to carry out a task.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还介绍了一个重要的Python组件，称为函数，它允许程序员创建一个自包含的代码单元，可以从程序中的多个点调用以执行特定任务。函数对现代编程至关重要，因为它们通过将复杂操作序列捆绑成一个单元来促进优雅的设计，你可以调用该单元来执行任务。
- en: In [*Chapter 5*](B19624_05.xhtml#_idTextAnchor075), we’ll return to Python and
    look at some topics in a little more depth – in particular, lists. Lists are probably
    Python’s most interesting and important feature.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第五章*](B19624_05.xhtml#_idTextAnchor075)中，我们将回到Python，并更深入地探讨一些主题——特别是列表。列表可能是Python最有趣和最重要的特性。
