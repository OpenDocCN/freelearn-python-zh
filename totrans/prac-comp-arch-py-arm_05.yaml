- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Crafting an Interpreter – First Steps
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译解释器 – 第一步
- en: In this chapter, we’ll take our first steps toward constructing a computer simulator
    by constructing a very primitive simulator that can execute only a single instruction.
    Once we’ve taken this step, we can move on by gradually enhancing this simulator.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过构建一个只能执行单个指令的非常原始的模拟器来迈出构建计算机模拟器的第一步。一旦我们迈出这一步，我们就可以通过逐步增强这个模拟器来继续前进。
- en: 'The key topics that we’ll cover in this chapter are as follows:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖的关键主题如下：
- en: Designing a minimal computer with one instruction
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用一条指令设计最小计算机
- en: Designing a simple simulator that can decode and execute several instructions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计一个可以解码和执行多个指令的简单模拟器
- en: The instruction set of a general-purpose computer called TC1
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 被称为TC1的通用计算机指令集
- en: Handing bits in Python (Boolean operations)
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Python中处理位（布尔运算）
- en: Decoding an instruction in binary form into its component parts
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将二进制形式的指令解码为其组成部分
- en: Executing an instruction after it has been decoded
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解码后执行指令
- en: Arithmetic operations in a computer
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算机中的算术运算
- en: Designing functions in Python
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Python中设计函数
- en: Branch and flow control instructions in computer instruction sets
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算机指令集中的分支和流程控制指令
- en: Collectively, these topics cover three areas. Some topics expand our knowledge
    of Python to help us construct a simulator. Some topics introduce the instruction
    set of a typical digital computer that we call TC1 (TC1 simply means *Teaching
    Computer 1*). Some topics cover the actual design of TC1 in Python.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这些主题共同涵盖了三个领域。一些主题扩展了我们对Python的了解，帮助我们构建模拟器。一些主题介绍了典型数字计算机的指令集，我们称之为TC1（TC1简单意味着*教学计算机1*）。一些主题涵盖了TC1在Python中的实际设计。
- en: This chapter will introduce the computer simulator and look at some basic building
    blocks. The actual simulator will be presented in [*Chapter 6*](B19624_06.xhtml#_idTextAnchor091).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍计算机模拟器并查看一些基本构建块。实际的模拟器将在[*第6章*](B19624_06.xhtml#_idTextAnchor091)中介绍。
- en: Technical Requirements
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find the programs used in this chapter on GitHub at [https://github.com/PacktPublishing/Practical-Computer-Architecture-with-Python-and-ARM/tree/main/Chapter04](https://github.com/PacktPublishing/Practical-Computer-Architecture-with-Python-and-ARM/tree/main/Chapter04).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub上找到本章使用的程序，链接为[https://github.com/PacktPublishing/Practical-Computer-Architecture-with-Python-and-ARM/tree/main/Chapter04](https://github.com/PacktPublishing/Practical-Computer-Architecture-with-Python-and-ARM/tree/main/Chapter04)。
- en: An ultra-primitive one-instruction computer
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个超原始的单指令计算机
- en: Our first *one-instruction interpreter* demonstrates both instruction decoding
    and execution, which are key to all simulators. This computer has a memory with
    nine locations, `mem[0]` to `mem[8]`, arranged as a list of integers. The contents
    of the memory are preset to `mem = [4,6,1,2,7,8,4,4,5]`. The memory locations
    are 0 to 8 and are read left to right in the list; for example, memory location
    0 contains a value of 4, location 1 contains a value of 6, and location 8 contains
    a value of 5.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个*单指令解释器*演示了指令解码和执行，这是所有模拟器的关键。这台计算机有一个九个位置的内存，`mem[0]`到`mem[8]`，排列成一个整数列表。内存的内容预设为`mem
    = [4,6,1,2,7,8,4,4,5]`。内存位置为0到8，在列表中从左到右读取；例如，内存位置0包含值为4，位置1包含值为6，位置8包含值为5。
- en: 'The computer has an array of eight registers, `r[0]` to `r[7]`. These are specified
    in Python via the following:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机有一个包含八个寄存器的数组，`r[0]`到`r[7]`。这些在Python中通过以下方式指定：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The single instruction we are going to execute is `add r[4],mem[3],mem[7]`.
    This instruction adds the contents of memory location 3 to the contents of memory
    location 7 and puts the sum in register 4\. We have chosen to begin with a single-instruction
    computer because it can be expressed in a few lines of Python code and yet it
    performs many of the actions required of a real computer simulator.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要执行的单一指令是`add r[4],mem[3],mem[7]`。这条指令将内存位置3的内容与内存位置7的内容相加，并将和放入寄存器4。我们选择从单指令计算机开始，因为它可以用几行Python代码表达，同时它执行了许多真实计算机模拟器所需的操作。
- en: We have defined this add memory to memory operation as a demonstration. It’s
    not part of any real computer language. Interestingly, it’s more complex than
    most real computer instructions because it uses memory-to-memory operations rather
    than register-to-register operations.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这种内存到内存的操作定义为演示。它不是任何真实计算机语言的一部分。有趣的是，它比大多数真实计算机指令更复杂，因为它使用内存到内存操作而不是寄存器到寄存器操作。
- en: We are going to write the Python code necessary to read this instruction in
    text form and carry out the action it defines. The two shaded lines in the following
    code take this instruction and split it into a list of tokens that can be processed.
    A token is an element in an instruction (just as a sentence in English can be
    split into tokens that we call words). The tokens here are `'add'`, `'r[4]'`,
    `'mem[3]'`, and `'mem[7]'`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: 'This instruction reads the contents of `mem[3]`, which is 2; reads the contents
    of `mem[7]`, which is 4; adds them together to get 2 + 4 = 6; and then stores
    the value 6 in register 4\. After this instruction has been executed, the value
    of register `r[4]` should be 6:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `inst1 = inst.replace(' ',',')` operation takes the instruction and replaces
    a space with a comma to get `'add r[4],mem[3],mem[7]'`.This is now a string with
    the tokens separated by commas.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to create a list of tokens so that we can access the individual
    components of the instruction. The effect of `inst2 = inst1.split('','')` is to
    create a list of strings:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `split()` method takes a string and creates a list of strings using the
    delimiter specified as a parameter. If `y = x.split(''!'')`, the value of `y`
    is a list of strings and the separator is `!`. An example of the use of `split()`
    is shown here:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `token2 = inst2[2]` line gives `token2 = 'mem[3]'`; that is, the fourth
    token.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: The `value2 = int(token2[4])` line gives `value2 = 3` because the second slice
    is the 3 in the `'mem[3]'` string. Note that we use the `int()` function to convert
    the characters 4, 3, and 7 into integer values. When going from strings to numeric
    operations, you have to remember to convert between character and integer types.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: 'If we execute this program, we get the following output:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now that we’ve introduced the fundamental components of a simulator, the next
    step is to construct a computer that can handle more instructions, albeit a tiny
    subset of typical operations. However, this is a subset that includes all categories
    of real computer operations.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: Building a simple computer interpreter in Python
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can take the concept of a simulator a step further and execute a program
    with multiple instructions using the concepts we just developed. Consecutive instructions
    are executed by reading them from program memory, one by one, and using a program
    counter to keep track of where we are in the program.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: Please be aware of a possible source of confusion when we refer to a *program*.
    We are writing a program in the high-level language Python to simulate a computer.
    That simulated computer runs a program written in assembly language. Consequently,
    the term program can refer to two different entities. It should be clear from
    the context which one we are referring to.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: Note that pseudocode is not a computer language, but a method of expressing
    a computer algorithm in almost plain English. So, a piece of pseudocode can represent
    either a high-level language such as Python or an assembly language.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，伪代码不是一种计算机语言，而是一种用几乎纯英语表达计算机算法的方法。因此，一段伪代码可以代表高级语言（如 Python）或汇编语言。
- en: 'In the following example, the source program of assembly language instructions
    is expressed as a Python list, where each instruction is a string:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，汇编语言指令的源程序以 Python 列表的形式表达，其中每个指令都是一个字符串：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The effect of these instructions is as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指令的效果如下：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: To simplify the Python code, we’ve used spaces as separators – for example,
    `LDRL r0,0` is written as `LDRL` `r0 0`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化 Python 代码，我们使用了空格作为分隔符——例如，`LDRL r0,0` 被写成 `LDRL` `r0 0`。
- en: 'Real computers store assembly language instructions as strings of 32- or 64-bit
    binary numbers. We’re going to directly execute the assembly language instructions
    from the text string to avoid having to translate text into binary and then interpret
    the binary as instructions. Here, we have one goal: to demonstrate how a program
    is executed.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 真实计算机将汇编语言指令存储为 32 位或 64 位二进制数字的字符串。我们将直接从文本字符串中执行汇编语言指令，以避免将文本转换为二进制，然后再将二进制作为指令进行解释。在这里，我们有一个目标：展示程序是如何执行的。
- en: 'The computer on which the preceding assembly-level code runs has only a handful
    of instructions, although it is very easy to add extra instructions. Throughout
    this text, the term *opcode* or operation code indicates the binary code (or text
    version) of an assembly language instruction such as `ADD` or `BNE`. The structure
    of the simulator program in pseudocode is as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行上述汇编级代码的计算机上，尽管添加额外指令非常容易，但只有少数指令。在整个文本中，术语 *opcode* 或操作码表示汇编语言指令（如 `ADD`
    或 `BNE`）的二元代码（或文本版本）。模拟器程序的伪代码结构如下：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This assembly language program, `prog` (provided as a list in the simulator
    code), uses a conditional branch, `BNE 2`, to jump back to instruction 2 if the
    previous operation result was not 0\. The assembly language version in the Python
    program in the following section uses a symbolic name, `Loop`, to indicate the
    target of the branch, but the actual code uses a literal 2\. We will look at how
    symbolic names such as `Loop` are handled later.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这个汇编语言程序，`prog`（在模拟器代码中作为列表提供），使用条件分支 `BNE 2`，如果前一个操作结果不是 0，则跳回指令 2。在下一段 Python
    程序中的汇编语言版本使用符号名 `Loop` 来指示分支的目标，但实际上代码使用的是字面量 2。我们将在稍后查看如何处理像 `Loop` 这样的符号名。
- en: Python code for a primitive simulator
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 原始模拟器的 Python 代码
- en: 'The following is the Python code for this simulator. The initial series of
    comments on lines 0 to 6 show the assembly language pro :'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码是此模拟器的 Python 代码。从第 0 行到第 6 行的初始注释显示了汇编语言程序：
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The interesting part of the code is extracting the operands from the instruction.
    Consider the `ADDL r1 r2 3` instruction, which means add a literal to the source
    register and put the sum in the destination register. The destination register
    is `r1`, the source register is `r2`, and the literal is `3`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的有趣部分是从指令中提取操作数。考虑 `ADDL r1 r2 3` 指令，这意味着将一个字面量加到源寄存器上，并将和放入目标寄存器。目标寄存器是 `r1`，源寄存器是
    `r2`，字面量是 `3`。
- en: 'The Python `inst = inst.split('' '')` operation converts a string into a list
    of substrings using a space as a separator. Therefore, the new value of `inst`
    is the following list:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的 `inst = inst.split(' ')` 操作使用空格作为分隔符将字符串转换为子字符串列表。因此，`inst` 的新值是以下列表：
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We can now examine the four fields of this list; for example, `inst[0] = 'ADDL'`
    gives us the actual instruction mnemonic.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以检查这个列表的四个字段；例如，`inst[0] = 'ADDL'` 给我们实际的指令助记符。
- en: Suppose we want to get the contents of the source register, `r2`. The source
    register is in the third position in the list at `['ADDL', 'r1', 'r2', '3']`;
    that is, `inst[2]`. Let’s write `rS1 = inst[2]`. The value of `rS1` is `'r2'`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要获取源寄存器的内容，`r2`。源寄存器在列表的第三个位置，`['ADDL', 'r1', 'r2', '3']`；即 `inst[2]`。让我们写下
    `rS1 = inst[2]`。`rS1` 的值是 `'r2'`。
- en: 'We want the register number (that is, 2) as an integer, so we have to get the
    second character of r2 and convert it into an integer. We can do this in the following
    way:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望将寄存器号（即 2）作为整数，因此我们必须获取 r2 的第二个字符并将其转换为整数。我们可以用以下方式做到这一点：
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We can combine these two expressions into one as follows.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这两个表达式合并为一个，如下所示。
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The tiny computer we have created executed only five different instructions,
    but it includes many of the most important components of a real computer. This
    computer directly executes instructions from their assembly language form, rather
    than from their binary code. The next step is to look a little more closely at
    instruction sets before we can build a more realistic machine.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的小型计算机只执行了五种不同的指令，但它包括了真实计算机中的许多重要组件。这台计算机直接从汇编语言形式执行指令，而不是从二进制代码执行。下一步是在我们能够构建一个更真实的机器之前，更仔细地看看指令集。
- en: Having constructed a simulator, the next step is to look at the type of instructions
    a computer can execute.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 构建了模拟器之后，下一步是看看计算机可以执行哪种类型的指令。
- en: In the next section, we will develop an instruction set for the TC1 computer.
    As well as providing a practical example of instruction set design, we will demonstrate
    how instructions are divided into multiple fields and each field supplies some
    information about the current instruction.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将为TC1计算机开发一套指令集。除了提供一个指令集设计的实际例子外，我们还将展示指令是如何被分成多个字段，并且每个字段都提供了关于当前指令的一些信息。
- en: The TC1 instruction set
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TC1指令集
- en: 'In this section, we will introduce the key component of our demonstration computer:
    its instruction set. This computer, TC1, has many of the functions of a real computer
    and is easy to understand and modify. We will begin by introducing the TC1 instruction
    set encoding.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍我们演示计算机的关键组件：其指令集。这个计算机，TC1，具有许多真实计算机的功能，易于理解和修改。我们将首先介绍TC1指令集编码。
- en: To simplify this, we can use separate programs and data memories. This departure
    from the traditional von Neuman model allows us to have a 32-bit program memory
    and a 16-bit data memory. Moreover, we don’t have to worry about accidentally
    putting data in the middle of the program area.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化，我们可以使用单独的程序和数据内存。这种与传统冯·诺伊曼模型的偏离使我们能够拥有32位的程序内存和16位的数据内存。此外，我们不必担心不小心将数据放在程序区域的中间。
- en: A typical instruction has several fields; for example, operation code, registers,
    and literals (that is, constants). However, the number of bits in each field must
    add up to the total length of the instruction.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的指令有几个字段；例如，操作码、寄存器和字面量（即常数）。然而，每个字段中的位数总和必须等于指令的总长度。
- en: Modern computers normally employ different formats for each class of instruction.
    This optimizes the allocation of op-codes to bits; for example, a branch instruction
    may have a 4-bit opcode and a 28-bit literal field, whereas a data-processing
    instruction may have a 17-bit opcode and three 5-bit register-select fields.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现代计算机通常为每类指令采用不同的格式。这优化了操作码到位的分配；例如，一个分支指令可能有一个4位的操作码和一个28位的字面量字段，而一个数据处理指令可能有一个17位的操作码和三个5位的寄存器选择字段。
- en: For the sake of simplicity, the TC1 computer has a single, fixed format. All
    instructions have the same number of fields, and fields are the same size for
    each instruction. An instruction, as shown in *Figure 4**.1*, is made up of an
    operation *class* plus an opcode, three register fields, and a literal field.
    *Figure 4**.1* shows the opcode field as 7 bits, with a 2-bit opcode class and
    a 5-bit actual opcode.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化起见，TC1计算机有一个单一、固定的格式。所有指令的字段数量相同，并且每个指令的字段大小相同。如图*图4**.1*所示，一条指令由操作*类别*加上操作码、三个寄存器字段和一个字面量字段组成。*图4**.1*显示了操作码字段为7位，其中包含2位的操作码类别和5位的实际操作码。
- en: 'The structure of this instruction format is inefficient because if an instruction
    does not access a register, the three register select fields are wasted. In a
    three-register instruction such as ADD rd,rS1,rS2, the rd register is the destination,
    rS1 is source register 1, and rS2 is source register 2:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这种指令格式的结构效率低下，因为如果一个指令不访问寄存器，那么三个寄存器选择字段就浪费了。在一个如ADD rd,rS1,rS2的三寄存器指令中，rd寄存器是目的寄存器，rS1是源寄存器1，rS2是源寄存器2：
- en: '![Figure 4.1 – TC1 instruction format (RISC style)](img/Figure_4.01_B19624.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图4.1 – TC1指令格式（RISC风格）](img/Figure_4.01_B19624.jpg)'
- en: Figure 4.1 – TC1 instruction format (RISC style)
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1 – TC1指令格式（RISC风格）
- en: We devote 16 bits to the literal field so that we can load a constant into memory
    with a single instruction. That leaves 32 - 16 = 16 bits to allocate to all the
    other fields.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将16位分配给字面量字段，以便我们可以用一条指令将常数加载到内存中。这留下了32 - 16 = 16位可以分配给所有其他字段。
- en: TC1 has a three-register format, which is typical of load and store computers
    such as ARM and MIPS. If we have eight registers, it takes 3 x 3 = 9 bits to specify
    all three registers. After allocating 16 bits to the literal and 9 bits to the
    register selection, we are left with 32 - (16 + 9) = 7 bits to specify up to 128
    different possible instructions (27 = 128).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: 'The opcode field itself is divided into four categories or classes, which take
    two bits, leaving 7- 2 = 5 for the instructions in each category. *Table 4.1*
    defines the categories (class) of instructions:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '| **Class** | **Group** | **Comments** |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
- en: '| 0 0 | Special operation | Operations that perform functions such as `STOP`
    or read the keyboard |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
- en: '| 0 1 | Data transfer | Operations that copy data from one place to another
    |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
- en: '| 1 0 | Data processing | Arithmetic and logic data-processing operations |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
- en: '| 1 1 | Flow control | Operations that control the sequencing of instructions,
    such as `BEQ` |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
- en: Table 4.1 – TC1 instruction classes
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '*Table 4.2* illustrates the TC1 instruction set. The first column (`01 00001`
    loads a register with the contents of a memory location. The leftmost two bits
    are separated to indicate the instruction group:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '| **Binary Code** | **Operation** | **Mnemonic** | **Instruction Format****rrr
    = Rd, aaa = rS1, bbb =** **rS2** | **Code** **Format** |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
- en: '| `00 00000` | Stop operation | STOP | 00 00000 000 000 000 0 | 0 0 0 0 |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
- en: '| `00 00001` | No operation | NOP | 00 00001 000 000 000 0 | 0 0 0 0 |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
- en: '| `00` `00 010` | Get a char from the keyboard | GET r0 | 00 00010 rrr 000
    000 0 | 1 0 0 0 |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
- en: '| `00 00011` | Get a random character | RND r0 | 00 00011 rrr 000 000 L | 1
    0 0 1 |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
- en: '| `00 00100` | Swap bytes in the register | SWAP r0 | 00 00100 rrr 000 000
    0 | 1 0 0 0 |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
- en: '| `00 01000` | Print a hex value in the register | PRT r0 | 00 01000 rrr 000
    000 0 | 1 0 0 0 |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
- en: '| `00 11111` | Terminate program | END | 00 11111 000 000 000 0 | 0 0 0 0 |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
- en: '| `01 00000` | Load register from register | MOV r0,r1 | 01 00000 rrr aaa 000
    0 | 1 1 0 0 |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
- en: '| `01 00001` | Load register from memory | LDRM r0,L | 01 00001 rrr 000 000
    L | 1 0 0 1 |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
- en: '| `01 00010` | Load register with literal | LDRL r0,L | 01 00010 rrr 000 000
    L | 1 0 0 1 |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
- en: '| `01 00011` | Load register indirect | LDRI r0,[r1,L] | 01 00011 rrr aaa 000
    L | 1 1 0 1 |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
- en: '| `01 00100` | Store register in memory | STRM r0,L | 01 00100 rrr 000 000
    L | 1 0 0 1 |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
- en: '| `01 00101` | Store register indirect | STRI r0,[r1,L] | 01 00101 rrr aaa
    000 L | 1 1 0 1 |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
- en: '| `10 00000` | Add register to register | ADD r0,r1,r2 | 10 00000 rrr aaa bbb
    0 | 1 1 1 0 |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
- en: '| `10 00001` | Add register to literal | ADDL r0,r1,L | 10 00001 rrr aaa 000
    L | 1 1 0 1 |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
- en: '| `10 00010` | Subtract register from register | SUB r0,r1,r2 | 10 00010 rrr
    aaa bbb 0 | 1 1 1 0 |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
- en: '| `10 00011` | Subtract literal from register | SUBL r0,r1,L | 10 00011 rrr
    aaa 000 L | 1 1 0 1 |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
- en: '| `10 00100` | Multiply register by register | MUL r0,r1,r2 | 10 00100 rrr
    aaa bbb 0 | 1 1 1 0 |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
- en: '| `10 00101` | Multiply literal by register | MULL r0,r1,L | 10 00101 rrr aaa
    000 L | 1 1 0 1 |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
- en: '| `10 00110` | Divide register by register | DIV r0,r1,r2 | 10 00110 rrr aaa
    bbb 0 | 1 1 1 0 |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
- en: '| `10 00111` | Divide register by literal | DIVL r0,r1,L | 10 00111 rrr aaa
    000 L | 1 1 0 1 |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
- en: '| `10 01000` | Mod register by register | MOD r0,r1,r2 | 10 01000 rrr aaa bbb
    0 | 1 1 1 0 |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
- en: '| `10 01001` | Mod register by literal | MOD r0,r1,L | 10 01001 rrr aaa 000
    L | 1 1 0 1 |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
- en: '| `10 01010` | AND register to register | AND r0,r1,r2 | 10 01000 rrr aaa bbb
    0 | 1 1 1 0 |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
- en: '| `10 01011` | AND register to literal | ANDL r0,r1,L | 10 01001 rrr aaa 000
    L | 1 1 0 1 |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
- en: '| `10 01100` | OR register to register | OR r0,r1,r2 | 10 01010 rrr aaa bbb
    0 | 1 1 1 0 |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
- en: '| `10 01101` | OR register to literal | ORL r0,r1,L | 10 01011 rrr aaa 000
    L | 1 1 0 1 |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
- en: '| `10 01110` | EOR register to register | EOR r0,r1,r2 | 10 01010 rrr aaa bbb
    0 | 1 1 1 0 |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
- en: '| `10 01111` | EOR register to literal | EORL r0,r1,L | 10 01011 rrr aaa 000
    L | 1 1 0 1 |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
- en: '| `10 10000` | NOT register | NOT r0 | 10 10000 rrr 000 000 0 | 1 0 0 0 |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
- en: '| `10 10010` | Increment register | INC r0 | 10 10010 rrr 000 000 0 | 1 0 0
    0 |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
- en: '| `10 10011` | Decrement register | DEC r0 | 10 10011 rrr 000 000 0 | 1 0 0
    0 |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
- en: '| `10 10100` | Compare register with register | CMP r0,r1 | 10 10100 rrr aaa
    000 0 | 1 1 0 0 |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
- en: '| `10 10101` | Compare register with literal | CMPL r0,L | 10 10101 rrr 000
    000 L | 1 0 0 1 |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
- en: '| `10 10110` | Add with carry | ADC r0,r1,r2 | 10 10110 rrr aaa bbb 0 | 1 1
    1 0 |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
- en: '| `10 10111` | Subtract with borrow | SBC r0,r1,r2 | 10 10111 rrr aaa bbb 0
    | 1 1 1 0 |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
- en: '| `10 11000` | Logical shift left | LSL r0,L | 10 10000 rrr 000 000 0 | 1 0
    0 1 |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
- en: '| `10 11001` | Logical shift left literal | LSLL r0,L | 10 10000 rrr 000 000
    L | 1 0 0 1 |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
- en: '| `10 11010` | Logical shift right | LSR r0,L | 10 10001 rrr 000 000 0 | 1
    0 0 1 |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
- en: '| `10 11011` | Logical shift right literal | LSRL r0,L | 10 10001 rrr 000 000
    L | 1 0 0 1 |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
- en: '| `10 11100` | Rotate left | ROL r0,L | 10 10010 rrr 000 000 0 | 1 0 0 1 |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
- en: '| `10 11101` | Rotate left literal | ROLL r0,L | 10 10010 rrr 000 000 L | 1
    0 0 1 |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
- en: '| `10 11110` | Rotate right | ROR r0,L | 10 10010 rrr 000 000 0 | 1 0 0 1 |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
- en: '| `10 11111` | Rotate right literal | RORL r0,L | 10 10010 rrr 000 000 L |
    1 0 0 1 |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
- en: '| `11 00000` | Branch unconditionally | BRA L | 11 00000 000 000 000 L | 0
    0 0 1 |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
- en: '| `11 00001` | Branch on zero | BEQ L | 11 00001 000 000 000 L | 0 0 0 1 |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
- en: '| `11 00010` | Branch on not zero | BNE L | 11 00010 000 000 000 L | 0 0 0
    1 |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
- en: '| `11 00011` | Branch on minus | BMI L | 11 00011 000 000 000 L | 0 0 0 1 |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
- en: '| `11 00100` | Branch to subroutine | BSR L | 11 00100 000 000 000 L | 0 0
    0 1 |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
- en: '| `11 00101` | Return from subroutine | RTS | 11 00101 000 000 000 0 | 0 0
    0 0 |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
- en: '| `11 00110` | Decrement and branch on not ٠ | DBNE r0,L | 11 00110 rrr 000
    000 L | 1 0 0 1 |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
- en: '| `11 00111` | Decrement and branch on zero | DBEQ r0,L | 11 00111 rrr 000
    000 L | 1 0 0 1 |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
- en: '| `11 01000` | Push register on the stack | PUSH r0 | 11 01000 rrr 000 000
    0 | 1 0 0 0 |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| `11 01000` | 将寄存器推入堆栈 | PUSH r0 | 11 01000 rrr 000 000 0 | 1 0 0 0 |'
- en: '| `11 01001` | Pull register off the stack | PULL r0 | 11 01001 rrr 000 000
    0 | 1 0 0 0 |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| `11 01001` | 从堆栈中拉取寄存器 | PULL r0 | 11 01001 rrr 000 000 0 | 1 0 0 0 |'
- en: Table 4.2 – TC1 Instruction encoding (the 4 code format bits are not part of
    the opcode)
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 表4.2 – TC1指令编码（4个代码格式位不是操作码的一部分）
- en: The rightmost column is called `1001` tells the assembler that the instruction
    requires a destination register and a 16-bit literal. Code 0000 tells us that
    the instruction contains no operands at all.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 最右侧的列称为`1001`，告诉汇编器该指令需要目标寄存器和16位字面值。代码`0000`告诉我们该指令不包含任何操作数。
- en: We chose these instructions to demonstrate a range of operations. Many of these
    instructions are typical of a RISC computer such as ARM (that is, we don’t include
    operations on data in memory). Note that later, we’ll introduce a simulator for
    a memory-to-register instruction set that allows operations such as `ADD r1,12`,
    where `12` is a memory location.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择这些指令来展示一系列操作。许多这些指令是RISC计算机（如ARM）的典型代表（即我们不包含对内存中数据的操作）。注意，稍后我们将介绍一个内存到寄存器指令集的模拟器，它允许执行如`ADD
    r1,12`这样的操作，其中`12`是一个内存位置。
- en: Some instructions in *Table 4.2* don’t exist on a real computer; for example,
    read a character from the keyboard. We added that to simplify debugging and experimentation.
    Similarly, TC1 can generate a random number, a feature not found in most computer
    instruction sets. However, it’s useful for generating random test data. Some instructions,
    such as subroutine calls and returns, implement more sophisticated operations,
    which we shall encounter later.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 表4.2中的一些指令在真实计算机上不存在；例如，从键盘读取字符。我们添加这些指令是为了简化调试和实验。同样，TC1可以生成随机数，这是大多数计算机指令集中没有的特性。然而，它对于生成随机测试数据很有用。一些指令，如子程序调用和返回，实现了更复杂的操作，我们将在后面遇到。
- en: The column labeled `L` indicates a literal value (that is, a 16-bit constant).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 标有`L`的列表示字面值（即16位常数）。
- en: The fourth column (`rrr`, `aaa`, and `bbb` show the location of the three register
    select fields. The rightmost field (`0` or `L`) represents 16 bits of the literal.
    We show `0` if all bits are 0, and `L` if a 16-bit literal is required by the
    instruction. If a register field is not required, the corresponding field is filled
    with zeros (although it doesn’t matter what value these bits are because they
    are not used by the instruction).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 第四列（`rrr`、`aaa`和`bbb`）显示了三个寄存器选择字段的位置。最右侧的字段（`0`或`L`）表示字面值的16位。如果所有位都是0，我们显示`0`；如果指令需要16位字面值，则显示`L`。如果一个寄存器字段不是必需的，相应的字段将用零填充（尽管这些位是什么值并不重要，因为指令不会使用这些位）。
- en: 'Remember that the four bits in the rightmost column are not part of the opcode
    or instruction itself. These bits show which fields are required by the current
    instruction: the destination register (`rrr`), the source 1 register (`aaa`),
    the source 2 register (`bb`), and the literal, `L`. For example, code `1100` indicates
    that the instruction has a destination register and a single source register.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，最右侧列中的四个位不是操作码或指令本身的一部分。这些位显示了当前指令所需的字段：目标寄存器（`rrr`）、源1寄存器（`aaa`）、源2寄存器（`bb`）和字面值`L`。例如，代码`1100`表示该指令有一个目标寄存器和单个源寄存器。
- en: Explaining some of the instructions
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解释一些指令
- en: Some of the instructions in *Table 4.2* are typical of real processors. Several
    instructions have been included to provide useful facilities such as generating
    a random number for testing purposes. This section describes several of the instructions
    in *Table 4.2*.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 表4.2中的一些指令是真实处理器的典型代表。包括了一些指令以提供有用的功能，例如生成随机数以供测试使用。本节描述了表4.2中的一些指令。
- en: '`STOP` terminates instruction processing. Most modern computers don’t have
    an explicit `STOP` operation.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`STOP`终止指令处理。大多数现代计算机没有显式的`STOP`操作。'
- en: '`NOP` does nothing other than advance the program counter. It’s a dummy operation
    that is useful as a marker in code, a placeholder for future code, or as an aid
    to testing.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`NOP`除了推进程序计数器外不做任何事情。它是一个有用的占位符操作，可以作为代码中的标记、未来代码的占位符或测试的辅助。'
- en: '`GET` reads data from the keyboard and offers a simple way of getting input
    from the keyboard into a register. This is useful when testing programs and is
    not a normal computer instruction.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`GET`从键盘读取数据，并提供了一种简单的方法将键盘输入传送到寄存器。这在测试程序时很有用，但它不是一个正常的计算机指令。'
- en: '`RND` generates a random number. It’s not in computer instruction sets but
    provides an excellent means of generating data internally when testing your code.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`RND` 生成随机数。它不在计算机指令集中，但在测试代码时提供了一种生成内部数据的优秀手段。'
- en: '`SWAP` exchanges upper- and lower-order bytes – for example, `0x1234` becomes
    `0x3412`.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`SWAP` 交换高字节和低字节 – 例如，`0x1234` 变为 `0x3412`。'
- en: The load and store instructions move data between memory and registers. The
    difference between members of this class is the direction (store is computer-to-memory,
    while load is memory-to-computer), size (some computers allow byte, 16-bit, or
    32-bit transfers), and addressing mode (using a literal value, an absolute address,
    or an address from a register).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 加载和存储指令在内存和寄存器之间移动数据。这类指令成员之间的区别在于方向（存储是从计算机到内存，而加载是从内存到计算机），大小（某些计算机允许字节、16位或32位传输），以及寻址模式（使用字面值、绝对地址或寄存器地址）。
- en: '`MOV` copies one register to another – for example, `MOV r3,r1` copies the
    contents of `r1` to `r3`. `MOV` is, essentially, an a load register with register
    (LDRR) instruction.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`MOV` 将一个寄存器的内容复制到另一个寄存器 – 例如，`MOV r3,r1` 将 `r1` 的内容复制到 `r3`。`MOV` 实质上是一个加载寄存器与寄存器（LDRR）指令。'
- en: '`LDRL` loads a register with a literal value – for example, `LDRL r3,20` loads
    register `r3` with `20`.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`LDRL` 将寄存器加载为字面值 – 例如，`LDRL r3,20` 将寄存器 `r3` 加载为 `20`。'
- en: '`LDRM` loads a register with the contents of a memory location specified by
    a literal address. `LDRM r1,42` loads `r1` with the contents of memory location
    `42`. This instruction does not exist on modern RISC processors. Most modern processors
    do not allow you to access an absolute memory address,'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`LDRM` 将寄存器的内容加载到由字面值地址指定的内存位置。`LDRM r1,42` 将 `r1` 加载为内存位置 `42` 的内容。这个指令在现代RISC处理器上不存在。大多数现代处理器不允许你访问绝对内存地址，'
- en: '`LDRI`, the load register indexed (or load register indirect) instruction,
    loads a register with the contents of a memory location specified by the contents
    of a register plus a literal address. `LDRM r2,[r3,10]` loads `r2` with the contents
    of the memory location whose address is given by the contents of `r3` plus `10`.
    This instruction is the standard RISC load operation.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`LDRI` 是加载寄存器索引（或加载寄存器间接）指令，将寄存器的内容加载到由寄存器内容加字面值地址指定的内存位置。`LDRM r2,[r3,10]`
    将 `r2` 加载为地址由 `r3` 内容加 `10` 给定的内存位置的内容。这个指令是标准的RISC加载操作。'
- en: '`STRM`, the store register memory instruction, stores a register at the location
    specified by a literal address. `STRM r2,15` stores register `r2` at memory location
    `15`. RISC processors don’t implement this instruction.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`STRM` 是存储寄存器内存指令，将寄存器存储在由字面值地址指定的位置。`STRM r2,15` 将寄存器 `r2` 存储在内存位置 `15`。RISC
    处理器不实现这个指令。'
- en: '`STRI`, the store register indexed instruction, stores a register at the location
    specified by a register plus a literal. `STRI r2,[r6,8]` stores `r2` at the memory
    location whose address is `r6` plus `8`.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`STRI` 是存储寄存器索引指令，将寄存器存储在由寄存器加字面值指定的位置。`STRI r2,[r6,8]` 将 `r2` 存储在地址为 `r6`
    加 `8` 的内存位置。'
- en: The `STR`, `STRM`, and `STRI` instructions are anomalous because they write
    the source and destination operands in the reverse order to `LDR` (and all other
    processor operations); that is, if you write `LDR r0,PQR`, you should write `STR
    PQR,r0` to indicate the reverse data flow. But, by custom and practice, we don’t.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`STR`、`STRM` 和 `STRI` 指令是异常的，因为它们将源操作数和目标操作数写入的顺序与 `LDR`（以及所有其他处理器操作）相反；也就是说，如果你写
    `LDR r0,PQR`，你应该写 `STR PQR,r0` 来表示反向数据流。但是，按照惯例和实践，我们并不这样做。'
- en: '`DBNE` We added the decrement and branch on not zero instruction for fun because
    it reminds me of my old Motorola days. The 68000 was a powerful microprocessor
    (at the time) with a 32-bit architecture. It has a decrement and branch instruction
    that is used at the end of a loop. On each pass around the loop, the specified
    register is decremented, and a branch back to a label is made if the counter is
    not -1\. `DBNE r0,L` decrements `r0` and branches to the line numbered `L` if
    the count is not zero.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`DBNE` 我们添加了递减且非零分支指令是为了好玩，因为这让我想起了我的老摩托罗拉时代。68000 是一个强大的微处理器（在当时）具有32位架构。它有一个递减和分支指令，用于循环的末尾。在循环的每次迭代中，指定的寄存器都会递减，如果计数器不是-1，则返回到标签。`DBNE
    r0,L` 递减 `r0`，如果计数器不为零，则跳转到编号为 `L` 的行。'
- en: Register indirect addressing
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 寄存器间接寻址
- en: 'Two instructions require a special mention because they are concerned not with
    operations on data but with accessing data in memory. These are `LDRI` and `STRI`,
    both of which use register indirect addressing. In *Table 4.2,* the `0b0100011`
    opcode corresponds to `LDRI` (that is, load register *indirect*). This instruction
    doesn’t give you the actual address of the operand; it tells you where the address
    can be found. The register indirect addressing mode is also called pointer-based
    or indexed addressing. The operand address in memory is given by the contents
    of a register plus an offset; that is, `r[rD]=mem[r[rS1]+lit]`. If we use bold
    and shading, we can make its interpretation a little easier:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*Figure 4**.2* demonstrates the effect of the `LDRI r1,[r0,3]` TC1 instruction,
    where pointer register `r0` contains 100 and the operand is accessed at memory
    address 100 + 3 = 103:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2 – Register indirect addressing](img/Figure_4.02_B19624.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
- en: Figure 4.2 – Register indirect addressing
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: 'This addressing mode lets you modify addresses while the program is running
    (because you can change the contents of the pointer, `r0`). Pointer-based addressing
    makes it possible to step through a list of items, element by element, simply
    by incrementing the pointer. Here’s an example:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We access the element pointed at by `r2` (in this case, the offset is `0`).
    The next line increments `r2` to point to the next element. If this sequence is
    executed in a loop, the data will be accessed element by element.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: Computers implement both arithmetic and Boolean (logical) operations. In the
    next section, we’ll briefly look at how Python can be used to simulate logical
    operations at the assembly language level.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: Bit-handling in Python
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we’ll look at how Python deals with the fundamental component
    of all computer data: the bit. Because simulated computers operate at the level
    of bits, we have to look at how bits are manipulated in Python before we can construct
    a simulator that can perform logical operations such as `AND` and `OR`.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: Computers can operate on entire words as a single entity, or on the individual
    bits of a word. Consequently, we have to be able to perform both bit operations
    and word operations to simulate a computer.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: Python lets you input data and display it as a binary string of bits. You can
    operate on individual bits of a string using Boolean operators, and you can shift
    the bits of a word left and right. You have all the tools you need in Python.
    We are now going to look at Python, which lets you operate on the individual bits
    of an integer.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: 'Because the simulator will operate on binary numbers, we have to exploit several
    Python facilities; for example, a binary value is indicated by prefixing it with
    `0b`. If you want to use the binary equivalent of 15, you must write `0b1111`
    and use it just like a decimal number. The following two operations have the same
    effect:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Two important binary operators are `>>` (shift right) and `<<` (shift left).
    Shift expressions are written as `p >> q` or `p << q`, where `p` is the number
    to be operated on and `q` is the number of bit positions shifted. Consider the
    following example:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This shifts `x` two places left to give the new value `0b111011000`. All the
    bits have moved two places left and 0s have been entered at the right-hand end
    to fill the newly vacated positions. The shifted version of `x` now has nine bits,
    rather than seven. However, when we simulate a computer, we have to ensure that,
    whatever we do, the number of bits in a word remains constant. If a register has
    16 bits, any operation you perform on it must yield 16 bits.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: 'We can take two words and perform Boolean (bitwise) operations on them; for
    example, C = A & B ANDs together words A and B by calculating ci = ai · bi for
    each bit in the word (that is, for i = 0 to 7). Consider the following:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '| **Truth table** **for AND** |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
- en: '| --- |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
- en: '| x | y | z=x & y |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
- en: '| 0 | 0 | 0 |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
- en: '| 0 | 1 | 0 |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
- en: '| 1 | 0 | 0 |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
- en: '| 1 | 1 | 1 |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
- en: This gives `x = 0b000001101`, because ANDing a bit with 0 gives a 0 result,
    and ANDing a bit x with 1 gives x, because 1 & 0 = 0 and 1 & 1 = 1, as the truth
    table demonstrates.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: 'In Python, hexadecimal numbers are prefixed with `0x`; for example, `0x2F1A`.
    We use hexadecimal numbers in Python programs because they are shorter than binary
    numbers. Here is an example:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Consider the following fragment of Python code:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The output from this code is `y` `is 0b1001`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: 'Python uses more than 16 bits to represent numbers. To simulate binary arithmetic
    in TC1, we must constrain Python’s numbers to 16 bits. We have to work with the
    longer words provided by Python and chop them down to 16 or 32 bits as necessary.
    Consider the following:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Shifting the 16-bit word left two places made it an 18-bit word. ANDing it with
    the `0b1111111111111111` binary value forces it to 16 significant bits.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: Operator precedence in Python
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, we have to re-learn something that we learned about in high school arithmetic:
    operator precedence. When you use several operators in an expression, you have
    to be aware of operator precedence; that is, which operations are performed before
    others. For example, is 4 * 5 + 3 equal to 23 or 32? All computer languages have
    a hierarchy of operator precedence. The partial list of operator precedence for
    Python is as follows, with the highest precedence first. We often use parentheses
    to make the meaning of expressions clearer, even if it’s not required – for example,
    `(xxx << 4) & (yyy <<` `2)`:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the next section, we’ll look at how an instruction, which is a string of
    1s and 0s, is decoded and the appropriate operation that’s performed.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll take a major step in constructing a simulator – that is, decoding
    a machine-level binary instruction to extract information about the operation
    it is going to simulate.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: Decoding and executing an instruction
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we’ll look at a few examples of how instructions are encoded
    and decoded. Consider the `ADD r1,r2,r3`, operation (where the codes for registers
    `rD`, `rS1`, and `rS2` are shaded), which is defined in RTL as follows:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '`[r1]` `←` `[r2] + [``r3]`'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '*Table 4.2* shows that the encoding of `ADD r1,r2,r3` is `10 00000 001 010
    011 0000000000000000`. The corresponding 4-bit format code that defines the registers
    to be used is `1110` because we use three registers and no literal field (remember
    that this 4-bit format code is not part of the opcode but is used by the assembler
    to interpret the instruction).'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: 'The following Python code shows how we can decode an instruction to extract
    five variables: the operation code (`binOp`); the three registers, `rD`, `rS1`,
    and `rS2`; and a literal. Decoding is performed by shifting the bits of the instruction
    right to move the required field into the least significant position and then
    ANDing it with a mask to remove any other fields. Consider, `xxxxxxx xxx 010 xxx
    xxxxxxxxxxxxxxxx`. If we shift this string 19 places right, we get `0000000000000000000xxxxxxxxxx010`.
    The zeros have been shifted in, and the three bits we’re interested in are right-justified
    in the least significant bits. If we `AND` this with `0b111` to select only the
    three least significant bits, we get `0000000000000000000000000000010` – that
    is, the required register value is now right-justified and we can use it:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The shift-right operator in Python is `>>` and the bit-wise logical `AND` operator
    is `&`. The mask is expressed as a string of bits (rather than a decimal number)
    because ANDing with binary 111 is clearer than ANDing with decimal 7\. In Python,
    a binary value is preceded by 0b, so 7 is represented by `0b111`. The literal
    is ANDed with 16 ones, expressed as `0xFFFF`. We use binary for short fields,
    and hex value for long fields. It’s just personal preference.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: The `binCode >> 22 & 0b111` expression shifts the bits of `binCode` 22 places
    right, and then bitwise ANDs the result with `000…000111`. Because of operator
    precedence, the shifting is performed first. Otherwise, we would have written
    `(binCode >> 22) & 0b111`. We often use parentheses, even when not strictly necessary,
    to stress operator precedence.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: Note that we extract all fields, even though they may not be required by each
    instruction. Similarly, we read all three register’s contents. This approach simplifies
    the Python code, at the cost of efficiency.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: Consider extracting the destination register field, `rrr`. Suppose that the
    instruction is `ADD r1,r2,r3`, and the opcode is `10`00000001010`011`0000000000000000\.
    We have put alternate fields in bold font and the destination field is shaded
    to make it easier to read. Performing a 22-bit right shift moves the destination
    register into the least-significant bits and leaves us with
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, if we perform the `AND` operation with 111 (all bits to the left are zero),
    we get the following:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We have now isolated the first register field to get `001`, which corresponds
    to register `r1`. The final three lines of the program to decode an instruction
    are as follows:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: These instructions use the register addresses (`rD`, `rS1`, and `rS2`) to access
    registers; that is, the instruction specifies which registers are to be used.
    For example, if `op0 = r[5],` register `r5` is operand zero, the destination register.
    If an instruction does not specify a register, the unused field is set to zero.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: 'Once an instruction has been decoded, it can be executed. Fortunately, executing
    most instructions is remarkably easy. Consider the following examples:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This fragment of code demonstrates the execution of four instructions from the
    load and store (that is, memory access) group. The Python `if … elif` construct
    tests each opcode in turn. The first line compares the 7-bit opcode with the binary
    value `0100010`, which corresponds to the `LDRL` (load a register with a literal
    value) instruction. Incidentally, in the final version of TC1, we made the code
    easier to read by comparing operations with the actual mnemonic; for example,
    `'LDRL'` is easier to read than its code, `0b100010`.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: If there is a match, the code following the colon is executed, `(r[rD] = lit)`.
    If not, the next line uses the `elif` command to compare the opcode with 010001\.
    If there is a match, the code after the colon is executed. In this way, the opcode
    is compared with all its possible values until a match is found.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose the instruction’s opcode is `0100010`, and the `r[rD] = lit` line is
    executed. This Python operation transfers the value of the 16-bit literal provided
    in the instruction to the destination register specified in the instruction. In
    RTL terms, it carries out `r[rD] ← lit` and is used by the programmer to load
    an integer into a register. Let’s say the binary pattern of the instruction code
    is as follows:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Here, the 16-bit literal is loaded into register `r6` to implement `LDRL r6,193`.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: Arithmetic and logical operations
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The arithmetic and logical group of operations do all the work (data processing)
    in a program. They include arithmetic operations (addition, subtraction, and multiplication),
    as well as logical operations (`AND`, `OR`, `EOR`, and `NOT`). These are three-operand
    instructions, apart from `NOT`; for example, `AND r``3,r0,r5` performs a bitwise
    `AND` between the bits of `r0` and `r5`, and puts the result in `r3`.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: 'The following fragment of Python code shows how TC1 interprets four instructions
    in this group. There are two pairs of instructions: addition and subtraction.
    Each pair consists of a register-to-register operation and a register-with-literal
    operation; for example, `ADD r1,r2,r3` adds the contents of registers `r2` and
    `r3` together, whereas `ADDL r1,r2,L` adds the contents of a 16-bit literal to
    the contents of register `r2`. We don’t do the arithmetic here. Instead, we call
    a function called `alu(f,a,b)` to perform the required action. The next section
    will show you how to create your own functions:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: If you were to write the full Python code required to execute each operation,
    it would require several lines of code per instruction. An addition operation
    such as `reg[dest] = reg[src1] + reg[src2]` appears simple enough, but there is
    more to an arithmetic operation.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: To explain why, we need to discuss the role of conditional flag bits. Recall
    that computers make decisions regarding whether to execute the next instruction
    in sequence, or whether to jump to a different place in the code (that is, an
    `if…then…else` construct). The decision whether to take the `if` branch or the
    `else` branch is determined by the outcome of an arithmetic or logical operation
    (this includes compare operations).
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: The result of an arithmetic or logical operation is tested and used to set or
    clear condition code flags. These flags are usually the negative, zero, carry,
    and overflow flags and are written as `n`, `z`, `c`, and `v`. For example, if
    an operation is x = p – q and the result is x = 0, then the z-bit (zero bit) is
    set to 1\. Similarly, if an operation yields a result that cannot be represented
    in 16 bits, the carry bit, c, is set. Because most computers use two’s complement
    arithmetic, the negative flag, n, is set if the result is negative in two’s complement
    terms (that is, its most significant bit is 1). The v-bit indicates arithmetic
    overflow and is set if the result is out of range. This means that two positive
    numbers have been added and the result is negative, or two negative numbers have
    been added and the result is positive.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '*Table 4.3* demonstrates how 4 bits can be allocated to the numbers 0 to 15
    (unsigned) or -8 to 7 (signed two’s complement). It’s up to the programmer to
    choose the convention. However, the arithmetic remains the same for both conventions.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider 0110 + 1100, which is 10010 (or 0010 in 4 bits). If we interpret these
    figures as unsigned, the calculation gives us 6 + 12 = 2, which is incorrect,
    because the result 18 cannot be represented in 4 bits. If we consider these as
    signed values, the calculation is 6 + -4 = 2 and the result is correct:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '| **8** | **4** | **2** | **1** | **Unsigned value** | **Signed value** |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
- en: '| 0 | 0 | 0 | 0 | 0 | 0 |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
- en: '| 0 | 0 | 0 | 1 | 1 | 1 |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
- en: '| 0 | 0 | 1 | 0 | 2 | 2 |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
- en: '| 0 | 0 | 1 | 1 | 3 | 3 |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
- en: '| 0 | 1 | 0 | 0 | 4 | 4 |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
- en: '| 0 | 1 | 0 | 1 | 5 | 5 |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
- en: '| 0 | 1 | 1 | 0 | 6 | 6 |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
- en: '| 0 | 1 | 1 | 1 | 7 | 7 |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
- en: '| 8 | 4 | 2 | 1 |  |  |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
- en: '| 1 | 0 | 0 | 0 | 8 | -8 |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
- en: '| 1 | 0 | 0 | 1 | 9 | -7 |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
- en: '| 1 | 0 | 1 | 0 | 10 | -6 |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
- en: '| 1 | 0 | 1 | 1 | 11 | -5 |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
- en: '| 1 | 1 | 0 | 0 | 12 | -4 |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
- en: '| 1 | 1 | 0 | 1 | 13 | -3 |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
- en: '| 1 | 1 | 1 | 0 | 14 | -2 |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
- en: '| 1 | 1 | 1 | 1 | 15 | -1 |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
- en: Table 4.3 – A representation of 4-bit values in signed and unsigned forms
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: Two’s complement arithmetic – a note
  id: totrans-259
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There are several ways of representing negative numbers in binary arithmetic.
    One of the oldest is called sign and magnitude, where a number is prefixed by
    0 if it’s positive and 1 if it’s negative. This is not used today in binary arithmetic
    (except for floating-point numbers).
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: Two’s complement notation is used by almost all modern computers to represent
    signed integers. In two’s complement arithmetic, if N is a positive number in
    n bits, the value of -N is given by 2n – 1\. The two’s complement of N can be
    calculated easily by inverting the bits and adding 1\. For example, if N = `000110`
    in six bits, the value of -6 is represented by `111010`.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: The advantage of two’s complement arithmetic is that addition and subtraction
    are performed in the same way. If you add a two’s complement value to another
    number, the result is correctly calculated. For example, if we add 9 (that is,
    `001001`) to the previous value of -6, we get `001001` + `111010` = `1000011`,
    which is +3 in six bits. The carry-out (in bold font) is discarded.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: Zero, carry, and sign bits
  id: totrans-263
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The carry and sign bits are used to determine whether a result is in range
    or out of range. In signed arithmetic, the result of a two’s complement addition
    of S = A+B is out of range, if the sign bits of A and B are both 0 and the sign
    bit of S is 1, or if the sign bits of A and B are both 1 and the sign bit of S
    is 0\. Consider addition and subtraction using four bits. Two’s complement arithmetic
    is used, and the leftmost bit is the sign bit. In each case, we’ve performed a
    two’s complement addition on signed numbers. The results give us the state of
    the flag bits:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: How do we know whether a number is signed or unsigned? We don’t! There is no
    difference. If you use signed numbers, you must interpret the result as a signed
    value. If you use unsigned numbers, you must interpret the result as an unsigned
    value. For example, in four bits, 1110 is both -2 and +14, depending on how you
    look at it.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: The next topic deals with how we handle groups of repetitive operations. If
    the same sequence of operations is going to be used more than once in a program,
    it makes sense to combine them into a group and invoke that group whenever you
    need it. In Python, this group of actions is called a function.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: Functions in Python
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will now describe Python’s functions. We’ve already used functions that
    are part of the language, such as `len()`. In this section, we’ll do the following:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: Explain why functions are useful
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide an example of a function to implement an ALU
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explain how variables can be private to a function or shared between functions
    (scope)
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Describe how parameters are passed to functions
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Describe how a function returns a result
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing the Python code to deal with each arithmetic or logical operation implemented
    by a simulator would be tedious because so much code would be replicated by individual
    instructions. Instead, we can create a Python function (that is, a subroutine
    or procedure) that carries out both the arithmetic/logic operation and the appropriate
    flag-bit setting.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider a Python function called `alu(f,p,q)` that returns an integer that
    is a function of the `f`, `p`, and `q` parameters. The operation to be performed
    is passed to the procedure as an integer, `f`. The function also updates the z
    and n flag bits. This is a simplified version of the actual function we will use
    and will provide just two operations, add and subtract, and update only two flag
    bits:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The function is introduced by `def`, its name, and any parameters followed by
    a colon. The body of the function is indented. The first parameter, `f`, selects
    the operation we wish to perform (`f` = 1 for addition and 2 for subtraction).
    The next two input parameters, `p` and `q`, are the data values used by the function.
    The last line of the function returns the result to the function’s calling point.
    This function can be called by, for example, `opVal = alu(2,s1,s2)`. In this case,
    the result, `opVal`, would be the value of `s1 –` `s2`.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: We also update two flag bits, `z` and `n`. Initially, both `z` and `n` are set
    to zero by `z, n = 0, 0`. (Python allows multiple assignments on the same line;
    for example, `a,b,c = 1,5,0` sets `a`, `b`, and `c` to 1, 5, and 0, respectively.)
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: You can pass data to a function via parameters and receive a result via `return()`.
    However, you can declare variables in a function as `global`, which means they
    can be accessed and modified as if they were part of the calling program.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '`return()` is not mandatory because some functions don’t return a value. You
    can have multiple `return()` statements in a function because you can return from
    more than one point in a function. A return can pass multiple values because Python
    permits multiple assignments on a line; for example, see the following:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Testing for a zero result can easily be done by comparing the result, `r`, with
    0\. Testing for a negative result is harder. In two’s complement arithmetic, a
    signed value is negative if the most significant bit is 1\. We are using 16-bit
    arithmetic, so that corresponds to bit 15\. We can extract bit 15 by ANDing the
    result, `r`, with the binary value of 1000000000000000 by writing `r&0x8000` (the
    literal is expressed in hex form as 0x8000, which is mercifully shorter than the
    binary version).
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: 'To call the function, we can write the following:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We test for opcode 1000000 and call the `alu` function if it corresponds to
    `ADD`. The function is called with the `f = 1` parameter for addition; the numbers
    to be added are the contents of the two source registers. The result is loaded
    into the `r[rD]` register. In the current version of TC1, we use the opcode to
    look up the mnemonic and then apply the test if `mnemonic == 'ADD':`. This approach
    is easier to read and can use the mnemonic when displaying the output during tracing.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: We have made the `z` and `n` variables global (that is, they can be changed
    by the function and accessed externally). If we didn’t make them global, we would
    have to have made them return parameters. In general, it is regarded as a better
    practice to pass variables as parameters rather than making them global.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: Functions and scope
  id: totrans-288
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Variables are associated with *scope* or *visibility*. If you write a program
    without functions, variables can be accessed everywhere in the program. If you
    use functions, life becomes rather more complex.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: If you declare a variable in the main body, that variable will be visible in
    functions (that is, you can use it). However, you cannot change it in the function
    and then access the new value outside the function. What goes on in the function
    stays in the function. If you wish to access it from outside the function, you
    must declare it as *global*. If you write `global temp3`, then the `temp3` variable
    is the same variable both in and outside the function.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: If you create a variable in a function, that variable cannot be accessed outside
    the function because it’s private to the function (a local variable). You can
    create a variable with the same name in another function or the body of the program,
    but the variable in this function has no effect on variables with the same name
    outside the function.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: 'If you create a variable in a function that you want to be visible outside
    the function, you have to declare it as global in the function. Consider the following
    code:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'After running this code, we get the following. As you can see, the function
    changes `q` because it is global, whereas `p` does not change since it is a local
    variable in the function:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Here is a summary of the rules:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t change it in a function, you can use it anywhere
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you declare it in a function, it’s all yours and private to the function
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you want to change it in the function and use it outside the function, then
    declare it as global in the function
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This means that variables such as the `z` and `n` condition code flags can
    be accessed in a function. If you wish to change them in a function, they must
    be declared as global by using the following command:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: If a function returns a value, it ends with `return(whatever)`. If you don’t
    return a value from a function, the `return` statement is not necessary. However,
    we usually include a `return()` that returns nothing, and then we explicitly mark
    the end of the function.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: Although the use of global variables is supported by Python, some programmers
    avoid them because global variables make it too easy to accidentally change a
    variable in a function and not notice it, leading to headaches when debugging
    a faulty program. They argue that all variables should be passed to a function
    as a parameter.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll describe the very thing that makes a computer a computer
    – its ability to take two different courses of action, depending on the outcome
    of an operation.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: Branches and flow control
  id: totrans-305
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'All microprocessors have flow control instructions; for example, the unconditional
    branch, `BRA XYZ`, means execute the next instruction at address `XYZ`. A typical
    conditional instruction is `BNE` `XYZ`, which implements taking the branch to
    the instruction at location `XYZ`, if and only if, the z flag is not set. The
    `BNE` mnemonic means “branch on not equal” because the z-bit is evaluated by comparing
    two values using subtraction. Consider the following example, which uses the TC1
    assembly language:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Load register with a literal (`LDRL`) is used three times to load `r2` with
    0, `r0` with 5, and `r1` with 1\. In the line labeled `Loop`, we add `r2` to `r1`
    and put the result in `r2`. On its first execution, `r2` becomes 0 + 1 = 1.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: The next two lines increment `r1` and decrement r0 so that `r1` becomes 2 and
    `r0` becomes 4\. When we decrement `r0`, the z-flag is set if the result is zero.
    Since r2 initially contains 5 and then 4 after decrementing, the result is not
    zero and the z-flag is not set.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: When `BNE` is executed, the z-flag is tested. If it is not zero, a branch is
    taken to the line labeled `Loop` and the same batch of four instructions are executed
    again. When the `BNE` is encountered a second time, the z-bit is still zero, because
    this time the decrement went from 4 to 3\. Eventually, `r0` contains 1 and is
    decremented to 0\. The z-bit is then set. When `BNE` is next executed, the branch
    to loop is not taken, and the next instruction in the sequence, `STOP`, is executed.
    The loop is repeated 5 times. This program evaluates 1 + 2 + 3 + 4 + 5 = 15, which
    is the result in `r2`.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: Branch addresses can be a little complicated. You can provide an absolute address;
    for example, `BRA 24` jumps to the instruction at memory location 24\. Most computers
    use a relative address, which is relative to the current instruction. For example,
    in this case, we would branch three instructions back from the current location
    (that is, the `BNE` instruction). So, you might think that the relative address
    is -3\. It is a negative address because it is backward from the current address.
    Since the program counter has already been incremented to point to the next instruction,
    the branch back is -4\. So, the literal field of the `BNE` loop would be -4.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: 'The following fragment of code demonstrates testing four branch instructions
    and their implementation. In this example, we are using relative addressing for
    the branch; that is, the target address is specified with respect to the program
    counter. The first branch, `BRA`, is an unconditional branch and the next value
    of `pc` is calculated. All the others are conditional branches, and `pc` is changed
    only if the required condition is met. Note that the last operation is `BMI`,
    which means branch on minus, although some call it branch on negative (which has
    the same meaning):'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '`The pc` is incremented by `pc + literal`. However, since backward branches
    are represented in two’s complement form, it is necessary to `AND` the result
    with 0xFFFF to force it to 16 bits to generate the correct value. This is because
    we are simulating 16-bit arithmetic using a computer language, Python, that represents
    numbers with more than 16 bits. This is just an unfortunate consequence of computer
    arithmetic that you have to be aware of when simulating binary arithmetic.'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will return to Python and extend our ability to handle
    data structures and use Python’s functions.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We started this chapter by designing a computer simulator. However, we haven’t
    created a final product yet. Instead, we looked at some of the issues involved,
    such as the nature of an instruction set and the structure of an opcode.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: We examined how an instruction can be decoded and how it can be executed. We
    also took the opportunity to broaden our knowledge of Python and introduced Python’s
    bit-manipulation facilities, which let us implement machine-level instructions
    that operate on bits.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: We also introduced an important component of Python, known as a function, which
    allows the programmer to create a self-contained unit of code that can be called
    to perform a specific job from many points in a program. Functions are vital to
    modern programming because they facilitate elegant design by bundling a complex
    sequence of operations into a unit, which you call to carry out a task.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 5*](B19624_05.xhtml#_idTextAnchor075), we’ll return to Python and
    look at some topics in a little more depth – in particular, lists. Lists are probably
    Python’s most interesting and important feature.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
