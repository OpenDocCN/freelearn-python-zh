<html><head></head><body>
		<div><div></div>
		</div>
		<div><h1 id="_idParaDest-169"><a id="_idTextAnchor172"/>5. Serving Static Files</h1>
		</div>
		<div><p class="callout-heading">Overview</p>
			<p class="callout">In this chapter, you will start by learning the difference between static and dynamic responses. You will then see how the Django <code>staticfiles</code> app helps manage static files. Continuing work on the Bookr app, you will enhance it with images and CSS. You'll learn the different ways you can lay out your static files for your project and examine how Django consolidates them for production deployment. Django includes tools to reference static files in templates and you'll see how these tools help reduce the amount of work needed when deploying an application to production. After this, you'll explore the <code>findstatic</code> command, which can be used to debug issues with your static files. Later, you'll get an overview of how to write code for storing static files on a remote service. Finally, you'll look at caching web assets and how Django can help with cache invalidation.</p>
			<h1 id="_idParaDest-170"><a id="_idTextAnchor173"/>Introduction</h1>
			<p>A web application with just plain <strong class="bold">Hypertext Markup Language</strong> (<strong class="bold">HTML</strong>) is quite limiting. We can enhance the look of web pages with <strong class="bold">Cascading Style Sheets</strong> (<strong class="bold">CSS</strong>) and images, and we can add interaction with JavaScript. We call all these kinds of files "static files." They are developed and then deployed as part of the application. We can compare these to dynamic responses, which are generated in real time when a request is made. All the views you have written generate a dynamic response by rendering a template. Note that we will not consider templates to be static files as they are not sent verbatim to a client; instead, they are rendered first and sent as part of a dynamic response. </p>
			<p>During development, the static files are created on the developer's machine, and they must then be moved to the production web server. If you have to move to production in a short timeframe (say, a few hours), then it can be time-consuming to collect all the static assets, move them to the correct directory, and upload them to the server. When developing web applications using other frameworks or languages, you might need to manually put all of your static files into a specific directory that your web server hosts. Making changes to the URL from which static files are served might mean updating values throughout your code.</p>
			<p>Django can manage static assets for us to make this process easier. It provides tools for serving them with its development server during development. When your application goes to production, it can also collect all your assets and copy them to a folder for a dedicated web server to host. This allows you to keep your static files segregated in a meaningful way during development and automatically bundle them for deployment.</p>
			<p>This functionality is provided by Django's built-in <code>staticfiles</code> app. It adds several useful features for working with and serving static files:</p>
			<ul>
				<li>The <code>static</code> template tag to automatically build the static URL for an asset and include it in your HTML.</li>
				<li>A view (called <code>static</code>) that serves static files in development.</li>
				<li>Static file finders to customize where assets are found on your filesystem.</li>
				<li><a id="_idTextAnchor174"/>The <code>collectstatic</code> management command, which finds all static files and moves them into a single directory for deployment.</li>
				<li>The <code>findstatic</code> management command, which shows which static file on disk is loaded for a particular request. This also helps to debug if a particular file is not being loaded.</li>
			</ul>
			<p>In the exercises and activities in this chapter, we will be adding static files (images and CSS) to the Bookr application. Each file will be stored inside the Bookr project directory during development. We need to generate a URL for each so that the templates can reference them, and the browser can download them. Once the URL is generated, Django needs to serve these files. When we deploy the Bookr application to production, all the static files need to be found and moved to a directory where they can be served by the production web server. If there are static files that are not loading as expected, we need some method of determining what the cause is.</p>
			<p>For the sake of simplicity, let's take a single static file as an example: <code>logo.png</code>. We will briefly introduce the role of each feature we mentioned in the previous paragraph and explain them in depth throughout the chapter:</p>
			<ul>
				<li>The <code>static</code> template tag is used to convert a filename to a URL or path that can be used in a template, for example, from <code>logo.png</code> to <code>/static/logo.png</code>.</li>
				<li>The <code>static</code> view receives a request to load the static file at the path <code>/static/logo.png</code>. It reads the file and sends it to the browser.</li>
				<li>A static file finder (or just <code>finder</code>) is used by the <code>static</code> view to locate the static file on the disk. There are different finders, but in this example, a finder is just converting from the URL path <code>/static/logo.png</code> to the path on disk <code>bookr/static/logo.png</code>.</li>
				<li>When deploying to production, the <code>collectstatic</code> management command is used. This will copy the <code>logo.png</code> file from the <code>bookr</code> project directory to a web server directory, such as <code>/var/www/bookr/static/logo.png</code>.</li>
				<li>If a static file is not working (for example, a request for it returns a <code>404 Not Found</code> response, or the wrong file is being served), then we can use the <code>findstatic</code> management command to try to determine the reason. This command takes the filename as a parameter and will output which directories were looked through and where it was able to locate that requested file.</li>
			</ul>
			<p>These are the most common features that are used day to day, but there are others that we will also discuss.</p>
			<h1 id="_idParaDest-171"><a id="_idTextAnchor175"/>Static File Serving</h1>
			<p>In the introduction, we mentioned that Django includes a view function called <code>static</code> that serves static files. The first important point to make regarding the serving of static files is that Django is not intended to serve them in production. It is not Django's role, and in production, Django will refuse to serve static files. This is normal and intended behavior. If Django is just reading from the filesystem and sending out a file, then it has no advantage over a normal web server, which would probably be more performant at this task. Furthermore, if you serve static files with Django, you will keep the Python process busy for the duration of the request and it will be unable to serve the dynamic requests to which it is more suited.</p>
			<p>For these reasons, the Django <code>static</code> view is designed only for use during development and will not work if your <code>DEBUG</code> setting is <code>False</code>. Since during development we only usually have one person accessing the site at a time (the developer), Django is fine to serve static files. Soon, we will discuss more how the <code>staticfiles</code> app supports production deployment. The entire production deployment process will be covered in <em class="italic">Chapter 17</em>, <em class="italic">Deployment of a Django Application (Part 1 – Server Setup)</em>. This chapter can be downloaded from the GitHub repository of this book, at <a href="http://packt.live/2Kx6FmR">http://packt.live/2Kx6FmR</a>.</p>
			<p>A URL mapping to the <code>static</code> view is automatically set up when running the Django development server, provided that your <code>settings.py</code> file meets the following conditions: </p>
			<ul>
				<li>Has <code>DEBUG</code> set to <code>True</code></li>
				<li>Contains <code>'django.contrib.staticfiles'</code> in its <code>INSTALLED_APPS</code></li>
			</ul>
			<p>Both settings exist by default.</p>
			<p>The URL mapping that is created is roughly equivalent to having the following map in your <code>urlpatterns</code>:</p>
			<pre>path(settings.STATIC_URL, django.conf.urls.static)</pre>
			<p>Any URL starting with <code>settings.STATIC_URL</code> (which is <code>/static/</code> by default) gets mapped to the <code>static</code> view.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">You can still use the <code>static</code> view without having <code>staticfiles</code> in <code>INSTALLED_APPS</code>, but you must set up an equivalent URL mapping manually.</p>
			<h2 id="_idParaDest-172"><a id="_idTextAnchor176"/>Introduction to Static File Finders</h2>
			<p>There are three times when Django needs to locate static files on disk, and for this, it uses a <strong class="bold">static file finder</strong>. A static file finder could be thought of like a plugin. It is a class that implements methods for converting URL paths to disks and iterates through the project directory to find static files.</p>
			<p>The first time Django needs to locate static files on disk is when the Django <code>static</code> view receives a request to load a particular static file; it then needs to convert the path in the URL to a location on disk. For example, the URL's path is <code>/static/logo.png</code>, and it is converted to the path <code>bookr/static/logo.png</code> on the disk. As we noted in the previous section, this is only during development. On a production server, Django should not receive this request as it will be handled directly by the web server.</p>
			<p>The second time is when using the <code>collectstatic</code> management command. This gathers up all the static files in the project directory and copies them to a single directory to be served by the production web server. <code>bookr/static/logo.png</code> will get copied to the web server root, for example, <code>/var/www/bookr/static/logo.png</code>. The static file finder contains code to locate all the static files inside your project directory.</p>
			<p>The last time a static file finder is used is during the execution of the <code>findstatic</code> management command. This is similar to the first usage in that it accepts a static file's name (such as <code>logo.png</code>), but it outputs the full path (<code>bookr/static/logo.png</code>) to the terminal instead of loading the file content.</p>
			<p>Django comes with some built-in finders, but you can also write your own if you want to store static files in a custom directory layout. The list of finders Django uses is defined by the <code>STATICFILES_FINDERS</code> setting in <code>settings.py</code>. In this chapter, we will cover the behavior of the default static file finders, <code>AppDirectoriesFinder</code> and <code>FileSystemFinder</code>, in the <em class="italic">AppDirectoriesFinder</em> and <em class="italic">FileSystemFinder</em> sections, respectively.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">If you look in <code>settings.py</code>, you won't see that <code>STATICFILES_FINDERS</code> setting defined by default. This is because Django will use its built-in default for the setting, which is defined as the list <code>['django.contrib.staticfiles.finders.FileSystemFinder', ' django.contrib.staticfiles.finders.AppDirectoriesFinder']</code>. If you add the <code>STATICFILES_FINDERS</code> setting to your <code>settings.py</code> file to include a custom finder, be sure to include these defaults if you're using them.</p>
			<p>First, we will discuss static file finders and their use in the first case – responding to a request. Then we will introduce some more concepts and return to the behavior of <code>collectstatic</code> and how it uses static file finders. Later in the chapter, we will work with the <code>findstatic</code> command to see how to use it.</p>
			<h2 id="_idParaDest-173"><a id="_idTextAnchor177"/>Static File Finders: Use During a Request</h2>
			<p>When Django receives a request for a static file (remember, Django will only serve static files during development), each static file finder that has been defined will be queried until a file on disk has been found. If none of the finders can locate a file, the <code>static</code> view will return an <code>HTTP 404 Not Found</code> response.</p>
			<p>For example, the URL of the request will be something like <code>/static/main.css</code> or <code>/static/reviews/ logo.png</code>. Each finder will be queried in turn with the path from the URL and will return a path such as <code>bookr/static/main.css</code> for the first file and <code>bookr/reviews/static/reviews/logo.png</code> for the second. Each finder will use its own logic to convert from a URL path to a filesystem path – we will discuss this logic in the upcoming <em class="italic">AppDirectoriesFinder</em> and <em class="italic">FileSystemFinder</em> sections.</p>
			<h2 id="_idParaDest-174"><a id="_idTextAnchor178"/>AppDirectoriesFinder</h2>
			<p>The <code>AppDirectoriesFinder</code> class is used to find static files inside each app directory, in a directory called <code>static</code>. The application must be listed in the <code>INSTALLED_APPS</code> setting in your <code>settings.py</code> file (we did this in <em class="italic">Chapter 1</em>, <em class="italic">Introduction to Django</em>). As we also mentioned in <em class="italic">Chapter 1</em>, <em class="italic">Introduction to Django</em>, it is good for apps to be self-contained. By letting each application have its own <code>static</code> directory, we can continue the self-contained design by also storing app-specific static files inside the app directory too.</p>
			<p>Before we use <code>AppDirectoriesFinder</code>, we will explain a problem that can occur if multiple static files have the same name, and also how to solve this problem.</p>
			<h2 id="_idParaDest-175"><a id="_idTextAnchor179"/>Static File Namespacing</h2>
			<p>In the <em class="italic">Static File Finders: Use during a Request</em> section, we discussed serving a file named <code>logo.png</code>. This would provide a logo for the <code>reviews</code> application. The filename (<code>logo.png</code>) could be quite common – you could imagine that if we added a <code>store</code> app (for purchasing books), it would also have a logo. Not to mention that third-party Django apps might also want to use a common name like <code>logo.png</code>. The problem we are about to describe could apply to any static file that has a common name, such as <code>styles.css</code> or <code>main.js</code>.</p>
			<p>Let's consider the <code>reviews</code> and <code>store</code> examples. We can add a <code>static</code> directory in each of these apps. Then, each <code>static</code> directory would have a <code>logo.png</code> file (although it would be a different logo). The directory structure is as shown in <em class="italic">Figure 5.1</em>:</p>
			<div><div><img src="img/B15509_05_01.jpg" alt="Figure 5.1: Directory layout with static directories inside app directories&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.1: Directory layout with static directories inside app directories</p>
			<p>The URL path that we use to download a static file is relative to the static directory. Therefore, it is unclear which <code>logo.png</code> is being referenced if we make an HTTP request for <code>/static/logo.png</code>. Django will check the <code>static</code> directory for each application in turn (in the order they are specified in the <code>INSTALLED_APPS</code> setting). The first <code>logo.png</code> it locates, it will serve. There is no way, in this directory layout, to specify which <code>logo.png</code> you want to load.</p>
			<p>We can solve this problem by <code>static</code> directory, named the same as the app. The <code>reviews</code> app has a <code>reviews</code> directory inside its <code>static</code> directory, and the <code>store</code> app has a <code>store</code> directory inside its <code>static</code> directory. The respective <code>logo.png</code> files are then moved inside these subdirectories. The new directory layout is as shown in <em class="italic">Figure 5.2</em>:</p>
			<div><div><img src="img/B15509_05_02.jpg" alt="Figure 5.2: Directory layout with namespaced directories&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.2: Directory layout with namespaced directories</p>
			<p>To load a specific file, we include the namespaced directory too. For the <code>reviews</code> logo, the URL path is <code>/static/reviews/logo.png</code>, which maps to <code>bookr/reviews/static/review/logo.png</code> on disk. Similarly, for the store logo, its path is <code>/static/store/logo.png</code>, which maps to <code>bookr/store/static/store/logo.png</code>. You might have noticed that the examples path for the <code>logo.png</code> file is already namespaced in the <em class="italic">Static File Finders: Use during a Request</em> section.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">If you are considering writing a Django app that might be released as its own standalone plugin, you could use an even more explicit sub-directory name. For example, choose one that contains the entire dotted project path: <em class="italic">bookr/reviews/static/bookr.reviews</em>. In most cases, though, it is fine for the sub-directory name to be unique to just your project.</p>
			<p>Now that we have introduced <code>AppDirectoriesFinder</code> and static file namespacing, we can use them to serve our first static file. In the first exercise of the chapter, we will create a new Django project for a basic business site. We will then serve a logo file from an app called <code>landing</code> that we will create in this project. The <code>AppDirectoriesFinder</code> class is used to find static files inside each app directory, in a directory called <code>static</code>. The application must be listed in the <code>INSTALLED_APPS</code> setting in your <code>settings.py</code> file. As we have mentioned in <em class="italic">Chapter 1</em>, <em class="italic">Introduction to Django</em>, it is good for apps to be self-contained. By letting each application have its own <code>static</code> directory, we can continue the self-contained design by also storing app-specific static files inside the app directory too.</p>
			<p>The easiest way to serve a static file is from an app directory. This is because we do not need to make any settings changes. Instead, we just need to create the files in the correct directory, and they will be served using the default Django configuration.</p>
			<p class="callout-heading">The Business Site Project</p>
			<p class="callout">For the exercises in this chapter, we'll create a new Django project and use it to demonstrate the static file concepts. The project will be a basic business site with a simple landing page that has a logo. The project will have one app, calling <code>landing</code>.</p>
			<p class="callout">You can refer to <em class="italic">Exercise 1.01</em>, <em class="italic">Creating a Project and App, and Starting the dev server </em>from <em class="italic">Chapter 1</em>, <em class="italic">Introduction to Django</em>, to refresh your memory on creating a Django project.</p>
			<h2 id="_idParaDest-176"><a id="_idTextAnchor180"/>Exercise 5.01: Serving a File from an App Directory</h2>
			<p>In this exercise, you will add a logo file for the <code>landing</code> app. This will be done by putting a <code>logo.png</code> file in a <code>static</code> directory inside the <code>landing</code> app directory. After this is done, you can test that the static file is being served correctly and confirm the URL that will serve it:</p>
			<ol>
				<li>Start by creating the new Django project. You can reuse the <code>bookr</code> virtual environment that already has Django installed. Open a new terminal and activate the virtual environment (refer to the <em class="italic">Preface</em> for instructions on how to create and activate a virtual environment). Then, run the <code>django-admin</code> command in the terminal (or command shell) to start a Django project named <code>business_site</code>. To do this, run this command:<pre>django-admin startproject business_site</pre><p>There will not be any output. This command will scaffold the Django project in a new directory named <code>business_site</code>.</p></li>
				<li>Create a new Django app in this project by using the <code>startapp</code> management command. The app should be called <em class="italic">landing</em>. To do this, <code>cd</code> into the <code>business_site</code> directory, then run this:<pre>python3 manage.py startapp landing</pre><p>Note that there will not be any output again. The command will create the <code>landing</code> app directory inside the <code>business_site</code> directory. </p><p class="callout-heading">Note</p><p class="callout">Remember that on Windows the command is <code>python manage.py startapp landing</code>.</p></li>
				<li>Launch PyCharm, then open the <code>business_site</code> directory. If you already have a project open, you can do this by choosing <code>File</code> -&gt; <code>Open</code>; otherwise, just click <code>Open</code> in the <code>Welcome to PyCharm</code> window. Navigate to the <code>business_site</code> directory, select it, then click <code>Open</code>. The <code>business_site</code> project window should be shown like <em class="italic">Figure 5.3</em>:<p class="callout-heading">Note</p><p class="callout">For detailed instructions on how to set up and configure PyCharm to work with your Django project, refer to <em class="italic">Exercise 1.02</em>, <em class="italic">Project Setup in PyCharm</em>, in <em class="italic">Chapter 1</em>, <em class="italic">Introduction to Django</em>.</p><div><img src="img/B15509_05_03.jpg" alt="Figure 5.3: The business_site project&#13;&#10;"/></div><p class="figure-caption">Figure 5.3: The business_site project</p></li>
				<li>Create a new run configuration to execute <code>manage.py runserver</code> for the project. You can reuse the <code>bookr</code> virtual environment again. The <code>Run/Debug Configurations</code> window should look like <em class="italic">Figure 5.4</em>. when you are done:<p class="callout-heading">Note</p><p class="callout">Note that if you are not sure how to configure these settings in PyCharm, refer to <em class="italic">Exercise 1.02</em>, <em class="italic">Project Setup in PyCharm</em>, from <em class="italic">Chapter 1</em>, <em class="italic">Introduction to Django</em>.</p><div><img src="img/B15509_05_04.jpg" alt="Figure 5.4: Run/Debug Configurations for Runserver&#13;&#10;"/></div><p class="figure-caption">Figure 5.4: Run/Debug Configurations for Runserver</p><p>You can test that the configuration is set up correctly by clicking the <code>Run</code> button, then visiting <code>http://127.0.0.1:8000/</code> in your browser. You should see the Django welcome screen. If the debug server fails to start or you see the Bookr main page, then you probably still have the Bookr project running. Try stopping the Bookr <code>runserver</code> process (press <em class="italic">Ctrl</em> + <em class="italic">C</em> in the terminal that is running it) and then starting the new one you just set up.</p></li>
				<li>Open <code>settings.py</code> in the <code>business_site</code> directory and add <code>'landing'</code> to the <code>INSTALLED_APPS</code> setting. Remember we learned how to do this in <em class="italic">step 1</em> of <em class="italic">Exercise 1.05</em>, <em class="italic">Creating a Templates Directory and Base Template</em>, in <em class="italic">Chapter 1</em>, <em class="italic">Introduction to Django</em>.</li>
				<li>In PyCharm, right-click the <code>landing</code> directory in the <code>Project</code> pane and select <code>New</code> -&gt; <code>Directory</code>. </li>
				<li>Enter the name <code>static</code> and click <code>OK</code>:<div><img src="img/B15509_05_05.jpg" alt="Figure 5.5: Naming the directory static&#13;&#10;"/></div><p class="figure-caption">Figure 5.5: Naming the directory static</p></li>
				<li>Right-click the <code>static</code> directory you just created and select <code>New</code> -&gt; <code>Directory</code> again. </li>
				<li>Enter the name <code>landing</code> and click <code>OK</code>. This is to implement namespacing of the static files directory as we discussed earlier:<div><img src="img/B15509_05_06.jpg" alt="Figure 5.6: Naming the new directory landing, to implement namespacing&#13;&#10;"/></div><p class="figure-caption">Figure 5.6: Naming the new directory landing, to implement namespacing</p></li>
				<li>Download <code>logo.png</code> from <a href="https://packt.live/2KM6kfT">https://packt.live/2KM6kfT</a> and move it into the <code>landing/static/landing</code> directory.</li>
				<li>Start the Django dev server, if it is not already running, then navigate to <code>http://127.0.0.1:8000/static/landing/logo.png</code>. You should see the image being served in your browser:<div><img src="img/B15509_05_07.jpg" alt="Figure 5.7: Image served by Django&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 5.7: Image served by Django</p>
			<p>If you see the image as in <em class="italic">Figure 5.7</em>, you have set up static file serving correctly. Now let us look at how to automatically insert this URL into your HTML code.</p>
			<h2 id="_idParaDest-177"><a id="_idTextAnchor181"/>Generating Static URLs with the static Template Tag</h2>
			<p>In <em class="italic">Exercise 5.01</em>, <em class="italic">Serving a File from an App Directory</em>, you set up an image file to be served by Django. You saw that the URL of the image was <code>http://127.0.0.1:8000/static/landing/logo.png</code>, which you could use inside an HTML template. For example, to display the image with an <code>img</code> tag, you could use this code in your template:</p>
			<pre>&lt;img src="img/logo.png"&gt;</pre>
			<p>Or, since Django is also serving the media and has the same host as the dynamic template response, you can simplify this by just including the path, as follows:</p>
			<pre>&lt;img src="img/logo.png"&gt;</pre>
			<p>Both addresses (URLs and paths) have been hardcoded into the template; that is, we include the full path to the static file and make assumptions about where the file is being hosted. This works fine with the Django dev server or if you host your static files and Django website on the same domain. For more performance as your site becomes more popular, you might consider serving static files from their own domain or <strong class="bold">Content Delivery Network</strong> (<strong class="bold">CDN</strong>).</p>
			<p class="callout-heading">Note</p>
			<p class="callout">A <strong class="bold">CDN</strong> is a service that can host parts or all of your website for you. They provide several web servers and can seamlessly speed up the loading of your website. For example, they might serve files to a user from the server that is geographically closest to them. There are several CDN providers, and depending on how they are set up, they might require you to specify a certain domain from which to serve your static files.</p>
			<p>Take, for instance, a common separation approach: using a different domain for static file serving. You host your main website at <code>https://www.example.com</code> but want to serve static files from <code>https://static.example.com</code>. During development, we could use just the path to the logo file as in the example we just saw. But when we deploy to the production server, our URLs would need to change to include the domain, like so:</p>
			<pre>&lt;img src="img/logo.png"&gt;</pre>
			<p>Since all the links are hardcoded, this would need to be done for every URL throughout our templates, every time we deploy to production. Once they were changed, though, the URL would no longer work in the Django dev server. Luckily, Django provides a solution to this problem.</p>
			<p>The <code>staticfiles</code> app provides a template tag, <code>static</code>, to dynamically generate the URL to a static file inside a template. Since the URLs are all being dynamically generated, we can change the URL for all of them by changing just one setting (<code>STATIC_URL</code> in <code>settings.py</code> – more on this soon). Furthermore, later we will introduce a method of invalidating browser caches for static files that relies on the use of the <code>static</code> template tag.</p>
			<p>The <code>static</code> tag is very simple: it takes a single argument, which is the project-relative path to a static asset. It will then output this path prepended with the <code>STATIC_URL</code> setting. It must<a id="_idTextAnchor182"/> first be loaded into the template with the <code>{% load static %}</code> template tag. </p>
			<p>Django has a set of default template tags and filters (or tag sets) that it automatically makes available to every template. Django (and third-party libraries) also provides tag sets that are not automatically loaded. In these cases, we need to load these extra template tags and filters into a template before we can use them. This is done with the use of the <code>load</code> template tag, which should come near the start of a template (although it must be after the <code>extends</code> template tag, if one is used). The <code>load</code> template tag takes one or more packages/libraries to load, for example:</p>
			<pre>{% load package_one package_two package_three %}</pre>
			<p>This would load the template tag and filters set provided by the (made-up) <code>package_one</code>, <code>package_two</code>, and <code>package_three</code> packages.</p>
			<p>The <code>load</code> template tag must be used in the actual template that requires the loaded package. In other words, if your template extends another template and that base template has loaded a certain package, your dependent template does not automatically have access to that package. Your template must still <code>load</code> the package to access the new tag set. The <code>static</code> template tag is not part of the default set, which is why we need to load it.</p>
			<p>Then, it can be used to interpolate anywhere inside the template file. For example, by default, Django uses <code>/static/</code> as <code>STATIC_URL</code>. If we wanted to generate the static URL for our <code>logo.png</code> file, we would use the tag in a template like this:</p>
			<pre>{% stat<a id="_idTextAnchor183"/>ic landing/logo.png' %}</pre>
			<p>The output inside the template would be this:</p>
			<pre>/static/landing/logo.png</pre>
			<p>This would be made clearer with an example, so let's look at how the <code>static</code> tag could be used to generate a URL for a number of different assets. </p>
			<p>We can include the logo as an image on the page with an <code>img</code> tag, as follows:</p>
			<pre>&lt;img src="img/logo.png' %}"&gt;</pre>
			<p>This is rendered in the template as follows:</p>
			<pre>&lt;img src="img/logo.png"&gt;</pre>
			<p>Or we could use the <code>static</code> tag to generate the URL for a linked CSS file, as follows:</p>
			<pre>&lt;link href="{% static 'path/to/file.css' %}" 
            rel="stylesheet"&gt;</pre>
			<p>This will be rendered as this:</p>
			<pre>&lt;link href="/static/path/to/file.css" 
            rel="stylesheet"&gt;</pre>
			<p>It can be used in a <code>script</code> tag to include a JavaScript file, using the following line of code:</p>
			<pre>&lt;script src="img/file.js' %}"&gt;
    &lt;/script&gt;</pre>
			<p>This is rendered as this:</p>
			<pre>&lt;script src="img/file.js"&gt;&lt;/script&gt;</pre>
			<p>We can even use it to generate a link to a static file for download:</p>
			<pre>&lt;a href="{% static 'path/to/document.pdf' %}"&gt;
    Download PDF&lt;/a&gt;</pre>
			<p class="callout-heading">Note</p>
			<p class="callout">Note that this won't generate the actual PDF content; it will just create a link to an already-existing file.</p>
			<p>This is rendered as follows:</p>
			<pre>&lt;a href="/static/path/to/document.pdf"&gt;
    Download PDF&lt;/a&gt;</pre>
			<p>Referring to these examples, we can now demonstrate the advantage of using the <code>static</code> tag instead of hardcoding. When we are ready to deploy to production, we can just change the <code>STATIC_URL</code> value in <code>settings.py</code>. None of the values in the templates need to be changed.</p>
			<p>For example, we can change <code>STATIC_URL</code> to <code>https://static.example.com/</code>, and then when the page next gets rendered, the examples we've seen will automatically update as follows.</p>
			<p>The following line shows this for the image:</p>
			<pre>&lt;img src="img/logo.png"&gt;</pre>
			<p>The following is for the CSS link:</p>
			<pre>&lt;link href=
    "https://static.example.com/path/to/files.css" 
    rel="stylesheet"&gt;</pre>
			<p>For the script, it's as follows:</p>
			<pre>&lt;script src="
    https://static.example.com/path/to/file.js"&gt;
    &lt;/script&gt;</pre>
			<p>And finally, the following is for the link:</p>
			<pre>&lt;a href="
    https://static.example.com/path/to/document.pdf"&gt;
    Download PDF&lt;/a&gt;</pre>
			<p>Note that in all these examples, a literal string is being passed as an argument (it is quoted). You can also use a variable as an argument. For example, say you were rendering a template with a context such as in this example code:</p>
			<pre>def view_function(request):
    context = {"image_file": "logofile.png"}
    return render(request, "example.html", context)</pre>
			<p>We are rendering the <code>example.html</code> template with an <code>image_file</code> variable. This variable has the value <code>logo.png</code>.</p>
			<p>You would pass this variable to the <code>static</code> tag without quotes:</p>
			<pre>&lt;img src="img/{% static image_file %}"&gt;</pre>
			<p>It would render like this (assuming we changed <code>STATIC_URL</code> back to <code>/static/</code>):</p>
			<pre>&lt;img src="img/logo.png"&gt;</pre>
			<p>The template tag can also be used with the <code>as [variable]</code> suffix to assign the result to a variable for use later in the template. This can be useful if the static file lookup takes a long time and you want to refer to the same static file multiple times (like when including an image in multiple places).</p>
			<p>The first time you refer to the static URL, give it a variable name to assign to. In this case, we are creating the <code>logo_path</code> variable:</p>
			<pre>&lt;img src="img/{% static 'logo.png' as logo_path %}"&gt;</pre>
			<p>This renders the same as the examples we've seen before:</p>
			<pre>&lt;img src="img/logo.png"&gt;</pre>
			<p>However, we can then use the assigned variable (<code>logo_path</code>) again later in the template:</p>
			<pre>&lt;img src="img/{{ logo_path }}"&gt;</pre>
			<p>That renders the same again:</p>
			<pre>&lt;img src="img/logo.png"&gt;</pre>
			<p>This variable is now just a normal context variable in the template scope and can be used anywhere in the template. Be careful, though, as you might override a variable that has already been defined – although this a general warning when using any of the template tags that assign variables (for example, <code>{% with %}</code>).</p>
			<p>In the next exercise, we will put the <code>static</code> template into practice to add the Bookr reviews logo to the Bookr site.</p>
			<h2 id="_idParaDest-178"><a id="_idTextAnchor184"/>Exercise 5.02: Using the static Template Tag</h2>
			<p>In <em class="italic">Exercise 5.01</em>, <em class="italic">Serving a File from an App Directory</em>, you tested serving the <code>logo.png</code> file from the static directory. In this exercise, you will continue with the business site project and create an <code>index.html</code> file as the template for our landing page. Then you'll include the logo inside this page, using the {<code>% static %</code>} template tag:</p>
			<ol>
				<li value="1">In PyCharm (make sure you're in the <code>business_site</code> project), right-click the <code>business_site</code> project directory and create a new folder called <code>templates</code>. Right-click this directory and select <code>New</code> -&gt; <code>HTML File</code>. Select <code>HTML 5 file</code> and name it <code>index.html</code>:<div><img src="img/B15509_05_08.jpg" alt="Figure 5.8: new index.html&#13;&#10;"/></div><p class="figure-caption">Figure 5.8: new index.html</p></li>
				<li><code>index.html</code> will open. First, load the <code>static</code> tag library to make the <code>static</code> tag available in the template. Do this with the <code>load</code> template tag. On the second line of the file (just after the <code>&lt;!DOCTYPE html&gt;</code>), add this line to load the static library:<pre>{% load static %}</pre></li>
				<li>You can also make the template a bit nicer with some extra content. Enter the text <code>Business Site</code> inside the <code>&lt;title&gt;</code> tags: <pre>&lt;title&gt;Business Site&lt;/title&gt;</pre><p>Then, inside the body, add an <code>&lt;h1&gt;</code> element with the text <code>Welcome to my Business Site</code>:</p><pre>&lt;h1&gt;Welcome to my Business Site&lt;/h1&gt;</pre></li>
				<li>Underneath the heading text, use the <code>{% static %}</code> template tag to set the source of <code>&lt;img&gt;</code>. You will use it to refer to the logo from <em class="italic">Exercise 5.01</em>, <em class="italic">Serving a File from an App Directory</em>:<pre>&lt;img src="img/logo.png' %}"&gt;</pre></li>
				<li>Finally, to flesh out the site a bit, add a <code>&lt;p&gt;</code> element under <code>&lt;img&gt;</code>. Give it some text about the business:<pre>&lt;p&gt;Welcome to the site for my Business. 
    For all your Business needs!&lt;/p&gt;</pre><p>Although the extra text and title are not too important, they give an idea of how to use the <code>{% static %</code>} template tag around the rest of the content. Save the file. It should look like this once complete: <a href="http://packt.live/37RUVnE">http://packt.live/37RUVnE</a>. </p></li>
				<li>Next, set up a URL to use to render the template. You will also use the built-in <code>TemplateView</code> to render the template without having to create a view. Open <code>urls.py</code> in the <code>business_site</code> package directory. At the start of the file, import <code>TemplateView</code> as follows:<pre>from django.views.generic import TemplateView</pre><p>You can also remove this Django admin import line since we're not using it in this project:</p><pre>from django.contrib import admin</pre></li>
				<li>Add a URL map from <code>/</code> to a <code>TemplateView</code>. The <code>as_view</code> method of <code>TemplateView</code> takes <code>template_name</code> as an argument, which is used in the same way as a path that you might pass to the <code>render</code> function. Your <code>urlpatterns</code> should look like this:<pre>urlpatterns = [path('', TemplateView.as_view\
                        (template_name='index.html')),]</pre><p>Save the <code>urls.py</code> file. Once complete, it should look like this: <a href="http://packt.live/2KLTrlY">http://packt.live/2KLTrlY</a>. </p></li>
				<li>Since we're not using the <code>landing</code> app template directory to store this template, you need to tell Django to use the <code>templates</code> directory you created in <em class="italic">step 1</em>. Do this by adding the directory to the <code>TEMPLATES['DIRS']</code> list in <code>settings.py</code>.<p>Open <code>settings.py</code> in the <code>business_site</code> directory. Scroll down until you find the <code>TEMPLATES</code> setting. It will look like this:</p><pre>TEMPLATES = \
[{'BACKEND': 'django.template.backends.django.DjangoTemplates',\
  'DIRS': [],\
  'APP_DIRS': True,\
  'OPTIONS': {'context_processors': \
              ['django.template.context_processors.debug',\
               'django.template.context_processors.request',\
               'django.contrib.auth.context_processors.auth',\
               'django.contrib.messages.context_processors\
               .messages',\
     ],\
  },\
},]</pre><p>Add <code>os.path.join(BASE_DIR, 'templates')</code> into the <code>DIRS</code> setting, so the <code>TEMPLATES</code> setting looks like this:</p><pre>TEMPLATES = \
[{'BACKEND': 'django.template.backends.django.DjangoTemplates',\
  <code>os</code> module in <code>settings.py</code>. To fix this, at the top of the <code>settings.py</code> file, just add this line:</p><pre>import os</pre><p>Save and close <code>settings.py</code>. It should look like this: <a href="http://packt.live/3pz4rlo">http://packt.live/3pz4rlo</a>. </p></li>
				<li>Start the Django dev server, if it's not already running. Navigate to <code>http://127.0.0.1:8000/</code> in your browser. You should see your new landing page as in <em class="italic">Figure 5.9</em>:<div><img src="img/B15509_05_09.jpg" alt="Figure 5.9: The site with the logo&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 5.9: The site with the logo</p>
			<p>In this exercise, we added a base template for <code>landing</code> and loaded the static library into the template. Once the static library was loaded, we were able to use the <code>static</code> template tag to load an image. We then were able to see our business logo rendered in the browser.</p>
			<p>All of the static file loading has so far used <code>AppDirectoriesFinder</code>, because it required no extra configuration to use it. In the next section, we will look at <code>FileSystemFinder</code>, which is more flexible but requires a small amount of configuration to use it.</p>
			<h2 id="_idParaDest-179"><a id="_idTextAnchor185"/>FileSystemFinder </h2>
			<p>We've learned about <code>AppDirectoriesFinder</code>, which loads static files inside Django app directories. However, well-designed apps should be self-contained and therefore should only contain static files that they themselves rely on. If we have other static files that are used throughout the website or across different apps, we should store them outside the app directory.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">As a general rule, your CSS is probably consistent throughout your site and could be kept in a global directory. Some images and JavaScript code could be specific to apps, so these would be stored in the static directory for that application. This is just general advice, though: you can store static files anywhere that makes the most sense for your project.</p>
			<p>In our business site application, we will be storing a CSS file in a site static directory, as it will be used not only in the <code>landing</code> app but throughout the site as we add more apps.</p>
			<p>Django provides support for serving static files from arbitrary directories using its <code>FileSystemFinder</code> static file finder. The directories can be anywhere on the disk. Usually, you will have a <code>static</code> directory inside your project directory, but if your company has a global static directory that is used in many different projects (including non-Django web applications), then you could use this as well.</p>
			<p><code>FileSystemFinder</code> uses the <code>STATICFILES_DIRS</code> setting in the <code>settings.py</code> file to determine which directories to search for static files in. This is not present when the project is created and must be set by the developer. We will add it in the next exercise. There are two options for building this list:</p>
			<ul>
				<li>Setting a list of directories</li>
				<li>Setting a list of tuples in the form <code>(prefix, directory)</code></li>
			</ul>
			<p>The second use case will be easier to understand once we have covered some more of the fundamentals, so we will return to it after explaining and demonstrating the first case. It is covered after <em class="italic">Exercise 5.04</em>, <em class="italic">Collecting Static Files for Production</em>, in the <em class="italic">STATICFILES_DIRS Prefixed Mode</em> section. For now, we will just explain the first use case, which is just a list of one or more directories.</p>
			<p>In <code>business_site</code>, we will add a <code>static</code> directory inside the project directory (that is, in the same directory that contains the <code>landing</code> app and the <code>manage.py</code> file). We can use the <code>BASE_DIR</code> setting when building the list to assign to <code>STATICFILES_DIRS</code>:</p>
			<pre>STATICFILES_DIRS = [os.path.join(BASE_DIR, 'static')]</pre>
			<p>We also mentioned earlier in this section that you might want to set multiple directory paths in this list, for example, if you had some company-wide static data shared by multiple web projects. Simply add extra directories to the <code>STATICFILES_DIRS</code> list:</p>
			<pre>STATICFILE<a id="_idTextAnchor186"/>S_DIRS = [os.path.join(BASE_DIR, 'static'), \
                    '/Users/username/projects/company-static/']</pre>
			<p>Each of these directories would be checked in order to find a matching file. If a file existed in both directories, the first one found would be served. For example, if the <code>static/main.css</code> (inside the <code>business_site</code> project directory) and <code>/Users/username/projects/company-static/bar/main.css</code> files both existed, a request for <code>/static/main.css</code> would serve the <code>business_site</code> project's <code>main.css</code> as it is first in the list. Keep this in mind when deciding the order in which you add directories to <code>STATICFILES_DIRS</code>; you may choose to prioritize your project static files over the global ones or vice versa.</p>
			<p>In our business site (and later with Bookr), we will only use one <code>static</code> directory in this list, so we won't have to worry about this problem.</p>
			<p>In the next exercise, we will add a <code>static</code> directory with a CSS file inside. Then we will configure the <code>STATICFILES_DIRS</code> setting to serve from the <code>static</code> directory.</p>
			<h2 id="_idParaDest-180"><a id="_idTextAnchor187"/>Exercise 5.03: Serving from a Project static Directory</h2>
			<p>We have already shown an example of serving an application-specific image file in <em class="italic">Exercise 5.01</em>, <em class="italic">Serving a File from an App Directory</em>. Now we want to serve a CSS file that is to be used throughout our project to set styles, so we will serve this from a static directory right inside the project folder.</p>
			<p>In this exercise, you'll set up your project to serve static files from a specific directory, and then use the <code>{% static %}</code> template tag again to include it in the template. This will be done using the <code>business_site</code> example project:</p>
			<ol>
				<li value="1">Open the <code>business_site</code> project in In PyCharm, if it's not already open. Then, right-click the <code>business_site</code> project directory (the top-level <code>business_site</code> directory, not the <code>business_site</code> package directory) and select <code>New</code> -&gt; <code>Directory</code>.</li>
				<li>In the <code>New Directory</code> dialog, enter <code>static</code> and then click <code>OK</code>.</li>
				<li>Right-click the <code>static</code> directory you just created and select <code>New</code> -&gt; <code>File</code>. </li>
				<li>In the <code>Name New File</code> dialog, enter <code>main.css</code> and click <code>OK</code>. </li>
				<li>The blank <code>main.css</code> file should open automatically. Enter a couple of simple CSS rules, to center the text, and set a font and background color. Enter this text into the <code>main.css</code> file:<pre>body {
    font-family: Arial, sans-serif;
    text-align: center;
    background-color: #f0f0f0;
}</pre><p>You can now save and class <code>main.css</code>. You can take a look at the complete file for reference: <a href="http://packt.live/38H8a9N">http://packt.live/38H8a9N</a>. </p></li>
				<li>Open <code>business_site/settings.py</code>. Here, set a list of directories to the <code>STATICFILES_DIRS</code> settings. In this case, the list will have just one item. Define a new <code>STATICFILES_DIRS</code> variable at the bottom of <code>settings.py</code>, using this code:<pre>STATICFILES_DIRS = [os.path.join(BASE_DIR, 'static')]</pre><p>In the <code>settings.py</code> file, <code>BASE_DIR</code> is a variable that contains the path to the project directory. You can build the full path to the <code>static</code> directory you created in <em class="italic">step 2</em> by joining <code>static</code> to <code>BASE_DIR</code>. You then put this inside a list. The complete <code>settings.py</code> file should look like this: <a href="http://packt.live/3hnQQKW">http://packt.live/3hnQQKW</a>. </p></li>
				<li>Start the Django dev server if it is not running. You can verify that the settings are correct by checking whether you can load the <code>main.css</code> file. Note that this is not namespaced so the URL is  <code>http://127.0.0.1:8000/static/main.css</code>. Open this URL in your browser and check that the content matches what you just entered and saved:<div><img src="img/B15509_05_10.jpg" alt="Figure 5.10: CSS served by Django&#13;&#10;"/></div><p class="figure-caption">Figure 5.10: CSS served by Django</p><p>If the file does not load, check your <code>STATICFILES_DIRS</code> settings. You may need to restart the Django dev server if it was running while you made changes to <code>settings.py</code>.</p></li>
				<li>You now need to include <code>main.css</code> in your index template. Open <code>index.html</code> in the <code>templates</code> folder. Before the closing <code>&lt;/head&gt;</code> tag, add this <code>&lt;link&gt;</code> tag to load the CSS:<pre>&lt;link rel="stylesheet" href="{% static 'main.css' %}"&gt;</pre><p>This links in the <code>main.css</code> file, using the <code>{% static %}</code> template tag. As mentioned earlier, since <code>main.css</code> is not namespaced, you can just include its name. Save the file. It should look like this: <a href="http://packt.live/392aedP">http://packt.live/392aedP</a>. </p></li>
				<li>Load <code>http://127.0.0.1:8000/</code> in your browser and you should see the background color, fonts, and alignment all change:<div><img src="img/B15509_05_11.jpg" alt="Figure 5.11: CSS applied with custom fonts visible&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 5.11: CSS applied with custom fonts visible</p>
			<p>Your business landing page should look like <em class="italic">Figure 5.11</em>. Since you included the CSS in the <code>base.html</code><em class="italic"> </em>template, it will be available in all templates that extend this template (although none do at the moment, it's good planning for the future).</p>
			<p>In this exercise, we put some CSS rules into their own file and served them using Django's <code>FileSystemFinder</code>. This was accomplished by creating a <code>static</code> directory inside the <code>business_site</code> project directory and specifying it in the Django settings (the <code>settings.py</code> file) using the <code>STATICFILES_DIRS</code> setting. We linked in the <code>main.css</code> file using the <code>static</code> template tag into the <code>base.html</code> template. We loaded the main page in our browser and saw that the font and color changes applied.</p>
			<p>We've now covered how static file finders are used during a request (to load a specific static file when given a URL). We'll now look at their other use case: finding and copying static files for production deployment, when running the <code>collectstatic</code> management command.</p>
			<h2 id="_idParaDest-181"><a id="_idTextAnchor188"/>Static File Finders: Use During collectstatic</h2>
			<p>Once we have finished working on our static files, they need to be moved into a specific directory that can be served by our production web server. We can then deploy our website by copying our Django code and static files to our production web server. In the case of <code>business_site</code>, we will want to move <code>logo.png</code> and <code>main.css</code> (along with other static files that Django itself includes) into a single directory that can be copied to the production web server. This is the role of the <code>collectstatic</code> management command.</p>
			<p>We have already discussed how Django uses static file finders during request handling. Now, we will cover the other use case: collecting static files for deployment. Upon running the <code>collectstatic</code> management command, Django uses each finder to list static files on the disk. Every static file that is found is then copied into the <code>STATIC_ROOT</code> directory (also defined in <code>settings.py</code>). This is a little bit like the reverse of handling a request. Instead of getting a URL path and mapping to a filesystem path, the filesystem path is being copied to a location that is predictable by the frontend web server. This allows the frontend web server to handle a request for a static file independently of Django.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">A frontend web server is designed to route requests to applications (like Django) or read static files from disk. It can handle requests faster but is not able to generate dynamic content in the same way as something like Django. Frontend web servers include software such as Apache HTTPD, Nginx, and lighttpd.</p>
			<p>For some specific examples of how <code>collectstatic</code> works, we'll use the two files from <em class="italic">Exercise 5.01</em>,<em class="italic"> Serving a File from an App Directory</em>, and <em class="italic">Exercise 5.03</em>, <em class="italic">Serving from a Project Status Directory</em>, respectively: <code>landing/static/landing/logo.png</code> and <code>static/main.css</code>. </p>
			<p>Assume that <code>STATIC_ROOT</code> is set to a directory being served by a normal web server – this would be something like <code>/var/www/business_site/static</code>. The destination for these files would be <code>/var/www/business_site/static/reviews/logo.png</code> and <code>/var/www/business_site/static/main.css</code>, respectively.</p>
			<p>Now when a request for a static file comes in, the web server will easily be able to serve it because the paths are mapped consistently:</p>
			<ul>
				<li><code>/static/main.css</code> is served from the <code>/var/www/business_site/static/main.css</code> file.</li>
				<li><code>/static/reviews/logo.png</code> is served from the <code>/var/www/business_site/static/reviews/logo.png</code> file.</li>
			</ul>
			<p>This means the web server root is <code>/var/www/business_site/</code> and static paths are just loaded directory from disk in the usual manner that a web server would load files.</p>
			<p>We have demonstrated how Django locates static files during development and can serve them itself. In production, we need the frontend web server to be able to serve static files without involving Django, for both safety and speed.</p>
			<p>Without having run <code>collectstatic</code>, a web server would not be able to map a URL back to a path. For example, it would not know that <code>main.css</code> must be loaded from the project static directory while <code>logo.png</code> is to be loaded from the <code>landing</code> app directory – it has no concept of the Django directory layout.</p>
			<p>You might be tempted to serve files directly from the Django project directory by setting your web server root to this directory – do not do this. There is a security risk in sharing your entire Django project directory as it would make it possible to download our <code>settings.py</code> or other sensitive files. Running <code>collectstatic</code> will copy the files to a directory that can be moved outside the Django project directory to the web server root for security.</p>
			<p>So far, we have talked about using Django to copy static files directly to the web server root. You could also have Django copy them to an intermediary directory and have your deployment process move to a CDN or another server afterward. We will not go into detail on specific deployment processes; how you choose to copy static files to the web server will depend on yours or your company's existing setup (for example, a continuous delivery pipeline).</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The <code>collectstatic</code> command does not take into consideration the use of <code>static</code> template tags. It will collect all the static files inside <code>static</code> directories, even those that your project does not include inside a template.</p>
			<p>In the next exercise, we will see the <code>collectstatic</code> command in action. We will use it to copy all the <code>business_site</code> static files that we have so far into a temporary directory.</p>
			<h2 id="_idParaDest-182"><a id="_idTextAnchor189"/>Exercise 5.04: Collecting Static Files for Production</h2>
			<p>While we won't be covering deployment to a web server in this chapter, we can still use the <code>collectstatic</code> management command and see its result. In this exercise, we will create a temporary holding location for the static files to be copied into. This directory will be called <code>static_prod<a id="_idTextAnchor190"/>uction_test</code> and will be located inside the <code>business_site</code> project directory. As part of the deployment process, you could copy this directory to your production web server. However, since we won't be setting up a web server until <em class="italic">Chapter 17</em>, <em class="italic">Deployment of a Django Application (Part 1 – Server Setup)</em>, we will just examine its contents to understand how files are copied and organized:</p>
			<ol>
				<li value="1">In PyCharm, create a temporary directory to put the collected files in. Right-click the <code>business_site</code> project directory (this is the top-level folder, not the <code>business_site</code> module) and select <code>New</code> -&gt; <code>Directory</code>.</li>
				<li>In the <code>New Directory</code> dialog, enter the name <code>static_production_test</code> and click <code>OK</code>.</li>
				<li>Open <code>settings.py</code> and at the bottom of the file, define a new setting for <code>STATIC_ROOT</code>. Set it to the path of the directory you just created:<pre>STATIC_ROOT<a id="_idTextAnchor191"/> = os.path.join(BASE_DIR, 'static_production_test')</pre><p>This will join <code>static_dir</code> to <code>BASE_DIR</code> (the business site project path) to generate the full path. Save the <code>settings.py</code> file. It should look like this: <a href="http://packt.live/2Jq59Cc">http://packt.live/2Jq59Cc</a>. </p></li>
				<li>In a terminal, run the <code>collectstatic</code> <code>manage</code> command:<pre>python3 manage.py collectstat<a id="_idTextAnchor192"/>ic</pre><p>You should see output similar to the following:</p><pre>132 static files copied to \
  '/Users/ben/business_site/static_production_test'.</pre><p>This might seem like a lot if you were expecting it to copy just two files but remember that it will copy all the files for all installed apps. In this case, as you have the Django admin app installed, most of the 132 files are to support that.</p></li>
				<li>Let us look through the <code>static_production_test</code> directory to see what has been created. An expanded view of this directory (from the PyCharm project page) is shown in <em class="italic">Figure 5.12</em>, for reference. Yours should be similar.<div><img src="img/B15509_05_12.jpg" alt="Figure 5.12: Destination directory of the collectstatic command&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 5.12: Destination directory of the collectstatic command</p>
			<p>You should notice three items inside:</p>
			<p><code>css</code>, <code>fonts</code>, <code>img</code>, and <code>js</code>.</p>
			<p><code>static</code> directory from your landing app. Inside is the <code>logo.png</code> file. This directory has been created to match the namespacing of the directory that we created.</p>
			<p><code>static</code> directory. Since you didn't place it inside a namespacing directory, this has been placed directly inside <code>STATIC_ROOT</code>.</p>
			<p>If you want, you can open up any of these files and verify that their content matches the files you have just been working on – they should do, as they are simply copies of the original files.</p>
			<p>In this exercise, we collected all the static files from <code>business_site</code> (including the <code>admin</code> static files that Django includes). They were copied into the directory defined by the <code>STATIC_ROOT</code> setting (<code>static_production_test</code> inside the <code>business_site</code> project directory). We saw that <code>main.css</code> was directly inside this folder but other static files were namespaced inside their app directories (<code>admin</code> and <code>reviews</code>). This folder could have been copied to a production web server to deploy our project.</p>
			<h2 id="_idParaDest-183"><a id="_idTextAnchor193"/>STATICFILES_DIRS Prefixed Mode</h2>
			<p>As mentioned earlier, the <code>STATICFILES_DIRS</code> setting also accepts items as tuples in the form <code>(prefix, directory)</code>. These modes of operation are not mutually exclusive, <code>STATICFILES_DIRS</code> may contain both non-prefixed (string) or prefixed (tuple) items. Essenti<a id="_idTextAnchor194"/>ally, this allows you to map a certain URL prefix to a directory. In Bookr, we do not have enough static assets to warrant setting this up, but it can be useful if you want to organize your static assets differently. For example, you can keep all your images in a certain directory, and all your CSS in another directory. You might need to do this if you use a third-party CSS generation tool such as Node.js with <strong class="bold">LESS</strong>.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">LESS is a CSS pre-processor that uses Node.js. It allows you to write CSS using variables and other programming-like concepts that don't exist natively. Node.js will then compile this to CSS. A more in-depth explanation is outside the scope of this book – suffice to say that if you use it (or a similar tool), then you might want to serve directly from the directory to which it saves its compiled output.</p>
			<p>The easiest way to explain how prefixed mode works is with a short example. This will expand on the <code>STATICFILES_DIRS</code> setting created in <em class="italic">Exercise 5.03</em>, <em class="italic">Serving from a Project Static Directory</em>. In this example, two prefixed directories are added to this setting, one for serving images and one for serving CSS:</p>
			<pre>STATICFILES_DIRS = [os.path.join(BASE_DIR, 'static'),\
                    ('images', os.path.join\
                               (BASE_DIR, 'static_images')),\
                    ('css', os.path.join(BASE_DIR, 'static_css'))]</pre>
			<p>As well as the <code>static</code> directory that was already being served with no prefix, we have added the serving of the <code>static_images</code> directory inside the <code>business_site</code> project directory. This has the prefix <code>images</code>. We have also added the serving of the <code>static_css</code> directory inside the Bookr project directory, with the prefix <code>css</code>.</p>
			<p>Then we can serve three files, <code>main.js</code>, <code>main.css</code>, and <code>main.jpg</code>, from the <code>static</code>, <code>static_css</code>, and <code>static_images</code> directories, respectively. The directory layout would be as shown in <em class="italic">Figure 5.13</em>:</p>
			<div><div><img src="img/B15509_05_13.jpg" alt="Figure 5.13: Directories layout for use with prefixed URLs&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.13: Directories layout for use with prefixed URLs</p>
			<p>In terms of accessing these through URLs, the mapping is as shown in <em class="italic">Figure 5.14</em>:</p>
			<div><div><img src="img/B15509_05_14.jpg" alt="Figure 5.14: Mappings of URLs to files, based on the prefix &#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.14: Mappings of URLs to files, based on the prefix </p>
			<p>Django routes any static URL with a prefix to the directory that matches that prefix.</p>
			<p>When using the <code>static</code> template tag, use the prefix and filename, not the directory name. For example:</p>
			<pre>{% static 'images/main.jpg' %}</pre>
			<p>When the static files are gathered using the <code>collectstatic</code> command, they are moved into a directory with the prefix name, inside <code>STATIC_ROOT</code>. The source paths and the target paths inside the <code>STATIC_ROOT</code> directory are shown in <em class="italic">Figure 5.15</em>:</p>
			<div><div><img src="img/B15509_05_15.jpg" alt="Figure 5.15: Mappings of paths in project directories to paths in STATIC_ROOT&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.15: Mappings of paths in project directories to paths in STATIC_ROOT</p>
			<p>Django creates the prefix directories inside <code>STATIC_ROOT</code>. Because of this, the paths can be kept consistent even when using a web server and not routing the URL lookup through Django.</p>
			<h2 id="_idParaDest-184"><a id="_idTextAnchor195"/>The findstatic Command</h2>
			<p>The <code>staticfiles</code> application also provides one more management command: <code>findstatic</code>. This command allows you to enter the relative path to a static file (the same as what would be used inside a <code>static</code> template tag) and Django will tell you where that file was located. It can also be used in a verbose mode to output the directories it is searching through.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">You may not be familiar with the concept of verbosity or verbose mode. Having a higher verbosity (or simply turning on verbose mode) will cause a command to generate more output. Many command-line applications can be executed with more or less verbosity. This can be helpful when trying to debug the programs you are using. To see an example of the verbose mode in action, you can try running the Python shell in verbose mode. Enter <code>python -v</code> (instead of just <code>python</code>) and hit <code>Enter</code>. Python will start in verbose mode and print out the path of every file it imports.</p>
			<p>This command is mostly useful for debugging/troubleshooting purposes. If the wrong file is loading, or a particular file cannot be found, you can use this command to try to find out why. The command will display which file on disk is being loaded for a specific path, or let you know that the file cannot be found and what directories were searched.</p>
			<p>This can help solve issues where multiple files have the same name, and the precedence is not what you expect. See the <em class="italic">FileSystemFinder</em> section for a note about precedence in the <code>STATICFILES_DIRS</code> setting. You might also see that Django is not searching in a directory you expect for the file, in which case the static directory might need to be added to the <code>STATICFILES_DIRS</code> setting.</p>
			<p>In the next exercise, you will execute the <code>findstatic</code> management command, so you are familiar with what some of the output is for good (file found correctly) and bad (file missing) scenarios.</p>
			<h2 id="_idParaDest-185"><a id="_idTextAnchor196"/>Exercise 5.05: Finding Files Using findstatic</h2>
			<p>You will now run the <code>findstatic</code> command with a variety of options and understand what its output means. First, we will use it to find a file that exists and see that it displays the path to the file. Then, we will try to find a file that does not exist and check the error that is output. We will then repeat this process with multiple levels of verbosity and different ways of interacting with the command. While this exercise will not make changes to or progress the Bookr project, it is good to be familiar with the command in case you need to use it when working on your own Django applications:</p>
			<ol>
				<li value="1">Open a terminal and navigate to the <code>business_site</code> project directory.</li>
				<li>Execute the <code>findstatic</code> command with no options. It will output some help explaining how it is used:<pre>python3 manage.py findstatic</pre><p>The help output is displayed:</p><pre>usage: manage.py findstatic 
      [-h] [--first] [--version] [-v {0,1,2,3}]
      [--settings SETTINGS] [--pythonpath PYTHONPATH]
      [--traceback] [--no-color] [--force-color]
      [--skip-checks]
      staticfile [staticfile ...]
manage.py findstatic: error: Enter at least one label.</pre></li>
				<li>You can find one or more files at a time; let's start with the one that we know exists, <code>main.css</code>:<pre>python3 manage.py findstatic main.css</pre><p>The command outputs the path at which <code>main.css</code> was found:</p><pre>Found 'main.css' here:
  /Users/ben/business_site/static/main.css</pre><p>Your full path will be different (unless you are also called Ben), but you can see that when Django locates <code>main.css</code> in a request it will load the <code>main.css</code> file from the project <code>static</code> directory.</p><p>This can be useful if a third-party application you have installed has not namespaced its static files correctly and is conflicting with one of your files.</p></li>
				<li>Let's try finding a file that does not exist, <code>logo.png</code>:<pre>python3 manage.py findstatic logo.png</pre><p>Django displays an error saying that the file could not be found:</p><pre>No matching file found for 'logo.png'.</pre><p>Django is unable to locate this file because we have namespaced it – we must include the full relative path, the same as we have used in the <code>static</code> template tag.</p></li>
				<li>Try finding <code>logo.png</code> again, but this time using the full path:<pre>python3 manage.py findstatic landing/logo.png</pre><p>Django can find the file now:</p><pre>Found 'landing/logo.png' here:
  /Users/ben/business_site/landing/static/landing/logo.png</pre></li>
				<li>Finding multiple files at once is done by adding each file as an argument:<pre>python3 manage.py findstatic landing/logo.png missing-file.js main.css</pre><p>The location status for each file is shown:</p><pre>No matching file found for 'missing-file.js'.
Found 'landing/logo.png' here:
  /Users/ben/business_site/landing/static/landing/logo.png
Found 'main.css' here:
  /Users/ben/business_site/static/main.css</pre></li>
				<li>The command can be executed with a verbosity of <code>0</code>, <code>1</code>, or <code>2</code>. By default, it executes at verbosity <code>1</code>. To set the verbosity, use the<code> --verbosity</code> or <code>-v</code> flag. Decrease the verbosity to <code>0</code> to only output the paths it locates without any extra information. No errors are displayed for missing paths:<pre>python3 manage.py findstatic -v0 landing/logo.png missing-file.js main.css</pre><p>The output shows only found paths – notice no error is shown for the missing file, <code>missing-file.js</code>:</p><pre>/Users/ben/business_site/landing/static/landing/logo.png
/Users/ben/business_site/static/main.css</pre><p>This level of verbosity can be useful if you are piping the output to another file or command.</p></li>
				<li>To get more information about which directories Django is searching in for the file you have requested, increase the verbosity to <code>2</code>:<pre>python3 manage.py findstatic -v2 <a id="_idTextAnchor197"/>landing/logo.png missing-file.js main.css</pre><p>The output contains much more information, including the directories that have been searched for the requested file. You can see that as the <code>admin</code> application is installed, Django is also searching in the Django admin application directory for static files:</p></li>
			</ol>
			<div><div><img src="img/B15509_05_16.jpg" alt="Figure 5.16: findstatic executed with verbosity 2, showing exactly &#13;&#10;which directories were searched&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.16: findstatic executed with verbosity 2, showing exactly which directories were searched</p>
			<p>The <code>findstatic</code> command is not something that you will use day to day when working with Django, but it is useful to know about when trying to troubleshoot problems with static files. We saw the command output the full path to a file that existed, as well as the error messages when files did not exist. We also ran the command and supplied multiple files at once and saw that information about all the files was output. Finally, we ran the command with different levels of verbosity. The <code>-v0</code> flag suppressed errors about missing files. <code>-v1</code> was the default and displayed found paths and errors. Increasing the verbosity using the <code>-v2</code> flag also printed out the directories that were being searched through for a particular static file.</p>
			<h2 id="_idParaDest-186"><a id="_idTextAnchor198"/>Serving the Latest Files (for Cache Invalidation)</h2>
			<p>If you are not familiar with caching, the basic idea is that some operations can take a long time to perform. We can speed up a system by storing the results of an operation in a place that is faster to access so that the next time we need them, they can be retrieved quickly. The operation that takes a long time can be anything – from a function that takes a long time to run or an image that takes a long time to render, to a large asset that takes a long time to download over the internet. We are most interested in this last scenario.</p>
			<p>You might have noticed that the first time you ever visit a particular website, it is slow to load, but then the next time it loads much faster. This is because your browser has cached some (or all) of the static files the site needs to load. </p>
			<p>To use our business site as an example, we have a page that includes the <code>logo.png</code> file. The first time we visit the business site, we have to download the dynamic HTML, which is small and quick to transfer. Our browser parses the HTML and sees that <code>logo.png</code> should be included. It can then download this file too, which is much larger and can take longer to download. Note that this scenario assumes that the business site is now hosted on a remote server and not on our local machine – which is very fast for us to access.</p>
			<p>If the web server is set up correctly, the browser will store <code>logo.png</code> on the computer. The next time we visit the <em class="italic">landing</em> page (or indeed any page that includes <code>logo.png</code>), your browser recognizes the URL can load the file from disk instead of having to download it again, thus speeding up the browsing experience.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">We said that the browser will cache "if the web server is set up correctly." What does this mean? The frontend web server should be configured to send special HTTP headers as part of a static file response. It can send a <code>Cache-Control</code> header, which can have values such as <code>no-cache</code> (the file should never be cached; in other words, the latest version should be requested every time) or <code>max-age=&lt;seconds&gt;</code> (the file should only be downloaded again if it was last retrieved more than <code>&lt;seconds&gt;</code> seconds ago). The response could also contain the <code>Expires</code> header, with the value being a date. The file is considered to be "stale" once this date is reached, and at that point, the new version should be requested.</p>
			<p>One of the hardest problems in computer science is cache invalidation. For instance, if we change <code>logo.png</code>, how does our browser know it should download the new version? The only surefire way of knowing it had changed would be to download the file again and compare it with the version we had already saved every time. Of course, this defeats the purpose of caching since we would still be downloading every time the file changed (or not). We can cache for an arbitrary or server-specified amount of time, but if the static file changed before that time was up, we would not know. We would use the old version until we considered it expired, at which time we would download the new version. If we had a 1-week expiry and the static file changed the next day, we would still be using the old one for 6 days. Of course, the browser can be made to reload the page without using the cache (how this is done depends on the browser, for example, <em class="italic">Shift</em> + <em class="italic">F5</em> or <em class="italic">Cmd</em> + <em class="italic">Shift</em> + <em class="italic">R</em>) if you want to force downloading of all static assets again.</p>
			<p>There is no need to try to cache our dynamic responses (rendered templates). Since they are designed to be dynamic, we would want to make sure that the user gets the latest version on every page load, and so they should not be cached. They are also quite small in size (compared to assets like images), so there is not much speed advantage when caching them.</p>
			<p>Django provides a built-in solution. During the <code>collectstatic</code> phase, when the files are copied, Django can append a hash of their content to the filename. For example, the <code>logo.png</code> source file will be copied to <code>static_production_test/landing/logo.f30ba08c60ba.png</code>. This is only done when using the <code>ManifestFilesStorage</code> storage engine. Since the filename is changing only when the content changes, the browser will always download the new content.</p>
			<p>Using <code>ManifestFilesStorage</code> is just one way of invalidating caches. There may be other options that are more suitable for your application.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">A hash is a one-way function that generates a string of a fixed length regardless of the length of the input. There are several different hash functions available, and Django uses <code>a</code> is <code>0cc175b9c0f1b6a831c399e269772661</code>. The MD5 hash of the string (a much longer string) is <code>69fc4316c18cdd594a58ec2d59462b97</code>. They are both 32 characters long.</p>
			<p>Choosing the storage engine is done by changing the <code>STATICFILES_STOR<a id="_idTextAnchor199"/>AGE</code> value in <code>settings.py</code>. This is a string with a dotted path to the module and class to use. The class that implements the hash-addition functionality is <code>django.contrib.staticfiles.storage.ManifestStaticFilesStorage</code>.</p>
			<p>Using this s<a id="_idTextAnchor200"/>torage engine doesn't require any changes to your HTML templates, provided you are including static assets with the <code>static</code> template tag. Django generates a manifest file (<code>staticfiles.json</code>, in JSON format) that contains a mapping between the original filename and the hashed filename. It will automatically insert the hashed filename when using the <code>static</code> template tag. If you are including your static files without using the <code>static</code> tag and instead just manually insert the static URL, then your browser will attempt to load the non-hashed path and the URL will not automatically be updated when the cache should be invalidated.</p>
			<p>For example, we include <code>logo.png</code> with the <code>static</code> tag here:</p>
			<pre>&lt;img src="img/logo.png' %}"&gt;</pre>
			<p>When the page is rendered, the latest hash will be retrieved from <code>staticfiles.json</code> and the output will be like this:</p>
			<pre>&lt;img src="img/logo.f30ba08c60ba.png"&gt;</pre>
			<p>If we had not used the <code>static</code> tag and instead hardcoded the path, it would always appear as written:</p>
			<pre>&lt;img src="img/logo.png"&gt;</pre>
			<p>Since this does not contain a hash, our browser will not see the path changing and thus never attempt to download the new file.</p>
			<p>Django retains the previous version of files with the old hash when running <code>collectstatic</code>, so older versions of your application can still refer to it if they need to. The latest version of the file is also copied with no hash so non-Django applications can refer to it without needing to look up the hash. </p>
			<p>In the next exercise, we will change our project settings to use the <code>ManifestFilesStorage</code> engine, then run the <code>collectstatic</code> management command. This will copy all the static assets as in <em class="italic">Exercise 5.04</em>,<em class="italic"> Collecting Static Files for Production</em>; however, they will now have their hash included in the filename.</p>
			<h2 id="_idParaDest-187"><a id="_idTextAnchor201"/>Exercise 5.06: Exploring the ManifestFilesStorage Storage Engine</h2>
			<p>In this exercise, you will temporarily update <em class="italic">settings.py</em> to use <code>ManifestFilesStorage</code>, then run <code>collectstatic</code> to see how the files are generated with a hash:</p>
			<ol>
				<li value="1">In PyCharm (still in the <code>business_site</code> project), open <code>settings.py</code>. Add a <code>STATICFILES_STORAGE</code> setting at the bottom of the file:<pre>STATICFILES_STORAGE = \
'django.contrib.staticfiles.storage.ManifestStaticFilesStorage'</pre><p>The completed file should look like this: <a href="http://packt.live/2Jq59Cc">http://packt.live/2Jq59Cc</a>. </p></li>
				<li>Open a terminal and navigate to the <code>business_site</code> project directory. Run the <code>collectstatic</code> command as you have before:<pre>python3 manage.py collectstatic</pre><p>If your <code>static_production_test</code> directory is not empty (which will probably be the case as files were moved there during <em class="italic">Exercise 5.04</em>, <em class="italic">Collecting Static Files for Production</em>) then you will be prompted to allow the overwrite of the existing files:</p><div><img src="img/B15509_05_17.jpg" alt="Figure 5.17: Prompt to allow overwrite during collectstatic&#13;&#10;"/></div><pre>0 static files copied to '/Users/ben/business_site
  /static_production_test', 132 unmodified, 
  28 post-processed.</pre><p>Since you haven't changed any files since we last ran <code>collectstatic</code>, no files are copied. Instead, Django is just post-processing the files (28 of them), that is, generating their hash and appending the filename.</p><p>The static files were copied into the <code>static_production_test</code> directory as they were before; however, there are now two copies of each file: one named with the hash and one without.</p><p><code>static/main.css</code> has been copied to <code>static_production_test/main.856c74fb7029.css</code> (this filename might be different if your CSS file contents differ, for example, if it has extra spaces or newlines):</p><div><img src="img/B15509_05_18.jpg" alt="Figure 5.18: Expanded static_production_test directory with hashed filenames&#13;&#10;"/></div><p class="figure-caption">Figure 5.18: Expanded static_production_test directory with hashed filenames</p><p><em class="italic">Figure 5.18</em> shows the expanded <code>static_production_test</code> directory layout. You can see two copies of each static file and the <code>staticfiles.json</code> manifest file. To take <code>logo.png</code> as an example, you can see that <code>landing/static/landing/logo.png</code> has been copied to the same directory as <code>static_production_test/landing/logo.ba8d3d8fe184.png</code>.</p></li>
				<li>Let's make a change to the <code>main.css</code> file and see how the hash changes. Add some blank lines at the end of the file then save it. This won't change the effect of the CSS but the change in the file will affect its hash. Rerun the <code>collectstatic</code> command in a terminal:<pre>python3 manage.py collectstatic</pre><p>Once again, you may have to enter <code>yes</code> to confirm the overwrite:</p><pre>You have requested to collect static files at the \
  destination location as specified in your settings:
    /Users/ben/business_site/static_production_test
This will overwrite existing files!
Are you sure you want to do this?
Type 'yes' to continue, or 'no' to cancel: yes
1 static file copied to '/Users/ben/business_site\
  /static_production_test', 131 unmodified, 28 post-processed.</pre><p>Since only one file was changed, only one static file was copied (<code>main.css</code>).</p></li>
				<li>Look inside the <code>static_production_test</code> directory again. You should see the old file with the old hash was retained, and a new file with a new hash has been added:<div><img src="img/B15509_05_19.jpg" alt="Figure 5.19: Another main.css file with the latest hash was added&#13;&#10;"/></div><p class="figure-caption">Figure 5.19: Another main.css file with the latest hash was added</p><p>In this case, we have <code>main.856c74fb7029.css</code> (existing), <code>main.df1234ac4e63.css</code> (new), and <code>main.css</code>. Your hashes may differ.</p><p>The <code>main.css</code> file (no hash) always contains the newest content; that is to say, the contents of the <code>main.df1234ac4e63.css</code> and <code>main.css</code> files are identical. During the execution of <code>collectstatic</code>, Django will copy the file with a hash, as well as without a hash.</p></li>
				<li>Now examine the <code>staticfiles.json</code> file that Django generates. This is the mapping that allows Django to look up the hashed path from the normal path. Open <code>static_production_test/staticfiles.json</code>. All the content may appear in one line; if it does, enable text soft wrapping from the <code>View</code> menu -&gt; <code>Active Editor</code> -&gt; <code>Soft Wrap</code>. Scroll to the end of the file and you should see an entry for the <code>main.css</code> file, for example:<pre>"main.css": "main.df1234ac4e63.css"</pre><p>This is how Django is able to populate the correct URL in a template when using the <code>static</code> template tag: by looking up the hashed path in this mapping file.</p></li>
				<li>We're finished with <code>business_site</code>, which we were just using for testing. You can delete the project or keep it around for reference during the activities.<p class="callout-heading">Note</p><p class="callout">Unfortunately, we can't examine how the hashed URL is interpolated in the template, because when running in debug mode, Django does not look up the hashed version of the file. As we know, the Django dev server only runs in debug mode, so if we turned debug mode off to try to view the hashed interpolation, then the Django dev server would not start. You will need to examine this interpolation yourself when going to production when using a frontend web server.</p></li>
			</ol>
			<p>In this exercise, we configured Django to use <code>ManifestFilesStorage</code> for its static file storage, by adding the <code>STATICFILES_STORAGE</code> setting to <code>settings.py</code>. We then executed the <code>collectstatic</code> command to see how the hashes are generated and added to the filename of the copied files. We saw the manifest file called <code>staticfiles.json</code>, which stored a lookup from the original path to the hashed path. Finally, we cleaned up the settings and directories that we added in this exercise and <em class="italic">Exercise 5.04</em>, <em class="italic">Collecting Static Files for Production</em>. These were the <code>STATIC_ROOT</code> setting, the <code>STATICFILES_STORAGE</code> setting, and the <code>static_product_test</code> directory.</p>
			<h2 id="_idParaDest-188"><a id="_idTextAnchor202"/>Custom Storage Engines</h2>
			<p>In the previous section, we set the storage engine to <code>ManifestFilesStorage</code>. This class is provided by Django, but it is also possible to write a custom storage engine. For example, you could write a storage engine that uploads your static files to a CDN, Amazon S3, or a Google Cloud bucket when you run <code>collectstatic</code>.</p>
			<p>Writing a custom storage engine is beyond the scope of this book. There already exist third-party libraries that support uploading to a variety of cloud services; one such library is <code>django-storages</code>, which can be found at <a href="https://django-storages.readthedocs.io/">https://django-storages.readthedocs.io/</a>.</p>
			<p>The following code is a short skeleton indicating which methods you should implement to create a custom file storage engine:</p>
			<pre>from django.conf import settings
from django.contrib.staticfiles import storage
class CustomFilesStorage(storage.StaticFilesStorage):
    def __init__(self):
    """
    The class must be able to be instantiated 
    without any arguments.
    Create custom settings in settings.py and read them instead.
    """
    self.setting = settings.CUSTOM_STORAGE_SETTING</pre>
			<p>The class must be able to be instantiated without any arguments. The <code>__init__</code> function must be able to load any settings from global identifiers (in this case, from our Django settings):</p>
			<pre>  def delete(self, name):
    """
    Implement delete of the file from the remote service.
    """</pre>
			<p>This method should be able to delete the file, specified by the <code>name</code> argument, from the remote service:</p>
			<pre>    def exists(self, name):
    """
    Return True if a file with name exists in the remote service.
    """</pre>
			<p>This method should query the remote service to check whether the file specified by name exists. It should return <code>True</code> if the file exists, or <code>False</code> if it doesn't:</p>
			<pre>    def listdir(self, path):
    """
    List a directory in the remote service. Return should 
    be a 2-tuple of lists, the first a list of directories, 
    the second a list of files.
    """</pre>
			<p>This method should query the remote service to list the directory at <code>path</code>. It should then return a 2-tuple of lists. The first element should be a list of directories inside <code>path</code>, and the second element should be a list of files. For example:</p>
			<pre>return (['directory1', 'directory2'], \
        ['code.py', 'document.txt', 'image.jpg'])</pre>
			<p>If <code>path</code> contains no directories or no files, then an empty list should be returned for that element. You would return two empty lists if the directory was empty:</p>
			<pre>    def size(self, name):
    """
    Return the size in bytes of the file with name.
    """</pre>
			<p>This method should query the remote service and get the size of the file specified by <code>name</code>:</p>
			<pre>  def url(self, name):
  """
  Return the URL where the file of with name can be 
  access on the remote service. For example, this 
  might be URL of the file after it has been uploaded 
  to a specific remote host with a specific domain.
  """</pre>
			<p>This method should determine the URL to access the file specified by <code>name</code>. This could be built by appending <code>name</code> to a specific static hosting URL:</p>
			<pre>  def _open(self, name, mode='rb'):
  """
  Return a File-like object pointing to file with 
  name. For example, this could be a URL handle for 
  a remote file.
  """</pre>
			<p>This method will provide a handle remote file, specified by <code>name</code>. How you implement this will depend on the type of remote service. You might have to download the file and then use a memory buffer (such as an <code>io.BytesIO</code> object) to simulate the opening of the file:</p>
			<pre>    def _save(self, name, content):
    """
    Write the content for a file with name. In this 
    method you might upload the content to a 
    remote service.
    """</pre>
			<p>This method should save <code>content</code> to the remote file at <code>name</code>. The method of implementing this will depend on your remote service. It might transfer the file over SFTP, or upload to a CDN.</p>
			<p>While this example does not implement any transferring to or from a remote service, you can refer to it to get an idea of how to implement a custom storage engine.</p>
			<p>After implementing your custom storage engine, you can make it active by setting its dotted module path in the <code>STATICFILES_STORAGE</code> setting in <code>settings.py</code>.</p>
			<h2 id="_idParaDest-189">Activity 5.01: Addi<a id="_idTextAnchor203"/>ng a reviews Logo</h2>
			<p>The Bookr app should have a logo that is specific for pages in the <code>reviews</code> app. This will involve adding a base template just for the <code>reviews</code> app and updating our current <code>reviews</code> templates to inherit from it. Then you will include the Bookr <code>reviews</code> logo on this base template.</p>
			<p>These steps will help you complete this activity:</p>
			<ol>
				<li value="1">Add a CSS rule to position the logo. Put this rule into the existing <code>base.html</code>, after the <code>.navbar-brand</code> rule:<pre>.navbar-brand &gt; img<a id="_idTextAnchor204"/> {
  height: 60px;
}</pre></li>
				<li>Add a <code>brand</code> <code>block</code> template tag that inheriting templates can override. Put this inside the <code>&lt;a&gt;</code> element with the <code>navbar-brand</code> class. The default contents of <code>block</code> should be left as <code>Book Review</code>.</li>
				<li>Add a static directory inside the <code>reviews</code> app, containing a namespaced directory. Download the reviews <code>logo.png</code> from <a href="https://packt.live/2WYlGjP">https://packt.live/2WYlGjP</a> and put it inside this directory.</li>
				<li>Create the <code>templates</code> directory for the Bookr project (inside the Bookr project directory). Then move the <code>reviews</code> app's current <code>base.html</code> into this directory, so it becomes a base template for the whole project.</li>
				<li>Add the new <code>templates</code> directory's path to the <code>TEMPLATES['DIRS']</code> setting in <code>settings.py</code> (the same as what you did in <em class="italic">Exercise 5.02</em>, <em class="italic">Using the static Template Tag</em>.</li>
				<li>Create another <code>base.html</code> template specifically for the <code>reviews</code> app. Put it inside the <code>reviews</code> app's <code>templates</code> directory. The new template should extend the existing <code>base.html</code>.</li>
				<li>The new <code>base.html</code> should override the content of the <code>brand</code> block. This block should contain just an <code>&lt;img&gt;</code> instance whose <code>src</code> attribute is set using the <code>{% static %}</code> template tag. The image source should be the logo added in <em class="italic">step 2</em>.</li>
				<li>The index view in <code>views.py</code> should render the project <code>base.html</code> instead of the <code>reviews</code> one.</li>
			</ol>
			<p>Refer to the following screenshots to see what your pages should be like after these changes. Note that although you are making changes to the base template, it will not change the layout of the main page:</p>
			<div><div><img src="img/B15509_05_20.jpg" alt="Figure 5.20: Book list page after adding reviews logos&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.20: Book list page after adding reviews logos</p>
			<div><div><img src="img/B15509_05_21.jpg" alt="Figure 5.21: Book Details page after adding logo&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.21: Book Details page after adding logo</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution to this activity can be found at <a href="http://packt.live/2Nh1NTJ">http://packt.live/2Nh1NTJ</a>.</p>
			<h2 id="_idParaDest-190">Activity 5.02: CSS En<a id="_idTextAnchor205"/>hancements</h2>
			<p>Currently, the CSS is kept inline in the <code>base.html</code> template. For best practice, it should be moved into its own file so that it can be cached separately and decrease the size of the HTML downloads. As part of this, you'll also add some CSS enhancements, such as fonts and colors, and link in Google Fonts CSS to support these changes.</p>
			<p>These steps will help you complete this activity:</p>
			<ol>
				<li value="1">Create a directory named <code>static</code> in the Bookr project directory. Then, create a new file inside it named <code>main.css</code>.</li>
				<li>Copy the contents of the <code>&lt;style&gt;</code> element from the main <code>base.html</code> template into the new <code>main.css</code> file, then remove the <code>&lt;style&gt;</code> element from the template. Add these extra rules to the end of the CSS file:<pre>body {
  font-family: 'Source Sans Pro', sans-serif;
    background-color: #e6efe8
  color: #393939;
}
h1, h2, h3, h4, h5, h6 {
  font-family: 'Libre Baskerville', serif;
}</pre></li>
				<li>Link to the new <code>main.css</code> file with a <code>&lt;link rel="stylesheet" href="…"&gt;</code> tag. Use the <code>{% static %}</code> template tag to generate the URL for the <code>href</code> attribute, and don't forget to <code>load</code> the <code>static</code> library.</li>
				<li>Link in the Google fonts CSS, by adding this code to the base template:<pre>&lt;link rel="stylesheet" 
  href="https://fonts.googleapis.com/css?family
    =Libre+Baskerville|Source+Sans+Pro&amp;display=swap"&gt;</pre><p class="callout-heading">Note</p><p class="callout">You will need to have an active internet connection so that your browser can include this remote CSS file.</p></li>
				<li>Update your Django settings to add <code>STATICFILES_DIRS</code>, set to the <code>static</code> directory created in <em class="italic">step 1</em>. When you're finished, your Bookr application should look like <em class="italic">Figure 5.22</em>:<div><img src="img/B15509_05_22.jpg" alt="Figure 5.22: Book list with the new font and background color&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 5.22: Book list with the new font and background color</p>
			<p>Notice the new font and background color. These should be displayed on all the Bookr pages.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution to this activity can be found at <a href="http://packt.live/2Nh1NTJ">http://packt.live/2Nh1NTJ</a>.</p>
			<h2 id="_idParaDest-191">Activity 5.03: Adding <a id="_idTextAnchor206"/>a Global Logo</h2>
			<p>You have already added a logo that is served on pages for the <code>reviews</code> app. We have another logo to be used globally as a default, but other apps will be able to override it:</p>
			<ol>
				<li value="1">Download the Bookr logo (<code>logo.png</code>) from <a href="https://packt.live/2Jx7Ge4">https://packt.live/2Jx7Ge4</a>.</li>
				<li>Save it in the main <code>static</code> directory for the project.</li>
				<li>Edit the main <code>base.html</code> file. We already have a block for the logo (<code>brand</code>), so an <code>&lt;img&gt;</code> instance can be placed inside here. Use the <code>static</code> template tag to refer to the logo you just downloaded.</li>
				<li>Check that your pages work. On the main URL, you should see the Bookr logo, but on the book list and details pages, you should see the Bookr Reviews logo.<p>When you're finished, you should see the Bookr logo on the main page:</p><div><img src="img/B15509_05_23.jpg" alt="Figure 5.23: Bookr logo on the main page&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 5.23: Bookr logo on the main page</p>
			<p>When you visit a page that had the Bookr Reviews logo before, such as the book list page, it should still show the Bookr Reviews logo:</p>
			<div><div><img src="img/B15509_05_24.jpg" alt="Figure 5.24: Bookr Reviews logo still shows on the Reviews pages&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.24: Bookr Reviews logo still shows on the Reviews pages</p>
			<p class="callout-heading"> Note</p>
			<p class="callout">The solution to this activity can be found at <a href="http://packt.live/2Nh1NTJ">http://packt.live/2Nh1NTJ</a>.</p>
			<h1 id="_idParaDest-192"><a id="_idTextAnchor207"/>Summary</h1>
			<p>In this chapter, we showed how to use Django's <code>staticfiles</code> app to find and serve static files. We used the built-in <code>static</code> view to serve these files with the Django dev server in <code>DEBUG</code> mode. We showed different places to store static files, using a directory that is global to the project or a specific directory for the application; global resources should be stored in the former while application-specific resources should be stored in the latter. We showed the importance of namespacing static file directories to prevent conflicts. After serving the assets, we used the <code>static</code> tag to include them in our template. We then demonstrated how the <code>collectstatic</code> command copies all the assets into the <code>STATIC_ROOT</code> directory, for production deployment. We showed how to use the <code>findstatic</code> command to debug the loading of static files. To invalidate caches automatically, we looked at using <code>ManifestFilesStorage</code> to add a hash of the file's content to the static file URL. Finally, we briefly talked about using a custom file storage engine.</p>
			<p>So far, we have only fetched web pages using content that already existed. In the next chapter, we will start adding forms so we can interact with web pages by sending data to them over HTTP.</p>
		</div>
	</body></html>