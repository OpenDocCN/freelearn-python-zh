<html><head></head><body>
		<div>
			<div id="_idContainer191" class="Content">
			</div>
		</div>
		<div id="_idContainer192" class="Content">
			<h1 id="_idParaDest-169"><a id="_idTextAnchor172"/>5. Serving Static Files</h1>
		</div>
		<div id="_idContainer217" class="Content">
			<p class="callout-heading">Overview</p>
			<p class="callout">In this chapter, you will start by learning the difference between static and dynamic responses. You will then see how the Django <strong class="source-inline">staticfiles</strong> app helps manage static files. Continuing work on the Bookr app, you will enhance it with images and CSS. You'll learn the different ways you can lay out your static files for your project and examine how Django consolidates them for production deployment. Django includes tools to reference static files in templates and you'll see how these tools help reduce the amount of work needed when deploying an application to production. After this, you'll explore the <strong class="source-inline">findstatic</strong> command, which can be used to debug issues with your static files. Later, you'll get an overview of how to write code for storing static files on a remote service. Finally, you'll look at caching web assets and how Django can help with cache invalidation.</p>
			<h1 id="_idParaDest-170"><a id="_idTextAnchor173"/>Introduction</h1>
			<p>A web application with just plain <strong class="bold">Hypertext Markup Language</strong> (<strong class="bold">HTML</strong>) is quite limiting. We can enhance the look of web pages with <strong class="bold">Cascading Style Sheets</strong> (<strong class="bold">CSS</strong>) and images, and we can add interaction with JavaScript. We call all these kinds of files "static files." They are developed and then deployed as part of the application. We can compare these to dynamic responses, which are generated in real time when a request is made. All the views you have written generate a dynamic response by rendering a template. Note that we will not consider templates to be static files as they are not sent verbatim to a client; instead, they are rendered first and sent as part of a dynamic response. </p>
			<p>During development, the static files are created on the developer's machine, and they must then be moved to the production web server. If you have to move to production in a short timeframe (say, a few hours), then it can be time-consuming to collect all the static assets, move them to the correct directory, and upload them to the server. When developing web applications using other frameworks or languages, you might need to manually put all of your static files into a specific directory that your web server hosts. Making changes to the URL from which static files are served might mean updating values throughout your code.</p>
			<p>Django can manage static assets for us to make this process easier. It provides tools for serving them with its development server during development. When your application goes to production, it can also collect all your assets and copy them to a folder for a dedicated web server to host. This allows you to keep your static files segregated in a meaningful way during development and automatically bundle them for deployment.</p>
			<p>This functionality is provided by Django's built-in <strong class="source-inline">staticfiles</strong> app. It adds several useful features for working with and serving static files:</p>
			<ul>
				<li>The <strong class="source-inline">static</strong> template tag to automatically build the static URL for an asset and include it in your HTML.</li>
				<li>A view (called <strong class="source-inline">static</strong>) that serves static files in development.</li>
				<li>Static file finders to customize where assets are found on your filesystem.</li>
				<li><a id="_idTextAnchor174"/>The <strong class="source-inline">collectstatic</strong> management command, which finds all static files and moves them into a single directory for deployment.</li>
				<li>The <strong class="source-inline">findstatic</strong> management command, which shows which static file on disk is loaded for a particular request. This also helps to debug if a particular file is not being loaded.</li>
			</ul>
			<p>In the exercises and activities in this chapter, we will be adding static files (images and CSS) to the Bookr application. Each file will be stored inside the Bookr project directory during development. We need to generate a URL for each so that the templates can reference them, and the browser can download them. Once the URL is generated, Django needs to serve these files. When we deploy the Bookr application to production, all the static files need to be found and moved to a directory where they can be served by the production web server. If there are static files that are not loading as expected, we need some method of determining what the cause is.</p>
			<p>For the sake of simplicity, let's take a single static file as an example: <strong class="source-inline">logo.png</strong>. We will briefly introduce the role of each feature we mentioned in the previous paragraph and explain them in depth throughout the chapter:</p>
			<ul>
				<li>The <strong class="source-inline">static</strong> template tag is used to convert a filename to a URL or path that can be used in a template, for example, from <strong class="source-inline">logo.png</strong> to <strong class="source-inline">/static/logo.png</strong>.</li>
				<li>The <strong class="source-inline">static</strong> view receives a request to load the static file at the path <strong class="source-inline">/static/logo.png</strong>. It reads the file and sends it to the browser.</li>
				<li>A static file finder (or just <strong class="source-inline">finder</strong>) is used by the <strong class="source-inline">static</strong> view to locate the static file on the disk. There are different finders, but in this example, a finder is just converting from the URL path <strong class="source-inline">/static/logo.png</strong> to the path on disk <strong class="source-inline">bookr/static/logo.png</strong>.</li>
				<li>When deploying to production, the <strong class="source-inline">collectstatic</strong> management command is used. This will copy the <strong class="source-inline">logo.png</strong> file from the <strong class="source-inline">bookr</strong> project directory to a web server directory, such as <strong class="source-inline">/var/www/bookr/static/logo.png</strong>.</li>
				<li>If a static file is not working (for example, a request for it returns a <strong class="source-inline">404 Not Found</strong> response, or the wrong file is being served), then we can use the <strong class="source-inline">findstatic</strong> management command to try to determine the reason. This command takes the filename as a parameter and will output which directories were looked through and where it was able to locate that requested file.</li>
			</ul>
			<p>These are the most common features that are used day to day, but there are others that we will also discuss.</p>
			<h1 id="_idParaDest-171"><a id="_idTextAnchor175"/>Static File Serving</h1>
			<p>In the introduction, we mentioned that Django includes a view function called <strong class="source-inline">static</strong> that serves static files. The first important point to make regarding the serving of static files is that Django is not intended to serve them in production. It is not Django's role, and in production, Django will refuse to serve static files. This is normal and intended behavior. If Django is just reading from the filesystem and sending out a file, then it has no advantage over a normal web server, which would probably be more performant at this task. Furthermore, if you serve static files with Django, you will keep the Python process busy for the duration of the request and it will be unable to serve the dynamic requests to which it is more suited.</p>
			<p>For these reasons, the Django <strong class="source-inline">static</strong> view is designed only for use during development and will not work if your <strong class="source-inline">DEBUG</strong> setting is <strong class="source-inline">False</strong>. Since during development we only usually have one person accessing the site at a time (the developer), Django is fine to serve static files. Soon, we will discuss more how the <strong class="source-inline">staticfiles</strong> app supports production deployment. The entire production deployment process will be covered in <em class="italic">Chapter 17</em>, <em class="italic">Deployment of a Django Application (Part 1 – Server Setup)</em>. This chapter can be downloaded from the GitHub repository of this book, at <a href="http://packt.live/2Kx6FmR">http://packt.live/2Kx6FmR</a>.</p>
			<p>A URL mapping to the <strong class="source-inline">static</strong> view is automatically set up when running the Django development server, provided that your <strong class="source-inline">settings.py</strong> file meets the following conditions: </p>
			<ul>
				<li>Has <strong class="source-inline">DEBUG</strong> set to <strong class="source-inline">True</strong></li>
				<li>Contains <strong class="source-inline">'django.contrib.staticfiles'</strong> in its <strong class="source-inline">INSTALLED_APPS</strong></li>
			</ul>
			<p>Both settings exist by default.</p>
			<p>The URL mapping that is created is roughly equivalent to having the following map in your <strong class="source-inline">urlpatterns</strong>:</p>
			<p class="source-code">path(settings.STATIC_URL, django.conf.urls.static)</p>
			<p>Any URL starting with <strong class="source-inline">settings.STATIC_URL</strong> (which is <strong class="source-inline">/static/</strong> by default) gets mapped to the <strong class="source-inline">static</strong> view.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">You can still use the <strong class="source-inline">static</strong> view without having <strong class="source-inline">staticfiles</strong> in <strong class="source-inline">INSTALLED_APPS</strong>, but you must set up an equivalent URL mapping manually.</p>
			<h2 id="_idParaDest-172"><a id="_idTextAnchor176"/>Introduction to Static File Finders</h2>
			<p>There are three times when Django needs to locate static files on disk, and for this, it uses a <strong class="bold">static file finder</strong>. A static file finder could be thought of like a plugin. It is a class that implements methods for converting URL paths to disks and iterates through the project directory to find static files.</p>
			<p>The first time Django needs to locate static files on disk is when the Django <strong class="source-inline">static</strong> view receives a request to load a particular static file; it then needs to convert the path in the URL to a location on disk. For example, the URL's path is <strong class="source-inline">/static/logo.png</strong>, and it is converted to the path <strong class="source-inline">bookr/static/logo.png</strong> on the disk. As we noted in the previous section, this is only during development. On a production server, Django should not receive this request as it will be handled directly by the web server.</p>
			<p>The second time is when using the <strong class="source-inline">collectstatic</strong> management command. This gathers up all the static files in the project directory and copies them to a single directory to be served by the production web server. <strong class="source-inline">bookr/static/logo.png</strong> will get copied to the web server root, for example, <strong class="source-inline">/var/www/bookr/static/logo.png</strong>. The static file finder contains code to locate all the static files inside your project directory.</p>
			<p>The last time a static file finder is used is during the execution of the <strong class="source-inline">findstatic</strong> management command. This is similar to the first usage in that it accepts a static file's name (such as <strong class="source-inline">logo.png</strong>), but it outputs the full path (<strong class="source-inline">bookr/static/logo.png</strong>) to the terminal instead of loading the file content.</p>
			<p>Django comes with some built-in finders, but you can also write your own if you want to store static files in a custom directory layout. The list of finders Django uses is defined by the <strong class="source-inline">STATICFILES_FINDERS</strong> setting in <strong class="source-inline">settings.py</strong>. In this chapter, we will cover the behavior of the default static file finders, <strong class="source-inline">AppDirectoriesFinder</strong> and <strong class="source-inline">FileSystemFinder</strong>, in the <em class="italic">AppDirectoriesFinder</em> and <em class="italic">FileSystemFinder</em> sections, respectively.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">If you look in <strong class="source-inline">settings.py</strong>, you won't see that <strong class="source-inline">STATICFILES_FINDERS</strong> setting defined by default. This is because Django will use its built-in default for the setting, which is defined as the list <strong class="source-inline">['django.contrib.staticfiles.finders.FileSystemFinder', ' django.contrib.staticfiles.finders.AppDirectoriesFinder']</strong>. If you add the <strong class="source-inline">STATICFILES_FINDERS</strong> setting to your <strong class="source-inline">settings.py</strong> file to include a custom finder, be sure to include these defaults if you're using them.</p>
			<p>First, we will discuss static file finders and their use in the first case – responding to a request. Then we will introduce some more concepts and return to the behavior of <strong class="source-inline">collectstatic</strong> and how it uses static file finders. Later in the chapter, we will work with the <strong class="source-inline">findstatic</strong> command to see how to use it.</p>
			<h2 id="_idParaDest-173"><a id="_idTextAnchor177"/>Static File Finders: Use During a Request</h2>
			<p>When Django receives a request for a static file (remember, Django will only serve static files during development), each static file finder that has been defined will be queried until a file on disk has been found. If none of the finders can locate a file, the <strong class="source-inline">static</strong> view will return an <strong class="source-inline">HTTP 404 Not Found</strong> response.</p>
			<p>For example, the URL of the request will be something like <strong class="source-inline">/static/main.css</strong> or <strong class="source-inline">/static/reviews/ logo.png</strong>. Each finder will be queried in turn with the path from the URL and will return a path such as <strong class="source-inline">bookr/static/main.css</strong> for the first file and <strong class="source-inline">bookr/reviews/static/reviews/logo.png</strong> for the second. Each finder will use its own logic to convert from a URL path to a filesystem path – we will discuss this logic in the upcoming <em class="italic">AppDirectoriesFinder</em> and <em class="italic">FileSystemFinder</em> sections.</p>
			<h2 id="_idParaDest-174"><a id="_idTextAnchor178"/>AppDirectoriesFinder</h2>
			<p>The <strong class="source-inline">AppDirectoriesFinder</strong> class is used to find static files inside each app directory, in a directory called <strong class="source-inline">static</strong>. The application must be listed in the <strong class="source-inline">INSTALLED_APPS</strong> setting in your <strong class="source-inline">settings.py</strong> file (we did this in <em class="italic">Chapter 1</em>, <em class="italic">Introduction to Django</em>). As we also mentioned in <em class="italic">Chapter 1</em>, <em class="italic">Introduction to Django</em>, it is good for apps to be self-contained. By letting each application have its own <strong class="source-inline">static</strong> directory, we can continue the self-contained design by also storing app-specific static files inside the app directory too.</p>
			<p>Before we use <strong class="source-inline">AppDirectoriesFinder</strong>, we will explain a problem that can occur if multiple static files have the same name, and also how to solve this problem.</p>
			<h2 id="_idParaDest-175"><a id="_idTextAnchor179"/>Static File Namespacing</h2>
			<p>In the <em class="italic">Static File Finders: Use during a Request</em> section, we discussed serving a file named <strong class="source-inline">logo.png</strong>. This would provide a logo for the <strong class="source-inline">reviews</strong> application. The filename (<strong class="source-inline">logo.png</strong>) could be quite common – you could imagine that if we added a <strong class="source-inline">store</strong> app (for purchasing books), it would also have a logo. Not to mention that third-party Django apps might also want to use a common name like <strong class="source-inline">logo.png</strong>. The problem we are about to describe could apply to any static file that has a common name, such as <strong class="source-inline">styles.css</strong> or <strong class="source-inline">main.js</strong>.</p>
			<p>Let's consider the <strong class="source-inline">reviews</strong> and <strong class="source-inline">store</strong> examples. We can add a <strong class="source-inline">static</strong> directory in each of these apps. Then, each <strong class="source-inline">static</strong> directory would have a <strong class="source-inline">logo.png</strong> file (although it would be a different logo). The directory structure is as shown in <em class="italic">Figure 5.1</em>:</p>
			<div>
				<div id="_idContainer193" class="IMG---Figure">
					<img src="image/B15509_05_01.jpg" alt="Figure 5.1: Directory layout with static directories inside app directories&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.1: Directory layout with static directories inside app directories</p>
			<p>The URL path that we use to download a static file is relative to the static directory. Therefore, it is unclear which <strong class="source-inline">logo.png</strong> is being referenced if we make an HTTP request for <strong class="source-inline">/static/logo.png</strong>. Django will check the <strong class="source-inline">static</strong> directory for each application in turn (in the order they are specified in the <strong class="source-inline">INSTALLED_APPS</strong> setting). The first <strong class="source-inline">logo.png</strong> it locates, it will serve. There is no way, in this directory layout, to specify which <strong class="source-inline">logo.png</strong> you want to load.</p>
			<p>We can solve this problem by <strong class="bold">namespacing</strong> our static files. This is the process of using another directory inside the <strong class="source-inline">static</strong> directory, named the same as the app. The <strong class="source-inline">reviews</strong> app has a <strong class="source-inline">reviews</strong> directory inside its <strong class="source-inline">static</strong> directory, and the <strong class="source-inline">store</strong> app has a <strong class="source-inline">store</strong> directory inside its <strong class="source-inline">static</strong> directory. The respective <strong class="source-inline">logo.png</strong> files are then moved inside these subdirectories. The new directory layout is as shown in <em class="italic">Figure 5.2</em>:</p>
			<div>
				<div id="_idContainer194" class="IMG---Figure">
					<img src="image/B15509_05_02.jpg" alt="Figure 5.2: Directory layout with namespaced directories&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.2: Directory layout with namespaced directories</p>
			<p>To load a specific file, we include the namespaced directory too. For the <strong class="source-inline">reviews</strong> logo, the URL path is <strong class="source-inline">/static/reviews/logo.png</strong>, which maps to <strong class="source-inline">bookr/reviews/static/review/logo.png</strong> on disk. Similarly, for the store logo, its path is <strong class="source-inline">/static/store/logo.png</strong>, which maps to <strong class="source-inline">bookr/store/static/store/logo.png</strong>. You might have noticed that the examples path for the <strong class="source-inline">logo.png</strong> file is already namespaced in the <em class="italic">Static File Finders: Use during a Request</em> section.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">If you are considering writing a Django app that might be released as its own standalone plugin, you could use an even more explicit sub-directory name. For example, choose one that contains the entire dotted project path: <em class="italic">bookr/reviews/static/bookr.reviews</em>. In most cases, though, it is fine for the sub-directory name to be unique to just your project.</p>
			<p>Now that we have introduced <strong class="source-inline">AppDirectoriesFinder</strong> and static file namespacing, we can use them to serve our first static file. In the first exercise of the chapter, we will create a new Django project for a basic business site. We will then serve a logo file from an app called <strong class="source-inline">landing</strong> that we will create in this project. The <strong class="source-inline">AppDirectoriesFinder</strong> class is used to find static files inside each app directory, in a directory called <strong class="source-inline">static</strong>. The application must be listed in the <strong class="source-inline">INSTALLED_APPS</strong> setting in your <strong class="source-inline">settings.py</strong> file. As we have mentioned in <em class="italic">Chapter 1</em>, <em class="italic">Introduction to Django</em>, it is good for apps to be self-contained. By letting each application have its own <strong class="source-inline">static</strong> directory, we can continue the self-contained design by also storing app-specific static files inside the app directory too.</p>
			<p>The easiest way to serve a static file is from an app directory. This is because we do not need to make any settings changes. Instead, we just need to create the files in the correct directory, and they will be served using the default Django configuration.</p>
			<p class="callout-heading">The Business Site Project</p>
			<p class="callout">For the exercises in this chapter, we'll create a new Django project and use it to demonstrate the static file concepts. The project will be a basic business site with a simple landing page that has a logo. The project will have one app, calling <strong class="source-inline">landing</strong>.</p>
			<p class="callout">You can refer to <em class="italic">Exercise 1.01</em>, <em class="italic">Creating a Project and App, and Starting the dev server </em>from <em class="italic">Chapter 1</em>, <em class="italic">Introduction to Django</em>, to refresh your memory on creating a Django project.</p>
			<h2 id="_idParaDest-176"><a id="_idTextAnchor180"/>Exercise 5.01: Serving a File from an App Directory</h2>
			<p>In this exercise, you will add a logo file for the <strong class="source-inline">landing</strong> app. This will be done by putting a <strong class="source-inline">logo.png</strong> file in a <strong class="source-inline">static</strong> directory inside the <strong class="source-inline">landing</strong> app directory. After this is done, you can test that the static file is being served correctly and confirm the URL that will serve it:</p>
			<ol>
				<li>Start by creating the new Django project. You can reuse the <strong class="source-inline">bookr</strong> virtual environment that already has Django installed. Open a new terminal and activate the virtual environment (refer to the <em class="italic">Preface</em> for instructions on how to create and activate a virtual environment). Then, run the <strong class="source-inline">django-admin</strong> command in the terminal (or command shell) to start a Django project named <strong class="source-inline">business_site</strong>. To do this, run this command:<p class="source-code">django-admin startproject business_site</p><p>There will not be any output. This command will scaffold the Django project in a new directory named <strong class="source-inline">business_site</strong>.</p></li>
				<li>Create a new Django app in this project by using the <strong class="source-inline">startapp</strong> management command. The app should be called <em class="italic">landing</em>. To do this, <strong class="source-inline">cd</strong> into the <strong class="source-inline">business_site</strong> directory, then run this:<p class="source-code">python3 manage.py startapp landing</p><p>Note that there will not be any output again. The command will create the <strong class="source-inline">landing</strong> app directory inside the <strong class="source-inline">business_site</strong> directory. </p><p class="callout-heading">Note</p><p class="callout">Remember that on Windows the command is <strong class="source-inline">python manage.py startapp landing</strong>.</p></li>
				<li>Launch PyCharm, then open the <strong class="source-inline">business_site</strong> directory. If you already have a project open, you can do this by choosing <strong class="source-inline">File</strong> -&gt; <strong class="source-inline">Open</strong>; otherwise, just click <strong class="source-inline">Open</strong> in the <strong class="source-inline">Welcome to PyCharm</strong> window. Navigate to the <strong class="source-inline">business_site</strong> directory, select it, then click <strong class="source-inline">Open</strong>. The <strong class="source-inline">business_site</strong> project window should be shown like <em class="italic">Figure 5.3</em>:<p class="callout-heading">Note</p><p class="callout">For detailed instructions on how to set up and configure PyCharm to work with your Django project, refer to <em class="italic">Exercise 1.02</em>, <em class="italic">Project Setup in PyCharm</em>, in <em class="italic">Chapter 1</em>, <em class="italic">Introduction to Django</em>.</p><div id="_idContainer195" class="IMG---Figure"><img src="image/B15509_05_03.jpg" alt="Figure 5.3: The business_site project&#13;&#10;"/></div><p class="figure-caption">Figure 5.3: The business_site project</p></li>
				<li>Create a new run configuration to execute <strong class="source-inline">manage.py runserver</strong> for the project. You can reuse the <strong class="source-inline">bookr</strong> virtual environment again. The <strong class="source-inline">Run/Debug Configurations</strong> window should look like <em class="italic">Figure 5.4</em>. when you are done:<p class="callout-heading">Note</p><p class="callout">Note that if you are not sure how to configure these settings in PyCharm, refer to <em class="italic">Exercise 1.02</em>, <em class="italic">Project Setup in PyCharm</em>, from <em class="italic">Chapter 1</em>, <em class="italic">Introduction to Django</em>.</p><div id="_idContainer196" class="IMG---Figure"><img src="image/B15509_05_04.jpg" alt="Figure 5.4: Run/Debug Configurations for Runserver&#13;&#10;"/></div><p class="figure-caption">Figure 5.4: Run/Debug Configurations for Runserver</p><p>You can test that the configuration is set up correctly by clicking the <strong class="source-inline">Run</strong> button, then visiting <strong class="source-inline">http://127.0.0.1:8000/</strong> in your browser. You should see the Django welcome screen. If the debug server fails to start or you see the Bookr main page, then you probably still have the Bookr project running. Try stopping the Bookr <strong class="source-inline">runserver</strong> process (press <em class="italic">Ctrl</em> + <em class="italic">C</em> in the terminal that is running it) and then starting the new one you just set up.</p></li>
				<li>Open <strong class="source-inline">settings.py</strong> in the <strong class="source-inline">business_site</strong> directory and add <strong class="source-inline">'landing'</strong> to the <strong class="source-inline">INSTALLED_APPS</strong> setting. Remember we learned how to do this in <em class="italic">step 1</em> of <em class="italic">Exercise 1.05</em>, <em class="italic">Creating a Templates Directory and Base Template</em>, in <em class="italic">Chapter 1</em>, <em class="italic">Introduction to Django</em>.</li>
				<li>In PyCharm, right-click the <strong class="source-inline">landing</strong> directory in the <strong class="source-inline">Project</strong> pane and select <strong class="source-inline">New</strong> -&gt; <strong class="source-inline">Directory</strong>. </li>
				<li>Enter the name <strong class="source-inline">static</strong> and click <strong class="source-inline">OK</strong>:<div id="_idContainer197" class="IMG---Figure"><img src="image/B15509_05_05.jpg" alt="Figure 5.5: Naming the directory static&#13;&#10;"/></div><p class="figure-caption">Figure 5.5: Naming the directory static</p></li>
				<li>Right-click the <strong class="source-inline">static</strong> directory you just created and select <strong class="source-inline">New</strong> -&gt; <strong class="source-inline">Directory</strong> again. </li>
				<li>Enter the name <strong class="source-inline">landing</strong> and click <strong class="source-inline">OK</strong>. This is to implement namespacing of the static files directory as we discussed earlier:<div id="_idContainer198" class="IMG---Figure"><img src="image/B15509_05_06.jpg" alt="Figure 5.6: Naming the new directory landing, to implement namespacing&#13;&#10;"/></div><p class="figure-caption">Figure 5.6: Naming the new directory landing, to implement namespacing</p></li>
				<li>Download <strong class="source-inline">logo.png</strong> from <a href="https://packt.live/2KM6kfT">https://packt.live/2KM6kfT</a> and move it into the <strong class="source-inline">landing/static/landing</strong> directory.</li>
				<li>Start the Django dev server, if it is not already running, then navigate to <strong class="source-inline">http://127.0.0.1:8000/static/landing/logo.png</strong>. You should see the image being served in your browser:<div id="_idContainer199" class="IMG---Figure"><img src="image/B15509_05_07.jpg" alt="Figure 5.7: Image served by Django&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 5.7: Image served by Django</p>
			<p>If you see the image as in <em class="italic">Figure 5.7</em>, you have set up static file serving correctly. Now let us look at how to automatically insert this URL into your HTML code.</p>
			<h2 id="_idParaDest-177"><a id="_idTextAnchor181"/>Generating Static URLs with the static Template Tag</h2>
			<p>In <em class="italic">Exercise 5.01</em>, <em class="italic">Serving a File from an App Directory</em>, you set up an image file to be served by Django. You saw that the URL of the image was <strong class="source-inline">http://127.0.0.1:8000/static/landing/logo.png</strong>, which you could use inside an HTML template. For example, to display the image with an <strong class="source-inline">img</strong> tag, you could use this code in your template:</p>
			<p class="source-code">&lt;img src="http://127.0.0.1:8000/static/landing/logo.png"&gt;</p>
			<p>Or, since Django is also serving the media and has the same host as the dynamic template response, you can simplify this by just including the path, as follows:</p>
			<p class="source-code">&lt;img src="/static/landing/logo.png"&gt;</p>
			<p>Both addresses (URLs and paths) have been hardcoded into the template; that is, we include the full path to the static file and make assumptions about where the file is being hosted. This works fine with the Django dev server or if you host your static files and Django website on the same domain. For more performance as your site becomes more popular, you might consider serving static files from their own domain or <strong class="bold">Content Delivery Network</strong> (<strong class="bold">CDN</strong>).</p>
			<p class="callout-heading">Note</p>
			<p class="callout">A <strong class="bold">CDN</strong> is a service that can host parts or all of your website for you. They provide several web servers and can seamlessly speed up the loading of your website. For example, they might serve files to a user from the server that is geographically closest to them. There are several CDN providers, and depending on how they are set up, they might require you to specify a certain domain from which to serve your static files.</p>
			<p>Take, for instance, a common separation approach: using a different domain for static file serving. You host your main website at <strong class="source-inline">https://www.example.com</strong> but want to serve static files from <strong class="source-inline">https://static.example.com</strong>. During development, we could use just the path to the logo file as in the example we just saw. But when we deploy to the production server, our URLs would need to change to include the domain, like so:</p>
			<p class="source-code">&lt;img src="https://static.example.com/landing/logo.png"&gt;</p>
			<p>Since all the links are hardcoded, this would need to be done for every URL throughout our templates, every time we deploy to production. Once they were changed, though, the URL would no longer work in the Django dev server. Luckily, Django provides a solution to this problem.</p>
			<p>The <strong class="source-inline">staticfiles</strong> app provides a template tag, <strong class="source-inline">static</strong>, to dynamically generate the URL to a static file inside a template. Since the URLs are all being dynamically generated, we can change the URL for all of them by changing just one setting (<strong class="source-inline">STATIC_URL</strong> in <strong class="source-inline">settings.py</strong> – more on this soon). Furthermore, later we will introduce a method of invalidating browser caches for static files that relies on the use of the <strong class="source-inline">static</strong> template tag.</p>
			<p>The <strong class="source-inline">static</strong> tag is very simple: it takes a single argument, which is the project-relative path to a static asset. It will then output this path prepended with the <strong class="source-inline">STATIC_URL</strong> setting. It must<a id="_idTextAnchor182"/> first be loaded into the template with the <strong class="source-inline">{% load static %}</strong> template tag. </p>
			<p>Django has a set of default template tags and filters (or tag sets) that it automatically makes available to every template. Django (and third-party libraries) also provides tag sets that are not automatically loaded. In these cases, we need to load these extra template tags and filters into a template before we can use them. This is done with the use of the <strong class="source-inline">load</strong> template tag, which should come near the start of a template (although it must be after the <strong class="source-inline">extends</strong> template tag, if one is used). The <strong class="source-inline">load</strong> template tag takes one or more packages/libraries to load, for example:</p>
			<p class="source-code">{% load package_one package_two package_three %}</p>
			<p>This would load the template tag and filters set provided by the (made-up) <strong class="source-inline">package_one</strong>, <strong class="source-inline">package_two</strong>, and <strong class="source-inline">package_three</strong> packages.</p>
			<p>The <strong class="source-inline">load</strong> template tag must be used in the actual template that requires the loaded package. In other words, if your template extends another template and that base template has loaded a certain package, your dependent template does not automatically have access to that package. Your template must still <strong class="source-inline">load</strong> the package to access the new tag set. The <strong class="source-inline">static</strong> template tag is not part of the default set, which is why we need to load it.</p>
			<p>Then, it can be used to interpolate anywhere inside the template file. For example, by default, Django uses <strong class="source-inline">/static/</strong> as <strong class="source-inline">STATIC_URL</strong>. If we wanted to generate the static URL for our <strong class="source-inline">logo.png</strong> file, we would use the tag in a template like this:</p>
			<p class="source-code">{% stat<a id="_idTextAnchor183"/>ic landing/logo.png' %}</p>
			<p>The output inside the template would be this:</p>
			<p class="source-code">/static/landing/logo.png</p>
			<p>This would be made clearer with an example, so let's look at how the <strong class="source-inline">static</strong> tag could be used to generate a URL for a number of different assets. </p>
			<p>We can include the logo as an image on the page with an <strong class="source-inline">img</strong> tag, as follows:</p>
			<p class="source-code">&lt;img src="{% static 'landing/logo.png' %}"&gt;</p>
			<p>This is rendered in the template as follows:</p>
			<p class="source-code">&lt;img src="/static/landing/logo.png"&gt;</p>
			<p>Or we could use the <strong class="source-inline">static</strong> tag to generate the URL for a linked CSS file, as follows:</p>
			<p class="source-code">&lt;link href="{% static 'path/to/file.css' %}" </p>
			<p class="source-code">            rel="stylesheet"&gt;</p>
			<p>This will be rendered as this:</p>
			<p class="source-code">&lt;link href="/static/path/to/file.css" </p>
			<p class="source-code">            rel="stylesheet"&gt;</p>
			<p>It can be used in a <strong class="source-inline">script</strong> tag to include a JavaScript file, using the following line of code:</p>
			<p class="source-code">&lt;script src="{% static 'path/to/file.js' %}"&gt;</p>
			<p class="source-code">    &lt;/script&gt;</p>
			<p>This is rendered as this:</p>
			<p class="source-code">&lt;script src="/static/path/to/file.js"&gt;&lt;/script&gt;</p>
			<p>We can even use it to generate a link to a static file for download:</p>
			<p class="source-code">&lt;a href="{% static 'path/to/document.pdf' %}"&gt;</p>
			<p class="source-code">    Download PDF&lt;/a&gt;</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Note that this won't generate the actual PDF content; it will just create a link to an already-existing file.</p>
			<p>This is rendered as follows:</p>
			<p class="source-code">&lt;a href="/static/path/to/document.pdf"&gt;</p>
			<p class="source-code">    Download PDF&lt;/a&gt;</p>
			<p>Referring to these examples, we can now demonstrate the advantage of using the <strong class="source-inline">static</strong> tag instead of hardcoding. When we are ready to deploy to production, we can just change the <strong class="source-inline">STATIC_URL</strong> value in <strong class="source-inline">settings.py</strong>. None of the values in the templates need to be changed.</p>
			<p>For example, we can change <strong class="source-inline">STATIC_URL</strong> to <strong class="source-inline">https://static.example.com/</strong>, and then when the page next gets rendered, the examples we've seen will automatically update as follows.</p>
			<p>The following line shows this for the image:</p>
			<p class="source-code">&lt;img src="https://static.example.com/landing/logo.png"&gt;</p>
			<p>The following is for the CSS link:</p>
			<p class="source-code">&lt;link href=</p>
			<p class="source-code">    "https://static.example.com/path/to/files.css" </p>
			<p class="source-code">    rel="stylesheet"&gt;</p>
			<p>For the script, it's as follows:</p>
			<p class="source-code">&lt;script src="</p>
			<p class="source-code">    https://static.example.com/path/to/file.js"&gt;</p>
			<p class="source-code">    &lt;/script&gt;</p>
			<p>And finally, the following is for the link:</p>
			<p class="source-code">&lt;a href="</p>
			<p class="source-code">    https://static.example.com/path/to/document.pdf"&gt;</p>
			<p class="source-code">    Download PDF&lt;/a&gt;</p>
			<p>Note that in all these examples, a literal string is being passed as an argument (it is quoted). You can also use a variable as an argument. For example, say you were rendering a template with a context such as in this example code:</p>
			<p class="source-code">def view_function(request):</p>
			<p class="source-code">    context = {"image_file": "logofile.png"}</p>
			<p class="source-code">    return render(request, "example.html", context)</p>
			<p>We are rendering the <strong class="source-inline">example.html</strong> template with an <strong class="source-inline">image_file</strong> variable. This variable has the value <strong class="source-inline">logo.png</strong>.</p>
			<p>You would pass this variable to the <strong class="source-inline">static</strong> tag without quotes:</p>
			<p class="source-code">&lt;img src="{% static image_file %}"&gt;</p>
			<p>It would render like this (assuming we changed <strong class="source-inline">STATIC_URL</strong> back to <strong class="source-inline">/static/</strong>):</p>
			<p class="source-code">&lt;img src="/static/logo.png"&gt;</p>
			<p>The template tag can also be used with the <strong class="source-inline">as [variable]</strong> suffix to assign the result to a variable for use later in the template. This can be useful if the static file lookup takes a long time and you want to refer to the same static file multiple times (like when including an image in multiple places).</p>
			<p>The first time you refer to the static URL, give it a variable name to assign to. In this case, we are creating the <strong class="source-inline">logo_path</strong> variable:</p>
			<p class="source-code">&lt;img src="{% static 'logo.png' as logo_path %}"&gt;</p>
			<p>This renders the same as the examples we've seen before:</p>
			<p class="source-code">&lt;img src="/static/logo.png"&gt;</p>
			<p>However, we can then use the assigned variable (<strong class="source-inline">logo_path</strong>) again later in the template:</p>
			<p class="source-code">&lt;img src="{{ logo_path }}"&gt;</p>
			<p>That renders the same again:</p>
			<p class="source-code">&lt;img src="/static/logo.png"&gt;</p>
			<p>This variable is now just a normal context variable in the template scope and can be used anywhere in the template. Be careful, though, as you might override a variable that has already been defined – although this a general warning when using any of the template tags that assign variables (for example, <strong class="source-inline">{% with %}</strong>).</p>
			<p>In the next exercise, we will put the <strong class="source-inline">static</strong> template into practice to add the Bookr reviews logo to the Bookr site.</p>
			<h2 id="_idParaDest-178"><a id="_idTextAnchor184"/>Exercise 5.02: Using the static Template Tag</h2>
			<p>In <em class="italic">Exercise 5.01</em>, <em class="italic">Serving a File from an App Directory</em>, you tested serving the <strong class="source-inline">logo.png</strong> file from the static directory. In this exercise, you will continue with the business site project and create an <strong class="source-inline">index.html</strong> file as the template for our landing page. Then you'll include the logo inside this page, using the {<strong class="source-inline">% static %</strong>} template tag:</p>
			<ol>
				<li value="1">In PyCharm (make sure you're in the <strong class="source-inline">business_site</strong> project), right-click the <strong class="source-inline">business_site</strong> project directory and create a new folder called <strong class="source-inline">templates</strong>. Right-click this directory and select <strong class="source-inline">New</strong> -&gt; <strong class="source-inline">HTML File</strong>. Select <strong class="source-inline">HTML 5 file</strong> and name it <strong class="source-inline">index.html</strong>:<div id="_idContainer200" class="IMG---Figure"><img src="image/B15509_05_08.jpg" alt="Figure 5.8: new index.html&#13;&#10;"/></div><p class="figure-caption">Figure 5.8: new index.html</p></li>
				<li><strong class="source-inline">index.html</strong> will open. First, load the <strong class="source-inline">static</strong> tag library to make the <strong class="source-inline">static</strong> tag available in the template. Do this with the <strong class="source-inline">load</strong> template tag. On the second line of the file (just after the <strong class="source-inline">&lt;!DOCTYPE html&gt;</strong>), add this line to load the static library:<p class="source-code">{% load static %}</p></li>
				<li>You can also make the template a bit nicer with some extra content. Enter the text <strong class="source-inline">Business Site</strong> inside the <strong class="source-inline">&lt;title&gt;</strong> tags: <p class="source-code">&lt;title&gt;Business Site&lt;/title&gt;</p><p>Then, inside the body, add an <strong class="source-inline">&lt;h1&gt;</strong> element with the text <strong class="source-inline">Welcome to my Business Site</strong>:</p><p class="source-code">&lt;h1&gt;Welcome to my Business Site&lt;/h1&gt;</p></li>
				<li>Underneath the heading text, use the <strong class="source-inline">{% static %}</strong> template tag to set the source of <strong class="source-inline">&lt;img&gt;</strong>. You will use it to refer to the logo from <em class="italic">Exercise 5.01</em>, <em class="italic">Serving a File from an App Directory</em>:<p class="source-code">&lt;img src="{% static 'landing/logo.png' %}"&gt;</p></li>
				<li>Finally, to flesh out the site a bit, add a <strong class="source-inline">&lt;p&gt;</strong> element under <strong class="source-inline">&lt;img&gt;</strong>. Give it some text about the business:<p class="source-code">&lt;p&gt;Welcome to the site for my Business. </p><p class="source-code">    For all your Business needs!&lt;/p&gt;</p><p>Although the extra text and title are not too important, they give an idea of how to use the <strong class="source-inline">{% static %</strong>} template tag around the rest of the content. Save the file. It should look like this once complete: <a href="http://packt.live/37RUVnE">http://packt.live/37RUVnE</a>. </p></li>
				<li>Next, set up a URL to use to render the template. You will also use the built-in <strong class="source-inline">TemplateView</strong> to render the template without having to create a view. Open <strong class="source-inline">urls.py</strong> in the <strong class="source-inline">business_site</strong> package directory. At the start of the file, import <strong class="source-inline">TemplateView</strong> as follows:<p class="source-code">from django.views.generic import TemplateView</p><p>You can also remove this Django admin import line since we're not using it in this project:</p><p class="source-code">from django.contrib import admin</p></li>
				<li>Add a URL map from <strong class="source-inline">/</strong> to a <strong class="source-inline">TemplateView</strong>. The <strong class="source-inline">as_view</strong> method of <strong class="source-inline">TemplateView</strong> takes <strong class="source-inline">template_name</strong> as an argument, which is used in the same way as a path that you might pass to the <strong class="source-inline">render</strong> function. Your <strong class="source-inline">urlpatterns</strong> should look like this:<p class="source-code">urlpatterns = [path('', TemplateView.as_view\</p><p class="source-code">                        (template_name='index.html')),]</p><p>Save the <strong class="source-inline">urls.py</strong> file. Once complete, it should look like this: <a href="http://packt.live/2KLTrlY">http://packt.live/2KLTrlY</a>. </p></li>
				<li>Since we're not using the <strong class="source-inline">landing</strong> app template directory to store this template, you need to tell Django to use the <strong class="source-inline">templates</strong> directory you created in <em class="italic">step 1</em>. Do this by adding the directory to the <strong class="source-inline">TEMPLATES['DIRS']</strong> list in <strong class="source-inline">settings.py</strong>.<p>Open <strong class="source-inline">settings.py</strong> in the <strong class="source-inline">business_site</strong> directory. Scroll down until you find the <strong class="source-inline">TEMPLATES</strong> setting. It will look like this:</p><p class="source-code">TEMPLATES = \</p><p class="source-code">[{'BACKEND': 'django.template.backends.django.DjangoTemplates',\</p><p class="source-code">  'DIRS': [],\</p><p class="source-code">  'APP_DIRS': True,\</p><p class="source-code">  'OPTIONS': {'context_processors': \</p><p class="source-code">              ['django.template.context_processors.debug',\</p><p class="source-code">               'django.template.context_processors.request',\</p><p class="source-code">               'django.contrib.auth.context_processors.auth',\</p><p class="source-code">               'django.contrib.messages.context_processors\</p><p class="source-code">               .messages',\</p><p class="source-code">     ],\</p><p class="source-code">  },\</p><p class="source-code">},]</p><p>Add <strong class="source-inline">os.path.join(BASE_DIR, 'templates')</strong> into the <strong class="source-inline">DIRS</strong> setting, so the <strong class="source-inline">TEMPLATES</strong> setting looks like this:</p><p class="source-code">TEMPLATES = \</p><p class="source-code">[{'BACKEND': 'django.template.backends.django.DjangoTemplates',\</p><p class="source-code">  <strong class="bold">'DIRS': [os.path.join(BASE_DIR, 'templates')],\</strong></p><p class="source-code">  'APP_DIRS': True,\</p><p class="source-code">  'OPTIONS': {'context_processors': \</p><p class="source-code">              ['django.template.context_processors.debug',\</p><p class="source-code">               'django.template.context_processors.request',\</p><p class="source-code">               'django.contrib.auth.context_processors.auth',\</p><p class="source-code">               'django.contrib.messages.context_processors\</p><p class="source-code">               .messages',\</p><p class="source-code">      ],\</p><p class="source-code">    },\</p><p class="source-code">  },]</p><p>Depending on the version of Django you have, it might not be importing the <strong class="source-inline">os</strong> module in <strong class="source-inline">settings.py</strong>. To fix this, at the top of the <strong class="source-inline">settings.py</strong> file, just add this line:</p><p class="source-code">import os</p><p>Save and close <strong class="source-inline">settings.py</strong>. It should look like this: <a href="http://packt.live/3pz4rlo">http://packt.live/3pz4rlo</a>. </p></li>
				<li>Start the Django dev server, if it's not already running. Navigate to <strong class="source-inline">http://127.0.0.1:8000/</strong> in your browser. You should see your new landing page as in <em class="italic">Figure 5.9</em>:<div id="_idContainer201" class="IMG---Figure"><img src="image/B15509_05_09.jpg" alt="Figure 5.9: The site with the logo&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 5.9: The site with the logo</p>
			<p>In this exercise, we added a base template for <strong class="source-inline">landing</strong> and loaded the static library into the template. Once the static library was loaded, we were able to use the <strong class="source-inline">static</strong> template tag to load an image. We then were able to see our business logo rendered in the browser.</p>
			<p>All of the static file loading has so far used <strong class="source-inline">AppDirectoriesFinder</strong>, because it required no extra configuration to use it. In the next section, we will look at <strong class="source-inline">FileSystemFinder</strong>, which is more flexible but requires a small amount of configuration to use it.</p>
			<h2 id="_idParaDest-179"><a id="_idTextAnchor185"/>FileSystemFinder </h2>
			<p>We've learned about <strong class="source-inline">AppDirectoriesFinder</strong>, which loads static files inside Django app directories. However, well-designed apps should be self-contained and therefore should only contain static files that they themselves rely on. If we have other static files that are used throughout the website or across different apps, we should store them outside the app directory.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">As a general rule, your CSS is probably consistent throughout your site and could be kept in a global directory. Some images and JavaScript code could be specific to apps, so these would be stored in the static directory for that application. This is just general advice, though: you can store static files anywhere that makes the most sense for your project.</p>
			<p>In our business site application, we will be storing a CSS file in a site static directory, as it will be used not only in the <strong class="source-inline">landing</strong> app but throughout the site as we add more apps.</p>
			<p>Django provides support for serving static files from arbitrary directories using its <strong class="source-inline">FileSystemFinder</strong> static file finder. The directories can be anywhere on the disk. Usually, you will have a <strong class="source-inline">static</strong> directory inside your project directory, but if your company has a global static directory that is used in many different projects (including non-Django web applications), then you could use this as well.</p>
			<p><strong class="source-inline">FileSystemFinder</strong> uses the <strong class="source-inline">STATICFILES_DIRS</strong> setting in the <strong class="source-inline">settings.py</strong> file to determine which directories to search for static files in. This is not present when the project is created and must be set by the developer. We will add it in the next exercise. There are two options for building this list:</p>
			<ul>
				<li>Setting a list of directories</li>
				<li>Setting a list of tuples in the form <strong class="source-inline">(prefix, directory)</strong></li>
			</ul>
			<p>The second use case will be easier to understand once we have covered some more of the fundamentals, so we will return to it after explaining and demonstrating the first case. It is covered after <em class="italic">Exercise 5.04</em>, <em class="italic">Collecting Static Files for Production</em>, in the <em class="italic">STATICFILES_DIRS Prefixed Mode</em> section. For now, we will just explain the first use case, which is just a list of one or more directories.</p>
			<p>In <strong class="source-inline">business_site</strong>, we will add a <strong class="source-inline">static</strong> directory inside the project directory (that is, in the same directory that contains the <strong class="source-inline">landing</strong> app and the <strong class="source-inline">manage.py</strong> file). We can use the <strong class="source-inline">BASE_DIR</strong> setting when building the list to assign to <strong class="source-inline">STATICFILES_DIRS</strong>:</p>
			<p class="source-code">STATICFILES_DIRS = [os.path.join(BASE_DIR, 'static')]</p>
			<p>We also mentioned earlier in this section that you might want to set multiple directory paths in this list, for example, if you had some company-wide static data shared by multiple web projects. Simply add extra directories to the <strong class="source-inline">STATICFILES_DIRS</strong> list:</p>
			<p class="source-code">STATICFILE<a id="_idTextAnchor186"/>S_DIRS = [os.path.join(BASE_DIR, 'static'), \</p>
			<p class="source-code">                    '/Users/username/projects/company-static/']</p>
			<p>Each of these directories would be checked in order to find a matching file. If a file existed in both directories, the first one found would be served. For example, if the <strong class="source-inline">static/main.css</strong> (inside the <strong class="source-inline">business_site</strong> project directory) and <strong class="source-inline">/Users/username/projects/company-static/bar/main.css</strong> files both existed, a request for <strong class="source-inline">/static/main.css</strong> would serve the <strong class="source-inline">business_site</strong> project's <strong class="source-inline">main.css</strong> as it is first in the list. Keep this in mind when deciding the order in which you add directories to <strong class="source-inline">STATICFILES_DIRS</strong>; you may choose to prioritize your project static files over the global ones or vice versa.</p>
			<p>In our business site (and later with Bookr), we will only use one <strong class="source-inline">static</strong> directory in this list, so we won't have to worry about this problem.</p>
			<p>In the next exercise, we will add a <strong class="source-inline">static</strong> directory with a CSS file inside. Then we will configure the <strong class="source-inline">STATICFILES_DIRS</strong> setting to serve from the <strong class="source-inline">static</strong> directory.</p>
			<h2 id="_idParaDest-180"><a id="_idTextAnchor187"/>Exercise 5.03: Serving from a Project static Directory</h2>
			<p>We have already shown an example of serving an application-specific image file in <em class="italic">Exercise 5.01</em>, <em class="italic">Serving a File from an App Directory</em>. Now we want to serve a CSS file that is to be used throughout our project to set styles, so we will serve this from a static directory right inside the project folder.</p>
			<p>In this exercise, you'll set up your project to serve static files from a specific directory, and then use the <strong class="source-inline">{% static %}</strong> template tag again to include it in the template. This will be done using the <strong class="source-inline">business_site</strong> example project:</p>
			<ol>
				<li value="1">Open the <strong class="source-inline">business_site</strong> project in In PyCharm, if it's not already open. Then, right-click the <strong class="source-inline">business_site</strong> project directory (the top-level <strong class="source-inline">business_site</strong> directory, not the <strong class="source-inline">business_site</strong> package directory) and select <strong class="source-inline">New</strong> -&gt; <strong class="source-inline">Directory</strong>.</li>
				<li>In the <strong class="source-inline">New Directory</strong> dialog, enter <strong class="source-inline">static</strong> and then click <strong class="source-inline">OK</strong>.</li>
				<li>Right-click the <strong class="source-inline">static</strong> directory you just created and select <strong class="source-inline">New</strong> -&gt; <strong class="source-inline">File</strong>. </li>
				<li>In the <strong class="source-inline">Name New File</strong> dialog, enter <strong class="source-inline">main.css</strong> and click <strong class="source-inline">OK</strong>. </li>
				<li>The blank <strong class="source-inline">main.css</strong> file should open automatically. Enter a couple of simple CSS rules, to center the text, and set a font and background color. Enter this text into the <strong class="source-inline">main.css</strong> file:<p class="source-code">body {</p><p class="source-code">    font-family: Arial, sans-serif;</p><p class="source-code">    text-align: center;</p><p class="source-code">    background-color: #f0f0f0;</p><p class="source-code">}</p><p>You can now save and class <strong class="source-inline">main.css</strong>. You can take a look at the complete file for reference: <a href="http://packt.live/38H8a9N">http://packt.live/38H8a9N</a>. </p></li>
				<li>Open <strong class="source-inline">business_site/settings.py</strong>. Here, set a list of directories to the <strong class="source-inline">STATICFILES_DIRS</strong> settings. In this case, the list will have just one item. Define a new <strong class="source-inline">STATICFILES_DIRS</strong> variable at the bottom of <strong class="source-inline">settings.py</strong>, using this code:<p class="source-code">STATICFILES_DIRS = [os.path.join(BASE_DIR, 'static')]</p><p>In the <strong class="source-inline">settings.py</strong> file, <strong class="source-inline">BASE_DIR</strong> is a variable that contains the path to the project directory. You can build the full path to the <strong class="source-inline">static</strong> directory you created in <em class="italic">step 2</em> by joining <strong class="source-inline">static</strong> to <strong class="source-inline">BASE_DIR</strong>. You then put this inside a list. The complete <strong class="source-inline">settings.py</strong> file should look like this: <a href="http://packt.live/3hnQQKW">http://packt.live/3hnQQKW</a>. </p></li>
				<li>Start the Django dev server if it is not running. You can verify that the settings are correct by checking whether you can load the <strong class="source-inline">main.css</strong> file. Note that this is not namespaced so the URL is  <strong class="source-inline">http://127.0.0.1:8000/static/main.css</strong>. Open this URL in your browser and check that the content matches what you just entered and saved:<div id="_idContainer202" class="IMG---Figure"><img src="image/B15509_05_10.jpg" alt="Figure 5.10: CSS served by Django&#13;&#10;"/></div><p class="figure-caption">Figure 5.10: CSS served by Django</p><p>If the file does not load, check your <strong class="source-inline">STATICFILES_DIRS</strong> settings. You may need to restart the Django dev server if it was running while you made changes to <strong class="source-inline">settings.py</strong>.</p></li>
				<li>You now need to include <strong class="source-inline">main.css</strong> in your index template. Open <strong class="source-inline">index.html</strong> in the <strong class="source-inline">templates</strong> folder. Before the closing <strong class="source-inline">&lt;/head&gt;</strong> tag, add this <strong class="source-inline">&lt;link&gt;</strong> tag to load the CSS:<p class="source-code">&lt;link rel="stylesheet" href="{% static 'main.css' %}"&gt;</p><p>This links in the <strong class="source-inline">main.css</strong> file, using the <strong class="source-inline">{% static %}</strong> template tag. As mentioned earlier, since <strong class="source-inline">main.css</strong> is not namespaced, you can just include its name. Save the file. It should look like this: <a href="http://packt.live/392aedP">http://packt.live/392aedP</a>. </p></li>
				<li>Load <strong class="source-inline">http://127.0.0.1:8000/</strong> in your browser and you should see the background color, fonts, and alignment all change:<div id="_idContainer203" class="IMG---Figure"><img src="image/B15509_05_11.jpg" alt="Figure 5.11: CSS applied with custom fonts visible&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 5.11: CSS applied with custom fonts visible</p>
			<p>Your business landing page should look like <em class="italic">Figure 5.11</em>. Since you included the CSS in the <strong class="source-inline">base.html</strong><em class="italic"> </em>template, it will be available in all templates that extend this template (although none do at the moment, it's good planning for the future).</p>
			<p>In this exercise, we put some CSS rules into their own file and served them using Django's <strong class="source-inline">FileSystemFinder</strong>. This was accomplished by creating a <strong class="source-inline">static</strong> directory inside the <strong class="source-inline">business_site</strong> project directory and specifying it in the Django settings (the <strong class="source-inline">settings.py</strong> file) using the <strong class="source-inline">STATICFILES_DIRS</strong> setting. We linked in the <strong class="source-inline">main.css</strong> file using the <strong class="source-inline">static</strong> template tag into the <strong class="source-inline">base.html</strong> template. We loaded the main page in our browser and saw that the font and color changes applied.</p>
			<p>We've now covered how static file finders are used during a request (to load a specific static file when given a URL). We'll now look at their other use case: finding and copying static files for production deployment, when running the <strong class="source-inline">collectstatic</strong> management command.</p>
			<h2 id="_idParaDest-181"><a id="_idTextAnchor188"/>Static File Finders: Use During collectstatic</h2>
			<p>Once we have finished working on our static files, they need to be moved into a specific directory that can be served by our production web server. We can then deploy our website by copying our Django code and static files to our production web server. In the case of <strong class="source-inline">business_site</strong>, we will want to move <strong class="source-inline">logo.png</strong> and <strong class="source-inline">main.css</strong> (along with other static files that Django itself includes) into a single directory that can be copied to the production web server. This is the role of the <strong class="source-inline">collectstatic</strong> management command.</p>
			<p>We have already discussed how Django uses static file finders during request handling. Now, we will cover the other use case: collecting static files for deployment. Upon running the <strong class="source-inline">collectstatic</strong> management command, Django uses each finder to list static files on the disk. Every static file that is found is then copied into the <strong class="source-inline">STATIC_ROOT</strong> directory (also defined in <strong class="source-inline">settings.py</strong>). This is a little bit like the reverse of handling a request. Instead of getting a URL path and mapping to a filesystem path, the filesystem path is being copied to a location that is predictable by the frontend web server. This allows the frontend web server to handle a request for a static file independently of Django.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">A frontend web server is designed to route requests to applications (like Django) or read static files from disk. It can handle requests faster but is not able to generate dynamic content in the same way as something like Django. Frontend web servers include software such as Apache HTTPD, Nginx, and lighttpd.</p>
			<p>For some specific examples of how <strong class="source-inline">collectstatic</strong> works, we'll use the two files from <em class="italic">Exercise 5.01</em>,<em class="italic"> Serving a File from an App Directory</em>, and <em class="italic">Exercise 5.03</em>, <em class="italic">Serving from a Project Status Directory</em>, respectively: <strong class="source-inline">landing/static/landing/logo.png</strong> and <strong class="source-inline">static/main.css</strong>. </p>
			<p>Assume that <strong class="source-inline">STATIC_ROOT</strong> is set to a directory being served by a normal web server – this would be something like <strong class="source-inline">/var/www/business_site/static</strong>. The destination for these files would be <strong class="source-inline">/var/www/business_site/static/reviews/logo.png</strong> and <strong class="source-inline">/var/www/business_site/static/main.css</strong>, respectively.</p>
			<p>Now when a request for a static file comes in, the web server will easily be able to serve it because the paths are mapped consistently:</p>
			<ul>
				<li><strong class="source-inline">/static/main.css</strong> is served from the <strong class="source-inline">/var/www/business_site/static/main.css</strong> file.</li>
				<li><strong class="source-inline">/static/reviews/logo.png</strong> is served from the <strong class="source-inline">/var/www/business_site/static/reviews/logo.png</strong> file.</li>
			</ul>
			<p>This means the web server root is <strong class="source-inline">/var/www/business_site/</strong> and static paths are just loaded directory from disk in the usual manner that a web server would load files.</p>
			<p>We have demonstrated how Django locates static files during development and can serve them itself. In production, we need the frontend web server to be able to serve static files without involving Django, for both safety and speed.</p>
			<p>Without having run <strong class="source-inline">collectstatic</strong>, a web server would not be able to map a URL back to a path. For example, it would not know that <strong class="source-inline">main.css</strong> must be loaded from the project static directory while <strong class="source-inline">logo.png</strong> is to be loaded from the <strong class="source-inline">landing</strong> app directory – it has no concept of the Django directory layout.</p>
			<p>You might be tempted to serve files directly from the Django project directory by setting your web server root to this directory – do not do this. There is a security risk in sharing your entire Django project directory as it would make it possible to download our <strong class="source-inline">settings.py</strong> or other sensitive files. Running <strong class="source-inline">collectstatic</strong> will copy the files to a directory that can be moved outside the Django project directory to the web server root for security.</p>
			<p>So far, we have talked about using Django to copy static files directly to the web server root. You could also have Django copy them to an intermediary directory and have your deployment process move to a CDN or another server afterward. We will not go into detail on specific deployment processes; how you choose to copy static files to the web server will depend on yours or your company's existing setup (for example, a continuous delivery pipeline).</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The <strong class="source-inline">collectstatic</strong> command does not take into consideration the use of <strong class="source-inline">static</strong> template tags. It will collect all the static files inside <strong class="source-inline">static</strong> directories, even those that your project does not include inside a template.</p>
			<p>In the next exercise, we will see the <strong class="source-inline">collectstatic</strong> command in action. We will use it to copy all the <strong class="source-inline">business_site</strong> static files that we have so far into a temporary directory.</p>
			<h2 id="_idParaDest-182"><a id="_idTextAnchor189"/>Exercise 5.04: Collecting Static Files for Production</h2>
			<p>While we won't be covering deployment to a web server in this chapter, we can still use the <strong class="source-inline">collectstatic</strong> management command and see its result. In this exercise, we will create a temporary holding location for the static files to be copied into. This directory will be called <strong class="source-inline">static_prod<a id="_idTextAnchor190"/>uction_test</strong> and will be located inside the <strong class="source-inline">business_site</strong> project directory. As part of the deployment process, you could copy this directory to your production web server. However, since we won't be setting up a web server until <em class="italic">Chapter 17</em>, <em class="italic">Deployment of a Django Application (Part 1 – Server Setup)</em>, we will just examine its contents to understand how files are copied and organized:</p>
			<ol>
				<li value="1">In PyCharm, create a temporary directory to put the collected files in. Right-click the <strong class="source-inline">business_site</strong> project directory (this is the top-level folder, not the <strong class="source-inline">business_site</strong> module) and select <strong class="source-inline">New</strong> -&gt; <strong class="source-inline">Directory</strong>.</li>
				<li>In the <strong class="source-inline">New Directory</strong> dialog, enter the name <strong class="source-inline">static_production_test</strong> and click <strong class="source-inline">OK</strong>.</li>
				<li>Open <strong class="source-inline">settings.py</strong> and at the bottom of the file, define a new setting for <strong class="source-inline">STATIC_ROOT</strong>. Set it to the path of the directory you just created:<p class="source-code">STATIC_ROOT<a id="_idTextAnchor191"/> = os.path.join(BASE_DIR, 'static_production_test')</p><p>This will join <strong class="source-inline">static_dir</strong> to <strong class="source-inline">BASE_DIR</strong> (the business site project path) to generate the full path. Save the <strong class="source-inline">settings.py</strong> file. It should look like this: <a href="http://packt.live/2Jq59Cc">http://packt.live/2Jq59Cc</a>. </p></li>
				<li>In a terminal, run the <strong class="source-inline">collectstatic</strong> <strong class="source-inline">manage</strong> command:<p class="source-code">python3 manage.py collectstat<a id="_idTextAnchor192"/>ic</p><p>You should see output similar to the following:</p><p class="source-code">132 static files copied to \</p><p class="source-code">  '/Users/ben/business_site/static_production_test'.</p><p>This might seem like a lot if you were expecting it to copy just two files but remember that it will copy all the files for all installed apps. In this case, as you have the Django admin app installed, most of the 132 files are to support that.</p></li>
				<li>Let us look through the <strong class="source-inline">static_production_test</strong> directory to see what has been created. An expanded view of this directory (from the PyCharm project page) is shown in <em class="italic">Figure 5.12</em>, for reference. Yours should be similar.<div id="_idContainer204" class="IMG---Figure"><img src="image/B15509_05_12.jpg" alt="Figure 5.12: Destination directory of the collectstatic command&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 5.12: Destination directory of the collectstatic command</p>
			<p>You should notice three items inside:</p>
			<p><strong class="bold">The admin directory</strong>: This contains files from the Django admin app. If you look inside this, you'll see it has been organized into subfolders: <strong class="source-inline">css</strong>, <strong class="source-inline">fonts</strong>, <strong class="source-inline">img</strong>, and <strong class="source-inline">js</strong>.</p>
			<p><strong class="bold">The landing directory</strong>: This is the <strong class="source-inline">static</strong> directory from your landing app. Inside is the <strong class="source-inline">logo.png</strong> file. This directory has been created to match the namespacing of the directory that we created.</p>
			<p><strong class="bold">The main.css file</strong>: This is from your project <strong class="source-inline">static</strong> directory. Since you didn't place it inside a namespacing directory, this has been placed directly inside <strong class="source-inline">STATIC_ROOT</strong>.</p>
			<p>If you want, you can open up any of these files and verify that their content matches the files you have just been working on – they should do, as they are simply copies of the original files.</p>
			<p>In this exercise, we collected all the static files from <strong class="source-inline">business_site</strong> (including the <strong class="source-inline">admin</strong> static files that Django includes). They were copied into the directory defined by the <strong class="source-inline">STATIC_ROOT</strong> setting (<strong class="source-inline">static_production_test</strong> inside the <strong class="source-inline">business_site</strong> project directory). We saw that <strong class="source-inline">main.css</strong> was directly inside this folder but other static files were namespaced inside their app directories (<strong class="source-inline">admin</strong> and <strong class="source-inline">reviews</strong>). This folder could have been copied to a production web server to deploy our project.</p>
			<h2 id="_idParaDest-183"><a id="_idTextAnchor193"/>STATICFILES_DIRS Prefixed Mode</h2>
			<p>As mentioned earlier, the <strong class="source-inline">STATICFILES_DIRS</strong> setting also accepts items as tuples in the form <strong class="source-inline">(prefix, directory)</strong>. These modes of operation are not mutually exclusive, <strong class="source-inline">STATICFILES_DIRS</strong> may contain both non-prefixed (string) or prefixed (tuple) items. Essenti<a id="_idTextAnchor194"/>ally, this allows you to map a certain URL prefix to a directory. In Bookr, we do not have enough static assets to warrant setting this up, but it can be useful if you want to organize your static assets differently. For example, you can keep all your images in a certain directory, and all your CSS in another directory. You might need to do this if you use a third-party CSS generation tool such as Node.js with <strong class="bold">LESS</strong>.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">LESS is a CSS pre-processor that uses Node.js. It allows you to write CSS using variables and other programming-like concepts that don't exist natively. Node.js will then compile this to CSS. A more in-depth explanation is outside the scope of this book – suffice to say that if you use it (or a similar tool), then you might want to serve directly from the directory to which it saves its compiled output.</p>
			<p>The easiest way to explain how prefixed mode works is with a short example. This will expand on the <strong class="source-inline">STATICFILES_DIRS</strong> setting created in <em class="italic">Exercise 5.03</em>, <em class="italic">Serving from a Project Static Directory</em>. In this example, two prefixed directories are added to this setting, one for serving images and one for serving CSS:</p>
			<p class="source-code">STATICFILES_DIRS = [os.path.join(BASE_DIR, 'static'),\</p>
			<p class="source-code">                    ('images', os.path.join\</p>
			<p class="source-code">                               (BASE_DIR, 'static_images')),\</p>
			<p class="source-code">                    ('css', os.path.join(BASE_DIR, 'static_css'))]</p>
			<p>As well as the <strong class="source-inline">static</strong> directory that was already being served with no prefix, we have added the serving of the <strong class="source-inline">static_images</strong> directory inside the <strong class="source-inline">business_site</strong> project directory. This has the prefix <strong class="source-inline">images</strong>. We have also added the serving of the <strong class="source-inline">static_css</strong> directory inside the Bookr project directory, with the prefix <strong class="source-inline">css</strong>.</p>
			<p>Then we can serve three files, <strong class="source-inline">main.js</strong>, <strong class="source-inline">main.css</strong>, and <strong class="source-inline">main.jpg</strong>, from the <strong class="source-inline">static</strong>, <strong class="source-inline">static_css</strong>, and <strong class="source-inline">static_images</strong> directories, respectively. The directory layout would be as shown in <em class="italic">Figure 5.13</em>:</p>
			<div>
				<div id="_idContainer205" class="IMG---Figure">
					<img src="image/B15509_05_13.jpg" alt="Figure 5.13: Directories layout for use with prefixed URLs&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.13: Directories layout for use with prefixed URLs</p>
			<p>In terms of accessing these through URLs, the mapping is as shown in <em class="italic">Figure 5.14</em>:</p>
			<div>
				<div id="_idContainer206" class="IMG---Figure">
					<img src="image/B15509_05_14.jpg" alt="Figure 5.14: Mappings of URLs to files, based on the prefix &#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.14: Mappings of URLs to files, based on the prefix </p>
			<p>Django routes any static URL with a prefix to the directory that matches that prefix.</p>
			<p>When using the <strong class="source-inline">static</strong> template tag, use the prefix and filename, not the directory name. For example:</p>
			<p class="source-code">{% static 'images/main.jpg' %}</p>
			<p>When the static files are gathered using the <strong class="source-inline">collectstatic</strong> command, they are moved into a directory with the prefix name, inside <strong class="source-inline">STATIC_ROOT</strong>. The source paths and the target paths inside the <strong class="source-inline">STATIC_ROOT</strong> directory are shown in <em class="italic">Figure 5.15</em>:</p>
			<div>
				<div id="_idContainer207" class="IMG---Figure">
					<img src="image/B15509_05_15.jpg" alt="Figure 5.15: Mappings of paths in project directories to paths in STATIC_ROOT&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.15: Mappings of paths in project directories to paths in STATIC_ROOT</p>
			<p>Django creates the prefix directories inside <strong class="source-inline">STATIC_ROOT</strong>. Because of this, the paths can be kept consistent even when using a web server and not routing the URL lookup through Django.</p>
			<h2 id="_idParaDest-184"><a id="_idTextAnchor195"/>The findstatic Command</h2>
			<p>The <strong class="source-inline">staticfiles</strong> application also provides one more management command: <strong class="source-inline">findstatic</strong>. This command allows you to enter the relative path to a static file (the same as what would be used inside a <strong class="source-inline">static</strong> template tag) and Django will tell you where that file was located. It can also be used in a verbose mode to output the directories it is searching through.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">You may not be familiar with the concept of verbosity or verbose mode. Having a higher verbosity (or simply turning on verbose mode) will cause a command to generate more output. Many command-line applications can be executed with more or less verbosity. This can be helpful when trying to debug the programs you are using. To see an example of the verbose mode in action, you can try running the Python shell in verbose mode. Enter <strong class="source-inline">python -v</strong> (instead of just <strong class="source-inline">python</strong>) and hit <strong class="source-inline">Enter</strong>. Python will start in verbose mode and print out the path of every file it imports.</p>
			<p>This command is mostly useful for debugging/troubleshooting purposes. If the wrong file is loading, or a particular file cannot be found, you can use this command to try to find out why. The command will display which file on disk is being loaded for a specific path, or let you know that the file cannot be found and what directories were searched.</p>
			<p>This can help solve issues where multiple files have the same name, and the precedence is not what you expect. See the <em class="italic">FileSystemFinder</em> section for a note about precedence in the <strong class="source-inline">STATICFILES_DIRS</strong> setting. You might also see that Django is not searching in a directory you expect for the file, in which case the static directory might need to be added to the <strong class="source-inline">STATICFILES_DIRS</strong> setting.</p>
			<p>In the next exercise, you will execute the <strong class="source-inline">findstatic</strong> management command, so you are familiar with what some of the output is for good (file found correctly) and bad (file missing) scenarios.</p>
			<h2 id="_idParaDest-185"><a id="_idTextAnchor196"/>Exercise 5.05: Finding Files Using findstatic</h2>
			<p>You will now run the <strong class="source-inline">findstatic</strong> command with a variety of options and understand what its output means. First, we will use it to find a file that exists and see that it displays the path to the file. Then, we will try to find a file that does not exist and check the error that is output. We will then repeat this process with multiple levels of verbosity and different ways of interacting with the command. While this exercise will not make changes to or progress the Bookr project, it is good to be familiar with the command in case you need to use it when working on your own Django applications:</p>
			<ol>
				<li value="1">Open a terminal and navigate to the <strong class="source-inline">business_site</strong> project directory.</li>
				<li>Execute the <strong class="source-inline">findstatic</strong> command with no options. It will output some help explaining how it is used:<p class="source-code">python3 manage.py findstatic</p><p>The help output is displayed:</p><p class="source-code">usage: manage.py findstatic </p><p class="source-code">      [-h] [--first] [--version] [-v {0,1,2,3}]</p><p class="source-code">      [--settings SETTINGS] [--pythonpath PYTHONPATH]</p><p class="source-code">      [--traceback] [--no-color] [--force-color]</p><p class="source-code">      [--skip-checks]</p><p class="source-code">      staticfile [staticfile ...]</p><p class="source-code">manage.py findstatic: error: Enter at least one label.</p></li>
				<li>You can find one or more files at a time; let's start with the one that we know exists, <strong class="source-inline">main.css</strong>:<p class="source-code">python3 manage.py findstatic main.css</p><p>The command outputs the path at which <strong class="source-inline">main.css</strong> was found:</p><p class="source-code">Found 'main.css' here:</p><p class="source-code">  /Users/ben/business_site/static/main.css</p><p>Your full path will be different (unless you are also called Ben), but you can see that when Django locates <strong class="source-inline">main.css</strong> in a request it will load the <strong class="source-inline">main.css</strong> file from the project <strong class="source-inline">static</strong> directory.</p><p>This can be useful if a third-party application you have installed has not namespaced its static files correctly and is conflicting with one of your files.</p></li>
				<li>Let's try finding a file that does not exist, <strong class="source-inline">logo.png</strong>:<p class="source-code">python3 manage.py findstatic logo.png</p><p>Django displays an error saying that the file could not be found:</p><p class="source-code">No matching file found for 'logo.png'.</p><p>Django is unable to locate this file because we have namespaced it – we must include the full relative path, the same as we have used in the <strong class="source-inline">static</strong> template tag.</p></li>
				<li>Try finding <strong class="source-inline">logo.png</strong> again, but this time using the full path:<p class="source-code">python3 manage.py findstatic landing/logo.png</p><p>Django can find the file now:</p><p class="source-code">Found 'landing/logo.png' here:</p><p class="source-code">  /Users/ben/business_site/landing/static/landing/logo.png</p></li>
				<li>Finding multiple files at once is done by adding each file as an argument:<p class="source-code">python3 manage.py findstatic landing/logo.png missing-file.js main.css</p><p>The location status for each file is shown:</p><p class="source-code">No matching file found for 'missing-file.js'.</p><p class="source-code">Found 'landing/logo.png' here:</p><p class="source-code">  /Users/ben/business_site/landing/static/landing/logo.png</p><p class="source-code">Found 'main.css' here:</p><p class="source-code">  /Users/ben/business_site/static/main.css</p></li>
				<li>The command can be executed with a verbosity of <strong class="source-inline">0</strong>, <strong class="source-inline">1</strong>, or <strong class="source-inline">2</strong>. By default, it executes at verbosity <strong class="source-inline">1</strong>. To set the verbosity, use the<strong class="source-inline"> --verbosity</strong> or <strong class="source-inline">-v</strong> flag. Decrease the verbosity to <strong class="source-inline">0</strong> to only output the paths it locates without any extra information. No errors are displayed for missing paths:<p class="source-code">python3 manage.py findstatic -v0 landing/logo.png missing-file.js main.css</p><p>The output shows only found paths – notice no error is shown for the missing file, <strong class="source-inline">missing-file.js</strong>:</p><p class="source-code">/Users/ben/business_site/landing/static/landing/logo.png</p><p class="source-code">/Users/ben/business_site/static/main.css</p><p>This level of verbosity can be useful if you are piping the output to another file or command.</p></li>
				<li>To get more information about which directories Django is searching in for the file you have requested, increase the verbosity to <strong class="source-inline">2</strong>:<p class="source-code">python3 manage.py findstatic -v2 <a id="_idTextAnchor197"/>landing/logo.png missing-file.js main.css</p><p>The output contains much more information, including the directories that have been searched for the requested file. You can see that as the <strong class="source-inline">admin</strong> application is installed, Django is also searching in the Django admin application directory for static files:</p></li>
			</ol>
			<div>
				<div id="_idContainer208" class="IMG---Figure">
					<img src="image/B15509_05_16.jpg" alt="Figure 5.16: findstatic executed with verbosity 2, showing exactly &#13;&#10;which directories were searched&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.16: findstatic executed with verbosity 2, showing exactly which directories were searched</p>
			<p>The <strong class="source-inline">findstatic</strong> command is not something that you will use day to day when working with Django, but it is useful to know about when trying to troubleshoot problems with static files. We saw the command output the full path to a file that existed, as well as the error messages when files did not exist. We also ran the command and supplied multiple files at once and saw that information about all the files was output. Finally, we ran the command with different levels of verbosity. The <strong class="source-inline">-v0</strong> flag suppressed errors about missing files. <strong class="source-inline">-v1</strong> was the default and displayed found paths and errors. Increasing the verbosity using the <strong class="source-inline">-v2</strong> flag also printed out the directories that were being searched through for a particular static file.</p>
			<h2 id="_idParaDest-186"><a id="_idTextAnchor198"/>Serving the Latest Files (for Cache Invalidation)</h2>
			<p>If you are not familiar with caching, the basic idea is that some operations can take a long time to perform. We can speed up a system by storing the results of an operation in a place that is faster to access so that the next time we need them, they can be retrieved quickly. The operation that takes a long time can be anything – from a function that takes a long time to run or an image that takes a long time to render, to a large asset that takes a long time to download over the internet. We are most interested in this last scenario.</p>
			<p>You might have noticed that the first time you ever visit a particular website, it is slow to load, but then the next time it loads much faster. This is because your browser has cached some (or all) of the static files the site needs to load. </p>
			<p>To use our business site as an example, we have a page that includes the <strong class="source-inline">logo.png</strong> file. The first time we visit the business site, we have to download the dynamic HTML, which is small and quick to transfer. Our browser parses the HTML and sees that <strong class="source-inline">logo.png</strong> should be included. It can then download this file too, which is much larger and can take longer to download. Note that this scenario assumes that the business site is now hosted on a remote server and not on our local machine – which is very fast for us to access.</p>
			<p>If the web server is set up correctly, the browser will store <strong class="source-inline">logo.png</strong> on the computer. The next time we visit the <em class="italic">landing</em> page (or indeed any page that includes <strong class="source-inline">logo.png</strong>), your browser recognizes the URL can load the file from disk instead of having to download it again, thus speeding up the browsing experience.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">We said that the browser will cache "if the web server is set up correctly." What does this mean? The frontend web server should be configured to send special HTTP headers as part of a static file response. It can send a <strong class="source-inline">Cache-Control</strong> header, which can have values such as <strong class="source-inline">no-cache</strong> (the file should never be cached; in other words, the latest version should be requested every time) or <strong class="source-inline">max-age=&lt;seconds&gt;</strong> (the file should only be downloaded again if it was last retrieved more than <strong class="source-inline">&lt;seconds&gt;</strong> seconds ago). The response could also contain the <strong class="source-inline">Expires</strong> header, with the value being a date. The file is considered to be "stale" once this date is reached, and at that point, the new version should be requested.</p>
			<p>One of the hardest problems in computer science is cache invalidation. For instance, if we change <strong class="source-inline">logo.png</strong>, how does our browser know it should download the new version? The only surefire way of knowing it had changed would be to download the file again and compare it with the version we had already saved every time. Of course, this defeats the purpose of caching since we would still be downloading every time the file changed (or not). We can cache for an arbitrary or server-specified amount of time, but if the static file changed before that time was up, we would not know. We would use the old version until we considered it expired, at which time we would download the new version. If we had a 1-week expiry and the static file changed the next day, we would still be using the old one for 6 days. Of course, the browser can be made to reload the page without using the cache (how this is done depends on the browser, for example, <em class="italic">Shift</em> + <em class="italic">F5</em> or <em class="italic">Cmd</em> + <em class="italic">Shift</em> + <em class="italic">R</em>) if you want to force downloading of all static assets again.</p>
			<p>There is no need to try to cache our dynamic responses (rendered templates). Since they are designed to be dynamic, we would want to make sure that the user gets the latest version on every page load, and so they should not be cached. They are also quite small in size (compared to assets like images), so there is not much speed advantage when caching them.</p>
			<p>Django provides a built-in solution. During the <strong class="source-inline">collectstatic</strong> phase, when the files are copied, Django can append a hash of their content to the filename. For example, the <strong class="source-inline">logo.png</strong> source file will be copied to <strong class="source-inline">static_production_test/landing/logo.f30ba08c60ba.png</strong>. This is only done when using the <strong class="source-inline">ManifestFilesStorage</strong> storage engine. Since the filename is changing only when the content changes, the browser will always download the new content.</p>
			<p>Using <strong class="source-inline">ManifestFilesStorage</strong> is just one way of invalidating caches. There may be other options that are more suitable for your application.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">A hash is a one-way function that generates a string of a fixed length regardless of the length of the input. There are several different hash functions available, and Django uses <strong class="bold">MD5</strong> for the content hashing. While no longer cryptographically secure, it is adequate for this purpose. To illustrate the fixed-length property, the MD5 hash of the string <strong class="source-inline">a</strong> is <strong class="source-inline">0cc175b9c0f1b6a831c399e269772661</strong>. The MD5 hash of the string (a much longer string) is <strong class="source-inline">69fc4316c18cdd594a58ec2d59462b97</strong>. They are both 32 characters long.</p>
			<p>Choosing the storage engine is done by changing the <strong class="source-inline">STATICFILES_STOR<a id="_idTextAnchor199"/>AGE</strong> value in <strong class="source-inline">settings.py</strong>. This is a string with a dotted path to the module and class to use. The class that implements the hash-addition functionality is <strong class="source-inline">django.contrib.staticfiles.storage.ManifestStaticFilesStorage</strong>.</p>
			<p>Using this s<a id="_idTextAnchor200"/>torage engine doesn't require any changes to your HTML templates, provided you are including static assets with the <strong class="source-inline">static</strong> template tag. Django generates a manifest file (<strong class="source-inline">staticfiles.json</strong>, in JSON format) that contains a mapping between the original filename and the hashed filename. It will automatically insert the hashed filename when using the <strong class="source-inline">static</strong> template tag. If you are including your static files without using the <strong class="source-inline">static</strong> tag and instead just manually insert the static URL, then your browser will attempt to load the non-hashed path and the URL will not automatically be updated when the cache should be invalidated.</p>
			<p>For example, we include <strong class="source-inline">logo.png</strong> with the <strong class="source-inline">static</strong> tag here:</p>
			<p class="source-code">&lt;img src="{% static 'reviews/logo.png' %}"&gt;</p>
			<p>When the page is rendered, the latest hash will be retrieved from <strong class="source-inline">staticfiles.json</strong> and the output will be like this:</p>
			<p class="source-code">&lt;img src="/static/landing/logo.f30ba08c60ba.png"&gt;</p>
			<p>If we had not used the <strong class="source-inline">static</strong> tag and instead hardcoded the path, it would always appear as written:</p>
			<p class="source-code">&lt;img src="/static/landing/logo.png"&gt;</p>
			<p>Since this does not contain a hash, our browser will not see the path changing and thus never attempt to download the new file.</p>
			<p>Django retains the previous version of files with the old hash when running <strong class="source-inline">collectstatic</strong>, so older versions of your application can still refer to it if they need to. The latest version of the file is also copied with no hash so non-Django applications can refer to it without needing to look up the hash. </p>
			<p>In the next exercise, we will change our project settings to use the <strong class="source-inline">ManifestFilesStorage</strong> engine, then run the <strong class="source-inline">collectstatic</strong> management command. This will copy all the static assets as in <em class="italic">Exercise 5.04</em>,<em class="italic"> Collecting Static Files for Production</em>; however, they will now have their hash included in the filename.</p>
			<h2 id="_idParaDest-187"><a id="_idTextAnchor201"/>Exercise 5.06: Exploring the ManifestFilesStorage Storage Engine</h2>
			<p>In this exercise, you will temporarily update <em class="italic">settings.py</em> to use <strong class="source-inline">ManifestFilesStorage</strong>, then run <strong class="source-inline">collectstatic</strong> to see how the files are generated with a hash:</p>
			<ol>
				<li value="1">In PyCharm (still in the <strong class="source-inline">business_site</strong> project), open <strong class="source-inline">settings.py</strong>. Add a <strong class="source-inline">STATICFILES_STORAGE</strong> setting at the bottom of the file:<p class="source-code">STATICFILES_STORAGE = \</p><p class="source-code">'django.contrib.staticfiles.storage.ManifestStaticFilesStorage'</p><p>The completed file should look like this: <a href="http://packt.live/2Jq59Cc">http://packt.live/2Jq59Cc</a>. </p></li>
				<li>Open a terminal and navigate to the <strong class="source-inline">business_site</strong> project directory. Run the <strong class="source-inline">collectstatic</strong> command as you have before:<p class="source-code">python3 manage.py collectstatic</p><p>If your <strong class="source-inline">static_production_test</strong> directory is not empty (which will probably be the case as files were moved there during <em class="italic">Exercise 5.04</em>, <em class="italic">Collecting Static Files for Production</em>) then you will be prompted to allow the overwrite of the existing files:</p><div id="_idContainer209" class="IMG---Figure"><img src="image/B15509_05_17.jpg" alt="Figure 5.17: Prompt to allow overwrite during collectstatic&#13;&#10;"/></div><p class="figure-caption">Figure 5.17: Prompt to allow overwrite during collectstatic</p><p>Just type <strong class="source-inline">yes</strong> and then press <em class="italic">Enter</em> to allow the overwrite.</p><p>The output from this command will tell you the number of files copied as well as the number that were processed and had the hash added to the filename:</p><p class="source-code">0 static files copied to '/Users/ben/business_site</p><p class="source-code">  /static_production_test', 132 unmodified, </p><p class="source-code">  28 post-processed.</p><p>Since you haven't changed any files since we last ran <strong class="source-inline">collectstatic</strong>, no files are copied. Instead, Django is just post-processing the files (28 of them), that is, generating their hash and appending the filename.</p><p>The static files were copied into the <strong class="source-inline">static_production_test</strong> directory as they were before; however, there are now two copies of each file: one named with the hash and one without.</p><p><strong class="source-inline">static/main.css</strong> has been copied to <strong class="source-inline">static_production_test/main.856c74fb7029.css</strong> (this filename might be different if your CSS file contents differ, for example, if it has extra spaces or newlines):</p><div id="_idContainer210" class="IMG---Figure"><img src="image/B15509_05_18.jpg" alt="Figure 5.18: Expanded static_production_test directory with hashed filenames&#13;&#10;"/></div><p class="figure-caption">Figure 5.18: Expanded static_production_test directory with hashed filenames</p><p><em class="italic">Figure 5.18</em> shows the expanded <strong class="source-inline">static_production_test</strong> directory layout. You can see two copies of each static file and the <strong class="source-inline">staticfiles.json</strong> manifest file. To take <strong class="source-inline">logo.png</strong> as an example, you can see that <strong class="source-inline">landing/static/landing/logo.png</strong> has been copied to the same directory as <strong class="source-inline">static_production_test/landing/logo.ba8d3d8fe184.png</strong>.</p></li>
				<li>Let's make a change to the <strong class="source-inline">main.css</strong> file and see how the hash changes. Add some blank lines at the end of the file then save it. This won't change the effect of the CSS but the change in the file will affect its hash. Rerun the <strong class="source-inline">collectstatic</strong> command in a terminal:<p class="source-code">python3 manage.py collectstatic</p><p>Once again, you may have to enter <strong class="source-inline">yes</strong> to confirm the overwrite:</p><p class="source-code">You have requested to collect static files at the \</p><p class="source-code">  destination location as specified in your settings:</p><p class="source-code">    /Users/ben/business_site/static_production_test</p><p class="source-code">This will overwrite existing files!</p><p class="source-code">Are you sure you want to do this?</p><p class="source-code">Type 'yes' to continue, or 'no' to cancel: yes</p><p class="source-code">1 static file copied to '/Users/ben/business_site\</p><p class="source-code">  /static_production_test', 131 unmodified, 28 post-processed.</p><p>Since only one file was changed, only one static file was copied (<strong class="source-inline">main.css</strong>).</p></li>
				<li>Look inside the <strong class="source-inline">static_production_test</strong> directory again. You should see the old file with the old hash was retained, and a new file with a new hash has been added:<div id="_idContainer211" class="IMG---Figure"><img src="image/B15509_05_19.jpg" alt="Figure 5.19: Another main.css file with the latest hash was added&#13;&#10;"/></div><p class="figure-caption">Figure 5.19: Another main.css file with the latest hash was added</p><p>In this case, we have <strong class="source-inline">main.856c74fb7029.css</strong> (existing), <strong class="source-inline">main.df1234ac4e63.css</strong> (new), and <strong class="source-inline">main.css</strong>. Your hashes may differ.</p><p>The <strong class="source-inline">main.css</strong> file (no hash) always contains the newest content; that is to say, the contents of the <strong class="source-inline">main.df1234ac4e63.css</strong> and <strong class="source-inline">main.css</strong> files are identical. During the execution of <strong class="source-inline">collectstatic</strong>, Django will copy the file with a hash, as well as without a hash.</p></li>
				<li>Now examine the <strong class="source-inline">staticfiles.json</strong> file that Django generates. This is the mapping that allows Django to look up the hashed path from the normal path. Open <strong class="source-inline">static_production_test/staticfiles.json</strong>. All the content may appear in one line; if it does, enable text soft wrapping from the <strong class="source-inline">View</strong> menu -&gt; <strong class="source-inline">Active Editor</strong> -&gt; <strong class="source-inline">Soft Wrap</strong>. Scroll to the end of the file and you should see an entry for the <strong class="source-inline">main.css</strong> file, for example:<p class="source-code">"main.css": "main.df1234ac4e63.css"</p><p>This is how Django is able to populate the correct URL in a template when using the <strong class="source-inline">static</strong> template tag: by looking up the hashed path in this mapping file.</p></li>
				<li>We're finished with <strong class="source-inline">business_site</strong>, which we were just using for testing. You can delete the project or keep it around for reference during the activities.<p class="callout-heading">Note</p><p class="callout">Unfortunately, we can't examine how the hashed URL is interpolated in the template, because when running in debug mode, Django does not look up the hashed version of the file. As we know, the Django dev server only runs in debug mode, so if we turned debug mode off to try to view the hashed interpolation, then the Django dev server would not start. You will need to examine this interpolation yourself when going to production when using a frontend web server.</p></li>
			</ol>
			<p>In this exercise, we configured Django to use <strong class="source-inline">ManifestFilesStorage</strong> for its static file storage, by adding the <strong class="source-inline">STATICFILES_STORAGE</strong> setting to <strong class="source-inline">settings.py</strong>. We then executed the <strong class="source-inline">collectstatic</strong> command to see how the hashes are generated and added to the filename of the copied files. We saw the manifest file called <strong class="source-inline">staticfiles.json</strong>, which stored a lookup from the original path to the hashed path. Finally, we cleaned up the settings and directories that we added in this exercise and <em class="italic">Exercise 5.04</em>, <em class="italic">Collecting Static Files for Production</em>. These were the <strong class="source-inline">STATIC_ROOT</strong> setting, the <strong class="source-inline">STATICFILES_STORAGE</strong> setting, and the <strong class="source-inline">static_product_test</strong> directory.</p>
			<h2 id="_idParaDest-188"><a id="_idTextAnchor202"/>Custom Storage Engines</h2>
			<p>In the previous section, we set the storage engine to <strong class="source-inline">ManifestFilesStorage</strong>. This class is provided by Django, but it is also possible to write a custom storage engine. For example, you could write a storage engine that uploads your static files to a CDN, Amazon S3, or a Google Cloud bucket when you run <strong class="source-inline">collectstatic</strong>.</p>
			<p>Writing a custom storage engine is beyond the scope of this book. There already exist third-party libraries that support uploading to a variety of cloud services; one such library is <strong class="source-inline">django-storages</strong>, which can be found at <a href="https://django-storages.readthedocs.io/">https://django-storages.readthedocs.io/</a>.</p>
			<p>The following code is a short skeleton indicating which methods you should implement to create a custom file storage engine:</p>
			<p class="source-code">from django.conf import settings</p>
			<p class="source-code">from django.contrib.staticfiles import storage</p>
			<p class="source-code">class CustomFilesStorage(storage.StaticFilesStorage):</p>
			<p class="source-code">    def __init__(self):</p>
			<p class="source-code">    """</p>
			<p class="source-code">    The class must be able to be instantiated </p>
			<p class="source-code">    without any arguments.</p>
			<p class="source-code">    Create custom settings in settings.py and read them instead.</p>
			<p class="source-code">    """</p>
			<p class="source-code">    self.setting = settings.CUSTOM_STORAGE_SETTING</p>
			<p>The class must be able to be instantiated without any arguments. The <strong class="source-inline">__init__</strong> function must be able to load any settings from global identifiers (in this case, from our Django settings):</p>
			<p class="source-code">  def delete(self, name):</p>
			<p class="source-code">    """</p>
			<p class="source-code">    Implement delete of the file from the remote service.</p>
			<p class="source-code">    """</p>
			<p>This method should be able to delete the file, specified by the <strong class="source-inline">name</strong> argument, from the remote service:</p>
			<p class="source-code">    def exists(self, name):</p>
			<p class="source-code">    """</p>
			<p class="source-code">    Return True if a file with name exists in the remote service.</p>
			<p class="source-code">    """</p>
			<p>This method should query the remote service to check whether the file specified by name exists. It should return <strong class="source-inline">True</strong> if the file exists, or <strong class="source-inline">False</strong> if it doesn't:</p>
			<p class="source-code">    def listdir(self, path):</p>
			<p class="source-code">    """</p>
			<p class="source-code">    List a directory in the remote service. Return should </p>
			<p class="source-code">    be a 2-tuple of lists, the first a list of directories, </p>
			<p class="source-code">    the second a list of files.</p>
			<p class="source-code">    """</p>
			<p>This method should query the remote service to list the directory at <strong class="source-inline">path</strong>. It should then return a 2-tuple of lists. The first element should be a list of directories inside <strong class="source-inline">path</strong>, and the second element should be a list of files. For example:</p>
			<p class="source-code">return (['directory1', 'directory2'], \</p>
			<p class="source-code">        ['code.py', 'document.txt', 'image.jpg'])</p>
			<p>If <strong class="source-inline">path</strong> contains no directories or no files, then an empty list should be returned for that element. You would return two empty lists if the directory was empty:</p>
			<p class="source-code">    def size(self, name):</p>
			<p class="source-code">    """</p>
			<p class="source-code">    Return the size in bytes of the file with name.</p>
			<p class="source-code">    """</p>
			<p>This method should query the remote service and get the size of the file specified by <strong class="source-inline">name</strong>:</p>
			<p class="source-code">  def url(self, name):</p>
			<p class="source-code">  """</p>
			<p class="source-code">  Return the URL where the file of with name can be </p>
			<p class="source-code">  access on the remote service. For example, this </p>
			<p class="source-code">  might be URL of the file after it has been uploaded </p>
			<p class="source-code">  to a specific remote host with a specific domain.</p>
			<p class="source-code">  """</p>
			<p>This method should determine the URL to access the file specified by <strong class="source-inline">name</strong>. This could be built by appending <strong class="source-inline">name</strong> to a specific static hosting URL:</p>
			<p class="source-code">  def _open(self, name, mode='rb'):</p>
			<p class="source-code">  """</p>
			<p class="source-code">  Return a File-like object pointing to file with </p>
			<p class="source-code">  name. For example, this could be a URL handle for </p>
			<p class="source-code">  a remote file.</p>
			<p class="source-code">  """</p>
			<p>This method will provide a handle remote file, specified by <strong class="source-inline">name</strong>. How you implement this will depend on the type of remote service. You might have to download the file and then use a memory buffer (such as an <strong class="source-inline">io.BytesIO</strong> object) to simulate the opening of the file:</p>
			<p class="source-code">    def _save(self, name, content):</p>
			<p class="source-code">    """</p>
			<p class="source-code">    Write the content for a file with name. In this </p>
			<p class="source-code">    method you might upload the content to a </p>
			<p class="source-code">    remote service.</p>
			<p class="source-code">    """</p>
			<p>This method should save <strong class="source-inline">content</strong> to the remote file at <strong class="source-inline">name</strong>. The method of implementing this will depend on your remote service. It might transfer the file over SFTP, or upload to a CDN.</p>
			<p>While this example does not implement any transferring to or from a remote service, you can refer to it to get an idea of how to implement a custom storage engine.</p>
			<p>After implementing your custom storage engine, you can make it active by setting its dotted module path in the <strong class="source-inline">STATICFILES_STORAGE</strong> setting in <strong class="source-inline">settings.py</strong>.</p>
			<h2 id="_idParaDest-189">Activity 5.01: Addi<a id="_idTextAnchor203"/>ng a reviews Logo</h2>
			<p>The Bookr app should have a logo that is specific for pages in the <strong class="source-inline">reviews</strong> app. This will involve adding a base template just for the <strong class="source-inline">reviews</strong> app and updating our current <strong class="source-inline">reviews</strong> templates to inherit from it. Then you will include the Bookr <strong class="source-inline">reviews</strong> logo on this base template.</p>
			<p>These steps will help you complete this activity:</p>
			<ol>
				<li value="1">Add a CSS rule to position the logo. Put this rule into the existing <strong class="source-inline">base.html</strong>, after the <strong class="source-inline">.navbar-brand</strong> rule:<p class="source-code">.navbar-brand &gt; img<a id="_idTextAnchor204"/> {</p><p class="source-code">  height: 60px;</p><p class="source-code">}</p></li>
				<li>Add a <strong class="source-inline">brand</strong> <strong class="source-inline">block</strong> template tag that inheriting templates can override. Put this inside the <strong class="source-inline">&lt;a&gt;</strong> element with the <strong class="source-inline">navbar-brand</strong> class. The default contents of <strong class="source-inline">block</strong> should be left as <strong class="source-inline">Book Review</strong>.</li>
				<li>Add a static directory inside the <strong class="source-inline">reviews</strong> app, containing a namespaced directory. Download the reviews <strong class="source-inline">logo.png</strong> from <a href="https://packt.live/2WYlGjP">https://packt.live/2WYlGjP</a> and put it inside this directory.</li>
				<li>Create the <strong class="source-inline">templates</strong> directory for the Bookr project (inside the Bookr project directory). Then move the <strong class="source-inline">reviews</strong> app's current <strong class="source-inline">base.html</strong> into this directory, so it becomes a base template for the whole project.</li>
				<li>Add the new <strong class="source-inline">templates</strong> directory's path to the <strong class="source-inline">TEMPLATES['DIRS']</strong> setting in <strong class="source-inline">settings.py</strong> (the same as what you did in <em class="italic">Exercise 5.02</em>, <em class="italic">Using the static Template Tag</em>.</li>
				<li>Create another <strong class="source-inline">base.html</strong> template specifically for the <strong class="source-inline">reviews</strong> app. Put it inside the <strong class="source-inline">reviews</strong> app's <strong class="source-inline">templates</strong> directory. The new template should extend the existing <strong class="source-inline">base.html</strong>.</li>
				<li>The new <strong class="source-inline">base.html</strong> should override the content of the <strong class="source-inline">brand</strong> block. This block should contain just an <strong class="source-inline">&lt;img&gt;</strong> instance whose <strong class="source-inline">src</strong> attribute is set using the <strong class="source-inline">{% static %}</strong> template tag. The image source should be the logo added in <em class="italic">step 2</em>.</li>
				<li>The index view in <strong class="source-inline">views.py</strong> should render the project <strong class="source-inline">base.html</strong> instead of the <strong class="source-inline">reviews</strong> one.</li>
			</ol>
			<p>Refer to the following screenshots to see what your pages should be like after these changes. Note that although you are making changes to the base template, it will not change the layout of the main page:</p>
			<div>
				<div id="_idContainer212" class="IMG---Figure">
					<img src="image/B15509_05_20.jpg" alt="Figure 5.20: Book list page after adding reviews logos&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.20: Book list page after adding reviews logos</p>
			<div>
				<div id="_idContainer213" class="IMG---Figure">
					<img src="image/B15509_05_21.jpg" alt="Figure 5.21: Book Details page after adding logo&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.21: Book Details page after adding logo</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution to this activity can be found at <a href="http://packt.live/2Nh1NTJ">http://packt.live/2Nh1NTJ</a>.</p>
			<h2 id="_idParaDest-190">Activity 5.02: CSS En<a id="_idTextAnchor205"/>hancements</h2>
			<p>Currently, the CSS is kept inline in the <strong class="source-inline">base.html</strong> template. For best practice, it should be moved into its own file so that it can be cached separately and decrease the size of the HTML downloads. As part of this, you'll also add some CSS enhancements, such as fonts and colors, and link in Google Fonts CSS to support these changes.</p>
			<p>These steps will help you complete this activity:</p>
			<ol>
				<li value="1">Create a directory named <strong class="source-inline">static</strong> in the Bookr project directory. Then, create a new file inside it named <strong class="source-inline">main.css</strong>.</li>
				<li>Copy the contents of the <strong class="source-inline">&lt;style&gt;</strong> element from the main <strong class="source-inline">base.html</strong> template into the new <strong class="source-inline">main.css</strong> file, then remove the <strong class="source-inline">&lt;style&gt;</strong> element from the template. Add these extra rules to the end of the CSS file:<p class="source-code">body {</p><p class="source-code">  font-family: 'Source Sans Pro', sans-serif;</p><p class="source-code">    background-color: #e6efe8</p><p class="source-code">  color: #393939;</p><p class="source-code">}</p><p class="source-code">h1, h2, h3, h4, h5, h6 {</p><p class="source-code">  font-family: 'Libre Baskerville', serif;</p><p class="source-code">}</p></li>
				<li>Link to the new <strong class="source-inline">main.css</strong> file with a <strong class="source-inline">&lt;link rel="stylesheet" href="…"&gt;</strong> tag. Use the <strong class="source-inline">{% static %}</strong> template tag to generate the URL for the <strong class="source-inline">href</strong> attribute, and don't forget to <strong class="source-inline">load</strong> the <strong class="source-inline">static</strong> library.</li>
				<li>Link in the Google fonts CSS, by adding this code to the base template:<p class="source-code">&lt;link rel="stylesheet" </p><p class="source-code">  href="https://fonts.googleapis.com/css?family</p><p class="source-code">    =Libre+Baskerville|Source+Sans+Pro&amp;display=swap"&gt;</p><p class="callout-heading">Note</p><p class="callout">You will need to have an active internet connection so that your browser can include this remote CSS file.</p></li>
				<li>Update your Django settings to add <strong class="source-inline">STATICFILES_DIRS</strong>, set to the <strong class="source-inline">static</strong> directory created in <em class="italic">step 1</em>. When you're finished, your Bookr application should look like <em class="italic">Figure 5.22</em>:<div id="_idContainer214" class="IMG---Figure"><img src="image/B15509_05_22.jpg" alt="Figure 5.22: Book list with the new font and background color&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 5.22: Book list with the new font and background color</p>
			<p>Notice the new font and background color. These should be displayed on all the Bookr pages.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution to this activity can be found at <a href="http://packt.live/2Nh1NTJ">http://packt.live/2Nh1NTJ</a>.</p>
			<h2 id="_idParaDest-191">Activity 5.03: Adding <a id="_idTextAnchor206"/>a Global Logo</h2>
			<p>You have already added a logo that is served on pages for the <strong class="source-inline">reviews</strong> app. We have another logo to be used globally as a default, but other apps will be able to override it:</p>
			<ol>
				<li value="1">Download the Bookr logo (<strong class="source-inline">logo.png</strong>) from <a href="https://packt.live/2Jx7Ge4">https://packt.live/2Jx7Ge4</a>.</li>
				<li>Save it in the main <strong class="source-inline">static</strong> directory for the project.</li>
				<li>Edit the main <strong class="source-inline">base.html</strong> file. We already have a block for the logo (<strong class="source-inline">brand</strong>), so an <strong class="source-inline">&lt;img&gt;</strong> instance can be placed inside here. Use the <strong class="source-inline">static</strong> template tag to refer to the logo you just downloaded.</li>
				<li>Check that your pages work. On the main URL, you should see the Bookr logo, but on the book list and details pages, you should see the Bookr Reviews logo.<p>When you're finished, you should see the Bookr logo on the main page:</p><div id="_idContainer215" class="IMG---Figure"><img src="image/B15509_05_23.jpg" alt="Figure 5.23: Bookr logo on the main page&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 5.23: Bookr logo on the main page</p>
			<p>When you visit a page that had the Bookr Reviews logo before, such as the book list page, it should still show the Bookr Reviews logo:</p>
			<div>
				<div id="_idContainer216" class="IMG---Figure">
					<img src="image/B15509_05_24.jpg" alt="Figure 5.24: Bookr Reviews logo still shows on the Reviews pages&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.24: Bookr Reviews logo still shows on the Reviews pages</p>
			<p class="callout-heading"> Note</p>
			<p class="callout">The solution to this activity can be found at <a href="http://packt.live/2Nh1NTJ">http://packt.live/2Nh1NTJ</a>.</p>
			<h1 id="_idParaDest-192"><a id="_idTextAnchor207"/>Summary</h1>
			<p>In this chapter, we showed how to use Django's <strong class="source-inline">staticfiles</strong> app to find and serve static files. We used the built-in <strong class="source-inline">static</strong> view to serve these files with the Django dev server in <strong class="source-inline">DEBUG</strong> mode. We showed different places to store static files, using a directory that is global to the project or a specific directory for the application; global resources should be stored in the former while application-specific resources should be stored in the latter. We showed the importance of namespacing static file directories to prevent conflicts. After serving the assets, we used the <strong class="source-inline">static</strong> tag to include them in our template. We then demonstrated how the <strong class="source-inline">collectstatic</strong> command copies all the assets into the <strong class="source-inline">STATIC_ROOT</strong> directory, for production deployment. We showed how to use the <strong class="source-inline">findstatic</strong> command to debug the loading of static files. To invalidate caches automatically, we looked at using <strong class="source-inline">ManifestFilesStorage</strong> to add a hash of the file's content to the static file URL. Finally, we briefly talked about using a custom file storage engine.</p>
			<p>So far, we have only fetched web pages using content that already existed. In the next chapter, we will start adding forms so we can interact with web pages by sending data to them over HTTP.</p>
		</div>
	</body></html>