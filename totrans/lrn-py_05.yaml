- en: Chapter 5. Saving Time and Memory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '|   | *"It''s not the daily increase but daily decrease. Hack away at the unessential."*
    |   |'
  prefs: []
  type: TYPE_TB
- en: '|   | --*Bruce Lee* |'
  prefs: []
  type: TYPE_TB
- en: I love this quote from Bruce Lee, he was such a wise man! Especially, the second
    part, *hack away at the unessential*, is to me what makes a computer program elegant.
    After all, if there is a better way of doing things so that we don't waste time
    or memory, why not?
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, there are valid reasons for not pushing our code up to the maximum
    limit: for example, sometimes to achieve a negligible improvement, we have to
    sacrifice on readability or maintainability. Does it make any sense to have a
    web page served in 1 second with unreadable, complicated code, when we can serve
    it in 1.05 seconds with readable, clean code? No, it makes no sense.'
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, sometimes it's perfectly licit to try and shave off a millisecond
    from a function, especially when the function is meant to be called thousands
    of times. Every millisecond you save there means one second saved per thousand
    of calls, and this could be meaningful for your application.
  prefs: []
  type: TYPE_NORMAL
- en: In light of these considerations, the focus of this chapter will not be to give
    you the tools to push your code to the absolute limits of performance and optimization
    "no matter what", but rather, to give you the tools to write efficient, elegant
    code that reads well, runs fast, and doesn't waste resources in an obvious way.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, I will perform several measurements and comparisons, and cautiously
    draw some conclusions. Please do keep in mind that on a different box with a different
    setup or a different operating system, results may vary. Take a look at this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`squares.py`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Both functions return the square of *n*, but which is faster? From a simple
    benchmark I ran on them, it looks like the second is slightly faster. If you think
    about it, it makes sense: calculating the power of a number involves multiplication
    and therefore, whatever algorithm you may use to perform the power operation,
    it''s not likely to beat a simple multiplication like the one in `square2`.'
  prefs: []
  type: TYPE_NORMAL
- en: Do we care about this result? In most cases no. If you're coding an e-commerce
    website, chances are you won't ever even need to raise a number to the second
    power, and if you do, you probably will have to do it a few times per page. You
    don't need to concern yourself on saving a few microseconds on a function you
    call a few times.
  prefs: []
  type: TYPE_NORMAL
- en: So, when does optimization become important? One very common case is when you
    have to deal with huge collections of data. If you're applying the same function
    on a million `customer` objects, then you want your function to be tuned up to
    its best. Gaining 1/10 of a second on a function called one million times saves
    you 100,000 seconds, which are about 27.7 hours. That's not the same, right? So,
    let's focus on collections, and let's see which tools Python gives you to handle
    them with efficiency and grace.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Many of the concepts we will see in this chapter are based on those of **iterator**
    and **iterable**. Simply put, the ability for an object to return its next element
    when asked, and to raise a `StopIteration` exception when exhausted. We'll see
    how to code a custom iterator and iterable objects in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: map, zip, and filter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll start by reviewing `map`, `filter`, and `zip`, which are the main built-in
    functions one can employ when handling collections, and then we''ll learn how
    to achieve the same results using two very important constructs: **comprehensions**
    and **generators**. Fasten your seat belt!'
  prefs: []
  type: TYPE_NORMAL
- en: map
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'According to the official Python documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '*`map(function, iterable, ...)` returns an iterator that applies function to
    every item of iterable, yielding the results. If additional iterable arguments
    are passed, function must take that many arguments and is applied to the items
    from all iterables in parallel. With multiple iterables, the iterator stops when
    the shortest iterable is exhausted.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'We will explain the concept of yielding later on in the chapter. For now, let''s
    translate this into code: we''ll use a *lambda* function that takes a variable
    number of positional arguments, and just returns them as a tuple. Also, as `map`
    returns an iterator, we''ll need to wrap each call to it within a `list` constructor
    so that we exhaust the iterable by putting all of its elements into a list (you''ll
    see an example of this in the code):'
  prefs: []
  type: TYPE_NORMAL
- en: '`map.example.py`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code you can see why, in order to present you with the results,
    I have to wrap the calls to `map` within a `list` constructor, otherwise I get
    the string representation of a `map` object, which is not really useful in this
    context, is it?
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also notice how the elements of each iterable are applied to the function:
    at first, the first element of each iterable, then the second one of each iterable,
    and so on. Notice also that map stops when the shortest of the iterables we called
    it with is exhausted. This is actually a very nice behavior: it doesn''t force
    us to level off all the iterables to a common length, and it doesn''t break if
    they aren''t all the same length.'
  prefs: []
  type: TYPE_NORMAL
- en: '`map` is very useful when you have to apply the same function to one or more
    collections of objects. As a more interesting example, let''s see the **decorate-sort-undecorate**
    idiom (also known as **Schwartzian transform**). It''s a technique that was extremely
    popular when Python sorting wasn''t providing *key-functions*, and therefore today
    is less used, but it''s a cool trick that still comes at hand once in a while.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see a variation of it in the next example: we want to sort in descending
    order by the sum of credits accumulated by students, so to have the best student
    at position 0\. We write a function to produce a decorated object, we sort, and
    then we undecorate. Each student has credits in three (possibly different) subjects.
    To decorate an object means to transform it, either adding extra data to it, or
    putting it into another object, in a way that allows us to be able to sort the
    original objects the way we want. After the sorting, we revert the decorated objects
    to get the original ones from them. This is called to undecorate.'
  prefs: []
  type: TYPE_NORMAL
- en: '`decorate.sort.undecorate.py`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, I highlighted the tricky and important parts. Let''s
    start by understanding what each student object is. In fact, let''s print the
    first one:'
  prefs: []
  type: TYPE_NORMAL
- en: '`{''credits'': {''history'': 7, ''math'': 9, ''physics'': 6}, ''id'': 0}`'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see that it''s a dictionary with two keys: `id` and `credit`. The value
    of `credit` is also a dictionary in which there are three subject/grade key/value
    pairs. As I''m sure you recall from our visit in the data structures world, calling
    `dict.values()` returns an object similar to an `iterable`, with only the values.
    Therefore, `sum(student[''credits''].values())`, for the first student is equivalent
    to `sum(9, 6, 7)` (or any permutation of those numbers because dictionaries don''t
    retain order, but luckily for us, addition is commutative).'
  prefs: []
  type: TYPE_NORMAL
- en: 'With that out of the way, it''s easy to see what is the result of calling decorate
    with any of the students. Let''s print the result of `decorate(students[0])`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`(22, {''credits'': {''history'': 7, ''math'': 9, ''physics'': 6}, ''id'':
    0})`'
  prefs: []
  type: TYPE_NORMAL
- en: That's nice! If we decorate all the students like this, we can sort them on
    their total amount of credits but just sorting the list of tuples. In order to
    apply the decoration to each item in students, we call `map(decorate, students)`.
    Then we sort the result, and then we undecorate in a similar fashion. If you have
    gone through the previous chapters correctly, understanding this code shouldn't
    be too hard.
  prefs: []
  type: TYPE_NORMAL
- en: 'Printing students after running the whole code yields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: And you can see, by the order of the student objects, that they have indeed
    been sorted by the sum of their credits.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more on the *decorate-sort-undecorate* idiom, there's a very nice introduction
    in the sorting how-to section of the official Python documentation ([https://docs.python.org/3.4/howto/sorting.html#the-old-way-using-decorate-sort-undecorate](https://docs.python.org/3.4/howto/sorting.html#the-old-way-using-decorate-sort-undecorate)).
  prefs: []
  type: TYPE_NORMAL
- en: 'One thing to notice about the sorting part: what if two or more students share
    the same total sum? The sorting algorithm would then proceed sorting the tuples
    by comparing the `student` objects with each other. This doesn''t make any sense,
    and in more complex cases could lead to unpredictable results, or even errors.
    If you want to be sure to avoid this issue, one simple solution is to create a
    3-tuple instead of a 2-tuple, having the sum of credits in the first position,
    the position of the `student` object in the `students` list in the second one,
    and the `student` object itself in the third one. This way, if the sum of credits
    is the same, the tuples will be sorted against the position, which will always
    be different and therefore enough to resolve the sorting between any pair of tuples.
    For more considerations on this topic, please check out the sorting how-to section
    on the official Python documentation.'
  prefs: []
  type: TYPE_NORMAL
- en: zip
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We've already covered `zip` in the previous chapters, so let's just define it
    properly and then I want to show you how you could combine it with `map`.
  prefs: []
  type: TYPE_NORMAL
- en: 'According to the Python documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '*`zip(*iterables)` returns an iterator of tuples, where the i-th tuple contains
    the i-th element from each of the argument sequences or iterables. The iterator
    stops when the shortest input iterable is exhausted. With a single iterable argument,
    it returns an iterator of 1-tuples. With no arguments, it returns an empty iterator.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Let''s see an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`zip.grades.py`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we're zipping together the average and the grade for
    the last exam, per each student. Notice how the code inside the two list calls
    produces exactly the same result, showing how easy it is to reproduce `zip` using
    `map`. Notice also that, as we do for `map`, we have to feed the result of the
    `zip` call to a `list` constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple example on the combined use of `map` and `zip` could be a way of calculating
    the element-wise maximum amongst sequences, that is, the maximum of the first
    element of each sequence, then the maximum of the second one, and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '`maxims.py`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Notice how easy it is to calculate the max values of three sequences. `zip`
    is not strictly needed of course, we could just use `map`, but this would require
    us to write a much more complicated function to feed `map` with. Sometimes we
    may be in a situation where changing the function we feed to `map` is not even
    possible. In cases like these, being able to massage the data (like we're doing
    in this example with `zip`) is very helpful.
  prefs: []
  type: TYPE_NORMAL
- en: filter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'According to the Python documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '*`filter(function, iterable)` construct an iterator from those elements of
    iterable for which function returns True. iterable may be either a sequence, a
    container which supports iteration, or an iterator. If function is `None`, the
    identity function is assumed, that is, all elements of iterable that are false
    are removed.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Let''s see a very quick example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`filter.py`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, notice how the second call to filter is equivalent to
    the first one. If we pass a function that takes one argument and returns the argument
    itself, only those arguments that are `True` will make the function return `True`,
    therefore this behavior is exactly the same as passing `None`. It's often a very
    good exercise to mimic some of the built-in Python behaviors. When you succeed
    you can say you fully understand how Python behaves in a specific situation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Armed with `map`, `zip`, and `filter` (and several other functions from the
    Python standard library) we can massage sequences very effectively. But those
    functions are not the only way to do it. So let''s see one of the nicest features
    of Python: comprehensions.'
  prefs: []
  type: TYPE_NORMAL
- en: Comprehensions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Python offers you different types of comprehensions: `list`, `dict`, and `set`.'
  prefs: []
  type: TYPE_NORMAL
- en: We'll concentrate on the first one for now, and then it will be easy to explain
    the other two.
  prefs: []
  type: TYPE_NORMAL
- en: A `list` comprehension is a quick way of making a list. Usually the list is
    the result of some operation that may involve applying a function, filtering,
    or building a different data structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with a very simple example I want to calculate a list with the
    squares of the first 10 natural numbers. How would you do it? There are a couple
    of equivalent ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '`squares.map.py`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding example should be nothing new for you. Let''s see how to achieve
    the same result using a list comprehension:'
  prefs: []
  type: TYPE_NORMAL
- en: '`squares.comprehension.py`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As simple as that. Isn't it elegant? Basically we have put a `for` loop within
    square brackets. Let's now filter out the odd squares. I'll show you how to do
    it with `map` and `filter`, and then using a `list` comprehension again.
  prefs: []
  type: TYPE_NORMAL
- en: '`even.squares.py`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'I think that now the difference in readability is evident. The list comprehension
    reads much better. It''s almost English: give me all squares (*n ** 2*) for *n*
    between 0 and 9 if n is even.'
  prefs: []
  type: TYPE_NORMAL
- en: 'According to the Python documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '*A list comprehension consists of brackets containing an expression followed
    by a `for` clause, then zero or more `for` or `if` clauses. The result will be
    a new list resulting from evaluating the expression in the context of the `for`
    and `if` clauses which follow it".*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Nested comprehensions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's see an example of nested loops. It's very common when dealing with algorithms
    to have to iterate on a sequence using two placeholders. The first one runs through
    the whole sequence, left to right. The second one as well, but it starts from
    the first one, instead of 0\. The concept is that of testing all pairs without
    duplication. Let's see the classical `for` loop equivalent.
  prefs: []
  type: TYPE_NORMAL
- en: '`pairs.for.loop.py`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'If you print pairs at the end, you get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'All the tuples with the same letter are those for which `b` is at the same
    position as `a`. Now, let''s see how we can translate this in a list comprehension:'
  prefs: []
  type: TYPE_NORMAL
- en: '`pairs.list.comprehension.py`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This version is just two lines long and achieves the same result. Notice that
    in this particular case, because the `for` loop over `b` has a dependency on `a`,
    it must follow the `for` loop over `a` in the comprehension. If you swap them
    around, you'll get a name error.
  prefs: []
  type: TYPE_NORMAL
- en: Filtering a comprehension
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can apply filtering to a comprehension. Let's first do it with `filter`.
    Let's find all Pythagorean triples whose short sides are numbers smaller than
    10\. We obviously don't want to test a combination twice, and therefore we'll
    use a trick like the one we saw in the previous example.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A **Pythagorean triple** is a triple (*a*, *b*, *c*) of integer numbers satisfying
    the equation ![Filtering a comprehension](img/4715_05_03.jpg).
  prefs: []
  type: TYPE_NORMAL
- en: '`pythagorean.triple.py`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we generated a list of *3-tuples*, legs. Each tuple contains
    two integer numbers (the legs) and the hypotenuse of the Pythagorean triangle
    whose legs are the first two numbers in the tuple. For example, when a = 3 and
    b = 4, the tuple will be (3, 4, 5.0), and when a = 5 and b = 7, the tuple will
    be (5, 7, 8.602325267042627).
  prefs: []
  type: TYPE_NORMAL
- en: After having all the triples done, we need to filter out all those that don't
    have a hypotenuse that is an integer number. In order to do this, we filter based
    on `float_number.is_integer()` being `True`. This means that of the two example
    tuples I showed you before, the one with hypotenuse 5.0 will be retained, while
    the one with hypotenuse 8.602325267042627 will be discarded.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is good, but I don''t like that the triple has two integer numbers and
    a float. They are supposed to be all integers, so let''s use map to fix this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`pythagorean.triple.int.py`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Notice the step we added. We take each element in legs and we slice it, taking
    only the first two elements in it. Then, we concatenate the slice with a 1-tuple,
    in which we put the integer version of that float number that we didn't like.
  prefs: []
  type: TYPE_NORMAL
- en: 'Seems like a lot of work, right? Indeed it is. Let''s see how to do all this
    with a list comprehension:'
  prefs: []
  type: TYPE_NORMAL
- en: '`pythagorean.triple.comprehension.py`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: I know. It's much better, isn't it? It's clean, readable, shorter. In other
    words, elegant.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I'm going quite fast here, as anticipated in the summary of the last chapter.
    Are you playing with this code? If not, I suggest you do. It's very important
    that you play around, break things, change things, see what happens. Make sure
    you have a clear understanding of what is going on. You want to become a ninja,
    right?
  prefs: []
  type: TYPE_NORMAL
- en: dict comprehensions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Dictionary and set comprehensions work exactly like the list ones, only there
    is a little difference in the syntax. The following example will suffice to explain
    everything you need to know:'
  prefs: []
  type: TYPE_NORMAL
- en: '`dictionary.comprehensions.py`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'If you print `lettermap`, you will see the following (I omitted the middle
    results, you get the gist):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'What happens in the preceding code is that we''re feeding the `dict` constructor
    with a comprehension (technically, a generator expression, we''ll see it in a
    bit). We tell the `dict` constructor to make *key/value* pairs from each tuple
    in the comprehension. We enumerate the sequence of all lowercase ASCII letters,
    starting from *1*, using `enumerate`. Piece of cake. There is also another way
    to do the same thing, which is closer to the other dictionary syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'It does exactly the same thing, with a slightly different syntax that highlights
    a bit more of the *key: value* part.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Dictionaries do not allow duplication in the keys, as shown in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`dictionary.comprehensions.duplicates.py`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We create a dictionary with keys, the letters in the string `''Hello''`, and
    values of the same letters, but with the case swapped. Notice there is only one
    `''l'': ''L''` pair. The constructor doesn''t complain, simply reassigns duplicates
    to the latest value. Let''s make this clearer with another example; let''s assign
    to each key its position in the string:'
  prefs: []
  type: TYPE_NORMAL
- en: '`dictionary.comprehensions.positions.py`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice the value associated to the letter `''l'': 3`. The pair `''l'': 2` isn''t
    there, it has been overridden by `''l'': 3`.'
  prefs: []
  type: TYPE_NORMAL
- en: set comprehensions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Set comprehensions are very similar to list and dictionary ones. Python allows
    both the `set()` constructor to be used, or the explicit `{}` syntax. Let''s see
    one quick example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`set.comprehensions.py`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Notice how for set comprehensions, as for dictionaries, duplication is not allowed
    and therefore the resulting set has only four letters. Also, notice that the expressions
    assigned to `letters1` and `letters2` produce equivalent sets.
  prefs: []
  type: TYPE_NORMAL
- en: The syntax used to create `letters2` is very similar to the one we can use to
    create a dictionary comprehension. You can spot the difference only by the fact
    that dictionaries require keys and values, separated by columns, while sets don't.
  prefs: []
  type: TYPE_NORMAL
- en: Generators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Generators** are one very powerful tool that Python gifts us with. They are
    based on the concepts of *iteration*, as we said before, and they allow for coding
    patterns that combine elegance with efficiency.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Generators are of two types:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Generator functions**: These are very similar to regular functions, but instead
    of returning results through return statements, they use yield, which allows them
    to suspend and resume their state between each call'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Generator expressions**: These are very similar to the list comprehensions
    we''ve seen in this chapter, but instead of returning a list they return an object
    that produces results one by one'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generator functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Generator functions** come under all aspects like regular functions, with
    one difference: instead of collecting results and returning them at once, they
    can start the computation, yield one value, suspend their state saving everything
    they need to be able to resume and, if called again, resume and perform another
    step. Generator functions are automatically turned into their own iterators by
    Python, so you can call `next` on them.'
  prefs: []
  type: TYPE_NORMAL
- en: This is all very theoretical so, let's make it clear why such a mechanism is
    so powerful, and then let's see an example.
  prefs: []
  type: TYPE_NORMAL
- en: Say I asked you to count out loud from 1 to a million. You start, and at some
    point I ask you to stop. After some time, I ask you to resume. At this point,
    what is the minimum information you need to be able to resume correctly? Well,
    you need to remember the last number you called. If I stopped you after 31415,
    you will just go on with 31416, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: The point is, you don't need to remember all the numbers you said before 31415,
    nor do you need them to be written down somewhere. Well, you may not know it,
    but you're behaving like a generator already!
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a good look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`first.n.squares.py`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of the prints will be the same: `[0, 1, 4, 9, 16, 25, 36, 49, 64,
    81]`. But there is a huge difference between the two functions. `get_squares`
    is a classic function that collects all the squares of numbers in [0, *n*) in
    a list, and returns it. On the other hand, `get_squares_gen` is a generator, and
    behaves very differently. Each time the interpreter reaches the `yield` line,
    its execution is suspended. The only reason those prints return the same result
    is because we fed `get_squares_gen` to the `list` constructor, which when called
    like that exhausts the generator completely by asking the next element until a
    `StopIteration` is raised. Let''s see this in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '`first.n.squares.manual.py`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, each time we call `next` on the generator object, we
    either start it (first `next`) or make it resume from the last suspension point
    (any other `next`).
  prefs: []
  type: TYPE_NORMAL
- en: The first time we call `next` on it, we get `0`, which is the square of `0`,
    then `1`, then `4`, then `9` and since the `for` loop stops after that (`n` is
    `4`), then the generator naturally ends. A classic function would at that point
    just return `None`, but in order to comply with the iteration protocol, a generator
    will instead raise a `StopIteration` exception.
  prefs: []
  type: TYPE_NORMAL
- en: This explains how a `for` loop works for example. When you call `for k in range(n)`,
    what happens under the hood is that the `for` loop gets an iterator out of `range(n)`
    and starts calling `next` on it, until `StopIteration` is raised, which tells
    the `for` loop that the iteration has reached its end.
  prefs: []
  type: TYPE_NORMAL
- en: Having this behavior built-in in every iteration aspect of Python makes generators
    even more powerful because once we write them, we'll be able to plug them in whatever
    iteration mechanism we want.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, you''re probably asking yourself why would you want to use a
    generator instead of a regular function. Well, the title of this chapter should
    suggest the answer. I''ll talk about performances later, so for now let''s concentrate
    on another aspect: sometimes generators allow you to do something that wouldn''t
    be possible with a simple list. For example, say you want to analyze all permutations
    of a sequence. If the sequence has length *N*, then the number of its permutations
    is *N!*. This means that if the sequence is 10 elements long, the number of permutations
    is 3628800\. But a sequence of 20 elements would have 2432902008176640000 permutations.
    They grow factorially.'
  prefs: []
  type: TYPE_NORMAL
- en: Now imagine you have a classic function that is attempting to calculate all
    permutations, put them in a list, and return it to you. With 10 elements, it would
    require probably a few tens of seconds, but for 20 elements there is simply no
    way that it can be done.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, a generator function will be able to start the computation
    and give you back the first permutation, then the second, and so on. Of course
    you won't have the time to parse them all, they are too many, but at least you'll
    be able to work with some of them.
  prefs: []
  type: TYPE_NORMAL
- en: Remember when we were talking about the `break` statement in `for` loops? When
    we found a number dividing a *candidate prime* we were breaking the loop, no need
    to go on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes it''s exactly the same, only the amount of data you have to iterate
    over is so huge that you cannot keep it all in memory in a list. In this case,
    generators are invaluable: they make possible what wouldn''t be possible otherwise.'
  prefs: []
  type: TYPE_NORMAL
- en: So, in order to save memory (and time), use generator functions whenever possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s also worth noting that you can use the return statement in a generator
    function. It will produce a `StopIteration` exception to be raised, effectively
    ending the iteration. This is extremely important. If a `return` statement were
    actually to make the function return something, it would break the iteration protocol.
    Python consistency prevents this, and allows us great ease when coding. Let''s
    see a quick example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`gen.yield.return.py`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code yields all terms of the geometric progression *a*, *aq*,
    ![Generator functions](img/4715_05_01.jpg), ![Generator functions](img/4715_05_02.jpg),
    .... When the progression produces a term that is greater than 100,000, the generator
    stops (with a `return` statement). Running the code produces the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The next term would have been 156250, which is too big.
  prefs: []
  type: TYPE_NORMAL
- en: Going beyond next
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At the beginning of this chapter, I told you that generator objects are based
    on the iteration protocol. We'll see in the next chapter a complete example of
    how to write a custom iterator/iterable object. For now, I just want you to understand
    how `next()` works.
  prefs: []
  type: TYPE_NORMAL
- en: What happens when you call `next(generator)` is that you're calling the `generator.__next__()`
    method. Remember, a **method** is just a function that belongs to an object, and
    objects in Python can have special methods. Our friend `__next__()` is just one
    of these and its purpose is to return the next element of the iteration, or to
    raise `StopIteration` when the iteration is over and there are no more elements
    to return.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Python, an object's special methods are also called **magic methods**, or
    **dunder** (from "double underscore") **methods**.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we write a generator function, Python automatically transforms it into
    an object that is very similar to an iterator, and when we call `next(generator)`,
    that call is transformed in `generator.__next__()`. Let''s revisit the previous
    example about generating squares:'
  prefs: []
  type: TYPE_NORMAL
- en: '`first.n.squares.manual.method.py`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The result is exactly as the previous example, only this time instead of using
    the proxy call `next(squares)`, we're directly calling `squares.__next__()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Generator objects have also three other methods that allow controlling their
    behavior: `send`, `throw`, and `close`. `send` allows us to communicate a value
    back to the generator object, while `throw` and `close` respectively allow raising
    an exception within the generator and closing it. Their use is quite advanced
    and I won''t be covering them here in detail, but I want to spend a few words
    at least about `send`, with a simple example.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`gen.send.preparation.py`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding iterator creates a generator object that will run forever. You
    can keep calling it, it will never stop. Alternatively, you can put it in a `for`
    loop, for example, `for n in counter(): ...` and it will go on forever as well.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, what if you wanted to stop it at some point? One solution is to use a
    variable to control the `while` loop. Something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`gen.send.preparation.stop.py`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This will do it. We start with `stop = False`, and until we change it to `True`,
    the generator will just keep going, like before. The moment we change stop to
    `True` though, the `while` loop will exit, and the next call will raise a `StopIteration`
    exception. This trick works, but I don''t like it. We depend on an external variable,
    and this can lead to issues: what if another function changes that `stop`? Moreover,
    the code is scattered. In a nutshell, this isn''t good enough.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can make it better by using `generator.send()`. When we call `generator.send()`,
    the value that we feed to `send` will be passed in to the generator, execution
    is resumed, and we can fetch it via the `yield` expression. This is all very complicated
    when explained with words, so let''s see an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`gen.send.py`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Execution of the preceding code produces the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: I think it's worth going through this code line by line, like if we were executing
    it, and see if we can understand what's going on.
  prefs: []
  type: TYPE_NORMAL
- en: We start the generator execution with a call to `next` (`#C`). Within the generator,
    `n` is set to the same value of `start`. The `while` loop is entered, execution
    stops (`#A`) and `n` (0) is yielded back to the caller. 0 is printed on the console.
  prefs: []
  type: TYPE_NORMAL
- en: We then call `send` (`#D`), execution resumes and `result` is set to `'Wow!'`
    (still `#A`), then its type and value are printed on the console (`#B`). `result`
    is not `'Q'`, therefore `n` is incremented by 1 and execution goes back to the
    `while` condition, which, being `True`, evaluates to `True` (that wasn't hard
    to guess, right?). Another loop cycle begins, execution stops again (`#A`), and
    `n` (1) is yielded back to the caller. 1 is printed on the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we call `next` (`#E`), execution is resumed again (`#A`), and
    because we are not sending anything to the generator explicitly, Python behaves
    exactly like functions that are not using the `return` statement: the `yield n`
    expression (`#A`) returns `None`. `result` therefore is set to `None`, and its
    type and value are yet again printed on the console (`#B`). Execution continues,
    `result` is not `''Q''` so `n` is incremented by 1, and we start another loop
    again. Execution stops again (`#A`) and `n` (2) is yielded back to the caller.
    2 is printed on the console.'
  prefs: []
  type: TYPE_NORMAL
- en: 'And now for the grand finale: we call `send` again (`#F`), but this time we
    pass in `''Q''`, therefore when execution is resumed, `result` is set to `''Q''`
    (`#A`). Its type and value are printed on the console (`#B`), and then finally
    the `if` clause evaluates to `True` and the `while` loop is stopped by the `break`
    statement. The generator naturally terminates and this means a `StopIteration`
    exception is raised. You can see the print of its traceback on the last few lines
    printed on the console.'
  prefs: []
  type: TYPE_NORMAL
- en: This is not at all simple to understand at first, so if it's not clear to you,
    don't be discouraged. You can keep reading on and then you can come back to this
    example after some time.
  prefs: []
  type: TYPE_NORMAL
- en: Using `send` allows for interesting patterns, and it's worth noting that `send`
    can only be used to resume the execution, not to start it. Only `next` starts
    the execution of a generator.
  prefs: []
  type: TYPE_NORMAL
- en: The yield from expression
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another interesting construct is the `yield from` expression. This expression
    allows you to yield values from a subiterator. Its use allows for quite advanced
    patterns, so let''s just see a very quick example of it:'
  prefs: []
  type: TYPE_NORMAL
- en: '`gen.yield.for.py`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The previous code prints the numbers `4`, `9`, `16` on the console (on separate
    lines). By now, I expect you to be able to understand it by yourself, but let's
    quickly recap what happens. The `for` loop outside the function gets an iterator
    from `print_squares(2, 5)` and calls `next` on it until iteration is over. Every
    time the generator is called, execution is suspended (and later resumed) on `yield
    n ** 2`, which returns the square of the current `n`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how we can transform this code benefiting from the `yield from`
    expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '`gen.yield.from.py`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This code produces the same result, but as you can see the `yield from` is actually
    running a subiterator `(n ** 2 …)`. The `yield from` expression returns to the
    caller each value the subiterator is producing. It's shorter and it reads better.
  prefs: []
  type: TYPE_NORMAL
- en: Generator expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's now talk about the other techniques to generate values one at a time.
  prefs: []
  type: TYPE_NORMAL
- en: The syntax is exactly the same as list comprehensions, only, instead of wrapping
    the comprehension with square brackets, you wrap it with round braces. That is
    called a **generator expression**.
  prefs: []
  type: TYPE_NORMAL
- en: 'In general, generator expressions behave like equivalent list comprehensions,
    but there is one very important thing to remember: generators allow for one iteration
    only, then they will be exhausted. Let''s see an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`generator.expressions.py`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Look at the line in which the generator expression is created and assigned the
    name `cubes_gen`. You can see it's a generator object. In order to see its elements,
    we can use a `for` loop, a manual set of calls to `next`, or simply, feed it to
    a `list` constructor, which is what I did.
  prefs: []
  type: TYPE_NORMAL
- en: Notice how, once the generator has been exhausted, there is no way to recover
    the same elements from it again. We need to recreate it, if we want to use it
    from scratch again.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next few examples, let''s see how to reproduce `map` and `filter` using
    generator expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`gen.map.py`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous example, `s1` and `s2` are exactly the same: they are the sum
    of `adder(0, 1), adder(1, 2), adder(2, 3)`, and so on, which translates to `sum(1,
    3, 5, ...)`. The syntax is different though, I find the generator expression to
    be much more readable:'
  prefs: []
  type: TYPE_NORMAL
- en: '`gen.filter.py`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous example, `odd_cubes1` and `odd_cubes2` are the same: they generate
    a sequence of odd cubes. Yet again, I prefer the generator syntax. This should
    be evident when things get a little more complicated:'
  prefs: []
  type: TYPE_NORMAL
- en: '`gen.map.filter.py`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code creates to generators `cubes1` and `cubes2`. They are exactly
    the same, and return 2-tuples (*n*, ![Generator expressions](img/4715_05_04.jpg))
    when *n* is a multiple of 3 or 5.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you print the list (`cubes1`), you get: `[(0, 0), (3, 27), (5, 125), (6,
    216), (9, 729), (10, 1000), (12, 1728), (15, 3375), (18, 5832)]`.'
  prefs: []
  type: TYPE_NORMAL
- en: See how much better the generator expression reads? It may be debatable when
    things are very simple, but as soon as you start nesting functions a bit, like
    we did in this example, the superiority of the generator syntax is evident. Shorter,
    simpler, more elegant.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let me ask you a question: what is the difference between the following
    lines of code?'
  prefs: []
  type: TYPE_NORMAL
- en: '`sum.example.py`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Strictly speaking, they all produce the same sum. The expressions to get `s2`
    and `s3` are exactly the same because the braces in `s2` are redundant. They are
    both generator expressions inside the `sum` function. The expression to get `s1`
    is different though. Inside `sum`, we find a list comprehension. This means that
    in order to calculate `s1`, the `sum` function has to call `next` on a list, a
    million times.
  prefs: []
  type: TYPE_NORMAL
- en: Do you see where we're loosing time and memory? Before `sum` can start calling
    `next` on that list, the list needs to have been created, which is a waste of
    time and space. It's much better for `sum` to call `next` on a simple generator
    expression. There is no need to have all the numbers from `range(10**6)` stored
    in a list.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, *watch out for extra parentheses when you write your expressions*: sometimes
    it''s easy to skip on these details, which makes our code much different. Don''t
    believe me?'
  prefs: []
  type: TYPE_NORMAL
- en: '`sum.example.2.py`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Try running the preceding example. If I run the first line, this is what I
    get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, if I comment out the first line, and uncomment the second
    one, this is the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Sweet generator expressions. The difference between the two lines is that in
    the first one, a list with the squares of the first hundred million numbers must
    be made before being able to sum them up. That list is huge, and we run out of
    memory (at least, my box did, if yours doesn't try a bigger number), therefore
    Python kills the process for us. Sad face.
  prefs: []
  type: TYPE_NORMAL
- en: But when we remove the square brackets, we don't make a list any more. The sum
    function receives 0, 1, 4, 9, and so on until the last one, and sums them up.
    No problems, happy face.
  prefs: []
  type: TYPE_NORMAL
- en: Some performance considerations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So, we''ve seen that we have many different ways to achieve the same result.
    We can use any combination of `map`, `zip`, `filter`, or choose to go with a comprehension,
    or maybe choose to use a generator, either function or expression. We may even
    decide to go with `for` loops: when the logic to apply to each running parameter
    isn''t simple, they may be the best option.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Other than readability concerns though, let''s talk about performances. When
    it comes to performances, usually there are two factors which play a major role:
    **space** and **time**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Space means the size of the memory that a data structure is going to take up.
    The best way to choose is to ask yourself if you really need a list (or tuple)
    or if a simple generator function would work as well. If the answer is yes, go
    with the generator, it''ll save a lot of space. Same goes with functions: if you
    don''t actually need them to return a list or tuple, then you can transform them
    in generator functions as well.'
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, you will have to use lists (or tuples), for example there are algorithms
    that scan sequences using multiple pointers or maybe they run over the sequence
    more than once. A generator function (or expression) can be iterated over only
    once and then it's exhausted, so in these situations, it wouldn't be the right
    choice.
  prefs: []
  type: TYPE_NORMAL
- en: Time is a bit harder than space because it depends on more variables and therefore
    it isn't possible to state that *X is faster than Y* with absolute certainty for
    all cases. However, based on tests run on Python today, we can say that `map`
    calls can be twice as fast as equivalent `for` loops, and list comprehensions
    can be (always generally speaking) even faster than equivalent `map` calls.
  prefs: []
  type: TYPE_NORMAL
- en: In order to fully appreciate the reason behind these statements, we need to
    understand how Python works, and this is a bit outside the scope of this book,
    for it's too technical in detail. Let's just say that `map` and `list` comprehensions
    run at C language speed within the interpreter, while a Python `for` loop is run
    as Python bytecode within the Python Virtual Machine, which is often much slower.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are several different implementations of Python. The original one, and
    still the most common one, is the one written in C. C is one of the most powerful
    and popular programming languages still used today.
  prefs: []
  type: TYPE_NORMAL
- en: These claims I made come from books and articles that you can find on the Web,
    but how about we do a small exercise and try to find out for ourselves? I will
    write a small piece of code that collects the results of `divmod(a, b)` for a
    certain set of integer pairs `(a, b)`. I will use the `time` function from the
    `time` module to calculate the elapsed time of the operations that I will perform.
    Let's go!
  prefs: []
  type: TYPE_NORMAL
- en: '`performances.py`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we''re creating three lists: `dmloop`, `dmlist`, `dmgen` (`divmod`-`for`
    loop, `divmod`-`list` comprehension, `divmod`-generator expression). We start
    with the slowest option, the `for` loops. Then we have a `list` comprehension,
    and finally a generator expression. Let''s see the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The `list` comprehension runs in 63% of the time taken by the `for` loop. That's
    impressive. The generator expression came quite close to that, with a good 72%.
    The reason the generator expression is slower is that we need to feed it to the
    `list()` constructor and this has a little bit more overhead compared to a sheer
    list comprehension.
  prefs: []
  type: TYPE_NORMAL
- en: I would never go with a generator expression in a similar case though, there
    is no point if at the end we want a list. I would just use a list comprehension,
    and the result of the previous example proves me right. On the other hand, if
    I just had to do those `divmod` calculations without retaining the results, then
    a generator expression would be the way to go because in such a situation a list
    comprehension would unnecessarily consume a lot of space.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, to recap: generators are very fast and allow you to save on space. List
    comprehensions are in general even faster, but don''t save on space. Pure Python
    `for` loops are the slowest option. Let''s see a similar example that compares
    a `for` loop and a `map` call:'
  prefs: []
  type: TYPE_NORMAL
- en: '`performances.map.py`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'This code is conceptually very similar to the previous example. The only thing
    that has changed is that we''re applying the `abs` function instead of the `divmod`
    one, and we have only one loop instead of two nested ones. Execution gives the
    following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: And `map` wins the race! As I told you before, giving a statement of *what is
    faster than what* is very tricky. In this case, the `map` call is faster than
    the list comprehension.
  prefs: []
  type: TYPE_NORMAL
- en: Apart from the case by case little differences though, it's quite clear that
    the `for` loop option is the slowest one, so let's see what are the reasons we
    still want to use it.
  prefs: []
  type: TYPE_NORMAL
- en: Don't overdo comprehensions and generators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've seen how powerful list comprehensions and generator expressions can be.
    And they are, don't get me wrong, but the feeling that I have when I deal with
    them is that their complexity grows exponentially. The more you try to do within
    a single comprehension or a generator expression, the harder it becomes to read,
    understand, and therefore to maintain or change.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a Python console and type in `import this`, let''s read the Zen of Python
    again, in particular, there are a few lines that I think are very important to
    keep in mind:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: I have put a comment sign on the right of the main focus points here. Comprehensions
    and generator expressions become hard to read, more implicit than explicit, complex,
    and they can be hard to explain. Sometimes you have to break them apart using
    the inside-out technique, to understand why they produce the result they produce.
  prefs: []
  type: TYPE_NORMAL
- en: To give you an example, let's talk a bit more about Pythagorean triples. Just
    to remind you, a Pythagorean triple is a tuple of positive integers (*a*, *b*,
    *c*) such that ![Don't overdo comprehensions and generators](img/4715_05_05.jpg).
  prefs: []
  type: TYPE_NORMAL
- en: We saw earlier in this chapter how to calculate them, but we did it in a very
    inefficient way because we were scanning all pairs of numbers below a certain
    threshold, calculating the hypotenuse, and filtering out those that were not producing
    a triple.
  prefs: []
  type: TYPE_NORMAL
- en: 'A better way to get a list of Pythagorean triples is to directly generate them.
    There are many different formulas to do this and we''ll use one of them: the **Euclidean
    formula**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This formula says that any triple (*a*, *b*, *c*), where ![Don''t overdo comprehensions
    and generators](img/4715_05_06.jpg), *b = 2mn*, ![Don''t overdo comprehensions
    and generators](img/4715_05_07.jpg), with *m* and *n* positive integers such that
    *m > n*, is a Pythagorean triple. For example, when *m = 2* and *n = 1*, we find
    the smallest triple: (3, 4, 5).'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one catch though: consider the triple (6, 8, 10), that is just like
    (3, 4, 5) with all the numbers multiplied by 2\. This triple is definitely Pythagorean,
    since ![Don''t overdo comprehensions and generators](img/4715_05_08.jpg), but
    we can derive it from (3, 4, 5) simply by multiplying each of its elements by
    *2*. Same goes for (9, 12, 15), (12, 16, 20), and in general for all the triples
    that we can write as (3k, 4k, 5k), with *k* being a positive integer greater than
    1.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A triple that cannot be obtained by multiplying the elements of another one
    by some factor *k*, is called **primitive**. Another way of stating this is: if
    the three elements of a triple are **coprime**, then the triple is primitive.
    Two numbers are coprime when they don''t share any prime factor amongst their
    divisors, that is, their **greatest common divisor** (**GCD**) is 1\. For example,
    3 and 5 are coprime, while 3 and 6 are not, because they are both divisible by
    3.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, the Euclidean formula tells us that if *m* and *n* are coprime, and *m
    – n* is odd, the triple they generate is *primitive*. In the following example,
    we will write a generator expression to calculate all the primitive Pythagorean
    triples whose hypotenuse (*c*) is less than or equal to some integer *N*. This
    means we want all triples for which ![Don''t overdo comprehensions and generators](img/4715_05_09.jpg).
    When *n* is *1*, the formula looks like this: ![Don''t overdo comprehensions and
    generators](img/4715_05_10.jpg), which means we can approximate the calculation
    with an upper bound of ![Don''t overdo comprehensions and generators](img/4715_05_11.jpg).'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, to recap: *m* must be greater than *n*, they must also be coprime, and
    their difference *m - n* must be odd. Moreover, in order to avoid useless calculations
    we''ll put the upper bound for *m* at *floor(sqrt(N)) + 1*.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The function `floor` for a real number *x* gives the maximum integer *n* such
    that *n < x*, for example, *floor(3.8) = 3*, *floor(13.1) = 13*. Taking the *floor(sqrt(N))
    + 1* means taking the integer part of the square root of *N* and adding a minimal
    margin just to make sure we don't miss out any number.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s put all of this into code, step by step. Let''s start by writing a simple
    `gcd` function that uses **Euclid''s algorithm**:'
  prefs: []
  type: TYPE_NORMAL
- en: '`functions.py`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The explanation of Euclid''s algorithm is available on the Web, so I won''t
    spend any time here talking about it; we need to concentrate on the generator
    expression. The next step is to use the knowledge we gathered before to generate
    a list of primitive Pythagorean triples:'
  prefs: []
  type: TYPE_NORMAL
- en: '`pythagorean.triple.generation.py`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: There you go. It's not easy to read, so let's go through it line by line. At
    `#3`, we start a generator expression that is creating triples. You can see from
    `#4` and `#5` that we're looping on `m` in *[1, M]* with *M* being the integer
    part of *sqrt(N)*, plus 1\. On the other hand, `n` loops within *[1, m)*, to respect
    the *m > n* rule. Worth noting how I calculated *sqrt(N)*, that is, `N**.5`, which
    is just another way to do it that I wanted to show you.
  prefs: []
  type: TYPE_NORMAL
- en: 'At `#6`, you can see the filtering conditions to make the triples primitive:
    `(m - n) % 2` evaluates to `True` when `(m - n)` is odd, and `gcd(m, n) == 1`
    means `m` and `n` are coprime. With these in place, we know the triples will be
    primitive. This takes care of the innermost generator expression. The outermost
    one starts at `#2`, and finishes at `#7`. We take the triples (*a*, *b*, *c*)
    in (...innermost generator...) such that `c <= N`. This is necessary because ![Don''t
    overdo comprehensions and generators](img/4715_05_11.jpg) is the lowest upper
    bound that we can apply, but it doesn''t guarantee that *c* will actually be less
    than or equal to *N*.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, at `#1` we apply sorting, to present the list in order. At `#7`, after
    the outermost generator expression is closed, you can see that we specify the
    sorting key to be the sum *a + b + c*. This is just my personal preference, there
    is no mathematical reason behind it.
  prefs: []
  type: TYPE_NORMAL
- en: So, what do you think? Was it straightforward to read? I don't think so. And
    believe me, this is still a simple example; I have seen expressions way more complicated
    than this one.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately some programmers think that writing code like this is cool, that
    it's some sort of demonstration of their superior intellectual powers, of their
    ability to quickly read and digest intricate code.
  prefs: []
  type: TYPE_NORMAL
- en: Within a professional environment though, I find myself having much more respect
    for those who write efficient, clean code, and manage to keep ego out the door.
    Conversely, those who don't, will produce lines at which you will stare for a
    long time while swearing in three languages (at least this is what I do).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s see if we can rewrite this code into something easier to read:'
  prefs: []
  type: TYPE_NORMAL
- en: '`pythagorean.triple.generation.for.py`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: I feel so much better already. Let's go through this code as well, line by line.
    You'll see how easier it is to understand.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start looping at `#1` and `#2`, in exactly the same way we were looping
    in the previous example. On line `#3`, we have the filtering for primitive triples.
    On line `#4`, we deviate a bit from what we were doing before: we calculate `c`,
    and on line `#5`, we filter on `c` being less than or equal to `N`. Only when
    `c` satisfies that condition, we calculate `a` and `b`, and yield the resulting
    tuple. It''s always good to delay all calculations for as much as possible so
    that we don''t waste time, in case eventually we have to discard those results.'
  prefs: []
  type: TYPE_NORMAL
- en: On the last line, before printing the result, we apply sorting with the same
    key we were using in the generator expression example.
  prefs: []
  type: TYPE_NORMAL
- en: I hope you agree, this example is easier to understand. And I promise you, if
    you have to modify the code one day, you'll find that modifying this one is easy,
    while to modify the other version will take much longer (and it will be more error
    prone).
  prefs: []
  type: TYPE_NORMAL
- en: 'Both examples, when run, print the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The moral of the story is, try and use comprehensions and generator expressions
    as much as you can, but if the code starts to be complicated to modify or to read,
    you may want to refactor into something more readable. There is nothing wrong
    with this.
  prefs: []
  type: TYPE_NORMAL
- en: Name localization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we are familiar with all types of comprehensions and generator expression,
    let''s talk about name localization within them. Python 3.* localizes loop variables
    in all four forms of comprehensions: `list`, `dict`, `set`, and generator expressions.
    This behavior is therefore different from that of the `for` loop. Let''s see a
    simple example to show all the cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '`scopes.py`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we declare a global name `A = 100`, and then we exercise
    the four comprehensions: list, generator expression, dictionary, and set. None
    of them alter the global name `A`. Conversely, you can see at the end that the
    `for` loop modifies it. The last print statement prints 4.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see what happens if `A` wasn''t there:'
  prefs: []
  type: TYPE_NORMAL
- en: '`scopes.noglobal.py`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code would work the same with any of the four types of comprehensions.
    After we run the first line, `A` is not defined in the global namespace.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once again, the `for` loop behaves differently:'
  prefs: []
  type: TYPE_NORMAL
- en: '`scopes.for.py`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code shows that after a `for` loop, if the loop variable wasn''t
    defined before it, we can find it in the global frame. To make sure of it, let''s
    take a peek at it by calling the `globals()` built-in function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Together with a lot of other boilerplate stuff, we can spot `''A'': 4`.'
  prefs: []
  type: TYPE_NORMAL
- en: Generation behavior in built-ins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Amongst the built-in types, the generation behavior is now quite common. This
    is a major difference between Python 2 and Python 3\. A lot of functions such
    as `map`, `zip`, and `filter` have been transformed so that they return objects
    that behave like iterables. The idea behind this change is that if you need to
    make a list of those results you can always wrap the call in a `list()` class,
    and you're done. On the other hand, if you just need to iterate and want to keep
    the impact on memory as light as possible, you can use those functions safely.
  prefs: []
  type: TYPE_NORMAL
- en: Another notable example is the `range` function. In Python 2 it returns a list,
    and there is another function called `xrange` that returns an object that you
    can iterate on, which generates the numbers on the fly. In Python 3 this function
    has gone, and `range` now behaves like it.
  prefs: []
  type: TYPE_NORMAL
- en: But this concept in general is now quite widespread. You can find it in the
    `open()` function, which is used to operate on file objects (we'll see it in one
    of the next chapters), but also in `enumerate`, in the dictionary `keys`, `values`,
    and `items` methods, and several other places.
  prefs: []
  type: TYPE_NORMAL
- en: 'It all makes sense: Python''s aim is to try and reduce the memory footprint
    by avoiding wasting space wherever is possible, especially in those functions
    and methods that are used extensively in most situations.'
  prefs: []
  type: TYPE_NORMAL
- en: Do you remember at the beginning of this chapter? I said that it makes more
    sense to optimize the performances of code that has to deal with a lot of objects,
    rather than shaving off a few milliseconds from a function that we call twice
    a day.
  prefs: []
  type: TYPE_NORMAL
- en: One last example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we part from this chapter, I'll show you a simple problem that I submitted
    to candidates for a Python developer role in a company I used to work for.
  prefs: []
  type: TYPE_NORMAL
- en: 'The problem is the following: given the sequence `0 1 1 2 3 5 8 13 21 ...`
    write a function that would return the terms of this sequence up to some limit
    `N`.'
  prefs: []
  type: TYPE_NORMAL
- en: If you haven't recognized it, that is the Fibonacci sequence, which is defined
    as *F(0) = 0*, *F(1) = 1* and, for any *n > 1*, *F(n) = F(n-1) + F(n-2)*. This
    sequence is excellent to test knowledge about recursion, memoization techniques
    and other technical details, but in this case it was a good opportunity to check
    whether the candidate knew about generators (and too many so called Python coders
    didn't, when I was interviewing them).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start from a rudimentary version of a function, and then improve on
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '`fibonacci.first.py`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'From the top: we set up the `result` list to a starting value of `[0]`. Then
    we start the iteration from the next element (`next_n`), which is `1`. While the
    next element is not greater than `N`, we keep appending it to the list and calculating
    the next. We calculate the next element by taking a slice of the last two elements
    in the `result` list and passing it to the `sum` function. Add some `print` statements
    here and there if this is not clear to you, but by now I would expect it not to
    be an issue.'
  prefs: []
  type: TYPE_NORMAL
- en: When the condition of the `while` loop evaluates to `False`, we exit the loop
    and return `result`. You can see the result of those `print` statements in the
    comments next to each of them.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, I would ask the candidate the following question: "What if I
    just wanted to iterate over those numbers?" A good candidate would then change
    the code like the next listing (an excellent candidate would have started with
    it!):'
  prefs: []
  type: TYPE_NORMAL
- en: '`fibonacci.second.py`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'This is actually one of the solutions I was given. I don''t know why I kept
    it, but I''m glad I did so I can show it to you. Now, the `fibonacci` function
    is a *generator function*. First we yield `0`, then if `N` is `0` we return (this
    will cause a `StopIteration` exception to be raised). If that''s not the case,
    we start iterating, yielding `b` at every loop cycle, and then updating `a` and
    `b`. All we need in order to be able to produce the next element of the sequence
    is the past two: `a` and `b`, respectively.'
  prefs: []
  type: TYPE_NORMAL
- en: This code is much better, has a lighter memory footprint and all we have to
    do to get a list of Fibonacci numbers is to wrap the call with `list()`, as usual.
  prefs: []
  type: TYPE_NORMAL
- en: 'But what about elegance? I cannot leave the code like that. It was decent for
    an interview, where the focus is more on functionality than elegance, but here
    I''d like to show you a nicer version:'
  prefs: []
  type: TYPE_NORMAL
- en: '`fibonacci.elegant.py`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Much better. The whole body of the function is four lines, five if you count
    the docstring. Notice how in this case using tuple assignment (`a, b = 0, 1` and
    `a, b = b, a + b`) helps in making the code shorter, and more readable. It's one
    of the features of Python I like a lot.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored the concept of iteration and generation a bit more
    deeply. We saw the `map`, `zip` and `filter` functions quite in detail, and how
    to use them as an alternative to a regular `for` loop approach.
  prefs: []
  type: TYPE_NORMAL
- en: Then we saw the concept of comprehensions, for lists, dictionaries, and sets.
    We saw their syntax and how to use them as an alternative to both the classic
    `for` loop approach and also to the use of `map`, `zip`, and `filter` functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we talked about the concept of generation, in two forms: generator
    functions and expressions. We learned how to save time and space by using generation
    techniques and saw how they can make possible what wouldn''t normally be if we
    used a conventional approach based on lists.'
  prefs: []
  type: TYPE_NORMAL
- en: We talked about performances, and saw that `for` loops are last in terms of
    speed, but they provide the best readability and flexibility to change. On the
    other hand, functions such as `map` and `filter` can be much faster, and comprehensions
    may be even better.
  prefs: []
  type: TYPE_NORMAL
- en: The complexity of the code written using these techniques grows exponentially
    so, in order to favor readability and ease of maintainability, we still need to
    use the classic `for` loop approach at times. Another difference is in the name
    localization, where the `for` loop behaves differently from all other types of
    comprehensions.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will be all about objects and classes. Structurally similar
    to this one, in that we won't explore many different subjects, rather, just a
    few of them, but we'll try to dive a little bit more deeply.
  prefs: []
  type: TYPE_NORMAL
- en: Make sure you understand well the concepts of this chapter before jumping to
    the next one. We're building a wall brick by brick, and if the foundation is not
    solid, we won't get very far.
  prefs: []
  type: TYPE_NORMAL
