<html><head></head><body>
        

                            
                    <h1 class="header-title">Getting Started with PyQt and PySide</h1>
                
            
            
                
<p class="mce-root">In this chapter, we will lay the groundwork so that we can start the creation of GUIs with Python bindings, such as PyQt and PySide. These bindings are able to utilize all Python programming language functionalities and various Python-based tools that are available in the Python world, together with the powerful Qt framework, which, in turn, allows us to visualize our imagination and development processes in real and widely functional GUI applications.</p>
<p class="mce-root">In this chapter, we will cover the following topics:</p>
<ul>
<li>PyQt versus PySide</li>
<li>PyQt5</li>
<li>PySide2</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">PyQt versus PySide</h1>
                
            
            
                
<p>As we can see, PyQt and PySide represent the bindings of the Python programming language functionality with the Qt library. These tools are very similar and provide just the ability to implement the Python syntax with C++, because Qt is basically a C++ language-based framework. The bindings are implemented as a set of Python modules and contain the classes that realize the GUI and infrastructure implementation. PySide is a community managed Qt Project (<a href="http://qt-project.org">http://qt-project.org</a>), while PyQt is a binding that's developed by the British firm, Riverbank Computing (<a href="https://riverbankcomputing.com">https://riverbankcomputing.com</a>) . The most recent versions of these bindings, at the time of writing this book, support the Qt5.x framework in both the PySide2 and PyQt5 versions. Within this book, the most recent versions of the bindings, PyQt5 and PySide2, will be used. These versions can be downloaded and installed from official sources, with <kbd>pip</kbd> or other available package managers. </p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Downloading and installing</h1>
                
            
            
                
<p>To start using these tools with Python, you need to have done the following:</p>
<ul>
<li> Downloaded and installed Python from <a href="https://www.python.org/downloads/">https://www.python.org/downloads/</a></li>
</ul>
<p>In the case of PyQt5, you need to have done the following:</p>
<ul>
<li>Built and installed SIP</li>
<li>Downloaded and installed the PyQt5 package from the official source or with <kbd>pip</kbd>:</li>
</ul>
<pre style="padding-left: 60px"><strong>&gt; pip3 install PyQt5</strong></pre>
<p>In the case of PySide2, you need to have done the following:</p>
<ul>
<li> Installed libclang</li>
<li> Downloaded and installed the PySide2 package from the official source:</li>
</ul>
<pre style="padding-left: 60px"><strong>&gt; python -m pip install --index-url=http://download.qt.io/snapshots/ci/pyside/5.11/latest pyside2 --trusted-host download.qt.io</strong></pre>
<p>Alternatively, the option that is most recommended is downloading and installing the Anaconda toolset. Anaconda, by default, has PyQt5 installed and ready to work. In addition, the PySide2 binding can be installed using the command in the cmd/Terminal:</p>
<pre><strong>&gt; conda config --add channels conda-forge</strong><br/><strong>&gt; conda install pyside2</strong></pre>
<p>Finally, PySide2 can be installed using Anaconda Navigator, which is provided as a default tool.</p>
<p>In this book, PySide2 with the Python 2.x Anaconda environment will be used and PyQt5 with Python 3.x Anaconda. This circumvents numerous version conflicts and gets the necessary knowledge about the differences between Python versions 2.x/3.x in practice.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The difference between PyQt5 and PySide2 bindings</h1>
                
            
            
                
<p>Given that the Python and Qt bindings are installed, let's describe some of the differences between PyQt and PySide. These differences are not constant over the period in question and may be excluded in the future. Firstly, there is a different <kbd>import</kbd> statement. </p>
<p>For the PyQt5 binding, <kbd>import</kbd> looks like the following:</p>
<pre>from PyQt5 import QtWidgets</pre>
<p>For the PySide2 binding, use the following <kbd>import</kbd> statement:</p>
<pre>from PySide2 import QtWidgets</pre>
<p>As we can see, the difference is in the name of the binding that is used to import the module. The statement to import some modules or classes can be different.</p>
<p>For example, the <kbd>import</kbd> statement of PyQt5 to Qt looks like this:</p>
<pre>from PyQt5.Qt import Qt</pre>
<p>But with PySide2, it is different:</p>
<pre>from PySide2.QtCore import Qt</pre>
<p>Also, other classes can have different importing locations. It is recommended to learn these import locations for both PyQt5 and PySide2 binding modules and classes in relation to the versions used.</p>
<p>The PySide2 binding only supports API 2, which means that classes including <kbd>QStrings</kbd>, <kbd>QStringLists</kbd>, and <kbd>QVariants</kbd> are not available.</p>
<p>Signals and slots have some different syntax.</p>
<p>The syntax for PyQt5 signals is as follows:</p>
<pre>from PyQt5.QtCore import pyqtSignal<br/>sig = pyqtSignal()</pre>
<p>For the PySide2 binding, we need to modify this syntax so that it's similar to the following:</p>
<pre>from PySide2.QtCore import Signal<br/>sig = Signal()</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>The following are some facts about the syntax:</p>
<ul>
<li>The signal decorator of PySide2 is <kbd>@Signal</kbd>, not <kbd>@pyqtSignal</kbd>, as it is in PyQt5 binding.</li>
<li>PySide2 will not export C++ components deprecated by Qt.</li>
<li>There are also differences with property declaration. If, in PyQt5, this looks like <kbd>QtCore.pyqtProperty</kbd>,<strong> </strong>then for PySide2, this will be <kbd>QtCore.Property</kbd>.</li>
<li>Different tool names are available with bindings. For example, the PyQt5 tool name, <kbd>pyuic5</kbd>, will be <kbd>pyside2-uic</kbd> with PySide2, and so on.</li>
<li>PySide uses <kbd>event()</kbd> and <kbd>connect()</kbd> with the <kbd>QObject</kbd> class. These property names cannot be used in the code for something else.</li>
<li>By working with the <kbd>QThread</kbd> class, in PySide2, after calling <kbd>stop()</kbd>, we need to use <kbd>wait()</kbd> when quitting the application.</li>
<li>The PySide2 <kbd>sender()</kbd> method returns <kbd>None</kbd> when a slot is a Lambda function. </li>
<li>With inheritance using PySide2, the parent class constructors always need to be called.</li>
</ul>
<p>Let's have a look at the following code snippets:</p>
<ul>
<li>The PyQt5 class construction is similar to this:</li>
</ul>
<pre style="padding-left: 60px">class UApp(QtWidgets.QWidget):<br/><br/>    def __init__(self, parent=None):<br/>        super(QtWidgets.QWidget, self).__init__(parent)<br/>        ...<br/>    ...</pre>
<ul>
<li>In PySide2, the class name needs to be added to the <kbd>super()</kbd> function:</li>
</ul>
<pre style="padding-left: 60px">class UApp(QtWidgets.QWidget):<br/><br/>    def __init__(self, parent=None):<br/>        super(UApp, self).__init__(parent)<br/>        ...<br/>    ...</pre>
<ul>
<li>PySide2 only supports new-style classes, which are classes that are available as part of inheritance with PyQt5:</li>
</ul>
<pre style="padding-left: 60px">class OldStyle():<br/>    ...</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<ul>
<li>With PySide2, we need change to the new style by adding <kbd>object</kbd>:</li>
</ul>
<pre style="padding-left: 60px">class NewStyle(<strong>object</strong>):<br/>    ...</pre>
<ul>
<li> The old-style signals look like this:</li>
</ul>
<pre style="padding-left: 60px">self.emit(SIGNAL('text_changed_cb'), text)</pre>
<ul>
<li>With PySide2, the old-style signals need to be rewritten as follows:</li>
</ul>
<pre style="padding-left: 60px">self.emit(SIGNAL('text_changed_cb(QString)'), text)</pre>
<ul>
<li>Only signals without arguments will have the auto connection to the constructor:</li>
</ul>
<pre style="padding-left: 60px">action = QtWidgets.QAction(None, triggered=handler)</pre>
<p style="padding-left: 60px">In the preceding code, the <kbd>triggered()</kbd> signal will be connected to the slot handler instead of the <kbd>triggered(bool)</kbd> signal.</p>
<p>PySide2 is related to <kbd>shiboken2</kbd>, the Python binding generator that is used to create the PySide2 modules, and is the Qt C++ API to Python. Shiboken is a generator runner plugin that provides C++ code for CPython extensions. PyQt5 is built using the SIP bindings generator, the tool that creates Python bindings for C and C++ libraries.</p>
<p>As we can see, the differences between PyQt5 and PySide2 are not the cardinal point in the comparison. All of these problems can easily be prevented. Within this book, we will try to avoid the limitations and restrictions related to the versions of the bindings, languages, and framework features. Hence, as we mentioned previously, we will use the most recent Anaconda 2 environment for PySide2, and the most recent Anaconda 3 environment for PyQt5. Also, modern programming approaches, including the utilization of the new-style classes, will be adopted.</p>
<p class="mce-root">Frequent questions that arise inside the community regarding the differences between PyQt5 and PySide2 are related to the licenses of these bindings. PySide2 is under the GNU <strong>Lesser General Public License</strong> (<strong>LGPL</strong>), or the Qt Commercial License, as a counterweight to PyQt5, under the Riverbank Commercial License, or GPL v3. Also, some third-party components of PySide2 are under licenses that may not be the LGPLs. If you are intending to use the software for commercial purposes, you need to read these license rules carefully.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">PyQt5</h1>
                
            
            
                
<p>We will start our learning of GUI creation with Python by exploring the PyQt5 binding to the Qt framework. As we mentioned previously, PyQt5 is a binding to the Qt application framework that's provided by the Qt company and developed by RiverBank Computing. At the time of writing, PyQt5 may be used on Windows, Linux, Unix platforms, macOS, Android, and iOS. The downloaded PyQt5 package does not have a copy of Qt, and by now, you must have downloaded and installed the correct licensed copy of Qt framework from the official source. PyQt5 is a dual licensed software, licensed under the Riverbank Commercial License and the GPL v3. This means that if the GPL license is to be used, then the code provided by the developer must also use a compatible license. PyQt5 modules contain the following:</p>
<ul>
<li><strong>Base</strong>:
<ul>
<li><kbd>Qt</kbd>: This is a consolidation of the modules, such as in the Qt library—the base of all classes. This is the base class of the Qt library.</li>
</ul>
</li>
<li><strong>Basic with GUI creation</strong>:
<ul>
<li><kbd>QtCore</kbd>: These are the core Qt classes; they provide core functionality, such as signals/slots or alignment of the elements.</li>
<li><kbd>QtWidgets</kbd>: This is the GUI for creating classes which create desktop applications, such as creating a window.</li>
<li><kbd>QtGui</kbd>: These are the core classes for widgets and GUIs, such as adding icons and working with colors and texts.</li>
<li><kbd>QtPrintSupport</kbd>: This provides local/remote printing functionality integration with the applications, with the ability to generate PostScript and PDF files.</li>
<li><kbd>QtMultimedia</kbd>: These are classes for multimedia content and APIs to access camera and radio. It has audio and video classes.</li>
<li><kbd>QtMultimediaWidgets</kbd>: These are additional classes for multimedia widgets and controls, such as video widgets.</li>
<li><kbd>QtSql</kbd>: This provides integration with SQL databases. This includes the SQL database, drivers, fields, table models, and queries classes.</li>
<li><kbd>QtSvg</kbd>: This provides support for rendering the contents of the <strong>Structured Vector Graphics</strong> (<strong>SVG</strong>).</li>
</ul>
</li>
<li><strong>QML</strong>:
<ul>
<li><kbd>QtQml</kbd>: Classes for integrating the QML language infrastructure with PyQt5 applications.</li>
<li><kbd>QtQuick</kbd>: Provides the extension for the QML user interfaces.</li>
<li><kbd>QtQuickWidgets</kbd>: Used to render a QML scene in traditional widgets.</li>
</ul>
</li>
<li><strong>Devices, networking, and the web</strong>:
<ul>
<li><kbd>QtBluetooth</kbd>: These are classes to connect with Bluetooth devices, such as scanning for devices, gathering information, and exchanging data.</li>
<li><kbd>QtNfc</kbd>: This provides the classes to connect between NFC devices (near-field communication protocols used by devices).</li>
<li><kbd>QtNetwork</kbd>: These are the core network classes. This facilitates the creation of UDP and TCP clients and servers, and includes the classes that implement HTTP clients and support DNS lookups. Options to work with sockets, network configuration, and SSL certificates are available.</li>
<li><kbd>QtNetworkAuth</kbd>: These are classes for network authorization (OAuth).</li>
<li><kbd>QtWebChannel</kbd>: This is for use of the classes that enable peer-to-peer communication between a server, Python/QML application and client, HTML/JavaScript, or QML application.</li>
<li><kbd>QtWebEngine</kbd>: These are classes for integrating QML WebEngine objects with Python. </li>
<li><kbd>QtWebEngineCore</kbd>: These are the core web engine classes.</li>
<li><kbd>QtWebEngineWidgets</kbd>: This provides a Chromium-based web browser.</li>
<li><kbd>QtWebSockets</kbd>: This is an implementation of the WebSocket protocol.</li>
<li><kbd>QtPurchasing</kbd>: This provides in-app purchasing, App Store, and Google Play support.</li>
</ul>
</li>
<li><strong>3D</strong>:
<ul>
<li><kbd>Qt3DAnimation</kbd>: Classes used for animations that are applied to the object properties in simulations.</li>
<li><strong><kbd>Qt3DCore</kbd></strong>: The core classes for the near real-time simulation systems with 2D and 3D rendering.</li>
<li><kbd>Qt3DExtras</kbd>: Classes that provide pre-built elements for Qt3D, such as geometries, meshes and materials, and camera controllers.</li>
<li><kbd>Qt3DInput</kbd>: Classes for handling user input with Qt3D.</li>
<li><kbd>Qt3DLogic</kbd>: Synchronization of the frames with the Qt3D backend.</li>
<li><kbd>Qt3DRender</kbd>: Classes for 2D and 3D rendering with Qt3D.</li>
<li><kbd>QtDataVisualization</kbd>: Contains the classes that visualize data in 3D as surface graphs, bars, and scatter plots.</li>
</ul>
</li>
<li><strong>XML</strong>:
<ul>
<li><kbd>QtXml</kbd>:<strong> </strong>Classes that provide the simple API for XML (SAX) and <strong>Document Object Model</strong> (<strong>DOM</strong>) interfaces for the XML parser of the Qt framework.</li>
<li><kbd>QtXmlPatterns</kbd>: Classes for additional XML technologies, such as XPath and XQuery, <strong>Extensible Stylesheet Language Transformations</strong> (<strong>XSLT</strong>), and XML schema validation.</li>
</ul>
</li>
<li><strong>Utilities</strong>:
<ul>
<li><kbd>QtLocation</kbd>: This provides classes for the creation of the mapping applications with data from the popular location services that provide navigation information and geocoding, along with place searching.</li>
<li><kbd>QtPositioning</kbd>: This module provides the classes for working with positioning information from satellites, Wi-Fi, and so on, and can be used to determine a position on a map.</li>
<li><kbd>QtSensors</kbd>: This provides classes for working with a system's hardware sensors, such as gyroscopes and accelerometers, altimeters, ambient light and temperature sensors, and magnetometers.</li>
<li><kbd>QtSerialPort</kbd>: This module provides the classes for working with serial ports of the system, and for configuring, I/O operations, and getting and setting the control signals of the RS-232 pinouts.</li>
<li><kbd>QtDBus</kbd>: This provides classes for working with the D-Bus protocol—the <strong>Inter-Process Communication</strong> (<strong>IPC</strong>) and <strong>Remote Procedure Calling</strong> (<strong>RPC</strong>) mechanism. This was designed to allow interaction between system-level processes, such as printers and hardware driver services, and other user processes.</li>
<li><kbd>QAxContainer</kbd>: This provides classes that provide access to ActiveX (internet-enabled components) controls and COM objects.</li>
<li><kbd>QtChart</kbd>: This provides classes for the creation of 2D charts. These include line and spline charts, area and scatter charts, bar charts, pie charts, box-and-whiskers charts, candlestick charts, and polar charts.</li>
<li><kbd>QtDesigner</kbd>: A module with classes that provides extensions for using the Qt Designer with Python.</li>
<li><kbd>QtHelp</kbd>: Classes that allow the creation/viewing of searchable help and documentation in the applications.</li>
<li><kbd>uic</kbd>: The <strong>User Interface Compiler</strong> (<kbd>uic</kbd>) handles the files that are created using the Qt Designer graphical interface tool and the generation of Python code from the <kbd>gui.ui</kbd> files that are created.</li>
<li><kbd>QtTest</kbd>: This provides unit testing for the applications. It includes the <kbd>QSignalSpy</kbd> class, which provides introspection of the signals and slots.</li>
</ul>
</li>
<li><strong>Extras</strong>:
<ul>
<li><kbd>QtAndroidExtras</kbd>: Classes specific to Android platforms.</li>
<li><kbd>QtMacExtras</kbd>: Classes specific to macOS and iOS platforms.</li>
<li><kbd>QtWinExtras</kbd>: Classes specific to Windows, such as a progress indicator on the taskbar button and a thumbnail toolbar.</li>
<li><kbd>QtX11Extras</kbd>: Classes specific to the X11 windowing system.</li>
</ul>
</li>
</ul>
<p>In addition, the PyQt5 framework provides a number of utility programs:</p>
<ul>
<li><kbd>pyuic5</kbd>: A utility that converts <kbd>gui.ui</kbd> files, which are created using the Qt Designer graphical tool, into standard Python code.</li>
<li><kbd>pyrcc5</kbd>: A utility that embeds icons, images, translation files, and so on, as described by the resource collection file in any Python module.</li>
<li><kbd>pylupdate5</kbd>:<strong> </strong>A utility for extracting the translatable strings from Python code and creating/updating translation files.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">PySide2</h1>
                
            
            
                
<p>The PySide2 library, as we mentioned previously, is a coupling of the classes that were provided so that Qt could be used with Python. It is developed by the Qt project community. These libraries (PyQt and PySide) are very similar and have a construction that uses the main Qt functionality for creating GUIs with Python. In this sense, PySide2 facilitates the use of Qt5 APIs in Python applications. This gives software developers the ability to use the full potential of Qt. The PySide2 module provides access to individual Qt modules, such as Qt Widgets, Qt Core, and Qt GUI. Some of these will repeat the preceding content, but for comparison purposes, it is necessary to describe these modules here:</p>
<ul>
<li><strong>GUI creation</strong>:
<ul>
<li><kbd>QtCore</kbd>: This is the core non-GUI functionality class that provides core functionality signals/slots or calibration of the components, similar to the PyQt5 library.</li>
<li><kbd>QtWidgets</kbd>: This implements C++ classes to extend Qt GUI widget functionality and provides the graphical components, such as buttons, window, and widgets.</li>
<li><kbd>QtGui</kbd>: This has classes for the windowing system and graphics in the Qt library, such as events, OpenGL, OpenGL ES, and Vulkan integration; 2D graphics; imaging; typography fonts; and colors.</li>
<li><kbd>QtPrintSupport</kbd>: This is a cross-platform printing functionality of the Qt library.</li>
<li><kbd>QtMultimedia</kbd>: This is a low-level multimedia functionality for audio, video, radio, camera, and so on.</li>
<li><kbd>QtMultimediaWidgets</kbd>: These classes are for the creation of multimedia widgets from the Qt Multimedia Widgets module.</li>
<li><kbd>QtSql</kbd>: This is the module for database implementations in the application. This includes the drivers, SQL API, and user interface layers for SQL databases.</li>
<li><kbd>QtSvg</kbd>: This provides classes to display SVG files, such as rendering (<kbd>QSvgRenderer</kbd>) and drawing (<kbd>QSvgWidget</kbd>).</li>
<li><kbd>QtConcurrent</kbd>: This provides high-level API functionality for the concurrent execution of code. It can be used for writing multithreaded constructions of the applications without using low-level threading primitives, such as mutexes, read-write locks, wait conditions, or semaphores.</li>
</ul>
</li>
<li><strong>QML</strong>:
<ul>
<li><kbd>QtQml</kbd>:<strong> </strong>This is a Python API for the Qt QML infrastructure.</li>
<li><kbd>QtQuick</kbd>: This is a class for Qt Quick in Qt/C++ applications.</li>
<li><kbd>QtQuickWidgets</kbd>: This is the <kbd>QQuickWidget</kbd> class for Qt Quick in widget-based applications.</li>
</ul>
</li>
<li><strong>Networking and web</strong>:
<ul>
<li><kbd>QtNetwork</kbd>: This is a network programming class that allows the creation of UDP and TCP clients and servers, and includes the classes that implement HTTP clients and support DNS lookups. Options to work with sockets, network configuration, and SSL certificates are available.</li>
<li><kbd>QtWebChannel</kbd>: This is a class for peer-to-peer communication between a server and a client HTML/JavaScript or QML application.</li>
<li><kbd>QtWebEngineCore</kbd>: The core functionality is to fuse the web content, the public API shared by <kbd>QtWebEngine</kbd>, and the <kbd>QtWebEnginEWidgets</kbd> classes.</li>
<li><kbd>QtWebEngineWidgets</kbd>: This provides a web browser engine with common C++ classes to provide and collaborate with web content.</li>
<li><kbd>QtWebSockets</kbd>: Interfaces for the Qt application that can act as servers/clients that can process WebSocket requests or receive data from the server. This also includes C++ classes that enable socket-based communication.</li>
</ul>
</li>
<li><strong>3D</strong>:
<ul>
<li><kbd>Qt3DAnimation</kbd>: This is a module that provides classes with basic elements to animate 3D objects in the Qt framework.</li>
<li><kbd>Qt3DCore</kbd>: This is the Qt3D module with classes for the core types that are used for near real-time simulations, built on the Qt3D framework.</li>
<li><kbd>Qt3DExtras</kbd>: This provides prebuilt elements for working with Qt3D.</li>
<li><kbd>Qt3DInput</kbd>: This is a module with classes for handling user input with Qt3D.</li>
<li><kbd>Qt3DLogic</kbd>: This provides classes for the synchronization of frames with the Qt3D backend.</li>
<li><kbd>Qt3DRender</kbd>: This is a module with classes for 2D/3D rendering with Qt3D.</li>
<li><kbd>QtDataVisualization</kbd>: This provides classes to visualize data in 3D as surface graphs, bars, and scatter plots.</li>
</ul>
</li>
<li><strong>XML</strong>:
<ul>
<li><kbd>QtXml</kbd>: C++ implementations of the simple API for XML (SAX) and DOM interfaces with the Qt application.</li>
<li><kbd>QtXmlPatterns</kbd>: XQuery, XPath, XSLT, and XML schema validation.</li>
<li><kbd>QtScxml</kbd>: Classes for creation using state machines from SCXML files.</li>
</ul>
</li>
<li><strong>Utilities</strong>:
<ul>
<li><kbd>QtLocation</kbd>: This provides C++ interfaces for location and navigational information.</li>
<li><kbd>QtPositioning</kbd>: This provides positioning access through QML and Python interfaces to the satellite and area monitoring data.</li>
<li><kbd>QtSensors</kbd>: This provides classes for reading a system's sensor hardware via QML and Python interfaces. It also provides a motion gesture recognition API.</li>
<li><kbd>QAxContainer</kbd>: This provides the <kbd>QAxObject</kbd> object and the <kbd>QAxWidget</kbd> widget, which are used as containers for the ActiveX controls and COM objects.</li>
<li><kbd>QtCharts</kbd>: This is the most commonly used chart components.</li>
<li><kbd>QtTextToSpeech</kbd>: This is an API to access text-to-speech engines with the <kbd>QTextToSpeechEngine</kbd>, <kbd>QTextToSpeech</kbd>, and <kbd>QVoice</kbd> classes.</li>
<li><kbd>QtHelp</kbd>: This provides classes to include online help and documentation in applications.</li>
<li><kbd>QtUiTools</kbd>: This provides classes to handle Qt Designer forms.</li>
<li><kbd>QtTest</kbd>: This provides classes for unit testing of the Qt applications and libraries.</li>
</ul>
</li>
<li><strong>Extras</strong>:
<ul>
<li><kbd>QtWindowsExtras</kbd>: Classes so that you can use a number of Windows APIs with Qt.</li>
<li><kbd>QtMacExtras</kbd>: Classes specific to macOS and iOS operating systems.</li>
<li><kbd>QtX11Extras</kbd>: Information regarding the X11 configuration.</li>
</ul>
</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Application construction</h1>
                
            
            
                
<p>The two Python bindings (PyQt5 and PySide2) to the Qt library are similar in nature. The most commonly used modules are related to GUI creation. These include Qt Core, Qt Widgets, and Qt GUI. As we can see, these modules are available in both PyQt5 and PySide2. It is precisely these modules that will be examined in detail within this book. The programming approach that will be used in this book implies writing the Python code inside Python files, with a declaration of the classes, functions, variables, and so on. Before we start this exciting process, we would like to consider a slightly different way of creating the GUI application in the design part—creation involving Qt Designer.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Qt Designer</h1>
                
            
            
                
<p>This graphical user tool for creating GUI applications with Qt is available with almost all variations of the PyQt and PySide libraries, as provided by the Anaconda toolset, with PyQt5 standalone, or can be downloaded and installed with Qt. Let's try to do something with Qt Designer. For this, we just need to open Designer by clicking on the icon, or we do this through the cmd/Terminal:</p>
<pre>for Windows<br/><strong>&gt; designer.exe</strong><br/>or for Linux<br/><strong>&gt; designer-qt5</strong></pre>
<p>Now, we can see the designer window, along with options to create forms, buttons, labels, and so on. Create the simple widget and add some elements, including frames and different buttons, to the widget, as demonstrated in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/3d433afe-14ca-4020-b190-eada486f19b0.png"/></p>
<p>Then, we need to save this file with a name, such as <kbd>design_app</kbd><strong>.</strong> It should be noted that Qt Designer uses XML <kbd>*.ui</kbd> files to store designs and does not generate any code itself. Choose the Save option and then save the file as <kbd>design_app.ui</kbd> in the <kbd>App/</kbd><strong> </strong>directory. As a result, we will have a file with a UI extension and XML inside it. However, it would be preferable for this file to be a Python file containing Python code. To do this, we need to convert this code into Python with the help of an additional utility—<kbd>pyuic5</kbd> (PyQt5) or <kbd>pyside2-uic</kbd> (PySide2). Type the following command in the cmd/Terminal:</p>
<pre><strong>&gt; cd /Path/to/the/App</strong><br/>PySide2<br/><strong>&gt; pyside2-uic -o design_app.py design_app.ui</strong><br/>PyQt5<br/><strong>&gt; pyuic5 -o design_app.py design_app.ui</strong></pre>
<p>Now, we can see the <kbd>design_app.py</kbd> file with Python code inside the <kbd>App/</kbd><strong> </strong>directory. </p>
<p>This book will not describe GUI development with Qt Designer. This brief introduction to this tool is sufficient to understand how a developer can use Qt Designer.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting started with GUI</h1>
                
            
            
                
<p>Following this brief introduction to Qt Designer, let's move on to the main objective of this book, namely, the correct choice in terms of the construction and writing of the qualitative Python code for the application with the GUI. Most programming practices require an understanding of the functionality and the form of the future application in order to appreciate how everything in the application works. But this is not what we will do. We will use Python—a real-time dynamic programming language that gives us the opportunity to implement almost everything in the world in a graphical window. We need to start low and go high.</p>
<p>First, we need to organize the directories with application files in the correct manner. Although this book will demonstrate examples of both bindings, it is recommended that you create directories, such as <kbd>App/App_PySide2</kbd> and <kbd>App/App_PyQt5</kbd>,<strong> </strong>inside the <kbd>App/</kbd><strong> </strong>directory. But if your choice of a certain Python binding has been made, it's not obligatory. Then, we need to execute a rewrite of the files, as we described in previous chapters, and add some more files. There are many different ways to create GUI applications. If the GUI app that will be created is small in size, on a small scale, or simply provides a limited functionality, for example, only performing several functions, it makes sense to put the code in a single file.</p>
<p>However, this is a bad idea, because each application can be rebuilt, updated, upgraded, or enlarged with additional code. And splitting the small application into several files will have no, or almost no, effect on performance and productivity. On the other hand, incorporating large-scale application code in a single file will lead to problems in terms of editors reading this file, as well as maintenance problems, and confusion in general. Problems may also arise in regards to rebuilding and changing the functionality. For example, if some style properties need to be changed, it will be necessary to find these parameters, and something will always go unnoticed. GUI applications usually have many lines of code, unlike the lines of functions for some special operations. In other words, it is a good idea to split the application between the different files in some way and import classes and functions from these files to the file with the main GUI application. This is the art of programming—to create applications with files, classes, and functions in the right places. We need to understand that some of them need to be located in the spaces that are allowed in order to exclude the problems associated with namespacing. We will utilize the <strong>object-oriented programming</strong> (<strong>OOP</strong>) approach, which means that we want to use the code many times in different places, and sometimes in other applications in the future. In addition, the styling code of GUI applications commonly requires many lines.</p>
<p>Based on this, let's split the application into the three files as they are created: <kbd>u_app.py</kbd>, <kbd>u_tools.py</kbd>, and a <kbd>u_style.py</kbd> file that we will add now. Then, put them into the <kbd>App/App_PySide2</kbd> and <kbd>App/App_PyQt5</kbd> directories. The <kbd>u_app.py</kbd> file will contain the main class of the GUI application, along with instructions to run it. Change the code inside as follows.</p>
<p>With regards to the <kbd>u_app.py</kbd> file, the following code creates the class with PyQt5:</p>
<pre># -*- coding: utf-8 -*-<br/>from u_tools import UTools<br/>from u_style import UWid<br/><br/><br/>class UApp(UWid, UTools):<br/><br/>    def __init__(self, parent=None):<br/>        super(UApp, self).__init__(parent)<br/>        UTools.__init__(self)<br/>        print(self.us1)<br/><br/><br/>if __name__ == "__main__":<br/>    import sys<br/>    from PyQt5 import QtWidgets, QtCore, QtGui<br/>    print(sys.argv)<br/>    app = QtWidgets.QApplication(sys.argv)<br/>    uap = UApp()<br/>    uap.show()<br/>    sys.exit(app.exec_())</pre>
<p>In this file, we are creating the main class of the GUI application. This class will combine all of the functionality from the other modules (third-party packages) and create the application.</p>
<p>In the case of the PySide2 <kbd>u_app.py</kbd> file, we have the following:</p>
<pre># -*- coding: utf-8 -*-<br/>from u_tools import UTools<br/>from u_style import UWid<br/><br/><br/>class UApp(UWid, UTools):<br/><br/>    def __init__(self, parent=None):<br/>        super(UApp, self).__init__(parent)<br/>        UTools.__init__(self)<br/>        print self.us1<br/><br/><br/>if __name__ == "__main__":<br/>    import sys<br/>    from PySide2 import QtWidgets, QtCore, QtGui<br/>    print sys.argv<br/>    app = QtWidgets.QApplication(sys.argv)<br/>    uap = UApp()<br/>    uap.show()<br/>    sys.exit(app.exec_())</pre>
<p>This is the file with the main class that will be used with the PySide2 binding to Qt. The <kbd>u_tools.py</kbd> file will contain the classes and functions to provide some functionality or additional features for the GUI application.</p>
<p>Change the content of this file to the following in the case of the PyQt5 <kbd>u_tools.py</kbd> file:</p>
<pre># -*- coding: utf-8 -*-<br/><br/>class UTools(object):<br/><br/>    def __init__(self):<br/>        self.us1 = "Application with Python."<br/><br/><br/>if __name__ == "__main__":<br/>    ut = UTools()</pre>
<p>This is the file that includes classes. We will use convenient functions that are not related, in the full sense, to the GUI representation of the application here.</p>
<p>In the case of the PySide2 <kbd>u_tools.py</kbd> file, we have the following:</p>
<pre># -*- coding: utf-8 -*-<br/><br/>class UTools(object):<br/><br/>    def __init__(self):<br/>        self.us1 = "Application with Python."<br/><br/><br/>if __name__ == "__main__":<br/>    ut = UTools()</pre>
<p>Where possible, we will avoid differences in syntax, used modules, and classes between the Python versions and Python bindings in the Qt library (PySide2/PyQt5).</p>
<p>The <kbd>u_style.py</kbd> file will contain the classes and functions that provide styling to the GUI application, including widgets, buttons, labels, frames, colors, and fonts.</p>
<p>In the case of the PyQt5 <kbd>u_style.py</kbd> file, we have the following:</p>
<pre># -*- coding: utf-8 -*-<br/>from PyQt5 import QtWidgets, QtCore, QtGui<br/><br/>color = ["rgba(0,41,59,140)",<br/>         "rgba(0,41,59,255)"]<br/><br/><br/>class UWid(QtWidgets.QWidget):<br/><br/>    def __init__(self, parent=None):<br/>        super(UWid, self).__init__(parent)<br/>        self.setWindowTitle("U App")<br/>        self.setStyleSheet("background-color: %s;" % (<br/>                            color[0],))<br/><br/></pre>
<p>These styling files will only contain graphically related objects and graphics properties. </p>
<p>In the case of the PySide2 <kbd>u_style.py</kbd> file, we have the following:</p>
<pre># -*- coding: utf-8 -*-<br/>from PySide2 import QtWidgets, QtCore, QtGui<br/><br/>color = ["rgba(0,41,59,140)",<br/>         "rgba(0,41,59,255)"]<br/><br/><br/>class UWid(QtWidgets.QWidget):<br/><br/>    def __init__(self, parent=None):<br/>        super(UWid, self).__init__(parent)<br/>        self.setWindowTitle("U App")<br/>        self.setStyleSheet(<br/>                           "background-color: %s;" % (<br/>                            color[0],))</pre>
<p>As we can see, the only differences between the PySide2 and PyQt5 bindings is in the name import statements and in the printing of the <kbd>string</kbd> variable, which depends on the different Python versions. Throughout this book, the code in these files will be augmented or changed as we add new elements, widgets, and functionality.</p>
<p class="mce-root"/>
<p>For now, these applications can be run using the cmd/Terminal command:</p>
<pre>### PySide2 ###<br/><strong>&gt; cd Path/to/App/App_PySide2</strong><br/><strong>&gt; Path/to/Python2/python u_app.py</strong><br/>### PyQt5 ###<br/><strong>&gt; cd Path/to/App/App_PyQt5</strong><br/><strong>&gt; Path/to/Python3/python u_app.py</strong></pre>
<p>We will get the same result, in other words, an empty widget:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/9b58da04-ba27-4781-829d-0becb2b99f6a.png" style="width:46.08em;height:29.58em;"/></p>
<p>In the cmd/Terminal, we have the same output that we did when the system arguments were passed with <kbd>QApplication</kbd>, that is, a list with the name of the application and a <kbd>string</kbd> variable of the <kbd>UTools</kbd> class.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Application features</h1>
                
            
            
                
<p>Let's consider the process that will be executed when the application is created and run the <kbd>u_app.py</kbd> file with the script. Let's look at what happens, line by line:</p>
<ol start="1">
<li>In the <kbd>u_app.py</kbd> file, the import section that import the <kbd>UTools</kbd> class, which will provide some functionality, was fixed, including functions, or, like it was in this case, <kbd>string</kbd> variables with text. The <kbd>UWid</kbd> class, which implements <kbd>Qwidget</kbd> (a widget that will be shown as a graphical element), will also be imported.</li>
<li>The <kbd>UApp</kbd> class is created. This is the main class of the application and will contain the tools, functions, elements, and layouts for these elements, as well as additional features. This class will inherit the <kbd>UTools</kbd> and <kbd>UWid</kbd> classes in order to realize their functionalities.</li>
<li>Instructions such as <kbd>if __name__ == "__main__"</kbd> specify whether this file will run from the cmd/Terminal or in another way, such as an executable script. The <kbd>__name__</kbd> variable will contain the <kbd>"__main__"</kbd> value, and instructions to the <kbd>if</kbd> statement will be realized. In other cases, if the classes, functions, or variables of this file are imported into another application or code, these instructions will not be realized, and the imported code will be used as an element in another construction that implies the OOP approach. These instructions are as follows:
<ul>
<li><kbd>import sys</kbd>—this is how you import the <kbd>sys</kbd> module from the standard Python library. The <kbd>sys</kbd> module provides access to the variables and functions that are used, maintained, or interact with the Python interpreter.</li>
<li>Importing <kbd>QtWidgets</kbd>, <kbd>QtGui</kbd>, and <kbd>QtCore</kbd>—these most commonly used modules for creating the application, adding graphical elements, working with features such as images, colors, and fonts, and core functions to provide functionality, such as events, signals and slots, and configuration.</li>
<li>Declaration of the object of the <kbd>QApplication</kbd> class from the <kbd>QtWidgets</kbd> module: The inheritance scheme of this class is <kbd>QtCore.QObject</kbd>—<kbd>QtCore.QCoreApplication</kbd>—<kbd>QtGui.QGuiApplication</kbd>—<kbd>QtWidgets.QApplication</kbd>. This class provides the main settings and control flow for the GUI application. For any Qt GUI application, there is precisely one <kbd>QApplication</kbd> object. The <kbd>qApp</kbd> attribute provides access to the <kbd>QApplication</kbd> object from any place in the application. This object takes the <kbd>sys.argv</kbd> parameter, which is the list of command-line arguments that are passed to a Python script. As we can see in the cmd/Terminal output, this parameter has the name of the file that contains the script (<kbd>u_app.py</kbd>).</li>
<li>Creating the class instance of the main application class with a widget and calling the <kbd>show()</kbd> method to visualize the widget: In the other case, if we do not implement the instance and do not call the <kbd>show()</kbd> method, the application will be created but not visualized in the GUI performance because we will not have a visual element (<kbd>Qwidget</kbd>, in this case). <kbd>sys.exit(app.exec_())</kbd> is the line that's used to execute the application; all lines of code that follow will not be executed. <kbd>sys.exit()</kbd> is the <kbd>exit()</kbd> method of the <kbd>sys</kbd> module and will exit from Python. This means that the program will be exited if an error occurs or will be closed with the application window. <kbd>app.exec_()</kbd> starts the main loop of the application, and returns the status code (success = <kbd>0</kbd>) , such as application exit or the appearance of some error, that will be used with <kbd>sys.exit()</kbd>.</li>
</ul>
</li>
</ol>
<p>If we run the file with application definitions from the cmd/Terminal, or by other means, this starts the application in an infinite loop and will continue until the application is closed or another exit event arises. To demonstrate these features, let's temporarily add to the <kbd>u_app.py</kbd> file, including instructions to run, along with some informative lines.</p>
<p>In the case of the PyQt5 <kbd>u_app.py</kbd> file, we have the following:</p>
<pre>...<br/>if __name__ == "__main__":<br/>    ...<br/>    print(" sys list of arguments: ", sys.argv)<br/>    print("qApp list of arguments: ", QtWidgets.qApp.arguments())<br/>    print("Application Process ID: ", QtWidgets.qApp.applicationPid())<br/>    print("  Application instance: ", QtWidgets.qApp.instance())<br/>    print("     Application state: ", QtWidgets.qApp.applicationState())<br/>    print("  Application platform: ", QtWidgets.qApp.platformName())<br/>    print("   List of the widgets: ", QtWidgets.qApp.allWidgets())<br/>    sys.exit(app.exec_())</pre>
<p>In the case of the PySide2 <kbd>u_app.py</kbd> file, we have the following:</p>
<pre>...<br/>if __name__ == "__main__":<br/>    ...<br/>    print " sys list of arguments: ", sys.argv<br/>    print "qApp list of arguments: ", QtWidgets.qApp.arguments()<br/>    print "Application Process ID: ", QtWidgets.qApp.applicationPid()<br/>    print "  Application instance: ", QtWidgets.qApp.instance()<br/>    print "     Application state: ", QtWidgets.qApp.applicationState()<br/>    print "  Application platform: ", QtWidgets.qApp.platformName()<br/>    print "   List of the widgets: ", QtWidgets.qApp.allWidgets()<br/>    sys.exit(app.exec_())</pre>
<p>Run these files in the cmd/Terminal:</p>
<pre>### PyQt5 ###<br/><strong>&gt; cd Path/to/App/App_PyQt5</strong><br/><strong>&gt; Path/to/Python3/python u_app.py</strong><br/>### PySide2 ###<br/><strong>&gt; cd Path/to/App/App_PySide2</strong><br/><strong>&gt; Path/to/Python2/python u_app.py</strong></pre>
<p>The results in the case of the PyQt5 <kbd>u_app.py</kbd> file will be as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/40836d3e-7b18-4876-af24-35e53a28f508.png"/></p>
<p>The results in the case of the PySide2 <kbd>u_app.py</kbd> file will be as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/46d608b1-e9d3-44bd-8338-4456944d641b.png"/></p>
<p>By implementing the preceding steps, we have constructed our application!</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>This was the final introductory chapter of this book and the final chapter of the first section. In this chapter, we covered the creation of the GUI application with the PyQt5 and PySide2 Python bindings. All of the chapters that follow will continue this theme. It is highly recommended that you review the code of the various examples regarding comparisons of the different Python bindings to the Qt library. This chapter included a brief description of PyQt5 and PySide, which may help when it comes to choosing one of these frameworks. Both bindings have numerous advantages and some disadvantages too.</p>
<p>The next chapter will consider the <kbd>QWidget</kbd> and <kbd>QMainWindow</kbd> classes, which provide the main window and widgets window for displaying the GUI application.</p>


            

            
        
    </body></html>