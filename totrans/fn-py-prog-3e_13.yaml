- en: '13'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The PyMonad Library
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'A monad allows us to impose an order on an expression evaluation in an otherwise
    lenient language. We can use a monad to insist that an expression such as `a`` +`` b`` +`` c`
    is evaluated in left-to-right order. This can interfere with the compiler’s ability
    to optimize expression evaluation. This is necessary, however, when we want files
    to have their content read or written in a specific order: a monad is a way to
    assure that the `read()` and `write()` functions are evaluated in a particular
    order.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Languages that are lenient and have optimizing compilers benefit from monads
    imposing order on the evaluation of expressions. Python, for the most part, is
    strict and does not optimize, meaning there are few practical requirements for
    monads in Python.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: While the PyMonad package contains a variety of monads and other functional
    tools, much of the package was designed to help folks understand functional programming
    using Python syntax. We’ll focus on a few features to help clarify this point
    of view.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll look at the following:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: Downloading and installing PyMonad
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The idea of currying and how this applies to functional composition
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The PyMonad star operator for creating composite functions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functors and techniques for currying data items with more generalized functions
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `bind()` operation, using the Python `>>` operator, to create ordered monads
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We’ll also explain how to build a Markov chain simulation using PyMonad techniques
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What’s important is that Python doesn’t require the use of monads. In many cases,
    the reader will be able to rewrite the example using pure Python constructs. Doing
    this kind of rewrite can help solidify one’s understanding of functional programming.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: 13.1 Downloading and installing
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The PyMonad package is available on the Python Package Index (PyPI). In order
    to add PyMonad to your environment, you’ll need to use the `python`` -m`` pip`` pymonad`
    command to install it.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: This book used version 2.4.0 to test all of the examples. Visit [https://pypi.python.org/pypi/PyMonad](https://pypi.python.org/pypi/PyMonad)
    for more information.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the PyMonad package is installed, you can confirm it using the following
    commands:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This will display the module’s docstring and confirm that things really are
    properly installed.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: The overall project name, PyMonad, uses mixed case. The installed Python package
    name that we import, `pymonad`, is all lower case.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: 13.2 Functional composition and currying
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Some functional languages work by transforming a multi-argument function syntax
    into a collection of single argument functions. This process is called currying:
    it’s named after logician Haskell Curry, who developed the theory from earlier
    concepts. We’ve looked at currying in depth in [Chapter 11](Chapter_11.xhtml#x1-23500011),
    [The Toolz Package](Chapter_11.xhtml#x1-23500011). We’ll revisit it from the PyMonad
    perspective here.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: 'Currying is a technique for transforming a multi-argument function into higher-order
    single argument functions. In a simple case, consider a function f(x,y) → z; given
    two arguments x and y; this will return some resulting value, z. We can curry
    the function f(x,y) into into two functions: f[c1](x) → f[c2](y) and f[c2](y)
    → z. Given the first argument value, x, evaluating the function f[c1](x) returns
    a new one-argument function, f[c2](y). This second function can be given the second
    argument value, y, and it returns the desired result, z.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: 'We can evaluate a curried function in Python with concrete argument values
    as follows: `f_c1(2)(3)`. We apply the curried function to the first argument
    value of 2, creating a new function. Then, we apply that new function to the second
    argument value of 3.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at a concrete example in Python. For example, we have a function
    like the following one:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This is a simple, multiple-regression-based model for systolic blood pressure.
    This predicts blood pressure from body mass index (BMI), age, gender (a value
    of 1 means male), and history of previous treatment (a value of 1 means previously
    treated). For more information on the model and how it’s derived, visit [http://sphweb.bumc.bu.edu/otlt/MPH-Modules/BS/BS704_Multivariable/BS704_Multivariable7.html](http://sphweb.bumc.bu.edu/otlt/MPH-Modules/BS/BS704_Multivariable/BS704_Multivariable7.html).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the `systolic_bp()` function with all four arguments, as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: A male person with a BMI of 25, age 50, and no previous treatment is predicted
    to have a blood pressure near 116\. The second example shows a similar woman with
    a history of treatment who will likely have a blood pressure of 121.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: 'Because we’ve used the `@curry` decorator, we can create intermediate results
    that are similar to partially applied functions. Take a look at the following
    command snippet that creates a new function, `treated()`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the preceding case, we evaluated the `systolic_bp(25,`` 50,`` 0)` expression
    to create a curried function and assigned this to the `treated` variable. This
    built a new function, `treated`, with values for some of the parameters. The BMI,
    age, and gender values don’t typically change for a given patient. We can now
    apply the new `treated()` function to the remaining argument value to get different
    blood pressure expectations based on patient history.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of creating some additional curried functions:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This is a gender-based treatment function based on our initial model. We must
    provide both the needed gender and treatment argument values to get a final value
    from the model.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: This is similar in some respects to the `functools.partial()` function. The
    important difference is that currying creates a function that can work in a variety
    of ways. The `functools.partial()` function creates a more specialized function
    that can only be used with the given set of bound values. For more information,
    see [Chapter 10](Chapter_10.xhtml#x1-21700010), [The Functools Module](Chapter_10.xhtml#x1-21700010).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: 13.2.1 Using curried higher-order functions
  id: totrans-37
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An important application of currying shows up when we use it on higher-order
    functions. We can, for example, curry the `reduce` function, as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `creduce()` function is a curried function; we can now use it to create
    functions by providing some of the required argument values. In the next example,
    we will use `operator.add` as one of the two argument values to reduce. We can
    create a new function, and assign this to `my_sum`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create and use this new `my_sum()` function as shown in the following
    example:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We can also use our curried `creduce()` function with other binary operators
    to create other reductions. The following shows how to create a reduction function
    that finds the maximum value in a sequence:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We defined our own version of the default `max()` function using a lambda object
    that picks the larger of two values. We could use the built-in `max()` function
    for this. More usefully, we could use more sophisticated comparisons among items
    to locate a local maxima. For geofencing applications, we might have a maximum
    east-west function separate from a maximum north-south function.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: We can’t easily create the more general form of the `max()` function using the
    PyMonad `curry()` function. This implementation is focused on positional parameters.
    Trying to use the `key=` keyword parameter adds too much complexity to make the
    technique work toward our overall goals of succinct and expressive functional
    programs.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: The built-in reductions including the `max()`, `min()`, and `sorted()` functions
    all rely on an optional `key=` keyword parameter paradigm. Creating curried versions
    means we need variants of these that accept a function as the first argument in
    the same way as the `filter()`, `map()`, and `reduce()` functions do. We could
    also create our own library of more consistent higher-order curried functions.
    These functions would rely exclusively on positional parameters, and follow the
    pattern of providing the function first and the values last.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: 13.2.2 Functional composition with PyMonad
  id: totrans-48
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: One of the significant benefits of using curried functions is the ability to
    combine them through functional composition. We looked at functional composition
    in [Chapter 5](Chapter_05.xhtml#x1-1000005), [Higher-Order Functions](Chapter_05.xhtml#x1-1000005),
    and [Chapter 12](Chapter_12.xhtml#x1-25000012), [Decorator Design Techniques](Chapter_12.xhtml#x1-25000012).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: When we’ve created a curried function, we can more easily perform function composition
    to create a new, more complex curried function. In this case, the PyMonad package
    defines the `*` operator for composing two functions. To explain how this works,
    we’ll define two curried functions that we can compose. First, we’ll define a
    function that computes the product, and then we’ll define a function that computes
    a specialized range of values.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s our first function, which computes the product:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This is based on our curried `creduce()` function that was defined previously.
    It uses the `operator.mul()` function to compute a times-reduction of an iterable:
    we can call a product a times-reduce of a sequence.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s our second curried function that will produce a range of even or odd
    values:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The result of the `alt_range()` function will be even values or odd values.
    It will have only odd values up to (and including) `n`, if `n` is odd. If `n`
    is even, it will have only even values up to `n`. The sequences are important
    for implementing the semifactorial or double factorial function, n!!.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how we can combine the `prod()` and `alt_range()` functions to compute
    a result:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: One very interesting use of curried functions is the idea of creating a composition
    of those functions that can be applied to argument values. The PyMonad package
    provides operators for this, but they can be confusing. What seems better is making
    use of the `Compose` subclass of `Monad`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use `Compose` to implement functional composition in a direct way. The
    following example shows how we can compose our `alt_range()` and `prod()` functions
    to compute the semifactorial:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We’ve built a `Compose` monad from the `alt_range()` function composed with
    the `prod()` function. The resulting function can be applied to an argument value
    to compute a result from the composition of the two functions.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: Using curried functions can help to clarify a complex computation by eliding
    some of the argument-passing details.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the `then()` method imposes a strict ordering: first, compute the
    range. Once that is done, use the result to compute the final product.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: 13.3 Functors – making everything a function
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The idea of a functor is a functional representation of a piece of simple data.
    A functor version of the number 3.14 is a function of zero arguments that returns
    this value. Consider the following example:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We created a zero-argument lambda object that returns a Python float object.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: When we apply a curried function to a functor, we’re creating a new curried
    functor. This generalizes the idea of applying a function to an argument to get
    a value by using functions to represent the arguments, the values, and the functions
    themselves.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: Once everything in our program is a function, then all processing becomes a
    variation on the theme of functional composition. To recover the underlying Python
    object, we can use the `value` attribute of a functor object to get a Python-friendly,
    simple type that we can use in uncurried code.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: Since this kind of programming is based on functional composition, no calculation
    needs to be done until we actually demand a value using the `value` attribute.
    Instead of performing a lot of intermediate calculations, our program defines
    intermediate complex objects that can produce a value when requested. In principle,
    this composition can be optimized by a clever compiler or runtime system.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: In order to work politely with functions that have multiple arguments, PyMonad
    offers a `to_arguments()` method. This is a handy way to clarify the argument
    value being provided to a curried function. We’ll see an example of this below,
    after introducing the `Maybe` and `Just` monads.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: We can wrap a Python object with a subclass of the `Maybe` monad. The `Maybe`
    monad is interesting, because it gives us a way to deal gracefully with missing
    data. The approach we used in [Chapter 12](Chapter_12.xhtml#x1-25000012), [Decorator
    Design Techniques](Chapter_12.xhtml#x1-25000012), was to decorate built-in functions
    to make them `None`-aware. The approach taken by the PyMonad library is to decorate
    the data to distinguish something that’s just an object from nothing.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two subclasses of the `Maybe` monad:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '`Nothing`'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Just(` some Python object `)`'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We use `Nothing` similarly to the Python value of `None`. This is how we represent
    missing data. We use `Just()` to wrap all other Python objects. These are also
    functors, offering function-like representations of constant values.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use a curried function with these `Maybe` objects to tolerate missing
    data gracefully. Here’s a short example:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This shows us how a monad can provide an answer instead of raising a `TypeError`
    exception. This can be very handy when working with large, complex datasets in
    which data could be missing or invalid.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: We must use the `value` attribute to extract the simple Python value for uncurried
    Python code.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: 13.3.1 Using the lazy ListMonad() monad
  id: totrans-82
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `ListMonad()` monad can be confusing at first. It’s extremely lazy, unlike
    Python’s built-in list type. When we evaluate the a `list(range(10))` expression,
    the `list()` function will evaluate the `range()` object to create a list with
    10 items. The PyMonad `ListMonad()` monad, however, is too lazy to even do this
    evaluation.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the comparison:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `ListMonad()` monad did not evaluate the `range()` object’s iterable sequence
    of values; it preserved it without being evaluated. A `ListMonad()` monad is useful
    for collecting functions without evaluating them.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: 'We can evaluate the `ListMonad()` monad later as required:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We created a lazy `ListMonad()` object which contained a `range()` object. Then
    we extracted and evaluated a `range()` object at position 0 in that list.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: A `ListMonad()` object won’t evaluate a generator function. It treats any iterable
    argument as a single iterator object. We can, later, apply the function being
    contained by the monad.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a curried version of the `range()` function. This has a lower bound
    of 1 instead of 0\. It’s handy for some mathematical work because it allows us
    to avoid the complexity of the positional arguments in the built-in `range()`
    function:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We wrapped the built-in `range()` function to make it curryable by the PyMonad
    package.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: Since a `ListMonad` object is a functor, we can map functions to the `ListMonad`
    object. The function is applied to each item in the `ListMonad` object.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We defined a composite function, `fact()`, which was built from the `prod()`
    and `range1n()` functions shown previously. This is the factorial function. We
    created a `ListMonad()` functor, `seq1`, which is a sequence of 20 values. We
    mapped the `fact()` function to the `seq1` functor, which created a sequence of
    factorial values, `f1`. Finally, we extracted the first 10 of these values.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s another little function that we’ll use to extend this example:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This little `n21()` function does a simple computation. It’s curried, however,
    so we can apply it to a functor such as a `ListMonad()` object. Here’s the next
    part of the preceding example:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We’ve defined a composite function from the `prod()` and `alt_range()` functions
    shown previously. The value of the `f2` object is built by mapping our small `n21()`
    function applied to the `seq1` sequence. This creates a new sequence. We then
    applied the `semi_fact()` function to each object in this new sequence to create
    a sequence of values that are parallels to the `f1` sequence of values.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now map the `/` operator, `operator.truediv`, to these two parallel
    sequences of values, `f1` and `f2`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The built-in `map()` function will apply the given operator to both functors,
    yielding a sequence of fractions that we can add.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: 'We defined a fairly complex calculation using a few functional composition
    techniques and a functor class definition. This is based on a computation for
    the arctangent. Here’s the full definition for this calculation:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '![ ∑ ---n!---- π = 2 (2n + 1)!! 0≤n<∞ ](img/file119.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
- en: Ideally, we prefer not to use a fixed-size `ListMonad` object with only twenty
    values. We’d prefer to have a lazy and potentially infinite sequence of integer
    values, allowing us an approximation of arbitrary accuracy. We could then use
    curried versions of the `sum()` and `takewhile()` functions to find the sum of
    values in the sequence until the values are too small to contribute to the result.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: This rewrite to use the `takewhile()` function is left as an exercise for the
    reader.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: 13.4 Monad bind() function
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The name of the PyMonad library comes from the functional programming concept
    of a monad, a function that has a strict order. The underlying assumption behind
    much functional programming is that functional evaluation is liberal: it can be
    optimized or rearranged as necessary. A monad provides an exception that imposes
    a strict left-to-right order.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: PyMonad库的名字来源于函数式编程中的单子概念，即具有严格顺序的函数。许多函数式编程背后的基本假设是函数式评估是自由的：它可以按需优化或重新排序。单子提供了一个例外，强制执行从左到右的严格顺序。
- en: Python, as we have seen, is already strict. It doesn’t require monads. We can,
    however, still apply the concept in places where it can help clarify a complex
    algorithm. We’ll look at an example, below, of using a monad-based approach to
    designing a simulation based on Markov chains.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，Python已经是严格的。它不需要单子。然而，我们仍然可以在有助于澄清复杂算法的地方应用这个概念。下面我们将通过一个例子来看使用基于单子的方法来设计基于马尔可夫链的模拟。
- en: The technology for imposing strict evaluation is a binding between a monad and
    a function that will return a monad. A flat expression will become nested bindings
    that can’t be reordered by an optimizing compiler. The `then()` method of a monad
    imposes this strict ordering.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 强制严格评估的技术是连接一个单子（monad）和一个将返回单子的函数的绑定。一个平坦的表达式将变成嵌套的绑定，优化编译器无法重新排序。单子的`then()`方法强制这种严格的顺序。
- en: In other languages, such as Haskell, a monad is crucial for file input and output
    where strict ordering is required. Python’s imperative mode is much like a Haskell
    `do` block, which has an implicit Haskell `>>=` operator to force the statements
    to be evaluated in order. PyMonad uses the `then()` method for this binding.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他语言中，如Haskell，单子对于需要严格顺序的文件输入和输出至关重要。Python的命令式模式与Haskell的`do`块非常相似，它有一个隐式的Haskell
    `>>=`运算符，用于强制按顺序评估语句。PyMonad使用`then()`方法进行这种绑定。
- en: 13.5 Implementing simulation with monads
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.5 使用单子实现模拟
- en: 'Monads are expected to pass through a kind of pipeline: a monad will be passed
    as an argument to a function and a similar monad will be returned as the value
    of the function. The functions must be designed to accept and return similar structures.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 预期单子将通过一种管道：单子将被作为参数传递给一个函数，并且将返回一个类似的单子作为函数的值。函数必须设计成可以接受和返回类似的结构。
- en: We’ll look at a monad-based pipeline that can be used for simulation of a process.
    This kind of simulation is sometimes called a Monte Carlo simulation. In this
    case, the simulation will create a Markov chain.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将研究一个可以用于过程模拟的单子基础管道。这种模拟有时被称为蒙特卡洛模拟。在这种情况下，模拟将创建一个马尔可夫链。
- en: A Markov chain is a model for a series of potential events. The probability
    of each event depends only on the state attained in the previous event. Each state
    of the overall system had a set of probabilities that define the events and related
    state changes. It fits well with games that involve random chance, like dice or
    cards. It also fits well with industrial processes where small random effects
    can ”ripple through” the system, leading to effects that may not appear to be—directly—related
    to tiny initial problems.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 马尔可夫链是一系列潜在事件的模型。每个事件发生的概率只取决于前一个事件中达到的状态。整个系统的每个状态都有一个概率集，这些概率定义了事件和相关状态变化。它非常适合涉及随机机会的游戏，如骰子或牌戏。它也适合于工业流程，其中小的随机效应可以“波及”整个系统，导致可能看似与微小初始问题直接无关的效果。
- en: Our example involves some rules for a fairly complex simulation. We can visualize
    the following state changes shown in Figure 13.1 as creating a chain of events
    that ends with either a Pass or Fail event. The number of events has a lower bound
    of 1.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的例子涉及一些相当复杂模拟的规则。我们可以将图13.1中显示的以下状态变化可视化为创建一个以通过或失败事件结束的事件链。事件的数量有一个下限为1。
- en: '![Figure 13.1: Markov chain generator ](img/file120.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.1：马尔可夫链生成器](img/file120.jpg)'
- en: 'Figure 13.1: Markov chain generator'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.1：马尔可夫链生成器
- en: The state transition probabilities are stated as fractions, ![n- 36](img/file121.jpg),
    because this particular Markov chain generator comes from a game that uses two
    dice. There are 36 possible outcomes from a roll of the dice. When considering
    the sum of the two dice, the 10 distinct values have probabilities ranging from
    ![-1 36](img/file122.jpg) for the values 2 and 12, to ![ 6 36](img/file123.jpg)
    for the value 7.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: Because this is based on a game, the actual algorithm is somewhat simpler than
    the diagram of the state transitions. The trick in simplifying the algorithm description
    is combining a number of similar behaviors into a single state defined by a parameter,
    p.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm’s use of an internal state. For designers new to functional programming,
    this is a bit of a problem. The solution that we’ve shown in other examples is
    to expose the state as a parameter to a function.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start with a presentation of the algorithm with explicit state.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '![Algorithm 9: Markov chain generator ](img/Algo_13.1.JPG)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
- en: 'Algorithm 9: Markov chain generator'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm can be seen as requiring a state change. Alternatively, we can
    look at this as a sequence of operations to append to the Markov chain, rather
    than a state change. There’s one function that must be used first to create an
    initial outcome or establish the value of p. Another, recursive function is used
    after that to iterate until an outcome is determined. In this way, this pairs-of-functions
    approach fits the monad design pattern nicely.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: 'To build Markov chains, we’ll need a source of random numbers:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The preceding function will generate a pair of dice for us. We also included
    a type hint, `DiceT`, that can be used to describe any similar function that returns
    a tuple with two integers. The type hint will be used in later functions as a
    shorthand for any similar random number generator.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s our expectations from the overall chain generator based on the game
    algorithm:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We create an initial monad, `Just(("",`` 0,`` []))`, to define the essential
    type we’re going to work with. A game will produce a three-tuple with the outcome
    text, the point value, and a sequence of rolls. At the start of each game, a default
    three-tuple establishes the three-tuple type.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: We pass this monad to two other functions. This will create a resulting monad,
    `outcome`, with the results of the game. We use the `then()` method to connect
    the functions in the specific order they must be executed. In a language with
    an optimizing compiler, this will prevent the expression from being rearranged.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: We will get the value of the monad at the end using the `value` attribute. Since
    the monad objects are lazy, this request is what triggers the evaluation of the
    various monads to create the required output.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: Each resulting sequence of three-tuples is a Markov chain we can analyze to
    determine the overall statistical properties. We’re often interested in the expected
    lengths of the chains. This can be difficult to predict from the initial model
    or the algorithm.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: The `initial_roll()` function has the `rng()` function curried as the first
    argument. The monad will become the second argument to this function. The `initial_roll()`
    function can roll the dice and apply the come out rule to determine if we have
    a pass, a fail, or a point.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: The `point_roll()` function also has the `rng()` function curried as the first
    argument. The monad will become the second argument. The `point_roll()` function
    can then roll the dice to see if the game is resolved. If the game is unresolved,
    this function will operate recursively to continue looking for a resolution.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: 'The `initial_roll()` function looks like this:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The dice are rolled once to determine if the initial outcome is pass, fail,
    or establish the point. We return an appropriate monad value that includes the
    outcome, a point value, and the roll of the dice that led to this state. The point
    values for an immediate pass and immediate fail aren’t really meaningful. We could
    sensibly return a 0 value here, since no point was really established.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: For developers using tools like pylint, the `status` argument isn’t used. This
    creates a warning that needs to be silenced. Adding a `#`` pylint:`` disable=`
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '`unused-argument` comment will silence the warning.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: 'The `point_roll()` function looks like this:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We decomposed the status monad into the three individual values of the tuple.
    We could have used small lambda objects to extract the first, second, and third
    values. We could also have used the `operator.itemgetter()` function to extract
    the tuple’s items. Instead, we used multiple assignment.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: If a point was not established, the previous state will be pass or fail. The
    game was resolved during the `initial_roll()` function, and this function simply
    returns the status monad.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: If a point was established, the state will be point. The dice is rolled and
    rules applied to this new roll. If roll is 7, the game is a lost and a final monad
    is returned. If the roll is the point, the game is won and the appropriate monad
    is returned. Otherwise, a slightly revised monad is passed to the `point_roll()`
    function. The revised status monad includes this roll in the history of rolls.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: 'A typical output looks like this:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The final monad has a string that shows the outcome. It has the point that was
    established and the sequence of dice rolls leading to the final outcome.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: We can use simulation to examine different outcomes to gather statistics on
    this complex, stateful process. This kind of Markov-chain model can reflect a
    number of odd edge cases that lead to surprising distributions of results.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: A great deal of clever Monte Carlo simulation can be built with a few simple,
    functional programming design techniques. The monad, in particular, can help to
    structure these kinds of calculations when there are complex orders or internal
    states.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: 13.6 Additional PyMonad features
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One of the other features of PyMonad is the confusingly named monoid. This
    comes directly from mathematics and it refers to a group of data elements that
    have an operator and an identity element, and the group is closed with respect
    to that operator. Here’s an example of what this means: when we think of natural
    numbers, the add operator, and an identity element 0, this is a proper monoid.
    For positive integers, with an operator `*`, and an identity value of 1, we also
    have a monoid; strings using `+` as an operator and an empty string as an identity
    element also qualify.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: PyMonad includes a number of predefined monoid classes. We can extend this to
    add our own monoid class. The intent is to limit a compiler to certain kinds of
    optimization. We can also use the monoid class to create data structures which
    accumulate a complex value, perhaps including a history of previous operations.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: The `pymonad.list` is an example of a monoid. The identity element is an empty
    list, defined by `ListMonad()`. The addition operation defines list concatenation.
    The monoid is an aspect of the overall `ListMonad()` class.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: Much of this package helps provide deeper insights into functional programming.
    To paraphrase the documentation, this is an easy way to learn about functional
    programming in, perhaps, a slightly more forgiving environment. Rather than learning
    an entire language and toolset to compile and run functional programs, we can
    just experiment with interactive Python.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: Pragmatically, we don’t need too many of these features because Python is already
    stateful and offers strict evaluation of expressions. There’s no practical reason
    to introduce stateful objects in Python, or strictly ordered evaluation. We can
    write useful programs in Python by mixing functional concepts with Python’s imperative
    implementation. For that reason, we won’t delve more deeply into PyMonad.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: 13.7 Summary
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we looked at how we can use the PyMonad library to express
    some functional programming concepts directly in Python. The module contains many
    important functional programming techniques.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: We looked at the idea of currying, a function that allows combinations of arguments
    to be applied to create new functions. Currying a function also allows us to use
    functional composition to create more complex functions from simpler pieces. We
    looked at functors that wrap simple data objects to make them into functions that
    can also be used with functional composition.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: Monads are a way to impose a strict evaluation order when working with an optimizing
    compiler and lazy evaluation rules. In Python, we don’t have a good use case for
    monads because Python is an imperative programming language under the hood. In
    some cases, imperative Python may be more expressive and succinct than a monad
    construction.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll look at the multiprocessing and multithreading techniques
    that are available to us. These packages become particularly helpful in a functional
    programming context. When we eliminate a complex shared state and design around
    non-strict processing, we can leverage parallelism to improve the performance.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: 13.8 Exercises
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This chapter’s exercises are based on code available from Packt Publishing on
    GitHub. See [https://github.com/PacktPublishing/Functional-Python-Programming-3rd-Edition](https://github.com/PacktPublishing/Functional-Python-Programming-3rd-Edition).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: In some cases, the reader will notice that the code provided on GitHub includes
    partial solutions to some of the exercises. These serve as hints, allowing the
    reader to explore alternative solutions.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: In many cases, exercises will need unit test cases to confirm they actually
    solve the problem. They are often identical to the unit test cases provided in
    the GitHub repository. The reader should replace the book’s example function name
    with their own solution to confirm that it works.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: 13.8.1 Revise the arctangent series
  id: totrans-170
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In [Using the lazy ListMonad() monad](#x1-2720001), we showed a computation
    for π that involved summing fractions from a series that used factorials, n!,
    and double factorials, (2n + 1)!!.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: The examples use a sequence `seq1`` =`` ListMonad(*range(20))` with only 20
    values. This choice of 20 was arbitrary, and intended only to keep the intermediate
    results small enough to visualize.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: A better choice is to use use curried versions of the `sum()` and `takewhile()`
    functions to find the sum of values in the sequence until the values are too small
    to contribute to the result.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: Rewrite the approximation to compute π to an accuracy of 10^(−15). This is close
    to the limit of what 64-bit floating-point values can represent.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: 13.8.2 Statistical computations
  id: totrans-175
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Given a list of values, `v`, we can create a useful monad with `Just(v)`. We
    can use built-in functions like `sum()` and `len()` with the `Just.map()` method
    to compute the values required for mean, variance, and standard deviation.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '![ ∑ x mean (D ) =---x∈D--- count(D ) ](img/file125.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
- en: '![ ∑ (x-−-mean-(D-))2 var(D ) = count (D )− 1 x∈D ](img/file126.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
- en: '![ ∘ ------- stdev(D ) = var(D ) ](img/file127.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
- en: After implementing these functions using PyMonad, compare these definitions
    with more conventional Python language techniques. Does the presence of a monad
    structure help with these relatively simple computations?
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: 13.8.3 Data validation
  id: totrans-181
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The PyMonad library includes an `Either` class of monads. This is similar to
    the `Maybe` class of monads. The `Maybe` monad can have just a value, or nothing,
    providing a `None`-like object. An `Either` monad has two subclasses, `Left` and
    `Right`. If we use `Right` instances for valid data, we can use `Left` instances
    for error messages that identify invalid data.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: The above concept suggests that a `try:/except:` statement can be used. If no
    Python exception is raised, the result is a `Right(v)`. If an exception is raised,
    a `Left` can be returned with the exception’s error message.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: This permits a `Compose` or `Pipe` to process data, emitting all of the erroneous
    rows as `Left` monads. This can lead to a helpful data validation application
    because it spots all of the problems with the data.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: First, define a simple validation rule, like ”the values must be multiples of
    3 or 5.” This means they must convert to integer values and the integer modulo
    3 is zero or the integer modulo 5 is zero. Second, write the validation function
    that returns either a `Right` or `Left` object.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: While a `pymonad.io.IO` object can be used to parse a file, we’ll start with
    applying the validation function to a list and examining the results. Apply the
    validation function to a sequence of values, saving the resulting sequence of
    `Either` objects.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: An `Either` object has an `.either()` method which can process either `Left`
    or `Right` instances. For example, `e.either(lambda`` x:`` True,`` lambda`` x:`` False)`
    will return `True` if the value of the `e` monad is a `Left` instance.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: 13.8.4 Multiple models
  id: totrans-188
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A given process has several alternative models that compute an expected value
    from an observed sample value.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: 'Each model computes an expected value, e, from the observed value in the sample,
    s[o]:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: e = 0.7412 × s[o]
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: e = 0.9 × s[o] − 90
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: e = 0.7724 × s[o]^(1.0134)
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First, we need to implement each of these models as a curried function. This
    will let us compute predicted values using any of these models.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: Given a model function, we then need to create a comparison function. We can
    use a general PyMonad `Composition` or `Pipe` to compute a predicted value using
    one of the models and compare the predicted value with an observed value.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: The results of this comparison function can be used as part of a χ² (chi-squared)
    test to discern how well the model fits the observations. The actual chi-squared
    metric is the subject of Chapter 16, A Chi-Squared Case Study.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: For now, create the curried model functions, and the `Composition` or `Pipe`
    to compare the model’s prediction with actual results.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: For actual values and observed values, see the [Logging](Chapter_12.xhtml#x1-2640004)
    exercise in [Chapter 12](Chapter_12.xhtml#x1-25000012), [Decorator Design Techniques](Chapter_12.xhtml#x1-25000012).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: Join our community Discord space
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Join our Python Discord workspace to discuss and know more about the book:
    [https://packt.link/dHrHU](https://packt.link/dHrHU)'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '![PIC](img/file1.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
