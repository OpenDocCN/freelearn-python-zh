["```py\n{\n        \"openapi\": \"3.0.3\",\n        \"info\": {\n                \"title\": \"The name of this service\",\n                \"description\": \"Some details.\",\n                \"version\": \"2023.02\"\n        }\n        \"paths\": {\n                \"...\"\n        }\n        \"components\": {\n                \"parameters\": {\"...\"},\n                \"schemas\": {\"...\"}\n        }\n}\n```", "```py\n  \"/2023.02/series\":\n    get:\n      responses:\n        \"200\":\n          description: All of the available data series.\n          content:\n            application/json:\n              schema:\n                $ref: \"#/components/schemas/series_list\"\n```", "```py\n  \"/2023.02/series/<series_id>\":\n    get:\n      description:\n        Get series data as text ND JSON.\n      parameters:\n        - $ref:\n            \"#/components/parameters/series_id\"\n      responses:\n        ...\n```", "```py\n    series_id:\n      name: series_id\n      in: path\n      required: true\n      description: Series name.\n      schema:\n        type: string\n```", "```py\n  content:\n    application/x-ndjson:\n      schema:\n        $ref: \"#/components/schemas/samples\"\n```", "```py\n    samples:\n      description: >\n        Acquired data for a series in ND JSON format.\n        See http://ndjson.org and https://jsonlines.org.\n      type: string\n      format: \"(\\\\{.*?\\\\}\\\\n)+\"\n```", "```py\n@fixture.REST_server\nScenario: Service starts and finishes acquiring data.\n\n  Given initial request is made with path \"/api/2023.02/creation\" and\n      method \"post\" and\n      body with {\"series\": \"2\", \"source\": \"Anscombe_quartet_data.csv\"}\n  And initial response has status \"200\", content-type \"application/json\"\n  And initial response has job-id\n  When polling every 2 seconds with path \"/api/2023.02/creation/job-id\" and\n      method \"get\" finally has response body with status \"Done\"\n  Then response content-type is \"application/json\"\n  And response body has log with more than 0 lines\n  And response body has series \"Series_2\"\n  And response body has status \"done\"\n```", "```py\n@fixture\ndef rest_server(context: Context) -> Iterator[Any]:\n        # Create log file, base URI (code omitted)\n\n        server = subprocess.Popen([sys.executable, \"src/service.py\"],\n    shell=False, stdout=context.log_file, stderr=subprocess.STDOUT)\n    time.sleep(0.5)  # 500 ms delay to allow the service to open a socket\n\n    yield server  # Scenario can now proceed.\n\n    # 100 ms delay to let server’s workers become idle.\n    time.sleep(0.10)\n    server.send_signal(signal.SIGINT)\n    # 100 ms delay to let API’s subprocesses all terminate.\n    time.sleep(0.10)\n```", "```py\nfrom bottle import response, get\n\n@get(’/api/2023.02/series’)\ndef series_list():\n    series_metadata = [\n        {\"name\": series.stem, \"elements\": series_size(series)}\n        for series in DATA_PATH.glob(\"*.ndj\")\n    ]\n    response.status = 200\n    response.body = json.dumps(series_metadata, indent=2)\n    response.content_type = \"application/json\"\n    return response\n```", "```py\nfrom conccurrent import futures\nfrom dataclasses import dataclass, field\nfrom pathlib import Path\nimport secrets\n\n@dataclass\nclass AcquireJob:\n    series: str\n    source_path: Path\n    output_path: Path\n    future: futures.Future = field(init=False)\n    job_id: str = field(default_factory=lambda:\n    \\secrets.token_urlsafe(nbytes=12))\n```", "```py\nfrom conccurrent import futures\nimport urllib.parse\n\nWORKERS: futures.ProcessPoolExecutor\n\n# Definitions of all of the routes\n\nif __name__ == \"__main__\":\n\t# Defaults...\n\tacquire_uri = \"http://localhost:8080\"\n\t# Parse a configuration, here; possibly overriding defaults\n    uri = urllib.parse.urlparse(acquire_uri)\n\twith futures.ProcessPoolExecutor() as WORKERS:\n        run(host=uri.hostname, port=uri.port)\n```", "```py\nfrom unittest.mock import sentinel, Mock, call\nfrom pytest import fixture, MonkeyPatch\nfrom webtest import TestApp\nimport service\n\ndef test_test(monkeypatch: MonkeyPatch) -> None:\n    monkeypatch.setitem(service.ACCESS, \"unit-test\", \"unit-test\")\n    app = TestApp(service.app)\n    app.authorization = (\n        \"Basic\", (\"unit-test\", \"unit-test\")\n    )\n    response = app.get(\"/api/2023.02/test\")\n    assert response.status_code == 200\n    assert response.json[’status’] == \"OK\"\n```"]