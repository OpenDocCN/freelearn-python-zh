<html><head></head><body>
		<div><div></div>
		</div>
		<div><h1 id="_idParaDest-39"><a id="_idTextAnchor043"/>2. Starting to Build Our Project</h1>
		</div>
		<div><h2>Learning Objectives</h2>
			<p>By the end of this chapter, you will be able to:</p>
			<ul>
				<li class="bullets">Build a Restful API service efficiently using the Flask-Restful package</li>
				<li class="bullets">Build an extendable Flask project</li>
				<li class="bullets">Perform CRUD operations using the model</li>
				<li class="bullets">Test RESTful APIs using curl, httpie, and Postman</li>
			</ul>
			<p>In this chapter, we will start to work on the food recipe-sharing platform and learn how to create a RESTful API application.</p>
		</div>
		<div><h2 id="_idParaDest-40"><a id="_idTextAnchor044"/>Introduction</h2>
			<p>Now that we've introduced APIs and learned a bit about HTTP and REST, we will work on building an application (the recipe-sharing app known as Smilecook). In this chapter, we aim to kick-start the actual project development. This is a recipe-sharing platform in which users can create accounts and share their own recipes with other users. As you can imagine, it will contain a lot of API endpoints for our users so that they can manage their recipes. We will be using the Flask-RESTful package to efficiently develop our RESTful API.</p>
			<p>This chapter will talk about the <strong class="keyword">CRUD</strong> (<strong class="keyword">Create, Read, Update, Delete</strong>) of these recipes, as well as how to set the publish status of the recipe.</p>
			<h2 id="_idParaDest-41"><a id="_idTextAnchor045"/>What is Flask-RESTful?</h2>
			<p>Flask-RESTful is a Flask extension that allows us to quickly develop RESTful APIs. Compared to the built-in wrapper, <code>@app.route('/')</code>, which we discussed in the previous chapter, Flask-RESTful allows us to maintain and structure the API endpoints in a much better and easier way.</p>
			<p>In this chapter, we will develop our project using this Flask extension so that you will see how we can structure our endpoints.</p>
			<h3 id="_idParaDest-42"><a id="_idTextAnchor046"/>Using Flask-RESTful to Develop Our Recipe-Sharing Platform, "Smilecook"</h3>
			<p>In this book, we are going to develop a recipe-sharing platform called <strong class="bold">Smilecook</strong>. Beginning with this chapter, we will start adding functions to it. We believe this approach will help you learn about the key concepts and skills you will need so that you can develop this application and help it reach its full potential, while at the same time helping you understand the entire development workflow.</p>
			<p>First, we will build the basic CRUD functions of the recipes. The Flask-RESTful package allows us to structure our code in a more comprehensive way. We will define certain methods in a resource and link them to the endpoints. The flow of a GET request, for example, will be for the request to be sent to the endpoints (<code>http://localhost:5000/recipes</code>), which will then be handled by the <code>GET</code> method we are going to implement in the resource. This will result in the recipes being returned to us.</p>
			<p>Apart from the basic CRUD functions, we will also implement the publish and unpublish functions on these recipes. This can be done through the <code>PUT</code> and <code>DELETE</code> methods, which can be found in the <code>RecipePublishResource</code> class. We will link these two methods to the <code>http://localhost:5000/recipes/1/publish</code> endpoint (for the recipe whose <em class="italics">ID = 1</em>). For details of our endpoint design, please refer to the following table:</p>
			<div><div><img src="img/C15309_02_01.jpg" alt=""/>
				</div>
			</div>
			<h6>Figure 2.1: Details of our endpoint designs</h6>
			<h2 id="_idParaDest-43"><a id="_idTextAnchor047"/>Virtual Environment</h2>
			<p>PyCharm will help us create a virtual environment. We want to develop our project in its own virtual environment in order to keep it isolated. Due to this, we will have absolute control over the versions of the packages that we are going to use.</p>
			<p>The best way to learn is through practice. Let's get our hands dirty now!</p>
			<h3 id="_idParaDest-44"><a id="_idTextAnchor048"/>Exercise 5: Creating a Development Project in PyCharm</h3>
			<p>Before you start developing the Python application, you'll need to create a development project in PyCharm. PyCharm manages things using projects. In this exercise, you will learn how to create a new development project in PyCharm called Smilecook. You will also need to install the necessary packages for this project. Let's get started:</p>
			<ol>
				<li><a id="_idTextAnchor049"/>Create the project and name it <strong class="bold">smilecook</strong>:<div><img src="img/C15309_02_02.jpg" alt=""/></div><h6>Figure 2.2: Creating a project</h6></li>
				<li>Check the project structure and ensure that the virtual environment has been created. Once the module has been created, we will be able to see the project's hierarchy on the left-hand side panel. We can see the <strong class="bold">venv</strong> folder under the project folder, which was created and activated by PyCharm. Now, when we write code under this project, it will be run in the virtual environment:<div><img src="img/C15309_02_03.jpg" alt=""/></div><h6>Figure 2.3: Checking the project structure and ensuring that the virtual environment has been created</h6></li>
				<li>Install the required packages for this chapter. To do this, create a file called <code>requirements.txt</code> under our project folder. Type in the following code to specify the packages you want to install:<pre>Flask==1.0.3
Flask-RESTful==0.3.7
httpie==1.0.3</pre></li>
				<li>Use the <code>pip</code> command to install these packages. After that, in the <code>pip</code> command to install the packages that we specified in the <code>requirements.txt</code> file:<pre>pip install -r requirements.txt</pre></li>
				<li>You should now see something similar in the following screenshot. Here, we can see that the packages are being installed on the virtual environment:<div><img src="img/C15309_02_04.jpg" alt=""/></div></li>
			</ol>
			<h6>Figure 2.4: Installing the packages on the virtual environment</h6>
			<p>Congratulations! You have created a PyCharm project for our Smilecook application. This is the first step of you embarking on your journey as a developer!</p>
			<h2 id="_idParaDest-45"><a id="_idTextAnchor050"/>Creating a Recipe Model</h2>
			<p>As you can imagine, a recipe may have several attributes. To save every detail of these attributes, we will model the recipe using a class. This recipe class is going to have several essential attributes.</p>
			<p>Here is a brief description of the attributes that we will define in the recipe class:</p>
			<ul>
				<li><code>name</code>: The name of the recipe.</li>
				<li><code>description</code>: The description of the recipe.</li>
				<li><code>num_of_servings</code>: The number of servings.</li>
				<li><code>cook_time</code>: The cooking time required. This is an integer whose units are in seconds.</li>
				<li><code>directions</code>: The directions.</li>
				<li><code>is_publish</code>: The publish status of the recipe; the default is draft.</li>
			</ul>
			<p>In the next exercise, we will show you how to code the recipe class so that it has these attributes.</p>
			<h3 id="_idParaDest-46">Exe<a id="_idTextAnchor051"/>rcise 6: Creating the Recipe Model</h3>
			<p>In this exercise, we will code the recipe model, step by step. The <code>recipe</code> class will contain the attributes that we discussed previously. The code file for this exercise can be found in <code>Lesson2/Exercise06/models/recipe.py</code>.</p>
			<p>Now, let's create the recipe class:</p>
			<ol>
				<li value="1"><em class="italics">Right-click</em> on the project name, that is, Smilecook, and create a <code>Python Package</code>. Name it <code>models</code>:<div><img src="img/C15309_02_05.jpg" alt=""/></div><h6>Fi<a id="_idTextAnchor052"/>gure 2.5: Creating a Python package and naming it models</h6></li>
				<li>Then<a id="_idTextAnchor053"/>, create a file called <code>recipe.py</code> under <code>models</code> and type in the following code:<pre>recipe_list = []
def get_last_id():
    if recipe_list:
        last_recipe = recipe_list[-1]
    else:
        return 1
    return last_recipe.id + 1</pre><p>Let's pause for a while and examine the code here. First, we define <code>recipe_list = []</code> so that we can store the recipes in the application memory. Then, we define the <code>get_last_id</code> function to get the ID of our last recipe. Later, when we create a new recipe, we will use this method to evaluate the last ID in <code>recipe_list</code> so that we can come up with a new ID for the new recipe. </p></li>
				<li>Define the recipe class using the following code. Type the following code into <code>recipe.py</code>, right after the <code>get_last_id</code> function that we implemented:<pre>class Recipe:
    def __init__(self, name, description, num_of_servings, cook_time, directions):
        self.id = get_last_id()
        self.name = name
        self.description = description
        self.num_of_servings = num_of_servings
        self.cook_time = cook_time
        self.directions = directions
        self.is_publish = False</pre><p>The <code>Recipe</code> class has the <code>__init__</code> constructor method, which will take in parameters such as <code>name</code>, <code>description</code>, <code>num_of_servings</code>, <code>cook_time</code>, and <code>directions</code>, and create the recipe object based on that. The ID is self-incremented and <code>is_publish</code> is set to <code>false</code> by default. This means that, by default, the recipe will be set to draft (not published).</p></li>
				<li>In the same <code>Recipe</code> class, define the <code>data</code> method for returning the data as a dictionary object. You will recall that, in Python, indentation matters. The following code is indented since it is under the <code>Recipe</code> class:<pre>    @property
    def data(self):
        return {
            'id': self.id,
            'name': self.name,
            'description': self.description,
            'num_of_servings': self.num_of_servings,
            'cook_time': self.cook_time,
            'directions': self.directions
        }</pre></li>
			</ol>
			<p>Now <a id="_idTextAnchor054"/>that we have built the recipe model, we will go ahead and build the API endpoint using Flask-RESTful.</p>
			<h3 id="_idParaDest-47"><a id="_idTextAnchor055"/>Resourceful Routing</h3>
			<p>The main building blocks in Flask-RESTful are resources. Resources are built on top of Flask's pluggable view. The concept of resourceful routing is that we want to structure all the client requests around resources. In our recipe-sharing platform, we are going to group the CRUD actions on a recipe under <code>RecipeResource</code>. For publish and unpublish actions, we will group them under a different <code>RecipePublishResource</code>. This provides a clear structure that other developers can follow.</p>
			<p>The way in which we can implement these resources is simple: we just need to inherit from the <code>flask_restful.Resource</code> class and implement the methods that correspond to the HTTP verb inside it.</p>
			<p>In the next exercise, we will define three subclasses: one for the collection of recipes, one for a single recipe, and one for publishing the recipe. </p>
			<h3 id="_idParaDest-48"><a id="_idTextAnchor056"/>Exercise 7: Defining an API Endpoint for the Recipe Model</h3>
			<p>To build an API endpoint, we need to define a class that inherits from <code>flask_restful.Resource</code>. Then, we can declare the get and post methods inside the class. Let's get started:</p>
			<ol>
				<li value="1">Crea<a id="_idTextAnchor057"/>te a folder called <code>resources</code> under the project and then crea<a id="_idTextAnchor058"/>te a file called <code>recipe.py</code> under the <code>resources</code> folder.<h4>Note</h4><p class="callout">The code file for this can be found in the <a href="https://github.com/TrainingByPackt/Python-API-Development-Fundamentals/tree/master/Lesson02/Exercise07/resources">https://github.com/TrainingByPackt/Python-API-Development-Fundamentals/tree/master/Lesson02/Exercise07/resources</a>.</p></li>
				<li>Impo<a id="_idTextAnchor059"/>rt the necessary packages, classes, and functions using the following code:<pre>from flask import request
from flask_restful import Resource
from http import HTTPStatus
from models.recipe import Recipe, recipe_list</pre></li>
				<li>Righ<a id="_idTextAnchor060"/>t after the preceding code import, create the <code>RecipeListResource</code> class. This class has <code>GET</code> and <code>POST</code> methods, which are used to get and create the recipe's resources, respectively. We will finish the get method first:<pre>class RecipeListResource(Resource):
    def get(self):
        data = []
        for recipe in recipe_list:
            if recipe.is_publish is True:
                data.append(recipe.data)
        return {'data': data}, HTTPStatus.OK</pre><p>Here, we have created and implemented the <code>RecipeListResource</code> class, which inherits from <code>flask-restful.Resource</code>. The <code>get</code> method that we implemented is for, getting all the public recipes back. It does this by declaring a <code>data</code> list and getting all the recipes with <code>is_publish</code> = <code>true</code> in <code>recipe_list</code>. These recipes are appended to our <code>data</code> list and returned to the users.</p></li>
				<li>Add the <code>post</code> method. This is used to create the recipe:<pre>    def post(self):
        data = request.get_json()
        recipe = Recipe(name=data['name'],
                        description=data['description'],
                        num_of_servings=data['num_of_servings'],
                        cook_time=data['cook_time'],
                        directions=data['directions'])
        recipe_list.append(recipe)
        return recipe.data, HTTPStatus.CREATED</pre></li>
			</ol>
			<p>In this exercise, we have built two methods that handle the GET and POST client requests. The following table summarizes the methods that we have built in this exercise:</p>
			<div><div><img src="img/C15309_02_06.jpg" alt=""/>
				</div>
			</div>
			<h6>Figure 2.6: Client request methods that we used in this exercise</h6>
			<h4>Note</h4>
			<p class="callout">We have skipped the step to jsonify the object before returning data to the client because Flask-RESTful has already done that for us behind the scenes.</p>
			<p class="callout">The <code>post</code> method that we built in this exercise is for creating a new recipe. It is a <code>POST</code> method. It does this by getting the JSON data back from the request using <code>request.get_json</code> and then creates the recipe object and stores that in <code>recipe_list</code>. Finally, it returns the recipe record with an HTTP status code <strong class="bold">201 CREATED</strong>.</p>
			<h3 id="_idParaDest-49"><a id="_idTextAnchor061"/>Exercise 8: Defining the Recipe Resource</h3>
			<p>In this exercise, we will define the recipe resource. We are going to use two methods: the get method, for getting back a single recipe; and the put method, for updating the recipe. Let's get started:</p>
			<ol>
				<li value="1"><a id="_idTextAnchor062"/>Define the <code>RecipeResource</code> resource and implement the <code>get</code> method by using the following sample code:<pre>class RecipeResource(Resource):
    def get(self, recipe_id):
        recipe = next((recipe for recipe in recipe_list if recipe.id == recipe_id and recipe.is_publish == True), None)
        if recipe is None:
            return {'message': 'recipe not found'}, HTTPStatus.NOT_FOUND
        return recipe.data, HTTPStatus.OK</pre><p>Similarly, <code>RecipeResource</code> also inherits from <code>flask-restful.Resource</code>. The get method we are implementing here is getting back a single recipe. We do that by searching for <code>recipe_id</code> in <code>recipe_list</code>. We will only get back those recipes with <code>is_publish = true</code>. If no such recipe is found, we will return the message <strong class="bold">recipe not found</strong>. Otherwise, we will return the recipe, along with an HTTP status of <strong class="bold">200 OK</strong>.</p></li>
				<li>Implement the <code>put</code> method with the following code:<pre>    def put(self, recipe_id):
        data = request.get_json()
        recipe = next((recipe for recipe in recipe_list if recipe.id == recipe_id), None)
        if recipe is None:
            return {'message': 'recipe not found'}, HTTPStatus.NOT_FOUND
        recipe.name = data['name']
        recipe.description = data['description']
        recipe.num_of_servings = data['num_of_servings']
        recipe.cook_time = data['cook_time']
        recipe.directions = data['directions']
        return recipe.data, HTTPStatus.OK</pre><p>The second method we've implemented here is <code>put</code>. It gets the recipe details from the client request using <code>request.get_json</code> and updates the recipe object. Then, it returns the HTTP status code <strong class="bold">200 OK</strong> if everything goes well.</p></li>
			</ol>
			<p>Here, we have built two methods for the recipe resources. The <code>GET</code> and <code>PUT</code> methods are used to handle the corresponding client request. The following table shows the methods that we have built for the <code>RecipeResource</code> class in this exercise:</p>
			<div><div><img src="img/C15309_02_07.jpg" alt=""/>
				</div>
			</div>
			<h6>Figure 2.7: Methods that we have built for the RecipeResource class</h6>
			<h3 id="_idParaDest-50"><a id="_idTextAnchor063"/>Exercise 9: Publishing and Unpublishing the Recipes</h3>
			<p>In the previous exercises, we created the recipe resources and their associated methods. Now, our Smilecook application can read/write actions on recipes. However, at the beginning of this chapter, we said that the recipes can have two Statuses (unpublished and published). This allows the user to continue updating their unpublished recipes before publishing them to the world. In this exercise, we will define the resource for publishing and unpublishing a recipe. Let's get started:</p>
			<ol>
				<li value="1"><a id="_idTextAnchor064"/>Define the <code>RecipePublic</code> resource and implement the <code>put</code> method that will handle the HTTP PUT request:<pre>class RecipePublishResource(Resource):
    def put(self, recipe_id):
        recipe = next((recipe for recipe in recipe_list if recipe.id == recipe_id), None)
        if recipe is None:
            return {'message': 'recipe not found'}, HTTPStatus.NOT_FOUND
        recipe.is_publish = True
        return {}, HTTPStatus.NO_CONTENT</pre><p><code>RecipePublishResource</code> inherits from <code>flask_restful.Resource</code>. The <code>put</code> method will locate the recipe with the passed-in <code>recipe_id</code> and update the <code>is_publish</code> status to true. Then, it will return <code>HTTPStatus.NO_CONTENT</code>, which shows us that the recipe has been published successfully. </p></li>
				<li>Implement the <code>delete</code> method, which will handle the HTTP DELETE request:<pre>    def delete(self, recipe_id):
        recipe = next((recipe for recipe in recipe_list if recipe.id == recipe_id), None)
        if recipe is None:
            return {'message': 'recipe not found'}, HTTPStatus.NOT_FOUND
        recipe.is_publish = False
        return {}, HTTPStatus.NO_CONTENT</pre><p>The <code>delete</code> method is the opposite of the <code>put</code> method. Instead of setting <code>is_publish</code> to <code>true</code>, it sets it to <code>false</code> in order to unpublish the recipe.</p><p>You can also see that we are using these methods in a flexible manner; the <code>put</code> method is not necessarily for update, and the <code>delete</code> method is not necessarily for removal.</p></li>
			</ol>
			<p>The following table shows all the methods that we have created in this exercise. Now that we have all three resources ready (<code>RecipeListResource</code>, <code>RecipeResource</code>, and <code>RecipePublishResource</code>), we will discuss endpoint configuration:</p>
			<div><div><img src="img/C15309_02_08.jpg" alt=""/>
				</div>
			</div>
			<h6>Figure 2.8: Methods that we used in this exercise</h6>
			<h4>Note</h4>
			<p class="callout">If the client request is with an HTTP verb that has no corresponding handling method in the resource, Flask-RESTful will return the HTTP status code <strong class="bold">405 Method Not Allowed</strong>.</p>
			<h2 id="_idParaDest-51"><a id="_idTextAnchor065"/>Configuring Endpoints</h2>
			<p>Now that we have defined all our resources, we will set up some endpoints so that users can send requests to them. These endpoints can be accessed by the users and are connected to specific resources. We will be using the <code>add_resource</code> method on the API object to specify the URL for these endpoints and route the client HTTP request to our resources. </p>
			<p>For example, the <code>api.add_resource(RecipeListResource, '/recipes')</code> syntax is used to link the route (relative URL path) to <code>RecipeListResource</code> so that HTTP requests will be directed to this resource. Depending on the HTTP verb (for example, <code>GET</code>, and <code>POST</code>), the request will be handled by the corresponding methods in the resource accordingly.</p>
			<h3 id="_idParaDest-52"><a id="_idTextAnchor066"/>Exercise 10: Creating the Main Application File</h3>
			<p>In this exercise, we will create our <code>app.py</code> file, which will be our main application file. We will set up Flask and initialize our <code>flask_restful.API</code> there. Finally, we will set up the endpoints so that users can send requests to our backend services. Let's get started:</p>
			<ol>
				<li value="1"><a id="_idTextAnchor067"/>Create the <code>app.py</code> file under the project folder.</li>
				<li><a id="_idTextAnchor068"/>Import the necessary classes using the following code:<pre>from flask import Flask
from flask_restful import Api
from resources.recipe import RecipeListResource, RecipeResource, RecipePublishResource</pre></li>
				<li>Set up Flask and initialize <code>flask_restful.API</code> with our Flask app:<pre>app = Flask(__name__)
api = Api(app)</pre></li>
				<li><a id="_idTextAnchor069"/>Add resource routing by passing in the URL so that it will route to our resources. Each resource will have its own HTTP method defined:<pre>api.add_resource(RecipeListResource, '/recipes') 
api.add_resource(RecipeResource, '/recipes/&lt;int:recipe_id&gt;')
api.add_resource(RecipePublishResource, '/recipes/&lt;int:recipe_id&gt;/publish')
if __name__ == '__main__':
    app.run(port=5000, debug=True)</pre><h4>Note</h4><p class="callout">In <code>RecipeListResource</code>, we have defined the <code>get</code> and <code>post</code> methods. So, when there is a GET HTTP request to the "/recipes" URL route, it will invoke the <code>get</code> method under <code>RecipeListResource</code> and get back all the published recipes.</p><p><a id="_idTextAnchor070"/>In the preceding code, you will notice that we have used <code>&lt;int: recipe_id &gt;</code> in the code. It is there as a placeholder for the recipe ID. When a GET HTTP request has been sent to the <code>route "/recipes/2"</code> URL, this will invoke the get method under <code>RecipeResource</code> with a parameter, that is, <code>recipe_id = 2</code>.</p></li>
				<li>Save <code>app.py</code> and <em class="italics">right-click</em> on it to run the application. Flask will then start up and run on the localhost (<code>127.0.0.1</code>) at port <code>5000</code>:</li>
			</ol>
			<div><div><img src="img/C15309_02_09.jpg" alt=""/>
				</div>
			</div>
			<h6>Figure 2.9: Flask started and running on localhost</h6>
			<p>Congratulations! You have completed the API endpoint. Now, let's move on to testing. You can either test it in curl/httpie or Postman.</p>
			<h2 id="_idParaDest-53">M<a id="_idTextAnchor071"/><a id="_idTextAnchor072"/>aking HTTP Requests to the Flask API using curl and httpie</h2>
			<p>Now, we are going to use the <code>httpie</code> and <code>curl</code> commands to test our API endpoints. We will test the functions for getting all the recipes back from the server and create/update/delete, publish, and unpublish the recipes. The best way to learn this is to complete a hands-on exercise. Let's get started!</p>
			<h3 id="_idParaDest-54"><a id="_idTextAnchor073"/>Exercise 11: Testing the Endpoints Using curl and httpie</h3>
			<p>In this exercise, we are going to use the httpie and curl commands to send requests to the endpoints so that we can create our first recipe. We want you to get comfortable using the httpie and curl command-line testing tool. Let's get started:</p>
			<ol>
				<li value="1">Open the Terminal in PyCharm and type in the following commands. You can use either the httpie or curl command. The following is the httpie command (<code>= is for string and :=  is for non-string</code>):<pre>http POST localhost:5000/recipes name="Cheese Pizza" description="This is a lovely cheese pizza" num_of_servings:=2 cook_time:=30 directions="This is how you make it"</pre><p>The following is the curl command. The <code>-H</code> argument is used to specify the header in the client request. We will set <code>Content-Type: application/json</code> as the header here. The <code>-d</code> argument is used for HTTP POST data, that is, the recipe in JSON format:</p><pre>curl -i -X POST localhost:5000/recipes -H "Content-Type: application/json" -d '{"name":"Cheese Pizza", "description":"This is a lovely cheese pizza", "num_of_servings":2, "cook_time":30, "directions":"This is how you make it" }'</pre></li>
				<li>Examine the response, you should see the following. Carefully examine it, it should be the same recipe as the one that was used in our request in <em class="italics">Step 1</em>:<pre>HTTP/1.0 201 CREATED
Content-Type: application/json
Content-Length: 188
Server: Werkzeug/0.16.0 Python/3.7.0
Date: Sun, 03 Nov 2019 03:19:00 GMT
{
    "id": 1,
    "name": "Cheese Pizza",
    "description": "This is a lovely cheese pizza",
    "num_of_servings": 2,
    "cook_time": 30,
    "directions": "This is how you make it"
}</pre><h4>Note</h4><p class="callout">Once the client request has been sent to the server using the HTTP <code>POST</code> method, the <code>post</code> method in <code>RecipeResource</code> will pick up the request and save the recipe in the request to the application memory. The new recipe will be appended in <code>recipe_list</code>. Once everything is done, it will return HTTP <code>201 CREATED</code> and the newly created recipe in JSON format.</p></li>
			</ol>
			<p>We have successfully created our first recipe on the platform. This recipe is stored on the server-side and we already have the API to retrieve it. Let's continue by creating our second recipe and retrieving all our recipes in one go.</p>
			<h3 id="_idParaDest-55"><a id="_idTextAnchor074"/>Exercise 12: Testing the Auto-Incremented Recipe ID</h3>
			<p>Now that we have implemented the auto-incremented ID in our Smilecook application, let's see how it works in practice. In this exercise, we will create the second recipe using the httpie and curl commands. Note that the ID is auto- incremented for our second recipe. Let's get started:</p>
			<ol>
				<li value="1">Create a second recipe and note that the ID is automatically incremented. Send the following client request using httpie:<pre>http POST localhost:5000/recipes name="Tomato Pasta" description="This is a lovely tomato pasta recipe" num_of_servings:=3 cook_time:=20 directions="This is how you make it"</pre><p>Alternatively, send the request using curl. Again, the <code>-H</code> argument is used to specify the header in the client request. We will set "<code>Content-Type: application/json</code>" as the header here. The <code>-d</code> argument is used for HTTP POST data, meaning that the recipe is in JSON format:</p><pre>curl -i -X POST localhost:5000/recipes -H "Content-Type: application/json" -d '{"name":"Tomato Pasta", "description":"This is a lovely tomato pasta recipe", "num_of_servings":3, "cook_time":20, "directions":"This is how you make it"}'</pre></li>
				<li>You should see the following response. Examine it carefully, it should be the same recipe as the one that was used in our request in <em class="italics">Step 1</em>:<pre>HTTP/1.0 201 CREATED
Content-Type: application/json
Content-Length: 195
Server: Werkzeug/0.16.0 Python/3.7.0
Date: Sun, 03 Nov 2019 03:23:37 GMT
 
{
    "id": 2,
    "name": "Tomato Pasta",
    "description": "This is a lovely tomato pasta recipe",
    "num_of_servings": 3,
    "cook_time": 20,
    "directions": "This is how you make it"
}</pre><p>Once the preceding client request has been sent to the server using the HTTP <code>POST</code> method, the <code>post</code> method in <code>RecipeResource</code> will pick up the request and save the recipe in the request to the application memory. The new recipe will be appended in <code>recipe_list</code>. This time, the ID will be automatically assigned to 2.</p></li>
			</ol>
			<h3 id="_idParaDest-56"><a id="_idTextAnchor075"/>Exercise 13: Getting All the Recipes Back</h3>
			<p>In this exercise, we will be using the httpie and curl commands to get back all the recipes that we have created. We are doing this to ensure that our recipes are there in the backend server. Let's get started: </p>
			<ol>
				<li value="1">Retrieve all the recipes by sending the following client request using httpie:<pre>http GET localhost:5000/recipes</pre><p>Alternatively, send the following request using curl. The <code>-i</code> argument is used to state that we want to see the response header. <code>-X GET</code> means that we are sending the client request using the HTTP <code>GET</code> method:</p><pre>curl -i -X GET localhost:5000/recipes </pre></li>
				<li>You should see the following response. Please examine it carefully:<pre>HTTP/1.0 200 OK
Content-Length: 19
Content-Type: application/json
Date: Sun, 03 Nov 2019 03:24:53 GMT
Server: Werkzeug/0.16.0 Python/3.7.0
 
{
    "data": []
}</pre><p>Once the preceding client request has been sent to the server using the HTTP GET method, the get method in <code>RecipeResource</code> will pick up the request and retrieve all the published recipes from <code>recipe_list</code> in the application memory.</p><h4><a id="_idTextAnchor076"/>Note</h4><p class="callout">We should see an empty list in the HTTP response because all the recipes we have created in the previous steps are in draft form (not published).</p></li>
			</ol>
			<h3 id="_idParaDest-57"><a id="_idTextAnchor077"/>Exercise 14: Testing the Recipe Resources</h3>
			<p>We have already tested the endpoints we built around the recipe resources. In this exercise, we will continue to use the httpie and curl commands to test the recipe publishing API. We can test it by sending requests asking to publish our recipes on the API endpoint. Let's get started:</p>
			<ol>
				<li value="1">Modify the publish status of the recipe with ID 1. We can send the following client request using the httpie command:<pre>http PUT localhost:5000/recipes/1/publish</pre><p>Alternatively, we can use the following curl command:</p><pre>curl -i -X PUT localhost:5000/recipes/1/publish </pre><h4>Note</h4><p class="callout">Once the preceding client request has been sent to the server using the HTTP PUT method, the <code>put</code> method in <code>RecipePublishResource</code> will pick up the request and assign <code>recipe_id</code> to be 1. The application will look for the recipe with <code>ID = 1</code> and update its publish status to <code>True</code>.</p></li>
				<li>You should see the following response. Please examine it carefully:<pre>HTTP/1.0 204 NO CONTENT
Content-Type: application/json
Date: Sun, 03 Nov 2019 03:25:48 GMT
Server: Werkzeug/0.16.0 Python/3.7.0</pre></li>
				<li>Now, retrieve all the published recipes and examine them. Then, send the following client request using httpie:<pre>http GET localhost:5000/recipes</pre><p>Alternatively, send the following request using curl. The <code>-i</code> argument is used to say that we want to see the response header. <code>-X GET</code> means that we are sending the client request using the HTTP GET method:</p><pre>curl -i -X GET localhost:5000/recipes</pre></li>
				<li>You should see the following response. Please examine it carefully:<pre>HTTP/1.0 200 OK
Content-Type: application/json
Content-Length: 276
Server: Werkzeug/0.16.0 Python/3.7.0
Date: Sun, 03 Nov 2019 03:26:43 GMT
 
{
    "data": [
        {
            "id": 1,
            "name": "Cheese Pizza",
            "description": "This is a lovely cheese pizza",
            "num_of_servings": 2,
            "cook_time": 30,
            "directions": "This is how you make it"
        }
    ]
}</pre><p>Once the preceding client request has been sent to the server using the HTTP <code>GET</code> method, the get method in <code>RecipeResource</code> will pick up the request and retrieve all the published recipes from <code>recipe_list</code> in the application memory. This time, because the recipe with ID 1 has been set to publish, we shall see it in the HTTP response.</p></li>
			</ol>
			<h3 id="_idParaDest-58"><a id="_idTextAnchor078"/>Exercise 15: Negative Testing</h3>
			<p>In the previous exercise, we successfully published our recipe. This is good because it shows us that the APIs that we've developed work. But the whole point of testing is to discover potential issues if any. We can perform so-called negative testing here. This is the process of deliberately testing the scenario with unwanted input. This exercise is going to test a request with an HTTP VERB that has no corresponding method defined in the resource. Let's get started:</p>
			<ol>
				<li value="1">Send the following request to the server-side. This HTTP method has not been defined; let's see what happens:<pre>http DELETE localhost:5000/recipes</pre><p>The following is the curl command, which does the same thing:</p><pre>curl -i -X DELETE localhost:5000/recipes </pre></li>
				<li>You should see the following response. Please examine it carefully:<pre>HTTP/1.0 405 METHOD NOT ALLOWED
Content-Type: application/json
Content-Length: 70
Allow: POST, GET, HEAD, OPTIONS
Server: Werkzeug/0.16.0 Python/3.7.0
Date: Sun, 03 Nov 2019 03:27:37 GMT
 
{
    "message": "The method is not allowed for the requested URL."
}</pre><p>We should see a response with an HTTP status of <code>RecipeListResource</code>.</p></li>
			</ol>
			<p>N<a id="_idTextAnchor079"/>egative testing is important. We always want our testing to be more complete and covers more scenarios.</p>
			<h3 id="_idParaDest-59"><a id="_idTextAnchor080"/>Exercise 16: Modifying the Recipes</h3>
			<p>In our Smilecook application, authors are allowed to update their recipes. It is like a blogging platform, where the authors can take their time to perfect their work, even after it has been published. Since we have already built the API, we would like to test it using Postman. Let's get started:</p>
			<ol>
				<li value="1">Use the PUT method to send the request to <code>localhost:5000/recipes/1</code>, along with the new recipe details:<pre>http PUT localhost:5000/recipes/1 name="Lovely Cheese Pizza" description="This is a lovely cheese pizza recipe" num_of_servings:=3 cook_time:=60 directions="This is how you make it"</pre><p>Alternatively, send the following request using curl. The <code>-H</code> argument is used to specify the header in the client request. We will set "<code>Content-Type: application/json</code>" as the header here. The <code>-d</code> argument is used for HTTP POST data, meaning that the recipe will be in JSON format:</p><pre>curl -i -X PUT localhost:5000/recipes/1 -H "Content-Type: application/json" -d '{"name":"Lovely Cheese Pizza", "description":"This is a lovely cheese pizza recipe", "num_of_servings":3, "cook_time":60, "directions":"This is how you make it"}'</pre></li>
				<li>You should see the following response. Please examine it carefully:<pre>HTTP/1.0 200 OK
Content-Type: application/json
Content-Length: 202
Server: Werkzeug/0.16.0 Python/3.7.0
Date: Sun, 03 Nov 2019 03:28:57 GMT
 
{
    "id": 1,
    "name": "Lovely Cheese Pizza",
    "description": "This is a lovely cheese pizza recipe",
    "num_of_servings": 3,
    "cook_time": 60,
    "directions": "This is how you make it"
}</pre><p>Once the preceding client request has been sent to the server using the HTTP PUT method, the <code>put</code> method in <code>RecipeResource</code> will pick up the request and assign <code>recipe_id</code> to be 1. The application will look for the recipe with <code>id = 1</code> and update its details with those in the client request. The preceding response shows that the recipe with ID 1 is modified. </p></li>
			</ol>
			<p>W<a id="_idTextAnchor081"/>e just finished testing another important feature. You have been doing great. Let's keep going!</p>
			<h3 id="_idParaDest-60"><a id="_idTextAnchor082"/>Exercise 17: Getting Back Specific Recipes with a Certain ID</h3>
			<p>So far, we have tested getting all the recipes back. But in the real world, a user will want to only get the recipes that they want to see. They can do this by using the recipe ID. This exercise will show you how to get a particular recipe with a certain ID. Let's get started:</p>
			<ol>
				<li value="1">Send the following client request using httpie:<pre>http GET localhost:5000/recipes/1</pre><p>Alternatively, use the following curl command, which does the same thing:</p><pre>curl -i -X GET localhost:5000/recipes/1
You should see the following response. Please examine it carefully:
HTTP/1.0 200 OK
Content-Type: application/json
Content-Length: 202
Server: Werkzeug/0.16.0 Python/3.7.0
Date: Sun, 03 Nov 2019 03:29:59 GMT
 
{
    "id": 1,
    "name": "Lovely Cheese Pizza",
    "description": "This is a lovely cheese pizza recipe",
    "num_of_servings": 3,
    "cook_time": 60,
    "directions": "This is how you make it"
}</pre><p>Once the preceding client request has been sent to the server using the HTTP <code>GET</code> method, the get method in <code>RecipeResource</code> will pick up the request and assign <code>recipe_id</code> to be 1. It will retrieve all the published recipes from <code>recipe_list</code> in the application memory with an HTTP status of HTTP <code>200</code>.</p></li>
			</ol>
			<p>We have just tested our Smilecook application and confirmed that it can give us back the recipe we want. </p>
			<h3 id="_idParaDest-61"><a id="_idTextAnchor083"/>Activity 3: Testing the APIs Using Postman</h3>
			<p>We added quite a few functions in the previous exercise. Now, we need to make sure that they work properly before we move on and develop other functions. In this activity, instead of using httpie/curl, we will be testing our API using Postman. Please follow these high-level steps:</p>
			<ol>
				<li value="1">Create the first recipe using Postman.</li>
				<li>Create the second recipe using Postman.</li>
				<li>Retrieve all the recipes using Postman.</li>
				<li>Set the recipes to published using Postman.</li>
				<li>Retrieve all the recipes using Postman again.</li>
				<li>Modify the recipe using Postman.</li>
				<li>Get a specific recipe back using Postman.<h4>Note</h4><p class="callout">The solution to this activity can be found on page 293.</p></li>
			</ol>
			<h3 id="_idParaDest-62">A<a id="_idTextAnchor084"/>ctivity 4: Implementing the Delete Recipe Function</h3>
			<p>In this activity, you will implement the delete recipe function in the Smilecook application yourself. Do this by adding a delete function to <code>RecipeResource</code>, similar to what we did in the previous exercises. Then, we will follow the standard software development life cycle flow, which is used to test our implementation, using Postman. Follow these steps to complete this activity:</p>
			<ol>
				<li value="1">Add the delete function to <code>RecipeResource</code>.</li>
				<li>Start up the Flask server for testing.</li>
				<li>Create the first recipe using Postman.</li>
				<li>Delete the recipe using Postman.<h4>Note</h4><p class="callout">The solution to this activity can be found on page 299.</p></li>
			</ol>
			<h2 id="_idParaDest-63"><a id="_idTextAnchor085"/>Summary</h2>
			<p>In this chapter, we built the RESTful API using the Flask-RESTful package. By doing this, you have seen how simple and easy it is to perform such tasks. We are building our project in a structural manner, which allows us to easily extend the project in the subsequent chapters. In this chapter, we created the models and resources folder; we will be developing more models and resources later in this book. So far, our food recipe-sharing platform, Smilecook, is capable of performing CRUD, as well as setting the publish status of the recipe. We have also tested the application to make sure it is working properly. Finally, you started to realize the power of Postman, which greatly automates the whole testing process. In the next chapter, we will learn about how to perform data validation.</p>
		</div>
	</body></html>