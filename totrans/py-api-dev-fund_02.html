<html><head></head><body>
		<div>
			<div id="_idContainer029" class="Content">
			</div>
		</div>
		<div id="_idContainer030" class="Content">
			<h1 id="_idParaDest-39"><a id="_idTextAnchor043"/>2. Starting to Build Our Project</h1>
		</div>
		<div id="_idContainer031" class="Content">
			<h2>Learning Objectives</h2>
			<p>By the end of this chapter, you will be able to:</p>
			<ul>
				<li class="bullets">Build a Restful API service efficiently using the Flask-Restful package</li>
				<li class="bullets">Build an extendable Flask project</li>
				<li class="bullets">Perform CRUD operations using the model</li>
				<li class="bullets">Test RESTful APIs using curl, httpie, and Postman</li>
			</ul>
			<p>In this chapter, we will start to work on the food recipe-sharing platform and learn how to create a RESTful API application.</p>
		</div>
		<div id="_idContainer041" class="Content">
			<h2 id="_idParaDest-40"><a id="_idTextAnchor044"/>Introduction</h2>
			<p>Now that we've introduced APIs and learned a bit about HTTP and REST, we will work on building an application (the recipe-sharing app known as Smilecook). In this chapter, we aim to kick-start the actual project development. This is a recipe-sharing platform in which users can create accounts and share their own recipes with other users. As you can imagine, it will contain a lot of API endpoints for our users so that they can manage their recipes. We will be using the Flask-RESTful package to efficiently develop our RESTful API.</p>
			<p>This chapter will talk about the <strong class="keyword">CRUD</strong> (<strong class="keyword">Create, Read, Update, Delete</strong>) of these recipes, as well as how to set the publish status of the recipe.</p>
			<h2 id="_idParaDest-41"><a id="_idTextAnchor045"/>What is Flask-RESTful?</h2>
			<p>Flask-RESTful is a Flask extension that allows us to quickly develop RESTful APIs. Compared to the built-in wrapper, <strong class="inline">@app.route('/')</strong>, which we discussed in the previous chapter, Flask-RESTful allows us to maintain and structure the API endpoints in a much better and easier way.</p>
			<p>In this chapter, we will develop our project using this Flask extension so that you will see how we can structure our endpoints.</p>
			<h3 id="_idParaDest-42"><a id="_idTextAnchor046"/>Using Flask-RESTful to Develop Our Recipe-Sharing Platform, "Smilecook"</h3>
			<p>In this book, we are going to develop a recipe-sharing platform called <strong class="bold">Smilecook</strong>. Beginning with this chapter, we will start adding functions to it. We believe this approach will help you learn about the key concepts and skills you will need so that you can develop this application and help it reach its full potential, while at the same time helping you understand the entire development workflow.</p>
			<p>First, we will build the basic CRUD functions of the recipes. The Flask-RESTful package allows us to structure our code in a more comprehensive way. We will define certain methods in a resource and link them to the endpoints. The flow of a GET request, for example, will be for the request to be sent to the endpoints (<strong class="inline">http://localhost:5000/recipes</strong>), which will then be handled by the <strong class="inline">GET</strong> method we are going to implement in the resource. This will result in the recipes being returned to us.</p>
			<p>Apart from the basic CRUD functions, we will also implement the publish and unpublish functions on these recipes. This can be done through the <strong class="inline">PUT</strong> and <strong class="inline">DELETE</strong> methods, which can be found in the <strong class="inline">RecipePublishResource</strong> class. We will link these two methods to the <strong class="inline">http://localhost:5000/recipes/1/publish</strong> endpoint (for the recipe whose <em class="italics">ID = 1</em>). For details of our endpoint design, please refer to the following table:</p>
			<div>
				<div id="_idContainer032" class="IMG---Figure">
					<img src="image/C15309_02_01.jpg" alt=""/>
				</div>
			</div>
			<h6>Figure 2.1: Details of our endpoint designs</h6>
			<h2 id="_idParaDest-43"><a id="_idTextAnchor047"/>Virtual Environment</h2>
			<p>PyCharm will help us create a virtual environment. We want to develop our project in its own virtual environment in order to keep it isolated. Due to this, we will have absolute control over the versions of the packages that we are going to use.</p>
			<p>The best way to learn is through practice. Let's get our hands dirty now!</p>
			<h3 id="_idParaDest-44"><a id="_idTextAnchor048"/>Exercise 5: Creating a Development Project in PyCharm</h3>
			<p>Before you start developing the Python application, you'll need to create a development project in PyCharm. PyCharm manages things using projects. In this exercise, you will learn how to create a new development project in PyCharm called Smilecook. You will also need to install the necessary packages for this project. Let's get started:</p>
			<ol>
				<li><a id="_idTextAnchor049"/>Create the project and name it <strong class="bold">smilecook</strong>:<div id="_idContainer033" class="IMG---Figure"><img src="image/C15309_02_02.jpg" alt=""/></div><h6>Figure 2.2: Creating a project</h6></li>
				<li>Check the project structure and ensure that the virtual environment has been created. Once the module has been created, we will be able to see the project's hierarchy on the left-hand side panel. We can see the <strong class="bold">venv</strong> folder under the project folder, which was created and activated by PyCharm. Now, when we write code under this project, it will be run in the virtual environment:<div id="_idContainer034" class="IMG---Figure"><img src="image/C15309_02_03.jpg" alt=""/></div><h6>Figure 2.3: Checking the project structure and ensuring that the virtual environment has been created</h6></li>
				<li>Install the required packages for this chapter. To do this, create a file called <strong class="inline">requirements.txt</strong> under our project folder. Type in the following code to specify the packages you want to install:<p class="snippet">Flask==1.0.3</p><p class="snippet">Flask-RESTful==0.3.7</p><p class="snippet">httpie==1.0.3</p></li>
				<li>Use the <strong class="inline">pip</strong> command to install these packages. After that, in the <strong class="bold">Terminal</strong> tab, at the bottom of Pycharm, use the following <strong class="inline">pip</strong> command to install the packages that we specified in the <strong class="inline">requirements.txt</strong> file:<p class="snippet">pip install -r requirements.txt</p></li>
				<li>You should now see something similar in the following screenshot. Here, we can see that the packages are being installed on the virtual environment:<div id="_idContainer035" class="IMG---Figure"><img src="image/C15309_02_04.jpg" alt=""/></div></li>
			</ol>
			<h6>Figure 2.4: Installing the packages on the virtual environment</h6>
			<p>Congratulations! You have created a PyCharm project for our Smilecook application. This is the first step of you embarking on your journey as a developer!</p>
			<h2 id="_idParaDest-45"><a id="_idTextAnchor050"/>Creating a Recipe Model</h2>
			<p>As you can imagine, a recipe may have several attributes. To save every detail of these attributes, we will model the recipe using a class. This recipe class is going to have several essential attributes.</p>
			<p>Here is a brief description of the attributes that we will define in the recipe class:</p>
			<ul>
				<li><strong class="inline">name</strong>: The name of the recipe.</li>
				<li><strong class="inline">description</strong>: The description of the recipe.</li>
				<li><strong class="inline">num_of_servings</strong>: The number of servings.</li>
				<li><strong class="inline">cook_time</strong>: The cooking time required. This is an integer whose units are in seconds.</li>
				<li><strong class="inline">directions</strong>: The directions.</li>
				<li><strong class="inline">is_publish</strong>: The publish status of the recipe; the default is draft.</li>
			</ul>
			<p>In the next exercise, we will show you how to code the recipe class so that it has these attributes.</p>
			<h3 id="_idParaDest-46">Exe<a id="_idTextAnchor051"/>rcise 6: Creating the Recipe Model</h3>
			<p>In this exercise, we will code the recipe model, step by step. The <strong class="inline">recipe</strong> class will contain the attributes that we discussed previously. The code file for this exercise can be found in <strong class="inline">Lesson2/Exercise06/models/recipe.py</strong>.</p>
			<p>Now, let's create the recipe class:</p>
			<ol>
				<li value="1"><em class="italics">Right-click</em> on the project name, that is, Smilecook, and create a <strong class="inline">Python Package</strong>. Name it <strong class="inline">models</strong>:<div id="_idContainer036" class="IMG---Figure"><img src="image/C15309_02_05.jpg" alt=""/></div><h6>Fi<a id="_idTextAnchor052"/>gure 2.5: Creating a Python package and naming it models</h6></li>
				<li>Then<a id="_idTextAnchor053"/>, create a file called <strong class="inline">recipe.py</strong> under <strong class="inline">models</strong> and type in the following code:<p class="snippet">recipe_list = []</p><p class="snippet">def get_last_id():</p><p class="snippet">    if recipe_list:</p><p class="snippet">        last_recipe = recipe_list[-1]</p><p class="snippet">    else:</p><p class="snippet">        return 1</p><p class="snippet">    return last_recipe.id + 1</p><p>Let's pause for a while and examine the code here. First, we define <strong class="inline">recipe_list = []</strong> so that we can store the recipes in the application memory. Then, we define the <strong class="inline">get_last_id</strong> function to get the ID of our last recipe. Later, when we create a new recipe, we will use this method to evaluate the last ID in <strong class="inline">recipe_list</strong> so that we can come up with a new ID for the new recipe. </p></li>
				<li>Define the recipe class using the following code. Type the following code into <strong class="inline">recipe.py</strong>, right after the <strong class="inline">get_last_id</strong> function that we implemented:<p class="snippet">class Recipe:</p><p class="snippet">    def __init__(self, name, description, num_of_servings, cook_time, directions):</p><p class="snippet">        self.id = get_last_id()</p><p class="snippet">        self.name = name</p><p class="snippet">        self.description = description</p><p class="snippet">        self.num_of_servings = num_of_servings</p><p class="snippet">        self.cook_time = cook_time</p><p class="snippet">        self.directions = directions</p><p class="snippet">        self.is_publish = False</p><p>The <strong class="inline">Recipe</strong> class has the <strong class="inline">__init__</strong> constructor method, which will take in parameters such as <strong class="inline">name</strong>, <strong class="inline">description</strong>, <strong class="inline">num_of_servings</strong>, <strong class="inline">cook_time</strong>, and <strong class="inline">directions</strong>, and create the recipe object based on that. The ID is self-incremented and <strong class="inline">is_publish</strong> is set to <strong class="inline">false</strong> by default. This means that, by default, the recipe will be set to draft (not published).</p></li>
				<li>In the same <strong class="inline">Recipe</strong> class, define the <strong class="inline">data</strong> method for returning the data as a dictionary object. You will recall that, in Python, indentation matters. The following code is indented since it is under the <strong class="inline">Recipe</strong> class:<p class="snippet">    @property</p><p class="snippet">    def data(self):</p><p class="snippet">        return {</p><p class="snippet">            'id': self.id,</p><p class="snippet">            'name': self.name,</p><p class="snippet">            'description': self.description,</p><p class="snippet">            'num_of_servings': self.num_of_servings,</p><p class="snippet">            'cook_time': self.cook_time,</p><p class="snippet">            'directions': self.directions</p><p class="snippet">        }</p></li>
			</ol>
			<p>Now <a id="_idTextAnchor054"/>that we have built the recipe model, we will go ahead and build the API endpoint using Flask-RESTful.</p>
			<h3 id="_idParaDest-47"><a id="_idTextAnchor055"/>Resourceful Routing</h3>
			<p>The main building blocks in Flask-RESTful are resources. Resources are built on top of Flask's pluggable view. The concept of resourceful routing is that we want to structure all the client requests around resources. In our recipe-sharing platform, we are going to group the CRUD actions on a recipe under <strong class="inline">RecipeResource</strong>. For publish and unpublish actions, we will group them under a different <strong class="inline">RecipePublishResource</strong>. This provides a clear structure that other developers can follow.</p>
			<p>The way in which we can implement these resources is simple: we just need to inherit from the <strong class="inline">flask_restful.Resource</strong> class and implement the methods that correspond to the HTTP verb inside it.</p>
			<p>In the next exercise, we will define three subclasses: one for the collection of recipes, one for a single recipe, and one for publishing the recipe. </p>
			<h3 id="_idParaDest-48"><a id="_idTextAnchor056"/>Exercise 7: Defining an API Endpoint for the Recipe Model</h3>
			<p>To build an API endpoint, we need to define a class that inherits from <strong class="inline">flask_restful.Resource</strong>. Then, we can declare the get and post methods inside the class. Let's get started:</p>
			<ol>
				<li value="1">Crea<a id="_idTextAnchor057"/>te a folder called <strong class="inline">resources</strong> under the project and then crea<a id="_idTextAnchor058"/>te a file called <strong class="inline">recipe.py</strong> under the <strong class="inline">resources</strong> folder.<h4>Note</h4><p class="callout">The code file for this can be found in the <a href="https://github.com/TrainingByPackt/Python-API-Development-Fundamentals/tree/master/Lesson02/Exercise07/resources">https://github.com/TrainingByPackt/Python-API-Development-Fundamentals/tree/master/Lesson02/Exercise07/resources</a>.</p></li>
				<li>Impo<a id="_idTextAnchor059"/>rt the necessary packages, classes, and functions using the following code:<p class="snippet">from flask import request</p><p class="snippet">from flask_restful import Resource</p><p class="snippet">from http import HTTPStatus</p><p class="snippet">from models.recipe import Recipe, recipe_list</p></li>
				<li>Righ<a id="_idTextAnchor060"/>t after the preceding code import, create the <strong class="inline">RecipeListResource</strong> class. This class has <strong class="inline">GET</strong> and <strong class="inline">POST</strong> methods, which are used to get and create the recipe's resources, respectively. We will finish the get method first:<p class="snippet">class RecipeListResource(Resource):</p><p class="snippet">    def get(self):</p><p class="snippet">        data = []</p><p class="snippet">        for recipe in recipe_list:</p><p class="snippet">            if recipe.is_publish is True:</p><p class="snippet">                data.append(recipe.data)</p><p class="snippet">        return {'data': data}, HTTPStatus.OK</p><p>Here, we have created and implemented the <strong class="inline">RecipeListResource</strong> class, which inherits from <strong class="inline">flask-restful.Resource</strong>. The <strong class="inline">get</strong> method that we implemented is for, getting all the public recipes back. It does this by declaring a <strong class="inline">data</strong> list and getting all the recipes with <strong class="inline">is_publish</strong> = <strong class="inline">true</strong> in <strong class="inline">recipe_list</strong>. These recipes are appended to our <strong class="inline">data</strong> list and returned to the users.</p></li>
				<li>Add the <strong class="inline">post</strong> method. This is used to create the recipe:<p class="snippet">    def post(self):</p><p class="snippet">        data = request.get_json()</p><p class="snippet">        recipe = Recipe(name=data['name'],</p><p class="snippet">                        description=data['description'],</p><p class="snippet">                        num_of_servings=data['num_of_servings'],</p><p class="snippet">                        cook_time=data['cook_time'],</p><p class="snippet">                        directions=data['directions'])</p><p class="snippet">        recipe_list.append(recipe)</p><p class="snippet">        return recipe.data, HTTPStatus.CREATED</p></li>
			</ol>
			<p>In this exercise, we have built two methods that handle the GET and POST client requests. The following table summarizes the methods that we have built in this exercise:</p>
			<div>
				<div id="_idContainer037" class="IMG---Figure">
					<img src="image/C15309_02_06.jpg" alt=""/>
				</div>
			</div>
			<h6>Figure 2.6: Client request methods that we used in this exercise</h6>
			<h4>Note</h4>
			<p class="callout">We have skipped the step to jsonify the object before returning data to the client because Flask-RESTful has already done that for us behind the scenes.</p>
			<p class="callout">The <strong class="inline">post</strong> method that we built in this exercise is for creating a new recipe. It is a <strong class="inline">POST</strong> method. It does this by getting the JSON data back from the request using <strong class="inline">request.get_json</strong> and then creates the recipe object and stores that in <strong class="inline">recipe_list</strong>. Finally, it returns the recipe record with an HTTP status code <strong class="bold">201 CREATED</strong>.</p>
			<h3 id="_idParaDest-49"><a id="_idTextAnchor061"/>Exercise 8: Defining the Recipe Resource</h3>
			<p>In this exercise, we will define the recipe resource. We are going to use two methods: the get method, for getting back a single recipe; and the put method, for updating the recipe. Let's get started:</p>
			<ol>
				<li value="1"><a id="_idTextAnchor062"/>Define the <strong class="inline">RecipeResource</strong> resource and implement the <strong class="inline">get</strong> method by using the following sample code:<p class="snippet">class RecipeResource(Resource):</p><p class="snippet">    def get(self, recipe_id):</p><p class="snippet">        recipe = next((recipe for recipe in recipe_list if recipe.id == recipe_id and recipe.is_publish == True), None)</p><p class="snippet">        if recipe is None:</p><p class="snippet">            return {'message': 'recipe not found'}, HTTPStatus.NOT_FOUND</p><p class="snippet">        return recipe.data, HTTPStatus.OK</p><p>Similarly, <strong class="inline">RecipeResource</strong> also inherits from <strong class="inline">flask-restful.Resource</strong>. The get method we are implementing here is getting back a single recipe. We do that by searching for <strong class="inline">recipe_id</strong> in <strong class="inline">recipe_list</strong>. We will only get back those recipes with <strong class="inline">is_publish = true</strong>. If no such recipe is found, we will return the message <strong class="bold">recipe not found</strong>. Otherwise, we will return the recipe, along with an HTTP status of <strong class="bold">200 OK</strong>.</p></li>
				<li>Implement the <strong class="inline">put</strong> method with the following code:<p class="snippet">    def put(self, recipe_id):</p><p class="snippet">        data = request.get_json()</p><p class="snippet">        recipe = next((recipe for recipe in recipe_list if recipe.id == recipe_id), None)</p><p class="snippet">        if recipe is None:</p><p class="snippet">            return {'message': 'recipe not found'}, HTTPStatus.NOT_FOUND</p><p class="snippet">        recipe.name = data['name']</p><p class="snippet">        recipe.description = data['description']</p><p class="snippet">        recipe.num_of_servings = data['num_of_servings']</p><p class="snippet">        recipe.cook_time = data['cook_time']</p><p class="snippet">        recipe.directions = data['directions']</p><p class="snippet">        return recipe.data, HTTPStatus.OK</p><p>The second method we've implemented here is <strong class="inline">put</strong>. It gets the recipe details from the client request using <strong class="inline">request.get_json</strong> and updates the recipe object. Then, it returns the HTTP status code <strong class="bold">200 OK</strong> if everything goes well.</p></li>
			</ol>
			<p>Here, we have built two methods for the recipe resources. The <strong class="inline">GET</strong> and <strong class="inline">PUT</strong> methods are used to handle the corresponding client request. The following table shows the methods that we have built for the <strong class="inline">RecipeResource</strong> class in this exercise:</p>
			<div>
				<div id="_idContainer038" class="IMG---Figure">
					<img src="image/C15309_02_07.jpg" alt=""/>
				</div>
			</div>
			<h6>Figure 2.7: Methods that we have built for the RecipeResource class</h6>
			<h3 id="_idParaDest-50"><a id="_idTextAnchor063"/>Exercise 9: Publishing and Unpublishing the Recipes</h3>
			<p>In the previous exercises, we created the recipe resources and their associated methods. Now, our Smilecook application can read/write actions on recipes. However, at the beginning of this chapter, we said that the recipes can have two Statuses (unpublished and published). This allows the user to continue updating their unpublished recipes before publishing them to the world. In this exercise, we will define the resource for publishing and unpublishing a recipe. Let's get started:</p>
			<ol>
				<li value="1"><a id="_idTextAnchor064"/>Define the <strong class="inline">RecipePublic</strong> resource and implement the <strong class="inline">put</strong> method that will handle the HTTP PUT request:<p class="snippet">class RecipePublishResource(Resource):</p><p class="snippet">    def put(self, recipe_id):</p><p class="snippet">        recipe = next((recipe for recipe in recipe_list if recipe.id == recipe_id), None)</p><p class="snippet">        if recipe is None:</p><p class="snippet">            return {'message': 'recipe not found'}, HTTPStatus.NOT_FOUND</p><p class="snippet">        recipe.is_publish = True</p><p class="snippet">        return {}, HTTPStatus.NO_CONTENT</p><p><strong class="inline">RecipePublishResource</strong> inherits from <strong class="inline">flask_restful.Resource</strong>. The <strong class="inline">put</strong> method will locate the recipe with the passed-in <strong class="inline">recipe_id</strong> and update the <strong class="inline">is_publish</strong> status to true. Then, it will return <strong class="inline">HTTPStatus.NO_CONTENT</strong>, which shows us that the recipe has been published successfully. </p></li>
				<li>Implement the <strong class="inline">delete</strong> method, which will handle the HTTP DELETE request:<p class="snippet">    def delete(self, recipe_id):</p><p class="snippet">        recipe = next((recipe for recipe in recipe_list if recipe.id == recipe_id), None)</p><p class="snippet">        if recipe is None:</p><p class="snippet">            return {'message': 'recipe not found'}, HTTPStatus.NOT_FOUND</p><p class="snippet">        recipe.is_publish = False</p><p class="snippet">        return {}, HTTPStatus.NO_CONTENT</p><p>The <strong class="inline">delete</strong> method is the opposite of the <strong class="inline">put</strong> method. Instead of setting <strong class="inline">is_publish</strong> to <strong class="inline">true</strong>, it sets it to <strong class="inline">false</strong> in order to unpublish the recipe.</p><p>You can also see that we are using these methods in a flexible manner; the <strong class="inline">put</strong> method is not necessarily for update, and the <strong class="inline">delete</strong> method is not necessarily for removal.</p></li>
			</ol>
			<p>The following table shows all the methods that we have created in this exercise. Now that we have all three resources ready (<strong class="inline">RecipeListResource</strong>, <strong class="inline">RecipeResource</strong>, and <strong class="inline">RecipePublishResource</strong>), we will discuss endpoint configuration:</p>
			<div>
				<div id="_idContainer039" class="IMG---Figure">
					<img src="image/C15309_02_08.jpg" alt=""/>
				</div>
			</div>
			<h6>Figure 2.8: Methods that we used in this exercise</h6>
			<h4>Note</h4>
			<p class="callout">If the client request is with an HTTP verb that has no corresponding handling method in the resource, Flask-RESTful will return the HTTP status code <strong class="bold">405 Method Not Allowed</strong>.</p>
			<h2 id="_idParaDest-51"><a id="_idTextAnchor065"/>Configuring Endpoints</h2>
			<p>Now that we have defined all our resources, we will set up some endpoints so that users can send requests to them. These endpoints can be accessed by the users and are connected to specific resources. We will be using the <strong class="inline">add_resource</strong> method on the API object to specify the URL for these endpoints and route the client HTTP request to our resources. </p>
			<p>For example, the <strong class="inline">api.add_resource(RecipeListResource, '/recipes')</strong> syntax is used to link the route (relative URL path) to <strong class="inline">RecipeListResource</strong> so that HTTP requests will be directed to this resource. Depending on the HTTP verb (for example, <strong class="inline">GET</strong>, and <strong class="inline">POST</strong>), the request will be handled by the corresponding methods in the resource accordingly.</p>
			<h3 id="_idParaDest-52"><a id="_idTextAnchor066"/>Exercise 10: Creating the Main Application File</h3>
			<p>In this exercise, we will create our <strong class="inline">app.py</strong> file, which will be our main application file. We will set up Flask and initialize our <strong class="inline">flask_restful.API</strong> there. Finally, we will set up the endpoints so that users can send requests to our backend services. Let's get started:</p>
			<ol>
				<li value="1"><a id="_idTextAnchor067"/>Create the <strong class="inline">app.py</strong> file under the project folder.</li>
				<li><a id="_idTextAnchor068"/>Import the necessary classes using the following code:<p class="snippet">from flask import Flask</p><p class="snippet">from flask_restful import Api</p><p class="snippet">from resources.recipe import RecipeListResource, RecipeResource, RecipePublishResource</p></li>
				<li>Set up Flask and initialize <strong class="inline">flask_restful.API</strong> with our Flask app:<p class="snippet">app = Flask(__name__)</p><p class="snippet">api = Api(app)</p></li>
				<li><a id="_idTextAnchor069"/>Add resource routing by passing in the URL so that it will route to our resources. Each resource will have its own HTTP method defined:<p class="snippet">api.add_resource(RecipeListResource, '/recipes') </p><p class="snippet">api.add_resource(RecipeResource, '/recipes/&lt;int:recipe_id&gt;')</p><p class="snippet">api.add_resource(RecipePublishResource, '/recipes/&lt;int:recipe_id&gt;/publish')</p><p class="snippet">if __name__ == '__main__':</p><p class="snippet">    app.run(port=5000, debug=True)</p><h4>Note</h4><p class="callout">In <strong class="inline">RecipeListResource</strong>, we have defined the <strong class="inline">get</strong> and <strong class="inline">post</strong> methods. So, when there is a GET HTTP request to the "/recipes" URL route, it will invoke the <strong class="inline">get</strong> method under <strong class="inline">RecipeListResource</strong> and get back all the published recipes.</p><p><a id="_idTextAnchor070"/>In the preceding code, you will notice that we have used <strong class="inline">&lt;int: recipe_id &gt;</strong> in the code. It is there as a placeholder for the recipe ID. When a GET HTTP request has been sent to the <strong class="inline">route "/recipes/2"</strong> URL, this will invoke the get method under <strong class="inline">RecipeResource</strong> with a parameter, that is, <strong class="inline">recipe_id = 2</strong>.</p></li>
				<li>Save <strong class="inline">app.py</strong> and <em class="italics">right-click</em> on it to run the application. Flask will then start up and run on the localhost (<strong class="inline">127.0.0.1</strong>) at port <strong class="inline">5000</strong>:</li>
			</ol>
			<div>
				<div id="_idContainer040" class="IMG---Figure">
					<img src="image/C15309_02_09.jpg" alt=""/>
				</div>
			</div>
			<h6>Figure 2.9: Flask started and running on localhost</h6>
			<p>Congratulations! You have completed the API endpoint. Now, let's move on to testing. You can either test it in curl/httpie or Postman.</p>
			<h2 id="_idParaDest-53">M<a id="_idTextAnchor071"/><a id="_idTextAnchor072"/>aking HTTP Requests to the Flask API using curl and httpie</h2>
			<p>Now, we are going to use the <strong class="inline">httpie</strong> and <strong class="inline">curl</strong> commands to test our API endpoints. We will test the functions for getting all the recipes back from the server and create/update/delete, publish, and unpublish the recipes. The best way to learn this is to complete a hands-on exercise. Let's get started!</p>
			<h3 id="_idParaDest-54"><a id="_idTextAnchor073"/>Exercise 11: Testing the Endpoints Using curl and httpie</h3>
			<p>In this exercise, we are going to use the httpie and curl commands to send requests to the endpoints so that we can create our first recipe. We want you to get comfortable using the httpie and curl command-line testing tool. Let's get started:</p>
			<ol>
				<li value="1">Open the Terminal in PyCharm and type in the following commands. You can use either the httpie or curl command. The following is the httpie command (<strong class="inline">= is for string and :=  is for non-string</strong>):<p class="snippet">http POST localhost:5000/recipes name="Cheese Pizza" description="This is a lovely cheese pizza" num_of_servings:=2 cook_time:=30 directions="This is how you make it"</p><p>The following is the curl command. The <strong class="inline">-H</strong> argument is used to specify the header in the client request. We will set <strong class="inline">Content-Type: application/json</strong> as the header here. The <strong class="inline">-d</strong> argument is used for HTTP POST data, that is, the recipe in JSON format:</p><p class="snippet">curl -i -X POST localhost:5000/recipes -H "Content-Type: application/json" -d '{"name":"Cheese Pizza", "description":"This is a lovely cheese pizza", "num_of_servings":2, "cook_time":30, "directions":"This is how you make it" }'</p></li>
				<li>Examine the response, you should see the following. Carefully examine it, it should be the same recipe as the one that was used in our request in <em class="italics">Step 1</em>:<p class="snippet">HTTP/1.0 201 CREATED</p><p class="snippet">Content-Type: application/json</p><p class="snippet">Content-Length: 188</p><p class="snippet">Server: Werkzeug/0.16.0 Python/3.7.0</p><p class="snippet">Date: Sun, 03 Nov 2019 03:19:00 GMT</p><p class="snippet">{</p><p class="snippet">    "id": 1,</p><p class="snippet">    "name": "Cheese Pizza",</p><p class="snippet">    "description": "This is a lovely cheese pizza",</p><p class="snippet">    "num_of_servings": 2,</p><p class="snippet">    "cook_time": 30,</p><p class="snippet">    "directions": "This is how you make it"</p><p class="snippet">}</p><h4>Note</h4><p class="callout">Once the client request has been sent to the server using the HTTP <strong class="inline">POST</strong> method, the <strong class="inline">post</strong> method in <strong class="inline">RecipeResource</strong> will pick up the request and save the recipe in the request to the application memory. The new recipe will be appended in <strong class="inline">recipe_list</strong>. Once everything is done, it will return HTTP <strong class="inline">201 CREATED</strong> and the newly created recipe in JSON format.</p></li>
			</ol>
			<p>We have successfully created our first recipe on the platform. This recipe is stored on the server-side and we already have the API to retrieve it. Let's continue by creating our second recipe and retrieving all our recipes in one go.</p>
			<h3 id="_idParaDest-55"><a id="_idTextAnchor074"/>Exercise 12: Testing the Auto-Incremented Recipe ID</h3>
			<p>Now that we have implemented the auto-incremented ID in our Smilecook application, let's see how it works in practice. In this exercise, we will create the second recipe using the httpie and curl commands. Note that the ID is auto- incremented for our second recipe. Let's get started:</p>
			<ol>
				<li value="1">Create a second recipe and note that the ID is automatically incremented. Send the following client request using httpie:<p class="snippet">http POST localhost:5000/recipes name="Tomato Pasta" description="This is a lovely tomato pasta recipe" num_of_servings:=3 cook_time:=20 directions="This is how you make it"</p><p>Alternatively, send the request using curl. Again, the <strong class="inline">-H</strong> argument is used to specify the header in the client request. We will set "<strong class="inline">Content-Type: application/json</strong>" as the header here. The <strong class="inline">-d</strong> argument is used for HTTP POST data, meaning that the recipe is in JSON format:</p><p class="snippet">curl -i -X POST localhost:5000/recipes -H "Content-Type: application/json" -d '{"name":"Tomato Pasta", "description":"This is a lovely tomato pasta recipe", "num_of_servings":3, "cook_time":20, "directions":"This is how you make it"}'</p></li>
				<li>You should see the following response. Examine it carefully, it should be the same recipe as the one that was used in our request in <em class="italics">Step 1</em>:<p class="snippet">HTTP/1.0 201 CREATED</p><p class="snippet">Content-Type: application/json</p><p class="snippet">Content-Length: 195</p><p class="snippet">Server: Werkzeug/0.16.0 Python/3.7.0</p><p class="snippet">Date: Sun, 03 Nov 2019 03:23:37 GMT</p><p class="snippet"> </p><p class="snippet">{</p><p class="snippet">    "id": 2,</p><p class="snippet">    "name": "Tomato Pasta",</p><p class="snippet">    "description": "This is a lovely tomato pasta recipe",</p><p class="snippet">    "num_of_servings": 3,</p><p class="snippet">    "cook_time": 20,</p><p class="snippet">    "directions": "This is how you make it"</p><p class="snippet">}</p><p>Once the preceding client request has been sent to the server using the HTTP <strong class="inline">POST</strong> method, the <strong class="inline">post</strong> method in <strong class="inline">RecipeResource</strong> will pick up the request and save the recipe in the request to the application memory. The new recipe will be appended in <strong class="inline">recipe_list</strong>. This time, the ID will be automatically assigned to 2.</p></li>
			</ol>
			<h3 id="_idParaDest-56"><a id="_idTextAnchor075"/>Exercise 13: Getting All the Recipes Back</h3>
			<p>In this exercise, we will be using the httpie and curl commands to get back all the recipes that we have created. We are doing this to ensure that our recipes are there in the backend server. Let's get started: </p>
			<ol>
				<li value="1">Retrieve all the recipes by sending the following client request using httpie:<p class="snippet">http GET localhost:5000/recipes</p><p>Alternatively, send the following request using curl. The <strong class="inline">-i</strong> argument is used to state that we want to see the response header. <strong class="inline">-X GET</strong> means that we are sending the client request using the HTTP <strong class="inline">GET</strong> method:</p><p class="snippet">curl -i -X GET localhost:5000/recipes </p></li>
				<li>You should see the following response. Please examine it carefully:<p class="snippet">HTTP/1.0 200 OK</p><p class="snippet">Content-Length: 19</p><p class="snippet">Content-Type: application/json</p><p class="snippet">Date: Sun, 03 Nov 2019 03:24:53 GMT</p><p class="snippet">Server: Werkzeug/0.16.0 Python/3.7.0</p><p class="snippet"> </p><p class="snippet">{</p><p class="snippet">    "data": []</p><p class="snippet">}</p><p>Once the preceding client request has been sent to the server using the HTTP GET method, the get method in <strong class="inline">RecipeResource</strong> will pick up the request and retrieve all the published recipes from <strong class="inline">recipe_list</strong> in the application memory.</p><h4><a id="_idTextAnchor076"/>Note</h4><p class="callout">We should see an empty list in the HTTP response because all the recipes we have created in the previous steps are in draft form (not published).</p></li>
			</ol>
			<h3 id="_idParaDest-57"><a id="_idTextAnchor077"/>Exercise 14: Testing the Recipe Resources</h3>
			<p>We have already tested the endpoints we built around the recipe resources. In this exercise, we will continue to use the httpie and curl commands to test the recipe publishing API. We can test it by sending requests asking to publish our recipes on the API endpoint. Let's get started:</p>
			<ol>
				<li value="1">Modify the publish status of the recipe with ID 1. We can send the following client request using the httpie command:<p class="snippet">http PUT localhost:5000/recipes/1/publish</p><p>Alternatively, we can use the following curl command:</p><p class="snippet">curl -i -X PUT localhost:5000/recipes/1/publish </p><h4>Note</h4><p class="callout">Once the preceding client request has been sent to the server using the HTTP PUT method, the <strong class="inline">put</strong> method in <strong class="inline">RecipePublishResource</strong> will pick up the request and assign <strong class="inline">recipe_id</strong> to be 1. The application will look for the recipe with <strong class="inline">ID = 1</strong> and update its publish status to <strong class="inline">True</strong>.</p></li>
				<li>You should see the following response. Please examine it carefully:<p class="snippet">HTTP/1.0 204 NO CONTENT</p><p class="snippet">Content-Type: application/json</p><p class="snippet">Date: Sun, 03 Nov 2019 03:25:48 GMT</p><p class="snippet">Server: Werkzeug/0.16.0 Python/3.7.0</p></li>
				<li>Now, retrieve all the published recipes and examine them. Then, send the following client request using httpie:<p class="snippet">http GET localhost:5000/recipes</p><p>Alternatively, send the following request using curl. The <strong class="inline">-i</strong> argument is used to say that we want to see the response header. <strong class="inline">-X GET</strong> means that we are sending the client request using the HTTP GET method:</p><p class="snippet">curl -i -X GET localhost:5000/recipes</p></li>
				<li>You should see the following response. Please examine it carefully:<p class="snippet">HTTP/1.0 200 OK</p><p class="snippet">Content-Type: application/json</p><p class="snippet">Content-Length: 276</p><p class="snippet">Server: Werkzeug/0.16.0 Python/3.7.0</p><p class="snippet">Date: Sun, 03 Nov 2019 03:26:43 GMT</p><p class="snippet"> </p><p class="snippet">{</p><p class="snippet">    "data": [</p><p class="snippet">        {</p><p class="snippet">            "id": 1,</p><p class="snippet">            "name": "Cheese Pizza",</p><p class="snippet">            "description": "This is a lovely cheese pizza",</p><p class="snippet">            "num_of_servings": 2,</p><p class="snippet">            "cook_time": 30,</p><p class="snippet">            "directions": "This is how you make it"</p><p class="snippet">        }</p><p class="snippet">    ]</p><p class="snippet">}</p><p>Once the preceding client request has been sent to the server using the HTTP <strong class="inline">GET</strong> method, the get method in <strong class="inline">RecipeResource</strong> will pick up the request and retrieve all the published recipes from <strong class="inline">recipe_list</strong> in the application memory. This time, because the recipe with ID 1 has been set to publish, we shall see it in the HTTP response.</p></li>
			</ol>
			<h3 id="_idParaDest-58"><a id="_idTextAnchor078"/>Exercise 15: Negative Testing</h3>
			<p>In the previous exercise, we successfully published our recipe. This is good because it shows us that the APIs that we've developed work. But the whole point of testing is to discover potential issues if any. We can perform so-called negative testing here. This is the process of deliberately testing the scenario with unwanted input. This exercise is going to test a request with an HTTP VERB that has no corresponding method defined in the resource. Let's get started:</p>
			<ol>
				<li value="1">Send the following request to the server-side. This HTTP method has not been defined; let's see what happens:<p class="snippet">http DELETE localhost:5000/recipes</p><p>The following is the curl command, which does the same thing:</p><p class="snippet">curl -i -X DELETE localhost:5000/recipes </p></li>
				<li>You should see the following response. Please examine it carefully:<p class="snippet">HTTP/1.0 405 METHOD NOT ALLOWED</p><p class="snippet">Content-Type: application/json</p><p class="snippet">Content-Length: 70</p><p class="snippet">Allow: POST, GET, HEAD, OPTIONS</p><p class="snippet">Server: Werkzeug/0.16.0 Python/3.7.0</p><p class="snippet">Date: Sun, 03 Nov 2019 03:27:37 GMT</p><p class="snippet"> </p><p class="snippet">{</p><p class="snippet">    "message": "The method is not allowed for the requested URL."</p><p class="snippet">}</p><p>We should see a response with an HTTP status of <strong class="bold">405</strong>, which means that the method is not allowed for the requested URL. This makes sense because we have not defined a delete method in <strong class="inline">RecipeListResource</strong>.</p></li>
			</ol>
			<p>N<a id="_idTextAnchor079"/>egative testing is important. We always want our testing to be more complete and covers more scenarios.</p>
			<h3 id="_idParaDest-59"><a id="_idTextAnchor080"/>Exercise 16: Modifying the Recipes</h3>
			<p>In our Smilecook application, authors are allowed to update their recipes. It is like a blogging platform, where the authors can take their time to perfect their work, even after it has been published. Since we have already built the API, we would like to test it using Postman. Let's get started:</p>
			<ol>
				<li value="1">Use the PUT method to send the request to <strong class="inline">localhost:5000/recipes/1</strong>, along with the new recipe details:<p class="snippet">http PUT localhost:5000/recipes/1 name="Lovely Cheese Pizza" description="This is a lovely cheese pizza recipe" num_of_servings:=3 cook_time:=60 directions="This is how you make it"</p><p>Alternatively, send the following request using curl. The <strong class="inline">-H</strong> argument is used to specify the header in the client request. We will set "<strong class="inline">Content-Type: application/json</strong>" as the header here. The <strong class="inline">-d</strong> argument is used for HTTP POST data, meaning that the recipe will be in JSON format:</p><p class="snippet">curl -i -X PUT localhost:5000/recipes/1 -H "Content-Type: application/json" -d '{"name":"Lovely Cheese Pizza", "description":"This is a lovely cheese pizza recipe", "num_of_servings":3, "cook_time":60, "directions":"This is how you make it"}'</p></li>
				<li>You should see the following response. Please examine it carefully:<p class="snippet">HTTP/1.0 200 OK</p><p class="snippet">Content-Type: application/json</p><p class="snippet">Content-Length: 202</p><p class="snippet">Server: Werkzeug/0.16.0 Python/3.7.0</p><p class="snippet">Date: Sun, 03 Nov 2019 03:28:57 GMT</p><p class="snippet"> </p><p class="snippet">{</p><p class="snippet">    "id": 1,</p><p class="snippet">    "name": "Lovely Cheese Pizza",</p><p class="snippet">    "description": "This is a lovely cheese pizza recipe",</p><p class="snippet">    "num_of_servings": 3,</p><p class="snippet">    "cook_time": 60,</p><p class="snippet">    "directions": "This is how you make it"</p><p class="snippet">}</p><p>Once the preceding client request has been sent to the server using the HTTP PUT method, the <strong class="inline">put</strong> method in <strong class="inline">RecipeResource</strong> will pick up the request and assign <strong class="inline">recipe_id</strong> to be 1. The application will look for the recipe with <strong class="inline">id = 1</strong> and update its details with those in the client request. The preceding response shows that the recipe with ID 1 is modified. </p></li>
			</ol>
			<p>W<a id="_idTextAnchor081"/>e just finished testing another important feature. You have been doing great. Let's keep going!</p>
			<h3 id="_idParaDest-60"><a id="_idTextAnchor082"/>Exercise 17: Getting Back Specific Recipes with a Certain ID</h3>
			<p>So far, we have tested getting all the recipes back. But in the real world, a user will want to only get the recipes that they want to see. They can do this by using the recipe ID. This exercise will show you how to get a particular recipe with a certain ID. Let's get started:</p>
			<ol>
				<li value="1">Send the following client request using httpie:<p class="snippet">http GET localhost:5000/recipes/1</p><p>Alternatively, use the following curl command, which does the same thing:</p><p class="snippet">curl -i -X GET localhost:5000/recipes/1</p><p class="snippet">You should see the following response. Please examine it carefully:</p><p class="snippet">HTTP/1.0 200 OK</p><p class="snippet">Content-Type: application/json</p><p class="snippet">Content-Length: 202</p><p class="snippet">Server: Werkzeug/0.16.0 Python/3.7.0</p><p class="snippet">Date: Sun, 03 Nov 2019 03:29:59 GMT</p><p class="snippet"> </p><p class="snippet">{</p><p class="snippet">    "id": 1,</p><p class="snippet">    "name": "Lovely Cheese Pizza",</p><p class="snippet">    "description": "This is a lovely cheese pizza recipe",</p><p class="snippet">    "num_of_servings": 3,</p><p class="snippet">    "cook_time": 60,</p><p class="snippet">    "directions": "This is how you make it"</p><p class="snippet">}</p><p>Once the preceding client request has been sent to the server using the HTTP <strong class="inline">GET</strong> method, the get method in <strong class="inline">RecipeResource</strong> will pick up the request and assign <strong class="inline">recipe_id</strong> to be 1. It will retrieve all the published recipes from <strong class="inline">recipe_list</strong> in the application memory with an HTTP status of HTTP <strong class="inline">200</strong>.</p></li>
			</ol>
			<p>We have just tested our Smilecook application and confirmed that it can give us back the recipe we want. </p>
			<h3 id="_idParaDest-61"><a id="_idTextAnchor083"/>Activity 3: Testing the APIs Using Postman</h3>
			<p>We added quite a few functions in the previous exercise. Now, we need to make sure that they work properly before we move on and develop other functions. In this activity, instead of using httpie/curl, we will be testing our API using Postman. Please follow these high-level steps:</p>
			<ol>
				<li value="1">Create the first recipe using Postman.</li>
				<li>Create the second recipe using Postman.</li>
				<li>Retrieve all the recipes using Postman.</li>
				<li>Set the recipes to published using Postman.</li>
				<li>Retrieve all the recipes using Postman again.</li>
				<li>Modify the recipe using Postman.</li>
				<li>Get a specific recipe back using Postman.<h4>Note</h4><p class="callout">The solution to this activity can be found on page 293.</p></li>
			</ol>
			<h3 id="_idParaDest-62">A<a id="_idTextAnchor084"/>ctivity 4: Implementing the Delete Recipe Function</h3>
			<p>In this activity, you will implement the delete recipe function in the Smilecook application yourself. Do this by adding a delete function to <strong class="inline">RecipeResource</strong>, similar to what we did in the previous exercises. Then, we will follow the standard software development life cycle flow, which is used to test our implementation, using Postman. Follow these steps to complete this activity:</p>
			<ol>
				<li value="1">Add the delete function to <strong class="inline">RecipeResource</strong>.</li>
				<li>Start up the Flask server for testing.</li>
				<li>Create the first recipe using Postman.</li>
				<li>Delete the recipe using Postman.<h4>Note</h4><p class="callout">The solution to this activity can be found on page 299.</p></li>
			</ol>
			<h2 id="_idParaDest-63"><a id="_idTextAnchor085"/>Summary</h2>
			<p>In this chapter, we built the RESTful API using the Flask-RESTful package. By doing this, you have seen how simple and easy it is to perform such tasks. We are building our project in a structural manner, which allows us to easily extend the project in the subsequent chapters. In this chapter, we created the models and resources folder; we will be developing more models and resources later in this book. So far, our food recipe-sharing platform, Smilecook, is capable of performing CRUD, as well as setting the publish status of the recipe. We have also tested the application to make sure it is working properly. Finally, you started to realize the power of Postman, which greatly automates the whole testing process. In the next chapter, we will learn about how to perform data validation.</p>
		</div>
	</body></html>