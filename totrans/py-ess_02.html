<html><head></head><body><div class="chapter" title="Chapter&#xA0;2.&#xA0;Simple Data Types"><div class="titlepage"><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Simple Data Types</h1></div></div></div><p>Now we'll look at a number of data types that are built-in as well as some that are part of Python's<a class="indexterm" id="id91"/> standard library. We'll start with Python's numeric <a class="indexterm" id="id92"/>types. These include three built-in types: <code class="literal">int</code>, <code class="literal">float</code>, and <code class="literal">complex</code>, plus<a class="indexterm" id="id93"/> the standard library types <code class="literal">Fraction</code> and <code class="literal">Decimal</code>.</p><p>We'll also look at strings, <code class="literal">str</code>, and simple collections, <code class="literal">tuple</code>. These are more complex than numbers because they contain multiple items. Since their behavior is less complex than the kinds of objects we'll see in later chapters, they serve as a good introduction to the general concept of sequences in Python.</p><p>Note the capitalization of the names of <code class="literal">Fraction</code> and <code class="literal">Decimal</code>. The built-in type names start with a lowercase letter. Types that we must import have a module name that starts with a lowercase letter, but the type name starts with a capital letter. This convention is widespread, but not universal.</p><p>All of the types we'll look at in this chapter have the common feature of immutability. This concept applies to the two collections we'll look at: once built, a string or a tuple cannot be changed. Rather than change it, we create a new object. In <a class="link" href="ch06.html" title="Chapter 6. More Complex Data Types">Chapter 6</a>, <span class="emphasis"><em>More Complex Data Types</em></span>, we'll look at collections which can be updated without creating a new object.</p><p>In this chapter, we'll look at the built-in functions for converting to and from string representations. This will help us when displaying output or converting input from a string to a useful Python object.</p><p>Note that we're continuing to play fast and loose with formal Python syntax. We'll defer a detailed examination of the syntax rules until <a class="link" href="ch03.html" title="Chapter 3. Expressions and Output">Chapter 3</a>, <span class="emphasis"><em>Expressions and Output</em></span>. For now, the kinds of simple expression statements we're focusing on must be restricted to a single line.</p><div class="section" title="Introducing the built-in operators"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec15"/>Introducing the built-in operators</h1></div></div></div><p>Before <a class="indexterm" id="id94"/>looking at the various kinds of numbers available, we'll introduce the Python operators. The operators fall into three broad groups:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Group</p>
</th><th style="text-align: left" valign="bottom">
<p>Operators</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>Arithmetic</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">+</code>, <code class="literal">-</code>, <code class="literal">*</code>, <code class="literal">**</code>, <code class="literal">/</code>, <code class="literal">//</code>, <code class="literal">%</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Bit-oriented</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">&lt;&lt;</code>, <code class="literal">&gt;&gt;</code>, <code class="literal">&amp;</code>, <code class="literal">|</code>, <code class="literal">^</code>, <code class="literal">~</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Comparison</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">&lt;</code>, <code class="literal">&gt;</code>, <code class="literal">&lt;=</code>, <code class="literal">&gt;=</code>, <code class="literal">==</code>, <code class="literal">!=</code>
</p>
</td></tr></tbody></table></div><p>The<a class="indexterm" id="id95"/> differences between these groups are partly subjective. There's <a class="indexterm" id="id96"/>only a small technical difference<a class="indexterm" id="id97"/> in the way the comparison operators work. Most of the operators are binary, only one (<code class="literal">~</code>) is unary, and a few (<code class="literal">+</code>, <code class="literal">-</code>, <code class="literal">*</code>, <code class="literal">**</code>) can be used in either context.</p><p>The <code class="literal">+</code>, <code class="literal">-</code>, <code class="literal">*</code>, <code class="literal">/</code>, and <code class="literal">%</code> operators have meanings similar to those used other programming languages. There is an arithmetic meaning for <code class="literal">–</code> and <code class="literal">+</code>. Python adds the <code class="literal">**</code> operator when raising a number to a power. The <code class="literal">**</code> operator takes higher precedence than the unary form <code class="literal">-</code>; this means that <code class="literal">-2**4</code> is <code class="literal">-16</code>.</p><p>Bit-oriented operators apply only to integers. They also apply to sets. These are emphatically not logical operators. The actual logical operators are described in <a class="link" href="ch05.html" title="Chapter 5. Logic, Comparisons, and Conditions">Chapter 5</a>, <span class="emphasis"><em>Logic, Comparisons, and Conditions</em></span>.</p><div class="section" title="Making comparisons"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec18"/>Making comparisons</h2></div></div></div><p>The comparison operators (<code class="literal">&lt;</code>, <code class="literal">&gt;</code>, <code class="literal">==</code>, <code class="literal">!=</code>, <code class="literal">&lt;=</code>, <code class="literal">&gt;=</code>) have meanings similar to those used in other<a class="indexterm" id="id98"/> programming languages. The coercion rules<a class="indexterm" id="id99"/> apply to comparisons between numbers. If the objects are of mixed types, one of them will be coerced "up" the numeric tower from integer to float, or float to complex. The result of a comparison is a Boolean (<code class="literal">True</code> or <code class="literal">False</code>) irrespective of the types of the two operands.</p><p>The various coercion rules do not apply to strings or other objects. Strings are not implicitly converted to numbers. <code class="literal">2 != '2'</code> is true because the integer <code class="literal">2</code> is not a string <code class="literal">'2'</code>.</p><p>Some popular languages (for example, Java, C++) have primitive types such as <code class="literal">int</code> or <code class="literal">long</code> which are not proper objects—they're not instances of a class—and the rules that apply to objects do not apply to them. Java allows the <code class="literal">==</code> comparison for <code class="literal">int</code> objects, but using the same comparison operator with string objects doesn't compare the characters of the two strings, it only compares the references. This is emphatically not the case with Python. All Python objects are proper instances of a class: the <code class="literal">==</code> comparison in Python strings compares the two strings character by character.</p><p>We'll look at<a class="indexterm" id="id100"/> comparisons in more detail in <a class="indexterm" id="id101"/>
<a class="link" href="ch05.html" title="Chapter 5. Logic, Comparisons, and Conditions">Chapter 5</a>, <span class="emphasis"><em>Logic, Comparisons, and Conditions</em></span>.</p></div><div class="section" title="Using integers"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec19"/>Using integers</h2></div></div></div><p>Python<a class="indexterm" id="id102"/> integers are objects of the class <code class="literal">int</code>. These<a class="indexterm" id="id103"/> objects have the largest number of operators, including all of the arithmetic, bit-oriented, and comparison operators.</p><p>Integer values are limited by available memory. This means they can be quite large. We can easily compute 1,000!, a number with over 2,500 digits. We'll save the details for <a class="link" href="ch08.html" title="Chapter 8. More Advanced Functions">Chapter 8</a>, <span class="emphasis"><em>More Advanced Functions</em></span>. A number of similarly gargantuan size is:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; 2**8530
610749...581824</pre></div><p>This is a very large number. We've elided most of it. It's easily represented in Python.</p><p>Generally, we provide integer literals in decimal, base 10. We can also write literals in three other bases: hexadecimal, octal, and binary.</p><p>The prefix of <code class="literal">0x</code> is the prefix for base 16 values: <code class="literal">0x10</code> is <code class="literal">16</code>. We can use the letters <code class="literal">a-f,</code> as is typical in many other programming languages; <code class="literal">0xdeadbeef</code> is valid. The prefix <code class="literal">0o</code> (zero and the letter o) is used for base eight; try to avoid using the maliciously confusing <code class="literal">0O</code> (zero and capital O) for octal values, for example, <code class="literal">0o33653337357</code>. We can write base two literal values using the <code class="literal">0b</code> prefix: <code class="literal">0b10</code> is <code class="literal">2</code>. The most common use case for non-decimal numbers is providing hexadecimal values for an array of bytes, and this is relatively rare.</p><div class="section" title="Using the bit-oriented operators"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec06"/>Using the bit-oriented operators</h3></div></div></div><p>Bit-oriented<a class="indexterm" id="id104"/> operators are defined for integers. They're <a class="indexterm" id="id105"/>not defined for complex or floating-point objects.</p><p>The <code class="literal">&lt;&lt;</code> and <code class="literal">&gt;&gt;</code> operators perform bit shifting. <code class="literal">1 &lt;&lt; 8</code>, for example, is 256. We've shifted the value 1 to the left 8 bit positions.</p><p>The <code class="literal">&amp;</code>, <code class="literal">|</code>, and <code class="literal">^</code> operators compute the bitwise "and", bitwise "or", and bitwise "xor" of two integer values. Here are some examples:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; 9 &amp; 5
1
&gt;&gt;&gt; 9 | 5
13
&gt;&gt;&gt; 9 ^ 3
10</pre></div><p>To visualize these operators, we can use the <code class="literal">bin()</code> function to see the binary values involved.</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; bin(9)
'0b1001'
&gt;&gt;&gt; bin(5)
'0b101'</pre></div><p>Using the <code class="literal">bin()</code> function can clarify how the bits of <code class="literal">9|5</code> combine to create the bits of <code class="literal">13</code>. The <code class="literal">~</code> operator is<a class="indexterm" id="id106"/> the bitwise two's complement<a class="indexterm" id="id107"/> of an integer value. <code class="literal">~14</code>, for example, is <code class="literal">-15</code>. These are emphatically not logical operators. Logical operators are described in <a class="link" href="ch05.html" title="Chapter 5. Logic, Comparisons, and Conditions">Chapter 5</a>, <span class="emphasis"><em>Logic, Comparisons, and Conditions</em></span>.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="tip05"/>Tip</h3><p>Do not confuse <code class="literal">a &amp; b</code> with <code class="literal">a and b</code>:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">a &amp; b</code> computes a bitwise "and" of the bits in the integers <span class="emphasis"><em>a</em></span> and <span class="emphasis"><em>b</em></span>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">a and b</code> computes the Boolean "and" based on the truth values of <span class="emphasis"><em>a</em></span> and <span class="emphasis"><em>b</em></span>.</li></ul></div></div></div></div></div><div class="section" title="Using rational numbers"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec20"/>Using rational numbers</h2></div></div></div><p>Rational<a class="indexterm" id="id108"/> numbers are fractions composed<a class="indexterm" id="id109"/> of two integer values. Python doesn't have a built-in rational number type. We must import the <code class="literal">Fraction</code> class using this:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; from fractions import Fraction</pre></div><p>This will introduce the <code class="literal">Fraction</code> class definition to our global environment. Once we have this, we can create objects of the class <code class="literal">Fraction</code> as follows:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; Fraction(355,113)
Fraction(355, 113)</pre></div><p>Arithmetic and comparison operators apply to fractions. When doing mixed-type expressions, fractions fit into the numeric tower above integers and below floating-point values. Here's an example of an integer coerced to a fraction:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; Fraction(4,2)*3
Fraction(6, 1)</pre></div><p>Performing an operation that involves a <code class="literal">Fraction</code> value and an <code class="literal">int</code> value requires that the <code class="literal">int</code> object is coerced up to the <code class="literal">Fraction</code> class.</p><p>We can extract the numerator and denominator of a fraction using their attribute names. Here's an example:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; a= Fraction(355,113)*5
&gt;&gt;&gt; a.numerator
1775
&gt;&gt;&gt; a.denominator
113</pre></div><p>We've created a <code class="literal">Fraction</code> object, <code class="literal">a</code>, from an expression involving a <code class="literal">Fraction</code> object and an integer. We've <a class="indexterm" id="id110"/>then extracted the<a class="indexterm" id="id111"/> <code class="literal">numerator</code> and <code class="literal">denominator</code> attributes of the variable <code class="literal">a</code>.</p></div><div class="section" title="Using decimal numbers"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec21"/>Using decimal numbers</h2></div></div></div><p>For<a class="indexterm" id="id112"/> currency calculations, we generally<a class="indexterm" id="id113"/> use <code class="literal">Decimal</code> numbers. Python doesn't have a built-in decimal number type. We import the <code class="literal">Decimal</code> class using this:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; from decimal import Decimal</pre></div><p>This will introduce the <code class="literal">Decimal</code> class definition to our global environment. We can now create <code class="literal">Decimal</code> objects. It's important to avoid accidentally mixing <code class="literal">Decimal</code> and <code class="literal">float</code> values, because <code class="literal">float</code> values are only an approximation. To be sure that <code class="literal">Decimal</code> values are exact, we must use only integers or strings.</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; Decimal("2.72")
Decimal('2.72')</pre></div><p>We've created a <code class="literal">Decimal</code> value from a string. The resulting <code class="literal">Decimal</code> object will represent this exactly, carefully preserving the appropriate decimal places and rounding up or down as required. For common financial calculations, <code class="literal">Decimal</code> is required. Here's an example:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; (Decimal('512.97')+Decimal('5.97'))*Decimal('0.075')
Decimal('38.92050')</pre></div><p>We've added two prices, $512.97 and $5.97 and computed a sales tax of 7.5%. The tax is $38.92050, to be precise. This is generally rounded to $38.92.</p><p>If we try this kind of financial calculation with floating-point values, we have a bit of a problem:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; (512.97+5.97)*0.075
38.920500000000004</pre></div><p>The floating-point approximations don't produce an exact answer.</p><p>Python coercion rules work well with <code class="literal">Decimal</code> and <code class="literal">int</code> values. We can calculate <code class="literal">Decimal('3.99')*3</code> and get <code class="literal">Decimal('11.97')</code> as the answer.</p><p>The coercion rules aren't implemented by the <code class="literal">Decimal</code> and <code class="literal">float</code> classes. It might make some sense for <code class="literal">Decimal</code> values to be coerced up to <code class="literal">float</code> values. On the other hand, this might indicate a profound programming error when mixing exact currency values and floating-point approximations. Since this is ambiguous, and debatable, the general approach followed by Python is summarized by this line from Tim Peters' <span class="emphasis"><em>The Zen of Python</em></span>:</p><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>In the face of ambiguity, refuse the temptation to guess.</em></span></p></blockquote></div><p>Consequently, mixing <code class="literal">Decimal</code> and <code class="literal">float</code> leads to <code class="literal">TypeError</code> exceptions instead of following coercion up the numeric tower and switching from exact to approximate values. We<a class="indexterm" id="id114"/> must explicitly convert <code class="literal">Decimal</code> to <code class="literal">float</code> to <a class="indexterm" id="id115"/>do mixed-type expressions.</p></div><div class="section" title="Using floating-point numbers"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec22"/>Using floating-point numbers</h2></div></div></div><p>Floating-point<a class="indexterm" id="id116"/> values are instances<a class="indexterm" id="id117"/> of the class <code class="literal">float</code>. These objects work with arithmetic and comparison operators. They don't participate in the bit-oriented operators.</p><p>The details of Python floating-point implementations can vary. CPython depends on the standard C libraries, which should provide reasonably consistent results on a wide variety of hardware and OS platforms. C libraries generally use IEEE 754 floating-point values; Python's <code class="literal">float</code> type is the C language <code class="literal">double</code>. This means that a float will be a 64-bit value with (effectively) a 53-bit fraction and an 11-bit exponent. The exponent range is from <span class="inlinemediaobject"><img alt="Using floating-point numbers" src="graphics/B03671_02_01.jpg"/></span>to <span class="inlinemediaobject"><img alt="Using floating-point numbers" src="graphics/B03671_02_02.jpg"/></span>.</p><p>We can write floating-point numbers two ways: as digits with a decimal point, as well as in "scientific" notation:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; 6335.437
6335.437
&gt;&gt;&gt; 6.335437E3
6335.437</pre></div><p>The <code class="literal">E</code> notation shows a power of 10. That means 6.335437E3 is <span class="inlinemediaobject"><img alt="Using floating-point numbers" src="graphics/B03671_02_03.jpg"/></span>.</p><p>It's very important to note that floating-point values are an approximation. We can't emphasize enough that they're not exact and should not be used for currency calculations. Here's an example of what happens when working with floating-point approximations:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; (5**6)**(1/6)
4.999999999999999</pre></div><p>This should not be surprising in any way. Mathematically, <span class="inlinemediaobject"><img alt="Using floating-point numbers" src="graphics/B03671_02_04.jpg"/></span>. Since values like 1/6 don't have exact binary representations, this kind of expression reveals the consequences of working with approximations.</p><p>The fact that floating-point numbers use a binary representation leads to interesting complications. A number such as 1/6 has no exact decimal representation; we can use .1666... to indicate that the decimal positions repeat infinitely. However, a number such as 1/5 has an exact decimal representation, 0.2. Neither of these numbers has an exact binary representation. Since we must use a finite number of bits, we'll notice slight discrepancies between idealized values and the finite values produced on a digital computer.</p><p>Note that exact equality comparisons between floating-point numbers, while permitted, is generally not a good idea. In <a class="link" href="ch05.html" title="Chapter 5. Logic, Comparisons, and Conditions">Chapter 5</a>, <span class="emphasis"><em>Logic, Comparisons, and Conditions</em></span>, we'll address<a class="indexterm" id="id118"/> how to use a narrow range<a class="indexterm" id="id119"/> instead of exact equality. Instead of <code class="literal">a == b</code>, we need to focus on <code class="literal">abs(a-b) &lt; ε</code>.</p></div><div class="section" title="Using complex numbers"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec23"/>Using complex numbers</h2></div></div></div><p>The <a class="indexterm" id="id120"/>top of Python's number tower is of <a class="indexterm" id="id121"/>the <code class="literal">complex</code> type. It can be thought of as expressions built from a pair of floating-point numbers: one is a real value, the other is an imaginary value. The imaginary value is multiplied by <span class="inlinemediaobject"><img alt="Using complex numbers" src="graphics/B03671_02_05.jpg"/></span>. We write <code class="literal">(2+3j)</code> to mean <span class="inlinemediaobject"><img alt="Using complex numbers" src="graphics/B03671_02_06.jpg"/></span>.</p><p>When working with complex numbers, we often import the <code class="literal">cmath</code> library instead of the <code class="literal">math</code> library. The <code class="literal">math.sqrt()</code> function is constrained to work only with <code class="literal">float</code> values, and will raise an exception rather than provide an imaginary value. The <code class="literal">cmath.sqrt()</code> function will provide a proper imaginary value, if required.</p><p>This library shows us that <span class="inlinemediaobject"><img alt="Using complex numbers" src="graphics/B03671_02_07.jpg"/></span> is essentially true:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; cmath.e**(cmath.pi*1j)+1
1.2246467991473532e-16j</pre></div><p>Note that we used <code class="literal">1j</code> to represent <span class="inlinemediaobject"><img alt="Using complex numbers" src="graphics/B03671_02_05.jpg"/></span>. If we try to use the identifier <code class="literal">j</code> (without a number in front of it) it is seen as a simple variable. The value <code class="literal">1j</code> is a complex literal because it starts with a digit and ends with <code class="literal">j</code>.</p><p>Since floating-point values have about 53 bits, which is about 16 decimal digits, we can expect <code class="literal">float</code> approximations of irrational values like <code class="literal">π</code> and <code class="literal">e</code> to be off by about <span class="inlinemediaobject"><img alt="Using complex numbers" src="graphics/B03671_02_08.jpg"/></span>.</p></div></div></div>
<div class="section" title="The numeric tower"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec16"/>The numeric tower</h1></div></div></div><p>We've <a class="indexterm" id="id122"/>seen Python's three built-in numeric types: <code class="literal">int</code>, <code class="literal">float</code>, <code class="literal">complex</code>, plus two more types—<code class="literal">Fraction</code> and <code class="literal">Decimal</code>—imported from the standard library. The numbers module in the standard library provides four base class definitions for the numeric types. We rarely need to use this module explicitly; it's a convention that we need when we have to implement our own numeric types.</p><p>The numeric types form a kind of "tower" that parallels the various kinds of numbers seen in conventional mathematics. The foundation of the tower is integers. Rational numbers are above integers. Floating-point values are still further up, and complex numbers are at the top of the tower.</p><p>A common expectation is that a language will automatically coerce numeric values to permit expressions such as <code class="literal">2*2.718</code> to work properly and produce a useful result. When multiplying an integer by a float value, we expect integers to be coerced to a floating-point value.</p><p>In order for this to work, there are two general rules applied to the result of a binary arithmetic operation:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">If both operands are of the same type, the result has that type. For example, <code class="literal">2 ** 1024</code> does not produce a floating-point result. It produces an immense integer.</li><li class="listitem" style="list-style-type: disc">If the operands are mixed, one of them will be coerced "up" the numeric tower from integer → rational → floating-point → complex.</li></ul></div><p>There is one notable exception to the preceding rules. The <code class="literal">/</code> and <code class="literal">//</code> operators define two different kinds of division. The <code class="literal">/</code> operator provides true division: even integer operands will yield a floating-point result. For example:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; 355/113
3.1415929203539825</pre></div><p>The <code class="literal">//</code> operator provides floor division: the result will be truncated as if it were an integer-only division. The resulting type won't be coerced, but the answer will be truncated. For example:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; 355./113.
3.1415929203539825
&gt;&gt;&gt; 355.//113.
3.0</pre></div><p>The presence of the <code class="literal">//</code> operator means that an expression which is designed with integers in mind will also work correctly with floating-point values. Similarly, we may write an expression with an informal expectation of floating-point values; by using <code class="literal">/</code>, it will also work with integers.</p><p>Note that these coercion rules for numeric types do not apply to strings or other objects. Strings are not implicitly converted to numbers. The expression <code class="literal">'2'+2</code> results in a <code class="literal">TypeError</code> exception. We'll look at explicit conversions later, in the <span class="emphasis"><em>Using the built-in conversion functions</em></span> section.</p><p>The tower<a class="indexterm" id="id123"/> metaphor provides a handy way to remember the coercion rules. Given two values from different levels, the lower-level value is coerced up the tower to the higher-level values.</p></div>
<div class="section" title="The math libraries"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec17"/>The math libraries</h1></div></div></div><p>The Python<a class="indexterm" id="id124"/> library has six modules relevant to mathematical work. These are described in <span class="emphasis"><em>Chapter 9</em></span>, <span class="emphasis"><em>Numeric and Mathematical Modules</em></span>, of the <span class="emphasis"><em>Python Standard Library</em></span> document. Beyond this, we have external libraries such<a class="indexterm" id="id125"/> as NumPy (<a class="ulink" href="http://www.numpy.org">http://www.numpy.org</a>) and SciPy (<a class="ulink" href="http://www.scipy.org">http://www.scipy.org</a>). These<a class="indexterm" id="id126"/> libraries include vast collections of sophisticated<a class="indexterm" id="id127"/> algorithms. For an even more sophisticated toolset, the Anaconda project (<a class="ulink" href="https://store.continuum.io/cshop/anaconda/">https://store.continuum.io/cshop/anaconda/</a>) combines NumPy, SciPy, and 18 more packages.</p><p>These are the relevant built-in numeric packages:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">numbers</code>: This<a class="indexterm" id="id128"/> module defines the essential numeric abstractions. We rarely need this unless we're going to invent an entirely new kind of number.</li><li class="listitem" style="list-style-type: disc"><code class="literal">math</code>: This <a class="indexterm" id="id129"/>module has a large collection of functions. It includes basic <code class="literal">sqrt()</code>, the various trigonometric functions (sine, cosine, and so on) and the various log-related functions. It has functions for working with the internals of floating-point numbers. It also has the gamma function and the error function.</li><li class="listitem" style="list-style-type: disc"><code class="literal">cmath</code>: This <a class="indexterm" id="id130"/>module is the complex version of the <code class="literal">math</code> library. We use the <code class="literal">cmath</code> library so that we can seamlessly move between <code class="literal">float</code> and <code class="literal">complex</code> values.</li><li class="listitem" style="list-style-type: disc"><code class="literal">decimal</code>: Import<a class="indexterm" id="id131"/> the <code class="literal">Decimal</code> class from this module to work with currency values accurately.</li><li class="listitem" style="list-style-type: disc"><code class="literal">fractions</code>: Import <a class="indexterm" id="id132"/>the <code class="literal">Fraction</code> class to work with a precise rational fraction value.</li><li class="listitem" style="list-style-type: disc"><code class="literal">random</code>: This <a class="indexterm" id="id133"/>module contains the essential random number generator. It has a number of other functions to produce random values in various ranges or with various constraints. For example <code class="literal">random.gauss()</code> produces a Gaussian, normal distribution of floating-point values.</li></ul></div><p>The three main ways of importing from these libraries are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">import random</code>: We <a class="indexterm" id="id134"/>use this when we want to be perfectly explicit about the origin of a name elsewhere in our code. We'll be writing code similar to <code class="literal">random.gauss()</code> and <code class="literal">random.randint()</code> using the module name as an explicit qualifier.</li><li class="listitem" style="list-style-type: disc"><code class="literal">from random import gauss, randint</code>: This<a class="indexterm" id="id135"/> introduces two selected names from the <code class="literal">random</code> module into the global namespace. We can use <code class="literal">gauss()</code> and <code class="literal">randint()</code> without a qualifying module name.</li><li class="listitem" style="list-style-type: disc"><code class="literal">from random import *</code>: This will<a class="indexterm" id="id136"/> introduce all of the available names in the <code class="literal">random</code> module as globals in our application. This is helpful for exploring and experimenting at the <code class="literal">&gt;&gt;&gt;</code> prompt. This may not be appropriate in a larger program because it can introduce a large number of irrelevant names.</li></ul></div><p>A less-commonly <a class="indexterm" id="id137"/>used feature allows us to rename objects brought in via the <code class="literal">import</code> statement. We might want to use <code class="literal">from cmath import sqrt as csqrt</code> to rename the <code class="literal">cmath.sqrt()</code> function to <code class="literal">csqrt()</code>. We have to be careful to avoid ambiguity and confusion when using this <code class="literal">import-as</code> renaming feature.</p></div>
<div class="section" title="Using bits and Boolean values"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec18"/>Using bits and Boolean values</h1></div></div></div><p>As <a class="indexterm" id="id138"/>noted earlier, the bit-oriented operators <code class="literal">&amp;</code>, <code class="literal">|</code>, <code class="literal">^</code>, and <code class="literal">~</code> have nothing to do with <a class="indexterm" id="id139"/>Python's actual Boolean operators <code class="literal">and</code>, <code class="literal">or</code>, <code class="literal">not</code>, and <code class="literal">if-else</code>. We'll look at Boolean values, logic operators, and related programming in <a class="link" href="ch05.html" title="Chapter 5. Logic, Comparisons, and Conditions">Chapter 5</a>, <span class="emphasis"><em>Logic, Comparisons, and Conditions</em></span>.</p><p>If we misuse the bit-oriented operators <code class="literal">&amp;</code> or <code class="literal">|</code> in place of a logical <code class="literal">and</code> or <code class="literal">or</code>, things may appear very peculiar:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; 5 &gt; 6 &amp; 3 &gt; 1
True
&gt;&gt;&gt; (5 &gt; 6) &amp; (3 &gt; 1)
False</pre></div><p>The first example is clearly wrong. Why? This is because the <code class="literal">&amp;</code> operator has relatively high priority. It's not a logical connective, it's more like an arithmetic operator. The <code class="literal">&amp;</code> operator is performed first: <code class="literal">6&amp;3</code> evaluates to 2. Given this, the resulting expression, <code class="literal">5 &gt; 2 &gt; 1</code>, is <code class="literal">True</code>.</p><p>When we group the comparisons to perform them first, we'll get a <code class="literal">False</code> for <code class="literal">5&gt;6</code>, and a <code class="literal">True</code> for <code class="literal">3&gt;1</code>. When we apply the <code class="literal">&amp;</code> operator the result will be <code class="literal">False</code>, which is what we expected. Using bit operators inappropriately as logical connectives can work if we use parentheses to<a class="indexterm" id="id140"/> be sure that the bit operators are performed last. It's a <a class="indexterm" id="id141"/>very bad idea, however.</p><p>It's easier, clearer, and altogether better to use the proper Boolean operators shown in <a class="link" href="ch05.html" title="Chapter 5. Logic, Comparisons, and Conditions">Chapter 5</a>, <span class="emphasis"><em>Logic, Comparisons, and Conditions</em></span>.</p></div>
<div class="section" title="Working with sequences"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec19"/>Working with sequences</h1></div></div></div><p>In this<a class="indexterm" id="id142"/> chapter, we'll introduce Python sequence collections. We'll look at strings and tuples as the first two examples of this class. Python offers a number of other sequence collections; we'll look at them in <a class="link" href="ch06.html" title="Chapter 6. More Complex Data Types">Chapter 6</a>, <span class="emphasis"><em>More Complex Data Types</em></span>. All of these sequences have common features.</p><p>Python sequences identify the individual elements by position. Position numbers start with zero. Here's a <code class="literal">tuple</code> collection with five elements:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; t=("hello", 3.14, 23, None, True)
&gt;&gt;&gt; t[0]
'hello'
&gt;&gt;&gt; t[4]
True</pre></div><p>In addition to the expected ascending numbers, Python also offers reverse numbering. Position <code class="literal">-1</code> is the end of the sequence:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; t[-1]
True
&gt;&gt;&gt; t[-2]
&gt;&gt;&gt; t[-5]
'hello'</pre></div><p>Note that position 3 (or -2) has a value of <code class="literal">None</code>. The REPL doesn't display the <code class="literal">None</code> object, so the value of <code class="literal">t[-2]</code> appears to be missing. For more visible evidence that this value is <code class="literal">None</code>, use this:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; t[3] is None
True</pre></div><p>The sequences use an extra comparison operator, <code class="literal">in</code>. We can ask if a given value occurs in a collection:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; "hello" in t
True
&gt;&gt;&gt; 2.718 in t
False</pre></div><div class="section" title="Slicing and dicing a sequence"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec24"/>Slicing and dicing a sequence</h2></div></div></div><p>We can<a class="indexterm" id="id143"/> extract <a class="indexterm" id="id144"/>a subsequence, called a <span class="strong"><strong>slice</strong></span>, from <a class="indexterm" id="id145"/>a sequence using more complex subscript expressions. Here's a substring of a longer string:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; "multifaceted"[5:10]
'facet'</pre></div><p>The <code class="literal">[5:10]</code> expression is a slice which starts at position 5 and extends to the position before 10. Python generally relies on "half-open" intervals. The starting position of a slice is included whereas the stop position is excluded.</p><p>We can omit the starting position from a slice, writing <code class="literal">[:pos]</code>. If the start value of a slice is omitted, it's 0. We can omit the ending, also, writing it as <code class="literal">[pos:]</code>. If the stop value of a slice is omitted, it's the length of the sequence, given by the <code class="literal">len()</code> function.</p><p>The way that Python uses these half-open intervals means that we can partition a string with very tidy syntax:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; "multifaceted"[:5]
'multi'
&gt;&gt;&gt; "multifaceted"[5:]
'faceted'</pre></div><p>In this example, we've taken the first five characters in the first slice. We've taken everything after the first five characters in the second slice. Since the numbers are both five, we can be completely sure that the entire string is accounted for.</p><p>And yes, we can omit both values from the slice: <code class="literal">"word"[:]</code> will create a copy of the entire string. This is an odd but sometimes useful construct for duplicating an object.</p><p>There's a third parameter to a slice. We generally call the positions <span class="strong"><strong>start</strong></span>, <span class="strong"><strong>stop</strong></span>, and <span class="strong"><strong>step</strong></span>. The step size is 1 by default. We can use a form such as <code class="literal">"abcdefg"[::2] </code>to provide an explicit step, and pick characters in positions 0, 2, 4, and 6. The form <code class="literal">"abcdefg"[1::2]</code> will pick the odd positions: 1, 3, and 5.</p><p>The step size can also be negative. This will enumerate the index values in reverse order. The value of <code class="literal">"word"[::-1] is 'drow'</code>.</p></div></div>
<div class="section" title="Using string and bytes values"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec20"/>Using string and bytes values</h1></div></div></div><p>Python<a class="indexterm" id="id146"/> string values are similar—in some respects—to simple numeric types. There<a class="indexterm" id="id147"/> are a few arithmetic-like operators available and all of the comparisons are defined. Strings are immutable: we cannot change a string. We can, however, easily build new strings from existing strings, making the mutability question as irrelevant for string objects as it is for number objects. Python has two kinds of string values:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Unicode</strong></span>: These <a class="indexterm" id="id148"/>strings use the entire Unicode character set. These are the default strings Python uses. The input-output libraries are all capable of a wide variety of Unicode encoding and decoding. The name for this type is <code class="literal">str</code>. It's a built-in type, so it starts with a lowercase letter.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Bytes</strong></span>: Many<a class="indexterm" id="id149"/> file formats and network protocols are defined over bytes, not Unicode characters. Python uses ASCII encoding for bytes. Special arrangements must be made to process bytes. The internal type name is <code class="literal">bytes</code>.</li></ul></div><p>We can<a class="indexterm" id="id150"/> easily encode Unicode into a sequence of bytes. We can just <a class="indexterm" id="id151"/>as easily decode a sequence of bytes to see the Unicode characters. We'll show these two methods in the <span class="emphasis"><em>Converting between Unicode and bytes</em></span> section, after we've looked at literals and operators.</p><div class="section" title="Writing string literals"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec25"/>Writing string literals</h2></div></div></div><p>String literals<a class="indexterm" id="id152"/> are characters surrounded by string delimiters. Python offers a variety of string delimiters to solve a variety of problems. The most common literals create Unicode strings:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Short string</strong></span>: Use either <code class="literal">"</code> or <code class="literal">'</code> to surround the string. For example: <code class="literal">"Don't Touch"</code> has<a class="indexterm" id="id153"/> an embedded apostrophe. <code class="literal">'Speak "friend" and enter'</code> has embedded quotes. In the rare cases where we have both, we can use <code class="literal">\</code> to avoid a quote: <code class="literal">'"Don\'t touch," he said.'</code> uses apostrophes as delimiters, and an escaped apostrophe within the string. While a string literal must be complete on a single line, a <code class="literal">'\n'</code> will expand into a proper newline character internally.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Long string</strong></span>: Use<a class="indexterm" id="id154"/> either <code class="literal">"""</code> or <code class="literal">'''</code> to surround a multi-line string. The string can span as many lines as necessary. A long string can include any characters except for the terminating triple-quote or triple-apostrophe.</li></ul></div><p>Python has a moderate number of <code class="literal">\</code> escape sequences to allow us to enter characters that aren't possible from a keyboard. If we use ordinary <code class="literal">str</code> literals, Python replaces all the escape sequences with proper Unicode characters. In an ordinary <code class="literal">bytes</code> literal, each escape sequence becomes a one-byte ASCII character.</p><p>Many Python programs are saved as pure ASCII text, but this is not a requirement. When saving a file in ASCII, escapes will be required for non-ASCII Unicode characters. When saving files in Unicode, then relatively few escapes are required, since any Unicode character available on our keyboard can be entered directly. Here are two examples of the same string:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; "String with π×r²"
&gt;&gt;&gt; "String with \u03c0\u00d7r\N{superscript two}"</pre></div><p>The first string uses Unicode characters; the file must be saved in the appropriate encoding, such as UTF-8, for this to work. The second string uses escape sequences to describe the Unicode characters. The <code class="literal">\u</code> sequence is followed by a four-digit hex value. The <code class="literal">\N{...}</code> escape allows the name of the character. A <code class="literal">\U</code> escape—not shown in the example—requires an 8-digit hex value. The second example can be saved in any encoding, including ASCII.</p><p>The most commonly-used escape sequences are <code class="literal">\"</code>, <code class="literal">\'</code>, <code class="literal">\n</code>, <code class="literal">\t</code>, and <code class="literal">\\</code> to create a quote inside a<a class="indexterm" id="id155"/> quoted string, an apostrophe inside an apostrophe delimited string, a newline, a tab, and a <code class="literal">\</code> character. There are a few others, but their meanings are so obscure that numeric codes usually make more sense. For example, <code class="literal">\v</code>, should probably be written as <code class="literal">\x0b</code> or <code class="literal">\u000b</code>; the original meaning behind <code class="literal">\v</code> is largely lost to history.</p><p>Note that <code class="literal">'\u000b'</code> is replaced by the actual Unicode character. We also have <code class="literal">'\u240b'</code> which is a Unicode glyph, '<span class="inlinemediaobject"><img alt="Writing string literals" src="graphics/B03671_02_09.jpg"/></span>', that symbolizes that vertical tab character. Most of the non-printing ASCII control characters also have these symbolic glyphs.</p></div><div class="section" title="Using raw string literals"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec26"/>Using raw string literals</h2></div></div></div><p>Sometimes, we <a class="indexterm" id="id156"/>need to provide strings in which the <code class="literal">\</code> character is not an escape character. When preparing regular expressions, for example, we prefer not be forced to write <code class="literal">\\</code> to represent a single <code class="literal">\</code> character. Similarly, when working with Windows filenames, we don't want <code class="literal">"C:\temp"</code> to have an ASCII horizontal tab character (<code class="literal">'\u0008'</code>) replace the <code class="literal">'\t'</code> sequence of characters in the middle of the string literal. We could write <code class="literal">"C:\\temp"</code> but it seems error-prone.</p><p>To avoid this <a class="indexterm" id="id157"/>escape processing, Python offers the <span class="strong"><strong>raw string</strong></span>. We can prefix any of the previous four flavors of delimiters with the letter <code class="literal">r</code> or <code class="literal">R</code>. For example, <code class="literal">r'\b[a-zA-Z_]\w+\b'</code>, is a raw string. The <code class="literal">\</code> characters will be left intact by Python: the '<code class="literal">\b</code>' sequences are not translated to '<code class="literal">\u0008</code>' characters.</p><p>If we do this <span class="emphasis"><em>without</em></span> using the <code class="literal">r"</code> character as the raw string delimiter, we'll create a string literal equivalent to this: <code class="literal">'\x08[a-zA-Z_]\\w+\x08'</code>. This shows how a '<code class="literal">\b</code>' characters are transformed to '<code class="literal">\x08</code>' in a non-raw string. Omitting the leading <code class="literal">r'</code> leads to a string that does not represent the regular expression we intended.</p></div><div class="section" title="Using byte string literals"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec27"/>Using byte string literals</h2></div></div></div><p>We may<a class="indexterm" id="id158"/> need to include byte strings in our programs as well as Unicode strings. In order to do this, we use a prefix of <code class="literal">b</code> or <code class="literal">B</code> in front of the string delimiter. A byte string is limited to ASCII characters and escape sequences that produce single-byte ASCII characters.</p><p>Generally, byte strings focus on the hexadecimal escape, <code class="literal">\xhh</code>, with two hex digits for byte strings. We can also use the octal escape, <code class="literal">\odd</code>, with octal digits.</p><p>We can also prepare raw byte strings using any combination of <code class="literal">r</code> or <code class="literal">R</code> paired with <code class="literal">b</code> or <code class="literal">B</code> as a prefix to the string. Here's a regular expression in ASCII bytes:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; rb"\\x[0-9a-fA-F]+"
b'\\\\x[0-9a-fA-F]+'</pre></div><p>The output is in Python's canonical notation using lengthy escapes for the '<code class="literal">\\</code>' regular expression <a class="indexterm" id="id159"/>pattern.</p><p>To be fastidious, we are also able to use a <code class="literal">u"</code> prefix to indicate that a given string is explicitly Unicode. This is relatively rare because it restates the default assumption. It can come in handy in a program where byte strings predominate; the use of <code class="literal">u"some string"</code> can make the Unicode literal stand out from numerous <code class="literal">b"bytes"</code> literals.</p></div><div class="section" title="Using the string operators"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec28"/>Using the string operators</h2></div></div></div><p>Two of the <a class="indexterm" id="id160"/>arithmetic operators, <code class="literal">+</code> and <code class="literal">*</code>, are defined for both classes of string objects, <code class="literal">str</code> and <code class="literal">bytes</code>. We can use the <code class="literal">+</code> operator to concatenate two string objects, creating a longer string. Interestingly, we can use the <code class="literal">*</code> operator to multiply a string and an integer to create a longer string: <code class="literal">"="*3</code> is <code class="literal">'==='</code>.</p><p>Additionally, adjacent string literals are combined into a larger string during code parsing. Here's an example:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; "adjacent " 'literals'
'adjacent literals'</pre></div><p>Since this happens at parse time, it only works for string literals. For variables or other expressions, there must be a proper <code class="literal">+</code> operator.</p><p>All of the comparison operators work for strings. The comparison operators compare two strings, character by character. We'll look at this in detail in <a class="link" href="ch05.html" title="Chapter 5. Logic, Comparisons, and Conditions">Chapter 5</a>, <span class="emphasis"><em>Logic, Comparisons, and Conditions</em></span>.</p><p>We cannot use string operators with mixed types of operands. Using <code class="literal">"hello" + b"world"</code> will raise a <code class="literal">TypeError</code> exception. We must either encode the Unicode <code class="literal">str</code> into <code class="literal">bytes</code>, or decode the <code class="literal">bytes</code> into a Unicode <code class="literal">str</code> object.</p><p>Strings are sequence collections. We can extract characters and slices from them. Strings also work with the <code class="literal">in</code> operator. We can ask if a particular character or a substring occurs in a string like this:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; "i" in "bankrupted"
False
&gt;&gt;&gt; "bank" in "bankrupted"
True</pre></div><p>The first example shows the typical use for the <code class="literal">in</code> operator: checking to see if a given item is in the collection. This use of <code class="literal">in</code> applies to many other kinds of collections. The second example shows a feature that is unique to strings: we're looking for a given substring <a class="indexterm" id="id161"/>in a longer string.</p></div><div class="section" title="Converting between Unicode and bytes"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec29"/>Converting between Unicode and bytes</h2></div></div></div><p>Most <a class="indexterm" id="id162"/>of the Python I/O libraries are aware <a class="indexterm" id="id163"/>of OS file encodings. When working with text files, we rarely need to explicitly provide encoding. We'll examine the details of Python's input-output capabilities in <a class="link" href="ch10.html" title="Chapter 10. Files, Databases, Networks, and Contexts">Chapter 10</a>, <span class="emphasis"><em>Files, Databases, Networks, and Contexts</em></span>.</p><p>When we need to encode Unicode characters as a string of bytes, we use the <code class="literal">encode()</code> method of a string. Here's an example:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; 'String with π×r²'.encode("utf-8")
b'String with \xcf\x80\xc3\x97r\xc2\xb2'</pre></div><p>We've provided a literal Unicode string, and encoded this into UTF-8 bytes. Python has numerous encoding schemes, all defined in the <code class="literal">codecs</code> module.</p><p>To decode the Unicode string represented by a string of bytes, we use the <code class="literal">decode()</code> method of the bytes. Here's an example:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; b'very \xe2\x98\xba\xef\xb8\x8e'.decode('utf-8')
'very ☺︎'</pre></div><p>We've provided a byte string with eleven individually hex-encoded bytes. We decoded this to include six Unicode characters.</p><p>Note that there are several aliases for the supported encodings. We've used <code class="literal">"utf-8"</code> and <code class="literal">"UTF-8"</code>. There are still more explained in the <code class="literal">codecs</code> chapter of the <span class="emphasis"><em>Python Standard Library</em></span>.</p><p>The <code class="literal">ASCII</code> codec is the most commonly used of these. In addition to <code class="literal">ASCII</code>, many strings and text files are encoded in <code class="literal">UTF-8</code>. When downloading data from the Internet, there's often a header or other indicator that provides the encoding, in the rare case that it's not <code class="literal">UTF-8</code>.</p><p>In some cases, we have a document which in bytes, written in traditional ASCII. To work with ASCII files, we convert the bytes from the ASCII encoding to Unicode characters. Similarly, we can encode a subset of Unicode characters using the ASCII encoding instead of UTF-8.</p><p>It's possible that a given sequences of bytes does not properly encode Unicode characters. This may be because the wrong encoding was used to decode the bytes. Or it could be because the bytes are incorrect. The <code class="literal">decode()</code> method has additional parameters to define what to do when the bytes cannot be decoded. The values for the errors argument are strings:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">"strict"</code> means that exceptions are raised. This is the default.</li><li class="listitem" style="list-style-type: disc"><code class="literal">"ignore"</code> means that invalid bytes will be skipped.</li><li class="listitem" style="list-style-type: disc"><code class="literal">"replace"</code> means that a default character will be inserted. This is defined in the <code class="literal">codecs</code> module. The <code class="literal">'\ufffd'</code> character is the default replacement.</li></ul></div><p>The<a class="indexterm" id="id164"/> choice<a class="indexterm" id="id165"/> of error handling is highly application-specific.</p></div><div class="section" title="Using string methods"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec30"/>Using string methods</h2></div></div></div><p>A string<a class="indexterm" id="id166"/> object has a large number of method functions. Most of these apply both to <code class="literal">str</code> and <code class="literal">bytes</code> objects. These can be separated into four groups:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Transformers</strong></span>: which<a class="indexterm" id="id167"/> create new strings from old strings</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Creators</strong></span>: which<a class="indexterm" id="id168"/> create a string from a non-string object(s)</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Accessors</strong></span>: which<a class="indexterm" id="id169"/> access a string and return a fact about that string</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Parsers</strong></span>: which <a class="indexterm" id="id170"/>examine a string and decompose the string, or create new data objects from the string</li></ul></div><p>The transformer group of method functions includes <code class="literal">capitalize()</code>, <code class="literal">center()</code>, <code class="literal">expandtabs()</code>, <code class="literal">ljust()</code>, <code class="literal">lower()</code>, <code class="literal">rjust()</code>, <code class="literal">swapcase()</code>, <code class="literal">title()</code>, <code class="literal">upper()</code>, and <code class="literal">zfill()</code>. These methods all make general changes to the characters of a string to create a transformed result. Methods such as <code class="literal">lower()</code> and <code class="literal">upper()</code> are used frequently to normalize case for comparisons:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; "WoRd".lower()
'word'</pre></div><p>Using this technique allows us to write programs which are more tolerant of character strings with minor errors.</p><p>Additional transformers include functions such as <code class="literal">strip()</code>, <code class="literal">rstrip()</code>, <code class="literal">lstrip()</code>, and <code class="literal">replace()</code>. The functions in the strip family remove whitespace. It's common to use <code class="literal">rstrip()</code> on input lines to remove any trailing spaces and the trailing newline character which might be present.</p><p>The <code class="literal">replace()</code> function<a class="indexterm" id="id171"/> replaces any substring with another substring. If we want to do multiple independent replacements, we can do something like this.</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; "$12,345.00".replace("$","").replace(",","")
'12345.00'</pre></div><p>This will create an intermediate string with the "<code class="literal">$</code>" removed. It will create a second intermediate string from that with the <code class="literal">,</code> character removed. This kind of processing is handy for cleaning up raw data.</p></div><div class="section" title="Accessing the details of a string"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec31"/>Accessing the details of a string</h2></div></div></div><p>We use <a class="indexterm" id="id172"/>accessor methods to determine facts about the string; the results may be Boolean or integer values. For example, the <code class="literal">count()</code> method returns a count of the number of places an argument substring or character was found in the object string.</p><p>Some widely-used methods include the <code class="literal">find()</code>, <code class="literal">rfind()</code>, <code class="literal">index()</code>, and <code class="literal">rindex() </code>methods which will find the position of a substring in the object string. The <code class="literal">find()</code> methods return a special value of <code class="literal">-1</code> if the substring isn't found. The <code class="literal">index()</code> methods raise a <code class="literal">ValueError</code> exception if the substring isn't found. The "r" versions find the right-most occurrence of the target substring. All of these methods are available for both <code class="literal">str</code> and <code class="literal">bytes</code> objects.</p><p>The <code class="literal">endswith()</code> and <code class="literal">startswith()</code> methods are Boolean functions; they examine the beginning or ending of a string. Here are some examples:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; "pleonastic".endswith("tic")
True
&gt;&gt;&gt; "rediscount".find("disc")
2
&gt;&gt;&gt; "postlaunch".find("not")
-1</pre></div><p>The first example shows how we can check the ending of a string with the <code class="literal">endswith()</code> method. The second example shows how the <code class="literal">find()</code> method locates the offset of a given substring in a longer string. The third example shows show the <code class="literal">find()</code> method returns a signal value of -1 if the substring can't be found.</p><p>Additionally, there are seven Boolean pattern-matching functions. These are <code class="literal">isalnum()</code>, <code class="literal">isalpha()</code>, <code class="literal">isdigit()</code>, <code class="literal">islower()</code>, <code class="literal">isspace()</code>, <code class="literal">istitle()</code>, and <code class="literal">isupper()</code>. These will return <code class="literal">True</code> if the function matches a given pattern. For example, <code class="literal">"13210".isdigit()</code> is <code class="literal">True</code>.</p></div><div class="section" title="Parsing strings into substrings"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec32"/>Parsing strings into substrings</h2></div></div></div><p>There<a class="indexterm" id="id173"/> are a few method functions which we can use to decompose a string into substrings. We'll hold off on looking at <code class="literal">split()</code>, <code class="literal">join()</code>, and <code class="literal">partition()</code> in detail until <a class="link" href="ch03.html" title="Chapter 3. Expressions and Output">Chapter 3</a>, <span class="emphasis"><em>Expressions and Output</em></span>.</p><p>As a quick overview, we'll note that <code class="literal">split()</code> splits a string into a sequence of strings based on locating a possibly repeating separator substring. We might use an expression such as <code class="literal">'01.03.05.15'.split('.')</code> to create the sequence <code class="literal">['01', '03', '05', '15']</code> from the longer string, by splitting on the '<code class="literal">.</code>' character. The <code class="literal">join()</code> method is the inverse of <code class="literal">split()</code>. That means that <code class="literal">"-".join(['01', '03', '05', '15'])</code> will create a new string from the individual strings and the separator; the result is <code class="literal">'01-03-05-15'</code>. The partition can be viewed as a single-item split to separate the head of a string from the tail.</p><p>Python's assignment statement deals very gracefully with such a method that returns more than one value. In <a class="link" href="ch04.html" title="Chapter 4. Variables, Assignment and Scoping Rules">Chapter 4</a>, <span class="emphasis"><em>Variables, Assignment and Scoping Rules</em></span>, we'll look at multiple assignment more closely.</p><p>The <code class="literal">split()</code> method should not be used to parse filenames, nor should the <code class="literal">join()</code> method be used to build filenames. There's a separate module, <code class="literal">os.path</code>, which handles this properly by applying OS-specific rules.</p></div></div>
<div class="section" title="Using the tuple collection"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec21"/>Using the tuple collection</h1></div></div></div><p>The <code class="literal">tuple</code> is<a class="indexterm" id="id174"/> one of the simplest collections available in Python. It is one of the many kinds of Python sequences. A tuple has a fixed number of items. For example, we might work with (<span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>y</em></span>) coordinates or (<span class="emphasis"><em>r</em></span>, <span class="emphasis"><em>g</em></span>, <span class="emphasis"><em>b</em></span>) colors. In these cases, the number of elements in each tuple is fixed by the problem domain. We don't want the flexibility of a collection that can vary in length.</p><p>Generally, we'll include <code class="literal">()</code> around a <code class="literal">tuple</code> to set it apart from the surrounding syntax. This isn't <span class="emphasis"><em>always</em></span> required; Python creates <code class="literal">tuple</code> objects implicitly in some common contexts. However, it is always a good idea. If we write an assignment statement like this:</p><div class="informalexample"><pre class="programlisting">a = 2, 3</pre></div><p>This statement will implicitly create a 2-tuple, <code class="literal">(2, 3)</code>, and assign the object to the variable <code class="literal">a</code>.</p><p>The <code class="literal">tuple</code> class is part of Python's family of <code class="literal">Sequence</code> classes; we can extract the items of a <code class="literal">tuple</code> using their positional indices. The <code class="literal">str</code> and <code class="literal">byte</code> classes are also examples of Sequence. In addition to simple index values, we can use slice notation to pick items from a <code class="literal">tuple</code>.</p><p>The value <code class="literal">()</code> is a zero-length tuple. To create a singleton tuple, we must use <code class="literal">()</code> and include a <code class="literal">,</code> character: this means that <code class="literal">(12,)</code> is a singleton tuple. If we omit the <code class="literal">,</code> character we've written an expression, not a singleton tuple.</p><p>A trailing comma is <span class="emphasis"><em>required</em></span> for a singleton tuple. An extra comma at the end of a tuple is quietly ignored everywhere else: <code class="literal">(1, 1, 2)</code> is equal to <code class="literal">(1, 1, 2,)</code>.</p><p>The <code class="literal">tuple</code> class<a class="indexterm" id="id175"/> offers only two method functions: <code class="literal">count()</code> and <code class="literal">index()</code>. We can count the number of occurrences of a given item in a <code class="literal">tuple</code>, and we can locate the position of an item in a <code class="literal">tuple</code>.</p></div>
<div class="section" title="The None object"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec22"/>The None object</h1></div></div></div><p>One very simple kind of Python object is the <code class="literal">None</code> object. It has few methods, and there's only a <a class="indexterm" id="id176"/>single instance of this object available. It is a handy way to identify something as missing or not applicable. It's often used as a default value for optional parameters to a function.</p><p>The <code class="literal">None</code> object is a singleton; there can be only one. This object is immutable: we can't change it in any way.</p><p>With the interactive use of Python, the REPL doesn't print the <code class="literal">None</code> object. For example, when we evaluate the <code class="literal">print()</code> function, the proper result of this function is always <code class="literal">None</code>. The side-effect of this function is to print things on our console. Looking forward to <a class="link" href="ch03.html" title="Chapter 3. Expressions and Output">Chapter 3</a>, <span class="emphasis"><em>Expressions and Output</em></span>, we'll give this quick example of a function that returns <code class="literal">None</code>:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; a = print("hello world")
hello world
&gt;&gt;&gt; a
&gt;&gt;&gt; a is None
True</pre></div><p>We've evaluated the <code class="literal">print()</code> function and saved the result of the print function in the <code class="literal">a</code> variable. The visible side-effect of printing is to see the string value displayed on the console. The result is the <code class="literal">None</code> object, which is not printed. We can, however, use the <code class="literal">is</code> comparison operator to see that the value of <code class="literal">a</code> really is the <code class="literal">None</code> object.</p></div>
<div class="section" title="The consequences of immutability"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec23"/>The consequences of immutability</h1></div></div></div><p>Python <a class="indexterm" id="id177"/>has two broad flavors of objects: mutable <a class="indexterm" id="id178"/>and immutable. A mutable object has an internal state that can be updated by using operators or method functions. An immutable object's state cannot be changed.</p><p>The canonical examples of immutable objects are the numbers. The number <code class="literal">2</code> must always have a single, immutable value midway between 1 and 3. We can't change the state of <code class="literal">2</code> to make it <code class="literal">3</code> without making a mockery of the idea of mathematical truth.</p><p>In <a class="link" href="ch06.html" title="Chapter 6. More Complex Data Types">Chapter 6</a>, <span class="emphasis"><em>More Complex Data Types</em></span>, we'll look at a number of mutable data structures. The <a class="indexterm" id="id179"/>most important three mutable collections are <code class="literal">set</code>, <code class="literal">list</code>, and <code class="literal">dict</code>. These objects can have items added, and removed; we can change the state of the object.</p><p>In addition to numbers being immutable, three other common structures are also immutable: <code class="literal">str</code>, <code class="literal">bytes</code>, and <code class="literal">tuple</code>. Because strings and bytes are immutable, the string manipulation methods will always create a new string object from one or more existing string objects.</p><p>This means we cannot mutate characters or substrings within a longer string. We might think we need to attempt something like this:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; word="vokalizers"
&gt;&gt;&gt; word[2]= "c"</pre></div><p>But this can't <a class="indexterm" id="id180"/>work because a string object is immutable. We always build new strings from the old string's parts. We do it like this:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; word= word[:2]+"c"+word[3:]</pre></div><p>This works by extracting pieces of the original string and including new characters mixed with the old.</p></div>
<div class="section" title="Using the built-in conversion functions"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec24"/>Using the built-in conversion functions</h1></div></div></div><p>We have a<a class="indexterm" id="id181"/> number of conversion functions in the various types of data we've seen in this chapter. Each of the built-in numeric types has a proper constructor function. As with many Python functions, each of these has a number of different kinds of arguments it can handle:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">int()</code>: Creates<a class="indexterm" id="id182"/> an <code class="literal">int</code> from a wide variety of other objects<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">int(3.718)</code> for another number</li><li class="listitem" style="list-style-type: disc"><code class="literal">int('48879')</code> for a string in base 10</li><li class="listitem" style="list-style-type: disc"><code class="literal">int('beef', 16)</code> for a string in the given base—16 in this example</li><li class="listitem" style="list-style-type: disc">The <code class="literal">int()</code> function can ignore the extra prefix characters on numbers written in Python literal syntax: <code class="literal">int('0b1010',2)</code>, <code class="literal">int('0xbeef',16)</code>, and <code class="literal">int('0o123',8)</code></li></ul></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">float()</code>: Creates<a class="indexterm" id="id183"/> a <code class="literal">float</code> from other objects<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">float(7331)</code> for another number</li><li class="listitem" style="list-style-type: disc"><code class="literal">float('4.8879e5')</code> for a decimal string</li></ul></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">complex()</code>: Creates <code class="literal">complex</code> values from<a class="indexterm" id="id184"/> a variety of objects<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">complex(23)</code> creates <code class="literal">(23+0j)</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">complex(23, 3)</code> creates <code class="literal">(23+3j)</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">complex('23+2j')</code> creates <code class="literal">(23+2j)</code></li></ul></div></li></ul></div><p>We can<a class="indexterm" id="id185"/> convert single numbers, pairs of numbers, and even some strings into <code class="literal">Fraction</code> objects:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Fraction(2,3)</code>: This is the most common way to create <code class="literal">Fraction</code> objects.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Fraction(2.718)</code>: This creates a value <code class="literal">Fraction(765048986699563, 281474976710656)</code>. This shows how floating-point values are actually approximations. If we wanted a more accurate value, we should do a meaningful <a class="indexterm" id="id186"/>conversion ourselves, using <code class="literal">Fraction(2718,1000)</code>, which would avoid the error bits present in many floating-point values.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Fraction("3/4")</code>: This also works very nicely to create a proper <code class="literal">Fraction</code> object.</li></ul></div><p>When we convert a <code class="literal">float</code> value to a <code class="literal">Fraction</code>, the results look unusual. However, considering that float values are an approximation, the <code class="literal">Fraction</code> value reveals the nature of the approximation.</p><p>We can also <a class="indexterm" id="id187"/>convert integers, strings, and floats to <code class="literal">Decimal</code> objects:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Decimal(2)</code>: Interestingly, this produces <code class="literal">Decimal('2')</code> as the result. This shows us that the preferred format for <code class="literal">Decimal</code> values is strings.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Decimal('2.718')</code>: This will produce the expected value. This is generally how we create <code class="literal">Decimal</code> objects.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Decimal(2.718)</code>: This will produce a value that reflects floating-point approximations: <code class="literal">Decimal('2.717999999999999971578290569595992565155029296875')</code>. Because of this, we generally avoid creating <code class="literal">Decimal</code> objects from <code class="literal">float</code> objects.</li></ul></div><p>We have a number of additional conversions from numbers to various kinds of strings: <code class="literal">bin()</code>, <code class="literal">oct()</code>, <code class="literal">hex()</code>, and <code class="literal">str()</code> produce strings in base 2, 8, 16, and 10 respectively. We can also use various formatting features of numbers using <code class="literal">"{0:b}".format(x)</code> for binary, <code class="literal">"{0:o}".format(x)</code> for octal, and <code class="literal">"{0:x}".format(x)</code> for hexadecimal. If we include the "<code class="literal">#</code>" modifier in the format string, we have considerable flexibility in the strings produced. For example:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; "{0:x}".format(12)
'c'
&gt;&gt;&gt; "{0:#x}".format(12)
'0xc'</pre></div><p>These<a class="indexterm" id="id188"/> functions show many different ways to create numbers from strings and create formatted strings from numbers.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec25"/>Summary</h1></div></div></div><p>We've looked at some core data types available in Python. We've looked at five different kinds of numbers, including integers, floating-point, complex, <code class="literal">Fraction</code> and <code class="literal">Decimal</code>. Each fills a different niche. Three of these are built-in, the other two must be imported from the standard library.</p><p>We've also looked at three different kinds of collections. The <code class="literal">tuple</code> is a simple sequence of items with relatively few methods. <code class="literal">str</code> is a Unicode string, which has several methods for creating new strings as transformations of existing strings. <code class="literal">bytes</code> is a byte string, which also has a variety of methods. We can decode bytes to create Unicode strings. We can encode Unicode strings into bytes.</p><p>We've touched on how the <code class="literal">import</code> statement is used to introduce new types and new modules. This will add features from the standard library.</p><p>We've also looked at a number of functions to convert various numeric types. Many of these functions also convert strings to numbers. We'll make heavy use of <code class="literal">int()</code> and <code class="literal">float()</code> to convert strings to numbers. The reverse—converting numbers to strings—can be done with the <code class="literal">str()</code> function. It can be done better, however, with the formatting tools we'll look at in the next chapter.</p><p>In <a class="link" href="ch03.html" title="Chapter 3. Expressions and Output">Chapter 3</a>, <span class="emphasis"><em>Expressions and Output</em></span>, we'll build on these basic concepts. We'll look in more depth at Python language syntax. We'll also look at functions for creating nicely formatted output. This will allow us to write simple programs. In <a class="link" href="ch04.html" title="Chapter 4. Variables, Assignment and Scoping Rules">Chapter 4</a>, <span class="emphasis"><em>Variables, Assignment and Scoping Rules</em></span>, we'll add even more essential language features so that we can write more sophisticated programs.</p></div></body></html>