<html><head></head><body>
        

                            
                    <h1 class="header-title">Getting Started with ROS</h1>
                
            
            
                
<p><strong>Robot Operating System</strong> (<strong>ROS</strong>) is an open source piece of software. Its development started at Willow Garage, a technology incubator and robotics research laboratory. Its origin dates back to several projects at Stanford University from the mid-2000s, where researchers found themselves reinventing the wheel every time they had to build the software for each project.</p>
<p>In 2007, Willow Garage took the lead and gave rise to ROS. The main goal was to reuse existing code and make it possible to prototype new robot designs quickly, focusing on high-level functionality and minimizing the need for editing code. If you are curious about how ROS has become the <em>de facto</em> standard for robot application development, you can view an interactive page at <a href="https://www.ros.org/history">https://www.ros.org/history</a>.</p>
<p>ROS is intended for the development of applications where different devices have to talk to each other in order to create a flexible and scalable environment. This chapter explains the basic concepts of ROS. It will introduce you to the framework using an easy language while avoiding very technical descriptions. This is because our first goal is to neatly show you what ROS is in a conceptual sense. In the following chapters, we will have the opportunity to cover technical descriptions; the ones that, in any case, you will need later in order to be able to use ROS in your projects.</p>
<p class="mce-root">In the first section of this chapter, we will cover how ROS works under the hood, and why it should not be simply considered as a specific-purpose programming language, but a framework for developing robotics apps. You will dive into the core concepts of the ROS graph and the asynchronous communication between nodes.</p>
<p>In the second section, you will be guided step by step to configure the ROS environment on your laptop.</p>
<p>In the third section, guided with a practical exercise, you will learn how to exchange simple messages between nodes using the command line.</p>
<p>Finally, we will give you an overview of the many available ROS packages that have been contributed by the open source community.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>ROS basic concepts and the ROS graph</li>
<li>Configuring your ROS development environment</li>
<li>Communication between ROS nodes: messages and topics</li>
<li>Using publicly available packages for ROS</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Technical requirements</h1>
                
            
            
                
<p>The practical aspects of this chapter require you to have access to a desktop computer or laptop with either of these two Ubuntu versions:</p>
<ul>
<li>Ubuntu 16.04 Xenial</li>
<li>Ubuntu 18.04 Bionic</li>
</ul>
<p><strong>Long-term support</strong> (<strong>LTS</strong>) Ubuntu versions are maintained by Canonical for the next 5 years. Also, these kind of versions are released in even years. Hence, Ubuntu 16.04- released in 2016- will be maintained up to 2021, while Ubuntu 18.04- released in 2018- will be maintained up to 2023. We will not consider odd-year versions, that is, Ubuntu 17 or Ubuntu 19 because they are development releases that are not LTS.</p>
<p>Open Robotics releases a new version of ROS every year coinciding with every Ubuntu version. The correspondence is as follows:</p>
<ul>
<li>ROS Kinetic running under Ubuntu 16.04 Xenial</li>
<li>ROS Melodic running under Ubuntu 18.04 Bionic</li>
</ul>
<p>The most used version as of the writing of this book is ROS Kinetic. The practical examples provided in the following chapters are valid for both Ubuntu 16.04 and Ubuntu 18.04. Hence, they will work for ROS Kinetic as well as for ROS Melodic.</p>
<p>When we don't make any distinction between Ubuntu or ROS versions, you should assume that they work for the two versions covered. If there is some difference in the commands or scripts to be run depending on the version, we will mention it explicitly.</p>
<p>The code for this chapter can be found in <kbd>Chapter3_ROS_basics</kbd> of the book repository, which is hosted on GitHub at <a href="https://github.com/PacktPublishing/Hands-On-ROS-for-Robotics-Programming/tree/master/Chapter3_ROS_basics" target="_blank">https://github.com/PacktPublishing/Hands-On-ROS-for-Robotics-Programming/tree/master/Chapter3_ROS_basics</a>. In the <em>Setting up the ROS package</em> section, you will learn how to download the code and make it work with your ROS installation.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">ROS basic concepts</h1>
                
            
            
                
<p>Early on, researchers of robotics at Stanford University found that prototyping software for robots was an intensive programming task, as they had to start coding from scratch for every project. There was a time in which programming languages such as C++ and Python were used for robotics as the general programming languages they are, and that fact required great efforts to build every piece of software to provide a robotic level of functionality, such as navigation or manipulation.</p>
<p>It was not only a question of the reusability of the code, but it was also a matter of how things worked in robotics. In procedural programming, the typical flow of a program executes one step after another, as shown in the following diagram:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1362 image-border" src="img/6dd10742-5596-4ac9-8267-479e8e7570be.png" style="width:17.83em;height:37.42em;"/></p>
<p>The task that this program executes is to combine multiple images into one, as can be easily inferred. From our robotic point of view, the main drawback of a process working like this is that, if some steps fail to execute, then the process cannot go on and, therefore, fails to deliver its results, that is, a combined image. If we use the analogy of robotics, this would mean that a humanoid robot transporting a light object (for example, a paper book) from one place to another may fail in its task if one of its arms does not work properly (the motor that drives the articulation of its elbow is broken, for example). The humanoid should be able to do the task with the other arm for sure. And this is what ROS does!</p>
<p>Let's take a look at the following example of a ROS graph.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The ROS graph</h1>
                
            
            
                
<p>This graph is to ROS what a workflow diagram is to procedural programming:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/72ca14dd-2590-4f14-9ad6-3de7fdc49162.png" style="width:27.75em;height:14.08em;"/></p>
<p>In the preceding graph, each circle—called a <strong>node</strong>—represents an independent program (this can be written in Python, Java, C++, Ruby, Node.js, or any of the other programming languages that ROS has implemented). The connections between them—called <strong>edges</strong>—represent the exchange of information. The meaning behind the direction of the arrows is self-explanatory: the emitter of data is the node where the arrow starts, and the receiver node is the one where the arrow points to. The words that appear above the edges are what ROS calls <strong>topics</strong>, and they constitute the channels through which flows the information exchanged between the nodes. When a node needs to use the information of a topic, it does so by subscribing to it and this operation adds a new arrow to the graph from the producer (of the data for such topic) to the subscriber node.</p>
<p>So, what does this graph do from the point of view of the robot? Remember that GoPiGo3 is a classical differential drive robot, where each wheel can be turned independently, and the sensor—for example, a distance sensor—provides the robot with information about how far away the obstacle is while moving:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/9401dda2-996f-40c9-9f80-b4b20ab4f812.png" style="width:28.00em;height:21.08em;"/></p>
<p>Image courtesy: Dexter Industries https://32414320wji53mwwch1u68ce-wpengine.netdna-ssl.com/wp-content/uploads/2017/05/GPG3_FullServoDistanceGoogly_1-800x800.jpg<a href="https://www.robotshop.com/media/catalog/product/cache/image/380x380/9df78eab33525d08d6e5fb8d27136e95/g/o/gopigo3-beginner-starter-kit.jpg"/></p>
<p>Therefore, you might have already guessed that in the preceding ROS graph, the <kbd>L_servo</kbd> node is the program that controls the left servomotor (by rotating that wheel) and the <kbd>R_servo</kbd> node does the same with the right wheel.</p>
<p>The <kbd>sensor</kbd> node is the one that takes the readings from the distance sensor and makes them available to the <kbd>control</kbd> node through the edge that is connected to it, that is, by using the <kbd>/sharp_data</kbd> topic. </p>
<p>Within the <kbd>control</kbd> node resides the program that takes the decision of what to do if GoPiGo3 is facing an obstacle. For example, it can rotate the robot until it finds a direction without any obstacles. Rotating means that the <kbd>control</kbd> node sends opposite commands to the <kbd>L_servo</kbd> and <kbd>R_Servo</kbd> nodes.</p>
<p>These signals are the ones that flow through the corresponding edges of the graph: the <kbd>/speed_left</kbd> topic or the left servo and <kbd>/speed_right</kbd> for the other one. In the ROS language, we say that the <kbd>control</kbd> node publishes the command for the left servo in the <kbd>/speed_left</kbd> topic.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">roscore</h1>
                
            
            
                
<p><strong>roscore</strong> is the mandatory and first node that has to be launched so that the ROS environment can be running. This allows every node to be capable of finding any other node by subscribing to the topics it publishes. roscore also manages the database for ROS parameters—the values that define the robot configuration. As a result, if the roscore process dies, the master node fails, and the robot stops working. You may guess that this single point of failure is a clear limitation for a distributed computed framework such as ROS. For this reason, ROS2 has addressed this issue, and the running software no longer requires a master node. Communication between the nodes relies on the <strong>DDS</strong> (short for <strong>Data Distribution Service</strong>) architecture for real-time systems.</p>
<p>Can you see how different programming a robot is from writing a software application? In robotics, you focus on the top-level functionalities of your application and integrate premade software pieces written by others.</p>
<p>Do take into account that not all software in robotics follows this approach. In fact, among its many uses, we selected ROS because its philosophy adapts very well to the <em>learn-through-practice</em> methodology that we have adopted for this book. </p>
<p>These pieces of software, which consist of code blocks grouped into nodes, form what we call a <strong>ROS package</strong>. Several related nodes constitute a ROS package that delivers a specific functionality, for example, object recognition with a camera.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Workspaces and catkin</h1>
                
            
            
                
<p>A workspace in ROS is an isolated environment for building and running your software. You may use different workspaces to manage different projects. The workspace will contain all the ROS packages you will need for your project.</p>
<p>Physically, it is a folder in your home directory that contains all of the specific files of your application in such a way that deploying this workspace in another machine with ROS preinstalled will work properly and do the same as it did on the original computer.</p>
<p>Tightly attached to the concept of the workspace is catkin, the build system of ROS that combines CMake macros and Python scripts to provide functionality on top of CMake's normal workflow. At this point, it is enough that you are aware that this is a tool used to build the software each time you include new packages in your workspace. You can find an in-depth conceptual explanation of catkin at <a href="http://wiki.ros.org/catkin/conceptual_overview">http://wiki.ros.org/catkin/conceptual_overview</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Configuring your ROS development environment</h1>
                
            
            
                
<p>In this section, we will guide you on how to install and configure the tools that you will need to work comfortably with ROS on your laptop. In short, these are the steps you need to complete before starting the practical exercises in this chapter:</p>
<ol>
<li>Make sure that your computer runs <strong>Ubuntu 16.04</strong> or <strong>Ubuntu 18.04</strong>. Both are the LTS releases that have the most extensive collection of ROS packages at the time of writing this book.</li>
<li>Install and set up <strong>ROS</strong> on your laptop. You will also be provided with the guidelines to install ROS in the Raspberry Pi, the CPU of the GoPiGO3 robot. However, in part 2 of the book, you will only need your laptop, since we will be dealing with a virtual model of the robot. The inclusion of the physical robot is left for part 3 of the book.</li>
<li>For the <em>Integrated Development Environment</em> (<strong>IDE</strong>) we will use <strong>RoboWare Studio</strong>, which is based on the general purpose IDE by Microsoft called <strong>Visual Studio Code</strong>. We provide the instructions to set it up in the <em>Installing RoboWare Studio</em> section below.</li>
</ol>
<p>So, provided your laptop has the required operating system, let's now move on to the second step of the configuration.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Installing ROS</h1>
                
            
            
                
<p>If you work under Ubuntu 16.04, you will need to install the Kinetic distribution of ROS. On the other hand, if you have Ubuntu 18.04, the corresponding version of ROS to install is called Melodic. Remember that these choices were explained in detail in the <em>Technical requirements</em> section.</p>
<p>Before installing the software, make sure that you have the two basic <kbd>curl</kbd> and <kbd>git</kbd> tools. If this is not the case, then run the following command to install the missing ones:</p>
<pre><strong>$ sudo apt update<br/>$ sudo apt install curl git</strong></pre>
<p>The instructions on the <strong>ROS Kinetic</strong> installation page (<a href="http://wiki.ros.org/kinetic/Installation/Ubuntu">http://wiki.ros.org/kinetic/Installation/Ubuntu</a>) are pretty clear and straightforward. They are the same for your laptop (<em>amd64/i386</em>) and for the Raspberry Pi (the <em>armhf</em> architecture). They are included here for the completion of the description.</p>
<div><strong>ROS Melodic</strong> also has an installation page at <a href="http://wiki.ros.org/melodic/Installation/Ubuntu">http://wiki.ros.org/melodic/Installation/Ubuntu</a>. There, you will find that the commands are the same as those for Kinetic, because they are written in such a way that are not dependent on the Ubuntu version of choice.</div>
<p>Following the next steps you will get ROS up and running in your laptop:</p>
<ol>
<li>First, add the source repository for ROS:</li>
</ol>
<pre class="mce-root" style="padding-left: 60px"><strong>$ sudo sh -c 'echo "deb http://packages.ros.org/ros/ubuntu $(lsb_release -sc) main" &gt; /etc/apt/sources.list.d/ros-latest.list'</strong></pre>
<p style="padding-left: 60px">This command adds ROS repository sources to your system. Since such a source is dependent on the Ubuntu version, the inner command  <kbd>$(lsb_release -sc)</kbd> in the snippet above outputs the version, i.e. <strong>xenial</strong> for Ubuntu 16.04 and <strong>bionic</strong> or Ubuntu 18.04.</p>
<ol start="2">
<li>Then, set up your keys: </li>
</ol>
<pre class="mce-root" style="padding-left: 60px"><strong>$ sudo apt-key adv --keyserver 'hkp://keyserver.ubuntu.com:80' --recv-key C1CF6E31E6BADE8868B172B4F42ED6FBAB17C654</strong></pre>
<p style="padding-left: 60px">Alternatively, you can use <kbd>curl</kbd> instead of the <kbd>apt-key</kbd> command. This is useful if you are behind a proxy server:</p>
<pre class="mce-root" style="padding-left: 60px"><strong>$ curl -sSL 'http://keyserver.ubuntu.com/pks/lookup?op=get&amp;search=0xC1CF6E31E6BADE8868B172B4F42ED6FBAB17C654' | sudo apt-key add -</strong></pre>
<p>If you do not get the key to be validated, then it may have been changed for security reasons (as of February 2020, the key remains active). If it is not the case at this moment, go to the official installation page at <a href="http://wiki.ros.org/melodic/Installation/Ubuntu">http://wiki.ros.org/melodic/Installation/Ubuntu</a> and find the section, where the key value <kbd>0xC1CF6E31E6BADE8868B172B4F42ED6FBAB17C654</kbd> needs to be replaced.</p>
<ol start="3">
<li>Update your sources:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ sudo apt update</strong></pre>
<ol start="4">
<li>If you have Ubuntu 16.04 on your laptop, install the full stack of ROS Kinetic, including the simulator called <strong>Gazebo</strong>, navigation, and robot perception packages (recommended):</li>
</ol>
<pre style="padding-left: 60px"><strong>$ sudo apt install ros-kinetic-desktop-full</strong></pre>
<p style="padding-left: 60px">If you are working in Ubuntu 18.04, perform the installation of ROS Melodic instead:</p>
<pre style="padding-left: 60px"><strong>$ sudo apt install ros-melodic-desktop-full</strong></pre>
<p style="padding-left: 60px">Alternatively, you may install the desktop version, which only includes the ROS GUI tools (<kbd>rqt</kbd>, <kbd>rviz</kbd>). Later on, you can add the packages for simulation (Gazebo), navigation, and perception when needed (remember that these are installed with full version outlined in step 4 above):</p>
<pre style="padding-left: 60px"><strong>$ sudo apt install ros-kinetic-desktop</strong></pre>
<p style="padding-left: 60px">Alternatively, if you are in Ubuntu 18.04, you can use the following:</p>
<pre style="padding-left: 60px"><strong>$ sudo apt install ros-melodic-desktop</strong></pre>
<ol start="5">
<li>Initialize <kbd>rosdep</kbd>. This is the component that enables you to easily install system dependencies for the source code to compile. It is also required in order to run some core components in ROS:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ sudo rosdep init
$ rosdep update</strong></pre>
<ol start="6">
<li>Set up the ROS environment for your interactive shell session:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ source /opt/ros/kinetic/setup.bash</strong></pre>
<p style="padding-left: 60px">Alternatively, if you are in Ubuntu 18.04, use the following:</p>
<pre style="padding-left: 60px"><strong>$ source /opt/ros/melodic/setup.bash</strong></pre>
<p style="padding-left: 60px">To avoid having to run this command each time you open a new terminal, include it at the end of your <kbd>.bashrc</kbd> file with the following command:</p>
<pre style="padding-left: 60px"><strong>$ echo "source /opt/ros/kinetic/setup.bash" &gt;&gt; ~/.bashrc
$ source ~/.bashrc</strong></pre>
<p style="padding-left: 60px">The second command in the snippet above executes the <strong>.bashrc</strong> file refreshing your custom setup. If in Ubuntu 18.04, just replace <kbd>kinetic</kbd> for <kbd>melodic</kbd>:</p>
<pre style="padding-left: 60px"><strong>$ echo "source /opt/ros/melodic/setup.bash" &gt;&gt; ~/.bashrc $ source ~/.bashrc</strong></pre>
<ol start="7">
<li>Finally, install <kbd>rosinstall</kbd>, the command-line tool that enables you to easily download many source trees for ROS packages:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ sudo apt install python-rosinstall python-rosinstall-generator python-wstool build-essential</strong></pre>
<p>Bear in mind that, as you become more familiar with the communication between the Raspberry Pi in the robot and your laptop, you can make all the desktop interactions from your computer and let the Raspberry Pi execute only robotics-specific tasks. This approach will make GoPiGo3 more responsive because you will have a minimal Ubuntu server in the Raspberry Pi and the ROS base version, which excludes the GUI tools and has only the core packages, as well as the build and communication libraries.</p>
<p>You can refer to the next section for specific details on how to prepare the ROS environment for the robot.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Ubuntu and ROS in the Raspberry Pi</h1>
                
            
            
                
<p>Since you will be using only the core ROS packages in your Raspberry Pi, it is recommended that you install the latest Ubuntu LTS version, that is, Ubuntu Mate 18.04 Bionic (<a href="https://ubuntu-mate.org/download/">https://ubuntu-mate.org/download/</a>). This is because, although almost all contributed ROS packages are available for ROS Kinetic, it is also true that core packages are already available in the 2018 version of ROS Melodic. Therefore, it is safe to install this release in the Raspberry Pi under Ubuntu 18.04.</p>
<p>As mentioned already, the instructions on the ROS Melodic installation page (<a href="http://wiki.ros.org/melodic/Installation/Ubuntu">http://wiki.ros.org/melodic/Installation/Ubuntu</a>) are pretty clear and straightforward.</p>
<p>Follow the next guidelines to decide which version to install:</p>
<ul>
<li>If installing ROS Desktop (which is recommended for beginners and for covering the contents of this book), use the following command:</li>
</ul>
<pre style="padding-left: 60px"><strong>$ sudo apt-get install ros-melodic-desktop</strong></pre>
<ul>
<li>If you wish to install the bare-bones version, that is, ROS Base, and so get a better performance from your Raspberry Pi, then use this command (this is only recommended for advanced users; at the moment, there is no desktop GUI): </li>
</ul>
<pre style="padding-left: 60px"><strong>$ sudo apt install ros-melodic-ros-base</strong></pre>
<p>As mentioned at the beginning of the section, for this chapter you will only need a laptop. The physical robot is left for part 3 of the book, starting from <a href="0b20bdff-f1dc-42e8-ae83-fc290da31381.xhtml" target="_blank">Chapter 6</a>, <em>Programming in ROS – Commands and Tools</em>. In that chapter, we will provide the necessary details to correctly set up the software in the Raspberry Pi.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Integrated Development Environment (IDE)</h1>
                
            
            
                
<p class="mce-root">In the section of ROS wiki devoted to <em>Integrated Development Environments</em> (<a href="http://wiki.ros.org/IDEs">http://wiki.ros.org/IDEs</a>) are described the currently available IDEs for ROS—a total of 15 IDEs exist at the time of writing this book. Out of all of these options, we have selected to work with RoboWare Studio because of the following factors:</p>
<ul>
<li>It is a fork of <strong>Visual Studio Code</strong> (<strong>VSC</strong>), the general-purpose and customizable IDE by Microsoft that is extensively used in the developer community. It is open source, light, easy to use and offers lots of contributed plugins, making it possible to customize the IDE environment to your own specific needs. <strong>RoboWare Studio</strong> is built on top of VSC code to provide ROS development functionalities. Furthermore, the plugin panel of the IDE is customized so that you can easily install ROS packages on demand. The current version is 1.2.0, which was issued in June 2018. Its code is open source and it is publicly available in GitHub at <em>TonyRobotics/RoboWare-Studio</em> (<a href="https://github.com/TonyRobotics/RoboWare-Studio">https://github.com/TonyRobotics/RoboWare-Studio</a>).</li>
<li><strong>RoboWare Studio </strong>out-of-the-box features allow you to start working with all of ROS's main characteristics: workspaces, packages, nodes, messages/services/actions, and more. </li>
</ul>
<p>For all of the explanations in this book, we will always give you the commands to be executed in <kbd>bash</kbd>, as this is the native way of commanding ROS.</p>
<p>IDEs such as RoboWare Studio may be of help in at least two scenarios:</p>
<ul>
<li>When beginning with ROS, to avoid dealing with the complexity of the command line if you are not very familiar with it</li>
<li>When developing projects, where the IDE facilitates the management of the large number of files that are spread along with the ROS packages that make up your application. Such packages provide functionalities such as coordinate transformations, computer vision, robot navigation, and so on.</li>
</ul>
<p>In any case, our advice is that you do the first round of this book using RoboWare Studio, and, for the second round, go directly to <kbd>bash</kbd>. If you want to skip one of them, then discard the IDE option and keep learning with the command line. Practicing <kbd>bash</kbd> commands is the best way to really understand how ROS works, and you surely know that this applies not only for ROS but for any other software tool running under Linux OS.</p>
<p>Therefore, from now on, use the IDE of your choice for editing files, and always work with the ROS command line (or RoboWare if you prefer to keep working with a GUI interface).</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Installing RoboWare Studio</h1>
                
            
            
                
<p>Provided that you have already installed ROS on your computer, execute the following block of commands in a terminal to install the required dependencies, as indicated in the manual of RoboWare Studio available at <a href="https://github.com/TonyRobotics/RoboWare/blob/master/Studio/RoboWare_Studio_Manual_1.2.0_EN.pdf">https://github.com/TonyRobotics/RoboWare/blob/master/Studio/RoboWare_Studio_Manual_1.2.0_EN.pdf</a>:</p>
<pre><strong>$ sudo apt-get update</strong><br/><strong>$ sudo apt-get install build-essential python-pip pylint</strong></pre>
<p class="packt_figref">Then, install the <kbd>clang-format-3.8</kbd> package:</p>
<pre><strong>$ sudo apt-get install clang-format-3.8</strong></pre>
<p>Binaries are hosted in GitHub at <a href="https://github.com/TonyRobotics/RoboWare/blob/master/Studio">https://github.com/TonyRobotics/RoboWare/blob/master/Studio</a>. You can download the latest version of RoboWare Studio in your Ubuntu OS for AMD64 from this link: <a href="https://github.com/TonyRobotics/RoboWare/raw/master/Studio/roboware-studio_1.2.0-1524709819_amd64.deb">https://github.com/TonyRobotics/RoboWare/raw/master/Studio/roboware-studio_1.2.0-1524709819_amd64.deb</a>. You also have the source code available in GitHub at <a href="https://github.com/tonyrobotics/roboware-studio">https://github.com/tonyrobotics/roboware-studio</a>. </p>
<p>Installation is pretty easy; execute the following command from the location where you got the <kbd>.deb</kbd> file:</p>
<pre><strong>$ sudo dpkg -i roboware-studio_1.2.0-1524709819_amd64.deb</strong></pre>
<p>After finishing, you can launch the IDE by clicking on the RoboWare Studio icon.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Communication between ROS nodes – messages and topics</h1>
                
            
            
                
<p>We will accomplish the goal of getting two nodes talking to each other by going step by step. First, you need to create a personal workspace, and then you will pull the book repository at <a href="https://github.com/PacktPublishing/Hands-On-ROS-for-Robotics-Programming">https://github.com/PacktPublishing/Hands-On-ROS-for-Robotics-Programming</a>, and go into the <kbd>Chapter3_ROS_basics</kbd> folder to follow the exercises by yourself.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a workspace</h1>
                
            
            
                
<p>Follow these steps to create a workspace from the command line:</p>
<ol>
<li>First, create the folders that you will need later to place your ROS packages:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ mkdir -p ~/catkin_ws/src</strong></pre>
<p style="padding-left: 60px">The following are the folder descriptions:</p>
<ul>
<li><kbd>catkin_ws</kbd> will be the root location of your workspace.</li>
<li><kbd>src</kbd> is where you will place your code, that is, inside the ROS packages.</li>
</ul>
<p>Be aware that <strong>~</strong> is equivalent to the home folder, that is, <kbd>/home/bronquillo</kbd>.</p>
<ol start="2">
<li>Move to this last folder and issue the following command to initialize the workspace:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ cd ~/catkin_ws/src</strong><br/><strong>$ catkin_init_workspace</strong></pre>
<p style="padding-left: 60px">The last command will generate the <kbd>~/catkin_ws/src/CMakeLists.txt</kbd> file, which contains the definition and configuration of the workspace. That file really is a symlink to a location in the ROS installation folder where the workspace configuration is defined:</p>
<pre style="padding-left: 60px">/opt/ros/melodic/share/catkin/cmake/toplevel.cmake</pre>
<ol start="3">
<li>Build the workspace for the first time; it does not matter that the folder is empty at this time:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ cd ~/catkin_ws</strong><br/><strong>$ catkin_make</strong></pre>
<p style="padding-left: 60px">By listing the content, you will see two new folders:</p>
<ul>
<li style="list-style-type: none">
<ul>
<li><kbd>build</kbd> contains the result of the compilation of our workspace, and makes available all the code you will place later when creating a package for its execution with ROS commands.</li>
<li><kbd>devel</kbd> contains the configuration of the workspace, and it will be sourced every time you open a terminal (refer to the following steps).</li>
</ul>
</li>
</ul>
<p style="padding-left: 60px">Be aware that compilation has to be done at the root folder, <kbd>~/catkin_ws</kbd>, while workspace initialization was done in the application code folder, <kbd>~/catkin_ws/src</kbd>.</p>
<ol start="4">
<li>To add the workspace to your ROS environment, you need to source the generated <kbd>setup</kbd> file:</li>
</ol>
<pre class="mce-root" style="padding-left: 60px"><strong>$ source ~/catkin_ws/devel/setup.bash</strong></pre>
<ol start="5">
<li>To avoid having to run this command each time you open a new terminal, include it in your <kbd>.bashrc</kbd> file:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ echo "source ~/catkin_ws/devel/setup.bash" &gt;&gt; ~/.bashrc
$ source ~/.bashrc</strong></pre>
<ol start="6">
<li>Then, you should have the following two lines added to your <kbd>.bashrc</kbd> file:</li>
</ol>
<pre class="mce-root" style="padding-left: 60px"><strong>source /opt/ros/kinetic/setup.bash</strong><br/><strong>source ~/catkin_ws/devel/setup.bash</strong></pre>
<p class="mce-root">Remember that the first line accounts for the ROS system configuration and the second for your workspace settings.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a workspace and building it using RoboWare</h1>
                
            
            
                
<p>The following instructions allow you to use the RoboWare IDE to create the workspace, avoiding the use of the command line:</p>
<ol>
<li>Launch RoboWare and click on the New Workspace... item:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/b39dca13-5fac-4b07-a04e-1509e187509d.png" style="width:19.75em;height:15.42em;"/></p>
<ol start="2">
<li>In the pop-up window, indicate the name of the workspace and select the folder where you want to place it:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/1dc1df84-ee79-4d87-806b-b6731188f727.png" style="width:33.92em;height:6.75em;"/></p>
<p style="padding-left: 60px">After setting the folder name, RoboWare executes <kbd>catkin_init_workspace</kbd> transparently for the user, and you will see a new file and a new folder on the left-hand side of your IDE window. They are the <kbd>src</kbd> folder and the file inside, <kbd>CMakeLists.txt</kbd>, which contains your workspace definition and configuration:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1364 image-border" src="img/13f96ac6-236c-459e-9303-244edf80ecf4.png" style="width:43.42em;height:18.00em;"/></p>
<p style="padding-left: 60px">For now, it is enough that you notice that the file has a symlink to a ROS system file located in the ROS installation folder,<strong> </strong><kbd>/opt/ros/kinetic</kbd>. This folder contains the common configuration for all the workspaces you may create.</p>
<p style="padding-left: 60px">You can open a terminal in RoboWare and list all files with the <kbd>ls -la</kbd> command from the specific <kbd>~/catkin/src</kbd> location:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1365 image-border" src="img/9e5a5de7-cd9e-47bf-8d29-9183f7ec4539.png" style="width:53.83em;height:2.83em;"/></p>
<p>Such a terminal is accessed from the top-bar menu, by clicking on the View item, and then selecting Integrated terminal (<em>Ctrl</em> + <em>`</em>) from the drop-down menu.</p>
<ol start="3">
<li>Select the build mode and set it to Debug, as shown in the following screenshot:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1366 image-border" src="img/de495ea1-2116-4932-a056-64dd67b6854c.png" style="width:27.67em;height:18.83em;"/></p>
<ol start="4">
<li>Then, from the top-bar menu, select ROS | Build:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1367 image-border" src="img/c91c6db5-f60e-4e51-b9fb-63e8b579f266.png" style="width:27.83em;height:18.67em;"/></p>
<p style="padding-left: 60px">You will see the following log in the OUTPUT window at the bottom of the screen:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1368 image-border" src="img/32182be7-c0b4-47bb-80b9-892e5de41995.png" style="width:29.58em;height:32.17em;"/></p>
<p style="padding-left: 60px">The last lines should look like this if successful:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1369 image-border" src="img/827dfbb8-08b5-4842-833b-f496dba956bf.png" style="width:48.75em;height:16.00em;"/></p>
<p>Next, let's set up the ROS package.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Setting up the ROS package</h1>
                
            
            
                
<p>Follow these steps for setting up the ROS package:</p>
<ol>
<li>From a terminal, clone the book repository, <a href="https://github.com/PacktPublishing/Hands-On-ROS-for-Robotics-Programming">https://github.com/PacktPublishing/Hands-On-ROS-for-Robotics-Programming</a>, into your home folder:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ cd ~</strong><br/><strong>$ git clone https://github.com/PacktPublishing/Hands-On-ROS-for-Robotics-Programming</strong> </pre>
<ol start="2">
<li>We are going to copy the code of this chapter into the ROS workspace. That way, you will have a cleaner ROS environment:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ cp -R ~/Hands-On-ROS-for-Robotics-Programming/Chapter3_ROS_basics ~/catkin_ws/src</strong></pre>
<p>Do not add a backslash, <kbd>\n</kbd>, after the <kbd>src</kbd> folder name. If you do, the files will be copied directly into the <kbd>src</kbd> folder, not under <strong><kbd>src/Chapter3_ROS_basics</kbd></strong>.</p>
<ol start="3">
<li>Within the <kbd>Chapter3_ROS_basics</kbd> folder, you can find the files of this chapter belonging to the first ROS package you will play with. Its configuration is contained in the <kbd>package.xml</kbd> file. Be aware that the package name is defined within the <kbd>&lt;name&gt;ros_basics&lt;/name&gt;</kbd><em> </em>tags. You can find it inside the following code file:</li>
</ol>
<div><pre style="padding-left: 60px">&lt;?xml version="1.0"?&gt;<br/>&lt;package format="2"&gt;<br/>    &lt;name&gt;<strong>ros_basics</strong>&lt;/name&gt;<br/>    &lt;version&gt;0.0.0&lt;/version&gt;<br/>    &lt;description&gt;Code samples for "Chapter 3: Getting started with ROS"&lt;/description&gt;<br/>    &lt;maintainer email="brjapon@therobotacademy.com"&gt;Bernardo R. Japon&lt;/maintainer<br/>    &lt;license&gt;GNU v3.0&lt;/license&gt;<br/>        <br/>    &lt;buildtool_depend&gt;catkin&lt;/buildtool_depend&gt;<br/>    &lt;build_depend&gt;rospy&lt;/build_depend&gt;<br/>    &lt;build_export_depend&gt;rospy&lt;/build_export_depend&gt;<br/>    &lt;exec_depend&gt;rospy&lt;/exec_depend&gt;<br/>&lt;/package&gt;</pre></div>
<ol start="4">
<li>Then, go to the workspace root and build again:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ cd ~/catkin_ws</strong><br/><strong>$ catkin_make</strong><br/><strong>$ source ~/catkin_ws/devel/setup.bash</strong></pre>
<p>In general, you will have to rebuild the workspace in at least two cases:</p>
<ul>
<li>Each time you include a new package</li>
<li>If your code contains pieces written in a compilable language such as C++</li>
</ul>
<p>In this book, we will be working mainly with Python, the widely used open source language that makes it easier to get started with ROS. Since Python is an interpreted language, you will not need to rebuild the workspace each time you modify the code base of the package. Hence, the rebuild will only be necessary when adding or removing ROS packages. The way to check whether the newly added package—<kbd>ros_basics</kbd>—is known to ROS is to execute this simple command:</p>
<pre><strong>$ rospack list | grep ros_basics</strong></pre>
<p>The output should look like this:</p>
<pre><strong>ros_basics /home/bronquillo/catkin_ws/src/book/Chapter3_ROS_basics</strong></pre>
<p>Although here, we will be working from a premade ROS package, it is relevant that you know at this point how to create your own package from scratch. Issue this command from the <kbd>src</kbd> location of your workspace (<kbd>$ cd ~/catkin_ws/src/</kbd>):</p>
<pre><strong>$ catkin_create_pkg &lt;YOUR-PACKAGE-NAME&gt; &lt;DEPENDENCIES&gt;</strong></pre>
<p><kbd>&lt;YOUR-PACKAGE-NAME&gt;</kbd> stands for the name you want to assign to your package. <kbd>&lt;DEPENDENCIES&gt;</kbd> refers to the list of ROS packages you will need for your code to run. For example, if your package is going to contain code in Python and C++, you will need <kbd>rospy</kbd> for the former and <kbd>roscpp</kbd> for the latter. Then, the command will be as follows:</p>
<pre><strong>$ catkin_create_pkg &lt;YOUR-PACKAGE-NAME&gt; rospy roscpp</strong></pre>
<p>This will create a folder with the name given to the package and two files:</p>
<ul>
<li><kbd>package.xml</kbd>: The package configuration as shown previously</li>
<li><kbd>CMakelists.txt</kbd>: The input to the CMake build system for building software packages</li>
</ul>
<p><kbd>CMakelists.txt</kbd> also contains the reference to<em> </em><kbd>&lt;YOUR-PACKAGE-NAME&gt;</kbd>. For our case, this file is as simple as follows:</p>
<div><pre>cmake_minimum_required(VERSION 2.8.3)<br/>project(ros_basics)<br/><br/>find_package(catkin REQUIRED COMPONENTS rospy)<br/><br/>###################################<br/>## catkin specific configuration ##<br/>###################################<br/>catkin_package()<br/><br/>###########<br/>## Build ##<br/>###########<br/>include_directories()<br/></pre></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Accessing package files and building the workspace using RoboWare</h1>
                
            
            
                
<p>Here's an alternative method. The following demonstrates that you can clone a package repository and build the workspace using RoboWare.</p>
<p>After cloning and placing the code of the chapter, as explained in the <em>Setting up the ROS package</em> section, you can explore the content in the file tree view on the left-hand side of the IDE window. Clicking on any of the files will let you see the content in the main window:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1370 image-border" src="img/134e7da1-e4ea-4699-b96a-8e60222d0d5f.png" style="width:70.00em;height:33.75em;"/></p>
<p>Finally, build the workspace; note that this is something you will have to do each time you create a new package on your own or when you clone an external one. To do that, go to the top bar menu, select ROS, and then click on Build as before.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">A node publishing a topic</h1>
                
            
            
                
<p>For the next steps, since we will need to deal with several simultaneous terminals, we will make use of a very handy tool, Terminator, that allows you to simultaneously handle several terminals. Launch these commands to install it on your system:</p>
<pre><strong>$ sudo apt-get update</strong><br/><strong>$ sudo apt-get install terminator</strong></pre>
<p>Launch Terminator and divide the screen into four terminals (you can right-click on the mouse to divide the windows successively). We will reference them as <kbd>T1</kbd>, <kbd>T2</kbd>, <kbd>T3</kbd>, and <kbd>T4</kbd>, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/06cbf42b-79ef-48dc-a1be-d481b96891d6.png" style="width:51.58em;height:22.58em;"/></p>
<p>Launch the roscore node in terminal 1 (the top-left window):</p>
<pre><strong>T1 $ roscore</strong></pre>
<p>You should be able to see this output in <kbd>T1</kbd>:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1372 image-border" src="img/6cd71e1e-4ecf-4ccc-92b8-ed8b90a9bc37.png" style="width:32.83em;height:20.67em;"/></p>
<p>This is the root process of ROS. roscore launches a node and starts the master service, as ROS is a centralized system. The master node is always needed so that other nodes may execute and it has to be launched prior to any other node.</p>
<p>In the next terminal, <kbd>T2</kbd>, run this command to launch the publisher node:</p>
<pre><strong>T2 $ rosrun ros_basics topic_publisher.py</strong></pre>
<p>This launches the <kbd>topic_publisher</kbd> node, but nothing happens! That's right. A publisher is just that, a publisher. We need a listener to know what data is being sent.</p>
<p class="mce-root">Go to terminal 3 and list the topics currently declared:</p>
<pre><strong>T3 $ rostopic list</strong><br/><strong>/counter</strong><br/><strong>/rosout</strong><br/><strong>/rosout_agg</strong></pre>
<p>In the listing, it appears that <kbd>/counter</kbd> is the topic that updates an incremental counter every 0.5 seconds. The other two topics, <kbd>/rosout</kbd> and <kbd>/rosout_agg</kbd>, are the console log-reporting (<a href="http://wiki.ros.org/rosout">http://wiki.ros.org/rosout</a>) mechanisms in ROS.</p>
<p>This line of the <kbd>topic_publisher.py</kbd> file is the one that sets up the <kbd>/counter</kbd> topic publisher:</p>
<pre>pub = rospy.Publisher('<strong>counter</strong>', Int32, queue_size=10)</pre>
<p>To watch the published messages, launch this command in the terminal:</p>
<pre><strong>T3 $ rostopic echo counter -n 5</strong></pre>
<p>This will output the next five messages that will be published in the <kbd>/counter</kbd> topic:</p>
<pre><strong>data: 530</strong><br/><strong>---</strong><br/><strong>data: 531</strong><br/><strong>---</strong><br/><strong>data: 532</strong><br/><strong>---</strong><br/><strong>data: 533</strong><br/><strong>---</strong><br/><strong>data: 534</strong><br/><strong>---</strong></pre>
<p>Finally, we will show a live view that will print the real-time frequency at which the messages are sent:</p>
<pre class="mce-root"><strong>T3 $ rostopic hz counter<br/><br/>average rate: 2.000</strong><br/><strong>min: 0.500s max: 0.501s std dev: 0.00020s window: 146</strong><br/><strong>average rate: 2.000</strong><br/><strong>min: 0.500s max: 0.501s std dev: 0.00020s window: 148</strong><br/><strong>average rate: 2.000</strong><br/><strong>min: 0.500s max: 0.501s std dev: 0.00020s window: 150</strong><br/><strong>average rate: 2.000</strong><br/><strong>min: 0.500s max: 0.501s std dev: 0.00020s window: 152</strong><br/><strong>average rate: 2.000</strong><br/><strong>min: 0.500s max: 0.501s std dev: 0.00020s window: 154</strong><br/><strong>average rate: 2.000</strong><br/><strong>min: 0.500s max: 0.501s std dev: 0.00020s window: 156</strong><br/><strong>average rate: 2.000</strong></pre>
<p>Press <em>Ctrl</em> + <em>C</em> to stop the log in <kbd>T3</kbd>. Bear in mind that, if you do this in any of the two previous terminals, the process that each one controls will die with the following consequences:</p>
<ul>
<li><strong>Terminal T2</strong>: The publisher process will end and no more messages will be sent through the <kbd>/counter</kbd> topic. </li>
<li><strong>Terminal T1</strong>: Pressing <em>Ctrl</em> + <em>C</em> in this terminal will kill roscore, making it evident that this process is a single point of failure in ROS, that is, all related processes (including nodes and messages) will die.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">A node that listens to the topic</h1>
                
            
            
                
<p>As there is one node that publishes the incremental counter in the <kbd>/counter</kbd> topic, we will now launch a node that subscribes to this topic.</p>
<p>To start, let's visualize the current ROS graph by issuing the following command in <kbd>T3</kbd>:</p>
<pre><strong>T3 $ rqt_graph</strong></pre>
<p>A window pops up and shows this:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1373 image-border" src="img/d2782ae9-27d4-4dbc-8bd8-524bc33c7434.png" style="width:51.58em;height:23.33em;"/></p>
<p>There is a single node, that is, the one we launched in <kbd>T2</kbd>. The <kbd>/counter</kbd> topic does not appear because no other node is listening to it. In order to make the topic show, launch the listener in <kbd>T4</kbd>:</p>
<pre><strong>T4 $ rosrun ros_basics topic_subscriber.py</strong></pre>
<p>You will see this log in the bottom-right terminal window, a neverending live data stream unless you kill (press <em>Ctrl</em> + <em>C</em>) any of  <kbd>T1</kbd> or <kbd>T2</kbd>, that correspond to <kbd>roscore</kbd> and <kbd>topic_publisher</kbd> respectively.</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/ae94c3ac-996c-45f7-ace7-99c50c2aee9e.png" style="width:53.00em;height:33.42em;"/></p>
<p>If you go back to the ROS graph window and click on the update icon, you will see the <kbd>/topic_publisher</kbd> node, the <kbd>/counter</kbd> topic that routes the messages, and the <kbd>/topic_subscriber</kbd> listening node:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1374 image-border" src="img/e892e914-fe48-46cb-94ed-433fec69914a.png" style="width:38.50em;height:14.50em;"/></p>
<p>This simple example illustrates the publish/subscribe architecture of communication in ROS. You can already appreciate how it works and how simple the underlying communication principle is, which is in the base of the ROS framework. We will now do something practical.</p>
<p>Let's make our counter behave like a chronometer. How can we do this? Well, you just need to modify the script <kbd>topic_publisher.py</kbd>, by changing the parameter that specifies the number of times per second that a message is sent to the topic, a concept known as the publishing <strong>frequency</strong>, whose units are <em>Hertz</em> (= number of times/second). In the script, the Python object that accounts for this behavior is: </p>
<pre>rate = <strong>rospy</strong>.Rate(2)</pre>
<p>In the loop below in the script, the configured behavior is achieved by applying the <strong>rospy</strong> method <kbd>sleep</kbd> method to the defined <kbd>rate</kbd> object:</p>
<pre>rate.sleep()</pre>
<p>Remember that <strong>rospy</strong> is the ROS library that allows us to run nodes whose code is written in Python. <strong>rospy</strong> defines a set of methods to make useful stuff in ROS, such as setting a publishing frequency in this way.</p>
<p>The line above states that two messages are published every second, that is, one message every 0.5 seconds. Hence if <kbd>rate</kbd> is set to 1 Hz, the frequency will be one message per second, therefore emulating a chronometer. You can modify such script <kbd>topic_publisher.py</kbd> without needing to stop ROS, and, as soon as you execute it again, the node is back in the graph. Let's show you how to do it step by step:</p>
<ol>
<li style="font-weight: 400">Hit <em>Ctrl</em> + <em>C</em> in terminal <kbd>T2</kbd> to stop the execution of the node.</li>
<li style="font-weight: 400">Modify the file to publish at a rate of 1 Hz, as shown previously.</li>
<li style="font-weight: 400">Then, relaunch the node:</li>
</ol>
<pre style="padding-left: 60px"><strong>T2 $ rosrun ros_basics topic_publisher.py</strong></pre>
<p>You will see the effect in terminal <kbd>T4</kbd> from where <kbd>topic_subscriber.py</kbd> was launched. Therefore, the speed of new lines appearing (that is, counts) will be double compared to before when the rate was 2 Hz. This will produce one counter update (+1) per second, which corresponds to the rate of 1 Hz.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Combining the publisher and subscriber in the same node</h1>
                
            
            
                
<p>Can a node talk and listen at the same time as a real human does? Well, if ROS is a framework for robotics, it should be possible. Let's explore this:</p>
<ol>
<li>Launch these two commands in the first two terminals, with each one in an independent terminal:</li>
</ol>
<pre style="padding-left: 60px">T1 $ roscore<br/>T2 $ rosrun ros_basics doubler.py</pre>
<p style="padding-left: 60px"><kbd>/doubler</kbd> is a node that subscribes to the <kbd>/number</kbd> topic, as specified in these two lines of the <kbd>doubler.py</kbd> script: </p>
<pre style="padding-left: 60px">rospy.init_node('doubler')<br/>...<br/>sub = rospy.Subscriber('number', Int32, callback)<br/>...</pre>
<p style="padding-left: 60px">Additionally, <kbd>/doubler</kbd> publishes its result in the <kbd>/doubled</kbd> topic:</p>
<pre style="padding-left: 60px">...<br/>pub = rospy.Publisher('doubled', Int32, queue_size=10)</pre>
<p style="padding-left: 60px">You will notice that nothing happens, because it needs to be fed with a number that can be multiplied by 2, as shown in the callback of <kbd>topic_subscriber.py</kbd>:</p>
<pre style="padding-left: 60px">def callback(msg):<br/>  doubled = Int32()<br/>  doubled.data = msg.data * 2</pre>
<ol start="2">
<li>Launch a terminal for listening to the <kbd>/doubled</kbd> topic:</li>
</ol>
<pre style="padding-left: 60px"><strong>T3 $ rostopic echo doubled</strong></pre>
<p style="padding-left: 60px">Then, let's publish a <kbd>/number</kbd> topic by hand:</p>
<pre style="padding-left: 60px"><strong>T4 $ rostopic pub number std_msgs/Int32 2</strong><br/><strong>    publishing and latching message. Press ctrl-C to terminate</strong></pre>
<p style="padding-left: 60px">The output in terminal <kbd>T3</kbd> is <kbd>4</kbd>, as expected:</p>
<pre style="padding-left: 60px"><strong>data: 4</strong><br/><strong>---</strong></pre>
<ol start="3">
<li>Try sending other numbers in <kbd>T4</kbd> and check that the double is shown immediately in <kbd>T3</kbd>.</li>
</ol>
<p class="mce-root" style="padding-left: 60px">If you issue <kbd>rqt_graph</kbd> in a fifth terminal, you will see something like this:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1375 image-border" src="img/dee74e53-1ffc-4bdd-a5fa-2817f9659f63.png" style="width:64.83em;height:4.50em;"/></p>
<p style="padding-left: 60px">Here, you can see the <kbd>/number</kbd> and <kbd>/doubled</kbd> topics, the <kbd>/doubler</kbd> node, and two other nodes with large machine names whose correspondence are as follows:</p>
<ul>
<li style="list-style-type: none">
<ul>
<li style="font-weight: 400">The node on the left of the preceding diagram, <kbd>/rostopic_5469_</kbd>, is created from the command in <kbd>T4</kbd>:</li>
</ul>
</li>
</ul>
<pre style="padding-left: 120px"><strong>T4 $ rostopic pub number std_msgs/Int32 2</strong></pre>
<ul>
<li style="list-style-type: none">
<ul>
<li style="font-weight: 400">The node on the right, <kbd>/rostopic_5631_</kbd>, is created from the command in <kbd>T3</kbd>:</li>
</ul>
</li>
</ul>
<pre style="padding-left: 120px"><strong>T3 $ rostopic echo doubled</strong></pre>
<ol start="4">
<li>To finish this exercise, we will feed the number to the <kbd>/counter</kbd> topic, not from the command line, but from the script of the publisher node we saw in the last section: <kbd>topic_publisher.py</kbd>. For the script to work properly, you have to modify the topic name in <kbd>doubler.py</kbd>, renaming it from <kbd>number</kbd> to <kbd>counter</kbd>:</li>
</ol>
<pre style="padding-left: 60px">sub = rospy.Subscriber('<strong>counter</strong>', Int32, callback)</pre>
<p style="padding-left: 60px">Then, after stopping all of the terminals, execute each of the following lines in an independent terminal:</p>
<pre style="padding-left: 60px"><strong>T1 $ roscore</strong><br/><strong>T2 $ rosrun ros_basics doubler.py</strong><br/><strong>T3 $ rosrun ros_basics topic_publisher.py</strong><br/><strong>T4 $ rostopic echo doubled</strong></pre>
<p>In this terminal, you will see the result of <kbd>counter</kbd> * 2 every time <kbd>/counter</kbd> is published. Take a look at the ROS graph (remember to click on the refresh button) and you will find that it reflects what is happening:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1376 image-border" src="img/a16bfec5-d221-4e4e-8c10-5bfa81673fcc.png" style="width:22.33em;height:3.67em;"/></p>
<p>Bear in mind that <kbd>rqt_graph</kbd> will give you very useful information when debugging the code, for example, detecting any mistakes in the topic names. Take a look at the following figure, where multiplication by 2 does not work because <kbd>/topic_publisher</kbd> is subscribed to the <kbd>count</kbd> topic (note that the end <kbd>r</kbd> character is missing). The nodes are disconnected from one another, and the wrongly typed topic, which is not listened to by anyone, does not appear:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-1377 image-border" src="img/45629828-fd88-4178-bc7b-9f7108aabb5f.png" style="width:17.00em;height:7.75em;"/></p>
<p>In the next section, we will provide an overview of the extension of the ROS package system.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Using publicly available packages for ROS</h1>
                
            
            
                
<p>ROS-contributed packages are indexed on the official website at <a href="http://www.ros.org/browse/list.php">http://www.ros.org/browse/list.php</a>.</p>
<p>As of July 2018, ROS Indigo (the distribution released for Ubuntu 14.04 LTS) has more than 2,900 packages, while ROS Kinetic (2016, Ubuntu 16.04 LTS) has over 1,600. Some of the more popularly downloaded ones include the following:</p>
<ul>
<li><kbd>rviz</kbd> (<a href="http://wiki.ros.org/rviz">http://wiki.ros.org/rviz</a>): The 3D visualization tool for ROS. You will start using this in <a href="742e6846-70e4-4bd4-8576-f3e4f445df3f.xhtml" target="_blank">Chapter 4</a>, <em>Creating the Virtual Two-</em><em>Wheeled ROS Robot</em>.</li>
<li><kbd>gazebo_ros_pkgs</kbd> (<a href="http://wiki.ros.org/gazebo_ros_pkgs">http://wiki.ros.org/gazebo_ros_pkgs</a>): This allows you to use the Gazebo 3D simulator from inside ROS. We will introduce Gazebo in <a href="74284adc-e0d7-4e40-a54b-e2e447b8e2fe.xhtml" target="_blank">Chapter 5</a>, <em>Simulating Robot Behavior with Gazebo</em>.</li>
<li><kbd>sensor-msgs</kbd> (<a href="http://wiki.ros.org/sensor_msgs">http://wiki.ros.org/sensor_msgs</a>): This is a package that defines messages for commonly used sensors, such as cameras and scanning laser rangefinders.</li>
<li><kbd>tf2</kbd> (<a href="http://wiki.ros.org/tf2">http://wiki.ros.org/tf2</a>): This is the package that deals with the transformation of coordinates between the many reference systems used in the environment.</li>
<li><kbd>laser-geometry</kbd> (<a href="http://wiki.ros.org/laser_geometry">http://wiki.ros.org/laser_geometry</a>): This makes it possible to transform a 2D laser scan into a point cloud for use in navigation.</li>
</ul>
<p>This should give you a neat view of what programming in ROS will mean for you. In other words, integrate software developed by others (that is, packages) and make them work together—by designing a coherent ROS graph—to build up the functionality you wish your robot to have.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we introduced ROS and practiced with simple examples in order to help you understand the architecture of ROS. The top-level entity is the workspace, which is an isolated environment for building and running your software.</p>
<p>The workspace is constituted by ROS packages, that is, premade pieces of software that provide specific functionalities to integrate into your robot. Following this, catkin is the tool used to build the software each time you include new packages in your workspace.</p>
<p>The node is the basic entity in ROS and holds the functional pieces of code that make the robot work. A collection of related nodes providing specific functionalities constitute a ROS package. <strong>roscore</strong>, the process that runs the master node, is the one that allows each node to be capable of finding others by subscribing to the published topics. <strong>roscore</strong> also manages the database for the ROS parameters.</p>
<p>Communication between nodes is possible thanks to topics, the channels—edges of the ROS graph—through which the exchanged information flows. When a node needs to use the information of a topic, it does so by subscribing to it.</p>
<p>In the next chapter, you will learn how to build a virtual model of a differential drive robot, one that emulates GoPiGo3 characteristics. The chapter will also provide you with the methodology to test your code first with the virtual robot, and then install and execute it in the physical robot.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Questions</h1>
                
            
            
                
<ol>
<li>What is the top-level component in a ROS environment?</li>
</ol>
<p class="mce-root" style="padding-left: 60px">A) Package<br/>
B) Workspace<br/>C) ROS graph</p>
<ol start="2">
<li>What is the purpose of the roscore process?</li>
</ol>
<p class="mce-root" style="padding-left: 60px">A) To allow a node to communicate with others and manage the robot parameters<br/>
B) To provide a master node for driving all other nodes in the graph<br/>C) To allow ROS nodes to be found from outside of the LAN</p>
<ol start="3">
<li>Mark the correct sentence: A node can __ .</li>
</ol>
<p class="mce-root" style="padding-left: 60px">A) only publish topics or only subscribe to topics<br/>
B) publish topics and subscrib to topics at the same time<br/>C) publish topics and/or subscribe to other topics</p>
<ol start="4">
<li>What happens if one node fails to execute its program?</li>
</ol>
<p class="mce-root" style="padding-left: 60px">A) Some functions of the robot will fail<br/>
B) The robot will not work<br/>C) The topics it publishes will be set to undefined</p>
<ol start="5">
<li>Mark the incorrect sentence: The way to identify a message in a published topic is __.</li>
</ol>
<p class="mce-root" style="padding-left: 60px">A) to launch a node that publishes data in such topic<br/>
B) to issue the <kbd>$ rostopic echo &lt;/topic_name&gt;</kbd> command <br/>C) to write a node that subscribes to that topic</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Further reading</h1>
                
            
            
                
<p>To go deeper into the concepts we have explained in this chapter, you can follow the links and tutorials:</p>
<ul>
<li class="mce-root">ROS tutorial<em>s:</em><strong> </strong><a href="http://wiki.ros.org/ROS/Tutorials">http://wiki.ros.org/ROS/Tutorials</a> (sections 1 through 6)</li>
<li class="mce-root"><em>ROS Robotics By Example, Second Edition, Fairchild C</em>., <em>Harman</em>, <em>Packt Publishing</em>, T. L. (2017), <em>Chapter 1, Getting Started with ROS:</em> <a href="https://www.packtpub.com/hardware-and-creative/ros-robotics-example-second-edition" target="_blank">https://www.packtpub.com/hardware-and-creative/ros-robotics-example-second-edition</a>.</li>
<li class="mce-root"><em>Programming Robots with ROS</em>, <em>Quigley M., Gerkey B., Bill Smart B</em>. (2015), <em>First Edition, O'Reilly</em>: <a href="http://shop.oreilly.com/product/0636920024736.do">http://shop.oreilly.com/product/0636920024736.do</a> (<em>Chapter 2</em>, <em>Preliminaries,</em> and <em>Chapter 3</em>, <em>Topics)</em>.</li>
</ul>


            

            
        
    </body></html>