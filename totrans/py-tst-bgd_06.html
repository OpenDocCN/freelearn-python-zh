<html><head></head><body><div class="chapter" title="Chapter&#xA0;6.&#xA0;Running Your Tests: Follow Your Nose"><div class="titlepage"><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Running Your Tests: Follow Your Nose</h1></div></div></div><p>
<span class="emphasis"><em>So far, we've talked a lot about how to write tests, but we haven't said much about how to run them. We've had to explicitly tell Python which tests to run, and we've had the either worry about which version of Python we were using (in the case of doctest) or put an <code class="literal">if __name__ == '__main__'</code> inside every module (for unittest). Clearly, there's room for improvement, when it comes to running tests.</em></span>
</p><p>In this chapter we shall:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Learn about a Python tool called Nose, which automatically finds and executes tests</li><li class="listitem" style="list-style-type: disc">Learn how to make Nose find and execute doctest tests</li><li class="listitem" style="list-style-type: disc">Learn how to make Nose find and execute unittest tests</li><li class="listitem" style="list-style-type: disc">Learn how to use Nose's internal test framework</li></ul></div><p>So let's get on with it!</p><div class="section" title="What is Nose?"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec47"/>What is Nose?</h1></div></div></div><a class="indexterm" id="id302"/><p>Nose is a tool for finding and running all of your tests, in one easy step. It finds tests in multiple files, organizes them, runs them, and presents you with a nice report at the end. You don't have to put any special code in your files to make the tests runnable and you don't have to worry about which Python version you're running, unless your tests make use of recently added features to the language. Nose understands doctest and unittest tests; it even adds a few features to both.</p></div></div>
<div class="section" title="Installing Nose"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec48"/>Installing Nose</h1></div></div></div><a class="indexterm" id="id303"/><p>At the time of this writing, Nose's home page is <a class="ulink" href="http://code.google.com/p/python-nose/">http://code.google.com/p/python-nose/</a>, with downloads available at <a class="ulink" href="http://code.google.com/p/python-nose/downloads/list">http://code.google.com/p/python-nose/downloads/list</a>. Go ahead and download the latest version, and uncompress it into a temporary directory. If you're using Windows, you'll need a program such as 7-Zip (<a class="ulink" href="http://7-zip.org/">http://7-zip.org/</a>) to uncompress the file; Linux and Mac users won't need any special software.</p><p>After uncompressing Nose, we need to install it. Everything we had to consider when installing Mocker applies here too: If you installed Python, you can just change to the Nose directory and type:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ python setup.py install</strong></span>
</pre></div><p>If you didn't install Python, but you're using version 2.6 or higher, you can instead type:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ python setup.py install --user </strong></span>
</pre></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note20"/>Note</h3><p>If you go for the <code class="literal">--user</code> installation, you might need to add a directory to the search path of your operating system. You'll know you need to if you can't run the <code class="literal">nosetests</code> program after installing it. On Linux or Mac, the directory that you need to add is <code class="literal">~/.local/bin</code>, while on Windows it's <code class="literal">%APPDATA%\Python\Scripts</code>. Additionally, on Windows you may need to create a file called <code class="literal">nosetests.bat</code> in the <code class="literal">%APPDATA%\Python\Scripts directory</code>, containing the line: <code class="literal">@python %APPDATA%\Python\Scripts\nosetests.</code>
</p><p>Sometimes, a tool called <code class="literal">easy_install</code> can simplify the installation process of Python modules and packages. If you want to give it a try, download and install setuptools from <a class="ulink" href="http://pypi.python.org/pypi/setuptools">http://pypi.python.org/pypi/setuptools</a>, and then run the command easy_install nose. Once that command is executed, you should be ready to use Nose.</p></div></div><a class="indexterm" id="id304"/><p>After installing it, you should be able to run <code class="literal">nosetests</code> by typing its name on the command line. If you run it in an empty directory, you should see output similar to this:</p><div class="mediaobject"><img alt="Installing Nose" src="graphics/8846_06_01.jpg"/></div></div>
<div class="section" title="Organizing tests"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec49"/>Organizing tests</h1></div></div></div><p>A<a class="indexterm" id="id305"/>ll right, we've got Nose installed, so what's it good for? Nose looks through a directory's structure, finds the test files, sorts out the tests that they contain, runs the tests, and reports the results back to you. That's a lot of work that it saves you from having to do each time you want to run your tests (which should be often).</p><p>Nose recognizes test files based on their names. Any file whose name contains <code class="literal">test </code>or <code class="literal">Test</code> either at the beginning or following any of the characters <code class="literal">_</code>, <code class="literal">.</code>, or <code class="literal">–</code> (this is often referred to as "underscore", dot, or dash) is recognized as a file that contains unittest <code class="literal">TestCase</code>s (or Nose's own test functions, which we'll talk about later) which should be executed. Any directory whose name matches the same pattern is recognized as a directory that might contain tests, and so should be searched for test files. Nose can find and execute doctest tests as well, either embedded in docstrings or written in separate test files. By default, it won't look for doctest tests unless we tell it to. We'll see how to change the default shortly.</p><p>Since Nose is so willing to go looking for our tests, we have a lot of freedom with respect to how we organize them. It often turns out to be a good idea to separate all of the tests into their own directory, or for larger projects into a whole tree of directories. A big project can end up having thousands of tests, so organizing them for easy navigation is a big benefit. If doctests are being used as documentation, as well as testing, it's probably a good idea to store them in yet another separate directory, with a name that communicates that they are documentary. For a moderately-sized project, the recommended structure might look like the following:</p><div class="mediaobject"><img alt="Organizing tests" src="graphics/8846_06_02.jpg"/></div><p><a class="indexterm" id="id306"/>That structure is only a recommendation (it's for your benefit, not for Nose's). If a different structure would make things easier for you, go ahead and use it.</p></div>
<div class="section" title="Time for action &#x2013; organizing tests from previous chapters"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec50"/>Time for action – organizing tests from previous chapters</h1></div></div></div><p><a class="indexterm" id="id307"/>We're going to take our tests from the previous chapters and organize them all into a tree of directories. Then we'll use Nose to run them all.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create a directory to hold our code and tests; you can choose any name for it, but I'll refer to it as <code class="literal">project</code> here.</li><li class="listitem">Put <code class="literal">pid.py</code>, <code class="literal">operations.py</code> and <code class="literal">testable.py</code> inside of <code class="literal">project</code>. When we run <code class="literal">nosetests</code> in the <code class="literal">project</code> directory, modules (and packages) stored in <code class="literal">project</code> will be accessible to all of the tests, no matter where the test is stored in the directory tree.</li><li class="listitem">Create a subdirectory called <code class="literal">test_chapter2</code>, and place the <code class="literal">test.txt</code> and <code class="literal">test.py</code> files from Chapter 2 in it.</li><li class="listitem">Create a subdirectory called <code class="literal">test_chapter3</code>, and place the final <code class="literal">pid.txt</code> file from Chapter 3 in it.</li><li class="listitem">Create a subdirectory called <code class="literal">test_chapter4</code>, and place the code from the Chapter 4 examples (if you have them) and <span class="emphasis"><em>Time for action</em></span> sections in it.</li><li class="listitem">Create a subdirectory called <code class="literal">test_chapter5</code>, and place the code from the Chapter 5 examples (if you have them) and <span class="emphasis"><em>Time for action</em></span> sections into it. Because Chapter 5 uses unittest tests, we also need to rename each of the files so that Nose will recognize them as test files. Good names for the files are:<div class="informalexample"><pre class="programlisting">
<code class="literal">test_equal_and_almost_equal.py</code>,  <code class="literal">test_fail.py</code>,  <code class="literal">test_mocker_test_case.py</code>,  <code class="literal">test_pid.py</code>,  <code class="literal">test_raises.py</code>,  <code class="literal">test_setup_teardown.py</code>,  <code class="literal">test_true_and_false.py.</code>
</pre></div></li><li class="listitem">Now that you have the tests all put together and organized, let's run them. To do that, change to the <code class="literal">project</code> directory and type:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ nosetests --with-doctest --doctest-extension=txt -v</strong></span>
</pre></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note21"/>Note</h3><p>You can leave off the <code class="literal">-v</code> if you want. All it does is to tell Nose to give a more detailed report of what it's doing.</p></div></div></li><li class="listitem">All of the tests should run. We expect to see a few failures, since some of the tests from previous chapters were intended to fail, for illustrative purposes. There's one failure though, that we need to consider:<div class="mediaobject"><img alt="Time for action – organizing tests from previous chapters" src="graphics/8846_06_03.jpg"/></div></li><li class="listitem">The first part of that error report can be safely ignored: it just means that the whole doctest file is being treated as a failing test by Nose. The useful information comes in the second part of the report. It's telling us that where we expected to get a previous time of 1.0, we're instead getting a very large number (which will be different, and larger, when you run the test for yourself, since it happens to represent the time in seconds since a point <a class="indexterm" id="id308"/>several decades in the past). What's going on? Didn't we replace <code class="literal">time.time</code> for that test with a mock? Let's take a look at the relevant part of <code class="literal">pid.txt</code>:<div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; import time
&gt;&gt;&gt; real_time = time.time
&gt;&gt;&gt; time.time = (float(x) for x in xrange(1, 1000)).next
&gt;&gt;&gt; import pid
&gt;&gt;&gt; controller = pid.PID(P = 0.5, I = 0.5, D = 0.5, setpoint = 0,
...                      initial = 12)
&gt;&gt;&gt; controller.gains
(0.5, 0.5, 0.5)
&gt;&gt;&gt; controller.setpoint
[0.0]
&gt;&gt;&gt; controller.previous_time
1.0</pre></div></li><li class="listitem">We mocked <code class="literal">time.time</code>, but we did it the ad hoc way instead of by using Mocker's <code class="literal">replace</code> method. This means that modules which did a <code class="literal">from</code> <code class="literal">time</code> <code class="literal">import</code> <code class="literal">time</code> and were imported before the test file is executed will have imported the real <code class="literal">time</code> function, and won't know about our mock. So, was <code class="literal">pid.py</code> imported by some other thing, before <code class="literal">pid.txt</code> imported it? As it happens, it was: Nose itself imported it when it was scanning for tests to execute. If we're using Nose, we can't count on our import statements actually being the first to import any given module. We can fix the problem easily, though, by using Mocker (Note that we're only looking at the first test in the file here. There is another test that also needs to be fixed in the same way):<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt;&gt;&gt; from mocker import Mocker</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; mocker = Mocker()</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; mock_time = mocker.replace('time.time')</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; t = mock_time()</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; mocker.result(1.0)</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; mocker.replay()</strong></span>
<span class="strong"><strong>&gt;&gt;&gt; import pid</strong></span>
&gt;&gt;&gt; controller = pid.PID(P = 0.5, I = 0.5, D = 0.5, setpoint = 0,
...                      initial = 12)
&gt;&gt;&gt; controller.gains
(0.5, 0.5, 0.5)
&gt;&gt;&gt; controller.setpoint
[0.0]
&gt;&gt;&gt; controller.previous_time
1.0
&gt;&gt;&gt; controller.previous_error
-12.0
&gt;&gt;&gt; controller.integrated_error
0.0
&gt;&gt;&gt; mocker.restore()
&gt;&gt;&gt; mocker.verify()</pre></div></li><li class="listitem">Now<a class="indexterm" id="id309"/> when we use nosetests to run the tests again, the only failures are the expected ones. Here's the overview that Nose prints because we passed the <code class="literal">-v</code> command line option:<div class="mediaobject"><img alt="Time for action – organizing tests from previous chapters" src="graphics/8846_06_04.jpg"/></div></li></ol></div><div class="section" title="What just happened?"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec73"/>
<span class="emphasis"><em>What just happened?</em></span>
</h2></div></div></div><p>We ran all of those tests, with a single command. Pretty good, right? We're getting to the point now where testing is becoming broadly useful.</p><p>Thanks to Nose, we don't need those goofy <code class="literal">if</code> <code class="literal">__name__ == '__main__'</code> blocks at the end of each unittest file, and we don't need to memorize any arcane commands to execute the doctest files. We can store our tests in a separate and well-organized directory structure, and run them all with a single, quick, and simple command. We can also easily run a subset of our tests, by passing the filenames, module names, or directories containing the tests that we want to run as command line parameters.</p><p>We also saw how hidden assumptions can break tests, just as they can break the code being tested. Until now, we've been assuming that when one of our tests imports a module, that's the first time the module has been imported. Some of our tests relied on that assumption to replace library objects with mocks. Now that we're dealing with running many tests aggregated together, with no guaranteed order of execution, that assumption wasn't reliable. On top of that, the module we had trouble with actually had to be imported to search it for tests, before any of our tests were run. That would have been a problem, except we already have a tool for replacing library objects, regardless of the <a class="indexterm" id="id310"/>order of imports. A quick switch of the affected tests to use Mocker and we're good to go.</p></div><div class="section" title="Finding doctests"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec74"/>Finding doctests</h2></div></div></div><p>The <a class="indexterm" id="id311"/>
<code class="literal">nosetests</code> command that we used in the previous section was fairly easy to understand, but it was still a bit long to type in all of the time. Instead of:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ nosetests --with-doctest --doctest-extension=txt -v</strong></span>
</pre></div><p>We'd really like to be able to just type:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ nosetests -v</strong></span>
</pre></div><p>Or even:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ nosetests</strong></span>
</pre></div><p>To execute our tests, and still have it find and execute all of our doctests.</p><p>Fortunately, it's a simple matter to tell Nose that we want it to use different defaults for the values of those command line switches. To do this, just create a configuration file called <code class="literal">nose.cfg</code> or <code class="literal">.noserc</code> (either name will work) in your home directory, and placing the following inside of it:</p><div class="informalexample"><pre class="programlisting">[nosetests]
with-doctest=1
doctest-extension=txt</pre></div><p>From now on, whenever you run <code class="literal">nosetests</code>, it will assume those options, unless you tell it otherwise. You don't have to type them on the command line any more. You can use the same trick for any option that Nose can accept on the command line.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note22"/>Note</h3><p>If you're a Windows user, you might not be sure what the phrase 'home directory' is supposed to refer to in this context. As far as Python is concerned, your home directory is defined by your environment variables. If <code class="literal">HOME</code> is defined, that's your home directory. Otherwise, if <code class="literal">USERPROFILE</code> is defined (it usually is, pointing at <code class="literal">C:\Documents and Settings\USERNAME</code>) then that's what is considered to be your home directory. Otherwise, the directory described by <code class="literal">HOMEDRIVE</code> and <code class="literal">HOMEPATH</code> (often <code class="literal">C:\</code>)is your home directory.</p></div></div></div><div class="section" title="Customizing Nose's search"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec75"/>Customizing Nose's search</h2></div></div></div><p><a class="indexterm" id="id312"/>We've said before that Nose looks for tests in directories and modules whose names start with <code class="literal">test</code> or <code class="literal">Test</code>, or contain a '<code class="literal">_</code>',<code class="literal"> </code>'<code class="literal">.</code>'<code class="literal">,</code> or '<code class="literal">-</code>' followed by <code class="literal">test</code> or <code class="literal">Test</code>. That's the default, but it's not actually the whole story.</p><p>If you know regular expressions, you can customize the pattern that Nose uses to look for tests. You do this by passing the <code class="literal">--include=REGEX</code> command line option or by putting <code class="literal">include=REGEX</code> in your <code class="literal">nose.cfg</code> or <code class="literal">.noserc</code>.</p><p>For example, if you do this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>nosetests --include="(?:^[Dd]oc)"</strong></span>
</pre></div><p>Nose will (in addition to looking for names as described above) also look for names that start with <code class="literal">doc</code> or <code class="literal">Doc</code>. That means you can call the directory containing your doctest files <code class="literal">docs</code>, <code class="literal">Documentation</code>, <code class="literal">doctests</code>, and so on, and Nose will still find it and run the tests. If <a class="indexterm" id="id313"/>you use this option often, you'll almost certainly want to add it to your configuration file, as described under the previous heading.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note23"/>Note</h3><p>The full syntax and use of regular expressions is a subject in itself, and has been the topic of many books. However, you can find everything you need, to do this sort of thing in the Python documentation at <a class="ulink" href="http://docs.python.org/library/re.html">http://docs.python.org/library/re.html</a>.</p></div></div></div><div class="section" title="Pop quiz – testing with Nose"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec76"/>Pop<a class="indexterm" id="id314"/> quiz – testing with Nose
</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">By <a class="indexterm" id="id315"/>running <code class="literal">nosetests --processes=4</code>, Nose can be made to launch four testing processes, which can provide a big performance gain if you're running the tests on a quad-core system. How would you make Nose always launch four testing processes, without being told on the command line?</li><li class="listitem">If some of your tests were stored in a directory called <code class="literal">specs</code>, how would you tell Nose that it should search that directory for tests?</li><li class="listitem">Which of the following will by default be recognized by Nose as possibly containing tests: <code class="literal">UnitTests</code>, <code class="literal">unit_tests</code>, <code class="literal">TestFiles</code>, <code class="literal">test_files</code>, <code class="literal">doctests</code>?</li></ol></div></div><div class="section" title="Have a go hero – nosing around"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec77"/>Have a go hero – nosing around</h2></div></div></div><p>Write some <code class="literal">doctest</code> and <code class="literal">unittest</code> tests for the following specification, and create a directory tree to contain them and the code that they describe. Write the code using the test-driven methodology, and use Nose to run the tests.</p><div class="informalexample"><pre class="programlisting">The graph module contains two classes: Node and Arc. An Arc is a connection between two Nodes. Each Node is an intersection of an arbitrary number of Arcs.

Arc objects contain references to the Node objects that the Arc connects, a textual identification label, and a "cost" or "weight", which is a real number.

Node objects contain references to all of the connected Arcs, and a textual identification label.

Node objects have a find_cycle(self, length) method which returns a list of Arcs making up the lowest cost complete path from the Node back to itself, if such a path exists with a length greater than 2 Arcs and less than or equal to the length parameter.

Node and Arc objects have a __repr__(self) method which returns a representation involving the identification labels assigned to the objects.</pre></div></div></div>
<div class="section" title="Nose and doctest"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec51"/>Nose and doctest</h1></div></div></div><p><a class="indexterm" id="id316"/>
<a class="indexterm" id="id317"/>
<a class="indexterm" id="id318"/> doesn't just support doctest, it actually enhances it. When you're using Nose, you can write test fixtures for your doctest files.</p><p>If you pass <code class="literal">--doctest-fixtures=_fixture</code> on the command line, Nose will go looking for a fixture file whenever it finds a doctest file. The name of the fixture file is based on the name of the doctest file and is calculated by appending the doctest fixture suffix (in other words, the value of <code class="literal">doctest-fixtures</code>) to the main part of the doctest file name, and then adding <code class="literal">.py</code> to the end. For example, if Nose found a doctest file called <code class="literal">pid.txt</code>, and had been told that <code class="literal">doctest-fixtures=_fixture</code>, it would try to find the test fixture in a file called <code class="literal">pid_fixture.py</code>.</p><p>The <a class="indexterm" id="id319"/>
<a class="indexterm" id="id320"/>test fixture file for a doctest is very simple: it's just a Python module that contains a <code class="literal">setup()</code> or <code class="literal">setUp()</code> function and a <a class="indexterm" id="id321"/>
<a class="indexterm" id="id322"/><code class="literal">teardown()</code> or <code class="literal">tearDown()</code> function. The setup function is executed before the doctest file, and the teardown function is executed after.</p><p>The fixture operates in a different namespace to the doctest file, so none of the variables that get defined in the fixture module are visible in the actual tests. If you want to share variables between the fixture and the test, you'll probably want to do it by making a simple little module to hold the variables, which you can import into both the fixture and the test.</p><p>Mocker replacements work fine when done in a doctest fixture. As long as you don't <code class="literal">restore()</code> them during the setup (and why would you do a silly thing like that?) then they'll still be in place when the test uses the replaced object.</p></div>
<div class="section" title="Time for action &#x2013; creating a fixture for a doctest"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec52"/>Time for action – creating a fixture for a doctest</h1></div></div></div><p><a class="indexterm" id="id323"/>We'll provide a mock <code class="literal">time.time()</code> in our test fixture and use it in our doctest.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create a file called <code class="literal">times.txt</code> containing the following doctest code:<div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; from time import time

This isn't a reasonable test for any purpose, but it serves to
illustrate a test that can't work without a mock object in place.

&gt;&gt;&gt; '%0.1f' % time()
'1.0'
&gt;&gt;&gt; '%0.1f' % time()
'1.1'
&gt;&gt;&gt; '%0.1f' % time()
'1.2'</pre></div></li><li class="listitem">Run the doctest file using Nose, and the following screen gets displayed:<div class="mediaobject"><img alt="Time for action – creating a fixture for a doctest" src="graphics/8846_06_05.jpg"/></div></li><li class="listitem">Unless your computer's clock was reset to the beginning of the epoch at just the right moment, the doctest failed. We need a mock to replace <code class="literal">time.time()</code> if we want these tests to pass reliably. Create a file called <code class="literal">times_fixture.py</code> and insert the following Python code:<div class="informalexample"><pre class="programlisting">from mocker import Mocker

mocker = Mocker()

def setup():
    fake_time = mocker.replace('time.time')

    fake_time()
    mocker.result(1.0)
    fake_time()
    mocker.result(1.1)
    fake_time()
    mocker.result(1.2)

    mocker.replay()

def teardown():
    mocker.restore()
    mocker.verify()</pre></div></li><li class="listitem">Now <a class="indexterm" id="id324"/><a class="indexterm" id="id325"/>when we run Nose and tell it how to find doctest fixtures, the doctest passes, because it's using the mock that we set up in the fixture:<div class="mediaobject"><img alt="Time for action – creating a fixture for a doctest" src="graphics/8846_06_06.jpg"/></div></li><li class="listitem">If you use this facility often, it makes sense to add <code class="literal">doctest-fixtures=_fixture</code> to your Nose configuration file.</li></ol></div></div>
<div class="section" title="Nose and unittest"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec53"/>Nose and unittest</h1></div></div></div><p>Nose <a class="indexterm" id="id326"/>
<a class="indexterm" id="id327"/>
<a class="indexterm" id="id328"/>enhances unittest, by providing test fixtures at the package and module levels. The package setup function is run before any of the tests in any of the modules in a package, while the teardown function is run after all of the tests in all of the modules in the package have completed. Similarly, the module setup is run before any of the tests in a given module execute, and the module teardown is executed after all of the tests in the module have been executed.</p></div>
<div class="section" title="Time for action &#x2013; creating a module fixture"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec54"/>Time <a class="indexterm" id="id329"/>
<a class="indexterm" id="id330"/>for action – creating a module fixture
</h1></div></div></div><p>We'll <a class="indexterm" id="id331"/>build a test module with a module-level fixture. In the fixture, we'll replace the <code class="literal">datetime.date.today</code> function, which normally returns an object representing the current date. We want it to return a specific value, so that our tests can know what to expect.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create a directory called <code class="literal">tests</code>. We'll use this directory in this <span class="emphasis"><em>Time for action</em></span>, as well as in the next one.</li><li class="listitem">Within the <code class="literal">tests</code> directory, create a file called <code class="literal">module_fixture_tests.py</code> containing the following code:<div class="informalexample"><pre class="programlisting">from unittest import TestCase
from mocker import Mocker
from datetime import date

mocker = Mocker()

def setup():
    fake_date = mocker.replace(date)

    fake_date.today()
    mocker.result(date(year = 2009, month = 6, day = 12))
    mocker.count(1, None)

    mocker.replay()

def teardown():
    mocker.restore()
    mocker.verify()

class first_tests(TestCase):
    def test_year(self):
        self.assertEqual(date.today().year, 2009)

    def test_month(self):
        self.assertEqual(date.today().month, 6)

    def test_day(self):
        self.assertEqual(date.today().day, 12)

class second_tests(TestCase):
    def test_isoformat(self):
        self.assertEqual(date.today().isoformat(), '2009-06-12')</pre></div></li><li class="listitem">Notice that there are two <code class="literal">TestCase</code> classes in this module. Using pure unittest, we'd have to duplicate the fixture code in each of those classes.</li><li class="listitem">Go ahead and run the tests by moving to the directory that contains the <code class="literal">tests</code> directory and typing:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ nosetests</strong></span>
</pre></div></li><li class="listitem"><a class="indexterm" id="id332"/>Nose will recognize tests as a directory that may contain tests (because of the directory name), find the <code class="literal">module_fixtures_tests.py</code> file, run the <code class="literal">setup</code> function, run all of the tests, and then run the <code class="literal">teardown</code> function. There won't be much to see though, aside from a simple report of how many tests passed.</li></ol></div><div class="section" title="What just happened?"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec78"/>
<span class="emphasis"><em>What just happened?</em></span>
</h2></div></div></div><p>We saved ourselves some time and effort by using a second 'layer' of test fixtures, which wrap around entire test modules instead of single test methods. By doing this, we saved ourselves from duplicating the fixture code inside every test class in the module, but this savings comes with a cost. The setup and teardown aren't run before and after each test, as normal test fixtures are. Instead, all of the tests in the module happen between a single module-level setup/teardown pair, which means that if a test does something that affects the environment created by the setup function, it won't be undone before the next test runs. In other words, isolation of tests is not guaranteed with respect to the environment created by a module-level fixture.</p><p>Now we'll expand on the previous <span class="emphasis"><em>Time for action</em></span> by including a package-level test fixture. Like the module-level test fixture, this is a labor-saving feature of Nose. </p></div></div>
<div class="section" title="Time for action &#x2013; creating a package fixture"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec55"/>Time for action – creating a package fixture</h1></div></div></div><a class="indexterm" id="id333"/><p>Now we'll create a fixture that wraps around all the test modules in an entire package.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Add a new file called <code class="literal">__init__.py</code> in the <code class="literal">tests</code> directory that we created in the last <span class="emphasis"><em>Time for action</em></span> section. (That's two underbars, the word 'init, and two more underbars). The presence of this file tells Python that the directory is a package. Place the following code inside of <code class="literal">__init__.py</code> in the <code class="literal">tests</code> directory:<div class="informalexample"><pre class="programlisting">from mocker import Mocker
from datetime import datetime

mocker = Mocker()

def setup():
    fake_datetime = mocker.replace(datetime)

    fake_datetime.now()
    mocker.result(datetime(year = 2009, month = 6, day = 12,
                           hour = 10, minute = 15, second = 5))
    mocker.count(1, None)


    mocker.replay()

def teardown():
    mocker.restore()
    mocker.verify()</pre></div><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="note24"/>Note</h3><p>It's fairly common that <code class="literal">__init__.py</code> files are completely empty, but they're a perfect place for code that is general to an entire package, so that's where Nose looks for a package-level fixture.</p></div></div></li><li class="listitem"><a class="indexterm" id="id334"/>Add a new file called <code class="literal">package_fixtures_tests.py</code> to the <code class="literal">tests</code> directory, with the following contents:<div class="informalexample"><pre class="programlisting">from unittest import TestCase
from datetime import datetime

class first_tests(TestCase):
    def test_year(self):
        self.assertEqual(datetime.now().year, 2009)

    def test_month(self):
        self.assertEqual(datetime.now().month, 6)

    def test_day(self):
        self.assertEqual(datetime.now().day, 12)

    def test_hour(self):
        self.assertEqual(datetime.now().hour, 10)

    def test_minute(self):
        self.assertEqual(datetime.now().minute, 15)

    def test_second(self):
        self.assertEqual(datetime.now().second, 5)</pre></div></li><li class="listitem">Add the following code to the already-existing <code class="literal">module_fixtures_tests.py</code> (We could place it in its own file too. The point is placing it in a separate module from the tests in step 2, for you to see that the package test fixture is in place):<div class="informalexample"><pre class="programlisting">from datetime import datetime
class third_tests(TestCase):
    def test_isoformat(self):
        self.assertEqual(datetime.now().isoformat(), 
                         '2009-06-12T10:15:05')</pre></div></li><li class="listitem">Go ahead an run the tests again. (You won't see much output, but that means everything worked) Go to the directory containing <code class="literal">tests</code> and run the following:<a class="indexterm" id="id335"/><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ nosetests</strong></span>
</pre></div></li></ol></div><div class="section" title="What just happened?"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec79"/>
<span class="emphasis"><em>What just happened?</em></span>
</h2></div></div></div><p>We worked with yet another layer of test fixture, this time wrapping around all of the test modules in the <code class="literal">tests</code> directory. As you can see from looking at the code that we just wrote, the environment created by the package-level test fixture is available in every test in every module in the package.</p><p>Like module-level test fixtures, package-level test fixtures can be a big labor-saving shortcut. However, they don't provide you with the protection against communication between tests that <span class="emphasis"><em>real</em></span> test-level fixtures do.</p></div></div>
<div class="section" title="Nose's own testing framework"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec56"/>Nose's own testing framework</h1></div></div></div><a class="indexterm" id="id336"/><p>Nose supports two new kinds of tests: stand-alone test functions and non-TestCase test classes<a class="indexterm" id="id337"/>. It finds these tests by using the same pattern matching that it uses to find test modules. When looking through a module whose name matches the pattern, any functions or classes whose names also match the pattern, are assumed to be tests.</p></div>
<div class="section" title="Time for action &#x2013; using Nose-specific tests"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec57"/>Time for action – using Nose-specific tests</h1></div></div></div><a class="indexterm" id="id338"/><p>We'll write a few tests that demonstrate Nose's support for test functions and non-TestCase test classes.<a class="indexterm" id="id339"/>
</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create a file called <code class="literal">nose_specific_tests.py</code> with the following contents:<div class="informalexample"><pre class="programlisting">import sys
from sqlite3 import connect

class grouped_tests:
    def setup(self):
        self.connection = connect(':memory:')
        cursor = self.connection.cursor()
        cursor.execute('create table test (a, b, c)')
        cursor.execute('''insert into test (a, b, c) 
                          values (1, 2, 3)''')
        self.connection.commit()

    def teardown(self):
        self.connection.close()

    def test_update(self):
        cursor = self.connection.cursor()
        cursor.execute('update test set b = 7 where a = 1')

    def test_select(self):
        cursor = self.connection.cursor()
        cursor.execute('select * from test limit 1')
        assert cursor.fetchone() == (1, 2, 3)</pre></div></li><li class="listitem"><a class="indexterm" id="id340"/>Now add the following text to the same file, outside of the <code class="literal">grouped_tests</code> class:<div class="informalexample"><pre class="programlisting">def platform_setup():
    sys.platform = 'test platform'

def platform_teardown():
    global sys
    sys = reload(sys)

def standalone_test():
    assert sys.platform == 'test platform'

standalone_test.setup = platform_setup
standalone_test.teardown = platform_teardown</pre></div></li><li class="listitem">Run the tests, although as usual you don't want to see any output beyond a report of how many tests were executed:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ nosetests</strong></span>
</pre></div></li></ol></div><div class="section" title="What just happened?"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec80"/>
<span class="emphasis"><em>What just happened?</em></span>
</h2></div></div></div><a class="indexterm" id="id341"/><p>The <code class="literal">grouped_tests</code> class contains a test fixture (the <code class="literal">setup</code> and <code class="literal">teardown</code> methods) and two tests, but it's not a unittest <a class="indexterm" id="id342"/>
<code class="literal">TestCase</code> class. Nose recognized it as a test class because its name follows the same pattern that Nose looks for, when it checks module names to find test modules. It then looks through the class for a test fixture (and any test methods), and runs them appropriately.</p><p>Since the class isn't a <code class="literal">TestCase</code>, the tests don't have access to any of unittest's <code class="literal">assert</code> methods; Nose considers such a test to pass unless it raises an exception. Python has an <code class="literal">assert</code> statement that raises an exception if its expression is false, which is helpful for this sort of thing. It's not as nice as <code class="literal">assertEqual</code>, but it does the job in many cases.</p><p>We wrote another test in the function <code class="literal">standalone_test</code>. Like <code class="literal">grouped_tests</code>, <code class="literal">standalone_test</code> is recognized as a test by Nose because its name matches the same pattern that Nose uses to search for test modules. Nose runs <code class="literal">standalone_test</code> as a test, and reports a failure if it raises an exception.</p><a class="indexterm" id="id343"/><p>We were able to attach a test fixture to <code class="literal">standalone_test</code>, by setting its <code class="literal">setup</code> and <code class="literal">teardown</code> attributes to a pair of functions that we defined for that purpose. As usual, the setup function gets executed before the test function and the teardown function gets run after.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec58"/>Summary</h1></div></div></div><p>We learned a lot in this chapter about the Nose testing meta-framework.</p><p>Specifically, we covered:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">How Nose finds the files that contain tests, and how you can adapt the process to fit into your organization scheme</li><li class="listitem" style="list-style-type: disc">How to run all of your tests with Nose, whether they are doctest, unittest, or nose-specific tests</li><li class="listitem" style="list-style-type: disc">How Nose enhances the other frameworks with additional support for test fixtures</li><li class="listitem" style="list-style-type: disc">How to use Nose's test functions and non-TestCase test classes</li></ul></div><p>Now that we've learned about Nose and running all of our tests easily, we're ready to tackle a complete test-driven project—which is the topic of the next chapter.</p></div></body></html>