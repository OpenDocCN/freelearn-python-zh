<html><head></head><body><div class="chapter" title="Chapter&#xA0;12.&#xA0;Scripts, Modules, Packages, Libraries, and Applications"><div class="titlepage"><div><div><h1 class="title"><a id="ch12"/>Chapter 12. Scripts, Modules, Packages, Libraries, and Applications</h1></div></div></div><p>While it's easy to work with Python at the <a class="indexterm" id="id632"/>
<span class="strong"><strong>Read-Evaluate-Print Loop</strong></span> (<span class="strong"><strong>REPL</strong></span>) <code class="literal">&gt;&gt;&gt;</code> prompt, our real goal is to create Python application files. A Python file may be a script, which means it should be able to do some useful work when it's executed by the Python program. A file may be a module, which means that it is designed to be imported to provide useful definitions. A directory of Python modules is a <a class="indexterm" id="id633"/>
<span class="strong"><strong>package</strong></span>. These are formal definitions, implemented by the language.</p><p>More generic terms like<a class="indexterm" id="id634"/> <span class="strong"><strong>library</strong></span>, <span class="strong"><strong>application</strong></span>, or <span class="strong"><strong>framework</strong></span> aren't formalized by the language. We <a class="indexterm" id="id635"/>have<a class="indexterm" id="id636"/> ways to implement these common concepts in Python. We can think of a collection of modules or packages as a library. The <span class="emphasis"><em>Python Standard Library</em></span>, for example, is a large collection of modules and packages. An "application" will be at least a script. A more complex application may involve a script plus several additional modules and packages. A framework will be a Python application into which we'll inject our customized modules or packages. Many frameworks will also include non-Python files: a web framework may include a great deal of HTML and CSS; a GUI framework may include image files and fonts.</p><p>We'll look at creating and running script files. We'll also look at creating modules and packages of modules. Finally, we'll look at a very clever Python feature that allows us to write a script that can also be used as a module. This design pattern allows us to build composite applications that are based on other applications.</p><div class="section" title="Script file rules"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec105"/>Script file rules</h1></div></div></div><p>A Python script file<a class="indexterm" id="id637"/> must adhere to only one simple rule: <span class="emphasis"><em>it must be pure text</em></span>. In some cases, a poorly-chosen filename can lead to problems, so we'll add two recommendations that are often helpful:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The content must be pure text; ideally encoded in UTF-8, although ASCII is also popular.</li><li class="listitem" style="list-style-type: disc">The filename should follow the Python identifier rules. It should start with a letter and use only letters, digits, and the <code class="literal">_</code> character. Filenames that begin and end with <code class="literal">__</code> (two underscores) are reserved and have special meanings for Python.</li><li class="listitem" style="list-style-type: disc">The extension should be <code class="literal">.py</code>.</li></ul></div><p>The <a class="indexterm" id="id638"/>two additional recommendations are essential for writing modules and packages, but are not required to write a simple script.</p><p>A <a class="indexterm" id="id639"/>script is simply a sequence of statements; it's identical to what we might do at the REPL prompt with only one difference: a script has no implicit printed output. We must use the <code class="literal">print()</code> function in a script to see any results. In larger applications, we often use the <code class="literal">logging</code> module to produce more sophisticated output. In some cases, we'll carefully replace all the <code class="literal">print()</code> functions we put into an early technology spike with <code class="literal">logging.debug()</code> functions as our application matures.</p><p>To run a script, we <a class="indexterm" id="id640"/>need to provide it as input to the Python program. We'll look at three common ways to do this.</p></div></div>
<div class="section" title="Running a script by the filename"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec106"/>Running a script by the filename</h1></div></div></div><p>The <a class="indexterm" id="id641"/>most common way to run a script is to provide the filename to the Python command. Let's assume we have a file with the unpleasant name of <code class="literal">ch12_script1.py</code> in a directory named <code class="literal">Chapter_12</code>.</p><p>In Linux and Mac OS X, the full name will be <code class="literal">Chapter_12/ch12_script1.py</code>. In Windows, the full filename will be <code class="literal">Chapter_12\ch12_script1.py</code>. We'll stick with the Linux standard filenames for the remaining examples.</p><p>Here's how we can run a script by giving the filename:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>MacBookPro-SLott:Code slott$ python3 Chapter_12/ch12_script1.py</strong></span>
<span class="strong"><strong>Temperature °C: 8</strong></span>
<span class="strong"><strong>C=8°, F=46°</strong></span>
</pre></div><p>This output shows the OS prompt. The <code class="literal">python3</code> command that we entered is highlighted. The prompts and the outputs from the script are also shown. This example is typical for an OS that uses Python 2 internally; we have to distinguish our new Python 3 from the OS's internal <code class="literal">python</code> command.</p><p>The application prompted us, and we entered a temperature of 8. The output shows that 8°C is about 46°F. We'll need to wear a coat.</p><p>The script file, <code class="literal">ch12_script1.py</code>, looks like this:</p><div class="informalexample"><pre class="programlisting">c= float(input("Temperature °C: "))
f = 32+9*c/5
print("C={c:.0f}°, F={f:.0f}°".format(c=c,f=f))</pre></div><p>The<a class="indexterm" id="id642"/> script uses the <code class="literal">input()</code> function to prompt an interactive user at the console. The output is displayed with the simple <code class="literal">print()</code> function.</p><p>We've kept the script small to emphasize ways that scripts can be run. There are numerous <span class="strong"><strong>user experience</strong></span> (<span class="strong"><strong>UX</strong></span>) issues<a class="indexterm" id="id643"/> with this, but that is not the focus of this section.</p><div class="section" title="Running a script by its module name"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec96"/>Running a script by its module name</h2></div></div></div><p>In most<a class="indexterm" id="id644"/> cases, our scripts can either be installed in the <code class="literal">site-packages</code> directory inside the Python library, or we can extend the Python path using the <code class="literal">PYTHONPATH</code> environment variable to include the location of our scripts. Either of these approaches makes a script file visible on Python's search path.</p><p>To install a script in <code class="literal">site-packages</code>, we can rely on Python's <code class="literal">distutils</code> package. We'll create a <code class="literal">setup.py</code> file, which describes the module we'd like to install. We can then run <code class="literal">python3 setup.py</code> <code class="literal">install</code> to have our module placed into the <code class="literal">site-packages</code> directory. Installers like <code class="literal">pip</code> and <code class="literal">easy-install</code> require use of <code class="literal">distutils</code> following this standard pattern.</p><p>We can also locate the <code class="literal">site-packages</code> directory and manually copy our module into that directory. This location varies from OS to OS. This directory is the last item in the <code class="literal">sys.path</code> variable.</p><p>Setting the <code class="literal">PYTHONPATH</code> environment variable is another alternative. We can use the Linux <code class="literal">export</code> command to make a change to environment variables. We often put this in our <code class="literal">~/.bash_profile</code> file. For Windows, we have to make a change to the advanced system settings where the environment variables are set. We can easily create private libraries with many modules, made visible via the <code class="literal">PYTHONPATH</code> variable.</p><p>Once our module is visible on Python's search path, we can execute the module like this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>MacBookPro-SLott:Code slott$ python3 -m Chapter_12.ch12_script1</strong></span>
<span class="strong"><strong>Temperature °C: 8</strong></span>
<span class="strong"><strong>C=8°, F=46°</strong></span>
</pre></div><p>When we provide the <code class="literal">-m</code> option, we're naming a module to be executed. In this example, we've used a qualified name: <code class="literal">Chapter_12</code> is a package and <code class="literal">ch12_script1</code> is the module within that package. We'll look at packages in the later sections; packages are essentially the directories in which module files can be found.</p></div><div class="section" title="Running a script using OS shell rules"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec97"/>Running a script using OS shell rules</h2></div></div></div><p>The third way <a class="indexterm" id="id645"/>that we can run a script is by making the script file executable and including an OS association between the script file and the Python3 program.</p><p>In Linux and Mac OS X, the file association is set by the first line of the file. We'll often use something like this as the first line in a file, to associate a given <code class="literal">.py</code> file and the Python3 program:</p><div class="informalexample"><pre class="programlisting">#!/usr/bin/env python3</pre></div><p>This will use the OS <code class="literal">env</code> program to locate and start the <code class="literal">python3</code> environment. The shell will provide the entire file as input to the program named on a <code class="literal">#!</code> line. This means that the <code class="literal">env</code> program will be started with the script file as input. The <code class="literal">env</code> program will prepare the environment and then hand the file to the Python3 program.</p><p>To mark a file as executable in Linux and Mac OS X, we use the <code class="literal">chmod +x</code> command. We can do this to mark our script as executable:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>MacBookPro-SLott:Code slott$ chmod +x Chapter_12/ch12_script1.py</strong></span>
</pre></div><p>This command will add the execute, <code class="literal">x</code>, option to the file's mode. When we do an <code class="literal">ls -l</code>, we'll see this as part of the file's details.</p><p>In Windows, all files are considered executable. The association between file extension and program is done through the Windows Control Panel. The setting was put in place when you installed Python.</p><p>Once the file is marked as executable, we can run it simply by providing the name:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>MacBookPro-SLott:Code slott$ Chapter_12/ch12_script1.py</strong></span>
</pre></div><p>Under Windows, the file extension of <code class="literal">.py</code> is bound to the Python program, and Windows will launch Python providing this filename as input. The binding of filename to script is outside the application.</p><p>Under Linux and Mac OS X, the processing is based on the magical first line of the file. The Linux shell checks the file's mode to see that it's executable. It then reads the first few bytes of the file. In this case, the first few bytes are <code class="literal">#!</code>, which marks the file as a script. The first full line of a script includes the command that must be used to process this script. In this case, the command is <code class="literal">/usr/bin/env python3</code>. The shell launches this program with the given file as input.</p></div><div class="section" title="Choosing good script names"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec98"/>Choosing good script names</h2></div></div></div><p>Script names<a class="indexterm" id="id646"/> should be kept short and meaningful. As with filenames, it's generally best practice to avoid complex prefixes and suffixes. The Linux or Windows DOS commands provide some guidance on what makes a good (and bad) name for a script. One of the best examples is the <code class="literal">git</code> command, which has numerous subcommands. Rather than invent dozens of complex-looking names, <span class="strong"><strong>git</strong></span> <a class="indexterm" id="id647"/>uses a simple command name as a prefix.</p><p>The <a class="indexterm" id="id648"/>
<code class="literal">argparse</code> module, used <a class="indexterm" id="id649"/>for parsing command-line arguments, supports this nicely. We can define a few common arguments that apply to all subcommands. We can also define arguments that are unique to each subcommand.</p><p>In order to keep the code for this book organized by the publishing pipeline, the script names are long. The redundancy in these names (<code class="literal">Chapter_12/ch12_...</code>) is not the best practice, and should be avoided where possible. As with variable names and function names, script names should be kept reasonably short and meaningful.</p></div></div>
<div class="section" title="Creating a reusable module"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec107"/>Creating a reusable module</h1></div></div></div><p>In Python, the module <a class="indexterm" id="id650"/>is the unit of software reuse. When we have a feature that must appear in more than one script, we'll put this feature into a module and import that module into each script that shares the feature.</p><p>It's important to note two slightly different senses of the word "reuse" as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We can define a class hierarchy to achieve localized reuse within an application. Inheritance is an elegant way to share code among related objects. Often we'll define all of these related classes in a single module file.</li><li class="listitem" style="list-style-type: disc">We can define a module to achieve a less local reuse across applications.</li></ul></div><p>To create a module that can be imported, we merely have to be sure that a Python file is visible in a directory that's part of the Python search path. Since the local directory is always visible, we can create a module simply by creating a file in the current working directory.</p><p>A module designed for import should consist mostly of <code class="literal">import</code>, <code class="literal">class</code>, and <code class="literal">def</code> statements. We can also use assignment statements to create module global variables, but we need to be cautious of how much processing is done. Any name that's created (via assignment, <code class="literal">class</code>, <code class="literal">def</code>, or <code class="literal">import</code>) will be in that module's namespace.</p><p>A module is only imported once. The <code class="literal">import</code> implementation checks a global cache of loaded modules, visible as <code class="literal">sys.modules</code>, to see if the module is known. Because of this, a module that actually does some kind of processing will only do it once. After that, the import is ignored. This behavior makes it easy to create a global <span class="strong"><strong>Singleton</strong></span> object<a class="indexterm" id="id651"/> inside an imported module.</p><p>Examples of modules that do significant processing on <code class="literal">import</code> are <code class="literal">this</code> and <code class="literal">antigravity</code>. When we execute <code class="literal">import this</code> or <code class="literal">import antigravity</code>, these modules will immediately do some interesting processing. After having been imported once, they won't do this again. While handy in some specialized situations, it's not a general pattern to follow.</p><div class="note" style="" title="Note"><div class="inner"><h3 class="title"><a id="tip22"/>Tip</h3><p>We generally expect an <code class="literal">import</code> statement to provide definitions of classes, functions, and module global variables.</p><p>We don't generally expect an <code class="literal">import</code> statement to do useful processing.</p></div></div><p>A module<a class="indexterm" id="id652"/> may define a unique exception. We might want to create a generic exception class named <code class="literal">Error</code> in a module. It would look like this:</p><div class="informalexample"><pre class="programlisting">class Error(Exception): pass</pre></div><p>Because this name will be qualified by the module name when the module is imported, we are able to reference this exception via <code class="literal">some_module.Error</code>. It might look like this:</p><div class="informalexample"><pre class="programlisting">import some_module
try:
    some_module.some_function()
except some_module.Error as e:
    logger.exception("some_function broke: {0}".format(e))</pre></div><p>The module name, <code class="literal">some_module</code>, acts as a nice qualifier to show the origin of the <code class="literal">Error</code> class definition. We don't need to give the <code class="literal">Error</code> class a more complex, globally unique name.</p></div>
<div class="section" title="Creating a hybrid library/application module"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec108"/>Creating a hybrid library/application module</h1></div></div></div><p>A script <a class="indexterm" id="id653"/>may import modules, perhaps define some functions or classes, but it will always do the relevant processing. Our first example script had just three lines of relevant processing: two assignment statements, and a function statement that printed a result. This shows the Pythonic ideal of having programs without any boilerplate; we try to avoid syntax that's just overhead.</p><p>A possible downside of a perfectly clean approach to scripting is that it's difficult to create unit tests. Each unit test would have to invoke the script as a subprocess; something that can involve quite a bit of OS overhead. The goal of unit testing is to isolate each unit—each function, class, module, package, or script—so that it can be tested separately. Having the OS launch the script file doesn't seem to be properly isolated.</p><p>Also, as an application matures, a good script may become a component in a larger, and more comprehensive, application. It can become difficult to create a composite application from a script file. It's far easier to create composite processes from functions or classes.</p><p>This leads to the following suggested structure for a script:</p><div class="informalexample"><pre class="programlisting">def c_to_f():
    c= float(input("Temperature °C: "))
    f = 32+9*c/5
    print("C={c:.0f}°, F={f:.0f}°".format(c=c,f=f))

if __name__ == "__main__":
    c_to_f()</pre></div><p>We've <a class="indexterm" id="id654"/>taken our script and wrapped it with a <code class="literal">def</code> statement to make a function. We've then written an <code class="literal">if</code> statement that distinguishes between a main script and an imported module by examining the <code class="literal">__name__</code> variable. The <code class="literal">if</code> statement makes the following conditions:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">When a module is imported, Python sets the global variable <code class="literal">__name__</code> to the actual module name</li><li class="listitem" style="list-style-type: disc">When run as a main script, Python sets the global variable <code class="literal">__name__</code> to <code class="literal">__main__</code></li></ul></div><p>This pattern can be used to write library modules which run their own unit tests. We can include the following in a library module that is never used as a main script:</p><div class="informalexample"><pre class="programlisting">if __name__ == "__main__":
    import doctest
    doctest.testmod( verbose=1 )</pre></div><p>This will run all of the unit tests that are embedded in docstrings. We'll look more closely at testing in <a class="link" href="ch14.html" title="Chapter 14. Fit and Finish – Unit Testing, Packaging, and Documentation">Chapter 14</a>, <span class="emphasis"><em>Fit and Finish – Unit Testing, Packaging, and Documentation</em></span>.</p></div>
<div class="section" title="Creating a package"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec109"/>Creating a package</h1></div></div></div><p>A package<a class="indexterm" id="id655"/> is a directory that <a class="indexterm" id="id656"/>contains module files plus one additional file. Each package must have an <code class="literal">__init__.py</code> file. This file must be present and is often empty.</p><p>The poem, <span class="emphasis"><em>Zen of Python</em></span>, by Tim Peters, offers the following advice:</p><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Flat is better than nested.</em></span></p></blockquote></div><p>The idea is to organize Python applications into a flat collection of modules to the greatest extent possible. A deeply-nested, complex hierarchy of packages isn't considered helpful.</p><p>We can use a package in two ways. We can import a module that's part of a package. The standard library, for example, has an XML package with several XML parser modules. We can use import <code class="literal">xml.etree</code> to import the <code class="literal">etree</code> module from the XML package. In this case, the <code class="literal">__init__.py</code> file has a comment and a list of sub-packages.</p><p>In other cases, we can import the package, as a whole, as if the package were a module. When we write import collections, for example, we're really importing the module <code class="literal">collections/__init__.py</code>.</p><p>The <code class="literal">__init__.py</code> file <a class="indexterm" id="id657"/>is a top-level module for the package as a whole. It can be empty, in which case we can only pick specific modules from within the package. Or the <code class="literal">__init__.py</code> file may have content, allowing us to import the package as a single complex structure.</p></div>
<div class="section" title="Designing alternative implementations"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec110"/>Designing alternative implementations</h1></div></div></div><p>We can <a class="indexterm" id="id658"/>easily offer alternative implementations of a given feature. If we want more speed, more accuracy, or less memory use, we should be able to import an alternative definition of a given library.</p><p>We can compare the <code class="literal">math</code> and <code class="literal">cmath</code> modules for a concrete example of this principle. Here's an example of how they differ:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; import math
&gt;&gt;&gt; import cmath
&gt;&gt;&gt; math.sqrt(-1)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
ValueError: math domain error
&gt;&gt;&gt; cmath.sqrt(-1)
1j</pre></div><p>The <code class="literal">math</code> module includes a square root function, which we used as <code class="literal">math.sqrt()</code>. This produces only real-valued results, and must raise an exception when confronted with an expression that's not real-valued.</p><p>The <code class="literal">cmath</code> module also includes a square root function. The <code class="literal">cmath.sqrt()</code> function can return complex values instead of raising an exception. Since the packages are so similar, we can substitute one for the other in a variety of ways.</p><p>Both of these modules offer a similar set of function definitions. The components within the module have the same names. The modules, which are namespaces, have different names to distinguish the origin of a definition.</p><p>This technique is often used to support different platforms. We can create a package with platform-specific modules within the package. The package's top-level <code class="literal">__init__.py</code> can choose which module to import and provide the platform-specific definitions. We can also use this to write enterprise software that must run in different environments: development, quality assurance, and final production. A single package can include different configuration modules. The standard library <code class="literal">os</code> package demonstrates this concept.</p></div>
<div class="section" title="Seeing the package search path"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec111"/>Seeing the package search path</h1></div></div></div><p>The<a class="indexterm" id="id659"/> Python search path can be seen by importing the <code class="literal">sys</code> package to see <code class="literal">sys.path</code>:</p><div class="informalexample"><pre class="programlisting">&gt;&gt;&gt; import sys
&gt;&gt;&gt; sys.path
['', '/Library/Frameworks/Python.framework/Versions/3.3/lib/python3.3/site-packages/setuptools-2.0.2-py3.3.egg',
<span class="emphasis"><em>…, etc.</em></span>
'/Library/Frameworks/Python.framework/Versions/3.3/lib/python33.zip',
'/Library/Frameworks/Python.framework/Versions/3.3/lib/python3.3',
'/Library/Frameworks/Python.framework/Versions/3.3/lib/python3.3/plat-darwin',
'/Library/Frameworks/Python.framework/Versions/3.3/lib/python3.3/lib-dynload',
'/Library/Frameworks/Python.framework/Versions/3.3/lib/python3.3/site-packages']</pre></div><p>We've elided a number of lines from this output to show the essentials of how the standard library fits into the way we develop Python code. This list of places to search for modules is built by the <code class="literal">sites</code> package when Python starts running.</p><p>The zero-length directory name, <code class="literal">''</code>, is first. This means that the current working directory is the preferred place to locate modules. This allows us to import our own modules from the local directory. After our local directory, a number of locations are searched, ending with the <code class="literal">.../site-packages</code> directory.</p><p>The next group of names, starting with <code class="literal">setuptools-2.0.2-py3.3.egg</code>, is a list of all external packages added to this installation in the form of downloaded <code class="literal">.egg</code> files. The exact list will vary from installation to installation. These names are created by the <code class="literal">pip</code> and <code class="literal">easy_install</code> programs.</p><p>When we set the <code class="literal">PYTHONPATH</code> environment variable, those names are spliced into the path <span class="emphasis"><em>after</em></span> the various installed packages. The final group of names, starting with <code class="literal">python33.zip</code>, is a common list of modules that come with Python. The last entry lists the generic site-packages portion of the library. If you download a package and run the package's <code class="literal">setup.py</code> script, it is copied into this directory where it will be found by Python.</p><p>The <code class="literal">sys.path</code> object is a proper mutable list. We can dynamically change the path in our script files. This can make it difficult to determine all the modules that a script depends on. It's almost always clearer to explicitly depend on the modules being properly installed or the <code class="literal">PYTHONPATH</code> environment variable being set.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec112"/>Summary</h1></div></div></div><p>In this chapter, we've looked at the higher-level ways to organize software. A function contains many statements, a class contains many method functions, and a module can contain many classes and functions. A package can contain many modules.</p><p>We've looked at a number of ways of executing a Python script. We have a great deal of flexibility because there are many contexts in which we need to execute software. Generally, we'll focus on executing Python programs by module name rather than by filename. The distinction is tiny. Since a module must be on the search path, we can create a directory that contains the script and any supporting modules and libraries, and ensure that this directory is named on the <code class="literal">PYTHONPATH</code>.</p><p>We've looked at how we can create library modules that contain definitions and will be imported into other scripts. This is our primary method of reuse. We've also looked at how we can create a script, that is reusable as a library module. This supports unit testing as well as maturation of our software.</p><p>In <a class="link" href="ch13.html" title="Chapter 13. Metaprogramming and Decorators">Chapter 13</a>, <span class="emphasis"><em>Metaprogramming and Decorators</em></span>, we'll look at some more advanced programming techniques. These will allow us to create more sophisticated class and function definitions. We can use these design patterns to write more flexible and more reusable software.</p></div></body></html>