<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Objects in Python</h1>
                </header>
            
            <article>
                
<p>So, we now have a design in hand and are ready to turn that design into a working program! Of course, it doesn't usually happen this way. We'll be seeing examples and hints for good software design throughout the book, but our focus is object-oriented programming. So, let's have a look at the Python syntax that allows us to create object-oriented software.</p>
<p>After completing this chapter, we will understand the following:</p>
<ul>
<li>How to create classes and instantiate objects in Python</li>
<li>How to add attributes and behaviors to Python objects</li>
<li>How to organize classes into packages and modules</li>
<li>How to suggest that people don't clobber our data</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating Python classes</h1>
                </header>
            
            <article>
                
<p>We don't have to write much Python code to realize that Python is a very <em>clean</em> language. When we want to do something, we can just do it, without having to set up a bunch of prerequisite code. The ubiquitous <em>hello world</em> in Python, as you've likely seen, is only one line.</p>
<p>Similarly, the simplest class in Python 3 looks like this:</p>
<pre>class MyFirstClass: 
    pass </pre>
<p>There's our first object-oriented program! The class definition starts with the <kbd>class</kbd> keyword. This is followed by a name (of our choice) identifying the class, and is terminated with a colon.</p>
<div class="packt_infobox">The class name must follow standard Python variable naming rules (it must start with a letter or underscore, and can only be comprised of letters, underscores, or numbers). In addition, the Python style guide (search the web for <em>PEP 8</em>) recommends that classes should be named using <strong>CapWords</strong> notation (start with a capital letter; any subsequent words should also start with a capital).</div>
<p>The class definition line is followed by the class contents, indented. As with other Python constructs, indentation is used to delimit the classes, rather than braces, keywords, or brackets, as many other languages use. Also in line with the style guide, use four spaces for indentation unless you have a compelling reason not to (such as fitting in with somebody else's code that uses tabs for indents).</p>
<p>Since our first class doesn't actually add any data or behaviors, we simply use the <kbd>pass</kbd> keyword on the second line to indicate that no further action needs to be taken.</p>
<p>We might think there isn't much we can do with this most basic class, but it does allow us to instantiate objects of that class. We can load the class into the Python 3 interpreter, so we can interactively play with it. To do this, save the class definition mentioned earlier in a file named <kbd>first_class.py</kbd> and then run the <kbd>python -i first_class.py</kbd> command. The <kbd>-i</kbd> argument tells Python to <em>run the code and then drop to the interactive interpreter</em>. The following interpreter session demonstrates a basic interaction with this class:</p>
<pre><strong>&gt;&gt;&gt; a = MyFirstClass()</strong>
<strong>&gt;&gt;&gt; b = MyFirstClass()</strong>
<strong>&gt;&gt;&gt; print(a)</strong>
<strong>&lt;__main__.MyFirstClass object at 0xb7b7faec&gt;</strong>
<strong>&gt;&gt;&gt; print(b)</strong>
<strong>&lt;__main__.MyFirstClass object at 0xb7b7fbac&gt;</strong>
<strong>&gt;&gt;&gt;</strong>  </pre>
<p>This code instantiates two objects from the new class, named <kbd>a</kbd> and <kbd>b</kbd>. Creating an instance of a class is a simple matter of typing the class name, followed by a pair of parentheses. It looks much like a normal function call, but Python knows we're <em>calling</em> a class and not a function, so it understands that its job is to create a new object. When printed, the two objects tell us which class they are and what memory address they live at. Memory addresses aren't used much in Python code, but here, they demonstrate that there are two distinct objects involved.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding attributes</h1>
                </header>
            
            <article>
                
<p>Now, we have a basic class, but it's fairly useless. It doesn't contain any data, and it doesn't do anything. What do we have to do to assign an attribute to a given object?</p>
<p>In fact, we don't have to do anything special in the class definition. We can set arbitrary attributes on an instantiated object using dot notation:</p>
<pre>class Point: 
    pass 
 
p1 = Point() 
p2 = Point() 
 
p1.x = 5 
p1.y = 4 
 
p2.x = 3 
p2.y = 6 
 
print(p1.x, p1.y) 
print(p2.x, p2.y) </pre>
<p>If we run this code, the two <kbd>print</kbd> statements at the end tell us the new attribute values on the two objects:</p>
<pre><strong>5 4</strong>
<strong>3 6</strong></pre>
<p>This code creates an empty <kbd>Point</kbd> class with no data or behaviors. Then, it creates two instances of that class and assigns each of those instances <kbd>x</kbd> and <kbd>y</kbd> coordinates to identify a point in two dimensions. All we need to do to assign a value to an attribute on an object is use the <kbd>&lt;object&gt;.&lt;attribute&gt; = &lt;value&gt;</kbd> syntax. This is sometimes referred to as <strong>dot notation</strong>. You have likely encountered this same notation before when reading attributes on objects provided by the standard library or a third-party library. The value can be anything: a Python primitive, a built-in data type, or another object. It can even be a function or another class!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Making it do something</h1>
                </header>
            
            <article>
                
<p>Now, having objects with attributes is great, but object-oriented programming is really about the interaction between objects. We're interested in invoking actions that cause things to happen to those attributes. We have data; now it's time to add behaviors to our classes.</p>
<p>Let's model a couple of actions on our <kbd>Point</kbd> class. We can start with a <strong>method</strong> called <kbd>reset</kbd>, which moves the point to the origin (the origin is the place where <kbd>x</kbd> and <kbd>y</kbd> are both zero). This is a good introductory action because it doesn't require any parameters:</p>
<pre>class Point: 
<strong>    def reset(self):</strong> 
        self.x = 0 
        self.y = 0 
 
p = Point() 
<strong>p.reset()</strong> 
print(p.x, p.y) </pre>
<p>This <kbd>print</kbd> statement shows us the two zeros on the attributes:</p>
<pre><strong>0 0</strong>  </pre>
<p>In Python, a method is formatted identically to a function. It starts with the <kbd>def</kbd> <span>keyword </span>, followed by a space, and the name of the method. This is followed by a set of parentheses containing the parameter list (we'll discuss that <kbd>self</kbd> parameter in just a moment), and terminated with a colon. The next line is indented to contain the statements inside the method. These statements can be arbitrary Python code operating on the object itself and any parameters passed in, as the method sees fit.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Talking to yourself</h1>
                </header>
            
            <article>
                
<p>The one difference, syntactically, between methods and normal functions is that all methods have one required argument. This argument is conventionally named <kbd>self</kbd>; I've never seen a Python programmer use any other name for this variable (convention is a very powerful thing). There's nothing stopping you, however, from calling it <kbd>this</kbd> or even <kbd>Martha</kbd>.</p>
<p>The <kbd>self</kbd> argument to a method is a reference to the object that the method is being invoked on. We can access attributes and methods of that object as if it were any another object. This is exactly what we do inside the <kbd>reset</kbd> method when we set the <kbd>x</kbd> and <kbd>y</kbd> attributes of the <kbd>self</kbd> object.</p>
<div class="packt_infobox">Pay attention to the difference between a <strong>class</strong> and an <strong>object</strong> in this discussion. We can think of the <strong>method</strong> as a function attached to a class. The <strong>self</strong> parameter is a specific instance of that class. When you call the method on two different objects, you are calling the same method twice, but passing two different <strong>objects</strong> as the <strong>self</strong> parameter.</div>
<p>Notice that when we call the <kbd>p.reset()</kbd> method, we do not have to pass the <kbd>self</kbd> argument into it. Python automatically takes care of this part for us. It knows we're calling a method on the <kbd>p</kbd> object, so it automatically passes that object to the method.</p>
<p>However, the method really is just a function that happens to be on a class. Instead of calling the method on the object, we could invoke the function on the class, explicitly passing our object as the <kbd>self</kbd> argument:</p>
<pre><strong>&gt;&gt;&gt; p = Point() 
&gt;&gt;&gt; Point.reset(p) 
&gt;&gt;&gt; print(p.x, p.y)</strong> </pre>
<p>The output is the same as in the previous example because, internally, the exact same process has occurred.</p>
<p>What happens if we forget to include the <kbd>self</kbd> argument in our class definition? Python will bail with an error message, as follows:</p>
<pre><strong>&gt;&gt;&gt; class Point:</strong><br/><strong>... def reset():</strong><br/><strong>... pass</strong><br/><strong>...</strong><br/><strong>&gt;&gt;&gt; p = Point()</strong><br/><strong>&gt;&gt;&gt; p.reset()</strong><br/><strong>Traceback (most recent call last):</strong><br/><strong>  File "&lt;stdin&gt;", line 1, in &lt;module&gt;</strong><br/><strong>TypeError: reset() takes 0 positional arguments but 1 was given</strong></pre>
<p>The error message is not as clear as it could be (Hey, silly, you forgot the <kbd>self</kbd> argument would be more informative). Just remember that when you see an error message that indicates missing arguments, the first thing to check is whether you forgot <kbd>self</kbd> in the method definition.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">More arguments</h1>
                </header>
            
            <article>
                
<p>So, how do we pass multiple arguments to a method? Let's add a new method that allows us to move a point to an arbitrary position, not just to the origin. We can also include one that accepts another <kbd>Point</kbd> object as input and returns the distance between them:</p>
<pre>import math<br/><br/><br/>class Point:<br/><strong>    def move(self, x, y):</strong><br/>        self.x = x<br/>        self.y = y<br/><br/>    def reset(self):<br/>        self.move(0, 0)<br/><br/><strong> def calculate_distance(self, other_point):</strong><br/>        return math.sqrt(<br/>            (self.x - other_point.x) ** 2<br/>            + (self.y - other_point.y) ** 2<br/>        )<br/><br/><br/># how to use it:<br/>point1 = Point()<br/>point2 = Point()<br/><br/>point1.reset()<br/>point2.move(5, 0)<br/>print(point2.calculate_distance(point1))<br/>assert point2.calculate_distance(point1) == point1.calculate_distance(<br/>    point2<br/>)<br/>point1.move(3, 4)<br/>print(point1.calculate_distance(point2))<br/>print(point1.calculate_distance(point1))</pre>
<p>The <kbd>print</kbd> statements at the end give us the following output:</p>
<pre><strong>5.0</strong>
<strong>4.47213595499958</strong>
<strong>0.0</strong>  </pre>
<p>A lot has happened here. The class now has three methods. The <kbd>move</kbd> method accepts two arguments, <kbd>x</kbd> and <kbd>y</kbd>, and sets the values on the <kbd>self</kbd> object, much like the old <kbd>reset</kbd> method from the previous example. The old <kbd>reset</kbd> method now calls <kbd>move</kbd>, since a reset is just a move to a specific known location.</p>
<p>The <kbd>calculate_distance</kbd> method uses the not-too-complex Pythagorean theorem to calculate the distance between two points. I hope you understand the math (<kbd>**2</kbd> means squared, and <kbd>math.sqrt</kbd> calculates a square root), but it's not a requirement for our current focus, learning how to write methods.</p>
<p>The sample code at the end of the preceding example shows how to call a method with arguments: simply include the arguments inside the parentheses, and use the same dot notation to access the method. I just picked some random positions to test the methods. The test code calls each method and prints the results on the console. The <kbd>assert</kbd> function is a simple test tool; the program will bail if the statement after <kbd>assert</kbd> evaluates to <kbd>False</kbd> (or zero, empty, or <kbd>None</kbd>). In this case, we use it to ensure that the distance is the same regardless of which point called the other point's <kbd>calculate_distance</kbd> method.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Initializing the object</h1>
                </header>
            
            <article>
                
<p>If we don't explicitly set the <kbd>x</kbd> and <kbd>y</kbd> positions on our <kbd>Point</kbd> object, either using <kbd>move</kbd> or by accessing them directly, we have a broken point with no real position. What will happen when we try to access it?</p>
<p>Well, let's just try it and see. <em>Try it and see</em> is an extremely useful tool for Python study. Open up your interactive interpreter and type away. The following interactive session shows what happens if we try to access a missing attribute. If you saved the previous example as a file or are using the examples distributed with the book, you can load it into the Python interpreter with the <kbd>python -i more_arguments.py</kbd> <span>command</span>:</p>
<pre><strong>&gt;&gt;&gt; point = Point()</strong>
<strong>&gt;&gt;&gt; point.x = 5</strong>
<strong>&gt;&gt;&gt; print(point.x)</strong>
<strong>5</strong>
<strong>&gt;&gt;&gt; print(point.y)</strong>
<strong>Traceback (most recent call last):</strong>
<strong>  File "&lt;stdin&gt;", line 1, in &lt;module&gt;</strong>
<strong>AttributeError: 'Point' object has no attribute 'y'<br/></strong></pre>
<p>Well, at least it threw a useful exception. We'll cover exceptions in detail in <a href="04b8e2ea-599a-4bd0-abf7-4276eab787e0.xhtml"><span class="ChapterrefPACKT">Chapter 4</span></a>, <em>Expecting the Unexpected</em>. You've probably seen them before (especially the ubiquitous <span class="packt_screen">SyntaxError</span>, which means you typed something incorrectly!). At this point, simply be aware that it means something went wrong.</p>
<p>The output is useful for debugging. In the interactive interpreter, it tells us the error occurred at <span class="packt_screen">line 1</span>, which is only partially true (in an interactive session, only one line is executed at a time). If we were running a script in a file, it would tell us the exact line number, making it easy to find the offending code. In addition, it tells us that the error is an <kbd>AttributeError</kbd>, and gives a helpful message telling us what that error means.</p>
<p>We can catch and recover from this error, but in this case, it feels like we should have specified some sort of default value. Perhaps every new object should be <kbd>reset()</kbd> by default, or maybe it would be nice if we could force the user to tell us what those positions should be when they create the object.</p>
<p>Most object-oriented programming languages have the concept of a <strong>constructor</strong>, a special method that creates and initializes the object when it is created. Python is a little different; it has a constructor <em>and</em> an initializer. The constructor function is rarely used, unless you're doing something very exotic. So, we'll start our discussion with the much more common initialization method.</p>
<p>The Python initialization method is the same as any other method, except it has a special name, <kbd>__init__</kbd>. The leading and trailing double underscores mean this is a special method that the Python interpreter will treat as a special case.</p>
<div class="packt_infobox">Never name a method of your own with leading and trailing double underscores. It may mean nothing to Python today, but there's always the possibility that the designers of Python will add a function that has a special purpose with that name in the future, and when they do, your code will break.</div>
<p>Let's add an initialization function on our <kbd>Point</kbd> class that requires the user to supply <kbd>x</kbd> and <kbd>y</kbd> coordinates when the <kbd>Point</kbd> object is instantiated:</p>
<pre>class Point: 
<strong>    def __init__(self, x, y): 
        self.move(x, y)</strong> 
 
    def move(self, x, y): 
        self.x = x 
        self.y = y 
 
    def reset(self): 
        self.move(0, 0) 
 
# Constructing a Point 
point = Point(3, 5) 
print(point.x, point.y) </pre>
<p>Now, our point can never go without a <kbd>y</kbd> coordinate! If we try to construct a point without including the proper initialization parameters, it will fail with a <kbd>not enough arguments</kbd> error similar to the one we received earlier when we forgot the <kbd>self</kbd> argument.</p>
<p>If we don't want to make the two arguments required, we can use the same syntax Python functions use to provide default arguments. The keyword argument syntax appends an equals sign after each variable name. If the calling object does not provide this argument, then the default argument is used instead. The variables will still be available to the function, but they will have the values specified in the argument list. Here's an example:</p>
<pre>class Point: 
    def __init__(self, x=0, y=0): 
        self.move(x, y) </pre>
<p>Most of the time, we put our initialization statements in an <kbd>__init__</kbd> function. But as mentioned earlier, Python has a constructor in addition to its initialization function. You may never need to use the other Python constructor (in well over a decade of professional Python coding, I can only think of two cases where I've used it, and in one of them, I probably shouldn't have!), but it helps to know it exists, so we'll cover it briefly.</p>
<p>The constructor function is called <kbd>__new__</kbd> as opposed to <kbd>__init__</kbd>, and accepts exactly one argument; the <strong>class</strong> that is being constructed (it is called <em>before</em> the object is constructed, so there is no <kbd>self</kbd> argument). It also has to return the newly created object. This has interesting possibilities when it comes to the complicated art of metaprogramming, but is not very useful in day-to-day Python. In practice, you will rarely, if ever, need to use <kbd>__new__</kbd>. The <kbd>__init__</kbd> method will almost always be sufficient.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Explaining yourself</h1>
                </header>
            
            <article>
                
<p>Python is an extremely easy-to-read programming language; some might say it is self-documenting. However, when carrying out object-oriented programming, it is important to write API documentation that clearly summarizes what each object and method does. Keeping documentation up to date is difficult; the best way to do it is to write it right into our code.</p>
<p>Python supports this through the use of <strong>docstrings</strong>. Each class, function, or method header can have a standard Python string as the first line following the definition (the line that ends in a colon). This line should be indented the same as the code that <span>follows it</span>.</p>
<p>Docstrings are simply Python strings enclosed with apostrophes (<kbd>'</kbd>) or quotation marks (<kbd>"</kbd>) characters. Often, docstrings are quite long and span multiple lines (the style guide suggests that the line length should not exceed 80 characters), which can be formatted as multi-line strings, enclosed in matching triple apostrophe (<kbd>'''</kbd>) or triple quote (<kbd>"""</kbd>) characters.</p>
<p>A docstring should clearly and concisely summarize the purpose of the class or method it is describing. It should explain any parameters whose usage is not immediately obvious, and is also a good place to include short examples of how to use the API. Any caveats or problems an unsuspecting user of the API should be aware of should also be noted.</p>
<p>To illustrate the use of docstrings, we will end this section with our completely documented <kbd>Point</kbd> class:</p>
<pre>import math<br/><br/><br/>class Point:<br/>    "Represents a point in two-dimensional geometric coordinates"<br/><br/>    def __init__(self, x=0, y=0):<br/>        """Initialize the position of a new point. The x and y<br/>           coordinates can be specified. If they are not, the<br/>           point defaults to the origin."""<br/>        self.move(x, y)<br/><br/>    def move(self, x, y):<br/>        "Move the point to a new location in 2D space."<br/>        self.x = x<br/>        self.y = y<br/><br/>    def reset(self):<br/>        "Reset the point back to the geometric origin: 0, 0"<br/>        self.move(0, 0)<br/><br/>    def calculate_distance(self, other_point):<br/>        """Calculate the distance from this point to a second<br/>        point passed as a parameter.<br/><br/>        This function uses the Pythagorean Theorem to calculate<br/>        the distance between the two points. The distance is<br/>        returned as a float."""<br/><br/>        return math.sqrt(<br/>            (self.x - other_point.x) ** 2<br/>            + (self.y - other_point.y) ** 2<br/>        )</pre>
<p>Try typing or loading (remember, it's <kbd>python -i point.py</kbd>) this file into the interactive interpreter. Then, enter <kbd>help(Point)&lt;enter&gt;</kbd> at the Python prompt.</p>
<p>You should see nicely formatted documentation for the class, as shown in the following screenshot:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/a74e0195-2712-4811-acc3-fc6a19732222.png" style="width:50.25em;height:31.08em;"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Modules and packages</h1>
                </header>
            
            <article>
                
<p>Now we know how to create classes and instantiate objects. You don't need to write too many classes (or non-object-oriented code, for that matter) before you start to lose track of them. For small programs, we can just put all our classes into one file and add a little script at the end of the file to start them interacting. However, as our projects grow, it can become difficult to find the one class that needs to be edited among the many classes we've defined. This is where <strong>modules</strong> come in. Modules are simply Python files, nothing more. The single file in our small program is a module. Two Python files are two modules. If we have two files in the same folder, we can load a class from one module for use in the other module.</p>
<p>For example, if we are building an e-commerce system, we will likely be storing a lot of data in a database. We can put all the classes and functions related to database access into a separate file (we'll call it something sensible: <kbd>database.py</kbd>). Then, our other modules (for example, customer models, product information, and inventory) can import classes from that module in order to access the database.</p>
<p>The <kbd>import</kbd> statement is used for importing modules or specific classes or functions from modules. We've already seen an example of this in our <kbd>Point</kbd> class in the previous section. We used the <kbd>import</kbd> statement to get Python's built-in <kbd>math</kbd> module and use its <kbd>sqrt</kbd> function in the <kbd>distance</kbd> calculation.</p>
<p>Here's a concrete example. Assume we have a module called <kbd>database.py</kbd>, which contains a class called <kbd>Database</kbd>. A second module called <kbd>products.py</kbd> is responsible for product-related queries. At this point, we don't need to think too much about the contents of these files. What we know is that <kbd>products.py</kbd> needs to instantiate the <kbd>Database</kbd> class from <kbd>database.py</kbd> so that it can execute queries on the product table in the database.</p>
<p>There are several variations on the <kbd>import</kbd> statement syntax that can be used to access the class:</p>
<pre><strong>import database</strong> 
db = database.Database() 
# Do queries on db </pre>
<p>This version imports the <kbd>database</kbd> module into the <kbd>products</kbd> namespace (the list of names currently accessible in a module or function), so any class or function in the <kbd>database</kbd> module can be accessed using the <kbd>database.&lt;something&gt;</kbd> notation. Alternatively, we can import just the one class we need using the <kbd>from...import</kbd> syntax:</p>
<pre><strong>from database import Database</strong> 
db = Database() 
# Do queries on db </pre>
<p>If, for some reason, <kbd>products</kbd> already has a class called <kbd>Database</kbd>, and we don't want the two names to be confused, we can rename the class when used inside the <kbd>products</kbd> module:</p>
<pre><strong>from database import Database as DB</strong> 
db = DB() 
# Do queries on db </pre>
<p>We can also import multiple items in one statement. If our <kbd>database</kbd> module also contains a <kbd>Query</kbd> class, we can import both classes using the following code:</p>
<pre><strong>from database import Database, Query</strong> </pre>
<p>Some sources say that we can import all classes and functions from the <kbd>database</kbd> module using this syntax:</p>
<pre>from database import * </pre>
<p><strong>Don't do this.</strong> Most experienced Python programmers will tell you that you should never use this syntax (a few will tell you there are some very specific situations where it is useful, but I disagree). They'll use obscure justifications such as <em>it clutters up the namespace</em>, which doesn't make much sense to beginners. One way to learn why to avoid this syntax is to use it and try to understand your code two years later. But we can save some time and two years of poorly written code with a quick explanation now!</p>
<p>When we explicitly import the <kbd>database</kbd> class at the top of our file using <kbd>from database import Database</kbd>, we can easily see where the <kbd>Database</kbd> class comes from. We might use <kbd>db = Database()</kbd> 400 lines later in the file, and we can quickly look at the imports to see where that <kbd>Database</kbd> class came from. Then, if we need clarification as to how to use the <kbd>Database</kbd> class, we can visit the original file (or import the module in the interactive interpreter and use the <kbd>help(database.Database)</kbd> command). However, if we use the <kbd>from database import *</kbd> syntax, it takes a lot longer to find where that class is located. Code maintenance becomes a nightmare.</p>
<p>In addition, most code editors are able to provide extra functionality, such as reliable code completion, the ability to jump to the definition of a class, or inline documentation, if normal imports are used. The <kbd>import *</kbd> syntax usually completely destroys their ability to do this reliably.</p>
<p>Finally, using the <kbd>import *</kbd> syntax can bring unexpected objects into our local namespace. Sure, it will import all the classes and functions defined in the module being imported from, but it will also import any classes or modules that were themselves imported into that file!</p>
<p class="mce-root"/>
<p>Every name used in a module should come from a well-specified place, whether it is defined in that module, or explicitly imported from another module. There should be no magic variables that seem to come out of thin air. We should <em>always</em> be able to immediately identify where the names in our current namespace originated. I promise that if you use this evil syntax, you will one day have extremely frustrating moments of <em>where on earth can this class be coming from?</em></p>
<div class="packt_tip">For fun, try typing <kbd>import this</kbd> into your interactive interpreter. It prints a nice poem (with a couple of inside jokes you can ignore) summarizing some of the idioms that Pythonistas tend to practice. Specific to this discussion, note the line <em>Explicit is better than implicit</em>. Explicitly importing names into your namespace makes your code much easier to navigate than the implicit <kbd>import *</kbd> syntax.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Organizing modules</h1>
                </header>
            
            <article>
                
<p>As a project grows into a collection of more and more modules, we may find that we want to add another level of abstraction, some kind of nested hierarchy on our modules' levels. However, we can't put modules inside modules; one file can hold only one file after all, and modules are just files.</p>
<p>Files, however, can go in folders, and so can modules. A <strong>package</strong> is a collection of modules in a folder. The name of the package is the name of the folder. We need to tell Python that a folder is a package to distinguish it from other folders in the directory. To do this, place a (normally empty) file in the folder named <kbd>__init__.py</kbd>. If we forget this file, we won't be able to import modules from that folder.</p>
<p>Let's put our modules inside an <kbd>ecommerce</kbd> package in our working folder, which will also contain a <kbd>main.py</kbd> file to start the program. Let's additionally add another package inside the <kbd>ecommerce</kbd> package for various payment options. The folder hierarchy will look like this:</p>
<pre>parent_directory/ 
    main.py 
    ecommerce/ 
        __init__.py 
        database.py 
        products.py 
        payments/ 
            __init__.py 
            square.py 
            stripe.py </pre>
<p>When importing modules or classes between packages, we have to be cautious about the syntax. In Python 3, there are two ways of importing modules: absolute imports and relative imports.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Absolute imports</h1>
                </header>
            
            <article>
                
<p><strong>Absolute imports</strong> specify the complete path to the module, function, or class we want to import. If we need access to the <kbd>Product</kbd> class inside the <kbd>products</kbd> module, we could use any of these syntaxes to perform an absolute import:</p>
<pre><strong>import ecommerce.products</strong> 
product = ecommerce.products.Product() <br/><br/>//or<br/><br/><strong>from ecommerce.products import Product</strong> 
product = Product() <br/><br/>//or<br/><br/><strong>from ecommerce import products</strong> 
product = products.Product() </pre>
<p>The <kbd>import</kbd> statements use the period operator to separate packages or modules.</p>
<p>These statements will work from any module. We could instantiate a <kbd>Product</kbd> class using this syntax in <kbd>main.py</kbd>, in the <kbd>database</kbd> module, or in either of the two payment modules. Indeed, assuming the packages are available to Python, it will be able to import them. For example, the packages can also be installed in the Python site packages folder, or the <kbd>PYTHONPATH</kbd> environment variable could be customized to dynamically tell Python which folders to search for packages and modules it is going to import.</p>
<p>So, with these choices, which syntax do we choose? It depends on your personal taste and the application at hand. If there are dozens of classes and functions inside the <kbd>products</kbd> module that I want to use, I generally import the module name using the <kbd>from ecommerce import products</kbd> syntax, and then access the individual classes using <kbd>products.Product</kbd>. If I only need one or two classes from the <kbd>products</kbd> module, I can import them directly using the <kbd>from ecommerce.products import Product</kbd> syntax. I don't personally use the first syntax very often, unless I have some kind of name conflict (for example, I need to access two completely different modules called <kbd>products</kbd> and I need to separate them). Do whatever you think makes your code look more elegant.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Relative imports</h1>
                </header>
            
            <article>
                
<p>When working with related modules inside a package, it seems kind of redundant to specify the full path; we know what our parent module is named. This is where <strong>relative imports</strong> come in. Relative imports are basically a way of saying find a class, function, or module as it is positioned relative to the current module. For example, if we are working in the <kbd>products</kbd> module and we want to import the <kbd>Database</kbd> class from the <kbd>database</kbd> module next to it, we could use a relative import:</p>
<pre>from .database import Database </pre>
<p>The period in front of <kbd>database</kbd> says <em>use the database module inside the current package</em>. In this case, the current package is the package containing the <kbd>products.py</kbd> file we are currently editing, that is, the <kbd>ecommerce</kbd> package.</p>
<p>If we were editing the <kbd>paypal</kbd> module inside the <kbd>ecommerce.payments</kbd> package, we would want, for example, to <em>use the database package inside the parent package</em> instead. This is easily done with two periods, as shown here:</p>
<pre>from ..database import Database </pre>
<p>We can use more periods to go further up the hierarchy. Of course, we can also go down one side and back up the other. We don't have a deep enough example hierarchy to illustrate this properly, but the following would be a valid import if we had an <kbd>ecommerce.contact</kbd> package containing an <kbd>email</kbd> module and wanted to import the <kbd>send_mail</kbd> function into our <kbd>paypal</kbd> module:</p>
<pre>from ..contact.email import send_mail </pre>
<p>This import uses two periods  indicating, <em>the parent of the payments package</em>, and then uses the normal <kbd>package.module</kbd> syntax to go back down into the contact package.</p>
<p>Finally, we can import code directly from packages, as opposed to just modules inside packages. In this example, we have an <kbd>ecommerce</kbd> package containing two modules named <kbd>database.py</kbd> and <kbd>products.py</kbd>. The database module contains a <kbd>db</kbd> variable that is accessed from a lot of places. Wouldn't it be convenient if this could be imported as <kbd>import ecommerce.db</kbd> instead of <kbd>import ecommerce.database.db</kbd>?</p>
<p>Remember the <kbd>__init__.py</kbd> file that defines a directory as a package? This file can contain any variable or class declarations we like, and they will be available as part of the package. In our example, if the <kbd>ecommerce/__init__.py</kbd> file contained the following line:</p>
<pre>from .database import db </pre>
<p>We could then access the <kbd>db</kbd> attribute from <kbd>main.py</kbd> or any other file using the following import:</p>
<pre>from ecommerce import db </pre>
<p>It might help to think of the <kbd>__init__.py</kbd> file as if it were an <kbd>ecommerce.py</kbd> file, if that file were a module instead of a package. This can also be useful if you put all your code in a single module and later decide to break it up into a package of modules. The <kbd>__init__.py</kbd> file for the new package can still be the main point of contact for other modules talking to it, but the code can be internally organized into several different modules or subpackages.</p>
<p>I recommend not putting much code in an <kbd>__init__.py</kbd> file, though. Programmers do not expect actual logic to happen in this file, and much like with <kbd>from x import *</kbd>, it can trip them up if they are looking for the declaration of a particular piece of code and can't find it until they check <kbd>__init__.py</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Organizing module content</h1>
                </header>
            
            <article>
                
<p>Inside any one module, we can specify variables, classes, or functions. They can be a handy way to store the global state without namespace conflicts. For example, we have been importing the <kbd>Database</kbd> class into various modules and then instantiating it, but it might make more sense to have only one <kbd>database</kbd> object globally available from the <kbd>database</kbd> module. The <kbd>database</kbd> module might look like this:</p>
<pre>class Database: 
    # the database implementation 
    pass 
 
database = Database() </pre>
<p>Then we can use any of the import methods we've discussed to access the <kbd>database</kbd> object, for example:</p>
<pre>from ecommerce.database import database </pre>
<p>A problem with the preceding class is that the <kbd>database</kbd> object is created immediately when the module is first imported, which is usually when the program starts up. This isn't always ideal, since connecting to a database can take a while, slowing down startup, or the database connection information may not yet be available. We could delay creating the database until it is actually needed by calling an <kbd>initialize_database</kbd> function to create a module-level variable:</p>
<pre>class Database: 
    # the database implementation 
    pass 
 
database = None 
 
def initialize_database(): 
    global database 
    database = Database() </pre>
<p>The <kbd>global</kbd> keyword tells Python that the database variable inside <kbd>initialize_database</kbd> is the module level one we just defined. If we had not specified the variable as global, Python would have created a new local variable that would be discarded when the method exits, leaving the module-level value unchanged.</p>
<p>As these two examples illustrate, all module-level code is executed immediately at the time it is imported. However, if it is inside a method or function, the function will be created, but its internal code will not be executed until the function is called. This can be a tricky thing for scripts that perform execution <span>(such as the main script in our e-commerce example)</span>. Sometimes, we write a program that does something useful, and then later find that we want to import a function or class from that module into a different program. However, as soon as we import it, any code at the module level is immediately executed. If we are not careful, we can end up running the first program when we really only meant to access a couple of functions inside that module.</p>
<p>To solve this, we should always put our start up code in a function (conventionally, called <kbd>main</kbd>) and only execute that function when we know we are running the module as a script, but not when our code is being imported from a different script. We can do this by <strong>guarding</strong> the call to <kbd>main</kbd> inside a conditional statement, demonstrated as follows:</p>
<pre>class UsefulClass:<br/>    """This class might be useful to other modules."""<br/><br/>    pass<br/><br/><br/>def main():<br/>    """Creates a useful class and does something with it for our module."""<br/>    useful = UsefulClass()<br/>    print(useful)<br/><br/><br/>if __name__ == "__main__":<br/>    main()</pre>
<p>Every module has a <kbd>__name__</kbd> special variable (remember, Python uses double underscores for special variables, such as a class's <kbd>__init__</kbd> method) that specifies the name of the module when it was imported. When the module is executed directly with <kbd>python module.py</kbd>, it is never imported, so the <kbd>__name__</kbd> is arbitrarily set to the <kbd>"__main__"</kbd> string. Make it a policy to wrap all your scripts in an <kbd>if __name__ == "__main__":</kbd> test, just in case you write a function that you may want to be imported by other code at some point in the future.</p>
<p>So, methods go in classes, which go in modules, which go in packages. Is that all there is to it?</p>
<p>Actually, no. This is the typical order of things in a Python program, but it's not the only possible layout. Classes can be defined anywhere. They are typically defined at the module level, but they can also be defined inside a function or method, like this:</p>
<pre>def format_string(string, formatter=None):<br/>    """Format a string using the formatter object, which <br/>    is expected to have a format() method that accepts <br/>    a string."""<br/><br/>    class DefaultFormatter:<br/>        """Format a string in title case."""<br/><br/>        def format(self, string):<br/>            return str(string).title()<br/><br/>    if not formatter:<br/>        formatter = DefaultFormatter()<br/><br/>    return formatter.format(string)<br/><br/><br/>hello_string = "hello world, how are you today?"<br/>print(" input: " + hello_string)<br/>print("output: " + format_string(hello_string))</pre>
<p>The output would be as follows:</p>
<pre><strong> input: hello world, how are you today?</strong>
<strong>output: Hello World, How Are You Today?</strong></pre>
<p>The <kbd>format_string</kbd> function accepts a string and optional formatter object, and then applies the formatter to that string. If no formatter is supplied, it creates a formatter of its own as a local class and instantiates it. Since it is created inside the scope of the function, this class cannot be accessed from anywhere outside of that function. Similarly, functions can be defined inside other functions as well; in general, any Python statement can be executed at any time.</p>
<p>These inner classes and functions are occasionally useful for one-off items that don't require or deserve their own scope at the module level, or only make sense inside a single method. However, it is not common to see Python code that frequently uses this technique.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Who can access my data?</h1>
                </header>
            
            <article>
                
<p>Most object-oriented programming languages have a concept of <strong>access control</strong>. This is related to abstraction. Some attributes and methods on an object are marked private, meaning only that object can access them. Others are marked protected, meaning only that class and any subclasses have access. The rest are public, meaning any other object is allowed to access them.</p>
<p>Python doesn't do this. Python doesn't really believe in enforcing laws that might someday get in your way. Instead, it provides unenforced guidelines and best practices. Technically, all methods and attributes on a class are publicly available. If we want to suggest that a method should not be used publicly, we can put a note in docstrings indicating that the method is meant for internal use only (preferably, with an explanation of how the public-facing API works!).</p>
<p>By convention, we should also prefix an internal attribute or method with an underscore character, <kbd>_</kbd>. Python programmers will interpret this as <em>this is an internal variable, think three times before accessing it directly</em>. But there is nothing inside the interpreter to stop them from accessing it if they think it is in their best interest to do so. Because, if they think so, why should we stop them? We may not have any idea what future uses our classes may be put to.</p>
<p>There's another thing you can do to strongly suggest that outside objects don't access a property or method: prefix it with a double underscore, <kbd>__</kbd>. This will perform <strong>name mangling</strong> on the attribute in question. In essence, name mangling means that the method can still be called by outside objects if they really want to do so, but it requires extra work and is a strong indicator that you demand that your attribute remains <strong>private</strong>. Here is an example code snippet:</p>
<pre>class SecretString:<br/>    """A not-at-all secure way to store a secret string."""<br/><br/>    def __init__(self, plain_string, pass_phrase):<br/><strong>        self.__plain_string = plain_string</strong><br/><strong>        self.__pass_phrase = pass_phrase</strong><br/><br/>    def decrypt(self, pass_phrase):<br/>        """Only show the string if the pass_phrase is correct."""<br/><strong> if pass_phrase == self.__pass_phrase:</strong><br/><strong> return self.__plain_string</strong><br/>        else:<br/>            return ""</pre>
<p>If we load this class and test it in the interactive interpreter, we can see that it hides the plain text string from the outside world:</p>
<pre><strong>&gt;&gt;&gt; secret_string = SecretString("ACME: Top Secret", "antwerp")</strong>
<strong>&gt;&gt;&gt; print(secret_string.decrypt("antwerp"))</strong>
<strong>ACME: Top Secret</strong>
<strong>&gt;&gt;&gt; print(secret_string.__plain_string)</strong>
<strong>Traceback (most recent call last):</strong>
<strong>  File "&lt;stdin&gt;", line 1, in &lt;module&gt;</strong>
<strong>AttributeError: 'SecretString' object has no attribute</strong>
<strong>'__plain_string'</strong>  </pre>
<p>It looks like it works; nobody can access our <kbd>plain_string</kbd> attribute without the passphrase, so it must be safe. Before we get too excited, though, let's see how easy it can be to hack our security:</p>
<pre><strong>&gt;&gt;&gt; print(secret_string._SecretString__plain_string)</strong>
<strong>ACME: Top Secret</strong>  </pre>
<p>Oh no! Somebody has discovered our secret string. Good thing we checked.</p>
<p>This is Python name mangling at work. When we use a double underscore, the property is prefixed with <kbd>_&lt;classname&gt;</kbd>. When methods in the class internally access the variable, they are automatically unmangled. When external classes wish to access it, they have to do the name mangling themselves. So, name mangling does not guarantee privacy; it only strongly recommends it. Most Python programmers will not touch a double underscore variable on another object unless they have an extremely compelling reason to do so.</p>
<p>However, most Python programmers will not touch a single underscore variable without a compelling reason either. Therefore, there are very few good reasons to use a name-mangled variable in Python, and doing so can cause grief. For example, a name-mangled variable may be useful to an as-yet-unknown subclass, and it would have to do the mangling itself. Let other objects access your hidden information if they want to. Just let them know, using a single-underscore prefix or some clear docstrings, that you think this is not a good idea.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Third-party libraries</h1>
                </header>
            
            <article>
                
<p>Python ships with a lovely standard library, which is a collection of packages and modules that are available on every machine that runs Python. However, you'll soon find that it doesn't contain everything you need. When this happens, you have two options:</p>
<ul>
<li>Write a supporting package yourself</li>
<li>Use somebody else's code</li>
</ul>
<p>We won't be covering the details about turning your packages into libraries, but if you have a problem you need to solve and you don't feel like coding it (the best programmers are extremely lazy and prefer to reuse existing, proven code, rather than write their own), you can probably find the library you want on the <strong>Python Package Index</strong> (<strong>PyPI</strong>) at <a href="http://pypi.python.org/"><span class="URLPACKT">http://pypi.python.org/</span></a>. Once you've identified a package that you want to install, you can use a tool called <kbd>pip</kbd> to install it. However, <kbd>pip</kbd> does not come with Python, but Python 3.4 and higher contain a useful tool called <kbd>ensurepip</kbd>. You can use this command to install it:</p>
<pre><strong>$python -m ensurepip</strong>  </pre>
<p>This may fail for you on Linux, macOS, or other Unix systems, in which case, you'll need to become a root user to make it work. On most modern Unix systems, this can be done with <kbd>sudo python -m ensurepip</kbd>.</p>
<div class="packt_infobox">If you are using an older version of Python than Python 3.4, you'll need to download and install <kbd>pip</kbd> yourself, since <kbd>ensurepip</kbd> isn't available. You can do this by following the instructions at: <a href="http://pip.readthedocs.org/"><span class="URLPACKT">http://pip.readthedocs.org/</span></a>.</div>
<p>Once <kbd>pip</kbd> is installed and you know the name of the package you want to install, you can install it using syntax such as the following:</p>
<pre><strong>$pip install requests</strong>  </pre>
<p>However, if you do this, you'll either be installing the third-party library directly into your system Python directory, or, more likely, will get an error that you don't have permission to do so. You could force the installation as an administrator, but common consensus in the Python community is that you should only use system installers to install the third-party library to your system Python directory.</p>
<p>Instead, Python 3.4 (and higher) supplies the <kbd>venv</kbd> tool. This utility basically gives you a mini Python installation called a <em>virtual environment</em> in your working directory. When you activate the mini Python, commands related to Python will work on that directory instead of the system directory. So, when you run <kbd>pip</kbd> or <kbd>python</kbd>, it won't touch the system Python at all. Here's how to use it:</p>
<pre><strong>cd project_directory</strong>
<strong>python -m venv env</strong>
<strong>source env/bin/activate  # on Linux or macOS</strong>
<strong>env/bin/activate.bat     # on Windows</strong>  </pre>
<p>Typically, you'll create a different virtual environment for each Python project you work on. You can store your virtual environments anywhere, but I traditionally keep mine in the same directory as the rest of my project files (but ignored in version control), so first we <kbd>cd</kbd> into that directory. Then, we run the <kbd>venv</kbd> utility to create a virtual environment named <kbd>env</kbd>. Finally, we use one of the last two lines (depending on the operating system, as indicated in the comments) to activate the environment. We'll need to execute this line each time we want to use that particular virtualenv, and then use the <kbd>deactivate</kbd> <span>command </span>when we are done working on this project.</p>
<p>Virtual environments are a terrific way to keep your third-party dependencies separate. It is common to have different projects that depend on different versions of a particular library (for example, an older website might run on Django 1.8, while newer versions run on Django 2.1). Keeping each project in separate virtualenvs makes it easy to work in either version of Django. Furthermore, it prevents conflicts between system-installed packages and <kbd>pip</kbd>-installed packages if you try to install the same package using different tools.</p>
<div class="packt_tip">There are several third-party tools for managing virtual environments effectively. Some of these include <kbd>pyenv</kbd>, <kbd>virtualenvwrapper</kbd>, and <kbd>conda</kbd>. My personal preference at the time of writing is <kbd>pyenv</kbd>, but there is no clear winner here. Do a quick web search and see what works for you.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Case study</h1>
                </header>
            
            <article>
                
<p>To tie it all together, let's build a simple command-line notebook application. This is a fairly simple task, so we won't be experimenting with multiple packages. We will, however, see common usage of classes, functions, methods, and docstrings.</p>
<p>Let's start with a quick analysis: notes are short memos stored in a notebook. Each note should record the day it was written and can have tags added for easy querying. It should be possible to modify notes. We also need to be able to search for notes. All of these things should be done from the command line.</p>
<p>An obvious object is the <kbd>Note</kbd> object; a less obvious one is a <kbd>Notebook</kbd> container object. Tags and dates also seem to be objects, but we can use dates from Python's standard library and a comma-separated string for tags. To avoid complexity, in the prototype, we need not define separate classes for these objects.</p>
<p><kbd>Note</kbd> objects have attributes for <kbd>memo</kbd> itself, <kbd>tags</kbd>, and <kbd>creation_date</kbd>. Each note will also need a unique integer <kbd>id</kbd> so that users can select them in a menu interface. Notes could have a method to modify note content and another for tags, or we could just let the notebook access those attributes directly. To make searching easier, we should put a <kbd>match</kbd> method on the <kbd>Note</kbd> object. This method will accept a string and can tell us whether a note matches the string without accessing the attributes directly. This way, if we want to modify the search parameters (to search tags instead of note contents, for example, or to make the search case-insensitive), we only have to do it in one place.</p>
<p>The <kbd>Notebook</kbd> object obviously has the list of notes as an attribute. It will also need a search method that returns a list of filtered notes.</p>
<p>But how do we interact with these objects? We've specified a command-line app, which can mean either that we run the program with different options to add or edit commands, or we have some kind of menu that allows us to pick different things to do to the notebook. We should try to design it such that either interface is supported and future interfaces, such as a GUI toolkit or web-based interface, could be added in the future.</p>
<p>As a design decision, we'll implement the menu interface now, but will keep the command-line options version in mind to ensure we design our <kbd>Notebook</kbd> class with extensibility in mind.</p>
<p>If we have two command-line interfaces, each interacting with the <kbd>Notebook</kbd> object, then <kbd>Notebook</kbd> will need some methods for those interfaces to interact with. We need to be able to <kbd>add</kbd> a new note, and <kbd>modify</kbd> an existing note by <kbd>id</kbd>, in addition to the <kbd>search</kbd> method we've already discussed. The interfaces will also need to be able to list all notes, but they can do that by accessing the <kbd>notes</kbd> list attribute directly.</p>
<p>We may be missing a few details, but we have a really good overview of the code we need to write. We can summarize all this analysis in a simple class diagram:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/bd5f4ff6-aaa2-49a3-b133-b89ff97cd02d.png" style="width:25.83em;height:21.08em;"/></div>
<p>Before writing any code, let's define the folder structure for this project. The menu interface should clearly be in its own module, since it will be an executable script, and we may have other executable scripts accessing the notebook in the future. The <kbd>Notebook</kbd> and <kbd>Note</kbd> objects can live together in one module. These modules can both exist in the same top-level directory without having to put them in a package. An empty <kbd>command_option.py</kbd> module can help remind us in the future that we were planning to add new user interfaces:</p>
<pre>parent_directory/ 
    notebook.py 
    menu.py 
    command_option.py </pre>
<p>Now let's see some code. We start by defining the <kbd>Note</kbd> class, as it seems simplest. The following example presents <kbd>Note</kbd> in its entirety. Docstrings within the example explain how it all fits together, demonstrated as follows:</p>
<pre>import datetime<br/><br/># Store the next available id for all new notes<br/>last_id = 0<br/><br/><br/>class Note:<br/>    """Represent a note in the notebook. Match against a<br/>    string in searches and store tags for each note."""<br/><br/>    def __init__(self, memo, tags=""):<br/>        """initialize a note with memo and optional<br/>        space-separated tags. Automatically set the note's<br/>        creation date and a unique id."""<br/>        self.memo = memo<br/>        self.tags = tags<br/>        self.creation_date = datetime.date.today()<br/>        global last_id<br/>        last_id += 1<br/>        self.id = last_id<br/><br/>    def match(self, filter):<br/>        """Determine if this note matches the filter<br/>        text. Return True if it matches, False otherwise.<br/><br/>        Search is case sensitive and matches both text and<br/>        tags."""<br/>        return filter in self.memo or filter in self.tags</pre>
<p>Before continuing, we should quickly fire up the interactive interpreter and test our code so far. Test frequently and often, because things never work the way you expect them to. Indeed, when I tested my first version of this example, I found out I had forgotten the <kbd>self</kbd> argument in the <kbd>match</kbd> function! We'll discuss automated testing in <a href="ab1b23ea-7665-4745-a2a3-e739252eafb0.xhtml">Chapter 12</a>, <em>Testing Object-Oriented Programs</em>. For now, it suffices to check a few things using the interpreter:</p>
<pre><strong>&gt;&gt;&gt; from notebook import Note</strong>
<strong>&gt;&gt;&gt; n1 = Note("hello first")</strong>
<strong>&gt;&gt;&gt; n2 = Note("hello again")</strong>
<strong>&gt;&gt;&gt; n1.id</strong>
<strong>1</strong>
<strong>&gt;&gt;&gt; n2.id</strong>
<strong>2</strong>
<strong>&gt;&gt;&gt; n1.match('hello')</strong>
<strong>True</strong>
<strong>&gt;&gt;&gt; n2.match('second')</strong>
<strong>False</strong>  </pre>
<p>It looks like everything is behaving as expected. Let's create our notebook next:</p>
<pre>class Notebook:<br/>    """Represent a collection of notes that can be tagged,<br/>    modified, and searched."""<br/><br/>    def __init__(self):<br/>        """Initialize a notebook with an empty list."""<br/>        self.notes = []<br/><br/>    def new_note(self, memo, tags=""):<br/>        """Create a new note and add it to the list."""<br/>        self.notes.append(Note(memo, tags))<br/><br/>    def modify_memo(self, note_id, memo):<br/>        """Find the note with the given id and change its<br/>        memo to the given value."""<br/>        for note in self.notes:<br/>            if note.id == note_id:<br/>                note.memo = memo<br/>                break<br/><br/>    def modify_tags(self, note_id, tags):<br/>        """Find the note with the given id and change its<br/>        tags to the given value."""<br/>        for note in self.notes:<br/>            if note.id == note_id:<br/>                note.tags = tags<br/>                break<br/><br/>    def search(self, filter):<br/>        """Find all notes that match the given filter<br/>        string."""<br/>        return [note for note in self.notes if note.match(filter)]</pre>
<p>We'll clean this up in a minute. First, let's test it to make sure it works:</p>
<pre><strong>&gt;&gt;&gt; from notebook import Note, Notebook</strong>
<strong>&gt;&gt;&gt; n = Notebook()</strong>
<strong>&gt;&gt;&gt; n.new_note("hello world")</strong>
<strong>&gt;&gt;&gt; n.new_note("hello again")</strong>
<strong>&gt;&gt;&gt; n.notes</strong>
<strong>[&lt;notebook.Note object at 0xb730a78c&gt;, &lt;notebook.Note object at</strong><strong> 0xb73103ac&gt;]</strong>
<strong>&gt;&gt;&gt; n.notes[0].id</strong>
<strong>1</strong>
<strong>&gt;&gt;&gt; n.notes[1].id</strong>
<strong>2</strong>
<strong>&gt;&gt;&gt; n.notes[0].memo</strong>
<strong>'hello world'</strong>
<strong>&gt;&gt;&gt; n.search("hello")</strong>
<strong>[&lt;notebook.Note object at 0xb730a78c&gt;, &lt;notebook.Note object at </strong><strong>0xb73103ac&gt;]</strong>
<strong>&gt;&gt;&gt; n.search("world")</strong>
<strong>[&lt;notebook.Note object at 0xb730a78c&gt;]</strong>
<strong>&gt;&gt;&gt; n.modify_memo(1, "hi world")</strong>
<strong>&gt;&gt;&gt; n.notes[0].memo</strong>
<strong>'hi world'</strong>  </pre>
<p>It does work. The code is a little messy though; our <kbd>modify_tags</kbd> and <kbd>modify_memo</kbd> methods are almost identical. That's not good coding practice. Let's see how we can improve it.</p>
<p>Both methods are trying to identify the note with a given ID before doing something to that note. So, let's add a method to locate the note with a specific ID. We'll prefix the method name with an underscore to suggest that the method is for internal use only, but, of course, our menu interface can access the method if it wants to:</p>
<pre>    def _find_note(self, note_id):<br/>        """Locate the note with the given id."""<br/>        for note in self.notes:<br/>            if note.id == note_id:<br/>                return note<br/>        return None<br/><br/>    def modify_memo(self, note_id, memo):<br/>        """Find the note with the given id and change its<br/>        memo to the given value."""<br/>        self._find_note(note_id).memo = memo<br/><br/>    def modify_tags(self, note_id, tags):<br/>        """Find the note with the given id and change its<br/>        tags to the given value."""<br/>        self._find_note(note_id).tags = tags</pre>
<p>This should work for now. Let's have a look at the menu interface. The interface needs to present a menu and allow the user to input choices. Here's our first attempt:</p>
<pre>import sys<br/>from notebook import Notebook<br/><br/><br/>class Menu:<br/>    """Display a menu and respond to choices when run."""<br/><br/>    def __init__(self):<br/>        self.notebook = Notebook()<br/>        self.choices = {<br/>            "1": self.show_notes,<br/>            "2": self.search_notes,<br/>            "3": self.add_note,<br/>            "4": self.modify_note,<br/>            "5": self.quit,<br/>        }<br/><br/>    def display_menu(self):<br/>        print(<br/>            """<br/>Notebook Menu<br/><br/>1. Show all Notes<br/>2. Search Notes<br/>3. Add Note<br/>4. Modify Note<br/>5. Quit<br/>"""<br/>        )<br/><br/>    def run(self):<br/>        """Display the menu and respond to choices."""<br/>        while True:<br/>            self.display_menu()<br/>            choice = input("Enter an option: ")<br/>            action = self.choices.get(choice)<br/>            if action:<br/>                action()<br/>            else:<br/>                print("{0} is not a valid choice".format(choice))<br/><br/>    def show_notes(self, notes=None):<br/>        if not notes:<br/>            notes = self.notebook.notes<br/>        for note in notes:<br/>            print("{0}: {1}\n{2}".format(note.id, note.tags, note.memo))<br/><br/>    def search_notes(self):<br/>        filter = input("Search for: ")<br/>        notes = self.notebook.search(filter)<br/>        self.show_notes(notes)<br/><br/>    def add_note(self):<br/>        memo = input("Enter a memo: ")<br/>        self.notebook.new_note(memo)<br/>        print("Your note has been added.")<br/><br/>    def modify_note(self):<br/>        id = input("Enter a note id: ")<br/>        memo = input("Enter a memo: ")<br/>        tags = input("Enter tags: ")<br/>        if memo:<br/>            self.notebook.modify_memo(id, memo)<br/>        if tags:<br/>            self.notebook.modify_tags(id, tags)<br/><br/>    def quit(self):<br/>        print("Thank you for using your notebook today.")<br/>        sys.exit(0)<br/><br/><br/>if __name__ == "__main__":<br/>    Menu().run()</pre>
<p>This code first imports the notebook objects using an absolute import. Relative imports wouldn't work because we haven't placed our code inside a package. The <kbd>Menu</kbd> class's <kbd>run</kbd> method repeatedly displays a menu and responds to choices by calling functions on the notebook. This is done using an idiom that is rather peculiar to Python; it is a lightweight version of the command pattern that we will discuss in <a href="345fe617-9a90-4c59-9355-e7076759f9a4.xhtml"><span class="ChapterrefPACKT">Chapter 10</span></a>, <em>Python Design Patterns I</em>. The choices entered by the user are strings. In the menu's <kbd>__init__</kbd> method, we create a dictionary that maps strings to functions on the menu object itself. Then, when the user makes a choice, we retrieve the object from the dictionary. The <kbd>action</kbd> variable actually refers to a specific method, and is called by appending empty brackets (since none of the methods require parameters) to the variable. Of course, the user might have entered an inappropriate choice, so we check if the action really exists before calling it.</p>
<p>Each of the various methods request user input and call appropriate methods on the <kbd>Notebook</kbd> object associated with it. For the <kbd>search</kbd> implementation, we notice that after we've filtered the notes, we need to show them to the user, so we make the <kbd>show_notes</kbd> function serve double duty; it accepts an optional <kbd>notes</kbd> parameter. If it's supplied, it displays only the filtered notes, but if it's not, it displays all notes. Since the <kbd>notes</kbd> parameter is optional, <kbd>show_notes</kbd> can still be called with no parameters as an empty menu item.</p>
<p>If we test this code, we'll find that it fails if we try to modify a note. There are two bugs, namely:</p>
<ul>
<li>The notebook crashes when we enter a note ID that does not exist. We should never trust our users to enter correct data!</li>
<li>Even if we enter a correct ID, it will crash because the note IDs are integers, but our menu is passing a string.</li>
</ul>
<p>The latter bug can be solved by modifying the <kbd>Notebook</kbd> class's <kbd>_find_note</kbd> method to compare the values using strings instead of the integers stored in the note, as follows:</p>
<pre>    def _find_note(self, note_id):<br/>        """Locate the note with the given id."""<br/>        for note in self.notes:<br/>            if str(note.id) == str(note_id):<br/>                return note<br/>        return None</pre>
<p>We simply convert both the input (<kbd>note_id</kbd>) and the note's ID to strings before comparing them. We could also convert the input to an integer, but then we'd have trouble if the user entered the letter <kbd>a</kbd> instead of the number <kbd>1</kbd>.</p>
<p>The problem with users entering note IDs that don't exist can be fixed by changing the two <kbd>modify</kbd> methods on the notebook to check whether <kbd>_find_note</kbd> returned a note or not, like this:</p>
<pre>    def modify_memo(self, note_id, memo):<br/>        """Find the note with the given id and change its<br/>        memo to the given value."""<br/>        note = self._find_note(note_id)<br/>        if note:<br/>            note.memo = memo<br/>            return True<br/>        return False</pre>
<p>This method has been updated to return <kbd>True</kbd> or <kbd>False</kbd>, depending on whether a note has been found. The menu could use this return value to display an error if the user entered an invalid note.</p>
<div class="packt_tip">This code is a bit unwieldy. It would look a bit better if it raised an exception instead. We'll cover those in <a href="04b8e2ea-599a-4bd0-abf7-4276eab787e0.xhtml"><span class="ChapterrefPACKT">Chapter 4</span></a>, <em>Expecting the Unexpected</em>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Exercises</h1>
                </header>
            
            <article>
                
<p>Write some object-oriented code. The goal is to use the principles and syntax you learned in this chapter to ensure you understand the topics we've covered. If you've been working on a Python project, go back over it and see whether there are some objects you can create and add properties or methods to. If it's large, try dividing it into a few modules or even packages and play with the syntax.</p>
<p>If you don't have such a project, try starting a new one. It doesn't have to be something you intend to finish; just stub out some basic design parts. You don't need to fully implement everything; often, just a <kbd>print("this method will do something")</kbd> is all you need to get the overall design in place. This is called <strong>top-down design</strong>, in which you work out the different interactions and describe how they should work before actually implementing what they do. The converse, <strong>bottom-up design</strong>, implements details first and then ties them all together. Both patterns are useful at different times, but for understanding object-oriented principles, a top-down workflow is more suitable.</p>
<p>If you're having trouble coming up with ideas, try writing a to-do application. (Hint: it would be similar to the design of the notebook application, but with extra date management methods.) It can keep track of things you want to do each day, and allow you to mark them as completed.</p>
<p>Now try designing a bigger project. As before, it doesn't have to actually do anything, but make sure you experiment with the package and module-importing syntax. Add some functions in various modules and try importing them from other modules and packages. Use relative and absolute imports. See the difference, and try to imagine scenarios where you would want to use each one.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we learned how simple it is to create classes and assign properties and methods in Python. Unlike many languages, Python differentiates between a constructor and an initializer. It has a relaxed attitude toward access control. There are many different levels of scope, including packages, modules, classes, and functions. We understood the difference between relative and absolute imports, and how to manage third-party packages that don't come with Python.</p>
<p>In the next chapter, we'll learn how to share implementation using inheritance.</p>


            </article>

            
        </section>
    </body></html>