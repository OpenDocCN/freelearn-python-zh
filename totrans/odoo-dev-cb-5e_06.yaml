- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Managing Module Data
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理模块数据
- en: In Odoo, managing module data involves various tasks such as creating, updating,
    and deleting records in a database upon installation, upgrade, or removal of a
    module. This is typically done through XML files called data files.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在Odoo中，管理模块数据涉及各种任务，例如在安装、升级或删除模块时在数据库中创建、更新和删除记录。这通常是通过称为数据文件的XML文件来完成的。
- en: We’ll study how add-on modules might offer data during installation in this
    chapter. This helps us when we provide metadata, such as view descriptions, menus,
    or actions, or when we provide default settings. Another important usage is providing
    demonstration data, which is loaded when a database is created with the **Load
    demonstration data** checkbox checked.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将研究添加组件模块在安装期间可能提供数据的情况。这有助于我们在提供元数据，如视图描述、菜单或操作，或提供默认设置时。另一个重要用途是提供演示数据，当创建数据库时，如果勾选了**加载演示数据**复选框，则会加载这些数据。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Using external IDs and namespaces
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用外部ID和命名空间
- en: Loading data using XML files
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用XML文件加载数据
- en: Using the `noupdate` and `forcecreate` flags
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`noupdate`和`forcecreate`标志
- en: Loading data using CSV files
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用CSV文件加载数据
- en: Add-on updates and data migration
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加组件更新和数据迁移
- en: Deleting records from XML files
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从XML文件中删除记录
- en: Invoking functions from XML files
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从XML文件中调用函数
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The technical requirements for this chapter include the online Odoo platform.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的技术要求包括在线Odoo平台。
- en: 'All the code that’s used in this chapter can be downloaded from the following
    GitHub repository: [https://github.com/PacktPublishing/Odoo-17-Development-Cookbook-Fifth-Edition/tree/main/Chapter06](https://github.com/PacktPublishing/Odoo-17-Development-Cookbook-Fifth-Edition/tree/main/Chapter06).'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的所有代码都可以从以下GitHub仓库下载：[https://github.com/PacktPublishing/Odoo-17-Development-Cookbook-Fifth-Edition/tree/main/Chapter06](https://github.com/PacktPublishing/Odoo-17-Development-Cookbook-Fifth-Edition/tree/main/Chapter06)。
- en: In order to avoid repeating a lot of code, we’ll make use of the models that
    were defined in [*Chapter 4*](B20997_04.xhtml#_idTextAnchor118), *Application
    Models*. To follow these examples, make sure you grab the code from the `my_hostel`
    module from `Chapter05/my_hostel`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免重复大量代码，我们将利用在[*第4章*](B20997_04.xhtml#_idTextAnchor118)、“应用模型”中定义的模型。为了遵循这些示例，请确保从`Chapter05/my_hostel`模块中获取`my_hostel`模块的代码。
- en: Using external IDs and namespaces
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用外部ID和命名空间
- en: Records in Odoo are identified using external IDs or XML IDs. We have utilized
    XML IDs so far in this book in areas such as views, menus, and actions, but we
    still don’t know what an XML ID is. This recipe will give you more clarity about
    it.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Odoo中的记录使用外部ID或XML ID进行标识。到目前为止，我们在本书的视图、菜单和操作等区域使用了XML ID，但我们仍然不知道XML ID是什么。本食谱将为您提供更多关于它的清晰度。
- en: How to do it...
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We will write in the already-existing records to demonstrate how to use cross-module
    references:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将向已存在的记录中写入以演示如何使用跨模块引用：
- en: 'Update the manifest file of the `my_hostel` module by registering a data file
    like this:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过注册如下数据文件来更新`my_hostel`模块的清单文件：
- en: '[PRE0]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Create a new room in the `hostel.room` model:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`hostel.room`模型中创建一个新的房间：
- en: '[PRE1]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Change the name of the main company:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改主公司的名称：
- en: '[PRE2]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Install the module to apply the changes. After installation, a new record for
    the `Hostel Room 01` room will be created, and the company will be renamed `Packt
    Publishing`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 安装模块以应用更改。安装后，将创建`Hostel Room 01`房间的新记录，并将公司重命名为`Packt Publishing`。
- en: How it works...
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: An XML ID is a string that refers to a record in the database. The IDs themselves
    are records of their `ir.model.data` model. This model includes information such
    as the module name that declares the XML ID, the ID string, the referred model,
    and the referred ID.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: XML ID是一个字符串，它指向数据库中的一个记录。这些ID本身是`ir.model.data`模型的记录。该模型包括诸如声明XML ID的模块名称、ID字符串、引用模型和引用ID等信息。
- en: Every time we use an XML ID on a `<record>` tag, Odoo checks whether the string
    is namespaced (that is, whether it contains exactly one dot), and if not, it adds
    the current module name as a namespace. Then, it looks up whether there is already
    a record in `ir.model.data` with the specified name. If so, an `UPDATE` statement
    for the listed fields is executed; if not, a `CREATE` statement is executed. This
    is how you can provide partial data when a record already exists, as we did earlier.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: In the first example of this tutorial, the record has the ID `hostel_room_1`.
    As it is not namespaced, the final external ID will have a module name like this
    – `my_hostel.hostel_room_1`. Then, Odoo will try to find a record for `my_hostel.hostel_room_1`.
    As Odoo doesn’t have a record for that external ID yet, it will generate a new
    record in the `hostel.room` model.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: In the second example, we have used the external ID of the main company, which
    is `base.main_company`. As its namespace suggests, it is loaded from the base
    module. As the external ID is already present, instead of creating a record, Odoo
    will perform the write `(UPDATE)` operation so that the company name will change
    to `Packt Publishing`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: A widespread application for partial data, apart from changing records defined
    by other modules, is using a shortcut element to create a record conveniently
    and writing a field on that record, which is not supported by the shortcut element
    – `<act_window id="my_action" name="My action" model="res.partner" /><record id="my_action"
    model="ir.actions.act_window"> <field name="auto_search"` `eval="False" /></record>`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: In Odoo, the `ref` function is used to establish relationships between different
    records within the system. It allows you to create references from one record
    to another, typically using a *many2one* relationship.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: The `ref` function, as used in the *Loading data using XML files* tutorial of
    this chapter, also adds the current module as a namespace if appropriate but raises
    an error if the resulting XML ID does not exist already. This also applies to
    the `id` attribute if it is not namespaced already.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: If you want to see the list of all external identifiers, start developer mode
    and open the menu at **Settings** | **Technical** | **Sequence & Identifiers**
    | **External Identifiers**.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You will probably need to access records with an XML ID from your Python code
    sooner or later. Use the `self.env.ref()` function in these cases. This returns
    a browse record (`recordset`) of the referenced record. Note that, here, you always
    have to pass the full XML ID. Here’s an example of a full XML ID – `<``module_name>.<record_id>`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: Sooner or later, you’ll probably need to use Python code to retrieve records
    that have an XML ID. In these circumstances, use the `self.env.ref()` method.
    This gives you access to the linked record’s browsing record (`recordset`). Keep
    in mind that you must always pass the complete XML ID here.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see the XML ID of any record from the user interface. For that, you
    need to activate developer mode in Odoo; refer to [*Chapter 1*](B20997_01.xhtml#_idTextAnchor020),
    *Installing the Odoo Development Environment*, to do so. After activating developer
    mode, open the **Form** view of the record for which you want to find out the
    XML ID. You will see a bug icon in the top bar. From that menu, click on the **View
    Metadata** option. See the following screenshot for reference:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从用户界面中看到任何记录的 XML ID。为此，你需要在 Odoo 中激活开发者模式；请参考 [*第 1 章*](B20997_01.xhtml#_idTextAnchor020)，*安装
    Odoo 开发环境*，以进行操作。激活开发者模式后，打开你想要查找 XML ID 的记录的 **表单** 视图。你将在顶部栏看到一个错误图标。从该菜单中，点击
    **查看元数据** 选项。参见以下截图以供参考：
- en: '![Figure 6.1 – The menu to open a record’s metadata](img/B20997_06_1.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.1 – 打开记录元数据的菜单](img/B20997_06_1.jpg)'
- en: Figure 6.1 – The menu to open a record’s metadata
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.1 – 打开记录元数据的菜单
- en: See also
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Consult the *Using the noupdate and forcecreate flags* tutorial of this chapter
    to find out why the company’s name is only changed during the installation of
    the module.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 咨询本章的 *使用 noupdate 和 forcecreate 标志* 教程，以了解为什么公司的名称仅在模块安装期间更改。
- en: Loading data using XML files
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 XML 文件加载数据
- en: In the previous tutorial, we created the new room record with the `hostel_room_1`
    external identifier. In this tutorial, we will add a different type of data from
    the XML file. We’ll add a room and an author as demonstration data. We’ll also
    add a well-known publisher as normal data to our module.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个教程中，我们使用 `hostel_room_1` 外部标识符创建了新的房间记录。在本教程中，我们将从 XML 文件添加不同类型的数据。我们将添加一个房间和一个作者作为演示数据。我们还将添加一个知名的出版商作为正常数据到我们的模块中。
- en: How to do it...
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow the following steps to create two data XML files and link them in `your__manifest__.py`
    file:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建两个数据 XML 文件，并在 `your__manifest__.py` 文件中链接它们：
- en: 'Add a file called `data/demo.xml` to your manifest, in the `demo` section:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将名为 `data/demo.xml` 的文件添加到你的清单中，在 `demo` 部分：
- en: '[PRE3]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Add the following content to this file:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下内容添加到该文件中：
- en: '[PRE4]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Add a file called `data/data.xml` to your manifest, in the `data` section:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将名为 `data/data.xml` 的文件添加到你的清单中，在 `data` 部分：
- en: '[PRE5]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Add the following XML content to the `data/data.xml` file:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下 XML 内容添加到 `data/data.xml` 文件中：
- en: '[PRE6]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: When you update your module now, you’ll see the publisher we created, and if
    your database has demo data enabled, as pointed out in [*Chapter 3*](B20997_03.xhtml#_idTextAnchor083),
    *Creating Add-On Odoo Modules*, you’ll also find this room and its members.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当你现在更新你的模块时，你会看到我们创建的出版商，如果你的数据库已启用演示数据，如[*第 3 章*](B20997_03.xhtml#_idTextAnchor083)中所述，*创建
    Odoo 扩展模块*，你也会找到这个房间及其成员。
- en: How it works...
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The data XML files uses the `<record>` tag to create a row in the database table.
    The `<record>` tag has two mandatory attributes, `id` and `model`. For the `id`
    attribute, consult the *Using external IDs and namespaces* tutorial; the `model`
    attribute refers to a model’s `_name` property. Then, we use the `<field>` element
    to fill the columns in the database, as defined by the model you named. The model
    also decides which fields it is mandatory to fill and also defines the default
    values. In this case, you don’t need to give those fields a value explicitly.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 数据 XML 文件使用 `<record>` 标签在数据库表中创建一行。`<record>` 标签有两个强制属性，`id` 和 `model`。对于 `id`
    属性，请参考 *使用外部 ID 和命名空间* 教程；`model` 属性指的是模型 `_name` 属性。然后，我们使用 `<field>` 元素填充数据库中的列，正如你命名的模型所定义的那样。模型还决定哪些字段是必须填充的，并定义默认值。在这种情况下，你不需要明确为这些字段赋值。
- en: There are two ways to register data XML files in a module manifest. The first
    is with the `data` key and the second is with the `demo` key. The XML files in
    the `data` key are loaded every time you install or update the module, while XML
    files with `demo` keys are loaded only if you enabled demo data for your database.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在模块清单中注册数据 XML 文件有两种方式。第一种是使用 `data` 键，第二种是使用 `demo` 键。`data` 键中的 XML 文件在每次安装或更新模块时都会被加载，而带有
    `demo` 键的 XML 文件只有在启用了数据库的演示数据时才会被加载。
- en: In *step 1*, we registered a `data XML` file in the manifest with the `demo`
    key. Because we are using the demo key, the `XML` file will be loaded only if
    you have enabled demo data for the database.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *步骤 1* 中，我们在清单中注册了一个带有 `demo` 键的 `data XML` 文件。因为我们使用了 `demo` 键，所以只有当你为数据库启用了演示数据时，`XML`
    文件才会被加载。
- en: In *step 2*, the `<field>` element can contain a value as simple text in the
    case of scalar values. If you need to pass the content of a file (to set an image,
    for example), use the `file` attribute on the `<field>` element and pass the file’s
    name relative to the add-ons path.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤2*中，`<field>`元素可以包含一个简单的文本值，例如标量值的情况。如果你需要传递文件的内容（例如设置图像），请在`<field>`元素上使用`file`属性，并传递相对于附加程序路径的文件名。
- en: To set up references, there are two possibilities. The simplest is using the
    `ref` attribute, which works for *many2one* fields and just contains the XML ID
    of the record to be referenced. For *one2many* and *many2many* fields, we need
    to use the `eval` attribute. Use the `eval` attribute in XML to evaluate expressions
    dynamically. This is a general-purpose attribute that can be used to evaluate
    Python code to use as the field’s value. Normally, content within `<field>` tags
    is treated as strings – for example, `<field name="value">4.5</field>`. This will
    evaluate to the string `4.5` and not `float`. If you want to evaluate the value
    to a float, a Boolean, or another type, except `string`, you need to use the eval
    attribute, such as `<field name="value" eval="4.5" /> <field name="value"` `eval="False"
    />`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置引用，有两种可能性。最简单的是使用`ref`属性，它适用于*many2one*字段，并且只包含要引用的记录的XML ID。对于*one2many*和*many2many*字段，我们需要使用`eval`属性。在XML中使用`eval`属性来动态评估表达式。这是一个通用属性，可以用来评估Python代码作为字段的值。通常，`<field>`标签内的内容被视为字符串——例如，`<field
    name="value">4.5</field>`。这将评估为字符串`4.5`而不是浮点数。如果你想将值评估为浮点数、布尔值或其他类型（除了字符串），你需要使用`eval`属性，例如`<field
    name="value" eval="4.5" /> <field name="value" eval="False" />`。
- en: 'Here’s another example – think of `strftime(''%Y-01-01'')` as a way to populate
    a `date` field. `X2many` fields expect to be populated by a list of three tuples,
    where the first value of the tuple determines the operation to be carried out.
    Within an `eval` attribute, we have access to a function called `ref`, which returns
    the database ID of an XML ID, given as a string. This allows us to refer to a
    record without knowing its concrete ID, which is probably different in different
    databases, as shown here:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有一个例子——将`strftime('%Y-01-01')`视为填充`date`字段的一种方式。`X2many`字段期望由一个包含三个元组的列表填充，其中元组的第一个值确定要执行的操作。在`eval`属性中，我们可以访问一个名为`ref`的函数，该函数返回作为字符串给出的XML
    ID的数据库ID。这允许我们引用一个记录，而无需知道其具体的ID，这个ID在不同的数据库中可能不同，如下所示：
- en: '`(2, id, False)`: This deletes the linked record with `id` from the database.
    The third element of the tuple is ignored.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(2, id, False)`: 这从数据库中删除了具有`id`的链接记录。元组的第三个元素被忽略。'
- en: '`(3, id, False)`: This detaches the record with `id` from the `one2many` field.
    Note that this operation does not delete the record – it just leaves the existing
    record as it is. The last element of the tuple is also ignored.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(3, id, False)`: 这将`id`记录从`one2many`字段中分离出来。请注意，此操作不会删除记录——它只是保留现有的记录不变。元组的最后一个元素也被忽略。'
- en: '`(4, id, False)`: This adds a link to the existing record `id`, and the last
    element of the tuple is ignored. This should be what you use most of the time,
    usually accompanied by the `ref` function to get the database ID of a record known
    by its XML ID.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(4, id, False)`: 这为现有的`id`记录添加了一个链接，元组的最后一个元素被忽略。这应该是你大多数时候使用的方法，通常伴随着`ref`函数来获取已知其XML
    ID的记录的数据库ID。'
- en: '`(5, False, False)`: This cuts all links but keeps the linked records intact.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(5, False, False)`: 这切断了所有链接，但保留了链接的记录。'
- en: '`(6, False, [id, ...])`: This clears out currently referenced records to replace
    them with the ones mentioned in the list of IDs. The second element of the tuple
    is ignored.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(6, False, [id, ...])`: 这清除当前引用的记录，用列表中提到的ID替换它们。元组的第二个元素被忽略。'
- en: Important note
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Note that order matters in data files and that records within data files can
    only refer to records defined in data files earlier in the list. This is why you
    should always check whether your module installs in an empty database because,
    during development, you often add records all over the place, and the records
    defined afterward are already in the database from an earlier update.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在数据文件中顺序很重要，并且数据文件中的记录只能引用列表中先定义的数据文件中的记录。这就是为什么你应该始终检查你的模块是否可以在空数据库中安装的原因，因为在开发过程中，你经常会在各个地方添加记录，而之后定义的记录已经存在于数据库中，这是从较早的更新中来的。
- en: Demo data is always loaded after the files from the `data` key, which is why
    the reference in this example works.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 演示数据总是在`data`键的文件之后加载，这就是为什么这个例子中的引用可以工作。
- en: There’s more...
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: While you can do basically anything with the `record` element, there are shortcut
    elements that make it more convenient for a developer to create certain kinds
    of records. These include menu items, templates, and act windows. Refer to [*Chapter
    9*](B20997_09.xhtml#_idTextAnchor446), *Backend Views*, and [*Chapter 14*](B20997_14.xhtml#_idTextAnchor734),
    *CMS Website Development*, for more information about these.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然您可以使用`record`元素做几乎所有事情，但有一些快捷元素使开发人员创建某些类型的记录更加方便。这些包括菜单项、模板和动作窗口。有关这些内容的更多信息，请参阅[*第9章*](B20997_09.xhtml#_idTextAnchor446)，*后端视图*，和[*第14章*](B20997_14.xhtml#_idTextAnchor734)，*CMS网站开发*。
- en: A `field` element can also contain the `function` element, which calls a function
    defined on a model to provide a field’s value. Refer to the *Invoking functions
    from XML files* tutorial for an application in which we simply call a function
    to directly write to the database, circumventing the loading mechanism.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`field`元素也可以包含`function`元素，该元素调用在模型上定义的函数以提供字段的值。请参阅*从XML文件调用函数*教程，了解我们如何简单地调用函数直接写入数据库，绕过加载机制。'
- en: 'The preceding list misses entries for `0` and `1` because they are not very
    useful when loading the data. They are entered, as follows, for the sake of completeness:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的列表遗漏了`0`和`1`的条目，因为它们在加载数据时不是非常有用。为了完整性，它们如下所示输入：
- en: '`(0, False, {''key'': value})`: This creates a new record of the referenced
    model, with its fields filled from the dictionary at position three. The second
    element of the tuple is ignored. As these records don’t have an XML ID and are
    evaluated every time the module is updated, leading to double entries, it’s better
    to avoid this. Instead, create the record in its own record element, and link
    it as explained in the *How it works…* section of this tutorial.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(0, False, {''key'': value})`：这会创建一个引用模型的新的记录，其字段从位置三的字典中填充。元组的第二个元素被忽略。由于这些记录没有XML
    ID，并且每次模块更新时都会进行评估，导致重复条目，因此最好避免这种做法。相反，应在自己的记录元素中创建记录，并如本教程中*如何工作…*部分所述进行链接。'
- en: '`(1, id, {''key'': value})`: This can be used to write on an existing linked
    record. For the same reasons that we mentioned earlier, you should avoid this
    syntax in your XML files.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(1, id, {''key'': value})`：这可以用来写入现有的链接记录。出于我们之前提到的原因，您应该避免在XML文件中使用此语法。'
- en: These syntaxes are the same as the ones we explained in the *Creating new records*
    and *Updating values of records* tutorials in [*Chapter 5*](B20997_05.xhtml#_idTextAnchor238),
    *Basic* *Server-Side Development*.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这些语法与我们在[*第5章*](B20997_05.xhtml#_idTextAnchor238)，*基本* *服务器端开发*中*创建新记录*和*更新记录值*教程中解释的语法相同。
- en: Using the noupdate and forcecreate flags
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用noupdate和forcecreate标志
- en: Most add-on modules have different types of data. Some data simply needs to
    exist for the module to work properly, other data shouldn’t be changed by the
    user, and most data can be changed as the user wants and is only provided as a
    convenience. This tutorial will detail how to address the different types. First,
    we’ll write a field in an already-existing record, and then we’ll create a record
    that is supposed to be recreated during a module update.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数附加模块有不同的数据类型。有些数据只需存在，模块才能正常工作，其他数据不应由用户更改，而大多数数据可以根据用户的意愿更改，并且仅作为便利提供。本教程将详细介绍如何处理不同类型。首先，我们将在已存在的记录中编写一个字段，然后我们将创建一个在模块更新期间应该被重新创建的记录。
- en: How to do it...
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'We can enforce different behaviors from Odoo when loading data by setting certain
    attributes on the enclosing `<odoo>` element, or the `<record>` element itself:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在包含的`<odoo>`元素或`<record>`元素上设置某些属性来强制执行在加载数据时从Odoo不同的行为：
- en: 'Add a publisher that will be created at installation time but not updated on
    subsequent updates. However, if the user deletes it, it will be recreated:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个在安装时创建但后续更新不会更新的发布者。然而，如果用户删除它，它将被重新创建：
- en: '[PRE7]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Add a `room` category that is not changed during add-on updates and is not
    recreated if the user deletes it:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`room`类别，在附加组件更新期间不会更改，并且如果用户删除它则不会重新创建：
- en: '[PRE8]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: How it works...
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作...
- en: The `<odoo>` element can have a `noupdate` attribute, which is propagated to
    the `ir.model.data` records that are created when reading the enclosed data records
    for the first time, thus ending up as a column in this table.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`<odoo>`元素可以有一个`noupdate`属性，该属性在首次读取包含的数据记录时传播到创建的`ir.model.data`记录，从而成为此表中的一列。'
- en: When Odoo installs an add-on (called `init` mode), all records are written,
    whether `noupdate` is `true` or `false`. When you update an add-on (called `update`
    mode), the existing XML IDs are checked to see whether they have the `noupdate`
    flag set, and if so, elements that try to write to this XML ID are ignored. This
    is not the case if the record in question was deleted by the user, which is why
    you can force `notrecreate` `noupdate` records in `update` mode by setting the
    `forcecreate` flag on the record to `false`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当Odoo安装附加组件（称为`init`模式）时，无论`noupdate`是`true`还是`false`，都会写入所有记录。当你更新附加组件（称为`update`模式）时，会检查现有的XML
    ID，以查看它们是否设置了`noupdate`标志，如果是，则忽略尝试写入此XML ID的元素。如果用户删除了相关的记录，则不会发生这种情况，这就是为什么你可以在`update`模式下通过将记录上的`forcecreate`标志设置为`false`来强制`notrecreate`
    `noupdate`记录。
- en: Important note
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: In legacy add-ons (prior to and including version 8.0), you’ll often find an
    `<openerp>` element enclosing a `<data>` element, which contains `<record>` and
    other elements. This is still possible but deprecated. Now, `<odoo>`, `<openerp>`,
    and `<data>` have exactly the same semantics; they are meant as a bracket to enclose
    XML data.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在旧版附加组件（包括版本8.0之前）中，你通常会找到一个包含`<record>`和其他元素的`<data>`元素的`<openerp>`元素。这仍然是可能的，但已弃用。现在，`<odoo>`、`<openerp>`和`<data>`具有完全相同的语义；它们被用作括号来包围XML数据。
- en: There’s more...
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: If you want to load records even with the `noupdate` flag, you can run the Odoo
    server with the `--init=your_addon` or `-i your_addon` parameter. This will force
    Odoo to reload your records. However, this will also cause deleted records to
    be recreated. Note that this can cause double records and related installation
    errors if a module circumvents the XML ID mechanism – for example, by creating
    records in Python code called by the `<``function>` tag.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要即使带有`noupdate`标志也能加载数据记录，你可以使用带有`--init=your_addon`或`-i your_addon`参数的Odoo服务器运行。这将强制Odoo重新加载你的记录。然而，这也会导致已删除的记录被重新创建。请注意，如果模块绕过XML
    ID机制（例如，通过在由`<function>`标签调用的Python代码中创建记录）——这可能会导致双重记录和相关安装错误。
- en: With this code, you can circumvent any `noupdate` flag, but first, make sure
    that this is really what you want. Another option to solve the scenario presented
    here is to write a migration script, as outlined in the *Add-on updates and data*
    *migration* tutorial.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此代码，你可以绕过任何`noupdate`标志，但首先，请确保这真的是你想要的。解决此处场景的另一种选项是编写迁移脚本，如*附加组件更新和数据迁移*教程中概述的那样。
- en: See also
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Odoo also uses XML IDs to keep track of which data is to be deleted after an
    add-on update. If a record has an XML ID from the module’s namespace before the
    update but the XML ID is not reinstated during the update, the record and its
    XML ID will be deleted from the database because they’re considered obsolete.
    For a more in-depth discussion of this mechanism, refer to the *Add-on updates
    and data* *migration* tutorial.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Odoo还使用XML ID来跟踪在附加组件更新后要删除哪些数据。如果在更新之前记录具有来自模块命名空间的XML ID，但在更新期间未重新设置XML ID，则该记录及其XML
    ID将从数据库中删除，因为它们被认为是过时的。有关此机制的更深入讨论，请参阅*附加组件更新和数据迁移*教程。
- en: Loading data using CSV files
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用CSV文件加载数据
- en: While you can do everything you need to with XML files, this format is not the
    most convenient when you need to provide larger amounts of data, especially given
    that many people are more comfortable preprocessing data in Calc or other spreadsheet
    software. Another advantage of the CSV format is that it is what you get when
    you use the standard `export` function. In this tutorial, we’ll take a look at
    importing table-like data.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以使用XML文件完成所有需要的功能，但当需要提供大量数据时，这种格式并不方便，尤其是考虑到许多人更习惯在Calc或其他电子表格软件中预处理数据。CSV格式的另一个优点是，当你使用标准的`export`功能时，你得到的就是CSV格式。在本教程中，我们将探讨如何导入类似表格的数据。
- en: How to do it...
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Traditionally, **access-control lists** (**ACLs**) in Odoo are used to manage
    record and operation access rights. ACLs specify who can execute particular actions
    (such as read, write, create, and delete) on specified entries using predefined
    rules. ACLs are commonly defined in Odoo modules via XML files. For more details
    on ACLs, check out the ACLs tutorial in [*Chapter 10*](B20997_10.xhtml#_idTextAnchor549)*,*
    *Security Access*
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，Odoo中的**访问控制列表**（**ACLs**）用于管理记录和操作访问权限。ACLs通过预定义的规则指定谁可以在指定的条目上执行特定操作（如读取、写入、创建和删除）。ACLs通常通过XML文件在Odoo模块中定义。有关ACLs的更多详细信息，请参阅第10章的ACLs教程，*安全访问*。
- en: 'Add `security/ir.model.access.csv` to your data files:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `security/ir.model.access.csv` 添加到你的数据文件中：
- en: '[PRE9]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Add access security to the module in the `ir.model.data` CSV file:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `ir.model.data` CSV 文件中为模块添加访问安全设置：
- en: '[PRE10]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We now have an ACL that permits hostel managers to read book records, and it
    also allows them to edit, create, or delete them.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个 ACL，允许宿舍管理员读取图书记录，并且还允许他们编辑、创建或删除它们。
- en: How it works...
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: You simply drop all your data files into your manifest’s *data* list. Odoo will
    use the file extension to decide which type of file it is. A specialty of CSV
    files is that their filenames must match the name of the model to be imported
    – in our case, `ir.model.access`. The first line needs to be a header with column
    names that match the model’s field names exactly.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 你只需将所有数据文件放入你的清单的 *data* 列表中。Odoo 会根据文件扩展名来决定文件类型。CSV 文件的一个特点是它们的文件名必须与要导入的模型名称匹配——在我们的例子中是
    `ir.model.access`。第一行需要是一个包含与模型字段名称完全匹配的列名的标题。
- en: For scalar values, you can use a quoted (if necessary, because the string contains
    quotes or commas itself) or an unquoted string.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 对于标量值，你可以使用带引号（如果必要，因为字符串本身包含引号或逗号）或不带引号字符串。
- en: When writing *many2one* fields with a CSV file, Odoo first tries to interpret
    the column value as an XML ID. If there’s no dot, Odoo adds the current module
    name as a namespace and looks up the result in `ir.model.data`. If this fails,
    the model’s `name_search` function is called with the column’s value as a parameter,
    and the first returned result wins. If this also fails, the line is considered
    invalid and Odoo raises an error.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 CSV 文件编写 *many2one* 字段时，Odoo 首先尝试将列值解释为 XML ID。如果没有点，Odoo 会添加当前模块名称作为命名空间，并在
    `ir.model.data` 中查找结果。如果这失败了，就会调用模型的 `name_search` 函数，并将列的值作为参数传递，第一个返回的结果获胜。如果这也失败了，该行将被视为无效，Odoo
    会引发错误。
- en: Add-on updates and data migration
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加插件更新和数据迁移
- en: The data model you choose when writing an add-on module might turn out to have
    some weaknesses, so you may need to adjust it during the life cycle of your add-on
    module. In order to allow that without a lot of hacks, Odoo supports versioning
    in add-on modules and running migrations if necessary.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当编写插件模块时，你选择的数据库模型可能存在一些弱点，因此在插件模块的生命周期中你可能需要调整它。为了在不进行大量修改的情况下允许这样做，Odoo 支持在插件模块中进行版本控制和必要时运行迁移。
- en: How to do it...
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: We assume that in an earlier version of our module, the `allocation_date` field
    was a character field, where people wrote whatever they saw fit as the date. We
    now realize that we need this field for comparisons and aggregations, which is
    why we want to change its type to `Date`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设在我们模块的早期版本中，`allocation_date` 字段是一个字符字段，人们可以写下他们认为合适的日期。我们现在意识到我们需要这个字段来进行比较和聚合，这就是为什么我们想将其类型更改为
    `Date`。
- en: 'Odoo does a great job at type conversions, but in this case, we’re on our own,
    which is why we need to provide instructions as to how to transform a database
    with the previous version of our module installed on it, where the current version
    can run. Let’s try this with the following steps:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Odoo 在类型转换方面做得很好，但在这个案例中，我们得自己动手，这就是为什么我们需要提供如何将安装了模块早期版本的数据库转换为当前版本可以运行的指导。让我们按照以下步骤尝试：
- en: 'Bump the version in your `__manifest__.py` file:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的 `__manifest__.py` 文件中增加版本号：
- en: '[PRE11]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Provide the pre-migration code in `migrations/17.0.1.0.1/pre-migrate.py`:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `migrations/17.0.1.0.1/pre-migrate.py` 中提供迁移前的代码：
- en: '[PRE12]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Provide the post-migration code in `migrations/17.0.1.0.1/post-migrate.py`:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `migrations/17.0.1.0.1/post-migrate.py` 中提供迁移后的代码：
- en: '[PRE13]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Without this code, Odoo would have renamed the old `allocation_date` column
    `allocation_date_moved` and created a new one, as there’s no automatic conversion
    from character fields to date fields. From the point of view of the user, the
    data in `allocation_date` is simply gone.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有这段代码，Odoo 会将旧的 `allocation_date` 列重命名为 `allocation_date_moved` 并创建一个新的列，因为没有从字符字段到日期字段的自动转换。从用户的角度来看，`allocation_date`
    中的数据就消失了。
- en: How it works...
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The first crucial point is that you increase the version number of your add-on,
    as migrations run only between different versions. During every update, Odoo writes
    the version number from the manifest at the time of the update into the `ir_module_module`
    table. The version number is prefixed with Odoo’s major and minor versions if
    the version number has three or fewer components. In the preceding example, we
    explicitly named Odoo’s major and minor version, which is good practice, but a
    value of `1.0.1` would have had the same effect because, internally, Odoo prefixes
    short version numbers for add-ons with its own major and minor version numbers.
    Generally, using the long notation is a good idea because you can see at a glance
    which version of Odoo an add-on is meant for.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个关键点是增加您附加组件的版本号，因为迁移仅在不同版本之间运行。在每次更新期间，Odoo都会将更新时清单中的版本号写入`ir_module_module`表。如果版本号有三个或更少的组件，则版本号前面会加上Odoo的主版本和次版本。在前面的例子中，我们明确地命名了Odoo的主版本和次版本，这是一个好习惯，但`1.0.1`的值也会有相同的效果，因为内部Odoo会为附加组件的短版本号添加其自己的主版本和次版本号。通常，使用长表示法是一个好主意，因为您可以一眼看出附加组件是为哪个版本的Odoo准备的。
- en: The two migration files are just code files that don’t need to be registered
    anywhere. When updating an add-on, Odoo compares the add-on’s version, as noted
    in `ir_module_module`, with the version in the add-on’s manifest. If the manifest’s
    version is higher (after adding Odoo’s major and minor version), this add-on’s
    `migrations` folder will be searched to see whether it contains folders with the
    version(s) in between, up to and including the version that is currently updated.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个迁移文件仅仅是代码文件，不需要在任何地方注册。当更新附加组件时，Odoo会将`ir_module_module`中记录的附加组件版本与附加组件清单中的版本进行比较。如果清单的版本更高（在添加Odoo的主版本和次版本之后），则将在`migrations`文件夹中搜索，看是否包含包含版本（s）的文件夹，包括当前更新的版本。
- en: Then, within the folders found, Odoo searches for Python files whose names start
    with `pre-`, loads them, and expects them to define a function called `migrate`,
    which has two parameters. This function is called with a database cursor as the
    first argument and the currently installed version as the second argument. This
    happens before Odoo even looks at the rest of the code that the add-on defines,
    so you can assume that nothing changes in your database layout compared to the
    previous version.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在找到的文件夹中，Odoo会搜索以`pre-`开头的Python文件，加载它们，并期望它们定义一个名为`migrate`的函数，该函数有两个参数。这个函数以数据库游标作为第一个参数，当前安装的版本作为第二个参数调用。这发生在Odoo甚至查看附加组件定义的其余代码之前，因此您可以假设与上一个版本相比，您的数据库布局没有发生变化。
- en: After all the `pre-migrate` functions run successfully, Odoo loads the models
    and the data declared in the add-on, which can cause changes in the database layout.
    Given that we renamed `date_release in pre-migrate.py`, Odoo will just create
    a new column with that name but with the correct data type.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有`pre-migrate`函数成功运行之后，Odoo会加载附加组件中声明的模型和数据，这可能会导致数据库布局发生变化。鉴于我们在`pre-migrate.py`中重命名了`date_release`，Odoo将仅创建一个具有该名称的新列，但具有正确的数据类型。
- en: After that, with the same search algorithm, the `post-migrate` files will be
    searched and executed if found. In our case, we need to look at every value to
    see whether we can make something usable out of it; otherwise, we keep the data
    as `NULL`. Don’t write scripts that iterate over a whole table if not absolutely
    necessary; in this case, we would have written a very big, unreadable SQL switch.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，使用相同的搜索算法，将搜索并执行找到的`post-migrate`文件。在我们的例子中，我们需要查看每个值，看看我们是否可以从中提取出有用的东西；否则，我们将数据保留为`NULL`。如果不是绝对必要，不要编写遍历整个表的脚本；在这种情况下，我们会编写一个非常大、难以阅读的SQL开关。
- en: Important tip
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: If you simply want to rename a column, you don’t need a migration script. In
    this case, you can set the `oldname` parameter of the field in question to the
    field’s original column name; Odoo then takes care of the renaming itself.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您只想重命名一个列，您不需要迁移脚本。在这种情况下，您可以将字段的`oldname`参数设置为字段的原始列名；然后Odoo会自行处理重命名。
- en: There’s more...
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'In both the pre- and post-migration steps, you only have access to a cursor,
    which is not very convenient if you’re used to Odoo environments. It can lead
    to unexpected results to use models at this stage because, in the pre-migration
    step, the add-on’s models are not yet loaded, and also, in the post-migration
    step, the models defined by add-ons that depend on the current add-on are not
    yet loaded either. However, if this is not a problem for you, either because you
    want to use a model that your add-on doesn’t touch or a model for which you know
    that this issue is not a problem, you can create the environment you’re used to
    by writing the following:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在迁移前和迁移后的步骤中，你只能访问到一个游标，如果你习惯了 Odoo 环境，这并不太方便。在这个阶段使用模型可能会导致意外结果，因为在迁移前步骤中，附加组件的模型尚未加载，而且在迁移后步骤中，依赖于当前附加组件的附加组件定义的模型也尚未加载。然而，如果你不介意这个问题，要么是因为你想使用你的附加组件没有触及到的模型，要么是因为你知道这个问题不会成为问题，你可以通过编写以下内容来创建你习惯的环境：
- en: '[PRE14]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: See also
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: When writing migration scripts, you’ll often be confronted with repetitive tasks,
    such as checking whether a column or table exists, renaming things, or mapping
    some old values to new values. It’s frustrating and error-prone to reinvent the
    wheel here; consider using [https://github.com/OCA/openupgradelib](https://github.com/OCA/openupgradelib)
    if you can afford the extra dependency.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写迁移脚本时，你经常会遇到重复的任务，例如检查列或表是否存在，重命名事物，或将一些旧值映射到新值。在这里重新发明轮子既令人沮丧又容易出错；如果你能承担额外的依赖，可以考虑使用
    [https://github.com/OCA/openupgradelib](https://github.com/OCA/openupgradelib)。
- en: Deleting records from XML files
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从 XML 文件中删除记录
- en: We learned how to generate or change records from the XML file in the previous
    tutorials. You may occasionally wish to remove the records that have already been
    created from the dependent module. The `<delete>` tag can be used.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的教程中，我们学习了如何从 XML 文件中生成或更改记录。你可能会偶尔希望删除由依赖模块创建的记录。可以使用 `<delete>` 标签。
- en: Getting ready
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In this tutorial, we will add some categories from the XML file and then delete
    them. In real situations, you will create this record from another module. But
    for simplicity, we will just add some categories to the same XML file, as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将从 XML 文件中添加一些类别，然后删除它们。在实际情况中，你将从这个模块创建此记录。但为了简单起见，我们将在同一个 XML 文件中添加一些类别，如下所示：
- en: '[PRE15]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: How to do it...
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'There are two ways to remove records from the XML file:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 从 XML 文件中删除记录有两种方法：
- en: 'Using the XML ID of previously created records:'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用之前创建的记录的 XML ID：
- en: '[PRE16]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'With the search domain:'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用搜索域：
- en: '[PRE17]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: How it works...
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: You will need to use the `<delete>` tag. To remove a record from a model, you
    need to provide the name of the model in the `model` attribute. This is a mandatory
    attribute.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 你将需要使用 `<delete>` 标签。要从模型中删除记录，你需要提供模型名称作为 `model` 属性的值。这是一个必填属性。
- en: The XML IDs of the records that had been generated from the data files of another
    module must be supplied in the first method. Odoo will look for the record while
    installing the module. If the specified XML ID matches a record, the record will
    be deleted; otherwise, an error will be raised. Only records that were generated
    from XML files (or records with XML IDs) are able to be deleted.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 必须在第一种方法中提供由另一个模块的数据文件生成的记录的 XML ID。Odoo 在安装模块时会查找记录。如果指定的 XML ID 与记录匹配，则该记录将被删除；否则，将引发错误。只有从
    XML 文件（或具有 XML ID 的记录）生成的记录才能被删除。
- en: In the second method, you need to pass the domain in the `domain` attribute.
    During the installation of the module, Odoo will search the records by this domain.
    If records are found, it deletes them. This option will not raise an error if
    no records match the given domain. Use this option with extreme caution because
    it might delete your user’s data, since the search option deletes all the records
    that match the domain.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二种方法中，你需要通过 `domain` 属性传递域。在模块安装期间，Odoo 将根据此域搜索记录。如果找到记录，则将其删除。如果没有记录匹配给定的域，则此选项不会引发错误。使用此选项时要极其小心，因为它可能会删除用户的数据，因为搜索选项会删除所有匹配域的记录。
- en: Warning
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: '`<delete>` is rarely used in Odoo, as it is dangerous. If you are not careful
    with this, you might break the system. Avoid it if possible.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`<delete>` 在 Odoo 中很少使用，因为它很危险。如果你不小心，可能会破坏系统。如果可能的话，尽量避免使用它。'
- en: Invoking functions from XML files
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从 XML 文件中调用函数
- en: You can create all types of records from XML files, but sometimes, it is difficult
    to generate data that includes some business logic. You might want to modify records
    when a user installs a dependent module in production. In this case, you can invoke
    the `model` method through the `<``function>` tag.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从XML文件创建所有类型的记录，但有时，生成包含一些业务逻辑的数据可能很困难。你可能想在生产环境中安装依赖模块时修改记录。在这种情况下，你可以通过`<function>`标签调用`model`方法。
- en: How to do it...
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: For this tutorial, we will use the code from the previous tutorial. As an example,
    we will increase the existing room price by $10 USD. Note that you might use another
    currency based on company configurations.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个教程，我们将使用上一个教程中的代码。作为一个例子，我们将增加现有房间的价格10美元。请注意，你可能根据公司配置使用其他货币。
- en: 'Follow these steps to invoke the Python method from the XML file:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤从XML文件中调用Python方法：
- en: 'Add the `_update_room_price()` method to the `hostel.room` model:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`_update_room_price()`方法添加到`hostel.room`模型中：
- en: '[PRE18]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Add `<function>` to the data XML file:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`<function>`添加到数据XML文件中：
- en: '[PRE19]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: How it works...
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In *step 1*, we added the `_update_room_price()` method, which searches for
    all books and increases the price by $10 USD. We started the method name with
    `_`, as this is considered private by ORM and cannot be invoked through RPC.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤 1*中，我们添加了`_update_room_price()`方法，该方法搜索所有书籍并将价格增加10美元。我们以`_`开始方法名，因为在ORM中这被认为是私有的，不能通过RPC调用。
- en: 'In *step 2*, we used the `<function>` tag with two attributes:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤 2*中，我们使用了带有两个属性的`<function>`标签：
- en: '`model`: The model name with which the method is declared'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`model`：声明方法的模型名'
- en: '`name`: The name of the method you want to invoke'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`：你想调用的方法名'
- en: When you install this module, `_update_room_price()` will be called and the
    price of books will increase by $10 USD.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 当你安装这个模块时，`_update_room_price()`将被调用，并且书籍的价格将增加10美元。
- en: Important note
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Always use this function with the `noupdate` options. Otherwise, it will be
    invoked every time you update your module.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 总是使用这个功能时带上`noupdate`选项。否则，每次你更新你的模块时它都会被调用。
- en: There’s more...
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: With `<function>`, it is also possible to send parameters to the functions.
    Let’s say you only want to increase the price of rooms in a particular category
    and you want to send that amount as a parameter.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`<function>`，你也可以向函数发送参数。比如说，你只想增加特定类别的房间价格，并且你想将这个金额作为参数发送。
- en: 'To do that, you need to create a method that accepts the category as a parameter,
    as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，你需要创建一个接受类别作为参数的方法，如下所示：
- en: '[PRE20]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'To pass the category and amount as a parameter, you need to use the `eval`
    attribute, as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 要将类别和金额作为参数传递，你需要使用`eval`属性，如下所示：
- en: '[PRE21]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: When you install the module, it will increase the price of the rooms of the
    given category by $20 USD.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 当你安装模块时，它将增加指定类别的房间价格20美元。
