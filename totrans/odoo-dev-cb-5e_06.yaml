- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Managing Module Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Odoo, managing module data involves various tasks such as creating, updating,
    and deleting records in a database upon installation, upgrade, or removal of a
    module. This is typically done through XML files called data files.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll study how add-on modules might offer data during installation in this
    chapter. This helps us when we provide metadata, such as view descriptions, menus,
    or actions, or when we provide default settings. Another important usage is providing
    demonstration data, which is loaded when a database is created with the **Load
    demonstration data** checkbox checked.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Using external IDs and namespaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loading data using XML files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `noupdate` and `forcecreate` flags
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loading data using CSV files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add-on updates and data migration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deleting records from XML files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Invoking functions from XML files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The technical requirements for this chapter include the online Odoo platform.
  prefs: []
  type: TYPE_NORMAL
- en: 'All the code that’s used in this chapter can be downloaded from the following
    GitHub repository: [https://github.com/PacktPublishing/Odoo-17-Development-Cookbook-Fifth-Edition/tree/main/Chapter06](https://github.com/PacktPublishing/Odoo-17-Development-Cookbook-Fifth-Edition/tree/main/Chapter06).'
  prefs: []
  type: TYPE_NORMAL
- en: In order to avoid repeating a lot of code, we’ll make use of the models that
    were defined in [*Chapter 4*](B20997_04.xhtml#_idTextAnchor118), *Application
    Models*. To follow these examples, make sure you grab the code from the `my_hostel`
    module from `Chapter05/my_hostel`.
  prefs: []
  type: TYPE_NORMAL
- en: Using external IDs and namespaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Records in Odoo are identified using external IDs or XML IDs. We have utilized
    XML IDs so far in this book in areas such as views, menus, and actions, but we
    still don’t know what an XML ID is. This recipe will give you more clarity about
    it.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will write in the already-existing records to demonstrate how to use cross-module
    references:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the manifest file of the `my_hostel` module by registering a data file
    like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new room in the `hostel.room` model:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Change the name of the main company:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Install the module to apply the changes. After installation, a new record for
    the `Hostel Room 01` room will be created, and the company will be renamed `Packt
    Publishing`.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An XML ID is a string that refers to a record in the database. The IDs themselves
    are records of their `ir.model.data` model. This model includes information such
    as the module name that declares the XML ID, the ID string, the referred model,
    and the referred ID.
  prefs: []
  type: TYPE_NORMAL
- en: Every time we use an XML ID on a `<record>` tag, Odoo checks whether the string
    is namespaced (that is, whether it contains exactly one dot), and if not, it adds
    the current module name as a namespace. Then, it looks up whether there is already
    a record in `ir.model.data` with the specified name. If so, an `UPDATE` statement
    for the listed fields is executed; if not, a `CREATE` statement is executed. This
    is how you can provide partial data when a record already exists, as we did earlier.
  prefs: []
  type: TYPE_NORMAL
- en: In the first example of this tutorial, the record has the ID `hostel_room_1`.
    As it is not namespaced, the final external ID will have a module name like this
    – `my_hostel.hostel_room_1`. Then, Odoo will try to find a record for `my_hostel.hostel_room_1`.
    As Odoo doesn’t have a record for that external ID yet, it will generate a new
    record in the `hostel.room` model.
  prefs: []
  type: TYPE_NORMAL
- en: In the second example, we have used the external ID of the main company, which
    is `base.main_company`. As its namespace suggests, it is loaded from the base
    module. As the external ID is already present, instead of creating a record, Odoo
    will perform the write `(UPDATE)` operation so that the company name will change
    to `Packt Publishing`.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: A widespread application for partial data, apart from changing records defined
    by other modules, is using a shortcut element to create a record conveniently
    and writing a field on that record, which is not supported by the shortcut element
    – `<act_window id="my_action" name="My action" model="res.partner" /><record id="my_action"
    model="ir.actions.act_window"> <field name="auto_search"` `eval="False" /></record>`.
  prefs: []
  type: TYPE_NORMAL
- en: In Odoo, the `ref` function is used to establish relationships between different
    records within the system. It allows you to create references from one record
    to another, typically using a *many2one* relationship.
  prefs: []
  type: TYPE_NORMAL
- en: The `ref` function, as used in the *Loading data using XML files* tutorial of
    this chapter, also adds the current module as a namespace if appropriate but raises
    an error if the resulting XML ID does not exist already. This also applies to
    the `id` attribute if it is not namespaced already.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to see the list of all external identifiers, start developer mode
    and open the menu at **Settings** | **Technical** | **Sequence & Identifiers**
    | **External Identifiers**.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You will probably need to access records with an XML ID from your Python code
    sooner or later. Use the `self.env.ref()` function in these cases. This returns
    a browse record (`recordset`) of the referenced record. Note that, here, you always
    have to pass the full XML ID. Here’s an example of a full XML ID – `<``module_name>.<record_id>`.
  prefs: []
  type: TYPE_NORMAL
- en: Sooner or later, you’ll probably need to use Python code to retrieve records
    that have an XML ID. In these circumstances, use the `self.env.ref()` method.
    This gives you access to the linked record’s browsing record (`recordset`). Keep
    in mind that you must always pass the complete XML ID here.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see the XML ID of any record from the user interface. For that, you
    need to activate developer mode in Odoo; refer to [*Chapter 1*](B20997_01.xhtml#_idTextAnchor020),
    *Installing the Odoo Development Environment*, to do so. After activating developer
    mode, open the **Form** view of the record for which you want to find out the
    XML ID. You will see a bug icon in the top bar. From that menu, click on the **View
    Metadata** option. See the following screenshot for reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1 – The menu to open a record’s metadata](img/B20997_06_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.1 – The menu to open a record’s metadata
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Consult the *Using the noupdate and forcecreate flags* tutorial of this chapter
    to find out why the company’s name is only changed during the installation of
    the module.
  prefs: []
  type: TYPE_NORMAL
- en: Loading data using XML files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous tutorial, we created the new room record with the `hostel_room_1`
    external identifier. In this tutorial, we will add a different type of data from
    the XML file. We’ll add a room and an author as demonstration data. We’ll also
    add a well-known publisher as normal data to our module.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Follow the following steps to create two data XML files and link them in `your__manifest__.py`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a file called `data/demo.xml` to your manifest, in the `demo` section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following content to this file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a file called `data/data.xml` to your manifest, in the `data` section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following XML content to the `data/data.xml` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When you update your module now, you’ll see the publisher we created, and if
    your database has demo data enabled, as pointed out in [*Chapter 3*](B20997_03.xhtml#_idTextAnchor083),
    *Creating Add-On Odoo Modules*, you’ll also find this room and its members.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The data XML files uses the `<record>` tag to create a row in the database table.
    The `<record>` tag has two mandatory attributes, `id` and `model`. For the `id`
    attribute, consult the *Using external IDs and namespaces* tutorial; the `model`
    attribute refers to a model’s `_name` property. Then, we use the `<field>` element
    to fill the columns in the database, as defined by the model you named. The model
    also decides which fields it is mandatory to fill and also defines the default
    values. In this case, you don’t need to give those fields a value explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: There are two ways to register data XML files in a module manifest. The first
    is with the `data` key and the second is with the `demo` key. The XML files in
    the `data` key are loaded every time you install or update the module, while XML
    files with `demo` keys are loaded only if you enabled demo data for your database.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 1*, we registered a `data XML` file in the manifest with the `demo`
    key. Because we are using the demo key, the `XML` file will be loaded only if
    you have enabled demo data for the database.
  prefs: []
  type: TYPE_NORMAL
- en: In *step 2*, the `<field>` element can contain a value as simple text in the
    case of scalar values. If you need to pass the content of a file (to set an image,
    for example), use the `file` attribute on the `<field>` element and pass the file’s
    name relative to the add-ons path.
  prefs: []
  type: TYPE_NORMAL
- en: To set up references, there are two possibilities. The simplest is using the
    `ref` attribute, which works for *many2one* fields and just contains the XML ID
    of the record to be referenced. For *one2many* and *many2many* fields, we need
    to use the `eval` attribute. Use the `eval` attribute in XML to evaluate expressions
    dynamically. This is a general-purpose attribute that can be used to evaluate
    Python code to use as the field’s value. Normally, content within `<field>` tags
    is treated as strings – for example, `<field name="value">4.5</field>`. This will
    evaluate to the string `4.5` and not `float`. If you want to evaluate the value
    to a float, a Boolean, or another type, except `string`, you need to use the eval
    attribute, such as `<field name="value" eval="4.5" /> <field name="value"` `eval="False"
    />`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s another example – think of `strftime(''%Y-01-01'')` as a way to populate
    a `date` field. `X2many` fields expect to be populated by a list of three tuples,
    where the first value of the tuple determines the operation to be carried out.
    Within an `eval` attribute, we have access to a function called `ref`, which returns
    the database ID of an XML ID, given as a string. This allows us to refer to a
    record without knowing its concrete ID, which is probably different in different
    databases, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`(2, id, False)`: This deletes the linked record with `id` from the database.
    The third element of the tuple is ignored.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(3, id, False)`: This detaches the record with `id` from the `one2many` field.
    Note that this operation does not delete the record – it just leaves the existing
    record as it is. The last element of the tuple is also ignored.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(4, id, False)`: This adds a link to the existing record `id`, and the last
    element of the tuple is ignored. This should be what you use most of the time,
    usually accompanied by the `ref` function to get the database ID of a record known
    by its XML ID.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(5, False, False)`: This cuts all links but keeps the linked records intact.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(6, False, [id, ...])`: This clears out currently referenced records to replace
    them with the ones mentioned in the list of IDs. The second element of the tuple
    is ignored.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Note that order matters in data files and that records within data files can
    only refer to records defined in data files earlier in the list. This is why you
    should always check whether your module installs in an empty database because,
    during development, you often add records all over the place, and the records
    defined afterward are already in the database from an earlier update.
  prefs: []
  type: TYPE_NORMAL
- en: Demo data is always loaded after the files from the `data` key, which is why
    the reference in this example works.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While you can do basically anything with the `record` element, there are shortcut
    elements that make it more convenient for a developer to create certain kinds
    of records. These include menu items, templates, and act windows. Refer to [*Chapter
    9*](B20997_09.xhtml#_idTextAnchor446), *Backend Views*, and [*Chapter 14*](B20997_14.xhtml#_idTextAnchor734),
    *CMS Website Development*, for more information about these.
  prefs: []
  type: TYPE_NORMAL
- en: A `field` element can also contain the `function` element, which calls a function
    defined on a model to provide a field’s value. Refer to the *Invoking functions
    from XML files* tutorial for an application in which we simply call a function
    to directly write to the database, circumventing the loading mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding list misses entries for `0` and `1` because they are not very
    useful when loading the data. They are entered, as follows, for the sake of completeness:'
  prefs: []
  type: TYPE_NORMAL
- en: '`(0, False, {''key'': value})`: This creates a new record of the referenced
    model, with its fields filled from the dictionary at position three. The second
    element of the tuple is ignored. As these records don’t have an XML ID and are
    evaluated every time the module is updated, leading to double entries, it’s better
    to avoid this. Instead, create the record in its own record element, and link
    it as explained in the *How it works…* section of this tutorial.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(1, id, {''key'': value})`: This can be used to write on an existing linked
    record. For the same reasons that we mentioned earlier, you should avoid this
    syntax in your XML files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These syntaxes are the same as the ones we explained in the *Creating new records*
    and *Updating values of records* tutorials in [*Chapter 5*](B20997_05.xhtml#_idTextAnchor238),
    *Basic* *Server-Side Development*.
  prefs: []
  type: TYPE_NORMAL
- en: Using the noupdate and forcecreate flags
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most add-on modules have different types of data. Some data simply needs to
    exist for the module to work properly, other data shouldn’t be changed by the
    user, and most data can be changed as the user wants and is only provided as a
    convenience. This tutorial will detail how to address the different types. First,
    we’ll write a field in an already-existing record, and then we’ll create a record
    that is supposed to be recreated during a module update.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can enforce different behaviors from Odoo when loading data by setting certain
    attributes on the enclosing `<odoo>` element, or the `<record>` element itself:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a publisher that will be created at installation time but not updated on
    subsequent updates. However, if the user deletes it, it will be recreated:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a `room` category that is not changed during add-on updates and is not
    recreated if the user deletes it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `<odoo>` element can have a `noupdate` attribute, which is propagated to
    the `ir.model.data` records that are created when reading the enclosed data records
    for the first time, thus ending up as a column in this table.
  prefs: []
  type: TYPE_NORMAL
- en: When Odoo installs an add-on (called `init` mode), all records are written,
    whether `noupdate` is `true` or `false`. When you update an add-on (called `update`
    mode), the existing XML IDs are checked to see whether they have the `noupdate`
    flag set, and if so, elements that try to write to this XML ID are ignored. This
    is not the case if the record in question was deleted by the user, which is why
    you can force `notrecreate` `noupdate` records in `update` mode by setting the
    `forcecreate` flag on the record to `false`.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: In legacy add-ons (prior to and including version 8.0), you’ll often find an
    `<openerp>` element enclosing a `<data>` element, which contains `<record>` and
    other elements. This is still possible but deprecated. Now, `<odoo>`, `<openerp>`,
    and `<data>` have exactly the same semantics; they are meant as a bracket to enclose
    XML data.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you want to load records even with the `noupdate` flag, you can run the Odoo
    server with the `--init=your_addon` or `-i your_addon` parameter. This will force
    Odoo to reload your records. However, this will also cause deleted records to
    be recreated. Note that this can cause double records and related installation
    errors if a module circumvents the XML ID mechanism – for example, by creating
    records in Python code called by the `<``function>` tag.
  prefs: []
  type: TYPE_NORMAL
- en: With this code, you can circumvent any `noupdate` flag, but first, make sure
    that this is really what you want. Another option to solve the scenario presented
    here is to write a migration script, as outlined in the *Add-on updates and data*
    *migration* tutorial.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Odoo also uses XML IDs to keep track of which data is to be deleted after an
    add-on update. If a record has an XML ID from the module’s namespace before the
    update but the XML ID is not reinstated during the update, the record and its
    XML ID will be deleted from the database because they’re considered obsolete.
    For a more in-depth discussion of this mechanism, refer to the *Add-on updates
    and data* *migration* tutorial.
  prefs: []
  type: TYPE_NORMAL
- en: Loading data using CSV files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While you can do everything you need to with XML files, this format is not the
    most convenient when you need to provide larger amounts of data, especially given
    that many people are more comfortable preprocessing data in Calc or other spreadsheet
    software. Another advantage of the CSV format is that it is what you get when
    you use the standard `export` function. In this tutorial, we’ll take a look at
    importing table-like data.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Traditionally, **access-control lists** (**ACLs**) in Odoo are used to manage
    record and operation access rights. ACLs specify who can execute particular actions
    (such as read, write, create, and delete) on specified entries using predefined
    rules. ACLs are commonly defined in Odoo modules via XML files. For more details
    on ACLs, check out the ACLs tutorial in [*Chapter 10*](B20997_10.xhtml#_idTextAnchor549)*,*
    *Security Access*
  prefs: []
  type: TYPE_NORMAL
- en: 'Add `security/ir.model.access.csv` to your data files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Add access security to the module in the `ir.model.data` CSV file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We now have an ACL that permits hostel managers to read book records, and it
    also allows them to edit, create, or delete them.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You simply drop all your data files into your manifest’s *data* list. Odoo will
    use the file extension to decide which type of file it is. A specialty of CSV
    files is that their filenames must match the name of the model to be imported
    – in our case, `ir.model.access`. The first line needs to be a header with column
    names that match the model’s field names exactly.
  prefs: []
  type: TYPE_NORMAL
- en: For scalar values, you can use a quoted (if necessary, because the string contains
    quotes or commas itself) or an unquoted string.
  prefs: []
  type: TYPE_NORMAL
- en: When writing *many2one* fields with a CSV file, Odoo first tries to interpret
    the column value as an XML ID. If there’s no dot, Odoo adds the current module
    name as a namespace and looks up the result in `ir.model.data`. If this fails,
    the model’s `name_search` function is called with the column’s value as a parameter,
    and the first returned result wins. If this also fails, the line is considered
    invalid and Odoo raises an error.
  prefs: []
  type: TYPE_NORMAL
- en: Add-on updates and data migration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The data model you choose when writing an add-on module might turn out to have
    some weaknesses, so you may need to adjust it during the life cycle of your add-on
    module. In order to allow that without a lot of hacks, Odoo supports versioning
    in add-on modules and running migrations if necessary.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We assume that in an earlier version of our module, the `allocation_date` field
    was a character field, where people wrote whatever they saw fit as the date. We
    now realize that we need this field for comparisons and aggregations, which is
    why we want to change its type to `Date`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Odoo does a great job at type conversions, but in this case, we’re on our own,
    which is why we need to provide instructions as to how to transform a database
    with the previous version of our module installed on it, where the current version
    can run. Let’s try this with the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Bump the version in your `__manifest__.py` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Provide the pre-migration code in `migrations/17.0.1.0.1/pre-migrate.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Provide the post-migration code in `migrations/17.0.1.0.1/post-migrate.py`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Without this code, Odoo would have renamed the old `allocation_date` column
    `allocation_date_moved` and created a new one, as there’s no automatic conversion
    from character fields to date fields. From the point of view of the user, the
    data in `allocation_date` is simply gone.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first crucial point is that you increase the version number of your add-on,
    as migrations run only between different versions. During every update, Odoo writes
    the version number from the manifest at the time of the update into the `ir_module_module`
    table. The version number is prefixed with Odoo’s major and minor versions if
    the version number has three or fewer components. In the preceding example, we
    explicitly named Odoo’s major and minor version, which is good practice, but a
    value of `1.0.1` would have had the same effect because, internally, Odoo prefixes
    short version numbers for add-ons with its own major and minor version numbers.
    Generally, using the long notation is a good idea because you can see at a glance
    which version of Odoo an add-on is meant for.
  prefs: []
  type: TYPE_NORMAL
- en: The two migration files are just code files that don’t need to be registered
    anywhere. When updating an add-on, Odoo compares the add-on’s version, as noted
    in `ir_module_module`, with the version in the add-on’s manifest. If the manifest’s
    version is higher (after adding Odoo’s major and minor version), this add-on’s
    `migrations` folder will be searched to see whether it contains folders with the
    version(s) in between, up to and including the version that is currently updated.
  prefs: []
  type: TYPE_NORMAL
- en: Then, within the folders found, Odoo searches for Python files whose names start
    with `pre-`, loads them, and expects them to define a function called `migrate`,
    which has two parameters. This function is called with a database cursor as the
    first argument and the currently installed version as the second argument. This
    happens before Odoo even looks at the rest of the code that the add-on defines,
    so you can assume that nothing changes in your database layout compared to the
    previous version.
  prefs: []
  type: TYPE_NORMAL
- en: After all the `pre-migrate` functions run successfully, Odoo loads the models
    and the data declared in the add-on, which can cause changes in the database layout.
    Given that we renamed `date_release in pre-migrate.py`, Odoo will just create
    a new column with that name but with the correct data type.
  prefs: []
  type: TYPE_NORMAL
- en: After that, with the same search algorithm, the `post-migrate` files will be
    searched and executed if found. In our case, we need to look at every value to
    see whether we can make something usable out of it; otherwise, we keep the data
    as `NULL`. Don’t write scripts that iterate over a whole table if not absolutely
    necessary; in this case, we would have written a very big, unreadable SQL switch.
  prefs: []
  type: TYPE_NORMAL
- en: Important tip
  prefs: []
  type: TYPE_NORMAL
- en: If you simply want to rename a column, you don’t need a migration script. In
    this case, you can set the `oldname` parameter of the field in question to the
    field’s original column name; Odoo then takes care of the renaming itself.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In both the pre- and post-migration steps, you only have access to a cursor,
    which is not very convenient if you’re used to Odoo environments. It can lead
    to unexpected results to use models at this stage because, in the pre-migration
    step, the add-on’s models are not yet loaded, and also, in the post-migration
    step, the models defined by add-ons that depend on the current add-on are not
    yet loaded either. However, if this is not a problem for you, either because you
    want to use a model that your add-on doesn’t touch or a model for which you know
    that this issue is not a problem, you can create the environment you’re used to
    by writing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When writing migration scripts, you’ll often be confronted with repetitive tasks,
    such as checking whether a column or table exists, renaming things, or mapping
    some old values to new values. It’s frustrating and error-prone to reinvent the
    wheel here; consider using [https://github.com/OCA/openupgradelib](https://github.com/OCA/openupgradelib)
    if you can afford the extra dependency.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting records from XML files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We learned how to generate or change records from the XML file in the previous
    tutorials. You may occasionally wish to remove the records that have already been
    created from the dependent module. The `<delete>` tag can be used.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this tutorial, we will add some categories from the XML file and then delete
    them. In real situations, you will create this record from another module. But
    for simplicity, we will just add some categories to the same XML file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two ways to remove records from the XML file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the XML ID of previously created records:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With the search domain:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You will need to use the `<delete>` tag. To remove a record from a model, you
    need to provide the name of the model in the `model` attribute. This is a mandatory
    attribute.
  prefs: []
  type: TYPE_NORMAL
- en: The XML IDs of the records that had been generated from the data files of another
    module must be supplied in the first method. Odoo will look for the record while
    installing the module. If the specified XML ID matches a record, the record will
    be deleted; otherwise, an error will be raised. Only records that were generated
    from XML files (or records with XML IDs) are able to be deleted.
  prefs: []
  type: TYPE_NORMAL
- en: In the second method, you need to pass the domain in the `domain` attribute.
    During the installation of the module, Odoo will search the records by this domain.
    If records are found, it deletes them. This option will not raise an error if
    no records match the given domain. Use this option with extreme caution because
    it might delete your user’s data, since the search option deletes all the records
    that match the domain.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: '`<delete>` is rarely used in Odoo, as it is dangerous. If you are not careful
    with this, you might break the system. Avoid it if possible.'
  prefs: []
  type: TYPE_NORMAL
- en: Invoking functions from XML files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can create all types of records from XML files, but sometimes, it is difficult
    to generate data that includes some business logic. You might want to modify records
    when a user installs a dependent module in production. In this case, you can invoke
    the `model` method through the `<``function>` tag.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this tutorial, we will use the code from the previous tutorial. As an example,
    we will increase the existing room price by $10 USD. Note that you might use another
    currency based on company configurations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to invoke the Python method from the XML file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `_update_room_price()` method to the `hostel.room` model:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add `<function>` to the data XML file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *step 1*, we added the `_update_room_price()` method, which searches for
    all books and increases the price by $10 USD. We started the method name with
    `_`, as this is considered private by ORM and cannot be invoked through RPC.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *step 2*, we used the `<function>` tag with two attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`model`: The model name with which the method is declared'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`name`: The name of the method you want to invoke'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you install this module, `_update_room_price()` will be called and the
    price of books will increase by $10 USD.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Always use this function with the `noupdate` options. Otherwise, it will be
    invoked every time you update your module.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With `<function>`, it is also possible to send parameters to the functions.
    Let’s say you only want to increase the price of rooms in a particular category
    and you want to send that amount as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do that, you need to create a method that accepts the category as a parameter,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'To pass the category and amount as a parameter, you need to use the `eval`
    attribute, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: When you install the module, it will increase the price of the rooms of the
    given category by $20 USD.
  prefs: []
  type: TYPE_NORMAL
