- en: Reactive Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, you learned about unit testing and the `unittest.mock`
    package. In this chapter, you will get a handle on the concepts of reactive programming
    and then take a look at the RxPY reactive programming framework. We'll work on
    solidifying your conceptual understanding of reactive programming and put together
    a very bare-bones reactive programming system from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will coverÂ the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What does reactive programming mean?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a simple reactive programming framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the **Reactive Extensions for Python** (**RxPY**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The concept of reactive programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a lot of different and valid ways that I could define reactive programming.
    It's a matter of perspective and focus. Which of them is the best definition?
    We're going to cover several in this section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perhaps, the most fundamental definition of reactive programming, at least
    in terms of what we need to think about to implement a reactive programming system,
    is that it''s a publish/subscribe model of event handling. The following diagram
    illustrates the basic reactive event handling:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/992c7bdd-b087-4da6-848f-4f01fc3cd7be.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the traditional nomenclature of reactive programming, there are **observables**
    and **observers**, which encapsulate the behavior of event publishers and event
    subscribers, respectively. In a reactive programming system, everything, or at
    least as much as possible, is an observable or an observer. So far, so good, but
    the publish/subscribe model by itself isn't really that exciting.
  prefs: []
  type: TYPE_NORMAL
- en: Reactive programming comes into its own when we recognize that an observable
    is conceptually very similar to a list, which means functional programming tools,
    such as map and reduce, have powerful analogues that apply to observables. So,
    the second definition of reactive programming is that it's **event-driven functional**
    programming.
  prefs: []
  type: TYPE_NORMAL
- en: The idea that we could, for example, take two observables, map a function over
    one of them, merge the result with the other, and reduce that merge sequence to
    a new value is a powerful one. We could describe all of the operations we want
    to perform ahead of time and whenever a new value comes out of one of the root
    observables, it will cascade through our whole processing chain, without further
    effort on our part.
  prefs: []
  type: TYPE_NORMAL
- en: Functional programming operations are mostly stateless and when they're not,
    the state is at least easy to define and keep contained. This means that our event-driven,
    mostly-stateless reactive programming systems are very well-suited to asynchronous
    or parallel execution. Thus, our third definition of reactive programming is that
    it's a systematic way of writing high-performance asynchronous or parallel code.
  prefs: []
  type: TYPE_NORMAL
- en: So, what is reactive programming? Let's bundle those definitions together. Reactive
    programming is an event-driven paradigm in which event sources can have functional
    operators applied to them to create new event sources. This is desirable because
    it results in programs that work well in asynchronous or parallel execution environments.
  prefs: []
  type: TYPE_NORMAL
- en: Building a simple reactive programming framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You have gained an understanding of what reactive programming means in a theoretical
    way. Now, we're going to get very concrete and build a simple reactive programming
    system, then build a demo so we can watch it in action. The roots of formalized
    reactive programming are in statically typed languages, particularly C#. That's
    of little concern to us as users of a language based around dynamic typing, but
    it does mean that the standard presentation of these ideas is heavily intertwined
    with types, templates, interfaces, and anonymous functions. We'll be a little
    less Pythonic here and perhaps a little more C#-ish. That said, let's move on
    to the coding.
  prefs: []
  type: TYPE_NORMAL
- en: Observers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Arguably, the single most fundamental element of a reactive programming system
    is the observer interface. The definition of how we can notify an object that
    the next item in a sequence is watching it is available. What we''re starting
    with in the following code example is an abstract base class, the closest Python
    equivalent to a C# interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4dea38a2-5d5b-40da-b390-3b93ddadf9ea.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Our `Observer` class doesn't define any functionality at all, just method names
    and signatures, and guarantees that classes which inherit from it will have to
    implement at least the `on_event` method. For a complete functionality, they'd
    have to implement `on_exception` and `on_complete` as well, but that's not required.
  prefs: []
  type: TYPE_NORMAL
- en: So, the intent is that an `Observer` class will have its `on_event` method called
    once for each element of the sequence, followed by its `on_complete` method if
    the sequence terminates while the observer is watching it. If something goes sideways,
    the `on_exception` method would be called instead.
  prefs: []
  type: TYPE_NORMAL
- en: For an `Observer` class to be useful, there must also be an `Observable` class.
    So, let's see the beginning of that class.
  prefs: []
  type: TYPE_NORMAL
- en: Observables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like `Observer`, `Observable` is an abstract base class, although in this case,
    we provide meaningful default implementations of all of its functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `subscribe` method, shown in the following code example, is how an `Observer`
    class connects to the `Observable` class, registering itself as a consumer of
    the events that the `Observable` class emits:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7b07d43e-abc6-4005-8c60-0ceb39272862.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Emitting events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are three methods which take care of emitting events. These are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: One for sending normal events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One for sending exceptions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One for sending a "this sequence has ended" event
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These are shown in the following code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/963c86ca-7b46-428f-a17e-2f2e3c118e6e.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In each case, they do a bit of error checking, then loop through the registered
    observers and invoke the appropriate method. These methods have names prefixed
    with a single underscore (`_`), marking them as not part of the public interface
    of the `Observable` class. They are helpers to make subclasses easier to write.
  prefs: []
  type: TYPE_NORMAL
- en: That can't possibly be a complete reactive programming system, can it? Yes and
    no. It is fundamentally complete, but it's lacking a great many refinements and
    in no way is it ready for a production environment. It will serve nicely as the
    spine for our demo program though, so let's move on to that.
  prefs: []
  type: TYPE_NORMAL
- en: Building the observable sequence
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For our demo, we'll make a program that prints messages loosely representing
    the sounds we might hear in a zoo. The animals will be represented as observables
    emitting events, representing sounds at random intervals. We'll use merging and
    mapping to combine and modify the event sequences, before finally printing out
    the resulting sequence.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, first of all, we have our `Animal` class, which is an observable, and the
    `AnimalEvent` helper class. The `Animal` class contains some basic information
    and a coroutine, which will run asynchronously and occasionally send events to
    the observers of the `Animal` class as shown in the following code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d76f72c0-3a3a-4ab6-8516-003fcbe54a45.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Looking at the preceding code, we can see that an animal is effectively a sequence
    of noise events, then a die event, immediately followed by the completion of the
    sequence.
  prefs: []
  type: TYPE_NORMAL
- en: We want some of our animals to be capable of creating loud noises. Instead of
    adding that capability to the `Animal` class, we'll create a mapping over the
    sequence of events, which replaces randomly selected noise events with loud noise
    events.
  prefs: []
  type: TYPE_NORMAL
- en: This mapping is both an observer, so that it can subscribe to the sequence of
    events, and an observable because the sequence of modified events is still a sequence
    of events and not much use if another observable can't subscribe to it.
  prefs: []
  type: TYPE_NORMAL
- en: This is fundamentally what happens in any reactive programming system when we
    apply an operator to an observable sequence to create a new observable sequence.
    However, in almost every case, a real reactive system provides us with a quicker,
    easier, and usually more efficient way of doing it.
  prefs: []
  type: TYPE_NORMAL
- en: Actually creating a class that's both observer and observable is rare indeed!
  prefs: []
  type: TYPE_NORMAL
- en: Illustrating a stream of animal events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There''s one more piece we need before we start putting things together and
    that''s a way to display a stream of animal events. Another observer is the obvious
    choice for that and it turns out to be quite easy, as you can see in the following
    code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0f250761-dcdf-4a76-a28d-199333e5d487.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The code for a new observer is similar to what we've already seen; all we need
    is a constructor and an appropriate `on_event` method.
  prefs: []
  type: TYPE_NORMAL
- en: Composing an observable sequence
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we''ve got all the pieces, how do we put them together to achieve
    our goal? Well, first we make our animal objects and then use the `SometimesLoud`
    and `Output` classes to create our modified composite sequence and display it
    as shown in the following code example from `animals.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/862005ac-4c88-48a4-9552-1343a5265725.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, we need to schedule the run methods of each animal for asynchronous execution
    via `asyncio`, which happens implicitly in this example when we pass them as parameters
    together in our `__main__.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1bf0ba87-74af-488a-8af6-d23a04f4bc72.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Our `__main__.py` file actually runs the `asyncio` event loop. So, now we can
    just sit back and watch the pseudo cacophony of our imaginary zoo, as shown in
    the following output window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8c9dc959-ee3b-4480-815c-9c799a4798f4.png)'
  prefs: []
  type: TYPE_IMG
- en: Did you notice how the meat of our program is boiled down to a single line of
    code?
  prefs: []
  type: TYPE_NORMAL
- en: Sure, we have a whole file devoted to the framework, but that's reusable. We
    also have the `SometimesLoud` and `Output` classes, but the only reason they're
    here is so we can see exactly what happens at each step of this program.
  prefs: []
  type: TYPE_NORMAL
- en: In a real system, `Output` and `SometimesLoud` would have used built-in functionality
    that mapped the function on the sequence, as we'll see in the next section. All
    of this leaves us with a single line of code that composites several observable
    sequences and transformations, and defines most of the behavior of the program.
    This one line demonstrates the power of reactive programming.
  prefs: []
  type: TYPE_NORMAL
- en: Using the reactive extensions for Python (RxPY)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have a basic understanding of reactive programming under our belts,
    let's look at one of the more widely used reactive programming frameworks called
    **Reactive Extensions**, which is often shortened to **ReactiveX**, or simply
    **Rx**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rx is not part of a standard Python installation, so we''ll need to use `pip`
    to install it. No problem; it''s only a single command, if you prefer to install
    to your Python system library instead of user library, or you are working in a
    virtual created by the `--user` from this command, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6a4d4269-fc26-4db2-b5f0-e7ab7f44b08b.png)'
  prefs: []
  type: TYPE_IMG
- en: Once we have Rx installed, we can move on to the fun stuff.
  prefs: []
  type: TYPE_NORMAL
- en: Translating our zoo demo into Rx
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like our example in the previous section, Rx provides `Observer` and `Observable`
    classes, and they encompass the same basic functionality.
  prefs: []
  type: TYPE_NORMAL
- en: The largest visible difference is that the `Observable` class of Rx has a large
    number of factory methods that could be used to construct special-purpose observables,
    especially, observables that produce a sequence based on one or more other observable
    sequences. In other words, most of the operators and operations that we'll use
    to construct a reactive dataflow are methods of the `Observable` class.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a moment to rewrite our demo from the previous section in Rx and
    we'll see what that means in practice.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `AnimalEvent` class can stay the same, since it''s just a data structure
    and doesn''t know anything about who''s using it for what. Our `Animal` class
    changes quite a bit. The run coroutine method goes away and in its place we have
    a somewhat simpler `generate_event` method (refer to the following code example):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/79366e77-2498-4d0e-9a3c-5418f9d1ab9c.jpg)'
  prefs: []
  type: TYPE_IMG
- en: That name isn't significant by the way; it's just a reasonable name I picked
    because it describes what the method does.
  prefs: []
  type: TYPE_NORMAL
- en: As shown in the preceding code, the `generate_event` method by itself doesn't
    encompass the entire functionality of the old run coroutine method, though. It
    knows how to emit an event, but it doesn't know how to wait a short while and
    do it again. That's where the `as_observable` method comes into play.
  prefs: []
  type: TYPE_NORMAL
- en: Observable factory methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `as_observable` method uses one of the factory methods of the `Observable`
    class to create an observable sequence. This sequence is backed up by what is
    functionally a generator, although it's not implemented as one because that concept
    doesn't exist in every language that Rx is portable to.
  prefs: []
  type: TYPE_NORMAL
- en: So, instead of a real generator, we're providing it with a state variable, which
    in this case is just the animal instance, along with functions it could call to
    check whether the sequences continue, update the state, get the next value in
    the sequence, or determine how long to wait before producing the next value. The
    factory method also accepts a scheduler object, which we'll discuss later in this
    section. So, what we're asking for in this code is an observable that produces
    animal events at random intervals from 0 to 10 seconds. Now, the `Animal` class
    may be a little simpler than it used to be; there's not a big difference.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, let''s take a look at what happens with the `SometimesLoud` and `Output`
    classes (refer to the following code example); they''re not classes anymore, just
    functions, and are significantly simpler:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a658e30b-d361-449d-9d5d-033be099cb95.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The `sometimes_loud` function takes an event and returns an event, and we'll
    use it to map from one observable sequence of events into a new one, just as you'd
    expect in a functional programming environment. The `output` function takes an
    event and returns none, which is again what we'd expect for a `side_effect` in
    a functional system.
  prefs: []
  type: TYPE_NORMAL
- en: Explaining the observable sequence of events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, now that we have our observable factory method and function to take and
    return an event; what do we need to do to put it all together? First, we will
    create an `asyncio` scheduler. Next comes the interesting part, where we will
    tell the computer how to combine and process those observable sequences.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an asyncio scheduler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can create an `asyncio` scheduler using a simple command, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This is an Rx scheduler that specifically integrates with an `asyncio` event
    loop. Rx contains quite a few different scheduler implementations that integrate
    with various event loops available in Python, as well as one that uses Python
    threads to implement scheduling.
  prefs: []
  type: TYPE_NORMAL
- en: Regardless of which scheduler we use, the scheduler's job will be to decide
    when time-based elements of our event pipeline occur. This means that in this
    example, the scheduler is going to be deciding when our animal observables produce
    new values.
  prefs: []
  type: TYPE_NORMAL
- en: 'After creating the scheduler, we create the animal objects and their observable
    sequence of events. The animal objects are the easy part, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2cff40d7-a19a-4a9b-acb2-898c8c3bf090.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Combining and processing observable sequences
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For combining and processing the observable sequences, we have three steps
    to follow. These are explained here:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we merge the elephant and lion sequences into a single combined sequence,
    and process that sequence through our `sometimes_loud` function to create a new
    sequence we call `louder`, as shown in the following code example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `select` method used in that line is the direct equivalent of the map function
    in a functional programming environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we merge the `louder` sequence with the remaining animal sequences and
    tell the system that whenever a new value arrives at the front of that merge sequence,
    it should call the output function on that value:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `do_action` method used in this example is not equivalent to map because
    it doesn't transform the sequence; it just performs an action on each element
    of it.
  prefs: []
  type: TYPE_NORMAL
- en: The `do_action` method is for side_effects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, as shown as follows, we subscribe to the `on_completed` event on the
    out observable sequence, which is the same as the sequence merging all event streams
    into one, since the `do_action` operation returns its input sequence unchanged:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: When the sequence is complete, we set a result value on the `done` future. Since
    we used that feature as the perimeter to run until complete in our `main.py` file,
    setting its result value terminates the `asyncio` event loop and our program ends.
  prefs: []
  type: TYPE_NORMAL
- en: 'The complete code listing for the `animals.py` file in this section is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/550bfeb1-8b85-483c-92a2-5fc8e416179b.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Miscellaneous observable factory methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The demo that we just worked through has shown us the `merge`, `merge.select`,
    and `generate_with_relative_time` factory methods of `Observable`, but that's
    just the tip of the iceberg.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are so many observable factories (a sample of which is shown in the following
    image) that it would take more time than we have, just to get a short description
    of each one:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/66acf3f8-e9b7-4e01-830f-026ea275a0ae.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Each of them gives us a useful way of constructing an observable, usually, but
    not always, based on one or more other observables.
  prefs: []
  type: TYPE_NORMAL
- en: Python's interactive shell and `help` function are our friends here. There's
    a lot to be learned by poking around in the `Observable` class. In the meantime,
    we're going to talk about a few of the very best observable factory methods that
    we haven't seen yet.
  prefs: []
  type: TYPE_NORMAL
- en: The Observable.create method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First on that list is `Observable.create` shown in the following code example.
    This is the recommended way of creating a completely customized observable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `create` method has callable as its parameter and calls that callable each
    time an observer subscribes to the observable.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding code example, we created an observable that says `Hi!` when
    an observer subscribes and then never produces another value; not the most useful
    of sequences, but it serves to illustrate the idea.
  prefs: []
  type: TYPE_NORMAL
- en: We can take the basic framework and construct an observable with any behavior
    we like from it, without subclassing the observable class and without re-implementing,
    probably incorrectly, the internal machinery that keeps observables synchronized
    and functioning properly in an asynchronous or parallel environment.
  prefs: []
  type: TYPE_NORMAL
- en: The Observable.select_many method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next is `Observable.select_many`. This time, let''s take a look at what Python''s
    `help` function can show us, using following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This should give you the following description:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bd704f31-53a9-42d1-b55f-073a51f56c66.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This observable factory method is a more generalized version of select. Here,
    select applies a function to each member of the sequence to create a new sequence
    from the function return values, and `select_many` expects a function that returns
    an observable sequence and concatenates those sequences.
  prefs: []
  type: TYPE_NORMAL
- en: This means that the function applied by `select_many` can remove elements from
    the sequence by returning an empty sequence and it can insert values by returning
    a sequence containing more than one element.
  prefs: []
  type: TYPE_NORMAL
- en: As with select, the values added to the result aren't necessarily the same values
    that were passed to the function either, so `select_many` can produce a sequence
    containing more or fewer values than the input sequence and the values can be
    determined however we choose.
  prefs: []
  type: TYPE_NORMAL
- en: Empty, return_value, and from_iterable factory methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Empty sequences and sequences of one value are easy to create using the `empty`
    and `return_value` factory methods, respectively. These can be shown using two
    commands, which are illustrated with their help pages respectively.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This command will lead us to the following help page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4014c686-12e0-4d38-9a51-f7abe4806bf4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Similarly, in the case of `return_value`, we can use this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll get this help page explaining how to use the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/62a8165d-d02c-4e54-89c4-e88ba580ff94.png)'
  prefs: []
  type: TYPE_IMG
- en: Similarly, it's easy to construct an observable sequence of any already known
    series of objects using the `of` or `from_iterable` factory methods.
  prefs: []
  type: TYPE_NORMAL
- en: The where factory method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While we could use `select_many` to remove unwanted events from an observable
    sequence, it''s easier to use the `where` method. Let''s look at the help information
    for the `where` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This method applies a callable to each element of the input observable sequence
    and returns an observable sequence containing only those elements for which the
    callable returned true. The following image shows the help description:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f537127e-1e7b-4672-8d55-4f57575244d7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now we saw that there are fundamental ways to add and remove observable sequences,
    so what about processing them? We could just use `select` and `select_many` to
    do all of our processing, but Rx provides us with many more methods, such as `min`,
    `max`, `average`, `distinct`, `slice`, and `zip`, just to name a few of the tools
    available to us. I highly recommend that you investigate the Rx framework in more
    detail.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed what reactive programming is and implemented a
    bare-bones reactive framework, and used it to implement a demo program to help
    us get a handle on the concepts. We looked at the Reactive Extensions for Python,
    and used them to re-implement our zoo demo. We finished by looking at some of
    the broader possibilities of the Rx framework.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll look at microservices, which are very small server
    processes that are meant to work together to create the desired results.
  prefs: []
  type: TYPE_NORMAL
