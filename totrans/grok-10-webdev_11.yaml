- en: Chapter 10. Grok and Relational Databases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have been using the ZODB for data storage. As we saw in the last
    chapter, this is a fine solution. Grok developers truly love the ZODB and would
    like to see it used a lot more across the Python world. Furthermore, Grok takes
    excellent advantage of its power and features.
  prefs: []
  type: TYPE_NORMAL
- en: Having said that, relational databases are currently the most commonly used
    persistence mechanism for web applications. For one thing, they are reliable,
    efficient, and scalable. They are also fairly well understood, and many novice
    web developers already happen to know a thing or two about SQL.
  prefs: []
  type: TYPE_NORMAL
- en: The fact that relational databases are used consistently for non-web-development
    projects also makes them more likely to be needed in web applications where access
    to existing information is required.
  prefs: []
  type: TYPE_NORMAL
- en: 'In other words, the ZODB is great, but a good web framework needs to offer
    ample support for working with relational databases. Of course, Grok is such a
    framework, so in this chapter, we''ll find out what facilities Grok has for relational
    database access. Here are some specific things that we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Why is it important that Grok allows developers to use relational databases
    easily
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What an Object Relational Mapper is
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use SQLAlchemy with Grok
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to change our authentication mechanism to use a relational database instead
    of the ZODB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Object Relational Mappers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python is an object-oriented language, and Grok uses this object orientation
    heavily. In practice, this means that we define models with properties and methods,
    and each model instance represents an object. Thus, we have project or to-do list
    objects, and our views work with them, and access their properties and call their
    methods, freely.
  prefs: []
  type: TYPE_NORMAL
- en: When it's time to save our objects, the ZODB comes in handy because we just
    grab the whole object and stuff it in there, which is why it's called an object
    database. Relational databases, on the other hand, work in a very different way.
    They store everything using tables and columns, usually dividing an object into
    several related tables.
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, we can't just take one of our to-do list objects and put it into
    a relational database; some translation is needed, even if there's only one table
    involved. Relational databases use the SQL language to receive read and write
    commands for a table or tables, so we could take our object's properties one-by-one,
    generate a SQL statement as a string, and send it to the database. We would then
    reverse the process to assemble the object again from the database columns. This
    doesn't really scale well, so the usual solution is to use a library specifically
    designed for disassembling objects into tables and assembling them back when queried,
    transparently generating the required SQL to make it work. These libraries are
    known as **Object Relational Mappers**, or **ORMs** for short.
  prefs: []
  type: TYPE_NORMAL
- en: ORMs are also very good at keeping the code independent of the database used,
    because the developer performs operations in terms of objects, and the ORMs generate
    a SQL specific for a database, behind the scenes. This makes it a lot easier to
    switch databases in a project without getting into time-consuming syntax changes
    in the SQL used.
  prefs: []
  type: TYPE_NORMAL
- en: SQLAlchemy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are many ORMs for Python, but perhaps the most popular one is **SQLAlchemy**.
    One of the reasons for its popularity is that SQLAlchemy, in addition to being
    a powerful ORM, offers a data abstraction layer for constructing SQL expressions
    in a platform-independent way. This gives the developer ample flexibility to work
    with the model objects without worrying about database or SQL details, but still
    have the ability to get down to the SQL level if needed, for performance or other
    reasons.
  prefs: []
  type: TYPE_NORMAL
- en: SQLAlchemy supports a dozen databases, including SQLite, Postgres, MySQL, Oracle,
    and MS-SQL. It organizes pending operations into queues and flushes them all in
    one batch, providing efficiency and transaction safety. SQL clauses can be built
    by using Python functions and expressions, thus allowing the complete range of
    language constructs to be used. It also takes care of connection pooling, helping
    to optimize the use of system resources.
  prefs: []
  type: TYPE_NORMAL
- en: Including SQLAlchemy in our Grok project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We already saw in the previous chapter how to include a Python package from
    the PyPI in our project. Just add the package to the `install_requires` variable
    in the project''s `setup.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, rerun the buildout and the package should be included:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Once we've done that, SQLAlchemy is ready to use.
  prefs: []
  type: TYPE_NORMAL
- en: Using SQLAlchemy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To get a feel of how SQLAlchemy operates by itself, let''s try it directly
    from the Python prompt first. Go to the top directory of the project and type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This will start the Python interpreter in the command line. As we already ran
    the buildout with the SQLAlchemy package, we should be able to import from it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `create_engine` method is used to tell `sqlalchemy` which database to interact
    with. The first parameter is called a **connection string** and contains all the
    information required to connect to the database, such as database name, username,
    and password. In this example, we use SQLite, which is a lightweight database
    included with Python since version 2.5\. SQLite allows us to work in memory instead
    of creating a database on disk. As we are just testing, we can use this feature.
  prefs: []
  type: TYPE_NORMAL
- en: The `echo` parameter is passed a value of `True` so that we can see the SQL
    generated by SQLAlchemy in the console output.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we''ll do a few more imports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `Column` class is used to define a table column. `Integer` and `String`
    are column data types. We'll use them to define our table.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we import `declarative_base`, which allows us to create a base class for
    use with our object models. To use it, we have to call it and assign the result
    to the variable that will act as a base class for our model.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are now ready to create a model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we create a `User` class for storing user data. We have to
    use the `Base` class that we just created with `declarative_base` for SQLAlchemy
    to be able to work transparently with this model. A `__tablename__` attribute
    is needed as well to designate the name of the table in the database that will
    store the model's information.
  prefs: []
  type: TYPE_NORMAL
- en: Next, the columns are defined using the `Column` class and the types we imported
    earlier. Note the use of the `primary_key` parameter to make `id` the primary
    key for this table.
  prefs: []
  type: TYPE_NORMAL
- en: 'Last, we need to define an `__init__` method to set the column values on creation.
    After this is done, SQLAlchemy can create the table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The table metadata is stored in the `metadata` attribute of the `Base` class
    and it can be used to create the table, via the `create_all` method. This method
    needs to be passed to the engine that we created earlier, to know what dialect
    of SQL to use and how to connect to the actual database. Notice how the generated
    SQL is displayed immediately after an SQLAlchemy method call. You can see that
    the name of the table is the one that we defined by using the `__tablename__`
    attribute earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the table is created, we can populate it with our `User` objects. To do
    so, we first need to create a session:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The `sessionmaker` method works in a way similar to that of `declarative_base`
    and produces a class that we can call to create the actual session. Session creation
    is done in this way to allow SQLAlchemy to create a specific `Session` class for
    an engine definition, which is passed to `sessionmaker` by using the `bind` parameter.
    Once we have a `sessionmaker` tailored to our engine, we can create the database
    session, and we are ready for our first object instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We create an instance of the `User` class, which represents the user ''grok''.
    To put it in the session queue, we use the `add` method. At this point, the `User`
    object is ready to be written to the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We use the `commit` method to save the changes to the database. Once again,
    we can look at the generated SQL in the console output. Now we can query the database
    by using Python constructs and use the data as we please:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we use the `query` method of the session to get all
    of the stored `User` objects, which right now are exactly one. We then print the
    `name` and `real_name` attribute values of the result.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we are finished, we should close the session:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Of course, there's a lot more that the SQLAlchemy can do, but giving an in-depth
    explanation goes beyond the purpose of this book. There's ample documentation
    available at the project's website, including a tutorial.
  prefs: []
  type: TYPE_NORMAL
- en: Using a relational database for authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen how to use SQLAlchemy by itself, so now we can try to do something
    with it in our project. One area where relational database connectivity usually
    comes in handy for a web application, is the authentication process. This is because
    most of the time, in real enterprise settings, web applications are not isolated
    but form a part of a series of tools that a company can use in its daily work.
    It's quite common to have a single database to store all of the company users
    instead of having a separate database per application.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will show how to turn our authentication database from a ZODB folder into
    a relational database table by using SQLAlchemy. To begin, add the following lines
    to the top of `auth.py`, just after the imports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We used these imports and the engine setup statements in the previous section.
    The only difference is that instead of using an in-memory database, we will now
    use a file to keep our data. SQLite allows us to pass a relative path in the connection
    string to create a file for the database. In this case, the file will be named
    `todo.db` and will be stored in the same directory as the root of the project.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we are now going to store user data in the database, we don''t need the
    user folder anymore, so we delete its definition from the code. Remove these two
    lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'With that out of the way, the next step is to modify the definition of the
    `Account` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Instead of using `grok.Model` as the base class, we switch to the `Base` class
    from `declarative_base`. Then, we define the columns, using the same names as
    in the already existing properties as declared in the `__init__` method. Note
    that all of the other methods of the class remain unchanged from the `grok.Model-based
    Account` class.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have an SQLAlchemy-based `Account` class, we can use any SQLAlchemy
    functionality that we may need in the code. In this case, we have to change the
    `UserAuthenticatorPlugin` implementation to access the database for user listing,
    user creation, and user deletion.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the new implementation. Notice that the `authenticateCredentials` and
    `principalInfo` methods have not changed from the previous definition, so they
    are not included:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `__init__` method uses the `metadata.create_all` method with the predefined
    engine to create the database table when the plugin is initialized.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: To get an account, we start a session and then query the `Account` class by
    using the `filter_by` method, which returns only the database rows that match
    the login passed. SQLAlchemy allows chaining of query results, so we use the first
    method on the filtered results to get either the first (and only) match, or `None`,
    if there is no such user.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: To add a user, we first check if the login exists, using the same `filter_by`
    call from the `getAccount` method. If the result is `None`, we create the user
    account and add it to the session. We immediately commit to save the results.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: One thing that we didn't do when we covered authentication back in Chapter 7
    was to give administrators the ability to delete users. The `deleteUser` method
    above does just that. We again use the `filter_by` call to see if a user with
    the passed login exists. If it does, we call `session.delete` to remove it from
    the database and commit.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Finally, on `listUsers`, we simply call the `all` method to return every row
    in the table.
  prefs: []
  type: TYPE_NORMAL
- en: This is all that is needed to change authentication from using a `grok.Container`
    in the ZODB to using a table in a relational database (refer to the next screenshot).
    To use a different database, we just need to change the engine definition to whatever
    database we want to use. Be aware, though, you have to install any drivers required
    by the database in your system, as well as add the corresponding Python driver
    to the project's `setup.py`. Check the SQLAlchemy documentation for more information.
  prefs: []
  type: TYPE_NORMAL
- en: '![Using a relational database for authentication](img/7481_10_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Handling database transactions securely
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So we now have relational database authentication with very little work. However,
    there is a subtle problem with our code, especially in the `addUser` method. Grok
    has a transaction machinery, as we have seen, but so does a relational database.
  prefs: []
  type: TYPE_NORMAL
- en: Right now we are calling `session.commit()` right after adding the user to the
    database. At that moment, the user data is saved to disk. The problem is that
    after saving this change, we immediately set the appropriate role for the user
    by using Grok's permission machinery, which is ZODB based.
  prefs: []
  type: TYPE_NORMAL
- en: Now, if some error occurs when calling `assignRoleToPrincipal`, the Grok transaction
    will be aborted, meaning that the role will not be set for the new user. Meanwhile,
    the database transaction has been committed, so we end up with a user that exists
    in the database but who can't access the application features because it has no
    roles set.
  prefs: []
  type: TYPE_NORMAL
- en: This is what we call an inconsistent state for the database and users would
    call it a bug. In this case, we could move the `session.commit()` call after the
    role changes and we would at least guarantee that a database error would then
    result in an aborted transaction in Grok. But clearly there could be more complicated
    cases where careful placement of the `session.commit()` call would not be enough.
  prefs: []
  type: TYPE_NORMAL
- en: What is needed is a way to synchronize both, the Grok and the SQLAlchemy transactions,
    so that we don't have to control them separately. Fortunately, the huge collection
    of packages available for Grok via the Zope Toolkit has the right tool for this
    job.
  prefs: []
  type: TYPE_NORMAL
- en: 'The package that we need is called `zope.sqlalchemy` and it can be found on
    the PyPI, which means that it can be easily added to our project using `setup.py`.
    You know the dance by now, add it to the `install_requires` and rerun the buildout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The `zope.sqlalchemy` package has a single purpose: to provide a transaction
    manager for integrating Grok and SQLAlchemy transactions. To use it, we first
    have to add a couple of imports at the top of `auth.py:`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '`scoped_session` is a special SQLAlchemy session manager that makes sure that
    any calls to `Session()` during the same transaction will return the same session
    object. `ZopeTransactionExtension` will create the object that is responsible
    for tying up Grok and the SQLAlchemy sessions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The engine and `Base` declarations at the top of the module remain unchanged,
    but we have to drop the line where the `Session` class is defined and use the
    following line of code in its place:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This will initialize a scoped session and integrate the two transactions by
    using the `ZopeTransactionExtension`. All that is required now is to substitute
    all of the `session.commit()` calls with `transaction.commit()` calls and our
    application will enjoy secure transaction handling. Here''s a look at the resulting
    `addUser` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, committing the `db` transaction is no longer necessary, as we
    are using the Grok transaction manager now, instead of the SQLAlchemy session
    object. The database transaction will be automatically committed when Grok commits
    the transaction for us, and the Grok machinery will make sure that either both
    transactions succeed or both fail. Less work and no data inconsistencies.
  prefs: []
  type: TYPE_NORMAL
- en: Creating database-backed models and containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have shown how easy it is to access and use data from a relational database.
    Very few lines of the program had to be modified and not a line of SQL was used.
    Of course, authentication is a functionality that is somewhat peripheral to the
    main application. What if we need to store all the data generated by our application
    in a relational database?
  prefs: []
  type: TYPE_NORMAL
- en: Grok's `Model` and `Container` classes store information in the ZODB, so if
    we want to use a relational database, we need to create our own model and container
    implementations, right? This seems like a lot of work. Fortunately, someone has
    already done that work for us.
  prefs: []
  type: TYPE_NORMAL
- en: The megrok.rdb package
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It turns out that the `megrok.rdb` package provides the Grok developer with
    `Container` and `Model` classes that work similarly to Grok's own classes, but
    store all information in a relational database. What's more, `megrok.rdb` also
    uses SQLAlchemy, so it goes hand in hand with what we have done in this chapter
    so far.
  prefs: []
  type: TYPE_NORMAL
- en: This package is available from the PyPI, as you might have guessed. Hopefully,
    by this time you know that `megrok.rdb` should be added to the `install_requires`
    section of `setup.py` and the buildout needs to be run once again. This way the
    `megrok.rdb` package will be ready for use.
  prefs: []
  type: TYPE_NORMAL
- en: Making an application database backed
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Converting our whole application to use `megrok.rdb` requires more work than
    is realistic for this introductory chapter, so let's just imagine, how we would
    design the application if we had a relational database planned for storage from
    the very beginning.
  prefs: []
  type: TYPE_NORMAL
- en: 'As this is just an exercise, we will show only the code that would be needed
    for getting the `Project` class working, along with its contained to-do lists.
    First, we need some imports from `sqlalchemy`, similar to those we used earlier.
    Of course, we have to import the `rdb` module from `megrok.rdb` as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'For now, we''ll dispense as well with the database connection setup. Just assume
    that we have created a database as we have done earlier in this chapter. However,
    we do need a special `metadata` object instead of the one provided by SQLAlchemy.
    We''ll get it from the `rdb` module that we just imported:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We can now create the models. Remember, this code is just for illustration purposes,
    do not add it to our project.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We define the to-do lists container first. It's just an empty class. Then, we
    define a `Project` model and its columns by using regular SQLAlchemy declarations.
    We have a `todolists` container as a property on the project, connected with the
    container that we defined earlier by using the SQLAlchemy relation declaration.
    This is necessary for having Grok-style containers in our relational database
    application.
  prefs: []
  type: TYPE_NORMAL
- en: For the `TodoList` class, we use the `rdb.Model` base class and add its columns
    as well, but here, we use a foreign key to relate the to-do list with a project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once this is done, we can generate the database structure, which will usually
    be done at an application''s creation time. We have also done this in the previous
    section, so let''s assume that we have everything ready, and start creating content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we create a session. After that, we create a new `Project` and add it
    to the session, just like regular SQLAlchemy usage. Next, we define some to-do
    lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This is again just regular SQLAlchemy syntax, but now we come to the part where
    we use the container that we defined inside the `Project` class to store the to-do
    lists. This is what makes it possible for us to have Grok container-like functionality
    for our database objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The `set` method takes care of 'adding' the list to the container and lets the
    database set the key for each row. We could now call Grok container methods, such
    as `items()` on the `project_x.todolists` container and get the expected results,
    just like using `grok.Container`.
  prefs: []
  type: TYPE_NORMAL
- en: There are other things that can be done with `megrok.rdb`, so if you are interested
    in having a Grok-like database-backed application, you should consult the documentation.
  prefs: []
  type: TYPE_NORMAL
- en: When to use the ZODB versus a relational database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Because it's fairly easy to use relational databases with Grok, people who are
    used to working with relational applications may wonder why they should use the
    ZODB at all. As comfortable as it is, to go with what we know best, no database
    technology is ideal for every kind of project.
  prefs: []
  type: TYPE_NORMAL
- en: A relational database is a flat entity. When working with object-oriented languages
    such as Python, it's usually necessary to take a complex hierarchy of interrelated
    objects and "flatten" it to fit into several tables. Sometimes it's a lot easier
    and faster to simply store the objects exactly as they are, like an object-oriented
    database does.
  prefs: []
  type: TYPE_NORMAL
- en: Which one is best for your application? The key words here are *flat* and *hierarchy*.
    If your application will handle flat information structures, such as customers,
    products, records, orders, and so on, or if you need to do heavy reporting and
    data manipulation, a relational database is most likely your best bet. Online
    stores are a good example of an application that is well suited for relational
    database use. The user management part of our application which we just did is
    also a good fit here.
  prefs: []
  type: TYPE_NORMAL
- en: If you have complex, hierarchical structures of objects, it might be better
    to use the ZODB and persist the hierarchies in their natural form. Content management
    applications, where you need to model structures resembling folders and pages
    that can be nested several levels deep, are ideally suited to an object-oriented
    database.
  prefs: []
  type: TYPE_NORMAL
- en: In the end, it's usually just a matter of preference, but in any case, Grok
    will let you use either one or even both of these mechanisms in a simple way,
    which gives you maximum flexibility.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we saw:'
  prefs: []
  type: TYPE_NORMAL
- en: How Grok makes it very easy to use the existing Python relational database packages
    and ORMs. We also learned to use the more advanced `megrok.rdb` package to transparently
    turn our models into ORM mappings.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to integrate relational database transactions with ZODB's transaction support.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use `megrok.rdb` to turn our models into ORM mappings.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
