- en: Chapter 10. Grok and Relational Databases
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 10 章. Grok 和关系数据库
- en: So far, we have been using the ZODB for data storage. As we saw in the last
    chapter, this is a fine solution. Grok developers truly love the ZODB and would
    like to see it used a lot more across the Python world. Furthermore, Grok takes
    excellent advantage of its power and features.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在使用 ZODB 进行数据存储。正如我们在上一章中看到的，这是一个很好的解决方案。Grok 开发者真正喜欢 ZODB，并希望它在 Python
    世界中得到更广泛的应用。此外，Grok 充分利用了它的力量和特性。
- en: Having said that, relational databases are currently the most commonly used
    persistence mechanism for web applications. For one thing, they are reliable,
    efficient, and scalable. They are also fairly well understood, and many novice
    web developers already happen to know a thing or two about SQL.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，关系数据库目前是网络应用程序中最常用的持久化机制。一方面，它们是可靠的、高效的和可扩展的。它们也相当为人所熟知，许多新手网络开发者已经对 SQL
    有了一些了解。
- en: The fact that relational databases are used consistently for non-web-development
    projects also makes them more likely to be needed in web applications where access
    to existing information is required.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 关系数据库在非网络开发项目中的一致使用也使得它们更有可能在需要访问现有信息的网络应用程序中被需要。
- en: 'In other words, the ZODB is great, but a good web framework needs to offer
    ample support for working with relational databases. Of course, Grok is such a
    framework, so in this chapter, we''ll find out what facilities Grok has for relational
    database access. Here are some specific things that we will cover:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，ZODB 是很棒的，但一个好的网络框架需要提供足够的支持来处理关系数据库。当然，Grok 就是这样一种框架，所以在本章中，我们将了解 Grok
    为关系数据库访问提供了哪些设施。以下是我们将涵盖的一些具体内容：
- en: Why is it important that Grok allows developers to use relational databases
    easily
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么 Grok 允许开发者轻松使用关系数据库很重要
- en: What an Object Relational Mapper is
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象关系映射器（ORM）是什么
- en: How to use SQLAlchemy with Grok
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 SQLAlchemy 与 Grok 结合
- en: How to change our authentication mechanism to use a relational database instead
    of the ZODB
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何将我们的认证机制更改为使用关系数据库而不是 ZODB
- en: Object Relational Mappers
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象关系映射器
- en: Python is an object-oriented language, and Grok uses this object orientation
    heavily. In practice, this means that we define models with properties and methods,
    and each model instance represents an object. Thus, we have project or to-do list
    objects, and our views work with them, and access their properties and call their
    methods, freely.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Python 是一种面向对象的编程语言，Grok 严重依赖这种面向对象。在实践中，这意味着我们使用属性和方法定义模型，每个模型实例代表一个对象。因此，我们有项目或待办事项列表对象，我们的视图与它们一起工作，自由地访问它们的属性和调用它们的方法。
- en: When it's time to save our objects, the ZODB comes in handy because we just
    grab the whole object and stuff it in there, which is why it's called an object
    database. Relational databases, on the other hand, work in a very different way.
    They store everything using tables and columns, usually dividing an object into
    several related tables.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们保存对象的时候，ZODB 就派上用场了，因为我们只需抓取整个对象并将其放入其中，这就是为什么它被称为对象数据库。另一方面，关系数据库以非常不同的方式工作。它们使用表格和列来存储所有内容，通常将一个对象分成几个相关的表格。
- en: Obviously, we can't just take one of our to-do list objects and put it into
    a relational database; some translation is needed, even if there's only one table
    involved. Relational databases use the SQL language to receive read and write
    commands for a table or tables, so we could take our object's properties one-by-one,
    generate a SQL statement as a string, and send it to the database. We would then
    reverse the process to assemble the object again from the database columns. This
    doesn't really scale well, so the usual solution is to use a library specifically
    designed for disassembling objects into tables and assembling them back when queried,
    transparently generating the required SQL to make it work. These libraries are
    known as **Object Relational Mappers**, or **ORMs** for short.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们不能直接将我们的待办事项列表对象放入关系数据库中；即使只涉及一个表格，也需要进行一些转换。关系数据库使用 SQL 语言来接收对表格或表格的读取和写入命令，因此我们可以逐个生成对象的属性，将它们作为字符串生成一个
    SQL 语句，并将其发送到数据库。然后，我们会逆向这个过程，从数据库列中重新组装对象。这实际上并不容易扩展，因此通常的解决方案是使用专门设计用于将对象拆分成表格并在查询时重新组装它们的库，透明地生成所需的
    SQL 以使其工作。这些库被称为**对象关系映射器**，或简称**ORM**。
- en: ORMs are also very good at keeping the code independent of the database used,
    because the developer performs operations in terms of objects, and the ORMs generate
    a SQL specific for a database, behind the scenes. This makes it a lot easier to
    switch databases in a project without getting into time-consuming syntax changes
    in the SQL used.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: ORMs（对象关系映射）在保持代码与所使用的数据库独立方面也非常出色，因为开发者以对象的形式执行操作，ORMs在幕后生成针对特定数据库的SQL语句。这使得在项目中切换数据库时，无需进行耗时的SQL语法更改，从而变得容易得多。
- en: SQLAlchemy
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SQLAlchemy
- en: There are many ORMs for Python, but perhaps the most popular one is **SQLAlchemy**.
    One of the reasons for its popularity is that SQLAlchemy, in addition to being
    a powerful ORM, offers a data abstraction layer for constructing SQL expressions
    in a platform-independent way. This gives the developer ample flexibility to work
    with the model objects without worrying about database or SQL details, but still
    have the ability to get down to the SQL level if needed, for performance or other
    reasons.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Python来说，有众多ORM，但可能最受欢迎的一个是**SQLAlchemy**。其受欢迎的原因之一是，SQLAlchemy除了是一个强大的ORM之外，还提供了一个数据抽象层，以平台无关的方式构建SQL表达式。这为开发者提供了足够的灵活性，可以在不担心数据库或SQL细节的情况下与模型对象一起工作，但在需要时仍然能够深入到SQL级别，无论是出于性能或其他原因。
- en: SQLAlchemy supports a dozen databases, including SQLite, Postgres, MySQL, Oracle,
    and MS-SQL. It organizes pending operations into queues and flushes them all in
    one batch, providing efficiency and transaction safety. SQL clauses can be built
    by using Python functions and expressions, thus allowing the complete range of
    language constructs to be used. It also takes care of connection pooling, helping
    to optimize the use of system resources.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy支持包括SQLite、Postgres、MySQL、Oracle和MS-SQL在内的十多种数据库。它将待处理的操作组织到队列中，并一次性批量刷新它们，提供效率和事务安全性。可以通过使用Python函数和表达式构建SQL子句，从而允许使用语言构造的完整范围。它还负责连接池管理，有助于优化系统资源的使用。
- en: Including SQLAlchemy in our Grok project
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将SQLAlchemy包含到我们的Grok项目中
- en: 'We already saw in the previous chapter how to include a Python package from
    the PyPI in our project. Just add the package to the `install_requires` variable
    in the project''s `setup.py` file:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一章中已经看到了如何将来自PyPI的Python包包含到我们的项目中。只需将包添加到项目`setup.py`文件中的`install_requires`变量即可：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'After that, rerun the buildout and the package should be included:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，重新运行buildout，包应该被包含在内：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Once we've done that, SQLAlchemy is ready to use.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些操作后，SQLAlchemy就准备好使用了。
- en: Using SQLAlchemy
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用SQLAlchemy
- en: 'To get a feel of how SQLAlchemy operates by itself, let''s try it directly
    from the Python prompt first. Go to the top directory of the project and type:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 为了感受SQLAlchemy独立运行的方式，让我们首先直接从Python提示符尝试。前往项目的顶层目录，并输入以下命令：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This will start the Python interpreter in the command line. As we already ran
    the buildout with the SQLAlchemy package, we should be able to import from it:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在命令行中启动Python解释器。由于我们已经运行了带有SQLAlchemy包的buildout，我们应该能够从中导入：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `create_engine` method is used to tell `sqlalchemy` which database to interact
    with. The first parameter is called a **connection string** and contains all the
    information required to connect to the database, such as database name, username,
    and password. In this example, we use SQLite, which is a lightweight database
    included with Python since version 2.5\. SQLite allows us to work in memory instead
    of creating a database on disk. As we are just testing, we can use this feature.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`create_engine`方法用于告诉`sqlalchemy`与哪个数据库进行交互。第一个参数被称为**连接字符串**，包含连接到数据库所需的所有信息，如数据库名称、用户名和密码。在这个例子中，我们使用SQLite，它是从Python
    2.5版本开始包含的一个轻量级数据库。SQLite允许我们在内存中工作，而不是在磁盘上创建数据库。由于我们只是在测试，我们可以使用这个特性。'
- en: The `echo` parameter is passed a value of `True` so that we can see the SQL
    generated by SQLAlchemy in the console output.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 将`echo`参数传递值为`True`，这样我们就可以在控制台输出中看到SQLAlchemy生成的SQL。
- en: 'Now we''ll do a few more imports:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将进行更多的导入操作：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `Column` class is used to define a table column. `Integer` and `String`
    are column data types. We'll use them to define our table.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`Column`类用于定义表列。`Integer`和`String`是列数据类型。我们将使用它们来定义我们的表。'
- en: Next, we import `declarative_base`, which allows us to create a base class for
    use with our object models. To use it, we have to call it and assign the result
    to the variable that will act as a base class for our model.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们导入`declarative_base`，这允许我们创建一个用于与我们的对象模型一起使用的基类。要使用它，我们必须调用它并将结果赋值给将作为我们模型基类的变量。
- en: 'We are now ready to create a model:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备好创建一个模型：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this example, we create a `User` class for storing user data. We have to
    use the `Base` class that we just created with `declarative_base` for SQLAlchemy
    to be able to work transparently with this model. A `__tablename__` attribute
    is needed as well to designate the name of the table in the database that will
    store the model's information.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了一个`User`类来存储用户数据。我们必须使用我们刚刚用`declarative_base`创建的`Base`类，以便SQLAlchemy能够透明地与这个模型一起工作。还需要一个`__tablename__`属性来指定数据库中存储模型信息的表名。
- en: Next, the columns are defined using the `Column` class and the types we imported
    earlier. Note the use of the `primary_key` parameter to make `id` the primary
    key for this table.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用`Column`类和之前导入的类型定义列。注意使用`primary_key`参数将`id`设置为该表的键。
- en: 'Last, we need to define an `__init__` method to set the column values on creation.
    After this is done, SQLAlchemy can create the table:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要定义一个`__init__`方法来在创建时设置列值。完成此操作后，SQLAlchemy可以创建表：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The table metadata is stored in the `metadata` attribute of the `Base` class
    and it can be used to create the table, via the `create_all` method. This method
    needs to be passed to the engine that we created earlier, to know what dialect
    of SQL to use and how to connect to the actual database. Notice how the generated
    SQL is displayed immediately after an SQLAlchemy method call. You can see that
    the name of the table is the one that we defined by using the `__tablename__`
    attribute earlier.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 表元数据存储在`Base`类的`metadata`属性中，并且可以通过`create_all`方法用来创建表。此方法需要传递给我们之前创建的引擎，以便知道使用哪种SQL方言以及如何连接到实际的数据库。注意生成的SQL是如何在调用SQLAlchemy方法后立即显示的。你可以看到表名是我们之前使用`__tablename__`属性定义的那个。
- en: 'Once the table is created, we can populate it with our `User` objects. To do
    so, we first need to create a session:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦表被创建，我们就可以用我们的`User`对象来填充它。为了这样做，我们首先需要创建一个会话：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `sessionmaker` method works in a way similar to that of `declarative_base`
    and produces a class that we can call to create the actual session. Session creation
    is done in this way to allow SQLAlchemy to create a specific `Session` class for
    an engine definition, which is passed to `sessionmaker` by using the `bind` parameter.
    Once we have a `sessionmaker` tailored to our engine, we can create the database
    session, and we are ready for our first object instance:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`sessionmaker`方法的工作方式与`declarative_base`类似，它产生一个我们可以调用的类来创建实际的会话。以这种方式创建会话是为了让SQLAlchemy能够为引擎定义创建一个特定的`Session`类，这个类通过`bind`参数传递给`sessionmaker`。一旦我们有一个针对我们引擎定制的`sessionmaker`，我们就可以创建数据库会话，并且我们准备好创建第一个对象实例：'
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We create an instance of the `User` class, which represents the user ''grok''.
    To put it in the session queue, we use the `add` method. At this point, the `User`
    object is ready to be written to the database:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个`User`类的实例，代表用户'grok'。为了将其放入会话队列中，我们使用了`add`方法。此时，`User`对象已经准备好写入数据库：
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We use the `commit` method to save the changes to the database. Once again,
    we can look at the generated SQL in the console output. Now we can query the database
    by using Python constructs and use the data as we please:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`commit`方法将更改保存到数据库。再次，我们可以在控制台输出中查看生成的SQL。现在我们可以使用Python构造函数查询数据库，并按需使用数据：
- en: '[PRE10]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the preceding example, we use the `query` method of the session to get all
    of the stored `User` objects, which right now are exactly one. We then print the
    `name` and `real_name` attribute values of the result.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们使用会话的`query`方法来获取所有存储的`User`对象，目前正好有一个。然后我们打印出结果的`name`和`real_name`属性值。
- en: 'Once we are finished, we should close the session:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们完成，我们应该关闭会话：
- en: '[PRE11]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Of course, there's a lot more that the SQLAlchemy can do, but giving an in-depth
    explanation goes beyond the purpose of this book. There's ample documentation
    available at the project's website, including a tutorial.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，SQLAlchemy可以做更多的事情，但深入的解释超出了本书的目的。在项目网站上提供了丰富的文档，包括教程。
- en: Using a relational database for authentication
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用关系型数据库进行身份验证
- en: We have seen how to use SQLAlchemy by itself, so now we can try to do something
    with it in our project. One area where relational database connectivity usually
    comes in handy for a web application, is the authentication process. This is because
    most of the time, in real enterprise settings, web applications are not isolated
    but form a part of a series of tools that a company can use in its daily work.
    It's quite common to have a single database to store all of the company users
    instead of having a separate database per application.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何单独使用 SQLAlchemy，因此现在我们可以在我们的项目中尝试使用它。对于网络应用程序来说，关系数据库连接通常在认证过程中很有用，因为大多数情况下，在实际的企业环境中，网络应用程序并不是孤立的，而是构成公司日常工作中可以使用的一系列工具的一部分。通常有一个单独的数据库来存储所有公司用户，而不是为每个应用程序都有一个单独的数据库。
- en: 'We will show how to turn our authentication database from a ZODB folder into
    a relational database table by using SQLAlchemy. To begin, add the following lines
    to the top of `auth.py`, just after the imports:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将展示如何使用 SQLAlchemy 将我们的认证数据库从 ZODB 文件夹转换为关系数据库表。首先，将以下行添加到 `auth.py` 的顶部，紧接在导入之后：
- en: '[PRE12]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We used these imports and the engine setup statements in the previous section.
    The only difference is that instead of using an in-memory database, we will now
    use a file to keep our data. SQLite allows us to pass a relative path in the connection
    string to create a file for the database. In this case, the file will be named
    `todo.db` and will be stored in the same directory as the root of the project.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一节中使用了这些导入和引擎设置语句。唯一的区别是，我们不再使用内存数据库，而将使用一个文件来保存我们的数据。SQLite 允许我们在连接字符串中传递一个相对路径来创建一个数据库文件。在这种情况下，文件将命名为
    `todo.db` 并存储在项目根目录中。
- en: 'As we are now going to store user data in the database, we don''t need the
    user folder anymore, so we delete its definition from the code. Remove these two
    lines:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们现在将用户数据存储在数据库中，我们不再需要用户文件夹，因此我们从代码中删除其定义。移除以下两行：
- en: '[PRE13]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'With that out of the way, the next step is to modify the definition of the
    `Account` class:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成这些之后，下一步是修改 `Account` 类的定义：
- en: '[PRE14]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Instead of using `grok.Model` as the base class, we switch to the `Base` class
    from `declarative_base`. Then, we define the columns, using the same names as
    in the already existing properties as declared in the `__init__` method. Note
    that all of the other methods of the class remain unchanged from the `grok.Model-based
    Account` class.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不再使用 `grok.Model` 作为基类，而是切换到 `declarative_base` 中的 `Base` 类。然后，我们定义列，使用与在
    `__init__` 方法中声明的现有属性相同的名称。请注意，类中的所有其他方法都保持与基于 `grok.Model` 的 `Account` 类相同。
- en: Now that we have an SQLAlchemy-based `Account` class, we can use any SQLAlchemy
    functionality that we may need in the code. In this case, we have to change the
    `UserAuthenticatorPlugin` implementation to access the database for user listing,
    user creation, and user deletion.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了基于 SQLAlchemy 的 `Account` 类，我们可以在代码中使用我们可能需要的任何 SQLAlchemy 功能。在这种情况下，我们必须更改
    `UserAuthenticatorPlugin` 的实现以访问数据库进行用户列表、用户创建和用户删除。
- en: 'Here''s the new implementation. Notice that the `authenticateCredentials` and
    `principalInfo` methods have not changed from the previous definition, so they
    are not included:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这是新的实现。请注意，`authenticateCredentials` 和 `principalInfo` 方法与之前的定义没有变化，因此不包括在内：
- en: '[PRE15]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `__init__` method uses the `metadata.create_all` method with the predefined
    engine to create the database table when the plugin is initialized.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`__init__` 方法使用预定义的引擎调用 `metadata.create_all` 方法来创建数据库表，当插件初始化时。'
- en: '[PRE16]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: To get an account, we start a session and then query the `Account` class by
    using the `filter_by` method, which returns only the database rows that match
    the login passed. SQLAlchemy allows chaining of query results, so we use the first
    method on the filtered results to get either the first (and only) match, or `None`,
    if there is no such user.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取一个账户，我们首先启动一个会话，然后通过使用`filter_by`方法查询`Account`类，该方法只返回与传入的登录信息匹配的数据库行。SQLAlchemy
    允许查询结果的链式调用，因此我们使用过滤结果上的第一个方法来获取第一个（也是唯一一个）匹配项，或者如果没有这样的用户，则返回`None`。
- en: '[PRE17]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: To add a user, we first check if the login exists, using the same `filter_by`
    call from the `getAccount` method. If the result is `None`, we create the user
    account and add it to the session. We immediately commit to save the results.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加用户，我们首先检查登录是否存在，使用与 `getAccount` 方法中的相同 `filter_by` 调用。如果结果是 `None`，我们创建用户账户并将其添加到会话中。我们立即提交以保存结果。
- en: '[PRE18]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: One thing that we didn't do when we covered authentication back in Chapter 7
    was to give administrators the ability to delete users. The `deleteUser` method
    above does just that. We again use the `filter_by` call to see if a user with
    the passed login exists. If it does, we call `session.delete` to remove it from
    the database and commit.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在第七章中我们讨论认证时，没有为管理员提供删除用户的能力。上面的`deleteUser`方法正是为了实现这一点。我们再次使用`filter_by`调用以检查是否存在传递的登录用户。如果存在，我们调用`session.delete`将其从数据库中删除并提交。
- en: '[PRE19]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Finally, on `listUsers`, we simply call the `all` method to return every row
    in the table.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`listUsers`中，我们简单地调用`all`方法以返回表中的每一行。
- en: This is all that is needed to change authentication from using a `grok.Container`
    in the ZODB to using a table in a relational database (refer to the next screenshot).
    To use a different database, we just need to change the engine definition to whatever
    database we want to use. Be aware, though, you have to install any drivers required
    by the database in your system, as well as add the corresponding Python driver
    to the project's `setup.py`. Check the SQLAlchemy documentation for more information.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是将认证从使用ZODB中的`grok.Container`改为使用关系数据库中的表所需的所有内容（参考下一张截图）。要使用不同的数据库，我们只需更改引擎定义为我们想要使用的数据库。但请注意，你必须在你系统中安装数据库所需的任何驱动程序，并将相应的Python驱动程序添加到项目的`setup.py`中。有关更多信息，请参阅SQLAlchemy文档。
- en: '![Using a relational database for authentication](img/7481_10_01.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![使用关系数据库进行认证](img/7481_10_01.jpg)'
- en: Handling database transactions securely
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全处理数据库事务
- en: So we now have relational database authentication with very little work. However,
    there is a subtle problem with our code, especially in the `addUser` method. Grok
    has a transaction machinery, as we have seen, but so does a relational database.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在只需做很少的工作就可以实现关系数据库认证。然而，我们的代码中存在一个微妙的问题，尤其是在`addUser`方法中。正如我们所见，Grok有一个事务机制，但关系数据库也有。
- en: Right now we are calling `session.commit()` right after adding the user to the
    database. At that moment, the user data is saved to disk. The problem is that
    after saving this change, we immediately set the appropriate role for the user
    by using Grok's permission machinery, which is ZODB based.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 目前我们是在将用户添加到数据库后立即调用`session.commit()`。在那个时刻，用户数据被保存到磁盘。问题是，在保存这个更改后，我们立即使用Grok的基于ZODB的权限机制为用户设置适当的角色。
- en: Now, if some error occurs when calling `assignRoleToPrincipal`, the Grok transaction
    will be aborted, meaning that the role will not be set for the new user. Meanwhile,
    the database transaction has been committed, so we end up with a user that exists
    in the database but who can't access the application features because it has no
    roles set.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果在调用`assignRoleToPrincipal`时发生错误，Grok事务将被中止，这意味着新用户将不会设置角色。同时，数据库事务已经提交，所以我们最终得到一个存在于数据库中但无法访问应用程序功能的用户，因为它没有设置任何角色。
- en: This is what we call an inconsistent state for the database and users would
    call it a bug. In this case, we could move the `session.commit()` call after the
    role changes and we would at least guarantee that a database error would then
    result in an aborted transaction in Grok. But clearly there could be more complicated
    cases where careful placement of the `session.commit()` call would not be enough.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们所说的数据库和用户的不一致状态，用户可能会称之为一个bug。在这种情况下，我们可以在角色更改后移动`session.commit()`调用，这样至少可以保证数据库错误会导致Grok中的事务中止。但显然可能存在更复杂的情况，在这些情况下，仅仅放置`session.commit()`调用可能不足以解决问题。
- en: What is needed is a way to synchronize both, the Grok and the SQLAlchemy transactions,
    so that we don't have to control them separately. Fortunately, the huge collection
    of packages available for Grok via the Zope Toolkit has the right tool for this
    job.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 需要的是一个同步Grok和SQLAlchemy事务的方法，这样我们就不必分别控制它们。幸运的是，通过Zope Toolkit提供的Grok的庞大包集合中，有适合这项工作的正确工具。
- en: 'The package that we need is called `zope.sqlalchemy` and it can be found on
    the PyPI, which means that it can be easily added to our project using `setup.py`.
    You know the dance by now, add it to the `install_requires` and rerun the buildout:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的包叫做`zope.sqlalchemy`，可以在PyPI上找到，这意味着我们可以通过`setup.py`轻松将其添加到我们的项目中。你现在应该知道了这个流程，将其添加到`install_requires`中，并重新运行buildout：
- en: '[PRE20]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `zope.sqlalchemy` package has a single purpose: to provide a transaction
    manager for integrating Grok and SQLAlchemy transactions. To use it, we first
    have to add a couple of imports at the top of `auth.py:`'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`zope.sqlalchemy` 包只有一个目的：为集成 Grok 和 SQLAlchemy 事务提供一个事务管理器。要使用它，我们首先必须在 `auth.py`
    的顶部添加几个导入：'
- en: '[PRE21]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '`scoped_session` is a special SQLAlchemy session manager that makes sure that
    any calls to `Session()` during the same transaction will return the same session
    object. `ZopeTransactionExtension` will create the object that is responsible
    for tying up Grok and the SQLAlchemy sessions.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`scoped_session` 是一个特殊的 SQLAlchemy 会话管理器，它确保在同一个事务中，对 `Session()` 的任何调用都将返回相同的会话对象。`ZopeTransactionExtension`
    将创建负责绑定 Grok 和 SQLAlchemy 会话的对象。'
- en: 'The engine and `Base` declarations at the top of the module remain unchanged,
    but we have to drop the line where the `Session` class is defined and use the
    following line of code in its place:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 模块顶部的引擎和 `Base` 声明保持不变，但我们必须删除定义 `Session` 类的那一行，并使用以下代码行来替换它：
- en: '[PRE22]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This will initialize a scoped session and integrate the two transactions by
    using the `ZopeTransactionExtension`. All that is required now is to substitute
    all of the `session.commit()` calls with `transaction.commit()` calls and our
    application will enjoy secure transaction handling. Here''s a look at the resulting
    `addUser` method:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这将初始化一个作用域会话，并通过使用 `ZopeTransactionExtension` 集成两个事务。现在所需做的就是将所有的 `session.commit()`
    调用替换为 `transaction.commit()` 调用，我们的应用程序将享受安全的交易处理。以下是对结果 `addUser` 方法的查看：
- en: '[PRE23]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As you can see, committing the `db` transaction is no longer necessary, as we
    are using the Grok transaction manager now, instead of the SQLAlchemy session
    object. The database transaction will be automatically committed when Grok commits
    the transaction for us, and the Grok machinery will make sure that either both
    transactions succeed or both fail. Less work and no data inconsistencies.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，现在提交 `db` 事务不再必要，因为我们现在使用的是 Grok 事务管理器，而不是 SQLAlchemy 会话对象。当 Grok 为我们提交事务时，数据库事务将自动提交，并且
    Grok 机制将确保两个事务要么都成功，要么都失败。更少的工作，没有数据不一致。
- en: Creating database-backed models and containers
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建数据库后端模型和容器
- en: We have shown how easy it is to access and use data from a relational database.
    Very few lines of the program had to be modified and not a line of SQL was used.
    Of course, authentication is a functionality that is somewhat peripheral to the
    main application. What if we need to store all the data generated by our application
    in a relational database?
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经展示了如何轻松访问和使用关系型数据库中的数据。程序中只需要修改很少的代码行，并且没有使用任何 SQL 代码。当然，认证是主应用程序的一个相对外围的功能。如果我们需要将应用程序生成的所有数据存储在关系型数据库中怎么办？
- en: Grok's `Model` and `Container` classes store information in the ZODB, so if
    we want to use a relational database, we need to create our own model and container
    implementations, right? This seems like a lot of work. Fortunately, someone has
    already done that work for us.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Grok 的 `Model` 和 `Container` 类将信息存储在 ZODB 中，所以如果我们想使用关系型数据库，我们需要创建自己的模型和容器实现，对吧？这似乎是很多工作。幸运的是，有人已经为我们做了这些工作。
- en: The megrok.rdb package
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: megrok.rdb 包
- en: It turns out that the `megrok.rdb` package provides the Grok developer with
    `Container` and `Model` classes that work similarly to Grok's own classes, but
    store all information in a relational database. What's more, `megrok.rdb` also
    uses SQLAlchemy, so it goes hand in hand with what we have done in this chapter
    so far.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，`megrok.rdb` 包为 Grok 开发者提供了与 Grok 自身类相似工作的 `Container` 和 `Model` 类，但将所有信息存储在关系型数据库中。更重要的是，`megrok.rdb`
    还使用了 SQLAlchemy，因此它与我们在本章中迄今为止所做的工作相得益彰。
- en: This package is available from the PyPI, as you might have guessed. Hopefully,
    by this time you know that `megrok.rdb` should be added to the `install_requires`
    section of `setup.py` and the buildout needs to be run once again. This way the
    `megrok.rdb` package will be ready for use.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所猜，这个包可以从 PyPI 获取。希望到这个时候你已经知道，应该将 `megrok.rdb` 添加到 `setup.py` 的 `install_requires`
    部分，并且需要再次运行 buildout。这样，`megrok.rdb` 包就准备好使用了。
- en: Making an application database backed
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个数据库后端应用
- en: Converting our whole application to use `megrok.rdb` requires more work than
    is realistic for this introductory chapter, so let's just imagine, how we would
    design the application if we had a relational database planned for storage from
    the very beginning.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 将整个应用程序转换为使用 `megrok.rdb` 需要的工作量比本介绍章节中现实可行的工作量要多，所以让我们假设，如果我们从一开始就计划使用关系数据库进行存储，我们会如何设计这个应用程序。
- en: 'As this is just an exercise, we will show only the code that would be needed
    for getting the `Project` class working, along with its contained to-do lists.
    First, we need some imports from `sqlalchemy`, similar to those we used earlier.
    Of course, we have to import the `rdb` module from `megrok.rdb` as well:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这只是一个练习，我们将只展示使 `Project` 类及其包含的待办事项列表工作的代码，首先，我们需要从 `sqlalchemy` 中导入一些内容，类似于我们之前使用的。当然，我们必须从
    `megrok.rdb` 中导入 `rdb` 模块：
- en: '[PRE24]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'For now, we''ll dispense as well with the database connection setup. Just assume
    that we have created a database as we have done earlier in this chapter. However,
    we do need a special `metadata` object instead of the one provided by SQLAlchemy.
    We''ll get it from the `rdb` module that we just imported:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们将省略数据库连接设置。假设我们已经在本章的早期创建了数据库。然而，我们需要一个特殊的 `metadata` 对象，而不是 SQLAlchemy
    提供的那个。我们将从刚刚导入的 `rdb` 模块中获取它：
- en: '[PRE25]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We can now create the models. Remember, this code is just for illustration purposes,
    do not add it to our project.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以创建模型了。记住，这段代码只是为了说明目的，不要将其添加到我们的项目中。
- en: '[PRE26]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We define the to-do lists container first. It's just an empty class. Then, we
    define a `Project` model and its columns by using regular SQLAlchemy declarations.
    We have a `todolists` container as a property on the project, connected with the
    container that we defined earlier by using the SQLAlchemy relation declaration.
    This is necessary for having Grok-style containers in our relational database
    application.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义待办事项列表容器。它只是一个空类。然后，我们使用常规 SQLAlchemy 声明来定义 `Project` 模型和其列。我们在项目上有一个
    `todolists` 容器属性，通过使用 SQLAlchemy 关系声明与之前定义的容器连接。这对于在我们的关系数据库应用程序中拥有 Grok 风格容器是必要的。
- en: For the `TodoList` class, we use the `rdb.Model` base class and add its columns
    as well, but here, we use a foreign key to relate the to-do list with a project.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `TodoList` 类，我们使用 `rdb.Model` 基类，并添加其列，但在这里，我们使用外键将待办事项列表与项目相关联。
- en: 'Once this is done, we can generate the database structure, which will usually
    be done at an application''s creation time. We have also done this in the previous
    section, so let''s assume that we have everything ready, and start creating content:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些后，我们可以生成数据库结构，这通常在应用程序创建时完成。我们也在前面的部分中做了这件事，所以让我们假设我们已经准备好了所有东西，并开始创建内容：
- en: '[PRE27]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'First, we create a session. After that, we create a new `Project` and add it
    to the session, just like regular SQLAlchemy usage. Next, we define some to-do
    lists:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个会话。然后，我们创建一个新的 `Project` 并将其添加到会话中，就像常规 SQLAlchemy 使用一样。接下来，我们定义一些待办事项列表：
- en: '[PRE28]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This is again just regular SQLAlchemy syntax, but now we come to the part where
    we use the container that we defined inside the `Project` class to store the to-do
    lists. This is what makes it possible for us to have Grok container-like functionality
    for our database objects:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这仍然是常规 SQLAlchemy 语法，但现在我们来到了使用我们在 `Project` 类内部定义的容器来存储待办事项列表的部分。这就是我们能够在我们的关系数据库应用程序中拥有
    Grok 风格容器功能的原因：
- en: '[PRE29]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `set` method takes care of 'adding' the list to the container and lets the
    database set the key for each row. We could now call Grok container methods, such
    as `items()` on the `project_x.todolists` container and get the expected results,
    just like using `grok.Container`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`set` 方法负责将列表添加到容器中，并让数据库为每一行设置键。现在我们可以调用 Grok 容器方法，例如在 `project_x.todolists`
    容器上使用 `items()`，以获得预期的结果，就像使用 `grok.Container` 一样。'
- en: There are other things that can be done with `megrok.rdb`, so if you are interested
    in having a Grok-like database-backed application, you should consult the documentation.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `megrok.rdb` 还可以完成其他事情，所以如果你对拥有类似 Grok 的数据库后端应用程序感兴趣，你应该查阅文档。
- en: When to use the ZODB versus a relational database
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 何时使用 ZODB 而不是关系数据库
- en: Because it's fairly easy to use relational databases with Grok, people who are
    used to working with relational applications may wonder why they should use the
    ZODB at all. As comfortable as it is, to go with what we know best, no database
    technology is ideal for every kind of project.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 由于使用 Grok 操作关系型数据库相对容易，那些习惯于使用关系型应用的人可能会 wonder 为什么他们应该使用 ZODB。尽管使用我们最熟悉的技术很舒适，但没有任何数据库技术是适合所有类型项目的。
- en: A relational database is a flat entity. When working with object-oriented languages
    such as Python, it's usually necessary to take a complex hierarchy of interrelated
    objects and "flatten" it to fit into several tables. Sometimes it's a lot easier
    and faster to simply store the objects exactly as they are, like an object-oriented
    database does.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 关系型数据库是一个扁平实体。当使用像 Python 这样的面向对象语言时，通常需要将复杂的相关对象层次结构“扁平化”以适应几个表。有时简单地以它们本来的样子存储对象，就像面向对象数据库所做的那样，会更容易和更快。
- en: Which one is best for your application? The key words here are *flat* and *hierarchy*.
    If your application will handle flat information structures, such as customers,
    products, records, orders, and so on, or if you need to do heavy reporting and
    data manipulation, a relational database is most likely your best bet. Online
    stores are a good example of an application that is well suited for relational
    database use. The user management part of our application which we just did is
    also a good fit here.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 哪个最适合您的应用？这里的关键词是*扁平*和*层次结构*。如果您的应用将处理扁平的信息结构，例如客户、产品、记录、订单等，或者如果您需要进行大量的报告和数据操作，关系型数据库很可能是您最好的选择。在线商店就是一个非常适合使用关系型数据库的应用示例。我们刚刚完成的应用的用户管理部分也非常适合这里。
- en: If you have complex, hierarchical structures of objects, it might be better
    to use the ZODB and persist the hierarchies in their natural form. Content management
    applications, where you need to model structures resembling folders and pages
    that can be nested several levels deep, are ideally suited to an object-oriented
    database.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有复杂、层次化的对象结构，使用 ZODB 并以它们自然的形式持久化层次结构可能更好。内容管理应用，其中您需要模拟类似于文件夹和可以嵌套多级深度的页面结构，非常适合面向对象数据库。
- en: In the end, it's usually just a matter of preference, but in any case, Grok
    will let you use either one or even both of these mechanisms in a simple way,
    which gives you maximum flexibility.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这通常只是个人偏好的问题，但无论如何，Grok 都会以简单的方式让您使用其中一种或两种机制，这为您提供了最大的灵活性。
- en: Summary
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we saw:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了：
- en: How Grok makes it very easy to use the existing Python relational database packages
    and ORMs. We also learned to use the more advanced `megrok.rdb` package to transparently
    turn our models into ORM mappings.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Grok 如何使使用现有的 Python 关系型数据库包和 ORM 变得非常容易。我们还学习了如何使用更高级的 `megrok.rdb` 包将我们的模型透明地转换为
    ORM 映射。
- en: How to integrate relational database transactions with ZODB's transaction support.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何将关系型数据库事务与 ZODB 的事务支持集成。
- en: How to use `megrok.rdb` to turn our models into ORM mappings.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 `megrok.rdb` 将我们的模型转换为 ORM 映射。
