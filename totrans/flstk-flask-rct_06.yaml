- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Working with React Router and Forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**React Router** is a library for client- and server-side routing. Imagine
    the usual way websites work; when you click on a link, your browser sends a request
    to the web server, receives a bunch of data, and then takes time to process everything
    before finally displaying the content of the new page.'
  prefs: []
  type: TYPE_NORMAL
- en: You will get the same experience every time you request a new page from the
    website. With client-side routing, things get way smoother! Instead of going through
    that whole process every time you click a link, your web app can update the URL
    instantly without bothering the server for a new document. This means your web
    app can quickly show you a new part of the app without any delays. This and more
    is what React Router offers.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will explore React Router v6 as a magical tool to handle
    navigation. You can also use React Router for data fetching but we will limit
    our scope to component navigation in this book. You will implement simple and
    complex nested routes in React. You will also work with the `useParams` and `useNavigate`
    hooks for dynamic and programmatic routing.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will delve into form handling in React applications. Forms are vital
    components in any web application. You can’t have a complete soup of web applications
    without forms. Interestingly, we use forms for a variety of purposes that depend
    on the business or project requirements.
  prefs: []
  type: TYPE_NORMAL
- en: In React, forms are used in components to allow activities such as user login,
    registration, search, contact forms, shopping checkout page, event attendees’
    forms, and a host of others. Forms provide a medium for browser-database server
    interactions.
  prefs: []
  type: TYPE_NORMAL
- en: We collect data from users of our applications through a form; sometimes, we
    send users’ data to a database or send/save it to other platforms such as email
    and third-party applications. It all depends on how we intend to handle form data.
  prefs: []
  type: TYPE_NORMAL
- en: In a nutshell, you will learn how to use form elements to facilitate user interaction
    in your React applications. You will also understand how to leverage React Router,
    a popular routing library for client-side routing.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will understand how routing works in React applications
    by working with the React Router library to navigate your different application
    endpoints. Finally, you will be able to develop elegant React forms and handle
    users’ information in a React way.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Routing with React Router
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding React Router in React
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling dynamic routes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using forms in React
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlled and uncontrolled form components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling user input – `Input field`, `TextArea`, and `Select`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validating and sanitizing users’ data in React
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this chapter can be found at [https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter06](https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter06).
  prefs: []
  type: TYPE_NORMAL
- en: Due to page constraints, some of the code blocks have been snipped. Please refer
    to GitHub for the complete code.
  prefs: []
  type: TYPE_NORMAL
- en: Routing with React Router
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Routing** in a React web application is the ability to navigate seamlessly
    to and from multiple application components, URLs, pages, and resources, both
    internal and external. By default, React doesn’t include page routing in its library.
    And as a matter of fact, React’s main goal is to allow developers to design the
    display of the view of a single-page web application.'
  prefs: []
  type: TYPE_NORMAL
- en: We all know web applications require multiple views, hence the need for an external
    library such as React Router to allow for component navigation. Working with a
    large application would require multiple specialized views. This means we have
    to solve the problem of navigation left untreated with the React library, but
    this is where React Router comes in.
  prefs: []
  type: TYPE_NORMAL
- en: '**React Router** is an open source package that’s used for component-based
    routing in React applications. It is popular among React developers and widely
    used in various React projects. Interestingly, you can use React Router anywhere
    you intend to run React applications: client side with browsers, on a web server
    with NodeJS, and even via mobile applications with React Native.'
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have kind of taken the *Bizza* application bit by bit, cherry-picking
    the components and their interaction. Now, we are going to move through the pages
    of our projects and link them up with React Router.
  prefs: []
  type: TYPE_NORMAL
- en: React Router is composed of some routing features. These features are the nuts
    and bolts of the inner working of React Router. Knowing them will help us with
    our understanding of React Router. In the following sections, we will explain
    some of the commonly used features of React Router.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with Router, a component that enables navigation and routing within
    a React application.
  prefs: []
  type: TYPE_NORMAL
- en: Routers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'React Router provides different types of routers that allow you to handle routing
    and navigation in React applications. Each router has its specific use case and
    benefits. We will briefly discuss some of the commonly used React Router routers:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CreateBrowserRouter`: This is a specialized function in React Router v6 that
    serves as the preferred method for generating a browser router in web projects.
    By utilizing the DOM History API, it efficiently updates the URL and maintains
    the history stack. Moreover, it unlocks access to the v6.4 data APIs, encompassing
    loaders, actions, fetchers, and other React Router functionalities.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RouterProvider`: This component in React Router is designed to supply the
    router instance to all components rendered within its scope. This ensures that
    the router can be utilized for efficient management of the application’s navigation
    and routing needs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `RouterProvider` component requires a `router` prop as an argument, and
    this prop serves as the router instance that will be distributed to the components
    rendered within `RouterProvider`. It is essential to position `RouterProvider`
    at the highest level in the component tree to ensure that all application components
    can access the router instance effectively.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`NativeRouter`: This is an interface that is required to run React Router in
    React Native, a routing solution for mobile applications. This is outside the
    scope of this book.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we will discuss components in React Router. Components in React Router
    allow you to render the user interface for a specific route within a single-page
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Components in React Router enable you to create a flexible and dynamic routing
    system within your React applications, making it easier to manage navigation and
    the state as users interact with your UI. We will briefly discuss some of the
    commonly used components.
  prefs: []
  type: TYPE_NORMAL
- en: '`Link`: `Link` is a component element that allows users to navigate to another
    component page upon it being clicked. Under the hood, `react-router-dom` renders
    a `<Link>` tag to an anchor element, `<a>`, with a real `href` that directs users
    to the resources it is pointing to.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NavLink`: This works as a `<Link>` tag but with the added feature of indicating
    an active element in a menu. This is commonly used when you are building a tabbed
    menu and you want to show which part of the menu is currently selected.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Route`: This is used to render the UI in React Router based on the current
    location. `Route` has a path and an element as props. This is how it works: whenever
    the path `Route` component matches the current URL, based on the user click operation,
    it renders its element. This element could be any component in the application.
    We will see a live example shortly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Routes`: This has `Route` as its children. `Routes` works logically in a simple
    way, like `Route`, except that `Route` or a series of `Route` are children of
    `Routes`. So, whenever the path of the UI component changes, `Routes` checks all
    its children `Route` elements to determine the best match for the user request
    or click path and renders that specific UI.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we will discuss hooks in React Router. Hooks provide a mechanism for interacting
    with the router’s state and executing navigation actions directly within your
    components. We will discuss hooks such as `useLocation`, `useParams`, and `useNavigate`.
  prefs: []
  type: TYPE_NORMAL
- en: Hooks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'React Router offers a range of hooks that empower developers with efficient
    ways to manage routing, the state, and navigation within their components. We
    will briefly discuss some of the commonly used hooks:'
  prefs: []
  type: TYPE_NORMAL
- en: '`useLocation`: You can use this hook to perform some side effects whenever
    you need to track changes in the current location. The `useLocation` hook usually
    returns the current location object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UseParams`: You can use this hook to get the parameter from the browser through
    the current URL matching `<Route path>`. The `useParams` hook returns an object
    of the key-value pairs of the dynamic params.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UseNavigate`: You can use this hook to programmatically navigate between different
    routes in your React application without the need for a `history` object or the
    `Link` component.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, it is time to add React Router to our root app and connect our pages.
  prefs: []
  type: TYPE_NORMAL
- en: Adding React Router in React
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You need to install React Router to use it in your project. We are going to
    build the navigation features for the *Bizza* project to connect different components.
    The navigation tabs will consist of the home, about, speakers, events, sponsors,
    and contact pages. Let’s start coding by entering this command in the project
    directory’s Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Once we have the package installed in the root directory of our project, we
    can create the home, about, speakers, news, and contact pages components.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will add content to each of these components:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside `src/pages/HomePage/HomePage.js`, add the following code snippet:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside `src/pages/AboutPage/AboutPage.js`, add the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside `src/pages/SpeakersPage/SpeakersPage.js`, add the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside `src/pages/EventsPage/EventsPage.js`, add the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside `src/pages/SponsorsPage/SponsorsPage.js`, add the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside `src/pages/ContactPage/ContactPage.js`, add the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that these components have been set, let’s start implementing the React
    Router functionalities in our application:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside `src/index.js`, add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`createRoot`: Imports the function to create a root React component for rendering'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`createBrowserRouter` and `RouterProvider`: Import components and functions
    related to React Router, which provides routing functionality'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We also need to import all the various components we created earlier. Still
    inside `index.js`, add the following component imports:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding imports are the various files and components that will be used
    in the application.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Please note that all future components that we might want React Router to be
    aware of can be added as part of the imported files and components of the application.
    Next, we will set up the routing configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the routing configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the context of web application development and libraries such as React Router,
    routing configuration refers to the process of setting up rules or mappings that
    define how different URLs (or routes) in a web application should be handled.
    It involves specifying which components or views should be rendered for specific
    URLs, allowing users to navigate through different parts of the application seamlessly.
  prefs: []
  type: TYPE_NORMAL
- en: With React Router, you can define a list of routes and associate each route
    with a corresponding component to be displayed when the route is matched. These
    routes can be static, dynamic (with placeholders), or nested to create a hierarchical
    structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s put this to practical use. Add the following code to the `index.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code shows the created `router` object using the `createBrowserRouter`
    function, which defines the routing configuration for the application. This `router`
    object sets up different paths and their corresponding React components to be
    rendered when those paths are matched.
  prefs: []
  type: TYPE_NORMAL
- en: 'What this means is that when a user navigates to different URLs in the application,
    the corresponding components will be rendered based on the defined routes; for
    instance:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigating to `/` will render the `HomePage` component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Navigating to `/about` will render the `AboutPage` component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Likewise, the rest of the components are rendered and displayed based on the
    routes and their corresponding components. The `createRoot()` function from the
    `react-dom` library, `'react-dom/client'`, is used to create a `root` component
    for intended rendering. It is a newer and more efficient alternative to `ReactDOM.render()`.
    The `createRoot()` function takes the target DOM element as an argument and returns
    a `root` component that can be used to render React elements into that target
    element.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, `createRoot(document.getElementById("root"))` creates a `root`
    React component that will render its content inside the `<div>` element with the
    `"root"` ID. In essence, the `createRoot` function is used to create a `Root`
    object and render the `RouterProvider` component into the `root` DOM element.
  prefs: []
  type: TYPE_NORMAL
- en: The `RouterProvider` component then renders the `HomePage` component, which
    is the default route for the application. `<RouterProvider router={router} />`
    uses the `RouterProvider` component from React Router. `RouterProvider` takes
    a prop called `router`, and the value of this prop is the previously defined router
    object, which contains the preceding routing configuration. This makes `router`
    available to the entire application, enabling navigation based on the defined
    routes.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll add links to routes in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Adding links
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s improve the navigation menu by adding links to the elements. To add a
    link to an element, use `<Link to="" >elementName </Link>`. `to=""` allows us
    to insert the navigation path we intend to go to. Let’s see the details of a typical
    link definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Check the GitHub `src/components/Header/Header.jsx` file to learn more about
    the `Link` definition.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows `HomePage` with a menu and links:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1 – Screenshot showing routes and links](img/Figure_6.1_B18554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.1 – Screenshot showing routes and links
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s learn how to embed a route into another route so that we have what
    we call a nested route.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a nested route
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Nested routes** in React Router provide a structured approach to organizing
    routes within your application. They facilitate grouping related routes, streamlining
    navigation between different sections. To implement nested routes, you must utilize
    the children prop on a Route component.'
  prefs: []
  type: TYPE_NORMAL
- en: This prop accepts an array of Route components as its value, defining the child
    routes that will be rendered when the parent route is matched. For instance, consider
    the following code snippet, which demonstrates the creation of a nested route
    for speakers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside `src/index.js`, update the `/speakers` route, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we have a parent route called `speakers` with the `/speakers`
    path. The child route for `SpeakerDetail` has the `/speakers/:speakerId` path.
    The `:speakerId` placeholder in the path is a dynamic parameter that will be replaced
    with the `:speakerId` value of the speaker when the user navigates to the route.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `SpeakerDetail` component will be rendered with the detailed information
    of `speakerId` in the URL. Inside `src/pages`, create `SpeakerDetail/SpeakerDetail.js`;
    then, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the nested route with `http://localhost:3000/speakers/234`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2 – Screenshot showing the nested route](img/Figure_6.2_B18554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.2 – Screenshot showing the nested route
  prefs: []
  type: TYPE_NORMAL
- en: Essentially, nested routes can be used to organize your routes in a way that
    makes sense for your application. They can also be used to make it easier to navigate
    between related routes.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will explore how to handle dynamic and programmatic routes with `useParams`
    and `useNavigate`.
  prefs: []
  type: TYPE_NORMAL
- en: Handling dynamic routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In web application development, a `speakerId`, `productId`, `postId`, and so
    on to represent the changing value.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, let’s consider the preceding speakers route we updated with `/speakers/:speakerId`.
    It is conventional to add a colon in front of a dynamic route, like so: `:speakerId`.
    So, how can we retrieve this value of `speakerId` from the URL? This is where
    the `useParams` hook comes in.'
  prefs: []
  type: TYPE_NORMAL
- en: Using useParams
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `useParams` hook in React Router provides access to the dynamic parameters
    extracted from a route. These parameters are the values that correspond to the
    placeholders in the path of a dynamic route.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, in the following code snippet, the `useParams` hook is used to
    retrieve `SpeakerId` from the `/speakers/:speakerId` route. The following code
    shows the code implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `SpeakerDetail` component in `src/pages/`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, we have the `SpeakerDetail` component, which
    is used to display the details of a speaker based on the `speakerId` dynamic parameter
    that was extracted from the URL. The `useParams` hook will return an object that
    contains the dynamic parameters from the route. In this case, the `speakerId`
    property of the object will contain the Speaker ID in the URL.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the extracted `speakerId` from the URL:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 6.3 – Screenshot showing the extracted \uFEFFspeakerId](img/Figure_6.3_B18554.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 6.3 – Screenshot showing the extracted speakerId
  prefs: []
  type: TYPE_NORMAL
- en: The `useParams` hook is a powerful tool that can be used to access the dynamic
    parameters of any route. Next, we will briefly discuss the `useNavigate` hook
    for programmatic navigation.
  prefs: []
  type: TYPE_NORMAL
- en: Using useNavigate
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`useNavigate` is a new hook that was introduced in React Router v6\. It provides
    a way to programmatically navigate or redirect users to different routes within
    a React application. Unlike the `useHistory` hook from previous versions of React
    Router that provided access to the history object, `useNavigate` provides a more
    straightforward and explicit way to navigate between routes.'
  prefs: []
  type: TYPE_NORMAL
- en: With `useNavigate`, you can initiate navigation in response to certain events,
    such as a button click, form submission, or any other user action. Instead of
    modifying the URL directly like in React Router v5, you can now use the navigate
    function returned by `useNavigate` to achieve navigation.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, inside the `src/components/Header/Header.jsx` file, we have the
    following code to show how `useNavigate` is implemented:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, the `useNavigate` hook is called to get the `navigate`
    function. When the button is clicked, the `handleLoginButtonClick` function is
    executed, which, in turn, calls `navigate('/auth/login')`. This will navigate
    the user to the `'/auth/login'` route programmatically.
  prefs: []
  type: TYPE_NORMAL
- en: '`useNavigate` provides a more declarative and concise way to handle navigation
    compared to directly manipulating the history object. It improves the overall
    readability and maintainability of the code when working with React Router v6.'
  prefs: []
  type: TYPE_NORMAL
- en: This section wraps up routing with React Router. The subsequent section shifts
    its focus to the realm of managing forms within the React library.
  prefs: []
  type: TYPE_NORMAL
- en: Using forms in React
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Conventionally, forms are used to collect user inputs. There is no serious production-grade
    web application without forms. Using forms in React is slightly different from
    using HTML form elements. If you have developed React applications for a while,
    this might not be new to you.
  prefs: []
  type: TYPE_NORMAL
- en: The subtle difference between the elements of React forms and those of normal
    HTML forms is due to the unique way React handles the internal state of forms.
    The HTML DOM manages the internal states of native HTML form elements in a browser
    DOM way. On the other hand, React handles form elements through its components’
    state.
  prefs: []
  type: TYPE_NORMAL
- en: So, what is this state all about? The state we are talking about is an object
    that holds user inputs before form submission. Form elements have an internal
    state that prevents data loss before you submit user input across the processing
    channel.
  prefs: []
  type: TYPE_NORMAL
- en: Having laid down the background for the internal state management of form elements,
    let’s quickly move on to how React enhances the user experience through its component-based
    approach, enhanced with the VDOM mechanism of React. We are going to develop forms
    in React without the use of any external library; instead, we will focus on pure
    React and leverage its controlled component-based approach in managing form state.
    Right now, we are going to design a simple sign-up form component.
  prefs: []
  type: TYPE_NORMAL
- en: The following snippet shows a `SignUp` form component to help you understand
    how to create a simple form in React.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create `SignUp` inside `src/pages/Auth/SignUp.js/` in your project directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The preceding snippet should look familiar – there’s nothing special here except
    for the `<label>` attribute, `htmlFor`. This is the React way of adding the `for`
    attributes to the form label. The `htmlFor` prop is used to match the corresponding
    ID with input form elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moving forward, let’s update the router configuration inside `index.js` and
    add the `signup` route. Inside `src/index.js`, add the sign-up path and its associated
    component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The following figure shows the output of the signup form code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.4 – Screenshot showing the rendered signup form](img/Figure_6.4_B18554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.4 – Screenshot showing the rendered signup form
  prefs: []
  type: TYPE_NORMAL
- en: When you navigate to `http://localhost:3000/auth/signup`, you will see that
    the `SignUp` form component has been rendered. With this, React is just rendering
    the form elements and allowing native browser DOM to carry on as usual with the
    page reload at every form submission. If you fill in the form and click **REGISTER**,
    you will see the page reload effect.
  prefs: []
  type: TYPE_NORMAL
- en: This is certainly an anti-React design pattern, which means this is not a React
    way of designing form elements. So, what is the React design expectation in building
    an intuitive user form experience? The answer to this is what we will focus on
    in the next section. There, you will learn how you can build engaging and reusable
    forms with all the ingredients of the React sauce.
  prefs: []
  type: TYPE_NORMAL
- en: 'In React, there are two approaches to form components: controlled and uncontrolled
    form components. In the next section, we will dive into this and learn how to
    design form components that enhance smooth interaction with the form elements
    in a React web application project.'
  prefs: []
  type: TYPE_NORMAL
- en: Controlled and uncontrolled form components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far in this book, we have become familiar with components and how they are
    the building blocks of any React application. When you blend pieces of independently
    designed components, you get either a UI component or a full-fledged React web
    application, depending on what you are working on.
  prefs: []
  type: TYPE_NORMAL
- en: The component-driven approach of React is not going to change anytime soon.
    Building quality UIs for applications is what React does best. You are going to
    need a high-performant form one way or the other in your career as a developer,
    and React has you covered with two approaches to building air-tight form components
    that prevent data loss and improve user experience regarding form interaction.
  prefs: []
  type: TYPE_NORMAL
- en: These two approaches are controlled and uncontrolled form components. Let’s
    start with controlled form components so that we have a sufficient understanding
    of how they are implemented and why they are the React-recommended approach to
    form handling.
  prefs: []
  type: TYPE_NORMAL
- en: Controlled form
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In terms of a controlled form, a React component maintains the internal state
    of user inputs in the form elements. What do we mean? Essentially, React has an
    in-built event wrapper known as `SyntheticEvent`, a key component of the React
    event system.
  prefs: []
  type: TYPE_NORMAL
- en: We spoke a lot about `SyntheticEvent` in [*Chapter 5*](B18554_05.xhtml#_idTextAnchor095),
    *JSX and Displaying Lists in React*, in the *Event handling in React* section.
    In the controlled form approach, the event handler function in controlled form
    components accepts an instance of `SyntheticEvent`, such as `onChange`, `onInput`,
    `onInvalid`, `onReset`, and `onSubmit`, to control the state of form data.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, the `onChange` event listens to the change in the state value
    of the component form: this change could be either a user typing something in
    the form input or trying to replace the value of the form input. The `onChange`
    event is triggered and the state data value is changed appropriately.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s explore how event handlers allow us to have controlled form components.
    The following snippet demonstrates a controlled form in React with the relevant
    event handlers to manage `onChange` and `onSubmit` events. Update the `SignUp.js`
    file code to demonstrate the use of event handlers in the form component inside
    `src/pages/Auth/SignUp.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Please refer to GitHub for the full source code. In the preceding snippet, we
    have updated our default form by adding some input attributes to it – that is,
    the `value` and `onChange` events, and set the stage for a controlled form. The
    form input uses `value` to accept the current value as a prop and `onChange` as
    a callback to update the state of the value.
  prefs: []
  type: TYPE_NORMAL
- en: As you already know, user actions such as tapping the keyboard, clicking a button
    on a web page, or mousing over on an HTML element with browsers elicit events.
    But React has what we call Synthetic Events with a couple of instance methods
    and properties to listen for user interactions and emit certain events.
  prefs: []
  type: TYPE_NORMAL
- en: Popular among these instances in React are `onChange` and `onClick`. We will
    use more of these. The `onChange` event is triggered whenever there is a change
    in the form’s input element. The `event.target` property of the Web API is used
    to access the value of this change.
  prefs: []
  type: TYPE_NORMAL
- en: 'Furthermore, the `onClick` event gets activated every time an HTML element
    is clicked; for example, when a button is clicked. In our snippet, event handlers
    are specified in the body of the component function: `nameHandler`, `emailHandler`,
    and `passwordHandler`. These event handlers listen to the corresponding value
    changes in the form inputs and control the operation of the form.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of `nameHandler`, it listens to what the users type in, accesses
    the value with the use of the `e.target` property, and updates its state with
    `setName()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'In the form input with the `Name` label, the following was added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The `input` elements for email and password were equally updated with appropriate
    values and `onChange` event handlers.
  prefs: []
  type: TYPE_NORMAL
- en: '`onSubmitHandler()` handles the `onSubmit` event of the form element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '`e.preventDefault()` prevents the default reloading behavior of the browser.
    We also output the submitted form data with `alert()`. What are the benefits of
    the controlled form component?'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few reasons why you would want to use controlled form components:'
  prefs: []
  type: TYPE_NORMAL
- en: React recommends it. It is React’s best-practice way of handling user inputs
    in React.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The components tightly control the behavior of the form, thereby ensuring a
    reactive user and developer experience.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We get instant feedback from forms since the event handlers listen to form elements
    and emit events appropriately.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The controlled form component improves the experience with form interaction
    in React applications and it is widely used in the React community. Next, we will
    learn what the uncontrolled form components provide for the React developer community
    and how we can use them.
  prefs: []
  type: TYPE_NORMAL
- en: Uncontrolled form
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In an uncontrolled form, native DOM maintains and stores the state of user input
    directly. It does this by storing the values of the form elements in the DOM with
    a reference to the form elements. This is the conventional way HTML form elements
    maintain their internal states.
  prefs: []
  type: TYPE_NORMAL
- en: React components simply interact with uncontrolled form elements by maintaining
    references to the underlying form element in the DOM. Let’s replicate our earlier
    signup form and refactor the snippet to use uncontrolled form components.
  prefs: []
  type: TYPE_NORMAL
- en: 'This snippet uses the `useRef` hook to reference the values of the form elements
    in the DOM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Please refer to GitHub for the full source code. Let’s briefly explain the preceding
    snippet.
  prefs: []
  type: TYPE_NORMAL
- en: In using the uncontrolled form React component, we needed the `useRef` hook
    to access the form elements in the DOM. `import React, { useRef } from 'react';`
    brings React and the `useRef()` hook into scope.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we created a reference variable to hold the reference of the form element
    in the DOM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `input` tag, we bound the reference variable to the `ref` attribute
    of the input element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The same steps were taken for the email and password input elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'To extract the current value of the form fields, we must use the `current.value`
    property of `useRef` in `onSubmitHandler()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The following figure shows the console logs of the uncontrolled form component
    in React:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.5 – Console log of the uncontrolled form component](img/Figure_6.5_B18554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.5 – Console log of the uncontrolled form component
  prefs: []
  type: TYPE_NORMAL
- en: What are the benefits of the uncontrolled form component?
  prefs: []
  type: TYPE_NORMAL
- en: 'Interestingly, there are few benefits to using uncontrolled form components,
    even though React recommends the controlled approach. Here are a few benefits
    for consideration in your React project:'
  prefs: []
  type: TYPE_NORMAL
- en: In complex React form applications, where re-rendering the form UI with every
    user input could be an expensive DOM operation on the performance of the application.
    Using uncontrolled form components prevents the performance bottlenecks associated
    with component re-rendering of form elements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The uncontrolled form is more appropriate when you need to work with a form
    input of the `file` type in your React application, such as when doing a file
    upload.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The uncontrolled form is quick to use when you are migrating from a legacy non-React
    code base project. Since DOM maintains the state of the form, working with form
    fields from the legacy code base is easier.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now that we have sufficiently examined what an uncontrolled form in React project
    is all about and covered a few of the benefits of using an uncontrolled form,
    let’s dive into a few of the commonly used input elements: `Input`, `TextArea`,
    and `Select`.'
  prefs: []
  type: TYPE_NORMAL
- en: Handling user input – Input, TextArea, and Select
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Handling React form elements is slightly different from the way non-React applications
    handle user inputs. In this section, we will look at common form elements that
    are used in handling user input while following React best practices.
  prefs: []
  type: TYPE_NORMAL
- en: Input
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Input** fields in the form are the most widely used tags in any web application.
    An input field allows the collection of user data. Input fields have different
    types depending on their purpose in a form. In the controlled input form element,
    the component state is always set using a value or checked attribute on the form
    input field. You also have a callback that listens to the change in value as a
    result of user input.'
  prefs: []
  type: TYPE_NORMAL
- en: With the input type radio and checkbox, we use the checked attributes. To access
    the value of the input field, we can use `event.target.checked`.
  prefs: []
  type: TYPE_NORMAL
- en: TextArea
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Textarea` is a tag that allows users to write multi-line characters of text.
    `Textarea` is usually used to collect user data such as comments or review sections
    in web applications. The `Textarea` element in React works differently. The state
    is set using a value or checked attribute in the form input field, similar to
    a single input field. `textarea` doesn’t have children, which is typical of HTML.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use a callback to retrieve the change in the state value of the form
    element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Select
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `select` form element is used in designing a drop-down list. React has its
    unique way of working with `select`. The selected value is set with a value attribute
    on the `select` form element. In React, there is no selected attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'This selection is determined by the set value property on the `select` form
    element. You can use a callback when handling the selected value in the form element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Next, we will discuss how React applications handle user data validation and
    how you can sanitize your users’ data when they’re filling in a form element.
  prefs: []
  type: TYPE_NORMAL
- en: Validating and sanitizing users’ data in React
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Validation** is a process that ensures user data quality, integrity, and
    an appropriate format that’s expected for a system. You can never trust data provided
    by users of your application blindly. While we expect them to trust our code,
    we can’t reciprocate that trust by not guiding them on how our forms and form
    data should be treated.'
  prefs: []
  type: TYPE_NORMAL
- en: Starting as a junior developer, the phrase *Don’t ever believe a user would
    always do the right thing with your form* will forever ring true. You can never
    trust user data as is. Data that comes from users has to be thoroughly scrutinized
    and cleaned and ensured it is in the desired format.
  prefs: []
  type: TYPE_NORMAL
- en: Forms fields are the open window into everything you might call the backend
    in web development. So, trusting user input without some rules in place could
    be detrimental to your sanity as a developer and to the healthy condition of your
    web application.
  prefs: []
  type: TYPE_NORMAL
- en: There are always standard-practice validation rules you can adhere to as a React
    developer. These validation rules guide you and your application against bad actors
    of your application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at a few validation rules you might want to check off before
    user input data is deposited in your database or any of your backend infrastructure:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Data type**: You need to ascertain the user is putting in the right data
    type for a form field. Are they even filling in anything at all? You need to check.
    For example, in a form field where you are expecting string characters, ensure
    you are not getting numeric data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Consistency**: You need to ensure data consistency of user input, and one
    of the ways to be sure you get consistent data is by enforcing validation rules.
    For instance, you might add a regular expression to check that the length of the
    password is not less than 8 characters and that it is mixed with symbols.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Alternatively, you might just allow users to select a country they’d like to
    visit from a drop-down list of options rather than asking them to type the name
    of countries they would like to visit. If you do the latter, you will be rudely
    shocked regarding what you will get in return for your benevolence.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Data format**: You probably want the date of birth of your application users
    to be in *YYYY-MM-DD* or *DD-MM-YYYY* format. You and I know we can’t leave this
    at the discretion of users!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Range and constraint**: You may also want to check data against a certain
    range of parameters or if some data falls within a certain constraint intended.
    So, you need to enforce this with some mechanisms – a regular expression is an
    example of such a mechanism. You should always remember that users are prone to
    making genuine errors as well, even though they don’t mean to act badly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'That being said, there are two major instances when you will want to enforce
    validation rules in React form design:'
  prefs: []
  type: TYPE_NORMAL
- en: '**On user input**: As users are interacting with your form elements, you are
    checking for compliance and giving instant feedback. React shines best here with
    a controlled form component that uses a callback to harvest user values and relay
    them to event handlers with the ability to check for errors. We will implement
    this in our sign-up form shortly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**On user submission**: Form data is subjected to validation when the user
    clicks on the submit button in this instance. This used to be the gold standard
    in the past. However, nowadays, this seems to be happening less in enterprise
    application development due to the arrays of frontend technologies that make instant
    feedback a cool breeze to implement.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing form validation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s examine the implementation of form data validation using the React-controlled
    form component.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start by importing the `useState` and `useEffect` hooks and bringing
    them into scope to manage state and side effects, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we must set the state variables as `initialValues`, `formValues`, `formErrors`,
    and `isSubmit`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '`initialValues` is declared as an object to hold the initial form input state,
    which is set to empty strings. `useState` takes the `initialValues` variable values
    as the initial state and assigns it to `formValues` so that from the onset, all
    the form input values are empty strings. The initial state of `formErrors` is
    set to an empty object as well and the initial state of `isSubmit` is set to `false`.
    This means no form has been submitted yet.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We need an `onChange` function to track changes to form input values. We must
    set `onChangeHandler()`, which takes `e` as a parameter of the event object and
    destructures the `e.target` object, which returns two properties – `name` and
    `value`. The `setFormValues` function accepts all the current `formValues` with
    the `...formValues` spread operator and updates them to the new values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '`useEffect()` is used to log successfully submitted values if there are no
    form errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Next, the rules for form data validation are set with the `validateForm` function.
    This is a simple validation rule that checks whether the `name`, `email`, and
    `password` form inputs are filled in. It also checks whether the right format
    is being used for email using `regex.test()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the password, we must check whether the password is more than 8 characters
    but does not exceed more than 12 characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, `onSubmitHandler()` is invoked, which ensures the `setFormErrors()` function
    is run, which takes `validateForm()` as a parameter. If there are no errors in
    the form, `setIsSubmit` is set to `true`, allowing the form to be submitted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the JSX that’s returned from the form component with `onSubmitHandler`
    and each of the errors displayed by the `formErrors` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The following figure shows the output for form entries when form fields are
    filled before being submitted:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.6 – Screenshot of a form with validation rules](img/Figure_6.6_B18554.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.6 – Screenshot of a form with validation rules
  prefs: []
  type: TYPE_NORMAL
- en: We added the `formErrors` property to every form element to output an error
    message if an error exists. For instance, `{formErrors.name}` displays an error
    for `name` if a name is not filled in the form.
  prefs: []
  type: TYPE_NORMAL
- en: 'The full code for this validation rule can be found in this book’s GitHub repository:
    https://github.com/PacktPublishing/Full-Stack-Flask-Web-Development-with-React/blob/main/Chapter-06/.'
  prefs: []
  type: TYPE_NORMAL
- en: This wraps up how you can add validation to your React application without the
    use of an external library, thus minimizing the number of potential dependencies
    your application might rely on.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we discussed two vital concepts in React: forms and routing.
    We highlighted the subtle difference in the forms that are set up in non-React
    and React applications. React provides tons of improvement in how it handles form
    elements through the use of controlled and uncontrolled form components to enhance
    the user experience.'
  prefs: []
  type: TYPE_NORMAL
- en: Then, we delved into validation concepts and how you can implement validation
    rules in React. We then spoke about React Router. We demonstrated how React Router,
    a third-party library, enables us to navigate complex React applications. We discussed
    the use of `Route`, `Links`, and nested `Routes` and explored how they are used
    in a React project.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about and understand how to implement testing
    in React applications. Testing is an essential part of software development as
    it ensures the components of an application work as they should and that the relevant
    best practices are observed in development.
  prefs: []
  type: TYPE_NORMAL
