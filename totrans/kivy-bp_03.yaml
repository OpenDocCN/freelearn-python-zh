- en: Chapter 3. Sound Recorder for Android
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we briefly discussed how the Kivy app, generally cross-platform,
    may have parts of code working conditionally on selected systems, enhancing user
    experience for some users and performing other platform-specific tasks.
  prefs: []
  type: TYPE_NORMAL
- en: At times, this is essentially free; for example, multitouch just works if Kivy
    detects support for it on a target system—you don't need to write any code to
    turn it on, but only account for the sheer possibility of several pointer events
    firing at the same time for different touches.
  prefs: []
  type: TYPE_NORMAL
- en: Other platform-dependent tasks include code that just cannot run on other systems
    for various reasons. Remember the mouse cursor customization from the Paint app?
    That code used low-level bindings to SDL cursor routines provided by Pygame, which
    is perfectly fine as long as you have SDL and Pygame running. So, in order to
    make our app multi-platform, we took precautions to avoid entering that specific
    code path on incompatible systems; otherwise, it would have crashed our program.
  prefs: []
  type: TYPE_NORMAL
- en: Otherwise, Kivy applications are generally portable across all supported platforms—Mac,
    Windows, Linux, iOS, Android, and Raspberry Pi—with no significant problems. Until
    they aren't; we will discuss the reason for this in a second.
  prefs: []
  type: TYPE_NORMAL
- en: '![Sound Recorder for Android](img/B01620_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Kivy supports a wide variety of platforms
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Achieving interoperability between Python and Java using the **Pyjnius** library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing Kivy apps on a device (or an emulator) running Android OS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with Android's sound API from Python, which allows you to record and
    playback audio files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making a tiled user interface layout, similar in concept to Windows Phone
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using icon fonts to improve the presentation of the app with vector icons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing platform-dependent code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most of the projects in this book are inherently cross-platform, thanks to Kivy
    being extremely portable. This time, however, we're building an app that will
    be purposefully single-platform. This is certainly a severe limitation that reduces
    our potential user base; on the other hand, this gives us an opportunity to rely
    on platform-specific bindings that provide extended functionality.
  prefs: []
  type: TYPE_NORMAL
- en: The need for such bindings arises from the fact that Kivy strives to be as cross-platform
    as possible and delivers a similar user experience on every system it supports.
    This is a huge feature by itself; as a plus, we have the ability to write code
    once and run everywhere with little to no tweaks.
  prefs: []
  type: TYPE_NORMAL
- en: The downside of being cross-platform, however, is that you can only rely on
    the core functionality supported by every system. This "lowest common denominator"
    feature set includes rendering graphics on the screen, reproducing a sound if
    there is a sound card, accepting user input, and not much else.
  prefs: []
  type: TYPE_NORMAL
- en: Each Kivy app, by the virtue of being written in Python, also has access to
    the vast Python standard library. It facilitates networking, supports a number
    of application protocols, and provides many general-purpose algorithms and utility
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: Still, the **input-output** (**IO**) capabilities of a "pure Kivy" program are
    limited to those that are present on most platforms. This amounts to a tiny fraction
    of what a common computer system, such as a smartphone or a tablet PC, can actually
    do.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the API surface of a modern mobile device (for the sake
    of this chapter, let''s assume it''s running Android). We''ll split everything
    in two parts: things that are supported directly by Python and/or Kivy, and things
    that aren''t.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are features that are directly available in Python or Kivy:'
  prefs: []
  type: TYPE_NORMAL
- en: Hardware-accelerated graphics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Touch screen input with optional multitouch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sound playback (at the time of writing this, the playback is supported only
    for files in persistent storage)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Networking, assuming that Internet connectivity is present
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following are features that aren''t supported or require an external library:'
  prefs: []
  type: TYPE_NORMAL
- en: Modem, support for voice calls, and SMS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use of built-in cameras for filming videos and taking pictures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use of a built-in microphone to record sound
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cloud storage for application data, associated with a user account
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bluetooth and other near-field networking features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Location services and GPS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fingerprinting and other biometric security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Motion sensors, that is, accelerometer and gyroscope
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Screen brightness control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vibration and other forms of haptic feedback
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Battery charge level
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For most entries in the "not supported" list, different Python libraries are
    already present to fill the gap, such as Audiostream for a low-level sound recording
    and Plyer that handles many platform-specific tasks.
  prefs: []
  type: TYPE_NORMAL
- en: So, it's not like these features are completely unavailable to your application;
    realistically, the challenge is that these bits of functionality are insanely
    fragmented across different platforms (or even consecutive versions of the same
    platform, for example, Android); thus, you end up writing platform-specific, not
    portable code anyway.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from the preceding comparison, a lot of functionality is available
    on Android, only partially covered by an existing Python or Kivy API. This leaves
    a huge amount of untamed potential for using platform-specific features in your
    applications. This is not a limitation, but an opportunity. Shortly, you will
    learn how to utilize any Android API from Python code, allowing your Kivy application
    to do practically anything.
  prefs: []
  type: TYPE_NORMAL
- en: Another advantage of narrowing the scope of your app to only a small selection
    of systems is that there are whole new classes of programs that can function (or
    even make sense) only on a mobile device with fitting hardware specifications.
    These include augmented reality apps, gyroscope-controlled games, panoramic cameras,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Pyjnius
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To harness the full power of our chosen platform, we're going to use a platform-specific
    API, which happens to be in Java and thus primarily Java-oriented. We are going
    to build a sound recorder app, similar to the apps commonly found in Android and
    iOS, albeit more simplistic. Unlike pure Kivy, the underlying Android API certainly
    provides us with ways of recording sound programmatically.
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the chapter will cover this little recorder program throughout its
    development to illustrate the Python-Java interoperability using the excellent
    Pyjnius library, another great project made by Kivy developers. The concept we
    chose—sound recording and playback—is deliberately simple so as to outline the
    features of such interoperation without too much distraction caused by the sheer
    complexity of a subject and abundant implementation details.
  prefs: []
  type: TYPE_NORMAL
- en: The most interesting property of Pyjnius is that it doesn't provide its own
    "overlay" API over Android's, but instead allows you to use Java classes directly
    from Python. It means that you have full access to the native Android API and
    the official Android documentation, which is obviously more suited for Java development,
    not Python. However, this is still better than having no API reference at all.
  prefs: []
  type: TYPE_NORMAL
- en: Note that you don't have to install Pyjnius locally to complete the tutorial,
    since we obviously aren't going to run the code that taps into Android Java classes
    on the machine used for development.
  prefs: []
  type: TYPE_NORMAL
- en: The source code of Pyjnius, together with the reference manual and some examples,
    can be found in the official repository at [https://github.com/kivy/pyjnius](https://github.com/kivy/pyjnius).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will talk about Pyjnius only in the context of Android development and interoperation,
    but keep in mind that you can do the same kind of integration with desktop Java.
    This is an interesting property because another option of scripting a Java API
    from Python is Jython, which is rather slow and incomplete. Pyjnius, on the other
    hand, allows you to use the official Python interpreter (CPython), together with
    a multitude of libraries such as NumPy, which facilitates very fast computation.
  prefs: []
  type: TYPE_NORMAL
- en: So, if you absolutely have to call a Java library from Python, by all means
    consider Pyjnius as a good interop variant.
  prefs: []
  type: TYPE_NORMAL
- en: Emulating Android
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned earlier, this chapter's project targets Android exclusively, thus
    it will not work on your computer. Don't worry if you haven't got a spare Android
    gadget, or if you don't feel comfortable toying with the real, physical device
    for the purpose of this tutorial. There are good-quality Android emulators available
    to help you overcome this minor obstacle and toy with the Android OS from the
    comfort of your desktop.
  prefs: []
  type: TYPE_NORMAL
- en: One of the best emulators out there is Genymotion (previously AndroVM), built
    on top of Oracle's VirtualBox virtual machine. You can grab a free copy from the
    official website, [http://www.genymotion.com/](http://www.genymotion.com/); at
    the time of writing this, their licensing is very liberal, allowing for practically
    unrestricted free personal use.
  prefs: []
  type: TYPE_NORMAL
- en: The installation of the VM package is wildly different for every emulator and
    host OS combination, so we won't provide overly detailed instructions at this
    point. After all, these things are supposed to be user friendly nowadays, complete
    with instruction manuals and graphical user interfaces. Truly, we have reached
    the golden age of technology.
  prefs: []
  type: TYPE_NORMAL
- en: 'Even if the last sentence wasn''t entirely sarcastic, there would''ve been
    some things to consider when setting up and using a virtual machine for Android
    emulation:'
  prefs: []
  type: TYPE_NORMAL
- en: Always use the latest version of Android. Backward compatibility or lack thereof
    can be pretty bad; debugging OS-level glitches isn't entertaining at all.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don't hesitate to search the Internet for solutions. The Android community is
    huge, and if you have a problem, it means that you're most probably not alone.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Kivy Launcher app, which you may find very useful to test your own programs,
    is available in the form of an `.apk` file from the official Kivy website, [http://kivy.org/](http://kivy.org/);
    this will be useful for emulated Android devices that don't have access to Google
    Play.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lastly, there are many different emulators out there of varying quality and
    compatibility. If things just seem to blow up and cease working at random, maybe
    you should try another VM or Android distribution. Fiddling with the virtual machine's
    configuration may also help.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The next screenshot depicts a Genymotion virtual machine running a recent version
    of Android, complete with usable Kivy Launcher:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Emulating Android](img/B01620_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Genymotion VM running Android 4.4.2 with Kivy Launcher installed
  prefs: []
  type: TYPE_NORMAL
- en: Metro UI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While we''re at it, let''s build a user interface that resembles the Windows
    Phone home screen. This concept, basically a grid of colored rectangles (tiles)
    of various sizes, was known as **Metro UI** at some point in time, but was later
    renamed to **Modern UI** due to trademark issues. No matter the name, this is
    how it looks. This will give you a vague idea of what we''ll be aiming at during
    the course of this app''s development:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Metro UI](img/B01620_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Design inspiration – Windows Phone home screen with tiles
  prefs: []
  type: TYPE_NORMAL
- en: 'Obviously, we aren''t going to replicate it as is, but rather make something
    that resembles the depicted user interface. The following list pretty much summarizes
    the distinctive features we''re after:'
  prefs: []
  type: TYPE_NORMAL
- en: Everything is aligned to a rectangular grid
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: UI elements feature the same flat look discussed in [Chapter 1](ch01.html "Chapter 1. Building
    a Clock App"), *Building a Clock App* (tiles use bright, solid colors, and there
    are no shadows or rounded corners)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tiles that are considered more useful (for an arbitrary definition of "useful")
    are larger and thus easier to hit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If this sounds easy to you, then you're absolutely right. As you will see shortly,
    the Kivy implementation of such a UI is rather straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: The buttons
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To start off, we are going to tweak a `Button` class, just like we did in our
    previous applications. It resembles `ColorButton` from the Paint app ([Chapter
    2](ch02.html "Chapter 2. Building a Paint App"), *Building a Paint App*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The texture we set as the background is solid white, exploiting the same trick
    that was used while creating the color palette. The `background_color` property
    acts as tint color, and assigning a plain white texture equals to painting the
    button in `background_color`. We don't want borders this time.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second (pressed `background_down`) texture is 25 percent transparent white.
    Combined with the pitch-black background color of the app, we''re getting a slightly
    darker shade of the same background color the button was assigned:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The buttons](img/B01620_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Normal (left) and pressed (right) states of a button – the background color
    is set to #0080FF'
  prefs: []
  type: TYPE_NORMAL
- en: The grid structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The layout is a bit more complex to build. In the absence of readily available
    Modern UI-like tiled layout, we are going to emulate it with the built-in `GridLayout`
    widget. It behaves just like the `BoxLayout` widget we used earlier, only in two
    dimensions instead of one, so there is no `orientation: ''horizontal''` or `''vertical''`
    property—the `GridLayout` widget is both at the same time.'
  prefs: []
  type: TYPE_NORMAL
- en: 'One such layout could have fulfilled all our needs, if not for the last requirement:
    we want to have bigger and smaller buttons. Presently, `GridLayout` doesn''t allow
    the merging of cells to create bigger ones (a functionality similar to the `rowspan`
    and `colspan` attributes in HTML would be nice to have). So, we will go in the
    opposite direction: start with the root `GridLayout` with big cells and add another
    `GridLayout` inside a cell to subdivide it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Thanks to nested layouts working great in Kivy, we arrive at the following
    Kivy language structure (let''s name the file `recorder.kv`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In order to run this code, you'll need the usual `main.py` boilerplate to serve
    as an application's entry point. Try writing this code yourself as an exercise.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Refer to the beginning of the first chapter. The application class name will
    be different because it should reflect the name of the Kivy language file presented
    earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note how the nested `GridLayout` widget sits on the same level as that of outer,
    large buttons. This should make perfect sense if you look at the previous screenshot
    of the WinPhone home screen: a pack of four smaller buttons takes up the same
    space (one outer grid cell) as a large button. The nested `GridLayout` is a container
    for those smaller buttons.'
  prefs: []
  type: TYPE_NORMAL
- en: Visual attributes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'On the outer grid, `padding` is provided to create some distance from the edges
    of the screen. Other visual attributes are shared between `GridLayout` instances
    and moved to a class, resulting in the following code inside `recorder.kv`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It's worth mentioning that both `padding` and `spacing` are effectively lists,
    not scalars. The `spacing[0]` property refers to a horizontal spacing, followed
    by a vertical one. However, we can initialize `spacing` with a single value, as
    shown in the preceding code; this value will then be used for everything.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each grid consists of two columns with some spacing in between. The `row_default_height`
    property is trickier: we can''t just say, "Let the row height be equal to the
    cell width." Instead, we compute the desired height manually, where 0.5 is because
    we have two columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Visual attributes](img/7849OS_03_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If we don't apply this tweak, the buttons inside the grid will fill all the
    available vertical space, which is undesirable, especially when there aren't that
    many buttons (every one of them ends up being too large). Instead, we want all
    the buttons nice and square, with empty space at the bottom left, well, empty.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the screenshot of our app''s "Modern UI" tiles, resulting
    from the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Visual attributes](img/B01620_03_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The UI so far – clickable tiles of variable size not too dissimilar from our
    design inspiration
  prefs: []
  type: TYPE_NORMAL
- en: Scalable vector icons
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the nice finishing touches we can apply to the application UI is the
    use of icons, and not just text, on buttons. We could, of course, just throw in
    a bunch of images, but let's borrow another useful technique from modern web development
    and use an icon font instead—as you will see shortly, these provide great flexibility
    at no cost.
  prefs: []
  type: TYPE_NORMAL
- en: Icon fonts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Icon fonts are essentially just like regular ones, except their glyphs are unrelated
    to the letters of a language. For example, you type "P" and the Python logo is
    rendered instead of the letter; every font invents its own mnemonic on how to
    assign letters to icons.
  prefs: []
  type: TYPE_NORMAL
- en: This is about the only downside to using an icon font—the code that uses such
    font heavily isn't very readable because character–icon mapping is hardly obvious.
    This can be mitigated by using constants instead of entering symbols directly.
  prefs: []
  type: TYPE_NORMAL
- en: There are also fonts that don't use English letters, instead they map icons
    to Unicode's "private use area" character codes. This is a technically correct
    way to build such a font, but application support for this Unicode feature varies—not
    every platform behaves the same in this regard, especially when it comes to mobile
    platforms. The font that we will use for our app does not assign private use characters
    and uses ASCII (plain English letters) instead.
  prefs: []
  type: TYPE_NORMAL
- en: Rationale for using icon fonts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'On the Web, icon fonts solve a number of problems that are commonly associated
    with (raster) images:'
  prefs: []
  type: TYPE_NORMAL
- en: First and foremost, raster images don't scale well and may become blurry when
    resized—there are certain algorithms that produce better results than others,
    but as of today, the "state of the art" is still not perfect. In contrast, a vector
    picture is infinitely scalable, by definition.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Raster image files containing schematic graphics (such as icons and UI elements)
    tend to be larger than vector formats. This does not apply to photos encoded as
    JPEG, obviously.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition, an icon font is typically just one file for any number of icons,
    which means one HTTP round trip. Regular icons (images) routinely end up in separate
    files, leading to significant HTTP overhead; there are ways to mitigate this,
    such as CSS sprites, but they are not universally used and have their own problems.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the case of icon fonts, a color change literally takes about a second—you
    can do just that by adding `color: red` (for example) to your CSS file. The same
    is true for size, rotation, and other properties that don''t involve changing
    the geometry of an image. Effectively, this means that making trivial adjustments
    to an icon does not require an image editor, like it normally would when dealing
    with bitmaps.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some of these points do not apply to Kivy apps that much, but overall, the use
    of icon fonts is considered a good practice in contemporary web development, especially
    since there are many free high-quality fonts to choose from—that's hundreds of
    icons readily available for inclusion in your project.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Two great sources of free fonts (including those that are free for commercial
    usage) are **Font Squirrel** ([http://www.fontsquirrel.com](http://www.fontsquirrel.com))
    and **Google Fonts** ([https://www.google.com/fonts](https://www.google.com/fonts)).
    Never mind the general web development orientation of these sites, most fonts
    are just as usable in your offline programs as they are on the Web. If not more
    so, because browser support still isn't ideal.
  prefs: []
  type: TYPE_NORMAL
- en: 'The only thing that really matters is the file format: Kivy only supports True
    Type (`.ttf`) at the moment. Thankfully, this is the most popular font format
    out there anyway. Besides, it''s possible to convert a font from practically any
    other format to `.ttf`.'
  prefs: []
  type: TYPE_NORMAL
- en: Using the icon font in Kivy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In our application, we are going to use the Modern Pictograms (version 1) free
    font, designed by John Caserta. The following is a glimpse of how it looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the icon font in Kivy](img/B01620_03_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A small sample of icons from the Modern Pictograms icon font
  prefs: []
  type: TYPE_NORMAL
- en: To load the font into our Kivy program, we'll use the same process outlined
    in [Chapter 1](ch01.html "Chapter 1. Building a Clock App"), *Building a Clock
    App*. In this specific case, it isn't strictly necessary, as icon fonts rarely
    have different font weights and styles. Still, accessing the font by display name
    (Modern Pictograms) rather than the filename (`modernpics.ttf`) is a better way.
    You can later rename or move the font file by updating just one occurrence of
    its path, and not every place where the font was used.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code so far (in `main.py`) looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The actual use of the font happens inside `recorder.kv`. First, we want to
    update the `Button` class once again to allow us to change the font in the middle
    of a text using markup tags. This is shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The `halign: ''center''` attribute means that we want every line of text centered
    inside the button. The `markup: True` attribute is self-evident and required because
    the next step in customization of buttons will rely heavily on markup.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can update button definitions. Here''s an example of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Normally, you don't need parentheses around strings in Kivy language files;
    this syntax is useful only when the declaration is multiline. This notation is
    effectively the same as writing a long string on the same line.
  prefs: []
  type: TYPE_NORMAL
- en: Notice the character `'e'` inside the `[font][size]` tags. That's the icon code.
    Every button in our app will use a different icon, and changing an icon amounts
    to replacing a single letter in the `recorder.kv` file. Complete mapping of the
    code for the Modern Pictograms font can be found on its official website at [http://modernpictograms.com/](http://modernpictograms.com/).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In order to explore an icon font by hand, you'll need to use a font viewer.
    Typically, there is one readily available on your machine, regardless of an operating
    system.
  prefs: []
  type: TYPE_NORMAL
- en: The **Character Map** program is bundled with Windows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On a Mac, there is a built-in application called **Font Book**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linux has several viewers depending on the desktop environment of your choice,
    for example, **gnome-font-viewer** in GNOME
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Alternatively, just search the Web. Popular fonts usually have some sort of
    user manual online that explains character mapping.
  prefs: []
  type: TYPE_NORMAL
- en: 'Long story short, this is how the UI of our application looks after the addition
    of icons to buttons:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the icon font in Kivy](img/B01620_03_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The sound recorder app interface – a modern UI with vector icons from the Modern
    Pictograms font
  prefs: []
  type: TYPE_NORMAL
- en: This is already pretty close to the original Modern UI look.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You might wonder what is the purpose of smaller green buttons at the top-right
    corner. The answer is that currently they're there for quantity alone. Three buttons
    that we actually need to implement a sound recorder—record, play, delete—just
    aren't enough to illustrate the Modern UI concept, as it needs more diversity
    to look even remotely interesting.
  prefs: []
  type: TYPE_NORMAL
- en: Testing on Android
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Right now, our app still doesn't contain any non-portable code, but let's gradually
    move towards our platform of choice nevertheless and begin testing it on Android.
    The only prerequisite for this operation is an Android device, physical or virtualized,
    with the **Kivy Launcher** application installed and working.
  prefs: []
  type: TYPE_NORMAL
- en: 'Packaging an app for Kivy Launcher is borderline trivial. We''re going to add
    two files, `android.txt` and `icon.png`, to the same folder where other sources
    (in this case, `main.py` and `recorder.kv`) reside and then copy the folder to
    an SD card of the Android device under `/Kivy`. The directory structure should
    look something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing on Android](img/B01620_03_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: SD card directory structure for Kivy Launcher
  prefs: []
  type: TYPE_NORMAL
- en: When you start Kivy Launcher, it will spell out the full path that it searches
    for projects. This may be useful, for example, when you have no SD card.
  prefs: []
  type: TYPE_NORMAL
- en: 'The format of the `android.txt` file is pretty self-evident:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Title and author fields are just strings displayed in the list of apps. Orientation
    can be either portrait (vertical, *height > width*) or landscape (horizontal,
    *width > height*), depending on the application's preferred aspect ratio.
  prefs: []
  type: TYPE_NORMAL
- en: The icon `icon.png` is optional and will be blank if omitted. It is advisable
    to add it because it's much easier to look up applications based on their icons,
    and if you're planning to release the resulting app to the Google Play store,
    you'll need an icon anyway.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the icon's filename isn't customizable, and neither is the `main.py`
    filename, which must designate the application's entry point; otherwise, Kivy
    Launcher won't start the app.
  prefs: []
  type: TYPE_NORMAL
- en: 'With all the files in place, you should see your Sound recorder program in
    the list when you start Kivy Launcher:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing on Android](img/B01620_03_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The Kivy Launcher applications list, containing every app we've written during
    the course of this book
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If instead you see a message containing instructions where to put files, please
    recheck your paths—unfortunately, the directory that Kivy Launcher searches for
    projects is not easily configurable at the time of writing this. This may improve
    in future versions.
  prefs: []
  type: TYPE_NORMAL
- en: Now you can start your app by tapping the corresponding entry in the list. This
    is the easiest way to test a Kivy program on Android—just copy files and you're
    all set (as opposed to packaging an `.apk` file, which is also relatively straightforward
    but considerably more involved).
  prefs: []
  type: TYPE_NORMAL
- en: Using the native API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having done the user interface part of the app, we will now turn to a native
    API and implement the sound recording and playback logic using the suitable Android
    Java classes, `MediaRecorder` and `MediaPlayer`.
  prefs: []
  type: TYPE_NORMAL
- en: Technically, both Python and Java are object-oriented, and it may even appear
    at first glance that these languages are rather similar. The utilization of OOP
    principles, however, differs radically. In comparison to Python, many Java APIs
    suffer from (or enjoy immensely, depending on who you ask) over-architecting and
    general overuse of the object-oriented paradigm. So don't be surprised that otherwise
    very simple tasks may require you to import and instantiate quite a lot of classes.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In 1913, Vladimir Lenin wrote regarding the Java architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '*And there is only one way of smashing the resistance of those classes, and
    that is to find, in the very society which surrounds us, the forces which can
    constitute the power capable of sweeping away the old and creating the new.*'
  prefs: []
  type: TYPE_NORMAL
- en: The essay didn't mention Python or Pyjnius back then, but the message is clear—even
    a century ago, going overboard with classes wasn't very much welcome in the contemporary
    society.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thankfully, the task at hand is relatively simple. To record a sound using
    the Android API, we only need the following five Java classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`android.os.Environment`: This class provides access to many useful environment
    variables. We are going to use it to determine the path where SD card is mounted
    so we can save the recorded audio file. It''s tempting to just hardcode `''/sdcard/''`
    or a similar constant, but in practice, every other Android device has a different
    filesystem layout. So let''s not do this even for the purposes of the tutorial.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`android.media.MediaRecorder`: This class is our main workhorse. It facilitates
    capturing audio and video and saving it to the filesystem.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`android.media.MediaRecorder$AudioSource`, `android.media.MediaRecorder$AudioEncoder`,
    and `android.media.MediaRecorder$OutputFormat`: These are enumerations that hold
    values we need to pass as arguments to the various methods of `MediaRecorder`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Java class naming scheme**'
  prefs: []
  type: TYPE_NORMAL
- en: The dollar sign in the class name commonly means that the class is internal.
    This is not the exact heuristic, as you can declare a similar class name yourself
    without following any logic whatsoever—`'$'` is a usable character in Java variable
    and class names, not too dissimilar from, for example, JavaScript. Such unorthodox
    naming, however, is frowned upon.
  prefs: []
  type: TYPE_NORMAL
- en: Loading Java classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The code to load the aforementioned Java classes into your Python application
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'If you try to run the program at this point, you''ll receive an error, something
    along the lines of:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ImportError: No module named jnius**: You''ll encounter this error if you
    don''t have Pyjnius installed on your machine'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**jnius.JavaException: Class not found ''android/os/Environment''**: You''ll
    encounter this error if Pyjnius is installed, but the Android classes we''re trying
    to load are missing (for example, when running on a desktop machine)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is one of the rare cases when receiving an error means we did everything
    right. From now on, we should do all of the testing on Android device or inside
    an emulator because the code isn't cross-platform anymore. It relies unequivocally
    on Android-specific Java features.
  prefs: []
  type: TYPE_NORMAL
- en: Now we can use Java classes seamlessly in our Python code.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Keep in mind that the documentation for these classes is intended for use with
    Java, not Python. You can look it up on Google's official Android developers portal
    at [http://developer.android.com/reference/packages.html](http://developer.android.com/reference/packages.html)—translating
    code samples from Java to Python may appear intimidating at first, but in reality,
    it is dead simple (if a bit wordy).
  prefs: []
  type: TYPE_NORMAL
- en: Looking up the storage path
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s illustrate the practical cross-language API use with a simple example.
    In Java, we would do something like this in order to find out where an SD card
    is mounted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'When translated to Python, this code reads:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This is the exact same thing as shown in the previous code, only written in
    Python instead of Java.
  prefs: []
  type: TYPE_NORMAL
- en: 'While we''re at it, let''s also log this value, so that we can see in the Kivy
    log which exact path the `getAbsolutePath` method returned to our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'On my testing device, this produces the following line in the Kivy log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Reading logs from the device
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you're running a Kivy application from the terminal during development,
    logs appear immediately in the same terminal window. This very useful feature
    is also available, albeit less accessible, when your app runs inside Kivy Launcher.
  prefs: []
  type: TYPE_NORMAL
- en: To read Kivy logs, navigate to the folder where your app lives on the device
    (for example, `/Kivy/Recorder` on the SD card). Inside this folder, Kivy Launcher
    creates another directory named `.kivy`, with the default configuration and miscellaneous
    service information inside. Every time the application is started, a log file
    is created under `.kivy/logs`.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, if you have the Android SDK installed, you can enable USB debugging
    on your device and then use the `adb logcat` command to see all the Android logs,
    including Kivy logs, in one place. This produces much more information about the
    internal processes happening inside the device, such as various hardware activating
    and deactivating, application windows changing their state, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Logs can be of tremendous value when debugging strange program behavior or when
    an app just refuses to start. Kivy also prints all sorts of warnings about the
    runtime environment there, such as libraries or features missing, Python modules
    failing to load, and other potential problems.
  prefs: []
  type: TYPE_NORMAL
- en: Recording sound
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, let's dive deeper into the rabbit hole of the Android API and actually
    record a sound from the mic. The following code is again basically a translation
    of Android API documentation into Python. If you're interested in the original
    Java version of this code, you may find it at [http://developer.android.com/guide/topics/media/audio-capture.html](http://developer.android.com/guide/topics/media/audio-capture.html)—it's
    way too lengthy to include here.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the preparation code that initializes a `MediaRecorder` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This is the typical, straightforward, verbose Java way of initializing things,
    rewritten in Python word for word.
  prefs: []
  type: TYPE_NORMAL
- en: You can tweak the output file format and codec here, for example, change `AMR_NB`
    (**Adaptive Multi-Rate** codec, which is optimized for speech and hence widely
    used in GSM and other mobile phone networks) to `AudioEncoder.AAC` (**Advanced
    Audio Coding** standard, a more general-purpose codec similar to MP3). There is
    probably no good reason for this since the dynamic range of the built-in microphone
    is unlikely to be suitable for recording music anyway, but the choice is yours.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now for the fun part, the "Begin/End recording" button. The following code
    snippet uses the same logic as already seen in [Chapter 1](ch01.html "Chapter 1. Building
    a Clock App"), *Building a Clock App*, when implementing the Start/Stop button
    for the stopwatch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, no rocket science was applied here either: we just stored the
    current state, `is_recording`, and then took the action depending on it, namely:'
  prefs: []
  type: TYPE_NORMAL
- en: Start or stop the `MediaRecorder` object (the highlighted part).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Flip the `is_recording` flag.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update the button text so that it reflects the current state (see the following
    screenshot).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The last part of the application that needs updating is the `recorder.kv` file.
    We need to tweak the "Begin/End recording" button so that it calls our `begin_end_recording()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s it! If you run the application now, chances are that you''ll be able
    to actually record a sound file that is going to be stored on the SD card. However,
    please see the next section before you do this. The button that you created will
    look something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Recording sound](img/B01620_03_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Begin recording and End recording – this one button summarizes our app's functionality
    so far
  prefs: []
  type: TYPE_NORMAL
- en: Major caveat – permissions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The default Kivy Launcher app at the time of writing this doesn't have the necessary
    permission to record sound, `android.permission.RECORD_AUDIO`. This results in
    a crash as soon as the `MediaRecorder` instance is initialized.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many ways to mitigate this problem. First, the easiest one: for the
    sake of this tutorial, we already provide a modified Kivy Launcher that has the
    necessary permission enabled. You can find `KivyLauncherMod.apk` bundled with
    the book''s source code archive. The latest version of the package is also available
    for download at [https://github.com/mvasilkov/kivy_launcher_hack](https://github.com/mvasilkov/kivy_launcher_hack).'
  prefs: []
  type: TYPE_NORMAL
- en: Before you install the provided `.apk` file, please delete the existing version
    of the app, if any, from your device.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, if you're willing to fiddle with the gory details of bundling
    Kivy apps for Google Play, you can build Kivy Launcher yourself from the source
    code. Everything you need to do this can be found in the official Kivy GitHub
    account, [https://github.com/kivy](https://github.com/kivy).
  prefs: []
  type: TYPE_NORMAL
- en: 'The third viable option (also probably easier than the previous one) is to
    tweak the already existing Kivy Launcher app. To do so, you can use the **apktool**
    ([https://code.google.com/p/android-apktool/](https://code.google.com/p/android-apktool/)).
    The exact steps you need to take are outlined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Download the official `KivyLauncher.apk` file and extract it from the command
    line, assuming that the apktool is in your path:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the necessary permission statement to the `AndroidManifest.xml` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Repackage `.apk` like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Sign the resulting `.apk` file using the `jarsigner` utility. Have a look at
    the official documentation on signing Android packages, available at [http://developer.android.com/tools/publishing/app-signing.html#signing-manually](http://developer.android.com/tools/publishing/app-signing.html#signing-manually).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As a result of this procedure, the modified Kivy Launcher package will be able
    to record sound.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can add various other permissions in the same way to be able to exploit
    them in your Python code using Pyjnius. For example, in order to access the GPS
    API, your app needs the `android.permission.ACCESS_FINE_LOCATION` permission.
  prefs: []
  type: TYPE_NORMAL
- en: All available permissions are listed in the Android documentation at [http://developer.android.com/reference/android/Manifest.permission.html](http://developer.android.com/reference/android/Manifest.permission.html).
  prefs: []
  type: TYPE_NORMAL
- en: Playing sound
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Getting sound playback to work is easier; there is no permission for this,
    and the API is somewhat more concise too. We need to load just one more class,
    `MediaPlayer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the code that will run when the user presses the Play button.
    We''ll also use the `reset_player()` function in the *Deleting files* section;
    otherwise, there could have been one slightly longer function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The intricate details of each API call can be found in the official documentation,
    but overall, this listing is pretty self-evident: reset the player to its initial
    state, load the sound file, and push play. The file format is determined automatically,
    making our task at hand a wee bit easier.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In practice, such code should always be wrapped in a `try ... catch` block.
    There are just too many things that can go wrong: the file may go missing or created
    in a wrong format, the SD card may become unplugged or otherwise unreadable, and
    other equally terrible things that will surely crash your program if given a chance.
    A good rule of thumb when doing IO is *better safe than sorry*.'
  prefs: []
  type: TYPE_NORMAL
- en: Deleting files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This last feature will use the `java.io.File` class, which is not strictly
    related to Android. One great thing about the official Android documentation is
    that it contains reference to these core Java classes too, despite the fact they
    predate the Android operating system by more than a decade. The actual code needed
    to implement file removal is exactly one line; it''s highlighted in the following
    listing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: First, we stop the playback (if any) by calling the `reset_player()` function,
    and then remove the file—short and sweet.
  prefs: []
  type: TYPE_NORMAL
- en: Interestingly, the `File.delete()` method in Java won't throw an exception in
    the event of a catastrophic failure, so there is no need to perform `try ... catch`
    in this case. Consistency, consistency everywhere.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An attentive reader will notice that we could also delete the file using Python's
    own `os.remove()` function. Doing this using Java achieves nothing special compared
    to a pure Python implementation; it's also slower. On the other hand, as a demonstration
    of Pyjnius, `java.io.File` works as good as any other Java class.
  prefs: []
  type: TYPE_NORMAL
- en: Also note that this function will run perfectly fine in a desktop OS as well
    because it's not Android-specific; you only need Java and Pyjnius installed in
    order for this to work.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, with the UI and all three major functions done, our application
    is complete for the purposes of this tutorial.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Writing non-portable code has its strengths and weaknesses, just like any other
    global architectural decision. This particular choice, however, is especially
    hard because the switch to native API typically happens early in the project and
    may be completely impractical to undo at a later stage.
  prefs: []
  type: TYPE_NORMAL
- en: 'The major advantage of the approach was discussed at the beginning of this
    chapter: with platform-specific code, you can do virtually anything that your
    platform is capable of. There are no artificial limits; your Python code has unrestricted
    access to the same underlying API as the native code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'On the downside, depending on a single platform is risky for a number of reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: The market of Android alone is provably smaller than that of Android plus iOS
    (this holds true for about every combination of operating systems).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Porting the program over to a new system becomes harder with every platform-specific
    feature you use.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the project runs on just one platform, exactly one political decision may
    be sufficient to kill it. The chances of getting banned by Google is higher than
    that of getting the boot from both App Store and Google Play simultaneously. (Again,
    this holds true for practically every set of application marketplaces.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that you're well aware of the options, it's up to you to make an educated
    choice regarding every app you develop.
  prefs: []
  type: TYPE_NORMAL
- en: '**A few words on the UI**'
  prefs: []
  type: TYPE_NORMAL
- en: 'By all means, you should not hesitate to borrow and re-implement ideas (and
    layouts, fonts, colors, and so on) seen elsewhere. The phrase attributed to Pablo
    Picasso, "Good artists borrow; great artists steal," summarizes today''s web and
    application development neatly. (The "steal" part is figurative: please don''t
    actually steal things.)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, let''s get this straight: the mere fact that Microsoft decided to use
    the "Modern UI" in a number of latest products, both mobile and desktop, doesn''t
    mean that the design itself is any good. What we know for sure is that this user
    interface paradigm will be immediately recognizable by users due to popularity,
    fortunate or otherwise, of Microsoft operating systems.'
  prefs: []
  type: TYPE_NORMAL
- en: Putting Java to rest, in the next chapter we will build a simple chat with client–server
    architecture on top of the popular Python web framework, **Twisted**.
  prefs: []
  type: TYPE_NORMAL
