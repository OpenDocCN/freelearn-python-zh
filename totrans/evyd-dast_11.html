<html><head></head><body>
<div class="book" title="Chapter&#xA0;11.&#xA0;Graphs: Values with Relationships" id="1T1401-77f2b5b248f04368a6f723b0e9357ef3"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch11" class="calibre1"/>Chapter 11. Graphs: Values with Relationships</h1></div></div></div><p class="calibre7">The final data structure that we will examine is the <span class="strong"><strong class="calibre16">Graph</strong></span>. Graphs are sets of objects with no specifically structured relationship, where each object can have links to one or many other objects in the collection. Objects in graphs are typically referred to as nodes, vertices, or points. Links, or the relationships between the objects, are referred to as edges, lines, or arcs. These links can be simple references or they can be objects with values of their own. More formally stated, graphs are a pair of sets <span class="strong"><em class="calibre20">(N, E)</em></span>, where <span class="strong"><em class="calibre20">N</em></span> is the set of nodes and <span class="strong"><em class="calibre20">E</em></span> is the set of edges in the collection.</p><p class="calibre7">One excellent example of graph applications would be visualizing the relationships between individuals in a social media database. In such a database, each person in the database represents one node, and each of their links to other people in their circle of acquaintances represents an edge. In such a circle of acquaintances, it would be perfectly reasonable to see circular or even intertwined relationships between nodes as one person can share many of the same friends or coworkers as another person. Tree and heap structures would very rapidly break down when attempting to rationalize these sets, while the graph data structure was practically designed with such scenarios in mind.</p><p class="calibre7">In this chapter, we will cover the following topics:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Definition of the graph data structure</li><li class="listitem">Visual conception of the graph structure</li><li class="listitem">Common operations</li><li class="listitem">Graph implementations</li></ul></div></div>

<div class="book" title="Chapter&#xA0;11.&#xA0;Graphs: Values with Relationships" id="1T1401-77f2b5b248f04368a6f723b0e9357ef3">
<div class="book" title="Visual graph concepts"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch11lvl1sec56" class="calibre1"/>Visual graph concepts</h1></div></div></div><p class="calibre7">It is sometimes easier to grasp the concept of graph data structures using visual representations of some collections. Consider the following diagram:</p><p class="calibre7">
</p><div class="mediaobject"><img src="../images/00016.jpeg" alt="Visual graph concepts" class="calibre17"/></div><p class="calibre18"> </p><p class="calibre7">
</p><p class="calibre7">This is a basic graph consisting of eleven nodes and twelve edges. Sets <span class="strong"><em class="calibre20">N</em></span> and <span class="strong"><em class="calibre20">E</em></span> can be described as follows:</p><p class="calibre7"><span class="strong"><em class="calibre20">N = {2, 3, 4, 5, 9, 11, 19, 38, 52, 77, 97}</em></span></p><p class="calibre7"><span class="strong"><em class="calibre20">E = {2:38, 2:77, 2:97, 3:19, 4:77, 5:2, 5:19, 11:2, 11:4, 11:5, 11:52, 77:9}</em></span></p><p class="calibre7">Note that, in this example, there are only unidirectional edges between nodes. This is perfectly acceptable, but graphs are much more powerful when bidirectional nodes are permitted. Consider the following example:</p><p class="calibre7">
</p><div class="mediaobject"><img src="../images/00017.jpeg" alt="Visual graph concepts" class="calibre17"/></div><p class="calibre18"> </p><p class="calibre7">
</p><p class="calibre7">This is the same graph we saw earlier, but set <span class="strong"><em class="calibre20">E</em></span> now contains several new reciprocal edges between existing nodes. Sets <span class="strong"><em class="calibre20">N</em></span> and <span class="strong"><em class="calibre20">E</em></span> can now be described as follows:</p><p class="calibre7"><span class="strong"><em class="calibre20">N = {2, 3, 4, 5, 9, 11, 19, 38, 52, 77, 97}</em></span></p><p class="calibre7"><span class="strong"><em class="calibre20">E = {2:5, 2:38, 2:77, 2:97, 3:19, 4:11, 4:77, 5:2, 5:19, 11:2, 11:4, 11:5, 11:52, 77:9, 97:2}</em></span></p><p class="calibre7">Finally, edges between nodes can also be defined with a particular value. Consider the following example:</p><p class="calibre7">
</p><div class="mediaobject"><img src="../images/00018.jpeg" alt="Visual graph concepts" class="calibre17"/></div><p class="calibre18"> </p><p class="calibre7">
</p><p class="calibre7">In this figure, we see a graph with a set of six nodes and seven edges. In this case, however, the edges are further defined by a specific value. This value is not limited to integers, but it can be represented by any type or custom object you need. Sets <span class="strong"><em class="calibre20">N</em></span> and <span class="strong"><em class="calibre20">E</em></span> for this graph can be described as follows:</p><p class="calibre7"><span class="strong"><em class="calibre20">N = {2, 4, 5, 52, 97}</em></span></p><p class="calibre7"><span class="strong"><em class="calibre20">E = {2:5(84), 4:11(97), 11:2(70), 11:4(97), 11:5(16), 11:52(102), 97:2(14)}</em></span></p></div></div>
<div class="book" title="Graph operations"><div class="book" id="1TVKI2-77f2b5b248f04368a6f723b0e9357ef3"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch11lvl1sec57" class="calibre1"/>Graph operations</h1></div></div></div><p class="calibre7">Since graphs support bidirectional references between nodes and nodes can virtually have unlimited neighbors, it is necessary to define two basic objects in order to implement the collection. These include the nodes that make up the graph as well as the graph collection itself. Optionally, an edge object may be required if the implementation supports edges that contain a value. Therefore, note that some of these common graph operations will have components in more than one class:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong class="calibre16">AddNode</strong></span>: This operation is sometimes called the <span class="strong"><strong class="calibre16">AddVertex</strong></span> or <span class="strong"><strong class="calibre16">AddPoint</strong></span> operation, and is dependent on the language used to define the graph. The AddNode operation simply inserts new nodes into the graph without defining any edges or references to neighboring nodes. Since a node does not necessarily need to have neighbors to exist in the graph, the AddNode operation represents an <span class="strong"><strong class="calibre16">O</strong></span>(1) operation. Also note that the AddNode operation is exclusively implemented in the graph collection object.</li><li class="listitem"><span class="strong"><strong class="calibre16">RemoveNode</strong></span>: This operation is sometimes called the <span class="strong"><strong class="calibre16">RemoveVertex</strong></span> or RemovePoint operation, and it is dependent on the language used to define the graph. The RemoveNode operation deletes the node from the graph and removes any edges or references to and from neighboring nodes. This operation has an <span class="strong"><strong class="calibre16">O</strong></span>(<span class="strong"><em class="calibre20">n</em></span> + <span class="strong"><em class="calibre20">k</em></span>) operational cost, where <span class="strong"><em class="calibre20">n</em></span> is the number of nodes in our graph and <span class="strong"><em class="calibre20">k</em></span> is the number of edges. The RemoveNode operation is exclusively implemented in the graph collection object.<div class="note" title="Note"><h3 class="title1"><a id="note41" class="calibre1"/>Note</h3><p class="calibre7">This may seem expensive for a simple remove operation, but keep in mind that references in a graph can be bidirectional, meaning that our node could potentially have edges to every other node in the graph while every other node in the graph could simultaneously have edges pointing back to our node.</p><p class="calibre7">This is primarily a concern with graphs designed to support edges that contain a value. In that case, each edge must be individually examined to determine if it points to the node being removed, and it must be handled accordingly if that is the case. In graphs where edges are merely pointers between objects, setting an object to <code class="literal">null</code> or <code class="literal">nil</code> will effectively eliminate any edges that point to it, potentially reducing this operation's cost to <span class="strong"><strong class="calibre16">O</strong></span>(1).</p></div></li><li class="listitem"><span class="strong"><strong class="calibre16">AddEdge</strong></span>: This operation is sometimes called the <span class="strong"><strong class="calibre16">AddArc</strong></span> or <span class="strong"><strong class="calibre16">AddLine</strong></span> operation, and it is dependent on the language used to define the node. The AddEdge operation simply adds a new edge from node <code class="literal">x</code> to node <code class="literal">y</code>. The AddEdge operation is implemented in both the collection object and the node object. At the node level, only the target node <code class="literal">y</code> must be passed as a parameter; while at the graph level, both <code class="literal">x</code> and <code class="literal">y</code> must be provided. If the graph supports edges with values, the new value must also be passed as a parameter, to the graph operation. Since graphs support bidirectional relationships between nodes, there is no need to first confirm that an edge already exists from node <code class="literal">y</code> to node <code class="literal">x</code>. This means adding a new edge between nodes is a simple process with an <span class="strong"><strong class="calibre16">O</strong></span>(1) operational cost.</li><li class="listitem"><span class="strong"><strong class="calibre16">RemoveEdge</strong></span>: This operation is sometimes called the <span class="strong"><strong class="calibre16">RemoveArc</strong></span> or <span class="strong"><strong class="calibre16">RemoveLine</strong></span> operation, and it is dependent on the language used to define the node. The RemoveEdge operation simply removes an existing edge from node <code class="literal">x</code> to node <code class="literal">y</code> if it exists. At the node level, only the target node <code class="literal">y</code> must be passed as a parameter, while at the graph level, both <code class="literal">x</code> and <code class="literal">y</code> must be provided. If the graph supports edges with values, the new value must also be passed as a parameter to the graph operation. Since graphs support bidirectional relationships between nodes, removing an edge from node <code class="literal">x</code> to node <code class="literal">y</code> as an operation is completely independent of existing edges from node <code class="literal">y</code> to node <code class="literal">x</code>; and this process, therefore, has an <span class="strong"><strong class="calibre16">O</strong></span>(1) operational cost.</li><li class="listitem"><span class="strong"><strong class="calibre16">GetNodeValue</strong></span>: The GetNodeValue operation is sometimes called the <span class="strong"><strong class="calibre16">GetVertexValue</strong></span> or <span class="strong"><strong class="calibre16">GetPointValue</strong></span> operation, and this is dependent on the language used to define the node. This operation returns the value associated with the node, whether it is a primitive or some custom object type, and the operation has an <span class="strong"><strong class="calibre16">O</strong></span>(1) operational cost. This operation can be defined at either the graph or node level, but if it is defined as a part of the graph object, the node to be interrogated must be passed into the operation as a parameter.</li><li class="listitem"><span class="strong"><strong class="calibre16">SetNodeValue</strong></span>: The SetNodeValue operation is sometimes called the <span class="strong"><strong class="calibre16">SetVertexValue</strong></span> or <span class="strong"><strong class="calibre16">SetPointValue</strong></span> operation, and it is dependent on the language used to define the node. This operation sets the value of the node and has an <span class="strong"><strong class="calibre16">O</strong></span>(1) operational cost. Again, this operation can be defined at either the graph or node level but, if it is defined as a part of the graph object, the node to be set must be passed into the operation as a parameter.</li><li class="listitem"><span class="strong"><strong class="calibre16">Adjacent</strong></span>: The Adjacent operation checks whether an edge exists from node <code class="literal">x</code> to node <code class="literal">y</code>, and typically returns a Boolean value representing the result. This operation is typically defined at the graph level and requires both node <code class="literal">x</code> and node <code class="literal">y</code> to be provided. This simple operation has an <span class="strong"><strong class="calibre16">O</strong></span>(1) operational cost.</li><li class="listitem"><span class="strong"><strong class="calibre16">Neighbors</strong></span>: This operation functions similarly to the children operation in a tree data structure. The Neighbors operation returns a list containing all of the nodes <code class="literal">y </code>where there is an edge from node <code class="literal">x</code> to node <code class="literal">y</code>. This operation is typically defined at the graph level and requires node <code class="literal">x</code> be provided. This operation has an <span class="strong"><strong class="calibre16">O</strong></span>(1) operational cost.</li><li class="listitem"><span class="strong"><strong class="calibre16">Count</strong></span>: As with many other collections, graphs typically expose a count operation that returns the number of nodes contained in the collection. Although dependent on the implementation, this operation typically has an <span class="strong"><strong class="calibre16">O</strong></span>(1) operational cost.</li><li class="listitem"><span class="strong"><strong class="calibre16">GetEdgeValue</strong></span>: This operation is sometimes called the GetArcValue or GetLineValue operation, and it is dependent on the language used to define the node. In graphs that support edges with values, this operation returns the value associated with the edge, whether it is a primitive or some custom object type, and the operation has an <span class="strong"><strong class="calibre16">O</strong></span>(1) operational cost. This operation can also be defined as a part of the node object, in which case the edge to be interrogated must be passed into the operation as a parameter.</li><li class="listitem"><span class="strong"><strong class="calibre16">SetEdgeValue</strong></span>: This operation is sometimes called the <span class="strong"><strong class="calibre16">SetArcValue</strong></span> or <span class="strong"><strong class="calibre16">SetLineValue</strong></span> operation, and this is dependent on the language used to define the edge. This operation sets the value of the edge and has an <span class="strong"><strong class="calibre16">O</strong></span>(1) operational cost. Again, this operation can be defined as a part of the node object, in which case the edge to be set must be passed into the operation as a parameter.</li></ul></div></div>
<div class="book" title="Graph implementations" id="1UU541-77f2b5b248f04368a6f723b0e9357ef3"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch11lvl1sec58" class="calibre1"/>Graph implementations</h1></div></div></div><p class="calibre7">As with heaps, graphs are a form of tree data structure and, therefore, we will not find a native concrete implementation in the languages we are discussing. However, the graph data structure is surprisingly easy to implement, so we will build our own <code class="literal">Graph</code> class from scratch.</p></div>
<div class="book" title="The graph data structure"><div class="book" id="1VSLM2-77f2b5b248f04368a6f723b0e9357ef3"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch11lvl1sec59" class="calibre1"/>The graph data structure</h1></div></div></div><p class="calibre7">Before we begin, we need to detail a few characteristics that our graph structure will possess. Our graph will support nodes that have no edges to or from other nodes. Our graph will also support exclusive and bidirectional edges. For the sake of brevity, the edges in our graph collection will not support edge values, but adding values to edges is a simple matter if you decide to use them in your custom implementations.</p><p class="calibre7">Our graph will be made up of two classes. The first is the <code class="literal">Graph</code> class itself, which in our implementation will contain most of the standard graph operations. The next is a <code class="literal">GraphNode</code> class, which will represent the nodes of our collection. Note that this class could also be named <code class="literal">GraphVertex</code> or <code class="literal">GraphPoint</code>, but in keeping with our tree <code class="literal">Node</code> class example from <a class="calibre1" title="Chapter 9. Trees: Non-Linear Structures" href="part0050_split_000.html#1FLS41-77f2b5b248f04368a6f723b0e9357ef3">Chapter 9</a>, <span class="strong"><em class="calibre20">Trees: Non-linear Structures</em></span>, we will stick with nodes.</p><p class="calibre7">The <code class="literal">Graph</code> class will be based on an array or list that contains the root references to the nodes. Each <code class="literal">GraphNode</code> object will also contain an array or list that holds the references to other nodes. In this implementation, these references represent the edges in our data structure. This class will support instantiation from scratch or by passing in an existing list of <code class="literal">GraphNode</code> objects. Operations for adding and removing both nodes and edges will be implemented in the <code class="literal">Graph</code> class. The <code class="literal">Graph</code> class will also contain operations for checking node adjacency, node neighbors, and the total count of nodes in the collection.</p><p class="calibre7"><span class="strong"><strong class="calibre16">C#</strong></span></p><p class="calibre7">C# does not provide a concrete <code class="literal">Graph</code> or <code class="literal">GraphNode</code> class out of the box, so we will need to create our own. We will start with the <code class="literal">GraphNode</code> class. Here is what a basic implementation of a <code class="literal">GraphNode</code> class might look like in C#:</p><pre class="programlisting">    public class GraphNode 
    { 
        public Int16 Value; 
 
        private List&lt;GraphNode&gt; _neighbors; 
        public List&lt;GraphNode&gt; Neighbors 
        { 
            get 
            { 
                return _neighbors; 
            } 
        } 
 
        public GraphNode() 
        { 
            _neighbors = new List&lt;GraphNode&gt;(); 
        } 
 
        public GraphNode(Int16 value) 
        { 
            _neighbors = new List&lt;GraphNode&gt;(); 
            Value = value; 
        } 
    }   
</pre><p class="calibre7">This class is very simple, containing a public field named <code class="literal">Value</code> to store our integer data and a <code class="literal">List&lt;GraphNode&gt;</code> object named <code class="literal">neighbors</code> that represents the edges between this node and its neighbors. The class also has two constructors both of which instantiate the <code class="literal">_neighbors</code> list. The overloaded <code class="literal">GraphNode(Int16 value)</code> constructor also allows a value to be defined at instantiation.</p><p class="calibre7">Next, we can implement our graph functions. Here's what a concrete implementation of a <code class="literal">Graph</code> class might look like in C#:</p><pre class="programlisting">    private List&lt;GraphNode&gt; _nodes; 
    public List&lt;GraphNode&gt; Nodes 
    { 
        get 
        { 
            return _nodes; 
        } 
    } 
 
    public Graph(List&lt;GraphNode&gt; nodes) 
    { 
        if (nodes == null) 
        { 
            _nodes = new List&lt;GraphNode&gt;(); 
        } 
        else 
        { 
            _nodes = nodes; 
        } 
    } 
</pre><p class="calibre7">Our <code class="literal">Graph</code> class includes one public field, a <code class="literal">List&lt;GraphNode&gt;</code> collection named <code class="literal">Nodes</code> that exposes read-only access to the private <code class="literal">List&lt;GraphNode&gt; _nodes</code> field. This field maintains the list of edges to neighboring nodes. Finally, our constructor accepts one parameter of the type <code class="literal">List&lt;Graphnode&gt;</code> and sets <code class="literal">_nodes</code> to this value if it is not null; otherwise, it initializes the <code class="literal">_nodes</code> collection:</p><pre class="programlisting">    public void AddNode(GraphNode node) 
    { 
        _nodes.Add(node); 
    } 
 
    public void AddNodeForValue(Int16 value) 
    { 
        _nodes.Add(new GraphNode(value)); 
    } 
</pre><p class="calibre7">The first two public methods in <code class="literal">Graph</code> are <code class="literal">AddNode(GraphNode node)</code> and <code class="literal">AddNodeForValue(Int16 value)</code>, which add two versions of the AddNode functionality to our class. The first adds a pre-existing node to the <code class="literal">_nodes</code> collection, while the second instantiates a new node using <code class="literal">value</code>, then adds that node to the <code class="literal">_nodes</code> collection. Both of these methods add nodes without defining any edges and, therefore, these operations have an <span class="strong"><strong class="calibre16">O</strong></span>(1) cost:</p><pre class="programlisting">    public bool RemoveNode(Int16 value) 
    { 
        GraphNode nodeToRemove = _nodes.Find(n =&gt; n.Value == value); 
        if (nodeToRemove == null) 
        { 
            return false; 
        } 
        _nodes.Remove(nodeToRemove); 
 
        foreach (GraphNode node in _nodes) 
        { 
            int index = node.Neighbors.IndexOf(nodeToRemove); 
            if (index != -1) 
            { 
                node.Neighbors.RemoveAt(index); 
            } 
        } 
        return true; 
    } 
</pre><p class="calibre7">The <code class="literal">RemoveNode(Int16 value)</code> method provides the RemoveNode functionality to our class. This method accepts one parameter of type <code class="literal">Int16</code> and named <code class="literal">value</code>, representing the node that the caller is asking to remove. The method begins by using a <span class="strong"><strong class="calibre16">LINQ</strong></span> statement to examine each of the nodes in the collection, searching for a match to <code class="literal">value</code>. If no match is found, the method returns <code class="literal">false</code>. Otherwise, the matching node is removed from the <code class="literal">_nodes</code> collection and the method execution continues.</p><p class="calibre7">The second half of this method loops through each of the nodes in the collection, examining each node's neighbors to find a match for <code class="literal">nodeToRemove</code>. A match found means an edge exists from the <code class="literal">node</code> object to the <code class="literal">nodeToRemove</code> object and returns an index value for that match. By removing the <code class="literal">nodeToRemove</code> object from the <code class="literal">node.Neighbors</code> collection using <code class="literal">index</code>, we eliminate the reference and delete the edge.</p><p class="calibre7">As we examined in the discussion on graph operations, the <code class="literal">RemoveNode</code> operation has an operational cost of <span class="strong"><strong class="calibre16">O</strong></span>(<span class="strong"><em class="calibre20">n</em></span> + <span class="strong"><em class="calibre20">k</em></span>), where <span class="strong"><em class="calibre20">n</em></span> is the number of nodes in the collection and <span class="strong"><em class="calibre20">k</em></span> is the number of edges. In the <code class="literal">RemoveNode(Int16 value)</code> method, the first half represents <span class="strong"><em class="calibre20">n</em></span> and the second half represents <span class="strong"><em class="calibre20">k</em></span> in that equation:</p><pre class="programlisting">    public void AddEdge(GraphNode from, GraphNode to) 
    { 
        from.Neighbors.Add(to); 
    } 
 
    public void AddBidirectedEdge(GraphNode from, GraphNode to) 
    { 
        from.Neighbors.Add(to); 
        to.Neighbors.Add(from); 
    } 
</pre><p class="calibre7">The <code class="literal">AddEdge(GraphNode from, GraphNode to)</code> and <code class="literal">AddBidirectedEdge(GraphNode from, GraphNode to)</code> methods provide the AddEdge functionality to the <code class="literal">Graph</code> class. The first method is the standard AddEdge operation, while the second method exists more as a convenience in case the caller wants to immediately add bidirectional references. The first method has an <span class="strong"><strong class="calibre16">O</strong></span>(1) operational cost, while the second technically has a more unusual <span class="strong"><strong class="calibre16">O</strong></span>(2) operational cost:</p><pre class="programlisting">    public bool Adjacent(GraphNode from, GraphNode to) 
    { 
        return from.Neighbors.Contains(to); 
    } 
</pre><p class="calibre7">The <code class="literal">Adjacent(GraphNode from, GraphNode to)</code> method returns a Boolean value denoting whether an edge exists between two nodes, <code class="literal">from</code> and <code class="literal">to</code>. Hopefully the signature makes the direction of this edge clear but, for clarity, this method only confirms that an edge exists from the <code class="literal">from</code> node and to the <code class="literal">to</code> node, but not the reciprocal. Since this method is based on the <code class="literal">contains</code> function, it has an <span class="strong"><strong class="calibre16">O</strong></span>(<span class="strong"><em class="calibre20">n</em></span>) operational cost where <span class="strong"><em class="calibre20">n</em></span> is the number of edges contained in <code class="literal">from.Neighbors</code>:</p><pre class="programlisting">    public List&lt;GraphNode&gt; Neighbors(Int16 value) 
    { 
        GraphNode node = _nodes.Find(n =&gt; n.Value == value); 
        if (node == null) 
        { 
            return null; 
        } 
        else 
        { 
            return node.Neighbors; 
        } 
    } 
</pre><p class="calibre7">The <code class="literal">Neighbors(Int16 value)</code> method provides the Neighbors functionality to our class. This method accepts one parameter of type <code class="literal">Int16</code> and named <code class="literal">value</code>, representing the node the caller is asking to examine. The method begins by using a LINQ statement to examine each of the nodes in the collection searching for a match to <code class="literal">value</code>. If no match is found, the method returns <code class="literal">null</code>. Otherwise, the method returns the matching node's <code class="literal">Neighbors</code> collection. If the <code class="literal">GraphNode</code> object was known in advance, this operation would have an <span class="strong"><strong class="calibre16">O</strong></span>(1) operational cost. However, since we are examining the entire collection of <code class="literal">_nodes</code> at the <code class="literal">Graph</code> level based on the value of a specific node, this implementation has an <span class="strong"><strong class="calibre16">O</strong></span>(<span class="strong"><em class="calibre20">n</em></span>) operational cost:</p><pre class="programlisting">    public int Count 
    { 
        get  
        {  
            return _nodes.Count;  
        } 
    } 
</pre><p class="calibre7">Finally, the <code class="literal">Count</code> field is a read-only value that returns the total number of nodes contained in the collection by returning <code class="literal">_nodes.Count</code>. This field provides the Count functionality to our <code class="literal">Graph</code> class and has an <span class="strong"><strong class="calibre16">O</strong></span>(1) operational cost.</p><p class="calibre7"><span class="strong"><strong class="calibre16">Java</strong></span></p><p class="calibre7">Like C#, Java does not provide a concrete <code class="literal">Graph</code> or <code class="literal">GraphNode</code> class out-of-the-box, so we will need to create our own. Again, we will start with the <code class="literal">GraphNode</code> class. Here is what a basic implementation of a <code class="literal">GraphNode</code> class will look like in Java:</p><pre class="programlisting">    public class GraphNode 
    { 
        public int Value; 
 
        private LinkedList&lt;GraphNode&gt; _neighbors; 
        public LinkedList&lt;GraphNode&gt; GetNeighbors() 
        { 
            return _neighbors; 
        } 
 
        public GraphNode() 
        { 
            _neighbors = new LinkedList&lt;GraphNode&gt;(); 
        } 
 
        public GraphNode(int value) 
        { 
            _neighbors = new LinkedList&lt;GraphNode&gt;(); 
            Value = value; 
        } 
    } 
</pre><p class="calibre7">This class is very simple, containing a public field named <code class="literal">Value</code> to store our integer data and a private <code class="literal">LinkedList&lt;GraphNode&gt;</code> object named <code class="literal">_neighbors</code> that represents the edges between this node and its neighbors. There is also a public method called <code class="literal">GetNeighbors()</code> that exposes the private <code class="literal">_neighbors</code> list. The class also has two constructors, both of which instantiate the <code class="literal">_neighbors</code> list. The overloaded <code class="literal">GraphNode(Int16 value)</code> constructor also allows a value to be defined at instantiation.</p><p class="calibre7">Next, we can implement our graph functions. Here's what a concrete implementation of a <code class="literal">Graph</code> class will look like in Java:</p><pre class="programlisting">    private LinkedList&lt;GraphNode&gt; _nodes; 
    public LinkedList&lt;GraphNode&gt; GetNodes() 
    { 
        return _nodes; 
    } 
 
    public Graph(){ 
       _nodes = new LinkedList&lt;GraphNode&gt;(); 
    } 
 
    public Graph(LinkedList&lt;GraphNode&gt; nodes) 
    { 
        _nodes = nodes; 
    } 
</pre><p class="calibre7">Our <code class="literal">Graph</code> class includes one private field, a <code class="literal">List&lt;GraphNode&gt;</code> collection named <code class="literal">_nodes</code> and a method named <code class="literal">GetNodes()</code>, which exposes read-only access to the private <code class="literal">List&lt;GraphNode&gt; _nodes</code> field. This field maintains a list of edges between the current node and its neighboring nodes. Finally, our constructor accepts one parameter of the type <code class="literal">List&lt;Graphnode&gt;</code>, and sets <code class="literal">_nodes </code>to this value if it is not <code class="literal">null</code>; otherwise, it initializes the <code class="literal">_nodes</code> collection:</p><pre class="programlisting">    public void AddNode(GraphNode node) 
    { 
        _nodes.add(node); 
    } 
 
    public void AddNodeForValue(int value) 
    { 
        _nodes.add(new GraphNode(value)); 
    } 
</pre><p class="calibre7">The first two public methods in <code class="literal">Graph</code> are <code class="literal">AddNode(GraphNode node)</code> and <code class="literal">AddNodeForValue(int value)</code>, which add two versions of the AddNode functionality to our class. The first adds a pre-existing node to the <code class="literal">_nodes</code> collection, while the second instantiates a new node using <code class="literal">value</code> and then adds that node to the <code class="literal">_nodes</code> collection. Both of these methods add nodes without defining any edges, and therefore these operations have an <span class="strong"><strong class="calibre16">O</strong></span>(1) cost:</p><pre class="programlisting">    public boolean RemoveNode(int value) 
    { 
        GraphNode nodeToRemove = null; 
        for (GraphNode node : _nodes) 
        { 
            if (node.Value == value) 
            { 
                nodeToRemove = node; 
                break; 
            } 
        } 
 
        if (nodeToRemove == null)  
        { 
            return false; 
        } 
 
        _nodes.remove(nodeToRemove); 
 
        for (GraphNode node : _nodes) 
        { 
            int index = node.GetNeighbors().indexOf(nodeToRemove); 
            if (index != -1) 
            { 
                node.GetNeighbors().remove(index); 
            } 
        } 
        return true; 
    } 
</pre><p class="calibre7">The <code class="literal">RemoveNode(int value)</code> method provides the <code class="literal">RemoveNode</code> functionality to our class. This method accepts one parameter of type <code class="literal">int</code> named <code class="literal">value</code>, representing the node the caller is asking to remove. The method begins by looping through each of the nodes, searching for a match for <code class="literal">value</code>. If no match is found, the method returns <code class="literal">false</code>. Otherwise, the matching node is removed from the <code class="literal">_nodes</code> collection using the <code class="literal">remove(E)</code> function and method execution continues.</p><p class="calibre7">The second half of this method loops through each of the nodes in the collection, examining each node's neighbors to find a match for <code class="literal">nodeToRemove</code>. A match found means an edge exists from <code class="literal">node</code> and <code class="literal">nodeToRemove</code> and returns an index value for that match. By removing <code class="literal">nodeToRemove</code> from that <code class="literal">node.Neighbors</code> using <code class="literal">index</code>, we eliminate the reference and delete the edge.</p><p class="calibre7">The operational cost in Java is the same as that in C#. The <code class="literal">RemoveNode</code> operation has a cost of <span class="strong"><strong class="calibre16">O</strong></span>(<span class="strong"><em class="calibre20">n</em></span> + <span class="strong"><em class="calibre20">k</em></span>), where <span class="strong"><em class="calibre20">n</em></span> is the number of nodes in the collection and <span class="strong"><em class="calibre20">k</em></span> is the number of edges. In the <code class="literal">RemoveNode(int value)</code> method, the first half represents <span class="strong"><em class="calibre20">n</em></span> and the second half represents <span class="strong"><em class="calibre20">k</em></span> in that equation:</p><pre class="programlisting">    public void AddEdge(GraphNode from, GraphNode to) 
    { 
        from.GetNeighbors().add(to); 
    } 
 
    public void AddBidirectedEdge(GraphNode from, GraphNode to) 
    { 
        from.GetNeighbors().add(to); 
        to.GetNeighbors().add(from); 
    } 
</pre><p class="calibre7">The <code class="literal">AddEdge(GraphNode from, GraphNode to)</code> and <code class="literal">AddBidirectedEdge(GraphNode from, GraphNode to)</code> methods provide the <code class="literal">AddEdge</code> functionality to the <code class="literal">Graph</code> class. The first method is the standard AddEdge operation, while the second is more of a convenience method in case the caller wants to immediately add bidirectional references. The first method has an <span class="strong"><strong class="calibre16">O</strong></span>(1) operational cost, while the second technically has a more unusual <span class="strong"><strong class="calibre16">O</strong></span>(2) operational cost:</p><pre class="programlisting">    public boolean Adjacent(GraphNode from, GraphNode to) 
    { 
        return from.GetNeighbors().contains(to); 
    } 
</pre><p class="calibre7">The <code class="literal">Adjacent(GraphNode from, GraphNode to)</code> method returns a Boolean value denoting whether an edge exists between two nodes, <code class="literal">from</code> and <code class="literal">to</code>. Hopefully, the signature makes the direction of this edge clear, but for clarity, this method only confirms that an edge exists from the <code class="literal">from</code> node and to the <code class="literal">to</code> node, but not the reciprocal. Since this method is based on the <code class="literal">contains</code> function, it has an <span class="strong"><strong class="calibre16">O</strong></span>(<span class="strong"><em class="calibre20">n</em></span>) operational cost, where <span class="strong"><em class="calibre20">n</em></span> is the number of edges contained in <code class="literal">from.Neighbors</code>:</p><pre class="programlisting">    public LinkedList&lt;GraphNode&gt; Neighbors(int value) 
    { 
        GraphNode node = null; 
        for (GraphNode n : _nodes) 
        { 
            if (n.Value == value) 
            { 
                return node.GetNeighbors(); 
            } 
        } 
 
        return null;    
    } 
</pre><p class="calibre7">The <code class="literal">Neighbors(int value)</code> method provides the Neighbors functionality to our class. This method accepts one parameter of type <code class="literal">int</code> and named <code class="literal">value</code>, representing the node the caller is asking to examine. The method begins by looping through the collection of nodes, searching for a match for <code class="literal">value</code>. If no match is found, the method returns <code class="literal">null</code>. Otherwise, the method returns the matching node's <code class="literal">Neighbors</code> collection using <code class="literal">GetNeighbors()</code>. If the <code class="literal">GraphNode</code> object was known in advance, this operation will have an <span class="strong"><strong class="calibre16">O</strong></span>(1) operational cost. However, since we are examining the entire collection of <code class="literal">_nodes</code> at the <code class="literal">Graph</code> level based on the value of a specific node, this implementation has an <span class="strong"><strong class="calibre16">O</strong></span>(<span class="strong"><em class="calibre20">n</em></span>) operational cost:</p><pre class="programlisting">    public int GetCount() 
    { 
        return _nodes.size(); 
    }  
</pre><p class="calibre7">Finally, the <code class="literal">GetCount()</code> method exposes read-only access to the total number of nodes contained in the collection by returning <code class="literal">_nodes.size()</code>. This field provides the Count functionality to our <code class="literal">Graph</code> class and has an <span class="strong"><strong class="calibre16">O</strong></span>(1) operational cost.</p><p class="calibre7"><span class="strong"><strong class="calibre16">Objective-C</strong></span></p><p class="calibre7">Objective-C does not provide a concrete <code class="literal">Graph</code> or <code class="literal">GraphNode</code> class, but it does provide the basic components necessary to build them. Here is what a basic implementation of a <code class="literal">EDSGraphNode</code> class will look like in Objective-C:</p><pre class="programlisting">    @interface EDSGraphNode() 
    { 
        NSInteger _value; 
        NSMutableArray *_neighbors; 
    } 
    -(instancetype)initGraphNode 
    { 
        if (self = [super init]) 
        { 
            _neighbors = [NSMutableArray array]; 
        } 
     
        return self; 
    } 
 
    -(instancetype)initGraphNodeWithValue:(NSInteger)value 
    { 
        if (self = [super init]) 
        { 
            _value = value; 
            _neighbors = [NSMutableArray array]; 
        } 
     
        return self; 
    } 
 
    -(NSMutableArray*)neighbors 
    { 
        return _neighbors; 
    } 
 
    -(NSInteger)value 
    { 
        return _value; 
    } 
</pre><p class="calibre7">This class contains two ivar properties named <code class="literal">_value</code> and <code class="literal">_neighbors</code>. The <code class="literal">_value</code> property is an <code class="literal">NSInteger</code> object and stores our integer data, while <code class="literal">_neighbors</code> is an <code class="literal">NSMutableArray</code> object that represents the edges between this node and its neighbors. The class has two initializers, both of which instantiate the <code class="literal">_neighbors</code> list. The <code class="literal">initGraphNode:</code> method simply instantiates the <code class="literal">_neighbors</code> array, while the <code class="literal">initGraphNodeWithValue:</code> also sets <code class="literal">_value</code> to the passed value property.</p><p class="calibre7">Next, we can implement our graph functions. Here's what a concrete implementation of a <code class="literal">EDSGraph</code> class will look like in Objective-C:</p><pre class="programlisting">    @interface EDSGraph() 
    { 
        NSMutableArray&lt;EDSGraphNode*&gt;* _nodes; 
    } 
 
    -(NSMutableArray&lt;EDSGraphNode*&gt;*)nodes 
    { 
        return _nodes; 
    } 
 
    -(instancetype)initGraphWithNodes:(NSMutableArray&lt;EDSGraphNode *&gt; *)nodes 
    { 
        if (self = [super init]) 
        { 
            if (nodes) 
            { 
                _nodes = nodes; 
            } 
            else 
            { 
                _nodes = [NSMutableArray array]; 
            } 
        } 
        return self; 
    } 
</pre><p class="calibre7">Our <code class="literal">EDSGraph</code> class includes one ivar property, an <code class="literal">NSMutableArray&lt;EDSGraphNode*&gt;*</code> named <code class="literal">_nodes</code> that maintains the list of edges to neighboring nodes. There is also a method named <code class="literal">nodes</code> that exposes read-only access to the private <code class="literal">_nodes</code> property. Finally, our initializer <code class="literal">initGraphWithNodes:(NSMutableArray&lt;EDSGraphNode *&gt; *)nodes</code> accepts one array of <code class="literal">EDSGraphnode</code> and sets <code class="literal">_nodes</code> to this value if it is not <code class="literal">nil</code>. Otherwise, the initializer method initializes the <code class="literal">_nodes</code> collection:</p><pre class="programlisting">    -(NSInteger)countOfNodes 
    { 
        return [_nodes count]; 
    } 
</pre><p class="calibre7">The <code class="literal">countOfNodes</code> method exposes read-only access to the total number of nodes contained in the collection by returning <code class="literal">[_nodes count]</code>. This method provides the Count functionality to our <code class="literal">EDSGraph</code> class and has an <span class="strong"><strong class="calibre16">O</strong></span>(1) operational cost:</p><pre class="programlisting">    -(void)addNode:(EDSGraphNode*)node 
    { 
        [_nodes addObject:node]; 
    } 
 
    -(void)addNodeForValue:(NSInteger)value 
    { 
        EDSGraphNode *node = [[EDSGraphNode alloc] initGraphNodeWithValue:value]; 
        [_nodes addObject:node]; 
    } 
</pre><p class="calibre7">The first two public methods in <code class="literal">EDSGraph</code> are <code class="literal">addNode:</code> and <code class="literal">addNodeForValue:</code> that add two versions of the <code class="literal">AddNode</code> functionality to our class. The first adds a pre-existing node to the <code class="literal">_nodes</code> collection, while the second instantiates a new node using <code class="literal">value</code> and then adds that node to the <code class="literal">_nodes</code> collection. Both of these methods add nodes without defining any edges, and therefore these operations have an <span class="strong"><strong class="calibre16">O</strong></span>(1) cost:</p><pre class="programlisting">    -(BOOL)removeNodeForValue:(NSInteger)value 
    { 
        EDSGraphNode *nodeToRemove; 
        for (EDSGraphNode *n in _nodes) 
        { 
            if (n.value == value) 
            { 
                nodeToRemove = n; 
                break; 
            } 
        } 
     
        if (!nodeToRemove) 
        { 
            return NO; 
        } 
     
        [_nodes removeObject:nodeToRemove]; 
     
        for (EDSGraphNode *n in _nodes) 
        { 
            long index = [n.neighbors indexOfObject:nodeToRemove]; 
            if (index != -1) 
            { 
                [n.neighbors removeObjectAtIndex:index]; 
            } 
        } 
        return YES;  
    } 
</pre><p class="calibre7">The <code class="literal">removeNodeForValue:</code> method provides the RemoveNode functionality to our class. This method accepts one parameter of type <code class="literal">NSInteger</code> and named <code class="literal">value</code>, representing the node the caller is asking to remove. The method begins by looping through the collection of nodes searching for a match for <code class="literal">value</code>. If no match is found, the method returns <code class="literal">NO</code>. Otherwise, the matching node is removed from the <code class="literal">_nodes</code> collection using <code class="literal">removeObject:</code> and the method execution continues.</p><p class="calibre7">The second half of this method loops through each of the nodes in the collection, examining each node's neighbors to find a match for <code class="literal">nodeToRemove</code>. A match found means an edge exists from <code class="literal">node</code> and <code class="literal">nodeToRemove</code> and returns an index value for that match. By removing <code class="literal">nodeToRemove</code> from that <code class="literal">node.Neighbors</code> using <code class="literal">index</code>, we eliminate the reference and delete the edge.</p><p class="calibre7">As we examined in the discussion on graph operations, the <code class="literal">RemoveNode</code> operation has an operational cost of <span class="strong"><strong class="calibre16">O</strong></span>(<span class="strong"><em class="calibre20">n</em></span> + <span class="strong"><em class="calibre20">k</em></span>), where <span class="strong"><em class="calibre20">n</em></span> is the number of nodes in the collection and <span class="strong"><em class="calibre20">k</em></span> is the number of edges. In the <code class="literal">removeNodeForValue:</code> method, the first half represents <span class="strong"><em class="calibre20">n</em></span> and the second half represents <span class="strong"><em class="calibre20">k</em></span> in that equation:</p><pre class="programlisting">    -(void)addEdgeFromNode:(EDSGraphNode*)from toNode:(EDSGraphNode*)to 
    { 
        [from.neighbors addObject:to]; 
    } 
 
    -(void)addBidirectionalEdgeFromNode:(EDSGraphNode*)from toNode:(EDSGraphNode*)to 
    { 
        [from.neighbors addObject:to]; 
        [to.neighbors addObject:from]; 
    } 
</pre><p class="calibre7">The <code class="literal">addEdgeFromNode:toNode:</code> and <code class="literal">addBidirectionalEdgeFromNode:toNode:</code> methods provide the AddEdge functionality to the <code class="literal">Graph</code> class. The first method is the standard AddEdge operation, while the second is more of a convenience method in case the caller wants to immediately add bidirectional references. The first method has an <span class="strong"><strong class="calibre16">O</strong></span>(1) operational cost, while the second has an <span class="strong"><strong class="calibre16">O</strong></span>(2) operational cost:</p><pre class="programlisting">    -(BOOL)adjacent:(EDSGraphNode*)from toNode:(EDSGraphNode*)to 
    { 
        return [from.neighbors containsObject:to]; 
    } 
</pre><p class="calibre7">The <code class="literal">adjacent:toNode:</code> method returns a <code class="literal">BOOL</code> value denoting whether an edge exists between two nodes, <code class="literal">from</code> and <code class="literal">to</code>. Hopefully, the signature makes the direction of this edge clear, but for clarity, this method only confirms that an edge exists from the <code class="literal">from</code> node and to the <code class="literal">to</code> node, but not the reciprocal. Since this method is based on the <code class="literal">containsObject:</code> function, it has an <span class="strong"><strong class="calibre16">O</strong></span>(<span class="strong"><em class="calibre20">n</em></span>) operational cost, where <span class="strong"><em class="calibre20">n</em></span> is the number of edges contained in <code class="literal">from.neighbors</code>:</p><pre class="programlisting">    -(NSMutableArray&lt;EDSGraphNode*&gt;*)neighborsOfValue:(NSInteger)value 
    { 
        for (EDSGraphNode *n in _nodes) 
        { 
            if (n.value == value) 
            { 
                return n.neighbors; 
            } 
        } 
     
        return nil; 
    } 
</pre><p class="calibre7">The <code class="literal">neighborsOfValue:</code> method provides the Neighbors functionality to our class. This method accepts one parameter of type <code class="literal">NSInteger</code> and named <code class="literal">value</code>, representing the node the caller is asking to examine. The method begins by looping through the collection of nodes searching for a match for <code class="literal">value</code>. If no match is found, the method returns <code class="literal">nil</code>. Otherwise, the method returns the matching node's <code class="literal">neighbors</code> collection. If the <code class="literal">EDSGraphNode</code> object was known in advance, this operation would have an <span class="strong"><strong class="calibre16">O</strong></span>(1) operational cost. However, since we are examining the entire collection of <code class="literal">_nodes</code> at the <code class="literal">EDSGraph</code> level based on the value of a specific node, this implementation has an <span class="strong"><strong class="calibre16">O</strong></span>(<span class="strong"><em class="calibre20">n</em></span>) operational cost.</p><p class="calibre7"><span class="strong"><strong class="calibre16">Swift</strong></span></p><p class="calibre7">Like its counterparts, Swift does not provide a concrete <code class="literal">Graph</code> or <code class="literal">GraphNode</code> class by default, so we will need to create our own. We will start with the <code class="literal">GraphNode</code> class. Here is what a basic implementation of a <code class="literal">GraphNode</code> class might look like in Swift:</p><pre class="programlisting">    public class GraphNode : Equatable 
    { 
        public var neighbors: Array = [GraphNode]() 
        public var value : Int 
     
        public init(val: Int) { 
            value = val 
        } 
    } 
 
    public func == (lhs: GraphNode, rhs: GraphNode) -&gt; Bool { 
        return (lhs.value == rhs.value) 
    } 
</pre><p class="calibre7">This class extends <code class="literal">Equatable</code>. This is necessary to support searching by value and by object. The class contains two public properties. The first is an array of <code class="literal">GraphNode</code> objects named <code class="literal">neighbors</code> that represents the edges between the node and its neighboring nodes. The second is an <code class="literal">Int</code> variable named <code class="literal">value</code>, and it is used to store our integer data for the object. The class has one custom constructor that accepts <code class="literal">Int</code> and assigns that value to the <code class="literal">value</code> variable. Finally, the class defines an overloaded comparison operator to support the <code class="literal">Equatable</code> functionality.</p><p class="calibre7">Next, we can implement our graph functions. Here's what a concrete implementation of a <code class="literal">Graph</code> class might look like in Swift:</p><pre class="programlisting">    public var nodes: Array = [GraphNode]() 
 
    public init(nodes: Array&lt;GraphNode&gt;) 
    { 
        self.nodes = nodes 
    } 
</pre><p class="calibre7">Our <code class="literal">Graph</code> class includes one public <code class="literal">Array</code> property named <code class="literal">nodes</code>. This property maintains the list of edges to neighboring nodes. The class has one custom constructor that accepts one parameter of the type <code class="literal">Array&lt;GraphNode&gt;</code> and sets <code class="literal">_nodes </code>to this value if it is not <code class="literal">nil</code>. Since the <code class="literal">nodes</code> object is initialized when it is declared, there is no need to initialize it here:</p><pre class="programlisting">    public func count() -&gt; Int 
    { 
        return nodes.count 
    } 
</pre><p class="calibre7">The first method in this class is <code class="literal">count()</code>, which exposes read-only access to the total number of nodes contained in the collection by returning <code class="literal">nodes.count</code>. This method provides the Count functionality to our <code class="literal">Graph</code> class and has an <span class="strong"><strong class="calibre16">O</strong></span>(1) operational cost:</p><pre class="programlisting">    public func addNode(node: GraphNode) 
    { 
        nodes.append(node) 
    } 
 
    public func addNodeForValue(value: Int) 
    { 
        let node = GraphNode(val: value) 
        nodes.append(node); 
    } 
</pre><p class="calibre7">The next two public methods in <code class="literal">Graph</code>, <code class="literal">AddNode(node: GraphNode)</code> and <code class="literal">AddNodeForValue(value: Int)</code>, add two versions of the <code class="literal">AddNode</code> functionality to our class. The first adds a pre-existing node to the <code class="literal">nodes</code> collection, while the second instantiates a new node using <code class="literal">value</code> and then adds that node to the <code class="literal">nodes</code> collection. Both of these methods add nodes without defining any edges, and therefore these operations have an <span class="strong"><strong class="calibre16">O</strong></span>(1) cost:</p><pre class="programlisting">    public func removeNodeForValue(value: Int) -&gt; Bool 
    { 
        var nodeToRemove: GraphNode? = nil 
     
        for n in nodes 
        { 
            if (n.value == value) 
            { 
                nodeToRemove = n; 
                break 
            } 
        } 
 
        if (nodeToRemove == nil) 
        { 
            return false 
        } 
     
        if let index = nodes.index(of: nodeToRemove!) 
        { 
            nodes.remove(at: index) 
            for n in nodes 
            { 
                if let foundIndex = n.neighbors.index(of: nodeToRemove!) 
                { 
                    n.neighbors.remove(at: foundIndex) 
                } 
            } 
         
            return true 
        } 
        return false 
    } 
</pre><p class="calibre7">The <code class="literal">removeNodeForValue(value: Int)</code> method provides the <code class="literal">RemoveNode</code> functionality to our class. This method accepts one parameter of type <code class="literal">Int</code> and named <code class="literal">value</code> representing the node the caller is asking to remove. The method begins by looping through each of the nodes in the collection searching for a match to the <code class="literal">value</code>, object. If no match is found, the method returns <code class="literal">false</code>. Otherwise, the matching node is removed from the <code class="literal">nodes</code> collection and method execution continues.</p><p class="calibre7">The second half of this method loops through each of the nodes in the collection, examining each node element's neighbors to find a match for <code class="literal">nodeToRemove</code>. A match found means an edge exists between the <code class="literal">node</code> and <code class="literal">nodeToRemove</code> objects and returns an index value for that match. By removing <code class="literal">nodeToRemove</code> from <code class="literal">node.neighbors</code> using <code class="literal">index</code>, we eliminate the reference and delete the edge.</p><p class="calibre7">As we examined in the discussion on graph operations, the <code class="literal">RemoveNode</code> operation has an operational cost of <span class="strong"><strong class="calibre16">O</strong></span>(<span class="strong"><em class="calibre20">n</em></span> + <span class="strong"><em class="calibre20">k</em></span>), where <span class="strong"><em class="calibre20">n</em></span> is the number of nodes in the collection and <span class="strong"><em class="calibre20">k</em></span> is the number of edges. In the <code class="literal">removeNodeForValue(value: Int)</code> method, the first half represents <span class="strong"><em class="calibre20">n</em></span> and the second half represents <span class="strong"><em class="calibre20">k</em></span> in that equation:</p><pre class="programlisting">    public func addEdgeFromNodeToNode(from: GraphNode, to: GraphNode) 
    { 
        from.neighbors.append(to) 
    } 
 
    public func addBidirectionalEdge(from: GraphNode, to: GraphNode) 
    { 
        from.neighbors.append(to) 
        to.neighbors.append(from) 
    } 
</pre><p class="calibre7">The <code class="literal">addEdgeFromNodeToNode(from: GraphNode, to: GraphNode)</code> and <code class="literal">addBidirectedEdge(from: GraphNode, to: GraphNode)</code> methods provide the <code class="literal">AddEdge</code> functionality to the <code class="literal">Graph</code> class. The first method is the standard AddEdge operation, while the second is more of a convenience method in case the caller wants to immediately add bidirectional references. The first method has an <span class="strong"><strong class="calibre16">O</strong></span>(1) operational cost, while the second technically has an <span class="strong"><strong class="calibre16">O</strong></span>(2) operational cost:</p><pre class="programlisting">    public func adjacent(from: GraphNode, to: GraphNode) -&gt; Bool 
    { 
        if from.neighbors.index(of: to) != nil 
        { 
            return true 
        } 
        else 
        { 
            return false 
        } 
    } 
</pre><p class="calibre7">The <code class="literal">adjacent(from: GraphNode, to: GraphNode)</code> method returns a <code class="literal">Bool</code> value denoting whether an edge exists between two nodes, <code class="literal">from</code> and <code class="literal">to</code>. Hopefully, the signature makes the direction of this edge clear, but for clarity, this method only confirms that an edge exists from the <code class="literal">from</code> node and to the <code class="literal">to</code> node, but not the reciprocal. Since this method is based on the <code class="literal">contains</code> function, it has an <span class="strong"><strong class="calibre16">O</strong></span>(<span class="strong"><em class="calibre20">n</em></span>) operational cost, where <span class="strong"><em class="calibre20">n</em></span> is the number of edges contained in <code class="literal">from.Neighbors</code>:</p><pre class="programlisting">    public func neighborsOfValue(value: Int) -&gt; Array&lt;GraphNode&gt;? 
    { 
        for n in nodes 
        { 
            if (n.value == value) 
            { 
                return n.neighbors 
            } 
        } 
 
        return nil 
    } 
</pre><p class="calibre7">The <code class="literal">neighborsOfValue(value: Int)</code> provides the Neighbors functionality to our class. This method accepts one parameter of type <code class="literal">Int</code> and named <code class="literal">value</code> representing the node the caller is asking to examine. The method begins by looping through the collection of nodes searching for a match to <code class="literal">value</code>. If no match is found, the method returns <code class="literal">nil</code>. Otherwise, the method returns the matching node's <code class="literal">neighbors</code> collection. If the <code class="literal">GraphNode</code> object was known in advance, this operation would have an <span class="strong"><strong class="calibre16">O</strong></span>(1) operational cost. However, since we are examining the entire collection of <code class="literal">nodes</code> at the <code class="literal">Graph</code> level based on the value of a specific node, this implementation has an <span class="strong"><strong class="calibre16">O</strong></span>(<span class="strong"><em class="calibre20">n</em></span>) operational cost.</p></div>
<div class="book" title="Summary" id="20R681-77f2b5b248f04368a6f723b0e9357ef3"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch11lvl1sec60" class="calibre1"/>Summary</h1></div></div></div><p class="calibre7">In this chapter, you learned about graph data structures. We used visual representations of graphs to gain a better understanding of how they are structured and how they can be used. Next, we examined the most common operations when working with graphs and discussed their typical complexity cost. Following this, we created our own simple graph node object and graph data structure class from scratch in each of the four languages we have examined in this book.</p></div></body></html>