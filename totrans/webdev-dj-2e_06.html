<html><head></head><body>
		<div>
			<div id="_idContainer218" class="Content">
			</div>
		</div>
		<div id="_idContainer219" class="Content">
			<h1 id="_idParaDest-193"><a id="_idTextAnchor208"/>6. Forms</h1>
		</div>
		<div id="_idContainer253" class="Content">
			<p class="callout-heading">Overview</p>
			<p class="callout">This chapter introduces web forms, a method of sending information from the browser to the web server. It starts with an introduction to forms in general and discusses how data is encoded to be sent to the server. You will learn about the differences between sending form data in a <strong class="source-inline">GET</strong> HTTP request and sending it in a <strong class="source-inline">POST</strong> HTTP request, and how to choose which one to use. By the end of the chapter, you will know how Django's form library is used to build and validate forms automatically and how it cuts down the amount of manual HTML you need to write.</p>
			<h1 id="_idParaDest-194"><a id="_idTextAnchor209"/>Introduction</h1>
			<p>So far, the views we have been building for Django have been one-way only. Our browser is retrieving data from the views we have written but it does not send any data back to them. In <em class="italic">Chapter 4</em>, <em class="italic">Introduction to Django Admin</em>, we created model instances using the Django admin and submitting forms, but those were using views built into Django, not created by us. In this chapter, we will use the Django Forms library to start accepting user-submitted data. The data will be provided through <strong class="source-inline">GET</strong> requests in the URL parameters, and/or <strong class="source-inline">POST</strong> requests in the body of the request. But before we get into the details, first let us understand what are forms in Django.</p>
			<h1 id="_idParaDest-195"><a id="_idTextAnchor210"/>What Is a Form?</h1>
			<p>When working with an interactive web app, we not only want to provide data to users but also accept data from them to either customize the responses we are generating or let them submit data to the site. When browsing the web, you will most definitely have used forms. Whether you're logging in to your internet banking account, surfing the web with a browser, posting a message on social media, or writing an email in an online email client, in all these cases, you are entering data in a form. A form is made up of inputs that define key-value pairs of data to submit to the server. For example, when logging in to a website, the data being sent would have the keys <em class="italic">username</em> and <em class="italic">password</em>, with the values of your username and your password, respectively. We will go into the different types of inputs in more detail in the <em class="italic">Types of Inputs</em> section. Each input in the form has a <em class="italic">name</em>, and this is how its data is identified on the server-side (in a Django view). There can be multiple inputs with the same <em class="italic">name</em>, whose data is available in a list containing all the posted values with this name – for example, a list of checkboxes with permissions to apply to users. Each checkbox would have the same name but a different value. The form has attributes that specify which URL the browser should submit the data to and what method it should use to submit the data (browsers only support <strong class="source-inline">GET</strong> or <strong class="source-inline">POST</strong>).</p>
			<p>The GitHub login form shown in the next figure is an example of a form:</p>
			<div>
				<div id="_idContainer220" class="IMG---Figure">
					<img src="image/B15509_06_01.jpg" alt="Figure 6.1: The GitHub login page is an example of a form&#13;&#10;"/>
				</div>
			</div>
			<p> </p>
			<p class="figure-caption">Figure 6.1: The GitHub login page is an example of a form</p>
			<p>It has three visible inputs: a text field (<strong class="source-inline">Username</strong>), a <strong class="source-inline">password</strong> field (<strong class="source-inline">Password</strong>), and a <strong class="source-inline">submit</strong> button (<strong class="source-inline">Sign in</strong>). It also has a field that is not visible – its type is <strong class="source-inline">hidden</strong>, and it contains a special token for security called a <strong class="bold">Cross-Site Request Forgery</strong> (<strong class="bold">CSRF</strong>) token. We will discuss this later in the chapter. When you click the <strong class="source-inline">Sign In</strong> button, the form data is submitted with a <strong class="source-inline">POST</strong> request. If you entered a valid username and password, you are logged in; otherwise, the form will display an error as follows:</p>
			<div>
				<div id="_idContainer221" class="IMG---Figure">
					<img src="image/B15509_06_02.jpg" alt="Figure 6.2: Form submitted with an incorrect username or password&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.2: Form submitted with an incorrect username or password</p>
			<p>There are two states a form can have: <strong class="bold">pre-submit</strong> and <strong class="bold">post-submit</strong>. The first is the initial state when the page is first loaded. All the fields will have a default value (usually empty) and no errors will be displayed. If all the information that has been entered into a form is valid, then usually when it is submitted you will be taken to a page showing the results of submitting the form. This might be a search results page, or a page showing you the new object that you created. In this case, you will not see the form in its post-submit state.</p>
			<p>If you did not enter valid information into the form, then it will be rendered again in its post-submit state. In this state, you will be shown the information that you entered as well as any errors to help you resolve the problems with the form. The errors may be <strong class="bold">field errors</strong> or <strong class="bold">non-field errors</strong>. Field errors apply to a specific field. For example, leaving a required field blank or entering a value that is too large, too small, too long, or too short. If a form required you to enter your name and you left it blank, this would be displayed as a field error next to that field.</p>
			<p>Non-field errors either do not apply to a field, or apply to multiple fields, and are displayed at the top of the form. In <em class="italic">Figure 6.2</em>, we see a message that either the username or password may be incorrect when logging in. For security, GitHub does not reveal whether a username is valid, and so this is displayed as a non-field error rather than a field error for the username or password (Django also follows this convention). Non-field errors also apply to fields that depend on each other. For example, on a credit card form, if the payment is rejected, we might not know if the credit card number or security code is incorrect; therefore, we cannot show that error on a specific field. It applies to the form as a whole. </p>
			<h2 id="_idParaDest-196"><a id="_idTextAnchor211"/>The &lt;form&gt; Element</h2>
			<p>All inputs used during form submission must be contained inside a <strong class="source-inline">&lt;form&gt;</strong> element. There are three HTML attributes that you will be using to modify the behavior of the form:</p>
			<ul>
				<li><strong class="source-inline">method</strong><p>This is the HTTP method used to submit the form, either <strong class="source-inline">GET</strong> or <strong class="source-inline">POST</strong>. If omitted, this defaults to <strong class="source-inline">GET</strong> (because this is the default method when typing a URL into the browser and hitting <em class="italic">Enter</em>).</p></li>
				<li><strong class="source-inline">action</strong><p>This refers to the URL (or path) to send the form data to. If omitted, the data gets sent back to the current page.</p></li>
				<li><strong class="source-inline">enctype</strong><p>This sets the encoding type of the form. You only need to change this if you are using the form to upload files. The most common values are <strong class="source-inline">application/x-www-form-urlencoded</strong> (the default if this value is omitted) or <strong class="source-inline">multipart/form-data</strong> (set this if uploading files). Note that you don't have to worry about the encoding type in your view; Django handles the different types automatically. </p></li>
			</ul>
			<p>Here is an example of a form without any of its attributes set:</p>
			<p class="source-code">&lt;form&gt;</p>
			<p class="source-code">    &lt;!-- Input elements go here --&gt;</p>
			<p class="source-code">&lt;/form&gt;</p>
			<p>It will submit its data using a <strong class="source-inline">GET</strong> request, to the current URL that the form is being displayed on, using the <strong class="source-inline">application/x-www-form-urlencoded</strong> encoding type.</p>
			<p>In this next example, we will set all three attributes on a form:</p>
			<p class="source-code">&lt;form method="post" action="/form-submit" enctype="multipart/form-data"&gt;</p>
			<p class="source-code">    &lt;!-- Input elements go here --&gt;</p>
			<p class="source-code">&lt;/form&gt;</p>
			<p>This form will submit its data with a <strong class="source-inline">POST</strong> request to the <strong class="source-inline">/form-submit</strong> path, encoding the data as <strong class="source-inline">multipart/form-data</strong>.</p>
			<p>How do <strong class="source-inline">GET</strong> and <strong class="source-inline">POST</strong> requests differ in how the data is sent? Recall in <em class="italic">Chapter 1</em>, <em class="italic">Introduction to Django</em>, we discussed what the underlying HTTP request and response data that your browser sends looks like. In these next two examples, we will submit the same form twice, the first time using <strong class="source-inline">GET</strong> and the second time using <strong class="source-inline">POST</strong>. The form will have two inputs, a first name, and the last name.</p>
			<p>A form submitted using <strong class="source-inline">GET</strong> sends its data in the URL, like this:</p>
			<p class="source-code">GET /form-submit?first_name=Joe&amp;last_name=Bloggs HTTP/1.1</p>
			<p class="source-code">Host: www.example.com</p>
			<p>A form submitted using <strong class="source-inline">POST</strong> sends its data in the body of the request, like this:</p>
			<p class="source-code">POST /form-submit HTTP/1.1</p>
			<p class="source-code">Host: www.example.com</p>
			<p class="source-code">Content-Length: 31</p>
			<p class="source-code">Content-Type: application/x-www-form-urlencoded</p>
			<p class="source-code">first_name=Joe&amp;last_name=Bloggs</p>
			<p>You will notice that the form data is encoded the same way in both cases; it is just placed differently for the <strong class="source-inline">GET</strong> and <strong class="source-inline">POST</strong> requests. In an upcoming section, we will discuss how to choose between these two types of requests.</p>
			<h2 id="_idParaDest-197"><a id="_idTextAnchor212"/>Types of Inputs</h2>
			<p>We have seen four examples of inputs so far (<em class="italic">text</em>, <em class="italic">password</em>, <em class="italic">submit</em>, and <em class="italic">hidden</em>). Most inputs are created with an <strong class="source-inline">&lt;input&gt;</strong> tag, and their type is specified with its <strong class="source-inline">type</strong> attribute. Each input has a <strong class="source-inline">name</strong> attribute that defines the key for the key-value pairs that are sent to the server in the HTTP request.</p>
			<p>In the next exercise, let's look at how we can build a form in HTML. This will allow you to get up to speed on many different form fields.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The code for all the exercises and activities used in this chapter can be found on the book's GitHub repository at <a href="http://packt.live/2KGjlaM">http://packt.live/2KGjlaM</a>.</p>
			<h2 id="_idParaDest-198"><a id="_idTextAnchor213"/>Exercise 6.01: Building a Form in HTML</h2>
			<p>For the first few exercises of this chapter, we will need an HTML form to test with. We will manually code one in this exercise. This will also allow you to experiment with how different fields are validated and submitted. This will be done in a new Django project so that we don't interfere with Bookr. You can refer to <em class="italic">Chapter 1</em>, <em class="italic">Introduction to Django</em>, to refresh your memory on creating a Django project:</p>
			<ol>
				<li>We will start by creating the new Django project. You can re-use the <strong class="source-inline">bookr</strong> virtual environment that already has Django installed. Open a new terminal and activate the virtual environment. Then, use <strong class="source-inline">django-admin</strong> to start a Django project named <strong class="source-inline">form_project</strong>. To do this, run the command:<p class="source-code">django-admin startproject form_project</p><p>This will scaffold the Django project in a directory named <strong class="source-inline">form_example</strong>.</p></li>
				<li>Create a new Django app in this project by using the <strong class="source-inline">startapp</strong> management command. The app should be called <strong class="source-inline">form_example</strong>. To do this, <strong class="source-inline">cd</strong> into the <strong class="source-inline">form_project</strong> directory, then run this:<p class="source-code">python3 manage.py startapp form_example</p><p>This will create the <strong class="source-inline">form_example</strong> app directory inside the <strong class="source-inline">form_project</strong> directory.</p></li>
				<li>Launch PyCharm, then open the <strong class="source-inline">form_project</strong> directory. If you already have a project open, you can do this by choosing <strong class="source-inline">File</strong> -&gt; <strong class="source-inline">Open</strong>; otherwise, just click <strong class="source-inline">Open</strong> in the <strong class="source-inline">Welcome to PyCharm</strong> window. Navigate to the <strong class="source-inline">form_project</strong> directory, select it, then click <strong class="source-inline">Open</strong>. The <strong class="source-inline">form_project</strong> project window should be shown similar to this:<div id="_idContainer222" class="IMG---Figure"><img src="image/B15509_06_03.jpg" alt="Figure 6.3: The form_project project open&#13;&#10;"/></div><p class="figure-caption">Figure 6.3: The form_project project open</p></li>
				<li>Create a new run configuration to execute <strong class="source-inline">manage.py runserver</strong> for the project. You can re-use the <strong class="source-inline">bookr</strong> virtual environment again. The <strong class="source-inline">Run/Debug Configurations</strong> window should look similar to the following figure when you're done:<div id="_idContainer223" class="IMG---Figure"><img src="image/B15509_06_04.jpg" alt="Figure 6.4: Run/Debug Configurations for Runserver&#13;&#10;"/></div><p class="figure-caption">Figure 6.4: Run/Debug Configurations for Runserver</p><p>You can test that the configuration is set up correctly by clicking the <strong class="source-inline">Run</strong> button, then visiting <strong class="source-inline">http://127.0.0.1:8000/</strong> in your browser. You should see the Django welcome screen. If the debug server fails to start or you see the Bookr main page, then you probably still have the Bookr project running. Try stopping the Bookr <strong class="source-inline">runserver</strong> process and then starting the new one you just set up.</p></li>
				<li>Open <strong class="source-inline">settings.py</strong> in the <strong class="source-inline">form_project</strong> directory and add <strong class="source-inline">'form_example'</strong> to the <strong class="source-inline">INSTALLED_APPS</strong> setting.</li>
				<li>The last step in setting up this new project is to create a <strong class="source-inline">templates</strong> directory for the <strong class="source-inline">form_example</strong> app. Right-click on the <strong class="source-inline">form_example</strong> directory and then select <strong class="source-inline">New</strong> -&gt; <strong class="source-inline">Directory</strong>. Name it <strong class="source-inline">templates</strong>.</li>
				<li>We need an HTML template to display our form. Create one by right-clicking the <strong class="source-inline">templates</strong> directory you just created and choosing <strong class="source-inline">New</strong> -&gt; <strong class="source-inline">HTML File</strong>. In the dialog box that appears, enter the name <strong class="source-inline">form-example.html</strong> and hit <em class="italic">Enter</em> to create it.</li>
				<li>The <strong class="source-inline">form-example.html</strong> file should now be open in the editor pane of PyCharm. Start by creating the <strong class="source-inline">form</strong> element. We will set its <strong class="source-inline">method</strong> attribute to <strong class="source-inline">post</strong>. The <strong class="source-inline">action</strong> attribute will be omitted, which means the form will submit back to the same URL on which it was loaded. <p>Insert this code between the <strong class="source-inline">&lt;body&gt;</strong> and <strong class="source-inline">&lt;/body&gt;</strong> tags:</p><p class="source-code">&lt;form method="post"&gt;</p><p class="source-code">&lt;/form&gt;</p></li>
				<li>Now let us add a few inputs. To add a little bit of spacing between each input, we will wrap them inside <strong class="source-inline">&lt;p&gt;</strong> tags. We will start with a text field and password field. This code should be inserted between the <strong class="source-inline">&lt;form&gt;</strong> tags you just created:<p class="source-code">&lt;p&gt;</p><p class="source-code">    &lt;label for="id_text_input"&gt;Text Input&lt;/label&gt;&lt;br&gt;</p><p class="source-code">    &lt;input id="id_text_input" type="text" name=      "text_input" value="" placeholder="Enter some text"&gt;</p><p class="source-code">&lt;/p&gt;</p><p class="source-code">&lt;p&gt;</p><p class="source-code">    &lt;label for="id_password_input"&gt;Password Input&lt;/label&gt;&lt;br&gt;</p><p class="source-code">    &lt;input id="id_password_input" type="password" name="password_input"       value="" placeholder="Your password"&gt;</p><p class="source-code">&lt;/p&gt;</p></li>
				<li>Next, we will add two checkboxes and three radio buttons. Insert this code after the HTML you added in the previous step; it should come before the <strong class="source-inline">&lt;/form&gt;</strong> tag:<p class="source-code">&lt;p&gt;</p><p class="source-code">    &lt;input id="id_checkbox_input" type="checkbox"      name="checkbox_on" value="Checkbox Checked" checked&gt;</p><p class="source-code">    &lt;label for="id_checkbox_input"&gt;Checkbox&lt;/label&gt;</p><p class="source-code">&lt;/p&gt;</p><p class="source-code">&lt;p&gt;</p><p class="source-code">    &lt;input id="id_radio_one_input" type="radio"      name="radio_input" value="Value One"&gt;</p><p class="source-code">    &lt;label for="id_radio_one_input"&gt;Value One&lt;/label&gt;</p><p class="source-code">    &lt;input id="id_radio_two_input" type="radio"      name="radio_input" value="Value Two" checked&gt;</p><p class="source-code">    &lt;label for="id_radio_two_input"&gt;Value Two&lt;/label&gt;</p><p class="source-code">    &lt;input id="id_radio_three_input" type="radio"      name="radio_input" value="Value Three"&gt;</p><p class="source-code">    &lt;label for="id_radio_three_input"&gt;Value Three&lt;/label&gt;</p><p class="source-code">&lt;/p&gt;</p></li>
				<li>Next is a dropdown select menu to allow the user to choose a favorite book. Add this code after that of the previous step but before the <strong class="source-inline">&lt;/form&gt;</strong> tag:<p class="source-code">&lt;p&gt;</p><p class="source-code">    &lt;label for="id_favorite_book"&gt;Favorite Book&lt;/label&gt;&lt;br&gt;</p><p class="source-code">    &lt;select id="id_favorite_book" name="favorite_book"&gt;</p><p class="source-code">        &lt;optgroup label="Non-Fiction"&gt;</p><p class="source-code">            &lt;option value="1"&gt;Deep Learning with Keras&lt;/option&gt;</p><p class="source-code">            &lt;option value="2"&gt;Web Development with Django&lt;/option&gt;</p><p class="source-code">        &lt;/optgroup&gt;</p><p class="source-code">        &lt;optgroup label="Fiction"&gt;</p><p class="source-code">            &lt;option value="3"&gt;Brave New World&lt;/option&gt;</p><p class="source-code">            &lt;option value="4"&gt;The Great Gatsby&lt;/option&gt;</p><p class="source-code">        &lt;/optgroup&gt;</p><p class="source-code">    &lt;/select&gt;</p><p class="source-code">&lt;/p&gt;</p><p>It will display four options that are split into two groups. The user will only be able to select one option.</p></li>
				<li>The next is a multiple select (achieved by using the <strong class="source-inline">multiple</strong> attribute). Add this code after that of the previous step but before the <strong class="source-inline">&lt;/form&gt;</strong> tag:<p class="source-code">&lt;p&gt;</p><p class="source-code">    &lt;label for="id_books_you_own"&gt;Books You Own&lt;/label&gt;&lt;br&gt;</p><p class="source-code">    &lt;select id="id_books_you_own" name="books_you_own" multiple&gt;</p><p class="source-code">        &lt;optgroup label="Non-Fiction"&gt;</p><p class="source-code">            &lt;option value="1"&gt;Deep Learning with Keras&lt;/option&gt;</p><p class="source-code">            &lt;option value="2"&gt;Web Development with Django&lt;/option&gt;</p><p class="source-code">        &lt;/optgroup&gt;</p><p class="source-code">        &lt;optgroup label="Fiction"&gt;</p><p class="source-code">            &lt;option value="3"&gt;Brave New World&lt;/option&gt;</p><p class="source-code">            &lt;option value="4"&gt;The Great Gatsby&lt;/option&gt;</p><p class="source-code">        &lt;/optgroup&gt;</p><p class="source-code">    &lt;/select&gt;</p><p class="source-code">&lt;/p&gt;</p><p>The user can select zero or more options from the four. They are displayed in two groups.</p></li>
				<li>Next is <strong class="source-inline">textarea</strong>. It is like a text field but has multiple lines. This code should be added like in the previous steps, before the closing <strong class="source-inline">&lt;/form&gt;</strong> tag:<p class="source-code">&lt;p&gt;</p><p class="source-code">    &lt;label for="id_text_area"&gt;Text Area&lt;/label&gt;&lt;br&gt;</p><p class="source-code">    &lt;textarea name="text_area" id="id_text_area"      placeholder="Enter multiple lines of text"&gt;&lt;/textarea&gt;</p><p class="source-code">&lt;/p&gt;</p></li>
				<li>Next, add some fields for specific data types: <strong class="source-inline">number</strong>, <strong class="source-inline">email</strong>, and <strong class="source-inline">date</strong> inputs. Add this all before the <strong class="source-inline">&lt;/form&gt;</strong> tag:<p class="source-code">&lt;p&gt;</p><p class="source-code">    &lt;label for="id_number_input"&gt;Number Input&lt;/label&gt;&lt;br&gt;</p><p class="source-code">    &lt;input id="id_number_input" type="number"      name="number_input" value="" step="any" placeholder="A number"&gt;</p><p class="source-code">&lt;/p&gt;</p><p class="source-code">&lt;p&gt;</p><p class="source-code">    &lt;label for="id_email_input"&gt;Email Input&lt;/label&gt;&lt;br&gt;</p><p class="source-code">    &lt;input id="id_email_input" type="email"      name="email_input" value="" placeholder="Your email address"&gt;</p><p class="source-code">&lt;/p&gt;</p><p class="source-code">&lt;p&gt;</p><p class="source-code">    &lt;label for="id_date_input"&gt;Date Input&lt;/label&gt;&lt;br&gt;</p><p class="source-code">    &lt;input id="id_date_input" type="date" name=      "date_input" value="2019-11-23"&gt;</p><p class="source-code">&lt;/p&gt;</p></li>
				<li>Now add some buttons to submit the form. Once again, insert this before the closing <strong class="source-inline">&lt;/form&gt;</strong> tag:<p class="source-code">&lt;p&gt;</p><p class="source-code">    &lt;input type="submit" name="submit_input" value="Submit Input"&gt;</p><p class="source-code">&lt;/p&gt;</p><p class="source-code">&lt;p&gt;</p><p class="source-code">    &lt;button type="submit" name="button_element" value="Button Element"&gt;</p><p class="source-code">        Button With &lt;strong&gt;Styled&lt;/strong&gt; Text</p><p class="source-code">    &lt;/button&gt;</p><p class="source-code">&lt;/p&gt;</p><p>This demonstrates two ways of creating submit buttons, either as <strong class="source-inline">&lt;input&gt;</strong> or <strong class="source-inline">&lt;button&gt;</strong>.</p></li>
				<li>Finally, add a hidden field. Insert this before the closing <strong class="source-inline">&lt;/form&gt;</strong> tag:<p class="source-code">&lt;input type="hidden" name="hidden_input" value="Hidden Value"&gt;</p><p>This field cannot be seen or edited so it has a fixed value. You can save and close <strong class="source-inline">form-example.html</strong>.</p></li>
				<li>As with any template, we cannot see it unless we have a view to render it. Open the <strong class="source-inline">form_example</strong> app's <strong class="source-inline">views.py</strong> file and add a new view called <strong class="source-inline">form_example</strong>. It should render and return the template you just created, like so:<p class="source-code">def form_example(request):</p><p class="source-code">    return render(request, "form-example.html")</p><p>You can now save and close <strong class="source-inline">views.py</strong>.</p></li>
				<li>You should be familiar with the next step now, which is to add a URL mapping to the view. Open the <strong class="source-inline">urls.py</strong> file in the <strong class="source-inline">form_project</strong> package directory. Add a mapping for the path <strong class="source-inline">form-example</strong> to your <strong class="source-inline">form_example</strong> view, to the <strong class="source-inline">urlpatterns</strong> variable. It should look like this:<p class="source-code">path('form-example/', form_example.views.form_example)</p><p>Make sure you also add an import of <strong class="source-inline">form_example.views</strong>. Save and close <strong class="source-inline">urls.py</strong>.</p></li>
				<li>Start the Django dev server (if it is not already running), then load your new view in your web browser; the address is <strong class="source-inline">http://127.0.0.1:8000/form-example/</strong>. Your page should look like this:<div id="_idContainer224" class="IMG---Figure"><img src="image/B15509_06_05.jpg" alt="Figure 6.5: Example inputs page&#13;&#10;"/></div><p class="figure-caption">Figure 6.5: Example inputs page</p><p>You can now familiarize yourself with the behavior of the web forms and see how they are generated from the HTML you specified. One activity to try is to enter invalid data into the number, date, or email inputs and click the submit button – the built-in HTML validation should prevent the form from being submitted:</p><div id="_idContainer225" class="IMG---Figure"><img src="image/B15509_06_06.jpg" alt="Figure 6.6: Browser error due to an invalid number&#13;&#10;"/></div><p class="figure-caption">Figure 6.6: Browser error due to an invalid number</p><p>We have not yet set up everything for form submission, so if you correct all the errors in the form and try to submit it (by clicking either of the submit buttons), you will receive an error stating <strong class="source-inline">CSRF verification failed. Request aborted.</strong>, as we can see in the next figure. We will talk about what this means, and how to fix it, later in the chapter:</p><div id="_idContainer226" class="IMG---Figure"><img src="image/B15509_06_07.jpg" alt="Figure 6.7: CSRF verification error&#13;&#10;"/></div><p class="figure-caption">Figure 6.7: CSRF verification error</p></li>
				<li>If you do receive the error, just go back in your browser to return to the input example page.</li>
			</ol>
			<p>In this exercise, you created an example page showcasing many HTML inputs, then created a view to render it and a URL to map to it. You loaded the page in your browser and experimented with changing data and trying to submit the form when it contained errors. </p>
			<h2 id="_idParaDest-199"><a id="_idTextAnchor214"/>Form Security with Cross-Site Request Forgery Protection</h2>
			<p>Throughout the book, we have mentioned features that Django includes to prevent certain types of security exploits. One of these features is protection against CSRF.</p>
			<p>A CSRF attack exploits the fact that a form on a website can be submitted to any other website. The <strong class="source-inline">action</strong> attribute of <strong class="source-inline">form</strong> just needs to be set appropriately. Let's take an example for Bookr. We don't have this set up yet, but we will be adding a view and URL that allows us to post a review for a book. To do this, we'll have a form for posting the review content and selecting the rating. Its HTML is like this:</p>
			<p class="source-code">&lt;form method="post" action="http://127.0.0.1:8000/books/4/reviews/"&gt;</p>
			<p class="source-code">    &lt;p&gt;</p>
			<p class="source-code">        &lt;label for="id_review_text"&gt;Your Review&lt;/label&gt;&lt;br/&gt;</p>
			<p class="source-code">        &lt;textarea id="id_review_text" name="review_text"          placeholder="Enter your review"&gt;&lt;/textarea&gt;</p>
			<p class="source-code">    &lt;/p&gt;</p>
			<p class="source-code">    &lt;p&gt;</p>
			<p class="source-code">        &lt;label for="id_rating"&gt;Rating&lt;/label&gt;&lt;br/&gt;</p>
			<p class="source-code">        &lt;input id="id_rating" type="number" name="rating"          placeholder="Rating 1-5"&gt;</p>
			<p class="source-code">    &lt;/p&gt;</p>
			<p class="source-code">    &lt;p&gt;</p>
			<p class="source-code">        &lt;button type="submit"&gt;Create Review&lt;/button&gt;</p>
			<p class="source-code">    &lt;/p</p>
			<p class="source-code">&lt;/form&gt;</p>
			<p>And on a web page, it would look like this:</p>
			<div>
				<div id="_idContainer227" class="IMG---Figure">
					<img src="image/B15509_06_08.jpg" alt="Figure 6.8: Example review creation form&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.8: Example review creation form</p>
			<p>Someone could take this form, make a few changes, and host it on their own website. For example, they could make the inputs hidden and hardcode a good review and rating for a book, and then make it look like some other kind of form, like this:</p>
			<p class="source-code">&lt;form method="post" action="http://127.0.0.1:8000/books/4/reviews/"&gt;</p>
			<p class="source-code">    &lt;input type="hidden" name="review_text" value="This book is great!"&gt;</p>
			<p class="source-code">    &lt;input type="hidden" name="rating" value="5"&gt;</p>
			<p class="source-code">    &lt;p&gt;</p>
			<p class="source-code">        &lt;button type="submit"&gt;Enter My Website&lt;/button&gt;</p>
			<p class="source-code">    &lt;/p&gt;</p>
			<p class="source-code">&lt;/form&gt;</p>
			<p>Of course, the hidden fields don't display, so the form looks like this on the malicious website.</p>
			<div>
				<div id="_idContainer228" class="IMG---Figure">
					<img src="image/B15509_06_09.jpg" alt="Figure 6.9: Hidden inputs are not visible&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.9: Hidden inputs are not visible</p>
			<p>The user would think they were clicking a button to enter a website, but while clicking it, they would submit the hidden values to the original view on Bookr. Of course, a user could check the source code of the page they were on to check what data is being sent and where, but most users are unlikely to inspect every form they come across. The attacker could even have the form with no submit button and just use JavaScript to submit it, which means the user would be submitting the form without even realizing it.</p>
			<p>You may think that requiring the user to log in to Bookr will prevent this type of attack, and it does limit its effectiveness somewhat, as the attack would then only work for logged-in users. But because of the way authentication works, once a user is logged in, they have a cookie set in their browser that identifies them to the Django application. This cookie is sent on every request so that the user does not have to provide their login credentials on every page. Because of the way web browsers work, they will include the server's authentication cookie in <em class="italic">all</em> requests they send to that particular server. Even though our form is hosted on a malicious site, ultimately it is sending a request to our application, so it will send through our server's cookies.</p>
			<p>How can we prevent CSRF attacks? Django uses something called a CSRF token, which is a small random string that is unique to each site visitor – in general, you can consider a visitor to be one browser session. Different browsers on the same computer would be different visitors, and the same Django user logged in on two different browsers would also be different visitors. When the form is read, Django puts the token into the form as a hidden input. The CSRF token must be included in all <strong class="source-inline">POST</strong> requests being sent to Django, and it must match the token Django has stored on the server-side for the visitor, otherwise, a 403 status HTTP response is returned. This protection can be disabled – either for the whole site or for an individual view – but it is not advisable to do so unless you really need to. The CSRF token must be added into the HTML for every form being sent and is done with the <strong class="source-inline">{% csrf_token %}</strong> template tag. We'll add it to our example review form now, and the code in the template will look like this:</p>
			<p class="source-code">&lt;form method="post" action="http://127.0.0.1:8000/books/4/reviews/"&gt;</p>
			<p class="source-code">    {% csrf_token %}</p>
			<p class="source-code">    &lt;p&gt;</p>
			<p class="source-code">        &lt;label for="id_review_text"&gt;Your Review&lt;/label&gt;&lt;br/&gt;</p>
			<p class="source-code">        &lt;textarea id="id_review_text" name="review_text"          placeholder="Enter your review"&gt;&lt;/textarea&gt;</p>
			<p class="source-code">    &lt;/p&gt;</p>
			<p class="source-code">    &lt;p&gt;</p>
			<p class="source-code">        &lt;label for="id_rating"&gt;Rating&lt;/label&gt;&lt;br/&gt;</p>
			<p class="source-code">        &lt;input id="id_rating" type="number" name="rating"          placeholder="Rating 1-5"&gt;</p>
			<p class="source-code">    &lt;/p&gt;</p>
			<p class="source-code">    &lt;p&gt;</p>
			<p class="source-code">        &lt;button type="submit"&gt;Enter My Website&lt;/button&gt;</p>
			<p class="source-code">    &lt;/p&gt;</p>
			<p class="source-code">&lt;/form&gt;</p>
			<p>When the template gets rendered, the template tag is interpolated, so the output HTML ends up like this (note that the inputs are still in the output; they have just been removed here for brevity):</p>
			<p class="source-code">&lt;form method="post" action="http://127.0.0.1:8000/books/4/reviews/"&gt;</p>
			<p class="source-code">    &lt;input type="hidden" name="csrfmiddlewaretoken"      value="tETZjLDUXev1tiYqGCSbMQkhWiesHCnutxpt6mutHI6YH64F0nin5k2JW3B68IeJ"&gt;</p>
			<p class="source-code">    …</p>
			<p class="source-code">&lt;/form&gt;</p>
			<p>Since this is a hidden field, the form on the page does not look any different from how it did before.</p>
			<p>The CSRF token is unique to every visitor on the site and periodically changes. If an attacker were to copy the HTML from our site, they would get their own CSRF token that would not match that of any other user, so Django would reject the form when it was posted by someone else. </p>
			<p>CSRF tokens also change periodically. This limits how long the attacker would have to take advantage of a particular user and token combination. Even if they were able to get the CSRF token of a user that they were trying to exploit, they would have a short window of time to be able to use it. </p>
			<h2 id="_idParaDest-200"><a id="_idTextAnchor215"/>Accessing Data in the View</h2>
			<p>As we discussed in <em class="italic">Chapter 1</em>, <em class="italic">Introduction to Django</em>, Django provides two <strong class="source-inline">QueryDict</strong> objects on the <strong class="source-inline">HTTPRequest</strong> instances that are passed to the view function. These are <strong class="source-inline">request.GET</strong>, which contains parameters passed in the URL, and <strong class="source-inline">request.POST</strong>, which contains parameters in the HTTP request body. Even though <strong class="source-inline">request.GET</strong> has <strong class="source-inline">GET</strong> in its name, this variable is populated even for non-<strong class="source-inline">GET</strong> HTTP requests. This is because the data it contains is parsed from the URL. Since all HTTP requests have a URL, all HTTP requests may contain <strong class="source-inline">GET</strong> data, even if they are <strong class="source-inline">POST</strong> or <strong class="source-inline">PUT</strong>, and so on. In the next exercise, we will add code to our view to read and display the <strong class="source-inline">POST</strong> data.</p>
			<h2 id="_idParaDest-201"><a id="_idTextAnchor216"/>Exercise 6.02: Working with POST Data in a View</h2>
			<p>We will now add some code to our example view to print out the received <strong class="source-inline">POST</strong> data to the console. We will also insert the HTTP method that was used to generate the page into the HTML output. This will allow us to be sure of what method was used to generate the page (<strong class="source-inline">GET</strong> or <strong class="source-inline">POST</strong>) and see how the form differs for each type:</p>
			<ol>
				<li value="1">First, in PyCharm, open the <strong class="source-inline">form_example</strong> app's <strong class="source-inline">views.py</strong> file. Alter the <strong class="source-inline">form_example</strong> view to print each value in the <strong class="source-inline">POST</strong> request to the console by adding this code inside the function:<p class="source-code">    for name in request.POST:</p><p class="source-code">        print("{}: {}".format(name, request.POST.getlist(name)))</p><p>This code iterates over each key in the request <strong class="source-inline">POST</strong> data <strong class="source-inline">QueryDict</strong> and prints the key and list of values to the console. We already know that each <strong class="source-inline">QueryDict</strong> can have multiple values for a key, so we use the <strong class="source-inline">getlist</strong> function to get them all. </p></li>
				<li>Pass <strong class="source-inline">request.method</strong> to the template in a context variable named <strong class="source-inline">method</strong>. Do this by updating the call to <strong class="source-inline">render</strong> in the view, so that it's like this:<p class="source-code">return render(request, "form-example.html", \</p><p class="source-code">              {"method": request.method})</p></li>
				<li>We will now display the <strong class="source-inline">method</strong> variable in the template. Open the <strong class="source-inline">form-example.html</strong> template and use an <strong class="source-inline">&lt;h4&gt;</strong> tag to show the <strong class="source-inline">method</strong> variable. Put this just after the opening <strong class="source-inline">&lt;body&gt;</strong> tag, like so:<p class="source-code">&lt;body&gt;</p><p class="source-code">    &lt;h4&gt;Method: {{ method }}&lt;/h4&gt;</p><p>Note that we could access the method directly inside the template without passing it in a context dictionary, by using the <strong class="source-inline">request</strong> method variable and attribute properly. We know from <em class="italic">Chapter 3</em>, <em class="italic">URL Mapping, Views, and Templates</em>, that by using the render shortcut function, the request is always available in the template. We just demonstrated how to access the method in the view here because later on, we will change the behavior of the page based on the method.</p></li>
				<li>We also need to add the CSRF token to the form HTML. We do this by putting the <strong class="source-inline">{% csrf_token %}</strong> template tag after the opening <strong class="source-inline">&lt;form&gt;</strong> tag. The start of the form should look like this:<p class="source-code">&lt;form method="post"&gt;</p><p class="source-code">     {% csrf_token %}</p><p>Now, save the file.</p></li>
				<li>Start the Django dev server if it's not already running. Load the example page (<strong class="source-inline">http://127.0.0.1:8000/form-example/</strong>) in your browser, and you should see it now displays the method at the top of the page (<strong class="source-inline">GET</strong>):<div id="_idContainer229" class="IMG---Figure"><img src="image/B15509_06_10.jpg" alt="Figure 6.10: Method at the top of the page&#13;&#10;"/></div><p class="figure-caption">Figure 6.10: Method at the top of the page</p></li>
				<li>Enter some text or data in each of the inputs and submit the form, by clicking the <strong class="source-inline">Submit Input</strong> button:<div id="_idContainer230" class="IMG---Figure"><img src="image/B15509_06_11.jpg" alt="Figure 6.11: Clicking the Submit Input button to submit the form&#13;&#10;"/></div><p class="figure-caption">Figure 6.11: Clicking the Submit Input button to submit the form</p><p>You should see the page reload and the method displayed change to <strong class="source-inline">POST</strong>:</p><div id="_idContainer231" class="IMG---Figure"><img src="image/B15509_06_12.jpg" alt="Figure 6.12: Method updated to POST after the form is submitted&#13;&#10;"/></div><p class="figure-caption">Figure 6.12: Method updated to POST after the form is submitted</p></li>
				<li>Switch back to PyCharm and look in the <strong class="source-inline">Run</strong> console at the bottom of the window. If it is not visible, click the <strong class="source-inline">Run</strong> button at the bottom of the window to show it:<div id="_idContainer232" class="IMG---Figure"><img src="image/B15509_06_13.jpg" alt="Figure 6.13: Click the Run button at the bottom of the window to display the console&#13;&#10;"/></div><p class="figure-caption">Figure 6.13: Click the Run button at the bottom of the window to display the console</p><p>Inside the <strong class="source-inline">Run</strong> console, a list of the values that were posted to the server should be displayed:</p><div id="_idContainer233" class="IMG---Figure"><img src="image/B15509_06_14.jpg" alt="Figure 6.14: Input values shown in the Run console&#13;&#10;"/></div><p class="figure-caption">Figure 6.14: Input values shown in the Run console</p><p>Some things you should notice are as follows:</p><ul><li>All values are sent as text, even <strong class="source-inline">number</strong> and <strong class="source-inline">date</strong> inputs.</li><li>For the <strong class="source-inline">select</strong> inputs, the selected <strong class="source-inline">value</strong> attributes of the selected options are sent, not the text content of the <strong class="source-inline">option</strong> tag.</li><li>If you select multiple options for <strong class="source-inline">books_you_own</strong>, then you will see multiple values in the request. This is why we use the <strong class="source-inline">getlist</strong> method since multiple values are sent for the same input name.</li><li>If the checkbox was checked, you will have a <strong class="source-inline">checkbox_on</strong> input in the debug output. If it was not checked, then the key will not exist at all (that is, there is no key, instead of having the key existing with an empty string or <strong class="source-inline">None</strong> value).</li><li>We have a value for the name <strong class="source-inline">submit_input</strong>, which is the text <strong class="source-inline">Submit Input</strong>. You submitted the form by clicking the <strong class="source-inline">Submit Input</strong> button, so we receive its value. Notice that no value is set for the <strong class="source-inline">button_element</strong> input since that button was not clicked.</li></ul></li>
				<li>We will experiment with two other ways of submitting the form, first by hitting <em class="italic">Enter</em> when your cursor is in a text-like input (such as <em class="italic">text</em>, <em class="italic">password</em>, <em class="italic">date</em>, and <em class="italic">email</em>, but not <em class="italic">text area</em>, as hitting <em class="italic">Enter</em> there will add a new line). <p>If you submit a form in this way, the form will act as though you had clicked the first submit button on the form, so the <strong class="source-inline">submit_input</strong> input value will be included. The output you see should match that of the previous figure.</p><p>The other way to submit the form is by clicking the <strong class="source-inline">Button Element</strong> submit input, in which we will try clicking this button to submit the form. You should see that <strong class="source-inline">submit_button</strong> is no longer in the list of posted values, while <strong class="source-inline">button_element</strong> is now present:</p><div id="_idContainer234" class="IMG---Figure"><img src="image/B15509_06_15.jpg" alt="Figure 6.15: submit_button is now gone from the inputs, and button_element is added&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 6.15: submit_button is now gone from the inputs, and button_element is added</p>
			<p>You can use this multiple-submit technique to alter how your view behaves depending on which button was clicked. You can even have multiple submit buttons with the same <em class="italic">name</em> attribute to make the logic easier to write. </p>
			<p>In this exercise, you added a CSRF token to your <strong class="source-inline">form</strong> element by using the <strong class="source-inline">{% csrf_token %}</strong> template tag. This means that your form could then be submitted to Django successfully without generating an HTTP Permission Denied response. We then added some code to output the values that our form contained when it was submitted. We tried submitting the form with various values to see how they are parsed into Python variables on the <strong class="source-inline">request.POST</strong> <strong class="source-inline">QueryDict</strong>. We will now discuss some more theory around the difference between <strong class="source-inline">GET</strong> and <strong class="source-inline">POST</strong> requests, then move on to the Django Forms library, which makes designing and validating forms easier.</p>
			<h2 id="_idParaDest-202"><a id="_idTextAnchor217"/>Choosing between GET and POST</h2>
			<p>Choosing when to use a <strong class="source-inline">GET</strong> or <strong class="source-inline">POST</strong> request requires the consideration of a number of factors. The most important is deciding whether or not the request should be idempotent. A request can be said to be idempotent if it can be repeated and produce the same result each time. Let us look at some examples.</p>
			<p>If you type any web address into your browser (such as any of the Bookr pages we have built so far), it will perform a <strong class="source-inline">GET</strong> request to fetch the information. You can refresh the page, and no matter how many times you click refresh, you will get the same data back. The request you are making will not affect the content on the server. You would say these requests are idempotent.</p>
			<p>Now, remember when you added data through the Django admin interface (in <em class="italic">Chapter 4</em>,<em class="italic"> Introduction to Django Admin</em>)? You typed in the information for the new book in a form, then clicked <strong class="source-inline">Save</strong>. Your browser made a <strong class="source-inline">POST</strong> request to create a new book on the server. If you repeated that <strong class="source-inline">POST</strong> request, the server would create <em class="italic">another</em> book and would do so each time you repeated the request. Since the request is updating information, it is not idempotent. Your browser will warn you about this. If you have ever tried to refresh a page that you were sent to after submitting a form, you may have received a message asking if you want to <em class="italic">"Repost form data?" </em>(or something more verbose, as in the following figure). This is a warning that you are sending the form data again, which might cause the action you just undertook to be repeated:</p>
			<div>
				<div id="_idContainer235" class="IMG---Figure">
					<img src="image/B15509_06_16.jpg" alt="Figure 6.16: Firefox confirming whether information should be resent&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.16: Firefox confirming whether information should be resent</p>
			<p>This is not to suggest that all <strong class="source-inline">GET</strong> requests are idempotent and all <strong class="source-inline">POST</strong> requests are not – your backend application can be designed in any way you want. Although it is not best practice, a developer might have decided to make data get updated during a <strong class="source-inline">GET</strong> request in their web application. When you are building your applications, you should try to make sure <strong class="source-inline">GET</strong> requests are idempotent and leave data-altering to <strong class="source-inline">POST</strong> requests only. Stick to these principles unless you have a good reason not to. </p>
			<p>Another point to consider is that Django only applies CSRF projection to <strong class="source-inline">POST</strong> requests. Any <strong class="source-inline">GET</strong> request, including one that alters data, can be accessed without a CSRF token.</p>
			<p>Sometimes, it can be hard to decide if a request is idempotent or not; for example, a login form. Before you submitted your username and password, you were not logged in, and afterward, the server considered you to be logged in, so could we consider that non-idempotent as it changed your authentication status with the server? On the other hand, once logged in, if you were able to send your credentials again, you would remain logged in. This implies that the request is idempotent and repeatable. So, should the request be <strong class="source-inline">GET</strong> or <strong class="source-inline">POST</strong>?</p>
			<p>This brings us to the second point to consider when choosing what method to use. If sending form data with a <strong class="source-inline">GET</strong> request, the form parameters will be visible in the URL. For example, if we made a login form use a <strong class="source-inline">GET</strong> request, the login URL might be <strong class="source-inline">https://www.example.com/login?username=user&amp;password=password1</strong>. The username, and worse, the password, is visible in the web browser's address bar. It would also be stored in the browser history, so anyone who used the browser after the real user could log in to the site. The URL is often stored in web server log files as well, meaning the credentials would be visible there too. In short, regardless of the idempotency of a request, don't pass sensitive data through URL parameters.</p>
			<p>Sometimes, knowing that the parameter will be visible in the URL might be something you desire. For example, when searching with a search engine, usually the search parameter will be visible in the URL. To see this in action, try visiting <a href="https://www.google.com">https://www.google.com</a> and searching for something. You'll notice that the page with the results has your search term as the <strong class="source-inline">q</strong> parameter. A search for <strong class="source-inline">Django</strong> will take you to the URL <a href="https://www.google.com/search?q=Django">https://www.google.com/search?q=Django</a>, for example. This allows you to share search results with someone else by sending them this URL. In <em class="italic">Activity 6.01, Book Searching</em>, you will add a search form that similarly passes a parameter.</p>
			<p>Another consideration is that the maximum length of a URL allowed by a browser can be short compared to the size of a <strong class="source-inline">POST</strong> body – sometimes only around 2,000 characters (or about 2 KB) compared to many megabytes or gigabytes that a <strong class="source-inline">POST</strong> body can be (assuming your server is set up to allow these sizes of requests). </p>
			<p>As we mentioned earlier, URL parameters are available in <strong class="source-inline">request.GET</strong> regardless of the type of request being made (<strong class="source-inline">GET</strong>, <strong class="source-inline">POST</strong>, <strong class="source-inline">PUT</strong>, and so on). You might find it useful to send some data in URL parameters and others in the request body (available in <strong class="source-inline">request.POST</strong>). For example, you could specify a <strong class="source-inline">format</strong> argument in the URL that sets what format some output data will be transformed to, but the input data is provided in the <strong class="source-inline">POST</strong> body.</p>
			<h2 id="_idParaDest-203"><a id="_idTextAnchor218"/>Why Use GET When We Can Put Parameters in the URL?</h2>
			<p>Django allows us to easily define URL maps that contain variables. We could, for example, set up a URL mapping for a search view like this:</p>
			<p class="source-code">path('/search/&lt;str:search&gt;/', reviews.views.search)</p>
			<p>This probably looks like a good approach at first, but when we start wanting to customize the results view with arguments, it can get complicated quickly. For example, we might want to be able to move from one results page to the next, so we add a page argument:</p>
			<p class="source-code">path('/search/&lt;str:search&gt;/&lt;int:page&gt;', reviews.views.search)</p>
			<p>And then we might also want to order the search results by a specific category, such as the author name or the date of publishing, so we add another argument for that:</p>
			<p class="source-code">path('/search/&lt;str:search&gt;/&lt;int:page&gt;/&lt;str:order &gt;', \</p>
			<p class="source-code">     reviews.views.search)</p>
			<p>You might be able to see the problem with this approach – we can't order the results without providing a page. If we wanted to also add a <strong class="source-inline">results_per_page</strong> argument too, we wouldn't be able to use that without setting <strong class="source-inline">page</strong> and <strong class="source-inline">order</strong> keys.</p>
			<p>Contrast this to using query parameters: all of them are optional, so you could search like this:</p>
			<p class="source-code">?search=search+term:</p>
			<p>Or you could set a page like this:</p>
			<p class="source-code">?search=search+term&amp;page=2</p>
			<p>Or you could just set the results ordering like this:</p>
			<p class="source-code">?search=search+term&amp;order=author</p>
			<p>Or you could combine them all:</p>
			<p class="source-code">?search=search+term&amp;page=2&amp;order=author</p>
			<p>Another reason for using URL query parameters is that when submitting a form, the browser always sends the input values in this manner; it cannot be changed so that parameters are submitted as path components in the URL. Therefore, when submitting a form using <strong class="source-inline">GET</strong>, the URL query parameters must be used as the input data.</p>
			<h1 id="_idParaDest-204"><a id="_idTextAnchor219"/>The Django Forms Library</h1>
			<p>We've looked at how to manually write forms in HTML and how to access the data on the request object using <strong class="source-inline">QueryDict</strong>. We saw that the browser provides some validation for us for certain field types, such as email or numbers, but we have not tried validating the data in the Python view. We should validate the form in the Python view for two reasons:</p>
			<ul>
				<li>It is not safe to rely solely on browser-based validation of input data. A browser may not implement certain validation features, meaning the user could post any type of data. For example, older browsers don't validate number fields, so a user can type in a number outside the range we are expecting. Furthermore, a malicious user could try to send harmful data without using a browser at all. The browser validation should be considered as a nicety for the user and that's all.</li>
				<li>The browser does not allow us to do cross-field validation. For example, we can use the <strong class="source-inline">required</strong> attribute for inputs that are mandatory to be filled in. Often, though, we want to set the <strong class="source-inline">required</strong> attribute, based on the value of another input. For example, the email address input should only be set as <strong class="source-inline">required</strong> if the user has checked the <strong class="source-inline">Register My Email</strong> checkbox.</li>
			</ul>
			<p>The Django Forms library allows you to quickly define a form using a Python class. This is done by creating a subclass of the base Django <strong class="source-inline">Form</strong> class. You can then use an instance of this class to render the form in your template and validate the input data. We refer to our classes as forms, similar to how we subclass Django models to create our own <strong class="source-inline">Model</strong> classes. Forms contain one or more fields of a certain type (such as text fields, number fields, or email fields). You'll notice this sounds like Django models, and forms <em class="italic">are</em> similar to models but use different field classes. You can even automatically create a form from a model – we will cover this in <em class="italic">Chapter 7</em>,<em class="italic"> Advanced Form Validation and Model Forms</em>.</p>
			<h2 id="_idParaDest-205"><a id="_idTextAnchor220"/>Defining a Form</h2>
			<p>Creating a Django form is similar to creating a Django model. You define a class that inherits from the <strong class="source-inline">django.forms.Form</strong> class. The class has attributes, which are instances of different <strong class="source-inline">django.forms.Field</strong> subclasses. When rendered, the attribute name in the class corresponds to its input <strong class="source-inline">name</strong> in HTML. To give you a quick idea of what fields there are, some examples are <strong class="source-inline">CharField</strong>, <strong class="source-inline">IntegerField</strong>, <strong class="source-inline">BooleanField</strong>, <strong class="source-inline">ChoiceField</strong>, and <strong class="source-inline">DateField</strong>. Each field generally corresponds to one input when rendered in HTML, but there's not always a one-to-one mapping between a form field class and an input type. Form fields are more coupled to the type of data they collect rather than how they are displayed.</p>
			<p>To illustrate this, consider a <strong class="source-inline">text</strong> input and a <strong class="source-inline">password</strong> input. They both accept some typed-in text data, but the main difference between them is that the text is visibly displayed in a <strong class="source-inline">text</strong> input, whereas with a <strong class="source-inline">password</strong> input the text is obscured. In a Django form, both of these fields are represented using <strong class="source-inline">CharField</strong>. The difference in how they are displayed is set by changing the <em class="italic">widget</em> the field is using.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">If you're not familiar with the word <em class="italic">widget</em>, it is a term to describe the actual input that is being interacted with and how it is displayed. Text inputs, password inputs, select menus, checkboxes, and buttons are all examples of different widgets. The inputs we have seen in HTML correspond one-to-one with widgets. In Django, this is not the case, and the same type of <strong class="source-inline">Field</strong> class can be rendered in multiple ways depending on the widget that is specified.</p>
			<p>Django defines a number of <strong class="source-inline">Widget</strong> classes that define how a <strong class="source-inline">Field</strong> should be rendered as HTML. They inherit from <strong class="source-inline">django.forms.widgets.Widget</strong>. A widget can be passed to the <strong class="source-inline">Field</strong> constructor to change how it is rendered. For example, a <strong class="source-inline">CharField</strong> instance renders as <strong class="source-inline">text</strong> <strong class="source-inline">&lt;input&gt;</strong> by default. If we use the <strong class="source-inline">PasswordInput</strong> widget, it will instead render as <strong class="source-inline">password</strong> <strong class="source-inline">&lt;input&gt;</strong>. The other widgets we will use are as follows:</p>
			<ul>
				<li><strong class="source-inline">RadioSelect</strong>, which renders a <strong class="source-inline">ChoiceField</strong> instance as radio buttons instead of a <strong class="source-inline">&lt;select&gt;</strong> menu</li>
				<li><strong class="source-inline">Textarea</strong>, which renders a <strong class="source-inline">CharField</strong> instance as <strong class="source-inline">&lt;textarea&gt;</strong></li>
				<li><strong class="source-inline">HiddenInput</strong>, which renders a field as a hidden <strong class="source-inline">&lt;input&gt;</strong></li>
			</ul>
			<p>We will look at an example form and add fields and features one by one. First, let's just create a form with a text input and a password input:</p>
			<p class="source-code">from django import forms</p>
			<p class="source-code">class ExampleForm(forms.Form):</p>
			<p class="source-code">    text_input = forms.CharField()</p>
			<p class="source-code">    password_input = forms.CharField(widget=forms.PasswordInput)</p>
			<p>The <strong class="source-inline">widget</strong> argument can be just a widget subclass, which can be fine a lot of the time. If you want to further customize the display of the input and its attributes, you can set the widget argument to an instance of the <strong class="source-inline">widget</strong> class instead. We will look at further customizing widget displays soon. In this case, we're using just the <strong class="source-inline">PasswordInput</strong> class, since we are not customizing it beyond changing the type of input being displayed.</p>
			<p>When the form is rendered in a template, it looks like this:</p>
			<div>
				<div id="_idContainer236" class="IMG---Figure">
					<img src="image/B15509_06_17.jpg" alt="Figure 6.17: Django form rendered in a browser&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.17: Django form rendered in a browser</p>
			<p>Note that the inputs do not contain any content when the page loads; the text has been entered to illustrate the different input types.</p>
			<p>If we examine the page source, we can see the HTML that Django generates. For the first two fields, it looks like this (some spacing added for readability):</p>
			<p class="source-code">&lt;p&gt;</p>
			<p class="source-code">    &lt;label for="id_text_input"&gt;Text input:&lt;/label&gt;</p>
			<p class="source-code">    &lt;input type="text" name="text_input" required id="id_text_input"&gt;</p>
			<p class="source-code">&lt;/p&gt;</p>
			<p class="source-code">&lt;p&gt;</p>
			<p class="source-code">    &lt;label for="id_password_input"&gt;Password input:&lt;/label&gt;</p>
			<p class="source-code">    &lt;input type="password" name="password_input" required id="id_password_input"&gt;</p>
			<p class="source-code">&lt;/p&gt;</p>
			<p>Notice that Django has automatically generated a <strong class="source-inline">label</strong> instance with its text derived from the field name. The <strong class="source-inline">name</strong> and <strong class="source-inline">id</strong> attributes have been set automatically. Django also automatically adds the <strong class="source-inline">required</strong> attribute to the input. Similar to model fields, form field constructors also accept a <strong class="source-inline">required</strong> argument – this defaults to <strong class="source-inline">True</strong>. Setting this to <strong class="source-inline">False</strong> removes the <strong class="source-inline">required</strong> attribute from the generated HTML.</p>
			<p>Next, we'll look at how a checkbox is added to the form:</p>
			<ul>
				<li>A checkbox is represented with <strong class="source-inline">BooleanField</strong>, as it can have only two values, checked or unchecked. It's added to the form in the same way as the other field:<p class="source-code">class ExampleForm(forms.Form):</p><p class="source-code">    …</p><p class="source-code">    checkbox_on = forms.BooleanField()</p><p>The HTML that Django generates for this new field is similar to the previous two fields:</p><p class="source-code">&lt;label for="id_checkbox_on"&gt;Checkbox on:&lt;/label&gt; </p><p class="source-code">&lt;input type="checkbox" name="checkbox_on" required id="id_checkbox_on"&gt;</p></li>
			</ul>
			<p>Next are the select inputs:</p>
			<ul>
				<li>We need to provide a list of choices to display in the <strong class="source-inline">&lt;select&gt;</strong> dropdown.</li>
				<li>The field class constructor takes a <strong class="source-inline">choices</strong> argument. The choices are provided as a tuple of two-element tuples. The first element in each sub-tuple is the value of the choice and the second element is the text or description of the choice. For example, choices could be defined like this:<p class="source-code">BOOK_CHOICES = (('1', 'Deep Learning with Keras'),\</p><p class="source-code">                ('2', 'Web Development with Django'),\</p><p class="source-code">                ('3', 'Brave New World'),\</p><p class="source-code">                ('4', 'The Great Gatsby'))</p><p>Note that you can use lists instead of tuples if you want (or a combination of the two). This can be useful if you want your choices to be mutable:</p><p class="source-code">BOOK_CHOICES = (['1', 'Deep Learning with Keras'],\</p><p class="source-code">                ['2', 'Web Development with Django'],\</p><p class="source-code">                ['3', 'Brave New World'],\</p><p class="source-code">                ['4', 'The Great Gatsby']]</p></li>
				<li>To implement <strong class="source-inline">optgroup</strong>, we can nest the choices. To implement the choices the same way as our previous examples, we use a structure like this:<p class="source-code">BOOK_CHOICES = (('Non-Fiction', \</p><p class="source-code">                 (('1', 'Deep Learning with Keras'),\</p><p class="source-code">                 ('2', 'Web Development with Django'))),\</p><p class="source-code">                ('Fiction', \</p><p class="source-code">                 (('3', 'Brave New World'),\</p><p class="source-code">                  ('4', 'The Great Gatsby'))))</p><p>The <strong class="source-inline">select</strong> functionality is added to the form by using a <strong class="source-inline">ChoiceField</strong> instance. The widget defaults to a <strong class="source-inline">select</strong> input so no configuration is necessary apart from setting <strong class="source-inline">choices</strong>:</p><p class="source-code">class ExampleForm(forms.Form):</p><p class="source-code">    …</p><p class="source-code">    favorite_book = forms.ChoiceField(choices=BOOK_CHOICES)</p></li>
			</ul>
			<p>This is the HTML that is generated:</p>
			<p class="source-code">&lt;label for="id_favorite_book"&gt;Favorite book:&lt;/label&gt;</p>
			<p class="source-code">&lt;select name="favorite_book" id="id_favorite_book"&gt;</p>
			<p class="source-code">    &lt;optgroup label="Non-Fiction"&gt;</p>
			<p class="source-code">        &lt;option value="1"&gt;Deep Learning with Keras&lt;/option&gt;</p>
			<p class="source-code">        &lt;option value="2"&gt;Web Development with Django&lt;/option&gt;</p>
			<p class="source-code">    &lt;/optgroup&gt;</p>
			<p class="source-code">    &lt;optgroup label="Fiction"&gt;</p>
			<p class="source-code">        &lt;option value="3"&gt;Brave New World&lt;/option&gt;</p>
			<p class="source-code">        &lt;option value="4"&gt;The Great Gatsby&lt;/option&gt;</p>
			<p class="source-code">    &lt;/optgroup&gt;</p>
			<p class="source-code">&lt;/select&gt;</p>
			<p>Making a multiple select requires the use of <strong class="source-inline">MultipleChoiceField</strong>. It takes a <strong class="source-inline">choices</strong> argument in the same format as the regular <strong class="source-inline">ChoiceField</strong> for single selects:</p>
			<p class="source-code">class ExampleForm(forms.Form):</p>
			<p class="source-code">    …</p>
			<p class="source-code">    books_you_own = forms.MultipleChoiceField(choices=BOOK_CHOICES)</p>
			<p>And its HTML is similar to that of the single select, except it has the <strong class="source-inline">multiple</strong> attribute added:</p>
			<p class="source-code">&lt;label for="id_books_you_own"&gt;Books you own:&lt;/label&gt;</p>
			<p class="source-code">&lt;select name="books_you_own" required id="id_books_you_own" multiple&gt;</p>
			<p class="source-code">    &lt;optgroup label="Non-Fiction"&gt;</p>
			<p class="source-code">        &lt;option value="1"&gt;Deep Learning with Keras&lt;/option&gt;</p>
			<p class="source-code">        &lt;option value="2"&gt;Web Development with Django&lt;/option&gt;</p>
			<p class="source-code">    &lt;/optgroup&gt;</p>
			<p class="source-code">    &lt;optgroup label="Fiction"&gt;</p>
			<p class="source-code">        &lt;option value="3"&gt;Brave New World&lt;/option&gt;</p>
			<p class="source-code">        &lt;option value="4"&gt;The Great Gatsby&lt;/option&gt;</p>
			<p class="source-code">    &lt;/optgroup&gt;</p>
			<p class="source-code">&lt;/select&gt;</p>
			<p>Choices can also be set after the form is instantiated. You may want to generate the choices <strong class="source-inline">list</strong>/<strong class="source-inline">tuple</strong> inside your view dynamically and then assign it to the field's <strong class="source-inline">choices</strong> attribute. See the following, for example:</p>
			<p class="source-code">form = ExampleForm()</p>
			<p class="source-code">form.fields["books_you_own"].choices = \</p>
			<p class="source-code">[("1", "Deep Learning with Keras"), …]</p>
			<p>Next are the radio inputs, which are similar to selects:</p>
			<ul>
				<li>Like selects, radio inputs use <strong class="source-inline">ChoiceField</strong>, as they provide a single choice between multiple options. </li>
				<li>The options to choose between are passed into the field constructor with the <strong class="source-inline">choices</strong> argument. </li>
				<li>The choices are provided as a tuple of two-element tuples, also like selects:</li>
			</ul>
			<p class="source-code">choices = (('1', 'Option One'),\</p>
			<p class="source-code">           ('2', 'Option Two'),\</p>
			<p class="source-code">           ('3', 'Option Three'))</p>
			<p><strong class="source-inline">ChoiceField</strong> defaults to displaying as a <strong class="source-inline">select</strong> input, so the widget must be set to <strong class="source-inline">RadioSelect</strong> to have it rendered as radio buttons. Putting the choice setting together with this, we add radio buttons to the form like this:</p>
			<p class="source-code">RADIO_CHOICES = (('Value One', 'Value One'),\</p>
			<p class="source-code">                 ('Value Two', 'Value Two'),\</p>
			<p class="source-code">                 ('Value Three', 'Value Three'))</p>
			<p class="source-code">class ExampleForm(forms.Form):</p>
			<p class="source-code">    …</p>
			<p class="source-code">    radio_input = forms.ChoiceField(choices=RADIO_CHOICES,\</p>
			<p class="source-code">                                    widget=forms.RadioSelect)</p>
			<p>Here is the HTML that is generated:</p>
			<p class="source-code">&lt;label for="id_radio_input_0"&gt;Radio input:&lt;/label&gt; </p>
			<p class="source-code">&lt;ul id="id_radio_input"&gt;</p>
			<p class="source-code">&lt;li&gt;</p>
			<p class="source-code">    &lt;label for="id_radio_input_0"&gt;</p>
			<p class="source-code">        &lt;input type="radio" name="radio_input"          value="Value One" required id="id_radio_input_0"&gt;</p>
			<p class="source-code">        Value One</p>
			<p class="source-code">    &lt;/label&gt;</p>
			<p class="source-code">&lt;/li&gt;</p>
			<p class="source-code">&lt;li&gt;</p>
			<p class="source-code">    &lt;label for="id_radio_input_1"&gt;</p>
			<p class="source-code">        &lt;input type="radio" name="radio_input"          value="Value Two" required id="id_radio_input_1"&gt;</p>
			<p class="source-code">        Value Two</p>
			<p class="source-code">    &lt;/label&gt;</p>
			<p class="source-code">&lt;/li&gt;</p>
			<p class="source-code">&lt;li&gt;</p>
			<p class="source-code">    &lt;label for="id_radio_input_2"&gt;</p>
			<p class="source-code">        &lt;input type="radio" name="radio_input"          value="Value Three" required id="id_radio_input_2"&gt;</p>
			<p class="source-code">        Value Three</p>
			<p class="source-code">    &lt;/label&gt;</p>
			<p class="source-code">&lt;/li&gt;</p>
			<p class="source-code">&lt;/ul&gt;</p>
			<p>Django automatically generates a unique label and ID for each of the three radio buttons:</p>
			<ul>
				<li>To create a <strong class="source-inline">textarea</strong> instance, use <strong class="source-inline">CharField</strong> with a <strong class="source-inline">Textarea</strong> widget:<p class="source-code">class ExampleForm(forms.Form):</p><p class="source-code">    …</p><p class="source-code">    text_area = forms.CharField(widget=forms.Textarea)</p><p>You might notice that <strong class="source-inline">textarea</strong> is much larger than the previous ones we have seen (see the following figure):</p><div id="_idContainer237" class="IMG---Figure"><img src="image/B15509_06_18.jpg" alt="Figure 6.18: Normal textarea (top) versus Django's default textarea (bottom)&#13;&#10;"/></div></li>
			</ul>
			<p class="figure-caption">Figure 6.18: Normal textarea (top) versus Django's default textarea (bottom)</p>
			<p>This is because Django automatically adds <strong class="source-inline">cols</strong> and <strong class="source-inline">rows</strong> attributes. These set the number of columns and rows, respectively, that the text field displays:</p>
			<p class="source-code">&lt;label for="id_text_area"&gt;Text area:&lt;/label&gt;</p>
			<p class="source-code">&lt;textarea name="text_area" cols="40"  rows="10" required id="id_text_area"&gt;&lt;/textarea&gt;</p>
			<ul>
				<li>Note that the <strong class="source-inline">cols</strong> and <strong class="source-inline">rows</strong> settings do not affect the amount of text that can be entered into a field, only the amount that is displayed at a time. Also note that the size of <strong class="source-inline">textarea</strong> can be set using CSS (for example, the <strong class="source-inline">height</strong> and <strong class="source-inline">width</strong> properties). This will override the <strong class="source-inline">cols</strong> and <strong class="source-inline">rows</strong> settings.<p>To create <strong class="source-inline">number</strong> inputs, you might expect Django to have a <strong class="source-inline">NumberField</strong> type, but it does not.</p><p>Remember that the Django form fields are data-centric rather than display-centric, so instead, Django provides different <strong class="source-inline">Field</strong> classes depending on what type of numeric data you want to store:</p></li>
				<li>For integers, use <strong class="source-inline">IntegerField</strong>.</li>
				<li>For floating-point numbers, use <strong class="source-inline">FloatField</strong> or <strong class="source-inline">DecimalField</strong>. The latter two differ in how they convert their data to a Python value. </li>
				<li><strong class="source-inline">FloatField</strong> will convert to a float while <strong class="source-inline">DecimalField</strong> is a decimal.</li>
				<li>Decimal values offer better accuracy in representing numbers than float values but may not integrate well into your existing Python code.</li>
			</ul>
			<p>We'll add all three fields to the form at once:</p>
			<p class="source-code">class ExampleForm(forms.Form):</p>
			<p class="source-code">    …</p>
			<p class="source-code">    integer_input = forms.IntegerField()</p>
			<p class="source-code">    float_input = forms.FloatField()</p>
			<p class="source-code">    decimal_input = forms.DecimalField()</p>
			<p>Here's the HTML for all three:</p>
			<p class="source-code">&lt;p&gt;</p>
			<p class="source-code">    &lt;label for="id_integer_input"&gt;Integer input:&lt;/label&gt;</p>
			<p class="source-code">    &lt;input type="number" name="integer_input"      required id="id_integer_input"&gt;</p>
			<p class="source-code">&lt;/p&gt;</p>
			<p class="source-code">&lt;p&gt;</p>
			<p class="source-code">    &lt;label for="id_float_input"&gt;Float input:&lt;/label&gt;</p>
			<p class="source-code">    &lt;input type="number" name="float_input"      step="any" required id="id_float_input"&gt;</p>
			<p class="source-code">&lt;/p&gt;</p>
			<p class="source-code">&lt;p&gt;</p>
			<p class="source-code">    &lt;label for="id_decimal_input"&gt;Decimal       input:&lt;/label&gt;</p>
			<p class="source-code">    &lt;input type="number" name="decimal_input"      step="any" required id="id_decimal_input"&gt;</p>
			<p class="source-code">&lt;/p&gt;</p>
			<p>The <strong class="source-inline">IntegerField</strong> generated HTML is missing the <strong class="source-inline">step</strong> attribute that the other two have, which means the widget will only accept integer values. The other two fields (<strong class="source-inline">FloatField</strong> and <strong class="source-inline">DecimalField</strong>) generate very similar HTML. Their behavior is the same in the browser; they differ only when their values are used in Django code.</p>
			<p>As you might have guessed, an <strong class="source-inline">email</strong> input can be created with <strong class="source-inline">EmailField</strong>:</p>
			<p class="source-code">class ExampleForm(forms.Form):</p>
			<p class="source-code">    …</p>
			<p class="source-code">    email_input = forms.EmailField()</p>
			<p>Its HTML is similar to the <strong class="source-inline">email</strong> input we created manually:</p>
			<p class="source-code">&lt;label for="id_email_input"&gt;Email input:&lt;/label&gt;</p>
			<p class="source-code">&lt;input type="email" name="email_input" required id="id_email_input"&gt;</p>
			<p>Following our manually created form, the next field we will look at is <strong class="source-inline">DateField</strong>:</p>
			<ul>
				<li>By default, Django will render <strong class="source-inline">DateField</strong> as <strong class="source-inline">text</strong> input, and the browser will not show a calendar popup when the field is clicked.</li>
			</ul>
			<p>We can add <strong class="source-inline">DateField</strong> to the form with no arguments, like this:</p>
			<p class="source-code">class ExampleForm(forms.Form):</p>
			<p class="source-code">    …</p>
			<p class="source-code">    date_input = forms.DateField()</p>
			<p>When rendered, it just looks like a normal <strong class="source-inline">text</strong> input:</p>
			<div>
				<div id="_idContainer238" class="IMG---Figure">
					<img src="image/B15509_06_19.jpg" alt="Figure 6.19: Default DateField display in a form&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.19: Default DateField display in a form</p>
			<p>Here is the HTML generated by default:</p>
			<p class="source-code">&lt;label for="id_date_input"&gt;Date input:&lt;/label&gt;</p>
			<p class="source-code">&lt;input type="text" name="date_input" required id="id_date_input"&gt;</p>
			<p>The reason for using a <strong class="source-inline">text</strong> input is that it allows the user to enter the date in a number of different formats. For example, by default, the user can type in the date in <em class="italic">Year-Month-Day</em> (dash-separated) or <em class="italic">Month/Day/Year</em> (slash-separated) formats. The accepted formats can be specified by passing a list of formats to the <strong class="source-inline">DateField</strong> constructor using the <strong class="source-inline">input_formats</strong> argument. For example, we could accept dates in the formats of <em class="italic">Day/Month/Year</em> or <em class="italic">Day/Month/Year-with-century</em>, like this: </p>
			<p class="source-code">DateField(input_formats = ['%d/m/%y', '%d/%m/%Y'])</p>
			<p>We can override any attributes on a field's widget by passing the <strong class="source-inline">attrs</strong> argument to the widget constructor. This accepts a dictionary of attribute key/values that will be rendered into the input's HTML.</p>
			<p>We have not used this yet, but we will see it again in the next chapter when we customize the field rendering further. For now, we'll just set one attribute, <strong class="source-inline">type</strong>, that will overwrite the default input type:</p>
			<p class="source-code">class ExampleForm(forms.Form):</p>
			<p class="source-code">    …</p>
			<p class="source-code">    date_input = forms.DateField\</p>
			<p class="source-code">                 (widget=forms.DateInput(attrs={'type': 'date'}))</p>
			<p>When rendered, it now looks like the date field we had before, and clicking on it brings up the calendar date picker:</p>
			<div>
				<div id="_idContainer239" class="IMG---Figure">
					<img src="image/B15509_06_20.jpg" alt="Figure 6.20: DateField with date input&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.20: DateField with date input</p>
			<p>Examining the generated HTML now, we can see it uses the <strong class="source-inline">date</strong> type:</p>
			<p class="source-code">&lt;label for="id_date_input"&gt;Date input:&lt;/label&gt;</p>
			<p class="source-code">&lt;input type="date" name="date_input" required id="id_date_input"&gt;</p>
			<p>The final input that we are missing is the hidden input.</p>
			<p>Once again, due to the data-centric nature of Django forms, there is no <strong class="source-inline">HiddenField</strong>. Instead, we choose the type of field that needs to be hidden and set its <strong class="source-inline">widget</strong> to <strong class="source-inline">HiddenInput</strong>. We can then set the value of the field using the field constructor's <strong class="source-inline">initial</strong> argument:</p>
			<p class="source-code">class ExampleForm(forms.Form):</p>
			<p class="source-code">    …</p>
			<p class="source-code">    hidden_input = forms.CharField\</p>
			<p class="source-code">                   (widget=forms.HiddenInput, \</p>
			<p class="source-code">                    initial='Hidden Value')</p>
			<p>Here is the generated HTML:</p>
			<p class="source-code">&lt;input type="hidden" name="hidden_input"  value="Hidden Value" id="id_hidden_input"&gt;</p>
			<p>Note that as this is a <strong class="source-inline">hidden</strong> input, Django does not generate a <strong class="source-inline">label</strong> instance or any surrounding <strong class="source-inline">p</strong> elements. There are other form fields that Django provides that work in similar ways. These range from <strong class="source-inline">DateTimeField</strong> (for capturing a date and time) to <strong class="source-inline">GenericIPAddressField</strong> (for either IPv4 or IPv6 addresses) and <strong class="source-inline">URLField</strong> (for URLs). A full list of fields is available at <a href="https://docs.djangoproject.com/en/3.0/ref/forms/fields/">https://docs.djangoproject.com/en/3.0/ref/forms/fields/</a>.</p>
			<h2 id="_idParaDest-206"><a id="_idTextAnchor221"/>Rendering a Form in a Template</h2>
			<p>We've now seen how to create a form and add fields, and we've seen what the form looks like and what HTML is generated. But how is the form actually rendered in the template? We simply instantiate the <strong class="source-inline">Form</strong> class and pass it to the <strong class="source-inline">render</strong> function in a view, using the context, just like any other variable.</p>
			<p>For example, here's how to pass our <strong class="source-inline">ExampleForm</strong> to a template:</p>
			<p class="source-code">def view_function(request):</p>
			<p class="source-code">    form = ExampleForm()</p>
			<p class="source-code">    return render(request, "template.html", {"form": form})</p>
			<p>Django does not add the <strong class="source-inline">&lt;form&gt;</strong> element or submit button(s) for you when rendering the template; you should add these around where your form is placed in the template. The form can be rendered like any other variable.</p>
			<p>We mentioned briefly earlier that the form is rendered in the template using the <strong class="source-inline">as_p</strong> method. This layout method was chosen as it most closely matches the example form we built manually. Django offers three layout methods that can be used:</p>
			<ul>
				<li><strong class="source-inline">as_table</strong><p>The form is rendered as table rows, with each input on its own row. Django does not generate the surrounding <strong class="source-inline">table</strong> element, so you should wrap the form yourself. See the following example:</p><p class="source-code">&lt;form method="post"&gt;</p><p class="source-code">    &lt;table&gt;</p><p class="source-code">        {{ form.as_table }}</p><p class="source-code">    &lt;/table&gt;</p><p class="source-code">&lt;/form&gt;</p><p><strong class="source-inline">as_table</strong> is the default rendering method, so <strong class="source-inline">{{ form.as_table }}</strong> and <strong class="source-inline">{{ form }}</strong> are equivalent. When rendered, the form looks like this:</p><div id="_idContainer240" class="IMG---Figure"><img src="image/B15509_06_21.jpg" alt="Figure 6.21: Form rendered as a table&#13;&#10;"/></div></li>
			</ul>
			<p class="figure-caption">Figure 6.21: Form rendered as a table</p>
			<p>Here is a small sample of HTML that is generated:</p>
			<p class="source-code">&lt;tr&gt;</p>
			<p class="source-code">    &lt;th&gt;</p>
			<p class="source-code">        &lt;label for="id_text_input"&gt;Text input:&lt;/label&gt;</p>
			<p class="source-code">    &lt;/th&gt;</p>
			<p class="source-code">    &lt;td&gt;</p>
			<p class="source-code">        &lt;input type="text" name="text_input" required id="id_text_input"&gt;</p>
			<p class="source-code">    &lt;/td&gt;</p>
			<p class="source-code">&lt;/tr&gt;</p>
			<p class="source-code">&lt;tr&gt;</p>
			<p class="source-code">    &lt;th&gt;</p>
			<p class="source-code">        &lt;label for="id_password_input"&gt;Password input:&lt;/label&gt;</p>
			<p class="source-code">    &lt;/th&gt;</p>
			<p class="source-code">    &lt;td&gt;</p>
			<p class="source-code">        &lt;input type="password" name="password_input" required id="id_password_input"&gt;</p>
			<p class="source-code">    &lt;/td&gt;</p>
			<p class="source-code">&lt;/tr&gt;</p>
			<ul>
				<li><strong class="source-inline">as_ul</strong><p>This renders the form fields as list items (<strong class="source-inline">li</strong>) inside either a <strong class="source-inline">ul</strong> or <strong class="source-inline">ol</strong> element. Like with <strong class="source-inline">as_table</strong>, the containing element (<strong class="source-inline">&lt;ul&gt;</strong> or <strong class="source-inline">&lt;ol&gt;</strong>) is not created by Django and must be added by you:</p><p class="source-code">&lt;form method="post"&gt;</p><p class="source-code">    &lt;ul&gt;</p><p class="source-code">        {{ form.as_ul }}</p><p class="source-code">    &lt;/ul&gt;</p><p class="source-code">&lt;/form&gt;</p><p>Here's how the form renders using <strong class="source-inline">as_ul</strong>:</p><p> </p><div id="_idContainer241" class="IMG---Figure"><img src="image/B15509_06_22.jpg" alt="Figure 6.22: Form rendered using as_ul&#13;&#10;"/></div></li>
			</ul>
			<p class="figure-caption">Figure 6.22: Form rendered using as_ul</p>
			<p>And here's a sample of the generated HTML:</p>
			<p class="source-code">&lt;li&gt;</p>
			<p class="source-code">    &lt;label for="id_text_input"&gt;Text input:&lt;/label&gt;</p>
			<p class="source-code">    &lt;input type="text" name="text_input" required id="id_text_input"&gt;</p>
			<p class="source-code">&lt;/li&gt;</p>
			<p class="source-code">&lt;li&gt;</p>
			<p class="source-code">    &lt;label for="id_password_input"&gt;Password input:&lt;/label&gt;</p>
			<p class="source-code">    &lt;input type="password" name="password_input" required id="id_password_input"&gt;</p>
			<p class="source-code">&lt;/li&gt;</p>
			<ul>
				<li><strong class="source-inline">as_p</strong><p>Finally, there is the <strong class="source-inline">as_p</strong> method, which we were using in our previous examples. Each input is wrapped within <strong class="source-inline">p</strong> tags, which means that you don't have to wrap the form manually (in <strong class="source-inline">&lt;table&gt;</strong> or <strong class="source-inline">&lt;ul&gt;</strong>) like you did with the previous methods:</p><p class="source-code">&lt;form method="post"&gt;</p><p class="source-code">    {{ form.as_p }}</p><p class="source-code">&lt;/form&gt;</p><p>Here's what the rendered form looks like:</p><div id="_idContainer242" class="IMG---Figure"><img src="image/B15509_06_23.jpg" alt="Figure 6.23: Form rendered using as_p&#13;&#10;"/></div></li>
			</ul>
			<p class="figure-caption">Figure 6.23: Form rendered using as_p</p>
			<p>And you've seen this before, but once again, here's a sample of the HTML generated:</p>
			<p class="source-code">&lt;p&gt;</p>
			<p class="source-code">    &lt;label for="id_text_input"&gt;Text input:&lt;/label&gt;</p>
			<p class="source-code">    &lt;input type="text" name="text_input" required id="id_text_input"&gt;</p>
			<p class="source-code">&lt;/p&gt;</p>
			<p class="source-code">&lt;p&gt;</p>
			<p class="source-code">    &lt;label for="id_password_input"&gt;Password input:&lt;/label&gt;</p>
			<p class="source-code">    &lt;input type="password" name="password_input" required       id="id_password_input"&gt;</p>
			<p class="source-code">&lt;/p&gt;</p>
			<p>It is up to you to decide which method you want to use to render your form, depending on which suits your application best. In terms of their behavior and use with your view, all of the methods are all identical. In <em class="italic">Chapter 15</em>, <em class="italic">Django Third Party Libraries</em>, we will also introduce a method of rendering forms that will make use of the Bootstrap CSS classes.</p>
			<p>Now that we have been introduced to Django Forms, we can now update our example form page to use a Django Form instead of manually writing all the HTML ourselves.</p>
			<h2 id="_idParaDest-207"><a id="_idTextAnchor222"/>Exercise 6.03: Building and Rendering a Django Form</h2>
			<p>In this exercise, you will build a Django form using all the fields we have seen. The form and view will behave similarly to the form that we built manually; however, you will be able to see how much less code is required when writing forms using Django. Your form will also automatically get field validation, and if we make changes to the form, we don't have to then make changes to the HTML, as it will update dynamically based on the form definition:</p>
			<ol>
				<li value="1">In PyCharm, create a new file called <strong class="source-inline">forms.py</strong> inside the <strong class="source-inline">form_example</strong> app directory.</li>
				<li>Import the Django <strong class="source-inline">forms</strong> library at the top of your <strong class="source-inline">forms.py</strong> file:<p class="source-code">from django import forms</p></li>
				<li>Define the choices for the radio buttons by creating a <strong class="source-inline">RADIO_CHOICES</strong> variable. Populate it as follows:<p class="source-code">RADIO_CHOICES = (("Value One", "Value One Display"),\</p><p class="source-code">                 ("Value Two", "Text For Value Two"),\</p><p class="source-code">                 ("Value Three", "Value Three's Display Text"))</p><p>You will use this soon when you create a <strong class="source-inline">ChoiceField</strong> instance called <strong class="source-inline">radio_input</strong>.</p></li>
				<li>Define the nested choices for the book select inputs by creating a <strong class="source-inline">BOOK_CHOICES</strong> variable. Populate it as follows:<p class="source-code">BOOK_CHOICES = (("Non-Fiction", \</p><p class="source-code">                 (("1", "Deep Learning with Keras"),\</p><p class="source-code">                  ("2", "Web Development with Django"))),\</p><p class="source-code">                 ("Fiction", \</p><p class="source-code">                  (("3", "Brave New World"),\</p><p class="source-code">                   ("4", "The Great Gatsby"))))</p></li>
				<li>Create a class called <strong class="source-inline">ExampleForm</strong> that inherits from the <strong class="source-inline">forms.Form</strong> class:<p class="source-code">class ExampleForm(forms.Form):</p><p>Add all of the following fields as attributes on the class:</p><p class="source-code">    text_input = forms.CharField()</p><p class="source-code">    password_input = forms.CharField\</p><p class="source-code">                     (widget=forms.PasswordInput)</p><p class="source-code">    checkbox_on = forms.BooleanField()</p><p class="source-code">    radio_input = forms.ChoiceField\</p><p class="source-code">                  (choices=RADIO_CHOICES, \</p><p class="source-code">                   widget=forms.RadioSelect)</p><p class="source-code">    favorite_book = forms.ChoiceField(choices=BOOK_CHOICES)</p><p class="source-code">    books_you_own = forms.MultipleChoiceField\</p><p class="source-code">                    (choices=BOOK_CHOICES)</p><p class="source-code">    text_area = forms.CharField(widget=forms.Textarea)</p><p class="source-code">    integer_input = forms.IntegerField()</p><p class="source-code">    float_input = forms.FloatField()</p><p class="source-code">    decimal_input = forms.DecimalField()</p><p class="source-code">    email_input = forms.EmailField()</p><p class="source-code">    date_input = forms.DateField\</p><p class="source-code">                 (widget=forms.DateInput\</p><p class="source-code">                         (attrs={"type": "date"}))</p><p class="source-code">    hidden_input = forms.CharField\</p><p class="source-code">                   (widget=forms.HiddenInput, initial="Hidden Value")</p><p>Save the file. </p></li>
				<li>Open your <strong class="source-inline">form_example</strong> app's <strong class="source-inline">views.py</strong> file. At the top of the file, add a line to import <strong class="source-inline">ExampleForm</strong> from your <strong class="source-inline">forms.py</strong> file:<p class="source-code">from .forms import ExampleForm</p></li>
				<li>Inside the <strong class="source-inline">form_example</strong> view, instantiate the <strong class="source-inline">ExampleForm</strong> class and assign it to the <strong class="source-inline">form</strong> variable:<p class="source-code">    form = ExampleForm()</p></li>
				<li>Add the <strong class="source-inline">form</strong> variable into the context dictionary, using the <strong class="source-inline">form</strong> key. The <strong class="source-inline">return</strong> line should look like this:<p class="source-code">    return render(request, "form-example.html",\</p><p class="source-code">                  {"method": request.method, "form": form})</p><p>Save the file. Make sure you haven't removed the code that prints out the data the form has sent, as we will use it again later in this exercise.</p></li>
				<li>Open the <strong class="source-inline">form-example.html</strong> file, inside the <strong class="source-inline">form_example</strong> app's <strong class="source-inline">templates</strong> directory. You can remove nearly all of the contents of the <strong class="source-inline">form</strong> element, except the <strong class="source-inline">{% csrf_token %}</strong> template tag and the submit buttons. When you're done, it should look like this:<p class="source-code">&lt;form method="post"&gt;</p><p class="source-code">    {% csrf_token %}</p><p class="source-code">    &lt;p&gt;</p><p class="source-code">        &lt;input type="submit" name="submit_input" value="Submit Input"&gt;</p><p class="source-code">    &lt;/p&gt;</p><p class="source-code">    &lt;p&gt;</p><p class="source-code">        &lt;button type="submit" name="button_element" value="Button Element"&gt;</p><p class="source-code">            Button With &lt;strong&gt;Styled&lt;/strong&gt; Text</p><p class="source-code">        &lt;/button&gt;</p><p class="source-code">    &lt;/p&gt;</p><p class="source-code">&lt;/form&gt;</p></li>
				<li>Add a rendering of the <strong class="source-inline">form</strong> variable using the <strong class="source-inline">as_p</strong> method. Put this on the line after the <strong class="source-inline">{%</strong><strong class="source-inline"> csrf_token %}</strong> template tag. The whole <strong class="source-inline">form</strong> element should now look like this:<p class="source-code">&lt;form method="post"&gt;</p><p class="source-code">    {% csrf_token %}</p><p class="source-code">    {{ form.as_p }}</p><p class="source-code">    &lt;p&gt;</p><p class="source-code">        &lt;input type="submit" name="submit_input" value="Submit Input"&gt;</p><p class="source-code">    &lt;/p&gt;</p><p class="source-code">    &lt;p&gt;</p><p class="source-code">        &lt;button type="submit" name="button_element"           value="Button Element"&gt;</p><p class="source-code">            Button With &lt;strong&gt;Styled&lt;/strong&gt; Text</p><p class="source-code">        &lt;/button&gt;</p><p class="source-code">    &lt;/p&gt;</p><p class="source-code">&lt;/form&gt;</p></li>
				<li>Start the Django dev server if it is not already running, then visit the form example page in your browser, at <strong class="source-inline">http://127.0.0.1:8000/form-example/</strong>. It should look as follows:<div id="_idContainer243" class="IMG---Figure"><img src="image/B15509_06_24.jpg" alt="Figure 6.24: Django ExampleForm rendered in the browser&#13;&#10;"/></div><p class="figure-caption">Figure 6.24: Django ExampleForm rendered in the browser</p></li>
				<li>Enter some data in the form – since Django marks all fields as required, you will need to enter some text or select values for all fields, including ensuring that the checkbox is checked. Submit the form.</li>
				<li>Switch back to PyCharm and look in the Debug Console at the bottom of the window. You should see all the values being submitted by the form are printed out to the console, similar to <em class="italic">Exercise 6.02, Working with POST Data in a View</em>:<div id="_idContainer244" class="IMG---Figure"><img src="image/B15509_06_25.jpg" alt="Figure 6.25: Values as submitted by the Django form&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 6.25: Values as submitted by the Django form</p>
			<p>You can see that the values are still strings, and the names match those of the attributes of <strong class="source-inline">ExampleForm</strong> class. Notice that the submit button that you clicked is included, as well as the CSRF token. The form you submit can be a mix of Django form fields and arbitrary fields you add; both will be contained in the <strong class="source-inline">request.POST</strong> <strong class="source-inline">QueryDict</strong> object.</p>
			<p>In this exercise, you created a Django form, with many different types of form fields. You instantiated it into a variable in your view, then passed it to <strong class="source-inline">form-example.html</strong> where it was rendered as HTML. Finally, you submitted the form and looked at the values it posted. Notice that the amount of code we had to write to generate the same form was greatly reduced. We did not have to manually code any HTML and we now have one place that both defines how the form will display and how it will validate. In the next section, we will examine how Django forms can automatically validate the submitted data, as well as how the data is converted from strings to Python objects.</p>
			<h1 id="_idParaDest-208"><a id="_idTextAnchor223"/>Validating Forms and Retrieving Python Values</h1>
			<p>So far, we have seen how Django Forms makes it much simpler to define a form using Python code and have it automatically rendered. We will now look at the other part of what makes Django forms useful: their ability to automatically validate the form and then retrieve native Python objects and values from them.</p>
			<p>In Django, a form can either be <em class="italic">unbound</em> or <em class="italic">bound</em>. These terms describe whether or not the form has had the submitted <strong class="source-inline">POST</strong> data sent to it for validation. So far, we have only seen unbound forms – they are instantiated without arguments, like this:</p>
			<p class="source-code">form = ExampleForm()</p>
			<p>A form is bound if it is called with some data to be used for validation, such as the <strong class="source-inline">POST</strong> data. A bound form can be created like this:</p>
			<p class="source-code">form = ExampleForm(request.POST)</p>
			<p>A bound form allows us to start using built-in validation-related tools: first, the <strong class="source-inline">is_valid</strong> method to check the form's validity, then the <strong class="source-inline">cleaned_data</strong> attribute on the form, which contains the values converted from strings to Python objects. The <strong class="source-inline">cleaned_data</strong> attribute is only available after the form has been <em class="italic">cleaned</em>, which means the process of "cleaning up" the data and converting it from strings to Python objects. The cleaning process runs during the <strong class="source-inline">is_valid</strong> call. You will get <strong class="source-inline">AttributeError</strong> raised if you try to access <strong class="source-inline">cleaned_data</strong> before calling <strong class="source-inline">is_valid</strong>.</p>
			<p>A short example of how to access the cleaned data of <strong class="source-inline">ExampleForm</strong> follows:</p>
			<p class="source-code">form = ExampleForm(request.POST)</p>
			<p class="source-code">if form.is_valid():</p>
			<p class="source-code">    # cleaned_data is only populated if the form is valid</p>
			<p class="source-code">    if form.cleaned_data["integer_input"] &gt; 5:</p>
			<p class="source-code">        do_something()</p>
			<p>In this example, <strong class="source-inline">form.cleaned_data["integer_input"]</strong> is the integer value <strong class="source-inline">10</strong>, so it can be compared to the number <em class="italic">5</em>. Compare this to the value that was posted, which is the string <strong class="source-inline">"10"</strong>. The cleaning process performs this conversion for us. Other fields such as dates or Booleans are converted accordingly.</p>
			<p>The cleaning process also sets any errors on the form and fields that will be displayed when the form is rendered again. Let's see all this in action. Modern browsers provide a large amount of client-side validation, so they prevent forms from being submitted unless their basic validation rules are met. You might have already seen this if you tried to submit the form in the previous exercise with empty fields:</p>
			<div>
				<div id="_idContainer245" class="IMG---Figure">
					<img src="image/B15509_06_26.jpg" alt="Figure 6.26: Form submission prevented by the browser&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.26: Form submission prevented by the browser</p>
			<p><em class="italic">Figure 6.26</em> shows the browser preventing form submission. Since the browser is preventing the submission, Django never gets the opportunity to validate the form itself. To allow the form to be submitted, we need to add some more advanced validation that the browser is unable to validate itself. </p>
			<p>We will discuss the different types of validations that can be applied to form fields in the next section, but for now, we will just add a <strong class="source-inline">max_digits</strong> setting of <strong class="source-inline">3</strong> to <strong class="source-inline">decimal_input</strong> for our <strong class="source-inline">ExampleForm</strong>. This means the user should not enter more than three digits into the form. </p>
			<p class="callout-heading">Note</p>
			<p class="callout">Why should Django validate the form if the browser is already doing this and preventing submission? A server-side application should never trust input from the user: the user might be using an older browser or another HTTP client to send the request, thus not receiving any errors from their "browser." Also, as we have just mentioned, there are types of validation that the browser does not understand, and so Django must validate these on its end.</p>
			<p><strong class="source-inline">ExampleForm</strong> is updated like this:</p>
			<p class="source-code">class ExampleForm(forms.Form):</p>
			<p class="source-code">    …</p>
			<p class="source-code">    decimal_input = forms.DecimalField(max_digits=3)</p>
			<p class="source-code">    …</p>
			<p>Now the view should be updated to pass <strong class="source-inline">request.POST</strong> to the <strong class="source-inline">Form</strong> class when the method is <strong class="source-inline">POST</strong>, for example, like this:</p>
			<p class="source-code">if request.method == "POST":</p>
			<p class="source-code">    form = ExampleForm(request.POST)</p>
			<p class="source-code">else:</p>
			<p class="source-code">    form = ExampleForm()</p>
			<p>If you pass <strong class="source-inline">request.POST</strong> into the form constructor when the method is not <strong class="source-inline">POST</strong>, then the form will always contain errors when first rendered, as <strong class="source-inline">request.POST</strong> will be empty. Now the browser will let us submit the form, but we will get an error displayed if the <strong class="source-inline">decimal_input</strong> contains more than three digits:</p>
			<div>
				<div id="_idContainer246" class="IMG---Figure">
					<img src="image/B15509_06_27.jpg" alt="Figure 6.27: An error displayed when a field is not valid&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.27: An error displayed when a field is not valid</p>
			<p>Django is automatically rendering the form differently in the template when it has errors. But how can we make the view behave differently depending on the validity of the form? As we mentioned earlier, we should use the form's <strong class="source-inline">is_valid</strong> method. A view using this check might have code like this:</p>
			<p class="source-code">form = ExampleForm(request.POST)</p>
			<p class="source-code">if form.is_valid():</p>
			<p class="source-code">    # perform operations with data from form.cleaned_data</p>
			<p class="source-code">    return redirect("/success-page")  # redirect to a success page</p>
			<p>In this example, we are redirecting to a success page if the form is valid. Otherwise, assume the execution flow continues as before and passes the invalid form back to the <strong class="source-inline">render</strong> function to be displayed to the user with errors.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Why do we return a redirect on success? For two reasons: first, an early return prevents the execution of the rest of the view (that is, the failure branch); second, it prevents the message about resending the form data if the user then reloads the page.</p>
			<p>In the next exercise, we will see the form validation in action and change the view execution flow based on the validity of the form.</p>
			<h2 id="_idParaDest-209"><a id="_idTextAnchor224"/>Exercise 6.04: Validating Forms in a View</h2>
			<p>In this exercise, we will update the example view to instantiate the form differently depending on the HTTP method. We will also change the form to print out the cleaned data instead of the raw <strong class="source-inline">POST</strong> data, but only if the form is valid:</p>
			<ol>
				<li value="1">In PyCharm, open the <strong class="source-inline">forms.py</strong> file inside the <strong class="source-inline">form_example</strong> app directory. Add a <strong class="source-inline">max_digits=3 </strong>argument to <strong class="source-inline">decimal_input</strong> of <strong class="source-inline">ExampleForm</strong>:<p class="source-code">class ExampleForm(forms.Form):</p><p class="source-code">    …</p><p class="source-code">    decimal_input = forms.DecimalField(max_digits=3)</p><p>Once this argument is added, we can submit the form, since the browser does not know how to validate this rule, but Django does.</p></li>
				<li>Open the <strong class="source-inline">reviews</strong> app's <strong class="source-inline">views.py</strong> file. We need to update the <strong class="source-inline">form_example</strong> view so that if the request's method is <strong class="source-inline">POST</strong>, the <strong class="source-inline">ExampleForm</strong> is instantiated with the <strong class="source-inline">POST</strong> data; otherwise, it's instantiated without arguments. Replace the current form initialization with this code:<p class="source-code">def form_example(request):</p><p class="source-code">    if request.method == "POST":</p><p class="source-code">        form = ExampleForm(request.POST)</p><p class="source-code">    else:</p><p class="source-code">        form = ExampleForm()</p></li>
				<li>Next, also for the <strong class="source-inline">POST</strong> request method, we will check whether the form is valid using the <strong class="source-inline">is_valid</strong> method. If the form is valid, we will print out all of the cleaned data. Add a condition after the <strong class="source-inline">ExampleForm</strong> instantiation to check <strong class="source-inline">form.is_valid()</strong>, then move the debug print loop inside this condition. Your <strong class="source-inline">POST</strong> branch should look like this:<p class="source-code">    if request.method == "POST":</p><p class="source-code">        form = ExampleForm(request.POST)</p><p class="source-code">        if form.is_valid():</p><p class="source-code">            for name in request.POST:</p><p class="source-code">                print("{}: {}".format\</p><p class="source-code">                               (name, request.POST.getlist(name)))</p></li>
				<li>Instead of iterating over the raw <strong class="source-inline">request.POST</strong> <strong class="source-inline">QueryDict</strong> (in which all the data are <strong class="source-inline">string</strong> instances), we will iterate over <strong class="source-inline">cleaned_data</strong> of <strong class="source-inline">form</strong>. This is a normal dictionary and contains the values converted to Python objects. Replace the <strong class="source-inline">for</strong> line and <strong class="source-inline">print</strong> line with these two:<p class="source-code">            for name, value in form.cleaned_data.items():</p><p class="source-code">                print("{}: ({}) {}".format\</p><p class="source-code">                                    (name, type(value), value))</p><p>We don't need to use <strong class="source-inline">getlist()</strong> anymore, as <strong class="source-inline">cleaned_data</strong> has already converted the multi-value fields into <strong class="source-inline">list</strong> instances.</p></li>
				<li>Start the Django dev server, if it is not already running. Switch to your browser and browse to the example form page at <strong class="source-inline">http://127.0.0.1:8000/form-example/</strong>. The form should look as it did before. Fill in all the fields, but be sure to enter four or more numbers into the <strong class="source-inline">Decimal input</strong> field to make the form invalid. Submit the form, and you should see the error message for <strong class="source-inline">Decimal input</strong> show up when the page refreshes:<div id="_idContainer247" class="IMG---Figure"><img src="image/B15509_06_28.jpg" alt="Figure 6.28: Decimal input error displayed after the form is submitted&#13;&#10;"/></div><p class="figure-caption">Figure 6.28: Decimal input error displayed after the form is submitted</p></li>
				<li>Fix the form errors by making sure only three digits are in the <strong class="source-inline">Decimal input</strong> field, then submit the form again. Switch back to PyCharm and check the debug console. You should see that all the cleaned data has been printed out:<div id="_idContainer248" class="IMG---Figure"><img src="image/B15509_06_29.jpg" alt="Figure 6.29: Cleaned data from the form printed out&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 6.29: Cleaned data from the form printed out</p>
			<p>Notice the conversions that have taken place. The <strong class="source-inline">CharField</strong> instances have been converted to <strong class="source-inline">str</strong>, <strong class="source-inline">BooleanField</strong> to <strong class="source-inline">bool</strong>, and <strong class="source-inline">IntegerField</strong>, <strong class="source-inline">FloatField</strong>, and <strong class="source-inline">DecimalField</strong> to <strong class="source-inline">int</strong>, <strong class="source-inline">float</strong>, and <strong class="source-inline">Decimal</strong>, respectively. <strong class="source-inline">DateField</strong> becomes <strong class="source-inline">datetime.date</strong> and the choice fields retain the string values of their initial choice values. Notice that <strong class="source-inline">books_you_own</strong> is automatically converted to a <strong class="source-inline">list</strong> of <strong class="source-inline">str</strong> instances.</p>
			<p>Also, note that unlike when we iterated over all of the <strong class="source-inline">POST</strong> data, <strong class="source-inline">cleaned_data</strong> only contains form fields. The other data (such as the CSRF token and the submit button that was clicked) is present in the <strong class="source-inline">POST</strong> <strong class="source-inline">QueryDict</strong> but is not included as it does not include form fields.</p>
			<p>In this exercise, you updated <strong class="source-inline">ExampleForm</strong> so the browser allowed it to be submitted even though Django would consider it to be invalid. This allowed Django to perform its validation on the form. You then updated the <strong class="source-inline">form_example</strong> view to instantiate the <strong class="source-inline">ExampleForm</strong> class differently depending on the HTTP method; passing in the request's <strong class="source-inline">POST</strong> data for a <strong class="source-inline">POST</strong> request. The view also had its debug output code updated to <strong class="source-inline">print</strong> out the <strong class="source-inline">cleaned_data</strong> dictionary. Finally, you tested submitting valid and invalid form data to see the different execution paths and the types of data that the form generated. We saw that Django automatically converted the <strong class="source-inline">POST</strong> data from strings to Python types based on the field class.</p>
			<p>Next, we will look at how to add more validation options to fields, which will allow us to more tightly control the values that can be entered.</p>
			<h2 id="_idParaDest-210"><a id="_idTextAnchor225"/>Built-In Field Validation</h2>
			<p>We have not yet discussed the standard validation arguments that can be used on fields. Although we already mentioned the <strong class="source-inline">required</strong> argument (which is <strong class="source-inline">True</strong> by default), many others can be used to more tightly control the data being entered into a field. Here are a few useful ones:</p>
			<ul>
				<li><strong class="source-inline">max_length</strong><p>Sets the maximum number of characters that can be entered into the field; available on <strong class="source-inline">CharField</strong> (and <strong class="source-inline">FileField</strong>, which we will cover in <em class="italic">Chapter 8</em>, <em class="italic">Media Serving and File Uploads</em>).</p></li>
				<li><strong class="source-inline">min_length</strong><p>Sets the minimum number of characters that must be entered into the field; available on <strong class="source-inline">CharField</strong> (and <strong class="source-inline">FileField</strong>; again, more about this in <em class="italic">Chapter 8</em>, <em class="italic">Media Serving and File Uploads</em>).</p></li>
				<li><strong class="source-inline">max_value</strong><p>Sets the maximum value that can be entered into a numeric field; available on <strong class="source-inline">IntegerField</strong>, <strong class="source-inline">FloatField</strong>, and <strong class="source-inline">DecimalField</strong>.</p></li>
				<li><strong class="source-inline">min_value</strong><p>Sets the minimum value that can be entered into a numeric field; available on <strong class="source-inline">IntegerField</strong>, <strong class="source-inline">FloatField</strong>, and <strong class="source-inline">DecimalField</strong>.</p></li>
				<li><strong class="source-inline">max_digits</strong><p>This sets the maximum number of digits that can be entered; this includes digits before and after a decimal point (if one exists). For example, the number <em class="italic">12.34</em> has four digits, and the number <em class="italic">56.7</em> has three. Used in <strong class="source-inline">DecimalField</strong>.</p></li>
				<li><strong class="source-inline">decimal_places</strong><p>This sets the maximum number of digits that can be after the decimal point. This is used in conjunction with <strong class="source-inline">max_digits</strong>, and the number of decimal places will always count toward the number of digits even if that number of decimals has not been entered after the decimal place. For example, imagine using <strong class="source-inline">max_digits</strong> of four and <strong class="source-inline">decimal_places</strong> of three: if the number <em class="italic">12.34</em> was entered, it would actually be interpreted as the value <em class="italic">12.340</em>; that is, zeros are appended until the number of digits after the decimal point is equal to the <strong class="source-inline">decimal_places</strong> setting. Since we set three as the value for <strong class="source-inline">decimal_places</strong>, the total number of digits ends up being five, which exceeds the <strong class="source-inline">max_digits</strong> setting of four. The number <em class="italic">1.2</em> would be valid since even after expanding to <em class="italic">1.200</em>, the total number of digits is only four.</p></li>
			</ul>
			<p>You can mix and match the validation rules (provided that the fields support them). <strong class="source-inline">CharField</strong> can have <strong class="source-inline">max_length</strong> and <strong class="source-inline">min_length</strong>, numeric fields can have both <strong class="source-inline">min_value</strong> and <strong class="source-inline">max_value</strong>, and so on.</p>
			<p>If you need more validation options, you can write custom validators, which we will cover in the next section. Right now, we will add some validators to our <strong class="source-inline">ExampleForm</strong> to see them in action.</p>
			<h2 id="_idParaDest-211"><a id="_idTextAnchor226"/>Exercise 6.05: Adding Extra Field Validation</h2>
			<p>In this exercise, we will add and modify the validation rules for the fields of <strong class="source-inline">ExampleForm</strong>. We will then see how these changes affect how the form behaves, both in the browser and when Django validates the form:</p>
			<ol>
				<li value="1">In PyCharm, open the <strong class="source-inline">forms.py</strong> file inside the <strong class="source-inline">form_example</strong> app directory. </li>
				<li>We will make <strong class="source-inline">text_input</strong> require at most three characters. Add a <strong class="source-inline">max_length=3</strong> argument to the <strong class="source-inline">CharField</strong> constructor:<p class="source-code">text_input = forms.CharField(max_length=3)</p></li>
				<li>Make <strong class="source-inline">password_input</strong> more secure by requiring a minimum of eight characters. Add a <strong class="source-inline">min_length=8</strong> argument to the <strong class="source-inline">CharField</strong> constructor:<p class="source-code">password_input = forms.CharField(min_length=8, \</p><p class="source-code">                                 widget=forms.PasswordInput)</p></li>
				<li>The user may have no books, so the <strong class="source-inline">books_you_own</strong> field should not be required. Add a <strong class="source-inline">required=False</strong> argument to the <strong class="source-inline">MultipleChoiceField</strong> constructor:<p class="source-code">books_you_own = forms.MultipleChoiceField\</p><p class="source-code">                (required=False, choices=BOOK_CHOICES)</p></li>
				<li>The user should only be able to enter a value between 1 and 10 in <strong class="source-inline">integer_input</strong>. Add <strong class="source-inline">min_value=1</strong> and <strong class="source-inline">max_value=10</strong> arguments to the <strong class="source-inline">IntegerField</strong> constructor:<p class="source-code">integer_input = forms.IntegerField\</p><p class="source-code">                (min_value=1, max_value=10)</p></li>
				<li>Finally, add <strong class="source-inline">max_digits=5</strong> and <strong class="source-inline">decimal_places=3</strong> to the <strong class="source-inline">DecimalField</strong> constructor:<p class="source-code">decimal_input = forms.DecimalField\</p><p class="source-code">                (max_digits=5, decimal_places=3)</p><p>Save the file.</p></li>
				<li>Start the Django dev server if it's not already running. We do not have to make any changes to any other files to get these new validation rules, since Django automatically updates the HTML generation and validation logic. This is a great benefit you get from using Django forms. Just visit or refresh <strong class="source-inline">http://127.0.0.1:8000/form-example/</strong> in your browser and the new validation will be automatically added. The form should not look any different until you try to submit it with incorrect values, in which case your browser can automatically show errors. Some things to try are as follows:<p>Enter more than three characters into the <strong class="source-inline">Text input</strong> field; you will not be able to.</p><p>Type fewer than eight characters into the <strong class="source-inline">Password</strong> field then click away from it. The browser should show an error indicating that this is not valid.</p><p>Do not select any values for the <strong class="source-inline">Books you own</strong> field. This will not prevent you from submitting the form anymore.</p><p>Use the stepper buttons on <strong class="source-inline">Integer input</strong>. You will only be able to enter a value between <strong class="source-inline">1</strong> and <strong class="source-inline">10</strong>. If you type in a value outside this range, your browser should show an error.</p><p><strong class="source-inline">Decimal input</strong> is the only field that does not validate the Django rules in the browser. You will need to type in an invalid value (such as <strong class="source-inline">123.456</strong>) and submit the form before an error (generated by Django) is displayed.</p><p>The following figure shows some of the fields that the browser can validate itself:</p><div id="_idContainer249" class="IMG---Figure"><img src="image/B15509_06_30.jpg" alt="Figure 6.30: Browser performing validation with the new rules&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 6.30: Browser performing validation with the new rules</p>
			<p><em class="italic">Figure 6.31</em> shows an error that can only be generated by Django as the browser does not understand the <strong class="source-inline">DecimalField</strong> validation rules:</p>
			<div>
				<div id="_idContainer250" class="IMG---Figure">
					<img src="image/B15509_06_31.jpg" alt="Figure 6.31: The browser considers the form valid, but Django does not&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.31: The browser considers the form valid, but Django does not</p>
			<p>In this exercise, we implemented some basic validation rules on our form fields. We then loaded the form example page in the browser, without having to make any changes to our template or view. We tried to submit the form with different values to see how the browser can validate the form compared to Django.</p>
			<p>In the activity for this chapter, we will implement the Book Search view using a Django form.</p>
			<h2 id="_idParaDest-212"><a id="_idTextAnchor227"/>Activity 6.01: Book Searching</h2>
			<p>In this activity, you will finish the Book Search view that was started in <em class="italic">Chapter 1</em>, <em class="italic">Introduction to Django</em>. You will build a <strong class="source-inline">SearchForm</strong> instance that submits and accepts a search string from <strong class="source-inline">request.GET</strong>. It will have a <strong class="source-inline">select</strong> field to choose to search for <strong class="source-inline">title</strong> or <strong class="source-inline">contributor</strong>. It will then search for all <strong class="source-inline">Book</strong> instances containing the given text in <strong class="source-inline">title</strong> or in <strong class="source-inline">first_names</strong> or <strong class="source-inline">last_names</strong> of <strong class="source-inline">Contributor</strong>. You will then render this list of books in the <strong class="source-inline">search-results.html</strong> template. The search term should not be required, but if it exists, it should have a length of three or fewer characters. Since the view will search even when using the <strong class="source-inline">GET</strong> method, the form will always have its validation checked. If we made the field <strong class="source-inline">required</strong>, it would always show an error whenever the page loads.</p>
			<p>There will be two ways of performing the search. The first is by submitting the search form that is in the <strong class="source-inline">base.html</strong> template and thus in the top-right corner of every page. This will only search through <strong class="source-inline">Book</strong> titles. The other method is by submitting a <strong class="source-inline">SearchForm</strong> instance that is rendered on the <strong class="source-inline">search-results.html</strong> page. This form will display the <strong class="source-inline">ChoiceField</strong> instance for choosing between <strong class="source-inline">title</strong> or <strong class="source-inline">contributor</strong> search.</p>
			<p>These steps will help you complete this activity:</p>
			<ol>
				<li value="1">Create a <strong class="source-inline">SearchForm</strong> instance in your <strong class="source-inline">forms.py</strong> file.</li>
				<li><strong class="source-inline">SearchForm</strong> should have two fields. The first is a <strong class="source-inline">CharField</strong> instance with the name <strong class="source-inline">search</strong>. This field should not be required but should have a minimum length of <strong class="source-inline">3</strong>.</li>
				<li>The second field on <strong class="source-inline">SearchForm</strong> is a <strong class="source-inline">ChoiceField</strong> instance named <strong class="source-inline">search_in</strong>. This will allow selecting between <strong class="source-inline">title</strong> and <strong class="source-inline">contributor</strong> (with <strong class="source-inline">Title</strong> and <strong class="source-inline">Contributor</strong> labels, respectively). It should not be <strong class="source-inline">required</strong>.</li>
				<li>Update the <strong class="source-inline">book_search</strong> view to instantiate a <strong class="source-inline">SearchForm</strong> instance using data from <strong class="source-inline">request.GET</strong>.</li>
				<li>Add code to search for <strong class="source-inline">Book</strong> models using <strong class="source-inline">title__icontains</strong> (for case-insensitive searching). This should be done if searching by <strong class="source-inline">title</strong>. The search should only be performed if the form is valid and contains some search text. The <strong class="source-inline">search_in</strong> value should be retrieved from <strong class="source-inline">cleaned_data</strong> using the <strong class="source-inline">get</strong> method since it might not exist, as it's not required. Set its default to <strong class="source-inline">title</strong>.</li>
				<li>When searching for contributors, use <strong class="source-inline">first_names__icontains</strong> or <strong class="source-inline">last_names__icontains</strong>, then iterate the contributors and retrieve the books for each contributor. This should be done if searching by <strong class="source-inline">contributor</strong>. The search should only be performed if the form is valid and contains some search text. There are many ways to combine the search results for a first or last name. The easiest method, using the techniques that you have been introduced to so far, is to perform two queries, one for matching first names and then for last names, and iterating them separately.</li>
				<li>Update the <strong class="source-inline">render</strong> call to include the <strong class="source-inline">form</strong> variable and the books that were retrieved in the context (as well as <strong class="source-inline">search_text</strong> that was already being passed). The location of the template was changed in <em class="italic">Chapter 3</em>, <em class="italic">URL Mapping, Views, and Templates</em>, so update the second argument to <strong class="source-inline">render</strong> accordingly.</li>
				<li>The <strong class="source-inline">search-results.html</strong> template we created in <em class="italic">Chapter 1</em>, <em class="italic">Introduction to Django</em>, is essentially redundant now, so you can clear its content. Update the <strong class="source-inline">search-results.html</strong> file to extend from <strong class="source-inline">base.html</strong> instead of being a standalone template file.</li>
				<li>Add a <strong class="source-inline">title</strong> block that will display <strong class="source-inline">Search Results for &lt;search_text&gt;</strong> if the form is valid and <strong class="source-inline">search_text</strong> was set and will otherwise just display <strong class="source-inline">Book Search</strong>. This block will also be added to <strong class="source-inline">base.html</strong> later in this activity.</li>
				<li>Add a <strong class="source-inline">content</strong> block, which should show an <strong class="source-inline">&lt;h2&gt;</strong> heading with the text <strong class="source-inline">Search for Books</strong>. Under the <strong class="source-inline">&lt;h2&gt;</strong> heading, render the form. The <strong class="source-inline">&lt;form&gt;</strong> element can have no attributes and it will default to making a <strong class="source-inline">GET</strong> request to the same URL that it's on. Add a submit button as we have used in previous activities, with the <strong class="source-inline">btn btn-primary</strong> class.</li>
				<li>Under the form, show a <strong class="source-inline">Search results for &lt;search_text&gt;</strong> message if the form is valid and search text was entered, otherwise show no message. This should be displayed in an <strong class="source-inline">&lt;h3&gt;</strong> heading, and the search text should be wrapped in <strong class="source-inline">&lt;em&gt;</strong>.</li>
				<li>Iterate over the search results and render each one. Show the book title and contributor's first and last names. The book title should link to the <strong class="source-inline">book_detail</strong> page. If the books list is empty, show the text <strong class="source-inline">No results found</strong>. You should wrap the results in <strong class="source-inline">&lt;ul&gt;</strong> with <strong class="source-inline">class</strong> <strong class="source-inline">list-group</strong>, and each result should be an <strong class="source-inline">&lt;li&gt;</strong> instance with <strong class="source-inline">class</strong> <strong class="source-inline">list-group-item</strong>. This will be similar to the <strong class="source-inline">book_list</strong> page; however, we won't show as much information (just the title and contributors). </li>
				<li>Update <strong class="source-inline">base.html</strong> to include an action attribute in the search <strong class="source-inline">&lt;form&gt;</strong> tag. Use the <strong class="source-inline">url</strong> template tag to generate the URL for this attribute.</li>
				<li>Set the <strong class="source-inline">name</strong> attribute of the search field to <strong class="source-inline">search</strong> and the <strong class="source-inline">value</strong> attribute to the search text that was entered. Also, ensure that the minimum length of the field is <strong class="source-inline">3</strong>.</li>
				<li>In <strong class="source-inline">base.html</strong>, add a <strong class="source-inline">title</strong> block to the <strong class="source-inline">title</strong> tag that was overridden by other templates (as in <em class="italic">step 9</em>). Add a <strong class="source-inline">block</strong> template tag inside the <strong class="source-inline">&lt;title&gt;</strong> HTML element. It should have the content <strong class="source-inline">Bookr</strong>.</li>
			</ol>
			<p>After completing this activity, you should be able to open the Book Search page at <strong class="source-inline">http://127.0.0.1:8000/book-search/</strong> and it will look like <em class="italic">Figure 6.32</em>:</p>
			<div>
				<div id="_idContainer251" class="IMG---Figure">
					<img src="image/B15509_06_32.jpg" alt="Figure 6.32: Book Search page without a search&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.32: Book Search page without a search</p>
			<p>When searching for something using just two characters, your browser should prevent you from submitting either of the search fields. If you search for something that returns no results, you will see a message that there were no results. Searching by title (this can be done with either field) will show matching results.</p>
			<p>Similarly, when searching by the contributor (although this can only be done in the lower form), you should see something like the following:</p>
			<div>
				<div id="_idContainer252" class="IMG---Figure">
					<img src="image/B15509_06_33.jpg" alt="Figure 6.33: A contributor search&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.33: A contributor search</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution to this activity can be found at <a href="http://packt.live/2Nh1NTJ">http://packt.live/2Nh1NTJ</a>.</p>
			<h1 id="_idParaDest-213"><a id="_idTextAnchor228"/>Summary</h1>
			<p>This chapter was an introduction to forms in Django. We introduced some HTML inputs for entering data onto a web page. We talked about how data is submitted to a web application and when to use <strong class="source-inline">GET</strong> and <strong class="source-inline">POST</strong> requests. We then looked at how Django's form classes can make generating the form HTML simpler, as well as allowing the automatic building of forms using models. We enhanced Bookr some more by building the book search functionality.</p>
			<p>In the next chapter, we will go deeper into forms and learn how to customize the display of form fields, how to add more advanced validation to your form, and how to automatically save model instances by using the <strong class="source-inline">ModelForm</strong> class.</p>
		</div>
	</body></html>