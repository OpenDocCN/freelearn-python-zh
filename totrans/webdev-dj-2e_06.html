<html><head></head><body>
		<div><div></div>
		</div>
		<div><h1 id="_idParaDest-193"><a id="_idTextAnchor208"/>6. Forms</h1>
		</div>
		<div><p class="callout-heading">Overview</p>
			<p class="callout">This chapter introduces web forms, a method of sending information from the browser to the web server. It starts with an introduction to forms in general and discusses how data is encoded to be sent to the server. You will learn about the differences between sending form data in a <code>GET</code> HTTP request and sending it in a <code>POST</code> HTTP request, and how to choose which one to use. By the end of the chapter, you will know how Django's form library is used to build and validate forms automatically and how it cuts down the amount of manual HTML you need to write.</p>
			<h1 id="_idParaDest-194"><a id="_idTextAnchor209"/>Introduction</h1>
			<p>So far, the views we have been building for Django have been one-way only. Our browser is retrieving data from the views we have written but it does not send any data back to them. In <em class="italic">Chapter 4</em>, <em class="italic">Introduction to Django Admin</em>, we created model instances using the Django admin and submitting forms, but those were using views built into Django, not created by us. In this chapter, we will use the Django Forms library to start accepting user-submitted data. The data will be provided through <code>GET</code> requests in the URL parameters, and/or <code>POST</code> requests in the body of the request. But before we get into the details, first let us understand what are forms in Django.</p>
			<h1 id="_idParaDest-195"><a id="_idTextAnchor210"/>What Is a Form?</h1>
			<p>When working with an interactive web app, we not only want to provide data to users but also accept data from them to either customize the responses we are generating or let them submit data to the site. When browsing the web, you will most definitely have used forms. Whether you're logging in to your internet banking account, surfing the web with a browser, posting a message on social media, or writing an email in an online email client, in all these cases, you are entering data in a form. A form is made up of inputs that define key-value pairs of data to submit to the server. For example, when logging in to a website, the data being sent would have the keys <em class="italic">username</em> and <em class="italic">password</em>, with the values of your username and your password, respectively. We will go into the different types of inputs in more detail in the <em class="italic">Types of Inputs</em> section. Each input in the form has a <em class="italic">name</em>, and this is how its data is identified on the server-side (in a Django view). There can be multiple inputs with the same <em class="italic">name</em>, whose data is available in a list containing all the posted values with this name – for example, a list of checkboxes with permissions to apply to users. Each checkbox would have the same name but a different value. The form has attributes that specify which URL the browser should submit the data to and what method it should use to submit the data (browsers only support <code>GET</code> or <code>POST</code>).</p>
			<p>The GitHub login form shown in the next figure is an example of a form:</p>
			<div><div><img src="img/B15509_06_01.jpg" alt="Figure 6.1: The GitHub login page is an example of a form&#13;&#10;"/>
				</div>
			</div>
			<p> </p>
			<p class="figure-caption">Figure 6.1: The GitHub login page is an example of a form</p>
			<p>It has three visible inputs: a text field (<code>Username</code>), a <code>password</code> field (<code>Password</code>), and a <code>submit</code> button (<code>Sign in</code>). It also has a field that is not visible – its type is <code>hidden</code>, and it contains a special token for security called a <code>Sign In</code> button, the form data is submitted with a <code>POST</code> request. If you entered a valid username and password, you are logged in; otherwise, the form will display an error as follows:</p>
			<div><div><img src="img/B15509_06_02.jpg" alt="Figure 6.2: Form submitted with an incorrect username or password&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.2: Form submitted with an incorrect username or password</p>
			<p>There are two states a form can have: <strong class="bold">pre-submit</strong> and <strong class="bold">post-submit</strong>. The first is the initial state when the page is first loaded. All the fields will have a default value (usually empty) and no errors will be displayed. If all the information that has been entered into a form is valid, then usually when it is submitted you will be taken to a page showing the results of submitting the form. This might be a search results page, or a page showing you the new object that you created. In this case, you will not see the form in its post-submit state.</p>
			<p>If you did not enter valid information into the form, then it will be rendered again in its post-submit state. In this state, you will be shown the information that you entered as well as any errors to help you resolve the problems with the form. The errors may be <strong class="bold">field errors</strong> or <strong class="bold">non-field errors</strong>. Field errors apply to a specific field. For example, leaving a required field blank or entering a value that is too large, too small, too long, or too short. If a form required you to enter your name and you left it blank, this would be displayed as a field error next to that field.</p>
			<p>Non-field errors either do not apply to a field, or apply to multiple fields, and are displayed at the top of the form. In <em class="italic">Figure 6.2</em>, we see a message that either the username or password may be incorrect when logging in. For security, GitHub does not reveal whether a username is valid, and so this is displayed as a non-field error rather than a field error for the username or password (Django also follows this convention). Non-field errors also apply to fields that depend on each other. For example, on a credit card form, if the payment is rejected, we might not know if the credit card number or security code is incorrect; therefore, we cannot show that error on a specific field. It applies to the form as a whole. </p>
			<h2 id="_idParaDest-196"><a id="_idTextAnchor211"/>The &lt;form&gt; Element</h2>
			<p>All inputs used during form submission must be contained inside a <code>&lt;form&gt;</code> element. There are three HTML attributes that you will be using to modify the behavior of the form:</p>
			<ul>
				<li><code>method</code><p>This is the HTTP method used to submit the form, either <code>GET</code> or <code>POST</code>. If omitted, this defaults to <code>GET</code> (because this is the default method when typing a URL into the browser and hitting <em class="italic">Enter</em>).</p></li>
				<li><code>action</code><p>This refers to the URL (or path) to send the form data to. If omitted, the data gets sent back to the current page.</p></li>
				<li><code>enctype</code><p>This sets the encoding type of the form. You only need to change this if you are using the form to upload files. The most common values are <code>application/x-www-form-urlencoded</code> (the default if this value is omitted) or <code>multipart/form-data</code> (set this if uploading files). Note that you don't have to worry about the encoding type in your view; Django handles the different types automatically. </p></li>
			</ul>
			<p>Here is an example of a form without any of its attributes set:</p>
			<pre>&lt;form&gt;
    &lt;!-- Input elements go here --&gt;
&lt;/form&gt;</pre>
			<p>It will submit its data using a <code>GET</code> request, to the current URL that the form is being displayed on, using the <code>application/x-www-form-urlencoded</code> encoding type.</p>
			<p>In this next example, we will set all three attributes on a form:</p>
			<pre>&lt;form method="post" action="/form-submit" enctype="multipart/form-data"&gt;
    &lt;!-- Input elements go here --&gt;
&lt;/form&gt;</pre>
			<p>This form will submit its data with a <code>POST</code> request to the <code>/form-submit</code> path, encoding the data as <code>multipart/form-data</code>.</p>
			<p>How do <code>GET</code> and <code>POST</code> requests differ in how the data is sent? Recall in <em class="italic">Chapter 1</em>, <em class="italic">Introduction to Django</em>, we discussed what the underlying HTTP request and response data that your browser sends looks like. In these next two examples, we will submit the same form twice, the first time using <code>GET</code> and the second time using <code>POST</code>. The form will have two inputs, a first name, and the last name.</p>
			<p>A form submitted using <code>GET</code> sends its data in the URL, like this:</p>
			<pre>GET /form-submit?first_name=Joe&amp;last_name=Bloggs HTTP/1.1
Host: www.example.com</pre>
			<p>A form submitted using <code>POST</code> sends its data in the body of the request, like this:</p>
			<pre>POST /form-submit HTTP/1.1
Host: www.example.com
Content-Length: 31
Content-Type: application/x-www-form-urlencoded
first_name=Joe&amp;last_name=Bloggs</pre>
			<p>You will notice that the form data is encoded the same way in both cases; it is just placed differently for the <code>GET</code> and <code>POST</code> requests. In an upcoming section, we will discuss how to choose between these two types of requests.</p>
			<h2 id="_idParaDest-197"><a id="_idTextAnchor212"/>Types of Inputs</h2>
			<p>We have seen four examples of inputs so far (<em class="italic">text</em>, <em class="italic">password</em>, <em class="italic">submit</em>, and <em class="italic">hidden</em>). Most inputs are created with an <code>&lt;input&gt;</code> tag, and their type is specified with its <code>type</code> attribute. Each input has a <code>name</code> attribute that defines the key for the key-value pairs that are sent to the server in the HTTP request.</p>
			<p>In the next exercise, let's look at how we can build a form in HTML. This will allow you to get up to speed on many different form fields.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The code for all the exercises and activities used in this chapter can be found on the book's GitHub repository at <a href="http://packt.live/2KGjlaM">http://packt.live/2KGjlaM</a>.</p>
			<h2 id="_idParaDest-198"><a id="_idTextAnchor213"/>Exercise 6.01: Building a Form in HTML</h2>
			<p>For the first few exercises of this chapter, we will need an HTML form to test with. We will manually code one in this exercise. This will also allow you to experiment with how different fields are validated and submitted. This will be done in a new Django project so that we don't interfere with Bookr. You can refer to <em class="italic">Chapter 1</em>, <em class="italic">Introduction to Django</em>, to refresh your memory on creating a Django project:</p>
			<ol>
				<li>We will start by creating the new Django project. You can re-use the <code>bookr</code> virtual environment that already has Django installed. Open a new terminal and activate the virtual environment. Then, use <code>django-admin</code> to start a Django project named <code>form_project</code>. To do this, run the command:<pre>django-admin startproject form_project</pre><p>This will scaffold the Django project in a directory named <code>form_example</code>.</p></li>
				<li>Create a new Django app in this project by using the <code>startapp</code> management command. The app should be called <code>form_example</code>. To do this, <code>cd</code> into the <code>form_project</code> directory, then run this:<pre>python3 manage.py startapp form_example</pre><p>This will create the <code>form_example</code> app directory inside the <code>form_project</code> directory.</p></li>
				<li>Launch PyCharm, then open the <code>form_project</code> directory. If you already have a project open, you can do this by choosing <code>File</code> -&gt; <code>Open</code>; otherwise, just click <code>Open</code> in the <code>Welcome to PyCharm</code> window. Navigate to the <code>form_project</code> directory, select it, then click <code>Open</code>. The <code>form_project</code> project window should be shown similar to this:<div><img src="img/B15509_06_03.jpg" alt="Figure 6.3: The form_project project open&#13;&#10;"/></div><p class="figure-caption">Figure 6.3: The form_project project open</p></li>
				<li>Create a new run configuration to execute <code>manage.py runserver</code> for the project. You can re-use the <code>bookr</code> virtual environment again. The <code>Run/Debug Configurations</code> window should look similar to the following figure when you're done:<div><img src="img/B15509_06_04.jpg" alt="Figure 6.4: Run/Debug Configurations for Runserver&#13;&#10;"/></div><p class="figure-caption">Figure 6.4: Run/Debug Configurations for Runserver</p><p>You can test that the configuration is set up correctly by clicking the <code>Run</code> button, then visiting <code>http://127.0.0.1:8000/</code> in your browser. You should see the Django welcome screen. If the debug server fails to start or you see the Bookr main page, then you probably still have the Bookr project running. Try stopping the Bookr <code>runserver</code> process and then starting the new one you just set up.</p></li>
				<li>Open <code>settings.py</code> in the <code>form_project</code> directory and add <code>'form_example'</code> to the <code>INSTALLED_APPS</code> setting.</li>
				<li>The last step in setting up this new project is to create a <code>templates</code> directory for the <code>form_example</code> app. Right-click on the <code>form_example</code> directory and then select <code>New</code> -&gt; <code>Directory</code>. Name it <code>templates</code>.</li>
				<li>We need an HTML template to display our form. Create one by right-clicking the <code>templates</code> directory you just created and choosing <code>New</code> -&gt; <code>HTML File</code>. In the dialog box that appears, enter the name <code>form-example.html</code> and hit <em class="italic">Enter</em> to create it.</li>
				<li>The <code>form-example.html</code> file should now be open in the editor pane of PyCharm. Start by creating the <code>form</code> element. We will set its <code>method</code> attribute to <code>post</code>. The <code>action</code> attribute will be omitted, which means the form will submit back to the same URL on which it was loaded. <p>Insert this code between the <code>&lt;body&gt;</code> and <code>&lt;/body&gt;</code> tags:</p><pre>&lt;form method="post"&gt;
&lt;/form&gt;</pre></li>
				<li>Now let us add a few inputs. To add a little bit of spacing between each input, we will wrap them inside <code>&lt;p&gt;</code> tags. We will start with a text field and password field. This code should be inserted between the <code>&lt;form&gt;</code> tags you just created:<pre>&lt;p&gt;
    &lt;label for="id_text_input"&gt;Text Input&lt;/label&gt;&lt;br&gt;
    &lt;input id="id_text_input" type="text" name=      "text_input" value="" placeholder="Enter some text"&gt;
&lt;/p&gt;
&lt;p&gt;
    &lt;label for="id_password_input"&gt;Password Input&lt;/label&gt;&lt;br&gt;
    &lt;input id="id_password_input" type="password" name="password_input"       value="" placeholder="Your password"&gt;
&lt;/p&gt;</pre></li>
				<li>Next, we will add two checkboxes and three radio buttons. Insert this code after the HTML you added in the previous step; it should come before the <code>&lt;/form&gt;</code> tag:<pre>&lt;p&gt;
    &lt;input id="id_checkbox_input" type="checkbox"      name="checkbox_on" value="Checkbox Checked" checked&gt;
    &lt;label for="id_checkbox_input"&gt;Checkbox&lt;/label&gt;
&lt;/p&gt;
&lt;p&gt;
    &lt;input id="id_radio_one_input" type="radio"      name="radio_input" value="Value One"&gt;
    &lt;label for="id_radio_one_input"&gt;Value One&lt;/label&gt;
    &lt;input id="id_radio_two_input" type="radio"      name="radio_input" value="Value Two" checked&gt;
    &lt;label for="id_radio_two_input"&gt;Value Two&lt;/label&gt;
    &lt;input id="id_radio_three_input" type="radio"      name="radio_input" value="Value Three"&gt;
    &lt;label for="id_radio_three_input"&gt;Value Three&lt;/label&gt;
&lt;/p&gt;</pre></li>
				<li>Next is a dropdown select menu to allow the user to choose a favorite book. Add this code after that of the previous step but before the <code>&lt;/form&gt;</code> tag:<pre>&lt;p&gt;
    &lt;label for="id_favorite_book"&gt;Favorite Book&lt;/label&gt;&lt;br&gt;
    &lt;select id="id_favorite_book" name="favorite_book"&gt;
        &lt;optgroup label="Non-Fiction"&gt;
            &lt;option value="1"&gt;Deep Learning with Keras&lt;/option&gt;
            &lt;option value="2"&gt;Web Development with Django&lt;/option&gt;
        &lt;/optgroup&gt;
        &lt;optgroup label="Fiction"&gt;
            &lt;option value="3"&gt;Brave New World&lt;/option&gt;
            &lt;option value="4"&gt;The Great Gatsby&lt;/option&gt;
        &lt;/optgroup&gt;
    &lt;/select&gt;
&lt;/p&gt;</pre><p>It will display four options that are split into two groups. The user will only be able to select one option.</p></li>
				<li>The next is a multiple select (achieved by using the <code>multiple</code> attribute). Add this code after that of the previous step but before the <code>&lt;/form&gt;</code> tag:<pre>&lt;p&gt;
    &lt;label for="id_books_you_own"&gt;Books You Own&lt;/label&gt;&lt;br&gt;
    &lt;select id="id_books_you_own" name="books_you_own" multiple&gt;
        &lt;optgroup label="Non-Fiction"&gt;
            &lt;option value="1"&gt;Deep Learning with Keras&lt;/option&gt;
            &lt;option value="2"&gt;Web Development with Django&lt;/option&gt;
        &lt;/optgroup&gt;
        &lt;optgroup label="Fiction"&gt;
            &lt;option value="3"&gt;Brave New World&lt;/option&gt;
            &lt;option value="4"&gt;The Great Gatsby&lt;/option&gt;
        &lt;/optgroup&gt;
    &lt;/select&gt;
&lt;/p&gt;</pre><p>The user can select zero or more options from the four. They are displayed in two groups.</p></li>
				<li>Next is <code>textarea</code>. It is like a text field but has multiple lines. This code should be added like in the previous steps, before the closing <code>&lt;/form&gt;</code> tag:<pre>&lt;p&gt;
    &lt;label for="id_text_area"&gt;Text Area&lt;/label&gt;&lt;br&gt;
    &lt;textarea name="text_area" id="id_text_area"      placeholder="Enter multiple lines of text"&gt;&lt;/textarea&gt;
&lt;/p&gt;</pre></li>
				<li>Next, add some fields for specific data types: <code>number</code>, <code>email</code>, and <code>date</code> inputs. Add this all before the <code>&lt;/form&gt;</code> tag:<pre>&lt;p&gt;
    &lt;label for="id_number_input"&gt;Number Input&lt;/label&gt;&lt;br&gt;
    &lt;input id="id_number_input" type="number"      name="number_input" value="" step="any" placeholder="A number"&gt;
&lt;/p&gt;
&lt;p&gt;
    &lt;label for="id_email_input"&gt;Email Input&lt;/label&gt;&lt;br&gt;
    &lt;input id="id_email_input" type="email"      name="email_input" value="" placeholder="Your email address"&gt;
&lt;/p&gt;
&lt;p&gt;
    &lt;label for="id_date_input"&gt;Date Input&lt;/label&gt;&lt;br&gt;
    &lt;input id="id_date_input" type="date" name=      "date_input" value="2019-11-23"&gt;
&lt;/p&gt;</pre></li>
				<li>Now add some buttons to submit the form. Once again, insert this before the closing <code>&lt;/form&gt;</code> tag:<pre>&lt;p&gt;
    &lt;input type="submit" name="submit_input" value="Submit Input"&gt;
&lt;/p&gt;
&lt;p&gt;
    &lt;button type="submit" name="button_element" value="Button Element"&gt;
        Button With &lt;strong&gt;Styled&lt;/strong&gt; Text
    &lt;/button&gt;
&lt;/p&gt;</pre><p>This demonstrates two ways of creating submit buttons, either as <code>&lt;input&gt;</code> or <code>&lt;button&gt;</code>.</p></li>
				<li>Finally, add a hidden field. Insert this before the closing <code>&lt;/form&gt;</code> tag:<pre>&lt;input type="hidden" name="hidden_input" value="Hidden Value"&gt;</pre><p>This field cannot be seen or edited so it has a fixed value. You can save and close <code>form-example.html</code>.</p></li>
				<li>As with any template, we cannot see it unless we have a view to render it. Open the <code>form_example</code> app's <code>views.py</code> file and add a new view called <code>form_example</code>. It should render and return the template you just created, like so:<pre>def form_example(request):
    return render(request, "form-example.html")</pre><p>You can now save and close <code>views.py</code>.</p></li>
				<li>You should be familiar with the next step now, which is to add a URL mapping to the view. Open the <code>urls.py</code> file in the <code>form_project</code> package directory. Add a mapping for the path <code>form-example</code> to your <code>form_example</code> view, to the <code>urlpatterns</code> variable. It should look like this:<pre>path('form-example/', form_example.views.form_example)</pre><p>Make sure you also add an import of <code>form_example.views</code>. Save and close <code>urls.py</code>.</p></li>
				<li>Start the Django dev server (if it is not already running), then load your new view in your web browser; the address is <code>http://127.0.0.1:8000/form-example/</code>. Your page should look like this:<div><img src="img/B15509_06_05.jpg" alt="Figure 6.5: Example inputs page&#13;&#10;"/></div><p class="figure-caption">Figure 6.5: Example inputs page</p><p>You can now familiarize yourself with the behavior of the web forms and see how they are generated from the HTML you specified. One activity to try is to enter invalid data into the number, date, or email inputs and click the submit button – the built-in HTML validation should prevent the form from being submitted:</p><div><img src="img/B15509_06_06.jpg" alt="Figure 6.6: Browser error due to an invalid number&#13;&#10;"/></div><p class="figure-caption">Figure 6.6: Browser error due to an invalid number</p><p>We have not yet set up everything for form submission, so if you correct all the errors in the form and try to submit it (by clicking either of the submit buttons), you will receive an error stating <code>CSRF verification failed. Request aborted.</code>, as we can see in the next figure. We will talk about what this means, and how to fix it, later in the chapter:</p><div><img src="img/B15509_06_07.jpg" alt="Figure 6.7: CSRF verification error&#13;&#10;"/></div><p class="figure-caption">Figure 6.7: CSRF verification error</p></li>
				<li>If you do receive the error, just go back in your browser to return to the input example page.</li>
			</ol>
			<p>In this exercise, you created an example page showcasing many HTML inputs, then created a view to render it and a URL to map to it. You loaded the page in your browser and experimented with changing data and trying to submit the form when it contained errors. </p>
			<h2 id="_idParaDest-199"><a id="_idTextAnchor214"/>Form Security with Cross-Site Request Forgery Protection</h2>
			<p>Throughout the book, we have mentioned features that Django includes to prevent certain types of security exploits. One of these features is protection against CSRF.</p>
			<p>A CSRF attack exploits the fact that a form on a website can be submitted to any other website. The <code>action</code> attribute of <code>form</code> just needs to be set appropriately. Let's take an example for Bookr. We don't have this set up yet, but we will be adding a view and URL that allows us to post a review for a book. To do this, we'll have a form for posting the review content and selecting the rating. Its HTML is like this:</p>
			<pre>&lt;form method="post" action="http://127.0.0.1:8000/books/4/reviews/"&gt;
    &lt;p&gt;
        &lt;label for="id_review_text"&gt;Your Review&lt;/label&gt;&lt;br/&gt;
        &lt;textarea id="id_review_text" name="review_text"          placeholder="Enter your review"&gt;&lt;/textarea&gt;
    &lt;/p&gt;
    &lt;p&gt;
        &lt;label for="id_rating"&gt;Rating&lt;/label&gt;&lt;br/&gt;
        &lt;input id="id_rating" type="number" name="rating"          placeholder="Rating 1-5"&gt;
    &lt;/p&gt;
    &lt;p&gt;
        &lt;button type="submit"&gt;Create Review&lt;/button&gt;
    &lt;/p
&lt;/form&gt;</pre>
			<p>And on a web page, it would look like this:</p>
			<div><div><img src="img/B15509_06_08.jpg" alt="Figure 6.8: Example review creation form&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.8: Example review creation form</p>
			<p>Someone could take this form, make a few changes, and host it on their own website. For example, they could make the inputs hidden and hardcode a good review and rating for a book, and then make it look like some other kind of form, like this:</p>
			<pre>&lt;form method="post" action="http://127.0.0.1:8000/books/4/reviews/"&gt;
    &lt;input type="hidden" name="review_text" value="This book is great!"&gt;
    &lt;input type="hidden" name="rating" value="5"&gt;
    &lt;p&gt;
        &lt;button type="submit"&gt;Enter My Website&lt;/button&gt;
    &lt;/p&gt;
&lt;/form&gt;</pre>
			<p>Of course, the hidden fields don't display, so the form looks like this on the malicious website.</p>
			<div><div><img src="img/B15509_06_09.jpg" alt="Figure 6.9: Hidden inputs are not visible&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.9: Hidden inputs are not visible</p>
			<p>The user would think they were clicking a button to enter a website, but while clicking it, they would submit the hidden values to the original view on Bookr. Of course, a user could check the source code of the page they were on to check what data is being sent and where, but most users are unlikely to inspect every form they come across. The attacker could even have the form with no submit button and just use JavaScript to submit it, which means the user would be submitting the form without even realizing it.</p>
			<p>You may think that requiring the user to log in to Bookr will prevent this type of attack, and it does limit its effectiveness somewhat, as the attack would then only work for logged-in users. But because of the way authentication works, once a user is logged in, they have a cookie set in their browser that identifies them to the Django application. This cookie is sent on every request so that the user does not have to provide their login credentials on every page. Because of the way web browsers work, they will include the server's authentication cookie in <em class="italic">all</em> requests they send to that particular server. Even though our form is hosted on a malicious site, ultimately it is sending a request to our application, so it will send through our server's cookies.</p>
			<p>How can we prevent CSRF attacks? Django uses something called a CSRF token, which is a small random string that is unique to each site visitor – in general, you can consider a visitor to be one browser session. Different browsers on the same computer would be different visitors, and the same Django user logged in on two different browsers would also be different visitors. When the form is read, Django puts the token into the form as a hidden input. The CSRF token must be included in all <code>POST</code> requests being sent to Django, and it must match the token Django has stored on the server-side for the visitor, otherwise, a 403 status HTTP response is returned. This protection can be disabled – either for the whole site or for an individual view – but it is not advisable to do so unless you really need to. The CSRF token must be added into the HTML for every form being sent and is done with the <code>{% csrf_token %}</code> template tag. We'll add it to our example review form now, and the code in the template will look like this:</p>
			<pre>&lt;form method="post" action="http://127.0.0.1:8000/books/4/reviews/"&gt;
    {% csrf_token %}
    &lt;p&gt;
        &lt;label for="id_review_text"&gt;Your Review&lt;/label&gt;&lt;br/&gt;
        &lt;textarea id="id_review_text" name="review_text"          placeholder="Enter your review"&gt;&lt;/textarea&gt;
    &lt;/p&gt;
    &lt;p&gt;
        &lt;label for="id_rating"&gt;Rating&lt;/label&gt;&lt;br/&gt;
        &lt;input id="id_rating" type="number" name="rating"          placeholder="Rating 1-5"&gt;
    &lt;/p&gt;
    &lt;p&gt;
        &lt;button type="submit"&gt;Enter My Website&lt;/button&gt;
    &lt;/p&gt;
&lt;/form&gt;</pre>
			<p>When the template gets rendered, the template tag is interpolated, so the output HTML ends up like this (note that the inputs are still in the output; they have just been removed here for brevity):</p>
			<pre>&lt;form method="post" action="http://127.0.0.1:8000/books/4/reviews/"&gt;
    &lt;input type="hidden" name="csrfmiddlewaretoken"      value="tETZjLDUXev1tiYqGCSbMQkhWiesHCnutxpt6mutHI6YH64F0nin5k2JW3B68IeJ"&gt;
    …
&lt;/form&gt;</pre>
			<p>Since this is a hidden field, the form on the page does not look any different from how it did before.</p>
			<p>The CSRF token is unique to every visitor on the site and periodically changes. If an attacker were to copy the HTML from our site, they would get their own CSRF token that would not match that of any other user, so Django would reject the form when it was posted by someone else. </p>
			<p>CSRF tokens also change periodically. This limits how long the attacker would have to take advantage of a particular user and token combination. Even if they were able to get the CSRF token of a user that they were trying to exploit, they would have a short window of time to be able to use it. </p>
			<h2 id="_idParaDest-200"><a id="_idTextAnchor215"/>Accessing Data in the View</h2>
			<p>As we discussed in <em class="italic">Chapter 1</em>, <em class="italic">Introduction to Django</em>, Django provides two <code>QueryDict</code> objects on the <code>HTTPRequest</code> instances that are passed to the view function. These are <code>request.GET</code>, which contains parameters passed in the URL, and <code>request.POST</code>, which contains parameters in the HTTP request body. Even though <code>request.GET</code> has <code>GET</code> in its name, this variable is populated even for non-<code>GET</code> HTTP requests. This is because the data it contains is parsed from the URL. Since all HTTP requests have a URL, all HTTP requests may contain <code>GET</code> data, even if they are <code>POST</code> or <code>PUT</code>, and so on. In the next exercise, we will add code to our view to read and display the <code>POST</code> data.</p>
			<h2 id="_idParaDest-201"><a id="_idTextAnchor216"/>Exercise 6.02: Working with POST Data in a View</h2>
			<p>We will now add some code to our example view to print out the received <code>POST</code> data to the console. We will also insert the HTTP method that was used to generate the page into the HTML output. This will allow us to be sure of what method was used to generate the page (<code>GET</code> or <code>POST</code>) and see how the form differs for each type:</p>
			<ol>
				<li value="1">First, in PyCharm, open the <code>form_example</code> app's <code>views.py</code> file. Alter the <code>form_example</code> view to print each value in the <code>POST</code> request to the console by adding this code inside the function:<pre>    for name in request.POST:
        print("{}: {}".format(name, request.POST.getlist(name)))</pre><p>This code iterates over each key in the request <code>POST</code> data <code>QueryDict</code> and prints the key and list of values to the console. We already know that each <code>QueryDict</code> can have multiple values for a key, so we use the <code>getlist</code> function to get them all. </p></li>
				<li>Pass <code>request.method</code> to the template in a context variable named <code>method</code>. Do this by updating the call to <code>render</code> in the view, so that it's like this:<pre>return render(request, "form-example.html", \
              {"method": request.method})</pre></li>
				<li>We will now display the <code>method</code> variable in the template. Open the <code>form-example.html</code> template and use an <code>&lt;h4&gt;</code> tag to show the <code>method</code> variable. Put this just after the opening <code>&lt;body&gt;</code> tag, like so:<pre>&lt;body&gt;
    &lt;h4&gt;Method: {{ method }}&lt;/h4&gt;</pre><p>Note that we could access the method directly inside the template without passing it in a context dictionary, by using the <code>request</code> method variable and attribute properly. We know from <em class="italic">Chapter 3</em>, <em class="italic">URL Mapping, Views, and Templates</em>, that by using the render shortcut function, the request is always available in the template. We just demonstrated how to access the method in the view here because later on, we will change the behavior of the page based on the method.</p></li>
				<li>We also need to add the CSRF token to the form HTML. We do this by putting the <code>{% csrf_token %}</code> template tag after the opening <code>&lt;form&gt;</code> tag. The start of the form should look like this:<pre>&lt;form method="post"&gt;
     {% csrf_token %}</pre><p>Now, save the file.</p></li>
				<li>Start the Django dev server if it's not already running. Load the example page (<code>http://127.0.0.1:8000/form-example/</code>) in your browser, and you should see it now displays the method at the top of the page (<code>GET</code>):<div><img src="img/B15509_06_10.jpg" alt="Figure 6.10: Method at the top of the page&#13;&#10;"/></div><p class="figure-caption">Figure 6.10: Method at the top of the page</p></li>
				<li>Enter some text or data in each of the inputs and submit the form, by clicking the <code>Submit Input</code> button:<div><img src="img/B15509_06_11.jpg" alt="Figure 6.11: Clicking the Submit Input button to submit the form&#13;&#10;"/></div><p class="figure-caption">Figure 6.11: Clicking the Submit Input button to submit the form</p><p>You should see the page reload and the method displayed change to <code>POST</code>:</p><div><img src="img/B15509_06_12.jpg" alt="Figure 6.12: Method updated to POST after the form is submitted&#13;&#10;"/></div><p class="figure-caption">Figure 6.12: Method updated to POST after the form is submitted</p></li>
				<li>Switch back to PyCharm and look in the <code>Run</code> console at the bottom of the window. If it is not visible, click the <code>Run</code> button at the bottom of the window to show it:<div><img src="img/B15509_06_13.jpg" alt="Figure 6.13: Click the Run button at the bottom of the window to display the console&#13;&#10;"/></div><p class="figure-caption">Figure 6.13: Click the Run button at the bottom of the window to display the console</p><p>Inside the <code>Run</code> console, a list of the values that were posted to the server should be displayed:</p><div><img src="img/B15509_06_14.jpg" alt="Figure 6.14: Input values shown in the Run console&#13;&#10;"/></div><p class="figure-caption">Figure 6.14: Input values shown in the Run console</p><p>Some things you should notice are as follows:</p><ul><li>All values are sent as text, even <code>number</code> and <code>date</code> inputs.</li><li>For the <code>select</code> inputs, the selected <code>value</code> attributes of the selected options are sent, not the text content of the <code>option</code> tag.</li><li>If you select multiple options for <code>books_you_own</code>, then you will see multiple values in the request. This is why we use the <code>getlist</code> method since multiple values are sent for the same input name.</li><li>If the checkbox was checked, you will have a <code>checkbox_on</code> input in the debug output. If it was not checked, then the key will not exist at all (that is, there is no key, instead of having the key existing with an empty string or <code>None</code> value).</li><li>We have a value for the name <code>submit_input</code>, which is the text <code>Submit Input</code>. You submitted the form by clicking the <code>Submit Input</code> button, so we receive its value. Notice that no value is set for the <code>button_element</code> input since that button was not clicked.</li></ul></li>
				<li>We will experiment with two other ways of submitting the form, first by hitting <em class="italic">Enter</em> when your cursor is in a text-like input (such as <em class="italic">text</em>, <em class="italic">password</em>, <em class="italic">date</em>, and <em class="italic">email</em>, but not <em class="italic">text area</em>, as hitting <em class="italic">Enter</em> there will add a new line). <p>If you submit a form in this way, the form will act as though you had clicked the first submit button on the form, so the <code>submit_input</code> input value will be included. The output you see should match that of the previous figure.</p><p>The other way to submit the form is by clicking the <code>Button Element</code> submit input, in which we will try clicking this button to submit the form. You should see that <code>submit_button</code> is no longer in the list of posted values, while <code>button_element</code> is now present:</p><div><img src="img/B15509_06_15.jpg" alt="Figure 6.15: submit_button is now gone from the inputs, and button_element is added&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 6.15: submit_button is now gone from the inputs, and button_element is added</p>
			<p>You can use this multiple-submit technique to alter how your view behaves depending on which button was clicked. You can even have multiple submit buttons with the same <em class="italic">name</em> attribute to make the logic easier to write. </p>
			<p>In this exercise, you added a CSRF token to your <code>form</code> element by using the <code>{% csrf_token %}</code> template tag. This means that your form could then be submitted to Django successfully without generating an HTTP Permission Denied response. We then added some code to output the values that our form contained when it was submitted. We tried submitting the form with various values to see how they are parsed into Python variables on the <code>request.POST</code> <code>QueryDict</code>. We will now discuss some more theory around the difference between <code>GET</code> and <code>POST</code> requests, then move on to the Django Forms library, which makes designing and validating forms easier.</p>
			<h2 id="_idParaDest-202"><a id="_idTextAnchor217"/>Choosing between GET and POST</h2>
			<p>Choosing when to use a <code>GET</code> or <code>POST</code> request requires the consideration of a number of factors. The most important is deciding whether or not the request should be idempotent. A request can be said to be idempotent if it can be repeated and produce the same result each time. Let us look at some examples.</p>
			<p>If you type any web address into your browser (such as any of the Bookr pages we have built so far), it will perform a <code>GET</code> request to fetch the information. You can refresh the page, and no matter how many times you click refresh, you will get the same data back. The request you are making will not affect the content on the server. You would say these requests are idempotent.</p>
			<p>Now, remember when you added data through the Django admin interface (in <em class="italic">Chapter 4</em>,<em class="italic"> Introduction to Django Admin</em>)? You typed in the information for the new book in a form, then clicked <code>Save</code>. Your browser made a <code>POST</code> request to create a new book on the server. If you repeated that <code>POST</code> request, the server would create <em class="italic">another</em> book and would do so each time you repeated the request. Since the request is updating information, it is not idempotent. Your browser will warn you about this. If you have ever tried to refresh a page that you were sent to after submitting a form, you may have received a message asking if you want to <em class="italic">"Repost form data?" </em>(or something more verbose, as in the following figure). This is a warning that you are sending the form data again, which might cause the action you just undertook to be repeated:</p>
			<div><div><img src="img/B15509_06_16.jpg" alt="Figure 6.16: Firefox confirming whether information should be resent&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.16: Firefox confirming whether information should be resent</p>
			<p>This is not to suggest that all <code>GET</code> requests are idempotent and all <code>POST</code> requests are not – your backend application can be designed in any way you want. Although it is not best practice, a developer might have decided to make data get updated during a <code>GET</code> request in their web application. When you are building your applications, you should try to make sure <code>GET</code> requests are idempotent and leave data-altering to <code>POST</code> requests only. Stick to these principles unless you have a good reason not to. </p>
			<p>Another point to consider is that Django only applies CSRF projection to <code>POST</code> requests. Any <code>GET</code> request, including one that alters data, can be accessed without a CSRF token.</p>
			<p>Sometimes, it can be hard to decide if a request is idempotent or not; for example, a login form. Before you submitted your username and password, you were not logged in, and afterward, the server considered you to be logged in, so could we consider that non-idempotent as it changed your authentication status with the server? On the other hand, once logged in, if you were able to send your credentials again, you would remain logged in. This implies that the request is idempotent and repeatable. So, should the request be <code>GET</code> or <code>POST</code>?</p>
			<p>This brings us to the second point to consider when choosing what method to use. If sending form data with a <code>GET</code> request, the form parameters will be visible in the URL. For example, if we made a login form use a <code>GET</code> request, the login URL might be <code>https://www.example.com/login?username=user&amp;password=password1</code>. The username, and worse, the password, is visible in the web browser's address bar. It would also be stored in the browser history, so anyone who used the browser after the real user could log in to the site. The URL is often stored in web server log files as well, meaning the credentials would be visible there too. In short, regardless of the idempotency of a request, don't pass sensitive data through URL parameters.</p>
			<p>Sometimes, knowing that the parameter will be visible in the URL might be something you desire. For example, when searching with a search engine, usually the search parameter will be visible in the URL. To see this in action, try visiting <a href="https://www.google.com">https://www.google.com</a> and searching for something. You'll notice that the page with the results has your search term as the <code>q</code> parameter. A search for <code>Django</code> will take you to the URL <a href="https://www.google.com/search?q=Django">https://www.google.com/search?q=Django</a>, for example. This allows you to share search results with someone else by sending them this URL. In <em class="italic">Activity 6.01, Book Searching</em>, you will add a search form that similarly passes a parameter.</p>
			<p>Another consideration is that the maximum length of a URL allowed by a browser can be short compared to the size of a <code>POST</code> body – sometimes only around 2,000 characters (or about 2 KB) compared to many megabytes or gigabytes that a <code>POST</code> body can be (assuming your server is set up to allow these sizes of requests). </p>
			<p>As we mentioned earlier, URL parameters are available in <code>request.GET</code> regardless of the type of request being made (<code>GET</code>, <code>POST</code>, <code>PUT</code>, and so on). You might find it useful to send some data in URL parameters and others in the request body (available in <code>request.POST</code>). For example, you could specify a <code>format</code> argument in the URL that sets what format some output data will be transformed to, but the input data is provided in the <code>POST</code> body.</p>
			<h2 id="_idParaDest-203"><a id="_idTextAnchor218"/>Why Use GET When We Can Put Parameters in the URL?</h2>
			<p>Django allows us to easily define URL maps that contain variables. We could, for example, set up a URL mapping for a search view like this:</p>
			<pre>path('/search/&lt;str:search&gt;/', reviews.views.search)</pre>
			<p>This probably looks like a good approach at first, but when we start wanting to customize the results view with arguments, it can get complicated quickly. For example, we might want to be able to move from one results page to the next, so we add a page argument:</p>
			<pre>path('/search/&lt;str:search&gt;/&lt;int:page&gt;', reviews.views.search)</pre>
			<p>And then we might also want to order the search results by a specific category, such as the author name or the date of publishing, so we add another argument for that:</p>
			<pre>path('/search/&lt;str:search&gt;/&lt;int:page&gt;/&lt;str:order &gt;', \
     reviews.views.search)</pre>
			<p>You might be able to see the problem with this approach – we can't order the results without providing a page. If we wanted to also add a <code>results_per_page</code> argument too, we wouldn't be able to use that without setting <code>page</code> and <code>order</code> keys.</p>
			<p>Contrast this to using query parameters: all of them are optional, so you could search like this:</p>
			<pre>?search=search+term:</pre>
			<p>Or you could set a page like this:</p>
			<pre>?search=search+term&amp;page=2</pre>
			<p>Or you could just set the results ordering like this:</p>
			<pre>?search=search+term&amp;order=author</pre>
			<p>Or you could combine them all:</p>
			<pre>?search=search+term&amp;page=2&amp;order=author</pre>
			<p>Another reason for using URL query parameters is that when submitting a form, the browser always sends the input values in this manner; it cannot be changed so that parameters are submitted as path components in the URL. Therefore, when submitting a form using <code>GET</code>, the URL query parameters must be used as the input data.</p>
			<h1 id="_idParaDest-204"><a id="_idTextAnchor219"/>The Django Forms Library</h1>
			<p>We've looked at how to manually write forms in HTML and how to access the data on the request object using <code>QueryDict</code>. We saw that the browser provides some validation for us for certain field types, such as email or numbers, but we have not tried validating the data in the Python view. We should validate the form in the Python view for two reasons:</p>
			<ul>
				<li>It is not safe to rely solely on browser-based validation of input data. A browser may not implement certain validation features, meaning the user could post any type of data. For example, older browsers don't validate number fields, so a user can type in a number outside the range we are expecting. Furthermore, a malicious user could try to send harmful data without using a browser at all. The browser validation should be considered as a nicety for the user and that's all.</li>
				<li>The browser does not allow us to do cross-field validation. For example, we can use the <code>required</code> attribute for inputs that are mandatory to be filled in. Often, though, we want to set the <code>required</code> attribute, based on the value of another input. For example, the email address input should only be set as <code>required</code> if the user has checked the <code>Register My Email</code> checkbox.</li>
			</ul>
			<p>The Django Forms library allows you to quickly define a form using a Python class. This is done by creating a subclass of the base Django <code>Form</code> class. You can then use an instance of this class to render the form in your template and validate the input data. We refer to our classes as forms, similar to how we subclass Django models to create our own <code>Model</code> classes. Forms contain one or more fields of a certain type (such as text fields, number fields, or email fields). You'll notice this sounds like Django models, and forms <em class="italic">are</em> similar to models but use different field classes. You can even automatically create a form from a model – we will cover this in <em class="italic">Chapter 7</em>,<em class="italic"> Advanced Form Validation and Model Forms</em>.</p>
			<h2 id="_idParaDest-205"><a id="_idTextAnchor220"/>Defining a Form</h2>
			<p>Creating a Django form is similar to creating a Django model. You define a class that inherits from the <code>django.forms.Form</code> class. The class has attributes, which are instances of different <code>django.forms.Field</code> subclasses. When rendered, the attribute name in the class corresponds to its input <code>name</code> in HTML. To give you a quick idea of what fields there are, some examples are <code>CharField</code>, <code>IntegerField</code>, <code>BooleanField</code>, <code>ChoiceField</code>, and <code>DateField</code>. Each field generally corresponds to one input when rendered in HTML, but there's not always a one-to-one mapping between a form field class and an input type. Form fields are more coupled to the type of data they collect rather than how they are displayed.</p>
			<p>To illustrate this, consider a <code>text</code> input and a <code>password</code> input. They both accept some typed-in text data, but the main difference between them is that the text is visibly displayed in a <code>text</code> input, whereas with a <code>password</code> input the text is obscured. In a Django form, both of these fields are represented using <code>CharField</code>. The difference in how they are displayed is set by changing the <em class="italic">widget</em> the field is using.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">If you're not familiar with the word <em class="italic">widget</em>, it is a term to describe the actual input that is being interacted with and how it is displayed. Text inputs, password inputs, select menus, checkboxes, and buttons are all examples of different widgets. The inputs we have seen in HTML correspond one-to-one with widgets. In Django, this is not the case, and the same type of <code>Field</code> class can be rendered in multiple ways depending on the widget that is specified.</p>
			<p>Django defines a number of <code>Widget</code> classes that define how a <code>Field</code> should be rendered as HTML. They inherit from <code>django.forms.widgets.Widget</code>. A widget can be passed to the <code>Field</code> constructor to change how it is rendered. For example, a <code>CharField</code> instance renders as <code>text</code> <code>&lt;input&gt;</code> by default. If we use the <code>PasswordInput</code> widget, it will instead render as <code>password</code> <code>&lt;input&gt;</code>. The other widgets we will use are as follows:</p>
			<ul>
				<li><code>RadioSelect</code>, which renders a <code>ChoiceField</code> instance as radio buttons instead of a <code>&lt;select&gt;</code> menu</li>
				<li><code>Textarea</code>, which renders a <code>CharField</code> instance as <code>&lt;textarea&gt;</code></li>
				<li><code>HiddenInput</code>, which renders a field as a hidden <code>&lt;input&gt;</code></li>
			</ul>
			<p>We will look at an example form and add fields and features one by one. First, let's just create a form with a text input and a password input:</p>
			<pre>from django import forms
class ExampleForm(forms.Form):
    text_input = forms.CharField()
    password_input = forms.CharField(widget=forms.PasswordInput)</pre>
			<p>The <code>widget</code> argument can be just a widget subclass, which can be fine a lot of the time. If you want to further customize the display of the input and its attributes, you can set the widget argument to an instance of the <code>widget</code> class instead. We will look at further customizing widget displays soon. In this case, we're using just the <code>PasswordInput</code> class, since we are not customizing it beyond changing the type of input being displayed.</p>
			<p>When the form is rendered in a template, it looks like this:</p>
			<div><div><img src="img/B15509_06_17.jpg" alt="Figure 6.17: Django form rendered in a browser&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.17: Django form rendered in a browser</p>
			<p>Note that the inputs do not contain any content when the page loads; the text has been entered to illustrate the different input types.</p>
			<p>If we examine the page source, we can see the HTML that Django generates. For the first two fields, it looks like this (some spacing added for readability):</p>
			<pre>&lt;p&gt;
    &lt;label for="id_text_input"&gt;Text input:&lt;/label&gt;
    &lt;input type="text" name="text_input" required id="id_text_input"&gt;
&lt;/p&gt;
&lt;p&gt;
    &lt;label for="id_password_input"&gt;Password input:&lt;/label&gt;
    &lt;input type="password" name="password_input" required id="id_password_input"&gt;
&lt;/p&gt;</pre>
			<p>Notice that Django has automatically generated a <code>label</code> instance with its text derived from the field name. The <code>name</code> and <code>id</code> attributes have been set automatically. Django also automatically adds the <code>required</code> attribute to the input. Similar to model fields, form field constructors also accept a <code>required</code> argument – this defaults to <code>True</code>. Setting this to <code>False</code> removes the <code>required</code> attribute from the generated HTML.</p>
			<p>Next, we'll look at how a checkbox is added to the form:</p>
			<ul>
				<li>A checkbox is represented with <code>BooleanField</code>, as it can have only two values, checked or unchecked. It's added to the form in the same way as the other field:<pre>class ExampleForm(forms.Form):
    …
    checkbox_on = forms.BooleanField()</pre><p>The HTML that Django generates for this new field is similar to the previous two fields:</p><pre>&lt;label for="id_checkbox_on"&gt;Checkbox on:&lt;/label&gt; 
&lt;input type="checkbox" name="checkbox_on" required id="id_checkbox_on"&gt;</pre></li>
			</ul>
			<p>Next are the select inputs:</p>
			<ul>
				<li>We need to provide a list of choices to display in the <code>&lt;select&gt;</code> dropdown.</li>
				<li>The field class constructor takes a <code>choices</code> argument. The choices are provided as a tuple of two-element tuples. The first element in each sub-tuple is the value of the choice and the second element is the text or description of the choice. For example, choices could be defined like this:<pre>BOOK_CHOICES = (('1', 'Deep Learning with Keras'),\
                ('2', 'Web Development with Django'),\
                ('3', 'Brave New World'),\
                ('4', 'The Great Gatsby'))</pre><p>Note that you can use lists instead of tuples if you want (or a combination of the two). This can be useful if you want your choices to be mutable:</p><pre>BOOK_CHOICES = (['1', 'Deep Learning with Keras'],\
                ['2', 'Web Development with Django'],\
                ['3', 'Brave New World'],\
                ['4', 'The Great Gatsby']]</pre></li>
				<li>To implement <code>optgroup</code>, we can nest the choices. To implement the choices the same way as our previous examples, we use a structure like this:<pre>BOOK_CHOICES = (('Non-Fiction', \
                 (('1', 'Deep Learning with Keras'),\
                 ('2', 'Web Development with Django'))),\
                ('Fiction', \
                 (('3', 'Brave New World'),\
                  ('4', 'The Great Gatsby'))))</pre><p>The <code>select</code> functionality is added to the form by using a <code>ChoiceField</code> instance. The widget defaults to a <code>select</code> input so no configuration is necessary apart from setting <code>choices</code>:</p><pre>class ExampleForm(forms.Form):
    …
    favorite_book = forms.ChoiceField(choices=BOOK_CHOICES)</pre></li>
			</ul>
			<p>This is the HTML that is generated:</p>
			<pre>&lt;label for="id_favorite_book"&gt;Favorite book:&lt;/label&gt;
&lt;select name="favorite_book" id="id_favorite_book"&gt;
    &lt;optgroup label="Non-Fiction"&gt;
        &lt;option value="1"&gt;Deep Learning with Keras&lt;/option&gt;
        &lt;option value="2"&gt;Web Development with Django&lt;/option&gt;
    &lt;/optgroup&gt;
    &lt;optgroup label="Fiction"&gt;
        &lt;option value="3"&gt;Brave New World&lt;/option&gt;
        &lt;option value="4"&gt;The Great Gatsby&lt;/option&gt;
    &lt;/optgroup&gt;
&lt;/select&gt;</pre>
			<p>Making a multiple select requires the use of <code>MultipleChoiceField</code>. It takes a <code>choices</code> argument in the same format as the regular <code>ChoiceField</code> for single selects:</p>
			<pre>class ExampleForm(forms.Form):
    …
    books_you_own = forms.MultipleChoiceField(choices=BOOK_CHOICES)</pre>
			<p>And its HTML is similar to that of the single select, except it has the <code>multiple</code> attribute added:</p>
			<pre>&lt;label for="id_books_you_own"&gt;Books you own:&lt;/label&gt;
&lt;select name="books_you_own" required id="id_books_you_own" multiple&gt;
    &lt;optgroup label="Non-Fiction"&gt;
        &lt;option value="1"&gt;Deep Learning with Keras&lt;/option&gt;
        &lt;option value="2"&gt;Web Development with Django&lt;/option&gt;
    &lt;/optgroup&gt;
    &lt;optgroup label="Fiction"&gt;
        &lt;option value="3"&gt;Brave New World&lt;/option&gt;
        &lt;option value="4"&gt;The Great Gatsby&lt;/option&gt;
    &lt;/optgroup&gt;
&lt;/select&gt;</pre>
			<p>Choices can also be set after the form is instantiated. You may want to generate the choices <code>list</code>/<code>tuple</code> inside your view dynamically and then assign it to the field's <code>choices</code> attribute. See the following, for example:</p>
			<pre>form = ExampleForm()
form.fields["books_you_own"].choices = \
[("1", "Deep Learning with Keras"), …]</pre>
			<p>Next are the radio inputs, which are similar to selects:</p>
			<ul>
				<li>Like selects, radio inputs use <code>ChoiceField</code>, as they provide a single choice between multiple options. </li>
				<li>The options to choose between are passed into the field constructor with the <code>choices</code> argument. </li>
				<li>The choices are provided as a tuple of two-element tuples, also like selects:</li>
			</ul>
			<pre>choices = (('1', 'Option One'),\
           ('2', 'Option Two'),\
           ('3', 'Option Three'))</pre>
			<p><code>ChoiceField</code> defaults to displaying as a <code>select</code> input, so the widget must be set to <code>RadioSelect</code> to have it rendered as radio buttons. Putting the choice setting together with this, we add radio buttons to the form like this:</p>
			<pre>RADIO_CHOICES = (('Value One', 'Value One'),\
                 ('Value Two', 'Value Two'),\
                 ('Value Three', 'Value Three'))
class ExampleForm(forms.Form):
    …
    radio_input = forms.ChoiceField(choices=RADIO_CHOICES,\
                                    widget=forms.RadioSelect)</pre>
			<p>Here is the HTML that is generated:</p>
			<pre>&lt;label for="id_radio_input_0"&gt;Radio input:&lt;/label&gt; 
&lt;ul id="id_radio_input"&gt;
&lt;li&gt;
    &lt;label for="id_radio_input_0"&gt;
        &lt;input type="radio" name="radio_input"          value="Value One" required id="id_radio_input_0"&gt;
        Value One
    &lt;/label&gt;
&lt;/li&gt;
&lt;li&gt;
    &lt;label for="id_radio_input_1"&gt;
        &lt;input type="radio" name="radio_input"          value="Value Two" required id="id_radio_input_1"&gt;
        Value Two
    &lt;/label&gt;
&lt;/li&gt;
&lt;li&gt;
    &lt;label for="id_radio_input_2"&gt;
        &lt;input type="radio" name="radio_input"          value="Value Three" required id="id_radio_input_2"&gt;
        Value Three
    &lt;/label&gt;
&lt;/li&gt;
&lt;/ul&gt;</pre>
			<p>Django automatically generates a unique label and ID for each of the three radio buttons:</p>
			<ul>
				<li>To create a <code>textarea</code> instance, use <code>CharField</code> with a <code>Textarea</code> widget:<pre>class ExampleForm(forms.Form):
    …
    text_area = forms.CharField(widget=forms.Textarea)</pre><p>You might notice that <code>textarea</code> is much larger than the previous ones we have seen (see the following figure):</p><div><img src="img/B15509_06_18.jpg" alt="Figure 6.18: Normal textarea (top) versus Django's default textarea (bottom)&#13;&#10;"/></div></li>
			</ul>
			<p class="figure-caption">Figure 6.18: Normal textarea (top) versus Django's default textarea (bottom)</p>
			<p>This is because Django automatically adds <code>cols</code> and <code>rows</code> attributes. These set the number of columns and rows, respectively, that the text field displays:</p>
			<pre>&lt;label for="id_text_area"&gt;Text area:&lt;/label&gt;
&lt;textarea name="text_area" cols="40"  rows="10" required id="id_text_area"&gt;&lt;/textarea&gt;</pre>
			<ul>
				<li>Note that the <code>cols</code> and <code>rows</code> settings do not affect the amount of text that can be entered into a field, only the amount that is displayed at a time. Also note that the size of <code>textarea</code> can be set using CSS (for example, the <code>height</code> and <code>width</code> properties). This will override the <code>cols</code> and <code>rows</code> settings.<p>To create <code>number</code> inputs, you might expect Django to have a <code>NumberField</code> type, but it does not.</p><p>Remember that the Django form fields are data-centric rather than display-centric, so instead, Django provides different <code>Field</code> classes depending on what type of numeric data you want to store:</p></li>
				<li>For integers, use <code>IntegerField</code>.</li>
				<li>For floating-point numbers, use <code>FloatField</code> or <code>DecimalField</code>. The latter two differ in how they convert their data to a Python value. </li>
				<li><code>FloatField</code> will convert to a float while <code>DecimalField</code> is a decimal.</li>
				<li>Decimal values offer better accuracy in representing numbers than float values but may not integrate well into your existing Python code.</li>
			</ul>
			<p>We'll add all three fields to the form at once:</p>
			<pre>class ExampleForm(forms.Form):
    …
    integer_input = forms.IntegerField()
    float_input = forms.FloatField()
    decimal_input = forms.DecimalField()</pre>
			<p>Here's the HTML for all three:</p>
			<pre>&lt;p&gt;
    &lt;label for="id_integer_input"&gt;Integer input:&lt;/label&gt;
    &lt;input type="number" name="integer_input"      required id="id_integer_input"&gt;
&lt;/p&gt;
&lt;p&gt;
    &lt;label for="id_float_input"&gt;Float input:&lt;/label&gt;
    &lt;input type="number" name="float_input"      step="any" required id="id_float_input"&gt;
&lt;/p&gt;
&lt;p&gt;
    &lt;label for="id_decimal_input"&gt;Decimal       input:&lt;/label&gt;
    &lt;input type="number" name="decimal_input"      step="any" required id="id_decimal_input"&gt;
&lt;/p&gt;</pre>
			<p>The <code>IntegerField</code> generated HTML is missing the <code>step</code> attribute that the other two have, which means the widget will only accept integer values. The other two fields (<code>FloatField</code> and <code>DecimalField</code>) generate very similar HTML. Their behavior is the same in the browser; they differ only when their values are used in Django code.</p>
			<p>As you might have guessed, an <code>email</code> input can be created with <code>EmailField</code>:</p>
			<pre>class ExampleForm(forms.Form):
    …
    email_input = forms.EmailField()</pre>
			<p>Its HTML is similar to the <code>email</code> input we created manually:</p>
			<pre>&lt;label for="id_email_input"&gt;Email input:&lt;/label&gt;
&lt;input type="email" name="email_input" required id="id_email_input"&gt;</pre>
			<p>Following our manually created form, the next field we will look at is <code>DateField</code>:</p>
			<ul>
				<li>By default, Django will render <code>DateField</code> as <code>text</code> input, and the browser will not show a calendar popup when the field is clicked.</li>
			</ul>
			<p>We can add <code>DateField</code> to the form with no arguments, like this:</p>
			<pre>class ExampleForm(forms.Form):
    …
    date_input = forms.DateField()</pre>
			<p>When rendered, it just looks like a normal <code>text</code> input:</p>
			<div><div><img src="img/B15509_06_19.jpg" alt="Figure 6.19: Default DateField display in a form&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.19: Default DateField display in a form</p>
			<p>Here is the HTML generated by default:</p>
			<pre>&lt;label for="id_date_input"&gt;Date input:&lt;/label&gt;
&lt;input type="text" name="date_input" required id="id_date_input"&gt;</pre>
			<p>The reason for using a <code>text</code> input is that it allows the user to enter the date in a number of different formats. For example, by default, the user can type in the date in <em class="italic">Year-Month-Day</em> (dash-separated) or <em class="italic">Month/Day/Year</em> (slash-separated) formats. The accepted formats can be specified by passing a list of formats to the <code>DateField</code> constructor using the <code>input_formats</code> argument. For example, we could accept dates in the formats of <em class="italic">Day/Month/Year</em> or <em class="italic">Day/Month/Year-with-century</em>, like this: </p>
			<pre>DateField(input_formats = ['%d/m/%y', '%d/%m/%Y'])</pre>
			<p>We can override any attributes on a field's widget by passing the <code>attrs</code> argument to the widget constructor. This accepts a dictionary of attribute key/values that will be rendered into the input's HTML.</p>
			<p>We have not used this yet, but we will see it again in the next chapter when we customize the field rendering further. For now, we'll just set one attribute, <code>type</code>, that will overwrite the default input type:</p>
			<pre>class ExampleForm(forms.Form):
    …
    date_input = forms.DateField\
                 (widget=forms.DateInput(attrs={'type': 'date'}))</pre>
			<p>When rendered, it now looks like the date field we had before, and clicking on it brings up the calendar date picker:</p>
			<div><div><img src="img/B15509_06_20.jpg" alt="Figure 6.20: DateField with date input&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.20: DateField with date input</p>
			<p>Examining the generated HTML now, we can see it uses the <code>date</code> type:</p>
			<pre>&lt;label for="id_date_input"&gt;Date input:&lt;/label&gt;
&lt;input type="date" name="date_input" required id="id_date_input"&gt;</pre>
			<p>The final input that we are missing is the hidden input.</p>
			<p>Once again, due to the data-centric nature of Django forms, there is no <code>HiddenField</code>. Instead, we choose the type of field that needs to be hidden and set its <code>widget</code> to <code>HiddenInput</code>. We can then set the value of the field using the field constructor's <code>initial</code> argument:</p>
			<pre>class ExampleForm(forms.Form):
    …
    hidden_input = forms.CharField\
                   (widget=forms.HiddenInput, \
                    initial='Hidden Value')</pre>
			<p>Here is the generated HTML:</p>
			<pre>&lt;input type="hidden" name="hidden_input"  value="Hidden Value" id="id_hidden_input"&gt;</pre>
			<p>Note that as this is a <code>hidden</code> input, Django does not generate a <code>label</code> instance or any surrounding <code>p</code> elements. There are other form fields that Django provides that work in similar ways. These range from <code>DateTimeField</code> (for capturing a date and time) to <code>GenericIPAddressField</code> (for either IPv4 or IPv6 addresses) and <code>URLField</code> (for URLs). A full list of fields is available at <a href="https://docs.djangoproject.com/en/3.0/ref/forms/fields/">https://docs.djangoproject.com/en/3.0/ref/forms/fields/</a>.</p>
			<h2 id="_idParaDest-206"><a id="_idTextAnchor221"/>Rendering a Form in a Template</h2>
			<p>We've now seen how to create a form and add fields, and we've seen what the form looks like and what HTML is generated. But how is the form actually rendered in the template? We simply instantiate the <code>Form</code> class and pass it to the <code>render</code> function in a view, using the context, just like any other variable.</p>
			<p>For example, here's how to pass our <code>ExampleForm</code> to a template:</p>
			<pre>def view_function(request):
    form = ExampleForm()
    return render(request, "template.html", {"form": form})</pre>
			<p>Django does not add the <code>&lt;form&gt;</code> element or submit button(s) for you when rendering the template; you should add these around where your form is placed in the template. The form can be rendered like any other variable.</p>
			<p>We mentioned briefly earlier that the form is rendered in the template using the <code>as_p</code> method. This layout method was chosen as it most closely matches the example form we built manually. Django offers three layout methods that can be used:</p>
			<ul>
				<li><code>as_table</code><p>The form is rendered as table rows, with each input on its own row. Django does not generate the surrounding <code>table</code> element, so you should wrap the form yourself. See the following example:</p><pre>&lt;form method="post"&gt;
    &lt;table&gt;
        {{ form.as_table }}
    &lt;/table&gt;
&lt;/form&gt;</pre><p><code>as_table</code> is the default rendering method, so <code>{{ form.as_table }}</code> and <code>{{ form }}</code> are equivalent. When rendered, the form looks like this:</p><div><img src="img/B15509_06_21.jpg" alt="Figure 6.21: Form rendered as a table&#13;&#10;"/></div></li>
			</ul>
			<p class="figure-caption">Figure 6.21: Form rendered as a table</p>
			<p>Here is a small sample of HTML that is generated:</p>
			<pre>&lt;tr&gt;
    &lt;th&gt;
        &lt;label for="id_text_input"&gt;Text input:&lt;/label&gt;
    &lt;/th&gt;
    &lt;td&gt;
        &lt;input type="text" name="text_input" required id="id_text_input"&gt;
    &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
    &lt;th&gt;
        &lt;label for="id_password_input"&gt;Password input:&lt;/label&gt;
    &lt;/th&gt;
    &lt;td&gt;
        &lt;input type="password" name="password_input" required id="id_password_input"&gt;
    &lt;/td&gt;
&lt;/tr&gt;</pre>
			<ul>
				<li><code>as_ul</code><p>This renders the form fields as list items (<code>li</code>) inside either a <code>ul</code> or <code>ol</code> element. Like with <code>as_table</code>, the containing element (<code>&lt;ul&gt;</code> or <code>&lt;ol&gt;</code>) is not created by Django and must be added by you:</p><pre>&lt;form method="post"&gt;
    &lt;ul&gt;
        {{ form.as_ul }}
    &lt;/ul&gt;
&lt;/form&gt;</pre><p>Here's how the form renders using <code>as_ul</code>:</p><p> </p><div><img src="img/B15509_06_22.jpg" alt="Figure 6.22: Form rendered using as_ul&#13;&#10;"/></div></li>
			</ul>
			<p class="figure-caption">Figure 6.22: Form rendered using as_ul</p>
			<p>And here's a sample of the generated HTML:</p>
			<pre>&lt;li&gt;
    &lt;label for="id_text_input"&gt;Text input:&lt;/label&gt;
    &lt;input type="text" name="text_input" required id="id_text_input"&gt;
&lt;/li&gt;
&lt;li&gt;
    &lt;label for="id_password_input"&gt;Password input:&lt;/label&gt;
    &lt;input type="password" name="password_input" required id="id_password_input"&gt;
&lt;/li&gt;</pre>
			<ul>
				<li><code>as_p</code><p>Finally, there is the <code>as_p</code> method, which we were using in our previous examples. Each input is wrapped within <code>p</code> tags, which means that you don't have to wrap the form manually (in <code>&lt;table&gt;</code> or <code>&lt;ul&gt;</code>) like you did with the previous methods:</p><pre>&lt;form method="post"&gt;
    {{ form.as_p }}
&lt;/form&gt;</pre><p>Here's what the rendered form looks like:</p><div><img src="img/B15509_06_23.jpg" alt="Figure 6.23: Form rendered using as_p&#13;&#10;"/></div></li>
			</ul>
			<p class="figure-caption">Figure 6.23: Form rendered using as_p</p>
			<p>And you've seen this before, but once again, here's a sample of the HTML generated:</p>
			<pre>&lt;p&gt;
    &lt;label for="id_text_input"&gt;Text input:&lt;/label&gt;
    &lt;input type="text" name="text_input" required id="id_text_input"&gt;
&lt;/p&gt;
&lt;p&gt;
    &lt;label for="id_password_input"&gt;Password input:&lt;/label&gt;
    &lt;input type="password" name="password_input" required       id="id_password_input"&gt;
&lt;/p&gt;</pre>
			<p>It is up to you to decide which method you want to use to render your form, depending on which suits your application best. In terms of their behavior and use with your view, all of the methods are all identical. In <em class="italic">Chapter 15</em>, <em class="italic">Django Third Party Libraries</em>, we will also introduce a method of rendering forms that will make use of the Bootstrap CSS classes.</p>
			<p>Now that we have been introduced to Django Forms, we can now update our example form page to use a Django Form instead of manually writing all the HTML ourselves.</p>
			<h2 id="_idParaDest-207"><a id="_idTextAnchor222"/>Exercise 6.03: Building and Rendering a Django Form</h2>
			<p>In this exercise, you will build a Django form using all the fields we have seen. The form and view will behave similarly to the form that we built manually; however, you will be able to see how much less code is required when writing forms using Django. Your form will also automatically get field validation, and if we make changes to the form, we don't have to then make changes to the HTML, as it will update dynamically based on the form definition:</p>
			<ol>
				<li value="1">In PyCharm, create a new file called <code>forms.py</code> inside the <code>form_example</code> app directory.</li>
				<li>Import the Django <code>forms</code> library at the top of your <code>forms.py</code> file:<pre>from django import forms</pre></li>
				<li>Define the choices for the radio buttons by creating a <code>RADIO_CHOICES</code> variable. Populate it as follows:<pre>RADIO_CHOICES = (("Value One", "Value One Display"),\
                 ("Value Two", "Text For Value Two"),\
                 ("Value Three", "Value Three's Display Text"))</pre><p>You will use this soon when you create a <code>ChoiceField</code> instance called <code>radio_input</code>.</p></li>
				<li>Define the nested choices for the book select inputs by creating a <code>BOOK_CHOICES</code> variable. Populate it as follows:<pre>BOOK_CHOICES = (("Non-Fiction", \
                 (("1", "Deep Learning with Keras"),\
                  ("2", "Web Development with Django"))),\
                 ("Fiction", \
                  (("3", "Brave New World"),\
                   ("4", "The Great Gatsby"))))</pre></li>
				<li>Create a class called <code>ExampleForm</code> that inherits from the <code>forms.Form</code> class:<pre>class ExampleForm(forms.Form):</pre><p>Add all of the following fields as attributes on the class:</p><pre>    text_input = forms.CharField()
    password_input = forms.CharField\
                     (widget=forms.PasswordInput)
    checkbox_on = forms.BooleanField()
    radio_input = forms.ChoiceField\
                  (choices=RADIO_CHOICES, \
                   widget=forms.RadioSelect)
    favorite_book = forms.ChoiceField(choices=BOOK_CHOICES)
    books_you_own = forms.MultipleChoiceField\
                    (choices=BOOK_CHOICES)
    text_area = forms.CharField(widget=forms.Textarea)
    integer_input = forms.IntegerField()
    float_input = forms.FloatField()
    decimal_input = forms.DecimalField()
    email_input = forms.EmailField()
    date_input = forms.DateField\
                 (widget=forms.DateInput\
                         (attrs={"type": "date"}))
    hidden_input = forms.CharField\
                   (widget=forms.HiddenInput, initial="Hidden Value")</pre><p>Save the file. </p></li>
				<li>Open your <code>form_example</code> app's <code>views.py</code> file. At the top of the file, add a line to import <code>ExampleForm</code> from your <code>forms.py</code> file:<pre>from .forms import ExampleForm</pre></li>
				<li>Inside the <code>form_example</code> view, instantiate the <code>ExampleForm</code> class and assign it to the <code>form</code> variable:<pre>    form = ExampleForm()</pre></li>
				<li>Add the <code>form</code> variable into the context dictionary, using the <code>form</code> key. The <code>return</code> line should look like this:<pre>    return render(request, "form-example.html",\
                  {"method": request.method, "form": form})</pre><p>Save the file. Make sure you haven't removed the code that prints out the data the form has sent, as we will use it again later in this exercise.</p></li>
				<li>Open the <code>form-example.html</code> file, inside the <code>form_example</code> app's <code>templates</code> directory. You can remove nearly all of the contents of the <code>form</code> element, except the <code>{% csrf_token %}</code> template tag and the submit buttons. When you're done, it should look like this:<pre>&lt;form method="post"&gt;
    {% csrf_token %}
    &lt;p&gt;
        &lt;input type="submit" name="submit_input" value="Submit Input"&gt;
    &lt;/p&gt;
    &lt;p&gt;
        &lt;button type="submit" name="button_element" value="Button Element"&gt;
            Button With &lt;strong&gt;Styled&lt;/strong&gt; Text
        &lt;/button&gt;
    &lt;/p&gt;
&lt;/form&gt;</pre></li>
				<li>Add a rendering of the <code>form</code> variable using the <code>as_p</code> method. Put this on the line after the <code>{%</code><code> csrf_token %}</code> template tag. The whole <code>form</code> element should now look like this:<pre>&lt;form method="post"&gt;
    {% csrf_token %}
    {{ form.as_p }}
    &lt;p&gt;
        &lt;input type="submit" name="submit_input" value="Submit Input"&gt;
    &lt;/p&gt;
    &lt;p&gt;
        &lt;button type="submit" name="button_element"           value="Button Element"&gt;
            Button With &lt;strong&gt;Styled&lt;/strong&gt; Text
        &lt;/button&gt;
    &lt;/p&gt;
&lt;/form&gt;</pre></li>
				<li>Start the Django dev server if it is not already running, then visit the form example page in your browser, at <code>http://127.0.0.1:8000/form-example/</code>. It should look as follows:<div><img src="img/B15509_06_24.jpg" alt="Figure 6.24: Django ExampleForm rendered in the browser&#13;&#10;"/></div><p class="figure-caption">Figure 6.24: Django ExampleForm rendered in the browser</p></li>
				<li>Enter some data in the form – since Django marks all fields as required, you will need to enter some text or select values for all fields, including ensuring that the checkbox is checked. Submit the form.</li>
				<li>Switch back to PyCharm and look in the Debug Console at the bottom of the window. You should see all the values being submitted by the form are printed out to the console, similar to <em class="italic">Exercise 6.02, Working with POST Data in a View</em>:<div><img src="img/B15509_06_25.jpg" alt="Figure 6.25: Values as submitted by the Django form&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 6.25: Values as submitted by the Django form</p>
			<p>You can see that the values are still strings, and the names match those of the attributes of <code>ExampleForm</code> class. Notice that the submit button that you clicked is included, as well as the CSRF token. The form you submit can be a mix of Django form fields and arbitrary fields you add; both will be contained in the <code>request.POST</code> <code>QueryDict</code> object.</p>
			<p>In this exercise, you created a Django form, with many different types of form fields. You instantiated it into a variable in your view, then passed it to <code>form-example.html</code> where it was rendered as HTML. Finally, you submitted the form and looked at the values it posted. Notice that the amount of code we had to write to generate the same form was greatly reduced. We did not have to manually code any HTML and we now have one place that both defines how the form will display and how it will validate. In the next section, we will examine how Django forms can automatically validate the submitted data, as well as how the data is converted from strings to Python objects.</p>
			<h1 id="_idParaDest-208"><a id="_idTextAnchor223"/>Validating Forms and Retrieving Python Values</h1>
			<p>So far, we have seen how Django Forms makes it much simpler to define a form using Python code and have it automatically rendered. We will now look at the other part of what makes Django forms useful: their ability to automatically validate the form and then retrieve native Python objects and values from them.</p>
			<p>In Django, a form can either be <em class="italic">unbound</em> or <em class="italic">bound</em>. These terms describe whether or not the form has had the submitted <code>POST</code> data sent to it for validation. So far, we have only seen unbound forms – they are instantiated without arguments, like this:</p>
			<pre>form = ExampleForm()</pre>
			<p>A form is bound if it is called with some data to be used for validation, such as the <code>POST</code> data. A bound form can be created like this:</p>
			<pre>form = ExampleForm(request.POST)</pre>
			<p>A bound form allows us to start using built-in validation-related tools: first, the <code>is_valid</code> method to check the form's validity, then the <code>cleaned_data</code> attribute on the form, which contains the values converted from strings to Python objects. The <code>cleaned_data</code> attribute is only available after the form has been <em class="italic">cleaned</em>, which means the process of "cleaning up" the data and converting it from strings to Python objects. The cleaning process runs during the <code>is_valid</code> call. You will get <code>AttributeError</code> raised if you try to access <code>cleaned_data</code> before calling <code>is_valid</code>.</p>
			<p>A short example of how to access the cleaned data of <code>ExampleForm</code> follows:</p>
			<pre>form = ExampleForm(request.POST)
if form.is_valid():
    # cleaned_data is only populated if the form is valid
    if form.cleaned_data["integer_input"] &gt; 5:
        do_something()</pre>
			<p>In this example, <code>form.cleaned_data["integer_input"]</code> is the integer value <code>10</code>, so it can be compared to the number <em class="italic">5</em>. Compare this to the value that was posted, which is the string <code>"10"</code>. The cleaning process performs this conversion for us. Other fields such as dates or Booleans are converted accordingly.</p>
			<p>The cleaning process also sets any errors on the form and fields that will be displayed when the form is rendered again. Let's see all this in action. Modern browsers provide a large amount of client-side validation, so they prevent forms from being submitted unless their basic validation rules are met. You might have already seen this if you tried to submit the form in the previous exercise with empty fields:</p>
			<div><div><img src="img/B15509_06_26.jpg" alt="Figure 6.26: Form submission prevented by the browser&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.26: Form submission prevented by the browser</p>
			<p><em class="italic">Figure 6.26</em> shows the browser preventing form submission. Since the browser is preventing the submission, Django never gets the opportunity to validate the form itself. To allow the form to be submitted, we need to add some more advanced validation that the browser is unable to validate itself. </p>
			<p>We will discuss the different types of validations that can be applied to form fields in the next section, but for now, we will just add a <code>max_digits</code> setting of <code>3</code> to <code>decimal_input</code> for our <code>ExampleForm</code>. This means the user should not enter more than three digits into the form. </p>
			<p class="callout-heading">Note</p>
			<p class="callout">Why should Django validate the form if the browser is already doing this and preventing submission? A server-side application should never trust input from the user: the user might be using an older browser or another HTTP client to send the request, thus not receiving any errors from their "browser." Also, as we have just mentioned, there are types of validation that the browser does not understand, and so Django must validate these on its end.</p>
			<p><code>ExampleForm</code> is updated like this:</p>
			<pre>class ExampleForm(forms.Form):
    …
    decimal_input = forms.DecimalField(max_digits=3)
    …</pre>
			<p>Now the view should be updated to pass <code>request.POST</code> to the <code>Form</code> class when the method is <code>POST</code>, for example, like this:</p>
			<pre>if request.method == "POST":
    form = ExampleForm(request.POST)
else:
    form = ExampleForm()</pre>
			<p>If you pass <code>request.POST</code> into the form constructor when the method is not <code>POST</code>, then the form will always contain errors when first rendered, as <code>request.POST</code> will be empty. Now the browser will let us submit the form, but we will get an error displayed if the <code>decimal_input</code> contains more than three digits:</p>
			<div><div><img src="img/B15509_06_27.jpg" alt="Figure 6.27: An error displayed when a field is not valid&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.27: An error displayed when a field is not valid</p>
			<p>Django is automatically rendering the form differently in the template when it has errors. But how can we make the view behave differently depending on the validity of the form? As we mentioned earlier, we should use the form's <code>is_valid</code> method. A view using this check might have code like this:</p>
			<pre>form = ExampleForm(request.POST)
if form.is_valid():
    # perform operations with data from form.cleaned_data
    return redirect("/success-page")  # redirect to a success page</pre>
			<p>In this example, we are redirecting to a success page if the form is valid. Otherwise, assume the execution flow continues as before and passes the invalid form back to the <code>render</code> function to be displayed to the user with errors.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Why do we return a redirect on success? For two reasons: first, an early return prevents the execution of the rest of the view (that is, the failure branch); second, it prevents the message about resending the form data if the user then reloads the page.</p>
			<p>In the next exercise, we will see the form validation in action and change the view execution flow based on the validity of the form.</p>
			<h2 id="_idParaDest-209"><a id="_idTextAnchor224"/>Exercise 6.04: Validating Forms in a View</h2>
			<p>In this exercise, we will update the example view to instantiate the form differently depending on the HTTP method. We will also change the form to print out the cleaned data instead of the raw <code>POST</code> data, but only if the form is valid:</p>
			<ol>
				<li value="1">In PyCharm, open the <code>forms.py</code> file inside the <code>form_example</code> app directory. Add a <code>max_digits=3 </code>argument to <code>decimal_input</code> of <code>ExampleForm</code>:<pre>class ExampleForm(forms.Form):
    …
    decimal_input = forms.DecimalField(max_digits=3)</pre><p>Once this argument is added, we can submit the form, since the browser does not know how to validate this rule, but Django does.</p></li>
				<li>Open the <code>reviews</code> app's <code>views.py</code> file. We need to update the <code>form_example</code> view so that if the request's method is <code>POST</code>, the <code>ExampleForm</code> is instantiated with the <code>POST</code> data; otherwise, it's instantiated without arguments. Replace the current form initialization with this code:<pre>def form_example(request):
    if request.method == "POST":
        form = ExampleForm(request.POST)
    else:
        form = ExampleForm()</pre></li>
				<li>Next, also for the <code>POST</code> request method, we will check whether the form is valid using the <code>is_valid</code> method. If the form is valid, we will print out all of the cleaned data. Add a condition after the <code>ExampleForm</code> instantiation to check <code>form.is_valid()</code>, then move the debug print loop inside this condition. Your <code>POST</code> branch should look like this:<pre>    if request.method == "POST":
        form = ExampleForm(request.POST)
        if form.is_valid():
            for name in request.POST:
                print("{}: {}".format\
                               (name, request.POST.getlist(name)))</pre></li>
				<li>Instead of iterating over the raw <code>request.POST</code> <code>QueryDict</code> (in which all the data are <code>string</code> instances), we will iterate over <code>cleaned_data</code> of <code>form</code>. This is a normal dictionary and contains the values converted to Python objects. Replace the <code>for</code> line and <code>print</code> line with these two:<pre>            for name, value in form.cleaned_data.items():
                print("{}: ({}) {}".format\
                                    (name, type(value), value))</pre><p>We don't need to use <code>getlist()</code> anymore, as <code>cleaned_data</code> has already converted the multi-value fields into <code>list</code> instances.</p></li>
				<li>Start the Django dev server, if it is not already running. Switch to your browser and browse to the example form page at <code>http://127.0.0.1:8000/form-example/</code>. The form should look as it did before. Fill in all the fields, but be sure to enter four or more numbers into the <code>Decimal input</code> field to make the form invalid. Submit the form, and you should see the error message for <code>Decimal input</code> show up when the page refreshes:<div><img src="img/B15509_06_28.jpg" alt="Figure 6.28: Decimal input error displayed after the form is submitted&#13;&#10;"/></div><p class="figure-caption">Figure 6.28: Decimal input error displayed after the form is submitted</p></li>
				<li>Fix the form errors by making sure only three digits are in the <code>Decimal input</code> field, then submit the form again. Switch back to PyCharm and check the debug console. You should see that all the cleaned data has been printed out:<div><img src="img/B15509_06_29.jpg" alt="Figure 6.29: Cleaned data from the form printed out&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 6.29: Cleaned data from the form printed out</p>
			<p>Notice the conversions that have taken place. The <code>CharField</code> instances have been converted to <code>str</code>, <code>BooleanField</code> to <code>bool</code>, and <code>IntegerField</code>, <code>FloatField</code>, and <code>DecimalField</code> to <code>int</code>, <code>float</code>, and <code>Decimal</code>, respectively. <code>DateField</code> becomes <code>datetime.date</code> and the choice fields retain the string values of their initial choice values. Notice that <code>books_you_own</code> is automatically converted to a <code>list</code> of <code>str</code> instances.</p>
			<p>Also, note that unlike when we iterated over all of the <code>POST</code> data, <code>cleaned_data</code> only contains form fields. The other data (such as the CSRF token and the submit button that was clicked) is present in the <code>POST</code> <code>QueryDict</code> but is not included as it does not include form fields.</p>
			<p>In this exercise, you updated <code>ExampleForm</code> so the browser allowed it to be submitted even though Django would consider it to be invalid. This allowed Django to perform its validation on the form. You then updated the <code>form_example</code> view to instantiate the <code>ExampleForm</code> class differently depending on the HTTP method; passing in the request's <code>POST</code> data for a <code>POST</code> request. The view also had its debug output code updated to <code>print</code> out the <code>cleaned_data</code> dictionary. Finally, you tested submitting valid and invalid form data to see the different execution paths and the types of data that the form generated. We saw that Django automatically converted the <code>POST</code> data from strings to Python types based on the field class.</p>
			<p>Next, we will look at how to add more validation options to fields, which will allow us to more tightly control the values that can be entered.</p>
			<h2 id="_idParaDest-210"><a id="_idTextAnchor225"/>Built-In Field Validation</h2>
			<p>We have not yet discussed the standard validation arguments that can be used on fields. Although we already mentioned the <code>required</code> argument (which is <code>True</code> by default), many others can be used to more tightly control the data being entered into a field. Here are a few useful ones:</p>
			<ul>
				<li><code>max_length</code><p>Sets the maximum number of characters that can be entered into the field; available on <code>CharField</code> (and <code>FileField</code>, which we will cover in <em class="italic">Chapter 8</em>, <em class="italic">Media Serving and File Uploads</em>).</p></li>
				<li><code>min_length</code><p>Sets the minimum number of characters that must be entered into the field; available on <code>CharField</code> (and <code>FileField</code>; again, more about this in <em class="italic">Chapter 8</em>, <em class="italic">Media Serving and File Uploads</em>).</p></li>
				<li><code>max_value</code><p>Sets the maximum value that can be entered into a numeric field; available on <code>IntegerField</code>, <code>FloatField</code>, and <code>DecimalField</code>.</p></li>
				<li><code>min_value</code><p>Sets the minimum value that can be entered into a numeric field; available on <code>IntegerField</code>, <code>FloatField</code>, and <code>DecimalField</code>.</p></li>
				<li><code>max_digits</code><p>This sets the maximum number of digits that can be entered; this includes digits before and after a decimal point (if one exists). For example, the number <em class="italic">12.34</em> has four digits, and the number <em class="italic">56.7</em> has three. Used in <code>DecimalField</code>.</p></li>
				<li><code>decimal_places</code><p>This sets the maximum number of digits that can be after the decimal point. This is used in conjunction with <code>max_digits</code>, and the number of decimal places will always count toward the number of digits even if that number of decimals has not been entered after the decimal place. For example, imagine using <code>max_digits</code> of four and <code>decimal_places</code> of three: if the number <em class="italic">12.34</em> was entered, it would actually be interpreted as the value <em class="italic">12.340</em>; that is, zeros are appended until the number of digits after the decimal point is equal to the <code>decimal_places</code> setting. Since we set three as the value for <code>decimal_places</code>, the total number of digits ends up being five, which exceeds the <code>max_digits</code> setting of four. The number <em class="italic">1.2</em> would be valid since even after expanding to <em class="italic">1.200</em>, the total number of digits is only four.</p></li>
			</ul>
			<p>You can mix and match the validation rules (provided that the fields support them). <code>CharField</code> can have <code>max_length</code> and <code>min_length</code>, numeric fields can have both <code>min_value</code> and <code>max_value</code>, and so on.</p>
			<p>If you need more validation options, you can write custom validators, which we will cover in the next section. Right now, we will add some validators to our <code>ExampleForm</code> to see them in action.</p>
			<h2 id="_idParaDest-211"><a id="_idTextAnchor226"/>Exercise 6.05: Adding Extra Field Validation</h2>
			<p>In this exercise, we will add and modify the validation rules for the fields of <code>ExampleForm</code>. We will then see how these changes affect how the form behaves, both in the browser and when Django validates the form:</p>
			<ol>
				<li value="1">In PyCharm, open the <code>forms.py</code> file inside the <code>form_example</code> app directory. </li>
				<li>We will make <code>text_input</code> require at most three characters. Add a <code>max_length=3</code> argument to the <code>CharField</code> constructor:<pre>text_input = forms.CharField(max_length=3)</pre></li>
				<li>Make <code>password_input</code> more secure by requiring a minimum of eight characters. Add a <code>min_length=8</code> argument to the <code>CharField</code> constructor:<pre>password_input = forms.CharField(min_length=8, \
                                 widget=forms.PasswordInput)</pre></li>
				<li>The user may have no books, so the <code>books_you_own</code> field should not be required. Add a <code>required=False</code> argument to the <code>MultipleChoiceField</code> constructor:<pre>books_you_own = forms.MultipleChoiceField\
                (required=False, choices=BOOK_CHOICES)</pre></li>
				<li>The user should only be able to enter a value between 1 and 10 in <code>integer_input</code>. Add <code>min_value=1</code> and <code>max_value=10</code> arguments to the <code>IntegerField</code> constructor:<pre>integer_input = forms.IntegerField\
                (min_value=1, max_value=10)</pre></li>
				<li>Finally, add <code>max_digits=5</code> and <code>decimal_places=3</code> to the <code>DecimalField</code> constructor:<pre>decimal_input = forms.DecimalField\
                (max_digits=5, decimal_places=3)</pre><p>Save the file.</p></li>
				<li>Start the Django dev server if it's not already running. We do not have to make any changes to any other files to get these new validation rules, since Django automatically updates the HTML generation and validation logic. This is a great benefit you get from using Django forms. Just visit or refresh <code>http://127.0.0.1:8000/form-example/</code> in your browser and the new validation will be automatically added. The form should not look any different until you try to submit it with incorrect values, in which case your browser can automatically show errors. Some things to try are as follows:<p>Enter more than three characters into the <code>Text input</code> field; you will not be able to.</p><p>Type fewer than eight characters into the <code>Password</code> field then click away from it. The browser should show an error indicating that this is not valid.</p><p>Do not select any values for the <code>Books you own</code> field. This will not prevent you from submitting the form anymore.</p><p>Use the stepper buttons on <code>Integer input</code>. You will only be able to enter a value between <code>1</code> and <code>10</code>. If you type in a value outside this range, your browser should show an error.</p><p><code>Decimal input</code> is the only field that does not validate the Django rules in the browser. You will need to type in an invalid value (such as <code>123.456</code>) and submit the form before an error (generated by Django) is displayed.</p><p>The following figure shows some of the fields that the browser can validate itself:</p><div><img src="img/B15509_06_30.jpg" alt="Figure 6.30: Browser performing validation with the new rules&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 6.30: Browser performing validation with the new rules</p>
			<p><em class="italic">Figure 6.31</em> shows an error that can only be generated by Django as the browser does not understand the <code>DecimalField</code> validation rules:</p>
			<div><div><img src="img/B15509_06_31.jpg" alt="Figure 6.31: The browser considers the form valid, but Django does not&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.31: The browser considers the form valid, but Django does not</p>
			<p>In this exercise, we implemented some basic validation rules on our form fields. We then loaded the form example page in the browser, without having to make any changes to our template or view. We tried to submit the form with different values to see how the browser can validate the form compared to Django.</p>
			<p>In the activity for this chapter, we will implement the Book Search view using a Django form.</p>
			<h2 id="_idParaDest-212"><a id="_idTextAnchor227"/>Activity 6.01: Book Searching</h2>
			<p>In this activity, you will finish the Book Search view that was started in <em class="italic">Chapter 1</em>, <em class="italic">Introduction to Django</em>. You will build a <code>SearchForm</code> instance that submits and accepts a search string from <code>request.GET</code>. It will have a <code>select</code> field to choose to search for <code>title</code> or <code>contributor</code>. It will then search for all <code>Book</code> instances containing the given text in <code>title</code> or in <code>first_names</code> or <code>last_names</code> of <code>Contributor</code>. You will then render this list of books in the <code>search-results.html</code> template. The search term should not be required, but if it exists, it should have a length of three or fewer characters. Since the view will search even when using the <code>GET</code> method, the form will always have its validation checked. If we made the field <code>required</code>, it would always show an error whenever the page loads.</p>
			<p>There will be two ways of performing the search. The first is by submitting the search form that is in the <code>base.html</code> template and thus in the top-right corner of every page. This will only search through <code>Book</code> titles. The other method is by submitting a <code>SearchForm</code> instance that is rendered on the <code>search-results.html</code> page. This form will display the <code>ChoiceField</code> instance for choosing between <code>title</code> or <code>contributor</code> search.</p>
			<p>These steps will help you complete this activity:</p>
			<ol>
				<li value="1">Create a <code>SearchForm</code> instance in your <code>forms.py</code> file.</li>
				<li><code>SearchForm</code> should have two fields. The first is a <code>CharField</code> instance with the name <code>search</code>. This field should not be required but should have a minimum length of <code>3</code>.</li>
				<li>The second field on <code>SearchForm</code> is a <code>ChoiceField</code> instance named <code>search_in</code>. This will allow selecting between <code>title</code> and <code>contributor</code> (with <code>Title</code> and <code>Contributor</code> labels, respectively). It should not be <code>required</code>.</li>
				<li>Update the <code>book_search</code> view to instantiate a <code>SearchForm</code> instance using data from <code>request.GET</code>.</li>
				<li>Add code to search for <code>Book</code> models using <code>title__icontains</code> (for case-insensitive searching). This should be done if searching by <code>title</code>. The search should only be performed if the form is valid and contains some search text. The <code>search_in</code> value should be retrieved from <code>cleaned_data</code> using the <code>get</code> method since it might not exist, as it's not required. Set its default to <code>title</code>.</li>
				<li>When searching for contributors, use <code>first_names__icontains</code> or <code>last_names__icontains</code>, then iterate the contributors and retrieve the books for each contributor. This should be done if searching by <code>contributor</code>. The search should only be performed if the form is valid and contains some search text. There are many ways to combine the search results for a first or last name. The easiest method, using the techniques that you have been introduced to so far, is to perform two queries, one for matching first names and then for last names, and iterating them separately.</li>
				<li>Update the <code>render</code> call to include the <code>form</code> variable and the books that were retrieved in the context (as well as <code>search_text</code> that was already being passed). The location of the template was changed in <em class="italic">Chapter 3</em>, <em class="italic">URL Mapping, Views, and Templates</em>, so update the second argument to <code>render</code> accordingly.</li>
				<li>The <code>search-results.html</code> template we created in <em class="italic">Chapter 1</em>, <em class="italic">Introduction to Django</em>, is essentially redundant now, so you can clear its content. Update the <code>search-results.html</code> file to extend from <code>base.html</code> instead of being a standalone template file.</li>
				<li>Add a <code>title</code> block that will display <code>Search Results for &lt;search_text&gt;</code> if the form is valid and <code>search_text</code> was set and will otherwise just display <code>Book Search</code>. This block will also be added to <code>base.html</code> later in this activity.</li>
				<li>Add a <code>content</code> block, which should show an <code>&lt;h2&gt;</code> heading with the text <code>Search for Books</code>. Under the <code>&lt;h2&gt;</code> heading, render the form. The <code>&lt;form&gt;</code> element can have no attributes and it will default to making a <code>GET</code> request to the same URL that it's on. Add a submit button as we have used in previous activities, with the <code>btn btn-primary</code> class.</li>
				<li>Under the form, show a <code>Search results for &lt;search_text&gt;</code> message if the form is valid and search text was entered, otherwise show no message. This should be displayed in an <code>&lt;h3&gt;</code> heading, and the search text should be wrapped in <code>&lt;em&gt;</code>.</li>
				<li>Iterate over the search results and render each one. Show the book title and contributor's first and last names. The book title should link to the <code>book_detail</code> page. If the books list is empty, show the text <code>No results found</code>. You should wrap the results in <code>&lt;ul&gt;</code> with <code>class</code> <code>list-group</code>, and each result should be an <code>&lt;li&gt;</code> instance with <code>class</code> <code>list-group-item</code>. This will be similar to the <code>book_list</code> page; however, we won't show as much information (just the title and contributors). </li>
				<li>Update <code>base.html</code> to include an action attribute in the search <code>&lt;form&gt;</code> tag. Use the <code>url</code> template tag to generate the URL for this attribute.</li>
				<li>Set the <code>name</code> attribute of the search field to <code>search</code> and the <code>value</code> attribute to the search text that was entered. Also, ensure that the minimum length of the field is <code>3</code>.</li>
				<li>In <code>base.html</code>, add a <code>title</code> block to the <code>title</code> tag that was overridden by other templates (as in <em class="italic">step 9</em>). Add a <code>block</code> template tag inside the <code>&lt;title&gt;</code> HTML element. It should have the content <code>Bookr</code>.</li>
			</ol>
			<p>After completing this activity, you should be able to open the Book Search page at <code>http://127.0.0.1:8000/book-search/</code> and it will look like <em class="italic">Figure 6.32</em>:</p>
			<div><div><img src="img/B15509_06_32.jpg" alt="Figure 6.32: Book Search page without a search&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.32: Book Search page without a search</p>
			<p>When searching for something using just two characters, your browser should prevent you from submitting either of the search fields. If you search for something that returns no results, you will see a message that there were no results. Searching by title (this can be done with either field) will show matching results.</p>
			<p>Similarly, when searching by the contributor (although this can only be done in the lower form), you should see something like the following:</p>
			<div><div><img src="img/B15509_06_33.jpg" alt="Figure 6.33: A contributor search&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.33: A contributor search</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution to this activity can be found at <a href="http://packt.live/2Nh1NTJ">http://packt.live/2Nh1NTJ</a>.</p>
			<h1 id="_idParaDest-213"><a id="_idTextAnchor228"/>Summary</h1>
			<p>This chapter was an introduction to forms in Django. We introduced some HTML inputs for entering data onto a web page. We talked about how data is submitted to a web application and when to use <code>GET</code> and <code>POST</code> requests. We then looked at how Django's form classes can make generating the form HTML simpler, as well as allowing the automatic building of forms using models. We enhanced Bookr some more by building the book search functionality.</p>
			<p>In the next chapter, we will go deeper into forms and learn how to customize the display of form fields, how to add more advanced validation to your form, and how to automatically save model instances by using the <code>ModelForm</code> class.</p>
		</div>
	</body></html>