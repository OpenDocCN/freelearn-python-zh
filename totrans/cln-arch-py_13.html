<html><head></head><body><div id="book-content"><div id="sbo-rt-content"><div id="_idContainer065">
    <h1 class="chapterNumber"><a id="_idTextAnchor235"/>10</h1>
    <h1 id="_idParaDest-221" class="chapterTitle"><a id="_idTextAnchor236"/>Implementing Observability: Monitoring and Verification</h1>
    <p class="normal">In previous chapters, we established Clean Architecture’s core principles through our task management system. We built domain entities, implemented use cases, and created both CLIs and web interfaces that demonstrate how Clean Architecture’s boundaries enable clean separation between our core business logic and external concerns. While these boundaries make our system more maintainable, they serve another crucial purpose. They make our system more observable and its architectural integrity more verifiable.</p>
    <p class="normal">Through our task management system, we’ll demonstrate how Clean Architecture transforms system observability from a cross-cutting concern into a structured capability. Because our system is built with clear architectural layers and explicit interfaces, monitoring becomes a natural extension of our existing structure. This same organization that simplifies monitoring also enables continuous verification, helping ensure our system maintains its architectural integrity as it evolves.</p>
    <p class="normal">By the end of this chapter, you’ll understand how to implement effective observability in Clean Architecture systems and how to verify architectural boundaries remain intact over time. You’ll learn practical techniques for detecting and preventing architectural drift, helping ensure your systems maintain their clean structure even as requirements and teams evolve.</p>
    <p class="normal">In this chapter, we’re going to cover the following main topics:</p>
    <ul>
      <li class="bulletList">Understanding observability in Clean Architecture</li>
      <li class="bulletList">Implementing cross-boundary instrumentation</li>
      <li class="bulletList">Maintaining architectural integrity through monitoring</li>
    </ul>
    <h1 id="_idParaDest-222" class="heading-1"><a id="_idTextAnchor237"/>Technical requirements</h1>
    <p class="normal">The code examples presented in this chapter and throughout the rest of the book are tested with Python 3.13. For brevity, most code examples in the chapter are only partially implemented. Complete versions of all examples can be found in the book’s accompanying GitHub repository at <a href="https://github.com/PacktPublishing/Clean-Architecture-with-Python"><span class="url">https://github.com/PacktPublishing/Clean-Architecture-with-Python</span></a>.</p>
    <h1 id="_idParaDest-223" class="heading-1"><a id="_idTextAnchor238"/>Understanding observability boundaries in Clean Architecture</h1>
    <p class="normal">Clean Architecture’s explicit layer perimeters provide natural points for system observation which is a <a id="_idIndexMarker535"/>significant advantage that many teams overlook. While layered architectures can introduce complexity, these same divisions that help manage dependencies also enable systematic monitoring and observability. Let’s first explore how Clean Architecture’s fundamental principles create opportunities for better system instrumentation, setting the foundation for the practical implementations we’ll explore later. By understanding these concepts, you’ll see how Clean Architecture makes systems not only more maintainable but also more observable.</p>
    <h2 id="_idParaDest-224" class="heading-2"><a id="_idTextAnchor239"/>Natural observation points in Clean Architecture</h2>
    <p class="normal">Clean Architecture’s layered structure naturally creates strategic points for system observation. Before exploring these observation points, let’s understand what we mean by observability <a id="_idIndexMarker536"/>in software systems. Modern observability combines logging, metrics, and request tracing to provide a complete picture of system behavior. In traditional systems where these concerns cut across all components, implementing comprehensive monitoring often becomes an exercise in working around tangled dependencies.</p>
    <p class="normal">Clean Architecture transforms this complexity into clarity by providing consistent observation points at each layer transition. Consider how information flows through our task management system: when a user creates a task through the web interface, we can observe the request as it moves through our architectural layers, from initial HTTP handling, through business operations, to final persistence. Each layer boundary provides specific insight:</p>
    <ul>
      <li class="bulletList">Our web interface tracks incoming requests and their transformations.</li>
      <li class="bulletList">Use cases monitor business operations and their outcomes.</li>
      <li class="bulletList">Domain entities capture state changes and business rule applications.</li>
      <li class="bulletList">Infrastructure components measure resource utilization and external interactions.</li>
    </ul>
    <p class="normal">This systematic approach ensures we have visibility into every crucial aspect of our system’s behavior while maintaining clean separation between technical and business concerns. This transforms not just monitoring but our entire approach to system maintenance. When investigating <a id="_idIndexMarker537"/>issues or analyzing performance, we know exactly where to look for relevant information. As we’ll see in the following sections, this same structured approach that enables monitoring also provides the foundation for verifying our architectural integrity.</p>
    <h2 id="_idParaDest-225" class="heading-2"><a id="_idTextAnchor240"/>Understanding observability in Clean Architecture</h2>
    <p class="normal">Having seen how Clean Architecture provides natural observation points, let’s explore how to effectively <a id="_idIndexMarker538"/>leverage these points in practice. While previous chapters focused on establishing core architectural principles, real-world systems require observability from the start. Early instrumentation proves crucial. Without it, debugging becomes more challenging, performance issues go undetected, and understanding system behavior across different environments becomes nearly impossible.</p>
    <p class="normal">Consider how this plays out in our task management system. <em class="italic">Figure 10.1</em> shows how a seemingly simple operation like task completion involves multiple architectural transitions, each providing distinct observability needs:</p>
    <figure class="mediaobject"><img src="../Images/B31577_10_1.png" alt="Figure 10.1: Task completion flow with observation points" width="1650" height="656"/></figure>
    <p class="packt_figref">Figure 10.1: Task completion flow with observation points</p>
    <p class="normal">The figure illustrates how monitoring concerns naturally align with our architectural layers. At each transition, we capture specific aspects of system behavior, from technical metrics at our outer boundaries to business operations in our core layers. This systematic approach ensures we maintain comprehensive visibility while respecting Clean Architecture’s separation of concerns.</p>
    <p class="normal">A layered monitoring approach provides clear benefits. When investigating issues, we can trace operations through our system with precision. If a customer reports intermittent task completion failures, we can follow the operation from web request through business logic to identify exactly where things went wrong. Performance bottlenecks become easier to locate since we know <a id="_idIndexMarker539"/>which layer is handling each aspect of the operation.</p>
    <p class="normal">Each layer contributes what it knows best. Web interfaces track request handling, use cases monitor business operations, and infrastructure captures technical metrics. By respecting these natural divisions, we maintain clean separation between business and technical concerns while ensuring comprehensive visibility into our system’s behavior.</p>
    <p class="normal">These monitoring principles translate directly into implementation patterns. In our task management system, we’ll use Python’s standard logging framework to implement this layered observability. We’ll see how Clean Architecture’s boundaries guide us toward simple yet effective monitoring solutions that maintain architectural integrity while providing the insights our system needs.</p>
    <h1 id="_idParaDest-226" class="heading-1"><a id="_idTextAnchor241"/>Implementing cross-boundary instrumentation</h1>
    <p class="normal">Let’s translate our understanding of Clean Architecture’s observability benefits into practical implementation. Modern web frameworks such as Flask provide their own logging infrastructure, which <a id="_idIndexMarker540"/>can tempt developers into tightly coupling business operations with framework-specific logging. We’ll see how to work effectively with these framework mechanisms while keeping our core business logic framework-independent. Through a careful implementation of structured logging and request tracing, we’ll demonstrate patterns that maintain Clean Architecture’s boundaries while delivering comprehensive system observability.</p>
    <h2 id="_idParaDest-227" class="heading-2"><a id="_idTextAnchor242"/>Avoiding framework coupling in logging</h2>
    <p class="normal">As <a id="_idIndexMarker541"/>we mentioned, web frameworks often provide their own logging infrastructure. Flask, for instance, encourages direct use of its application logger (<code class="inlineCode">app.logger</code>):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">@app.route(</span><span class="hljs-string">'/tasks/new'</span><span class="hljs-params">, methods=[</span><span class="hljs-string">'POST'</span><span class="hljs-params">]</span><span class="hljs-meta">)</span>
<span class="hljs-keyword">def</span> <span class="hljs-title">create_task</span>():
    task = create_task_from_request(request.form)
    <span class="hljs-comment"># Framework-specific logging:</span>
    app.logger.info(<span class="hljs-string">'</span><span class="hljs-string">Created task %s'</span>, task.<span class="hljs-built_in">id</span>) 
    <span class="hljs-keyword">return</span> redirect(url_for(<span class="hljs-string">'index'</span>))
</code></pre>
    <p class="normal">While convenient, this approach creates problematic coupling between our business operations and framework-specific logging. Using Flask’s <code class="inlineCode">app.logger</code> would require making the Flask application object accessible throughout our codebase which is a serious violation of Clean Architecture’s Dependency Rule. Inner layers would need to reach out to the Framework layer just to perform logging, creating exactly the kind of outward dependency that <a id="_idIndexMarker542"/>Clean Architecture aims to prevent.</p>
    <p class="normal">Instead, Clean Architecture guides us toward framework-independent logging that respects architectural boundaries. Consider how our task creation use case should log operations:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># todo_app/application/use_cases/task_use_cases.py</span>
<span class="hljs-keyword">import</span> logging
logger = logging.getLogger(__name__)
<span class="hljs-meta">@dataclass</span>
<span class="hljs-keyword">class</span> <span class="hljs-title">CreateTaskUseCase</span>:
    task_repository: TaskRepository
    project_repository: ProjectRepository
    <span class="hljs-keyword">def</span> <span class="hljs-title">execute</span>(<span class="hljs-params">self, request: CreateTaskRequest</span>) -&gt; Result:
        <span class="hljs-keyword">try</span>:
            logger.info(
                <span class="hljs-string">"Creating new task"</span>,
                extra={<span class="hljs-string">"context"</span>: {
                    <span class="hljs-string">"title"</span>: request.title,
                    <span class="hljs-string">"project_id"</span>: request.project_id
                }},
            )
            <span class="hljs-comment"># ... implementation continues ...</span>
</code></pre>
    <p class="normal">This approach offers several Clean Architecture benefits:</p>
    <ul>
      <li class="bulletList">Use cases remain unaware of logging implementation details</li>
      <li class="bulletList">Logging statements document business operations naturally</li>
      <li class="bulletList">We can change logging infrastructure without modifying business logic</li>
      <li class="bulletList">Framework-specific logging stays at system edges where it belongs</li>
    </ul>
    <p class="normal">Let’s implement this clean logging approach systematically, starting with the proper separation of framework and application logging concerns.</p>
    <h2 id="_idParaDest-228" class="heading-2"><a id="_idTextAnchor243"/>Implementing structured logging patterns</h2>
    <p class="normal">As we’ve seen, Clean Architecture requires that infrastructure concerns, including logging implementation details, remain isolated in outer layers.</p>
    <p class="normal">For <a id="_idIndexMarker543"/>our implementation, we’ve chosen structured JSON logging. This is a common practice that enables precise log processing and analysis. Each log entry becomes a JSON object with consistent fields, making it easier to search, filter, and analyze log data programmatically. While we’ll demonstrate JSON formatting, the patterns we establish would work equally well with other logging formats: you could adapt the formatter implementation without touching any code in the inner layers.</p>
    <p class="normal">We organize our logging infrastructure to maintain clean architectural boundaries:</p>
    <figure class="mediaobject"><img src="../Images/B31577_10_2.png" alt="Figure 10.2: Logging files in the Frameworks and Drivers layer" width="1027" height="508"/></figure>
    <p class="packt_figref">Figure 10.2: Logging files in the Frameworks and Drivers layer</p>
    <p class="normal">This organization keeps logging configuration where it belongs: in the Frameworks and Drivers layer. The separation between framework logs (<code class="inlineCode">access.log</code>) and application logs (<code class="inlineCode">app.log</code>) demonstrates how we maintain clean boundaries even in our log output.</p>
    <p class="normal">This separation serves two key Clean Architecture objectives:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Separation of concerns</strong>: Each <a id="_idIndexMarker544"/>layer logs what it knows best. Flask handles HTTP request logging in its standard format, while our application captures business operations in structured JSON. This clean separation means each type of log can evolve independently, using formats and fields appropriate to its purpose.</li>
      <li class="bulletList"><strong class="keyWord">Framework independence</strong>: Our core application logging remains completely unaware <a id="_idIndexMarker545"/>of Flask or any other web framework. We could switch to a different framework, or even add new interfaces such as a REST API, while our business operation logging continues unchanged.</li>
    </ul>
    <p class="normal">We <a id="_idIndexMarker546"/>need a way to format our application logs that supports structured data while remaining independent of any framework opinions. Our <code class="inlineCode">JsonFormatter</code> handles this responsibility:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># todo_app/infrastructure/logging/config.py</span>
<span class="hljs-keyword">class</span> <span class="hljs-title">JsonFormatter</span>(logging.Formatter):
    <span class="hljs-string">"""</span><span class="hljs-string">Formats log records as JSON."""</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, app_context: </span><span class="hljs-built_in">str</span>):
        <span class="hljs-built_in">super</span>().__init__()
        <span class="hljs-variable">self</span>.app_context = app_context
        <span class="hljs-comment"># Custom encoder handles datetime, UUID, sets, and exceptions</span>
        <span class="hljs-variable">self</span>.encoder = JsonLogEncoder()
    <span class="hljs-keyword">def</span> <span class="hljs-title">format</span>(<span class="hljs-params">self, record: logging.LogRecord</span>) -&gt; <span class="hljs-built_in">str</span>:
        <span class="hljs-string">"""Format log record as JSON."""</span>
        log_data = {
            <span class="hljs-string">"timestamp"</span>: datetime.now(timezone.utc),
            <span class="hljs-string">"level"</span>: record.levelname,
            <span class="hljs-string">"logger"</span>: record.name,
            <span class="hljs-string">"message"</span>: record.getMessage(),
            <span class="hljs-string">"app_context"</span>: <span class="hljs-variable">self</span>.app_context,
        }
        <span class="hljs-comment"># `extra` in the log statement, places `context`</span>
        <span class="hljs-comment"># on the LogRecord so seek and extract</span>
        context = {}
        <span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> record.__dict__.items():
            <span class="hljs-keyword">if</span> key == <span class="hljs-string">"context"</span>:
                context = value
                <span class="hljs-keyword">break</span>
        <span class="hljs-keyword">if</span> context:
            log_data[<span class="hljs-string">"context"</span>] = context
        <span class="hljs-keyword">return</span> <span class="hljs-variable">self</span>.encoder.encode(log_data)
</code></pre>
    <p class="normal">The formatter encapsulates all JSON formatting logic in a single component, demonstrating the Single Responsibility Principle in action. Each log entry includes essential context like <code class="inlineCode">timestamp </code>and log <code class="inlineCode">level</code>, while remaining completely unaware of web frameworks or other external concerns.</p>
    <p class="normal">Since Python’s logging mechanism directly attaches the extra parameter keys to the <code class="inlineCode">LogRecord</code> instance, we use a dedicated <code class="inlineCode">context</code> namespace to prevent collisions with <code class="inlineCode">LogRecord</code>'s built-in attributes (like <code class="inlineCode">name</code>, <code class="inlineCode">args</code>). This simple namespacing strategy lets us safely include structured data with each log message.</p>
    <p class="normal">With <a id="_idIndexMarker547"/>our formatter handling the structure of individual log messages, we now need to configure how these messages flow through our system. This configuration determines which logs go where, maintaining our clean separation between framework and application logging. For clarity, we’ll use the Python logger’s <code class="inlineCode">dictConfig</code> to establish these paths, starting with our formatters:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># todo_app/infrastructure/logging/config.py</span>
<span class="hljs-keyword">def</span> <span class="hljs-title">configure_logging</span>(<span class="hljs-params">app_context: </span><span class="hljs-type">Literal</span><span class="hljs-params">[</span><span class="hljs-string">"CLI"</span><span class="hljs-params">, </span><span class="hljs-string">"WEB"</span><span class="hljs-params">]</span>) -&gt; <span class="hljs-literal">None</span>:
    <span class="hljs-string">"""Configure application logging with sensible defaults."""</span>
    log_dir = Path(<span class="hljs-string">"logs"</span>)
    log_dir.mkdir(exist_ok=<span class="hljs-literal">True</span>)
    config = {
        <span class="hljs-string">"formatters"</span>: {
            <span class="hljs-string">"json"</span>: {<span class="hljs-string">"()"</span>: JsonFormatter, <span class="hljs-string">"app_context"</span>: app_context},
            <span class="hljs-string">"standard"</span>: {<span class="hljs-string">"format"</span>: <span class="hljs-string">"%(message)s"</span>},
        },
        ...
</code></pre>
    <p class="normal">Here we define two formatters: our custom JSON formatter for application logs and a simple format for framework logs. This separation lets each type of log maintain its appropriate structure.</p>
    <p class="normal">Next, we configure handlers that direct logs to their appropriate destinations:</p>
    <pre class="programlisting code"><code class="hljs-code">        ...
        },
        <span class="hljs-string">"handlers"</span> = {
            <span class="hljs-string">"app_file"</span>: {
                <span class="hljs-string">"class"</span>: <span class="hljs-string">"logging.FileHandler"</span>,
                <span class="hljs-string">"filename"</span>: log_dir / <span class="hljs-string">"app.log"</span>,
                <span class="hljs-string">"formatter"</span>: <span class="hljs-string">"json"</span>,
            },
            <span class="hljs-string">"access_file"</span>: {
                <span class="hljs-string">"class"</span>: <span class="hljs-string">"logging.FileHandler"</span>,
                <span class="hljs-string">"filename"</span>: log_dir / <span class="hljs-string">"access.log"</span>,
                <span class="hljs-string">"formatter"</span>: <span class="hljs-string">"standard"</span>,
            },
        },
        ...
</code></pre>
    <p class="normal">Each <a id="_idIndexMarker548"/>handler connects a log destination with its appropriate formatter, maintaining our clean separation between framework and application concerns.</p>
    <p class="normal">Finally, we wire everything together with logger configurations:</p>
    <pre class="programlisting code"><code class="hljs-code">        ...
        },   
        <span class="hljs-string">"loggers"</span> = {
            <span class="hljs-comment"># Application logger</span>
            <span class="hljs-string">"todo_app"</span>: {
                <span class="hljs-string">"handlers"</span>: [<span class="hljs-string">"app_file"</span>],
                <span class="hljs-string">"level"</span>: <span class="hljs-string">"INFO"</span>,
            },
            <span class="hljs-comment"># Flask's werkzeug logger</span>
            <span class="hljs-string">"werkzeug"</span>: {
                <span class="hljs-string">"handlers"</span>: [<span class="hljs-string">"access_file"</span>],
                <span class="hljs-string">"level"</span>: <span class="hljs-string">"INFO"</span>,
                <span class="hljs-string">"propagate"</span>: <span class="hljs-literal">False</span>,
            },
        },
    } // end configure_logging()
</code></pre>
    <p class="normal">The <code class="inlineCode">todo_app</code> logger captures all application-level operations through our JSON formatter, writing them to <code class="inlineCode">app.log</code>. Meanwhile, Flask’s built-in Werkzeug logger remains untouched, recording HTTP requests in standard format to <code class="inlineCode">access.log</code>. By keeping these logging streams separate, we maintain clean boundaries between framework and business concerns.</p>
    <p class="normal">This configuration gets activated early in our application startup:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># web_main.py</span>
<span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():
    <span class="hljs-string">"""Configure logging early"""</span>
    configure_logging(app_context=<span class="hljs-string">"WEB"</span>)
    <span class="hljs-comment"># ...</span>
</code></pre>
    <p class="normal">Here we see the main file for the web app; the CLI will be identical except for <code class="inlineCode">app_context="CLI"</code>.</p>
    <p class="normal">Most importantly, this configuration means any code in our application can simply use Python’s standard logging module without knowing about JSON formatting, file handlers, or any other implementation details. These concerns remain properly contained within our Infrastructure layer.</p>
    <p class="normal">With <a id="_idIndexMarker549"/>our logging infrastructure in place, let’s see how Clean Architecture’s separation of concerns translates into practical benefit. Our task creation use case demonstrates how business operations can be clearly logged without any awareness of framework specifics:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> logging
logger = logging.getLogger(__name__)
<span class="hljs-meta">@dataclass</span>
<span class="hljs-keyword">class</span> <span class="hljs-title">CreateTaskUseCase</span>:
    task_repository: TaskRepository
    project_repository: ProjectRepository
    <span class="hljs-keyword">def</span> <span class="hljs-title">execute</span>(<span class="hljs-params">self, request: CreateTaskRequest</span>) -&gt; Result:
        <span class="hljs-keyword">try</span>:
            logger.info(
                <span class="hljs-string">"Creating new task"</span>,
                extra={<span class="hljs-string">"title"</span>: request.title,
                       <span class="hljs-string">"project_id"</span>: request.project_id},
            )
            <span class="hljs-comment"># ... task creation logic ...</span>
            logger.info(
                <span class="hljs-string">"</span><span class="hljs-string">Task created successfully"</span>,
                extra={<span class="hljs-string">"context"</span>:{
                    <span class="hljs-string">"task_id"</span>: <span class="hljs-built_in">str</span>(task.<span class="hljs-built_in">id</span>),
                    <span class="hljs-string">"project_id"</span>: <span class="hljs-built_in">str</span>(project_id),
                    <span class="hljs-string">"priority"</span>: task.priority.name}}
            )
</code></pre>
    <p class="normal">When we run our application, we see this in the console:</p>
    <figure class="mediaobject"><img src="../Images/B31577_10_3.png" alt="" width="1650" height="142"/></figure>
    <p class="normal">While we’ve chosen to display both log streams in the console for development convenience, each type of log is properly separated into its designated file:</p>
    <figure class="mediaobject"><img src="../Images/B31577_10_4.png" alt="A close-up of a computer code  Description automatically generated" width="1650" height="267"/></figure>
    <p class="normal">If <a id="_idIndexMarker550"/>we view the formatted <em class="italic">create new task</em> log statement, we see the injection of the <code class="inlineCode">context</code> attribute of the log statement:</p>
    <pre class="programlisting con"><code class="hljs-con">{
  "timestamp": "2025-02-22T20:10:03.800373+00:00",
  "level": "INFO",
  "logger":
  "todo_app.application.use_cases.task_use_cases",
  "message": "Creating new task",
  "app_context": "WEB",
  "trace_id": "19d386aa-5537-45ac-9da6-3a0ce8717660",
  "context": {
    "title": "New Task",
    "project_id": "e587f1d5-5f6e-4da5-8d6b-155b39bbe8a9"
  }
}
</code></pre>
    <p class="normal">Through this implementation, we’ve seen how Clean Architecture guides us to pragmatic solutions for common infrastructure concerns. By isolating logging configuration in our outermost layer, we enable each part of our system to log appropriately while maintaining proper architectural boundaries. Framework logs and business operations remain cleanly separated, yet both contribute to a comprehensive view of system behavior.</p>
    <h2 id="_idParaDest-229" class="heading-2"><a id="_idTextAnchor244"/>Building cross-boundary observability</h2>
    <p class="normal">Throughout this book, we’ve seen how Clean Architecture’s explicit boundaries provide crucial benefits, from isolating business logic and maintaining testability to enabling interface flexibility and <a id="_idIndexMarker551"/>framework independence. However, these same boundaries that keep our system maintainable can make it challenging to trace operations as they flow through our layers.</p>
    <p class="normal">While structured logging provides insight into individual operations, tracking requests across these architectural boundaries requires additional infrastructure. Let’s extend our task management system to implement cross-boundary tracing while maintaining these clean separations.</p>
    <p class="normal">Consider what happens when a user creates a task through our web interface, an operation that crosses multiple architectural boundaries:</p>
    <ol>
      <li class="numberedList" value="1">A web request arrives at our Flask route handler</li>
      <li class="numberedList">The request flows through our task controller</li>
      <li class="numberedList">The controller invokes our use case</li>
      <li class="numberedList">The use case coordinates with repositories</li>
      <li class="numberedList">Finally, the result flows back through these layers</li>
    </ol>
    <p class="normal">Without correlation between these events, debugging and monitoring become challenging. Our solution is straightforward but powerful: we’ll generate a unique identifier (trace ID) for each request <a id="_idIndexMarker552"/>and include this ID in every log statement related to that request. This allows us to follow a request’s journey through all layers of our system, from the initial web request to database operations and back.</p>
    <p class="normal">To implement this tracing, we’ll need to:</p>
    <ol>
      <li class="numberedList" value="1">Create <code class="inlineCode">infrastructure/logging/trace.py</code> to manage trace ID generation and storage</li>
      <li class="numberedList">Extend our logging configuration in <code class="inlineCode">infrastructure/logging/config.py</code> to include trace IDs in log formats</li>
      <li class="numberedList">Add Flask middleware in <code class="inlineCode">infrastructure/web/middleware.py</code> to set trace IDs for incoming requests</li>
    </ol>
    <p class="normal">Because we’ve built our logging infrastructure following Clean Architecture principles, no changes are needed to application code. Trace IDs will automatically flow through our existing logging calls.</p>
    <p class="normal">With our approach mapped out, let’s start with the foundation: the trace ID management itself. This infrastructure, while living entirely in our outer layer, will enable visibility across all architectural boundaries:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># todo_app/infrastructure/logging/trace.py</span>
<span class="hljs-comment"># Thread-safe context variable to hold trace ID</span>
trace_id_var: ContextVar[<span class="hljs-type">Optional</span>[<span class="hljs-built_in">str</span>]] = ContextVar(<span class="hljs-string">"trace_id"</span>, 
                                                     default=<span class="hljs-literal">None</span>)
<span class="hljs-keyword">def</span> <span class="hljs-title">get_trace_id</span>() -&gt; <span class="hljs-built_in">str</span>:
    <span class="hljs-string">"""Get current trace ID or generate new one if not set."""</span>
    current = trace_id_var.get()
    <span class="hljs-keyword">if</span> current <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
        current = <span class="hljs-built_in">str</span>(uuid4())
        trace_id_var.<span class="hljs-built_in">set</span>(current)
    <span class="hljs-keyword">return</span> current
<span class="hljs-keyword">def</span> <span class="hljs-title">set_trace_id</span>(<span class="hljs-params">trace_id: </span><span class="hljs-type">Optional</span><span class="hljs-params">[</span><span class="hljs-built_in">str</span><span class="hljs-params">] = </span><span class="hljs-literal">None</span>) -&gt; <span class="hljs-built_in">str</span>:
    <span class="hljs-string">"""Set trace ID for current context."""</span>
    new_id = trace_id <span class="hljs-keyword">or</span> <span class="hljs-built_in">str</span>(uuid4())
    trace_id_var.<span class="hljs-built_in">set</span>(new_id)
    <span class="hljs-keyword">return</span> new_id
</code></pre>
    <p class="normal">The <code class="inlineCode">set_trace_id</code> function establishes a unique identifier for each request in our system. While it accepts <a id="_idIndexMarker553"/>an optional existing ID parameter (primarily used for testing or specialized integrations), in normal operation each request receives a new <code class="inlineCode">UUID</code>. This ensures <a id="_idIndexMarker554"/>that every operation in our system can be traced independently, regardless of whether it originated from our CLI, web UI, or other entry points.</p>
    <div class="note">
      <p class="normal"> <strong class="keyWord">Why </strong><code class="inlineCode">ContextVar</code><strong class="keyWord">?</strong></p>
      <p class="normal">We use Python’s <code class="inlineCode">ContextVar</code> because it <a id="_idIndexMarker555"/>provides thread-safe storage that works across async boundaries. While the specific implementation mechanism isn’t crucial to Clean Architecture, choosing the right tools helps maintain clean boundaries. For more details on context variables, see Python’s documentation: <a href="https://docs.python.org/3/library/contextvars.html"><span class="url">https://docs.python.org/3/library/contextvars.html</span></a></p>
    </div>
    <p class="normal">With trace ID management in place, we next need to ensure our logging configuration includes the trace ID in log formats:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># todo_app/infrastructure/logging/config.py</span>
<span class="hljs-keyword">def</span> <span class="hljs-title">configure_logging</span>(<span class="hljs-params">app_context: </span><span class="hljs-type">Literal</span><span class="hljs-params">[</span><span class="hljs-string">"CLI"</span><span class="hljs-params">, </span><span class="hljs-string">"WEB"</span><span class="hljs-params">]</span>) -&gt; <span class="hljs-literal">None</span>:
    config = {
        <span class="hljs-string">"formatters"</span>: {
            <span class="hljs-string">"json"</span>: {<span class="hljs-string">"()"</span>: JsonFormatter, <span class="hljs-string">"app_context"</span>: app_context},
            <span class="hljs-string">"</span><span class="hljs-string">standard"</span>: {
                <span class="hljs-string">"format"</span>: <span class="hljs-string">"%(asctime)s [%(trace_id)s] %(message)s"</span>,
                <span class="hljs-string">"datefmt"</span>: <span class="hljs-string">"%Y-%m-%d %H:%M:%S"</span>
            },
        },
        <span class="hljs-comment"># ... rest of configuration</span>
    }
</code></pre>
    <p class="normal">Our logging configuration ensures trace IDs are included with every log message, regardless of the log format. For framework logs, we add trace IDs to the standard format using Python’s built-in logging pattern syntax <code class="inlineCode">(%(trace_id)s)</code>. Our JSON formatter automatically includes trace IDs in structured output. This consistency means we can follow operations across all log sources, while each logging stream maintains its appropriate format.</p>
    <p class="normal">Lastly, our web middleware ensures each request gets a trace ID:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># todo_app/infrastructure/web/middleware.py</span>
<span class="hljs-keyword">def</span> <span class="hljs-title">trace_requests</span>(<span class="hljs-params">flask_app</span>):
    <span class="hljs-string">"""Add trace ID to all requests."""</span>
<span class="hljs-meta">    @flask_app.before_request</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title">before_request</span>():
        trace_id = request.headers.get(<span class="hljs-string">"X-Trace-ID"</span>) <span class="hljs-keyword">or</span> <span class="hljs-literal">None</span>
        <span class="hljs-comment"># pull trace id from globals</span>
        g.trace_id = set_trace_id(trace_id)
<span class="hljs-meta">    @flask_app.after_request</span>
    <span class="hljs-keyword">def</span> <span class="hljs-title">after_request</span>(<span class="hljs-params">response</span>):
        response.headers[<span class="hljs-string">"X-Trace-ID"</span>] = g.trace_id
        <span class="hljs-keyword">return</span> response
</code></pre>
    <p class="normal">This middleware <a id="_idIndexMarker556"/>ensures every web request receives a unique trace ID. Though it can accept an existing ID through the <code class="inlineCode">X-Trace-ID</code> header (useful for testing), it typically generates a new <code class="inlineCode">UUID</code> for each request.</p>
    <p class="normal">To activate this tracing, we integrate the middleware when creating our Flask application:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># todo_app/infrastructure/web/app.py</span>
<span class="hljs-keyword">def</span> <span class="hljs-title">create_web_app</span>(<span class="hljs-params">app_container: Application</span>) -&gt; Flask:
    <span class="hljs-string">"""Create and configure Flask application."""</span>
    flask_app = Flask(__name__)
    flask_app.config[<span class="hljs-string">"SECRET_KEY"</span>] = <span class="hljs-string">"dev"</span>
    flask_app.config[<span class="hljs-string">"APP_CONTAINER"</span>] = app_container
    <span class="hljs-comment"># Add trace ID middleware</span>
    trace_requests(flask_app)
    <span class="hljs-comment"># ...</span>
</code></pre>
    <p class="normal">Recall that <code class="inlineCode">web_main.py</code> calls <code class="inlineCode">create_web_app</code>, and thus this setup ensures that every request flowing through our system gets traced. This ID is then available throughout request processing and included in response headers for debugging purposes. The trace ID connects all log entries related to processing that specific request, from initial receipt through final response.</p>
    <figure class="mediaobject"><img src="../Images/B31577_10_5.png" alt="A close-up of a computer code  Description automatically generated" width="1650" height="222"/></figure>
    <p class="normal">Each request through our system is assigned a unique trace ID, allowing us to follow that specific operation across architectural boundaries. As shown above, the trace ID <code class="inlineCode">abc-123-xyz</code> appears in both framework and application logs, connecting all events related to this single task creation request. This tracing enables us to understand exactly what happened during any given request, from initial HTTP handling through business operations to final response.</p>
    <p class="normal">Our logging <a id="_idIndexMarker557"/>and tracing implementation demonstrates how Clean Architecture’s boundaries enable comprehensive system observability without compromising architectural principles. Yet implementing these patterns is only half the challenge; we must also ensure these boundaries remain intact as our system evolves. Next, we’ll explore how to actively verify our architectural integrity through automated checks and fitness functions.</p>
    <h1 id="_idParaDest-230" class="heading-1"><a id="_idTextAnchor245"/>Verifying architectural integrity through fitness functions</h1>
    <p class="normal">As systems evolve, maintaining architectural integrity becomes increasingly challenging. Even teams <a id="_idIndexMarker558"/>committed to Clean Architecture’s principles can inadvertently introduce changes that compromise their systems’ carefully crafted boundaries. This risk has led architects to develop <em class="italic">fitness functions</em> which are automated tests that verify that architectural principles are correctly implemented and detect any drift from those principles over time.</p>
    <p class="normal">The concept of architectural fitness functions, introduced by Neal Ford, Rebecca Parsons, and Patrick Kua in their book <em class="italic">Building Evolutionary Architectures</em>, provides a systematic approach to maintaining architectural integrity. Just as unit tests verify code behavior, fitness functions verify architectural characteristics. By detecting violations early in the development process (an approach known as <em class="italic">shift left</em>), these tests help teams maintain Clean Architecture’s principles in an automated manner.</p>
    <p class="normal">While comprehensive architectural validation frameworks exist, Python enables us to implement effective verification in a simpler, more pragmatic way using the language’s built-in capabilities. Through our architectural verification approach, we’ll focus on two key aspects: ensuring our source structure maintains Clean Architecture’s layered organization, and detecting any violations of the fundamental Dependency Rule that requires dependencies to only flow inward. These complementary checks help teams maintain architectural integrity as systems evolve.</p>
    <h2 id="_idParaDest-231" class="heading-2"><a id="_idTextAnchor246"/>Verifying layer structure</h2>
    <p class="normal">Let’s start by defining our expected architectural structure. While every team’s specific implementation <a id="_idIndexMarker559"/>of Clean Architecture may vary slightly, the core principle of explicit layer organization remains constant. We can capture our particular interpretation in a simple configuration:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span> <span class="hljs-title">ArchitectureConfig</span>:
    <span class="hljs-string">"""Defines Clean Architecture structure and rules."""</span>
  
    <span class="hljs-comment"># Ordered from innermost to outermost layer</span>
    LAYER_HIERARCHY = [
        <span class="hljs-string">"domain"</span>,
        <span class="hljs-string">"application"</span>,
        <span class="hljs-string">"interfaces"</span>,
        <span class="hljs-string">"infrastructure"</span>
    ]
</code></pre>
    <p class="normal">This configuration serves as our architectural contract, by defining how we expect our codebase directories to be organized. Your team might choose different layer names or add additional organizational rules, but the principle remains the same: Clean Architecture requires explicit, well-defined layers with clear responsibilities.</p>
    <p class="normal">With our structure defined, we can implement verification tests that ensure our codebase maintains this organization:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span> <span class="hljs-title">test_source_folders</span>(<span class="hljs-params">self</span>):
    <span class="hljs-string">"""Verify todo_app contains only Clean Architecture layer folders."""</span>
    src_path = Path(<span class="hljs-string">"todo_app"</span>)
    folders = {f.name <span class="hljs-keyword">for</span> f <span class="hljs-keyword">in</span> src_path.iterdir() <span class="hljs-keyword">if</span> f.is_dir()}
  
    <span class="hljs-comment"># All layer folders must exist</span>
    <span class="hljs-keyword">for</span> layer <span class="hljs-keyword">in</span> ArchitectureConfig.LAYER_HIERARCHY:
        <span class="hljs-variable">self</span>.assertIn(
            layer,
            folders,
            <span class="hljs-string">f"Missing </span><span class="hljs-subst">{layer}</span><span class="hljs-string"> layer folder"</span>
        )
      
    <span class="hljs-comment"># No unexpected folders</span>
    unexpected = folders - <span class="hljs-built_in">set</span>(ArchitectureConfig.LAYER_HIERARCHY)
    <span class="hljs-variable">self</span>.assertEqual(
        unexpected,
        <span class="hljs-built_in">set</span>(),
        <span class="hljs-string">f"Source should only contain Clean Architecture layers.\n"</span>
        <span class="hljs-string">f"Unexpected folders found: </span><span class="hljs-subst">{unexpected}</span><span class="hljs-string">"</span>
    )
</code></pre>
    <p class="normal">This simple check enforces a fundamental Clean Architecture principle: our source code must be explicitly organized into well-defined layers. The <code class="inlineCode">ArchitectureConfig</code> class allows us to customize these tests to your particular preferences. We’re specifically examining the top-level folders within <code class="inlineCode">todo_app</code>, ensuring they match our expected architectural structure. This isn’t about <a id="_idIndexMarker560"/>the contents of these folders (we’ll get to that with dependency checking), but rather verifying the basic organizational foundation of our Clean Architecture implementation.</p>
    <p class="normal">Consider a common scenario: a team is adding email notification capabilities to the task management system. A new developer, not yet familiar with Clean Architecture, creates a new notifications folder at the root level:</p>
    <figure class="mediaobject"><img src="../Images/B31577_10_6.png" alt="A close-up of a text  Description automatically generated" width="991" height="330"/></figure>
    <p class="normal">This seemingly innocent organization choice represents the start of architectural drift. The notifications code should live in the Infrastructure layer since it’s an external concern. By creating a new top-level folder, we’ve:</p>
    <ul>
      <li class="bulletList">Created confusion about where notification-related code belongs</li>
      <li class="bulletList">Started bypassing Clean Architecture’s explicit layering</li>
      <li class="bulletList">Set a precedent for creating new top-level folders when developers are unsure about proper placement</li>
    </ul>
    <p class="normal">Our simple structural check catches this early (literally within seconds if tests are run on the developer’s machine):</p>
    <pre class="programlisting con"><code class="hljs-con">❯ pytest tests/architecture
========== test session starts ==================
tests/architecture/test_source_structure.py F
E    AssertionError: Items in the first set but not the second:
E    'notifications' : Source should only contain Clean Architecture layers.
E    Unexpected folders found: {'notifications'}
</code></pre>
    <p class="normal">This warning prompts the new developer to properly integrate the notification code into the Infrastructure layer:</p>
    <figure class="mediaobject"><img src="../Images/B31577_10_7.png" alt="" width="869" height="329"/></figure>
    <p class="normal">These simple <a id="_idIndexMarker561"/>structural checks catch architectural drift before it can compromise system maintainability. However, proper structure is only part of Clean Architecture’s requirements. We must also ensure that dependencies between these layers flow in the right direction. Let’s examine how to verify Clean Architecture’s fundamental Dependency Rule.</p>
    <h2 id="_idParaDest-232" class="heading-2"><a id="_idTextAnchor247"/>Enforcing dependency rules</h2>
    <p class="normal">With our layer structure verified, we must ensure that these layers interact correctly according to <a id="_idIndexMarker562"/>Clean Architecture’s principles. The most fundamental of these is the Dependency Rule, which states that dependencies must only point inward toward more central layers. Even a small violation of this rule can compromise the architectural integrity we’ve carefully built.</p>
    <p class="normal">Building on our structural verification, let’s examine how to detect violations of the Dependency Rule. This rule is crucial for maintaining a clean separation of concerns, yet it can be subtly violated during development.</p>
    <p class="normal">Our Dependency Rule verification takes a direct approach, examining Python import statements to ensure they only flow inward through our architectural layers. While more sophisticated static analysis tools exist (see <em class="italic">Further reading</em>), this straightforward implementation catches the most common violations:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span> <span class="hljs-title">test_domain_layer_dependencies</span>(<span class="hljs-params">self</span>):
    <span class="hljs-string">"""Verify domain layer has no outward dependencies."""</span>
    domain_path = Path(<span class="hljs-string">"</span><span class="hljs-string">todo_app/domain"</span>)
    violations = []
  
    <span class="hljs-keyword">for</span> py_file <span class="hljs-keyword">in</span> domain_path.rglob(<span class="hljs-string">"*.py"</span>):
        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(py_file) <span class="hljs-keyword">as</span> f:
            tree = ast.parse(f.read())
          
        <span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> ast.walk(tree):
            <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(node, ast.Import) <span class="hljs-keyword">or</span> <span class="hljs-built_in">isinstance</span>(
               node, ast.ImportFrom
            ):
                module = node.names[<span class="hljs-number">0</span>].name
                <span class="hljs-keyword">if</span> module.startswith(<span class="hljs-string">"todo_app."</span>):
                    layer = module.split(<span class="hljs-string">"."</span>)[<span class="hljs-number">1</span>]
                    <span class="hljs-keyword">if</span> layer <span class="hljs-keyword">in</span> [
                        <span class="hljs-string">"</span><span class="hljs-string">infrastructure"</span>,
                        <span class="hljs-string">"interfaces"</span>,
                        <span class="hljs-string">"application"</span>
                    ]:
                        violations.append(
                            <span class="hljs-string">f"</span><span class="hljs-subst">{py_file.relative_to(domain_path)}</span><span class="hljs-string">: "</span>
                            <span class="hljs-string">f"Domain layer cannot import from "</span>
                            <span class="hljs-string">f"</span><span class="hljs-subst">{layer}</span><span class="hljs-string"> layer"</span>
                        )
    <span class="hljs-variable">self</span>.assertEqual(
        violations,
        [],
        <span class="hljs-string">"\nDependency Rule Violations:\n"</span> + <span class="hljs-string">"</span><span class="hljs-string">\n"</span>.join(violations)
    )
</code></pre>
    <p class="normal">This test <a id="_idIndexMarker563"/>implementation leverages Python’s built-in <code class="inlineCode">ast</code> module to analyze import statements in our Domain layer code. It works by:</p>
    <ol>
      <li class="numberedList" value="1">Recursively finding all Python files in the Domain layer</li>
      <li class="numberedList">Parsing each file into an Abstract Syntax Tree (AST)</li>
      <li class="numberedList">Walking the AST to find Import and <code class="inlineCode">ImportFrom</code> nodes</li>
      <li class="numberedList">Checking each import to ensure it doesn’t reference outer layers</li>
    </ol>
    <p class="normal">While more complex static analysis is possible, this focused check effectively catches the most critical dependency violations, which are those that would compromise our core Domain layer’s independence.</p>
    <p class="normal">Consider a real-world scenario: a developer is implementing task completion notifications. They notice that the <code class="inlineCode">NotificationService</code> in the Infrastructure layer already has the logic they need. Instead of following Clean Architecture’s patterns, they take a shortcut that violates our fundamental Dependency Rule:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># todo_app/domain/entities/task.py</span>
<span class="hljs-comment"># Dependency Rule Violation!</span>
<span class="hljs-keyword">from</span> todo_app.infrastructure.notifications.recorder <span class="hljs-keyword">import</span> NotificationRecorder
<span class="hljs-keyword">class</span> <span class="hljs-title">Task</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title">complete</span>(<span class="hljs-params">self</span>):
        <span class="hljs-variable">self</span>.status = TaskStatus.DONE
        <span class="hljs-variable">self</span>.completed_at = datetime.now()
      
        <span class="hljs-comment"># Direct dependency on infrastructure –</span>
        <span class="hljs-comment"># violates Clean Architecture</span>
        notification = NotificationRecorder()
        notification.notify_task_completed(<span class="hljs-variable">self</span>)
</code></pre>
    <p class="normal">This change <a id="_idIndexMarker564"/>might seem innocent because it gets the job done. However, it creates exactly the kind of outward dependency that Clean Architecture prohibits. Our domain entity now depends directly on an infrastructure component, meaning:</p>
    <ul>
      <li class="bulletList">The Task entity can no longer be tested without <code class="inlineCode">NotificationService</code></li>
      <li class="bulletList">We can’t change notification implementations without modifying domain code</li>
      <li class="bulletList">We’ve created a precedent for mixing infrastructure concerns with domain logic</li>
    </ul>
    <p class="normal">Our dependency check catches this violation immediately during testing:</p>
    <pre class="programlisting con"><code class="hljs-con">❯ pytest tests/architecture
====================== test session starts ==========
...
E    'entities/task.py: Domain layer cannot import from infrastructure layer'
E    Dependency Rule Violations:
E    entities/task.py: Domain layer cannot import from infrastructure layer
====================== 2 passed in 0.01s ============
</code></pre>
    <p class="normal">The error message clearly identifies:</p>
    <ul>
      <li class="bulletList">The file containing the violation</li>
      <li class="bulletList">Which architectural rule was broken</li>
      <li class="bulletList">How to fix it (Domain layer can’t import from infrastructure)</li>
    </ul>
    <p class="normal">These simple but powerful verifications help teams maintain alignment with Clean Architecture’s <a id="_idIndexMarker565"/>principles as systems evolve. While we’ve focused on two fundamental checks (structural organization and dependency rules), teams can expand this approach to verify other architectural characteristics:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Interface conformance</strong>: Verify that interface adapters properly implement their declared contracts</li>
      <li class="bulletList"><strong class="keyWord">Repository implementations</strong>: Confirm that repository implementations properly extend their abstract bases</li>
      <li class="bulletList"><strong class="keyWord">Layer-specific rules</strong>: Add custom rules for how each layer should structure and expose its components</li>
    </ul>
    <p class="normal">The key is starting with focused, high-impact checks that verify your most crucial architectural boundaries. You can then evolve these fitness functions alongside your architecture, adding verification for new patterns and constraints as your system grows.</p>
    <p class="normal">By catching structural and dependency violations early, we prevent the gradual erosion of architectural boundaries that can occur during rapid development. While these checks can’t replace architectural understanding, they provide immediate, actionable feedback when architectural rules are violated, thereby helping teams build and preserve clean, maintainable systems.</p>
    <h1 id="_idParaDest-233" class="heading-1"><a id="_idTextAnchor248"/>Summary</h1>
    <p class="normal">In this chapter, we’ve explored how Clean Architecture’s explicit boundaries enable systematic monitoring and verification of our systems. Through our task management system, we’ve demonstrated how to implement effective observability while maintaining architectural integrity. We’ve seen how Clean Architecture transforms monitoring from a cross-cutting concern into a natural part of our system’s structure.</p>
    <p class="normal">We implemented several key observability patterns that demonstrate Clean Architecture’s benefits:</p>
    <ul>
      <li class="bulletList">Framework-independent logging that respects architectural boundaries while enabling comprehensive system visibility</li>
      <li class="bulletList">Cross-boundary request tracing that maintains clean separation between technical and business concerns</li>
      <li class="bulletList">Automated architectural verification that helps teams maintain Clean Architecture’s principles as systems evolve</li>
    </ul>
    <p class="normal">Most importantly, we’ve seen how Clean Architecture’s careful attention to boundaries makes our systems not just maintainable but also observable and verifiable. By organizing our logging and monitoring infrastructure according to Clean Architecture principles, we create systems that are easier to understand, debug, and maintain over time.</p>
    <p class="normal">In <a href="Chapter_11.xhtml#_idTextAnchor250"><em class="italic">Chapter 11</em></a>, we’ll explore how to apply Clean Architecture principles to existing systems, showing how these same boundaries and patterns can guide the transformation of legacy codebases into clean, maintainable architectures.</p>
    <h1 id="_idParaDest-234" class="heading-1"><a id="_idTextAnchor249"/>Further reading</h1>
    <ul>
      <li class="bulletList"><em class="italic">Python Logging Cookbook</em> (<a href="https://docs.python.org/3/howto/logging-cookbook.html"><span class="url">https://docs.python.org/3/howto/logging-cookbook.html</span></a>). A collection of logging related code recipes.</li>
      <li class="bulletList"><em class="italic">Building Evolutionary Architectures </em>(<a href="https://www.oreilly.com/library/view/building-evolutionary-architectures/9781491986356/"><span class="url">https://www.oreilly.com/library/view/building-evolutionary-architectures/9781491986356/</span></a>). Excellent software architecture book where the term <em class="italic">Fitness Function</em> was first coined.</li>
      <li class="bulletList"><em class="italic">PyTestArch</em> (<a href="https://github.com/zyskarch/pytestarch"><span class="url">https://github.com/zyskarch/pytestarch</span></a>). Open-source framework enabling you to define architectural rules in code and run as tests.</li>
    </ul>
  </div>
</div></div></body></html>