- en: Chapter 1. Introduction and First Steps – Take a Deep Breath
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一章. 引言和第一步 – 深呼吸
- en: '|   | *"Give a man a fish and you feed him for a day. Teach a man to fish and
    you feed him for a lifetime."* |   |'
  id: totrans-1
  prefs: []
  type: TYPE_TB
  zh: '|   | *"给一个人一条鱼，你只能养他一天。教一个人钓鱼，你就能养他一辈子。"* |   |'
- en: '|   | --*Chinese proverb* |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '|   | --*中国谚语* |'
- en: 'According to Wikipedia, **computer programming** is:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 根据维基百科，**计算机编程**是：
- en: '*"...a process that leads from an original formulation of a computing problem
    to executable computer programs. Programming involves activities such as analysis,
    developing understanding, generating algorithms, verification of requirements
    of algorithms including their correctness and resources consumption, and implementation
    (commonly referred to as coding) of algorithms in a target programming language".*'
  id: totrans-4
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*"…一个从原始的计算机问题表述到可执行计算机程序的过程。编程涉及分析、理解开发、生成算法、验证算法的需求包括它们的正确性和资源消耗，以及在目标编程语言中的算法实现（通常称为编码）"。*'
- en: In a nutshell, coding is telling a computer to do something using a language
    it understands.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，编码就是用计算机能理解的语言告诉计算机做某事。
- en: Computers are very powerful tools, but unfortunately, they can't think for themselves.
    So they need to be told everything. They need to be told how to perform a task,
    how to evaluate a condition to decide which path to follow, how to handle data
    that comes from a device such as the network or a disk, and how to react when
    something unforeseen happens, say, something is broken or missing.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 电脑是非常强大的工具，但遗憾的是，它们不能自己思考。所以它们需要被告知一切。它们需要被告知如何执行任务，如何评估条件以决定要遵循的路径，如何处理来自网络或磁盘等设备的来自设备的数据，以及当发生不可预见的事情时如何反应，比如说，某物损坏或丢失。
- en: You can code in many different styles and languages. Is it hard? I would say
    "yes" and "no". It's a bit like writing. Everybody can learn how to write, and
    you can too. But what if you wanted to become a poet? Then writing alone is not
    enough. You have to acquire a whole other set of skills and this will take a longer
    and greater effort.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用许多不同的风格和语言进行编码。这很难吗？我会说“是”和“不是”。这有点像写作。每个人都可以学习如何写作，你也可以。但如果你想要成为一名诗人呢？那么仅仅写作是不够的。你必须掌握另一套技能，这将需要更长的时间和更大的努力。
- en: In the end, it all comes down to how far you want to go down the road. Coding
    is not just putting together some instructions that work. It is so much more!
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一切都取决于你想要走多远。编码不仅仅是组合一些能工作的指令。它要复杂得多！
- en: Good code is short, fast, elegant, easy to read and understand, simple, easy
    to modify and extend, easy to scale and refactor, and easy to test. It takes time
    to be able to write code that has all these qualities at the same time, but the
    good news is that you're taking the first step towards it at this very moment
    by reading this book. And I have no doubt you can do it. Anyone can, in fact,
    we all program all the time, only we aren't aware of it.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 优秀的代码是简短、快速、优雅的，易于阅读和理解，简单，易于修改和扩展，易于扩展和重构，以及易于测试。要同时具备所有这些品质的代码需要时间，但好消息是，你通过阅读这本书已经迈出了第一步。我毫不怀疑你能够做到。实际上，任何人都可以，因为我们都在不断地编程，只是我们没有意识到这一点。
- en: Would you like an example?
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要一个例子吗？
- en: Say you want to make instant coffee. You have to get a mug, the instant coffee
    jar, a teaspoon, water, and the kettle. Even if you're not aware of it, you're
    evaluating a lot of data. You're making sure that there is water in the kettle
    as well as the kettle is plugged-in, that the mug is clean, and that there is
    enough coffee in the jar. Then, you boil the water and maybe in the meantime you
    put some coffee in the mug. When the water is ready, you pour it into the cup,
    and stir.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想冲速溶咖啡。你需要拿一个杯子，速溶咖啡罐，一把勺子，水，还有水壶。即使你没有意识到，你也在评估大量的数据。你确保水壶里有水，水壶已经插上电源，杯子是干净的，罐子里有足够的咖啡。然后，你烧开水，也许同时你在杯子里放了一些咖啡。当水烧开了，你倒入杯子，然后搅拌。
- en: So, how is this programming?
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，编程是什么呢？
- en: Well, we gathered resources (the kettle, coffee, water, teaspoon, and mug) and
    we verified some conditions on them (kettle is plugged-in, mug is clean, there
    is enough coffee). Then we started two actions (boiling the water and putting
    coffee in the mug), and when both of them were completed, we finally ended the
    procedure by pouring water in the mug and stirring.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，我们收集了资源（水壶、咖啡、水、茶匙和杯子）并验证了它们的一些条件（水壶已插电，杯子干净，有足够的咖啡）。然后我们开始执行两个动作（烧开水和把咖啡倒入杯子），当这两个动作都完成后，我们通过倒水进杯子并搅拌来最终结束程序。
- en: 'Can you see it? I have just described the high-level functionality of a coffee
    program. It wasn''t that hard because this is what the brain does all day long:
    evaluate conditions, decide to take actions, carry out tasks, repeat some of them,
    and stop at some point. Clean objects, put them back, and so on.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你看得到吗？我刚刚描述了一个咖啡程序的高级功能。这并不难，因为大脑整天都在做这件事：评估条件、决定采取行动、执行任务、重复一些任务，并在某个点上停止。清洁对象，放回原处，等等。
- en: All you need now is to learn how to deconstruct all those actions you do automatically
    in real life so that a computer can actually make some sense of them. And you
    need to learn a language as well, to instruct it.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你需要学习如何将你在现实生活中自动执行的所有动作分解，以便计算机能够真正理解它们。你还需要学习一种语言，来指导它。
- en: So this is what this book is for. I'll tell you how to do it and I'll try to
    do that by means of many simple but focused examples (my favorite kind).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这本书就是为了这个目的。我会告诉你如何做到这一点，我会通过许多简单但专注的例子（我最喜欢的类型）来尝试做到这一点。
- en: A proper introduction
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 适当的介绍
- en: I love to make references to the real world when I teach coding; I believe they
    help people retain the concepts better. However, now is the time to be a bit more
    rigorous and see what coding is from a more technical perspective.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢在教授编码时引用现实世界；我相信这有助于人们更好地保留概念。然而，现在是时候更加严谨一点，从更技术性的角度来了解编码了。
- en: 'When we write code, we''re instructing a computer on what are the things it
    has to do. Where does the action happen? In many places: the computer memory,
    hard drives, network cables, CPU, and so on. It''s a whole "world", which most
    of the time is the representation of a subset of the real world.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编写代码时，我们是在指导计算机执行它必须做的事情。动作发生在哪里？在许多地方：计算机内存、硬盘、网络电缆、CPU等等。这是一个“世界”，大多数时候是现实世界的一个子集的表示。
- en: If you write a piece of software that allows people to buy clothes online, you
    will have to represent real people, real clothes, real brands, sizes, and so on
    and so forth, within the boundaries of a program.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你编写了一个允许人们在线购买服装的软件，你将不得不在程序的范围内表示真实的人、真实的衣服、真实的品牌、尺寸等等。
- en: In order to do so, you will need to create and handle objects in the program
    you're writing. A person can be an object. A car is an object. A pair of socks
    is an object. Luckily, Python understands objects very well.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，你需要在编写的程序中创建和处理对象。人可以是一个对象。汽车是一个对象。一双袜子也是一个对象。幸运的是，Python非常理解对象。
- en: 'The two main features any object has are properties and methods. Let''s take
    a person object as an example. Typically in a computer program, you''ll represent
    people as customers or employees. The properties that you store against them are
    things like the name, the SSN, the age, if they have a driving license, their
    e-mail, gender, and so on. In a computer program, you store all the data you need
    in order to use an object for the purpose you''re serving. If you are coding a
    website to sell clothes, you probably want to store the height and weight as well
    as other measures of your customers so that you can suggest the appropriate clothes
    for them. So, properties are characteristics of an object. We use them all the
    time: "Could you pass me that pen?" – "Which one?" – "The black one." Here, we
    used the "black" property of a pen to identify it (most likely amongst a blue
    and a red one).'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 任何对象都具有的两个主要特征是属性和方法。让我们以一个人物对象为例。通常在计算机程序中，你会将人表示为顾客或员工。你存储在他们身上的属性可能包括姓名、SSN、年龄、是否有驾驶执照、电子邮件、性别等等。在计算机程序中，你存储所有你需要的数据，以便使用对象来完成你的目的。如果你正在编写一个销售服装的网站，你可能还想存储顾客的身高和体重以及其他尺寸，这样你就可以为他们推荐合适的衣服。因此，属性是对象的特征。我们经常使用它们：“你能把那支笔递给我吗？”——“哪一支？”——“那支黑色的。”在这里，我们使用了笔的“黑色”属性来识别它（很可能是蓝色和红色中的一支）。
- en: Methods are things that an object can do. As a person, I have methods such as
    *speak*, *walk*, *sleep*, *wake-up*, *eat*, *dream*, *write*, *read*, and so on.
    All the things that I can do could be seen as methods of the objects that represents
    me.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 方法是对象可以执行的事情。作为一个人类，我有诸如 *说话*、*走路*、*睡觉*、*醒来*、*吃饭*、*做梦*、*写作*、*阅读* 等方法。我能做的所有事情都可以看作是我所代表的对象的方法。
- en: So, now that you know what objects are and that they expose methods that you
    can run and properties that you can inspect, you're ready to start coding. Coding
    in fact is simply about managing those objects that live in the subset of the
    world that we're reproducing in our software. You can create, use, reuse, and
    delete objects as you please.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在你已经知道了对象是什么，以及它们暴露了你可以运行的方法和你可以检查的属性，你就可以开始编码了。实际上，编码就是关于管理那些存在于我们软件中复制的世界子集中的对象。你可以随意创建、使用、重用和删除对象。
- en: 'According to the *Data Model* chapter on the official Python documentation:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 根据官方 Python 文档中的“数据模型”章节：
- en: '*"Objects are Python''s abstraction for data. All data in a Python program
    is represented by objects or by relations between objects."*'
  id: totrans-26
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*"对象是 Python 对数据的抽象。Python 程序中的所有数据都由对象或对象之间的关系表示。"*'
- en: We'll take a closer look at Python objects in [Chapter 6](ch06.html "Chapter 6. Advanced
    Concepts – OOP, Decorators, and Iterators"), *Advanced Concepts – OOP, Decorators,
    and Iterators*. For now, all we need to know is that every object in Python has
    an ID (or identity), a type, and a value.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第 6 章](ch06.html "第 6 章。高级概念 – 面向对象编程、装饰器和迭代器")“高级概念 – 面向对象编程、装饰器和迭代器”中更详细地研究
    Python 对象。现在，我们只需要知道，Python 中的每个对象都有一个 ID（或标识），一个类型和一个值。
- en: Once created, the identity of an object is never changed. It's a unique identifier
    for it, and it's used behind the scenes by Python to retrieve the object when
    we want to use it.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建，对象的标识永远不会改变。它是它的唯一标识符，Python 在幕后使用它来在我们想要使用对象时检索它。
- en: The type as well, never changes. The type tells what operations are supported
    by the object and the possible values that can be assigned to it.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '类型同样也不会改变。类型告诉了对象支持哪些操作，以及可以分配给它的可能值。 '
- en: We'll see Python's most important data types in [Chapter 2](ch02.html "Chapter 2. Built-in
    Data Types"), *Built-in Data Types*.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第 2 章](ch02.html "第 2 章。内置数据类型")“内置数据类型”中看到 Python 的最重要的数据类型。
- en: The value can either change or not. If it can, the object is said to be **mutable**,
    while when it cannot, the object is said to be **immutable**.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 值可以改变，也可以不改变。如果可以改变，则该对象被称为 **可变**，而当它不能改变时，该对象被称为 **不可变**。
- en: How do we use an object? We give it a name of course! When you give an object
    a name, then you can use the name to retrieve the object and use it.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何使用一个对象？当然，给它一个名字！当你给一个对象一个名字时，然后你可以使用这个名字来检索对象并使用它。
- en: In a more generic sense, objects such as numbers, strings (text), collections,
    and so on are associated with a name. Usually, we say that this name is the name
    of a variable. You can see the variable as being like a box, which you can use
    to hold data.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在更通用的意义上，诸如数字、字符串（文本）、集合等对象都与一个名字相关联。通常，我们说这个名字是变量的名字。你可以把变量看作是一个盒子，你可以用它来存储数据。
- en: 'So, you have all the objects you need: what now? Well, we need to use them,
    right? We may want to send them over a network connection or store them in a database.
    Maybe display them on a web page or write them into a file. In order to do so,
    we need to react to a user filling in a form, or pressing a button, or opening
    a web page and performing a search. We react by running our code, evaluating conditions
    to choose which parts to execute, how many times, and under which circumstances.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你已经拥有了所有需要的对象：接下来是什么？嗯，我们需要使用它们，对吧？我们可能想要通过网络连接发送它们，或者将它们存储在数据库中。也许在网页上显示它们，或者将它们写入文件。为了做到这一点，我们需要对用户填写表单、按下按钮、打开网页并执行搜索等操作做出反应。我们通过运行我们的代码，评估条件来选择要执行的部分、执行次数以及执行的条件来做出反应。
- en: And to do all this, basically we need a language. That's what Python is for.
    Python is the language we'll use together throughout this book to instruct the
    computer to do something for us.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 而为了做所有这些，基本上我们需要一种语言。这就是 Python 的作用。Python 是我们将在这本书中一起使用的语言，用来指导计算机为我们做某事。
- en: Now, enough of this theoretical stuff, let's get started.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，关于这些理论性的东西就足够了，让我们开始吧。
- en: Enter the Python
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进入 Python
- en: Python is the marvelous creature of Guido Van Rossum, a Dutch computer scientist
    and mathematician who decided to gift the world with a project he was playing
    around with over Christmas 1989\. The language appeared to the public somewhere
    around 1991, and since then has evolved to be one of the leading programming languages
    used worldwide today.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Python是荷兰计算机科学家和数学家Guido Van Rossum的杰作，他决定在1989年圣诞节期间赠送世界一个他一直在玩的项目。这种语言大约在1991年向公众亮相，从那时起，它已经发展成为今天全球使用的领先编程语言之一。
- en: I started programming when I was 7 years old, on a Commodore VIC 20, which was
    later replaced by its bigger brother, the Commodore 64\. The language was BASIC.
    Later on, I landed on Pascal, Assembly, C, C++, Java, JavaScript, Visual Basic,
    PHP, ASP, ASP .NET, C#, and other minor languages I cannot even remember, but
    only when I landed on Python, I finally had that feeling that you have when you
    find the right couch in the shop. When all of your body parts are yelling, "Buy
    this one! This one is perfect for us!"
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我7岁时开始编程，在Commodore VIC 20上，后来被它的更大兄弟Commodore 64所取代。使用的语言是BASIC。后来，我转向了Pascal、汇编、C、C++、Java、JavaScript、Visual
    Basic、PHP、ASP、ASP .NET、C#以及其他我甚至无法记住的较小语言，但只有当我接触到Python时，我才有那种在商店找到正确沙发时的感觉。当你的所有身体部位都在喊叫，“买这个！这个对我们来说是最完美的！”
- en: It took me about a day to get used to it. Its syntax is a bit different from
    what I was used to, and in general, I very rarely worked with a language that
    defines scoping with indentation. But after getting past that initial feeling
    of discomfort (like having new shoes), I just fell in love with it. Deeply. Let's
    see why.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我大约花了一天时间适应它。它的语法与我习惯的不同，总的来说，我很少使用一种通过缩进来定义作用域的语言。但一旦克服了那种最初的不适感（就像穿新鞋一样），我就深深地爱上了它。让我们看看原因。
- en: About Python
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于Python
- en: Before we get into the gory details, let's get a sense of why someone would
    want to use Python (I would recommend you to read the Python page on Wikipedia
    to get a more detailed introduction).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入了解细节之前，让我们了解一下为什么有人想使用Python（我建议你阅读维基百科上的Python页面以获得更详细的介绍）。
- en: To my mind, Python exposes the following qualities.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在我看来，Python展现了以下品质。
- en: Portability
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可移植性
- en: Python runs everywhere, and porting a program from Linux to Windows or Mac is
    usually just a matter of fixing paths and settings. Python is designed for portability
    and it takes care of **operating system** (**OS**) specific quirks behind interfaces
    that shield you from the pain of having to write code tailored to a specific platform.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Python可以在任何地方运行，将程序从Linux迁移到Windows或Mac通常只是修复路径和设置的问题。Python被设计为具有可移植性，它通过接口处理操作系统（**OS**）特定的怪癖，从而保护你免受编写针对特定平台定制的代码的痛苦。
- en: Coherence
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一致性
- en: Python is extremely logical and coherent. You can see it was designed by a brilliant
    computer scientist. Most of the time you can just guess how a method is called,
    if you don't know it.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Python极其逻辑和一致。你可以看到它是由一位杰出的计算机科学家设计的。大多数时候，如果你不知道，你只需猜测一个方法是如何被调用的。
- en: You may not realize how important this is right now, especially if you are at
    the beginning, but this is a major feature. It means less cluttering in your head,
    less skimming through the documentation, and less need for mapping in your brain
    when you code.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能现在还没有意识到这一点的重要性，尤其是如果你刚开始，但这是一个主要特性。这意味着你的头脑中杂乱无章的情况更少，查阅文档的次数更少，当你编码时，在大脑中映射的需求也更少。
- en: Developer productivity
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开发者生产力
- en: According to Mark Lutz (*Learning Python, 5th Edition*, *O'Reilly Media*), a
    Python program is typically one-fifth to one-third the size of equivalent Java
    or C++ code. This means the job gets done faster. And faster is good. Faster means
    a faster response on the market. Less code not only means less code to write,
    but also less code to read (and professional coders read much more than they write),
    less code to maintain, to debug, and to refactor.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Mark Lutz的《Python编程：从入门到实践》（第5版，*O'Reilly Media*），Python程序的大小通常是等效Java或C++代码的五分之一到三分之一。这意味着工作完成得更快。更快是好事。更快意味着市场响应更快。更少的代码不仅意味着要编写的代码更少，而且意味着要阅读的代码更少（而且专业程序员读的比写的多），维护、调试和重构的代码也更少。
- en: Another important aspect is that Python runs without the need of lengthy and
    time consuming compilation and linkage steps, so you don't have to wait to see
    the results of your work.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要方面是，Python无需漫长的编译和链接步骤即可运行，因此你不必等待看到你工作的结果。
- en: An extensive library
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 丰富的库
- en: Python has an incredibly wide standard library (it's said to come with "batteries
    included"). If that wasn't enough, the Python community all over the world maintains
    a body of third party libraries, tailored to specific needs, which you can access
    freely at the **Python Package Index** (**PyPI**). When you code Python and you
    realize that you need a certain feature, in most cases, there is at least one
    library where that feature has already been implemented for you.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Python 拥有一个极其广泛的内置标准库（据说“内置电池”）。如果这还不够，全球的 Python 社区还维护了一个第三方库的集合，这些库针对特定需求定制，你可以在
    **Python 包索引**（**PyPI**）上免费访问。当你编写 Python 代码并意识到你需要某个功能时，在大多数情况下，至少有一个库已经为你实现了这个功能。
- en: Software quality
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 软件质量
- en: Python is heavily focused on readability, coherence, and quality. The language
    uniformity allows for high readability and this is crucial nowadays where code
    is more of a collective effort than a solo experience. Another important aspect
    of Python is its intrinsic multi-paradigm nature. You can use it as scripting
    language, but you also can exploit object-oriented, imperative, and functional
    programming styles. It is versatile.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Python 专注于可读性、连贯性和质量。语言的统一性使得代码具有很高的可读性，这在当今代码更多是集体努力而非个人体验的时代至关重要。Python 的另一个重要方面是其固有的多范式特性。你可以将其用作脚本语言，但也可以利用面向对象、命令式和函数式编程风格。它非常灵活。
- en: Software integration
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 软件集成
- en: Another important aspect is that Python can be extended and integrated with
    many other languages, which means that even when a company is using a different
    language as their mainstream tool, Python can come in and act as a glue agent
    between complex applications that need to talk to each other in some way. This
    is kind of an advanced topic, but in the real world, this feature is very important.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要方面是 Python 可以扩展并与许多其他语言集成，这意味着即使一家公司使用不同的语言作为主流工具，Python 也可以介入并作为需要以某种方式相互通信的复杂应用程序之间的粘合剂。这是一个高级话题，但在现实世界中，这个特性非常重要。
- en: Satisfaction and enjoyment
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 满足与享受
- en: Last but not least, the fun of it! Working with Python is fun. I can code for
    8 hours and leave the office happy and satisfied, alien to the struggle other
    coders have to endure because they use languages that don't provide them with
    the same amount of well-designed data structures and constructs. Python makes
    coding fun, no doubt about it. And fun promotes motivation and productivity.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，乐趣所在！使用 Python 是一件有趣的事情。我可以连续编码 8 个小时，然后快乐地离开办公室，而其他使用不提供同样数量精心设计的数据结构和结构的语言的程序员则必须忍受痛苦。毫无疑问，Python
    让编码变得有趣。而乐趣可以促进动力和生产力。
- en: These are the major aspects why I would recommend Python to everyone for. Of
    course, there are many other technical and advanced features that I could have
    talked about, but they don't really pertain to an introductory section like this
    one. They will come up naturally, chapter after chapter, in this book.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我推荐 Python 给每个人的主要原因。当然，还有很多其他技术和高级特性我可以讨论，但它们并不真正属于像这样一个介绍性章节。它们将在本书的每一章中自然出现。
- en: What are the drawbacks?
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有什么缺点？
- en: Probably, the only drawback that one could find in Python, which is not due
    to personal preferences, is the *execution speed*. Typically, Python is slower
    than its compiled brothers. The standard implementation of Python produces, when
    you run an application, a compiled version of the source code called byte code
    (with the extension `.pyc`), which is then run by the Python interpreter. The
    advantage of this approach is portability, which we pay for with a slowdown due
    to the fact that Python is not compiled down to machine level as are other languages.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 可能，Python 的唯一缺点，这不是由于个人偏好，而是 *执行速度*。通常，Python 比其编译型兄弟慢。Python 的标准实现当你运行应用程序时，会生成源代码的编译版本，称为字节码（扩展名为
    `.pyc`），然后由 Python 解释器运行。这种方法的优点是可移植性，我们为此付出了速度降低的代价，因为 Python 没有像其他语言那样编译到机器级别。
- en: However, Python speed is rarely a problem today, hence its wide use regardless
    of this suboptimal feature. What happens is that in real life, hardware cost is
    no longer a problem, and usually it's easy enough to gain speed by parallelizing
    tasks. When it comes to number crunching though, one can switch to faster Python
    implementations, such as PyPy, which provides an average 7-fold speedup by implementing
    advanced compilation techniques (check [http://pypy.org/](http://pypy.org/) for
    reference).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Python 的速度在当今很少成为问题，因此尽管这个次优特性存在，它仍然得到了广泛的应用。实际上，硬件成本不再是问题，通常通过并行化任务来提高速度是足够的。然而，当涉及到数值计算时，人们可以切换到更快的
    Python 实现，如 PyPy，它通过实现高级编译技术提供了平均 7 倍的速度提升（参考 [http://pypy.org/](http://pypy.org/)
    获取更多信息）。
- en: When doing data science, you'll most likely find that the libraries that you
    use with Python, such as Pandas and Numpy, achieve native speed due to the way
    they are implemented.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行数据科学时，你很可能会发现你与 Python 一起使用的库，如 Pandas 和 Numpy，由于它们的实现方式，能够达到原生速度。
- en: If that wasn't a good enough argument, you can always consider that Python is
    driving the backend of services such as Spotify and Instagram, where performance
    is a concern. Nonetheless, Python does its job perfectly adequately.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这还不够有说服力，你总是可以考虑 Python 正在推动 Spotify 和 Instagram 等服务的后端，这些服务对性能有要求。尽管如此，Python
    完美地完成了它的任务。
- en: Who is using Python today?
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 谁在现在使用 Python？
- en: 'Not yet convinced? Let''s take a very brief look at the companies that are
    using Python today: Google, YouTube, Dropbox, Yahoo, Zope Corporation, Industrial
    Light & Magic, Walt Disney Feature Animation, Pixar, NASA, NSA, Red Hat, Nokia,
    IBM, Netflix, Yelp, Intel, Cisco, HP, Qualcomm, and JPMorgan Chase, just to name
    a few.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 还没有说服你？让我们简要地看看今天正在使用 Python 的公司：Google、YouTube、Dropbox、Yahoo、Zope 公司、工业光魔、华特迪士尼动画、皮克斯、NASA、NSA、Red
    Hat、诺基亚、IBM、Netflix、Yelp、英特尔、思科、惠普、高通和摩根大通，仅举几个例子。
- en: Even games such as *Battlefield 2*, *Civilization 4*, and *QuArK* are implemented
    using Python.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 甚至像 *Battlefield 2*、*Civilization 4* 和 *QuArK* 这样的游戏也是用 Python 实现的。
- en: Python is used in many different contexts, such as system programming, web programming,
    GUI applications, gaming and robotics, rapid prototyping, system integration,
    data science, database applications, and much more.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Python 被用于许多不同的环境，例如系统编程、网络编程、GUI 应用程序、游戏和机器人技术、快速原型设计、系统集成、数据科学、数据库应用程序等等。
- en: Setting up the environment
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置环境
- en: Before we talk about installing Python on your system, let me tell you about
    which Python version I'll be using in this book.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论如何在您的系统上安装 Python 之前，让我告诉你在这本书中我将使用哪个 Python 版本。
- en: Python 2 versus Python 3 – the great debate
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python 2 与 Python 3 – 伟大的辩论
- en: Python comes in two main versions—Python 2, which is the past—and Python 3,
    which is the present. The two versions, though very similar, are incompatible
    on some aspects.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Python 有两个主要版本——Python 2，这是过去——和 Python 3，这是现在。这两个版本虽然非常相似，但在某些方面是不兼容的。
- en: In the real world, Python 2 is actually quite far from being the past. In short,
    even though Python 3 has been out since 2008, the transition phase is still far
    from being over. This is mostly due to the fact that Python 2 is widely used in
    the industry, and of course, companies aren't so keen on updating their systems
    just for the sake of updating, following the *if it ain't broke, don't fix it*
    philosophy. You can read all about the transition between the two versions on
    the Web.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界中，Python 2 实际上离成为过去还相当遥远。简而言之，尽管 Python 3 自 2008 年以来就已经推出，但过渡阶段还远未结束。这主要是因为
    Python 2 在行业中得到了广泛的应用，当然，公司并不那么热衷于仅仅为了更新而更新他们的系统，遵循“如果它没坏，就别修”的哲学。你可以在网上阅读关于这两个版本之间过渡的所有内容。
- en: Another issue that was hindering the transition is the availability of third-party
    libraries. Usually, a Python project relies on tens of external libraries, and
    of course, when you start a new project, you need to be sure that there is already
    a version 3 compatible library for any business requirement that may come up.
    If that's not the case, starting a brand new project in Python 3 means introducing
    a potential risk, which many companies are not happy to take.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个阻碍过渡的问题是第三方库的可用性。通常，一个 Python 项目依赖于数十个外部库，当然，当你开始一个新的项目时，你需要确保已经有一个与任何可能出现的业务需求兼容的版本
    3 兼容的库。如果不是这样，在 Python 3 中启动全新的项目就意味着引入潜在的风险，许多公司都不愿意承担这种风险。
- en: At the time of writing, the majority of the most widely used libraries have
    been ported to Python 3, and it's quite safe to start a project in Python 3 for
    most cases. Many of the libraries have been rewritten so that they are compatible
    with both versions, mostly harnessing the power of the six (2 x 3) library, which
    helps introspecting and adapting the behavior according to the version used.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在写作的时候，大多数最广泛使用的库都已经移植到了 Python 3，对于大多数情况来说，开始一个 Python 3 项目是非常安全的。许多库已经被重写，以便它们与两个版本兼容，主要利用了
    six（2 x 3）库的力量，这个库有助于根据使用的版本进行内省和调整行为。
- en: 'On my Linux box (Ubuntu 14.04), I have the following Python version:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的 Linux 机器（Ubuntu 14.04）上，我使用的 Python 版本如下：
- en: '[PRE0]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: So you can see that my Python version is 3.4.0\. The preceding text is a little
    bit of Python code that I typed into my console. We'll talk about it in a moment.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 所以你可以看到我的 Python 版本是 3.4.0。前面的文本是我输入到我的控制台中的一段 Python 代码。我们稍后会讨论它。
- en: All the examples in this book will be run using this Python version. Most of
    them will run also in Python 2 (I have version 2.7.6 installed as well), and those
    that won't will just require some minor adjustments to cater for the small incompatibilities
    between the two versions. Another reason behind this choice is that I think it's
    better to learn Python 3, and then, if you need to, learn the differences it has
    with Python 2, rather than going the other way around.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的所有示例都将使用这个 Python 版本运行。其中大部分也可以在 Python 2 中运行（我已安装了 Python 2.7.6），而那些不能运行的则只需要进行一些小的调整来适应两个版本之间的小不兼容性。选择这个版本的原因还有，我认为学习
    Python 3 更好，然后，如果你需要的话，再学习它与 Python 2 的差异，而不是反过来。
- en: 'Don''t worry about this version thing though: it''s not that big an issue in
    practice.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，不必担心版本问题：在实践中这并不是一个大问题。
- en: Installing Python
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 Python
- en: I never really got the point of having a *setup* section in a book, regardless
    of what it is that you have to set up. Most of the time, between the time the
    author writes the instruction and the time you actually try them out, months have
    passed. That is, if you're lucky. One version change and things may not work the
    way it is described in the book. Luckily, we have the Web now, so in order to
    help you get up and running, I'll just give you pointers and objectives.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我从未真正理解为什么一本书中要有“设置”这一章节，无论你需要设置什么。大多数情况下，从作者编写说明到你自己尝试它们，可能已经过去了数月。也就是说，如果你很幸运的话。一旦版本更新，事情可能就不会像书中描述的那样工作。幸运的是，我们现在有了网络，为了帮助你快速上手，我只会给你提供一些指导和目标。
- en: Tip
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'If any of the URLs or resources I''ll point you to are no longer there by the
    time you read this book, just remember: Google is your friend.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我在本书中提到的任何 URL 或资源在你阅读本书时已经不存在，请记住：谷歌是你的朋友。
- en: Setting up the Python interpreter
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置 Python 解释器
- en: First of all, let's talk about your OS. Python is fully integrated and most
    likely already installed in basically almost every Linux distribution. If you
    have a Mac, it's likely that Python is already there as well (however, possibly
    only Python 2.7), whereas if you're using Windows, you probably need to install
    it.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们谈谈你的操作系统。Python 在几乎所有 Linux 发行版中都是完全集成的，并且很可能已经安装好了（然而，可能只有 Python 2.7），而如果你使用的是
    Mac，Python 也可能已经安装好了（然而，可能只有 Python 2.7），而如果你使用的是 Windows，你可能需要安装它。
- en: Getting Python and the libraries you need up and running requires a bit of handiwork.
    Linux happens to be the most user friendly OS for Python programmers, Windows
    on the other hand is the one that requires the biggest effort, Mac being somewhere
    in between. For this reason, if you can choose, I suggest you to use Linux. If
    you can't, and you have a Mac, then go for it anyway. If you use Windows, you'll
    be fine for the examples in this book, but in general working with Python will
    require you a bit more tweaking.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 Python 和所需的库并使其运行需要一点手动操作。Linux 对于 Python 程序员来说是最友好的操作系统，而 Windows 则需要最大的努力，Mac
    则介于两者之间。因此，如果你可以选择，我建议你使用 Linux。如果你不能，并且你有 Mac，那么无论如何都去尝试。如果你使用 Windows，你将能够运行本书中的示例，但总的来说，使用
    Python 需要你进行一些调整。
- en: My OS is Ubuntu 14.04, and this is what I will use throughout the book, along
    with Python 3.4.0.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我的操作系统是 Ubuntu 14.04，本书中我会一直使用这个版本，以及 Python 3.4.0。
- en: 'The place you want to start is the official Python website: [https://www.python.org](https://www.python.org).
    This website hosts the official Python documentation and many other resources
    that you will find very useful. Take the time to explore it.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 您想要开始的地方是官方Python网站：[https://www.python.org](https://www.python.org)。该网站托管了官方Python文档和许多其他您会发现非常有用的资源。花点时间探索它。
- en: Tip
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Another excellent, resourceful website on Python and its ecosystem is [http://docs.python-guide.org](http://docs.python-guide.org).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个关于Python及其生态系统的优秀、资源丰富的网站是[http://docs.python-guide.org](http://docs.python-guide.org)。
- en: Find the download section and choose the installer for your OS. If you are on
    Windows, make sure that when you run the installer, you check the option `install
    pip` (actually, I would suggest to make a complete installation, just to be safe,
    of all the components the installer holds). We'll talk about pip later.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 找到下载部分，选择适合您操作系统的安装程序。如果您在Windows上，确保在运行安装程序时，您选中了`install pip`选项（实际上，我建议进行完整安装，以确保安装程序包含的所有组件都安装好）。我们稍后会谈到pip。
- en: Now that Python is installed in your system, the objective is to be able to
    open a console and run the Python interactive shell by typing `python`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在Python已安装到您的系统中，目标是能够打开控制台并通过输入`python`来运行Python交互式shell。
- en: Note
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Please note that I usually refer to the *Python interactive shell* simply as
    *Python console*.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我通常将*Python交互式shell*简单地称为*Python控制台*。
- en: To open the console in Windows, go to the **Start** menu, choose **Run**, and
    type `cmd`. If you encounter anything that looks like a permission problem while
    working on the examples of this book, please make sure you are running the console
    with administrator rights.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Windows中打开控制台，请转到**开始**菜单，选择**运行**，然后输入`cmd`。如果在本书的示例中遇到任何看起来像权限问题的东西，请确保您以管理员权限运行控制台。
- en: On the Mac OS X, you can start a terminal by going to **Applications** | **Utilities**
    | **Terminal**.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在Mac OS X上，您可以通过转到**应用程序** | **实用工具** | **终端**来启动一个终端。
- en: If you are on Linux, you know all that there is to know about the console.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在Linux上，您已经知道所有关于控制台的知识。
- en: Note
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'I will use the term *console* interchangeably to indicate the Linux **console**,
    the Windows **command prompt**, and the Mac **terminal**. I will also indicate
    the command-line prompt with the Linux default format, like this:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我将交替使用术语*控制台*来表示Linux **控制台**、Windows **命令提示符**和Mac **终端**。我还会使用Linux默认格式来指示命令行提示符，如下所示：
- en: '[PRE1]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Whatever console you open, type `python` at the prompt, and make sure the Python
    interactive shell shows up. Type `exit()` to quit. Keep in mind that you may have
    to specify `python3` if your OS comes with Python 2.* preinstalled.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您打开哪个控制台，在提示符下输入`python`，并确保Python交互式shell出现。输入`exit()`退出。请记住，如果您的操作系统预装了Python
    2.*，您可能需要指定`python3`。
- en: 'This is how it should look on Windows 7:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在Windows 7上的样子：
- en: '![Setting up the Python interpreter](img/4715_01_01.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![设置Python解释器](img/4715_01_01.jpg)'
- en: 'And this is how it should look on Linux:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在Linux上的样子：
- en: '![Setting up the Python interpreter](img/4715_01_02.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![设置Python解释器](img/4715_01_02.jpg)'
- en: 'Now that Python is set up and you can run it, it''s time to make sure you have
    the other tool that will be indispensable to follow the examples in the book:
    virtualenv.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在Python已设置好并且可以运行，是时候确保您拥有其他将不可或缺的工具，以便跟随书中的示例：virtualenv。
- en: About virtualenv
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于virtualenv
- en: As you probably have guessed by its name, **virtualenv** is all about virtual
    environments. Let me explain what they are and why we need them and let me do
    it by means of a simple example.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所猜测的，**virtualenv**全名是关于虚拟环境。让我解释一下它们是什么，为什么我们需要它们，并通过一个简单的例子来说明。
- en: You install Python on your system and you start working on a website for client
    X. You create a project folder and start coding. Along the way you also install
    some libraries, for example the Django framework, which we'll see in depth in
    [Chapter 10](ch10.html "Chapter 10. Web Development Done Right"), *Web Development
    Done Right*. Let's say the Django version you install for project X is 1.7.1.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 您在系统中安装Python并开始为客户X制作一个网站。您创建了一个项目文件夹并开始编码。在这个过程中，您还安装了一些库，例如Django框架，我们将在第10章[Web
    Development Done Right](ch10.html "第10章。正确进行Web开发")中深入探讨，*正确进行Web开发*。假设您为项目X安装的Django版本是1.7.1。
- en: 'Now, your website is so good that you get another client, Y. He wants you to
    build another website, so you start project Y and, along the way, you need to
    install Django again. The only issue is that now the Django version is 1.8 and
    you cannot install it on your system because this would replace the version you
    installed for project X. You don''t want to risk introducing incompatibility issues,
    so you have two choices: either you stick with the version you have currently
    on your machine, or you upgrade it and make sure the first project is still fully
    working correctly with the new version.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你的网站做得如此出色，你得到了另一个客户Y。他希望让你再建一个网站，所以你开始项目Y，在这个过程中，你需要再次安装Django。唯一的问题是现在Django的版本是1.8，你无法在你的系统上安装它，因为这会替换掉你为项目X安装的版本。你不想冒引入不兼容性问题的风险，所以你有两个选择：要么坚持使用你机器上现有的版本，要么升级它并确保第一个项目仍然能够完全正确地运行在新版本上。
- en: 'Let''s be honest, neither of these options is very appealing, right? Definitely
    not. So, here''s the solution: virtualenv!'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 诚实地讲，这两种选择都不太吸引人，对吧？绝对不是。所以，这里有一个解决方案：virtualenv！
- en: virtualenv is a tool that allows you to create a virtual environment. In other
    words, it is a tool to create isolated Python environments, each of which is a
    folder that contains all the necessary executables to use the packages that a
    Python project would need (think of packages as libraries for the time being).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 'virtualenv是一个允许你创建虚拟环境的工具。换句话说，它是一个创建隔离的Python环境的工具，每个环境都是一个包含所有必要的可执行文件以使用Python项目所需的包的文件夹（暂时将包视为库）。 '
- en: So you create a virtual environment for project X, install all the dependencies,
    and then you create a virtual environment for project Y, installing all its dependencies
    without the slightest worry because every library you install ends up within the
    boundaries of the appropriate virtual environment. In our example, project X will
    hold Django 1.7.1, while project Y will hold Django 1.8.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你为项目X创建了一个虚拟环境，安装了所有依赖项，然后你为项目Y创建了一个虚拟环境，安装了所有其依赖项，而无需丝毫担心，因为每个你安装的库最终都会在适当的虚拟环境边界内。在我们的例子中，项目X将包含Django
    1.7.1，而项目Y将包含Django 1.8。
- en: Note
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'It is of vital importance that you never install libraries directly at the
    system level. Linux for example relies on Python for many different tasks and
    operations, and if you fiddle with the system installation of Python, you risk
    compromising the integrity of the whole system (guess to whom this happened…).
    So take this as a rule, such as brushing your teeth before going to bed: *always,
    always create a virtual environment when you start a new project*.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 永远不要在系统级别直接安装库这一点至关重要。例如，Linux依赖于Python执行许多不同的任务和操作，如果你篡改Python的系统安装，你可能会危及整个系统的完整性（猜猜这是谁遇到的…）。所以，把这当作一个规则，就像睡前刷牙一样：*每次开始一个新项目时，总是创建一个虚拟环境*。
- en: 'To install virtualenv on your system, there are a few different ways. On a
    Debian-based distribution of Linux for example, you can install it with the following
    command:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 要在你的系统上安装virtualenv，有几种不同的方法。例如，在基于Debian的Linux发行版上，你可以使用以下命令进行安装：
- en: '[PRE2]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Probably, the easiest way is to use `pip` though, with the following command:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 可能，最简单的方法是使用`pip`，以下是一个命令：
- en: '[PRE3]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`pip` is a package management system used to install and manage software packages
    written in Python.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`pip`是一个用于安装和管理用Python编写的软件包的包管理系统。'
- en: 'Python 3 has built-in support for virtual environments, but in practice, the
    external libraries are still the default on production systems. If you have trouble
    getting virtualenv up and running, please refer to the virtualenv official website:
    [https://virtualenv.pypa.io](https://virtualenv.pypa.io).'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Python 3内置了对虚拟环境的支持，但在实践中，外部库仍然是生产系统上的默认选项。如果你在设置virtualenv时遇到麻烦，请参阅virtualenv官方网站：[https://virtualenv.pypa.io](https://virtualenv.pypa.io)。
- en: Your first virtual environment
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 您的第一个虚拟环境
- en: It is very easy to create a virtual environment, but according to how your system
    is configured and which Python version you want the virtual environment to run,
    you need to run the command properly. Another thing you will need to do with a
    virtualenv, when you want to work with it, is to activate it. Activating a virtualenv
    basically produces some path juggling behind the scenes so that when you call
    the Python interpreter, you're actually calling the active virtual environment
    one, instead of the mere system one.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 创建虚拟环境非常简单，但根据您的系统配置和您希望虚拟环境运行的 Python 版本，您需要正确运行命令。另外，当您想使用 virtualenv 时，您还需要执行激活操作。激活
    virtualenv 实际上会在后台进行一些路径调整，这样当您调用 Python 解释器时，您实际上是在调用活动的虚拟环境，而不是普通的系统环境。
- en: 'I''ll show you a full example on both Linux and Windows. We will:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我将向您展示在 Linux 和 Windows 上的完整示例。我们将：
- en: Create a folder named `learning.python` under your project root (which in my
    case is a folder called `srv`, in my home folder). Please adapt the paths according
    to the setup you fancy on your box.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的项目根目录下创建一个名为 `learning.python` 的文件夹（在我的情况下，这是一个名为 `srv` 的文件夹，位于我的家目录中）。请根据您在机器上的设置调整路径。
- en: Within the `learning.python` folder, we will create a virtual environment called
    `.lpvenv`.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `learning.python` 文件夹内，我们将创建一个名为 `.lpvenv` 的虚拟环境。
- en: Note
  id: totrans-129
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Some developers prefer to call all virtual environments using the same name
    (for example, `.venv`). This way they can run scripts against any virtualenv by
    just knowing the name of the project they dwell in. This is a very common technique
    that I use as well. The dot in `.venv` is because in Linux/Mac prepending a name
    with a dot makes that file or folder invisible.
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一些开发者更喜欢使用相同的名称（例如，`.venv`）来调用所有虚拟环境。这样，他们只需知道他们所在项目的名称，就可以运行任何虚拟环境中的脚本。这是一种非常常见的技巧，我也是这样使用的。`.venv`
    中的点是因为在 Linux/Mac 中，在名称前加上点会使该文件或文件夹不可见。
- en: After creating the virtual environment, we will activate it (this is slightly
    different between Linux, Mac, and Windows).
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建虚拟环境后，我们将激活它（在 Linux、Mac 和 Windows 之间略有不同）。
- en: Then, we'll make sure that we are running the desired Python version (3.4.*)
    by running the Python interactive shell.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将确保我们正在运行所需的 Python 版本（3.4.*），通过运行 Python 交互式外壳来做到这一点。
- en: Finally, we will deactivate the virtual environment using the deactivate command.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将使用 deactivate 命令来关闭虚拟环境。
- en: These five simple steps will show you all you have to do to start and use a
    project.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这五个简单的步骤将向您展示您需要开始和使用项目所做的一切。
- en: 'Here''s an example of how those steps might look like on Linux (commands that
    start with a `#` are comments):'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个在 Linux 上如何执行这些步骤的示例（以 `#` 开头的命令是注释）：
- en: '![Your first virtual environment](img/4715_01_03.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![您的第一个虚拟环境](img/4715_01_03.jpg)'
- en: Notice that I had to explicitly tell virtualenv to use the Python 3.4 interpreter
    because on my box Python 2.7 is the default one. Had I not done that, I would
    have had a virtual environment with Python 2.7 instead of Python 3.4.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我必须明确告诉 virtualenv 使用 Python 3.4 解释器，因为在我的机器上 Python 2.7 是默认的。如果我没有这样做，我将有一个
    Python 2.7 而不是 Python 3.4 的虚拟环境。
- en: 'You can combine the two instructions for *step 2* in one single command like
    this:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将 *步骤 2* 的两个指令合并为一个单独的命令，如下所示：
- en: '[PRE4]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: I preferred to be explicitly verbose in this instance, to help you understand
    each bit of the procedure.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我更喜欢明确地详细说明，以帮助您理解每个步骤的细节。
- en: Another thing to notice is that in order to activate a virtual environment,
    we need to run the `/bin/activate` script, which needs to be sourced (when a script
    is "sourced", it means that its effects stick around when it's done running).
    This is very important. Also notice how the prompt changes after we activate the
    virtual environment, showing its name on the left (and how it disappears when
    we deactivate). In Mac OS, the steps are the same so I won't repeat them here.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 另一件需要注意的事情是，为了激活一个虚拟环境，我们需要运行 `/bin/activate` 脚本，该脚本需要被引用（当一个脚本被“引用”时，意味着它在运行完成后其效果仍然存在）。这一点非常重要。同时注意，在激活虚拟环境后，提示符发生了变化，显示其名称在左侧（以及当我们关闭时它如何消失）。在
    Mac OS 中，步骤是相同的，所以这里不再重复。
- en: Now let's have a look at how we can achieve the same result in Windows. You
    will probably have to play around a bit, especially if you have a different Windows
    or Python version than I'm using here. This is all good experience though, so
    try and think positively at the initial struggle that every coder has to go through
    in order to get things going.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何在Windows上实现相同的结果。你可能需要做一些尝试，特别是如果你使用的Windows或Python版本与我这里的不同。但这都是很好的经验，所以试着在开始时保持积极的态度，因为每个程序员都必须经历这种为了启动项目而必须克服的初步挑战。
- en: 'Here''s how it should look on Windows (commands that start with `::` are comments):'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是在Windows上的样子（以`::`开头的命令是注释）：
- en: '![Your first virtual environment](img/4715_01_04.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![你的第一个虚拟环境](img/4715_01_04.jpg)'
- en: Notice there are a few small differences from the Linux version. Apart from
    the commands to create and navigate the folders, one important difference is how
    you activate your virtualenv. Also, in Windows there is no `which` command, so
    we used the `where` command.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，与Linux版本相比，有一些细微的差别。除了创建和导航文件夹的命令外，一个重要的区别是激活你的virtualenv的方式。另外，在Windows中，没有`which`命令，所以我们使用了`where`命令。
- en: 'At this point, you should be able to create and activate a virtual environment.
    Please try and create another one without me guiding you, get acquainted to this
    procedure because it''s something that you will always be doing: *we never work
    system-wide with Python*, remember? It''s extremely important.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你应该能够创建和激活一个虚拟环境。请尝试在没有我的指导下创建另一个，熟悉这个流程，因为它是你将一直要做的事情：我们从不全局使用Python，记住？这非常重要。
- en: So, with the scaffolding out of the way, we're ready to talk a bit more about
    Python and how you can use it. Before we do it though, allow me to spend a few
    words about the console.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在搭建好框架之后，我们准备更深入地讨论Python以及如何使用它。但在我们这样做之前，请允许我花几分钟谈谈控制台。
- en: Your friend, the console
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你的朋友，控制台
- en: In this era of GUIs and touchscreen devices, it seems a little ridiculous to
    have to resort to a tool such as the console, when everything is just about one
    click away.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图形用户界面和触摸屏设备的时代，似乎有些荒谬，不得不求助于像控制台这样的工具，因为一切似乎都只需要一键即可完成。
- en: But the truth is every time you remove your right hand from the keyboard (or
    the left one, if you're a lefty) to grab your mouse and move the cursor over to
    the spot you want to click, you're losing time. Getting things done with the console,
    counter-intuitively as it may be, results in higher productivity and speed. I
    know, you have to trust me on this.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 但事实是，每当你从键盘（或者如果你是左撇子，是左手）上移开右手（或左手）去抓鼠标并将光标移动到你想要点击的位置时，你都在浪费时间。用控制台完成任务，尽管这可能看起来有些反直觉，但结果却是更高的生产力和速度。我知道，你必须相信我。
- en: 'Speed and productivity are important and personally, I have nothing against
    the mouse, but there is another very good reason for which you may want to get
    well acquainted with the console: when you develop code that ends up on some server,
    the console might be the only available tool. If you make friends with it, I promise
    you, you will never get lost when it''s of utmost importance that you don''t (typically,
    when the website is down and you have to investigate very quickly what''s going
    on).'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 速度和生产力很重要，就我个人而言，我对鼠标没有意见，但还有一个非常好的理由让你熟悉控制台：当你开发的代码最终部署到某个服务器上时，控制台可能是唯一可用的工具。如果你能与之成为朋友，我保证，在你最需要的时候，你永远不会迷失方向（通常，当网站宕机时，你必须迅速调查发生了什么）。
- en: So it's really up to you. If you're in doubt, please grant me the benefit of
    the doubt and give it a try. It's easier than you think, and you'll never regret
    it. There is nothing more pitiful than a good developer who gets lost within an
    SSH connection to a server because they are used to their own custom set of tools,
    and only to that.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这完全取决于你。如果你有疑虑，请给我一个机会，尝试一下。这比你想象的要简单，你永远不会后悔。没有什么比一个优秀的开发者因为习惯了自己定制的工具集，而迷失在服务器的SSH连接中更可怜的了。
- en: Now, let's get back to Python.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到Python。
- en: How you can run a Python program
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何运行Python程序
- en: There are a few different ways in which you can run a Python program.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过几种不同的方式运行Python程序。
- en: Running Python scripts
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行Python脚本
- en: Python can be used as a scripting language. In fact, it always proves itself
    very useful. Scripts are files (usually of small dimensions) that you normally
    execute to do something like a task. Many developers end up having their own arsenal
    of tools that they fire when they need to perform a task. For example, you can
    have scripts to parse data in a format and render it into another different format.
    Or you can use a script to work with files and folders. You can create or modify
    configuration files, and much more. Technically, there is not much that cannot
    be done in a script.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Python可以用作脚本语言。实际上，它总是证明自己非常有用。脚本通常是小型文件，你通常执行它们来完成某些任务，比如一个任务。许多开发者最终会拥有自己的工具库，当他们需要执行任务时就会使用这些工具。例如，你可以有脚本来解析一种格式的数据并将其渲染成另一种不同的格式。或者你可以使用脚本来处理文件和文件夹。你可以创建或修改配置文件，等等。从技术上讲，在脚本中几乎可以做任何事情。
- en: It's quite common to have scripts running at a precise time on a server. For
    example, if your website database needs cleaning every 24 hours (for example,
    the table that stores the user sessions, which expire pretty quickly but aren't
    cleaned automatically), you could set up a cron job that fires your script at
    3:00 A.M. every day.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器上，脚本在精确时间运行是很常见的。例如，如果你的网站数据库需要每24小时清理一次（例如，存储用户会话的表，这些会话很快就会过期但不会自动清理），你可以设置一个cron作业，每天凌晨3点触发你的脚本。
- en: Note
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: According to Wikipedia, the software utility Cron is a time-based job scheduler
    in Unix-like computer operating systems. People who set up and maintain software
    environments use cron to schedule jobs (commands or shell scripts) to run periodically
    at fixed times, dates, or intervals.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 根据维基百科，软件实用工具Cron是类Unix计算机操作系统中的基于时间的作业调度器。设置和维护软件环境的人员使用cron来安排作业（命令或shell脚本）在固定的时间、日期或间隔定期运行。
- en: I have Python scripts to do all the menial tasks that would take me minutes
    or more to do manually, and at some point, I decided to automate. For example,
    I have a laptop that doesn't have a *Fn* key to toggle the touchpad on and off.
    I find this very annoying, and I don't want to go clicking about through several
    menus when I need to do it, so I wrote a small script that is smart enough to
    tell my system to toggle the touchpad active state, and now I can do it with one
    simple click from my launcher. Priceless.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我有一些Python脚本可以完成那些需要我手动操作几分钟甚至更长时间的低级任务，并且在某一点上，我决定自动化。例如，我有一台没有*Fn*键来切换触摸板开关的笔记本电脑。我觉得这非常烦人，而且我不希望每次需要这样做时都要在几个菜单中点击，所以我编写了一个小脚本，足够智能地告诉我的系统切换触摸板的活动状态，现在我可以通过启动器的一个简单点击来完成它。无价之宝。
- en: We'll devote half of [Chapter 8](ch08.html "Chapter 8. The Edges – GUIs and
    Scripts"), *The Edges – GUIs and Scripts* on scripting with Python.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把[第8章](ch08.html "第8章。边缘 – 图形用户界面和脚本")的一半内容，即*边缘 – 图形用户界面和脚本*，用于Python脚本编写。
- en: Running the Python interactive shell
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行Python交互式shell
- en: Another way of running Python is by calling the interactive shell. This is something
    we already saw when we typed `python` on the command line of our console.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 运行Python的另一种方式是通过调用交互式shell。这是我们之前在控制台的命令行中输入`python`时已经看到过的。
- en: 'So open a console, activate your virtual environment (which by now should be
    second nature to you, right?), and type `python`. You will be presented with a
    couple of lines that should look like this (if you are on Linux):'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 因此打开控制台，激活你的虚拟环境（到现在这应该已经变得很自然了，对吧？），然后输入`python`。你会看到几行，如果是在Linux系统上，它们应该看起来像这样：
- en: '[PRE5]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Those `>>>` are the prompt of the shell. They tell you that Python is waiting
    for you to type something. If you type a simple instruction, something that fits
    in one line, that's all you'll see. However, if you type something that requires
    more than one line of code, the shell will change the prompt to `...`, giving
    you a visual clue that you're typing a multiline statement (or anything that would
    require more than one line of code).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 那些带有`>>>`的提示符是shell的提示符。它们告诉你Python正在等待你输入某些内容。如果你输入一个简单的指令，一行之内就能完成的指令，那么你只会看到这个指令。然而，如果你输入需要多行代码的指令，shell会将提示符更改为`...`，给你一个视觉提示，表明你正在输入一个多行语句（或任何需要多行代码的内容）。
- en: 'Go on, try it out, let''s do some basic maths:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 继续尝试吧，让我们做一些基本的数学题：
- en: '[PRE6]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The last operation is showing you something incredible. We raise 2 to the power
    of 1024, and Python is handling this task with no trouble at all. Try to do it
    in Java, C++, or C#. It won't work, unless you use special libraries to handle
    such big numbers.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的操作是展示一些令人难以置信的事情。我们将 2 的 1024 次幂，Python 完全没有问题地处理这个任务。尝试在 Java、C++ 或 C# 中做这件事，除非你使用特殊库来处理这样的大数，否则它不会工作。
- en: I use the interactive shell every day. It's extremely useful to debug very quickly,
    for example, to check if a data structure supports an operation. Or maybe to inspect
    or run a piece of code.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我每天都在使用交互式外壳。它对于快速调试非常有用，例如，检查一个数据结构是否支持一个操作。或者也许检查或运行一段代码。
- en: When you use Django (a web framework), the interactive shell is coupled with
    it and allows you to work your way through the framework tools, to inspect the
    data in the database, and many more things. You will find that the interactive
    shell will soon become one of your dearest friends on the journey you are embarking
    on.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用 Django（一个 Web 框架）时，交互式外壳与之耦合，允许你通过框架工具工作，检查数据库中的数据，以及更多的事情。你会发现，交互式外壳很快就会成为你在即将开始的旅程中最亲密的朋友之一。
- en: Another solution, which comes in a much nicer graphic layout, is to use **IDLE**
    (**Integrated DeveLopment Environment**). It's quite a simple IDE, which is intended
    mostly for beginners. It has a slightly larger set of capabilities than the naked
    interactive shell you get in the console, so you may want to explore it. It comes
    for free in the Windows Python installer and you can easily install it in any
    other system. You can find information about it on the Python website.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个解决方案，它提供了一个更漂亮的图形布局，是使用 **IDLE**（**集成开发环境**）。它相当简单，主要面向初学者。它比控制台中的裸交互式外壳具有更广泛的功能集，因此你可能想探索它。它随
    Windows Python 安装程序免费提供，你可以在任何其他系统上轻松安装它。你可以在 Python 网站上找到有关它的信息。
- en: Guido Van Rossum named Python after the British comedy group Monty Python, so
    it's rumored that the name IDLE has been chosen in honor of Erik Idle, one of
    Monty Python's founding members.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 吉多·范罗苏姆将 Python 命名为英国喜剧团体 Monty Python 的名字，因此据说 IDLE 的名字是为了纪念 Monty Python 的创始人之一埃里克·艾德勒。
- en: Running Python as a service
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将 Python 作为服务运行
- en: Apart from being run as a script, and within the boundaries of a shell, Python
    can be coded and run as proper software. We'll see many examples throughout the
    book about this mode. And we'll understand more about it in a moment, when we'll
    talk about how Python code is organized and run.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 除了作为脚本运行和在壳内运行之外，Python 还可以编码并作为真正的软件运行。本书中我们将看到许多关于这种模式的示例。我们将在稍后讨论 Python
    代码的组织和运行方式时了解更多关于它。
- en: Running Python as a GUI application
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将 Python 作为 GUI 应用程序运行
- en: Python can also be run as a **GUI** (**Graphical User Interface**). There are
    several frameworks available, some of which are cross-platform and some others
    are platform-specific. In [Chapter 8](ch08.html "Chapter 8. The Edges – GUIs and
    Scripts"), *The Edges – GUIs and Scripts*, we'll see an example of a GUI application
    created using *Tkinter*, which is an object-oriented layer that lives on top of
    **Tk** (Tkinter means Tk Interface).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: Python 也可以作为 **GUI**（**图形用户界面**）运行。有几种框架可供选择，其中一些是跨平台的，而其他一些则是特定平台的。在 [第 8 章](ch08.html
    "第 8 章。边缘 – GUI 和脚本") *边缘 – GUI 和脚本* 中，我们将看到一个使用 *Tkinter* 创建的 GUI 应用程序的示例，Tkinter
    是一个位于 **Tk**（Tkinter 意味着 Tk 接口）之上的面向对象的层。
- en: Note
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Tk is a graphical user interface toolkit that takes desktop application development
    to a higher level than the conventional approach. It is the standard GUI for **Tcl**
    (**Tool Command Language**), but also for many other dynamic languages and can
    produce rich native applications that run seamlessly under Windows, Linux, Mac
    OS X, and more.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: Tk 是一个图形用户界面工具包，它将桌面应用程序开发提升到了比传统方法更高的水平。它是 **Tcl**（**工具命令语言**）的标准 GUI，也是许多其他动态语言的
    GUI，可以在 Windows、Linux、Mac OS X 等操作系统上无缝运行丰富本机应用程序。
- en: Tkinter comes bundled with Python, therefore it gives the programmer easy access
    to the GUI world, and for these reasons, I have chosen it to be the framework
    for the GUI examples that I'll present in this book.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: Tkinter 与 Python 一起打包，因此它为程序员提供了轻松访问 GUI 世界的方式，出于这些原因，我选择了它作为本书中将要展示的 GUI 示例的框架。
- en: 'Among the other GUI frameworks, we find that the following are the most widely
    used:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他 GUI 框架中，我们发现以下是最广泛使用的：
- en: PyQt
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PyQt
- en: wxPython
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: wxPython
- en: PyGtk
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PyGtk
- en: 'Describing them in detail is outside the scope of this book, but you can find
    all the information you need on the Python website in the *GUI Programming* section.
    If GUIs are what you''re looking for, remember to choose the one you want according
    to some principles. Make sure they:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 详细描述它们超出了本书的范围，但你可以在Python网站上的*GUI编程*部分找到你需要的所有信息。如果你在寻找GUI，记得根据一些原则选择你想要的。确保它们：
- en: Offer all the features you may need to develop your project
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供你可能需要的所有功能来开发你的项目
- en: Run on all the platforms you may need to support
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在所有你可能需要支持的平台上运行
- en: Rely on a community that is as wide and active as possible
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依靠尽可能广泛和活跃的社区
- en: Wrap graphic drivers/tools that you can easily install/access
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包装那些你可以轻松安装/访问的图形驱动程序/工具
- en: How is Python code organized
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python代码是如何组织的
- en: Let's talk a little bit about how Python code is organized. In this paragraph,
    we'll start going down the rabbit hole a little bit more and introduce a bit more
    technical names and concepts.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简单谈谈Python代码是如何组织的。在这段话中，我们将深入探讨一些更多的技术名称和概念。
- en: Starting with the basics, how is Python code organized? Of course, you write
    your code into files. When you save a file with the extension `.py`, that file
    is said to be a Python module.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 从基础知识开始，Python代码是如何组织的？当然，你将你的代码写入文件。当你保存一个扩展名为`.py`的文件时，这个文件就被认为是Python模块。
- en: Tip
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you're on Windows or Mac, which typically hide file extensions to the user,
    please make sure you change the configuration so that you can see the complete
    name of the files. This is not strictly a requirement, but a hearty suggestion.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在Windows或Mac上，这些系统通常默认隐藏文件扩展名以供用户查看，请确保你更改配置，以便可以看到文件的完整名称。这并不是一个严格的要求，而是一个诚恳的建议。
- en: It would be impractical to save all the code that it is required for software
    to work within one single file. That solution works for *scripts*, which are usually
    not longer than a few hundred lines (and often they are quite shorter than that).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有必需的代码保存到一个单独的文件中对于软件来说是不切实际的。这种解决方案适用于*脚本*，通常不超过几百行（而且通常比这还要短得多）。
- en: A complete Python application can be made of hundreds of thousands of lines
    of code, so you will have to scatter it through different modules. Better, but
    not nearly good enough. It turns out that even like this it would still be impractical
    to work with the code. So Python gives you another structure, called **package**,
    which allows you to group modules together. A package is nothing more than a folder,
    which must contain a special file, `__init__.py` that doesn't need to hold any
    code but whose presence is required to tell Python that the folder is not just
    some folder, but it's actually a package (note that as of Python 3.3 `__init__.py`
    is not strictly required any more).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 一个完整的Python应用程序可能由数十万行代码组成，因此你将不得不将它们分散到不同的模块中。这更好，但还远远不够好。结果发现，即使这样，处理代码仍然是不切实际的。所以Python为你提供了另一种结构，称为**包**，它允许你将模块分组在一起。包不过是一个文件夹，它必须包含一个特殊的文件，`__init__.py`，这个文件不需要包含任何代码，但其存在是必须的，以告诉Python这个文件夹不仅仅是一个文件夹，而实际上是一个包（注意，从Python
    3.3开始，`__init__.py`不再是严格必需的）。
- en: 'As always, an example will make all of this much clearer. I have created an
    example structure in my book project, and when I type in my Linux console:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 总是如此，一个例子会让这一切变得更加清晰。我在我的书项目中创建了一个示例结构，当我在我Linux控制台中输入：
- en: '[PRE7]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'I get a tree representation of the contents of the `ch1/example` folder, which
    holds the code for the examples of this chapter. Here''s how a structure of a
    real simple application could look like:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我得到了`ch1/example`文件夹内容的树状表示，这个文件夹包含本章示例的代码。一个真实简单应用程序的结构可能看起来是这样的：
- en: '[PRE8]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You can see that within the root of this example, we have two modules, `core.py`
    and `run.py`, and one package: `util`. Within `core.py`, there may be the core
    logic of our application. On the other hand, within the `run.py` module, we can
    probably find the logic to start the application. Within the `util` package, I
    expect to find various utility tools, and in fact, we can guess that the modules
    there are called by the type of tools they hold: `db.py` would hold tools to work
    with databases, `math.py` would of course hold mathematical tools (maybe our application
    deals with financial data), and `network.py` would probably hold tools to send/receive
    data on networks.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，在这个示例的根目录下，我们有两个模块，`core.py` 和 `run.py`，以及一个包：`util`。在 `core.py` 中，可能会有我们应用程序的核心逻辑。另一方面，在
    `run.py` 模块中，我们可能可以找到启动应用程序的逻辑。在 `util` 包中，我预计会找到各种实用工具，实际上，我们可以猜测那里的模块是根据它们持有的工具类型命名的：`db.py`
    会包含用于处理数据库的工具，`math.py` 当然会包含数学工具（也许我们的应用程序处理财务数据），而 `network.py` 很可能包含用于在网络上发送/接收数据的工具。
- en: As explained before, the `__init__.py` file is there just to tell Python that
    `util` is a package and not just a mere folder.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`__init__.py` 文件仅仅是为了告诉 Python `util` 是一个包，而不仅仅是一个文件夹。
- en: 'Had this software been organized within modules only, it would have been much
    harder to infer its structure. I put a *module only* example under the `ch1/files_only`
    folder, see it for yourself:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个软件仅仅在模块中组织，那么推断其结构将会更加困难。我把一个**仅模块**的例子放在了 `ch1/files_only` 文件夹下，自己去看看吧：
- en: '[PRE9]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This shows us a completely different picture:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这向我们展示了一个完全不同的画面：
- en: '[PRE10]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: It is a little harder to guess what each module does, right? Now, consider that
    this is just a simple example, so you can guess how much harder it would be to
    understand a real application if we couldn't organize the code in packages and
    modules.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 猜测每个模块的功能有点困难，对吧？现在，考虑到这仅仅是一个简单的例子，你可以想象如果我们不能将代码组织成包和模块，理解一个真实的应用程序会有多难。
- en: How do we use modules and packages
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们如何使用模块和包
- en: 'When a developer is writing an application, it is very likely that they will
    need to apply the same piece of logic in different parts of it. For example, when
    writing a parser for the data that comes from a form that a user can fill in a
    web page, the application will have to validate whether a certain field is holding
    a number or not. Regardless of how the logic for this kind of validation is written,
    it''s very likely that it will be needed in more than one place. For example in
    a poll application, where the user is asked many question, it''s likely that several
    of them will require a numeric answer. For example:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个开发者编写一个应用程序时，他们很可能需要在它的不同部分应用相同的逻辑。例如，当编写一个用于处理用户可以在网页上填写的表单数据的解析器时，应用程序将不得不验证某个字段是否包含数字。无论这种验证逻辑是如何编写的，它很可能需要应用在多个地方。例如，在一个投票应用程序中，用户会被问及许多问题，其中一些很可能需要数字答案。例如：
- en: What is your age
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你多大了
- en: How many pets do you own
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你拥有多少宠物
- en: How many children do you have
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你有多少孩子
- en: How many times have you been married
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你结过几次婚
- en: 'It would be very bad practice to copy paste (or, more properly said: duplicate)
    the validation logic in every place where we expect a numeric answer. This would
    violate the **DRY** (**Don''t Repeat Yourself**) principle, which states that
    you should never repeat the same piece of code more than once in your application.
    I feel the need to stress the importance of this principle: *you should never
    repeat the same piece of code more than once in your application* (got the irony?).'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们期望得到数字答案的每个地方复制粘贴（或者更准确地说：重复）验证逻辑是非常糟糕的做法。这将违反**DRY**（**不要重复自己**）原则，该原则指出，你永远不应该在应用程序中重复相同的代码片段超过一次。我需要强调这个原则的重要性：*你永远不应该在应用程序中重复相同的代码片段超过一次*（你感受到了讽刺吗？）。
- en: 'There are several reasons why repeating the same piece of logic can be very
    bad, the most important ones being:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 重复相同的逻辑可能有几个原因，其中最重要的包括：
- en: There could be a bug in the logic, and therefore, you would have to correct
    it in every place that logic is applied.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逻辑中可能存在错误，因此，你将不得不在每个应用该逻辑的地方进行纠正。
- en: You may want to amend the way you carry out the validation, and again you would
    have to change it in every place it is applied.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可能想要修改执行验证的方式，并且你将不得不在每个应用该逻辑的地方进行更改。
- en: You may forget to fix/amend a piece of logic because you missed it when searching
    for all its occurrences. This would leave wrong/inconsistent behavior in your
    application.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可能会忘记修复/修正一段逻辑，因为你错过了在搜索所有出现位置时找到它。这将在你的应用程序中留下错误/不一致的行为。
- en: Your code would be longer than needed, for no good reason.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的代码会比所需的更长，没有很好的理由。
- en: Python is a wonderful language and provides you with all the tools you need
    to apply all the coding best practices. For this particular example, we need to
    be able to reuse a piece of code. To be able to reuse a piece of code, we need
    to have a construct that will hold the code for us so that we can call that construct
    every time we need to repeat the logic inside it. That construct exists, and it's
    called **function**.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: Python 是一种奇妙的语言，为你提供了应用所有编码最佳实践所需的所有工具。对于这个特定的例子，我们需要能够重用一段代码。为了能够重用一段代码，我们需要一个构造函数来为我们保存代码，这样我们就可以在需要重复其中逻辑时调用该构造函数。这个构造函数存在，它被称为**函数**。
- en: I'm not going too deep into the specifics here, so please just remember that
    a function is a block of organized, reusable code which is used to perform a task.
    Functions can assume many forms and names, according to what kind of environment
    they belong to, but for now this is not important. We'll see the details when
    we are able to appreciate them, later on, in the book. Functions are the building
    blocks of modularity in your application, and they are almost indispensable (unless
    you're writing a super simple script, you'll use functions all the time). We'll
    explore functions in [Chapter 4](ch04.html "Chapter 4. Functions, the Building
    Blocks of Code"), *Functions, the Building Blocks of Code*.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里不会深入具体细节，所以请记住，函数是一块组织良好、可重用的代码块，用于执行任务。函数可以有多种形式和名称，根据它们所属的环境而定，但就目前而言，这并不重要。我们将在能够欣赏它们的时候，在书中的后面部分看到细节。函数是应用程序模块化的基石，它们几乎是不可或缺的（除非你正在编写一个非常简单的脚本，你将一直使用函数）。我们将在[第4章](ch04.html
    "第4章。函数，代码的构建块")中探讨函数，*函数，代码的构建块*。
- en: 'Python comes with a very extensive library, as I already said a few pages ago.
    Now, maybe it''s a good time to define what a library is: a **library** is a collection
    of functions and objects that provide functionalities that enrich the abilities
    of a language.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前几页所说，Python 拥有一个非常广泛的库。现在，也许定义什么是库是个好时机：**库**是一系列提供丰富语言能力的函数和对象的集合。
- en: For example, within Python's `math` library we can find a plethora of functions,
    one of which is the `factorial` function, which of course calculates the factorial
    of a number.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在 Python 的 `math` 库中，我们可以找到大量的函数，其中之一是 `factorial` 函数，它当然用于计算一个数的阶乘。
- en: Note
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'In mathematics, the **factorial** of a non-negative integer number *N*, denoted
    as *N!*, is defined as the product of all positive integers less than or equal
    to N. For example, the factorial of 5 is calculated as:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在数学中，非负整数 *N* 的**阶乘**，表示为 *N!*，定义为小于或等于 N 的所有正整数的乘积。例如，5 的阶乘计算如下：
- en: '[PRE11]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The factorial of `0` is `0! = 1`, to respect the convention for an empty product.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`0` 的阶乘是 `0! = 1`，以尊重空乘积的惯例。'
- en: So, if you wanted to use this function in your code, all you would have to do
    is to import it and call it with the right input values. Don't worry too much
    if input values and the concept of calling is not very clear for now, please just
    concentrate on the import part.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果你想在代码中使用这个函数，你所要做的就是导入它，并用正确的输入值调用它。现在如果输入值和调用的概念不是很清楚，请不要担心太多，请只关注导入部分。
- en: Note
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We use a library by importing what we need from it, and then we use it.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过从库中导入所需的内容来使用库，然后使用它。
- en: 'In Python, to calculate the factorial of number 5, we just need the following
    code:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，要计算数字 5 的阶乘，我们只需要以下代码：
- en: '[PRE12]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Whatever we type in the shell, if it has a printable representation, will be
    printed on the console for us (in this case, the result of the function call:
    120).'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我们在 shell 中输入什么，如果它有可打印的表示，都会被打印到控制台（在这种情况下，函数调用的结果：120）。
- en: So, let's go back to our example, the one with `core.py`, `run.py`, `util`,
    and so on.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们回到我们的例子，即包含 `core.py`、`run.py`、`util` 等的例子。
- en: In our example, the package `util` is our utility library. Our custom utility
    belt that holds all those reusable tools (that is, functions), which we need in
    our application. Some of them will deal with databases (`db.py`), some with the
    network (`network.py`), and some will perform mathematical calculations (`math.py`)
    that are outside the scope of Python's standard `math` library and therefore,
    we had to code them for ourselves.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，包`util`是我们的工具库。这是我们自定义的工具带，它包含了所有那些可重用的工具（即，函数），这些工具是我们应用中需要的。其中一些将处理数据库（`db.py`），一些处理网络（`network.py`），还有一些将执行数学计算（`math.py`），这些计算超出了Python标准`math`库的范围，因此，我们不得不自己编写这些代码。
- en: 'We will see in detail how to import functions and use them in their dedicated
    chapter. Let''s now talk about another very important concept: Python''s execution
    model.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在专门的章节中详细说明如何导入函数并使用它们。现在让我们谈谈另一个非常重要的概念：Python的执行模型。
- en: Python's execution model
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python的执行模型
- en: In this paragraph, I would like to introduce you to a few very important concepts,
    such as scope, names, and namespaces. You can read all about Python's execution
    model in the official Language reference, of course, but I would argue that it
    is quite technical and abstract, so let me give you a less formal explanation
    first.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个段落中，我想向你介绍几个非常重要的概念，比如作用域、名称和命名空间。当然，你可以在官方语言参考中阅读有关Python执行模型的全部内容，但我认为它相当技术性和抽象，所以让我先给你一个不那么正式的解释。
- en: Names and namespaces
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 名称和命名空间
- en: Say you are looking for a book, so you go to the library and ask someone for
    the book you want to fetch. They tell you something like "second floor, section
    X, row three". So you go up the stairs, look for section X, and so on.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你在找一本书，所以你去了图书馆，并请求某人帮你找到你想要的书。他们会告诉你类似“二楼，分区X，第三排”的信息。然后你上楼，寻找分区X，依此类推。
- en: It would be very different to enter a library where all the books are piled
    together in random order in one big room. No floors, no sections, no rows, no
    order. Fetching a book would be extremely hard.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 进入一个图书馆，所有的书都随机堆放在一个大房间里，没有楼层，没有分区，没有行列，没有秩序，要找一本书会非常困难。
- en: 'When we write code we have the same issue: we have to try and organize it so
    that it will be easy for someone who has no prior knowledge about it to find what
    they''re looking for. When software is structured correctly, it also promotes
    code reuse. On the other hand, disorganized software is more likely to expose
    scattered pieces of duplicated logic.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编写代码时，我们面临相同的问题：我们必须尽量组织代码，以便对没有相关知识的人更容易找到他们需要的东西。当软件结构正确时，它也促进了代码的重用。另一方面，无序的软件更有可能暴露出散乱的重复逻辑。
- en: 'First of all, let''s start with the book. We refer to a book by its title and
    in Python lingo, that would be a name. Python names are the closest abstraction
    to what other languages call variables. Names basically refer to objects and are
    introduced by name binding operations. Let''s make a quick example (notice that
    anything that follows a `#` is a comment):'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们从书开始。我们通过书名来引用一本书，在Python术语中，那将是名称。Python名称是其他语言所称为变量的最接近的抽象。名称基本上是指向对象，并且通过名称绑定操作引入。让我们做一个快速示例（注意，任何跟在`#`后面的都是注释）：
- en: '[PRE13]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We defined three objects in the preceding code (do you remember what are the
    three features every Python object has?):'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们定义了三个对象（你还记得每个Python对象都有哪三个特性吗？）：
- en: 'An integer number `n` (type: `int`, value: `3`)'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个整数`n`（类型：`int`，值：`3`）
- en: 'A string `address` (type: `str`, value: Sherlock Holmes'' address)'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个字符串`address`（类型：`str`，值：福尔摩斯的地址）
- en: 'A dictionary `employee` (type: `dict`, value: a dictionary which holds three
    key/value pairs)'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个字典`employee`（类型：`dict`，值：一个包含三个键/值对的字典）
- en: Don't worry, I know you're not supposed to know what a dictionary is. We'll
    see in the next chapter that it's the king of Python data structures.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 别担心，我知道你不应该知道什么是字典。我们将在下一章中看到，它是Python数据结构之王。
- en: Tip
  id: totrans-252
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Have you noticed that the prompt changed from `>>>` to `...` when I typed in
    the definition of employee? That's because the definition spans over multiple
    lines.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 你有没有注意到，当我输入员工定义时，提示符从`>>>`变成了`...`？这是因为定义跨越了多行。
- en: 'So, what are `n`, `address` and `employee`? They are **names**. Names that
    we can use to retrieve data within our code. They need to be kept somewhere so
    that whenever we need to retrieve those objects, we can use their names to fetch
    them. We need some space to hold them, hence: namespaces!'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，`n`、`address` 和 `employee` 是什么呢？它们是**名称**。我们可以使用这些名称在我们的代码中检索数据。它们需要被保存在某个地方，这样我们每次需要检索这些对象时，都可以使用它们的名称来获取它们。我们需要一些空间来保存它们，因此：命名空间！
- en: A **namespace** is therefore a mapping from names to objects. Examples are the
    set of built-in names (containing functions that are always accessible for free
    in any Python program), the global names in a module, and the local names in a
    function. Even the set of attributes of an object can be considered a namespace.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，**命名空间**是从名称到对象的映射。例如，内置名称的集合（包含在任何 Python 程序中始终免费可用的函数）、模块中的全局名称和函数中的局部名称。甚至一个对象的属性集合也可以被视为一个命名空间。
- en: 'The beauty of namespaces is that they allow you to define and organize your
    names with clarity, without overlapping or interference. For example, the namespace
    associated with that book we were looking for in the library can be used to import
    the book itself, like this:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间的美妙之处在于，它们允许你清晰地定义和组织你的名称，而不重叠或干扰。例如，与我们在图书馆中寻找的那本书相关的命名空间可以用来导入这本书本身，如下所示：
- en: '[PRE14]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We start from the `library` namespace, and by means of the dot (`.`) operator,
    we walk into that namespace. Within this namespace, we look for `second_floor`,
    and again we walk into it with the `.` operator. We then walk into `section_x`,
    and finally within the last namespace, `row_tree`, we find the name we were looking
    for: `book`.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从 `library` 命名空间开始，通过点（`.`）操作符进入该命名空间。在这个命名空间内，我们寻找 `second_floor`，然后再次使用点操作符进入它。然后我们进入
    `section_x`，最后在最后一个命名空间 `row_tree` 中，我们找到了我们寻找的名称：`book`。
- en: Walking through a namespace will be clearer when we'll be dealing with real
    code examples. For now, just keep in mind that namespaces are places where names
    are associated to objects.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们处理实际的代码示例时，遍历命名空间将更加清晰。现在，只需记住，命名空间是名称与对象关联的地方。
- en: 'There is another concept, which is closely related to that of a namespace,
    which I''d like to briefly talk about: the **scope**.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 另有一个概念，它与命名空间的概念密切相关，我想简要地谈谈：**作用域**。
- en: Scopes
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 作用域
- en: According to Python's documentation, *a scope is a textual region of a Python
    program, where a namespace is directly accessible*. Directly accessible means
    that when you're looking for an unqualified reference to a name, Python tries
    to find it in the namespace.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 Python 的文档，*作用域是 Python 程序中的一个文本区域，其中命名空间可以直接访问*。直接访问意味着当你寻找一个无限定名称的引用时，Python
    会尝试在命名空间中查找它。
- en: 'Scopes are determined statically, but actually during runtime they are used
    dynamically. This means that by inspecting the source code you can tell what the
    scope of an object is, but this doesn''t prevent the software to alter that during
    runtime. There are four different scopes that Python makes accessible (not necessarily
    all of them present at the same time, of course):'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 作用域是静态确定的，但实际上在运行时它们是动态使用的。这意味着通过检查源代码，你可以知道一个对象的作用域，但这并不能阻止软件在运行时改变它。Python
    提供了四种不同的作用域可供访问（当然，不一定同时都存在）：
- en: The **local** scope, which is the innermost one and contains the local names.
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**局部**作用域，这是最内层的作用域，包含局部名称。'
- en: The **enclosing** scope, that is, the scope of any enclosing function. It contains
    non-local names and also non-global names.
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**包含**作用域，即任何包含函数的作用域。它包含非局部名称和非全局名称。'
- en: The **global** scope contains the global names.
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**全局**作用域包含全局名称。'
- en: The **built-in** scope contains the built-in names. Python comes with a set
    of functions that you can use in a off-the-shelf fashion, such as `print`, `all`,
    `abs`, and so on. They live in the built-in scope.
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内置**作用域包含内置名称。Python 提供了一组你可以直接使用的函数，例如 `print`、`all`、`abs` 等。它们位于内置作用域中。'
- en: 'The rule is the following: when we refer to a name, Python starts looking for
    it in the current namespace. If the name is not found, Python continues the search
    to the enclosing scope and this continue until the built-in scope is searched.
    If a name hasn''t been found after searching the built-in scope, then Python raises
    a `NameError` **exception**, which basically means that the name hasn''t been
    defined (you saw this in the preceding example).'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 规则是这样的：当我们引用一个名称时，Python 从当前命名空间开始查找。如果找不到名称，Python 继续在封装作用域中搜索，并一直继续到内置作用域被搜索。如果在搜索内置作用域之后仍未找到名称，那么
    Python 会引发一个 `NameError` **异常**，这基本上意味着该名称尚未定义（你在前面的例子中看到了这个）。
- en: 'The order in which the namespaces are scanned when looking for a name is therefore:
    **local**, **enclosing**, **global**, **built-in** (**LEGB**).'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在查找名称时，命名空间被扫描的顺序是：**局部**、**封装**、**全局**、**内置**（**LEGB**）。
- en: This is all very theoretical, so let's see an example. In order to show you
    Local and Enclosing namespaces, I will have to define a few functions. Don't worry
    if you are not familiar with their syntax for the moment, we'll study functions
    in [Chapter 4](ch04.html "Chapter 4. Functions, the Building Blocks of Code"),
    *Functions, the Building Blocks of Code*. Just remember that in the following
    code, when you see `def`, it means I'm defining a function.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切都是非常理论性的，所以让我们看看一个例子。为了向您展示局部和封装命名空间，我必须定义几个函数。如果你目前不熟悉它们的语法，请不要担心，我们将在[第
    4 章](ch04.html "第 4 章。函数，代码的构建块")*函数，代码的构建块*中学习函数。只需记住，在下面的代码中，当你看到 `def` 时，这意味着我正在定义一个函数。
- en: '`scopes1.py`'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '`scopes1.py`'
- en: '[PRE15]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In the preceding example, we define the same name `m`, both in the global scope
    and in the local one (the one defined by the function local). When we execute
    this program with the following command (have you activated your virtualenv?):'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们在全局作用域和局部作用域（由 `local` 函数定义的）中定义了同一个名称 `m`。当我们使用以下命令执行此程序时（你激活了虚拟环境吗？）：
- en: '[PRE16]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We see two numbers printed on the console: `5` and `7`.'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在控制台看到打印出两个数字：`5` 和 `7`。
- en: 'What happens is that the Python interpreter parses the file, top to bottom.
    First, it finds a couple of comment lines, which are skipped, then it parses the
    definition of the function `local`. When called, this function does two things:
    it sets up a name to an object representing number 7 and prints it. The Python
    interpreter keeps going and it finds another name binding. This time the binding
    happens in the global scope and the value is 5\. The next line is a call to the
    `print` function, which is executed (and so we get the first value printed on
    the console: `5`).'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 发生的事情是 Python 解释器从上到下解析文件。首先，它找到几行注释，这些会被跳过，然后解析函数 `local` 的定义。当调用这个函数时，它会做两件事：将一个代表数字
    7 的对象赋值给一个名称并打印它。Python 解释器继续执行并找到另一个名称绑定。这次绑定发生在全局作用域中，值为 5。下一行是调用 `print` 函数，该函数被执行（因此我们在控制台上看到了第一个打印的值：`5`）。
- en: After this, there is a call to the function `local`. At this point, Python executes
    the function, so at this time, the binding `m = 7` happens and it's printed.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，有一个对函数 `local` 的调用。在这个时候，Python 执行该函数，因此此时发生绑定 `m = 7` 并打印出来。
- en: One very important thing to notice is that the part of the code that belongs
    to the definition of the function local is indented by four spaces on the right.
    Python in fact defines scopes by indenting the code. You walk into a scope by
    indenting and walk out of it by unindenting. Some coders use two spaces, others
    three, but the suggested number of spaces to use is four. It's a good measure
    to maximize readability. We'll talk more about all the conventions you should
    embrace when writing Python code later.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个非常重要的事情需要注意，那就是属于函数 `local` 定义的部分代码在右侧缩进了四个空格。实际上，Python 通过缩进来定义作用域。你通过缩进来进入一个作用域，通过取消缩进来退出它。一些程序员使用两个空格，另一些使用三个空格，但建议使用的空格数是四个。这是一个很好的做法，可以最大化可读性。我们将在稍后更多地讨论你在编写
    Python 代码时应遵循的所有约定。
- en: 'What would happen if we removed that `m = 7` line? Remember the LEGB rule.
    Python would start looking for `m` in the local scope (function `local`), and,
    not finding it, it would go to the next enclosing scope. The next one in this
    case is the global one because there is no enclosing function wrapped around `local`.
    Therefore, we would see two number `5` printed on the console. Let''s actually
    see how the code would look like:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们删除那行 `m = 7` 会发生什么？记住LEGB规则。Python将开始在局部作用域（函数 `local`）中查找 `m`，如果没有找到，它将转到下一个封装作用域。在这种情况下，下一个是全局作用域，因为没有封装函数围绕
    `local`。因此，我们将在控制台上看到两个数字 `5` 被打印出来。让我们实际看看代码会是什么样子：
- en: '`scopes2.py`'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '`scopes2.py`'
- en: '[PRE17]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Running `scopes2.py` will print this:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `scopes2.py` 将会打印以下内容：
- en: '[PRE18]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As expected, Python prints `m` the first time, then when the function `local`
    is called, `m` isn't found in its scope, so Python looks for it following the
    LEGB chain until `m` is found in the global scope.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期，Python第一次打印 `m`，然后在调用 `local` 函数时，`m` 在其作用域中未找到，因此Python会沿着LEGB链查找，直到在全局作用域中找到
    `m`。
- en: 'Let''s see an example with an extra layer, the enclosing scope:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个额外的封装作用域的例子来看一下：
- en: '`scopes3.py`'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '`scopes3.py`'
- en: '[PRE19]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Running `scopes3.py` will print on the console:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `scopes3.py` 将会在控制台上打印：
- en: '[PRE20]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As you can see, the `print` instruction from the function `local` is referring
    to `m` as before. `m` is still not defined within the function itself, so Python
    starts walking scopes following the LEGB order. This time `m` is found in the
    enclosing scope.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，函数 `local` 中的 `print` 指令与之前一样引用 `m`。`m` 仍然在函数内部未定义，因此Python开始按照LEGB顺序遍历作用域。这次
    `m` 在封装作用域中被找到。
- en: Don't worry if this is still not perfectly clear for now. It will come to you
    as we go through the examples in the book. The *Classes* section of the Python
    tutorial (official documentation) has an interesting paragraph about scopes and
    namespaces. Make sure you read it at some point if you wish for a deeper understanding
    of the subject.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 如果现在这还不完全清楚，请不要担心。随着我们在书中通过示例进行学习，这会逐渐变得清晰。Python教程（官方文档）的 *Classes* 部分有一个关于作用域和命名空间的有趣段落。如果您希望对主题有更深入的理解，请确保在某个时候阅读它。
- en: Before we finish off this chapter, I would like to talk a bit more about objects.
    After all, basically everything in Python is an object, so I think they deserve
    a bit more attention.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们完成本章之前，我想再谈谈对象。毕竟，基本上Python中的所有东西都是对象，所以我认为它们值得更多的关注。
- en: Tip
  id: totrans-293
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Downloading the example code**'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files from your account at [http://www.packtpub.com](http://www.packtpub.com)
    for all the Packt Publishing books you have purchased. If you purchased this book
    elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从[http://www.packtpub.com](http://www.packtpub.com)下载您所购买的Packt Publishing书籍的示例代码文件。如果您在其他地方购买了这本书，您可以访问[http://www.packtpub.com/support](http://www.packtpub.com/support)并注册，以便将文件直接通过电子邮件发送给您。
- en: Object and classes
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象和类
- en: When I introduced objects in the *A proper introduction* section, I said that
    we use them to represent real-life objects. For example, we sell goods of any
    kind on the Web nowadays and we need to be able to handle, store, and represent
    them properly. But objects are actually so much more than that. Most of what you
    will ever do, in Python, has to do with manipulating objects.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *A proper introduction* 部分介绍对象时，我说过我们使用它们来表示现实生活中的对象。例如，我们现在在网上销售各种商品，我们需要能够正确地处理、存储和表示它们。但对象实际上远不止于此。您在Python中将要做的几乎所有事情都与操作对象有关。
- en: So, without going too much into detail (we'll do that in [Chapter 6](ch06.html
    "Chapter 6. Advanced Concepts – OOP, Decorators, and Iterators"), *Advanced Concepts
    – OOP, Decorators, and Iterators*), I want to give you the *in a nutshell* kind
    of explanation about classes and objects.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在不深入细节的情况下（我们将在[第6章](ch06.html "第6章。高级概念 – 面向对象编程、装饰器和迭代器")中这样做，*高级概念 – 面向对象编程、装饰器和迭代器*），我想给您一个*简而言之*的解释关于类和对象。
- en: 'We''ve already seen that objects are Python''s abstraction for data. In fact,
    everything in Python is an object. Numbers, strings (data structures that hold
    text), containers, collections, even functions. You can think of them as if they
    were boxes with at least three features: an ID (unique), a type, and a value.'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，对象是Python对数据的抽象。实际上，Python中的所有东西都是一个对象。数字、字符串（包含文本的数据结构）、容器、集合，甚至函数。您可以将它们想象成具有至少三个特征的盒子：一个ID（唯一的）、一个类型和一个值。
- en: 'But how do they come to life? How do we create them? How to we write our own
    custom objects? The answer lies in one simple word: classes.'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 但它们是如何变得有生命的呢？我们如何创建它们？我们如何编写自己的自定义对象？答案在于一个简单的词：类。
- en: 'Objects are, in fact, instances of classes. The beauty of Python is that classes
    are objects themselves, but let''s not go down this road. It leads to one of the
    most advanced concepts of this language: **metaclasses**. We''ll talk very briefly
    about them in [Chapter 6](ch06.html "Chapter 6. Advanced Concepts – OOP, Decorators,
    and Iterators"), *Advanced Concepts – OOP, Decorators, and Iterators*. For now,
    the best way for you to get the difference between classes and objects, is by
    means of an example.'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，对象是类的实例。Python的美丽之处在于类本身也是对象，但让我们不要走这条路。这会引导我们进入这门语言最先进的概念之一：**元类**。我们将在[第6章](ch06.html
    "第6章。高级概念 – 面向对象编程、装饰器和迭代器")中非常简要地讨论它们，*高级概念 – 面向对象编程、装饰器和迭代器*。现在，你了解类和对象之间区别的最好方式是通过一个例子。
- en: Say a friend tells you "I bought a new bike!" You immediately understand what
    she's talking about. Have you seen the bike? No. Do you know what color it is?
    Nope. The brand? Nope. Do you know anything about it? Nope. But at the same time,
    you know everything you need in order to understand what your friend meant when
    she told you she bought a new bike. You know that a bike has two wheels attached
    to a frame, a saddle, pedals, handlebars, brakes, and so on. In other words, even
    if you haven't seen the bike itself, you know the concept of bike. An abstract
    set of features and characteristics that together form something called bike.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 假设一个朋友告诉你“我买了一辆新自行车！”你立刻就明白她在说什么。你见过那辆自行车吗？没有。你知道它的颜色吗？不知道。品牌？不知道。你知道关于它的任何信息吗？不知道。但与此同时，你知道你需要知道的一切，以便理解当你的朋友告诉你她买了一辆新自行车时她的意思。你知道自行车有两个轮子连接到车架，有座椅、踏板、把手、刹车等等。换句话说，即使你没有见过那辆自行车本身，你也知道自行车的概念。一组抽象的特征和特性，共同构成了所谓的自行车。
- en: In computer programming, that is called a **class**. It's that simple. Classes
    are used to create objects. In fact, objects are said to be **instances of classes**.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机编程中，这被称为**类**。就这么简单。类用于创建对象。实际上，对象被认为是**类的实例**。
- en: In other words, we all know what a bike is, we know the class. But then I have
    my own bike, which is an instance of the class bike. And my bike is an object
    with its own characteristics and methods. You have your own bike. Same class,
    but different instance. Every bike ever created in the world is an instance of
    the bike class.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，我们都知道什么是自行车，我们知道类。但然后我有一辆自己的自行车，它是类自行车的实例。我的自行车是一个具有自己特性和方法的对象。你也有自己的自行车。同一个类，但不同的实例。世界上每辆制造的自行车都是自行车类的实例。
- en: 'Let''s see an example. We will write a class that defines a bike and then we''ll
    create two bikes, one red and one blue. I''ll keep the code very simple, but don''t
    fret if you don''t understand everything about it; all you need to care about
    at this moment is to understand the difference between class and object (or instance
    of a class):'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个例子。我们将编写一个定义自行车的类，然后我们将创建两辆自行车，一辆红色一辆蓝色。我会保持代码非常简单，但如果你不理解其中的所有内容，不要担心；你现在需要关心的只是理解类和对象（或类的实例）之间的区别：
- en: '`bike.py`'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '`bike.py`'
- en: '[PRE21]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Tip
  id: totrans-308
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: I hope by now I don't need to tell you to run the file every time, right? The
    filename is indicated in the first line of the code block. Just run `$ python
    filename`, and you'll be fine.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我不需要告诉你每次都要运行文件，对吧？文件名在代码块的第一行中指示。只需运行`$ python filename`，你就会没事的。
- en: So many interesting things to notice here. First things first; the definition
    of a class happens with the `class` statement (highlighted in the code). Whatever
    code comes after the `class` statement, and is indented, is called the body of
    the class. In our case, the last line that belongs to the class definition is
    the `print("Braking!")` one.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有很多有趣的事情需要注意。首先，类的定义是通过`class`语句来完成的（在代码中突出显示）。`class`语句之后，并且缩进的任何代码，被称为类的主体。在我们的例子中，属于类定义的最后一行是`print("Braking!")`这一行。
- en: After having defined the class we're ready to create instances. You can see
    that the class body hosts the definition of two methods. A method is basically
    (and simplistically) a function that belongs to a class.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了类之后，我们就准备好创建实例了。你可以看到类体中包含了两个方法的定义。一个方法基本上（并且简单地说）是一个属于类的函数。
- en: The first method, `__init__` is an **initializer**. It uses some Python magic
    to set up the objects with the values we pass when we create it.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法，`__init__`是一个**初始化器**。它使用一些Python魔法来设置我们在创建时传递的值。
- en: Note
  id: totrans-313
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Every method that has leading and trailing double underscore, in Python, is
    called **magic method**. Magic methods are used by Python for a multitude of different
    purposes, hence it's never a good idea to name a custom method using two leading
    and trailing underscores. This naming convention is best left to Python.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，每个以前后双下划线开头和结尾的方法都称为**魔法方法**。Python用于多种不同的目的，因此使用两个前后下划线来命名自定义方法从来不是一个好主意。这种命名约定最好留给Python。
- en: The other method we defined, `brake`, is just an example of an additional method
    that we could call if we wanted to brake the bike. It contains just a `print`
    statement, of course, it's an example.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义的另一种方法，`brake`，只是如果我们想要刹车自行车时可以调用的额外方法的例子。它只包含一个`print`语句，当然，它只是一个例子。
- en: We created two bikes then. One has red color and a carbon fiber frame, and the
    other one has blue color and steel frame. We pass those values upon creation.
    After creation, we print out the color property and frame type of the red bike,
    and the frame type of the blue one just as an example. We also call the `brake`
    method of the `red_bike`.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当时创建了两种自行车。一种红色，碳纤维车架，另一种蓝色，钢制车架。我们在创建时传递了这些值。创建后，我们打印出红色自行车的颜色属性和车架类型，以及蓝色自行车的车架类型，仅作为一个例子。我们还调用了`red_bike`的`brake`方法。
- en: One last thing to notice. You remember I told you that the set of attributes
    of an object is considered to be a namespace? I hope it's clearer now, what I
    meant. You see that by getting to the `frame_type` property through different
    namespaces (`red_bike`, `blue_bike`) we obtain different values. No overlapping,
    no confusion.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要注意的一点。你还记得我告诉你，一个对象的属性集被认为是命名空间吗？我希望现在更清楚了我所指的意思。你看到通过不同的命名空间（`red_bike`，`blue_bike`）获取到`frame_type`属性，我们得到了不同的值。没有重叠，没有混淆。
- en: The dot (`.`) operator is of course the means we use to walk into a namespace,
    in the case of objects as well.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 点（`.`）操作符当然是我们用来进入命名空间的方式，在对象的情况下也是如此。
- en: Guidelines on how to write good code
  id: totrans-319
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于如何编写良好代码的指南
- en: 'Writing good code is not as easy as it seems. As I already said before, good
    code exposes a long list of qualities that is quite hard to put together. Writing
    good code is, to some extent, an art. Regardless of where on the path you will
    be happy to settle, there is something that you can embrace which will make your
    code instantly better: **PEP8**.'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 编写良好的代码并不像看起来那么简单。正如我之前所说，良好的代码暴露出一系列相当难以组合的品质。在某种程度上，编写良好的代码是一种艺术。无论你会在哪个阶段感到满意，总有一些你可以接受的东西，这将使你的代码立即变得更好：**PEP8**。
- en: 'According to Wikipedia:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 根据维基百科：
- en: '*"Python''s development is conducted largely through the Python Enhancement
    Proposal (PEP) process. The PEP process is the primary mechanism for proposing
    major new features, for collecting community input on an issue, and for documenting
    the design decisions that have gone into Python."*'
  id: totrans-322
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*"Python的开发主要通过各种Python增强提案（PEP）流程进行。PEP流程是提出重大新功能、收集社区对问题的反馈以及记录Python设计决策的主要机制。"*'
- en: 'Among all the PEPs, probably the most famous one is PEP8\. It lays out a simple
    but effective set of guidelines to define Python aesthetic so that we write beautiful
    Python code. If you take one suggestion out of this chapter, please let it be
    this: use it. Embrace it. You will thank me later.'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有PEP中，可能最著名的是PEP8。它概述了一套简单但有效的指南，以定义Python美学，以便我们编写漂亮的Python代码。如果你从这个章节中取出一项建议，请让它成为这个：使用它。接受它。你以后会感谢我的。
- en: Coding today is no longer a check-in/check-out business. Rather, it's more of
    a social effort. Several developers collaborate to a piece of code through tools
    like git and mercurial, and the result is code that is fathered by many different
    hands.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 今天的编码已经不再是简单的签到/签退业务。相反，它更像是一项社会性的努力。几个开发者通过像git和mercurial这样的工具共同协作编写代码，结果是许多不同人手的产物。
- en: Note
  id: totrans-325
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Git and Mercurial are probably the most used distributed revision control systems
    today. They are essential tools designed to help teams of developers collaborate
    on the same software.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: Git和Mercurial可能是今天最常用的分布式版本控制系统。它们是专为帮助开发者团队在同一软件上协作而设计的必要工具。
- en: These days, more than ever, we need to have a consistent way of writing code,
    so that readability is maximized. When all developers of a company abide with
    PEP8, it's not uncommon for any of them landing on a piece of code to think they
    wrote it themselves. It actually happens to me all the time (I always forget the
    code I write).
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 这些天，比以往任何时候都更需要有一种一致的代码编写方式，以便最大限度地提高可读性。当一家公司的所有开发人员都遵守PEP8时，任何一个人遇到一段代码时都会认为他们自己写了它。这实际上经常发生在我身上（我总是忘记我写的代码）。
- en: 'This has a tremendous advantage: when you read code that you could have written
    yourself, you read it easily. Without a convention, every coder would structure
    the code the way they like most, or simply the way they were taught or are used
    to, and this would mean having to interpret every line according to someone else''s
    style. It would mean having to lose much more time just trying to understand it.
    Thanks to PEP8, we can avoid this. I''m such a fan of it that I won''t sign off
    a code review if the code doesn''t respect it. So please take the time to study
    it, it''s very important.'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 这带来了巨大的优势：当你阅读你自己可能编写过的代码时，你会很容易地阅读它。如果没有约定，每个程序员都会以他们最喜欢的方式结构化代码，或者简单地按照他们被教导或习惯的方式，这意味着必须根据别人的风格来解释每一行。这意味着需要花费更多的时间仅仅是为了理解它。多亏了PEP8，我们可以避免这种情况。我是它的忠实粉丝，如果代码不遵守它，我不会签署代码审查。所以请花时间学习它，它非常重要。
- en: In the examples of this book, I will try to respect it as much as I can. Unfortunately,
    I don't have the luxury of 79 characters (which is the maximum line length suggested
    by PEP*), and I will have to cut down on blank lines and other things, but I promise
    you I'll try to layout my code so that it's as readable as possible.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的示例中，我将尽可能地尊重它。不幸的是，我没有79个字符的奢侈（这是PEP建议的最大行长度），我必须减少空白行和其他东西，但我向你保证，我会尽量布局我的代码，使其尽可能易于阅读。
- en: The Python culture
  id: totrans-330
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python文化
- en: Python has been adopted widely in all coding industries. It's used by many different
    companies for many different purposes, and it's also used in education (it's an
    excellent language for that purpose, because of its many qualities and the fact
    that it's easy to learn).
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: Python在所有编码行业中都得到了广泛的应用。许多不同的公司出于许多不同的目的使用它，它也被用于教育（它是一个极好的语言，因为它的许多质量和易于学习的特点）。
- en: One of the reasons Python is so popular today is that the community around it
    is vast, vibrant, and full of brilliant people. Many events are organized all
    over the world, mostly either around Python or its main web framework, Django.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: Python之所以今天如此受欢迎，其中一个原因是围绕它的社区庞大、充满活力，并且充满了杰出的人。世界各地组织了许多活动，大多数活动都是围绕Python或其主要的Web框架Django进行的。
- en: Python is open, and very often so are the minds of those who embrace it. Check
    out the community page on the Python website for more information and get involved!
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: Python是开放的，而且那些接受它的人的大脑通常也是开放的。查看Python网站上的社区页面以获取更多信息并参与其中！
- en: There is another aspect to Python which revolves around the notion of being
    **Pythonic**. It has to do with the fact that Python allows you to use some idioms
    that aren't found elsewhere, at least not in the same form or easiness of use
    (I feel quite claustrophobic when I have to code in a language which is not Python
    now).
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: Python还有一个方面是围绕着“Pythonic”这一概念。这与Python允许你使用一些在其他地方找不到的习语有关，至少不是以相同的形式或易用性（我现在不得不在非Python语言中编码时，感觉非常压抑）。
- en: Anyway, over the years, this concept of being Pythonic has emerged and, the
    way I understand it, is something along the lines of *doing things the way they
    are supposed to be done in Python.*
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，多年来，这种“Pythonic”的概念已经出现，按照我的理解，它大致是按照“以Python应该被完成的方式做事”这一思路。
- en: 'To help you understand a little bit more about Python''s culture and about
    being Pythonic, I will show you the *Zen of Python*. A lovely Easter egg that
    is very popular. Open up a Python console and type `import this`. What follows
    is the result of this line:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助你更好地了解Python的文化和“Pythonic”的概念，我将向你展示“Python的禅意”。一个非常受欢迎的可爱彩蛋。打开Python控制台并输入`import
    this`。以下是该行代码的结果：
- en: '[PRE22]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: There are two levels of reading here. One is to consider it as a set of guidelines
    that have been put down in a fun way. The other one is to keep it in mind, and
    maybe read it once in a while, trying to understand how it refers to something
    deeper. Some Python characteristics that you will have to understand deeply in
    order to write Python the way it's supposed to be written. Start with the fun
    level, and then dig deeper. Always dig deeper.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两种阅读层次。一种是将其视为一套以有趣方式写下的指南。另一种是记住它，也许偶尔读一读，试图理解它如何引用更深层次的内容。一些你必须深入理解的Python特性，以便以正确的方式编写Python。从有趣层次开始，然后深入挖掘。总是深入挖掘。
- en: A note on the IDEs
  id: totrans-339
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于IDEs的注意事项
- en: Just a few words about **Integrated Development Environments** (**IDEs**). To
    follow the examples in this book you don't need one, any text editor will do fine.
    If you want to have more advanced features such as syntax coloring and auto completion,
    you will have to fetch yourself an IDE. You can find a comprehensive list of open
    source IDEs (just Google "python ides") on the Python website. I personally use
    Sublime Text editor. It's free to try out and it costs just a few dollars. I have
    tried many IDEs in my life, but this is the one that makes me most productive.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 简单地说几句关于**集成开发环境**（**IDEs**）的。为了跟随这本书中的示例，你不需要一个IDE，任何文本编辑器都行。如果你想拥有更高级的功能，如语法高亮和自动完成，你必须自己获取一个IDE。你可以在Python网站上找到一个开源IDE的完整列表（只需Google“python
    ides”）。我个人使用Sublime Text编辑器。它免费试用，只需几美元。我一生中尝试过许多IDE，但这是让我最有效率的一个。
- en: 'Two extremely important pieces of advice:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 两条极其重要的建议：
- en: Whatever IDE you will chose to use, try to learn it well so that you can exploit
    its strengths, but *don't depend on it*. Exercise yourself to work with VIM (or
    any other text editor) once in a while, learn to be able to do some work on any
    platform, with any set of tools.
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无论你将选择什么IDE，都要努力学好它，以便你能利用它的优势，但*不要依赖它*。偶尔练习使用VIM（或任何其他文本编辑器），学会在任何平台上使用任何一组工具做一些工作。
- en: Whatever text editor/IDE you will use, when it comes to writing Python, *indentation
    is four spaces*. Don't use tabs, don't mix them with spaces. Use four spaces,
    not two, not three, not five. Just use four. The whole world works like that,
    and you don't want to become an outcast because you were fond of the three-space
    layout.
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无论你将使用什么文本编辑器/IDE，当涉及到编写Python时，*缩进应该是四个空格*。不要使用制表符，也不要将它们与空格混合。使用四个空格，不要用两个、三个或五个。只需使用四个。全世界都是这样做的，你也不想因为喜欢三个空格布局而成为局外人。
- en: Summary
  id: totrans-344
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we started to explore the world of programming and that of
    Python. We've barely scratched the surface, just a little, touching concepts that
    will be discussed later on in the book in greater detail.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们开始探索编程和Python的世界。我们只是刚刚触及表面，只是触及一下将在书中更详细讨论的概念。
- en: We talked about Python's main features, who is using it and for what, and what
    are the different ways in which we can write a Python program.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了Python的主要特性，谁在使用它以及为什么，以及我们可以用不同的方式编写Python程序。
- en: In the last part of the chapter, we flew over the fundamental notions of namespace,
    scope, class, and object. We also saw how Python code can be organized using modules
    and packages.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后部分，我们飞越了命名空间、作用域、类和对象的基本概念。我们还看到了如何使用模块和包来组织Python代码。
- en: On a practical level, we learned how to install Python on our system, how to
    make sure we have the tools we need, pip and virtualenv, and we also created and
    activated our first virtual environment. This will allow us to work in a self-contained
    environment without the risk of compromising the Python system installation.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际层面上，我们学习了如何在我们的系统上安装Python，如何确保我们有需要的工具，pip和virtualenv，我们还创建并激活了我们的第一个虚拟环境。这将使我们能够在不危及Python系统安装的情况下在一个自包含的环境中工作。
- en: Now you're ready to start this journey with me. All you need is enthusiasm,
    an activated virtual environment, this book, your fingers, and some coffee.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你准备好和我一起开始这段旅程了。你需要的是热情、一个激活的虚拟环境、这本书、你的手指和一些咖啡。
- en: Try to follow the examples, I'll keep them simple and short. If you put them
    under your fingertips, you will retain them much better than if you just read
    them.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 尽量跟随示例，我会让它们简单而简短。如果你能将它们放在指尖下，你将比仅仅阅读它们更好地保留它们。
- en: In the next chapter, we will explore Python's rich set of built-in data types.
    There's much to cover and much to learn!
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨Python丰富的内置数据类型。有很多内容要介绍，也有很多东西要学习！
