- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating Menus with Menu and Tkinter Dialogs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As an application grows in functionality, it becomes increasingly counterproductive
    to cram all its functions and inputs into a single form. Instead, we will need
    to organize access to features, information, and controls in a way that keeps
    them available without cluttering up the visual presentation. GUI toolkits like
    Tkinter offer us a couple of tools to help deal with this. First, the **menu system**,
    typically located at the top of the application window (or, on some platforms,
    in a global desktop menu), can be used to organize application functions in a
    condensed hierarchy. Second, **dialog windows**, often referred to as **dialog
    boxes**, provide a quick means of displaying temporary windows containing information,
    errors, or basic forms.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to explore the use and best practices of menus
    and dialog boxes in Tkinter through the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: In *Solving problems in our application*, we'll analyze some reported problems
    with our application and design a solution involving menus and dialog boxes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In *Implementing Tkinter dialogs*, we'll explore Tkinter's dialog classes and
    how to use them to implement common application functionality.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In *Designing the application menu*, we'll organize our application's features
    into a main menu system using Tkinter's `Menu` widget.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's begin by seeing what improvements our application needs.
  prefs: []
  type: TYPE_NORMAL
- en: Solving problems in our application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Although everyone is happy with your application so far, your boss, after discussion
    with the staff, has brought you this set of problems that need to be addressed:'
  prefs: []
  type: TYPE_NORMAL
- en: The hard-coded filename is a problem. Occasionally the data entry staff aren't
    able to get to a form until the following day; in this situation, they need to
    be able to manually enter the filename that they'd like to append the data to.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also, the data entry staff have mixed feelings about the auto-filling features
    in the form. Some find it very helpful, but others would like auto-fill to be
    partially or completely disabled.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some users have a hard time noticing the status bar text at the bottom, and
    would like the application to be more assertive when it fails to save a data record
    due to field errors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, the lab is bringing in some interns to work in the labs, and the issue
    of data security has been raised. IT has suggested a simple login requirement
    would be advisable. It doesn't have to have high security, just enough to "keep
    the honest person honest."
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Planning solutions to the issues
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It''s clear you need to implement a way to enter login credentials, select
    a save file name, and toggle the auto-populate features of the form. You also
    need to make the status text more noticeable. First, you consider just adding
    controls to the main application for these features and increasing the size of
    the status text. You make a quick mock-up that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17578_07_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.1: Our first attempt at adding the new features: three Entry widgets
    for login data and filename, and two Checkbutton widgets for the settings'
  prefs: []
  type: TYPE_NORMAL
- en: It's immediately evident that this is not a great design, and certainly not
    one that will accommodate growth. Your users don't want to have to type a file
    path and filename blindly into the box, nor do they need the extra login fields
    and check boxes cluttering up the user interface. Making the status font larger
    seems like a good idea, until you realize that the form is now so long it will
    likely just get pushed off the bottom of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thinking through other GUI applications, you realize that these features are
    typically handled by dialog windows, usually activated from menu options. Taking
    menus and dialogs into consideration, you plan the following solutions to the
    problems:'
  prefs: []
  type: TYPE_NORMAL
- en: A **file dialog**, activated from a menu system, can be used to select the file
    that the data will be saved to.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **settings menu** in our menu system will handle activating or disabling auto-fill.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An **error dialog** will be used to display problematic status messages more
    assertively.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **login dialog** can be used to enter login information.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before we can code this solution, we'll need to learn more about dialogs in
    Tkinter.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing Tkinter dialogs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Tkinter contains a number of submodules that provide ready-made dialog windows
    for different situations. These include:'
  prefs: []
  type: TYPE_NORMAL
- en: '`messagebox`, for displaying simple messages and warnings'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`filedialog`, for prompting the user for a file or folder path'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`simpledialog`, for requesting string, integer, or float values from a user'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, we're going to explore these dialogs and use them to solve
    some of the problems with our application.
  prefs: []
  type: TYPE_NORMAL
- en: Error dialogs with the Tkinter messagebox
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The best way to display simple dialog boxes in Tkinter is by using the `tkinter.messagebox`
    module, which provides a variety of information-display dialog types.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since it is a submodule, we need to explicitly import it before we can use
    it, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Rather than having a lot of widget classes that we create instances of, the
    `messagebox` module provides a selection of **convenience functions** for making
    use of its various dialog types. When executed, each function displays a different
    combination of buttons and a preset icon, along with a message and detail text
    that you specify. When the user clicks a button in the dialog or closes it, the
    function will return a Boolean or string value depending on which button was clicked.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table shows some of the `messagebox` module''s functions with
    their icons and return values:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Function | Icon | Button text/Return value |'
  prefs: []
  type: TYPE_TB
- en: '| `askokcancel()` | Question | OK (`True`), Cancel (`False`) |'
  prefs: []
  type: TYPE_TB
- en: '| `askretrycancel()` | Warning | Retry (`True`), Cancel (`False`) |'
  prefs: []
  type: TYPE_TB
- en: '| `askyesno()` | Question | Yes (`True`), No (`False`) |'
  prefs: []
  type: TYPE_TB
- en: '| `askyesnocancel()` | Question | Yes (`True`), No (`False`), Cancel (`None`)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `showerror()` | Error | OK (`ok`) |'
  prefs: []
  type: TYPE_TB
- en: '| `showinfo()` | Information | OK (`ok`) |'
  prefs: []
  type: TYPE_TB
- en: '| `showwarning()` | Warning | OK (`ok`) |'
  prefs: []
  type: TYPE_TB
- en: 'Each `message``box` function accepts this same set of arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '`title` sets the title of the window, which is displayed in the title bar and/or
    task bar in your desktop environment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`message` sets the main message of the dialog. It''s usually in a heading font
    and should be kept fairly short.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`detail` sets the body text of the dialog, which is usually displayed in the
    standard window font.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A basic call to `messagebox.showinfo()` would look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In Windows 10, it results in a dialog box that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A showinfo() message box on Windows 10](img/B17578_07_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.2: A showinfo() message box on Windows 10'
  prefs: []
  type: TYPE_NORMAL
- en: 'On macOS, you''d see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17578_07_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.3: A showinfo() message box on macOS'
  prefs: []
  type: TYPE_NORMAL
- en: 'On Ubuntu Linux, the dialog looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17578_07_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.4: A showinfo() message box on Ubuntu Linux'
  prefs: []
  type: TYPE_NORMAL
- en: Note that Tkinter `messagebox` dialog boxes are **modal**, which means that
    the program execution pauses and the rest of the UI is unresponsive while the
    dialog box is open. There is no way to change this, so only use them in situations
    where it's acceptable for the program to pause execution while the box is open.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a small example script to show the use of the `messagebox` functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This creates a dialog with **Yes** and **No** buttons. If the user clicks **No**,
    the function returns `False` and the application exits. In the case our user wants
    to see more boxes, the program continues and displays an information box.
  prefs: []
  type: TYPE_NORMAL
- en: Showing error dialogs in ABQ Data Entry
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that you understand how to use `messagebox`, error dialogs should be easy
    to implement in our application. The `Application._on_save()` method already displays
    errors in the status bar; we just need to make the same text display in an error
    dialog as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, open `application.py`, and let''s import `messagebox` like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, locate the line in the `Application._on_save()` method that updates the
    application status with any errors (inside the `if errors:` block). Just after
    that line, let''s add some code to display the error dialog, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The first thing we've done is build the message and detail strings for the dialog,
    making a bullet list of the fields that have errors by joining them with `\n *`
    (that is, a newline, space, and asterisk). Unfortunately, `messagebox` dialogs
    don't support any sort of markup or rich text, so constructs like bullet lists
    need to be built manually using regular characters.
  prefs: []
  type: TYPE_NORMAL
- en: After building the messages, we call `messagebox.showerror()` to display them.
    Remember that the application will freeze at this point until the user clicks
    **OK** and the `showerror()` function returns.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the program and hit **Save**; you''ll see a dialog box alerting you to
    the errors in the application, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The error message when we try to save with no data](img/B17578_07_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.5: The error message on Windows 10 when we try to save with no data'
  prefs: []
  type: TYPE_NORMAL
- en: This error should be hard for anyone to miss!
  prefs: []
  type: TYPE_NORMAL
- en: One shortcoming of the `messagebox` module's dialogs is that they don't scroll;
    a long error message will create a dialog that may fill (or extend beyond) the
    screen. If this is a potential problem, you'll want to create a custom dialog
    containing a scrollable widget. We'll make a custom dialog later in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Using filedialog
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When a user needs to enter a file or directory path, the preferred way to do
    this is to display a dialog containing a miniature file browser, commonly called
    a **file dialog**. Like most toolkits, Tkinter provides us with dialogs for opening
    files, saving files, and selecting a directory. These are all part of the `filedialog`
    module.
  prefs: []
  type: TYPE_NORMAL
- en: Just like `messagebox`, `filedialog` is a Tkinter submodule that needs to be
    explicitly imported to be used. Also like `messagebox`, it contains a set of convenience
    functions that create file dialogs appropriate to different scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table lists the functions, what they return, and what can be
    selected in the dialog shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Function | Return value | Allows selection of |'
  prefs: []
  type: TYPE_TB
- en: '| `askdirectory()` | Directory path as string | Directories only |'
  prefs: []
  type: TYPE_TB
- en: '| `askopenfile()` | File handle object | Existing file only |'
  prefs: []
  type: TYPE_TB
- en: '| `askopenfilename()` | File path as string | Existing file only |'
  prefs: []
  type: TYPE_TB
- en: '| `askopenfilenames()` | Multiple file paths as a list of strings | Multiple
    existing files |'
  prefs: []
  type: TYPE_TB
- en: '| `asksaveasfile()` | File handle object | New or existing file |'
  prefs: []
  type: TYPE_TB
- en: '| `asksaveasfilename()` | File path as string | New or existing file |'
  prefs: []
  type: TYPE_TB
- en: 'As you can see, each file selection dialog comes in two versions: one that
    returns a path as a string, and one that returns an open file object.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Each function can take the following arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '`title` specifies the dialog window title.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`parent` specifies the (optional) parent widget. The file dialog will appear
    over this widget.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`initialdir` sets the directory in which the file browser should start.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`filetypes` is a list of tuples, each with a label and matching pattern, which
    will be used to build the "Format" or "files of type" drop-down typically seen
    under the filename entry. This is used to filter the visible files to only those
    supported by the application. For example, a value of `[(''Text'', ''*.txt''),
    (''Python'', ''*.py'')]` would provide the ability to see only `.txt` or `.py`
    files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `asksaveasfile()` and `asksaveasfilename()` functions take the following
    two additional arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '`initialfile`: This argument is a default file path to select'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`defaultextension`: This argument is a file extension string that will be automatically
    appended to the filename if the user doesn''t include one'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, the methods that return a file object take a `mode` argument that specifies
    the mode to use when opening the file; these are the same one- or two-character
    strings used by Python's built-in `open()` function (for example, `r` for read-only,
    `w` for write, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: Be aware that `asksaveasfile()` automatically opens the selected file in write
    mode by default. This immediately empties the contents of the selected file, *even
    if you do not subsequently write anything to the file or close the file handle!*
    For that reason, this function should be avoided unless you're absolutely certain
    the selected file should be overwritten.
  prefs: []
  type: TYPE_NORMAL
- en: 'On macOS and Windows, `filedialog` uses the operating system''s built-in file
    dialogs, which you are likely familiar with. On Linux, it will use its own dialog,
    which looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17578_07_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.6: File dialog on Ubuntu Linux'
  prefs: []
  type: TYPE_NORMAL
- en: 'Which dialog do we need to use in our application? Let''s consider our needs:'
  prefs: []
  type: TYPE_NORMAL
- en: We need a dialog that allows us to select an existing file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We also need to be able to create a new file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since opening the file is the responsibility of the model, we don't want Tkinter
    to open it for us, so we'll just want to get a filename to pass to the model.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These requirements clearly point to the `asksaveasfilename()` function. Let's
    create a method on our `Application` object that will use this dialog to get a
    filename and build a new model.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `abq_data_entry/application.py` and start a new method on the `Application`
    class called `_on_file_select()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The method first launches an `asksaveasfilename` file dialog; using the `filetypes`
    argument, the selection of existing files will be limited to those ending in `.csv`
    or `.CSV`. When the dialog exits, the function will return the path to the selected
    file as a string to `filename`. Somehow, we have to get this path to our model.
  prefs: []
  type: TYPE_NORMAL
- en: Currently, the filename used by the model is generated in the model's initializer
    method. To create a new model with a user-provided filename, we'll need to update
    the initializer so that it can accept a filename as an argument instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `abq_data_entry/model.py` and let''s edit the `CSVModel.__init__()` method,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we've added `filename` as a keyword argument with a default
    value of `None`. If `filename` does happen to be empty, we'll use our generated
    filename as before. This way, we don't have to alter any existing code using `CSVModel`,
    but we have the option to pass in a filename.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, go back to the `Application` class and let''s finish out the `_on_file_select()`
    method, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This is all that we need to change to use a different file. Currently there's
    no way for us to run this callback; we'll address that in the next section, *Designing
    the application menu*. First, though, let's talk about the last dialog module,
    `simpledialog`.
  prefs: []
  type: TYPE_NORMAL
- en: Using simpledialog and creating a custom dialog
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Quite often in a GUI application, you will need to stop everything and ask the
    user for a value before the program can continue with an operation. For this purpose,
    Tkinter provides the `simpledialog` module. Like `messagebox`, it provides us
    with some convenience functions that display a modal dialog and return a value
    based on the user's interaction. However, with `simpledialog`, the dialog box
    contains an `Entry` widget that allows the user to provide a value.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with the other dialog libraries, we have to import `simpledialog` to use
    it, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'There are three convenience functions available: `askstring()`, `askinteger()`,
    and `askfloat()`. Each one takes a `title` and `prompt` argument, for providing
    the window title and the text prompt for the entry, respectively.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s ask the user for a word:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This will display a box like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The askstring dialog box on macOS](img/B17578_07_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.7: The askstring dialog box on macOS'
  prefs: []
  type: TYPE_NORMAL
- en: 'When the user clicks **OK**, the function will return whatever was typed into
    the `Entry` widget as a string. `askinteger()` and `askfloat()` work exactly the
    same, except that they will try to convert the entered value into an integer or
    float before returning it. The `Entry` widget itself is not validated using validation
    callbacks, but Tkinter will display an error box when the dialog is submitted
    if there is a problem converting the entered value, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Error generated from askinteger() when a non-integer value is submitted.](img/B17578_07_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.8: Error generated from askinteger() when a non-integer value is submitted'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Login dialog using simpledialog
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One of the tasks we''ve been given for this chapter is adding a `Login` dialog
    to our application. It seems like something `simpledialog` can help us with, but
    none of the built-in convenience functions really work well for this purpose:
    `askstring()` could be used, but it only asks for one string at a time, and it
    would be nice if we could mask the password entry for user security.'
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately we can create our own custom `simpledialog` class with any set of
    fields we wish. To do that, we'll subclass the `simpledialog.Dialog` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since this is a GUI form, let''s add it to our `abq_data_entry/views.py` file.
    Open that file and start with importing `Dialog`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, at the end of the file, let''s start a new class called `LoginDialog`,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `Dialog` initializer expects a `parent` argument specifying the widget over
    which it will appear, as well as a `title` argument for the window title of the
    box. We've also added a keyword argument, `error`, that will allow us to pass
    an error message to the dialog box when we display it.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the initializer, we're setting up private control variables for the user,
    password, and error strings, then calling the superclass initializer. To actually
    build the GUI for the `Dialog` class, we need to override a method called `body()`.
    This method is expected to build the main body of the GUI and return an instance
    of an input widget, which should receive focus when the dialog is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `body()` method will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `frame` argument to this method is a `tkinter.Frame` object created by the
    super-class initializer on which the body of the dialog can be built. Our method
    needs to build the form on this frame. Here, we've added a `Label` widget for
    the top of the form, then made use of our `LabelInput` class to add User name
    and Password fields. For our password input, we're using the `show` argument to
    mask password entry with asterisks. Also note that we've saved a local reference
    to the user input class; remember that `body()` needs to return a reference to
    a widget that will have focus when the dialog is shown.
  prefs: []
  type: TYPE_NORMAL
- en: Notice there are no buttons defined by our `body()` method. By default, `Dialog`
    creates an **OK** button and **Cancel** button, which are connected to the `Dialog.ok()`
    and `Dialog.cancel()` callbacks, respectively. This is fine for many situations,
    but we might prefer for our dialog to show **Login** and **Cancel** instead. To
    do that, we need to override the `buttonbox()` method. This method is responsible
    for putting the buttons on the form and connecting them to their callbacks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s override that method like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In this method, we've created a `Frame` widget, then added Login and Cancel
    buttons. Each button is connected to the appropriate callback and added to the
    frame. Next, we've bound the same callbacks to the `Return` and `Escape` keys,
    respectively. This isn't strictly necessary, but it's a nice touch for keyboard-only
    users, and it's what the superclass version of the method does.
  prefs: []
  type: TYPE_NORMAL
- en: To make the entered data easily available to the code calling the dialog, we'll
    create a tuple with the entered username and password and make it available as
    a class member when the user clicks **Login**.
  prefs: []
  type: TYPE_NORMAL
- en: We could override the `ok()` method to do this, but that method takes care of
    some other logic (like closing the dialog) that we don't want to have to re-implement.
    Instead, `Dialog` features an `apply()` method that we are meant to override with
    our custom logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ours will simply look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This function builds a tuple containing the entered data and stores it as a
    public member, `result`. Code using our `LoginDialog` class can access this attribute
    to retrieve the `username` and `password`.
  prefs: []
  type: TYPE_NORMAL
- en: Incorporating the LoginDialog in our class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The convenience functions, `askstring()`, `askfloat()`, and `askinteger()`,
    essentially create an instance of their associated dialog class and return its
    `result` attribute. To use our custom dialog class, we'll essentially do the same
    thing. When we get the result, however, we'll pass it to an authentication method
    that will decide if the credentials are valid or not. If they're not, we'll re-display
    the dialog with an error until either the credentials are correct, or the user
    cancels the dialog.
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin, let''s write an authentication method. We''ll be adding this to the
    `Application` class, so open `application.py` and add this `_simple_login()` method
    to the end of the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Notice we've implemented this as a static method, since it does not need access
    to the instance or class. It will simply take the `username` and `password` given
    and see if they match hard-coded values. It returns `True` or `False` accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: This is quite possibly the worst way you can do password security in an application;
    *do not* ever use this approach in a real application. We are using it here for
    the sake of illustration, since the point is to understand dialogs. In *Chapter
    12*, *Improving Data Storage with SQL*, we'll implement an authentication backend
    that's actually production-worthy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s create a second method that will display the login dialog and test
    the entered credentials for validity, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In this method, we begin by creating `error` and `title` variables, then entering
    an infinite loop. Inside the loop, we create our `LoginDialog` instance using
    the `title` and `error` strings. This will display the dialog, and execution will
    halt here until the user either cancels or submits the dialog. When that happens,
    `login` is assigned to the instance of the dialog (*not* to the results!). Now
    we can check `login.result` to see what the user entered.
  prefs: []
  type: TYPE_NORMAL
- en: If `result` is empty, the user canceled, so we can return `False` from the method.
    If the user entered something, we'll extract `result` into its `username` and
    `password` values, then pass those to our `_simple_login()` method. If the credentials
    check out, we will return `True`; if not, we'll update the error string and let
    the loop iterate again, re-displaying the dialog. The net result is that this
    method will return either `False` if the dialog was canceled, or `True` if the
    authentication succeeded.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we need to call this method during the startup of our application. We'll
    do this in the application's initializer. Since dialogs cannot be created until
    a root window has been created, we'll have to do this just after the call to `super().__init__()`
    (remember that `Application` is a subclass of `Tk`, so calling `super().__init__()`
    is what creates our `Tk` instance).
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to `Application.__init__()`, just under the call to
    `super().__init__()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The first line calls the `withdraw()` method, which hides our main window. We
    don't strictly have to do this, but without it we'll have a blank `Application`
    window hanging around while the login dialog is being presented.
  prefs: []
  type: TYPE_NORMAL
- en: After hiding the blank window, we'll call `_show_login()` and test its `return`
    value. Remember it will return `True` if the user successfully authenticates,
    or `False` if the user cancels the dialog. In the latter case, we'll call `self.destroy()`,
    which deletes our `Tk` instance, and return from the method. Effectively, this
    quits the application.
  prefs: []
  type: TYPE_NORMAL
- en: Normally you would call `Application.quit()` to exit a Tkinter program; this
    method of the `Tk` object causes the main loop to exit and thus the program ends.
    However, at this point in the program, we haven't started the main loop yet, so
    `quit()` won't do anything. If we destroy the window and return without adding
    anything else, the main loop will see that the root window is destroyed and exit
    after its first iteration.
  prefs: []
  type: TYPE_NORMAL
- en: If the user is successful in authenticating, we'll call the application's `deiconify()`
    method, which restores its visibility. Then we continue with the remainder of
    the initializer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go ahead and launch the application to give your `LoginDialog` class a test
    run. It should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The login dialog](img/B17578_07_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.9: The login dialog'
  prefs: []
  type: TYPE_NORMAL
- en: Great job!
  prefs: []
  type: TYPE_NORMAL
- en: Designing the application menu
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most applications organize functionality into a hierarchical menu system, typically
    displayed at the top of the application or screen (depending on the operating
    system). While the organization of this menu varies between operating systems,
    certain items are fairly common across platforms.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of these common items, our application will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A **File menu** containing file operations such as **Open**/**Save**/**Export**,
    and often an option to quit the application. Our users will need this menu to
    select a file to save to, and to quit the program.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An **Options menu** where users can configure the application. We'll need this
    menu for our toggle settings; sometimes a menu like this is called Preferences
    or Settings, but we'll go with Options for now.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **Help menu**, which contains links to help documentation, or, at the very
    least, an About message giving the basic information about the application. We'll
    implement this menu for the About dialog.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apple, Microsoft, and the GNOME Project publish guidelines for macOS, Windows,
    and the GNOME desktop environment (used on Linux and BSD), respectively; each
    set of guidelines addresses the layout of menu items specific to that platform.
    We'll explore this in more detail in *Chapter 10*, *Maintaining Cross-Platform
    Compatibility*.
  prefs: []
  type: TYPE_NORMAL
- en: Before we can implement our menu, we'll need to understand how menus work in
    Tkinter.
  prefs: []
  type: TYPE_NORMAL
- en: The Tkinter Menu widget
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `tkinter.Menu` widget is the building block used to implement menus in Tkinter
    applications; it's a fairly simple widget that acts as a container for any number
    of menu items.
  prefs: []
  type: TYPE_NORMAL
- en: 'The menu items can be one of the following five types:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Item type | Description |'
  prefs: []
  type: TYPE_TB
- en: '| `command` | A labeled item that executes a command when clicked |'
  prefs: []
  type: TYPE_TB
- en: '| `checkbutton` | A labeled checkbutton that can be tied to a Boolean control
    variable |'
  prefs: []
  type: TYPE_TB
- en: '| `radiobutton` | A labeled radio button that can be tied to a control variable
    |'
  prefs: []
  type: TYPE_TB
- en: '| `separator` | A system-appropriate visual separator, usually a black line
    |'
  prefs: []
  type: TYPE_TB
- en: '| `cascade` | A submenu, implemented as a second `Menu` instance |'
  prefs: []
  type: TYPE_TB
- en: 'To explore how the `Menu` class works, let''s start a simple example script,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This application sets up a 200-by-150-pixel main window with a `Label` widget,
    whose text is controlled by a string variable, `main_text`. Now, let''s start
    adding the menu components, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This creates a `Menu` instance and then sets it as the main menu of our application
    by assigning it to the `root` window's `menu` argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'Currently, the menu is empty, so let''s add an item; add this code to the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Here, we've added a `command` item to quit the application. The `Menu.add()`
    method allows us to specify an item type and any number of keyword arguments to
    create a new menu item. In the case of a `command` item, we need to at least have
    a `label` argument specifying the text that will show in the menu and a `command`
    argument pointing to a Python callback.
  prefs: []
  type: TYPE_NORMAL
- en: Some platforms, such as macOS, don't allow a command in the top-level menu.
    We'll cover the differences between menus on different platforms in more detail
    in *Chapter 10*, *Maintaining Cross-Platform Compatibility*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s try creating a submenu, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Creating a submenu is just like creating a menu, except that we specify the
    parent menu as the widget's parent. Notice the `tearoff` argument; by default,
    submenus in Tkinter are **tearable**, which means they can be pulled off and moved
    around as independent windows.
  prefs: []
  type: TYPE_NORMAL
- en: You don't have to disable this option, but it is a rather archaic UI feature
    that is rarely used on modern platforms. Our users will likely just find it confusing,
    so we're going to disable it whenever we create submenus.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a submenu object, let''s add some commands, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `add_command()` method used here is simply a shortcut for `add('command')`,
    and it can be used on any `Menu` object. There are analogous methods for adding
    other items as well (`add_cascade()`, `add_separator()`, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we''ve populated the `text_menu`, let''s use the `add_cascade()` method
    to add our menu back to its parent widget as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: When adding a submenu to its parent menu, we simply have to provide the label
    for the menu and the menu object itself.
  prefs: []
  type: TYPE_NORMAL
- en: Using Checkbutton and Radiobutton items
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In addition to commands and submenus, we can also add `Checkbutton` and `Radiobutton`
    widgets to the menu. To demonstrate this, let's create another submenu with options
    to alter the label's appearance.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''ll need to add the following setup code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: To use `checkbutton` and `radiobutton` items in a menu, we need to first create
    control variables to bind to them. Here, we're just creating a Boolean variable
    for the bold font toggle, and an integer variable for the font size. Next, we've
    created a callback function that reads the variables and sets the `Label` widget's
    `font` property from them when called. Finally, we've set up a trace on both variables
    to call the callback whenever the values are changed, and called the callback
    to initialize the font settings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we just need to create the menu options to change the variables; add this
    code next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Here we've created the submenu for the appearance options and added the checkbutton
    for bold text. Like a regular `Checkbutton` widget, the `add_checkbutton()` method
    uses a `variable` argument to assign its control variable. Unlike a regular `Checkbutton`
    widget, though, it uses the `label` argument, rather than the `text` argument,
    to assign the label text.
  prefs: []
  type: TYPE_NORMAL
- en: The `checkbutton` item works with a `BooleanVar` by default; however, just like
    a `Checkbutton` widget, you can use it with different control variable types by
    passing in `onvalue` and `offvalue` arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate `radiobutton` items, let''s add a submenu to our Appearance
    submenu, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Just as we added a submenu to our main menu, we can add submenus to submenus.
    In theory, you could nest submenus indefinitely, but most UI guidelines discourage
    more than two levels.
  prefs: []
  type: TYPE_NORMAL
- en: To create the items for our size menu, we're just iterating a generated list
    of even numbers between 8 and 24; for each one, we call `add_radiobutton()`, adding
    an item with a value equal to that size. Just as with regular `Radiobutton` widgets,
    the control variable passed to the `variable` argument will be updated with the
    value stored in the `value` argument when the button is selected.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s add a call to `mainloop()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Launch the application and try it out. You should get something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Menu demo application](img/B17578_07_10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.10: The Menu demo application'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand how to work with the `Menu` widget, let's design and
    implement a menu for our application.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the ABQ application menu
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As a major component of the GUI, our main menu code would be right at home
    in the `views.py` file. However, because it''s going to be expanded considerably
    as our application grows, we''ll put it in its own module file. Create a new file
    the `abq_data_entry` directory called `mainmenu.py`. Then begin the file with
    a docstring and our imports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s subclass `tkinter.Menu` to create our own main menu class, like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We will be building the rest of the menu inside the initializer, though for
    the moment this doesn't do anything extra. Before we start building the menu,
    let's drop back into our `application.py` module and set up this class as the
    application's main menu.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, import the class at the top of the file, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, inside `Application.__init__()`, we need to create an instance of our
    `MainMenu` class and make it the application''s menu. Update the method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Now let's head back to `mainmenu.py` and start building the components of our
    menu.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a Help menu
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's begin with something simple. We'll just add an About dialog to display
    some information about our program. This is typically located in a Help menu.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to `MainMenu.__init__()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Here, we've added a Help menu and a command for About.
  prefs: []
  type: TYPE_NORMAL
- en: 'The command specifies an instance method, `show_about()`, as its callback;
    so, we''ll need to add that method to the class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This method just specifies some basic information about the application and
    displays it in a `messagebox` dialog. You can, of course, update the `about_detail`
    variable with your own information, or a much longer (and hopefully more helpful)
    message.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a File menu
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next menu we'll create is a File menu. This will have two commands, one
    for selecting a file and another for quitting the application. Unlike the About
    dialog, though, we can't really implement the callback logic for either command
    in the menu class itself. File selection will need to call the `Application._on_file_select()`
    method we created earlier in the chapter, and the quit command will need to call
    `Application.quit()`.
  prefs: []
  type: TYPE_NORMAL
- en: Since the menu's parent widget will be the `Application` object, we could just
    bind these commands to `parent._on_file_select` and `parent.quit`, but that would
    create a tight coupling situation as we discussed in *Chapter 6*, *Planning for
    the Expansion of Our Application*. As we did in that chapter, we'll instead use
    generated events to communicate back to the controller class.
  prefs: []
  type: TYPE_NORMAL
- en: 'One possible way to implement our File menu commands is to use a `lambda` function,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The `lambda` keyword creates an anonymous inline function that contains a single
    expression. It is often used in situations where we need a reference to a function
    (such as a widget's `command` argument) but don't need the overhead of defining
    a named function. In this case, we're creating an anonymous function that generates
    a custom `<<FileSelect>>` event on the `MainMenu` object using `event_generate()`.
  prefs: []
  type: TYPE_NORMAL
- en: You can find out more about Lambda expressions in *Section 6.14* of the Python
    official documentation, available at [https://docs.python.org/3/reference/expressions.html](https://docs.python.org/3/reference/expressions.html).
  prefs: []
  type: TYPE_NORMAL
- en: However, there are two problems with this approach.
  prefs: []
  type: TYPE_NORMAL
- en: First, using `lambda` every time is rather verbose and ugly, and since our menu
    is going to be generating a lot of custom events as the application grows, we'd
    like to avoid a lot of repetitive boilerplate code.
  prefs: []
  type: TYPE_NORMAL
- en: Second, binding events on a `Menu` object doesn't work on all platforms (particularly,
    it doesn't work on Microsoft Windows). This has to do with the fact that the `Menu`
    is built around the native menu system of each platform. To work around this,
    we'll need to get a reference to our `root` window and bind our events to that.
  prefs: []
  type: TYPE_NORMAL
- en: Since this makes our code even uglier, it makes sense to create a simple wrapper
    function that will keep our menu definitions nice and clean.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following `_event()` method to the `MainMenu` class above the initializer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This simple method creates a function that causes the `root` window instance
    to generate the provided `sequence` string, then returns a reference to the newly
    defined function. To get a reference to the `root` window, we call `winfo_toplevel()`
    on the menu's parent widget (`self.master`), which returns the top-level window
    of the menu's parent widget. You might wonder why we don't just use `self.master`,
    or just call `winfo_toplevel()` on the `Menu` object itself. In the first case,
    we can't be sure what the menu's parent widget will be until we create an instance
    of it, especially as our program evolves in the future. While we can't be sure
    exactly what the parent widget will be, we can be sure it will be a widget on
    a window; by calling `winfo_toplevel()` we should get the `root` window.
  prefs: []
  type: TYPE_NORMAL
- en: In the second case, the `winfo_toplevel()` method, when called on a `Menu` object,
    actually returns the top level of the *menu*. In other words, `self.winfo_toplevel()`
    in this context would just return our `MainMenu` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can update our menu items to use this wrapper method, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Note the use of the ellipsis character (`â€¦`) after `"Select file"`. This is
    a convention in menus to indicate when a command will open another window or dialog
    to get information from the user rather than just running a command directly.
  prefs: []
  type: TYPE_NORMAL
- en: Now our code looks much cleaner. To make these commands work, we'll need to
    tell our `Application` class to listen for these events and take appropriate action
    when they're generated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back in the `application.py` file, let''s add the following lines to `Application.__init__()`,
    just after the menu object setup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Here, we've created an `event_callbacks` dictionary, matching event sequences
    to callback methods. Then, we're iterating through the dictionary, binding each
    sequence to its event.
  prefs: []
  type: TYPE_NORMAL
- en: As we add more items to our menu, we'll just need to update the dictionary with
    the additional bindings. Note that we cannot bind the `<<FileQuit>>` action directly
    to `self.quit()`. That's because callbacks bound using the `bind()` method pass
    arguments when the callback is called, and `self.quit()` takes no arguments. We're
    using a `lambda` call here just to filter out the added argument from the callback.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a settings menu
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next thing we need to add is our Options menu, which will allow the user
    to specify whether they want the Date and Sheet data auto-filled in the form or
    not. We've already seen that adding checkbutton options to a menu is fairly easy,
    but actually making these options work is going to take some additional plumbing
    work. Somehow, we need to connect these menu options to the `DataRecordForm` instance
    so that it can disable the automation appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, let''s begin by creating a dictionary in the `Application` class
    that will store some control variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Next, we will need to make sure both our `DataRecordForm` and `MainMenu` objects
    have access to these settings; we will do this by passing the `settings` dictionary
    to their initializer methods and storing it as an instance variable on each class.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, in `views.py`, let''s update the `DataRecordForm.__init__()` method,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, in `mainmenu.py`, let''s update the `MainMenu.__init__()` method, like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, back in the `Application` class, we have to update the code that creates
    instances of these classes to pass in the `settings` dictionary to each one. Update
    the code in `Application.__init__()` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Each class now has access to the `settings` dictionary, so let's put it to use.
    To begin with, let's add our Options menu to the main menu.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `MainMenu` file, add this code to the initializer method to build the
    menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Very simply, we've created a `Menu` widget called `options_menu` with two `checkbutton`
    items that are bound to our settings variable. That's all the configuration our
    `MainMenu` needs for the settings.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we need to do is make these settings work with the `DataRecordForm`
    class's `reset()` method, which handles the auto-filling of these fields.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `views.py` file, locate the `DataRecordForm.reset()` method, and find
    the code that sets the date variable. Update it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'All we''ve done here is put this date-setting logic below an `if` statement
    that checks the `settings` value. We need to do the same for our sheet data section,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Since this logic was already under an `if` statement, we've just added another
    condition to the check. This should now give us functioning options.
  prefs: []
  type: TYPE_NORMAL
- en: Finishing the menu
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The last thing we need to do in our main menu is add the submenus we''ve created
    to the main menu. At the end of `MainMenu.__init__()`, add the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The submenus will be arranged from left to right in the order we add them. Typically
    the File menu is first and the Help menu is last, with the other menus arranged
    in between. We'll learn more about how to arrange menus with respect to platform
    in *Chapter 10*, *Maintaining Cross-Platform Compatibility*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the application, and you should see a nice main menu like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The ABQ application sporting a fancy main menu](img/B17578_07_11.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.11: The ABQ application sporting a fancy main menu'
  prefs: []
  type: TYPE_NORMAL
- en: Give the settings a try by un-checking them and entering some records. They
    should disable the auto-fill functionality when disabled.
  prefs: []
  type: TYPE_NORMAL
- en: Persisting settings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our settings work, but there''s a major annoyance: they don''t persist between
    sessions. Shut down the application and start it up again, and you''ll see that
    the settings are back to their defaults. It''s not a major problem, but it''s
    a rough edge we shouldn''t leave for our users. Ideally, their personal settings
    should load up each time they launch the application.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Python gives us a variety of ways to persist data in files. We''ve already
    experienced CSV, which is designed for tabular data; there are other formats designed
    with different capabilities in mind. The following table shows just a few of the
    options for storing data available in the Python standard library:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Module | File type | Suitable for | Benefits | Drawbacks |'
  prefs: []
  type: TYPE_TB
- en: '| `pickle` | Binary | Any Python object | Fast, easy, small files | Not safe,
    files not human-readable, whole file must be read |'
  prefs: []
  type: TYPE_TB
- en: '| `configparser` | Text | Key -> value pairs | Human-readable files | Can''t
    handle sequences or complex objects, limited hierarchy |'
  prefs: []
  type: TYPE_TB
- en: '| `json` | Text | Simple values and sequences | Widely used, easy, human-readable
    | Can''t handle dates, complex objects without modification |'
  prefs: []
  type: TYPE_TB
- en: '| `xml` | Text | Any kind of Python object | Powerful, flexible, human-readable
    files | Not safe, complex to use, verbose syntax |'
  prefs: []
  type: TYPE_TB
- en: '| `sqlite` | Binary | Relational data | Fast, powerful, can represent complex
    relationships | Requires SQL knowledge, objects must be translated to tables |'
  prefs: []
  type: TYPE_TB
- en: 'Table 7.3:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If this weren''t enough, there are even more options available in the third-party
    libraries. Almost any of them would be suitable for storing a couple of Boolean
    values, so how do we choose? Let''s consider the options:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SQL` and `XML` are powerful, but far too complex for our simple needs here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'd like to stick to a text format in case we need to debug a corrupt settings
    file, so `pickle` is out.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`configparser` would work for now, but its inability to handle lists, tuples,
    and dictionaries may be limiting in the future.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That leaves `json`, which is a good option. While it can't handle every kind
    of Python object, it can handle strings, numbers, and Boolean values, as well
    as lists and dictionaries. It can even be extended to handle other kinds of data.
    It should cover our current configuration needs just fine, and most likely our
    future needs as well.
  prefs: []
  type: TYPE_NORMAL
- en: What does it mean when we say that a library is "not safe"? Some data formats
    are designed with powerful capabilities, such as extensibility, linking, or aliasing,
    which parser libraries must implement. Unfortunately, those capabilities can be
    exploited for malicious purposes. For example, the "billion laughs" XML vulnerability
    combines three XML capabilities to craft a file that, when parsed, expands to
    a massive size (usually causing the program or, in some cases, the operating system,
    to crash).
  prefs: []
  type: TYPE_NORMAL
- en: Building a model for settings persistence
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As with any kind of data persistence, we need to start by implementing a model.
    As with our `CSVModel` class, the settings model needs to save and load the data,
    as well as authoritatively defining the layout of the settings data. Since we''re
    using `json`, we need to import it. Add this to the top of `models.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, down at the end of `models.py`, let''s start a new `SettingsModel` class
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: As we did with the `CSVModel`, we've begun our class with a class variable that
    defines the `fields` included in the settings file. Currently, it only contains
    our two Boolean values. Each field in the dictionary defines a data type and default
    value for the field. Note that we're using strings here rather than Python `type`
    objects; doing this will allow us to persist both the type and the value to a
    text file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s create the initializer method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The initializer will determine the file path to which our settings will be saved;
    for now, we've hard-coded the name `abq_settings.json` and stored it in the user's
    home directory. `Path.home()` is a class method of the `Path` class that provides
    us with a `Path` object pointed to the user's home directory. In this way, each
    user on the system can have their own settings file.
  prefs: []
  type: TYPE_NORMAL
- en: 'As soon as the model is created, we''ll want to load the user''s saved options
    from disk, so let''s add a call to an instance method we''ll call `load()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need to implement the `load()` method. A simplistic implementation may
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'This simply opens the file stored in our `self.filepath` location and overwrites
    the `fields` variable with whatever contents are extracted by `json.load()`. This
    is the gist of what we need to do, but there are two problems with this approach:'
  prefs: []
  type: TYPE_NORMAL
- en: What happens if the file doesn't exist? (For example, if the user has never
    run the program before.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What happens if the JSON data in the model doesn't match with the keys expected
    by our application? (For example, if it was tampered with, or created by an older
    version of the application.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s create a more robust callback that addresses these issues, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: In this version, we address the first issue by checking to see if the file exists.
    If the file doesn't exist, the method simply returns and does nothing. It's perfectly
    reasonable for the file not to exist, especially if the user has never run the
    program or edited any of the settings. In this case, the method would leave `self.fields`
    alone and the user would end up with the defaults.
  prefs: []
  type: TYPE_NORMAL
- en: To address the second problem, we've pulled the JSON data into a local variable
    called `raw_values`; then, we update `fields` by retrieving from `raw_values`
    only those keys that are defined by our class. If the JSON data lacks a particular
    key, we skip it, leaving `fields` with its default value.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to loading settings, our model will of course need to save its
    data. Let''s write a `save()` method to write our values to the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The `json.dump()` function is the inverse of `json.load()`: it takes a Python
    object and a file handle, converts the object to a JSON string, and writes it
    to the file. Saving our settings data is as simple as converting the `fields`
    dictionary to a JSON string and writing it to the specified text file.'
  prefs: []
  type: TYPE_NORMAL
- en: The final method our model needs is a way for external code to set values; we
    could just allow external code to manipulate the `fields` dictionary directly,
    but in the interest of protecting our data integrity, we'll do it through a method
    call.
  prefs: []
  type: TYPE_NORMAL
- en: Keeping with Tkinter convention, we'll call this method `set()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A basic implementation of the `set()` method is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'This simple method just takes `key` and `value` arguments and writes them to
    the `fields` dictionary. This opens up some potential problems, though:'
  prefs: []
  type: TYPE_NORMAL
- en: What if the value provided isn't valid for the data type?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What if the key isn't in our `fields` dictionary? Should we allow outside code
    to just add new keys?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These situations could create problems in the application that would be hard
    to debug, so our `set()` method should safeguard against these scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a more robust version, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: In this version, we check if the given `key` argument exists in `fields`, and
    if the `type` of the data matches the type defined for that field. To match the
    `value` variable's object type to the `field` dictionary's `type` strings, we
    have extracted the variable's data type as a string using `type(value).__name__`.
    This returns a string like `bool` for Boolean variables, or `str` for strings.
    With these checks protecting our value assignment, an attempt to write an unknown
    key or incorrect variable type will fail.
  prefs: []
  type: TYPE_NORMAL
- en: However, we don't let it fail silently; if there is bad data, we immediately
    raise a `ValueError` exception. Why raise an exception? If the test fails, it
    can only mean a bug in the calling code. With an exception, we'll know immediately
    if the calling code is sending bad requests to our model. Without it, requests
    would fail silently, leaving a hard-to-find bug.
  prefs: []
  type: TYPE_NORMAL
- en: Using the settings model in our application
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our application needs to load in the settings when it starts, then save them
    automatically whenever they are changed. Currently, the application's `settings`
    dictionary is created manually, but our model, as the authority on the settings
    data structure, should really be telling it what kind of variables to create.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back in the `Application.__init__()` method, locate the line that creates our
    `settings` dictionary, and replace it with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: First, we've created a `SettingsModel` instance, storing it as an instance variable.
    Then, we're running an instance method called `_load_settings()`. This method
    will be responsible for querying the `settings_model` to create the `Application.settings`
    dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end of the class definition, let''s create the `_load_settings()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Our model stores the type and value for each variable, but our application needs
    Tkinter control variables. We need to translate the model's representation of
    the data into a structure that `Application` can use. So the first thing this
    function does is create a `vartypes` dictionary to translate our `type` strings
    to control variable types.
  prefs: []
  type: TYPE_NORMAL
- en: Although we currently only have Boolean variables in our settings, we're going
    to anticipate more settings in the future and create a function capable of handling
    strings, floats, and integers as well.
  prefs: []
  type: TYPE_NORMAL
- en: After defining the `vartypes` dictionary and creating an empty dictionary for
    `settings`, we just need to iterate through `self.settings_model.fields`, creating
    a matching control variable for each field. Note that `vartypes.get(data['type'],
    tk.StringVar)` ensures that, if we get a variable type not listed in `vartypes`,
    we'll just create a `StringVar` for it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main reason for using Tkinter variables here is so that we can trace any
    changes the user makes to the values via the UI and respond immediately. Specifically,
    we want to save our settings whenever the user makes a change. To implement this,
    add the last two lines to the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: This adds a trace that calls `_save_settings` whenever a settings variable is
    changed. Of course, this means we need to write a method called `Application._save_settings()`,
    which will save the settings to disk.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this code to the end of `Application`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: The `save_settings()` method just needs to get the data back from `Application.settings`
    to the model and then save it. It's as simple as iterating through `self.settings`
    and calling our model's `set()` method to pull in the values one at a time. Once
    we've updated the values, we call the model's `save()` method.
  prefs: []
  type: TYPE_NORMAL
- en: This completes our settings persistence; you should be able to run the program
    and observe that the settings are saved, even when you close and re-open the application.
    You'll also find a file in your home directory called `abq_settings.json` (this
    isn't the ideal place to keep a settings file, but we'll address that in *Chapter
    10*, *Maintaining Cross-Platform Compatibility*).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, our simple form has taken a big step forward toward being a
    full-blown application. We've implemented a main menu, option settings that are
    persisted between executions, and an About dialog. We've added the ability to
    select a file where records are saved, and improved the visibility of form errors
    with an error dialog. Along the way, you learned about Tkinter menus, file dialogs,
    message boxes, and custom dialogs, as well as the various options for persisting
    data in the standard library.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we're going to be asked to make the program read data as
    well as write it. We'll learn about Ttk's `Treeview` and `Notebook` widgets, and
    how to make our `CSVModel` and `DataRecordForm` classes capable of reading and
    updating existing data.
  prefs: []
  type: TYPE_NORMAL
