- en: Chapter 2. Creating a Simple Spreadsheet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will develop a simple spreadsheet application. The spreadsheet
    functionality will be entirely implemented in JavaScript plus jQuery UI, but we
    will configure CherryPy to deliver the page that contains the spreadsheet application
    dynamically.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: On the presentation side, we will encounter our first jQuery UI widgets (buttons)
    and will see how we can design other elements to adhere to jQuery UI standards
    to fit seamlessly in jQuery UI's theme framework. We will also see how to find
    and use publically available jQuery plugins and integrate the jEditable plugin
    into our application.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: That is a lot to grasp in one go, but don't worry if every detail is not clear
    the first time. We will encounter many variants of the issues first encountered
    here in the other chapters and will explain all relevant details again in their
    context.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'In this chapter, we will be:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating an environment to develop and deliver our applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing a simple spreadsheet application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning how to configure CherryPy to deliver this application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encountering our first jQuery UI widgets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And designing our own jQuery plugins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a lot of ground to cover so let's go...
  prefs: []
  type: TYPE_NORMAL
- en: Python 3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python 3 is the language we will use to develop the server-side parts of our
    applications. At the time of writing, the current stable version is 3.2\. Installers
    and source archives are available for various platforms (including Windows, Mac
    OS, and Linux distributions) and may be downloaded from [http://www.python.org/download/](http://www.python.org/download/).
  prefs: []
  type: TYPE_NORMAL
- en: Time for action installing Python 3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Downloading and installing Python is not difficult. The installers for many
    platforms can be downloaded from [http://www.python.org/download/](http://www.python.org/download/).
  prefs: []
  type: TYPE_NORMAL
- en: Download the installer for your platform and follow the installation instructions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Verify that you correctly installed Python by typing the following command
    on the command line (for example, inside a Windows command prompt or a Linux xterm):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The response will be the version:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: On a UNIX-like system (like Ubuntu Linux, or Mac OS), Python might very well
    be already installed, so it might be a good idea to verify that first by trying
    the instructions in step 2\. If the version returned is lower than 3, you should
    update your Python distribution. Note that it is perfectly possible to install
    version 3.x of Python alongside a 2.x version in order to not break applications
    depending on version 2.x (Python 3 is not backward compatible with version 2).
  prefs: []
  type: TYPE_NORMAL
- en: CherryPy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Writing an HTTP server in Python isn't that difficult, but writing and maintaining
    a robust and fully fledged web server that can act as an application server is
    quite something else. As we explained in [Chapter 1](ch01.html "Chapter 1. Choosing
    Your Tools"), *Choosing Your Tools*, we will use CherryPy as our application server.
    At the time of writing, CherryPy's latest stable version for Python 3 is version
    3.2.0 and can be downloaded from [http://download.cherrypy.org/cherrypy/3.2.0/](http://download.cherrypy.org/cherrypy/3.2.0/).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Windows users should use the zip archive and unpack it before proceeding to
    the instructions in the next section. There is also a `msi` installer available
    at the indicated location, but this installer might not be able to find the correct
    Python installation in the Windows registry and will only work on 32-bit versions
    of Windows. Unpacking the zip archive and following the setup instructions next
    is therefore a safer bet and also identical on both Windows and Unix-like platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action installing CherryPy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The one thing to be careful with when you install CherryPy is that you have
    to make sure you install it in the right directory if you have more than one Python
    version on your system. CherryPy uses a setup script to install itself and one
    way to make sure the CherryPy modules end up in the correct place is by invoking
    Python explicitly with a full path, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Running CherryPy''s `setup.py` script installs a number of modules in Python''s
    `Lib\site-packages` directory. You may verify this was successful by typing the
    following on the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This checks whether we can import the `cherrypy` module. If everything is installed
    correctly, there will be no output produced by this command. However, if CherryPy
    isn''t installed, this may be signaled by an error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'When you have more than one version of Python installed, be careful to enter
    the complete path of the Python executable to select the correct version, for
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Installing jQuery and jQuery UI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The applications we will design and implement in this chapter and the following
    chapters depend heavily on the jQuery and jQuery UI libraries. These libraries
    consist mainly of JavaScript files and some cascading style sheets, and images
    to style the widgets.
  prefs: []
  type: TYPE_NORMAL
- en: 'These files are served to the web browser as part of the application, and in
    general, there are two locations where they may be served from:'
  prefs: []
  type: TYPE_NORMAL
- en: A (sub)directory on the server that runs CherryPy together with the other files
    that make up our application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Or from an external web location like Google's or Microsoft's content delivery
    networks.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The latter option might be the best choice if your application gets a lot of
    traffic as these publicly available resources are designed for high availability
    and can cope with an enormous number of requests. This might seriously reduce
    the load on your server and thus reduce costs. More information on this can be
    found on jQuery's download section [http://docs.jquery.com/Downloading_jQuery#CDN_Hosted_jQuery](http://docs.jquery.com/Downloading_jQuery#CDN_Hosted_jQuery).
  prefs: []
  type: TYPE_NORMAL
- en: For development purposes it is often better to download the necessary files
    and serve them from the web server that serves the rest of the application as
    well. This way we can inspect those files easily when some error occurs or even
    decide to tweak the contents. If we choose to theme our application in a customized
    way (see the info box on jQuery UI's themeroller), the cascading style sheets
    will differ from the standard ones so we will have to serve them from our web
    server anyway.
  prefs: []
  type: TYPE_NORMAL
- en: In the example code provided with this book, we include both the jQuery and
    jQuery UI libraries in the `static` subdirectory of the directory for each chapter.
    There is also a `css` subdirectory that contains a set of customized style sheets
    that are optimized to deliver a visual style that is well readable both in print
    and onscreen. The version of the jQuery library used in this book is downloaded
    from [http://code.jquery.com/jquery-1.4.2.js](http://code.jquery.com/jquery-1.4.2.js).
    Information on downloading a (possible themed) version of jQuery UI can be found
    on [http://jqueryui.com/download](http://jqueryui.com/download).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Using jQuery UI''s themeroller**'
  prefs: []
  type: TYPE_NORMAL
- en: The theme used throughout this book is called *smoothness* and can be downloaded
    from [http://jqueryui.com/themeroller/](http://jqueryui.com/themeroller/) by choosing
    the **Gallery** tab and clicking the **Download** button below the **Smoothness**
    example. It is even possible to create a completely customized theme based on
    one of the standard themes by selecting one of the themes from the gallery and
    then tweaking it in the **Roll Your Own** tab. Once you're satisfied with the
    look you can download the result. Check the online documentation at [http://jqueryui.com/docs/Getting_Started](http://jqueryui.com/docs/Getting_Started)
    for all details.
  prefs: []
  type: TYPE_NORMAL
- en: Serving an application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first task we set ourselves is serving content to the end user. In the end
    this should be useful content, of course, but let us first make certain that we
    can write a tiny web application that delivers some content at all.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action serving a dummy application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have the necessary building blocks in place, we can start developing
    our application. Let''s start with a very simple application:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to the directory where you unpacked the example code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to the directory `Chapter 2`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Double-click the file `nocontent.py`, a text window will open (alternatively
    you can enter the command `python nocontent.py` from the command line):![Time
    for action serving a dummy application](img/3746_2_1.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open your favorite browser and enter `http://localhost:8080` in the address
    bar. You will be presented with a rather dull page:![Time for action serving a
    dummy application](img/3746_2_2.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If your browser is unable to connect to `http://localhost:8080`, this might
    be because your local name server is not configured to resolve the name [localhost](http://localhost).
    If you do not have the means to correct this, it is equally valid, though less
    convenient, to enter `http://127.0.0.1:8080` in the address bar of your browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also possible that the default port that the application will be listening
    on (8080) is already in use, in which case, Python will raise an exception: **IOError:
    Port 8080 not free on ''127.0.0.1''**. If that is the case, we can configure CherryPy
    to listen on a different port (see the info box in the next section).'
  prefs: []
  type: TYPE_NORMAL
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Double-clicking `nocontent.py` caused the Python interpreter to start and execute
    the script. This opened up a console window where the CherryPy framework logged
    the fact that it started and that it will be listening on port `8080` at `127.0.0.1`
    (the so called loop back IP-address of the local machine, an address present on
    the machine even if it is not connected to the Internet).
  prefs: []
  type: TYPE_NORMAL
- en: This address and port are the ones we point our browser to, after which the
    HTTP server provides us with an HTML file, and a couple of JavaScript files to
    serve the application. Each file that is retrieved by the browser is logged in
    the console window together with a status. This will be convenient for spotting
    the missing files, for example.
  prefs: []
  type: TYPE_NORMAL
- en: Our script can be stopped from serving requests by closing the console window
    or by pressing *Ctrl* + *Break* (on Windows) or *Ctrl* + *C* (on Windows and most
    other platforms).
  prefs: []
  type: TYPE_NORMAL
- en: Time for action serving HTML as dynamic content
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have seen how to run an application and access it with a web browser, now
    let''s have a look at the Python code needed to accomplish this. We will need
    to serve static files but in addition to those static files we want to generate
    the main HTML content dynamically. This isn''t strictly necessary as we could
    have served it as a static file just as easily but it serves as a simple example
    of how to generate dynamic content:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter2/nocontent.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.PacktPub.com](http://www.PacktPub.com). If you
    purchased this book elsewhere, you can visit [http://www.PacktPub.com/support](http://www.PacktPub.com/support)
    and register to have the files e-mailed directly to you.
  prefs: []
  type: TYPE_NORMAL
- en: '`nocontent.py` starts off with importing the `cherrypy` and `os.path` modules.
    The latter is needed to determine the directory that `nocontent.py` resides in
    (highlighted), so that we may refer to other static files and directories relative
    to `nocontent.py`. This way, we make life a lot easier once we want to move this
    application to its final destination on a production server.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter2/nocontent.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The next step is to start the CherryPy server with the `quickstart()` function
    (highlighted). We pass two arguments: the first one is an object instance of a
    class that exposes some methods to CherryPy that may deliver dynamic content.
    We will look at that one in a minute.'
  prefs: []
  type: TYPE_NORMAL
- en: The second (named) argument is a dictionary containing a number of configuration
    items. In this case, we configure just a static directory, but in other situations,
    additional configuration items may appear here. The URL component `/static` is
    made to refer to a location on the file-system relative to `nocontent.py` by concatenating
    to the `current_dir` determined earlier. Again we use a function from Python's
    `os.path` module, `os.path.join()`, to create a file path in a platform-independent
    manner.
  prefs: []
  type: TYPE_NORMAL
- en: The `static` directory contains all jQuery and jQuery UI files we will need
    for this application along with all CSS files and images to style the application.
    In this example, without real content there are no additional files besides the
    ones belonging to the jQuery and jQuery UI libraries, but if we needed them, we
    could have placed them here.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If we would like CherryPy to listen on a different port, we should indicate
    this in the global configuration. This can be done by preceding the call to `cherrypy.quickstart()`
    with `cherrypy.config.update({'server.socket_port':8088})`. CherryPy has a rich
    palette of configuration options and can even be instructed to read its configuration
    from files. A good starting point for all the possibilities is [http://www.cherrypy.org/wiki/ConfigAPI](http://www.cherrypy.org/wiki/ConfigAPI).
  prefs: []
  type: TYPE_NORMAL
- en: 'We still have to implement a `Root` class to provide CherryPy with an object
    instance that may act as the root of the document hierarchy that CherryPy may
    serve. This class should actually be defined before we can create an instance
    to pass to the `quickstart()` method, but I wanted to concentrate on how to start
    the server first before concentrating on producing content:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter2/nocontent.py**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This `Root` class contains a single class variable `content` that holds the
    HTML code we will serve. We will examine it in detail in the next section. This
    HTML is generated by the `index()` method and passed to the HTTP server that in
    its turn will pass it on to the requesting browser.
  prefs: []
  type: TYPE_NORMAL
- en: It is **exposed** to CherryPy by the `@cherrypy.expose` decorator (highlighted).
    Only exposed methods will be called by CherryPy to produce content. In the default
    configuration, CherryPy will map a URL of the form `/name` to a method called
    `name()`. A URL containing just a forward slash */* will map to a method called
    `index()`, just like the one we defined here. This means we have now configured
    CherryPy to deliver dynamic content when the user directs his browser to `http://127.0.0.1:8080/`
    (and he may even omit the final slash as CherryPy effectively ignores a trailing
    slash by default).
  prefs: []
  type: TYPE_NORMAL
- en: Note that we let `index()` return the contents of a single string variable but
    we could have returned just about anything, making this a truly dynamic way of
    producing content.
  prefs: []
  type: TYPE_NORMAL
- en: 'Who serves what: an overview'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Serving an application from a mixture of dynamic and static content may quickly
    become confusing. It might help to form a clear picture early on of the relations
    between components, of data streams, and directory structures used. This builds
    on the general picture sketched in [Chapter 1](ch01.html "Chapter 1. Choosing
    Your Tools") and will get extended in each chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Almost all applications in this book are served from the same directory structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Who serves what: an overview](img/3746OS_02_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The top-level directory contains one or more Python files that you can execute
    and that will start a CherryPy server. Those Python files implement the server-side
    of an application. They may import additional modules from the same top-level
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: The top-level directory also contains a subdirectory called `static`. It holds
    several JavaScript files, including the jQuery and jQuery UI libraries and any
    additional plugins. It also contains a directory called `css` that contains one
    or more subdirectories with additional CSS stylesheets and images for jQuery UI
    themes.
  prefs: []
  type: TYPE_NORMAL
- en: Note that although our applications are served by a web server, there are no
    HTML files to be seen because all HTML content is generated dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: 'From an application point of view, the best way to comprehend a web application
    is to see the application as distributed. Some of its code (in our case Python)
    runs on the server, while other code (JavaScript) runs in the browser. Together,
    they make up the complete application as visualized in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Who serves what: an overview](img/3746OS_02_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Pop quiz serving content with CherryPy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We made the choice to serve our content from the `index()` method so users could
    get the content by referring to the URL ending in just a slash (/). But what if
    we would like our content to be accessed by referring to a URL like [http://127.0.0.1/content?](http://127.0.0.1/content?)
    What would have to change?
  prefs: []
  type: TYPE_NORMAL
- en: 'HTML: separating form and content'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Almost always, it is a good idea to separate form and content. This enables
    us to concentrate on the logical structure of the information we want to present
    and makes it easier to change the appearance of the data later. This even allows
    for applying themes in a maintainable way.
  prefs: []
  type: TYPE_NORMAL
- en: The structure of our data is laid down in the HTML we deliver to the browser.
    To be more precise, the structural data can be found within the`<body>` element,
    but the`<head>` element of the HTML contains important information as well. For
    example, references to stylesheets and JavaScript libraries that will be used
    to style the appearance of the data and enhance the user interaction.
  prefs: []
  type: TYPE_NORMAL
- en: In the following code, we use a`<link>` element to refer to a CSS stylesheet
    from a theme we downloaded from the jQuery UI website (highlighted). In this example,
    we do not actually use this stylesheet and nor are the jQuery and jQuery UI libraries
    included in the`<script>` elements, but this example shows how to refer to those
    libraries from the HTML we produce, and in the following examples, we will see
    that this is also the spot where we refer to any additional JavaScript libraries
    that we will create ourselves. The actual content is enclosed in the highlighted`<div>`
    element.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Time for action a unit convertor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Serving just a piece of text isn''t very useful, so our next step is to add
    some HTML content and enhance the display and functionality with JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to the same directory where `nocontent.py` could be found.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Double-click the file `unitconvertor.py`, CherryPy console will again open in
    a text window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `http://localhost:8080` in the address bar of your browser (or click refresh
    if it is still open on that address). You will now see a small unit convertor:![Time
    for action a unit convertor](img/3746_2_3.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can enter any number (with an optional fraction) in the text input on the
    left and after selecting the units to convert from and to, pressing the **convert**
    button will present you with the converted number on the right.
  prefs: []
  type: TYPE_NORMAL
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The basic structure of our web application hasn't changed. The content we deliver
    is different but that hardly changes the Python code we need to deliver it. The
    actual content, that is the HTML we deliver when the `index()` function is invoked,
    does differ as it has to define the`<form>` elements that our unit convertor consists
    of and we want to execute some JavaScript as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'HTML: form-based interaction'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The`<head>` portion of the HTML doesn't have to be changed as it already refers
    to the stylesheet and JavaScript libraries we want to use. However, we do have
    to change the`<body>` element to contain the structural elements that make up
    our unit convertor.
  prefs: []
  type: TYPE_NORMAL
- en: The unit convertor is structured as a`<form>` element (highlighted). It contains
    two drop-down lists to select the units to convert, both implemented with`<select>`
    elements, and a text`<input>` element where the user can enter a number. A second
    text`<input>` element is used to display the result of the conversion. This one
    is set to read only as it is not meant to receive input from the user. The final
    element is a`<button>` that the user may click to initiate the conversion.
  prefs: []
  type: TYPE_NORMAL
- en: You may have noticed that the`<form>` element lacks an `action` attribute. This
    is intentional as there is no interaction with a server. The conversion that happens
    when the user clicks the button is completely implemented in JavaScript. This
    JavaScript is included (and executed) in the final script element (highlighted).
    We will examine this script in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'JavaScript: using jQuery UI widgets'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Screen elements or **widgets** are essential to let the end user interact with
    you application. These widgets might be simple buttons that initiate some action
    when the user clicks them or more complex widgets like drop-down boxes, radio
    buttons, or even little calendars that let you pick a date. The jQuery UI library
    provides a large number of predefined and easy to configure widgets, and so our
    next step is to use jQuery UI to let the button in our conversion application
    react to a click of the mouse and initiate the unit conversion.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action conversion using unitconverter.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`unitconverter.js` contains the necessary JavaScript code to do the actual
    conversion. It starts with the definition of a conversion map, a dictionary holding
    the conversion factors for any conversion we want to define. We restrict ourselves
    to conversions from inches to centimeters and vice versa, but additional conversion
    factors can easily be added.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The highlighted line in the previous code is our first encounter with the jQuery
    and jQuery UI libraries and deserves some close attention. The `$("button")` part
    selects all`<button>` elements on the page. In this case, it will be just a single
    one. This`<button>` element is converted to a button widget from the jQuery UI
    library with the `button()` method. This is a simple widget that styles an element
    as a recognizable button that will be easy to theme and customize.
  prefs: []
  type: TYPE_NORMAL
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What actually happens once the user clicks the button is defined by the anonymous
    function we pass as a **click handler** to the button element with the `click()`
    method. This anonymous function is called each time the user clicks the button.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing this handler does is retrieve the contents of the text`<input>`
    element with a `name` attribute equal to **from** with `$("input[name='from']").val()`.
    Next, it retrieves the currently selected units from both`<select>` elements.
  prefs: []
  type: TYPE_NORMAL
- en: If those units are not the same, it fetches the conversion factor from the conversion
    map with the concatenated units as a key. The result of the conversion is calculated
    by multiplying the conversion factor and the contents of the`<input>` element.
    The content we retrieve of any`<input>` element is always returned as a string,
    therefore we have to use the built-in JavaScript function `parseFloat()` to interpret
    it as a floating point number. If both units are equal, the result is simply the
    same as the input value.
  prefs: []
  type: TYPE_NORMAL
- en: The calculated result is stored in the text`<input>` element with a `name` attribute
    of `to`. Note that even though this element has a read-only attribute to prevent
    the user from entering any text, we can still alter its content within a script.
  prefs: []
  type: TYPE_NORMAL
- en: Pop quiz adding an icon to a button
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A button with just simple text might be appropriate for many applications but
    it would look much better, if it showed an appropriate icon as well. Knowing that
    the button widget is highly configurable, how would you add an icon to your button?
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero adding a dynamic title
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The HTML we served in the `nocontent.py` example was simply the contents of
    a class variable, so not really dynamic! What all would we have to do if we wanted
    to serve HTML containing a`<title>` element that shows the current date?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Hint: A`<title>` element should be contained inside the`<head>` element. So
    instead of returning all the HTML in one go, you could rewrite the Python code
    to return HTML composed of three parts: The first and last parts are pieces of
    static HTML and the middle part is a dynamically generated string representing
    a`<title>` element containing a date. That date could be obtained from Python''s
    `asctime()` function found in the standard `time` module.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A possible implementation can be found in the file `nocontenttitle.py`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: jQuery selectors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: jQuery selectors pop up in many locations and in a sense they are the focus
    of any JavaScript program that uses the jQuery library. A complete overview is
    out of the scope of this book (for that, refer to the appendix for some books
    on jQuery with extensive examples or check jQuery's documentation section on [http://docs.jquery.com/Main_Page](http://docs.jquery.com/Main_Page),
    especially the part on selectors) but basically jQuery allows us to select any
    element or set of elements in a CSS 3-compliant fashion in a cross browser compatible
    way. In other words, it works even in browsers that do not yet support CSS 3.
  prefs: []
  type: TYPE_NORMAL
- en: 'To give some idea of what is possible, some examples are given next, all of
    them assume an HTML document containing the following markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'To select all`<li>` elements: `$("li")`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To select just the first`<li>` element: `$("li:first")`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To select the`<li>` element with the class `highlight: $(".highlight")`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To select the`<div>` with an id equal to `footer: $("#footer")`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The jQuery function (often represented by the alias `$)` returns a jQuery object
    that refers to the collection of matched elements. A jQuery object has many methods
    to manipulate the elements in this collection. For example, `$("li").addClass("red-background")`
    adds the red-background class to all`<li>` elements.
  prefs: []
  type: TYPE_NORMAL
- en: The jQuery UI library extends the available methods even further by adding functionality
    to change elements to standardized widgets. That is why in our example `$("button").button()`
    alters the appearance of our button element to the stylized button widget that
    jQuery UI provides.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our example application also shows another important jQuery concept: **chaining**.
    Most jQuery and jQuery UI methods return the selection they operated on. That
    way, it is easy to call multiple methods on the same selection. In our example,
    `$("button").button()` returns the selected button elements after transforming
    them into button widgets, which allows us to chain the click method to define
    mouse-click behavior by writing `$("button").button().click(…)`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'CSS: applying a jQuery UI theme to other elements'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The last line in `unitconverter.js` shows how we can style any element in the
    same manner as the standard jQuery UI widgets. This is accomplished, in this case,
    by selecting all elements contained in the`<form>` element with `$("form *")`
    and then adding the `ui-widget` class with the `addClass()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Any element adorned with the `ui-widget` class will receive the same styling
    as any jQuery UI widget. In our case, this is visible in the font and colors used
    in the `input` and `select` elements. Even if we change the theme this change
    will be uniformly applied. There are more predefined classes available to allow
    for a more fine grained control and we will encounter those when we create our
    own jQuery UI plugin in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to grasp the effect of one of the predefined jQuery UI classes
    to an element. Classes in themselves don't change the way elements are displayed
    but the jQuery UI framework associates various CSS style elements with the predefined
    classes. When the classes associated with an element change, the browser checks
    again which style elements to apply, effecting an immediate style change.
  prefs: []
  type: TYPE_NORMAL
- en: It is also possible to directly alter CSS styles associated with an element.
    However, defining styles for a certain class and altering the class makes it easier
    to maintain a consistent look without having to resort to individual style components
    for each and every element that you want to change.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero adding zebra stripes to a table
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An often required feature when styling HTML tables is to render the rows of
    tables with an alternating background color.
  prefs: []
  type: TYPE_NORMAL
- en: Because jQuery allows us to use CSS 3-compliant selectors and add to an elements
    `class` attribute with the `.addClass()` method, this is now accomplished easily
    even in the browsers that do not support CSS 3.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given the following sample HTML, what JavaScript should be added to the last`<script>`
    element to render the background of all even rows in light gray? (Hints: CSS 3
    has an `:even` selector and when you add a class to an element with jQuery, any
    CSS styles applicable to that class are re-evaluated).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check `zebra.html` to see a solution (It is included with the sample code for
    [Chapter 2](ch02.html "Chapter 2. Creating a Simple Spreadsheet"). Open the file
    in your browser to see the effect):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The result will look something like this in the browser (note that elements
    are numbered starting at zero, so maybe the result is not what you expected):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Have a go hero adding zebra stripes to a table](img/3746_2_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Time for action converting a unit convertor into a plugin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Re-using one of the many well designed jQuery UI widgets is good as it saves
    us development and maintenance time but the true power of the jQuery UI framework
    is the manner in which it enables us to devise completely new widgets that merge
    seamlessly with the rest of the framework and are indistinguishable in their use
    from the standard widgets. To illustrate what is possible, let''s implement our
    unit converter again, but this time as a jQuery plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to the directory containing the example code for [Chapter 2](ch02.html "Chapter 2. Creating
    a Simple Spreadsheet").
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Double-click the file `unitconverter2.py`, the CherryPy console will again open
    in a window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `http://localhost:8080` in the address bar of your browser (or click refresh
    if it is still open on that address). You will now see a slightly restyled unit
    converter:![Time for action converting a unit convertor into a plugin](img/3746_2_5.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The interaction with this new unit converter is exactly the same as our previous
    one.
  prefs: []
  type: TYPE_NORMAL
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Instead of structuring a widget with a`<form>` element containing a number
    of additional elements, we now take a simpler approach. We will design a reusable
    unit converter widget that can be inserted into any`<div>` element. Our HTML backbone
    becomes much simpler now, as its body will just contain a single`<div>` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The first highlighted line includes the JavaScript file that contains the new
    implementation of the unit converter. We refer to the plugin defined in this file
    in the JavaScript code near the end of the`<body>` element (last highlighted line).
    This script refers to the`<div>` element to which we want to add a unit converter
    by its id (in this case `#example)` and apply the `unitconvertor()` method.
  prefs: []
  type: TYPE_NORMAL
- en: As we will see when we look at the JavaScript code that implements our converter
    plugin, `unitconverter()` takes an option object as its single argument. This
    option object may contain any number of keys defining additional conversion factors
    for this instance of the plugin. In this case, we pass additional information
    to allow for conversion from miles to kilometers, and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: Pop quiz adding conversions to a unitconverter instance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What would the JavaScript look like when we want to add a unit converter plugin
    with the possibility of converting from cubic feet to liters?
  prefs: []
  type: TYPE_NORMAL
- en: 'JavaScript: creating a jQuery UI plugin'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All jQuery UI plugins are defined in the same way by adding a new function to
    the `fn` attribute of the `jQuery` object (the object we mostly refer to by its
    alias `$)`. In `unitconverter2.js`, this is exactly what we do, as it is seen
    in the first line of the following code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next thing we do is merge any options passed to the plugin with defaults
    (highlighted). jQuery provides an `extend()` method that merges the attributes
    of any number of objects and returns the first one. As we do not want to overwrite
    the default options that we have defined in `$.fn.unitconverter.conversion_map`,
    we pass it an empty object. This object will receive the default attributes and
    any attributes defined in the `options` object, overwriting the ones with a name
    that is the same. This set of merged attributes is stored in the `cmap` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The conversion factors are referred to by keys of the form `unit1_unit2`. To
    construct two drop-down selectors from the keys, we iterate over all these keys
    and use JavaScript''s `split()` method to retrieve the individual units (highlighted).
    These are then stored in the `from` and `to` arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The next step is to construct the HTML needed by the plugin to present to the
    user. The structure is similar to the handcrafted one used in the previous example,
    a`<form>` with`<input>` and`<select>` elements, and a`<button>`. The`<form>` element
    is adorned with a random id attribute. This way we may refer to it later even
    if there is more than one unit converter present on the page.
  prefs: []
  type: TYPE_NORMAL
- en: 'The`<select>` elements contain a number of`<option>` elements that are created
    by retrieving the unit names stored in the `from` and `to` arrays one-by-one with
    the `pop()` method. The first of these options is selected by default (highlighted).
    The HTML code is then passed to the `append()` method of `this. this` is a variable
    that is available to the function implementing the plugin that contains the selected
    elements the plugin is applied to, in our example the`<div>` element with the
    `#example` id:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The randomly generated id for the form element now comes in handy to select
    just the`<button>` element within the form we are currently constructing and convert
    it to a button: we construct a suitable selector by concatenating relevant parts
    with `"#"+id+" button`".'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that it is perfectly valid to include other plugins or widgets within
    a custom plugin. This time we choose to construct a slightly different looking
    button with just an icon and no text by passing an appropriate options object.
    From the numerous icons shipped with jQuery UI, we choose the one that represents
    the function of the button best: `ui-icon-refresh` (highlighted).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The conversion that happens when the user clicks the button is implemented
    by a function that we will encounter shortly and that is passed by the button
    object (available to the `click()` method as the `this` variable) and the merged
    map of conversion factors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The finishing touch is to style our widget in a consistent manner. jQuery provides
    us with a `css()` method that allows us to directly manipulate the style attributes
    of any element. We first deal with a layout matter: we apply a `float:left` style
    to the`<form>` element to make sure it doesn''t fill the page completely, but
    shrink/wraps itself around the elements it contains:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We then copy a number of background style attributes from the`<button>` element
    to the`<form>` element to give the`<form>` element a look that is consistent with
    the theme applied to the standard button widget. Other style elements from the
    theme like font face and font size are applied to the form element by adding the
    `ui-widget` class (highlighted). We end by returning the `this` variable (which
    in our example contains the`<div>` element we selected, but now with the`<form>`
    element we just added to it). This allows for chaining additional jQuery methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Of course, we still need to define a function that does the actual conversion
    when the button of the unit converter is clicked. It differs slightly from the
    previous implementation.
  prefs: []
  type: TYPE_NORMAL
- en: The `convert()` function is passed both the`<button>` element that is clicked
    and a map with conversion factors. The`<form>` element enclosing the button is
    determined with the `parent()` method and stored in the `form` variable.
  prefs: []
  type: TYPE_NORMAL
- en: The input value we want to convert is retrieved from the`<input>` element with
    a `name` attribute equal to `from`. We can find this specific element by selecting
    all children of the`<form>` element stored in `form` and filtering these children
    by passing a suitable selector to the `.children()` method (highlighted).
  prefs: []
  type: TYPE_NORMAL
- en: 'In a similar way, we determine which option is selected in the two`<select>`
    elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'What is left is the actual conversion. If the conversion units are not equal,
    we retrieve the conversion factor from the map (highlighted) and then multiply
    it by the contents of the`<input>` element interpreted as a floating point number.
    If the input can''t be interpreted as a floating point number or there wasn''t
    a suitable conversion factor in the map, the result of the multiplication is a
    `NaN` (Not a Number) and we signal that fact by placing an error text in the result.
    However, we convert the result to a number with four decimal digits with JavaScript''s
    `toFixed()` method if everything goes well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '`unitconverter2.py` concludes by defining an object with defaults:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Pop quiz changing option defaults
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If we would:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a unitconvertor to a <div> element with an ID #first.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the possibility of converting from cubic feet to liters to the default conversion
    map.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'And finally, add a unitconverter to a <div> element with an id #last.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The code would look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: If we would execute the preceding code, which <div> element(s) would get a unitconverter
    with the added conversion possibility?
  prefs: []
  type: TYPE_NORMAL
- en: 'The div with the #first ID'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The div with the #last ID'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Both
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Designing a spreadsheet application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our goal for this chapter was to be able to present the user with a simple
    spreadsheet application and we are nearly there. We know how to serve HTML and
    we saw how we can implement a custom jQuery UI widget, so let''s apply that knowledge
    to designing a spreadsheet plugin. First let''s see how it will look:'
  prefs: []
  type: TYPE_NORMAL
- en: Time for action serving a spreadsheet application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Go to the directory containing the example code for [Chapter 2:](ch02.html "Chapter 2. Creating
    a Simple Spreadsheet")
  prefs: []
  type: TYPE_NORMAL
- en: Double-click the file `spreadsheet.py`, the now familiar CherryPy console will
    open in a text window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `http://localhost:8080` in the address bar of your browser (or click refresh
    if it is still open on that address). You will now see a simple spreadsheet application:![Time
    for action serving a spreadsheet application](img/3746_2_6.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You can click on any cell to edit its formula. You should not start a formula
    with an equal sign: **42, D2+19** and **"text**" (including the double quote marks)
    are examples of valid formulas. In fact, any JavaScript expression is valid.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The spreadsheet application served to the end user consists of two major parts,
    HTML to structure the spreadsheet and some JavaScript to provide interaction.
    We look at each of these in turn.
  prefs: []
  type: TYPE_NORMAL
- en: 'HTML: keeping it simple'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The HTML we need for our spreadsheet is nearly identical to the one for the
    unit converter. The highlighted lines in the following code show the differences.
    `spreadsheet.js` contains the definition of the plugin and the final`<script>`
    element inserts an 8x10 spreadsheet into the `#example` div. Converting a`<div>`
    element to a fully functional spreadsheet widget is just as simple as converting
    to the standard button widget!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'JavaScript: creating a spreadsheet plugin'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The file `spreadsheet.js` contains all JavaScript code needed to implement a
    reusable spreadsheet widget. The spreadsheet is very similar to our unit converter
    from a jQuery perspective although the actual JavaScript to implement the user
    interaction is somewhat more involved. Again our plugin is a function that is
    associated with jQuery's `fn` attribute as it can be seen in the very first line
    in the following code, where we define our widget with the name `sheet`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next we merge the default options for the sheet plugin (defined at the end
    of the file) with the options passed to the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to create a table that will represent our spreadsheet. We
    create this`<table>` element with a number of associated classes: its very own
    `sheet` class to make it easily recognizable as a sheet plugin once created, a
    `ui-helper-reset` class that will cause suitable CSS to be applied by jQuery to
    reset any unwanted default styling added by the browser and finally a `ui-widget`
    class that will cause the selected theme to be applied. Then we create the table
    contents step-by-step by adding the needed HTML to a variable `t` in incremental
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The table contains a`<thead>` element that will be styled as a `ui-widget-header`.
    It contains a single row of`<th>` elements. These`<th>` elements contain the column
    label, a capital letter that we construct from the column index with the `fromCharCode()`
    method (highlighted):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The body of the table consists of a`<tbody>` element containing a number of
    rows with`<td>` elements. The first`<td>` element of each row contains the row
    label (a number) and will be styled as a `ui-widget-header` just like the column
    labels. The regular cells, that is the ones that will contain our formulas and
    values, will belong to the class `ui-widget-content` to style them in an appropriate
    manner. These cells will also belong to a class `cell` to make them easy to distinguish
    when we add additional functionality to them (highlighted).
  prefs: []
  type: TYPE_NORMAL
- en: There is initially no content in such a cell except for a`<span>` element that
    will contain the formula and that will be styled as `ui-helper-hidden`, rendering
    the formula invisible. The value of the evaluated formula will be stored both
    as text content in the`<td>` element (side-by-side with the`<span>` element) and
    as a global variable with a name equal to the name of the cell. A global variable
    in this context is a named attribute of the top-level `window` object defined
    by the browser that may be accessed as `window[name]`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Storing the value of a cell in a global variable as well allows us to use any
    JavaScript expression as the formula in a cell because we can now refer to the
    value of any other cell by name. `A1+B3*9`, for example will be a perfectly valid
    expression because `A1` and `B3` will be defined as global variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The HTML for the table we created in the `t` variable is then inserted into
    the jQuery selection that we applied the `sheet()` method with the `.append()`
    method of the `this` object. The `this` object is available to any function defining
    a plugin and holds the current jQuery selection.
  prefs: []
  type: TYPE_NORMAL
- en: To edit a cell, we will employ the jEditable plugin. This plugin will take care
    of the user interaction when the user clicks a cell to edit its content. To do
    this it needs functions to get and set the contents of a cell.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The jEditable plugin we use here is included in the example code distributed
    with this chapter. The latest version can be obtained from Mika Tuupola''s website:
    [http://www.appelsiini.net/projects/jeditable](http://www.appelsiini.net/projects/jeditable).
    It comes with a pretty comprehensive set of documentation. Turning a`<td>` element
    into something that changes into an editable textbox when the user clicks on it
    with a mouse, is as simple as selecting the element and invoking the `editable()`
    method. For example, `$(".editable").editable("[http://www.example.com/save](http://www.example.com/save)")`
    will render any element with the `editable` class into an editable textbox once
    clicked and will send the edited contents to the URL passed as the first parameter
    to the `editable()` method. The jEditable plugin comes with a host of options
    and we will encounter a few of them when we employ the jEditable plugin to do
    the editing of the spreadsheet cells.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to define a function that will be invoked by jEditable for extracting
    the content of the element. This function will require two arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: The element we are editing (a`<td>` element in our example).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The original settings passed to the jEditable plugin. Those settings we ignore
    for now.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The`<td>` elements are structured in such a way that the formula itself is stored
    in a (hidden) span element. The `getvalue()` function then must get access to
    this`<span>` element first before it can obtain the formula.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, we convert the`<td>` element first to a jQuery object (highlighted)
    and then filter the elements it contains to just elements with a class of `formula`.
    This amounts to just the`<span>` element whose text is the formula we are after:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The corresponding `setvalue()` function is used by jEditable to store the edited
    formula again in the`<td>` element. When called this function is passed two arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: The edited content of the element.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The original settings passed to the jEditable plugin and its code is quite complicated
    because storing the formula is not the only thing it has to do. It must also calculate
    the result of the formula and update any cells that depend on the updated cell.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The cell we are editing (that is the`<td>` element) is available as the `this`
    variable. We stored the cell index as its `id` attribute so we retrieve that one
    first (highlighted). The `value` argument that was passed to the `setvalue()`
    function is the edited formula.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we use JavaScript syntax for these formulas, we can simply call JavaScript''s
    `eval()` function to calculate the value of the formula. We have to store the
    result in global variables with the name of the cell as well to make it reusable
    by other cells. Note that these global variables are just attributes of the `window`
    object in the context of the browser so assigning a value to such an attribute
    is just what we do inside the `if … else …` clause. If the result of evaluating
    the formula was undefined in some way (for example, because of an error) we set
    the result to the string`''#undef''` to signal that situation to the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: After we have evaluated the formula of the current cell and stored its result
    we must now recalculate all other cells because they may depend on the contents
    of the cell we just changed.
  prefs: []
  type: TYPE_NORMAL
- en: 'We do affect this by selecting all cells in the sheet and applying a function
    to each of them (highlighted). If we are looking at a different cell than the
    one just changed (something we determine by comparing their `id` attributes),
    we recalculate the formula contained in its`<span>` element. If the result is
    different from the previous value stored for a cell we set the change variable
    to true. We repeat the whole procedure until nothing is changed or we repeated
    ourselves more often than there are cells in the sheet, at which point we must
    have a circular reference somewhere, something we indicate to the user by setting
    the value of the cell to a suitable text. This is certainly not the most efficient
    method to recalculate a spreadsheet, nor is it a failsafe method to detect all
    circular references but it works well enough:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The purpose of defining functions to set and get a value from a`<td>` element
    was to be able to apply the jEditable plugin to every cell. This we do in the
    final lines of our `sheet` plugin. We find all children with a `cell` class (highlighted)
    and invoke an anonymous function on each of them.
  prefs: []
  type: TYPE_NORMAL
- en: This function first applies the jEditable plugin on the element by invoking
    the `editable()` method with a reference to our `setvalue()` function as the first
    argument and an options object as the second argument. The `type` attribute marks
    this editable element as a text element (and not, for example, a multiline text
    area element), whereas setting `onblur` to `cancel` indicates that on clicking
    outside the cell when editing will revert the content to its original. The `data`
    attribute points to our `getvalue()` function to indicate to the plugin how to
    get the value that we want to edit.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second thing the function does is applies CSS style attributes to each
    cell. In this case a fixed `width` and the `border-collapse` attribute will make
    sure that the border between cells is just as wide as the border on outlying cells:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '`spreadsheet.js` is completed with the definition of a default options object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Have a go hero adding math functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the spreadsheet we designed, the user may use any JavaScript expression as
    the cell formula. That's fine if we want to use operators like addition (+) or
    multiplication (*), but what if we would like to use, for example, trigonometric
    functions like `sin()` or `cos()?`
  prefs: []
  type: TYPE_NORMAL
- en: 'This is possible by referring to the methods of the built-in JavaScript object
    `Math` (an example would be `Math.sin(A1)+Math.cos(B1))` but prefixing every function
    with `Math` is awkward. Devise a way to make these functions available without
    the `Math` prefix. (Hint: we already saw how to create names in the global namespace
    by assigning to `window[<name>])`.'
  prefs: []
  type: TYPE_NORMAL
- en: A solution can be found in `spreadsheet2.js`. Its effects can be tested by running
    `spreadsheet2.py`.
  prefs: []
  type: TYPE_NORMAL
- en: The missing parts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In designing and building a spreadsheet application we saw that it is relatively
    simple to implement quite sophisticated user interaction by making full use of
    the jQuery and jQuery UI libraries and choosing wisely from the wide array of
    available additional plugins like jEditable.
  prefs: []
  type: TYPE_NORMAL
- en: However, although our spreadsheet application was served from the CherryPy server,
    the functionality of the application was limited to client-side activity only.
    For example, there is no possibility to save or load a spreadsheet on the server,
    and neither is there a way to limit the access to our spreadsheet to authorized
    users only. Both requirements depend on ways to store data in a persistent manner
    and dealing with persistence will be the next step on our road to developing web
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have learned a lot in this chapter. Specifically, we covered:'
  prefs: []
  type: TYPE_NORMAL
- en: How to create an environment to develop and deliver our applications. We saw
    how to install Python, CherryPy, and the jQuery and jQuery UI frameworks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The design of a simple spreadsheet application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to configure CherryPy to deliver static and dynamic content.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use standard jQuery UI widgets and third party plugins; specifically,
    the button widget and the jEditable plugin.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The implementation of our own jQuery plugin.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We also discussed how to reuse jQuery UI's concept of `ui-widget` classes to
    style our own widget components in a way that blends seamlessly with jQuery UI's
    themes.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've learned about the client-side of web applications, we're ready
    to tackle server-side issues which is the topic of the next chapter.
  prefs: []
  type: TYPE_NORMAL
