<html><head></head><body>
  <div><div><div><div><div><h1 class="title"><a id="ch14"/>Chapter 14. Deployment</h1></div></div></div><p>So far, we have been working in a development environment, and running our application on the console in 'foreground' mode, so that we can see the output for debugging and confirmation purposes.</p><p>Now that we have a more or less complete application, we may want to deploy it. Even for limited audience testing, we want the deployed application to run in the background. Later on, we probably want to use a full-fledged web server, such as Apache, for serving our application, and maybe others. Finally, for an application that expects lots of traffic and numerous visitors, we might want to balance the load over multiple instances of our application.</p><p>This chapter will discuss how to deploy our application by using the standard paster server. Then we'll find out how to run the application behind Apache, first by using a simple proxy configuration, and then under<code class="literal"> mod_wsgi</code>. Finally, we'll explore how ZEO provides horizontal scalability for our application, and will briefly discuss how to make a site support high traffic loads by adding caching and load balancing into the mix.</p><p>Some specific topics that we will cover include:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Simple deployment with paster</li><li class="listitem" style="list-style-type: disc">Running behind Apache with proxy pass</li><li class="listitem" style="list-style-type: disc">Running behind Apache with<code class="literal"> mod_wsgi</code></li><li class="listitem" style="list-style-type: disc">Setting up a ZEO cluster</li><li class="listitem" style="list-style-type: disc">Caching and load balancing</li></ul></div><div><div><div><div><h1 class="title"><a id="ch14lvl1sec01"/>Moving an application to production mode</h1></div></div></div><p>Before thinking about which web server we will use for our deployment, there is one step that we need to take for every production application. Grok offers a 'developer mode' for the application server, which enables some functionality intended to help developers debug and test their applications more easily.<a id="id492" class="indexterm"/>
</p><p>The most noticeable effect of developer mode is that any changes made to templates are automatically taken into account by the server, without needing to restart. This imposes a penalty on application performance because the server has to poll files to find out if there were any changes made to a template.</p><p>It is recommended that you turn this functionality off when preparing an application for release. Further changes to templates will require a restart, but in web development, any performance gain must be welcomed.</p><p>To turn developer mode off, edit the<code class="literal"> etc/zope.conf.in</code> file that was included in the package that was generated by<code class="literal"> grokproject</code>. Find the line that says<code class="literal"> devmode on</code>, and modify it to look like this:</p><div><pre class="programlisting"># Comment this line to disable developer mode. This should be done in
# production
<strong># devmode on
</strong>
</pre></div><p>By commenting out the line shown in bold, the default will apply, which is for development mode to be off. However, note that this is not the actual configuration file, but a template used to generate it.</p><p>To make the change take effect, rerun the buildout, so that the actual configuration file at<code class="literal"> parts/etc/zope.conf</code> is rewritten. When you next start the application, it will run in production mode.</p></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch14lvl1sec02"/>Running the paster server in the background</h1></div></div></div><p>By far the easiest way of deploying our application is to use the same paster server that we have been using for development throughout the book. The only thing that we need to do is to launch the server in 'daemon' mode, so that our application runs in the background:<a id="id493" class="indexterm"/>
</p><div><pre class="programlisting"><strong>$ bin/paster serve --daemon parts/etc/deploy.ini
</strong>
</pre></div><p>The process will then start in the background. The PID for that process will be stored in the file<code class="literal"> paster.pid</code>, which can be used to get status information for the running server. The<code class="literal"> paster.if</code> filename is assumed by default, by other<code class="literal"> paster serve</code> commands, so for example, to get the process status, you can type:</p><div><pre class="programlisting"><strong>$ bin/paster serve --status parts/etc/deploy.ini
$ Server running in PID 11482
</strong>
</pre></div><p>When we need to stop the server, we use the<code class="literal"> stop-daemon</code> option, as follows:</p><div><pre class="programlisting"><strong>$ bin/paster serve --stop-daemon parts/etc/deploy.ini
</strong>
</pre></div><p>There are a couple of other options that can be useful. We might want the server to be restarted automatically in case, the server dies for whatever reason; that's what the<code class="literal"> monitor-restart</code> option does:<a id="id494" class="indexterm"/>
</p><div><pre class="programlisting"><strong>$ bin/paster serve --daemon --monitor-restart parts/etc/deploy.ini
</strong>
</pre></div><p>Finally, we may prefer to run the server continuously in the background and have it restart automatically when we change some files. This can be accomplished with the<code class="literal"> reload</code> option:</p><div><pre class="programlisting"><strong>$ bin/paster serve --daemon --reload parts/etc/deploy.ini
</strong>
</pre></div><p>This setup could be considered as the minimum Grok deployment architecture, and its parts are shown in the following figure:</p><div><img src="img/7481_14_01.jpg" alt="Running the paster server in the background"/></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch14lvl1sec03"/>Running Grok behind the Apache web server</h1></div></div></div><p>The problem with using the default paster configuration for production is that the URL for our site must include the application name. This might be acceptable in some cases, but almost always it's not good enough. The easiest way to overcome this problem is to put the application behind a web server, such as Apache, and use the powerful URL-rewriting tools available in most web servers to serve our application from any URL that we require.<a id="id495" class="indexterm"/>
</p><p>Also, if our site will be running any other applications besides the one that we have developed, it is usually a good idea to let Apache or some other web server take care of centralizing the requests for multiple applications on the site.</p><div><div><div><div><h2 class="title"><a id="ch14lvl2sec01"/>Using mod_rewrite to serve our application from Apache</h2></div></div></div><p>To set up this configuration, you will need to install the Apache web server, which is available for all platforms. Most Linux distributions will allow you to install it by using their package management tools.<a id="id496" class="indexterm"/>
</p><p>For example, in Ubuntu or Debian, you can simply type:</p><div><pre class="programlisting"><strong>$ sudo apt-get install apache2
</strong>
</pre></div><p>Once you have Apache ready, the next step is to configure it to use the<code class="literal"> mod_rewrite</code> module. Usually, the way to do this is to edit the<code class="literal"> httpd.conf</code> file, which should be available somewhere inside the<code class="literal"> /etc</code> directory of your server, under either the<code class="literal"> apache2</code> or<code class="literal"> httpd</code> subdirectory.</p><p>To load the required modules to make<code class="literal"> mod_rewrite</code> work, the following general configuration is required:</p><div><pre class="programlisting">LoadModule rewrite_module /usr/lib/apache2/modules/mod_rewrite.so
LoadModule proxy_module /usr/lib/apache2/modules/mod_proxy.so
LoadModule proxy_http_module /usr/lib/apache2/modules/mod_proxy_http.so
<strong>ProxyRequests off
</strong>
</pre></div><p>The first three lines load the required modules, and the<code class="literal"> ProxyRequests</code> line makes sure that the server can't be used as an involuntary proxy by third parties. Do not leave this line out.</p><p>Now that the "rewrite" functionality is enabled, we need to create a virtual host that will serve our application's requests. This virtual host will include the "rewrite" rule that will allow our application to be served by Apache. A sample virtual host definition looks like this:</p><div><pre class="programlisting">&lt;VirtualHost *:80&gt;
ServerName grok.example.com
RewriteEngine On
RewriteRule ^/(.*) http://localhost:8080/todo/++vh++http:grok.example.com:80/++/$1 [P,L]
&lt;/VirtualHost&gt;
</pre></div><p>In this simple example, we just set the server name, turn on the rewrite engine, and set up a rewrite rule. Before doing anything else, make sure that the server name is correct.</p><p>The rewrite rule is the important part of the configuration. Apache's<code class="literal"> mod_rewrite</code> uses regular expression syntax for matching the part of a URL that will trigger the rule. In the configuration above, the first part of the rule tells the engine to match any URL that begins with a slash, which of course, will match any URL that will be served by this virtual host.</p><p>In regular expressions, when you enclose a subexpression in parentheses, it means that anything that matches the text inside them has to be saved in a variable. The first expression in parentheses that matches this text is stored in the variable<code class="literal"> $1</code>, the second in<code class="literal"> $2</code>, and so on. In this case, anything after the slash, which is the full path of the request, will be stored in<code class="literal"> $1</code>.<a id="id497" class="indexterm"/>
</p><p>The second part of the rule is dependent on Grok's virtual hosting tools. This will be the URL that will be looked up by the rule in order to get the actual content to be served at the matching location. For virtual hosting, Grok expects the full URL to the application that we are publishing (http://localhost:8080/todo), followed by the special virtual hosting syntax that will include the protocol, server name, and port, which will be used by Grok to translate all of the URLs present in the response, so that every link in it points to the correct host. Notice how, after the Grok<code class="literal"> ++vh++</code> rule, the full path for the request is appended to the end, by using the<code class="literal"> $1</code> variable explained before.</p><p>The third and final part of the rule indicates to Apache that this is a proxy request (P) and that this rule should be the last rule applied, when it matches (L).</p><p>This is all that is needed to set up our application with<code class="literal"> mod_rewrite</code>. To test this, first make sure that the paster process is running and that Apache is using the configuration that we added. Usually, the server is started automatically when it's installed, so you might need to tell it to reload the configuration. In Ubuntu or Debian, the way to do this is:</p><div><pre class="programlisting">$ /etc/init.d/apache2 reload
</pre></div><p>Now you can go to the URL that you defined in the configuration (http://grok.example.com, in our example) and see your application work from behind Apache.<a id="id498" class="indexterm"/>
</p></div><div><div><div><div><h2 class="title"><a id="ch14lvl2sec02"/>Installing and setting up Grok under mod_wsgi</h2></div></div></div><p>Another great option for serving Grok applications behind Apache is<code class="literal"> mod_wsgi</code>, which is an Apache module that serves applications under the WSGI protocol. In this section, we'll learn what WSGI is, and how to set up Apache to serve our application by using the<code class="literal"> mod_wsgi</code> module.</p><div><div><div><div><h3 class="title"><a id="ch14lvl3sec01"/>WSGI: The Python Web Server Gateway Interface</h3></div></div></div><p>WSGI is a Python standard for specifying how web applications can communicate with web servers and application servers. Its objective is to provide a simple interface that can support most interactions between a web server and a web framework (such as Grok).<a id="id499" class="indexterm"/>
</p><p>WSGI also supports "middleware" components that can be used to preprocess or post-process a request. This means that it is used to create Python WSGI tools that "plug" into our applications and perform services such as profiling, error handling, and more.</p><p>Grok can run behind any WSGI server. We'll now look at how to install Grok behind the Apache web server and<code class="literal"> mod_wsgi</code> on a brand new Linux virtual server.</p></div><div><div><div><div><h3 class="title"><a id="ch14lvl3sec02"/>Grok and WSGI</h3></div></div></div><p>For Python web developers, WSGI holds the key to the Python web development future. As there are a number of important web development frameworks, and the power of Python makes it really easy to create new ones quickly, interacting with the best of breed applications developed in multiple frameworks could soon be the best way to create a new Python website.<a id="id500" class="indexterm"/>
</p><p>Until relatively recently, Zope 3 and some of its derived applications, such as Grok, ran the risk of missing the WSGI party, but not anymore. Grok 1.0 is WSGI compatible and can therefore be integrated with the wide range of WSGI-based technologies available in the Python world today.<a id="id501" class="indexterm"/>
</p></div><div><div><div><div><h3 class="title"><a id="ch14lvl3sec03"/>Why use Apache and mod_wsgi for Grok?</h3></div></div></div><p>There are a number of WSGI servers available, but this chapter will focus on using<code class="literal"> mod_wsgi</code>, which is a WSGI adapter module for Apache. There are a number of reasons for this.<a id="id502" class="indexterm"/>
</p><p>First, Apache is the most popular web hosting platform, so there are many web developers and site administrators who are already familiar with it. Grok, for example, has been installed behind Apache for production servers by using<code class="literal"> mod_rewrite</code>.</p><p>Second, there are also lots of Python applications that already run under Apache by using<code class="literal"> mod_python</code>. There are a few WSGI adapters for this module as well, but<code class="literal"> mod_wsgi</code> is written in C code, and has lower memory overhead and better performance than those adapters.</p><p>Also, one of the goals of<code class="literal"> mod_wsgi</code> is to break into the low-cost commodity web hosting market, which would be good for Python, and ultimately for Grok and Zope.</p></div><div><div><div><div><h3 class="title"><a id="ch14lvl3sec04"/>Setting up a clean Linux server</h3></div></div></div><p>In the discussion that follows, we'll use Linux as the operating system because, it's the most popular way to deploy web applications, by far. Ubuntu is the distribution that we'll cover, but these steps apply equally well to any Debian-based distribution. Other distributions use different package managers, and probably other system paths, but you should be able to easily figure out what you need in any case.<a id="id503" class="indexterm"/>
</p><p>We can start with a clean install of a recent version of Ubuntu GNU/Linux. The first step is to install the necessary packages for both the correct Python version (Grok currently requires Python 2.5) and the Apache server.</p><p>Before that, it is necessary to install the required packages for being able to compile and build software using Ubuntu (other distributions usually don't need this). Be aware that both package installation and Apache module additions usually require root access. In the commands block, the prompt with<code class="literal"> $</code> is a user prompt, and the one with<code class="literal"> #</code> is a root prompt that you can have with the command<code class="literal"> sudo -s</code>. In this part, you'll use a root terminal so that you do not have to prefix each command with<code class="literal"> sudo</code>. In the other parts, you'll use a user terminal where you add<code class="literal"> sudo</code> before a command, if you need to execute something as root. You can have one terminal opened as root and another terminal as user.</p><div><pre class="programlisting"><strong>$ sudo -s
# apt-get install build-essential
</strong>
</pre></div><p>Next, install the packages for Python and Apache. As with most packaged Linux distributions, Ubuntu requires a separate install for the development libraries of each piece of software:</p><div><pre class="programlisting"><strong># apt-get install python2.5 python2.5-dev
# apt-get install apache2
</strong>
</pre></div><p>The<code class="literal"> apache2</code> package usually installs<code class="literal"> apache2-mpm-worker</code>, but you may have the other version,<code class="literal"> apache2-mpm-prefork</code>, installed. To check which one is installed, you can execute:</p><div><pre class="programlisting"><strong># dpkg -l|grep apache2
</strong>
</pre></div><p>Next, install the corresponding development package,<code class="literal"> apache2-threaded-dev</code> if<code class="literal"> apache2-mpm-worker</code> is installed, or<code class="literal"> apache2-prefork-dev</code> if<code class="literal"> apache2-mpm-prefork</code> is installed:<a id="id504" class="indexterm"/>
</p><div><pre class="programlisting"><strong># apt-get install apache2-threaded-dev
</strong>
</pre></div><p>Grok uses Python's<code class="literal"> setuptools</code>, so that package is needed as well:</p><div><pre class="programlisting"><strong># apt-get install python-setuptools
</strong>
</pre></div><p>It's possible that the version provided by the Ubuntu package is not the latest. If you want to have more control of the installed version of<code class="literal"> setuptools</code> and want to update it yourself when a new version is available, you can use the following method instead. Download<code class="literal"> setuptools-0.6c9-py2.5.egg</code> manually (or latest version, choose py2.5) and execute the command:</p><div><pre class="programlisting"><strong># sh setuptools-0.6c9-py2.5.egg
</strong>
</pre></div><p>You can later update it with:</p><div><pre class="programlisting"><strong>sudo easy_install-2.5 -U setuptools
</strong>
</pre></div></div><div><div><div><div><h3 class="title"><a id="ch14lvl3sec05"/>Installing and configuring mod_wsgi</h3></div></div></div><p>Now, the server is ready to install<code class="literal"> mod_wsgi</code>. There is a package<code class="literal"> libapache2-mod-wsgi</code> in Ubuntu, but it's recommended that you build the latest version, in part because<code class="literal"> mod_wsgi</code> has to be compiled with the same Python used by Grok. Please remove the<code class="literal"> libapache2-mod-wsgi</code> package if you have installed it previously. We need to get the source directly from the download site, and then build it:<a id="id505" class="indexterm"/>
</p><div><pre class="programlisting"><strong>$ wget http://modwsgi.googlecode.com/files/mod_wsgi-2.6.tar.gz
$ tar xzf mod_wsgi-2.6.tar.gz
$ cd mod_wsgi-2.6
$ ./configure --with-python=/usr/bin/python2.5
$ make
$ sudo make install
</strong>
</pre></div><p>Again, note that it is necessary to compile<code class="literal"> mod_wsgi</code> using the same Python that you will use to run your website. As Grok requires 2.5, the<code class="literal"> --with-python</code> option was used to point to the version of Python that we need.</p><p>Once<code class="literal"> mod_wsgi</code> is installed, the Apache server needs to be told about it. On Apache 2, this is done by adding the load declaration and any configuration directives to the<code class="literal"> /etc/apache2/mods-available/</code> directory.</p><p>The load declaration for the module needs to go in a file named<code class="literal"> wsgi.load</code> (in the<code class="literal"> /etc/apache2/mods-available/</code> directory), which contains only the following line of code:</p><div><pre class="programlisting">LoadModule wsgi_module /usr/lib/apache2/modules/mod_wsgi.so
</pre></div><p>The configuration directives reside in the file named<code class="literal"> wsgi.conf</code> next to<code class="literal"> wsgi.load</code> file. We don't create it now, but it can be useful later to add directives to it, if you have more than one WSGI application to serve.<a id="id506" class="indexterm"/>
</p><p>Then, you have to activate the<code class="literal"> wsgi</code> module with:</p><div><pre class="programlisting"><strong># a2enmod wsgi
</strong>
</pre></div><p>Note that<code class="literal"> a2enmod</code> stands for "apache2 enable mod" an executable that creates the symlink for you. Actually,<code class="literal"> a2enmod wsgi</code> is equivalent to:</p><div><pre class="programlisting"><strong># cd /etc/apache2/mods-enabled
# ln -s ../mods-available/wsgi.load
# ln -s ../mods-available/wsgi.conf # if it exists
</strong>
</pre></div><p>For Apache 1.3, or Apache 2 with an old directory layout, you may need to place the<code class="literal"> LoadModule</code> line and the configuration directives (which you will see later) inside the<code class="literal"> httpd.conf</code> file in your Apache's<code class="literal"> /etc</code> directory. The soft links above will not be necessary in this case.</p></div><div><div><div><div><h3 class="title"><a id="ch14lvl3sec06"/>Configuring a Grok site under mod_wsgi</h3></div></div></div><p>Grok can be installed with<code class="literal"> setuptools</code>, and a Grok site can be easily created by using the included<code class="literal"> grokproject</code> tool. As mentioned before, Grok can run behind any WSGI server, not just the paster server that is used by default. Now that we have a working<code class="literal"> mod_wsgi</code>, we will look at how to run Grok behind it.<a id="id507" class="indexterm"/>
</p></div><div><div><div><div><h3 class="title"><a id="ch14lvl3sec07"/>Getting the to-do application ready for mod_wsgi</h3></div></div></div><p>WSGI applications use entry points to let the WSGI server know how to run the program. The<strong> entry point</strong> is usually a simple Python script that provides a function for calling the application and passing the appropriate initialization file to the server. Some servers, such as the paster server, need only the path to the<code class="literal"> .ini</code> file, which is what we normally use to start up a Grok application. This doesn't mean that there's no entry point script for paster. In fact, the entry point is defined in the<code class="literal"> setup.py</code> file, which is created by<code class="literal"> grokproject</code> when a new project is initialized. Take a look at the last few lines of the file:<a id="id508" class="indexterm"/>
</p><div><pre class="programlisting">[paste.app_factory]
main = grokcore.startup:application_factory
debug = grokcore.startup:debug_application_factory
</pre></div><p>The heading<code class="literal"> paste.app_factory</code> tells the server where to find the factory functions for each section of the<code class="literal"> .ini</code> file. In Grok, a general application factory function is defined in the<code class="literal"> grokcore.startup</code> package, which is what paster uses to start applications.</p><p>However,<code class="literal"> mod_wsgi</code> requires a path to the factory, which would be cumbersome to include in our configuration, because this would mean that it would need to point to a file inside the<code class="literal"> grokcore.startup</code> egg. As eggs include the version number, a simple update could crash our site if the old egg is removed. It would be better to have our own factory defined inside the application package.</p><p>Given that the factory code can be almost identical for different projects, it would be better to have it included automatically when we create the project, to avoid having to re-create the same script every time. Fortunately for us, Grok's use of buildout turns out to be very helpful in this case, as there is a buildout recipe available that creates the WSGI application factory for us.<a id="id509" class="indexterm"/>
</p><p>The recipe is called<code class="literal"> collective.recipe.modwsgi</code>. To use it, simply add a part to the buildout having a name such as<code class="literal"> wsgi_app</code>. The recipe requires two parameters the first being the eggs that have to be made available to the Python process that will run the app under WSGI, and the second being the path to the configuration file that will be used for the site. This last parameter<code class="literal"> value</code> is the usual<code class="literal"> parts/etc/deploy.ini</code> path that we have been using for running the application under paster. That's it. Edit the<code class="literal"> buildout.cfg</code> file's<code class="literal"> parts</code> list as follows:</p><div><pre class="programlisting">parts =
eggbasket
app
i18n
test
mkdirs
zpasswd
zope_conf
site_zcml
zdaemon_conf
wsgi_app
deploy_ini
debug_ini
</pre></div><p>Next, add the following section anywhere in the file:</p><div><pre class="programlisting">[wsgi_app]
recipe = collective.recipe.modwsgi
eggs = ${app:eggs}
config-file = ${buildout:directory}/parts/etc/deploy.ini
</pre></div><p>Note that the<code class="literal"> eggs</code> parameter simply points back to the main egg section defined at the start of the buildout, to avoid repetition.</p><p>When the buildout is run again, we'll find a<code class="literal"> parts/wsgi_app</code> directory (or whichever name we used for the buildout part). Inside that directory, there will be a<code class="literal"> wsgi</code> file that can be used as is by<code class="literal"> mod_wsgi</code> to run the application.<a id="id510" class="indexterm"/>
</p></div><div><div><div><div><h3 class="title"><a id="ch14lvl3sec08"/>Configuring an Apache site to use mod_wsgi</h3></div></div></div><p>The last step is to add a site to the Apache server that uses<code class="literal"> mod_wsgi</code> to serve our application. This is standard<code class="literal"> mod_wsgi</code> configuration; we'll just add the path to the application factory that we created in the previous section.<a id="id511" class="indexterm"/>
</p><p>To set up the virtual host, create a file in the<code class="literal"> /etc/apache2/sites-available</code> directory and call it, for example, "grok". Add the following code to it, assuming your to-do application is at<code class="literal"> /home/cguardia/grok/todo:</code>
</p><div><pre class="programlisting">WSGIPythonHome /usr
WSGIDaemonProcess grok user=cguardia group=cguardia threads=4 maximum-requests=10000
&lt;VirtualHost *:80&gt;
ServerName wsgi.example.com
WSGIScriptAlias /todo /home/cguardia/grok/todo/parts/wsgi_app/wsgi
WSGIProcessGroup grok
WSGIPassAuthorization On
WSGIReloadMechanism Process
SetEnv HTTP_X_VHM_HOST http://wsgi.example.com/todo
&lt;/VirtualHost&gt;
</pre></div><p>This will run<code class="literal"> mod_wsgi</code> in 'daemon' mode, which means that it will launch a number of processes in order to run the configured WSGI application instead of using the Apache process. If you are using virtualenv, the<code class="literal"> site-packages</code> directory of the virtual Python, which is used to run it, needs to be passed in the<code class="literal"> WSGIPythonHome</code> variable. To tell<code class="literal"> mod_wsgi</code> which WSGI application to run, we use the<code class="literal"> WSGIScriptAlias</code> directive, and pass to it the path to the application factory that we created earlier.<a id="id512" class="indexterm"/>
</p><p>Note that we assign a user and group to run the process. It is required that this user has access to the application directory.<a id="id513" class="indexterm"/>
</p><div><div><div><div><h4 class="title"><a id="ch14lvl4sec01"/>The PYTHON_EGG_CACHE directory</h4></div></div></div><p>Note that when the application is started, all of the eggs will be automatically extracted in the<code class="literal"> PYTHON_EGG_CACHE</code> directory, normally<code class="literal"> ~/.python-eggs</code>. This directory depends on the<code class="literal"> HOME</code> environment variable. The<code class="literal"> HOME</code> apache user<code class="literal"> www-data</code> is<code class="literal"> /var/www</code>. You may get the error,<strong> [Errno 13] Permission denied: '/var/www/.python-eggs'</strong> in your<code class="literal"> error.log</code> apache file if you don't configure the user or the<code class="literal"> python-eggs</code> variable in the<code class="literal"> WSGIDaemonProcess</code> directive. You can also add a<code class="literal"> python-eggs</code> parameter to tell<code class="literal"> mod_wsgi</code> to use an alternative directory for the egg cache:<a id="id514" class="indexterm"/>
</p><div><pre class="programlisting">WSGIDaemonProcess grok threads=4 maximum-requests=10000 python-eggs=/tmp/python-eggs
</pre></div><p>In this example, the process belongs to<code class="literal"> www-data</code>. The<code class="literal"> www-data</code> and<code class="literal"> python-eggs</code> cache directory will be<code class="literal"> /tmp/python-eggs</code>.</p></div></div><div><div><div><div><h3 class="title"><a id="ch14lvl3sec09"/>Running the application</h3></div></div></div><p>Once the configuration is ready, we need to enable the site in Apache, because we just created it. This is necessary only for the first time we run it:<a id="id515" class="indexterm"/>
</p><div><pre class="programlisting"><strong>$ sudo a2ensite grok
</strong>
</pre></div><p>This command will create a link from the Apache<code class="literal"> sites-enabled</code> directory to the "grok" site that we just configured, which is enough to make it active. Then, we can start serving our application from Apache by simply reloading the configuration for the server:</p><div><pre class="programlisting"><strong>$ sudo /etc/init.d/apache2 reload
</strong>
</pre></div><p>When you visit the site in a browser (<a class="ulink" href="http://wsgi.example.com/todo">http://wsgi.example.com/todo</a>), you should see the Grok admin UI. You should be able to log in by using the admin login name and password.<a id="id516" class="indexterm"/>
</p></div></div><div><div><div><div><h2 class="title"><a id="ch14lvl2sec03"/>Adding a ZEO server</h2></div></div></div><p>By default,<code class="literal"> mod_wsgi</code> will use a single process to run the application. As this configuration is intended for production use, it may be desirable to have a higher number of processes available to serve the application. The ZODB that Grok uses comes with a server named<strong> Zope Enterprise Object</strong> (ZEO), which allows us to add as many processes to our configuration as our system permits, providing unlimited horizontal scalability. Typically, the recommended number of processes is one for each core in the system's processors. Let's set up a ZEO server and configure the Grok process to connect to it.<a id="id517" class="indexterm"/>
</p><div><div><div><div><h3 class="title"><a id="ch14lvl3sec10"/>Buildout recipe for the ZEO configuration</h3></div></div></div><p>Once again, the easiest way to get ZEO running is to use an existing buildout recipe. This time we'll use the one named<code class="literal"> zc:zodbrecipes</code>. Add a<code class="literal"> zeo_server</code> part to your<code class="literal"> buildout.cfg</code> file, as shown below:<a id="id518" class="indexterm"/>
</p><div><pre class="programlisting">parts =
eggbasket
app
i18n
test
mkdirs
zpasswd
zope_conf
site_zcml
zdaemon_conf
zeo_server
wsgi_app
deploy_ini
debug_ini
</pre></div><p>Next, add a<code class="literal"> zeo_server</code> section as follows:</p><div><pre class="programlisting">[zeo_server]
recipe = zc.zodbrecipes:server
zeo.conf =
&lt;zeo&gt;
address 8100
&lt;/zeo&gt;
&lt;blobstorage 1&gt;
blob-dir ${buildout:directory}/var/blobstorage
&lt;filestorage 1&gt;
path ${buildout:directory}/var/filestorage/Data.fs
&lt;/filestorage&gt;
&lt;/blobstorage&gt;
&lt;eventlog&gt;
level info
&lt;logfile&gt;
path ${buildout:directory}/parts/log/zeo.log
&lt;/logfile&gt;
&lt;/eventlog&gt;
</pre></div><p>This will add the ZEO server, and configure it to listen on port 8100. The rest of the configuration is pretty much boilerplate, so just copy it to new projects when you need ZEO there. The<code class="literal"> blobstorage</code> section sets up a file storage with blob handling enabled; the<code class="literal"> logfile</code> sections tells the server where to store the log file.<a id="id519" class="indexterm"/>
</p><p>Next, we need the buildout to add scripts for starting and stopping ZEO. This is easily accomplished by adding the<code class="literal"> ZODB3</code> egg to our app section:</p><div><pre class="programlisting">[app]
recipe = zc.recipe.egg
eggs = gwsgi
z3c.evalexception&gt;=2.0
Paste
PasteScript
PasteDeploy
ZODB3
</pre></div></div><div><div><div><div><h3 class="title"><a id="ch14lvl3sec11"/>Configuring the ZEO client</h3></div></div></div><p>Currently, the Grok application that we are using is working with the regular Zope server. To use ZEO, we need to change the configuration to connect to the server at port 8100. Fortunately, the required changes already come inside the regular<code class="literal"> zope.conf</code> file that is created inside the Grok project, so we only need to uncomment those lines. Uncomment the following lines inside the<code class="literal"> zope.conf.in</code> file in the<code class="literal"> etc</code> directory of your Grok project:<a id="id520" class="indexterm"/>
</p><div><pre class="programlisting"># Uncomment this if you want to connect to a ZEO server instead:
&lt;zeoclient&gt;
server localhost:8100
storage 1
# ZEO client cache, in bytes
cache-size 20MB
# Uncomment to have a persistent disk cache
#client zeo1
&lt;/zeoclient&gt;
</pre></div><p>The important line here is the one with the ZEO server address. In this case, we are using the same host as the Grok application, and the port that we defined in our ZEO configuration in the previous section.<a id="id521" class="indexterm"/>
</p></div><div><div><div><div><h3 class="title"><a id="ch14lvl3sec12"/>Launching the ZEO server</h3></div></div></div><p>After running the buildout again, we'll be ready to start the ZEO server in the background. To do this, we have to run only the server script that was automatically created for us. The name of the script is the same as the name of the part in the buildout where we configured the server:<a id="id522" class="indexterm"/>
</p><div><pre class="programlisting"><strong>$ bin/zeo_server start
</strong>
</pre></div><p>Our Grok application is now running! To stop it, you can use the following command:</p><div><pre class="programlisting"><strong>$ bin/zeo_server stop
</strong>
</pre></div></div><div><div><div><div><h3 class="title"><a id="ch14lvl3sec13"/>Augmenting the number of processes</h3></div></div></div><p>Recall that we mentioned earlier that<code class="literal"> mod_wsgi</code> runs the application in a single process by default. To really take advantage of ZEO, we want to have more processes available. We need to make a small addition to our<code class="literal"> mod_wsgi</code> Apache virtual host configuration for that. Change the<code class="literal"> WSGIDaemonProcess</code> line, near the top, to look like the following code:<a id="id523" class="indexterm"/>
</p><div><pre class="programlisting">WSGIDaemonProcess grok user=cguardia group=cguardia processes=2 threads=4 maximum-requests=10000
</pre></div><p>Remember to reload the Apache configuration to be able to see the new setup in action. In this example, we'll have two processes running, with four threads each. By using ZEO and<code class="literal"> mod_wsgi</code>, we now have a scalable site.</p></div></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch14lvl1sec04"/>More scalability: Adding caching and load balancing</h1></div></div></div><p>The configurations that we just discussed will be enough for most kinds of sites. However, there are times when a site is required to handle high traffic loads, and measures need to be taken to ensure that it will not go down under pressure.</p><div><div><div><div><h2 class="title"><a id="ch14lvl2sec04"/>Caching proxies</h2></div></div></div><p>One very effective thing that can be done is to add a caching proxy in front of the Apache server. A<strong> caching proxy</strong> reduces bandwidth and improves response times by saving a copy of the most frequently used pages of a site and serving that copy directly on further requests, rather than connecting to the server again.<a id="id524" class="indexterm"/>
</p><p>Two very popular caching proxies are Squid (<a class="ulink" href="http://www.squid-cache.org">http://www.squid-cache.org</a>) and Varnish (<a class="ulink" href="http://www.varnish-cache.org">http://www.varnish-cache.org</a>). A detailed discussion of how to set these up is beyond the objectives of this chapter, but, interestingly, there are buildout recipes available for setting them up automatically. Take a look at the Python Package Index and see how these recipes help to build and configure a caching proxy. For Squid, there's<code class="literal"> plone.recipe.squid</code>
 (<a class="ulink" href="http://pypi.python.org/pypi/plone.recipe.squid/">http://pypi.python.org/pypi/plone.recipe.squid/</a>), and for Varnish, the corresponding<code class="literal"> plone.recipe.varnish</code> (<a class="ulink" href="http://pypi.python.org/pypi/plone.recipe.varnish">http://pypi.python.org/pypi/plone.recipe.varnish</a>).</p></div><div><div><div><div><h2 class="title"><a id="ch14lvl2sec05"/>Load balancers</h2></div></div></div><p>A<strong> load balancer</strong> sits in front of two or more instances of an application and distributes the incoming requests evenly between them. This is a very powerful solution when you can have several machines serving the application.<a id="id525" class="indexterm"/>
</p><p>There are several load balancers available as open source; for example, Apache itself has a load-balancing module. However, one of the most popular load balancers to use with Zope Toolkit-based applications is "Pound" (<a class="ulink" href="http://www.apsis.ch/pound/">http://www.apsis.ch/pound/</a>).</p><p>Pound does a lot more than just distributing the load. It can keep session information and send a request from the same origin browser to the same destination server used on the first request. Pound can also distribute requests among servers according to its URL. Finally, it can act as a failover server, because it's smart enough to notice when a backend server fails and will stop sending requests to it until the server recovers.</p><p>There is, of course, a buildout recipe available for setting up Pound, appropriately named<code class="literal"> plone.recipe.pound</code> (<a class="ulink" href="http://pypi.python.org/pypi/plone.recipe.pound">http://pypi.python.org/pypi/plone.recipe.pound</a>).</p></div><div><div><div><div><h2 class="title"><a id="ch14lvl2sec06"/>A high-traffic architecture for Grok</h2></div></div></div><p>Now that we know about some mechanisms for improving our application's performance, it can be helpful to visualize how the different parts relate to each other. In our case, a good way of organizing a system to support high traffic loads would be to put a caching proxy such as Varnish at the front and configure it to pass requests to the Pound load balancer.</p><p>Pound would be configured to distribute the load among a number of separate servers, each one of them running Apache configured with<code class="literal"> mod_wsgi</code>, and running several processes that would talk to a number of ZEO clients running our Grok application. Using this architecture, depicted in the following figure, we could scale our application to deal with very high traffic.</p><div><img src="img/7481_14_02.jpg" alt="A high-traffic architecture for Grok"/></div></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch14lvl1sec05"/>Summary</h1></div></div></div><p>This chapter discussed how to approach application deployment, and explored various possibilities for deploying our sample application, from a simple setup to a scalable configuration with ZEO.</p><p>We have reached the end of our journey with Grok. Hopefully, you'll find that Grok is a good addition to your web arsenal, and will think about how its strengths could help you reach your goals whenever you need to develop a web application. In this Internet age, it's very easy to reach out and communicate with people who can help us with many kinds of technologies. Grok developers and users are no exception, so please do not hesitate to ask for advice, by using Grok's mailing lists or IRC channel. We'll be glad to help you, and will be happy that you took Grok out for a spin.</p></div></div>
</body></html>