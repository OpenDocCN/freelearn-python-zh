<html><head></head><body>
<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch07" class="calibre1"/>Chapter 7. The Command Pattern – Encapsulating Invocation</h1></div></div></div><p class="calibre6">In the previous chapter, we started with an introduction to behavioral design patterns. You learned the concept of <code class="email">Observers</code> and discussed the Observer design pattern. We understood the concept of the Observer design pattern with a UML diagram and also learned how it's applied in the real world with the help of Python implementations. We discussed the pros and cons of the Observer pattern. You also learned about the Observer pattern with an FAQ section and summarized the discussion at the end of the chapter.</p><p class="calibre6">In this chapter, we will talk about the Command design pattern. Like the Observer pattern, the Command pattern falls under the hood of Behavioral patterns. We will get introduced to the Command design pattern and discuss how it is used in software application development. We will work with a sample use case and implement it in Python v3.5.</p><p class="calibre6">In this chapter, we will cover the following topics in brief:</p><div><ul class="itemizedlist"><li class="listitem">An introduction to Command design patterns</li><li class="listitem">The Command pattern and its UML diagram</li><li class="listitem">A real-world use case with the Python v3.5 code implementation</li><li class="listitem">The Command pattern's pros and cons</li><li class="listitem">Frequently asked questions</li></ul></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_1"><a id="ch07lvl1sec53" class="calibre1"/>Introducing the Command pattern</h1></div></div></div><p class="calibre6">As we<a id="id180" class="calibre1"/> saw in the previous chapter, Behavioral patterns focus on the responsibilities that an object has. It deals with the interaction among objects to achieve larger functionality. The Command pattern is a behavioral design pattern in which an object is used to encapsulate all the information needed to perform an action or trigger an event at a later time. This information includes the following:</p><div><ul class="itemizedlist"><li class="listitem">The method name</li><li class="listitem">An object that owns the method</li><li class="listitem">Values for method parameters</li></ul></div><p class="calibre6">Let's<a id="id181" class="calibre1"/> understand the pattern with a very simple software example. Consider the case of an installation wizard. A typical wizard may contain multiple phases or screens that capture a user's preferences. While the user browses through the wizard, s/he makes certain choices. Wizards are typically implemented with the Command pattern. A wizard is first launched with an object called the <code class="email">Command</code> object. The preferences or choices made by the user in multiple phases of the wizard are then stored in the <code class="email">Command</code> object. When the user clicks on the <strong class="calibre7">Finish</strong> button on the last screen of the wizard, the <code class="email">Command</code> object runs an <code class="email">execute()</code> method, which considers all the stored choices and runs the appropriate installation procedure. Thus, all the information regarding the choices are encapsulated in an object that can be used later to take an action.</p><p class="calibre6">Another easy example is that of the printer spooler. A spooler can be implemented as a <code class="email">Command</code> object that stores information such as the page type (<em class="calibre13">A5</em>-<em class="calibre13">A1</em>), portrait/landscape, collated/non-collated. When the user prints something (say, an image), the spooler runs the <code class="email">execute()</code> method on the <code class="email">Command</code> object and the image is printed with the set preferences.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch07lvl1sec54" class="calibre1"/>Understanding the Command design pattern</h1></div></div></div><p class="calibre6">The<a id="id182" class="calibre1"/> Command pattern works with the following terms—<code class="email">Command</code>, <code class="email">Receiver</code>, <code class="email">Invoker</code>, and <code class="email">Client</code>:</p><div><ul class="itemizedlist"><li class="listitem">A <code class="email">Command</code> object knows about the <code class="email">Receiver</code> objects and invokes a method of the <code class="email">Receiver</code> object.</li><li class="listitem">Values for parameters of the receiver method are stored in the <code class="email">Command</code> object</li><li class="listitem">The invoker knows how to execute a command</li><li class="listitem">The client creates a <code class="email">Command</code> object and sets its receiver</li></ul></div><p class="calibre6">The main intentions of the Command pattern are as follows:</p><div><ul class="itemizedlist"><li class="listitem">Encapsulating a request as an object</li><li class="listitem">Allowing the parameterization of clients with different requests</li><li class="listitem">Allowing to save the requests in a queue (we will talk about this later in the chapter)</li><li class="listitem">Providing an object-oriented callback</li></ul></div><p class="calibre6">The Command pattern can be used in the following multiple scenarios:</p><div><ul class="itemizedlist"><li class="listitem">Parameterizing objects depending on the action to be performed</li><li class="listitem">Adding actions to a queue and executing requests at different points</li><li class="listitem">Creating a structure for high-level operations that are based on smaller operations</li></ul></div><p class="calibre6">The following <a id="id183" class="calibre1"/>Python code implements the Command design pattern. We talked about the example of the wizard earlier in the chapter. Consider that we want to develop a wizard for installation or, popularly, installer. Typically, an installation implies the copying or moving of files in the filesystem based on the choices that a user makes. In the following example, in the client code, we start by creating the <code class="email">Wizard</code> object and use the <code class="email">preferences()</code> method that stores the choices made by the user during various screens of the wizard. On the wizard, when <strong class="calibre7">Finish</strong> button is clicked, the <code class="email">execute()</code> method is called. The <code class="email">execute()</code> method picks up the preference and starts the installation:</p><div><pre class="programlisting">class Wizard():
    
    def __init__(self, src, rootdir):
        self.choices = []
        self.rootdir = rootdir
        self.src = src
    
    def preferences(self, command):
        self.choices.append(command)
    
    def execute(self):
        for choice in self.choices:
            if list(choice.values())[0]:
                print("Copying binaries --", self.src, " to ", self.rootdir)
            else:
                print("No Operation")


if __name__ == '__main__':
  ## Client code
  wizard = Wizard('python3.5.gzip', '/usr/bin/')
  ## Users chooses to install Python only
  wizard.preferences({'python':True})
  wizard.preferences({'java':False})
  wizard.execute()</pre></div><p class="calibre6">The <a id="id184" class="calibre1"/>output of the preceding code is as follows:</p><div><img src="img/00023.jpeg" alt="Understanding the Command design pattern" class="calibre14"/></div><p class="calibre15"> </p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch07lvl2sec40" class="calibre1"/>A UML class diagram for the Command pattern</h2></div></div></div><p class="calibre6">Let's <a id="id185" class="calibre1"/>now understand more about the Command pattern with the help of the following UML diagram.</p><p class="calibre6">As we discussed in the previous paragraph, the Command pattern has these main participants: the <code class="email">Command</code>, <code class="email">ConcreteCommand</code>, <code class="email">Receiver</code>, <code class="email">Invoker</code>, and <code class="email">Client</code>. Let's put these in a UML diagram and see how the classes look:</p><div><img src="img/00024.jpeg" alt="A UML class diagram for the Command pattern" class="calibre14"/></div><p class="calibre15"> </p><p class="calibre6">As we look at the UML diagram, you'll realize that there are five main participants in this pattern:</p><div><ul class="itemizedlist"><li class="listitem"><code class="email">Command</code>: This declares an interface to execute an operation</li><li class="listitem"><code class="email">ConcreteCommand</code>: This defines a binding between the <code class="email">Receiver</code> object and action</li><li class="listitem"><code class="email">Client</code>: This creates a <code class="email">ConcreteCommand</code> object and sets its receiver</li><li class="listitem"><code class="email">Invoker</code>: This asks <code class="email">ConcreteCommand</code> to carry out the request</li><li class="listitem"><code class="email">Receiver</code>: This knows how to perform the operations associated with carrying out the request</li></ul></div><p class="calibre6">The flow<a id="id186" class="calibre1"/> is straightforward. The client asks for a command to be executed. The invoker takes the command, encapsulates it, and places it in a queue. The <code class="email">ConcreteCommand</code> class is in charge of the requested command and asks the receiver to perform the given action. The following code example is to understand the pattern with all the participants involved:</p><div><pre class="programlisting">from abc import ABCMeta, abstractmethod

class Command(metaclass=ABCMeta):
    def __init__(self, recv):
        self.recv = recv
    
    def execute(self):
        pass


class ConcreteCommand(Command):
    def __init__(self, recv):
        self.recv = recv
    
    def execute(self):
        self.recv.action()


class Receiver:
    def action(self):
        print("Receiver Action")


class Invoker:
    def command(self, cmd):
        self.cmd = cmd
    
    def execute(self):
        self.cmd.execute()


if __name__ == '__main__':
    recv = Receiver()
    cmd = ConcreteCommand(recv)
    invoker = Invoker()
    invoker.command(cmd)
    invoker.execute()</pre></div></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch07lvl1sec55" class="calibre1"/>Implementing the Command pattern in the real world</h1></div></div></div><p class="calibre6">We will <a id="id187" class="calibre1"/>take up an example of the stock exchange (much talked about in the Internet world) to demonstrate the implementation of the Command pattern. What happens in a stock exchange? You, as a user of the stock exchange, create orders to buy or sell stocks. Typically, you don't buy or sell them; it's the agent or broker who plays the intermediary between you and the stock exchange. The agent is responsible for taking your request to the stock exchange and getting the work done. Imagine that you want to sell a stock on Monday morning when the exchange opens up. You can still make the request to sell stock on Sunday night to your agent even though the exchange is not yet open. The agent then queues this request to be executed on Monday morning when the exchange is open for the trading. This presents a classical case for the Command pattern.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch07lvl2sec41" class="calibre1"/>Design considerations</h2></div></div></div><p class="calibre6">Based on<a id="id188" class="calibre1"/> the UML diagram, you learned that the Command pattern has four main participants—<code class="email">Command</code>, <code class="email">ConcreteCommand</code>, <code class="email">Invoker</code>, and <code class="email">Receiver</code>. For the preceding scenario, we should create an <code class="email">Order</code> interface that defines the order that a client places. We should define <code class="email">ConcreteCommand</code> classes to buy or sell a stock. A class also needs to be defined for the stock exchange. We should define the <code class="email">Receiver</code> class that will actually execute the trade and the agent (known as the invoker) that invokes the order and gets it executed by the receiver.</p><p class="calibre6">Let's develop an application in Python v3.5 and implement the preceding use case. We start with the <code class="email">Command</code> object, <code class="email">Order</code>:</p><div><ul class="itemizedlist"><li class="listitem">The <code class="email">Command</code> object is represented by the <code class="email">Order</code> class</li><li class="listitem"><code class="email">Order</code> provides you with an interface (Python's abstract base class) so that <code class="email">ConcreteCommand</code> can implement the behavior</li><li class="listitem">The <code class="email">execute()</code> method is the abstract method that needs to be defined by the <code class="email">ConcreteCommand</code> classes to execute the <code class="email">Order</code> class</li></ul></div><p class="calibre6">The following code represents the abstract class <code class="email">Order</code> and the abstract method <code class="email">execute()</code>:</p><div><pre class="programlisting">from abc import ABCMeta, abstractmethod

class Order(metaclass=ABCMeta):
    
    @abstractmethod
    def execute(self):
        pass</pre></div><p class="calibre6">We have<a id="id189" class="calibre1"/> also developed certain classes that represent <code class="email">ConcreteCommand</code>:</p><div><ul class="itemizedlist"><li class="listitem">In this case, we have two main concrete classes: <code class="email">BuyStockOrder</code> and <code class="email">SellStockOrder</code> that implement the <code class="email">Order</code> interface</li><li class="listitem">Both the <code class="email">ConcreteCommand</code> classes use the object of the stock trading system so that they can define appropriate actions for the trading system</li><li class="listitem">The <code class="email">execute()</code> method of each of these <code class="email">ConcreteCommand</code> classes uses the stock trade object to execute the actions to buy and sell</li></ul></div><p class="calibre6">Let's now look at concrete classes that implement the interface:</p><div><pre class="programlisting">class BuyStockOrder(Order):
    def __init__(self, stock):
        self.stock = stock
    
    def execute(self):
        self.stock.buy()


class SellStockOrder(Order):
    def __init__(self, stock):
        self.stock = stock
    
    def execute(self):
        self.stock.sell()</pre></div><p class="calibre6">Now, let's<a id="id190" class="calibre1"/> talk about the stock trading system and how it's implemented:</p><div><ul class="itemizedlist"><li class="listitem">The <code class="email">StockTrade</code> class represents the <code class="email">Receiver</code> object in this example</li><li class="listitem">It defines multiple methods (actions) to execute the orders placed by <code class="email">ConcreteCommand</code> objects</li><li class="listitem">The <code class="email">buy()</code> and <code class="email">sell()</code> methods are defined by the receiver which are called by <code class="email">BuyStockOrder</code> and <code class="email">SellStockOrder</code> respectively to buy or sell the stock in the exchange</li></ul></div><p class="calibre6">Let's take a look at the <code class="email">StockTrade</code> class:</p><div><pre class="programlisting">class StockTrade:
    def buy(self):
        print("You will buy stocks")
    
    def sell(self):
        print("You will sell stocks")</pre></div><p class="calibre6">Another<a id="id191" class="calibre1"/> part of the implementation is the invoker:</p><div><ul class="itemizedlist"><li class="listitem">The <code class="email">Agent</code> class <a id="id192" class="calibre1"/>represents the invoker.</li><li class="listitem">Agent is the intermediary between the client and <code class="email">StockExchange</code> and executes the orders placed by the client.</li><li class="listitem">Agent defines a data member, <code class="email">__orderQueue</code> (a list), that acts as a queue. Any new orders placed by the client are added to the queue.</li><li class="listitem">The <code class="email">placeOrder()</code> method of Agent is responsible for queuing the orders and also executing the orders.</li></ul></div><p class="calibre6">The following code depicts the <code class="email">Agent</code> class which performs the role of <code class="email">Invoker</code>:</p><div><pre class="programlisting">class Agent:
    def __init__(self):
        self.__orderQueue = []
    
    def placeOrder(self, order):
        self.__orderQueue.append(order)
        order.execute()</pre></div><p class="calibre6">Let us now put all the above classes into perspective and look at how the client is implemented:</p><div><ul class="itemizedlist"><li class="listitem">The client first sets its receiver, the <code class="email">StockTrade</code> class</li><li class="listitem">It creates orders to buy and sell stocks with <code class="email">BuyStockOrder</code> and <code class="email">SellStockOrder</code> (<code class="email">ConcreteCommand</code>) that executes the action on <code class="email">StockTrade</code></li><li class="listitem">The invoker object is created by instantiating the <code class="email">Agent</code> class</li><li class="listitem">The <code class="email">placeOrder()</code> method of <code class="email">Agent</code> is used to get the orders that the client places</li></ul></div><p class="calibre6">The following is the code for the client is implemented:</p><div><pre class="programlisting">if __name__ == '__main__':
    #Client
    stock = StockTrade()
    buyStock = BuyStockOrder(stock)
    sellStock = SellStockOrder(stock)
    
    #Invoker
    agent = Agent()
    agent.placeOrder(buyStock)
    agent.placeOrder(sellStock)</pre></div><p class="calibre6">The<a id="id193" class="calibre1"/> following is the output of the preceding code:</p><div><img src="img/00025.jpeg" alt="Design considerations" class="calibre14"/></div><p class="calibre15"> </p><p class="calibre6">There are multiple ways in which the Command pattern is used in software applications. We will discuss two specific implementations that are very relevant to the cloud applications:</p><div><ul class="itemizedlist"><li class="listitem">Redo or rollback operations:<div><ul class="itemizedlist1"><li class="listitem">While implementing<a id="id194" class="calibre1"/> the rollback or redo operations, developers can do two different things.</li><li class="listitem">These are to create a snapshot in the filesystem or memory, and when asked for a rollback, revert to this snapshot.</li><li class="listitem">With the Command pattern, you can store the sequence of commands, and when asked for a redo, rerun the same set of actions.</li></ul></div></li><li class="listitem">Asynchronous task execution:<div><ul class="itemizedlist1"><li class="listitem">In distributed systems, we <a id="id195" class="calibre1"/>often need the facility to perform the asynchronous execution of tasks so that the core service is never blocked in case of more requests.</li><li class="listitem">In the Command pattern, the invoker object can maintain a queue of requests and send these tasks to the <code class="email">Receiver</code> object so that they can be acted on independent of the main application thread.</li></ul></div></li></ul></div></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch07lvl1sec56" class="calibre1"/>Advantages and disadvantages of Command patterns</h1></div></div></div><p class="calibre6">The<a id="id196" class="calibre1"/> Command pattern has the following advantages:</p><div><ul class="itemizedlist"><li class="listitem">It decouples the classes that invoke the operation from the object that knows how to execute the operation</li><li class="listitem">It allows you to create a sequence of commands by providing a queue system</li><li class="listitem">Extensions to add a new command is easy and can be done without changing the existing code</li><li class="listitem">You can also define a rollback system with the Command pattern, for example, in the Wizard example, we could write a rollback method</li></ul></div><p class="calibre6">The<a id="id197" class="calibre1"/> following are the disadvantages of the Command pattern:</p><div><ul class="itemizedlist"><li class="listitem">There are a high number of classes and objects working together to achieve a goal. Application developers need to be careful developing these classes correctly.</li><li class="listitem">Every individual command is a <code class="email">ConcreteCommand</code> class that increases the volume of classes for implementation and maintenance.</li></ul></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch07lvl1sec57" class="calibre1"/>Frequently asked questions</h1></div></div></div><p class="calibre6">Q1. Can there be no <code class="email">Receiver</code> and <code class="email">ConcreteCommand</code> implement execute method?</p><p class="calibre6">A: Yes, it <a id="id198" class="calibre1"/>is definitely possible to do so. Many software applications use the Command pattern in this way too. The only thing to note here is the interaction between the invoker and receiver. If the receiver is not defined, the level of decoupling goes down; moreover, the facility to parameterize commands is lost.</p><p class="calibre6">Q2. What data structure do I use to implement the queue mechanism in the invoker object?</p><p class="calibre6">A: In the stock exchange example that we studied earlier in the chapter, we used a list to implement the queue. However, the Command pattern talks about a stack implementation that is really helpful in the case of redo or rollback development.</p></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch07lvl1sec58" class="calibre1"/>Summary</h1></div></div></div><p class="calibre6">We began the chapter by understanding the Command design pattern and how it is effectively used in software architecture.</p><p class="calibre6">We looked at how Command design patterns are used to encapsulate all the information needed to trigger an event or action at a later point in time.</p><p class="calibre6">You also learned the pattern with a UML diagram and sample code implementation in Python v3.5 along with the explanation.</p><p class="calibre6">We also covered an FAQ section that would help you get more ideas on the pattern and its possible advantages/disadvantages.</p><p class="calibre6">We will now take up other behavioral design patterns in the chapters to come.</p></div></body></html>