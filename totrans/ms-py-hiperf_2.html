<html><head></head><body><div class="chapter" title="Chapter&#xA0;2.&#xA0;The Profilers"><div class="titlepage"><div><div><h1 class="title"><a id="ch02"/>Chapter 2. The Profilers</h1></div></div></div><p>In the previous chapter, we covered the basics of profiling and understood its importance. You learned how it will help the development process if we incorporate the practice of profiling into the cycle of development. We also went over some good profiling practices.</p><p>Finally, we covered some theory about the different execution times our program can have. In this chapter, we'll use the first part (the part about profiling). Then, with the help of two specific Python profilers (<code class="literal">cProfile</code> and <code class="literal">line_profilers</code>), we'll start putting into practice some theory that you have learned.</p><p>In this chapter, we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Some basic information about each profiler</li><li class="listitem" style="list-style-type: disc">How to download and install each profiler</li><li class="listitem" style="list-style-type: disc">Use cases examples with different options</li><li class="listitem" style="list-style-type: disc">Differences and similarities between both profilers</li></ul></div><div class="section" title="Getting to know our new best friends: the profilers"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec16"/>Getting to know our new best friends: the profilers</h1></div></div></div><p>After all the theory <a id="id74" class="indexterm"/>and generic examples from the previous chapter, it is time for some real Python. So, let's begin with two of the most known and used Python profilers: <code class="literal">cProfile</code> and <code class="literal">line_profiler</code>. They will help us profile our code in two different ways.</p><p>On <a id="id75" class="indexterm"/>one hand, we<a id="id76" class="indexterm"/> have <code class="literal">cProfile</code> (<a class="ulink" href="https://docs.python.org/2/library/profile.html#module-cProfile">https://docs.python.org/2/library/profile.html#module-cProfile</a>), It comes by default <a id="id77" class="indexterm"/>with Python since version 2.5 and is the recommended profiler for most use cases. At least that is what the official Python documentation <a id="id78" class="indexterm"/>says <a id="id79" class="indexterm"/>about it. On the <a id="id80" class="indexterm"/>other hand, we have <code class="literal">line_profiler</code> (<a class="ulink" href="https://github.com/rkern/line_profiler">https://github.com/rkern/line_profiler</a>), which is not an official part of the Python programming language, but it's a well-known profiler out there.</p><p>Let's go over both of them in more detail.</p><div class="section" title="cProfile"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec24"/>cProfile</h2></div></div></div><p>Like I've already<a id="id81" class="indexterm"/> mentioned, <code class="literal">cProfile</code> comes by default with the standard Python interpreter (<code class="literal">cPython</code>) since version 2.5. Other versions, such as PyPy, don't have it. It is a deterministic profiler. It provides a set of APIs that allow the developers to gather information about the execution of Python programs, more specifically, about the CPU time used by each function. It also provides other details, such as the number of times a function was called.</p><p>It exclusively measures CPU time and pays no attention to memory consumption and other memory related stats. Nonetheless, it is a great starter point, since most of the times, if we're trying to optimize code, this type of analysis will provide an immediate set of optimization candidates.</p><p>There is no need for installation, since it's part of the language already. To use it, all you have to do is to import the <code class="literal">cProfile</code> package.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note03"/>Note</h3><p>A deterministic profiler<a id="id82" class="indexterm"/> is just another name for an event-based profiler (check out the previous chapter for more details). This means that that this profiler will be aware of every function call, return statement, and other events during the execution of our code. It will also measure everything that happens during that time (unlike the statistical profiler we saw in the previous chapter).</p></div></div><p>Here is a very simple<a id="id83" class="indexterm"/> example taken from Python's documentation:</p><div class="informalexample"><pre class="programlisting">import cProfile
import re
cProfile.run('re.compile("foo|bar")')</pre></div><p>The preceding code outputs the following text:</p><div class="informalexample"><pre class="programlisting">    197 function calls (192 primitive calls) in 0.002 seconds

Ordered by: standard name

ncalls  tottime  percall  cumtime  percall filename:lineno(function)
     1    0.000    0.000    0.001    0.001 &lt;string&gt;:1(&lt;module&gt;)
     1    0.000    0.000    0.001    0.001 re.py:212(compile)
     1    0.000    0.000    0.001    0.001 re.py:268(_compile)
     1    0.000    0.000    0.000    0.000 sre_compile.py:172(_compile_charset)
     1    0.000    0.000    0.000    0.000 sre_compile.py:201(_optimize_charset)
     4    0.000    0.000    0.000    0.000 sre_compile.py:25(_identityfunction)
   3/1    0.000    0.000    0.000    0.000 sre_compile.py:33(_compile)</pre></div><p>From this output, the <a id="id84" class="indexterm"/>following information can be gathered:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The first line tells us that 197 function calls were monitored, and out of them, 192 were primitive calls, which means no recursion was involved.</li><li class="listitem" style="list-style-type: disc"><code class="literal">ncalls</code> reports the number of calls to the function. If there are two numbers in this column, it means there was recursion. The second one is the number of primitive calls, and the first one is the total number of calls. This number can be helpful to identify the possible bugs (unexpected high numbers) or possible inline expansion points.</li><li class="listitem" style="list-style-type: disc"><code class="literal">tottime</code> is the total time spent inside the function (excluding the time spent doing subcalls to other functions). This particular information can help the developer find long running loops that could be optimized.</li><li class="listitem" style="list-style-type: disc"><code class="literal">percall</code> is simply the quotient of <code class="literal">tottime</code> divided by <code class="literal">ncalls</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">cumtime</code> is the cumulative time spent inside the function including the time spent in subfunctions (this includes recursive calls as well). This number could help identify higher level errors, such as those in the selection of the algorithm.</li><li class="listitem" style="list-style-type: disc"><code class="literal">percall</code> is the quotient of <code class="literal">cumtime</code> divided by primitive calls.</li><li class="listitem" style="list-style-type: disc"><code class="literal">filename:lineno(function)</code> provides the file name, line number, and function name of the analyzed function.</li></ul></div></div><div class="section" title="A note about limitations"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec25"/>A note about limitations</h2></div></div></div><p>There is no such<a id="id85" class="indexterm"/> thing as the invisible profiler. This means that even in the case of <code class="literal">cProfile</code>, which has a very small overhead, it still adds an overhead to our code. On every event that is triggered, there is some lag between the time that the event actually happens and that time that the profiler gets to query the state of the internal clock. At the same time, there is some lag between the moment the program counter leaves the profiler's code and goes back into the user's code to continue with the execution.</p><p>Adding to the fact, that as any piece of data inside a computer, the internal clock has a set precision, and any measurement that is smaller than that precision will be lost. That being said, the developer needs to have a special consideration when profiling code with a high number of recursive calls or, in particular cases, when a function calls many other functions, since<a id="id86" class="indexterm"/> that error can accumulate and begin to be significant.</p></div><div class="section" title="The API provided"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec26"/>The API provided</h2></div></div></div><p>The <code class="literal">cProfile</code> profiler <a id="id87" class="indexterm"/>provides a set of methods that will help the developer gather <a id="id88" class="indexterm"/>statistics in different contexts:</p><div class="informalexample"><pre class="programlisting">run(command, filename=None, sort=-1)</pre></div><p>This classic method used in the preceding example gathers statistics about the execution of the command. After that, it calls the following function:</p><div class="informalexample"><pre class="programlisting">exec(command, __main__.__dict__, __main__.__dict__)</pre></div><p>If no file name is given, it'll create a new instance of <code class="literal">stats</code> (more on this class in a minute). Here is the preceding same example, but using the extra parameters:</p><div class="informalexample"><pre class="programlisting">import cProfile
import re
cProfile.run('re.compile("foo|bar")', 'stats', 'cumtime')</pre></div><p>If you run the preceding code, you'll notice that nothing gets printed out. However, if you inspect the content of the folder, you'll notice a new file, called <code class="literal">stats</code>. If you try to open that file, you won't be able to understand its meaning because it was saved using a binary format. In a few minutes, we'll see how to read that information and manipulate it to create our own reports:</p><div class="informalexample"><pre class="programlisting">runctx(command, globals, locals, filename=None)</pre></div><p>This method is very similar to the preceding one. The only difference is that it also receives the <code class="literal">globals</code> and <code class="literal">locals</code> dictionaries for the command-line string. After that, it executes the following function:</p><div class="informalexample"><pre class="programlisting">exec(command, globals, locals)</pre></div><p>It gathers profiling statistics just like <code class="literal">run</code> does. Let's see an example of the main difference between <code class="literal">run</code> and <code class="literal">runctx</code>.</p><p>Let's stick to <code class="literal">run</code> and write the following code:</p><div class="informalexample"><pre class="programlisting">import cProfile
def runRe():
    import re 
    cProfile.run('re.compile("foo|bar")')
runRe()</pre></div><p>What we would actually get when running the code is the following error message:</p><div class="informalexample"><pre class="programlisting">Traceback (most recent call last): 
  File "cprof-test1.py", line 7, in &lt;module&gt; 
    runRe() ...
  File "/usr/lib/python2.7/cProfile.py", line 140, in runctx 
    exec cmd in globals, locals 
  <span class="strong"><strong>File "&lt;string&gt;", line 1, in &lt;module&gt;</strong></span> 
NameError: name 're' is not defined </pre></div><p>The <code class="literal">re</code> module<a id="id89" class="indexterm"/> is not found by the <code class="literal">run</code> method because as we saw earlier<a id="id90" class="indexterm"/> that <code class="literal">run</code> calls the <code class="literal">exec</code> function with the <code class="literal">__main__.__dict__</code> as parameters.</p><p>Now, let's use <code class="literal">runctx</code> in the following manner:</p><div class="informalexample"><pre class="programlisting">import cProfile
def runRe():
    import re 
    cProfile.runctx('re.compile("foo|bar")', None, locals())
runRe()</pre></div><p>Then the output would change into a valid one as follows:</p><div class="informalexample"><pre class="programlisting">         194 function calls (189 primitive calls) in 0.000 seconds 
  Ordered by: standard name 
   ncalls  tottime  percall  cumtime  percall filename:lineno(function) 
        1    0.000    0.000    0.000    0.000 &lt;string&gt;:1(&lt;module&gt;) 
        1    0.000    0.000    0.000    0.000 re.py:188(compile) 
        1    0.000    0.000    0.000    0.000 re.py:226(_compile) 
        1    0.000    0.000    0.000    0.000 sre_compile.py:178(_compile_charset) 
        1    0.000    0.000    0.000    0.000 sre_compile.py:207(_optimize_charset) 
        4    0.000    0.000    0.000    0.000 sre_compile.py:24(_identityfunction) 
      3/1    0.000    0.000    0.000    0.000 sre_compile.py:32(_compile) 
        1    0.000    0.000    0.000    0.000 sre_compile.py:359(_compile_info) 
        2    0.000    0.000    0.000    0.000 sre_compile.py:472(isstring) 
        1    0.000    0.000    0.000    0.000 sre_compile.py:478(_code) 
        1    0.000    0.000    0.000    0.000 sre_compile.py:493(compile) 
        5    0.000    0.000    0.000    0.000 sre_parse.py:126(__len__) 
       12    0.000    0.000    0.000    0.000 sre_parse.py:130(__getitem__) 
        7    0.000    0.000    0.000    0.000 sre_parse.py:138(append) 
      3/1    0.000    0.000    0.000    0.000 sre_parse.py:140(getwidth) 
        1    0.000    0.000    0.000    0.000 sre_parse.py:178(__init__) 
       10    0.000    0.000    0.000    0.000 sre_parse.py:182(__next) 
        2    0.000    0.000    0.000    0.000 sre_parse.py:195(match) 
        8    0.000    0.000    0.000    0.000 sre_parse.py:201(get) 
        1    0.000    0.000    0.000    0.000 sre_parse.py:301(_parse_sub) 
        2    0.000    0.000    0.000    0.000 sre_parse.py:379(_parse) 
        1    0.000    0.000    0.000    0.000 sre_parse.py:67(__init__) 
        1    0.000    0.000    0.000    0.000 sre_parse.py:675(parse) 
        3    0.000    0.000    0.000    0.000 sre_parse.py:90(__init__) 
        1    0.000    0.000    0.000    0.000 {_sre.compile} 
       15    0.000    0.000    0.000    0.000 {isinstance} 
    38/37    0.000    0.000    0.000    0.000 {len} 
        2    0.000    0.000    0.000    0.000 {max} 
       48    0.000    0.000    0.000    0.000 {method 'append' of 'list' objects} 
        1    0.000    0.000    0.000    0.000 {method 'disable' of '_lsprof.Profiler' objects} 
        1    0.000    0.000    0.000    0.000 {method 'get' of 'dict' objects} 
        1    0.000    0.000    0.000    0.000 {method 'items' of 'dict' objects} 
        8    0.000    0.000    0.000    0.000 {min} 
        6    0.000    0.000    0.000    0.000 {ord} </pre></div><p>The <code class="literal">Profile(timer=None, timeunit=0.0, subcalls=True, builtins=True)</code> method returns <a id="id91" class="indexterm"/>a class, providing more control to the developer during the <a id="id92" class="indexterm"/>profiling process than <code class="literal">run</code> and <code class="literal">runctx</code> do.</p><p>The <code class="literal">timer</code> parameter is a custom function that can be used to measure time in a different way than the one provided by default. It must be a function returning a number representing the current time. If the developer needs a custom function, it should be as fast as possible to lower overhead and avoid problems of calibration (please refer to <span class="emphasis"><em>A note about limitations</em></span> section a few pages back).</p><p>If the number returned by the timer is an integer, the <code class="literal">timeunit</code> parameter specifies the multiplier that represents the duration of each unit of time. For example, if the returned value is in milliseconds, then <code class="literal">timeunit</code> would be <code class="literal">.001</code>.</p><p>Let's also take a look at the methods provided by the returned class:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">enable()</code>: This starts collecting profiling data</li><li class="listitem" style="list-style-type: disc"><code class="literal">disable()</code>: This stops collecting profiling data</li><li class="listitem" style="list-style-type: disc"><code class="literal">create_stats()</code>: This stops collecting data and records the information gathered as the current profile</li><li class="listitem" style="list-style-type: disc"><code class="literal">print_stats(sort=-1)</code>: This creates a <code class="literal">stats</code> object and prints the result into <code class="literal">STDOUT</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">dump_stats(filename)</code>: This writes the content of the current profile into a file</li><li class="listitem" style="list-style-type: disc"><code class="literal">run(cmd)</code>: This is same as the <code class="literal">run</code> function we saw earlier</li><li class="listitem" style="list-style-type: disc"><code class="literal">runctx(cmd, globals, locals)</code>: This is same as the <code class="literal">runctx</code> function we saw earlier</li><li class="listitem" style="list-style-type: disc"><code class="literal">runcall(func, *args, **kwargs)</code>: This gathers profiling information about the function called</li></ul></div><p>Let's see <a id="id93" class="indexterm"/>the <a id="id94" class="indexterm"/>preceding example, using the following method this time:</p><div class="informalexample"><pre class="programlisting">import cProfile

def runRe():
    import re
    re.compile("foo|bar")

prof = cProfile.Profile() 
prof.enable() 
runRe()
prof.create_stats()
prof.print_stats()</pre></div><p>There are more lines involved to get the profiling going, but it is clearly less invasive to the original code. That is an advantage when trying to profile code that's already been written and tested. This way, we can add and remove our profiling code without having to modify the original code.</p><p>There is an even less invasive alternative, which involves not adding code at all, but using some specific command-line parameters when running the script instead:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ python -m cProfile your_script.py -o your_script.profile</strong></span>
</pre></div><p>Note that this will profile the entire code, so if you were actually just profiling a specific portion of your script, the preceding approach would not return the same results.</p><p>Now, before going into more detailed and interesting examples, let's first look at the <code class="literal">Stats</code> class and understand what it can do for us.</p></div><div class="section" title="The Stats class"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec27"/>The Stats class</h2></div></div></div><p>The <code class="literal">pstats</code> module <a id="id95" class="indexterm"/>provides the developer with the <code class="literal">Stats</code> class, which, in turn, allows them to read and manipulate the content of the <code class="literal">stats</code> file (the file into which we <a id="id96" class="indexterm"/>saved the profiling information using one of the methods described earlier).</p><p>For example, the following code loads the <code class="literal">stats</code> file and prints out the sorted statistics:</p><div class="informalexample"><pre class="programlisting">import pstats
p = pstats.Stats('stats')
p.strip_dirs().sort_stats(-1).print_stats()</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note04"/>Note</h3><p>Note that the <code class="literal">Stats</code> class constructor is able to receive a <code class="literal">cProfile.Profile</code> instance instead of the file name as the source of the data.</p></div></div><p>Let's take a closer look at the<a id="id97" class="indexterm"/> methods provided by the <code class="literal">pstats.Stats</code> class:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">strip_dirs()</code>: This removes all the leading paths' information from the file names in the report. This method modifies the <code class="literal">stats</code> instance, so any instance that has this method executed will be considered to have its items in a random order. If two entries are considered to be the same (same line on the same file name having the same function name), then those entries would be accumulated.</li><li class="listitem" style="list-style-type: disc"><code class="literal">add(*filenames)</code>: This method loads more information into <code class="literal">stats</code> from the files referenced in the file names. It's worth mentioning that just like with only one file, the <code class="literal">stats</code> entries that reference the same function (file name, and line and function name) will be accumulated.</li><li class="listitem" style="list-style-type: disc"><code class="literal">dump_stats(filename)</code>: Just like in the <code class="literal">cProfile.Profile</code> class, this method saves the data loaded into the <code class="literal">Stats</code> class inside a file.</li><li class="listitem" style="list-style-type: disc"><code class="literal">sort_stats(*keys)</code>: This method is present since version 2.3, and it modifies the <code class="literal">stats</code> object by sorting its entries by the given criteria. When more than one criteria is given, then the additional ones are used only when there is equality in the previous ones. For instance, if <code class="literal">sort_stats ('name', 'file')</code> is used, it would sort all entries by function name, and when that name is the same, it would sort those entries by file name.</li></ul></div><p>The method is smart enough to understand abbreviations as long as they're unambiguous, so be careful there. The<a id="id98" class="indexterm"/> full list of the currently supported sorting criteria is as follows:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Criteria</p>
</th><th style="text-align: left" valign="bottom">
<p>Meaning</p>
</th><th style="text-align: left" valign="bottom">
<p>Ascending/Descending</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">calls</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Total number of calls</p>
</td><td style="text-align: left" valign="top">
<p>Descending</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">cumulative</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Cumulative time</p>
</td><td style="text-align: left" valign="top">
<p>Descending</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">cumtime</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Cumulative time</p>
</td><td style="text-align: left" valign="top">
<p>Descending</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">file</code>
</p>
</td><td style="text-align: left" valign="top">
<p>File name</p>
</td><td style="text-align: left" valign="top">
<p>Ascending</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">filename</code>
</p>
</td><td style="text-align: left" valign="top">
<p>File name</p>
</td><td style="text-align: left" valign="top">
<p>Ascending</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">module</code>
</p>
</td><td style="text-align: left" valign="top">
<p>File name</p>
</td><td style="text-align: left" valign="top">
<p>Ascending</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">ncalls</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Total number of calls</p>
</td><td style="text-align: left" valign="top">
<p>Descending</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">pcalls</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Primitive call count</p>
</td><td style="text-align: left" valign="top">
<p>Descending</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">line</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Line<a id="id99" class="indexterm"/> number</p>
</td><td style="text-align: left" valign="top">
<p>Ascending</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">name</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Function name</p>
</td><td style="text-align: left" valign="top">
<p>Ascending</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">nfl</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Composite of name/file/line</p>
</td><td style="text-align: left" valign="top">
<p>Descending</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">stdname</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Standard name</p>
</td><td style="text-align: left" valign="top">
<p>Ascending</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">time</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Internal time</p>
</td><td style="text-align: left" valign="top">
<p>Descending</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">tottime</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Internal time</p>
</td><td style="text-align: left" valign="top">
<p>Descending</p>
</td></tr></tbody></table></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note05"/>Note</h3><p>
<span class="strong"><strong>A note on nfl versus stdname</strong></span>
</p><p>The main <a id="id100" class="indexterm"/>difference between these two sort types is that the<a id="id101" class="indexterm"/> latter is a sort of the printed name. This means the line numbers will be sorted as strings (which means that for 4, 20, and 30 the sorting will be 20, 30, 4). The <code class="literal">nfl</code> sort does a numeric comparison of the line number fields.</p></div></div><p>Finally, for backward <a id="id102" class="indexterm"/>compatibility reasons, some numeric values are accepted, instead of the ones in the preceding table. They are <code class="literal">-1</code>, <code class="literal">0</code>, <code class="literal">1</code>, and <code class="literal">2</code>, and they're translated into <code class="literal">stdname</code>, <code class="literal">calls</code>, <code class="literal">time</code>, and <code class="literal">cumulative</code>, respectively.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">reverse_order()</code>: This method reverses the default order of the sort key selected (so, if the key is by the default ascending order, it would be in the descending order now).</li><li class="listitem" style="list-style-type: disc"><code class="literal">print_stats(*restrictions)</code>: This method takes care of printing out the stats into <code class="literal">STDOUT</code>. The optional argument is meant to restrict the output of this function. It can either be an integer value, a decimal value, or a string. They are explained here:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">integer</code>: This will limit the number of lines printed</li><li class="listitem" style="list-style-type: disc"><code class="literal">Decimal between 0.0 and 1.0 (inclusive)</code>: This will select the percentage of the lines</li><li class="listitem" style="list-style-type: disc"><code class="literal">String</code>: This is a regular expression to match against the standard name</li></ul></div><div class="mediaobject"><img src="graphics/B02088_02_01.jpg" alt="The Stats class"/></div></li></ul></div><p>The preceding<a id="id103" class="indexterm"/> screenshot shows the output we get from calling the <code class="literal">print_stats</code> method as follows:</p><div class="informalexample"><pre class="programlisting">import cProfile
import pstats

def runRe():
    import re
    re.compile("foo|bar")
prof = cProfile.Profile()
prof.enable()
runRe()
prof.create_stats()

p = pstats.Stats(prof)
<span class="strong"><strong>p.print_stats(10, 1.0, '.*.py.*') #print top 10 lines that match the given reg exp.</strong></span>
</pre></div><p>If more than one parameter is passed, then they are applied sequentially. As we've seen in the preceding lines of code, the output of this profiler can be quite long. However, if we sort it properly, then we can summarize that output using this parameter and still get relevant information.</p><p>The <code class="literal">print_callers(*restrictions)</code> function works with the same input and restriction rules than the previous one, but the output is a bit different. For every function called during the execution of our program, it'll show the number of times each call was made, the total and cumulative times, and a combination of filename, and the line and function names.</p><p>Let's look at a quick <a id="id104" class="indexterm"/>example of how using <code class="literal">cProfile.Profile</code> and <code class="literal">Stats</code> can render the list of caller functions:</p><div class="informalexample"><pre class="programlisting">import cProfile
import pstats

def runRe():
    import re
    re.compile("foo|bar")
prof = cProfile.Profile()
prof.enable()
runRe()
prof.create_stats()

p = pstats.Stats(prof)
p.print_callers()</pre></div><p>Notice how we're <a id="id105" class="indexterm"/>combining the <code class="literal">pstats.Stats</code> class with the <code class="literal">cProfile.Profile</code> class. They're<a id="id106" class="indexterm"/> working together to gather and show the information in the way we need it. Now, look at the output:</p><div class="mediaobject"><img src="graphics/B02088_02_02.jpg" alt="The Stats class"/></div><p>The <code class="literal">print_callees(*restrictions)</code> method prints a list of functions that call other functions. The format of the data shown and the restrictions are same as the preceding example.</p><p>You may encounter a block like the one shown in the following screenshot as part of the output:</p><div class="mediaobject"><img src="graphics/B02088_02_03.jpg" alt="The Stats class"/></div><p>This output means that the functions on the right-hand side were called by the same function on<a id="id107" class="indexterm"/> the<a id="id108" class="indexterm"/> left-hand side.</p></div><div class="section" title="Profiling examples"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec28"/>Profiling examples</h2></div></div></div><p>Now that we've seen the basics of how to use <code class="literal">cProfile</code> and <code class="literal">Stats</code>, let's dig into some more interesting and practical examples.</p><div class="section" title="Fibonacci again"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec01"/>Fibonacci again</h3></div></div></div><p>Let's go back to<a id="id109" class="indexterm"/> the Fibonacci example, since a basic recursive Fibonacci sequence calculator has a lot of room for improvement.</p><p>Let's first look at the unprofiled, unoptimized code:</p><div class="informalexample"><pre class="programlisting">import profile

def fib(n):
    if n &lt;= 1:
  return n
    else:
        return fib(n-1) + fib(n-2)

def fib_seq(n):
    seq = [ ]
    if n &gt; 0:
        seq.extend(fib_seq(n-1))
    seq.append(fib(n))
    return seq

profile.run('print fib_seq(20); print')</pre></div><p>This code will output the following results:</p><div class="mediaobject"><img src="graphics/B02088_02_04.jpg" alt="Fibonacci again"/></div><p>The output is printed correctly, but look at the highlighted sections in the preceding screenshot. These <a id="id110" class="indexterm"/>sections are explained here:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">There are 57.356 function calls during those 0.114 seconds</li><li class="listitem" style="list-style-type: disc">Out of those, only 66 were primitive calls (not called by recursion)</li><li class="listitem" style="list-style-type: disc">In line 3 of our code, 57.270 (57.291—21) were recursion-induced function calls</li></ul></div><p>As we all know, the act of calling another function adds an overhead to our time. Since it looks like (for the <code class="literal">cumtime</code> column) that most of the execution time is spent inside this function, we can safely assume that if we speed this up, the entire script's time would be affected.</p><p>Now, let's apply a simple decorator to the <code class="literal">fib</code> function that will allow us to cache the previously calculated values (a technique also known as memoization, about which you'll read in the upcoming chapters) so that we don't have to call fib more than once per value:</p><div class="informalexample"><pre class="programlisting">import profile

class cached:
    def __init__(self, fn):
        self.fn = fn
        self.cache = {}

    def __call__(self, *args):
        try:
            return self.cache[args]
        except KeyError:
            self.cache[args] = self.fn(*args)
            return self.cache[args]

@cached
def fib(n):
    if n &lt;= 1:
        return n
    else:
        return fib(n-1) + fib(n-2)

def fib_seq(n):
    seq = [ ]
    if n &gt; 0: 

        seq.extend(fib_seq(n-1))
    seq.append(fib(n))
    return seq

profile.run('print fib_seq(20); print')</pre></div><p>Now, let's run<a id="id111" class="indexterm"/> the code again and look at the output:</p><div class="mediaobject"><img src="graphics/B02088_02_05.jpg" alt="Fibonacci again"/></div><p>We went from around 57k total calls to only 145 and from 0.114 seconds to 0.001. That's an amazing improvement! However, we have more primitive calls, but we also have significantly less recursive calls.</p><p>Let's continue with another possible optimization. Our example works quite fast for a single call, but let's try to do several runs in a row and get the combined stats for that execution. Perhaps, we'll get something interesting back. To do this, we need to use the stats module. Let's see an example for this:</p><div class="informalexample"><pre class="programlisting">import cProfile
import pstats
from fibo4 import fib, fib_seq

filenames = []
profiler = cProfile.Profile()
profiler.enable()
for i in range(5):
    print fib_seq(1000); print
profiler.create_stats()
stats = pstats.Stats(profiler)
stats.strip_dirs().sort_stats('cumulative').print_stats()
stats.print_callers()</pre></div><p>We've pushed the <a id="id112" class="indexterm"/>envelope here. Getting the Fibonacci sequence for 1000 might be too much to ask, especially from a recursive implementation. Indeed, we ran out of recursion depth. This is mainly due to the fact that <code class="literal">cPython</code> has a guard to prevent a stack overflow error generated by the amount of recursive calls (ideally, a tail recursion optimization would solve this, but <code class="literal">cPython</code> does not provide it). So, we just found another issue. Let's try to fix it and reanalyze the code:</p><div class="informalexample"><pre class="programlisting">import profile
def fib(n):
    a, b = 0, 1 
    for i in range(0, n):
        a,b = b, a+b
    return a

def fib_seq(n):
    seq = [ ]
    for i in range(0, n + 1):
        seq.append(fib(i))
    return seq

print fib_seq(1000)</pre></div><p>The preceding lines of code print a huge list of really big numbers, but these lines prove that we made it. We can now compute the Fibonacci sequence for the number 1000. Now, let's analyze it and see what we find.</p><p>Using the new profiling code, but requiring the iterative version of the Fibonacci implementation, we will get this:</p><div class="informalexample"><pre class="programlisting">import cProfile
import pstats
<span class="strong"><strong>from fibo_iter import fib, fib_seq</strong></span>

filenames = []
profiler = cProfile.Profile()
profiler.enable()
for i in range(5):
    print fib_seq(1000); print
profiler.create_stats()
stats = pstats.Stats(profiler)
stats.strip_dirs().sort_stats('cumulative').print_stats()
stats.print_callers()</pre></div><p>This, in turn, will <a id="id113" class="indexterm"/>yield the following result into the console:</p><div class="mediaobject"><img src="graphics/B02088_02_06.jpg" alt="Fibonacci again"/></div><p>Our new code is taking 0.187 seconds to calculate the Fibonacci sequence of 1000 five times. It's not a bad number, but we know we can improve it by caching the results, just like we did earlier. <span class="emphasis"><em>As you can see, we have 5005 calls to the </em></span>
<code class="literal">fib</code>
<span class="emphasis"><em> function. If we cache it, we would have a lot less function calls, which would mean less execution time</em></span>.</p><p>With very little effort, we can improve that time by caching the calls to the <code class="literal">fib</code> function, which, according the preceding report, is called 5005 times:</p><div class="informalexample"><pre class="programlisting">import profile

class cached:
    def __init__(self, fn):
        self.fn = fn
        self.cache = {}

    def __call__(self, *args):
        try:
            return self.cache[args]
        except KeyError:
            self.cache[args] = self.fn(*args)
            return self.cache[args]

@cached
def fib(n):
    a, b = 0, 1 
    for i in range(0, n):
        a,b = b, a+b
    return a

def fib_seq(n):
    seq = [ ]
    for i in range(0, n + 1):
        seq.append(fib(i))
    return seq

print fib_seq(1000)</pre></div><p>You <a id="id114" class="indexterm"/>should get something like the following output:</p><div class="mediaobject"><img src="graphics/B02088_02_07.jpg" alt="Fibonacci again"/></div><p>Simply by <a id="id115" class="indexterm"/>caching the call to <code class="literal">fib</code>, we went from 0.187 seconds to 0.006 seconds. This is an amazing improvement. Well done!</p></div><div class="section" title="Tweet stats"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec02"/>Tweet stats</h3></div></div></div><p>Let's look at another example, something a bit more conceptually complex, since calculating the<a id="id116" class="indexterm"/> Fibonacci sequence is not really an everyday use case. Let's do something a bit more interesting. These days, Twitter allows you to download your complete list of tweets in the form of a CSV file. We'll use this file to generate some statistics from our feed.</p><p>Using the data provided, we'll calculate the following statistics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The percentage of messages that are actual replies</li><li class="listitem" style="list-style-type: disc">The percentage of tweets that were made from the website (<a class="ulink" href="https://twitter.com">https://twitter.com</a>)</li><li class="listitem" style="list-style-type: disc">The percentage of tweets that were made from a mobile phone</li></ul></div><p>The output form our script will look like the one shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/B02088_02_08.jpg" alt="Tweet stats"/></div><p>To keep things simple, we'll take care of parsing the CSV file and doing these basic calculations. We<a id="id117" class="indexterm"/> won't use any third-party modules; that way, we'll be in total control of the code and its analysis. This means leaving out obvious things, such as using the CSV module from Python.</p><p>Other bad practices shown earlier, such as the <code class="literal">inc_stat</code> function or the fact that we're loading the entire file into memory before processing it, will remind you that this is just an example to show basic improvements.</p><p>Here is the initial code of the script:</p><div class="informalexample"><pre class="programlisting">def build_twit_stats():
    STATS_FILE = './files/tweets.csv'
    STATE = {
        'replies': 0,
        'from_web': 0,
        'from_phone': 0,
        'lines_parts': [],
        'total_tweets': 0
    }
    read_data(STATE, STATS_FILE)
    get_stats(STATE)
    print_results(STATE)

def get_percentage(n, total):
    return (n * 100) / total

def read_data(state, source):
    f = open(source, 'r')

    lines = f.read().strip().split("\"\n\"")
    for line in lines:

       state['lines_parts'].append(line.strip().split(',')) 
    state['total_tweets'] = len(lines)

def inc_stat(state, st):
    state[st] += 1

def get_stats(state):
    for i in state['lines_parts']:
        if(i[1] != '""'):
            inc_stat(state, 'replies')
        if(i[4].find('Twitter Web Client') &gt; -1):
            inc_stat(state, 'from_web')
        else:
            inc_stat(state, 'from_phone')

def print_results(state):
    print "-------- My twitter stats -------------"
    print "%s%% of tweets are replies" % (get_percentage(state['replies'], state['total_tweets']))
    print "%s%% of tweets were made from the website" % (get_percentage(state['from_web'], state['total_tweets']))
    print "%s%% of tweets were made from my phone" % (get_percentage(state['from_phone'], state['total_tweets']))</pre></div><p>To be fair, the <a id="id118" class="indexterm"/>code doesn't do anything too complicated. It loads the content of the file, splits it into lines, and then it splits each line into different fields. Finally, it counts things. One might think that with this explanation, there is nothing much to optimize, but we're about to see that there is always room for some optimization.</p><p>Another important thing to note is that the CSV file we'll be processing has almost 150 MB of tweets data.</p><p>Here is the script that imports that code, uses it, and generates a profiling report:</p><div class="informalexample"><pre class="programlisting">import cProfile
import pstats

from B02088_02_14 import build_twit_stats
profiler = cProfile.Profile()

profiler.enable()

build_twit_stats()

profiler.create_stats()
stats = pstats.Stats(profiler)
stats.strip_dirs().sort_stats('cumulative').print_stats()</pre></div><p>The output we get from this execution is as follows:</p><div class="mediaobject"><img src="graphics/B02088_02_09.jpg" alt="Tweet stats"/></div><p>There are three<a id="id119" class="indexterm"/> main areas of interest in the preceding screenshot:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Total execution time</li><li class="listitem">Cumulative times of individual function calls</li><li class="listitem">Total number of calls for individual functions</li></ol></div><p>Our aim is to lower the total execution time. For that, we will pay special attention to the cumulative times of individual functions and the total number of calls for individual functions. We can infer the following conclusions for the last two points:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">build_twit_stats</code> function is the one that takes the most time. However, as you can see in the preceding lines of code, it just calls all other functions, so it makes sense. We can focus on <code class="literal">read_data</code> since it's the second most time-consuming function. This is interesting, because it means that our bottleneck is not when we calculate the stats, but when we load the data for it.</li><li class="listitem" style="list-style-type: disc">In the third line of the code, we also see exactly our bottleneck inside <code class="literal">read_data</code>. We perform too many <code class="literal">split</code> commands and they add up.</li><li class="listitem" style="list-style-type: disc">We also see that the fourth most time-consuming function is <code class="literal">get_stats</code>.</li></ul></div><p>So, let's tackle these issues and see if we get better results. The biggest bottleneck we had was the way we were loading data. We were loading it all into memory first and then iterating over it to calculate our stats. We can improve this by reading the file line by line and calculating <a id="id120" class="indexterm"/>the stats after each one. Let's see how that code would look.</p><p>The new <code class="literal">read_data</code> method looks like this:</p><div class="informalexample"><pre class="programlisting">  def read_data(state, source):
    f = open(source)

    buffer_parts = []
    for line in f:
      #Multi line tweets are saved in several lines in the file, so we need to
      #take that into account.
      parts = line.split('","')
      buffer_parts += parts
      if len(parts) == 10:
        state['lines_parts'].append(buffer_parts) 
        get_line_stats(state, buffer_parts)
        buffer_parts = []
    state['total_tweets'] = len(state['lines_parts'])</pre></div><p>We had to add some logic to take into account multiline tweets, which are also saved as multiline records on our CSV file. We changed our <code class="literal">get_stats</code> function into <code class="literal">get_line_stats</code>, which simplifies its logic since it only calculates the values for the current record:</p><div class="informalexample"><pre class="programlisting">def get_line_stats(state, line_parts):
  if line_parts[1] != '' :
      state['replies'] += 1
  if 'Twitter Web Client' in line_parts[4]:
      state['from_web'] += 1
  else:
      state['from_phone'] += 1</pre></div><p>The two final improvements were to remove the calls to <code class="literal">inc_stat</code>, since, thanks to the dictionary we're using, the call is unnecessary. We also replaced the usage of the find method using the more proficient <code class="literal">in</code> operator.</p><p>Let's run the code again and see the changes:</p><div class="mediaobject"><img src="graphics/B02088_02_10.jpg" alt="Tweet stats"/></div><p>We went from <a id="id121" class="indexterm"/>2 seconds to 1.6; that was a considerable improvement. The <code class="literal">read_data</code> function is still up there with the most time-consuming functions, but that's just because it now also calls the <code class="literal">get_line_stats</code> function. We can also improve on this, since even though the <code class="literal">get_line_stats</code> function does very little, we're incurring in a lookup time by calling it so often inside the loop. We could inline this function and see if that helps.</p><p>The new code would look like this:</p><div class="informalexample"><pre class="programlisting">def read_data(state, source):
    f = open(source)

    buffer_parts = []
    for line in f:
      #Multi line tweets are saved in several lines in the file, so we need to
      #take that into account.
      parts = line.split('","')
      buffer_parts += parts
      if len(parts) == 10:
        state['lines_parts'].append(buffer_parts) 
        <span class="strong"><strong>if buffer_parts[1] != '' :</strong></span>
          <span class="strong"><strong>state['replies'] += 1</strong></span>
        <span class="strong"><strong>if 'Twitter Web Client' in buffer_parts[4]:</strong></span>
          <span class="strong"><strong>state['from_web'] += 1</strong></span>
        <span class="strong"><strong>else:</strong></span>
          <span class="strong"><strong>state['from_phone'] += 1</strong></span>
        buffer_parts = []
    state['total_tweets'] = len(state['lines_parts'])</pre></div><p>Now, with the<a id="id122" class="indexterm"/> new changes, the report will look like this:</p><div class="mediaobject"><img src="graphics/B02088_02_11.jpg" alt="Tweet stats"/></div><p>There is a notable improvement between the first screenshot and the preceding one. We got the time down to barely above 1.4 seconds from 2 seconds. The number of function calls is considerably lower as well (it went from around 3 million calls to 1.7 million), which in turn should help lower the time spent doing lookups and calls.</p><p>As an added bonus, we will improve the readability of our code by simplifying it. Here is the final code all together:</p><div class="informalexample"><pre class="programlisting">def build_twit_stats():
    STATS_FILE = './files/tweets.csv'
    STATE = {
        'replies': 0,
        'from_web': 0,
        'from_phone': 0,
        'lines_parts': [],
        'total_tweets': 0
    }
    read_data(STATE, STATS_FILE)
    print_results(STATE)

def get_percentage(n, total):
    return (n * 100) / total

def read_data(state, source):
    f = open(source)

    buffer_parts = []
    for line in f:
      #Multi line tweets are saved in several lines in the file, so we need to
      #take that into account.
      parts = line.split('","')
      buffer_parts += parts
      if len(parts) == 10:
        state['lines_parts'].append(buffer_parts) 
        if buffer_parts[1] != '' :
          state['replies'] += 1
        if 'Twitter Web Client' in buffer_parts[4]:
          state['from_web'] += 1
        else:
          state['from_phone'] += 1
        buffer_parts = []
    state['total_tweets'] = len(state['lines_parts'])

def print_results(state):
    print "-------- My twitter stats -------------"

    print "%s%% of tweets are replies" % (get_percentage(state['replies'], state['total_tweets']))

    print "%s%% of tweets were made from the website" % (get_percentage(state['from_web'], state['total_tweets']))

    print "%s%% of tweets were made from my phone" % (get_percentage(state['from_phone'], state['total_tweets']))</pre></div><p>This is it for <a id="id123" class="indexterm"/>our review of <code class="literal">cProfile</code>. With it, we managed to profile our scripts, getting per-function numbers and total function calls. It helped us improve on the overall view of the system. We'll now look at a different profiler, which will give us per-line details that <code class="literal">cProfile</code> is not capable of providing.</p></div></div></div></div>
<div class="section" title="line_profiler"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec17"/>line_profiler</h1></div></div></div><p>This profiler is different from <code class="literal">cProfile</code>. It helps you profile a function line by line instead of <a id="id124" class="indexterm"/>doing a deterministic profiling, like the other one does.</p><p>To install this<a id="id125" class="indexterm"/> profiler, you can use the pip (<a class="ulink" href="https://pypi.python.org/pypi/pip">https://pypi.python.org/pypi/pip</a>) command-line tool, with the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ pip install line_profiler</strong></span>
</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note06"/>Note</h3><p>If you run into any trouble, such as missing files during installation, make sure you have all development dependencies installed. In the case of Ubuntu, you can ensure that all the dependencies are installed by running the following command:</p><p>
<code class="literal">$ sudo apt-get install python-dev libxml2-dev libxslt-dev</code>
</p></div></div><p>This profiler is trying to fill in a breach left by <code class="literal">cProfile</code> and others like it. Other profilers cover CPU time on function calls. Most of the time, this is more than enough to catch the problems and fix them (we saw that earlier). However, sometimes, the problem or bottleneck is related to one specific line inside the function and that is where <code class="literal">line_profiler</code> comes into play.</p><p>The author recommends us <a id="id126" class="indexterm"/>to use the <code class="literal">kernprof</code> utility, so we'll look at examples of it. Kernprof will create an instance of the profiler and insert it into the <code class="literal">__builtins__</code> namespace with the name, profile. The profiler was designed to be used as a decorator, so you can just decorate any function you want, and it will time the execution for each line of it.</p><p>This is how we'll execute the profiler:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ kernprof -l script_to_profile.py</strong></span>
</pre></div><p>The decorated function is ready to be profiled:</p><div class="informalexample"><pre class="programlisting">@profile
def fib(n):
    a, b = 0, 1 
    for i in range(0, n):
        a,b = b, a+b
    return a</pre></div><p>By default, <code class="literal">kernprof</code> will save the results into a file called <code class="literal">script_to_profile.py.lprof</code>, but you can tell it to display the results right away using the <code class="literal">-v</code> attribute:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ kernprof -l -v script_to_profile.py</strong></span>
</pre></div><p>Here is a simple example <a id="id127" class="indexterm"/>output to help you understand what you'll be looking at:</p><div class="mediaobject"><img src="graphics/B02088_02_12.jpg" alt="line_profiler"/></div><p>The output<a id="id128" class="indexterm"/> contains every line of the function, next to the timing information. There are six columns of information, and this is what they mean:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Line #</code>: This is the line number inside the file.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Hits</code>: This is the number of times this line is executed during the profiling.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Time</code>: This is the total execution time of that line, specified in timer's unit. In the header information before the table with the results, you'll notice a field called <code class="literal">Timer unit</code>, that number is the conversion factor to seconds (to calculate the actual time, you'll have to do time <code class="literal">x</code> timer's unit). It might be different on different systems.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Per hit</code>: The average amount of time spent executing that line of code. This is also specified in timer's units.</li><li class="listitem" style="list-style-type: disc"><code class="literal">% Time</code>: The percentage of time spent executing that line, relative to the total time spent executing the entire function.</li></ul></div><p>If you're building another tool that leverages <code class="literal">line_profiler</code>, there are two ways to let it know which functions to profile: using the constructor and using the <code class="literal">add_function</code> method.</p><p>The <code class="literal">line_profiler</code> also provides the same <code class="literal">run</code>, <code class="literal">runctx</code>, <code class="literal">runcall</code>, <code class="literal">enable</code>, and <code class="literal">disable</code> methods that <code class="literal">cProfile.Profile</code> provides. However, the last two aren't safe when nesting, so be careful. After profiling, you can dump the <code class="literal">stats</code> into a file using the <code class="literal">dump_stats(filename)</code> method, or you can print them using the <code class="literal">print_stats([stream])</code> method. It'll print the results into <code class="literal">sys.stdout</code> or whatever other stream you pass it as parameter.</p><p>Here is an <a id="id129" class="indexterm"/>example of the same function from earlier. This time, the function is being profiled using the <code class="literal">line_profiler</code> API:</p><div class="informalexample"><pre class="programlisting">import line_profiler
import sys

def test():
    for i in range(0, 10):
        print i**2
    print "End of the function"


prof = line_profiler.LineProfiler(test) #pass in the function to profile

prof.enable() #start profiling
test()
prof.disable() #stop profiling

prof.print_stats(sys.stdout) #print out the results</pre></div><div class="section" title="kernprof"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec29"/>kernprof</h2></div></div></div><p>The <code class="literal">kernprof</code> is the<a id="id130" class="indexterm"/> profiling utility that comes bundled with <code class="literal">line_profiler</code> and <a id="id131" class="indexterm"/>allows us to abstract most of the profiling code from our own source code. This means we can use it to profile our application, like we <a id="id132" class="indexterm"/>saw earlier. <code class="literal">kernprof</code> will do several things for us:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">It'll work with <code class="literal">cProfile</code>, <code class="literal">lsprof</code>, and even the profile module, depending on which one is available.</li><li class="listitem" style="list-style-type: disc">It'll find our script properly. If the script is not inside the current folder, it'll even check the <code class="literal">PATH</code> variable.</li><li class="listitem" style="list-style-type: disc">It'll instantiate and insert the profiler into the <code class="literal">__builtins__</code> namespace with the name <code class="literal">profile</code>. This will allow us to use the profiler inside our code. In the case of <code class="literal">line_profiler</code>, we can even use it as a decorator without having to worry about importing anything.</li><li class="listitem" style="list-style-type: disc">The output files with the profiling <code class="literal">stats</code> can be viewed using the <code class="literal">pstats.Stats</code> class or even from the command line as follows:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ python -m pstats stats_file.py.prof</strong></span>
</pre></div><p>Or in the case of <code class="literal">lprof</code> files:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ python -m line_profiler stats_file.py.lprof</strong></span>
</pre></div></li></ul></div></div><div class="section" title="Some things to consider about kernprof"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec30"/>Some things to consider about kernprof</h2></div></div></div><p>There are a couple of things to take into consideration when reading the output from kernprof. In some cases, the output might be confusing, or the numbers might not add up. Here are the<a id="id133" class="indexterm"/> answers to some of the most common questions:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Line-by-line time doesn't add up to total time when the profile function calls another one</strong></span>: When profiling a function that gets called by another profiled function, sometimes, it might happen that the numbers don't add up. This is because <code class="literal">kernprof</code> is only recording the time spent inside the function and tries to avoid measuring any overhead added by the profiler itself, as shown in the following screenshot:<div class="mediaobject"><img src="graphics/B02088_02_13.jpg" alt="Some things to consider about kernprof"/></div><p>The preceding screenshot shows an example of this. The <code class="literal">printI</code> function takes <code class="literal">0.010539</code> seconds according to the profiler. However, inside the <code class="literal">test</code> function, the total amount of time spent seems to be <code class="literal">19567</code> timer's units, which amounts to <code class="literal">0.019567</code> seconds.</p></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>List comprehension lines have a lot more hits than they should inside the report</strong></span>: This <a id="id134" class="indexterm"/>is basically because the report is adding one hit per iteration inside the expression. Here is an example of this:<div class="mediaobject"><img src="graphics/B02088_02_14.jpg" alt="Some things to consider about kernprof"/></div></li></ul></div><p>You can see how the actual expression line has <code class="literal">102</code> hits, <code class="literal">2</code> for each time the <code class="literal">printExpression</code> function is called, and the other 100 due to the range used.</p></div><div class="section" title="Profiling examples"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec31"/>Profiling examples</h2></div></div></div><p>Now that we've seen the basics of how to use <code class="literal">line_profiler</code> and <code class="literal">kernprof</code>, let's get our hands dirty with more interesting examples.</p><div class="section" title="Back to Fibonacci"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec03"/>Back to Fibonacci</h3></div></div></div><p>Yes, let's<a id="id135" class="indexterm"/> again profile our original Fibonacci code. It'll be good to <a id="id136" class="indexterm"/>compare the output from both profilers to see how they work.</p><p>Let's first look at the output from this new profiler:</p><div class="mediaobject"><img src="graphics/B02088_02_15.jpg" alt="Back to Fibonacci"/></div><p>Out of all the<a id="id137" class="indexterm"/> numbers in the report, we can rest assured that timing is <a id="id138" class="indexterm"/>not an issue. Inside the <code class="literal">fib</code> function, none of the lines take too long (nor should they). Inside <code class="literal">fib_seq</code>, only one does, but that's because of the recursion shown inside <code class="literal">fib</code>.</p><p>So, our problem (as we already know) is the recursion and the number of times we're executing the <code class="literal">fib</code> function (57, 291 times to be exact). Every time we make a function call, the interpreter has to do a lookup by name and then execute the function. Every time we call the <code class="literal">fib</code> function, two more calls are made.</p><p>The first thing that comes to mind is to somehow lower the number of recursive calls. We can rewrite it into an iterative version or do a quick fix by adding the cached decorator, like we did earlier. We can see the results in the following report:</p><div class="mediaobject"><img src="graphics/B02088_02_16.jpg" alt="Back to Fibonacci"/></div><p>The number <a id="id139" class="indexterm"/>of hits for the <code class="literal">fib</code> function went from 57, 291 hits to <code class="literal">21</code>. This is <a id="id140" class="indexterm"/>another proof that the cached decorator is a great optimization in this case.</p></div><div class="section" title="Inverted index"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec04"/>Inverted index</h3></div></div></div><p>Instead of repeating the second example from within a different profiler, let's look at another <a id="id141" class="indexterm"/>problem: creating<a id="id142" class="indexterm"/> an inverted index (<a class="ulink" href="http://en.wikipedia.org/wiki/inverted_index">http://en.wikipedia.org/wiki/inverted_index</a>).</p><p>An inverted index is <a id="id143" class="indexterm"/>a resource used by many<a id="id144" class="indexterm"/> search engines to find words in several files at the same time. The way they work is by pre-scanning all files, splitting their content into words, and then saving the relations between those words and the files (some even save the position of the word too). This way, when a search is made on a specific word, the searching time is <code class="literal">O(1)</code> (constant).</p><p>Let's see a simple example:</p><div class="informalexample"><pre class="programlisting">//With these files:
file1.txt = "This is a file"
file2.txt = "This is another file"
//We get the following index:
This, (file1.txt, 0), (file2.txt, 0)
is, (file1.txt, 5), (file2.txt, 5)
a, (file1.txt, 8)
another, (file2.txt, 8)
file, (file1.txt, 10), (file2.txt, 16)</pre></div><p>So now, if we <a id="id145" class="indexterm"/>were to look for the word <code class="literal">file</code>, we know<a id="id146" class="indexterm"/> it's in both files (at different positions). Let's see the code that calculates this index (again, the point of the following code is to show classic improvement opportunities, so stick with us until we see the optimized version of the code):</p><div class="informalexample"><pre class="programlisting">#!/usr/bin/env python

import sys
import os
import glob

def getFileNames(folder):
  return glob.glob("%s/*.txt" % folder)

def getOffsetUpToWord(words, index):
  if not index:
    return 0
    subList = words[0:index]
    length = sum(len(w) for w in subList)
    return length + index + 1
        
def getWords(content, filename, wordIndexDict):
  STRIP_CHARS = ",.\t\n |"
  currentOffset = 0

  for line in content:
    line = line.strip(STRIP_CHARS)
    localWords = line.split()
    for (idx, word) in enumerate(localWords):
      word = word.strip(STRIP_CHARS)
      if word not in wordIndexDict:
        wordIndexDict[word] = []

      line_offset = getOffsetUpToWord(localWords, idx) 
      index = (line_offset) + currentOffset
      currentOffset = index 
      wordIndexDict[word].append([filename, index])

  return wordIndexDict

def readFileContent(filepath):
    f = open(filepath, 'r')
    return f.read().split( ' ' )

def list2dict(list):
  res = {}
  for item in list:
    if item[0] not in res:
      res[item[0]] = []
    res[item[0]].append(item[1])
  return res

def saveIndex(index):
  lines = []
  for word in index:
    indexLine = ""
    glue = ""
    for filename in index[word]:
      indexLine += "%s(%s, %s)" % (glue, filename, ','.join(map(str, index[word][filename])))
     glue = ","
    lines.append("%s, %s" % (word, indexLine))

  f = open("index-file.txt", "w")
  f.write("\n".join(lines))
  f.close()

def __start__():
  files = getFileNames('./files')
  words = {}
  for f in files:
    content = readFileContent(f)
    words = getWords(content, f, words)
  for word in (words):
    words[word] = list2dict(words[word])
  saveIndex(words)

__start__()</pre></div><p>The preceding code is as simple as it gets. It gets the job done for simple <code class="literal">.txt</code> files, and that is what we want right now. It'll load all <code class="literal">.txt</code> files inside the files folder, split their content into words, and calculate the offset of those words inside the document. Finally, it'll save all <a id="id147" class="indexterm"/>this information into a file called <code class="literal">index-file.txt</code>.</p><p>So, let's begin <a id="id148" class="indexterm"/>profiling and see what we get. Since we don't really know exactly which are the heavy-duty functions and which ones are the light ones, let's add the <code class="literal">@profile</code> decorator to all of them and run the profiler.</p><div class="section" title="getOffsetUpToWord"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl4sec01"/>getOffsetUpToWord</h4></div></div></div><p>The <code class="literal">getOffsetUpToWord</code> function looks like a great candidate for optimization, since it gets called <a id="id149" class="indexterm"/>quite a few times during execution. Let's keep the decorator on it for now.</p><div class="mediaobject"><img src="graphics/B02088_02_17.jpg" alt="getOffsetUpToWord"/></div></div><div class="section" title="getWords"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl4sec02"/>getWords</h4></div></div></div><p>The <code class="literal">getWords</code> function<a id="id150" class="indexterm"/> does a lot of processing. It even has two nested <code class="literal">for</code> loops, so we'll keep the decorator on as well.</p><div class="mediaobject"><img src="graphics/B02088_02_18.jpg" alt="getWords"/></div></div><div class="section" title="list2dict"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl4sec03"/>list2dict</h4></div></div></div><p>The <code class="literal">list2dict</code> function takes care of grabbing a list of arrays with two elements and returning a <a id="id151" class="indexterm"/>dictionary, using the first element of the array items as key and the second one as values. We'll leave the <code class="literal">@profile</code> decorator on for now.</p><div class="mediaobject"><img src="graphics/B02088_02_19.jpg" alt="list2dict"/></div></div><div class="section" title="readFileContent"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl4sec04"/>readFileContent</h4></div></div></div><p>The <code class="literal">readFileContent</code> function has two lines, and the significant one simply calls the <code class="literal">split</code> method<a id="id152" class="indexterm"/> on the content of the file. There is not a lot to improve here, so we'll discard it and focus on the other ones.</p><div class="mediaobject"><img src="graphics/B02088_02_20.jpg" alt="readFileContent"/></div></div><div class="section" title="saveIndex"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl4sec05"/>saveIndex</h4></div></div></div><p>The <code class="literal">saveIndex</code> function writes the results of the processing to a file, using a specific format. We<a id="id153" class="indexterm"/> might be able to get some better numbers here too.</p><div class="mediaobject"><img src="graphics/B02088_02_21.jpg" alt="saveIndex"/></div></div><div class="section" title="__start__"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl4sec06"/>__start__</h4></div></div></div><p>Finally, the <a id="id154" class="indexterm"/>main method, <code class="literal">__start__</code>, takes care of calling the other functions and doesn't do much heavy lifting, so we'll also discard it.</p><div class="mediaobject"><img src="graphics/B02088_02_22.jpg" alt="__start__"/></div><p>So, let's summarize. We originally had six functions, out of which we discarded two, because they <a id="id155" class="indexterm"/>were too trivial or just didn't do anything relevant. Now, we have a total of four functions to review and optimize.</p></div><div class="section" title="getOffsetUpToWord"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl4sec07"/>getOffsetUpToWord</h4></div></div></div><p>Let's first look at the <code class="literal">getOffsetUpToWord</code> function, which has a lot of lines for something as simple as adding up the length of the words leading up to the current index. There is<a id="id156" class="indexterm"/> probably a more Pythonic way to go about it, so let's try it out.</p><p>This function originally comprised 1.4 seconds of the total execution time, so let's try to lower that number by simplifying the code. The adding up of the length of the words can be translated into a reduce expression, as shown here:</p><div class="informalexample"><pre class="programlisting">def getOffsetUpToWord(words, index):
  if(index == 0):
    return 0
  length =  reduce(lambda curr, w: len(w) + curr, words[0:index], 0)
  return length + index + 1</pre></div><p>This simplification removes the need for extra time doing variable assignments and lookups. It might not seem like much. However, if we run the profiler again with this new code, the time would go down to 0.9 seconds. There is still an obvious drawback to that implementation: the lambda function. We're dynamically creating a function every time we call <code class="literal">getOffsetUpToWord</code>. We're calling it 313,868 times, so it would be a good idea to have this function already created. We can just add a reference to it in the reduce expression, as shown here:</p><div class="informalexample"><pre class="programlisting">def addWordLength(curr, w):
  return len(w) + curr

@profile
def getOffsetUpToWord(words, index):
  if not index:
    return 0
  length = reduce(addWordLength, words[0:index], 0)
  return length + index + 1</pre></div><p>The output<a id="id157" class="indexterm"/> should be similar to the following screenshot:</p><div class="mediaobject"><img src="graphics/B02088_02_23.jpg" alt="getOffsetUpToWord"/></div><p>With this minor improvement, the execution time goes down to 0.8 seconds. In the preceding screenshot, we can see that there are still a lot of unwanted hits (and therefore time) spent in the first two lines of the function. This check is unnecessary because the reduce function already defaults to 0. Finally, the assignment to the length variable can be removed, and we can return directly the sum of the length, the index, and the integer 1.</p><p>With that, we're left with the following code:</p><div class="informalexample"><pre class="programlisting">def addWordLength(curr, w):
  return len(w) + curr

@profile
def getOffsetUpToWord(words, index):
  return reduce(addWordLength, words[0:index], 0) + index + 1</pre></div><p>The total execution time for this function went from 1.4 to an amazing 0.67 seconds.</p></div><div class="section" title="getWords"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl4sec08"/>getWords</h4></div></div></div><p>Let's now move on to the next one: the <code class="literal">getWords</code> function. It is a pretty slow one. According to <a id="id158" class="indexterm"/>the screenshot, the execution of this function adds up to 4 seconds. That's not good. Let's see what we can do about it. First things first, the most expensive (time-consuming) line in this function is the one that calls the <code class="literal">getOffsetUpToWord</code> function. Since we already optimized that one, the total time of this function is now 2.2 seconds (down from 4 seconds).</p><p>That's a pretty decent side effect optimization, but we can still do a bit more for this function. We're using a normal dictionary for the <code class="literal">wordIndexDict</code> variable, so we have to check whether a key is set before actually using it. Doing that check inside this function takes up about 0.2 seconds. It is not a lot, but an optimization nonetheless. To remove that check, we can use the <code class="literal">defaultdict</code> class. It is a subclass of the <code class="literal">dict</code> class, which adds an extra functionality. It sets a default value for when a key doesn't exist. This will remove the need for those 0.2 seconds inside the function.</p><p>Another trivial but helpful optimization is the assignment of results to variables. It might seem like a small thing, but doing it 313,868 times will no doubt hurt our timing. So, take a look at these lines:</p><div class="informalexample"><pre class="programlisting">    35    313868      1266039      4.0     62.9        line_offset = getOffsetUpToWord(localWords, idx) 
    36    313868       108729      0.3      5.4        index = (line_offset) + currentOffset
    37    313868       101932      0.3      5.1        currentOffset = index </pre></div><p>These lines can be changed into a single line of code, as shown here:</p><div class="informalexample"><pre class="programlisting">      currentOffset = getOffsetUpToWord(localWords, idx) + currentOffset</pre></div><p>With that, we shaved off another 0.2 seconds. Finally, we're doing a strip operation on every line and then on every word. We can simplify this by calling the <code class="literal">replace</code> method several times for the entire content when loading the file. This will take care of cleaning up the text we'll be processing and remove added time for lookups and method calls inside the <code class="literal">getWords</code> function.</p><p>The new code looks like this:</p><div class="informalexample"><pre class="programlisting">def getWords(content, filename, wordIndexDict):
  currentOffset = 0
  for line in content:
    localWords = line.split()
    for (idx, word) in enumerate(localWords):
      currentOffset = getOffsetUpToWord(localWords, idx) + currentOffset
      wordIndexDict[word].append([filename, currentOffset])])])
  return wordIndexDict</pre></div><p>It only takes 1.57 seconds to run. There is one extra optimization that we might want to look at. It fits this particular case, because the <code class="literal">getOffsetUpToWord</code> function is only used in one place. Since this function got reduced to a one-liner, we can just put the one-liner in place of the<a id="id159" class="indexterm"/> function call. This one-liner will subtract the lookup time and give us a whopping 1.07 seconds (that's a 0.50 seconds reduction!). This is how the latest version of the function looks:</p><div class="mediaobject"><img src="graphics/B02088_02_24.jpg" alt="getWords"/></div><p>If you'll call the function from several places, this might be an optimization that is not worth having, since it'll hurt the code maintainability. Code maintainability is also an important aspect when developing. It should be a deciding factor when trying to figure out when to stop with the optimization process.</p></div><div class="section" title="list2dict"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl4sec09"/>list2dict</h4></div></div></div><p>Moving on, for the <code class="literal">list2dict</code> function, we can't really do much, but we can clean it up to get a more<a id="id160" class="indexterm"/> readable code and shave of about 0.1 seconds. Again, we're not doing this strictly for the speed gain, but for the readability gain. We have a chance to use the <code class="literal">defaultdict</code> class again and remove the check for a key so that the new code looks like this:</p><div class="informalexample"><pre class="programlisting">def list2dict(list):
  res = defaultdict(lambda: [])
  for item in list:
    res[item[0]].append(item[1])
  return res</pre></div><p>The preceding code has less lines, is easier to read, and more easy to understand.</p></div><div class="section" title="saveIndex"><div class="titlepage"><div><div><h4 class="title"><a id="ch02lvl4sec10"/>saveIndex</h4></div></div></div><p>Finally, let's take a<a id="id161" class="indexterm"/> look at the <code class="literal">saveIndex</code> function. According to our initial report, this function took 0.23 seconds to preprocess and save the data into the index file. That's a pretty good number already, but we can do a bit better by taking a second look at all the string concatenations we have.</p><p>Before saving the data, for every word we generate a string by concatenating several pieces together. In that same loop, we will also reset the <code class="literal">indexLine</code> and <code class="literal">glue</code> variables. These actions will add up to a lot of time, so we might want to change our strategy.</p><p>This is shown<a id="id162" class="indexterm"/> in the following code:</p><div class="informalexample"><pre class="programlisting">def saveIndex(index):
  lines = []
  for word in index:
    indexLines = []
    for filename in index[word]:
      indexLines.append("(%s, %s)" % (filename, ','.join(index[word][filename])))
    lines.append(word + "," +  ','.join(indexLines))

  f = open("index-file.txt", "w")
  f.write("\n".join(lines))
  f.close()</pre></div><p>As you can see in the preceding code, we changed the entire <code class="literal">for</code> loop. Now, instead of adding the new string to the <code class="literal">indexLine</code> variable, we appended it into a list. We also removed the map call, which was making sure we were dealing with strings during the <code class="literal">join</code> call. That <code class="literal">map</code> was moved into the <code class="literal">list2dict</code> function, casting the indexes to the string directly while appending them.</p><p>Finally, we used the <code class="literal">+</code> operator to concatenate strings instead of doing string expansion, which is a more expensive operation. In the end, this function went down from 0.23 seconds to 0.13, giving us a 0.10-second gain in speed.</p></div></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec18"/>Summary</h1></div></div></div><p>To sum things up, we've seen two major profilers used with Python: <code class="literal">cProfile</code>, which comes bundled with the language, and <code class="literal">line_profiler</code>, which gives us the chance to look at each line of code independently. We also covered some examples of analysis and optimization using them.</p><p>In the next chapter, we will look at a set of visual tools that will help us in our job by displaying the same data we covered in this chapter, but in a graphic manner.</p></div></body></html>