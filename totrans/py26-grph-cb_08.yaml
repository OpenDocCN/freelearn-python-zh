- en: Chapter 8. Data In and Data Out
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new file on the hard drive
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing data to a newly created file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing data to multiple files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding data to existing files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Saving a Tkinter drawing shape to disk
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Retrieving Python data from disk
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simple mouse input
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing and retrieving a mouse-drawn shape
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A mouse-line editor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All possible mouse actions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we address the technicalities of storing and retrieving graphic data on
    storage media like hard disks. Besides raster images, we need to be able to create,
    store, and retrieve vector graphics of ever increasing complexity. We also want
    techniques for transforming portions of raster images into vector images.
  prefs: []
  type: TYPE_NORMAL
- en: Till now, all our programs have carried their data inside the source code. This
    limits the complexity of the data lists and arrays that we can conveniently type
    in a few minutes. We do not want this limitation. We want to be able to handle
    and manipulate blocks of raw data that may be hundreds of megabytes in size if
    necessary. Typing in such files by hand is unthinkably inefficient. There are
    better ways of doing things. This is what named-files, data streams, and hard
    drives are for.
  prefs: []
  type: TYPE_NORMAL
- en: Creation of a new file on a hard drive
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We write and execute the simplest program that will create a data file on disk.
  prefs: []
  type: TYPE_NORMAL
- en: Till now, it was not required to store any data on our hard drive or a USB memory
    stick. Now we work through a series of simple exercises in storing and retrieving
    data in files on storage media. Then we use these methods to save and edit Tkinter
    lines in a practical way. Tkinter lines can be a large collection of separate
    line segments and shapes. If we are developing a drawing of complexity and richness,
    it is vital that we be able to store and retrieve work in progress.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Write, save, and execute the program shown in the usual way. When you run the
    program, all you will observe from a successful execution is a short pause after
    you have clicked *Enter*. The execution will terminate without any messages. However,
    a new file called `brand_new_file.dat` now exists on the destination directory
    `constr`. We should open `constr` and verify that this is indeed the case.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This minimalist-looking program achieves the following objectives:'
  prefs: []
  type: TYPE_NORMAL
- en: It verifies that Python's file IO functions are present and working. No modules
    need to be imported
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It demonstrates that there is nothing unusual about the way Python accesses
    data files on storage devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It proves that the operating system obeys file creation directives from Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to read the newly created file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once a file has been created, it can then be read. So a program to read an
    existing file on disk would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the only difference is the `r` instead of the `w`.
  prefs: []
  type: TYPE_NORMAL
- en: Note that Python reads and writes files in more than one format. A `b` as in
    `rb` and `wb` reads and writes as byte or binary format. These are the `1s` and
    `0s` in each byte. `r` and `w` without the `b` as in our examples tells the Python
    interpreter that it must interpret the bytes as ASCII characters. The only point
    we need to remember is to keep the formats separate.
  prefs: []
  type: TYPE_NORMAL
- en: Writing data to a newly-created file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We now create a file and then write a small amount of data to it. The value
    of these very, very simple recipes is that when we are trying some task that is
    complex and things do not work as expected, the simple one-action-only test programs
    allow us to break our problem down into simple tasks that we can gradually add
    complexity to, verifying the validity of each new change. This is a tried and
    trusted philosophy used by many of the best programmers.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The important thing to note at this point is that the newline character `\n`
    is the natural way by which Python separates variables. Space characters will
    also be used as number or character value separators or delimiters.
  prefs: []
  type: TYPE_NORMAL
- en: Writing data to multiple files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We see here that opening and writing data to a series of separate files is,
    as we have come to expect from Python, very simple and straightforward. Once we
    have seen an example of the correct syntax, it just works.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The value of this example is that it provides examples of correct debugged syntax.
    So it is available for reuse and modification with the minimum of bother.
  prefs: []
  type: TYPE_NORMAL
- en: Adding data to existing files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We test three ways of writing data to existing files in order to discover some
    basic rules of data storage.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'What make up the first method are two things: firstly, we open the file for
    appending ("a") which means we will add data to what is already in the file. Nothing
    will be destroyed or overwritten. Secondly, we separate the new data from the
    old with the line'
  prefs: []
  type: TYPE_NORMAL
- en: '`filly.write("\n")`'
  prefs: []
  type: TYPE_NORMAL
- en: The second method works, but is a very bad practice because there is no way
    of separating different entries.
  prefs: []
  type: TYPE_NORMAL
- en: The third method wipes out whatever was previously stored in the file.
  prefs: []
  type: TYPE_NORMAL
- en: So remember the difference between write and append
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If we keep the above three methods clear in our heads, we will be able to successfully
    store and retrieve our data without mishap and frustration.
  prefs: []
  type: TYPE_NORMAL
- en: Saving a Tkinter-drawing shape to disk
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we create an elaborate shape using Tkinter, we often want to preserve that
    shape for later use. In fact, we would like to build up a whole library of shapes.
    If other people do similar work, we may want to share and exchange shapes. Such
    community efforts are the key to the success of the most powerful and successful
    open-source programs.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If we go back to the example titled "Drawing Intricate Shapes the Curly Vine",
    in *Chapter 2, Drawing Fundamental Shapes*, we see that the shapes are defined
    by the two coordinate lists `vine_x` and `vine_y`. We are going to first save
    these shapes in a disk file and then see what is needed to successfully retrieve
    and draw them.
  prefs: []
  type: TYPE_NORMAL
- en: Create a folder `/constr/vector_shapes` on your hard drive ready to receive
    your stored data.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Execute the program shown in the usual way.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first thing to note is that stored data does not have a 'type' it is just
    text characters. So any data being appended to an open file must be converted
    into string format using the string conversion function `str(some_integer_or_float_object)`.
  prefs: []
  type: TYPE_NORMAL
- en: The second thing to note is that storing the whole list as a list object, like
    `str(vine_x)`, is the best way to do things because when stored this way it can
    be read back directly as a whole line read into a similar list object see the
    next recipe to how to do this. In typical Python fashion, the simple and obvious
    method always seems to be the best.
  prefs: []
  type: TYPE_NORMAL
- en: Storing commands
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The problem we face when retrieving lists of mixed integer and floating point
    data is that it is stored as a long string of characters. So how do we get Python
    to convert the long lists of characters that include square brackets, commas,
    spaces and new-line characters, into a normal Python numerical list? We want our
    drawing back undamaged. There is a lovely function `eval()` that does this effortlessly.
  prefs: []
  type: TYPE_NORMAL
- en: There is another method called pickle that does the same thing.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving Python data from disk storage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We retrieve two lists `vine_x` and `vine_y` from the stored file `curley_vine_1.txt`.
    We want them to be in exactly the same form they were in before they were sent
    for storage.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The preparation for this recipe was done by running the previous program `save_curly_vine_1.py`.
    If this ran successfully, there will be a file `curly_vine_1.txt` inside `/constr/vector_shapes`.
    If you open the text file you will see two lines, the first line being the string
    representation of our original `vine_x` and similarly the second line of this
    file will represent `vine_y`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This works so simply and elegantly because of the `eval()` function. The documentation
    says: "The *expression* argument is parsed and evaluated as a Python expression"
    and "The return value is the result of the evaluated expression". This is a way
    of saying that the text inside the brackets is treated as if it were plain Python
    expressions and executed as such. In our particular example, the string inside
    the curly brackets is interpreted as a list of numbers, not characters which is
    what we desire.'
  prefs: []
  type: TYPE_NORMAL
- en: Simple mouse input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We now develop code that helps to draw complicated shapes by capturing mouse
    clicks on electronic graph paper rather than with a pencil, eraser, and sheets
    of paper made from dead trees. We break this complex task into simple steps covered
    by the next three recipes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Clicking a mouse button is referred to as an event. If we want our program to
    perform some actions within our program, then we need to write a `callback` function
    that is called whenever the event occurs. Older terminology for `callback` was
    "interrupt service routine".
  prefs: []
  type: TYPE_NORMAL
- en: 'The line `frame.bind("<Button-1>", callback)` says in effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '"Make a connection (bind()) between the event, which is the click of the left
    button on the mouse `(<Button-1>)`, and the function called `callback"`. You could
    name this function anything you like, but the word callback makes the code easier
    to understand.'
  prefs: []
  type: TYPE_NORMAL
- en: The final point to note is that the variables `event.x` and `event.y` are reserved
    for recording the x-y coordinates of the mouse. In this specific `callback` function
    we print out the position, in a frame called "frame", of the mouse when clicked.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We build on the use of mouse-triggered `callback` functions in the next two
    recipes with the objective of producing a shape-tracing tool.
  prefs: []
  type: TYPE_NORMAL
- en: Storing and retrieving a mouse-drawn shape
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We make a program that lets you create a shape through the use of the mouse
    and by means of three buttons we can store the shape on disk, clear the canvas
    and then recall and display the shape on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ensure you have created a folder call `constr` because this is where the code
    in our program expects to be able to save the shape drawn. It is also where it
    will retrieve it from when commanded to retrieve and display it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In addition to a `callback` function for adding the positions of left mouse
    clicks to lists `x0` and `y0`, of x and y-coordinates, we have another three `callback`
    functions. The three additional `callback` functions are to trigger the execution
    of functions that:'
  prefs: []
  type: TYPE_NORMAL
- en: Save the lists `x0` and `y0` to a disk in a file called `shape_xy_1.txt`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clear the canvas of all drawn lines and circles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Retrieve the contents of `shape_xy_1.txt` and re-draw it onto the canvas
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Drawing is an imperfect process and artists and draughtsman use an eraser as
    well as a pencil. When we make drawings with a mouse connected to a computer we
    also need to make adjustments and corrections to any lines we draw. We need editing
    ability.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing is an imperfect process. We would like to be able to adjust the position
    of some of the points in order to improve the drawing. We do this in the next
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: A mouse-line editor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We edit (change) a shape drawn using the mouse after the drawing is finished.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To limit the complexity and length of the code, we have excluded the facilities
    provided in the previous recipe for storing and recalling the drawn shape. So
    for this recipe no storage folders will be used.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The preceding program now includes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`callback` functions to deal with left and right mouse clicks and drags.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A distance-measuring function `separation(x_now, y_now, x_dot, y_dot)`. When
    the right mouse button is clicked, the distance to every line joint is measured.
    If one of these distances is inside an existing joint then an orange circle is
    drawn and control is passed to `callback_6` which updates the coordinates of the
    new point and refreshes the revised drawing. The decision on whether to move a
    point or not is decided by the value of the `magic_circle_flag`. The state of
    this flag is determined by the distance computed by `separation()`. It is set
    to `1` if the distance measurement finds it inside a joint when the right mouse
    is pressed and set to `0` after a point has been moved.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have a means to control and adjust the drawing of lines and curves
    using mouse manipulation, other possibilities are opened up.
  prefs: []
  type: TYPE_NORMAL
- en: Why don't we add more features?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It would be good to extend the features of this program to include:'
  prefs: []
  type: TYPE_NORMAL
- en: The ability to erase points
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ability to work with unjoined segments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ability to select or click to create points
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drag fairy lights (equal length segments)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The list will grow longer as we work on the extensions. In the end, we will
    have created a useful vector graphics editor and the pressure would be on to match
    features of existing proprietary and open-source editors. Why re-invent the wheel?
    What may bear more fruit would be an effort to work with vector images produced
    by an existing mature vector editor, if this is a practical option.
  prefs: []
  type: TYPE_NORMAL
- en: Using other tools to acquire and re-work images
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the next chapter, we explore ways and means of using vector images from the
    open-source vector graphics editor Inkscape. Inkscape is able to export images
    in a wide choice of formats including a standardized web format called **Scaled
    Vector Graphics** or **SVG** for short.
  prefs: []
  type: TYPE_NORMAL
- en: How to exploit that mouse
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This chapter has made much use of the mouse as a user-interaction tool for drawing
    shapes on Tkinter canvasses. To complete the job of acquiring the know-how of
    using the mouse to its fullest the next recipe will be an examination of the full
    toolkit of mouse interactions.
  prefs: []
  type: TYPE_NORMAL
- en: We can measure the distance along a meandering line
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the code, there is a variable called `map_distance` that has not been used.
    It can be used to trace the distance travelled on meandering paths on maps. The
    idea is that if we wanted to measure distances on unmarked paths and roads on
    something like a Google map, we would be able to adapt this recipe to the task.
  prefs: []
  type: TYPE_NORMAL
- en: All possible mouse actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we make a program that tests each possible mouse event that Python is capable
    of responding to.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Execute the program shown in the normal way.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The preceding code is reasonably self-explanatory. A small canvas is created
    that is responsive to all the mouse actions. Proof that the responses are working
    correctly are by means of confirmation messages typed on the system console. We
    can adapt the `callback` functions to do any kind of task we choose simply by
    inserting appropriate Python commands into the `callback` functions.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Mouse events and Tkinter widgets often work together. Most Tkinter GUI widgets
    are designed to be controlled by mouse events such as left or right-clicks or
    dragging with a button held down. Tkinter provides a versatile selection of widgets
    and these will be explored in *Chapter 10, GUI Construction Part 1* and *Chapter
    11, GUI Construction*
  prefs: []
  type: TYPE_NORMAL
