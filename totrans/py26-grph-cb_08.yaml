- en: Chapter 8. Data In and Data Out
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。数据输入与数据输出
- en: 'In this chapter, we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Creating a new file on the hard drive
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在硬盘上创建新文件
- en: Writing data to a newly created file
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数据写入新创建的文件
- en: Writing data to multiple files
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数据写入多个文件
- en: Adding data to existing files
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向现有文件添加数据
- en: Saving a Tkinter drawing shape to disk
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将Tkinter绘图形状保存到磁盘
- en: Retrieving Python data from disk
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从磁盘检索Python数据
- en: Simple mouse input
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单的鼠标输入
- en: Storing and retrieving a mouse-drawn shape
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储和检索鼠标绘制的形状
- en: A mouse-line editor
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 鼠标线条编辑器
- en: All possible mouse actions
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有可能的鼠标操作
- en: Introduction
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Now we address the technicalities of storing and retrieving graphic data on
    storage media like hard disks. Besides raster images, we need to be able to create,
    store, and retrieve vector graphics of ever increasing complexity. We also want
    techniques for transforming portions of raster images into vector images.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来讨论在硬盘等存储介质上存储和检索图形数据的细节。除了位图图像外，我们还需要能够创建、存储和检索越来越复杂的矢量图形。我们还希望有将位图图像的部分转换为矢量图像的技术。
- en: Till now, all our programs have carried their data inside the source code. This
    limits the complexity of the data lists and arrays that we can conveniently type
    in a few minutes. We do not want this limitation. We want to be able to handle
    and manipulate blocks of raw data that may be hundreds of megabytes in size if
    necessary. Typing in such files by hand is unthinkably inefficient. There are
    better ways of doing things. This is what named-files, data streams, and hard
    drives are for.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们所有的程序都将其数据包含在源代码中。这限制了我们可以方便地在几分钟内键入的数据列表和数组复杂性。我们不希望有这种限制。我们希望能够处理和操作可能达到数百兆字节大小的原始数据块。手动键入这样的文件是难以想象的低效。有更好的做事方式。这就是命名文件、数据流和硬盘的作用。
- en: Creation of a new file on a hard drive
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在硬盘上创建新文件
- en: We write and execute the simplest program that will create a data file on disk.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写并执行了最简单的程序，该程序将在磁盘上创建一个数据文件。
- en: Till now, it was not required to store any data on our hard drive or a USB memory
    stick. Now we work through a series of simple exercises in storing and retrieving
    data in files on storage media. Then we use these methods to save and edit Tkinter
    lines in a practical way. Tkinter lines can be a large collection of separate
    line segments and shapes. If we are developing a drawing of complexity and richness,
    it is vital that we be able to store and retrieve work in progress.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们不需要在硬盘或USB闪存盘上存储任何数据。现在，我们将通过一系列简单的练习来存储和检索存储介质上的文件数据。然后，我们使用这些方法以实际的方式保存和编辑Tkinter线条。Tkinter线条可以是一组单独的线段和形状的集合。如果我们正在开发复杂且丰富的绘图，我们能够存储和检索工作进度是至关重要的。
- en: How to do it...
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: Write, save, and execute the program shown in the usual way. When you run the
    program, all you will observe from a successful execution is a short pause after
    you have clicked *Enter*. The execution will terminate without any messages. However,
    a new file called `brand_new_file.dat` now exists on the destination directory
    `constr`. We should open `constr` and verify that this is indeed the case.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 按照常规方式编写、保存并执行显示的程序。当你运行程序时，你将观察到的唯一成功执行迹象是在你点击*Enter*后短暂的暂停。执行将没有任何消息而终止。然而，现在在目标目录`constr`中存在一个名为`brand_new_file.dat`的新文件。我们应该打开`constr`并验证这确实如此。
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: How it works...
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'This minimalist-looking program achieves the following objectives:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这个看起来简约的程序实现了以下目标：
- en: It verifies that Python's file IO functions are present and working. No modules
    need to be imported
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它验证了Python的文件I/O函数存在且正在工作。不需要导入任何模块
- en: It demonstrates that there is nothing unusual about the way Python accesses
    data files on storage devices
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它展示了Python访问存储设备上的数据文件的方式并没有什么异常
- en: It proves that the operating system obeys file creation directives from Python
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它证明了操作系统遵循Python的文件创建指令
- en: How to read the newly created file
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何读取新创建的文件
- en: 'Once a file has been created, it can then be read. So a program to read an
    existing file on disk would be:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了一个文件，就可以读取它。因此，一个读取磁盘上现有文件的程序会是这样的：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you can see, the only difference is the `r` instead of the `w`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，唯一的区别是`r`而不是`w`。
- en: Note that Python reads and writes files in more than one format. A `b` as in
    `rb` and `wb` reads and writes as byte or binary format. These are the `1s` and
    `0s` in each byte. `r` and `w` without the `b` as in our examples tells the Python
    interpreter that it must interpret the bytes as ASCII characters. The only point
    we need to remember is to keep the formats separate.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Python以多种格式读取和写入文件。在`rb`和`wb`中的`b`表示以字节或二进制格式读取和写入。这些是每个字节中的`1s`和`0s`。在我们的例子中，没有`b`的`r`和`w`告诉Python解释器必须将字节解释为ASCII字符。我们唯一需要记住的是保持格式分离。
- en: Writing data to a newly-created file
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将数据写入新创建的文件
- en: We now create a file and then write a small amount of data to it. The value
    of these very, very simple recipes is that when we are trying some task that is
    complex and things do not work as expected, the simple one-action-only test programs
    allow us to break our problem down into simple tasks that we can gradually add
    complexity to, verifying the validity of each new change. This is a tried and
    trusted philosophy used by many of the best programmers.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在创建一个文件，然后向其中写入一小部分数据。这些非常简单的菜谱的价值在于，当我们尝试一些复杂且不符合预期的任务时，简单的一步测试程序允许我们将问题分解成简单的任务，我们可以逐步增加复杂性，验证每个新更改的有效性。这是许多最佳程序员使用的经过验证和信任的哲学。
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: How it works...
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The important thing to note at this point is that the newline character `\n`
    is the natural way by which Python separates variables. Space characters will
    also be used as number or character value separators or delimiters.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上需要注意的重要事情是，换行符`\n`是Python区分变量的自然方式。空格字符也将用作数字或字符值的分隔符或定界符。
- en: Writing data to multiple files
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将数据写入多个文件
- en: We see here that opening and writing data to a series of separate files is,
    as we have come to expect from Python, very simple and straightforward. Once we
    have seen an example of the correct syntax, it just works.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里看到，像我们预期的那样，使用Python打开和写入一系列单独的文件非常简单直接。一旦我们看到了正确的语法示例，它就会正常工作。
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: How it works...
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The value of this example is that it provides examples of correct debugged syntax.
    So it is available for reuse and modification with the minimum of bother.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例的价值在于它提供了正确的调试语法示例。因此，它可以以最小的麻烦进行重用和修改。
- en: Adding data to existing files
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向现有文件添加数据
- en: We test three ways of writing data to existing files in order to discover some
    basic rules of data storage.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们测试了三种将数据写入现有文件的方法，以发现一些基本的数据存储规则。
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: How it works...
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'What make up the first method are two things: firstly, we open the file for
    appending ("a") which means we will add data to what is already in the file. Nothing
    will be destroyed or overwritten. Secondly, we separate the new data from the
    old with the line'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 构成第一种方法的是两件事：首先，我们以追加模式打开文件（"a"），这意味着我们将数据添加到文件中已有的内容。不会销毁或覆盖任何内容。其次，我们通过以下行将新数据与旧数据分开：
- en: '`filly.write("\n")`'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`filly.write("\n")`'
- en: The second method works, but is a very bad practice because there is no way
    of separating different entries.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法可行，但这是一个非常不好的实践，因为没有方法来分离不同的条目。
- en: The third method wipes out whatever was previously stored in the file.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种方法会清除文件中之前存储的内容。
- en: So remember the difference between write and append
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 所以记住write和append之间的区别
- en: If we keep the above three methods clear in our heads, we will be able to successfully
    store and retrieve our data without mishap and frustration.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们清楚地记住上述三种方法，我们将能够成功存储和检索我们的数据，而不会出现错误和挫败感。
- en: Saving a Tkinter-drawing shape to disk
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将Tkinter绘制的形状保存到磁盘
- en: When we create an elaborate shape using Tkinter, we often want to preserve that
    shape for later use. In fact, we would like to build up a whole library of shapes.
    If other people do similar work, we may want to share and exchange shapes. Such
    community efforts are the key to the success of the most powerful and successful
    open-source programs.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用Tkinter创建一个复杂的形状时，我们通常希望保留这个形状以供以后使用。实际上，我们希望建立一个整个形状库。如果其他人做类似的工作，我们可能希望共享和交换形状。这种社区努力是大多数强大且成功的开源程序成功的关键。
- en: Getting ready
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: If we go back to the example titled "Drawing Intricate Shapes the Curly Vine",
    in *Chapter 2, Drawing Fundamental Shapes*, we see that the shapes are defined
    by the two coordinate lists `vine_x` and `vine_y`. We are going to first save
    these shapes in a disk file and then see what is needed to successfully retrieve
    and draw them.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们回到名为“绘制复杂形状——螺旋藤”的例子，在*第二章，绘制基本形状*中，我们会看到形状是由两个坐标列表`vine_x`和`vine_y`定义的。我们首先将这些形状保存到磁盘文件中，然后看看成功检索和绘制它们需要什么。
- en: Create a folder `/constr/vector_shapes` on your hard drive ready to receive
    your stored data.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的硬盘上创建一个名为`/constr/vector_shapes`的文件夹，以便接收你的存储数据。
- en: How to do it...
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Execute the program shown in the usual way.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 按照常规方式执行显示的程序。
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: How it works...
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The first thing to note is that stored data does not have a 'type' it is just
    text characters. So any data being appended to an open file must be converted
    into string format using the string conversion function `str(some_integer_or_float_object)`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要注意的是，存储的数据没有“类型”，它仅仅是文本字符。因此，任何要追加到打开文件的数據都必须使用字符串转换函数`str(some_integer_or_float_object)`转换为字符串格式。
- en: The second thing to note is that storing the whole list as a list object, like
    `str(vine_x)`, is the best way to do things because when stored this way it can
    be read back directly as a whole line read into a similar list object see the
    next recipe to how to do this. In typical Python fashion, the simple and obvious
    method always seems to be the best.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 第二点要注意的是，将整个列表作为一个列表对象存储，例如`str(vine_x)`，是做事的最佳方式，因为以这种方式存储后，可以直接作为一个整行读入到类似的列表对象中，参见下一道菜谱了解如何做到这一点。在典型的Python风格中，简单而明显的方法似乎总是最好的。
- en: Storing commands
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 存储命令
- en: The problem we face when retrieving lists of mixed integer and floating point
    data is that it is stored as a long string of characters. So how do we get Python
    to convert the long lists of characters that include square brackets, commas,
    spaces and new-line characters, into a normal Python numerical list? We want our
    drawing back undamaged. There is a lovely function `eval()` that does this effortlessly.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们检索混合整数和浮点数据的列表时面临的问题是，它被存储为一个长的字符字符串。那么我们如何让Python将包含方括号、逗号、空格和新行字符的长字符串列表转换为正常的Python数值列表呢？我们希望我们的绘图不受损坏。有一个很棒的功能`eval()`可以轻松完成这项工作。
- en: There is another method called pickle that does the same thing.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 另有一种名为pickle的方法也能做到同样的事情。
- en: Retrieving Python data from disk storage
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从磁盘存储中检索Python数据
- en: We retrieve two lists `vine_x` and `vine_y` from the stored file `curley_vine_1.txt`.
    We want them to be in exactly the same form they were in before they were sent
    for storage.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从存储的文件`curley_vine_1.txt`中检索两个列表`vine_x`和`vine_y`。我们希望它们与存储之前的形式完全相同。
- en: Getting ready
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The preparation for this recipe was done by running the previous program `save_curly_vine_1.py`.
    If this ran successfully, there will be a file `curly_vine_1.txt` inside `/constr/vector_shapes`.
    If you open the text file you will see two lines, the first line being the string
    representation of our original `vine_x` and similarly the second line of this
    file will represent `vine_y`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱的准备是通过运行之前的程序`save_curly_vine_1.py`来完成的。如果这个程序运行成功，那么在`/constr/vector_shapes`目录下将会有一个名为`curly_vine_1.txt`的文件。如果你打开这个文本文件，你会看到两行，第一行是我们原始的`vine_x`的字符串表示，同样地，这个文件的第二行将代表`vine_y`。
- en: '[PRE6]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: How it works...
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'This works so simply and elegantly because of the `eval()` function. The documentation
    says: "The *expression* argument is parsed and evaluated as a Python expression"
    and "The return value is the result of the evaluated expression". This is a way
    of saying that the text inside the brackets is treated as if it were plain Python
    expressions and executed as such. In our particular example, the string inside
    the curly brackets is interpreted as a list of numbers, not characters which is
    what we desire.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这之所以如此简单而优雅，是因为`eval()`函数的存在。文档中提到：“*expression*参数被解析并作为Python表达式评估”以及“返回值是评估表达式的结果”。这意味着括号内的文本被当作普通的Python表达式处理并执行。在我们的特定例子中，花括号内的字符串被解释为一个数字列表，而不是字符，这正是我们想要的。
- en: Simple mouse input
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简单鼠标输入
- en: We now develop code that helps to draw complicated shapes by capturing mouse
    clicks on electronic graph paper rather than with a pencil, eraser, and sheets
    of paper made from dead trees. We break this complex task into simple steps covered
    by the next three recipes.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在开发代码，通过捕捉电子图纸上鼠标点击而不是使用铅笔、橡皮和由死树制成的纸张来帮助绘制复杂的形状。我们将这个复杂任务分解为下一个三个菜谱中涵盖的简单步骤。
- en: '[PRE7]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: How it works...
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Clicking a mouse button is referred to as an event. If we want our program to
    perform some actions within our program, then we need to write a `callback` function
    that is called whenever the event occurs. Older terminology for `callback` was
    "interrupt service routine".
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 点击鼠标按钮被称为事件。如果我们想让我们的程序在程序内部执行某些操作，那么我们需要编写一个`callback`函数，每当事件发生时都会调用这个函数。`callback`的旧术语是“中断服务例程”。
- en: 'The line `frame.bind("<Button-1>", callback)` says in effect:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这行`frame.bind("<Button-1>", callback)`实际上表示：
- en: '"Make a connection (bind()) between the event, which is the click of the left
    button on the mouse `(<Button-1>)`, and the function called `callback"`. You could
    name this function anything you like, but the word callback makes the code easier
    to understand.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: “在事件（即鼠标左键点击`(<Button-1>)`）和被调用的函数`callback`之间建立一个连接（绑定）”。你可以给这个函数取任何你喜欢的名字，但“callback”这个词可以使代码更容易理解。
- en: The final point to note is that the variables `event.x` and `event.y` are reserved
    for recording the x-y coordinates of the mouse. In this specific `callback` function
    we print out the position, in a frame called "frame", of the mouse when clicked.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的最后一个点是，变量`event.x`和`event.y`是保留用于记录鼠标的x-y坐标。在这个特定的`callback`函数中，我们打印出鼠标点击时的位置，在一个称为“frame”的框架中。
- en: There's more...
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: We build on the use of mouse-triggered `callback` functions in the next two
    recipes with the objective of producing a shape-tracing tool.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的两个菜谱中，我们基于使用鼠标触发的`callback`函数，目的是制作一个形状追踪工具。
- en: Storing and retrieving a mouse-drawn shape
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 存储和检索鼠标绘制的形状
- en: We make a program that lets you create a shape through the use of the mouse
    and by means of three buttons we can store the shape on disk, clear the canvas
    and then recall and display the shape on the screen.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们制作一个程序，通过使用鼠标和三个按钮，我们可以将形状存储到磁盘上，清除画布，然后召回并在屏幕上显示形状。
- en: Getting ready
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Ensure you have created a folder call `constr` because this is where the code
    in our program expects to be able to save the shape drawn. It is also where it
    will retrieve it from when commanded to retrieve and display it.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你已经创建了一个名为`constr`的文件夹，因为这是我们的程序期望能够保存绘制的形状的地方。它也是当被命令检索并显示时将从中检索的地方。
- en: '[PRE8]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: How it works...
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In addition to a `callback` function for adding the positions of left mouse
    clicks to lists `x0` and `y0`, of x and y-coordinates, we have another three `callback`
    functions. The three additional `callback` functions are to trigger the execution
    of functions that:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 除了用于将左鼠标点击的位置添加到列表`x0`和`y0`（x和y坐标）的`callback`函数外，我们还有另外三个`callback`函数。这三个额外的`callback`函数是用来触发执行以下功能的：
- en: Save the lists `x0` and `y0` to a disk in a file called `shape_xy_1.txt`.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将列表`x0`和`y0`保存到名为`shape_xy_1.txt`的磁盘文件中。
- en: Clear the canvas of all drawn lines and circles
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清除画布上的所有绘制线条和圆圈
- en: Retrieve the contents of `shape_xy_1.txt` and re-draw it onto the canvas
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检索`shape_xy_1.txt`的内容，并将其重新绘制到画布上
- en: There's more...
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Drawing is an imperfect process and artists and draughtsman use an eraser as
    well as a pencil. When we make drawings with a mouse connected to a computer we
    also need to make adjustments and corrections to any lines we draw. We need editing
    ability.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制是一个不完美的过程，艺术家和制图员会使用橡皮和铅笔。当我们用连接到计算机的鼠标绘制时，我们也需要对所绘制的任何线条进行调整和修正。我们需要编辑能力。
- en: Drawing is an imperfect process. We would like to be able to adjust the position
    of some of the points in order to improve the drawing. We do this in the next
    recipe.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制是一个不完美的过程。我们希望能够调整一些点的位置，以改善绘制。我们将在下一个菜谱中这样做。
- en: A mouse-line editor
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 鼠标线条编辑器
- en: We edit (change) a shape drawn using the mouse after the drawing is finished.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在绘制完成后，我们编辑（更改）使用鼠标绘制的形状。
- en: Getting ready
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To limit the complexity and length of the code, we have excluded the facilities
    provided in the previous recipe for storing and recalling the drawn shape. So
    for this recipe no storage folders will be used.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 为了限制代码的复杂性和长度，我们排除了上一个菜谱中提供的存储和回忆绘制形状的功能。因此，在这个菜谱中不会使用任何存储文件夹。
- en: '[PRE9]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: How it works...
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The preceding program now includes:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的程序现在包括：
- en: '`callback` functions to deal with left and right mouse clicks and drags.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理左右鼠标点击和拖动的 `callback` 函数。
- en: A distance-measuring function `separation(x_now, y_now, x_dot, y_dot)`. When
    the right mouse button is clicked, the distance to every line joint is measured.
    If one of these distances is inside an existing joint then an orange circle is
    drawn and control is passed to `callback_6` which updates the coordinates of the
    new point and refreshes the revised drawing. The decision on whether to move a
    point or not is decided by the value of the `magic_circle_flag`. The state of
    this flag is determined by the distance computed by `separation()`. It is set
    to `1` if the distance measurement finds it inside a joint when the right mouse
    is pressed and set to `0` after a point has been moved.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 距离测量函数 `separation(x_now, y_now, x_dot, y_dot)`。当右键点击时，测量到每个线段的距离。如果这些距离中的任何一个在现有接点内部，则绘制一个橙色圆圈，并将控制权传递给
    `callback_6`，该函数更新新点的坐标并刷新修改后的绘图。是否移动点的决定由 `magic_circle_flag` 的值决定。这个标志的状态由 `separation()`
    计算的距离确定。当右键按下时，如果距离测量发现它在接点内部，则将其设置为 `1`，在移动一个点之后将其设置为 `0`。
- en: There's more...
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Now that we have a means to control and adjust the drawing of lines and curves
    using mouse manipulation, other possibilities are opened up.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了通过鼠标操作来控制和调整线条和曲线绘制的方法，其他可能性也被打开了。
- en: Why don't we add more features?
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为什么不添加更多功能？
- en: 'It would be good to extend the features of this program to include:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 好好扩展这个程序的功能，包括：
- en: The ability to erase points
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除点的功能
- en: The ability to work with unjoined segments
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理未连接段的能力
- en: The ability to select or click to create points
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择或点击创建点的功能
- en: Drag fairy lights (equal length segments)
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拖动仙女灯（等长段）
- en: The list will grow longer as we work on the extensions. In the end, we will
    have created a useful vector graphics editor and the pressure would be on to match
    features of existing proprietary and open-source editors. Why re-invent the wheel?
    What may bear more fruit would be an effort to work with vector images produced
    by an existing mature vector editor, if this is a practical option.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们工作的扩展，这个列表会变得越来越长。最终，我们将创建一个有用的矢量图形编辑器，并且会有压力去匹配现有专有和开源编辑器的功能。为什么重造轮子？如果这是一个实际的选择，那么与现有成熟的矢量编辑器产生的矢量图像一起工作的努力可能会更有成效。
- en: Using other tools to acquire and re-work images
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用其他工具获取和重新处理图像
- en: In the next chapter, we explore ways and means of using vector images from the
    open-source vector graphics editor Inkscape. Inkscape is able to export images
    in a wide choice of formats including a standardized web format called **Scaled
    Vector Graphics** or **SVG** for short.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何使用开源矢量图形编辑器 Inkscape 中的矢量图像。Inkscape 能够导出多种格式的图像，包括一种标准化的网络格式，称为**缩放矢量图形**或简称**SVG**。
- en: How to exploit that mouse
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何利用鼠标
- en: This chapter has made much use of the mouse as a user-interaction tool for drawing
    shapes on Tkinter canvasses. To complete the job of acquiring the know-how of
    using the mouse to its fullest the next recipe will be an examination of the full
    toolkit of mouse interactions.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 本章大量使用了鼠标作为用户交互工具，在 Tkinter 画布上绘制形状。为了充分利用鼠标的技能，下一道菜谱将是对鼠标交互完整工具包的考察。
- en: We can measure the distance along a meandering line
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我们可以测量蜿蜒线上的距离
- en: In the code, there is a variable called `map_distance` that has not been used.
    It can be used to trace the distance travelled on meandering paths on maps. The
    idea is that if we wanted to measure distances on unmarked paths and roads on
    something like a Google map, we would be able to adapt this recipe to the task.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中，有一个名为 `map_distance` 的变量尚未使用。它可以用来追踪地图上蜿蜒路径的距离。想法是，如果我们想在类似谷歌地图这样的地图上测量未标记路径和道路的距离，我们就能将这个方法适应到这项任务中。
- en: All possible mouse actions
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 所有可能的鼠标动作
- en: Now we make a program that tests each possible mouse event that Python is capable
    of responding to.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们编写一个程序来测试 Python 能够响应的每个可能的鼠标事件。
- en: How to do it...
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Execute the program shown in the normal way.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 以正常方式执行显示的程序。
- en: '[PRE10]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: How it works...
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The preceding code is reasonably self-explanatory. A small canvas is created
    that is responsive to all the mouse actions. Proof that the responses are working
    correctly are by means of confirmation messages typed on the system console. We
    can adapt the `callback` functions to do any kind of task we choose simply by
    inserting appropriate Python commands into the `callback` functions.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码相当直观。创建了一个小画布，它能够响应所有鼠标操作。确认响应是否正确工作是通过在系统控制台上输入确认消息来实现的。我们可以通过在 `callback`
    函数中插入适当的 Python 命令来调整 `callback` 函数，以执行我们选择的任何任务。
- en: There's more...
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Mouse events and Tkinter widgets often work together. Most Tkinter GUI widgets
    are designed to be controlled by mouse events such as left or right-clicks or
    dragging with a button held down. Tkinter provides a versatile selection of widgets
    and these will be explored in *Chapter 10, GUI Construction Part 1* and *Chapter
    11, GUI Construction*
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 鼠标事件和 Tkinter 小部件通常协同工作。大多数 Tkinter 图形用户界面小部件都是设计用来通过鼠标事件进行控制的，例如左键或右键点击，或者按住按钮进行拖动。Tkinter
    提供了丰富的选择，这些小部件将在 *第 10 章，GUI 构建第 1 部分* 和 *第 11 章，GUI 构建第 2 部分* 中进行探讨。
