<html><head></head><body>
<div id="_idContainer166">
<h1 class="chapter-number" id="_idParaDest-230"><a id="_idTextAnchor231"/><span class="koboSpan" id="kobo.1.1">14</span></h1>
<h1 id="_idParaDest-231"><a id="_idTextAnchor232"/><span class="koboSpan" id="kobo.2.1">Where to Go Now?</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Although the previous chapter sounded like the end of the book, I thought it would be unfair to leave you without giving some guidelines regarding further development of your knowledge and skills in FX markets and creating trading algorithms (algo). </span><span class="koboSpan" id="kobo.3.2">Unlike previous chapters, where each chapter was dedicated to a single large topic, this one is a collection of short stories about different aspects of FX algo trading, aiming to provide you with starting points for </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">further research.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">Mastering any complex subject requires effort and trading is probably the most time- and labor-consuming activity, which requires a very special attitude combining the mindsets of a scientist and a businessman. </span><span class="koboSpan" id="kobo.5.2">Any successful trading strategy or algorithm is a result of many hours of work, of which only 10-20% is spent on actual coding, debugging, and refactoring; the majority of time is always spent on studying the markets, in search of trading ideas and endless trial-and-error proofs of concept. </span><span class="koboSpan" id="kobo.5.3">This chapter will give you hints both on finding your own edge in the market and making your trading apps </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">more robust.</span></span></p>
<p><span class="koboSpan" id="kobo.7.1">Don’t forget that we are all perpetual students of the market, and you will keep learning as long as you are in this complex yet exciting business of </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">algo trading.</span></span></p>
<p><span class="koboSpan" id="kobo.9.1">In this chapter, you will learn about the </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">following topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.11.1">Implementing limit and </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">stop orders</span></span></li>
<li><span class="koboSpan" id="kobo.13.1">The correct way to calculate the number </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">of trades</span></span></li>
<li><span class="koboSpan" id="kobo.15.1">From trading ideas to implementation – another sample strategy using limit and </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">stop orders</span></span></li>
<li><span class="koboSpan" id="kobo.17.1">Money management and handling </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">multiple entries</span></span></li>
<li><span class="koboSpan" id="kobo.19.1">Revisiting strategy performance – </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">more metrics</span></span></li>
<li><span class="koboSpan" id="kobo.21.1">More about the risks specific to </span><span class="No-Break"><span class="koboSpan" id="kobo.22.1">algo trading</span></span></li>
<li><span class="koboSpan" id="kobo.23.1">Classical technical </span><span class="No-Break"><span class="koboSpan" id="kobo.24.1">trading setups</span></span></li>
<li><span class="koboSpan" id="kobo.25.1">Optimization – the blessing and the curse of </span><span class="No-Break"><span class="koboSpan" id="kobo.26.1">algo trading</span></span></li>
</ul>
<h1 id="_idParaDest-232"><a id="_idTextAnchor233"/><span class="koboSpan" id="kobo.27.1">Implementing limit and stop orders</span></h1>
<p><span class="koboSpan" id="kobo.28.1">In </span><a href="B19145_10.xhtml#_idTextAnchor171"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.29.1">Chapter 10</span></em></span></a><span class="koboSpan" id="kobo.30.1">, </span><em class="italic"><span class="koboSpan" id="kobo.31.1">Types of Orders and Their Simulation in Python</span></em><span class="koboSpan" id="kobo.32.1">, we considered three main types of orders: market, limit, and stop. </span><span class="koboSpan" id="kobo.32.2">However, so far, we have only used market orders in actual codes. </span><span class="koboSpan" id="kobo.32.3">Although we noted that a live trading application may not ever use stop and limit orders because they can be emulated on the client side and sent to the market as market orders when necessary, it would be definitely useful to have both types of orders implemented in the backtester to simplify the development of </span><span class="No-Break"><span class="koboSpan" id="kobo.33.1">trading strategies.</span></span></p>
<p><span class="koboSpan" id="kobo.34.1">Let’s quickly recall the essence of limit and </span><span class="No-Break"><span class="koboSpan" id="kobo.35.1">stop orders.</span></span></p>
<p><span class="koboSpan" id="kobo.36.1">A </span><strong class="bold"><span class="koboSpan" id="kobo.37.1">limit order</span></strong><span class="koboSpan" id="kobo.38.1"> is always executed at</span><a id="_idIndexMarker938"/><span class="koboSpan" id="kobo.39.1"> a price equal to the order price </span><em class="italic"><span class="koboSpan" id="kobo.40.1">or better</span></em><span class="koboSpan" id="kobo.41.1">. </span><span class="koboSpan" id="kobo.41.2">This means that if the market price is currently 100 and a buy limit order is sent below the market, for example, at 99, then it will be filled only when the price becomes 99 </span><em class="italic"><span class="koboSpan" id="kobo.42.1">or lower</span></em><span class="koboSpan" id="kobo.43.1">. </span><span class="koboSpan" id="kobo.43.2">If a buy limit order is sent above the market, for example, at 101, then it will be executed immediately and its price will work as a cap for possible adverse price increase during the </span><span class="No-Break"><span class="koboSpan" id="kobo.44.1">order execution.</span></span></p>
<p><span class="koboSpan" id="kobo.45.1">Similarly, a </span><strong class="bold"><span class="koboSpan" id="kobo.46.1">stop order</span></strong><span class="koboSpan" id="kobo.47.1"> is always </span><a id="_idIndexMarker939"/><span class="koboSpan" id="kobo.48.1">executed at a price equal to the order price </span><em class="italic"><span class="koboSpan" id="kobo.49.1">or worse</span></em><span class="koboSpan" id="kobo.50.1">. </span><span class="koboSpan" id="kobo.50.2">Using the same example, if a buy stop order is sent below the market, then it is executed immediately, and if it is sent above the market, then it will be executed only when the market price reaches the order level. </span><span class="koboSpan" id="kobo.50.3">When executing a stop order, there is no limit on how the price may grow during </span><span class="No-Break"><span class="koboSpan" id="kobo.51.1">the execution.</span></span></p>
<p><span class="koboSpan" id="kobo.52.1">With sell orders, the situation </span><span class="No-Break"><span class="koboSpan" id="kobo.53.1">is symmetrical.</span></span></p>
<p><span class="koboSpan" id="kobo.54.1">When we emulate the execution of limit and stop orders using tick data, we can always check whether a certain tick satisfies the order condition and then assume it as the price at which the order was executed. </span><span class="koboSpan" id="kobo.54.2">However, when we work with compressed data, for example, 1 minute, 1 hour, 1 day, and so on, we have no idea at which tick the order would be actually executed. </span><span class="koboSpan" id="kobo.54.3">Instead, we assume that if the bar’s high or low crosses the order level, then the order is supposed to be filled. </span><em class="italic"><span class="koboSpan" id="kobo.55.1">Table 14.1</span></em><span class="koboSpan" id="kobo.56.1"> summarizes all the possible fill conditions for limit and </span><span class="No-Break"><span class="koboSpan" id="kobo.57.1">stop orders:</span></span></p>
<table class="T---Table" id="table001-4">
<colgroup>
<col/>
<col/>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="T---Table">
<td class="T---Table T---Body T---Body">
<p><strong class="bold"><span class="koboSpan" id="kobo.58.1">Type </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.59.1">of order</span></strong></span></p>
</td>
<td class="T---Table T---Body T---Body">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.60.1">Side</span></strong></span></p>
</td>
<td class="T---Table T---Body T---Body">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.61.1">Fill condition</span></strong></span></p>
</td>
<td class="T---Table T---Body T---Body">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.62.1">Fill price</span></strong></span></p>
</td>
</tr>
<tr class="T---Table">
<td class="T---Table T---Body T---Body">
<p><span class="No-Break"><span class="koboSpan" id="kobo.63.1">Limit</span></span></p>
</td>
<td class="T---Table T---Body T---Body">
<p><span class="No-Break"><span class="koboSpan" id="kobo.64.1">Buy</span></span></p>
</td>
<td class="T---Table T---Body T---Body">
<p><span class="koboSpan" id="kobo.65.1">Bar’s low &lt; </span><span class="No-Break"><span class="koboSpan" id="kobo.66.1">order price</span></span></p>
</td>
<td class="T---Table T---Body T---Body">
<p><span class="koboSpan" id="kobo.67.1">Minimum of the order price and the </span><span class="No-Break"><span class="koboSpan" id="kobo.68.1">bar’s open</span></span></p>
</td>
</tr>
<tr class="T---Table">
<td class="T---Table T---Body T---Body">
<p><span class="No-Break"><span class="koboSpan" id="kobo.69.1">Limit</span></span></p>
</td>
<td class="T---Table T---Body T---Body">
<p><span class="No-Break"><span class="koboSpan" id="kobo.70.1">Sell</span></span></p>
</td>
<td class="T---Table T---Body T---Body">
<p><span class="koboSpan" id="kobo.71.1">Bar’s high &gt; </span><span class="No-Break"><span class="koboSpan" id="kobo.72.1">order price</span></span></p>
</td>
<td class="T---Table T---Body T---Body">
<p><span class="koboSpan" id="kobo.73.1">Maximum of the order price and the </span><span class="No-Break"><span class="koboSpan" id="kobo.74.1">bar’s open</span></span></p>
</td>
</tr>
<tr class="T---Table">
<td class="T---Table T---Body T---Body">
<p><span class="No-Break"><span class="koboSpan" id="kobo.75.1">Stop</span></span></p>
</td>
<td class="T---Table T---Body T---Body">
<p><span class="No-Break"><span class="koboSpan" id="kobo.76.1">Buy</span></span></p>
</td>
<td class="T---Table T---Body T---Body">
<p><span class="koboSpan" id="kobo.77.1">Bar’s high &gt; </span><span class="No-Break"><span class="koboSpan" id="kobo.78.1">order price</span></span></p>
</td>
<td class="T---Table T---Body T---Body">
<p><span class="koboSpan" id="kobo.79.1">Maximum of the order price and the </span><span class="No-Break"><span class="koboSpan" id="kobo.80.1">bar’s open</span></span></p>
</td>
</tr>
<tr class="T---Table">
<td class="T---Table T---Body T---Body">
<p><span class="No-Break"><span class="koboSpan" id="kobo.81.1">Stop</span></span></p>
</td>
<td class="T---Table T---Body T---Body">
<p><span class="No-Break"><span class="koboSpan" id="kobo.82.1">Sell</span></span></p>
</td>
<td class="T---Table T---Body T---Body">
<p><span class="koboSpan" id="kobo.83.1">Bar’s low &lt; </span><span class="No-Break"><span class="koboSpan" id="kobo.84.1">order price</span></span></p>
</td>
<td class="T---Table T---Body T---Body">
<p><span class="koboSpan" id="kobo.85.1">Minimum of the order price and the </span><span class="No-Break"><span class="koboSpan" id="kobo.86.1">bar’s open</span></span></p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.87.1">Table 14.1 – Conditions to trigger limit and stop orders and their assumed execution price</span></p>
<p><span class="koboSpan" id="kobo.88.1">You can see that when backtesting using compressed data, the price at which we assume the order was </span><a id="_idIndexMarker940"/><span class="koboSpan" id="kobo.89.1">executed is not necessarily equal to the order price. </span><span class="koboSpan" id="kobo.89.2">In some cases, it can be that the bar’s </span><span class="No-Break"><span class="koboSpan" id="kobo.90.1">open. </span><span class="koboSpan" id="kobo.90.2">Why?</span></span></p>
<p><span class="koboSpan" id="kobo.91.1">To answer this</span><a id="_idIndexMarker941"/><span class="koboSpan" id="kobo.92.1"> question, we should recall that the market price is not continuous, and sometimes adjacent ticks have quite a significant difference in prices between them. </span><span class="koboSpan" id="kobo.92.2">In a bar chart, it can be seen as an </span><em class="italic"><span class="koboSpan" id="kobo.93.1">empty space</span></em><span class="koboSpan" id="kobo.94.1"> between the bar’s closed and the </span><a id="_idIndexMarker942"/><span class="koboSpan" id="kobo.95.1">next bar’s open. </span><span class="koboSpan" id="kobo.95.2">These empty spaces are </span><span class="No-Break"><span class="koboSpan" id="kobo.96.1">called </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.97.1">gaps</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.98.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.99.1">Typically, gaps on bar charts in FX markets can be seen between the close of the market on Friday and its re-opening on late Sunday. </span><span class="koboSpan" id="kobo.99.2">Normally, these gaps are not very large, but sometimes they may be quite dramatic, especially if there was some important economic or political news during the weekend. </span><span class="koboSpan" id="kobo.99.3">The following graph illustrates a weekend gap for USD/JPY on February </span><span class="No-Break"><span class="koboSpan" id="kobo.100.1">6, 2023:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer160">
<span class="koboSpan" id="kobo.101.1"><img alt="Figure 14.1 – Weekend gap in USD/JPY (chart by Multicharts)" src="image/B19145_14_01.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.102.1">Figure 14.1 – Weekend gap in USD/JPY (chart by Multicharts)</span></p>
<p><span class="koboSpan" id="kobo.103.1">The market closed on Friday, February 3, 2023, at </span><strong class="bold"><span class="koboSpan" id="kobo.104.1">131.141</span></strong><span class="koboSpan" id="kobo.105.1"> and opened on Monday, February 6, 2023, at </span><strong class="bold"><span class="koboSpan" id="kobo.106.1">132.194</span></strong><span class="koboSpan" id="kobo.107.1">. </span><span class="koboSpan" id="kobo.107.2">The difference between these prices is shown by the gray arrow. </span><span class="koboSpan" id="kobo.107.3">It is more than 100 pips, which is comparable to the average daily price movement. </span><span class="koboSpan" id="kobo.107.4">If on Friday’s close we sent a stop order to buy at, say, 131.50, then in reality, this order would </span><a id="_idIndexMarker943"/><span class="koboSpan" id="kobo.108.1">have been executed only at 132.194 (and in reality, most likely</span><a id="_idIndexMarker944"/><span class="koboSpan" id="kobo.109.1"> even worse because of slippage during an illiquid time after the open of the market). </span><span class="koboSpan" id="kobo.109.2">If we sold on Friday’s close, even if we protected our position with a stop loss – which is in fact just a stop order – well... </span><span class="koboSpan" id="kobo.109.3">we could only hope that the position size was small enough not to ruin the trading account with one </span><span class="No-Break"><span class="koboSpan" id="kobo.110.1">huge loss.</span></span></p>
<p><span class="koboSpan" id="kobo.111.1">Anyway, we now can see why we always check whether the order price is beyond the open price of the bar and why we suggest calculating the actual execution price as per the </span><strong class="bold"><span class="koboSpan" id="kobo.112.1">Fill price</span></strong><span class="koboSpan" id="kobo.113.1"> column in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.114.1">Table 14.1</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.115.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.116.1">Now that we understand how we can realistically emulate limit and stop orders, let’s proceed to coding. </span><span class="koboSpan" id="kobo.116.2">We will be working with the backtester code that we developed in </span><a href="B19145_11.xhtml#_idTextAnchor186"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.117.1">Chapter 11</span></em></span></a><span class="koboSpan" id="kobo.118.1">, </span><em class="italic"><span class="koboSpan" id="kobo.119.1">Backtesting and Theoretical Performance</span></em><span class="koboSpan" id="kobo.120.1">, and we are going to modify the </span><strong class="source-inline"><span class="koboSpan" id="kobo.121.1">emulateBrokerExecution()</span></strong><span class="koboSpan" id="kobo.122.1"> function because the order execution is isolated in it (remember the ideology </span><a id="_idIndexMarker945"/><span class="koboSpan" id="kobo.123.1">of keeping the code logic modular? </span><span class="koboSpan" id="kobo.123.2">Now, we start to</span><a id="_idIndexMarker946"/><span class="koboSpan" id="kobo.124.1"> really benefit from </span><span class="No-Break"><span class="koboSpan" id="kobo.125.1">this approach).</span></span></p>
<p><span class="koboSpan" id="kobo.126.1">Presently the </span><strong class="source-inline"><span class="koboSpan" id="kobo.127.1">emulateBrokerExecution()</span></strong><span class="koboSpan" id="kobo.128.1"> function contains an implementation only of market orders. </span><span class="koboSpan" id="kobo.128.2">Let’s add the following block of code directly </span><span class="No-Break"><span class="koboSpan" id="kobo.129.1">below it:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.130.1">
    if order['Type'] == 'Limit':
        if order['Status'] == 'Created':
            order['Status'] = 'Submitted'
        if order['Status'] == 'Submitted':
            if order['Side'] == 'Buy' and bar['Low'] &lt;= order['Price']:
                order['Status'] = 'Executed'
                order['Executed Price'] = min(order['Price'], bar['Open'])
            if order['Side'] == 'Sell' and bar['High'] &gt;= order['Price']:
                order['Status'] = 'Executed'
                order['Executed Price'] = max(order['Price'], bar['Open'])</span></pre>
<p><span class="koboSpan" id="kobo.131.1">I hope the code is transparent enough to see that it just implements the logic outlined in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.132.1">Table 14.1</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.133.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.134.1">If you want to emulate issues with execution, which are typical for limit orders, then you may want to replace </span><strong class="source-inline"><span class="koboSpan" id="kobo.135.1">&lt;=</span></strong><span class="koboSpan" id="kobo.136.1"> with </span><strong class="source-inline"><span class="koboSpan" id="kobo.137.1">&lt;</span></strong><span class="koboSpan" id="kobo.138.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.139.1">&gt;=</span></strong><span class="koboSpan" id="kobo.140.1"> with </span><strong class="source-inline"><span class="koboSpan" id="kobo.141.1">&gt;</span></strong><span class="koboSpan" id="kobo.142.1"> in the code, which check whether the bar’s price matches the order price. </span><span class="koboSpan" id="kobo.142.2">In this case, you assume that the limit order had a guaranteed fill (see </span><a href="B19145_10.xhtml#_idTextAnchor171"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.143.1">Chapter 10</span></em></span></a><span class="koboSpan" id="kobo.144.1">, </span><em class="italic"><span class="koboSpan" id="kobo.145.1">Types of Orders and Their Simulation </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.146.1">in Python</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.147.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.148.1">Now, let’s add a very similar block to simulate the execution of </span><span class="No-Break"><span class="koboSpan" id="kobo.149.1">stop orders:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.150.1">
    if order['Type'] == 'Stop':
        # print('Begin processing limit order',
                Broker.orders_list)
        if order['Status'] == 'Created':
            # Here we actually send orders to the API
            order['Status'] = 'Submitted'
        if order['Status'] == 'Submitted':
            if order['Side'] == 'Buy' and bar['High'] &gt;= order['Price']:
                order['Status'] = 'Executed'
                order['Executed Price'] = max(order['Price'], bar['Open'])
            if order['Side'] == 'Sell' and bar['Low'] &lt;= order['Price']:
                order['Status'] = 'Executed'
                order['Executed Price'] = min(order['Price'], bar['Open'])</span></pre>
<p><span class="koboSpan" id="kobo.151.1">The code is absolutely symmetrical to that of limit </span><span class="No-Break"><span class="koboSpan" id="kobo.152.1">order simulation.</span></span></p>
<p><span class="koboSpan" id="kobo.153.1">If you want to emulate slippage, which</span><a id="_idIndexMarker947"/><span class="koboSpan" id="kobo.154.1"> is typical for stop orders, then you may want to add or subtract a small</span><a id="_idIndexMarker948"/><span class="koboSpan" id="kobo.155.1"> amount from the executed price. </span><span class="koboSpan" id="kobo.155.2">Normally, if we trade liquid markets such as EUR/USD and send orders from 7 am until 9:50 p.m. </span><span class="koboSpan" id="kobo.155.3">GMT, we may not add or subtract anything. </span><span class="koboSpan" id="kobo.155.4">If we trade less liquid currency pairs, such as AUD/USD, then a slippage of 0.00001 to 0.00005 pips looks reasonable. </span><span class="koboSpan" id="kobo.155.5">If you are into more unusual pairs, such as TRY/MXN, then check the order book (if your broker provides such a pair at all!) See again </span><a href="B19145_10.xhtml#_idTextAnchor171"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.156.1">Chapter 10</span></em></span></a><span class="koboSpan" id="kobo.157.1">, </span><em class="italic"><span class="koboSpan" id="kobo.158.1">Types of Orders and Their Simulation in Python</span></em><span class="koboSpan" id="kobo.159.1">, for details on stop orders </span><span class="No-Break"><span class="koboSpan" id="kobo.160.1">and slippage.</span></span></p>
<p><span class="koboSpan" id="kobo.161.1">Note an important difference between the way we treat market, limit, or stop orders. </span><span class="koboSpan" id="kobo.161.2">A market order’s status is set to </span><strong class="source-inline"><span class="koboSpan" id="kobo.162.1">Executed</span></strong><span class="koboSpan" id="kobo.163.1"> immediately as soon as the order is received by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.164.1">emulateBrokerExecution()</span></strong><span class="koboSpan" id="kobo.165.1"> function, but the status of a limit or a stop order is first set to </span><strong class="source-inline"><span class="koboSpan" id="kobo.166.1">Submitted</span></strong><span class="koboSpan" id="kobo.167.1">. </span><span class="koboSpan" id="kobo.167.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.168.1">Submitted</span></strong><span class="koboSpan" id="kobo.169.1"> status is assigned because once generated, these orders should remain in the orders queue either until they are executed </span><span class="No-Break"><span class="koboSpan" id="kobo.170.1">or canceled.</span></span></p>
<p><span class="koboSpan" id="kobo.171.1">Now that we have added </span><a id="_idIndexMarker949"/><span class="koboSpan" id="kobo.172.1">two new types of orders, we should check whether we did </span><a id="_idIndexMarker950"/><span class="koboSpan" id="kobo.173.1">everything correctly. </span><span class="koboSpan" id="kobo.173.2">As we did in </span><a href="B19145_10.xhtml#_idTextAnchor171"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.174.1">Chapter 10</span></em></span></a><span class="koboSpan" id="kobo.175.1"> to test the execution of market orders, we will use the same source data file, which contains 1-minute bars of EUR/USD. </span><span class="koboSpan" id="kobo.175.2">We are only going to read the first 20 bars and execute one limit and one stop order to make sure that they are </span><span class="No-Break"><span class="koboSpan" id="kobo.176.1">simulated correctly.</span></span></p>
<p><span class="koboSpan" id="kobo.177.1">Before we do any testing, let’s open the source data file in any text editor, copy the first 21 lines, and paste them into an Excel spreadsheet. </span><span class="koboSpan" id="kobo.177.2">Then, we will build a chart using the </span><strong class="bold"><span class="koboSpan" id="kobo.178.1">Financial</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.179.1">chart type:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer161">
<span class="koboSpan" id="kobo.180.1"><img alt="Figure 14.2 – Test chart using the first 20 bars from the EUR/USD source data file" src="image/B19145_14_02.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.181.1">Figure 14.2 – Test chart using the first 20 bars from the EUR/USD source data file</span></p>
<p><span class="koboSpan" id="kobo.182.1">The price data starts from about </span><strong class="bold"><span class="koboSpan" id="kobo.183.1">1.1295</span></strong><span class="koboSpan" id="kobo.184.1"> and falls below </span><strong class="bold"><span class="koboSpan" id="kobo.185.1">1.1290</span></strong><span class="koboSpan" id="kobo.186.1"> on the fourth bar. </span><span class="koboSpan" id="kobo.186.2">Great, let’s place a buy limit order at </span><strong class="bold"><span class="koboSpan" id="kobo.187.1">1.1290</span></strong><span class="koboSpan" id="kobo.188.1">. </span><span class="koboSpan" id="kobo.188.2">Then, we can see that the price starts growing, but eventually falls below </span><strong class="bold"><span class="koboSpan" id="kobo.189.1">1.1285</span></strong><span class="koboSpan" id="kobo.190.1">, so let’s place a sell stop order at this level – thus emulating a stop-loss (remember that a stop-loss protects an open position from excessive losses and is always placed on</span><a id="_idIndexMarker951"/><span class="koboSpan" id="kobo.191.1"> the side opposite to the position, so in our example, it will be a sell stop). </span><span class="koboSpan" id="kobo.191.2">This</span><a id="_idIndexMarker952"/><span class="koboSpan" id="kobo.192.1"> stop order should be executed on the </span><span class="No-Break"><span class="koboSpan" id="kobo.193.1">11</span></span><span class="No-Break"><span class="superscript"><span class="koboSpan" id="kobo.194.1">th</span></span></span><span class="No-Break"><span class="koboSpan" id="kobo.195.1"> bar.</span></span></p>
<p><span class="koboSpan" id="kobo.196.1">Now, let’s get </span><span class="No-Break"><span class="koboSpan" id="kobo.197.1">to coding:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.198.1">Firstly, in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.199.1">getBar()</span></strong><span class="koboSpan" id="kobo.200.1"> function, we set the maximum number of bars to be read from </span><span class="No-Break"><span class="koboSpan" id="kobo.201.1">the file:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.202.1">
 if counter == 20:</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.203.1">
     break</span></pre></li>
<li><span class="koboSpan" id="kobo.204.1">Next, we implement the </span><em class="italic"><span class="koboSpan" id="kobo.205.1">strategy</span></em><span class="koboSpan" id="kobo.206.1"> logic so it produces only </span><span class="No-Break"><span class="koboSpan" id="kobo.207.1">two orders:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.208.1">
        if close == 1.12949 and System.market_position == 0:</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.209.1">
            order = {}</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.210.1">
            order['Type'] = 'Limit'</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.211.1">
            order['Price'] = 1.1290</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.212.1">
            order['Side'] = 'Buy'</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.213.1">
            order['Size'] = 10000</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.214.1">
            order['Status'] = 'Created'</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.215.1">
            orders_stream.put(order)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.216.1">
            order = {}</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.217.1">
            order['Type'] = 'Stop'</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.218.1">
            order['Price'] = 1.1285</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.219.1">
            order['Side'] = 'Sell'</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.220.1">
            order['Size'] = 10000</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.221.1">
            order['Status'] = 'Created'</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.222.1">
            orders_stream.put(order)</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.223.1">If we now try to run the backtest, it will produce no output because we do not process an order status of </span><strong class="bold"><span class="koboSpan" id="kobo.224.1">Submitted</span></strong><span class="koboSpan" id="kobo.225.1"> in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.226.1">processOrders()</span></strong><span class="koboSpan" id="kobo.227.1"> function yet. </span><span class="koboSpan" id="kobo.227.2">The logic of this processing is quite simple: if the order status is </span><strong class="bold"><span class="koboSpan" id="kobo.228.1">Submitted</span></strong><span class="koboSpan" id="kobo.229.1">, we should return it to the </span><span class="No-Break"><span class="koboSpan" id="kobo.230.1">orders queue.</span></span></p>
<p><span class="koboSpan" id="kobo.231.1">However, we should be very careful with returning orders to the queue. </span><span class="koboSpan" id="kobo.231.2">Don’t forget that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.232.1">processOrders()</span></strong><span class="koboSpan" id="kobo.233.1"> function uses an internal infinite loop, which retrieves orders from the queue and finishes</span><a id="_idIndexMarker953"/><span class="koboSpan" id="kobo.234.1"> working only when there is no order left. </span><span class="koboSpan" id="kobo.234.2">If we return </span><a id="_idIndexMarker954"/><span class="koboSpan" id="kobo.235.1">submitted orders back to the queue inside the same infinite loop, we will never get out </span><span class="No-Break"><span class="koboSpan" id="kobo.236.1">of it.</span></span></p>
<p><span class="koboSpan" id="kobo.237.1">Again, there are different solutions to this problem, and maybe you will suggest a better one, but let’s use the most straightforward approach for now. </span><span class="koboSpan" id="kobo.237.2">Let’s add temporary storage where we will store orders that were processed but not executed, and then put them back in the orders queue after all orders have </span><span class="No-Break"><span class="koboSpan" id="kobo.238.1">been processed.</span></span></p>
<p><span class="koboSpan" id="kobo.239.1">Let’s start by adding the </span><strong class="source-inline"><span class="koboSpan" id="kobo.240.1">self.orders_buffer = []</span></strong><span class="koboSpan" id="kobo.241.1"> temporary storage to the constructor of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.242.1">tradingSystemMetadata</span></strong><span class="koboSpan" id="kobo.243.1"> class. </span><span class="koboSpan" id="kobo.243.2">Then, let’s add the following code below the </span><strong class="source-inline"><span class="koboSpan" id="kobo.244.1">if order['Status'] == 'Executed':</span></strong><span class="koboSpan" id="kobo.245.1"> logical block in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.246.1">processOrders()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.247.1"> function:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.248.1">
if order['Status'] == 'Submitted':
    System.orders_buffer.append(order)</span></pre>
<p><span class="koboSpan" id="kobo.249.1">This will add the submitted order to the buffer. </span><span class="koboSpan" id="kobo.249.2">And finally, we will rewrite the </span><strong class="source-inline"><span class="koboSpan" id="kobo.250.1">except:</span></strong><span class="koboSpan" id="kobo.251.1"> clause </span><span class="No-Break"><span class="koboSpan" id="kobo.252.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.253.1">
for order in System.orders_buffer:
    orders_stream.put(order)
    break</span></pre>
<p><span class="koboSpan" id="kobo.254.1">The idea is that if there are no more orders in the orders queue, it raises an exception, so we can safely return all submitted orders temporarily accumulated in the buffer back to </span><span class="No-Break"><span class="koboSpan" id="kobo.255.1">the queue.</span></span></p>
<p><span class="koboSpan" id="kobo.256.1">Now, let’s run the backtest and look at the resulting </span><span class="No-Break"><span class="koboSpan" id="kobo.257.1">equity curve:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer162">
<span class="koboSpan" id="kobo.258.1"><img alt="Figure 14.3 – Equity curve" src="image/B19145_14_03.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.259.1">Figure 14.3 – Equity curve</span></p>
<p><span class="koboSpan" id="kobo.260.1">We can see that the buy </span><a id="_idIndexMarker955"/><span class="koboSpan" id="kobo.261.1">limit order indeed was executed on the 4</span><span class="superscript"><span class="koboSpan" id="kobo.262.1">th</span></span><span class="koboSpan" id="kobo.263.1"> bar (remember</span><a id="_idIndexMarker956"/><span class="koboSpan" id="kobo.264.1"> that we count from zero), then the equity started to grow, then it dropped, and, finally, the sell stop order was executed on the 11</span><span class="superscript"><span class="koboSpan" id="kobo.265.1">th</span></span><span class="koboSpan" id="kobo.266.1"> bar. </span><span class="koboSpan" id="kobo.266.2">In the console, we can check the information about the number of trades and the average </span><span class="No-Break"><span class="koboSpan" id="kobo.267.1">trade value:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.268.1">
Total trades: 2
Average trade: -2.6999999999999247</span></pre>
<p><span class="koboSpan" id="kobo.269.1">But wait a moment! </span><span class="koboSpan" id="kobo.269.2">There’s something wrong with it now. </span><span class="koboSpan" id="kobo.269.3">According to the price levels at which the orders were executed, the distance between the entry and the exit should be exactly 5 pips, but the average trade is -2.7 pips, which is even not an integer value. </span><span class="koboSpan" id="kobo.269.4">What happened? </span><span class="koboSpan" id="kobo.269.5">To answer this question, we should revise the way we calculate the number </span><span class="No-Break"><span class="koboSpan" id="kobo.270.1">of trades.</span></span></p>
<h1 id="_idParaDest-233"><a id="_idTextAnchor234"/><span class="koboSpan" id="kobo.271.1">The correct way to calculate the number of trades</span></h1>
<p><span class="koboSpan" id="kobo.272.1">When we were working with the trend-following strategy in </span><a href="B19145_12.xhtml#_idTextAnchor203"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.273.1">Chapter 12</span></em></span></a><span class="koboSpan" id="kobo.274.1">, </span><em class="italic"><span class="koboSpan" id="kobo.275.1">Sample Strategy – Trend-Following</span></em><span class="koboSpan" id="kobo.276.1">, we only opened new positions, and each opening closed the previously open one. </span><span class="koboSpan" id="kobo.276.2">This is normal for always-in-the-market strategies. </span><span class="koboSpan" id="kobo.276.3">In this case, indeed, the number of trades coincides with the number of </span><span class="No-Break"><span class="koboSpan" id="kobo.277.1">executed orders.</span></span></p>
<p><span class="koboSpan" id="kobo.278.1">In our example with a limit and</span><a id="_idIndexMarker957"/><span class="koboSpan" id="kobo.279.1"> a stop order, we use two orders to actually perform just one trade: buying and then exiting the market with a profit or loss. </span><span class="koboSpan" id="kobo.279.2">Therefore, we should only use the amount of entry orders to calculate the average trade. </span><span class="koboSpan" id="kobo.279.3">How can we distinguish between opening and </span><span class="No-Break"><span class="koboSpan" id="kobo.280.1">closing orders?</span></span></p>
<p><span class="koboSpan" id="kobo.281.1">There are multiple ways of doing that. </span><span class="koboSpan" id="kobo.281.2">One of the possible options would be adding another key to the order with values of </span><strong class="source-inline"><span class="koboSpan" id="kobo.282.1">Entry</span></strong><span class="koboSpan" id="kobo.283.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.284.1">Exit</span></strong><span class="koboSpan" id="kobo.285.1">, but we will use a different approach: we will add a new attribute to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.286.1">tradingSystemMetadata</span></strong><span class="koboSpan" id="kobo.287.1"> class, which will hold the actual number of trades, and we will update it only when the market position after the order execution is not zero, that is, the last executed order was not a </span><span class="No-Break"><span class="koboSpan" id="kobo.288.1">closing order:</span></span></p>
<ol>
<li value="1"><span class="koboSpan" id="kobo.289.1">First, let’s add </span><strong class="source-inline"><span class="koboSpan" id="kobo.290.1">self.number_of_trades = 0</span></strong><span class="koboSpan" id="kobo.291.1"> to the constructor of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.292.1">tradingSystemMetadata</span></strong><span class="koboSpan" id="kobo.293.1"> class. </span><span class="koboSpan" id="kobo.293.2">This is where we’re going to save the number </span><span class="No-Break"><span class="koboSpan" id="kobo.294.1">of trades.</span></span></li>
<li><span class="koboSpan" id="kobo.295.1">Next, we need to modify the way we count trades. </span><span class="koboSpan" id="kobo.295.2">The right place to do it is when we update the market position in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.296.1">processOrders()</span></strong><span class="koboSpan" id="kobo.297.1"> function. </span><span class="koboSpan" id="kobo.297.2">Presently, we use code that only updates the market position and does not check whether the market position is zero or not after the execution of the </span><span class="No-Break"><span class="koboSpan" id="kobo.298.1">last order:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.299.1">
if order['Side'] == 'Buy':</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.300.1">
    System.market_position = System.market_position + order['Size']</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.301.1">
if order['Side'] == 'Sell':</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.302.1">
    System.market_position = System.market_position – order['Size']</span></pre></li>
<li><span class="koboSpan" id="kobo.303.1">Now, we’re going to replace this piece of code with </span><span class="No-Break"><span class="koboSpan" id="kobo.304.1">the following:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.305.1">
if order['Side'] == 'Buy':</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.306.1">
    System.market_position = System.market_position + order['Size']</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.307.1">
    if System.market_position != 0:</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.308.1">
        System.number_of_trades += 1</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.309.1">
if order['Side'] == 'Sell':</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.310.1">
    System.market_position = System.market_position - order['Size']</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.311.1">
    if System.market_position != 0:</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.312.1">
        System.number_of_trades += 1</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.313.1">You can see that this code checks </span><a id="_idIndexMarker958"/><span class="koboSpan" id="kobo.314.1">whether the market position changed to non-zero after the trade and only in this case increases the number of trades. </span><span class="koboSpan" id="kobo.314.2">Thus, if the last order only closed the position without opening a new one, it won’t be taken </span><span class="No-Break"><span class="koboSpan" id="kobo.315.1">into account.</span></span></p>
<ol>
<li value="4"><span class="koboSpan" id="kobo.316.1">The only thing to fix now is at the very end of the code, where we print the number of trades and calculate the </span><span class="No-Break"><span class="koboSpan" id="kobo.317.1">average trade:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.318.1">
print("Total trades:", System.number_of_trades) # introduced number_of_trades</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.319.1">
print("Average trade:", System.equity / System.number_of_trades)</span></pre></li>
<li><span class="koboSpan" id="kobo.320.1">If we now re-run the backtest, we will see the </span><span class="No-Break"><span class="koboSpan" id="kobo.321.1">correct output:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.322.1">
Total trades: 1</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.323.1">
Average trade: -5.399999999999849</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.324.1">Almost there! </span><span class="koboSpan" id="kobo.324.2">The number of trades is correct, but strangely there are 0.4 extra pips in the average trade value – and according to the levels we specified in the strategy logic, the average trade should be exactly -5 pips, not -5.4. </span><span class="koboSpan" id="kobo.324.3">Where does the difference </span><span class="No-Break"><span class="koboSpan" id="kobo.325.1">come from?</span></span></p>
<ol>
<li value="6"><span class="koboSpan" id="kobo.326.1">To answer this question, we should once again critically revise the </span><strong class="source-inline"><span class="koboSpan" id="kobo.327.1">processOrders()</span></strong><span class="koboSpan" id="kobo.328.1"> function. </span><span class="koboSpan" id="kobo.328.2">When we developed it to process only market orders generated at the end of a bar, we placed the following three lines before the </span><strong class="source-inline"><span class="koboSpan" id="kobo.329.1">while True</span></strong><span class="koboSpan" id="kobo.330.1"> loop, which processes the </span><span class="No-Break"><span class="koboSpan" id="kobo.331.1">orders queue:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.332.1">
System.equity += (bar['Close'] - System.last_price) * System.market_position</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.333.1">
System.equity_timeseries.append(System.equity)</span></pre><pre class="source-code"><span class="koboSpan" id="kobo.334.1">
System.last_price = bar['Close']</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.335.1">Therefore, recalculating the equity </span><a id="_idIndexMarker959"/><span class="koboSpan" id="kobo.336.1">based on the bar’s closing price is the first thing the function does before orders start processing. </span><span class="koboSpan" id="kobo.336.2">If we only use market orders, that’s fine, we update the </span><strong class="source-inline"><span class="koboSpan" id="kobo.337.1">System.last_price</span></strong><span class="koboSpan" id="kobo.338.1"> value when we process the order and it will always coincide with the bar’s close. </span><span class="koboSpan" id="kobo.338.2">However, now that an order can be executed anywhere between the bar’s low and the bar’s high, we have an</span><a id="_idTextAnchor235"/><span class="koboSpan" id="kobo.339.1"> extra</span><a id="_idIndexMarker960"/><span class="koboSpan" id="kobo.340.1"> amount of </span><strong class="bold"><span class="koboSpan" id="kobo.341.1">profit and loss</span></strong><span class="koboSpan" id="kobo.342.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.343.1">PnL</span></strong><span class="koboSpan" id="kobo.344.1">) each time a limit or a stop order is executed, and this amount equals the difference between the order’s executed price and the bar’s close. </span><span class="koboSpan" id="kobo.344.2">So, we should modify the </span><strong class="source-inline"><span class="koboSpan" id="kobo.345.1">processOrders()</span></strong><span class="koboSpan" id="kobo.346.1"> function with the </span><span class="No-Break"><span class="koboSpan" id="kobo.347.1">following steps:</span></span></p>
<ol>
<li value="1"><span class="koboSpan" id="kobo.348.1">Let’s move the block of three lines that update the equity from the top of the code (before the </span><strong class="source-inline"><span class="koboSpan" id="kobo.349.1">while True</span></strong><span class="koboSpan" id="kobo.350.1"> loop) to the end (after the </span><strong class="source-inline"><span class="koboSpan" id="kobo.351.1">while True</span></strong><span class="koboSpan" id="kobo.352.1"> loop). </span><span class="koboSpan" id="kobo.352.2">See the </span><strong class="source-inline"><span class="koboSpan" id="kobo.353.1">Stop and limit orders.py</span></strong><span class="koboSpan" id="kobo.354.1"> code and the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.355.1">processOrders()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.356.1"> function.</span></span></li>
<li><span class="koboSpan" id="kobo.357.1">After </span><strong class="source-inline"><span class="koboSpan" id="kobo.358.1">if order['Status'] == 'Executed'</span></strong><span class="koboSpan" id="kobo.359.1">, let’s add the </span><span class="No-Break"><span class="koboSpan" id="kobo.360.1">following line:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.361.1">
System.equity += (order['Executed Price'] - System.last_price) * System.market_position</span></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.362.1">This way, we update the equity value by multiplying the price difference between the previous bar’s close (which is stored in </span><strong class="source-inline"><span class="koboSpan" id="kobo.363.1">System.last_price</span></strong><span class="koboSpan" id="kobo.364.1"> at the moment of execution of this line) and the price at which the order was executed by the market position, </span><em class="italic"><span class="koboSpan" id="kobo.365.1">which existed before the order was executed</span></em><span class="koboSpan" id="kobo.366.1">. </span><span class="koboSpan" id="kobo.366.2">Then, at the end of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.367.1">processOrders()</span></strong><span class="koboSpan" id="kobo.368.1"> function, the equity is updated once again, this time by calculating the difference between the order price and the bar’s close, </span><em class="italic"><span class="koboSpan" id="kobo.369.1">multiplied by the new market position</span></em><span class="koboSpan" id="kobo.370.1">. </span><span class="koboSpan" id="kobo.370.2">This gives us a perfectly precise calculation of the strategy equity and, consequently, the value of the </span><span class="No-Break"><span class="koboSpan" id="kobo.371.1">average trade.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.372.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.373.1">I intentionally have not published the entire code of the modified backtester here in this book. </span><span class="koboSpan" id="kobo.373.2">My goal now is to train you in the mental process of discovering new shortcomings and suggesting solutions. </span><span class="koboSpan" id="kobo.373.3">After you’re done with all modifications, I recommend downloading my code from GitHub and comparing it – this will give you an excellent opportunity to improve your skills in upgrading code logic, which is the most important and sensitive part of the entire development in </span><span class="No-Break"><span class="koboSpan" id="kobo.374.1">algo trading.</span></span></p>
<ol>
<li value="3"><span class="koboSpan" id="kobo.375.1">If we run the final </span><a id="_idIndexMarker961"/><span class="koboSpan" id="kobo.376.1">code now, we will get absolutely </span><span class="No-Break"><span class="koboSpan" id="kobo.377.1">precise values:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.378.1">Total trades: 1</span></strong></pre><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.379.1">Average trade: -4.999999999999449</span></strong></pre></li>
</ol>
<p><span class="koboSpan" id="kobo.380.1">Now that we have mastered limit and stop orders, let me give you several hints regarding further development of both backtesting and live </span><span class="No-Break"><span class="koboSpan" id="kobo.381.1">trading applications.</span></span></p>
<h1 id="_idParaDest-234"><a id="_idTextAnchor236"/><span class="koboSpan" id="kobo.382.1">From trading ideas to implementation – another sample strategy using limit and stop orders</span></h1>
<p><span class="koboSpan" id="kobo.383.1">Let’s consider a practical application of the limit and stop orders that we have just implemented. </span><span class="koboSpan" id="kobo.383.2">I like using this example</span><a id="_idIndexMarker962"/><span class="koboSpan" id="kobo.384.1"> because it illustrates the importance of having a trading idea </span><a id="_idIndexMarker963"/><span class="koboSpan" id="kobo.385.1">before writing the code and shows that trading ideas do not have to be complex. </span><span class="koboSpan" id="kobo.385.2">In practice, the simpler the trading idea, the greater the chance that it will work </span><span class="No-Break"><span class="koboSpan" id="kobo.386.1">in production.</span></span></p>
<p><span class="koboSpan" id="kobo.387.1">As you may remember from </span><a href="B19145_03.xhtml#_idTextAnchor044"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.388.1">Chapter 3</span></em></span></a><span class="koboSpan" id="kobo.389.1">, </span><em class="italic"><span class="koboSpan" id="kobo.390.1">FX Market Overview from a Developer’s Standpoint</span></em><span class="koboSpan" id="kobo.391.1">, most FX markets undergo a bank settlement procedure, which happens at 5 p.m. </span><span class="koboSpan" id="kobo.391.2">New York time. </span><span class="koboSpan" id="kobo.391.3">The price at the settlement is very important because it’s used to evaluate many other financial instruments and is used for settlement in all cash trades between any parties. </span><span class="koboSpan" id="kobo.391.4">So, comparing an</span><a id="_idIndexMarker964"/><span class="koboSpan" id="kobo.392.1"> intraday price to the last settlement price may give us an idea about the</span><a id="_idIndexMarker965"/><span class="koboSpan" id="kobo.393.1"> overall sentiment in this market: if it’s greater than the last settlement price, then the sentiment is positive – if it’s lower, the sentiment </span><span class="No-Break"><span class="koboSpan" id="kobo.394.1">is negative.</span></span></p>
<p><span class="koboSpan" id="kobo.395.1">Next, we may want to suppose that if the overall market sentiment is positive, then we can try opening a long position, and if it’s negative, a </span><span class="No-Break"><span class="koboSpan" id="kobo.396.1">short position.</span></span></p>
<p><span class="koboSpan" id="kobo.397.1">Then, we have to decide when we may want to do so. </span><span class="koboSpan" id="kobo.397.2">Naturally, it should be the time of the next settlement because, during the day, external factors such as news breaking can move the price up and down many times. </span><span class="koboSpan" id="kobo.397.3">However, remember that it’s impossible to send an order at exactly 5 p.m. </span><span class="koboSpan" id="kobo.397.4">because at that time, the market is closed and the order will be rejected. </span><span class="koboSpan" id="kobo.397.5">Besides that, several minutes before the settlement, the liquidity becomes thinner and thinner, so it may be problematic to trade, say, 1 minute before the settlement even with a small trading size. </span><span class="koboSpan" id="kobo.397.6">So, we will try entering the market 10 minutes before the </span><span class="No-Break"><span class="koboSpan" id="kobo.398.1">settlement time.</span></span></p>
<p><span class="koboSpan" id="kobo.399.1">And finally, we have to decide how long we stay in the market, or at which price we liquidate our positions. </span><span class="koboSpan" id="kobo.399.2">Let’s not be greedy and just exit with a small profit of 5 pips. </span><span class="koboSpan" id="kobo.399.3">We will use limit orders to exit the position at a certain distance from the entry price – such an order is frequently referred</span><a id="_idIndexMarker966"/><span class="koboSpan" id="kobo.400.1"> to as a </span><strong class="bold"><span class="koboSpan" id="kobo.401.1">profit target</span></strong><span class="koboSpan" id="kobo.402.1">. </span><span class="koboSpan" id="kobo.402.2">However, if the market develops the opposite way, we should liquidate our position with a loss, so we will use a stop order for this purpose. </span><span class="koboSpan" id="kobo.402.3">The question is at which level we place this </span><span class="No-Break"><span class="koboSpan" id="kobo.403.1">stop order.</span></span></p>
<p><span class="koboSpan" id="kobo.404.1">There are many opposite opinions on this subject. </span><span class="koboSpan" id="kobo.404.2">Many authors believe that stops should always be smaller than potential profits because otherwise, it looks like you risk more than you can potentially win. </span><span class="koboSpan" id="kobo.404.3">Others argue that not only the size of the win and loss matter but their probabilities are also important. </span><span class="koboSpan" id="kobo.404.4">Indeed, we can win a game even if the average loss is 2 times the average win if the percentage of wins is greater </span><span class="No-Break"><span class="koboSpan" id="kobo.405.1">than 67%.</span></span></p>
<p><span class="koboSpan" id="kobo.406.1">We have the luxury of quickly testing both approaches: let’s first try setting the stop-loss amount the same as the profit target and then increase it to stay at the position for a longer time in the hope that sooner or later, it will reach our profit </span><span class="No-Break"><span class="koboSpan" id="kobo.407.1">target level.</span></span></p>
<p><span class="koboSpan" id="kobo.408.1">As you can see, we build a market model again, as we did in </span><a href="B19145_11.xhtml#_idTextAnchor186"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.409.1">Chapter 11</span></em></span></a><span class="koboSpan" id="kobo.410.1">, but this time, the model doesn’t aim to explain the entire price time series. </span><span class="koboSpan" id="kobo.410.2">Instead, this model describes only quite a short-term market process, which may take place in the market at regular intervals. </span><span class="koboSpan" id="kobo.410.3">Generally </span><a id="_idIndexMarker967"/><span class="koboSpan" id="kobo.411.1">speaking, we can even model the entire price series this way if we find a sufficient </span><a id="_idIndexMarker968"/><span class="koboSpan" id="kobo.412.1">amount of regularly appearing </span><span class="No-Break"><span class="koboSpan" id="kobo.413.1">market processes.</span></span></p>
<p><span class="koboSpan" id="kobo.414.1">So, to summarize, the trading algorithm </span><a id="_idIndexMarker969"/><span class="koboSpan" id="kobo.415.1">should be </span><span class="No-Break"><span class="koboSpan" id="kobo.416.1">as follows:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.417.1">At 5 p.m. </span><span class="koboSpan" id="kobo.417.2">NY time, we save the close price as </span><span class="No-Break"><span class="koboSpan" id="kobo.418.1">the reference.</span></span></li>
<li><span class="koboSpan" id="kobo.419.1">At 4:50 p.m. </span><span class="koboSpan" id="kobo.419.2">NY time the next day, we compare the price to the reference. </span><span class="koboSpan" id="kobo.419.3">If the difference is positive, we buy. </span><span class="koboSpan" id="kobo.419.4">If the difference is negative, </span><span class="No-Break"><span class="koboSpan" id="kobo.420.1">we sell.</span></span></li>
<li><span class="koboSpan" id="kobo.421.1">We set a profit target of 5 pips and a stop loss of </span><span class="No-Break"><span class="koboSpan" id="kobo.422.1">5 pips.</span></span></li>
<li><span class="koboSpan" id="kobo.423.1">We stay in the market until either the profit target or the stop-loss </span><span class="No-Break"><span class="koboSpan" id="kobo.424.1">is hit.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.425.1">Is </span><span class="No-Break"><span class="koboSpan" id="kobo.426.1">that all?</span></span></p>
<p><span class="koboSpan" id="kobo.427.1">No. </span><span class="koboSpan" id="kobo.427.2">We have to cancel the other order in the </span><em class="italic"><span class="koboSpan" id="kobo.428.1">profit target – stop-loss</span></em><span class="koboSpan" id="kobo.429.1"> pair when either of them is executed. </span><span class="koboSpan" id="kobo.429.2">Otherwise, the remaining order may be triggered when the market position is flat (zero), and it will open an unexpected and unwanted position that we’ll be unable to manage. </span><span class="koboSpan" id="kobo.429.3">Orders whose execution depends on the execution of other orders are called </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.430.1">contingent orders</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.431.1">.</span></span></p>
<h2 id="_idParaDest-235"><a id="_idTextAnchor237"/><span class="koboSpan" id="kobo.432.1">Contingent orders</span></h2>
<p><span class="koboSpan" id="kobo.433.1">The backtesting and live trading codes </span><a id="_idIndexMarker970"/><span class="koboSpan" id="kobo.434.1">developed in this book assume that any order is sent to the broker and then is never modified. </span><span class="koboSpan" id="kobo.434.2">However, sometimes you want to change something in an order that has already been submitted but not executed yet. </span><span class="koboSpan" id="kobo.434.3">For example, you sent a stop-loss order, but the market conditions changed and you now want to increase or decrease the </span><span class="No-Break"><span class="koboSpan" id="kobo.435.1">order price.</span></span></p>
<p><span class="koboSpan" id="kobo.436.1">Our codes don’t support this functionality, and not all brokers support it either. </span><span class="koboSpan" id="kobo.436.2">If you want to implement it, the easiest way to do so is to add a unique identifier to each order, and then refer to it in the orders queue when modification is necessary. </span><span class="koboSpan" id="kobo.436.3">First, you have to remove the old order from the queue and then issue a new order. </span><span class="koboSpan" id="kobo.436.4">This will provide compatibility with virtually any broker because this is the preferred way of modifying orders on the </span><span class="No-Break"><span class="koboSpan" id="kobo.437.1">broker’s side.</span></span></p>
<p><span class="koboSpan" id="kobo.438.1">We are not going to implement a universal order management solution that requires the introduction of order IDs and appropriate order handling methods for now, as it is outside the scope of this book. </span><span class="koboSpan" id="kobo.438.2">We will add a small piece of code to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.439.1">processOrders()</span></strong><span class="koboSpan" id="kobo.440.1"> function that clears the entire orders queue as soon as a limit or a stop order is executed. </span><span class="koboSpan" id="kobo.440.2">This way, we can effectively implement contingent profit targets and </span><span class="No-Break"><span class="koboSpan" id="kobo.441.1">stop-loss orders.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.442.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.443.1">The suggested workaround only works if we have jsut one pair of contingent orders. </span><span class="koboSpan" id="kobo.443.2">If you want to implement a more sophisticated strategy that utilizes multiple contingent orders, there is no other way of doing it than adding order IDs and implementing routines that handle </span><span class="No-Break"><span class="koboSpan" id="kobo.444.1">orders individually.</span></span></p>
<p><span class="koboSpan" id="kobo.445.1">To implement our simple </span><a id="_idIndexMarker971"/><span class="koboSpan" id="kobo.446.1">workaround, let’s add the following code to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.447.1">processOrders()</span></strong><span class="koboSpan" id="kobo.448.1"> function at the end of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.449.1">if order['Status'] == 'Executed':</span></strong><span class="koboSpan" id="kobo.450.1"> branch, right after </span><strong class="source-inline"><span class="koboSpan" id="kobo.451.1">System.last_price = </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.452.1">order['Executed Price']</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.453.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.454.1">
if order['Type'] == 'Limit' or order['Type'] == 'Stop':
    System.orders_buffer = []
    orders_stream.queue.clear()</span></pre>
<p><span class="koboSpan" id="kobo.455.1">The idea of this code is that if any of the contingent orders have been executed (and remember, we add this to the processing of the </span><strong class="bold"><span class="koboSpan" id="kobo.456.1">Executed</span></strong><span class="koboSpan" id="kobo.457.1"> order status), then we cancel all other orders. </span><span class="koboSpan" id="kobo.457.2">Let me repeat once again that this workaround only works if we have just one pair of contingent orders in the orders queue and no other order is </span><span class="No-Break"><span class="koboSpan" id="kobo.458.1">in there.</span></span></p>
<p><span class="koboSpan" id="kobo.459.1">All that we now have to do is add the strategy logic. </span><span class="koboSpan" id="kobo.459.2">As always, we only modify the code between the </span><strong class="source-inline"><span class="koboSpan" id="kobo.460.1">trade logic starts here</span></strong><span class="koboSpan" id="kobo.461.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.462.1">trade logic ends here</span></strong><span class="koboSpan" id="kobo.463.1"> comments. </span><span class="koboSpan" id="kobo.463.2">The code is very simplistic and implements the four-step logic </span><span class="No-Break"><span class="koboSpan" id="kobo.464.1">just described:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.465.1">
        close = bar['Close']
        if bar['Time'] == '23:00:00':
            ref_close = close
        if bar['Time'] == '22:50:00' and System.market_position == 0:
            order = {}
            order['Type'] = 'Market'
            order['Price'] = close
            if close &lt; ref_close:
                order['Side'] = 'Sell'
            if close &gt; ref_close:
                order['Side'] = 'Buy'
            order['Size'] = 10000
            order['Status'] = 'Created'
            orders_stream.put(order)
            order = {}
            order['Type'] = 'Limit'
            if close &lt; ref_close:
                order['Side'] = 'Buy'
                order['Price'] = close - 0.0005
            if close &gt; ref_close:
                order['Side'] = 'Sell'
                order['Price'] = close + 0.0005
            order['Size'] = 10000
            order['Status'] = 'Created'
            orders_stream.put(order)
            order = {}
            order['Type'] = 'Stop'
            if close &lt; ref_close:
                order['Side'] = 'Buy'
                order['Price'] = close + 0.0005
            if close &gt; ref_close:
                order['Side'] = 'Sell'
                order['Price'] = close - 0.0005
            order['Size'] = 10000
            order['Status'] = 'Created'
            orders_stream.put(order)</span></pre>
<p><span class="koboSpan" id="kobo.466.1">We check whether the price is greater or less than the reference price, open a position with a market order, and immediately send a limit order to take a profit and a stop order to exit with </span><span class="No-Break"><span class="koboSpan" id="kobo.467.1">a loss.</span></span></p>
<p><span class="koboSpan" id="kobo.468.1">I am not going to consider the entire strategy code here because most of it has remained the same as developed in </span><a href="B19145_10.xhtml#_idTextAnchor171"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.469.1">Chapter 10</span></em></span></a><span class="koboSpan" id="kobo.470.1">, and the modifications that introduced limit and stop orders were </span><a id="_idIndexMarker972"/><span class="koboSpan" id="kobo.471.1">considered earlier in this chapter (see the </span><em class="italic"><span class="koboSpan" id="kobo.472.1">Implementing limit and stop orders</span></em><span class="koboSpan" id="kobo.473.1"> section). </span><span class="koboSpan" id="kobo.473.2">You can download the code from GitHub, analyze the changes made, and run it to make sure you get the </span><span class="No-Break"><span class="koboSpan" id="kobo.474.1">correct results.</span></span></p>
<p><span class="koboSpan" id="kobo.475.1">If we run the code using EUR/USD 1-minute bars as the source data, we will get an equity curve </span><span class="No-Break"><span class="koboSpan" id="kobo.476.1">like this:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer163">
<span class="koboSpan" id="kobo.477.1"><img alt="Figure 14.4 – Equity curve of a strategy with tight stops" src="image/B19145_14_04.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.478.1">Figure 14.4 – Equity curve of a strategy with tight stops</span></p>
<p><span class="koboSpan" id="kobo.479.1">We will also get the following basic performance metrics: 1,464 total trades with an average trade of about -</span><span class="No-Break"><span class="koboSpan" id="kobo.480.1">0.12 pips.</span></span></p>
<p><span class="koboSpan" id="kobo.481.1">Clearly, the strategy doesn’t work, and we even don’t have to go through an in-depth analysis of its performance. </span><span class="koboSpan" id="kobo.481.2">So, the</span><a id="_idIndexMarker973"/><span class="koboSpan" id="kobo.482.1"> idea of putting stops at the same distance as profit targets doesn’t work. </span><span class="koboSpan" id="kobo.482.2">What if we now set the stop at 50 pips instead of 5 and run the </span><span class="No-Break"><span class="koboSpan" id="kobo.483.1">code again?</span></span></p>
<p><span class="koboSpan" id="kobo.484.1">In the following graph, you can see that now the result is </span><span class="No-Break"><span class="koboSpan" id="kobo.485.1">dramatically different:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer164">
<span class="koboSpan" id="kobo.486.1"><img alt="Figure 13.5 – Equity curve of a strategy with wider stops" src="image/B19145_14_05.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.487.1">Figure 13.5 – Equity curve of a strategy with wider stops</span></p>
<p><span class="koboSpan" id="kobo.488.1">Now, we have 1,428 trades and an average trade of </span><span class="No-Break"><span class="koboSpan" id="kobo.489.1">1.18 pips.</span></span></p>
<p><span class="koboSpan" id="kobo.490.1">Is this </span><span class="No-Break"><span class="koboSpan" id="kobo.491.1">strategy tradable?</span></span></p>
<p><span class="koboSpan" id="kobo.492.1">First of all, we need to understand whether the average trade can cover all trading costs. </span><span class="koboSpan" id="kobo.492.2">The instrument traded here, the euro versus the US dollar, is by far the most liquid in the FX market and thus </span><a id="_idIndexMarker974"/><span class="koboSpan" id="kobo.493.1">normally at the time of the entry, spreads are about 0.00001-0.00002 pips, with at least 100,000 to 500,000 at top of the order book (depending on the trading venue). </span><span class="koboSpan" id="kobo.493.2">So, we shouldn’t suffer from slippage if we keep the trading size reasonable, and at first glance, it seems like we can actually trade </span><span class="No-Break"><span class="koboSpan" id="kobo.494.1">this strategy.</span></span></p>
<p><span class="koboSpan" id="kobo.495.1">I encourage you to follow all steps considered in </span><a href="B19145_13.xhtml#_idTextAnchor215"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.496.1">Chapter 13</span></em></span></a><span class="koboSpan" id="kobo.497.1">, </span><em class="italic"><span class="koboSpan" id="kobo.498.1">To Trade or Not to Trade – Performance Analysis,</span></em><span class="koboSpan" id="kobo.499.1"> and make your final decision about </span><span class="No-Break"><span class="koboSpan" id="kobo.500.1">this strategy.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.501.1">Hint</span></p>
<p class="callout"><span class="koboSpan" id="kobo.502.1">Don’t forget to take into consideration overnight swaps. </span><span class="koboSpan" id="kobo.502.2">See how they affect the </span><span class="No-Break"><span class="koboSpan" id="kobo.503.1">strategy performance.</span></span></p>
<p><span class="koboSpan" id="kobo.504.1">However, regardless of whether this strategy is tradable or not, let me emphasize once again the importance of a trading idea behind the code. </span><span class="koboSpan" id="kobo.504.2">Trading ideas do not come out of the blue: they are all based on various factors specific to a particular market. </span><span class="koboSpan" id="kobo.504.3">I’d even go further and say that </span><em class="italic"><span class="koboSpan" id="kobo.505.1">trading ideas are always based on factors that distinguish the market from a random process</span></em><span class="koboSpan" id="kobo.506.1"> in a mathematical sense. </span><span class="koboSpan" id="kobo.506.2">That’s why we have spent so much time on market fundamentals in this book, and I hope you will be able to find many other trading ideas amid the massive heap of facts that we </span><span class="No-Break"><span class="koboSpan" id="kobo.507.1">have considered.</span></span></p>
<p><span class="koboSpan" id="kobo.508.1">So far, we have been working only </span><a id="_idIndexMarker975"/><span class="koboSpan" id="kobo.509.1">with strategies that open new positions only either when the market position is zero or to reverse the currently open position. </span><span class="koboSpan" id="kobo.509.2">In this case, the edge of the strategy logic is in its ability to properly time entries and exits. </span><span class="koboSpan" id="kobo.509.3">However, there is a whole class of strategies that achieve an edge in managing multiple positions open in the same direction. </span><span class="koboSpan" id="kobo.509.4">In this case, we say that a strategy has an edge in terms of </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.510.1">money management</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.511.1">.</span></span></p>
<h1 id="_idParaDest-236"><a id="_idTextAnchor238"/><span class="koboSpan" id="kobo.512.1">Money management and multiple entries</span></h1>
<p><span class="koboSpan" id="kobo.513.1">To give you an idea about what </span><a id="_idIndexMarker976"/><span class="koboSpan" id="kobo.514.1">money management is and how it may affect strategy performance, let me tell you about probably the most famous – or infamous – kind of money management technique, known </span><a id="_idIndexMarker977"/><span class="No-Break"><span class="koboSpan" id="kobo.515.1">as </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.516.1">martingale</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.517.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.518.1">The origin of martingale is in gambling. </span><span class="koboSpan" id="kobo.518.2">Imagine the simplest gambling game of a coin toss. </span><span class="koboSpan" id="kobo.518.3">You toss the coin and if it comes up heads, you win; if it comes up tails, you lose. </span><span class="koboSpan" id="kobo.518.4">We can use </span><strong class="source-inline"><span class="koboSpan" id="kobo.519.1">1</span></strong><span class="koboSpan" id="kobo.520.1"> for wins and </span><strong class="source-inline"><span class="koboSpan" id="kobo.521.1">-1</span></strong><span class="koboSpan" id="kobo.522.1"> for losses and the</span><a id="_idIndexMarker978"/><span class="koboSpan" id="kobo.523.1"> series of tosses can be represented by a sequence </span><span class="No-Break"><span class="koboSpan" id="kobo.524.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.525.1">
S = {1, -1, -1, 1, -1, 1, 1, 1, -1, -1, 1, -1, ...}</span></pre>
<p><span class="koboSpan" id="kobo.526.1">If you put at stake an equal amount of money each time you toss the coin, we can multiply the sequence by that amount and write it </span><span class="No-Break"><span class="koboSpan" id="kobo.527.1">like so:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.528.1">
S1 = {b, -b, -b, b, -b, b, b, b, -b, -b, b, -b, ...}</span></pre>
<p><span class="koboSpan" id="kobo.529.1">Here, </span><strong class="source-inline"><span class="koboSpan" id="kobo.530.1">b</span></strong><span class="koboSpan" id="kobo.531.1"> refers to the size of the bet. </span><span class="koboSpan" id="kobo.531.2">Obviously, your total win in the game is the sum of the entire series. </span><span class="koboSpan" id="kobo.531.3">In an idealistic model, the results of each toss are independent of each other, and the probability of the coin coming up as heads or tails is strictly 50%. </span><span class="koboSpan" id="kobo.531.4">Therefore in the long term, the sum of the series will always be around zero and there is no chance to win </span><span class="No-Break"><span class="koboSpan" id="kobo.532.1">this game.</span></span></p>
<p><span class="koboSpan" id="kobo.533.1">The sum of this series is </span><a id="_idIndexMarker979"/><span class="koboSpan" id="kobo.534.1">indeed zero. </span><span class="koboSpan" id="kobo.534.2">However, things change dramatically if you start using money management in form of a martingale. </span><span class="koboSpan" id="kobo.534.3">After each new loss, you double your stake, and after each new win, you reset the bet size to its initial value. </span><span class="koboSpan" id="kobo.534.4">Then, the sequence of wins and losses transforms into </span><span class="No-Break"><span class="koboSpan" id="kobo.535.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.536.1">
S2 = {b, -b, -2b, 4b, -b, 2b, b, b, -b, -2b, 4b, -b, ...}</span></pre>
<p><span class="koboSpan" id="kobo.537.1">It’s clear that now the sum</span><a id="_idIndexMarker980"/><span class="koboSpan" id="kobo.538.1"> of the sequence is very far from zero; in our example, it is 5b. </span><span class="koboSpan" id="kobo.538.2">This means that by using money management, it is possible to win a game with outcomes of </span><span class="No-Break"><span class="koboSpan" id="kobo.539.1">equal probability.</span></span></p>
<p><span class="koboSpan" id="kobo.540.1">At first glance, the martingale looks like the ultimate method to win any game, but there are </span><span class="No-Break"><span class="koboSpan" id="kobo.541.1">two pitfalls:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.542.1">This method may work </span><a id="_idIndexMarker981"/><span class="koboSpan" id="kobo.543.1">only in a game whose outcomes are truly independent. </span><span class="koboSpan" id="kobo.543.2">In the theory of probability, processes of this kind are called </span><strong class="bold"><span class="koboSpan" id="kobo.544.1">stochastic</span></strong><span class="koboSpan" id="kobo.545.1"> (see </span><a href="B19145_06.xhtml#_idTextAnchor101"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.546.1">Chapter 6</span></em></span></a><span class="koboSpan" id="kobo.547.1">, </span><em class="italic"><span class="koboSpan" id="kobo.548.1">Basics of Fundamental Analysis and Its Possible Use in FX Trading</span></em><span class="koboSpan" id="kobo.549.1">). </span><span class="koboSpan" id="kobo.549.2">Financial time</span><a id="_idIndexMarker982"/><span class="koboSpan" id="kobo.550.1"> series are frequently considered in academic research to be stochastic, at least at the tick level, but we already know that there are certain moments and even relatively long periods when this is not true: for example, after the release of important economic news, it’s clear that upticks or downticks will prevail for some time, depending on the resonance of the news (see again </span><a href="B19145_06.xhtml#_idTextAnchor101"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.551.1">Chapter 6</span></em></span></a><span class="koboSpan" id="kobo.552.1">, </span><em class="italic"><span class="koboSpan" id="kobo.553.1">Basics of Fundamental Analysis and Its Possible Use in </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.554.1">FX Trading</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.555.1">).</span></span></li>
<li><span class="koboSpan" id="kobo.556.1">Even with a </span><em class="italic"><span class="koboSpan" id="kobo.557.1">pure</span></em><span class="koboSpan" id="kobo.558.1"> random walk process, the equal probability of outcomes is achieved only in long term (to be absolutely precise, only in an infinitely long series). </span><span class="koboSpan" id="kobo.558.2">If we analyze a short-term subsequence of outcomes, we may see a series of identical outcomes, and no one can guarantee that such a series will definitely end at a certain outcome number – exactly because the probability of a new outcome does not depend on previous outcomes! </span><span class="koboSpan" id="kobo.558.3">If you start with just $100 and double your stake with each loss, then you have to put </span><span class="koboSpan" id="kobo.559.1"><img alt="" src="image/Formula_B19145_14_001.png"/></span><span class="koboSpan" id="kobo.560.1"> on the table after the n-th loss in a series. </span><span class="koboSpan" id="kobo.560.2">After the 3</span><span class="superscript"><span class="koboSpan" id="kobo.561.1">rd</span></span><span class="koboSpan" id="kobo.562.1"> loss, you will have to bet $800, after the 4</span><span class="superscript"><span class="koboSpan" id="kobo.563.1">th</span></span><span class="koboSpan" id="kobo.564.1"> loss, $1,600, and so on, and if you are so unlucky to face a series of 10 losses in a row, then you should call your bank and ask them to provide you with a credit line because now you have to </span><span class="No-Break"><span class="koboSpan" id="kobo.565.1">bet $102,400!</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.566.1">I hope you understand why the martingale is so popular in books for illustrative purposes but </span><em class="italic"><span class="koboSpan" id="kobo.567.1">highly not recommended</span></em><span class="koboSpan" id="kobo.568.1"> for </span><span class="No-Break"><span class="koboSpan" id="kobo.569.1">practical use.</span></span></p>
<p><span class="koboSpan" id="kobo.570.1">In trading, there is a modification </span><a id="_idIndexMarker983"/><span class="koboSpan" id="kobo.571.1">of the martingale known as </span><strong class="bold"><span class="koboSpan" id="kobo.572.1">averaging down</span></strong><span class="koboSpan" id="kobo.573.1">. </span><span class="koboSpan" id="kobo.573.2">Let’s suppose that we opened a long position, but the market price went down. </span><span class="koboSpan" id="kobo.573.3">Instead of liquidating the position or </span><a id="_idIndexMarker984"/><span class="koboSpan" id="kobo.574.1">just waiting until the price returns to the initial level, we open long new positions, increasing the trading size and moving the average entry price down. </span><span class="koboSpan" id="kobo.574.2">For </span><a id="_idIndexMarker985"/><span class="koboSpan" id="kobo.575.1">example, if we originally opened a long position of 1 contract at 100.00 and then added another 1 contract at 90.00, then we actually have a position of 2 contracts opened </span><span class="No-Break"><span class="koboSpan" id="kobo.576.1">at 95.00.</span></span></p>
<p><span class="koboSpan" id="kobo.577.1">Both the martingale and</span><a id="_idIndexMarker986"/><span class="koboSpan" id="kobo.578.1"> averaging may have only limited uses and normally, traders who use them in any form apply some restrictions to the maximum size of the </span><span class="No-Break"><span class="koboSpan" id="kobo.579.1">open position.</span></span></p>
<p><span class="koboSpan" id="kobo.580.1">Like many other authors, I used the martingale and averaging down for illustrative purposes: only because they give a very clear idea of what money management is about. </span><span class="koboSpan" id="kobo.580.2">There are more conservative money management strategies, and some of them are quite sophisticated. </span><span class="koboSpan" id="kobo.580.3">If you are interested in learning more about money management strategies and looking for a single source, I’d recommend the ultimate guide written by the money management guru Van Tharp, </span><em class="italic"><span class="koboSpan" id="kobo.581.1">Definitive Guide to Position Sizing Strategies</span></em><span class="koboSpan" id="kobo.582.1">. </span><span class="koboSpan" id="kobo.582.2">If you have a more academic interest in the subject or are more inclined to collect information from various sources, I’d recommend starting with understanding the stochastic processes in general (</span><a href="https://en.wikipedia.org/wiki/Stochastic_process"><span class="koboSpan" id="kobo.583.1">https://en.wikipedia.org/wiki/Stochastic_process</span></a><span class="koboSpan" id="kobo.584.1">) and random walks in particular (</span><a href="https://en.wikipedia.org/wiki/Random_walk"><span class="koboSpan" id="kobo.585.1">https://en.wikipedia.org/wiki/Random_walk</span></a><span class="koboSpan" id="kobo.586.1">), and then referring to a book by Ralph Vince, </span><em class="italic"><span class="koboSpan" id="kobo.587.1">The Mathematics of Money Management: Risk Analysis Techniques for </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.588.1">Traders</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.589.1"> (</span></span><a href="https://www.amazon.com/Mathematics-Money-Management-Analysis-Techniques/dp/0471547387"><span class="No-Break"><span class="koboSpan" id="kobo.590.1">https://www.amazon.com/Mathematics-Money-Management-Analysis-Techniques/dp/0471547387</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.591.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.592.1">To work with money management strategies, you should be very careful with the order size. </span><span class="koboSpan" id="kobo.592.2">Presently, we have worked only with strategies that open a position with a fixed size and then close it before opening a new one. </span><span class="koboSpan" id="kobo.592.3">If you increase the position by using multiple orders in the same direction, you should carefully calculate the order size when you try to liquidate a position. </span><span class="koboSpan" id="kobo.592.4">If you make a mistake, the strategy will leave one or more positions open, and this may highly adversely impact the strategy’s performance. </span><span class="koboSpan" id="kobo.592.5">So, generally, the order handling </span><a id="_idIndexMarker987"/><span class="koboSpan" id="kobo.593.1">methods mentioned in this chapter are required for the correct implementation of money </span><span class="No-Break"><span class="koboSpan" id="kobo.594.1">management strategies.</span></span></p>
<p><span class="koboSpan" id="kobo.595.1">I would be happy to</span><a id="_idIndexMarker988"/><span class="koboSpan" id="kobo.596.1"> continue our discussions about the FX markets, systematic, and algo trading at the same level of detail as before, but unfortunately, the book’s size is limited, so I will just give you general guidelines on a few more important</span><a id="_idIndexMarker989"/><span class="koboSpan" id="kobo.597.1"> subjects for your own further studies. </span><span class="koboSpan" id="kobo.597.2">They are presented here as separate topics, without any evident logical connection </span><span class="No-Break"><span class="koboSpan" id="kobo.598.1">between them.</span></span></p>
<h1 id="_idParaDest-237"><a id="_idTextAnchor239"/><span class="koboSpan" id="kobo.599.1">Strategy performance revisited – more metrics</span></h1>
<p><span class="koboSpan" id="kobo.600.1">In </span><a href="B19145_13.xhtml#_idTextAnchor215"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.601.1">Chapter 13</span></em></span></a><span class="koboSpan" id="kobo.602.1">, </span><em class="italic"><span class="koboSpan" id="kobo.603.1">To Trade or Not to Trade – Performance Analysis</span></em><span class="koboSpan" id="kobo.604.1">, we considered only the very basic performance metrics. </span><span class="koboSpan" id="kobo.604.2">Of course, there are many others that are no less important. </span><span class="koboSpan" id="kobo.604.3">I recommend starting with</span><a id="_idIndexMarker990"/><span class="koboSpan" id="kobo.605.1"> the nice overview from </span><em class="italic"><span class="koboSpan" id="kobo.606.1">Quantinsti</span></em><span class="koboSpan" id="kobo.607.1"> (</span><a href="https://blog.quantinsti.com/performance-metrics-risk-metrics-optimization/"><span class="koboSpan" id="kobo.608.1">https://blog.quantinsti.com/performance-metrics-risk-metrics-optimization/</span></a><span class="koboSpan" id="kobo.609.1">), implementing each metric in the code, and then you can analyze your strategies as market </span><span class="No-Break"><span class="koboSpan" id="kobo.610.1">professionals do.</span></span></p>
<h1 id="_idParaDest-238"><a id="_idTextAnchor240"/><span class="koboSpan" id="kobo.611.1">More about the risks specific to algo trading</span></h1>
<p><span class="koboSpan" id="kobo.612.1">We have already considered the main risks in any trading: operational, systemic, and transactional. </span><span class="koboSpan" id="kobo.612.2">Let’s highlight another kind of risk that is specific to </span><span class="No-Break"><span class="koboSpan" id="kobo.613.1">algo trading.</span></span></p>
<p><span class="koboSpan" id="kobo.614.1">When you develop and backtest a strategy using compressed data, along with limit or stop orders, there is a risk that more than </span><a id="_idIndexMarker991"/><span class="koboSpan" id="kobo.615.1">one of these orders will be simulated on the same bar. </span><span class="koboSpan" id="kobo.615.2">Typically, this happens when the order prices are too close to each other and the data resolution is not granular enough. </span><span class="koboSpan" id="kobo.615.3">For example, if you place a limit and a stop order at a distance of 5 pips from each other and run a backtest using daily data, then on most days, both orders should be executed during a single bar. </span><span class="koboSpan" id="kobo.615.4">This is what you want to avoid at all costs because the backtester has no idea about how the price has actually moved inside this single bar and therefore no one knows which of the two orders will have been triggered first and which next. </span><span class="koboSpan" id="kobo.615.5">So, it is extremely important to </span><a id="_idIndexMarker992"/><span class="koboSpan" id="kobo.616.1">correctly choose the data resolution so that the backtesting results </span><span class="No-Break"><span class="koboSpan" id="kobo.617.1">are realistic.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.618.1">The rule of thumb for choosing the data resolution</span></p>
<p class="callout"><span class="koboSpan" id="kobo.619.1">Always choose the data resolution for which the average range of a bar (the difference between a bar’s high and low values) is less than the distance between order prices. </span><span class="koboSpan" id="kobo.619.2">If you place limit or stop orders of 100+ pips, then you can use daily data. </span><span class="koboSpan" id="kobo.619.3">If you use limit or stop orders of 20+ pips, then most likely, a timeframe of 30 minutes may work. </span><span class="koboSpan" id="kobo.619.4">If you use tight stops or limits, as in the previous example, then a 1-minute resolution is the way to go. </span><span class="koboSpan" id="kobo.619.5">Remember that only testing using tick data can give you the ultimately correct picture, although this kind of backtest will take a lot </span><span class="No-Break"><span class="koboSpan" id="kobo.620.1">of time.</span></span></p>
<h1 id="_idParaDest-239"><a id="_idTextAnchor241"/><span class="koboSpan" id="kobo.621.1">Classical technical trading setups</span></h1>
<p><span class="koboSpan" id="kobo.622.1">In </span><a href="B19145_07.xhtml#_idTextAnchor114"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.623.1">Chapter 7</span></em></span></a><span class="koboSpan" id="kobo.624.1">, </span><em class="italic"><span class="koboSpan" id="kobo.625.1">Technical Analysis and Its Implementation in Python</span></em><span class="koboSpan" id="kobo.626.1">, we considered a number of classical technical analysis indicators, such as the RSI, a stochastic oscillator, moving averages, and Bollinger bands. </span><span class="koboSpan" id="kobo.626.2">We saw that each of these indicators is able to bring into focus a certain property of the price time series: for example, Bollinger bands are a </span><a id="_idIndexMarker993"/><span class="koboSpan" id="kobo.627.1">volatility indicator, and moving averages are digital filters that remove higher frequencies from the price data. </span><span class="koboSpan" id="kobo.627.2">However, we didn’t consider any classical trading setup with any of these </span><span class="No-Break"><span class="koboSpan" id="kobo.628.1">indicators. </span><span class="koboSpan" id="kobo.628.2">Why?</span></span></p>
<p><span class="koboSpan" id="kobo.629.1">The answer to this question is twofold. </span><span class="koboSpan" id="kobo.629.2">First, these setups can be found in literally any book or internet publication about technical analysis. </span><span class="koboSpan" id="kobo.629.3">You can start with an overview of technical indicators at Investopedia (</span><a href="https://www.investopedia.com/terms/t/technicalindicator.asp"><span class="koboSpan" id="kobo.630.1">https://www.investopedia.com/terms/t/technicalindicator.asp</span></a><span class="koboSpan" id="kobo.631.1">) and then follow the links to articles on specific indicators to see how they are supposed to be used to generate </span><span class="No-Break"><span class="koboSpan" id="kobo.632.1">trading signals.</span></span></p>
<p><span class="koboSpan" id="kobo.633.1">The second and more important reason we don’t go into detail on these classical setups here is that none of them can create a profitable trading strategy as they are. </span><span class="koboSpan" id="kobo.633.2">You can try building a simple strategy by implementing any of the classical setups, then run it in multiple markets using different data resolutions, and you will see that unfortunately, none of the combinations deliver anything that could be considered </span><span class="No-Break"><span class="koboSpan" id="kobo.634.1">satisfactory performance.</span></span></p>
<p><span class="koboSpan" id="kobo.635.1">Why does this happen? </span><span class="koboSpan" id="kobo.635.2">And does it mean that technical analysis indicators are useless for </span><span class="No-Break"><span class="koboSpan" id="kobo.636.1">practical trading?</span></span></p>
<p><span class="koboSpan" id="kobo.637.1">This happens because all of the classical indicators were developed to highlight specific processes that took place in specific markets at a </span><span class="No-Break"><span class="koboSpan" id="kobo.638.1">specific time.</span></span></p>
<p><span class="koboSpan" id="kobo.639.1">For example, Welles Wilder, the creator of the RSI, developed this indicator when he traded commodity futures back in the 1970s. </span><span class="koboSpan" id="kobo.639.2">At that time, the market was relatively illiquid and was open for only a few hours a day. </span><span class="koboSpan" id="kobo.639.3">Only select traders had access to it and trades were placed either in the pit or</span><a id="_idIndexMarker994"/><span class="koboSpan" id="kobo.640.1"> by phone – and this is what commodity futures markets used to be in the 1970s. </span><span class="koboSpan" id="kobo.640.2">On the contrary, the present-day FX market is open 24/7 and is full of liquidity, with many diverse kinds of market participants, from big banks to retail traders. </span><span class="koboSpan" id="kobo.640.3">Its computerized ordering can process thousands of transactions per second. </span><span class="koboSpan" id="kobo.640.4">Compare these two markets and you will understand why the indicators of the old days may not indicate what they are </span><span class="No-Break"><span class="koboSpan" id="kobo.641.1">supposed to.</span></span></p>
<p><span class="koboSpan" id="kobo.642.1">The answer to the second question – whether classical technical indicators are useless these days – is negative. </span><span class="koboSpan" id="kobo.642.2">We still can use any or all of these indicators </span><em class="italic"><span class="koboSpan" id="kobo.643.1">if we understand what exactly they show us</span></em><span class="koboSpan" id="kobo.644.1">. </span><span class="koboSpan" id="kobo.644.2">That’s why I tried to focus on their meaning rather than just listing the well-known use cases, such as moving averages crossover (see </span><a href="https://www.investopedia.com/terms/c/crossover.asp"><span class="koboSpan" id="kobo.645.1">https://www.investopedia.com/terms/c/crossover.asp</span></a><span class="koboSpan" id="kobo.646.1">) or overbought/oversold zones identified with the RSI or a stochastic oscillator (</span><span class="No-Break"><span class="koboSpan" id="kobo.647.1">see </span></span><a href="https://www.investopedia.com/ask/answers/121214/what-are-best-indicators-identify-overbought-and-oversold-stocks.asp"><span class="No-Break"><span class="koboSpan" id="kobo.648.1">https://www.investopedia.com/ask/answers/121214/what-are-best-indicators-identify-overbought-and-oversold-stocks.asp</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.649.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.650.1">Nevertheless, despite the present-day electronic FX markets being very different from good old pit-traded futures markets, I would highly recommend reading the classic books written by the creators of technical indicators – because, in these books, they explain </span><em class="italic"><span class="koboSpan" id="kobo.651.1">why they suggested</span></em><span class="koboSpan" id="kobo.652.1"> a particular indicator, </span><em class="italic"><span class="koboSpan" id="kobo.653.1">which market process</span></em><span class="koboSpan" id="kobo.654.1"> they tried to identify using an indicator, and </span><em class="italic"><span class="koboSpan" id="kobo.655.1">how we are supposed to profit</span></em><span class="koboSpan" id="kobo.656.1"> from the </span><span class="No-Break"><span class="koboSpan" id="kobo.657.1">suggested setups.</span></span></p>
<p><span class="koboSpan" id="kobo.658.1">Spending a couple of days on thorough reading may be way more valuable than wasting weeks and months trying to fit a particular well-known technical trading setup to a market that it simply doesn’t fit by nature. </span><span class="koboSpan" id="kobo.658.2">I can recommend starting with a classic by Welles Wilder Jr., </span><em class="italic"><span class="koboSpan" id="kobo.659.1">New Concepts in Technical Trading Systems</span></em><span class="koboSpan" id="kobo.660.1">, in which he carefully explains </span><em class="italic"><span class="koboSpan" id="kobo.661.1">how he noticed certain potentially profitable market processes</span></em><span class="koboSpan" id="kobo.662.1">, </span><em class="italic"><span class="koboSpan" id="kobo.663.1">how he tried to formalize them</span></em><span class="koboSpan" id="kobo.664.1">, </span><em class="italic"><span class="koboSpan" id="kobo.665.1">how he eventually came to a set of technical indicators</span></em><span class="koboSpan" id="kobo.666.1">, and </span><em class="italic"><span class="koboSpan" id="kobo.667.1">how he actually used them to make profits</span></em><span class="koboSpan" id="kobo.668.1">. </span><span class="koboSpan" id="kobo.668.2">Focus on this </span><em class="italic"><span class="koboSpan" id="kobo.669.1">mental process</span></em><span class="koboSpan" id="kobo.670.1">, not just the numbers, and you will develop a way better understanding of the process of developing a </span><span class="No-Break"><span class="koboSpan" id="kobo.671.1">trading strategy.</span></span></p>
<p><span class="koboSpan" id="kobo.672.1">Keep in mind that behind any formula and any code, there should stand a trading idea, and trading ideas can be found</span><a id="_idIndexMarker995"/><span class="koboSpan" id="kobo.673.1"> only in the analysis of markets, not in crunching numbers or fitting an irrelevant model to the market. </span><span class="koboSpan" id="kobo.673.2">In the next section, we will see why excessive fitting may not only be counterproductive but </span><span class="No-Break"><span class="koboSpan" id="kobo.674.1">also dangerous.</span></span></p>
<h1 id="_idParaDest-240"><a id="_idTextAnchor242"/><span class="koboSpan" id="kobo.675.1">Optimization – the blessing and the curse of algo trading</span></h1>
<p><span class="koboSpan" id="kobo.676.1">Do you remember how the performance</span><a id="_idIndexMarker996"/><span class="koboSpan" id="kobo.677.1"> of a simple overnight strategy that we created earlier in this chapter radically changed when we replaced a tight stop of 5 pips with a wider stop of </span><span class="No-Break"><span class="koboSpan" id="kobo.678.1">50 pips?</span></span></p>
<p><span class="koboSpan" id="kobo.679.1">But this fact raises another important question: why 5 and 50 pips? </span><span class="koboSpan" id="kobo.679.2">Why not 6 and 45? </span><span class="koboSpan" id="kobo.679.3">Or 10 </span><span class="No-Break"><span class="koboSpan" id="kobo.680.1">and 76?</span></span></p>
<p><span class="koboSpan" id="kobo.681.1">Any quantitative strategy depends on the values of its parameters, and the procedure of finding the best combination of parameters that</span><a id="_idIndexMarker997"/><span class="koboSpan" id="kobo.682.1"> delivers the best results of the backtesting is </span><span class="No-Break"><span class="koboSpan" id="kobo.683.1">called </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.684.1">optimization</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.685.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.686.1">Optimization is a massive topic. </span><span class="koboSpan" id="kobo.686.2">I’d even say it’s overwhelmingly vast and complex. </span><span class="koboSpan" id="kobo.686.3">At first glance, it looks straightforward: let’s find the best combination of parameter values and then run the strategy live with these very values. </span><span class="koboSpan" id="kobo.686.4">However, the problem is that we always test and optimize our strategies using past data. </span><span class="koboSpan" id="kobo.686.5">And I hope you already understood and remember well that markets are anything but stationary processes. </span><span class="koboSpan" id="kobo.686.6">This means that the price behavior may change in the future, and the same strategy with the same </span><em class="italic"><span class="koboSpan" id="kobo.687.1">best</span></em><span class="koboSpan" id="kobo.688.1"> combination of parameters will start </span><span class="No-Break"><span class="koboSpan" id="kobo.689.1">losing money.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.690.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.691.1">A situation in which a strategy has been optimized using insufficient data or inappropriate logic and then starts losing money in live</span><a id="_idIndexMarker998"/><span class="koboSpan" id="kobo.692.1"> trading is known as </span><strong class="bold"><span class="koboSpan" id="kobo.693.1">overfitting</span></strong><span class="koboSpan" id="kobo.694.1"> or </span><strong class="bold"><span class="koboSpan" id="kobo.695.1">curve fitting</span></strong><span class="koboSpan" id="kobo.696.1">. </span><span class="koboSpan" id="kobo.696.2">This is considered to</span><a id="_idIndexMarker999"/><span class="koboSpan" id="kobo.697.1"> be the plague of all algo trading and the reason why many discretionary traders are still skeptical </span><span class="No-Break"><span class="koboSpan" id="kobo.698.1">about it.</span></span></p>
<p><span class="koboSpan" id="kobo.699.1">How to mitigate this </span><span class="No-Break"><span class="koboSpan" id="kobo.700.1">specific risk?</span></span></p>
<p><span class="koboSpan" id="kobo.701.1">There are various workarounds, </span><strong class="bold"><span class="koboSpan" id="kobo.702.1">forward testing</span></strong><span class="koboSpan" id="kobo.703.1"> probably being the most popular. </span><span class="koboSpan" id="kobo.703.2">When running a forward test, we first optimize the </span><a id="_idIndexMarker1000"/><span class="koboSpan" id="kobo.704.1">strategy parameters using only a subset of the entire past market data and then generate the performance report for backtesting, run on another subset of data. </span><span class="koboSpan" id="kobo.704.2">For example, if we have data from 2015 to 2023, then we may want to optimize the strategy using data from 2015 to 2017 and then test using data from 2018 to 2023. </span><span class="koboSpan" id="kobo.704.3">The backtest using the first subset is then called </span><strong class="bold"><span class="koboSpan" id="kobo.705.1">in-sample</span></strong><span class="koboSpan" id="kobo.706.1"> and</span><a id="_idIndexMarker1001"/><span class="koboSpan" id="kobo.707.1"> the backtest using the second subset is called </span><strong class="bold"><span class="koboSpan" id="kobo.708.1">out-of-sample</span></strong><span class="koboSpan" id="kobo.709.1">. </span><span class="koboSpan" id="kobo.709.2">If the </span><a id="_idIndexMarker1002"/><span class="koboSpan" id="kobo.710.1">out-of-sample strategy demonstrates performance comparable to that of the in-sample, we can estimate that it will continue working even in the future (although in reality, things may be far </span><span class="No-Break"><span class="koboSpan" id="kobo.711.1">more complex).</span></span></p>
<p><span class="koboSpan" id="kobo.712.1">Another approach is to make a forward test only on a relatively small amount of out-of-sample data, then re-optimize the strategy using newer data, and repeat the forward test on another, newer portion </span><a id="_idIndexMarker1003"/><span class="koboSpan" id="kobo.713.1">of out-of-sample data, and so on. </span><span class="koboSpan" id="kobo.713.2">In our example, we can perform a forward test optimizing the strategy using data from 2015 to 2017, then run a forward test on 2018 only, then re-optimize the strategy using data from 2016 to 2018, run a forward test on </span><a id="_idIndexMarker1004"/><span class="koboSpan" id="kobo.714.1">2019, and so on. </span><span class="koboSpan" id="kobo.714.2">Such an approach is called </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.715.1">walk-forward optimization</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.716.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.717.1">As you may have already realized, optimization is an extremely resource- and time-consuming process. </span><span class="koboSpan" id="kobo.717.2">Indeed, we need to run a backtest with one set of parameter values, then save the result, modify the parameters, run a backtest again, and repeat. </span><span class="koboSpan" id="kobo.717.3">In our sample strategy, if we wanted to find the best values for the stop-loss and profit target between 5 and 50 pips with a step of 5 pips, it would require 100 runs of the entire backtest, which would take hours on most computers. </span><span class="koboSpan" id="kobo.717.4">That’s why optimization algorithms are mostly developed using compiled versions of Python, such as Cython </span><span class="No-Break"><span class="koboSpan" id="kobo.718.1">or Numba.</span></span></p>
<p><span class="koboSpan" id="kobo.719.1">If you are interested in developing a true understanding of optimization, I’d recommend starting with the concise yet nice introduction by Davide Scassola at </span><em class="italic"><span class="koboSpan" id="kobo.720.1">Triality</span></em><span class="koboSpan" id="kobo.721.1"> (</span><a href="https://www.trality.com/blog/an-introduction-to-optimization-algorithms-for-trading-strategies"><span class="koboSpan" id="kobo.722.1">https://www.trality.com/blog/an-introduction-to-optimization-algorithms-for-trading-strategies</span></a><span class="koboSpan" id="kobo.723.1">) and then reading Robert Pardo’s book, </span><em class="italic"><span class="koboSpan" id="kobo.724.1">The Evaluation and Optimization of Trading </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.725.1">Strategies</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.726.1"> (</span></span><a href="https://www.amazon.com/Evaluation-Optimization-Trading-Strategies/dp/0470128011"><span class="No-Break"><span class="koboSpan" id="kobo.727.1">https://www.amazon.com/Evaluation-Optimization-Trading-Strategies/dp/0470128011</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.728.1">).</span></span></p>
<h1 id="_idParaDest-241"><a id="_idTextAnchor243"/><span class="koboSpan" id="kobo.729.1">Final words</span></h1>
<p><span class="koboSpan" id="kobo.730.1">Well, any story comes to an end sooner or later, and this book is no exception. </span><span class="koboSpan" id="kobo.730.2">Even if you opened it with no idea about FX markets and algo trading, now you have definitely taken yourself to a new level. </span><span class="koboSpan" id="kobo.730.3">You have knowledge about FX markets comparable to that of a beginner professional desk trader. </span><span class="koboSpan" id="kobo.730.4">You know how to develop trading applications for both live trading and producing reliable backtests. </span><span class="koboSpan" id="kobo.730.5">You also know the risks pertaining to trading, for algo trading in particular. </span><span class="koboSpan" id="kobo.730.6">You have plenty of roads to go down — in terms of money management, performance analysis, and optimization – but there is one thing I really want you to always remember whatever </span><span class="No-Break"><span class="koboSpan" id="kobo.731.1">you do:</span></span></p>
<p><span class="koboSpan" id="kobo.732.1">Any good trading strategy always has a trading idea behind it. </span><span class="koboSpan" id="kobo.732.2">No sophisticated mathematics, no money management, and no optimization will help if the strategy is just a randomly chosen combination of technical analysis studies and parameters. </span><span class="koboSpan" id="kobo.732.3">Look for ideas in the market and use the mathematical and programming apparatus to implement, test, and run them – without fear </span><span class="No-Break"><span class="koboSpan" id="kobo.733.1">or greed.</span></span></p>
</div>
</body></html>