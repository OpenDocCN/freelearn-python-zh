<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-230"><a id="_idTextAnchor231"/>14</h1>
<h1 id="_idParaDest-231"><a id="_idTextAnchor232"/>Where to Go Now?</h1>
<p>Although the previous chapter sounded like the end of the book, I thought it would be unfair to leave you without giving some guidelines regarding further development of your knowledge and skills in FX markets and creating trading algorithms (algo). Unlike previous chapters, where each chapter was dedicated to a single large topic, this one is a collection of short stories about different aspects of FX algo trading, aiming to provide you with starting points for further research.</p>
<p>Mastering any complex subject requires effort and trading is probably the most time- and labor-consuming activity, which requires a very special attitude combining the mindsets of a scientist and a businessman. Any successful trading strategy or algorithm is a result of many hours of work, of which only 10-20% is spent on actual coding, debugging, and refactoring; the majority of time is always spent on studying the markets, in search of trading ideas and endless trial-and-error proofs of concept. This chapter will give you hints both on finding your own edge in the market and making your trading apps more robust.</p>
<p>Don’t forget that we are all perpetual students of the market, and you will keep learning as long as you are in this complex yet exciting business of algo trading.</p>
<p>In this chapter, you will learn about the following topics:</p>
<ul>
<li>Implementing limit and stop orders</li>
<li>The correct way to calculate the number of trades</li>
<li>From trading ideas to implementation – another sample strategy using limit and stop orders</li>
<li>Money management and handling multiple entries</li>
<li>Revisiting strategy performance – more metrics</li>
<li>More about the risks specific to algo trading</li>
<li>Classical technical trading setups</li>
<li>Optimization – the blessing and the curse of algo trading</li>
</ul>
<h1 id="_idParaDest-232"><a id="_idTextAnchor233"/>Implementing limit and stop orders</h1>
<p>In <a href="B19145_10.xhtml#_idTextAnchor171"><em class="italic">Chapter 10</em></a>, <em class="italic">Types of Orders and Their Simulation in Python</em>, we considered three main types of orders: market, limit, and stop. However, so far, we have only used market orders in actual codes. Although we noted that a live trading application may not ever use stop and limit orders because they can be emulated on the client side and sent to the market as market orders when necessary, it would be definitely useful to have both types of orders implemented in the backtester to simplify the development of trading strategies.</p>
<p>Let’s quickly recall the essence of limit and stop orders.</p>
<p>A <strong class="bold">limit order</strong> is always executed at<a id="_idIndexMarker938"/> a price equal to the order price <em class="italic">or better</em>. This means that if the market price is currently 100 and a buy limit order is sent below the market, for example, at 99, then it will be filled only when the price becomes 99 <em class="italic">or lower</em>. If a buy limit order is sent above the market, for example, at 101, then it will be executed immediately and its price will work as a cap for possible adverse price increase during the order execution.</p>
<p>Similarly, a <strong class="bold">stop order</strong> is always <a id="_idIndexMarker939"/>executed at a price equal to the order price <em class="italic">or worse</em>. Using the same example, if a buy stop order is sent below the market, then it is executed immediately, and if it is sent above the market, then it will be executed only when the market price reaches the order level. When executing a stop order, there is no limit on how the price may grow during the execution.</p>
<p>With sell orders, the situation is symmetrical.</p>
<p>When we emulate the execution of limit and stop orders using tick data, we can always check whether a certain tick satisfies the order condition and then assume it as the price at which the order was executed. However, when we work with compressed data, for example, 1 minute, 1 hour, 1 day, and so on, we have no idea at which tick the order would be actually executed. Instead, we assume that if the bar’s high or low crosses the order level, then the order is supposed to be filled. <em class="italic">Table 14.1</em> summarizes all the possible fill conditions for limit and stop orders:</p>
<table class="T---Table" id="table001-4">
<colgroup>
<col/>
<col/>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="T---Table">
<td class="T---Table T---Body T---Body">
<p><strong class="bold">Type </strong><strong class="bold">of order</strong></p>
</td>
<td class="T---Table T---Body T---Body">
<p><strong class="bold">Side</strong></p>
</td>
<td class="T---Table T---Body T---Body">
<p><strong class="bold">Fill condition</strong></p>
</td>
<td class="T---Table T---Body T---Body">
<p><strong class="bold">Fill price</strong></p>
</td>
</tr>
<tr class="T---Table">
<td class="T---Table T---Body T---Body">
<p>Limit</p>
</td>
<td class="T---Table T---Body T---Body">
<p>Buy</p>
</td>
<td class="T---Table T---Body T---Body">
<p>Bar’s low &lt; order price</p>
</td>
<td class="T---Table T---Body T---Body">
<p>Minimum of the order price and the bar’s open</p>
</td>
</tr>
<tr class="T---Table">
<td class="T---Table T---Body T---Body">
<p>Limit</p>
</td>
<td class="T---Table T---Body T---Body">
<p>Sell</p>
</td>
<td class="T---Table T---Body T---Body">
<p>Bar’s high &gt; order price</p>
</td>
<td class="T---Table T---Body T---Body">
<p>Maximum of the order price and the bar’s open</p>
</td>
</tr>
<tr class="T---Table">
<td class="T---Table T---Body T---Body">
<p>Stop</p>
</td>
<td class="T---Table T---Body T---Body">
<p>Buy</p>
</td>
<td class="T---Table T---Body T---Body">
<p>Bar’s high &gt; order price</p>
</td>
<td class="T---Table T---Body T---Body">
<p>Maximum of the order price and the bar’s open</p>
</td>
</tr>
<tr class="T---Table">
<td class="T---Table T---Body T---Body">
<p>Stop</p>
</td>
<td class="T---Table T---Body T---Body">
<p>Sell</p>
</td>
<td class="T---Table T---Body T---Body">
<p>Bar’s low &lt; order price</p>
</td>
<td class="T---Table T---Body T---Body">
<p>Minimum of the order price and the bar’s open</p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 14.1 – Conditions to trigger limit and stop orders and their assumed execution price</p>
<p>You can see that when backtesting using compressed data, the price at which we assume the order was <a id="_idIndexMarker940"/>executed is not necessarily equal to the order price. In some cases, it can be that the bar’s open. Why?</p>
<p>To answer this<a id="_idIndexMarker941"/> question, we should recall that the market price is not continuous, and sometimes adjacent ticks have quite a significant difference in prices between them. In a bar chart, it can be seen as an <em class="italic">empty space</em> between the bar’s closed and the <a id="_idIndexMarker942"/>next bar’s open. These empty spaces are called <strong class="bold">gaps</strong>.</p>
<p>Typically, gaps on bar charts in FX markets can be seen between the close of the market on Friday and its re-opening on late Sunday. Normally, these gaps are not very large, but sometimes they may be quite dramatic, especially if there was some important economic or political news during the weekend. The following graph illustrates a weekend gap for USD/JPY on February 6, 2023:</p>
<div><div><img alt="Figure 14.1 – Weekend gap in USD/JPY (chart by Multicharts)" src="img/B19145_14_01.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.1 – Weekend gap in USD/JPY (chart by Multicharts)</p>
<p>The market closed on Friday, February 3, 2023, at <strong class="bold">131.141</strong> and opened on Monday, February 6, 2023, at <strong class="bold">132.194</strong>. The difference between these prices is shown by the gray arrow. It is more than 100 pips, which is comparable to the average daily price movement. If on Friday’s close we sent a stop order to buy at, say, 131.50, then in reality, this order would <a id="_idIndexMarker943"/>have been executed only at 132.194 (and in reality, most likely<a id="_idIndexMarker944"/> even worse because of slippage during an illiquid time after the open of the market). If we sold on Friday’s close, even if we protected our position with a stop loss – which is in fact just a stop order – well... we could only hope that the position size was small enough not to ruin the trading account with one huge loss.</p>
<p>Anyway, we now can see why we always check whether the order price is beyond the open price of the bar and why we suggest calculating the actual execution price as per the <strong class="bold">Fill price</strong> column in <em class="italic">Table 14.1</em>.</p>
<p>Now that we understand how we can realistically emulate limit and stop orders, let’s proceed to coding. We will be working with the backtester code that we developed in <a href="B19145_11.xhtml#_idTextAnchor186"><em class="italic">Chapter 11</em></a>, <em class="italic">Backtesting and Theoretical Performance</em>, and we are going to modify the <code>emulateBrokerExecution()</code> function because the order execution is isolated in it (remember the ideology <a id="_idIndexMarker945"/>of keeping the code logic modular? Now, we start to<a id="_idIndexMarker946"/> really benefit from this approach).</p>
<p>Presently the <code>emulateBrokerExecution()</code> function contains an implementation only of market orders. Let’s add the following block of code directly below it:</p>
<pre class="source-code">
    if order['Type'] == 'Limit':
        if order['Status'] == 'Created':
            order['Status'] = 'Submitted'
        if order['Status'] == 'Submitted':
            if order['Side'] == 'Buy' and bar['Low'] &lt;= order['Price']:
                order['Status'] = 'Executed'
                order['Executed Price'] = min(order['Price'], bar['Open'])
            if order['Side'] == 'Sell' and bar['High'] &gt;= order['Price']:
                order['Status'] = 'Executed'
                order['Executed Price'] = max(order['Price'], bar['Open'])</pre>
<p>I hope the code is transparent enough to see that it just implements the logic outlined in <em class="italic">Table 14.1</em>.</p>
<p>If you want to emulate issues with execution, which are typical for limit orders, then you may want to replace <code>&lt;=</code> with <code>&lt;</code> and <code>&gt;=</code> with <code>&gt;</code> in the code, which check whether the bar’s price matches the order price. In this case, you assume that the limit order had a guaranteed fill (see <a href="B19145_10.xhtml#_idTextAnchor171"><em class="italic">Chapter 10</em></a>, <em class="italic">Types of Orders and Their Simulation </em><em class="italic">in Python</em>).</p>
<p>Now, let’s add a very similar block to simulate the execution of stop orders:</p>
<pre class="source-code">
    if order['Type'] == 'Stop':
        # print('Begin processing limit order',
                Broker.orders_list)
        if order['Status'] == 'Created':
            # Here we actually send orders to the API
            order['Status'] = 'Submitted'
        if order['Status'] == 'Submitted':
            if order['Side'] == 'Buy' and bar['High'] &gt;= order['Price']:
                order['Status'] = 'Executed'
                order['Executed Price'] = max(order['Price'], bar['Open'])
            if order['Side'] == 'Sell' and bar['Low'] &lt;= order['Price']:
                order['Status'] = 'Executed'
                order['Executed Price'] = min(order['Price'], bar['Open'])</pre>
<p>The code is absolutely symmetrical to that of limit order simulation.</p>
<p>If you want to emulate slippage, which<a id="_idIndexMarker947"/> is typical for stop orders, then you may want to add or subtract a small<a id="_idIndexMarker948"/> amount from the executed price. Normally, if we trade liquid markets such as EUR/USD and send orders from 7 am until 9:50 p.m. GMT, we may not add or subtract anything. If we trade less liquid currency pairs, such as AUD/USD, then a slippage of 0.00001 to 0.00005 pips looks reasonable. If you are into more unusual pairs, such as TRY/MXN, then check the order book (if your broker provides such a pair at all!) See again <a href="B19145_10.xhtml#_idTextAnchor171"><em class="italic">Chapter 10</em></a>, <em class="italic">Types of Orders and Their Simulation in Python</em>, for details on stop orders and slippage.</p>
<p>Note an important difference between the way we treat market, limit, or stop orders. A market order’s status is set to <code>Executed</code> immediately as soon as the order is received by the <code>emulateBrokerExecution()</code> function, but the status of a limit or a stop order is first set to <code>Submitted</code>. The <code>Submitted</code> status is assigned because once generated, these orders should remain in the orders queue either until they are executed or canceled.</p>
<p>Now that we have added <a id="_idIndexMarker949"/>two new types of orders, we should check whether we did <a id="_idIndexMarker950"/>everything correctly. As we did in <a href="B19145_10.xhtml#_idTextAnchor171"><em class="italic">Chapter 10</em></a> to test the execution of market orders, we will use the same source data file, which contains 1-minute bars of EUR/USD. We are only going to read the first 20 bars and execute one limit and one stop order to make sure that they are simulated correctly.</p>
<p>Before we do any testing, let’s open the source data file in any text editor, copy the first 21 lines, and paste them into an Excel spreadsheet. Then, we will build a chart using the <strong class="bold">Financial</strong> chart type:</p>
<div><div><img alt="Figure 14.2 – Test chart using the first 20 bars from the EUR/USD source data file" src="img/B19145_14_02.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.2 – Test chart using the first 20 bars from the EUR/USD source data file</p>
<p>The price data starts from about <strong class="bold">1.1295</strong> and falls below <strong class="bold">1.1290</strong> on the fourth bar. Great, let’s place a buy limit order at <strong class="bold">1.1290</strong>. Then, we can see that the price starts growing, but eventually falls below <strong class="bold">1.1285</strong>, so let’s place a sell stop order at this level – thus emulating a stop-loss (remember that a stop-loss protects an open position from excessive losses and is always placed on<a id="_idIndexMarker951"/> the side opposite to the position, so in our example, it will be a sell stop). This<a id="_idIndexMarker952"/> stop order should be executed on the 11th bar.</p>
<p>Now, let’s get to coding:</p>
<ol>
<li>Firstly, in the <code>getBar()</code> function, we set the maximum number of bars to be read from the file:<pre class="source-code">
 if counter == 20:</pre><pre class="source-code">
     break</pre></li>
<li>Next, we implement the <em class="italic">strategy</em> logic so it produces only two orders:<pre class="source-code">
        if close == 1.12949 and System.market_position == 0:</pre><pre class="source-code">
            order = {}</pre><pre class="source-code">
            order['Type'] = 'Limit'</pre><pre class="source-code">
            order['Price'] = 1.1290</pre><pre class="source-code">
            order['Side'] = 'Buy'</pre><pre class="source-code">
            order['Size'] = 10000</pre><pre class="source-code">
            order['Status'] = 'Created'</pre><pre class="source-code">
            orders_stream.put(order)</pre><pre class="source-code">
            order = {}</pre><pre class="source-code">
            order['Type'] = 'Stop'</pre><pre class="source-code">
            order['Price'] = 1.1285</pre><pre class="source-code">
            order['Side'] = 'Sell'</pre><pre class="source-code">
            order['Size'] = 10000</pre><pre class="source-code">
            order['Status'] = 'Created'</pre><pre class="source-code">
            orders_stream.put(order)</pre></li>
</ol>
<p>If we now try to run the backtest, it will produce no output because we do not process an order status of <code>processOrders()</code> function yet. The logic of this processing is quite simple: if the order status is <strong class="bold">Submitted</strong>, we should return it to the orders queue.</p>
<p>However, we should be very careful with returning orders to the queue. Don’t forget that the <code>processOrders()</code> function uses an internal infinite loop, which retrieves orders from the queue and finishes<a id="_idIndexMarker953"/> working only when there is no order left. If we return <a id="_idIndexMarker954"/>submitted orders back to the queue inside the same infinite loop, we will never get out of it.</p>
<p>Again, there are different solutions to this problem, and maybe you will suggest a better one, but let’s use the most straightforward approach for now. Let’s add temporary storage where we will store orders that were processed but not executed, and then put them back in the orders queue after all orders have been processed.</p>
<p>Let’s start by adding the <code>self.orders_buffer = []</code> temporary storage to the constructor of the <code>tradingSystemMetadata</code> class. Then, let’s add the following code below the <code>if order['Status'] == 'Executed':</code> logical block in the <code>processOrders()</code> function:</p>
<pre class="source-code">
if order['Status'] == 'Submitted':
    System.orders_buffer.append(order)</pre>
<p>This will add the submitted order to the buffer. And finally, we will rewrite the <code>except:</code> clause as follows:</p>
<pre class="source-code">
for order in System.orders_buffer:
    orders_stream.put(order)
    break</pre>
<p>The idea is that if there are no more orders in the orders queue, it raises an exception, so we can safely return all submitted orders temporarily accumulated in the buffer back to the queue.</p>
<p>Now, let’s run the backtest and look at the resulting equity curve:</p>
<div><div><img alt="Figure 14.3 – Equity curve" src="img/B19145_14_03.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.3 – Equity curve</p>
<p>We can see that the buy <a id="_idIndexMarker955"/>limit order indeed was executed on the 4th bar (remember<a id="_idIndexMarker956"/> that we count from zero), then the equity started to grow, then it dropped, and, finally, the sell stop order was executed on the 11th bar. In the console, we can check the information about the number of trades and the average trade value:</p>
<pre class="console">
Total trades: 2
Average trade: -2.6999999999999247</pre>
<p>But wait a moment! There’s something wrong with it now. According to the price levels at which the orders were executed, the distance between the entry and the exit should be exactly 5 pips, but the average trade is -2.7 pips, which is even not an integer value. What happened? To answer this question, we should revise the way we calculate the number of trades.</p>
<h1 id="_idParaDest-233"><a id="_idTextAnchor234"/>The correct way to calculate the number of trades</h1>
<p>When we were working with the trend-following strategy in <a href="B19145_12.xhtml#_idTextAnchor203"><em class="italic">Chapter 12</em></a>, <em class="italic">Sample Strategy – Trend-Following</em>, we only opened new positions, and each opening closed the previously open one. This is normal for always-in-the-market strategies. In this case, indeed, the number of trades coincides with the number of executed orders.</p>
<p>In our example with a limit and<a id="_idIndexMarker957"/> a stop order, we use two orders to actually perform just one trade: buying and then exiting the market with a profit or loss. Therefore, we should only use the amount of entry orders to calculate the average trade. How can we distinguish between opening and closing orders?</p>
<p>There are multiple ways of doing that. One of the possible options would be adding another key to the order with values of <code>Entry</code> or <code>Exit</code>, but we will use a different approach: we will add a new attribute to the <code>tradingSystemMetadata</code> class, which will hold the actual number of trades, and we will update it only when the market position after the order execution is not zero, that is, the last executed order was not a closing order:</p>
<ol>
<li value="1">First, let’s add <code>self.number_of_trades = 0</code> to the constructor of the <code>tradingSystemMetadata</code> class. This is where we’re going to save the number of trades.</li>
<li>Next, we need to modify the way we count trades. The right place to do it is when we update the market position in the <code>processOrders()</code> function. Presently, we use code that only updates the market position and does not check whether the market position is zero or not after the execution of the last order:<pre class="source-code">
if order['Side'] == 'Buy':</pre><pre class="source-code">
    System.market_position = System.market_position + order['Size']</pre><pre class="source-code">
if order['Side'] == 'Sell':</pre><pre class="source-code">
    System.market_position = System.market_position – order['Size']</pre></li>
<li>Now, we’re going to replace this piece of code with the following:<pre class="source-code">
if order['Side'] == 'Buy':</pre><pre class="source-code">
    System.market_position = System.market_position + order['Size']</pre><pre class="source-code">
    if System.market_position != 0:</pre><pre class="source-code">
        System.number_of_trades += 1</pre><pre class="source-code">
if order['Side'] == 'Sell':</pre><pre class="source-code">
    System.market_position = System.market_position - order['Size']</pre><pre class="source-code">
    if System.market_position != 0:</pre><pre class="source-code">
        System.number_of_trades += 1</pre></li>
</ol>
<p>You can see that this code checks <a id="_idIndexMarker958"/>whether the market position changed to non-zero after the trade and only in this case increases the number of trades. Thus, if the last order only closed the position without opening a new one, it won’t be taken into account.</p>
<ol>
<li value="4">The only thing to fix now is at the very end of the code, where we print the number of trades and calculate the average trade:<pre class="source-code">
print("Total trades:", System.number_of_trades) # introduced number_of_trades</pre><pre class="source-code">
print("Average trade:", System.equity / System.number_of_trades)</pre></li>
<li>If we now re-run the backtest, we will see the correct output:<pre class="source-code">
Total trades: 1</pre><pre class="source-code">
Average trade: -5.399999999999849</pre></li>
</ol>
<p>Almost there! The number of trades is correct, but strangely there are 0.4 extra pips in the average trade value – and according to the levels we specified in the strategy logic, the average trade should be exactly -5 pips, not -5.4. Where does the difference come from?</p>
<ol>
<li value="6">To answer this question, we should once again critically revise the <code>processOrders()</code> function. When we developed it to process only market orders generated at the end of a bar, we placed the following three lines before the <code>while True</code> loop, which processes the orders queue:<pre class="source-code">
System.equity += (bar['Close'] - System.last_price) * System.market_position</pre><pre class="source-code">
System.equity_timeseries.append(System.equity)</pre><pre class="source-code">
System.last_price = bar['Close']</pre></li>
</ol>
<p>Therefore, recalculating the equity <a id="_idIndexMarker959"/>based on the bar’s closing price is the first thing the function does before orders start processing. If we only use market orders, that’s fine, we update the <code>System.last_price</code> value when we process the order and it will always coincide with the bar’s close. However, now that an order can be executed anywhere between the bar’s low and the bar’s high, we have an<a id="_idTextAnchor235"/> extra<a id="_idIndexMarker960"/> amount of <code>processOrders()</code> function with the following steps:</p>
<ol>
<li value="1">Let’s move the block of three lines that update the equity from the top of the code (before the <code>while True</code> loop) to the end (after the <code>while True</code> loop). See the <code>Stop and limit orders.py</code> code and the <code>processOrders()</code> function.</li>
<li>After <code>if order['Status'] == 'Executed'</code>, let’s add the following line:<pre class="source-code">
System.equity += (order['Executed Price'] - System.last_price) * System.market_position</pre></li>
</ol>
<p>This way, we update the equity value by multiplying the price difference between the previous bar’s close (which is stored in <code>System.last_price</code> at the moment of execution of this line) and the price at which the order was executed by the market position, <em class="italic">which existed before the order was executed</em>. Then, at the end of the <code>processOrders()</code> function, the equity is updated once again, this time by calculating the difference between the order price and the bar’s close, <em class="italic">multiplied by the new market position</em>. This gives us a perfectly precise calculation of the strategy equity and, consequently, the value of the average trade.</p>
<p class="callout-heading">Note</p>
<p class="callout">I intentionally have not published the entire code of the modified backtester here in this book. My goal now is to train you in the mental process of discovering new shortcomings and suggesting solutions. After you’re done with all modifications, I recommend downloading my code from GitHub and comparing it – this will give you an excellent opportunity to improve your skills in upgrading code logic, which is the most important and sensitive part of the entire development in algo trading.</p>
<ol>
<li value="3">If we run the final <a id="_idIndexMarker961"/>code now, we will get absolutely precise values:<pre class="source-code">
<strong class="bold">Total trades: 1</strong></pre><pre class="source-code">
<strong class="bold">Average trade: -4.999999999999449</strong></pre></li>
</ol>
<p>Now that we have mastered limit and stop orders, let me give you several hints regarding further development of both backtesting and live trading applications.</p>
<h1 id="_idParaDest-234"><a id="_idTextAnchor236"/>From trading ideas to implementation – another sample strategy using limit and stop orders</h1>
<p>Let’s consider a practical application of the limit and stop orders that we have just implemented. I like using this example<a id="_idIndexMarker962"/> because it illustrates the importance of having a trading idea <a id="_idIndexMarker963"/>before writing the code and shows that trading ideas do not have to be complex. In practice, the simpler the trading idea, the greater the chance that it will work in production.</p>
<p>As you may remember from <a href="B19145_03.xhtml#_idTextAnchor044"><em class="italic">Chapter 3</em></a>, <em class="italic">FX Market Overview from a Developer’s Standpoint</em>, most FX markets undergo a bank settlement procedure, which happens at 5 p.m. New York time. The price at the settlement is very important because it’s used to evaluate many other financial instruments and is used for settlement in all cash trades between any parties. So, comparing an<a id="_idIndexMarker964"/> intraday price to the last settlement price may give us an idea about the<a id="_idIndexMarker965"/> overall sentiment in this market: if it’s greater than the last settlement price, then the sentiment is positive – if it’s lower, the sentiment is negative.</p>
<p>Next, we may want to suppose that if the overall market sentiment is positive, then we can try opening a long position, and if it’s negative, a short position.</p>
<p>Then, we have to decide when we may want to do so. Naturally, it should be the time of the next settlement because, during the day, external factors such as news breaking can move the price up and down many times. However, remember that it’s impossible to send an order at exactly 5 p.m. because at that time, the market is closed and the order will be rejected. Besides that, several minutes before the settlement, the liquidity becomes thinner and thinner, so it may be problematic to trade, say, 1 minute before the settlement even with a small trading size. So, we will try entering the market 10 minutes before the settlement time.</p>
<p>And finally, we have to decide how long we stay in the market, or at which price we liquidate our positions. Let’s not be greedy and just exit with a small profit of 5 pips. We will use limit orders to exit the position at a certain distance from the entry price – such an order is frequently referred<a id="_idIndexMarker966"/> to as a <strong class="bold">profit target</strong>. However, if the market develops the opposite way, we should liquidate our position with a loss, so we will use a stop order for this purpose. The question is at which level we place this stop order.</p>
<p>There are many opposite opinions on this subject. Many authors believe that stops should always be smaller than potential profits because otherwise, it looks like you risk more than you can potentially win. Others argue that not only the size of the win and loss matter but their probabilities are also important. Indeed, we can win a game even if the average loss is 2 times the average win if the percentage of wins is greater than 67%.</p>
<p>We have the luxury of quickly testing both approaches: let’s first try setting the stop-loss amount the same as the profit target and then increase it to stay at the position for a longer time in the hope that sooner or later, it will reach our profit target level.</p>
<p>As you can see, we build a market model again, as we did in <a href="B19145_11.xhtml#_idTextAnchor186"><em class="italic">Chapter 11</em></a>, but this time, the model doesn’t aim to explain the entire price time series. Instead, this model describes only quite a short-term market process, which may take place in the market at regular intervals. Generally <a id="_idIndexMarker967"/>speaking, we can even model the entire price series this way if we find a sufficient <a id="_idIndexMarker968"/>amount of regularly appearing market processes.</p>
<p>So, to summarize, the trading algorithm <a id="_idIndexMarker969"/>should be as follows:</p>
<ul>
<li>At 5 p.m. NY time, we save the close price as the reference.</li>
<li>At 4:50 p.m. NY time the next day, we compare the price to the reference. If the difference is positive, we buy. If the difference is negative, we sell.</li>
<li>We set a profit target of 5 pips and a stop loss of 5 pips.</li>
<li>We stay in the market until either the profit target or the stop-loss is hit.</li>
</ul>
<p>Is that all?</p>
<p>No. We have to cancel the other order in the <em class="italic">profit target – stop-loss</em> pair when either of them is executed. Otherwise, the remaining order may be triggered when the market position is flat (zero), and it will open an unexpected and unwanted position that we’ll be unable to manage. Orders whose execution depends on the execution of other orders are called <strong class="bold">contingent orders</strong>.</p>
<h2 id="_idParaDest-235"><a id="_idTextAnchor237"/>Contingent orders</h2>
<p>The backtesting and live trading codes <a id="_idIndexMarker970"/>developed in this book assume that any order is sent to the broker and then is never modified. However, sometimes you want to change something in an order that has already been submitted but not executed yet. For example, you sent a stop-loss order, but the market conditions changed and you now want to increase or decrease the order price.</p>
<p>Our codes don’t support this functionality, and not all brokers support it either. If you want to implement it, the easiest way to do so is to add a unique identifier to each order, and then refer to it in the orders queue when modification is necessary. First, you have to remove the old order from the queue and then issue a new order. This will provide compatibility with virtually any broker because this is the preferred way of modifying orders on the broker’s side.</p>
<p>We are not going to implement a universal order management solution that requires the introduction of order IDs and appropriate order handling methods for now, as it is outside the scope of this book. We will add a small piece of code to the <code>processOrders()</code> function that clears the entire orders queue as soon as a limit or a stop order is executed. This way, we can effectively implement contingent profit targets and stop-loss orders.</p>
<p class="callout-heading">Important note</p>
<p class="callout">The suggested workaround only works if we have jsut one pair of contingent orders. If you want to implement a more sophisticated strategy that utilizes multiple contingent orders, there is no other way of doing it than adding order IDs and implementing routines that handle orders individually.</p>
<p>To implement our simple <a id="_idIndexMarker971"/>workaround, let’s add the following code to the <code>processOrders()</code> function at the end of the <code>if order['Status'] == 'Executed':</code> branch, right after <code>System.last_price = </code><code>order['Executed Price']</code>:</p>
<pre class="source-code">
if order['Type'] == 'Limit' or order['Type'] == 'Stop':
    System.orders_buffer = []
    orders_stream.queue.clear()</pre>
<p>The idea of this code is that if any of the contingent orders have been executed (and remember, we add this to the processing of the <strong class="bold">Executed</strong> order status), then we cancel all other orders. Let me repeat once again that this workaround only works if we have just one pair of contingent orders in the orders queue and no other order is in there.</p>
<p>All that we now have to do is add the strategy logic. As always, we only modify the code between the <code>trade logic starts here</code> and <code>trade logic ends here</code> comments. The code is very simplistic and implements the four-step logic just described:</p>
<pre class="source-code">
        close = bar['Close']
        if bar['Time'] == '23:00:00':
            ref_close = close
        if bar['Time'] == '22:50:00' and System.market_position == 0:
            order = {}
            order['Type'] = 'Market'
            order['Price'] = close
            if close &lt; ref_close:
                order['Side'] = 'Sell'
            if close &gt; ref_close:
                order['Side'] = 'Buy'
            order['Size'] = 10000
            order['Status'] = 'Created'
            orders_stream.put(order)
            order = {}
            order['Type'] = 'Limit'
            if close &lt; ref_close:
                order['Side'] = 'Buy'
                order['Price'] = close - 0.0005
            if close &gt; ref_close:
                order['Side'] = 'Sell'
                order['Price'] = close + 0.0005
            order['Size'] = 10000
            order['Status'] = 'Created'
            orders_stream.put(order)
            order = {}
            order['Type'] = 'Stop'
            if close &lt; ref_close:
                order['Side'] = 'Buy'
                order['Price'] = close + 0.0005
            if close &gt; ref_close:
                order['Side'] = 'Sell'
                order['Price'] = close - 0.0005
            order['Size'] = 10000
            order['Status'] = 'Created'
            orders_stream.put(order)</pre>
<p>We check whether the price is greater or less than the reference price, open a position with a market order, and immediately send a limit order to take a profit and a stop order to exit with a loss.</p>
<p>I am not going to consider the entire strategy code here because most of it has remained the same as developed in <a href="B19145_10.xhtml#_idTextAnchor171"><em class="italic">Chapter 10</em></a>, and the modifications that introduced limit and stop orders were <a id="_idIndexMarker972"/>considered earlier in this chapter (see the <em class="italic">Implementing limit and stop orders</em> section). You can download the code from GitHub, analyze the changes made, and run it to make sure you get the correct results.</p>
<p>If we run the code using EUR/USD 1-minute bars as the source data, we will get an equity curve like this:</p>
<div><div><img alt="Figure 14.4 – Equity curve of a strategy with tight stops" src="img/B19145_14_04.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 14.4 – Equity curve of a strategy with tight stops</p>
<p>We will also get the following basic performance metrics: 1,464 total trades with an average trade of about -0.12 pips.</p>
<p>Clearly, the strategy doesn’t work, and we even don’t have to go through an in-depth analysis of its performance. So, the<a id="_idIndexMarker973"/> idea of putting stops at the same distance as profit targets doesn’t work. What if we now set the stop at 50 pips instead of 5 and run the code again?</p>
<p>In the following graph, you can see that now the result is dramatically different:</p>
<div><div><img alt="Figure 13.5 – Equity curve of a strategy with wider stops" src="img/B19145_14_05.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.5 – Equity curve of a strategy with wider stops</p>
<p>Now, we have 1,428 trades and an average trade of 1.18 pips.</p>
<p>Is this strategy tradable?</p>
<p>First of all, we need to understand whether the average trade can cover all trading costs. The instrument traded here, the euro versus the US dollar, is by far the most liquid in the FX market and thus <a id="_idIndexMarker974"/>normally at the time of the entry, spreads are about 0.00001-0.00002 pips, with at least 100,000 to 500,000 at top of the order book (depending on the trading venue). So, we shouldn’t suffer from slippage if we keep the trading size reasonable, and at first glance, it seems like we can actually trade this strategy.</p>
<p>I encourage you to follow all steps considered in <a href="B19145_13.xhtml#_idTextAnchor215"><em class="italic">Chapter 13</em></a>, <em class="italic">To Trade or Not to Trade – Performance Analysis,</em> and make your final decision about this strategy.</p>
<p class="callout-heading">Hint</p>
<p class="callout">Don’t forget to take into consideration overnight swaps. See how they affect the strategy performance.</p>
<p>However, regardless of whether this strategy is tradable or not, let me emphasize once again the importance of a trading idea behind the code. Trading ideas do not come out of the blue: they are all based on various factors specific to a particular market. I’d even go further and say that <em class="italic">trading ideas are always based on factors that distinguish the market from a random process</em> in a mathematical sense. That’s why we have spent so much time on market fundamentals in this book, and I hope you will be able to find many other trading ideas amid the massive heap of facts that we have considered.</p>
<p>So far, we have been working only <a id="_idIndexMarker975"/>with strategies that open new positions only either when the market position is zero or to reverse the currently open position. In this case, the edge of the strategy logic is in its ability to properly time entries and exits. However, there is a whole class of strategies that achieve an edge in managing multiple positions open in the same direction. In this case, we say that a strategy has an edge in terms of <em class="italic">money management</em>.</p>
<h1 id="_idParaDest-236"><a id="_idTextAnchor238"/>Money management and multiple entries</h1>
<p>To give you an idea about what <a id="_idIndexMarker976"/>money management is and how it may affect strategy performance, let me tell you about probably the most famous – or infamous – kind of money management technique, known <a id="_idIndexMarker977"/>as <strong class="bold">martingale</strong>.</p>
<p>The origin of martingale is in gambling. Imagine the simplest gambling game of a coin toss. You toss the coin and if it comes up heads, you win; if it comes up tails, you lose. We can use <code>1</code> for wins and <code>-1</code> for losses and the<a id="_idIndexMarker978"/> series of tosses can be represented by a sequence as follows:</p>
<pre class="source-code">
S = {1, -1, -1, 1, -1, 1, 1, 1, -1, -1, 1, -1, ...}</pre>
<p>If you put at stake an equal amount of money each time you toss the coin, we can multiply the sequence by that amount and write it like so:</p>
<pre class="source-code">
S1 = {b, -b, -b, b, -b, b, b, b, -b, -b, b, -b, ...}</pre>
<p>Here, <code>b</code> refers to the size of the bet. Obviously, your total win in the game is the sum of the entire series. In an idealistic model, the results of each toss are independent of each other, and the probability of the coin coming up as heads or tails is strictly 50%. Therefore in the long term, the sum of the series will always be around zero and there is no chance to win this game.</p>
<p>The sum of this series is <a id="_idIndexMarker979"/>indeed zero. However, things change dramatically if you start using money management in form of a martingale. After each new loss, you double your stake, and after each new win, you reset the bet size to its initial value. Then, the sequence of wins and losses transforms into the following:</p>
<pre class="source-code">
S2 = {b, -b, -2b, 4b, -b, 2b, b, b, -b, -2b, 4b, -b, ...}</pre>
<p>It’s clear that now the sum<a id="_idIndexMarker980"/> of the sequence is very far from zero; in our example, it is 5b. This means that by using money management, it is possible to win a game with outcomes of equal probability.</p>
<p>At first glance, the martingale looks like the ultimate method to win any game, but there are two pitfalls:</p>
<ul>
<li>This method may work <a id="_idIndexMarker981"/>only in a game whose outcomes are truly independent. In the theory of probability, processes of this kind are called <strong class="bold">stochastic</strong> (see <a href="B19145_06.xhtml#_idTextAnchor101"><em class="italic">Chapter 6</em></a>, <em class="italic">Basics of Fundamental Analysis and Its Possible Use in FX Trading</em>). Financial time<a id="_idIndexMarker982"/> series are frequently considered in academic research to be stochastic, at least at the tick level, but we already know that there are certain moments and even relatively long periods when this is not true: for example, after the release of important economic news, it’s clear that upticks or downticks will prevail for some time, depending on the resonance of the news (see again <a href="B19145_06.xhtml#_idTextAnchor101"><em class="italic">Chapter 6</em></a>, <em class="italic">Basics of Fundamental Analysis and Its Possible Use in </em><em class="italic">FX Trading</em>).</li>
<li>Even with a <em class="italic">pure</em> random walk process, the equal probability of outcomes is achieved only in long term (to be absolutely precise, only in an infinitely long series). If we analyze a short-term subsequence of outcomes, we may see a series of identical outcomes, and no one can guarantee that such a series will definitely end at a certain outcome number – exactly because the probability of a new outcome does not depend on previous outcomes! If you start with just $100 and double your stake with each loss, then you have to put <img alt="" src="img/Formula_B19145_14_001.png"/> on the table after the n-th loss in a series. After the 3rd loss, you will have to bet $800, after the 4th loss, $1,600, and so on, and if you are so unlucky to face a series of 10 losses in a row, then you should call your bank and ask them to provide you with a credit line because now you have to bet $102,400!</li>
</ul>
<p>I hope you understand why the martingale is so popular in books for illustrative purposes but <em class="italic">highly not recommended</em> for practical use.</p>
<p>In trading, there is a modification <a id="_idIndexMarker983"/>of the martingale known as <strong class="bold">averaging down</strong>. Let’s suppose that we opened a long position, but the market price went down. Instead of liquidating the position or <a id="_idIndexMarker984"/>just waiting until the price returns to the initial level, we open long new positions, increasing the trading size and moving the average entry price down. For <a id="_idIndexMarker985"/>example, if we originally opened a long position of 1 contract at 100.00 and then added another 1 contract at 90.00, then we actually have a position of 2 contracts opened at 95.00.</p>
<p>Both the martingale and<a id="_idIndexMarker986"/> averaging may have only limited uses and normally, traders who use them in any form apply some restrictions to the maximum size of the open position.</p>
<p>Like many other authors, I used the martingale and averaging down for illustrative purposes: only because they give a very clear idea of what money management is about. There are more conservative money management strategies, and some of them are quite sophisticated. If you are interested in learning more about money management strategies and looking for a single source, I’d recommend the ultimate guide written by the money management guru Van Tharp, <em class="italic">Definitive Guide to Position Sizing Strategies</em>. If you have a more academic interest in the subject or are more inclined to collect information from various sources, I’d recommend starting with understanding the stochastic processes in general (<a href="https://en.wikipedia.org/wiki/Stochastic_process">https://en.wikipedia.org/wiki/Stochastic_process</a>) and random walks in particular (<a href="https://en.wikipedia.org/wiki/Random_walk">https://en.wikipedia.org/wiki/Random_walk</a>), and then referring to a book by Ralph Vince, <em class="italic">The Mathematics of Money Management: Risk Analysis Techniques for </em><em class="italic">Traders</em> (<a href="https://www.amazon.com/Mathematics-Money-Management-Analysis-Techniques/dp/0471547387">https://www.amazon.com/Mathematics-Money-Management-Analysis-Techniques/dp/0471547387</a>).</p>
<p>To work with money management strategies, you should be very careful with the order size. Presently, we have worked only with strategies that open a position with a fixed size and then close it before opening a new one. If you increase the position by using multiple orders in the same direction, you should carefully calculate the order size when you try to liquidate a position. If you make a mistake, the strategy will leave one or more positions open, and this may highly adversely impact the strategy’s performance. So, generally, the order handling <a id="_idIndexMarker987"/>methods mentioned in this chapter are required for the correct implementation of money management strategies.</p>
<p>I would be happy to<a id="_idIndexMarker988"/> continue our discussions about the FX markets, systematic, and algo trading at the same level of detail as before, but unfortunately, the book’s size is limited, so I will just give you general guidelines on a few more important<a id="_idIndexMarker989"/> subjects for your own further studies. They are presented here as separate topics, without any evident logical connection between them.</p>
<h1 id="_idParaDest-237"><a id="_idTextAnchor239"/>Strategy performance revisited – more metrics</h1>
<p>In <a href="B19145_13.xhtml#_idTextAnchor215"><em class="italic">Chapter 13</em></a>, <em class="italic">To Trade or Not to Trade – Performance Analysis</em>, we considered only the very basic performance metrics. Of course, there are many others that are no less important. I recommend starting with<a id="_idIndexMarker990"/> the nice overview from <em class="italic">Quantinsti</em> (<a href="https://blog.quantinsti.com/performance-metrics-risk-metrics-optimization/">https://blog.quantinsti.com/performance-metrics-risk-metrics-optimization/</a>), implementing each metric in the code, and then you can analyze your strategies as market professionals do.</p>
<h1 id="_idParaDest-238"><a id="_idTextAnchor240"/>More about the risks specific to algo trading</h1>
<p>We have already considered the main risks in any trading: operational, systemic, and transactional. Let’s highlight another kind of risk that is specific to algo trading.</p>
<p>When you develop and backtest a strategy using compressed data, along with limit or stop orders, there is a risk that more than <a id="_idIndexMarker991"/>one of these orders will be simulated on the same bar. Typically, this happens when the order prices are too close to each other and the data resolution is not granular enough. For example, if you place a limit and a stop order at a distance of 5 pips from each other and run a backtest using daily data, then on most days, both orders should be executed during a single bar. This is what you want to avoid at all costs because the backtester has no idea about how the price has actually moved inside this single bar and therefore no one knows which of the two orders will have been triggered first and which next. So, it is extremely important to <a id="_idIndexMarker992"/>correctly choose the data resolution so that the backtesting results are realistic.</p>
<p class="callout-heading">The rule of thumb for choosing the data resolution</p>
<p class="callout">Always choose the data resolution for which the average range of a bar (the difference between a bar’s high and low values) is less than the distance between order prices. If you place limit or stop orders of 100+ pips, then you can use daily data. If you use limit or stop orders of 20+ pips, then most likely, a timeframe of 30 minutes may work. If you use tight stops or limits, as in the previous example, then a 1-minute resolution is the way to go. Remember that only testing using tick data can give you the ultimately correct picture, although this kind of backtest will take a lot of time.</p>
<h1 id="_idParaDest-239"><a id="_idTextAnchor241"/>Classical technical trading setups</h1>
<p>In <a href="B19145_07.xhtml#_idTextAnchor114"><em class="italic">Chapter 7</em></a>, <em class="italic">Technical Analysis and Its Implementation in Python</em>, we considered a number of classical technical analysis indicators, such as the RSI, a stochastic oscillator, moving averages, and Bollinger bands. We saw that each of these indicators is able to bring into focus a certain property of the price time series: for example, Bollinger bands are a <a id="_idIndexMarker993"/>volatility indicator, and moving averages are digital filters that remove higher frequencies from the price data. However, we didn’t consider any classical trading setup with any of these indicators. Why?</p>
<p>The answer to this question is twofold. First, these setups can be found in literally any book or internet publication about technical analysis. You can start with an overview of technical indicators at Investopedia (<a href="https://www.investopedia.com/terms/t/technicalindicator.asp">https://www.investopedia.com/terms/t/technicalindicator.asp</a>) and then follow the links to articles on specific indicators to see how they are supposed to be used to generate trading signals.</p>
<p>The second and more important reason we don’t go into detail on these classical setups here is that none of them can create a profitable trading strategy as they are. You can try building a simple strategy by implementing any of the classical setups, then run it in multiple markets using different data resolutions, and you will see that unfortunately, none of the combinations deliver anything that could be considered satisfactory performance.</p>
<p>Why does this happen? And does it mean that technical analysis indicators are useless for practical trading?</p>
<p>This happens because all of the classical indicators were developed to highlight specific processes that took place in specific markets at a specific time.</p>
<p>For example, Welles Wilder, the creator of the RSI, developed this indicator when he traded commodity futures back in the 1970s. At that time, the market was relatively illiquid and was open for only a few hours a day. Only select traders had access to it and trades were placed either in the pit or<a id="_idIndexMarker994"/> by phone – and this is what commodity futures markets used to be in the 1970s. On the contrary, the present-day FX market is open 24/7 and is full of liquidity, with many diverse kinds of market participants, from big banks to retail traders. Its computerized ordering can process thousands of transactions per second. Compare these two markets and you will understand why the indicators of the old days may not indicate what they are supposed to.</p>
<p>The answer to the second question – whether classical technical indicators are useless these days – is negative. We still can use any or all of these indicators <em class="italic">if we understand what exactly they show us</em>. That’s why I tried to focus on their meaning rather than just listing the well-known use cases, such as moving averages crossover (see <a href="https://www.investopedia.com/terms/c/crossover.asp">https://www.investopedia.com/terms/c/crossover.asp</a>) or overbought/oversold zones identified with the RSI or a stochastic oscillator (see <a href="https://www.investopedia.com/ask/answers/121214/what-are-best-indicators-identify-overbought-and-oversold-stocks.asp">https://www.investopedia.com/ask/answers/121214/what-are-best-indicators-identify-overbought-and-oversold-stocks.asp</a>).</p>
<p>Nevertheless, despite the present-day electronic FX markets being very different from good old pit-traded futures markets, I would highly recommend reading the classic books written by the creators of technical indicators – because, in these books, they explain <em class="italic">why they suggested</em> a particular indicator, <em class="italic">which market process</em> they tried to identify using an indicator, and <em class="italic">how we are supposed to profit</em> from the suggested setups.</p>
<p>Spending a couple of days on thorough reading may be way more valuable than wasting weeks and months trying to fit a particular well-known technical trading setup to a market that it simply doesn’t fit by nature. I can recommend starting with a classic by Welles Wilder Jr., <em class="italic">New Concepts in Technical Trading Systems</em>, in which he carefully explains <em class="italic">how he noticed certain potentially profitable market processes</em>, <em class="italic">how he tried to formalize them</em>, <em class="italic">how he eventually came to a set of technical indicators</em>, and <em class="italic">how he actually used them to make profits</em>. Focus on this <em class="italic">mental process</em>, not just the numbers, and you will develop a way better understanding of the process of developing a trading strategy.</p>
<p>Keep in mind that behind any formula and any code, there should stand a trading idea, and trading ideas can be found<a id="_idIndexMarker995"/> only in the analysis of markets, not in crunching numbers or fitting an irrelevant model to the market. In the next section, we will see why excessive fitting may not only be counterproductive but also dangerous.</p>
<h1 id="_idParaDest-240"><a id="_idTextAnchor242"/>Optimization – the blessing and the curse of algo trading</h1>
<p>Do you remember how the performance<a id="_idIndexMarker996"/> of a simple overnight strategy that we created earlier in this chapter radically changed when we replaced a tight stop of 5 pips with a wider stop of 50 pips?</p>
<p>But this fact raises another important question: why 5 and 50 pips? Why not 6 and 45? Or 10 and 76?</p>
<p>Any quantitative strategy depends on the values of its parameters, and the procedure of finding the best combination of parameters that<a id="_idIndexMarker997"/> delivers the best results of the backtesting is called <strong class="bold">optimization</strong>.</p>
<p>Optimization is a massive topic. I’d even say it’s overwhelmingly vast and complex. At first glance, it looks straightforward: let’s find the best combination of parameter values and then run the strategy live with these very values. However, the problem is that we always test and optimize our strategies using past data. And I hope you already understood and remember well that markets are anything but stationary processes. This means that the price behavior may change in the future, and the same strategy with the same <em class="italic">best</em> combination of parameters will start losing money.</p>
<p class="callout-heading">Note</p>
<p class="callout">A situation in which a strategy has been optimized using insufficient data or inappropriate logic and then starts losing money in live<a id="_idIndexMarker998"/> trading is known as <strong class="bold">overfitting</strong> or <strong class="bold">curve fitting</strong>. This is considered to<a id="_idIndexMarker999"/> be the plague of all algo trading and the reason why many discretionary traders are still skeptical about it.</p>
<p>How to mitigate this specific risk?</p>
<p>There are various workarounds, <strong class="bold">forward testing</strong> probably being the most popular. When running a forward test, we first optimize the <a id="_idIndexMarker1000"/>strategy parameters using only a subset of the entire past market data and then generate the performance report for backtesting, run on another subset of data. For example, if we have data from 2015 to 2023, then we may want to optimize the strategy using data from 2015 to 2017 and then test using data from 2018 to 2023. The backtest using the first subset is then called <strong class="bold">in-sample</strong> and<a id="_idIndexMarker1001"/> the backtest using the second subset is called <strong class="bold">out-of-sample</strong>. If the <a id="_idIndexMarker1002"/>out-of-sample strategy demonstrates performance comparable to that of the in-sample, we can estimate that it will continue working even in the future (although in reality, things may be far more complex).</p>
<p>Another approach is to make a forward test only on a relatively small amount of out-of-sample data, then re-optimize the strategy using newer data, and repeat the forward test on another, newer portion <a id="_idIndexMarker1003"/>of out-of-sample data, and so on. In our example, we can perform a forward test optimizing the strategy using data from 2015 to 2017, then run a forward test on 2018 only, then re-optimize the strategy using data from 2016 to 2018, run a forward test on <a id="_idIndexMarker1004"/>2019, and so on. Such an approach is called <strong class="bold">walk-forward optimization</strong>.</p>
<p>As you may have already realized, optimization is an extremely resource- and time-consuming process. Indeed, we need to run a backtest with one set of parameter values, then save the result, modify the parameters, run a backtest again, and repeat. In our sample strategy, if we wanted to find the best values for the stop-loss and profit target between 5 and 50 pips with a step of 5 pips, it would require 100 runs of the entire backtest, which would take hours on most computers. That’s why optimization algorithms are mostly developed using compiled versions of Python, such as Cython or Numba.</p>
<p>If you are interested in developing a true understanding of optimization, I’d recommend starting with the concise yet nice introduction by Davide Scassola at <em class="italic">Triality</em> (<a href="https://www.trality.com/blog/an-introduction-to-optimization-algorithms-for-trading-strategies">https://www.trality.com/blog/an-introduction-to-optimization-algorithms-for-trading-strategies</a>) and then reading Robert Pardo’s book, <em class="italic">The Evaluation and Optimization of Trading </em><em class="italic">Strategies</em> (<a href="https://www.amazon.com/Evaluation-Optimization-Trading-Strategies/dp/0470128011">https://www.amazon.com/Evaluation-Optimization-Trading-Strategies/dp/0470128011</a>).</p>
<h1 id="_idParaDest-241"><a id="_idTextAnchor243"/>Final words</h1>
<p>Well, any story comes to an end sooner or later, and this book is no exception. Even if you opened it with no idea about FX markets and algo trading, now you have definitely taken yourself to a new level. You have knowledge about FX markets comparable to that of a beginner professional desk trader. You know how to develop trading applications for both live trading and producing reliable backtests. You also know the risks pertaining to trading, for algo trading in particular. You have plenty of roads to go down — in terms of money management, performance analysis, and optimization – but there is one thing I really want you to always remember whatever you do:</p>
<p>Any good trading strategy always has a trading idea behind it. No sophisticated mathematics, no money management, and no optimization will help if the strategy is just a randomly chosen combination of technical analysis studies and parameters. Look for ideas in the market and use the mathematical and programming apparatus to implement, test, and run them – without fear or greed.</p>
</div>
</body></html>