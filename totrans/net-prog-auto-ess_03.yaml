- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Accessing the Network
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we looked into programmable networks and their history.
    One of the ideas we explored was **Software-Defined Networking** (**SDN**), where
    we saw why the separation between the data plane and the control plane was important.
    One important point of SDN was its architecture and how it separates the **North
    Bound Interface** (**NBI**) and **South Bound Interface** (**SBI**). In this chapter,
    we are going to explore how to access the network devices that can be interpreted
    as the SBI for SDN when OpenFlow is not available on the device.
  prefs: []
  type: TYPE_NORMAL
- en: As we have seen before, OpenFlow is not a widely adopted protocol, and its availability
    is limited to a few manufacturers and devices. Therefore, if you are planning
    to use SDN, you may need to use the available native methods to configure the
    devices.
  prefs: []
  type: TYPE_NORMAL
- en: Network access is not only used for SDN but also for a variety of software,
    such as network configuration, configuration audit, upgrade tools, and automation,
    among others. Additionally, devices usually have multiple methods or protocols,
    some of which may be better than others.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will explore the most common methods and protocols for accessing
    network devices for our network automation. Since devices have multiple methods,
    we will aim to give you enough information so that you can choose the one that
    is most appropriate for your network automation code.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to explore the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Working with the CLI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using SNMP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Employing NETCONF
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adopting gRPC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operating with gNMI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with the CLI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Command-Line Interface** (**CLI**) is perhaps the most widely available
    method for accessing a network device. It is a term imported from computers, which
    was a replacement for **teletypewriter** (**TTY**) machines. A CLI is normally
    implemented by using a program that runs inside the device to interpret the keys
    being typed. Early implementations of the CLI program monitored the device’s serial
    port, where a terminal with a keyboard was connected to communicate.
  prefs: []
  type: TYPE_NORMAL
- en: In UNIX, the CLI program was called a shell, and the first shell, called the
    **V6 shell**, was created in 1971 by Ken Thompson at Bell Labs. The **Bourne shell**
    was introduced in 1977 as a replacement for the V6 shell. Although the UNIX shell
    is used as an interactive command interpreter, it was also intended to be a scripting
    language and contains most of the features that are commonly considered to produce
    structured programs.
  prefs: []
  type: TYPE_NORMAL
- en: Network devices use a simplified version of a shell for their CLIs. Let’s explore
    a bit more what CLI access can offer.
  prefs: []
  type: TYPE_NORMAL
- en: The command prompt
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When using the CLI in our network automation work, the command prompt is the
    most important piece in our code to be interpreted. We will see that the device
    uses the command prompt to indicate when it is ready to receive a new command.
  prefs: []
  type: TYPE_NORMAL
- en: A `$`, `%`, `#`, `:`, `>`, or `-`. It also can include additional information,
    such as the current time, working directory, username, or hostname. On many network
    devices, the prompt normally ends with `$` or `%`, and for the privileged CLI
    access mode, it normally ends with `#`, which is similar to the UNIX superuser,
    `root`.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the prompts can be modified by the user – however, the most common information
    presented in the prompts of network devices is the hostname and sometimes, the
    username used for login.
  prefs: []
  type: TYPE_NORMAL
- en: 'The example in *Figure 3.1* shows an `core-router` and the `>` character at
    the end, meaning it is waiting for the commands to be placed where the cursor
    is:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – A FRR router command prompt example](img/B18165_03_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.1 – A FRR router command prompt example
  prefs: []
  type: TYPE_NORMAL
- en: Serial access
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A network device normally has a special port called a *console* or *serial console*.
    This port is normally configured to operate at a slow speed, and the common configuration
    sets the baud rate to 9,600, with some devices able to accept up to 115,200 bits
    per second. The serial port is normally a **DB9** connector or an **RJ45**, with
    **RS232** technical specifications. *Figure 3.2* shows an example of the pins
    used for DB9 and RJ45 serial console connectors.
  prefs: []
  type: TYPE_NORMAL
- en: 'The program that handles the serial port is normally independent of the device’s
    operating system, allowing this type of port to be used in catastrophic scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2 – An example of a device’s serial port pin configuration ](img/B18165_03_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.2 – An example of a device’s serial port pin configuration
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s important to note that the serial port is used in the following cases:'
  prefs: []
  type: TYPE_NORMAL
- en: Extreme cases when the network device is unresponsible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For local maintenance in the presence of a technician
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Critical upgrades with the risk of crashes or operation system deletion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operation system or hardware failure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The network automation should avoid using the serial port to configure the device
    because no parallelism exists (only one port) and its speed is limited.
  prefs: []
  type: TYPE_NORMAL
- en: Remote insecure access
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For the reasons explained previously, the serial port is slow and can’t be used
    in parallel. Therefore, the best way to access the network device is via remote
    access, which can be done via **Out-Of-Band** (**OOB**) or in-band management
    (described in [*Chapter 1*](B18165_01.xhtml#_idTextAnchor015)*.*
  prefs: []
  type: TYPE_NORMAL
- en: How to determine whether the access is secure or not will depend on the protocol
    used and what kind of network is used to transport this remote access. If access
    is via an OOB network, it is normally secured and has separated and isolated infrastructure,
    but if it is in-band, some extra care needs to be taken to avoid some common security
    breaches.
  prefs: []
  type: TYPE_NORMAL
- en: Insecure applications and protocols
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The following applications are normally not encrypted and are easy to eavesdrop
    on, proxy, or hijack.
  prefs: []
  type: TYPE_NORMAL
- en: Telnet
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Telnet is an application that uses TCP port `23` to access a remote device.
    The data is not encrypted and there is no authentication on the connection. TCP
    hijacking and eavesdropping are the most common security problems when using Telnet.
    To make sure these threats are not present, the network path carrying the access
    must be secured or isolated.
  prefs: []
  type: TYPE_NORMAL
- en: Telnet normally requires a password and sometimes a username as well.
  prefs: []
  type: TYPE_NORMAL
- en: RSH
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`514` and does not provide encryption or a password. As IP addresses are used
    to authenticate access, this protocol is extremely insecure and susceptible to
    IP spoofing attacks.'
  prefs: []
  type: TYPE_NORMAL
- en: If it were not for its lack of security, RSH would be a fast and easy option
    for running commands and creating network automation.
  prefs: []
  type: TYPE_NORMAL
- en: Remote secure access
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To make sure remote access is secure, the data has to be encrypted and the hosts
    need to have some sort of identity-based authentication to make sure whoever is
    connecting is allowed to connect.
  prefs: []
  type: TYPE_NORMAL
- en: The most used application for remote CLI access is `22` as the default.
  prefs: []
  type: TYPE_NORMAL
- en: Identity-based authentication
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The identity-based authentication on SSH is based on a key fingerprint using
    SHA-256 (an encryption algorithm). When SSH is used for the first time, SSH asks
    you to confirm the fingerprint key to make sure the host you are connecting to
    is the correct one. An example of this fingerprint is shown in *Figure 3.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3 – An example of an SSH fingerprint acceptance request ](img/B18165_03_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.3 – An example of an SSH fingerprint acceptance request
  prefs: []
  type: TYPE_NORMAL
- en: 'Although SSH is considered a secure application protocol for accessing devices,
    the identity-based key fingerprint needs to be managed properly to avoid the most
    common attack, called *man-in-the-middle*. This attack redirects the traffic to
    another device, pretends it is the end device, and uses this procedure to capture
    the password of the final target network device, as shown in *Figure 3.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.4 – An example of a man-in-the-middle attack on a network device](img/B18165_03_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.4 – An example of a man-in-the-middle attack on a network device
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several ways to avoid a man-in-the-middle attack: one is to make
    sure the network device has an ACL (discussed in [*Chapter 1*](B18165_01.xhtml#_idTextAnchor015))
    that filters incoming IPs that are not part of the management. Another is to make
    sure identity key management is shared with the agent who is requesting remote
    access.'
  prefs: []
  type: TYPE_NORMAL
- en: Why is this important? Because network automation needs to make sure it uses
    a secure channel to modify the network and the key management is a shared responsibility
    between the network operators and the network automation teams.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some pros and cons of using a CLI for network automation:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Pros**:'
  prefs: []
  type: TYPE_NORMAL
- en: Available on almost all network devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Able to access the whole network device’s operating system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Critical and privileged access
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remote or local access via serial access without a network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cons**:'
  prefs: []
  type: TYPE_NORMAL
- en: Slow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Limited parallel access
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When not correctly used, may allow hackers to interfere
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interactive, requiring prompt
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data information is not structured (such as JSON or XML), which makes it prone
    to interpretation errors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To wrap up this section, we’ve covered the usage of the CLI, which is the oldest
    interface known for gathering information from network devices. We also learned
    that a CLI is the only way to collect or configure the device for some network
    devices. One of the important points is that CLI is always present on the network
    device. In the next section, we will see how we can improve the interface of the
    network device for gathering network information, called SNMP.
  prefs: []
  type: TYPE_NORMAL
- en: Using SNMP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Simple Network Management Protocol** (**SNMP**) is perhaps the oldest and
    most used protocol to gather management information from devices. The SNMP specification
    was first published in 1998 in RFC 2261 and was designed to be simple and fast.'
  prefs: []
  type: TYPE_NORMAL
- en: SNMP agents and managers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'SNMP defines two identities:'
  prefs: []
  type: TYPE_NORMAL
- en: The manager (or server)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The agent
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The agent is normally a network device and the manager is a network management
    system.
  prefs: []
  type: TYPE_NORMAL
- en: SNMP uses UDP and TCP as transport protocols with ports `161` and `162`. The
    UDP port `161` is used to gather or set information in an on-demand manner, where
    the manager sends the request to the agent. The UDP port `162` is used asynchronously
    without a request from the manager. The agent sends UDP packets to the server
    whenever necessary. This method is called an SNMP trap and is used to send unsolicited
    messages, such as alarms or threshold-level breaches.
  prefs: []
  type: TYPE_NORMAL
- en: An SNMP MIB
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As described in [*Chapter 1*](B18165_01.xhtml#_idTextAnchor015), a **Management
    Information Base** (**MIB**) is used as an identifier to access the network information
    variable. The identifier is known as an **Object Identifier** (**OID**), as seen
    in *Figure 1.8*.
  prefs: []
  type: TYPE_NORMAL
- en: SNMP versions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SNMP comes with version 1, version 2c, and version 3\. They were published at
    different times, and the differences are the available methods, transport protocol,
    MIB variables, and cryptography. SNMP agents are compatible backward – therefore,
    an agent that supports version 3 can work with all versions. The following sections
    present a summary of each version.
  prefs: []
  type: TYPE_NORMAL
- en: SNMPv1
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is the first version and contains most of the MIB variables and methods.
    It is based on UDP, using a community string as authentication. It only supported
    32-bit MIB counters, which is a problem with fast interfaces, as the counter expires
    quickly.
  prefs: []
  type: TYPE_NORMAL
- en: SNMPv2c
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Introduced 64-bit MIB variable counters and the `InformRequest` and `GetBulkRequest`
    methods. Version 2 was not adopted because of security complexity. Version 2c
    was then published with simplifications and was widely accepted.
  prefs: []
  type: TYPE_NORMAL
- en: SNMPv3
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Introduced cryptography for authentication and privacy. The `Report` method
    was added.
  prefs: []
  type: TYPE_NORMAL
- en: SNMP primitive methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SNMP essentially uses the following primitive methods.
  prefs: []
  type: TYPE_NORMAL
- en: '`GET`: Methods to gather information from the agent:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GetRequest`: Given an OID, returns the variable associated with it'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GetNextRequest`: Given an OID, returns the next OID with the variable associated
    with it (used on an SNMP MIB walk function)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GetBulkRequest`: Given an OID base, returns all OIDs and variables under this
    OID branch (sometimes causes long responses that can’t be interrupted)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SET`: Methods to set a value on the agent:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SetRequest`: Given an OID and a value, sets it on the MIB'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Response`: All responses for `SET` and `GET`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TRAP`: Asynchronous information sent from the agent to the manager with an
    OID and a variable'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`InformRequest`: Used to send asynchronous information with acknowledgment'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SNMP security issues
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Because of a lack of cryptography and authentication, SNMPv1 and v2 are vulnerable
    to IP spoofing attacks, which allow hackers to potentially send `SET` requests
    to agents compromising the network. Historically, because of this security issue,
    SNMP is not used to write configuration and only gathers configuration using the
    `GET` method or `TRAP`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some pros and cons of using SNMP for network automation:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Pros**:'
  prefs: []
  type: TYPE_NORMAL
- en: Easy to implement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fast
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parallelism is easy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No privileged access
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cons**:'
  prefs: []
  type: TYPE_NORMAL
- en: Requires pooling to gather information frequently
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Not normally used for writing information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Very limited scope of data coverage compared to a CLI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security issues when writing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we saw in this section, SNMP is the oldest and most robust protocol for network
    management. Although it has security and scope problems for writing configurations,
    its protocol is light, fast, and easy to read. The following section will cover
    the protocol developed by the IETF working group to fill the gap in network management
    concerning configuration. It is called NETCONF.
  prefs: []
  type: TYPE_NORMAL
- en: Employing NETCONF
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Network Configuration Protocol** (**NETCONF**) is a network management
    protocol developed and standardized by the IETF in 2006\. It provides mechanisms
    to install, manipulate, and delete the configuration of network devices.
  prefs: []
  type: TYPE_NORMAL
- en: NETCONF operations are implemented on top of a **Remote Procedure Call** (**RPC**)
    layer. The NETCONF protocol uses **Extensible Markup Language** (**XML**)-based
    data encoding for the configuration data as well as the protocol messages. The
    protocol messages can also be exchanged on top of a secure transport protocol
    such as SSH (RFC 6242) or using TLS (RFC 7589).
  prefs: []
  type: TYPE_NORMAL
- en: Motivation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Up until the early part of the 21st century, the only management protocol available
    from IETF was SNMP, which was developed in the late 1980s. It became clear that
    despite what was originally intended, SNMP was not being used to configure network
    equipment and was mainly being used for gathering network device information (as
    we have seen previously). The reasons are various, but mainly because SNMP was
    insecure and had a limited scope compared to a CLI for instance.
  prefs: []
  type: TYPE_NORMAL
- en: In June 2002, the network management community and the Internet Architecture
    Board got together with network key operators to discuss the real situation on
    network management protocols and usage. The results of this meeting are documented
    in RFC 3535 ([https://datatracker.ietf.org/doc/html/rfc3535](https://datatracker.ietf.org/doc/html/rfc3535)).
  prefs: []
  type: TYPE_NORMAL
- en: It turned out that network operators, instead of using SNMP, were primarily
    using different proprietary CLIs to configure their network devices. The reasons
    were various, including security issues and the lack of scope to configure or
    write configs because SNMP was too rigid to do so.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, around this time, Juniper Networks had started to use an
    XML-based network management approach, which was seen by IETF and the network
    operator community as an opportunity to combine efforts. This led to the creation
    of the NETCONF working group in May 2003.
  prefs: []
  type: TYPE_NORMAL
- en: In December 2006, with a lot of help from Juniper Networks, the first version
    of the base NETCONF protocol was published, RFC 4741 ([https://datatracker.ietf.org/doc/html/rfc4741](https://datatracker.ietf.org/doc/html/rfc4741)).
    After that, several extensions were published in subsequent years (RFC 5277, RFC
    5717, RFC 6243, RFC 6470, and RFC 6536, among others). The last revised version
    of NETCONF is documented in RFC 6241, published in June 2011 (updated by RFC 7803
    and RFC 8526).
  prefs: []
  type: TYPE_NORMAL
- en: OpenConfig
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**OpenConfig** is an informal working group of network operators sharing the
    goal of moving our networks toward a more dynamic, programmable infrastructure
    by adopting SDN principles such as declarative configuration and model-driven
    management and operations.'
  prefs: []
  type: TYPE_NORMAL
- en: Our initial focus in OpenConfig is on compiling a consistent set of vendor-neutral
    data models – written in **Yet Another Next Generation** (**YANG**) – based on
    the actual operational needs from use cases and requirements from multiple network
    operators.
  prefs: []
  type: TYPE_NORMAL
- en: YANG
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: YANG is a data modeling language that is used by the NETCONF protocol. YANG
    can be used to model both configuration data and state data from network devices.
    It is a modular language representing data structures in the XML format but can
    also be represented by other formats.
  prefs: []
  type: TYPE_NORMAL
- en: For each network device feature, at least one RFC describes the data model with
    YANG – for instance, VRRP (in [*Chapter 2*](B18165_02.xhtml#_idTextAnchor041))
    describes the YANG data model in RFC 8347 ([https://datatracker.ietf.org/doc/html/rfc8347](https://datatracker.ietf.org/doc/html/rfc8347)).
    Another effort to cover network ACLs (see [*Chapter 1*](B18165_01.xhtml#_idTextAnchor015))
    describes the YANG models in RFC 8519 ([https://datatracker.ietf.org/doc/html/rfc8519](https://datatracker.ietf.org/doc/html/rfc8519)).
  prefs: []
  type: TYPE_NORMAL
- en: Let’s examine the characteristics of YANG and the details of the model a bit
    more closely.
  prefs: []
  type: TYPE_NORMAL
- en: The data modeling process is hard
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It is important to understand that creating a YANG data model for a router
    function is not an easy task because it has to accommodate possible scenarios
    from the existing methods of all possible devices. So, it is not a fresh start
    from scratch, but the task of modeling functions that are already in use in several
    vendors and devices. Let’s take one example – the YANG data model for **Routing
    Policy**. As you can see on the timeline shown in *Figure 3.5*, the work started
    in 2015, and after more than 30 drafts, the standard was finally published in
    October 2021, which meant it took almost 7 years:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.5 – Timeline for creating a YANG data model for Routing Policy](img/B18165_03_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.5 – Timeline for creating a YANG data model for Routing Policy
  prefs: []
  type: TYPE_NORMAL
- en: It would be easier if each vendor had its own YANG data model, but then that
    would remove the general dependency.
  prefs: []
  type: TYPE_NORMAL
- en: NETCONF
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: NETCONF uses client-server communication based on RPCs. With NETCONF, server
    configurations are stored in a NETCONF configuration datastore that follows a
    YANG data format specification. To change or update data, a client sends an XML-based
    remote procedure call over one of the secure transfer methods, and the server
    replies with XML-encoded data.
  prefs: []
  type: TYPE_NORMAL
- en: 'NETCONF has four layers, as shown in *Figure 3.6*, extracted from the original
    RFC 6241:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.6 – The four layers described in the RFC 6241](img/B18165_03_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.6 – The four layers described in the RFC 6241
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s summarize each of the layers:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Content** layer: Consists of configuration data and notification data. Valid
    content is defined in the YANG specification.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`get`, `get-config`, `edit-config`, `copy-config`, `delete-config`, `lock`,
    `unlock`, `close-session`, and `kill-session`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<rpc>` request from a client or a `<rpc-reply>` from a server. RFC6241 also
    added notifications to this layer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Secure Transport** layer: This layer deals with the protocols used to transmit
    NETCONF messages. SSH, TLS, and HTTP are a few of the protocols associated with
    this layer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RESTCONF
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The RESTCONF protocol is a proposed standard defined in RFC 8040 ([https://www.rfc-editor.org/rfc/rfc8040.html](https://www.rfc-editor.org/rfc/rfc8040.html)).
    NETCONF and RESTCONF are similar in terms of their capabilities, but RESTCONF
    came later in 2017 with a **Representational State Transfer** (**REST**)**ful
    API** model using HTTP. They both allow administrators to query information or
    modify settings using a client-server model. RESTCONF is different in a few key
    ways:'
  prefs: []
  type: TYPE_NORMAL
- en: RESTCONF uses HTTP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RESTCONF supports both JSON and XML
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RESTCONF does not have the concept of transaction and therefore does not have
    the `lock` concept as NETCONF does
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RESTCONF is not intended to replace NETCONF. Rather, it was created to allow
    the use of a RESTful API that can be used to query and configure devices with
    NETCONF or YANG configuration datastores.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 3.7* shows a table extracted from RFC 8040 that demonstrates the overlap
    between RESTCONF and NETCONF calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.7 – The overlap between RESTCONF and NETCONF methods extracted from
    RFC 8040](img/B18165_03_007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.7 – The overlap between RESTCONF and NETCONF methods extracted from
    RFC 8040
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some pros and cons of using NETCONF or RESTCONF:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Pros**:'
  prefs: []
  type: TYPE_NORMAL
- en: Incorporate network specification
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IETF standards
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No privileged access
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allow stream event notifications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Programmatic device configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cons**:'
  prefs: []
  type: TYPE_NORMAL
- en: Not all device capabilities are covered in YANG
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adoption of NETCONF has been really slow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NETCONF transport is limited and implementation is old
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Not that efficient
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This section summarizes how NETCONF, RESTCONF, and YANG are used to interact
    with network devices. The transaction states of NETCONF make it a powerful tool
    for network configuration. Despite its good base of IETF standards, NETCONF is
    not efficient enough to handle some of the network automation we want, such as
    collecting data at a high-frequency rate. In the following section, we are going
    to explore a newer protocol called gRPC.
  prefs: []
  type: TYPE_NORMAL
- en: Adopting gRPC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**gRPC** was published in 2015 as an open source RPC framework. It is one of
    the most promising protocols to be used in automation because it is easy to create
    a program and add methods to obtain or set configuration on the network device.'
  prefs: []
  type: TYPE_NORMAL
- en: 'gRPC does not directly use TCP for transport, but HTTP/2 instead, which was
    published in 2015 to overcome the limitations of HTTP/1.1\. While it is backward
    compatible with HTTP/1.1, HTTP/2 brings many added advanced capabilities, such
    as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Binary framing layer**: Request and response is divided into small messages
    and framed in binary format, making message transmission efficient'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bidirectional full-duplex streaming**: Here, the client can request and the
    server can respond simultaneously'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Flow control (used in HTTP/2)**: Enables the detailed control of memory used
    for the network buffers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Header compression**: Everything in HTTP/2, including headers, is encoded
    before it is sent, significantly improving performance'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Asynchronous and synchronous processing**: Can be used to perform different
    types of interaction and streaming RPCs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All these features of HTTP/2 enable gRPC to use fewer resources, resulting in
    reduced response times between clients and servers.
  prefs: []
  type: TYPE_NORMAL
- en: To ensure the security of gRPC, TLS end-to-end encryption can be used, and authentication
    can use SSL or TLS with or without token-based authentication or the need to define
    your own authentication system by extending the provided code (more on authentication
    can be found at [https://grpc.io/docs/guides/auth/](https://grpc.io/docs/guides/auth/)).
  prefs: []
  type: TYPE_NORMAL
- en: The letter g
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Initially, in version 1.0 of the protocol, the letter *g* was a recursive reference
    to the name gRPC, but as later versions were published, another word was added,
    making the name a bit of code entertainment. For instance, in version 1.1, the
    word was *good*, in version 1.2, it was *green*, and for version 1.42, it was
    *granola*. A complete list of names used for the letter *g* can be found in the
    gRPC source code here: [https://grpc.github.io/grpc/core/md_doc_g_stands_for.html](https://grpc.github.io/grpc/core/md_doc_g_stands_for.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Motivation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Google has used a single general-purpose RPC infrastructure called **Stubby**
    to connect the large number of microservices running within and across Google
    data centers for more than a decade. That motivated Google to publish and sponsor
    the creation of gRPC.
  prefs: []
  type: TYPE_NORMAL
- en: Letter from the gRPC team on Monday, October 26, 2015
  prefs: []
  type: TYPE_NORMAL
- en: '*The gRPC team is excited to announce the immediate availability of gRPC Beta.
    This release represents a major step forward in API stability, with most API changes
    in the future being additive in nature. It opens the door for gRPC use in production
    environments.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*We updated grpc.io documentation to reflect the latest changes and released
    language-specific reference documentation. In the release notes on GitHub for
    Java, Go, and all other languages, you will find information on what has changed.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*We would like to thank everyone who contributed code, gave presentations,
    adopted the technology, and participated in the community. We look forward to
    1.0 with your support!*'
  prefs: []
  type: TYPE_NORMAL
- en: Overview
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: gRPC uses the concept of a client and server application. Client applications
    can directly invoke server applications on remote machines just as if they were
    local objects. gRPC is based on the idea of defining a service and specifying
    methods that can be called remotely using their parameters and return types. The
    server implements this interface and runs a gRPC server to handle client calls.
    The client has a stub (just referred to as a client in some languages) that provides
    the same methods as the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the world of network automation, the gRCP client is actually our automation
    software and the gRPC server is the network device, as illustrated in *Figure
    3.8*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.8 – Basic request and response for gRPC](img/B18165_03_008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.8 – Basic request and response for gRPC
  prefs: []
  type: TYPE_NORMAL
- en: 'The gRPC server and client are not required to use the same programming language.
    Today, there are several implementations of different languages, whether Go, Python,
    Java, or Ruby. A complete list of the languages supported can be found here: [https://grpc.io/docs/languages/](https://grpc.io/docs/languages/).'
  prefs: []
  type: TYPE_NORMAL
- en: Protobuf
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By default, gRPC uses **Protocol Buffers** (**Protobuf**), which is another
    open source mechanism for serializing data created by Google. Although Protobuf
    is the default, gRPC can also use JSON instead, but that is less efficient, as
    we are going to see.
  prefs: []
  type: TYPE_NORMAL
- en: Protobuf is a language- and platform-neutral mechanism for serializing data,
    like JSON or XML but much smaller, faster, and simpler. The structure of the data
    is defined once and then a specially generated source code is used to easily write
    and read this structured data from a variety of data streams with any programming
    language.
  prefs: []
  type: TYPE_NORMAL
- en: 'More about Protobuf can be found here: [https://developers.google.com/protocol-buffers](https://developers.google.com/protocol-buffers).'
  prefs: []
  type: TYPE_NORMAL
- en: gRPC and network telemetry
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: During our network automation work, we are going to experience a series of limitations,
    especially in gathering network information in an effective way. So, let’s explore
    the following example.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine a network with 500 devices, with 50 interfaces on each device on average.
    Each interface needs to gather multiple variables, such as the current state,
    the error rate, drop counts, packet-in counts, or packet-out counts. If we consider
    a conservative approach, such as only collecting 10 variables per interface, for
    this network example, we are going to gather information from 10 variables x 50
    interfaces x 500 devices, which adds up to 250,000 variables.
  prefs: []
  type: TYPE_NORMAL
- en: The other point to consider is the frequency of the data. In the 90s, network
    management required information from the network every 5 minutes and that was
    sufficient for handling failures and troubleshooting, but nowadays, the interval
    is much smaller. We are looking to gather information at intervals of less than
    1 minute, ideally every 30 or 10 seconds. The reason is that troubleshooting and
    failure resolution can occur faster when detecting failures quickly.
  prefs: []
  type: TYPE_NORMAL
- en: So, in our example, 250,000 variables every 10 seconds give us an enormous amount
    of data using traditional polling mechanisms such as SNMP. However, one important
    point to note here is most of the content of the variables might not change at
    all, such as the counters for interfaces when there is no traffic, the state of
    the interface when nothing has changed, the interface discard counter when there
    aren’t any, or the error rate when the interface is perfectly fine. Therefore,
    several or even the majority of the contents of the network variables are not
    going to change that often, meaning that pooling mechanisms are inefficient and
    accumulate redundant information over time. What would be better than polling?
    Streaming telemetry. Streaming telemetry allows devices to send incremental updates
    continuously as soon as changes occur. In this way, the collection of network
    information can be done more effectively than with pooling.
  prefs: []
  type: TYPE_NORMAL
- en: gRPC supports bidirectional streaming, which gives this protocol a huge advantage
    compared to the others we saw so far for data collection.
  prefs: []
  type: TYPE_NORMAL
- en: Code examples using gRPC
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To make the example more realistic for network automation, let’s have a service
    on the routers that can return the following information:'
  prefs: []
  type: TYPE_NORMAL
- en: Return the memory utilization in percent
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Return the CPU utilization in percent
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Return the router uptime in seconds
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our examples will create a client gRPC stub to communicate to the router, which
    will be the gRPC server, as depicted in *Figure 3.8*. We are only going to demonstrate
    the client side and we are going to assume the gRPC server on the router has already
    been implemented.
  prefs: []
  type: TYPE_NORMAL
- en: The Protobuf file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Protobuf file definition is a single part of the code that is not tied
    to any language. The same file definition is used on the client and the server.
    It is compiled once and feeds the client and server programs to interpret the
    data used to generate the RPCs. For our example, the Protobuf file would look
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: An example using Python
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here is an example using Python. The import name, `r_grpc`, compiles the code
    for Python from the Protobuf file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: An example using Go
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here is an example using a Go program client. Note that `pb` (used on the import)
    is the code compiled for the Protobuf:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are some pros and cons of using gRPC for network automation:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Pros**:'
  prefs: []
  type: TYPE_NORMAL
- en: Secure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fast
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parallelism is easy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No privileged access is possible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flexible and can expose any local device command using the gRPC server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cons**:'
  prefs: []
  type: TYPE_NORMAL
- en: Not many network devices have gRPC capability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, we saw that gRPC is a powerful protocol to use for network
    automation. However, it is not well integrated into network devices yet. The majority
    of the new operating systems on network devices come with this capability. In
    the next section, a higher-level protocol called gNMI will be used to make better
    use of the gRPC protocol for network automation.
  prefs: []
  type: TYPE_NORMAL
- en: Operating with gNMI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we saw before, gRPC is probably the most appropriate protocol for working
    with devices in terms of performance. However, it is actually a generic protocol
    to be used in any client and server interaction – not only network devices but
    also computer servers. For this reason, **gRPC Network Management Interface**
    (**gNMI**) was created.
  prefs: []
  type: TYPE_NORMAL
- en: gNMI is an open source protocol specification created by the OpenConfig working
    group that is used to communicate to and from network devices using YANG (discussed
    in the *NETCONF* section). In other words, gNMI was created to utilize the good
    work done by people defining the network specification data using YANG but with
    a more modern protocol such as gRPC instead of NETCONF.
  prefs: []
  type: TYPE_NORMAL
- en: Protocol layers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: gNMI uses gRPC. For that, it has to translate the YANG data description into
    Protobuf to serialize the communication, as illustrated in *Figure 3.9*. At the
    bottom of the diagram is a normal gRPC connection over HTTP/2 and TLS. The gRPC
    code is auto-generated from the gNMI Protobuf model and gNMI carries the data
    modeled in YANG, which can support encoding in JSON, like the example below.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.9 – gNMI protocol layers](img/B18165_03_009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.9 – gNMI protocol layers
  prefs: []
  type: TYPE_NORMAL
- en: The data model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: gNMI uses a data model called `PathElem` messages. Each `PathElem` consists
    of a name encoded as a string. An element’s name must be encoded as a `PathElem`
    may optionally specify a set of keys, specified as a `map<string,string>` (dictionary
    or map).
  prefs: []
  type: TYPE_NORMAL
- en: 'The root path, `/`, is encoded as a zero-length array (slice) of `PathElem`
    messages. Here are some example declarations in Go and Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '`path := []*PathElem{}`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`path = []`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A human-readable path can be formed by concatenating elements of the prefix
    and path using the `/` separator.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let’s see the following representation: `/interfaces/interface[name=Ethernet1/2/3]/state.`'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is specified as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The communication model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The communication model uses a target and client as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Target**: The device within the gNMI that acts as the owner of the data that
    is being manipulated or collected. Typically, this is our network device.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Client or collector:** The system using the gNMI to query or modify data
    on the target or act as a collector for streamed data. Typically, this is the
    network management system or our automation code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Similar to gRPC, the server actually is on the network device, as depicted
    in *Figure 3.10*:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 3.10 – gNMI \uFEFFtarget and \uFEFFclient communication](img/B18165_03_010.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 3.10 – gNMI target and client communication
  prefs: []
  type: TYPE_NORMAL
- en: Service definition
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The gNMI service is based on RPC calls called `Capabilities`, `Get`, `Set`,
    and `Subscribe`, which will be detailed in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Capabilities RPC
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A client can discover the capabilities of the target using the `CapabilityRequest`
    message is sent by the client to interrogate the target. The target must then
    reply with a `CapabilityResponse` message that includes its gNMI service version,
    the versioned data models it supports, and the supported data encodings. This
    information is used in subsequent RPC messages from the client to indicate the
    set of models that the client will use for the `Get` and `Subscribe` RPC calls
    and the encoding to be used for the data.
  prefs: []
  type: TYPE_NORMAL
- en: Get RPC
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `GetRequest` message to the target, specifying the path that is to be retrieved.
    Upon reception of the `GetRequest` message, the target serializes the requested
    path and returns a `GetResponse` message. This connection is short-lived and the
    target closes the `Get` RPC following the transmission of the `GetResponse` message.
  prefs: []
  type: TYPE_NORMAL
- en: Set RPC
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Modifications to the state of the target are made through the `SetRequest` message
    to the target indicating the modifications it desires.
  prefs: []
  type: TYPE_NORMAL
- en: A target receiving a `SetRequest` message processes the operations specified
    within it, which are treated as a transaction. In response to a `SetRequest` message,
    the target must respond with a `SetResponse` message. For each operation specified
    in the `SetReques`t message, an `UpdateResult` message must be included in the
    response field of `SetResponse`.
  prefs: []
  type: TYPE_NORMAL
- en: Subscribe RPC
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This perhaps is the most important call on the gNMI because it is the one that
    allows Streaming Telemetry, as discussed before.
  prefs: []
  type: TYPE_NORMAL
- en: When a client wishes to receive updates relating to the state of data instances
    on a target, it creates a subscription via the **Subscribe RPC**. A subscription
    consists of one or more paths, with a specified subscription mode. The mode of
    each subscription determines the triggers for updates to the data sent from the
    target to the client.
  prefs: []
  type: TYPE_NORMAL
- en: All requests for new subscriptions are encapsulated within a `SubscribeRequest`
    message, which itself has a mode describing the longevity of the subscription.
    A client may create a subscription that has a dedicated stream to return one-off
    data (`ONCE`); a subscription that utilizes a stream to periodically request a
    set of data (`POLL`); or a long-lived subscription that streams data according
    to the triggers specified within the individual subscription’s mode (`STREAM`).
    For Streaming Telemetry, the mode is set to `STREAM`.
  prefs: []
  type: TYPE_NORMAL
- en: gNMI-gateway
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**gNMI-gateway** is open source software that was initially developed by Netflix
    and then released as part of the OpenConfig working group to collect and distribute
    OpenConfig-modeled gNMI data from network devices.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The motivations to create gNMI-gateway were various, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: First, there were not many open source services available to consume and distribute
    OpenConfig-modeled gNMI Streaming Telemetry data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Second, there was a lack of failure tolerance for the client and target connection
    using gNMI data streaming, making Streaming Telemetry vulnerable. As the client
    dies, the streamed data is lost until another subscription takes place.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third was the lack of supporting multiple consumers. If multiple departments
    in a company want data from a network device or a group of network devices, it
    would be necessary for all of them to send subscriptions to the targets. With
    clustering functionality and replication in gNMI-gateway, it is possible to avoid
    unnecessarily duplicating gNMI connections to targets and offer the same data
    to multiple customers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fourth, there was a lack of unifying gNMI clients with non-gNMI clients. gNMI-gateway
    allows either gNMI clients or non-gNMI clients to gather information.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Figure 3.11* shows a single instance of gNMI-gateway with gNMI clients and
    non-gNMI clients, also known as exporters. **Apache Kafta** ([https://kafka.apache.org/](https://kafka.apache.org/))
    is one piece of software that can be used as an exporter; another one already
    implemented is **Prometheus** ([https://prometheus.io/](https://prometheus.io/)):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.11 – A single instance of gNMI-gateway](img/B18165_03_011.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.11 – A single instance of gNMI-gateway
  prefs: []
  type: TYPE_NORMAL
- en: 'The redundancy can be obtained by using multiple instances of gNMI-gateway
    which is implemented by using **Apache Zookeeper** ([https://zookeeper.apache.org/](https://zookeeper.apache.org/)),
    as illustrated in *Figure 3.12*. If only one instance is running, there is no
    need to use Apache Zookeeper:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.12 – Multiple instances of gNMI-gateway](img/B18165_03_012.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.12 – Multiple instances of gNMI-gateway
  prefs: []
  type: TYPE_NORMAL
- en: 'More on gNMI-gateway can be found here: [https://github.com/openconfig/gnmi](https://github.com/openconfig/gnmi).'
  prefs: []
  type: TYPE_NORMAL
- en: 'For reference, here is a full presentation on gNMI-gateway presented at 2020’s
    NANOG Webcast: [https://nanog.org/news-stories/nanog-tv/nanog-80-webcast/gnmi-gateway/](https://nanog.org/news-stories/nanog-tv/nanog-80-webcast/gnmi-gateway/).'
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: 'Full specification on gNMI can be found here: [https://github.com/openconfig/reference/blob/master/rpc/gnmi/gnmi-specification.md](https://github.com/openconfig/reference/blob/master/rpc/gnmi/gnmi-specification.md).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some pros and cons of using gNMI for network automation:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Pros**:'
  prefs: []
  type: TYPE_NORMAL
- en: Secure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fast
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parallelism is easy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No privileged access is possible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Incorporates YANG specification for networking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allows easy Streaming Telemetry
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Capable of adding gNMI-gateway with full redundancy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cons**:'
  prefs: []
  type: TYPE_NORMAL
- en: Not many network devices have gNMI capability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered the major methods used by software engineers to
    interact with network devices. Not many more methods are available, so I would
    assume we have covered perhaps 99.9% of all existing methods at the time of writing.
  prefs: []
  type: TYPE_NORMAL
- en: Using the information provided in this chapter, you can choose which method
    or methods to incorporate into your network automation code. In most cases, you
    won’t be able to cover all scenarios using just one method; you will probably
    have to combine two or more methods.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will explore how files can be used to define a network. We
    will discuss the pros and cons of each type of file that’s available.
  prefs: []
  type: TYPE_NORMAL
