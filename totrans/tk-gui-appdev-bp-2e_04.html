<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Game of Chess</h1>
                </header>
            
            <article>
                
<p class="mce-root">Let's build a game of chess in Tkinter. If you already know the basic rules of chess, you are ready to write this program. However, if you do not know the rules, you should read them before you start programming this application.</p>
<p class="mce-root">Some of the key objectives of this chapter are as follows:</p>
<ul>
<li class="mce-root">Learning how to structure a program in a <strong>Model-View-Controller</strong> (<strong>MVC</strong>) architecture</li>
<li class="mce-root">Learning how to tame complexity by implementing programs in a modular structure</li>
<li class="mce-root">Taking a look at the versatility and power of the Tkinter Canvas widget</li>
<li class="mce-root">Learning the basic usage of canvas coordinates, object IDs, and tags</li>
<li class="mce-root">Learning the recommended error-handling practices</li>
<li class="mce-root">Learning how to extend Python's built-in data types</li>
<li class="mce-root">Using object inheritance to code classes with similar attributes and behavior</li>
<li class="mce-root">Using Python's built-in <kbd>configparser</kbd> module to store program preferences</li>
<li class="mce-root">Getting acquainted with several Python modules that you will often use in a variety of application development projects</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">An overview of the chapter</h1>
                </header>
            
            <article>
                
<p>We will now implement a <span><em>human</em> versus <em>human</em> chess game. </span>Our chess game will enforce all the standard rules that are applicable to a game of chess. Some advanced rules such as castling and e<span>n passant</span> are left as an exercise for you.</p>
<p>In its final form, our chess program will look like this:</p>
<div class="CDPAlignCenter CDPAlign"><img height="328" src="assets/670b8c08-8200-4bdd-8a5a-83e95d0029ed.png" width="284"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Module requirements for this chapter</h1>
                </header>
            
            <article>
                
<p>We will not use any external third-party modules in this chapter. However, we will use several built-in Python modules.</p>
<p>To check whether all the required libraries are indeed provided by your Python distribution, type the following command in your Python command line:</p>
<pre><strong>&gt;&gt; import tkinter, copy, sys, configparser</strong></pre>
<p>This should be executed without an error message. If no errors are thrown back, you are ready to build the chess application. Let's get started!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Structuring our program</h1>
                </header>
            
            <article>
                
<p>In this section, we decide on an overall structure for our program.</p>
<p>The development of large applications generally starts with recording the <strong>software requirement specifications</strong> (<strong>SRS</strong>). This is generally followed by a graphical representation of constructs, such as the class, composition, inheritance, and the hiding of information using several modeling tools. These tools can be flow charts, <strong>Unified Modeling Language</strong> (<strong>UML</strong>) tools, data flow diagrams, Venn diagrams (for database modeling), and so on.</p>
<p>These tools are very useful when the problem domain is not very clear. However, if you have ever played the game of chess, you should be very well acquainted with the problem domain. Furthermore, our chess program can be classified as a medium-sized program spanning a few hundred lines of code. Therefore, let's bypass these visual tools and get to the actual program design.</p>
<p>All of our previous projects have been structured as a single file. However, as programs grow in complexity, we need to break programs into modules and class structures.</p>
<p>One of the key objectives of this chapter is to learn to write programs in the <strong>MVC</strong> architecture. Some of the central aspects of the MVC architecture are as follows:</p>
<ul>
<li>A model handles backend data and logic</li>
<li>A view handles the frontend presentation</li>
<li>The model and view never interact directly</li>
<li>Whenever the view needs to access backend data, it requests the controller to intervene with the model and fetch the required data</li>
</ul>
<p>Given these aspects, let's create three files for our chess program: <kbd>model.py</kbd>, <kbd>view.py</kbd>, and <kbd>controller.py</kbd> (see <kbd>4.01.py</kbd>).</p>
<p>Now, let's create an empty <kbd>Model</kbd> class, an empty <kbd>View</kbd> class, and a <kbd>Controller</kbd> class in their respective files, as follows:</p>
<pre>class Model(): #in model.py<br/>  def __init__(self):<br/>    pass<br/><br/>class View(): #in view.py<br/>  def __init__(self):<br/>    pass<br/><br/>class Controller(): # in controller.py<br/>  def __init__(self):<br/>    self.init_model()<br/><br/>  def init_model(self):<br/>    self.model = model.Model()</pre>
<p>Note that since the <kbd>Controller</kbd> class needs to fetch data from the <kbd>Model</kbd> class, we instantiated a new <kbd>Model</kbd> class from within the <kbd>Controller</kbd> class. This now provides us with a way to fetch data from the <kbd>Model</kbd> class as and when needed.</p>
<p>Let's also add a separate file called <kbd>exceptions.py</kbd>. This will be our central place for the handling of all errors and exceptions. Within this file, add the following single line of code:</p>
<pre>class ChessError(Exception): pass</pre>
<p>We created a custom <kbd>ChessError</kbd> class that was inherited from the standard <kbd>Exception</kbd> class. This simple line of code now allows the <kbd>ChessError</kbd> class and all of its children to raise errors, which can then be handled by using the <kbd>try…except</kbd> block. All the new error classes that will be defined in our code from now on will derive from this <kbd>ChessError</kbd> base class.</p>
<p>With this boilerplate code out of the way, let's create another blank file called <kbd>configurations.py (4.01)</kbd>. We will use this file to store all the constants and configurable values in one place.</p>
<p>Let's define some constants right away, as follows (see code <kbd>4.01</kbd>—<kbd>configurations.py</kbd>):</p>
<pre>NUMBER_OF_ROWS = 8<br/>NUMBER_OF_COLUMNS = 8<br/>DIMENSION_OF_EACH_SQUARE = 64 # denoting 64 pixels<br/>BOARD_COLOR_1 = "#DDB88C"<br/>BOARD_COLOR_2 = "#A66D4F"</pre>
<p>To make these constant values available to all files, let's import them in to the <kbd>model.py</kbd>, <kbd>view.py</kbd>, and <kbd>controller.py</kbd> folders (see <kbd>4.01</kbd>):</p>
<pre>from configurations import *</pre>
<p>As per the tenets of the MVC architecture, the <kbd>View</kbd> class is never supposed to interact directly with the <kbd>Model</kbd> class. It should always interact with the <kbd>Controller</kbd> class, and the <kbd>Controller</kbd> class is then responsible for fetching data from the <kbd>Model</kbd> class. Accordingly, let's import the controller in the <kbd>View</kbd> class and the model in the <kbd>Controller</kbd> class, as follows:</p>
<pre>import controller # in view.py<br/>import model # in controller.py</pre>
<p>Let's start by editing the <kbd>view.py</kbd> file to display a chessboard (see <kbd>4.01</kbd>—<kbd>view.py</kbd>). Our goal for this iteration is to display the empty chessboard as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img height="310" src="assets/40be4ee4-13b3-4b49-a482-7df875247a4b.png" width="266"/></div>
<p>Take a look at the code implementation in <kbd>view.py</kbd> (see <kbd>4.01</kbd>).<br/>
The <kbd>__init__</kbd> method of the <kbd>View</kbd> class calls a method called <kbd>create_chess_base</kbd>, which is defined as follows:</p>
<pre>def create_chess_base(self):<br/>  self.create_top_menu()<br/>  self.create_canvas()<br/>  self.draw_board()<br/>  self.create_bottom_frame()</pre>
<p>We will not reproduce the code responsible for the creation of the root window, the menu at the top, or the frame at the bottom. We have implemented similar widgets in previous chapters (see <kbd>4.01</kbd>—<kbd>view.py</kbd> for a complete reference).<br/>
However, we will discuss the code that creates the chessboard:</p>
<pre>def create_canvas(self):<br/>  canvas_width = NUMBER_OF_COLUMNS * DIMENSION_OF_EACH_SQUARE<br/>  canvas_height = NUMBER_OF_ROWS * DIMENSION_OF_EACH_SQUARE<br/>  self.canvas = Canvas(self.parent, width=canvas_width, height=canvas_height)<br/>  self.canvas.pack(padx=8, pady=8)</pre>
<p>Nothing fancy here. Creating a Canvas widget is similar to creating other widgets in Tkinter. The Canvas widget takes the <kbd>width</kbd> and <kbd>height</kbd> of two configurable options. Next, paint the Canvas widget in alternating shades to form the chessboard (<kbd>view.py</kbd>):</p>
<pre>def draw_board(self):<br/>  current_color = BOARD_COLOR_2<br/>  for row in range(NUMBER_OF_ROWS):<br/>    current_color = self.get_alternate_color(current_color)<br/>    for col in range(NUMBER_OF_COLUMNS):<br/>       x1, y1 = self.get_x_y_coordinate(row, col)<br/>       x2, y2 = x1 + DIMENSION_OF_EACH_SQUARE, y1 +DIMENSION_OF_EACH_SQUARE<br/>       self.canvas.create_rectangle(x1, y1, x2, y2, fill=current_color)<br/>       current_color = self.get_alternate_color(current_color)<br/><br/>def get_x_y_coordinate(self, row, col):<br/>        x = (col * DIMENSION_OF_EACH_SQUARE)<br/>        y = ((7 - row) * DIMENSION_OF_EACH_SQUARE)<br/>       return (x, y)<br/><br/>def get_alternate_color(self, current_color):<br/>     if current_color == self.board_color_2:<br/>        next_color = self.board_color_1<br/>     else:<br/>        next_color = self.board_color_2<br/>     return next_color</pre>
<p>The following is the description of the code:</p>
<ul>
<li>We used the Canvas widget's <kbd>create_rectangle()</kbd> method to draw alternating shades of squares to resemble a chessboard.</li>
<li>The rectangles are drawn from point <kbd>x1</kbd>, <kbd>y1</kbd>, and they extend to <kbd>x2</kbd>, <kbd>y2</kbd>. These values correspond to two diagonally opposite corners of the rectangle (coordinates of the upper-left and lower-right edges).</li>
<li>The <kbd>x</kbd> and <kbd>y</kbd> values are calculated by using a newly defined method called <kbd>get_x_y_coordinate()</kbd>, which performs simple mathematics depending on the dimensions of each square that was defined in pixel units earlier.<br/>
The <kbd>y</kbd> value is calculated by first subtracting a row from (7-row) because the Canvas widget measures the coordinates starting from the top left. The top-left corner of the canvas has the coordinates (<kbd>0</kbd>, <kbd>0</kbd>).</li>
<li>The <kbd>get_alternate_color</kbd> method is a helper method that, not surprisingly, returns the alternate color.</li>
</ul>
<div class="packt_infobox">The Tkinter Canvas widget lets you draw a line, an oval, a rectangle, an arc, and polygon shapes at a given coordinate. You can also specify various configuration options, such as fill, outline, width, and so on for each of these shapes.<br/>
The Canvas widget uses a coordinate system to specify the position of objects on the widget. Coordinates are measured in pixels. The top-left corner of the canvas has the coordinates (<kbd>0</kbd>, <kbd>0</kbd>).<br/>
The objects drawn on the Canvas widget are usually handled by assigning them an ID or a tag. We will see an example of this later in the chapter.<br/>
If an object on the Canvas widget is tagged to multiple tags, the options defined for tags at the top of the stack have precedence.<br/>
However, you can change the precedence of tags by using <kbd>tag_raise(name)</kbd> or <kbd>tag_lower(name)</kbd>.<br/>
For a complete list of Canvas widget-related options, refer to the interactive help for the Canvas widget using <kbd>help(Tkinter.Canvas)</kbd> in the command line, as follows:<br/>
<kbd>&gt;&gt;&gt; import tkinter</kbd><br/>
<strong><kbd>&gt;&gt;&gt; help(tkinter.Canvas)</kbd></strong></div>
<p>Next, let's bind the mouse click to the Canvas widget from the <kbd>__init__</kbd> method of the <kbd>View</kbd> class (see <kbd>4.01</kbd>—<kbd>view.py</kbd>), as follows:</p>
<pre>self.canvas.bind("&lt;Button-1&gt;", self.on_square_clicked)</pre>
<p>The bound method calls another method called <kbd>get_clicked_row_column()</kbd>, and for now it prints the result on the console as follows:</p>
<pre>def on_square_clicked(self, event):<br/>  clicked_row, clicked_column =  self.get_clicked_row_column(event)<br/>  print("Hey you clicked on", clicked_row, clicked_column)</pre>
<p>The <kbd>get_clicked_row_column()</kbd> method is defined as follows:</p>
<pre>def get_clicked_row_column(self, event):<br/>  col_size = row_size = DIMENSION_OF_EACH_SQUARE<br/>  clicked_column = event.x // col_size<br/>  clicked_row = 7 - (event.y // row_size)<br/>  return (clicked_row, clicked_column)</pre>
<p>Now, if you run the code (see <kbd>4.01</kbd>—<kbd>view.py</kbd>) and click on different squares, it should output a message like this to the console:</p>
<pre><strong>Hey you clicked on 0 7</strong><br/><strong>Hey you clicked on 3 3</strong></pre>
<p>This completes our first iteration. In this iteration, we determined the broader file structure for the chess program. We created the <kbd>model</kbd>, <kbd>view</kbd>, and <kbd>controller</kbd> classes. We also decided to keep all the constants and configuration values in a separate file called <kbd>configurations.py</kbd>.</p>
<p>We have now had a first taste of the Canvas widget. We created a blank canvas and then added square areas using the <kbd>canvas.create_rectangle</kbd> method to create a chessboard.</p>
<p>Now, if you run <kbd>4.01</kbd>—<kbd>view.py</kbd>, you will see an empty chessboard. You will also find out that the <em>File</em> menu and the <em>Edit</em> menu dropdowns are not functional. The <em>About</em> menu should show a standard <kbd>messagebox</kbd> widget. </p>
<p>Before you proceed to the next section, you are encouraged to go and explore the code in the <kbd>4.01</kbd> folder in its entirety.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Modeling the data structure</h1>
                </header>
            
            <article>
                
<p>Coming back to the old adage, data structures, not algorithms, are central to writing good programs. Therefore, it is important that we spend some time defining the data structure.</p>
<p>The key data that the model needs to record is the position of the chess pieces on the chessboard. Accordingly, we first need a way to define these locations and a unique way to identify the chess pieces. Let's first agree to the naming conventions that we will stick to in the program.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Convention on naming chess pieces</h1>
                </header>
            
            <article>
                
<p>Every chess piece is identified by a single letter (pawn = p, knight = n (yes knight with an n!), bishop = b, rook = r, queen = q, and king = k).</p>
<p>The <em>white</em> chess pieces are represented by <em>uppercase</em> letters (PNBRQK), and the <em>black</em> chess pieces are represented by <em>lowercase</em> letters (pnbrqk).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Convention for naming locations on the chessboard</h1>
                </header>
            
            <article>
                
<p>In order to assign unique identifiers to every square on the chessboard, we will mark the squares along the <em>x</em> axis by using the letters A to H. We will mark the <em>y</em> axis by using the numbers 1 to 8.</p>
<p>Accordingly, the squares on the chessboard will be identified as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img height="215" src="assets/27a601f3-ad2e-4128-a2c0-cc1255f1f6fb.png" width="333"/></div>
<p>Thus, <strong>A1</strong> denotes the leftmost square at the bottom of the chessboard. Currently, it is occupied by a white rook. The <strong>C3</strong> position is currently empty, <strong>E8</strong> has a black king, and <strong>A8</strong> has a black rook.</p>
<p>Let's add this to the <kbd>configurations.py</kbd> file (see <kbd>4.02</kbd>):</p>
<pre>X_AXIS_LABELS = ('A', 'B', 'C', 'D', 'E', 'F', 'G', 'H')<br/>Y_AXIS_LABELS = (1, 2, 3, 4, 5, 6, 7, 8)</pre>
<p>Now, if you want to represent the chessboard at any point in time, all you need is a mapping of the location to the chess piece at that location. Looks like a perfect candidate for storing as a Python dictionary.</p>
<p>Thus, the initial position of all the chess pieces on the chessboard can be represented as follows:</p>
<pre>START_PIECES_POSITION = {<br/>"A8": "r", "B8": "n", "C8": "b", "b", "G8": "n", "H8": "r",<br/>"A7": "p", "B7": "p", "C7": "p", "p", "G7": "p", "H7": "p",<br/>"A2": "P", "B2": "P", "C2": "P", "P", "G2": "P", "H2": "P",<br/>"A1": "R", "B1": "N", "C1": "B", "D8": "q", "E8": "k", "F8":<br/>"D7": "p", "E7": "p", "F7": "D2": "P", "E2": "P", "F2":<br/>"D1": "Q", "E1": "K", "F1":<span>"B", "G1": "N", "H1": "R"</span><br/><span>}</span></pre>
<p>We need this data to get started. So, let's add this as a constant to the <kbd>configurations.py</kbd> file (see <kbd>4.02</kbd>).</p>
<p>Now, let's move on to code the <kbd>Model</kbd> class for our program. We have already decided that we will use a Python dictionary to store the position of chess pieces on the chessboard. We can go ahead and add a dictionary attribute to the class.</p>
<p>However, we will take a slightly different approach.</p>
<p>Let's make the <kbd>Model</kbd> class a child class of the built-in dictionary class, as follows:</p>
<pre>class Model(dict): </pre>
<p>Thus, the <kbd>self</kbd> variable that refers to the current class object instance will also have all the properties and methods that are available to the dictionary. All the methods that are available to the standard dictionary class can now be called on the <kbd>Model</kbd> object (<kbd>self</kbd>).</p>
<p>So now we can define a method that returns the short name of the chess piece at that position when it's given a position on the chessboard, as follows (see <kbd>4.02</kbd>—<kbd>model.py</kbd>):</p>
<pre>def get_piece_at(self, position):<br/>   return self.get(position) </pre>
<p>If there is no chess piece at the position, this returns <kbd>None</kbd> rather than giving a <kbd>KeyError</kbd> exception.</p>
<p>Next, let's add some more important attributes to the <kbd>Model</kbd> class, as follows (see <kbd>4.02</kbd>—<kbd>model.py</kbd>):</p>
<pre>captured_pieces = { 'white': [], 'black': [] }<br/>player_turn = None<br/>halfmove_clock = 0<br/>fullmove_number = 1<br/>history = []</pre>
<p>The <kbd>half-move_clock</kbd> keeps a track of the number of turns played since the last pawn's advance or the last capture. This is used to determine whether a draw can be claimed under the <kbd>fifty-move</kbd> rule.</p>
<p>The <kbd>full-move</kbd> number is a count that is incremented by <kbd>1</kbd> after every move of a black piece. This is used to track the overall length of a game.</p>
<p>Finally, let's add another method that, given the row-column tuple for a square, returns its alphanumeric position (for example, an input of (<kbd>1</kbd>, <kbd>2</kbd>) returns <kbd>B3</kbd>):</p>
<pre>def get_alphanumeric_position(self, rowcol):<br/>  if self.is_on_board(rowcol):<br/>     row, col = rowcol<br/>     return "{}{}".format(X_AXIS_LABELS[col], Y_AXIS_LABELS[row])</pre>
<p>Next, let's define an associated helper method to ensure that we only process mouse clicks that occur on the Canvas widget and not anywhere else in the root window, as follows:</p>
<pre>def is_on_board(self, rowcol):<br/>     row, col = rowcol<br/>    return 0 &lt;= row &lt;= 7 and 0 &lt;= col &lt;= 7 </pre>
<p>There is not much that can be added to the <kbd>Model</kbd> class for now until we lay down the code logic to handle the chess pieces.</p>
<p>We can define the rules for all the chess pieces within the <kbd>Model</kbd> class, but that would make the <kbd>Model</kbd> class too bulky.</p>
<p>Therefore, let's define the chess piece-related logic in a new file named <kbd>piece.py</kbd>. Since this is inherently a part of the <kbd>Model</kbd> class but it is defined in a new file, let's add a reference to the <kbd>Model</kbd> class within this file.<br/>
(see <kbd>4.02</kbd>—<kbd>piece.py</kbd>)</p>
<p>Let's do this next.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a Piece class</h1>
                </header>
            
            <article>
                
<p>Think about it. We need to define rules for all the different chess pieces. Some attributes and methods, such as color, will be common to all the chess pieces, while other attributes/methods, such as rules for movement, will vary for each chess piece.</p>
<p>First, we'll define a new <kbd>Piece</kbd> class. This class will have the attributes and methods that are common to all the chess pieces. Then, we will define classes for every individual piece as a subclass of this parent <kbd>Piece</kbd> class. We can then override all the attributes and methods in these individual classes. The code will look like this (see <kbd>4.02</kbd>—<kbd>piece.py</kbd>):</p>
<pre>from configurations import *<br/><br/>class Piece():<br/>  def __init__(self, color):<br/>    self.name = self.__class__.__name__.lower()<br/>    if color == 'black':<br/>      self.name = self.name.lower()<br/>    elif color == 'white':<br/>      self.name = self.name.upper()<br/>      self.color = color<br/><br/>def keep_reference(self, model):<br/>   self.model = model<br/><br/>class King(Piece):<br/>  pass<br/><br/>class Queen(Piece):<br/>  pass<br/><br/>class Rook(Piece):<br/>  pass<br/><br/>class Bishop(Piece):<br/>  pass<br/><br/>class Knight(Piece):<br/>  pass<br/><br/>class Pawn(Piece):<br/>  pass</pre>
<p>Note that the <kbd>Piece</kbd> class needs <kbd>color</kbd> as an argument for object creation. We create two attributes, named <kbd>self.name</kbd> and <kbd>self.color</kbd>, in the class.</p>
<p>Also note the <kbd>keep_reference(self, model)</kbd> method definition. Since the <kbd>Piece</kbd> class is nothing but an extension of the <kbd>Model</kbd> class, we need to get a reference to the <kbd>Model</kbd> class in this method to communicate with it.</p>
<p>Similarly, the <kbd>Model</kbd> class needs a reference to the new <kbd>Piece</kbd> class. Accordingly, we add this as an import to the <kbd>Model</kbd> class, as follows (see <kbd>4.02</kbd>—<kbd>model.py</kbd>):</p>
<pre>import piece</pre>
<p>Finally, we need a method that takes a string pertaining to the name of a given piece object and creates a new piece object. For example, we need a method that, given the arguments (Pawn, black) or simply (<kbd>"p"</kbd>), dynamically creates a new <kbd>Pawn</kbd> object with the color attribute defined as black.</p>
<p>Accordingly, let's define a helper method in the <kbd>piece.py</kbd> file but outside the <kbd>Piece</kbd> class, as follows (see <kbd>4.02</kbd>—<kbd>piece.py</kbd>):</p>
<pre>def create_piece (piece, color='white'):<br/>  if isinstance(piece, str):<br/>    if piece.upper() in SHORT_NAME.keys():<br/>      color = "white" if piece.isupper() else "black"<br/>      piece = SHORT_NAME[piece.upper()]<br/>    piece = piece.capitalize()<br/>    if piece in SHORT_NAME.values():<br/>      return eval("{classname} (color)".format(classname=piece))<br/> raise exceptions.ChessError("invalid piece name: '{}'".format(piece))</pre>
<p>To support the preceding method, add the following constant to the <kbd>configurations.py</kbd> file (see <kbd>4.02</kbd>):</p>
<pre>SHORT_NAME = {<br/> 'R':'Rook', 'N':'Knight', 'B':'Bishop', 'Q':'Queen', 'K':'King', 'P':'Pawn'<br/> }</pre>
<p>The preceding code simply takes a single character as an input. It then gets the full name for the corresponding piece class (for example, if a <kbd>p</kbd> is given, it gets the full name, which is <kbd>Pawn</kbd>). It then checks the case of the character and defines the color variable as <em>white</em> if the input character is uppercase. Otherwise, the color is set to <em>black</em>. It then dynamically creates a corresponding piece object.</p>
<p>This concludes the iteration. We have created the <kbd>Piece</kbd> class and all of its subclasses, and we have the ability to create <kbd>Piece</kbd> objects dynamically from a given input character. This class is simply an extension of the <kbd>Model</kbd> class, and each of the two classes can access each other's methods by keeping a reference to each other.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Displaying chess pieces on the chessboard</h1>
                </header>
            
            <article>
                
<p>Now, let's turn our attention to displaying all the chess pieces on the chessboard.</p>
<p>First, we'll define a method named <kbd>draw_single_piece</kbd>, which draws a chess piece at the given position when it's given a position, and the character representing the chess piece as follows (see <kbd>4.03</kbd>—<kbd>view.py</kbd>):</p>
<pre>def draw_single_piece(self, position, piece):<br/>  x, y = self.controller.get_numeric_notation(position)<br/>  if piece:<br/>    filename = "../pieces_image/{}_{}.png".format(piece.name.lower(), piece.color)<br/>    if filename not in self.images:<br/>      self.images[filename] = PhotoImage(file=filename)<br/>    x0, y0 = self.calculate_piece_coordinate(x, y)<br/>    self.canvas.create_image(x0, y0, image=self.images[filename], <br/>                          tags=("occupied"),  anchor="c")</pre>
<p>The following is a description of the preceding code:</p>
<ul>
<li>The images of the chess pieces are stored in a folder named <kbd>pieces_image</kbd> and are named with the chess piece's name in <kbd>lowercase + _ + color.png</kbd> format. So for instance, the black queen is saved by the name <kbd>queen_black.png</kbd>.</li>
<li>The images are added to the chessboard by using the <kbd>canvas.create_image()</kbd> method, which takes the <em>x</em>, <em>y</em> coordinates and a <kbd>PhotoImage()</kbd> object that relies on the location of the image file as its argument.</li>
<li>We used Tkinter's <kbd>PhotoImage</kbd> class to reference the <kbd>.png</kbd> files.</li>
<li>In addition to creating and displaying a chess piece on the chessboard, we also <em>tagged</em> them with a custom tag called <kbd>occupied</kbd>. Tagging is an important feature of the Canvas widget which lets us uniquely identify items placed on the Canvas widget.</li>
</ul>
<p>We  used the following helper method in the preceding code (see <kbd>4.03</kbd>—<kbd>view.py</kbd>):</p>
<pre>def calculate_piece_coordinate(self, row, col):<br/>  x0 = (col * DIMENSION_OF_EACH_SQUARE) + int(DIMENSION_OF_EACH_SQUARE / 2)<br/>  y0 = ((7 - row) * DIMENSION_OF_EACH_SQUARE) + <br/>    int(DIMENSION_OF_EACH_SQUARE / 2)<br/>  return (x0, y0)</pre>
<p>We also define another helper method that returns the numeric notation for the position of a piece (see <kbd>4.03</kbd>—<kbd>controller.py</kbd>):</p>
<pre>def get_numeric_notation(self, position):<br/>  return piece.get_numeric_notation(position)</pre>
<p>This is just a wrapper around the following code from <kbd>4.03</kbd>—<kbd>piece.py</kbd>:</p>
<pre>def get_numeric_notation(rowcol):<br/>  row, col = rowcol<br/>  return int(col)-1, X_AXIS_LABELS.index(row) </pre>
<p>Now, it's time simply to call the preceding <kbd>draw_single_piece</kbd> method on all the chess pieces (<kbd>4.03</kbd>—<kbd>view.py</kbd>):</p>
<pre>def draw_all_pieces(self):<br/> self.canvas.delete("occupied")<br/> for position, piece in  self.controller.get_all_pieces_on_chess_board():<br/>   self.draw_single_piece(position, piece)</pre>
<p>A key aspect that you need to note here is that when we needed some data from the <kbd>Model</kbd> class, say, a dictionary containing all the chess pieces on the chessboard, we did not directly call the <kbd>Model</kbd> class for the data. Instead, we requested the controller get us the data from the model. The <kbd>get_all_pieces_on_chess_board()</kbd> controller method is simply a wrapper around the actual method from the <kbd>Model</kbd> class (see <kbd>4.03</kbd>—<kbd>controller.py</kbd>):</p>
<pre>def get_all_pieces_on_chess_board(self):<br/>  return self.model.items()</pre>
<p>Great! We now have the methods required to draw all the chess pieces on the chessboard. But merely defining them does not help. These methods need to be called from somewhere. Therefore, let's define a new method named <kbd>start_new_game()</kbd> and call it from the <kbd>__init__</kbd> method of the <kbd>View</kbd> class, as follows (see <kbd>4.03</kbd>—<kbd>view.py</kbd>):</p>
<pre> def start_new_game(self):<br/>   self.controller.reset_game_data()<br/>   self.controller.reset_to_initial_locations()<br/>   self.draw_all_pieces()</pre>
<p>In addition to calling the <kbd>draw_all pieces()</kbd> method, this method also resets the <kbd>Model</kbd> via calls to two wrapper controller methods (see <kbd>4.03</kbd>—<kbd>controller.py</kbd>):</p>
<pre>def reset_game_data(self):<br/>  self.model.reset_game_data()<br/><br/>def reset_to_initial_locations(self):<br/>  self.model.reset_to_initial_locations()</pre>
<p>The actual methods are defined in the <kbd>Model</kbd> class, as follows:</p>
<pre>def reset_game_data(self):<br/>  captured_pieces = {'white': [], 'black': []}<br/>  player_turn = None<br/>  halfmove_clock = 0<br/>  fullmove_number = 1<br/>  history = []<br/> <br/>def reset_to_initial_locations(self):<br/>  self.clear()<br/>  for position, value in START_PIECES_POSITION.items():<br/>    self[position] = piece.create_piece(value)<br/>    self[position].keep_reference(self)<br/>    self.player_turn = 'white'</pre>
<p>The <kbd>reset_game_data()</kbd> method is simple. It just resets all the attributes of the <kbd>Model</kbd> class to their initial states.</p>
<p>The <kbd>reset_to_initial_locations()</kbd> method initializes all the chess piece locations to reflect the starting position of the game. This too should be self-explanatory if you are aware of the data structure that we discussed earlier.</p>
<p>Now, when you go ahead and run the code (see <kbd>4.03</kbd>—<kbd>view.py</kbd>), the chessboard should display all the chess pieces at the starting position of the game, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img height="273" src="assets/4d6034d2-d50b-473f-85bc-b9a4b67ef9d3.png" width="236"/></div>
<p>This completes the current iteration. The next iteration will define the rules for the movement of the chess pieces on the chessboard. We need this part done before we can think of moving the chess pieces around.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Defining rules for the chess pieces</h1>
                </header>
            
            <article>
                
<p>Different chess pieces have different rules of movement. Let's try to tabulate the rules:</p>
<table>
<tbody>
<tr>
<td><strong>Name of the</strong><br/>
<strong>chess piece</strong></td>
<td><strong>Orthogonal movement</strong></td>
<td><strong>Diagonal movement</strong></td>
<td><strong>The maximum number</strong><br/>
<strong>of places the chess piece</strong><br/>
<strong>is allowed to move</strong></td>
</tr>
<tr>
<td>King</td>
<td>Yes</td>
<td>Yes</td>
<td>1</td>
</tr>
<tr>
<td>Queen</td>
<td>Yes</td>
<td>Yes</td>
<td>8</td>
</tr>
<tr>
<td>Rook</td>
<td>Yes</td>
<td>No</td>
<td>8</td>
</tr>
<tr>
<td>Bishop</td>
<td>No</td>
<td>Yes</td>
<td>8</td>
</tr>
<tr>
<td>Knight</td>
<td>N/A</td>
<td>N/A</td>
<td>N/A</td>
</tr>
<tr>
<td>Pawn</td>
<td>Yes, but it captures<br/>
diagonally</td>
<td>No</td>
<td>1 or 2</td>
</tr>
</tbody>
</table>
<p> </p>
<p>As evident from the table, the rules for all the chess pieces except for <em>Knight</em> and <em>Pawn</em> are pretty straightforward.</p>
<p>Knights are different from the others. They must move two squares in one direction, and then one more move at a 90-degree angle, following the shape of an L. Knights are also the only chess pieces that can jump over other chess pieces.</p>
<p>Pawns move forward, but they capture diagonally. Pawns can only move forward one square at a time, except for their very first move, where they can move forward by two squares. Pawns can only capture one square diagonally in front of them.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Rules for the king, queen, rooks, and bishops</h1>
                </header>
            
            <article>
                
<p>Let's first take a look at simple cases of orthogonally and diagonally moving chess pieces, which are the king, queen, rooks, and bishops. We need somehow to figure out a way to change the position of these chess pieces by using a mathematical rule.</p>
<p>The following diagram shows what it takes to move a chess piece from its current position (say <em>x</em>, <em>y)</em> both orthogonally and diagonally:</p>
<div class="CDPAlignCenter CDPAlign"><img height="184" src="assets/7b70b290-f160-45f8-9a8a-5676b126e5c1.png" width="316"/></div>
<p class="mce-root">If you look at the preceding diagram, <em>x</em> represents the column number and <em>y</em> represents the row number. It is clear that we can represent the orthogonal movements by adding to the current position the items from the tuples (<kbd>-1</kbd>, <kbd>0</kbd>), (<kbd>0</kbd>, <kbd>1</kbd>), (<kbd>1</kbd>, <kbd>0</kbd>), (<kbd>0</kbd>, <kbd>-1</kbd>).</p>
<p>Similarly, diagonal movements can be represented by adding to the tuples (<kbd>-1</kbd>, <kbd>1</kbd>), (<kbd>1</kbd>, <kbd>1</kbd>), (<kbd>1</kbd>, <kbd>-1</kbd>), (<kbd>-1</kbd>, <kbd>-1</kbd>).</p>
<p>Let's add these two tuples to <kbd>configurations.py</kbd> (see <kbd>4.04</kbd>), as follows:</p>
<pre>ORTHOGONAL_POSITIONS = ((-1,0),(0,1),(1,0),(0, -1))<br/>DIAGONAL_POSITIONS = ((-1,-1),(-1,1),(1,-1),(1,1)) </pre>
<p>If a chess piece can move both orthogonally and diagonally, such as the <em>queen,</em> the representative tuple is simply an addition of the preceding two tuples.</p>
<p>If a chess piece can be moved by more than one square, it's simply a matter of multiplying the representative tuple by an integer to get all the other allowed positions on the chessboard.</p>
<p>With this information in mind, let's code a <kbd>moves_available</kbd> method that, given the current position of the chess piece, the directions tuple relevant to the chess piece, and the maximum distance that the chess piece can move, returns a list of all the <kbd>allowed_moves</kbd>, as follows (see <kbd>4.04</kbd>—<kbd>piece.py</kbd>):</p>
<pre>def moves_available(self, current_position, directions,distance):<br/>  model = self.model<br/>  allowed_moves = []<br/>  piece = self<br/>  start_row, start_column = get_numeric_notation(current_position)<br/>  for x, y in directions:<br/>    collision = False<br/>    for step in range(1, distance + 1):<br/>      if collision: break<br/>      destination = start_row + step * x, start_column + step * y<br/>      if self.possible_position(destination) not in <br/>        model.all_occupied_positions():<br/>         allowed_moves.append(destination)<br/>      elif self.possible_position(destination) in<br/>                         model.all_positions_occupied_by_color <br/>                           (piece.color):<br/>         collision = True<br/>      else:<br/>         allowed_moves.append(destination)<br/>         collision = True<br/>  allowed_moves = filter(model.is_on_board, allowed_moves)<br/>  return map(model.get_alphanumeric_position, allowed_moves)<br/><br/></pre>
<p>The following is a description of the preceding code:</p>
<ul>
<li>Depending on the arguments, the method collects all the allowed moves for a given chess piece in a list named <kbd>allowed_moves</kbd>.</li>
<li>The code iterates through all the locations to detect a possible collision. If a collision is detected, it breaks out of the loop. Otherwise, it appends the coordinate to the <kbd>allowed_moves</kbd> list.</li>
<li>The second to last line filters out the moves that fall outside the chessboard, and the last line returns the equivalent position in alphanumeric notations for all the allowed moves.</li>
</ul>
<p>We can also define a few helper methods to support the preceding method, as follows:</p>
<pre>def possible_position(self, destination): #4.04 piece.py<br/>  return self.model.get_alphanumeric_position(destination)<br/> <br/>def all_positions_occupied_by_color(self, color): #4.04 model.py<br/>  result = []<br/>  for position in self.keys():<br/>    piece = self.get_piece_at(position)<br/>    if piece.color == color:<br/>      result.append(position)<br/>  return result<br/><br/>def all_occupied_positions(self): #4.04 model.py<br/>  return self.all_positions_occupied_by_color('white') +\<br/>         self.all_positions_occupied_by_color('black')</pre>
<p>Next, let's modify the <kbd>Piece</kbd> child classes of king, queen, rooks, and bishops as follows (see <kbd>4.04</kbd>—<kbd>piece.py</kbd>):</p>
<pre><strong>class King(Piece):</strong><br/>  directions = ORTHOGONAL_POSITIONS + DIAGONAL_POSITIONS<br/>  max_distance = 1<br/> <br/>  def moves_available(self,current_position):<br/>     return super().moves_available(current_position, self.directions, self.max_distance)<br/><br/><strong>class Queen(Piece):</strong><br/>  directions = ORTHOGONAL_POSITIONS + DIAGONAL_POSITIONS<br/>  max_distance = 8<br/> <br/>  def moves_available(self,current_position):<br/>    return super(Queen, self).moves_available<br/>               (current_position, self.directions, self.max_distance)<br/><br/><strong>class Rook(Piece):</strong><br/>  directions = ORTHOGONAL_POSITIONS<br/>  max_distance = 8<br/>  <br/>  def moves_available(self,current_position):<br/>      return super(Rook, self).moves_available(current_position,<br/>                                    self.directions, self.max_distance)<br/><br/><strong>class Bishop(Piece):</strong><br/>  directions = DIAGONAL_POSITIONS<br/>  max_distance = 8<br/> <br/>  def moves_available(self,current_position):<br/>     return super(Bishop, self).moves_available<br/>              (current_position, self.directions, self.max_distance)</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Rules for the Knight</h1>
                </header>
            
            <article>
                
<p>The knight is a different beast because it does not move orthogonally or diagonally. It can also jump over chess pieces.</p>
<p>Like the rules that we followed earlier to arrive at <kbd>ORTHOGONAL_POSITIONS</kbd> and <kbd>DIAGONAL_POSITIONS</kbd>, we can similarly arrive at the rules that are required to determine the <kbd>KNIGHT_POSITIONS</kbd> tuple. This is defined in <kbd>4.04</kbd>—<kbd>configurations.py</kbd>, as follows:</p>
<pre>KNIGHT_POSITIONS = ((-2,-1),(-2,1),(-1,-2),(-1,2),(1,-2),(1,2),(2,-1),(2,1))</pre>
<p>Next, let's override the <kbd>moves_available</kbd> method from the <kbd>Knight</kbd> class (see code <kbd>4.04</kbd>—<kbd>piece.py</kbd>):</p>
<pre>class Knight(Piece):<br/><br/> def moves_available(self, current_position):<br/>   model = self.model<br/>   allowed_moves = []<br/>   start_position = get_numeric_notation(current_position.upper())<br/>   piece = model.get(pos.upper())<br/>   for x, y in KNIGHT_POSITIONS:<br/>     destination = start_position[0] + x, start_position[1] + y<br/>     if(model.get_alphanumeric_position(destination) not <br/>             in model.all_positions_occupied_by_color(piece.color)):<br/>       allowed_moves.append(destination)<br/>   allowed_moves = filter(model.is_on_board, allowed_moves)<br/>   return map(model.get_alphanumeric_position, allowed_moves)</pre>
<p>The following is a description of the preceding code:</p>
<ul>
<li>The method is quite similar to the previous superclass method. However, unlike the superclass method, the changes are represented as capture moves using the <kbd>KNIGHT_POSITIONS</kbd> tuple.</li>
<li>Unlike the superclass, we do not need to track collisions, because knights can jump over other chess pieces.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Rules for a pawn</h1>
                </header>
            
            <article>
                
<p>A pawn has a unique movement too in that it moves forward, but it captures diagonally. Let's similarly override the <kbd>moves_available</kbd> class from within the <kbd>Pawn</kbd> class, as follows (see <kbd>4.04</kbd>—<kbd>piece.py</kbd>):</p>
<pre>class Pawn(Piece):<br/> <br/>  def moves_available(self, current_position):<br/>    model = self.model<br/>    piece = self<br/>    if self.color == 'white':<br/>      initial_position, direction, enemy = 1, 1, 'black'<br/>    else:<br/>      initial_position, direction, enemy = 6, -1, 'white'<br/>    allowed_moves = []<br/>    # Moving<br/>    prohibited = model.all_occupied_positions()<br/>    start_position = get_numeric_notation(current_position.upper())<br/>    forward = start_position[0] + direction, start_position[1]<br/>    if model.get_alphanumeric_position(forward) not in prohibited:<br/>      allowed_moves.append(forward)<br/>      if start_position[0] == initial_position:<br/>        # If pawn is in starting position allow double  moves<br/>        double_forward = (forward[0] + direction, forward[1])<br/>        if model.get_alphanumeric_position(double_forward) not in <br/>          prohibited:<br/>            allowed_moves.append(double_forward)<br/>    # Attacking<br/>    for a in range(-1, 2, 2):<br/>      attack = start_position[0] + direction,<br/>      start_position[1] + a<br/>      if model.get_alphanumeric_position(attack) in<br/>                 model.all_positions_occupied_by_color(enemy):<br/>         allowed_moves.append(attack)<br/>    allowed_moves = filter(model.is_on_board, allowed_moves)<br/>    return map(model.get_alphanumeric_position, allowed_moves)</pre>
<p>The following is a description of the preceding code:</p>
<ul>
<li>We first assigned the <kbd>initial_row_position</kbd>, direction, and enemy variables depending on whether the pawn is black or white.</li>
<li>Similar to the previous <kbd>moves_allowed</kbd> methods, this method collects all the allowed moves in a blank list named <kbd>allowed_moves</kbd>.</li>
<li>Then, we collected a list of all the prohibited moves by concatenating two lists of squares occupied by all the black and white chess pieces.</li>
<li>We defined a variable named <kbd>forward</kbd> which holds the position of the square immediately ahead of the current position of the pawn.</li>
<li>A pawn cannot move forward if there is a chess piece in front of it. If the forward position is not prohibited, the position is appended to the <kbd>allowed_moves</kbd> list.  A pawn can move two places forward from its starting position. We check whether the current position is the starting position, and if it is the starting position, we append the double move to the <kbd>allowed_moves</kbd> list.</li>
<li>A pawn can capture only the diagonally adjacent chess pieces in front of it. Therefore, we assigned a variable attack to track the diagonally adjacent positions on the chessboard. If the diagonally adjacent square is occupied by an enemy, that position qualifies to be appended to the <kbd>allowed_moves</kbd> list.</li>
<li>Then, we filtered the list to remove all the positions that may fall outside the chessboard. The last line returns all the allowed moves as a list of corresponding alphanumeric notations, as we did in all the previous definitions.</li>
</ul>
<p>This completes the current iteration. We coded the logic needed to enforce the rules related to the movement of chess pieces on the chessboard.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Movement validation of chess pieces</h1>
                </header>
            
            <article>
                
<p>Before we allow chess pieces to move, we must have a record of all the possible movement options on the chessboard. At every move, we also need to check whether it is a legitimate turn for a given player and the proposed move should not cause check on the current player's king.</p>
<p>Now, check may occur on the king not only from a chess piece that was moved, but from any other chess piece on the chessboard as a consequence of such a movement. Thus, after every move, we need to calculate the possible moves for all the chess pieces of the opponent.</p>
<p>Accordingly, we will need two methods to do the following:</p>
<ul>
<li>Keep a track of all the available moves for a player</li>
<li>Check whether there is check on the king</li>
</ul>
<p>Let's add two new methods in the <kbd>Model</kbd> class (see <kbd>4.05</kbd>—<kbd>model.py</kbd>).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Tracking all available moves</h1>
                </header>
            
            <article>
                
<p>The code needed to keep track of all the available moves for a player is as follows:</p>
<pre>def get_all_available_moves(self, color):<br/>  result = []<br/>  for position in self.keys():<br/>    piece = self.get_piece_at(position)<br/>    if piece and piece.color == color:<br/>       moves = piece.moves_available(position)<br/>       if moves:<br/>         result.extend(moves)<br/>  return result</pre>
<p>The description of the code is as follows:</p>
<ul>
<li>We have already coded the <kbd>moves_available</kbd> method in the previous iteration</li>
<li>The preceding method simply iterates through every item in the dictionary and appends the <kbd>moves_available</kbd> result for every chess piece of a given color in a list named <kbd>result</kbd></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Finding out the current position of the king</h1>
                </header>
            
            <article>
                
<p>Before we code the method that checks whether a king is in check, we first need to know the exact position of the king. Let's define a method to find out the current position of the king, as follows (see <kbd>4.05</kbd>—<kbd>model.py</kbd>):</p>
<pre> def get_alphanumeric_position_of_king(self, color):<br/>   for position in self.keys():<br/>     this_piece = self.get_piece_at(position)<br/>     if isinstance(this_piece, piece.King) and this_piece.color == color:<br/>        return position</pre>
<p>The preceding code simply iterates through all the items in the dictionary. If a given position is an instance of the <kbd>King</kbd> class, it simply returns its position.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Checking whether the king is in check</h1>
                </header>
            
            <article>
                
<p>Let's define a method to check whether the king is in check from the opponent, as follows:</p>
<pre>def is_king_under_check(self, color):<br/>  position_of_king = self.get_alphanumeric_position_of_king(color)<br/>  opponent = 'black' if color =='white' else 'white'<br/>  return position_of_king in self.get_all_available_moves(opponent) </pre>
<p>The following is a description of the preceding code:</p>
<ul>
<li>First, we obtained the current position of the king and the color of the opponent.</li>
<li>We then found out all the possible moves for all the chess pieces of the opponent. If the position of the king coincides with any position from all the possible moves, the king is in check and we return <kbd>True</kbd>. Otherwise, we return <kbd>False</kbd>.</li>
</ul>
<p>This accomplishes the objectives for the iteration. We are now in a position to check all the available moves for a player at a given point in the game. We can also check whether a king is in check from the opponent.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Making the game functional</h1>
                </header>
            
            <article>
                
<p>Now that we have all the chess pieces and chessboard-related validation rules in place, let's add life to our chess program. In this iteration, we will make our chess game fully functional.</p>
<p>The objective of this iteration is to move the chess pieces with a click of the left mouse button. When a player clicks on a chess piece, the code should first check whether it is a legitimate turn for that chess piece.</p>
<p>On the first click, the chess piece that needs to be moved is selected, and all the allowed moves for that chess piece are highlighted on the chessboard. The second click should be performed on the destination square. If the second click is done on a valid destination square, the chess piece should move from the source square to the destination square.</p>
<p>We also need to code the events of capturing chess pieces and the king being in check. The other attributes that need to be tracked include a list of the captured chess pieces, the half-move clock count, the full-move number count, and the history of all the previous moves.</p>
<p>You may recall that we created a dummy method which is bound to the left-click event. The method, for now, simply prints the row and column value on the console.</p>
<p>Let's modify this method, as follows (see <kbd>4.06</kbd>—<kbd>view.py</kbd>):</p>
<pre>def on_square_clicked(self, event):<br/>  clicked_row, clicked_column = self.get_clicked_row_column(event)<br/>  position_of_click =  self.controller.get_alphanumeric_position <br/>                                   ((clicked_row, clicked_column))<br/>  if self.selected_piece_position: # on second click<br/>     self.shift(self.selected_piece_position, position_of_click)<br/>     self.selected_piece_position = None<br/>  self.update_highlight_list(position_of_click)<br/>  self.draw_board()<br/>  self.draw_all_pieces()</pre>
<p>The following is a description of the preceding code:</p>
<ul>
<li>The first part of the code calculates the coordinates for the chess piece on which you clicked. Based on the calculated coordinates, it stores the corresponding letter notation in a variable named <kbd>position_of_click</kbd>.</li>
<li>It then tries to assign the piece variable to the corresponding piece instance. If there is no piece instance on the clicked square, it simply ignores the click.</li>
<li>The second part of the method checks whether this is the second click that was intended to move a chess piece to a destination square. If this is the second click, it calls the <kbd>shift</kbd> method, passing the source and destination coordinates as its two arguments.</li>
<li>If the <kbd>shift</kbd> method succeeds, it sets all the previously set attributes to their original empty values and calls the <kbd>draw_board</kbd> and <kbd>draw_pieces</kbd> methods to redraw the chessboard and chess pieces.</li>
</ul>
<p>While coding the desired functionality for the <kbd>on_square_clicked</kbd> method, we called several new methods from within it. We need to define these new methods.</p>
<p>Keep an eye on <span>the <kbd>on_square_clicked</kbd></span> method. This is the central method around which all the other methods will evolve over the course of our attempts to make the chess game functional.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting the source and destination position</h1>
                </header>
            
            <article>
                
<p>We have called the <kbd>shift</kbd> method from the <kbd>on_square_clicked</kbd> method. The code for the <kbd>shift</kbd> method is responsible for the collection of the necessary arguments that are required for the <kbd>shift</kbd> operation.</p>
<p>The code for the <kbd>shift</kbd> method is as follows:</p>
<pre>def shift(self, start_pos, end_pos):<br/>  selected_piece = self.controller.get_piece_at(start_pos)<br/>  piece_at_destination =  self.controller.get_piece_at(end_pos)<br/>  if not piece_at_destination or piece_at_destination.color<br/>                      != selected_piece.color:<br/>     try:<br/>        self.controller.pre_move_validation(start_pos, end_pos)<br/>     except exceptions.ChessError as error:<br/>        self.info_label["text"] = error.__class__.__name__<br/>  else:<br/>     self.update_label(selected_piece, start_pos, end_pos)</pre>
<p>The code first checks whether a chess piece exists at the destination. If a chess piece does not exist at the destination square, it calls on a method, <kbd>shift</kbd>, from the <em>controller,</em> which is a wrapper around the actual <kbd>shift</kbd> method from the <kbd>Model</kbd> class.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Collecting a list of the moves that need to be highlighted</h1>
                </header>
            
            <article>
                
<p>We also called the <kbd>update_highlight_list(position)</kbd> method from the <kbd>on_square_clicked</kbd> method. The purpose of this method is to collect all the possible moves for a given chess piece in a list named <kbd>all_squares_to_be_highlighted</kbd>.</p>
<p>The actual focusing of the available moves takes place in the <kbd>draw_board</kbd> method of the GUI class. The code for this is as follows (see <kbd>4.06</kbd>—<kbd>view.py</kbd>):</p>
<pre>def update_highlight_list(self, position):<br/>  self.all_squares_to_be_highlighted = None<br/>  try:<br/>    piece = self.controller.get_piece_at(position)<br/>  except:<br/>    piece = None<br/>  if piece and (piece.color == self.controller.player_turn()):<br/>    self.selected_piece_position = position<br/>  self.all_squares_to_be_highlighted = list(map(self.controller.get_numeric_notation,<br/>                   self.controller.get_piece_at(position).moves_available(position)))</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Highlighting allowed moves</h1>
                </header>
            
            <article>
                
<p>In the <kbd>on_square_clicked</kbd> method, we called the <kbd>draw_board</kbd> method to take care of the redrawing or changing of the chess pieces' coordinates. The current <kbd>draw_board</kbd> method is not equipped to handle this because we only designed it in the first iteration to provide us with a blank chessboard.</p>
<p>First, let's add a <kbd>HIGHLIGHT_COLOR</kbd> constant to the <kbd>configurations.py</kbd> file, as follows:</p>
<pre>HIGHLIGHT_COLOR = "#2EF70D"</pre>
<p>Then, modify the <kbd>draw_board</kbd> method to handle this, as follows (see <kbd>4.06</kbd>—<kbd>view.py</kbd>):</p>
<pre>def draw_board(self):<br/>  current_color = BOARD_COLOR_2<br/>  for row in range(NUMBER_OF_ROWS):<br/>     current_color = self.get_alternate_color(current_color)<br/>     for col in range(NUMBER_OF_COLUMNS):<br/>        x1, y1 = self.get_x_y_coordinate(row, col)<br/>        x2, y2 = x1 + DIMENSION_OF_EACH_SQUARE, y1 + <br/>          DIMENSION_OF_EACH_SQUARE<br/>        if(self.all_squares_to_be_highlighted and (row, col) in <br/>                       self.all_squares_to_be_highlighted):<br/>           self.canvas.create_rectangle(x1, y1, x2, y2, <br/>             fill=HIGHLIGHT_COLOR)<br/>        else:<br/>           self.canvas.create_rectangle(x1, y1, x2, y2, fill=current_color)<br/>        current_color = self.get_alternate_color(current_color)</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Pre-move validation</h1>
                </header>
            
            <article>
                
<p>The chess piece must only be moved if it does not violate the rules of the game. For example, a chess piece can move to a valid location only if that location is not already occupied by a chess piece of the same color. Similarly, a piece can move only if it is the player's turn to move. Another rule states that a piece can only move if the resulting move does not result in check for the king of the same color. </p>
<p>This <kbd>pre_move_validation</kbd> method is responsible for checking all the rules. If all validations pass, it calls the <kbd>move</kbd> method to update the move, as follows (see <kbd>4.06</kbd>—<kbd>model.py</kbd>):</p>
<pre>    def pre_move_validation(self, initial_pos, final_pos):<br/>        initial_pos, final_pos = initial_pos.upper(), final_pos.upper()<br/>        piece = self.get_piece_at(initial_pos)<br/>        try:<br/>            piece_at_destination = self.get_piece_at(final_pos)<br/>        except:<br/>            piece_at_destination = None<br/>        if self.player_turn != piece.color:<br/>            raise exceptions.NotYourTurn("Not " + piece.color + "'s turn!")<br/>        enemy = ('white' if piece.color == 'black' else 'black')<br/>        moves_available = piece.moves_available(initial_pos)<br/>        if final_pos not in moves_available:<br/>            raise exceptions.InvalidMove<br/>        if self.get_all_available_moves(enemy):<br/>            if self.will_move_cause_check(initial_pos, final_pos):<br/>                raise exceptions.Check<br/>        if not moves_available and self.is_king_under_check(piece.color):<br/>            raise exceptions.CheckMate<br/>        elif not moves_available:<br/>            raise exceptions.Draw<br/>        else:<br/>            self.move(initial_pos, final_pos)<br/>            self.update_game_statistics(<br/>                piece, piece_at_destination, initial_pos, final_pos)<br/>            self.change_player_turn(piece.color)</pre>
<p>If the rules are not being followed, this code raises several exceptions, which are defined in the exceptions class as follows (see <kbd>4.06</kbd>—<kbd>exceptions.py</kbd>):</p>
<pre> class <span>Check(ChessError): pass<br/></span> class <span>InvalidMove(ChessError): pass</span><br/> class <span>CheckMate(ChessError): pass</span><br/> class <span>Draw(ChessError): pass</span><br/> class <span>NotYourTurn(ChessError): pass</span></pre>
<p>We could have further coded the error classes, but we chose not to because we simply updated the name of the error class to the bottom label, which is sufficient for our current purpose. The error message is displayed from the shift method of the <kbd>View</kbd> class, as follows (see <kbd>4.06</kbd>—<kbd>view.py</kbd>):</p>
<pre>self.info_label["text"] = error.__class__.__name__</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Check whether a move will cause check on the King</h1>
                </header>
            
            <article>
                
<p>Though a major part of the validation check done in the preceding lines is simple, one of the validation steps needs to check whether a movement will cause the king to be in check. This is a tricky situation. We can only find this out after we have made the actual move. However, we cannot allow that movement to happen on the chessboard.</p>
<p>To do this, the <kbd>pre_move_validation</kbd> method calls a method named <kbd>will_move_cause_check</kbd>, which creates a copy of the <kbd>Model</kbd> class. Then, it performs a move on the new temporary copy to check whether it does cause a king to be in check. The code for this is as follows (<kbd>4.06</kbd>—<kbd>model.py</kbd>):</p>
<pre>def will_move_cause_check(self, start_position, end_position):<br/>  tmp = deepcopy(self)<br/>  tmp.move(start_position, end_position)<br/>  return tmp.is_king_under_check(self[start_position].color)</pre>
<div class="packt_tip">Note that when you create a copy by simple assignment, Python creates a shallow copy. In a shallow copy, the two variables now share the same data. So, a modification in one place affects the other as well.<br/>
In contrast to this, deep copies create a copy of everything—the structure as well as the elements. We need to create a deep copy of the chessboard because we want to check whether the king makes a valid move before it actually moves, and we want to do this without modifying the original object's state in any way.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Recording a move in the data structure</h1>
                </header>
            
            <article>
                
<p>The <kbd>shift</kbd> method defined in <kbd>view.py</kbd> is responsible for the actual moving of a chess piece on the chessboard. However, this brings about a change in the underlying data structure. The <kbd>move</kbd> method of the <kbd>Model</kbd> class is then responsible for updating the data structure. This <kbd>move</kbd> method is called from the previously defined <kbd>pre_move_validation()</kbd> method if and only if no errors are raised, as follows (<kbd>4.06</kbd>—<kbd>model.py</kbd>):</p>
<pre>def move(self, start_pos, final_pos):<br/> self[final_pos] = self.pop(start_pos, None)</pre>
<p>Note that as soon as this update is complete, the control returns to the <kbd>on_square_clicked()</kbd> method in <kbd>view.py</kbd><em>.</em> The method then calls the <kbd>draw_all_pieces()</kbd> method, which updates the view.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Keep game statistics</h1>
                </header>
            
            <article>
                
<p>The <kbd>pre_move_validation()</kbd> method also calls another method called <kbd>update_game_statistics()</kbd> on successfully recording a move (see <kbd>4.06</kbd>—<kbd>model.py</kbd>):</p>
<pre>    def update_game_statistics(self, piece, dest, start_pos, end_pos):<br/>        if piece.color == 'black':<br/>            self.fullmove_number += 1<br/>        self.halfmove_clock += 1<br/>        abbr = piece.name<br/>        if abbr == 'pawn':<br/>            abbr = ''<br/>            self.halfmove_clock = 0<br/>        if dest is None:<br/>            move_text = abbr + end_pos.lower()<br/>        else:<br/>            move_text = abbr + 'x' + end_pos.lower()<br/>            self.halfmove_clock = 0<br/>        self.history.append(move_text)<br/><br/></pre>
<p>Congratulations, our chess game is now functional!</p>
<p>Let's complete the iteration by binding the <span class="packt_screen">File</span> <em>|</em> <span class="packt_screen">New Game</span> menu item to start a new game. Earlier, we defined the <kbd>start_new_game()</kbd> method. Now, it's simply a matter of calling it from the <kbd>on_new_game_menu_clicked()</kbd> method, as follows (<kbd>4.06</kbd>—<kbd>view.py</kbd>):</p>
<pre>def on_new_game_menu_clicked(self):<br/>  self.start_new_game()</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Managing user preferences</h1>
                </header>
            
            <article>
                
<p>A very common theme in several GUI programs involves letting the user set the program's preferences.</p>
<p>For example, what if we want users to be able to customize the chessboard colors? What if we want users to select colors and, once selected, it is saved as a user preference and it is loaded the next time the program is run? Let's implement this as a feature.</p>
<p>Python offers a standard module called <kbd>configparser</kbd> that lets us save user preferences. Let's see the <kbd>configparser</kbd> module in action.</p>
<p>To begin with, import the <kbd>ConfigParser</kbd> class from the <kbd>configparser</kbd> module in the <kbd>configurations.py</kbd> file, as follows (see <kbd>4.07 preferenceswindow.py</kbd>):</p>
<pre>from configparser import ConfigParser</pre>
<p>The <kbd>configparser</kbd> module uses the <kbd>.ini</kbd> files to store and read the configuration values. The file consists of one or more named sections. These sections contain individual options with names and values.</p>
<p>To illustrate this, let's create a file called <kbd>chess_options.ini</kbd> in the project's root folder (see <kbd>4.07</kbd>). The file looks like this:</p>
<pre>[chess_colors]<br/> board_color_1 = #DDB88C<br/> board_color_2 = #A66D4F<br/> highlight_color = #2EF70D</pre>
<p>The first line of the file enclosed in square brackets (<kbd>[chess_colors]</kbd> in our example) is called a <strong>section</strong>. A <kbd>.ini</kbd> file can have multiple sections. This file has a single section. Each section can have multiple <em>key-value</em> options, as specified in the example.</p>
<p>We can read these values in our program by using the <kbd>getter</kbd> methods, as follows (see <kbd>4.07</kbd>—<kbd>configurations.py</kbd>):</p>
<pre>config = ConfigParser()<br/>config.read('chess_options.ini')<br/>BOARD_COLOR_1 = config.get('chess_colors', 'board_color_1', <br/>  fallback="#DDB88C")<br/>BOARD_COLOR_2 = config.get('chess_colors', 'board_color_2', fallback = <br/>  "#A66D4F")<br/>HIGHLIGHT_COLOR =config.get('chess_colors', 'highlight_color', fallback <br/>  = "#2EF70D")</pre>
<p>The preceding code replaces the three color constants that we defined earlier in the code.</p>
<p>Now, if you change the options in the <kbd>.ini</kbd> file, the color of the chessboard changes accordingly. However, we cannot expect end users to be conversant with editing the <kbd>.ini</kbd> files. Therefore, we will let them choose the colors using the <strong>color chooser </strong>module of Tkinter. A color that a user chooses gets reflected in the <kbd>.ini</kbd> file and consequently on the chessboard.</p>
<p>When a user clicks on the <span class="packt_screen">Edit</span> <em>|</em> <span class="packt_screen">Preference</span> menu item, we want to open a <em>transient window</em> with three different buttons to choose two chessboard colors and one highlight color. Clicking on a single button opens a color select window, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img height="180" src="assets/b515c321-a74d-4b71-9ab5-f34dd1342f40.png" width="193"/></div>
<p>We created this transient window in a new file called <kbd>preferenceswindow.py</kbd><em> </em>(see <kbd>4.07.py</kbd>). We will not discuss the code that creates this window, as this should be an easy task for you now.</p>
<p>Note that this window is converted into a transient window with respect to the top-level window by using the following code:</p>
<pre>self.pref_window.transient(self.parent)</pre>
<p>As a reminder, a transient window is one that always stays at the top of its parent window. It gets minimized when its parent window is minimized. For a quick refresher on transient windows, refer to <a href="41f1fda5-b3b1-4dfa-8971-2a016274d39a.xhtml" target="_blank">Chapter 2</a>, <em>Making a Text Editor,—</em><kbd>2.06.py</kbd>.<br/>
As we have created the window in <kbd>preferencewindow.py</kbd>, we'll import it into the <kbd>View</kbd> class as follows (see <kbd>2.07</kbd>—<kbd>view.py</kbd>):</p>
<pre>import preferenceswindow</pre>
<p>Then, command bind the preference menu by using the following two methods:</p>
<pre>def on_preference_menu_clicked(self):<br/>  self.show_prefereces_window()<br/> <br/>def show_prefereces_window(self):<br/>  preferenceswindow.PreferencesWindow(self)</pre>
<p>When a user clicks on the <span class="packt_screen">Cancel</span> button, we simply want the settings window to close. To do this, use the following code (see <kbd>4.07</kbd>—<kbd>preferencewindow.py</kbd>):</p>
<pre>def on_cancel_button_clicked(self):<br/>  self.pref_window.destroy()</pre>
<p>When a user changes the colors and clicks on the <span class="packt_screen">Save</span> button, the method calls the <kbd>set_new_values()</kbd> method, which first writes the new values to the <kbd>.ini</kbd> file and then returns the values to the <kbd>View</kbd> class to update the chessboard<span> immediately</span>:</p>
<pre>def set_new_values(self):<br/>  color_1 = self.board_color_1.get()<br/>  color_2 = self.board_color_2.get()<br/>  highlight_color = self.highlight_color.get()<br/>  config = ConfigParser()<br/>  config.read('chess_options.ini')<br/>  config.set('chess_colors', 'board_color_1',color_1)<br/>  config.set('chess_colors', 'board_color_2',color_2)<br/>  config.set('chess_colors', 'highlight_color', highlight_color)<br/>  configurations.BOARD_COLOR_1 = self.board_color_1.get()<br/>  configurations.BOARD_COLOR_2 = self.board_color_2.get()<br/>  configurations.HIGHLIGHT_COLOR = self.highlight_color.get()<br/>  with open('chess_options.ini', 'w') as config_file:<br/>     config.write(config_file)</pre>
<p>When the preceding code writes the new values to the <kbd>.ini</kbd> file, call the <kbd>reload_colors()</kbd> method from the <kbd>View</kbd> class to update the chessboard's color<span> immediately</span>. If you do not do this, the color change will take place the next time the chess program is run (see <kbd>4.07</kbd>—<kbd>view.py</kbd>):</p>
<pre>def reload_colors(self, color_1, color_2, highlight_color):<br/> self.board_color_1 = color_1<br/> self.board_color_2 = color_2<br/> self.highlight_color = highlight_color<br/> self.draw_board()<br/> self.draw_all_pieces()</pre>
<p>Having changed these attributes, we call <kbd>draw_board()</kbd> and <kbd>draw_all_pieces()</kbd> to repaint the chessboard in the newly defined colors. (see <kbd>4.07</kbd>—<kbd>view.py</kbd>).</p>
<p>This concludes the iteration. The users of the program can change the colors to match their preferences, and the program will remember the chosen values.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>We have come to the end of this chapter. So, what is it that we achieved here? Let's have a look at all the key things that we learned from the chapter.</p>
<p>We learned how to structure programs using the MVC architecture.</p>
<p>We took a peek at the versatility and power of the Tkinter Canvas widget. This included a tour through the basic usage of the canvas coordinates, object IDs, and tags.</p>
<p>We discussed how to handle complexity by implementing programs in a modular structure. We achieved this modularity by breaking down the code into several smaller files. We handled the entire configuration from a single file and all the errors in another file.</p>
<p>We explored how to extend Python's built-in error class to define a custom error and exceptions. We also had a look at how we can extend Python's built-in data types, as in the case of the <kbd>Model</kbd> class, which directly extended the <kbd>dict</kbd> class.<br/>
We studied how to use object inheritance to code classes with similar attributes and behavior when building the <kbd>Piece</kbd> class and all its subclasses.</p>
<p>Finally, you learned how to use Python's built-in <kbd>configparser</kbd> module to store user preferences. </p>
<p>We will create an audio player in the next chapter. In addition to this, we'll work with several new widgets. We will also take a look at how to create our own widgets!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">QA section</h1>
                </header>
            
            <article>
                
<p><span class="fontstyle0">Before you proceed to the next chapter, make sure you can answer these questions to your<br/>
satisfaction:</span></p>
<ul>
<li>What are the central tenets of the model-view-controller framework?</li>
<li>What is modularity in programming? Why is modularity good?</li>
<li>What are the advantages and disadvantages of using class inheritance in programs? </li>
<li><span>While inheritance provided us with a tool to reuse our code, multiple inheritance is frowned upon by many experts.  What could be the reason for this?</span></li>
<li>What are <kbd>tags</kbd> used for in the Tkinter Canvas widget?</li>
<li>Why do we use a <kbd>configparser</kbd> module? <span>What are some of the alternatives to using a <kbd>configparser</kbd> module?</span></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<p>MVC is a popular software <strong>architectural pattern</strong>, but there are many more architectural patterns that suit different use cases. Read about different architectural patterns at <a href="https://en.wikipedia.org/wiki/Architectural_pattern">https://en.wikipedia.org/wiki/Architectural_pattern</a>.</p>
<p>If chess enthuses you, or if you would like to get started in artificial intelligence,  you might attempt to implement a chess engine that plays as an opponent. This would require some reading on optimal search algorithms. Here's a tutorial that walks us through the process: <a href="https://medium.freecodecamp.org/simple-chess-ai-step-by-step-1d55a9266977">https://medium.freecodecamp.org/simple-chess-ai-step-by-step-1d55a9266977</a>. The tutorial engine has been implemented in JavaScript, but we can use it as a reference to build our own engine in Python.</p>
<p> </p>


            </article>

            
        </section>
    </body></html>