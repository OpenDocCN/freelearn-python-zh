- en: Gesture Recognition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since the beginning of time, humans have communicated with each other using
    gestures, even before there wasn't any formal language. Hand gestures were the
    primary way of communication, and it is also evident in the ancient sculptures
    found all across the world that the signs have been a successful way of transferring
    a huge amount of data in a very efficient way, sometimes, even more efficient
    than language itself.
  prefs: []
  type: TYPE_NORMAL
- en: Gestures are natural, and they can occur as a reflex to a certain situation.
    It also happens subconsciously even without our knowing. So, it becomes an ideal
    way of communication with various devices. However, the question remains, how?
  prefs: []
  type: TYPE_NORMAL
- en: We have used vision processing in our last few chapters, and we can be sure
    that if we are talking about gestures, then we would surely have to do a lot of
    programming to identify the gestures in the videos; furthermore, it would require
    a huge amount of processing power to make it happen as well. Hence, it is out
    of the question. We can build some basic gesture-recognition system using an array
    of proximity sensors. However, the range of gestures recognized would be very
    limited, and the overall ports being used would be multiple fold.
  prefs: []
  type: TYPE_NORMAL
- en: Hence, we need to find a solution that is easy to work with and does not cost
    more than what it would deliver.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Electric field sensing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Flick HAT
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gesture recognition-based automation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Electric field sensing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Near-field sensing is a very interesting field of sensing. Be prepared for some
    interesting stuff. If you are feeling a little sleepy, or if you are lacking attention,
    then get some coffee because the working principle of this system is going to
    be a little new.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever there is a charge, there is an associated electrical field that comes
    along with it. These charges propagate through the space and go around an object.
    When that happens, the electric field associated with it has a specific characteristic.
    This characteristic will be the same till the time the environment around it is
    empty.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the gesture-recognition board that we are using, the field that would be
    sensed around it is only for about a few centimeters, so anything beyond that
    point can be disregarded. If there is nothing in that vicinity, then we can safely
    assume that the pattern of electric field being sensed would be unchanged. However,
    whenever an object such as our hand comes in the vicinity, then these waves are
    distorted. The distortion is directly linked to the position of the object and
    its position. With this distortion, we can sense where the finger is, and with
    constant sensing, we see what kind of motion is being performed. The board in
    question looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/60de2d05-9256-4afd-8463-efd2c9fc4c8c.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The central criss-crossed area on the board is the transmitter and on the extreme
    sides are rectangular structures that are four in number. These are the sensing
    elements. These sense the pattern of waves in the space. Based on it, they can
    derive what are the x, y, and z coordinates of the object. This is powered by
    a chip named MGC 3130\. This does all the computation and delivers the raw reading
    to the user, regarding the coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Flick HAT
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Flick HAT comes in the form of a shield, which you can simply plug into your
    Raspberry Pi and start using. However, once you do that, you will not be left
    with any GPIO pins. Hence, to save ourselves from that problem, we will be connecting
    it using male-to-female wires. This will give us access to the other GPIO pins
    and then we can have fun.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, go ahead and connect it as follows. The following is a pin diagram of the
    Flick board:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b1f8cc67-60d5-4905-a6b6-2d7449c9c9a5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Thereafter, make the connections as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4ee5d33b-2203-475b-a489-8486f1691c4e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once the connection is done, simply upload this code and see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Now once you have uploaded  the code, lets go ahead and understand what this
    code is actually doing.
  prefs: []
  type: TYPE_NORMAL
- en: We are using a library called  `import flicklib` this is provided by the manufacturer
    of this board. The functions of this library would be used all over in this chapter
    for communicating with the flick board and getting the data
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are defining a function named `message(value)` what this would do
    is simply print whatever value would be passed on to the function in the argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This has a special concept of decorators. By definition, a decorator is a function
    that takes another function and extends the behavior of the latter function without
    explicitly modifying it. In the preceding line of code, we are declaring that
    it is a decorator `@`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This has a special job: dynamically defines any function in a program. What
    this means in plain English is that the function defined using this methodology
    can work differently depending on how the user defines it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The function `move()` will further be complimented by the function, which is
    getting defined after it. These kind of functions are named nested functions.
    That is functions inside a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are defining a function named `move()`, which has arguments as `x`,
    `y`, and `z`. Inside the function, we have defined a global variable named `xyztxt`;
    now, the value of `xyztxt` would be in a form of five digit, with a decimal after
    three places. How did we know that? As you can see, we are using a function named
    `format()`. What this function does is format the values of a given variable according
    to the way the user has requested it for. We have declared here the value as `{:5.3f}`. `:5`
    represents that it would be of five digits, and `3f` represents that the decimal
    places would be after three digits. Hence, the format would be `xxx.xx`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have defined a function named `flick(start, finish)`. It has two arguments: `start`
    and `finish`. Using the line `flicktxt = ''FLICK-'' + start[0].upper() + finish[0].upper()`, this
    is slicing the characters as recognized by the gesture board. If a south–north
    swipe is detected, then the start will get south and finish is north. Now we are
    only using the first characters of the words:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We are again defining the variables named `xyztxt` and `flicktxt` globally.
    Earlier, what we have done is that we have defined it in the function. Hence,
    it is important for us to define it in the main program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `flicktxt` variable would get a value corresponding to the gesture  when
    the gesture is detected. In case there is no gesture then `flicktxt` would be
    left empty. A variable named `flickcount` will count how many times its swiped.
    If the values are out of the range specified then the `flicktxt` would be cleared
    to empty string using the line `flicktxt = ''` and `flickcount` would be made
    0.
  prefs: []
  type: TYPE_NORMAL
- en: The final output of this would be a text given to user providing in which direction
    the hand is flicked.
  prefs: []
  type: TYPE_NORMAL
- en: Gesture recognition-based automation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we have interfaced the connections as per the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ff99fae1-1c6e-46aa-be14-52193face5e3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s go ahead and upload the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The program is in addition to the program we have done before, as always we
    have some added functionality of using the data being received by the flick gesture
    board and using it to switch on or switch off the lights.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like the previous program, we are taking in the gestures over the board in
    the form of the directions of swipes, and using a simple condition to switch off
    the lights, or switch them on. So, let''s see what are the additions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The first condition is simple. We are comparing the value of `flicktxt` to
    a given variable, which in our case is `FLICK-WE`, wherein `WE` stands for **west**
    to **east**. So when we flick from west to east, or in other words, when we flick
    from left to right, the lights would be switched off:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'As before, we are again taking in a variable named `FLICK-EW`, which stands
    for flick from east to west. What it does is whenever we flick our hand from east
    to west, or from right to left, the lights will be switched on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have put a dimmer along with a fan to control the speed of the fan as
    well; hence, we will have to give it a PWM corresponding to the speed that we
    want to drive it. Now whenever the user will flick his hand from south to north
    or from down to up. The condition `if dc_inc <100` will check whether the value
    of the `dc_inc` is less than or equal to `100` or not. If it is, then it will
    increment the value of the `dc_inc` by `20` values. Using the function `ChangeDutyCycle()`,
    we are providing the different duty cycle to the dimmer; hence, changing the overall
    speed of the fan. Every time you swipe up the value of the fan, it will increase
    by 20%:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we are were able to understand the concept of how gesture recognition
    works via electric field detection. We also understood how easy it is to use a
    gesture-controlled board and control the home using gestures. We will cover the
    machine learning part in the next chapter.
  prefs: []
  type: TYPE_NORMAL
