- en: Chapter 9. Grok and the ZODB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we stressed right from the first chapter, one of the most important pieces
    of Grok is the ZODB. The capability to store objects transparently has allowed
    us to create a complete application without having to think about persisting its
    data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although Grok takes care of what little ZODB interaction our application needs
    behind the scenes, there are a few more things that the ZODB can do, and we will
    review them in this chapter. In particular, we will see:'
  prefs: []
  type: TYPE_NORMAL
- en: How the ZODB works
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What ZODB storage is
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to add file attachments to our application by using Blob support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to pack the database and why this is recommended
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use the ZODB outside Grok
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How the ZODB works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we get into the details of how to use other ZODB functionality, let's
    talk a bit more about how ZODB works.
  prefs: []
  type: TYPE_NORMAL
- en: Simply put, the ZODB is a persistence system for Python objects. Its objective
    is to make persistence as transparent as possible, so that any changes to objects
    can automatically be saved to disk and read again when they are needed.
  prefs: []
  type: TYPE_NORMAL
- en: ZODB is an object database, which means that instead of partitioning objects
    into one or more tables according to a data schema, the objects themselves are
    written to the database in their current state. In a relational database system,
    once a row of data is read from the database, the program still needs to reassemble
    the columns of information to get a real object instance. In an object database
    system, an object instance is immediately there when you fetch it from the database.
  prefs: []
  type: TYPE_NORMAL
- en: Transparency
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Because it''s possible to store objects directly into the database as they
    are, very little effort is needed to make an object ZODB aware. In other words,
    objects are stored transparently. Due to this, although there are some cases where
    a little more work is needed, objects can generally be persisted in the database
    simply by meeting one simple requirement: to subclass from the `persistent.Persistent`
    class provided by the ZODB.'
  prefs: []
  type: TYPE_NORMAL
- en: When instances of persistent objects are modified, they are marked by the ZODB
    mechanisms, and the changes can be written to the database, if the user requests
    this. Of course, more than one modification could be requested at the same time.
    A group of one or more changes to stored objects is known as a **transaction**,
    and when the objects are written, the transaction is said to have been **committed.**
  prefs: []
  type: TYPE_NORMAL
- en: A transaction can also be aborted, so that modifications to objects made since
    the last commit are forgotten. It's also possible to roll back an already committed
    transaction, leaving the database in a previous state.
  prefs: []
  type: TYPE_NORMAL
- en: ACID properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you have worked with relational databases, all this talk about transactions
    should be familiar to you. You might also know that transactional systems need
    to make sure that the database never gets into an inconsistent state, which they
    do by supporting four properties, known by the acronym **ACID:**
  prefs: []
  type: TYPE_NORMAL
- en: '**Atomicity:**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Either all of the modifications grouped in a transaction will be written to
    the database or, if something makes this impossible, the whole transaction will
    be aborted. This ensures that in the event of a write error or a hardware glitch,
    the database will remain in the previous state and avoid inconsistencies.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Consistency:**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For write transactions, this means that no transaction will be allowed if it
    would leave the database in an inconsistent state. For read transactions, this
    means that a read operation will see the database in the consistent state it was
    at the beginning of the transaction, regardless of other transactions taking place
    at that time.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Isolation:**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When changes are made to the database by two different programs, they will not
    be able to see each other's transactions until they commit their own.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Durability:**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This simply means that the data will be safely stored once the transaction is
    committed. A software or hardware crash after that will not cause any information
    to be lost.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Other ZODB features
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition to being ACID compliant, the ZODB provides several other features
    that make it a really good option for industrial-strength data management.
  prefs: []
  type: TYPE_NORMAL
- en: '**In memory caching:**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Every time an object is read from the database, it is kept on a cache in memory,
    so that subsequent accesses to this object consume less resources and time. The
    ZODB manages the cache transparently, and automatically removes the objects that
    have not been accessed for a long time. The size of the cache can be configured,
    so that machines with more memory can take better advantage of it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Undo:**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ZODB provides a very simple mechanism for rolling back any committed transaction,
    which is possible because it keeps track of the database state before and after
    every transaction. This makes it possible to undo the changes in a transaction,
    even if more transactions have been committed after it. Of course, if the objects
    involved in this transaction that we need to undo have changed in later transactions,
    it will not be possible to undo it because of consistency requirements.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**History:**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As every transaction is kept in the database, it is possible to see an object
    as it was in previous transactions, and compare it with its current state. This
    allows a developer to quickly implement simple versioning functionality.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Save points:**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As changes made during a single transaction are kept in memory until the transaction
    is committed, memory usage can skyrocket during a transaction where lots of objects
    are modified at the same time (say, a for loop that changes a property on 100,000
    objects). Save points allow us to commit part of a transaction before it has finished,
    so that changes are written to the database and the memory that the changes had
    occupied is released. These changes in the save points are not really committed
    until the whole transaction is completed, so that if it is aborted, any save points
    will be rolled back as well.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Blobs (Binary large objects):**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Binary large objects, such as images or office documents, do not need all of
    the versioning facilities that the ZODB offers. In fact, if they were handled
    as regular object properties, blobs would make the size of a database increase
    greatly, and generally slow things down. That's why the ZODB uses a special storage
    for blobs, which makes it feasible to easily handle large files up to a few hundred
    megabytes without performance problems.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Packing:**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we have seen, the ZODB keeps all versions of the objects stored in it. This
    means that the database grows with every object modification and can reach really
    large sizes, which may slow it down. The ZODB allows us to remove old revisions
    of stored objects via a procedure known as packing the database. The packing routine
    is flexible enough to allow only objects older than a specified number of days
    to be removed, keeping the newer revisions.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Pluggable storages:**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By default, the ZODB stores the database in a single file. The program that
    manages this is called a file storage. However, the ZODB is built in such a way
    that other storages can be plugged in without needing to modify it. This feature
    can be used to store ZODB data in other media or formats, as we'll see later in
    more detail.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ZEO
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**ZEO** stands for **Zope Enterprise Objects** and is a network storage for
    the ZODB. By using ZEO, any number of Grok instances can connect to the same ZODB.
    ZEO can be used to provide scalability, because the load can be distributed between
    several ZEO clients instead of only one.'
  prefs: []
  type: TYPE_NORMAL
- en: We'll learn more about ZEO in Chapter 14.
  prefs: []
  type: TYPE_NORMAL
- en: Using the ZODB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To store objects, the ZODB makes use of a root object, which is basically a
    container for other objects. Contained objects, in turn, can also act as containers,
    which means that the ZODB structure can be expressed using a tree.
  prefs: []
  type: TYPE_NORMAL
- en: The rules of persistence
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Not all object modifications can be automatically detected and transparently
    written to the database. As we saw earlier in this book, there are some rules
    about how to make an object persistent and what conditions require additional
    work:'
  prefs: []
  type: TYPE_NORMAL
- en: Inherit from `persistent.Persistent` (a class defined in the ZODB code) or one
    of its subclasses.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Class instances have to be related to each other in a hierarchical structure.
    The ZODB has a root object, and this object contains other objects, which can
    in turn contain further objects, thereby forming a tree.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When modifying mutable attributes of persistent objects that are not persistent
    themselves, the persistence machinery has to be notified, by setting the special
    `_p_changed` attribute of the instance to `True`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Traversal
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To get to a particular object inside the database, the ZODB always starts with
    the root object and recursively goes inside any containers until it finds the
    object. This is called **traversal**, because every containing object in the visited
    object's path has to be touched to get to it.
  prefs: []
  type: TYPE_NORMAL
- en: This means that a unique object can be identified by its path within the database.
    By design, URL paths can be mapped pretty well to a ZODB structure, so when we
    have a URL in Grok, every element of its path usually represents an object that
    has to be traversed to get to a specific object. The exception is sometimes the
    last element of the path, which can also represent a view.
  prefs: []
  type: TYPE_NORMAL
- en: How Grok uses the ZODB
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We haven't had to do anything directly with the ZODB so far, because Grok has
    already set up everything to take advantage of the ZODB's transparency. Grok's
    models and containers already inherit from `persistence.Persistent`, so modifications
    to any of our model objects are automatically saved to the database.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, Grok's URL-resolving mechanism uses traversal to get to the persisted
    objects, so we don't have to keep track of where we put what, in order for Grok
    to get us the correct object.
  prefs: []
  type: TYPE_NORMAL
- en: However, Grok can't help us avoid the ZODB requirement to signal the persistence
    machinery about changes to mutable objects. Remember, whenever changes are made
    to mutable attributes, the application needs to inform the ZODB that there has
    been a change. This is done by setting the special `_p_changed` attribute of the
    instance to `True:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'If you use regular Python mutable objects, such as lists and dictionaries,
    you have to remember this rule, which is not a lot to ask for, but still can be
    easy to forget. For precisely this reason, the ZODB package includes a couple
    of replacements for these built-in Python types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: These two types are exact equivalents of the built-in Python types, except they
    take care of setting `p_changed` when needed. Consider using them if you need
    a list or a dictionary in your applications.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Blob support to our application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many applications need to allow external files to be uploaded and stored, be
    it office documents, images, multimedia, or other kinds of files. As processing
    these files by using the ZODB can prove costly in terms of resources and bandwidth,
    it's better that we show how to take advantage of the ZODB Blob support now.
  prefs: []
  type: TYPE_NORMAL
- en: Adding messages to projects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Right now, the projects in our application have only tasks. This was enough
    when we had a single-user application, but now that multiple users can log in
    and have different roles, a mechanism for communicating with other users about
    the state of the tasks would come in handy.
  prefs: []
  type: TYPE_NORMAL
- en: Let's add a **messages** tab to the project view, where anyone can post a message.
    A message will have a title, the message text, and optionally will allow users
    to upload a file.
  prefs: []
  type: TYPE_NORMAL
- en: The megrok.form package
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We could add some code to enable a Grok form field to use blobs, but sometimes,
    it's a lot easier to find a package that already does what we need, and then integrate
    that into our project instead.
  prefs: []
  type: TYPE_NORMAL
- en: As Grok uses the Zope Toolkit, there are hundreds of packages available to choose
    from. There are also many packages that have been created specifically for Grok.
    Just go to the Python Package Index (PyPI) page and you will see that there are
    a lot of packages ready for downloading.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, there is a package that does exactly what we need, which is to
    make the use of blobs easy. This package is called `megrok.form`, and we are going
    to integrate it into our project. It is available at [http://pypi.python.org/pypi/megrok.form](http://pypi.python.org/pypi/megrok.form).
  prefs: []
  type: TYPE_NORMAL
- en: Adding an external package to our project
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Integrating a package from the PyPI is fairly easy with Grok. The first step
    is to add it to the project install requirements, which are specified inside the
    `setup.py` file at the root of our project. Find this file, and change the `install_requires`
    assignment to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Next, run `bin/buildout` from the command line. The `megrok.form` package and
    its dependencies will be downloaded and installed into the project. In this case,
    we added `megrok.form`, but of course, we could pick any other package from PyPI
    and add it to our project in the same way.
  prefs: []
  type: TYPE_NORMAL
- en: How blob support is configured in Grok
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'By default, Grok is preconfigured to use the blob storage, so it''s simple
    to take advantage of it. You can see how this configuration is done if you take
    a look at the `zope.conf` file in the `parts/etc/` directory of our project. The
    relevant section looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The messaging class and schema
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have the supporting packages and configuration that we need, let's
    get the **messages** tab going. We'll go through the code quickly, as most of
    the concepts have been used earlier in our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we add a `Message` class that will store the messages and their attachments.
    The context of this class will be the `Project` class, as we want messages to
    be stored by project. Of course, we start by defining the interface for the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We keep it simple, by adding only `subject, message`, and `attachment` fields.
    Note that the field where we''ll store the attachment is declared as a `BlobFile`.
    For this declaration to work, we of course need to include the following import
    at the top of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, find the actual class definition, where we just implement the interface,
    and add a `searchableText` method, to allow messages to appear in search results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We need a form for creating the messages and uploading the attachment, so that's
    our next step. This will create an `add_message` form that will require the `todo.changeitems`
    permission to be used. The fields come from the interface defined earlier, and
    we use the template for custom edit forms that we created in Chapter 5.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The key part of the form is the add action, where the message is created and
    its properties are set with the values from the form. Notice that both messages
    and lists use the same `next_id` counter for their name, so the `content_type`
    class attribute becomes very important. This will be used to get only messages
    or only lists, depending upon the view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see this form in action in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The messaging class and schema](img/7481_09_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The message viewlet
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next, we create the view and viewlet for showing the messages. The view performs
    a catalog search by using the content type. Of course, we first need to add to
    our `ProjectIndexes` class (from Chapter 6), so that it gets indexed, as now there
    are two different kinds of objects that can be stored inside a project (messages
    and lists). We also have to change the catalog search of `todo` lists to use this
    new index. Here is the view code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'For the viewlet, we simply define a template and set the view to the one that
    we just created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The message list template
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The project messages viewlet uses a new template named `projectmessages_viewlet`.
    We will show a couple of links at the top that will function more or less like
    tabs, for switching between list and messages views:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, we show the messages and their contents by using a "repeat" structure.
    The most important part of the template for the purposes of this chapter is the
    link for downloading the attachment, which uses the `view.url` method to point
    to the download view. Note that a message may not include an attachment, which
    is why the paragraph with the link has a condition for either showing it or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Some CSS styles were added to the project as well. These are not shown here.
    Please check the source code for this book to see what they are.
  prefs: []
  type: TYPE_NORMAL
- en: Downloading an attachment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The last step is to add a view for downloading an attachment. We do not need
    to show a template here; we have to return the file. This is how it is done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: First, we get the filename and the file data from the attachment in question,
    in the `update` method. Then, in the `render` method, we set the `Content-Disposition
    response` header to `attachment` and pass the filename to it, so that the browser
    will know which file to download by using its original name, directly. Finally,
    we return the file data.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the Blob support
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We are now ready to run the application. The following screenshot shows the
    way it should look. Try adding a few messages and files, and then take a look
    at the contents of the `blob` directory that you specified in the `zope.conf`
    file. You should see a `blobs` directory containing one directory for each file
    that you uploaded.
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing the Blob support](img/7481_09_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Taking advantage of transactions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have been saying from the beginning of this chapter that the ZODB is transactional,
    but so far we haven't seen the benefits that we get from this. Possibly the most
    important benefit is the ability to roll back, or undo, a transaction.
  prefs: []
  type: TYPE_NORMAL
- en: Using zope.app.undo
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As Grok handles the transaction commits for us, we haven''t had the chance
    to show it, but we''ll now see how to undo and even redo transactions. The easiest
    way to show this is to use the `zope.app.undo` package available in the PyPI.
    We will add it to the project in the same way that we inserted `megrok.form`,
    earlier in this chapter. Edit the `setup.py` file at the root of the project and
    add the following code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Now rerun `bin/buildout` to let Grok download and install the package. No other
    action is needed to enable it just restart the application.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the undo functionality
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create an instance of the todo application, and add a project. Then add a list
    inside that project, with the title `test undo`. Now delete the list that you
    have just created. You will see an empty project once again.
  prefs: []
  type: TYPE_NORMAL
- en: 'To undo the transaction, we''ll have to use the Grok management interface,
    which we used earlier, when learning about the catalog, in Chapter 6\. Point your
    browser to the following URL: [http://localhost:8080/todo/@@undoMore.html](http://localhost:8080/todo/@@undoMore.html).'
  prefs: []
  type: TYPE_NORMAL
- en: You should see a list of transactions, similar to the one in the next screenshot.
    The screen shows the last ten transactions for the todo application instance visited.
    The transaction at the top is the last one committed. To revert it, simply select
    the checkbox to its left, and then click on the **Undo** button at the bottom
    of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Now go back to your project. The list that you deleted is magically back there.
    If you go back to the list, you'll notice that the undo operation itself is now
    listed as a transaction, so you can "redo" the old transaction, by undoing the
    transaction that is now at the top.
  prefs: []
  type: TYPE_NORMAL
- en: '"Undo" is a powerful feature, and the one that can make you look like a hero
    in the eyes of your application users. It''s also possible to undo multiple transactions
    at the same time. However, a transaction can only be undone if the objects on
    which it operated have not been modified by a later transaction. This means that
    undoing a mistake is something that has to be done quickly, before new transactions
    can complicate things.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing the undo functionality](img/7481_09_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: ZODB maintenance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As with any other database system, the ZODB needs some maintenance, from time
    to time. The main thing that can happen is that the database size will grow to
    occupy a large amount of disk space, causing some tasks to become slower.
  prefs: []
  type: TYPE_NORMAL
- en: File storage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we mentioned before, the ZODB keeps track of all of the versions of a stored
    object, which makes ZODB grow every time an object changes. Packing allows the
    ZODB to get rid of older versions of objects, thus reducing the database size.
  prefs: []
  type: TYPE_NORMAL
- en: The database is usually contained in a file named `Data.fs`, which is located
    under `parts/data` in our `project` directory.
  prefs: []
  type: TYPE_NORMAL
- en: Packing is a process that can take some time, and thus it runs on a separate
    thread. A backup copy of the database file is created before the packing starts,
    in case something goes wrong, so be aware that you will need to have at least
    as much free disk space as the current size of the ZODB, in order to be able to
    pack it.
  prefs: []
  type: TYPE_NORMAL
- en: In Grok, the easiest way to pack the database is to go to the administration
    interface and click on the **Server Control** link. This will take you to a control
    panel where the option to pack the current database is shown (see the next screenshot).
    To pack the database, simply select the number of days beyond which object revisions
    should be removed. The packing process will be started, and when it's finished,
    there will be a message at the top of the control panel notifying you of this.
  prefs: []
  type: TYPE_NORMAL
- en: '![File storage](img/7481_09_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Automatic packing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In most cases, packing will be a good thing to do frequently, unless for some
    reason you absolutely need to keep track of every revision of every object, ever.
    Packing the database once a week, for example, could be a good way to keep the
    database size in check and also to make tasks such as backing up, easier and faster.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, manually packing the database every time could be a burden to an
    administrator, and is easily forgotten, so an automatic way of performing the
    packing comes in handy.
  prefs: []
  type: TYPE_NORMAL
- en: Packing is an expensive operation, and doing it from outside Grok requires a
    separate database connection, which is why using ZEO is a good idea, even if our
    scalability demands do not call for it. As ZEO allows multiple connections, packing
    can be done from another ZEO client, without needing to stop the regular service.
  prefs: []
  type: TYPE_NORMAL
- en: 'This task is so necessary that the Grok installation already makes a script
    available to pack the ZODB by using ZEO. It''s called `zeopack`, and can be found
    under the `bin` directory of the main Grok installation. To use it, simply make
    sure that the ZEO server is running, and then call the script with the host and
    port of the site:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This script call could be added to a UNIX cron script to perform the task weekly,
    or as frequently as needed.
  prefs: []
  type: TYPE_NORMAL
- en: Backing up
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As with all important data handling services, backups are greatly encouraged
    when using the ZODB. Exactly how often to make backups can vary depending on the
    type of application, but it should be done regularly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Grok installation includes a script, called `repozo`, to facilitate backups.
    This script allows incremental or full backups to be taken, and can be used both
    for backing up and restoring a `Data.fs` file. To backup our database, we can
    first create a directory, called `backups` inside our Grok main directory and
    then use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `-B` option means to perform a backup action. The `-f` options gives the
    path to the `Data.fs` file that we want to backup. The first time, `repozo` will
    make a full backup to the `backups` directory (specified by the `-r` option).
    Further calls will result in incremental backups unless the database has been
    packed after the last backup.
  prefs: []
  type: TYPE_NORMAL
- en: 'To recover a `Data.fs` file from a `repozo` backup, we use the `-R` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This command will recover the latest backup and output the recovered file to
    `RecoveredData.fs` (specified by the `-o` option). It's also possible to recover
    a backup from a specified date, by using the `-D` option with a date in the format
    "yyyy-mm-dd".
  prefs: []
  type: TYPE_NORMAL
- en: Using the ZODB without Grok
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The ZODB is a very powerful package, and there is no reason why we couldn't
    use it on regular applications outside Grok, too. In fact, many simple applications
    that are usually developed by using a relational database (mainly because that's
    what most developers are used to) can be even simpler if the ZODB is used.
  prefs: []
  type: TYPE_NORMAL
- en: To show how easy it is to work with the ZODB from Python, we'll show a simple
    example. All that's needed to follow along is to have Python installed, and to
    use `easy_install` to get the ZODB3 egg, or download the ZODB package from [http://pypi.python.org/pypi/ZODB3](http://pypi.python.org/pypi/ZODB3).
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file named `zodb_demo.py`. First, let''s create a small class that
    will take care of opening and closing the connection to a `FileStorage`. Add the
    following code at the start of your `zodb_demo.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: First, we make a few imports. `FileStorage` is needed to define the file where
    the database will be stored, `DB` is the actual ZODB library, and `transaction`
    is used for committing changes to the database.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a class named `ZODBHandler` that will take a file path and initialize
    a file storage for our ZODB. If the file passed in the path exists, it will be
    used as the database; if it does not exist, it will be created. Either way, we
    don't have to worry about this, as `FileStorage` takes care of it for us. With
    this, we have a storage that we can pass to the `DB` class on the following line.
    After that, we can open a connection and once this is done, we get the root object
    of the database and store it in `dbroot`. From there, we can work with the database,
    as we will see shortly.
  prefs: []
  type: TYPE_NORMAL
- en: The other thing that our ZODB handler does, is close the connection and storage
    when we have finished using them, by means of a `close` method that we can call
    when we want.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now initialize a database, and start writing data to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We pass our handler a path that will create a file named `Data.fs` in the current
    directory. Next, we get the root object of the database that is stored there.
    We then add several objects, just to show that any Python object that is pickable
    can be stored in the database. Finally, we need to commit the transaction, in
    order to actually save the changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'To fetch an object from the database, we simply need to refer to it by its
    key, much like a dictionary works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Deleting an object is also quite easy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, most applications will not use built-in Python objects, but will
    create their own classes that subclass from `persistent.Persistent`. Insert the
    following class definition before the `if` statement, above:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now store projects transparently in our database. Append the following
    lines at the end of the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This is a very simple example, but hopefully you can see the potential for creating
    interesting ZODB-backed applications. No SQL is needed, just plain Python objects.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned more about the ZODB, and learned how to take
    advantage of its features, such as blob handling. We also learned a bit about
    ZODB maintenance and the need to pack the database frequently. Finally, we tried
    our hand at using the ZODB outside Grok, as a regular Python library.
  prefs: []
  type: TYPE_NORMAL
