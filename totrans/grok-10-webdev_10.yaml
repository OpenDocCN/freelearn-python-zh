- en: Chapter 9. Grok and the ZODB
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第九章. Grok和ZODB
- en: As we stressed right from the first chapter, one of the most important pieces
    of Grok is the ZODB. The capability to store objects transparently has allowed
    us to create a complete application without having to think about persisting its
    data.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在第一章就强调的，Grok最重要的组成部分之一是ZODB。能够透明地存储对象的能力使我们能够创建一个完整的应用程序，而无需考虑其数据的持久化。
- en: 'Although Grok takes care of what little ZODB interaction our application needs
    behind the scenes, there are a few more things that the ZODB can do, and we will
    review them in this chapter. In particular, we will see:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Grok在幕后处理我们应用程序需要的ZODB交互，但ZODB还能做更多的事情，我们将在本章中回顾它们。特别是，我们将看到：
- en: How the ZODB works
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ZODB是如何工作的
- en: What ZODB storage is
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ZODB存储是什么
- en: How to add file attachments to our application by using Blob support
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何通过使用Blob支持将文件附件添加到我们的应用程序中
- en: How to pack the database and why this is recommended
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何打包数据库以及为什么推荐这样做
- en: How to use the ZODB outside Grok
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在Grok之外使用ZODB
- en: How the ZODB works
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ZODB是如何工作的
- en: Before we get into the details of how to use other ZODB functionality, let's
    talk a bit more about how ZODB works.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入探讨如何使用其他ZODB功能之前，让我们再谈谈ZODB是如何工作的。
- en: Simply put, the ZODB is a persistence system for Python objects. Its objective
    is to make persistence as transparent as possible, so that any changes to objects
    can automatically be saved to disk and read again when they are needed.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，ZODB是一个Python对象的持久化系统。其目标是使持久化尽可能透明，以便任何对象更改都可以自动保存到磁盘并在需要时再次读取。
- en: ZODB is an object database, which means that instead of partitioning objects
    into one or more tables according to a data schema, the objects themselves are
    written to the database in their current state. In a relational database system,
    once a row of data is read from the database, the program still needs to reassemble
    the columns of information to get a real object instance. In an object database
    system, an object instance is immediately there when you fetch it from the database.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: ZODB是一个对象数据库，这意味着不是根据数据模式将对象分区到一个或多个表中，而是将对象以当前状态写入数据库。在关系型数据库系统中，一旦从数据库中读取了一行数据，程序仍然需要重新组装信息列以获取一个真正的对象实例。在对象数据库系统中，当你从数据库中检索对象时，对象实例立即存在。
- en: Transparency
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 透明性
- en: 'Because it''s possible to store objects directly into the database as they
    are, very little effort is needed to make an object ZODB aware. In other words,
    objects are stored transparently. Due to this, although there are some cases where
    a little more work is needed, objects can generally be persisted in the database
    simply by meeting one simple requirement: to subclass from the `persistent.Persistent`
    class provided by the ZODB.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 由于可以直接将对象以当前状态直接存储到数据库中，因此使对象成为ZODB意识所需的努力非常小。换句话说，对象是以透明的方式存储的。因此，尽管在某些情况下可能需要做更多的工作，但通常只需满足一个简单的要求：从ZODB提供的`persistent.Persistent`类派生子类，就可以在数据库中持久化对象。
- en: When instances of persistent objects are modified, they are marked by the ZODB
    mechanisms, and the changes can be written to the database, if the user requests
    this. Of course, more than one modification could be requested at the same time.
    A group of one or more changes to stored objects is known as a **transaction**,
    and when the objects are written, the transaction is said to have been **committed.**
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当持久化对象的实例被修改时，它们会被ZODB机制标记，如果用户请求这样做，这些更改可以写入数据库。当然，可能同时会有多个修改请求。一组对存储对象的单个或多个更改被称为**事务**，当对象被写入时，我们说事务已经**提交**。
- en: A transaction can also be aborted, so that modifications to objects made since
    the last commit are forgotten. It's also possible to roll back an already committed
    transaction, leaving the database in a previous state.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 事务也可以被中止，这样自上次提交以来对对象的修改就会被遗忘。还可以回滚已提交的事务，使数据库回到之前的状态。
- en: ACID properties
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ACID属性
- en: If you have worked with relational databases, all this talk about transactions
    should be familiar to you. You might also know that transactional systems need
    to make sure that the database never gets into an inconsistent state, which they
    do by supporting four properties, known by the acronym **ACID:**
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经使用过关系型数据库，那么关于事务的所有讨论都应该很熟悉。你可能也知道，事务性系统需要确保数据库永远不会进入不一致的状态，它们通过支持四个属性来实现这一点，这些属性以首字母缩写词**ACID**闻名：
- en: '**Atomicity:**'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**原子性：**'
- en: Either all of the modifications grouped in a transaction will be written to
    the database or, if something makes this impossible, the whole transaction will
    be aborted. This ensures that in the event of a write error or a hardware glitch,
    the database will remain in the previous state and avoid inconsistencies.
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要么将事务中分组的所有修改都写入数据库，要么如果某些事情使这成为不可能，则整个事务将被中止。这确保了在发生写错误或硬件故障的情况下，数据库将保持之前的状态，避免不一致性。
- en: '**Consistency:**'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一致性：**'
- en: For write transactions, this means that no transaction will be allowed if it
    would leave the database in an inconsistent state. For read transactions, this
    means that a read operation will see the database in the consistent state it was
    at the beginning of the transaction, regardless of other transactions taking place
    at that time.
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于写事务，这意味着如果事务会导致数据库处于不一致状态，则不允许任何事务。对于读事务，这意味着读操作将看到事务开始时的数据库一致状态，而不管当时是否正在进行其他事务。
- en: '**Isolation:**'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**隔离：**'
- en: When changes are made to the database by two different programs, they will not
    be able to see each other's transactions until they commit their own.
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当两个不同的程序对数据库进行更改时，它们将无法看到彼此的事务，直到它们提交自己的事务。
- en: '**Durability:**'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**耐用性：**'
- en: This simply means that the data will be safely stored once the transaction is
    committed. A software or hardware crash after that will not cause any information
    to be lost.
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这仅仅意味着一旦事务提交，数据就会被安全存储。之后的软件或硬件崩溃不会导致任何信息丢失。
- en: Other ZODB features
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他ZODB功能
- en: In addition to being ACID compliant, the ZODB provides several other features
    that make it a really good option for industrial-strength data management.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 除了符合ACID标准外，ZODB还提供了其他一些功能，使其成为工业强度数据管理的真正好选择。
- en: '**In memory caching:**'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存缓存：**'
- en: Every time an object is read from the database, it is kept on a cache in memory,
    so that subsequent accesses to this object consume less resources and time. The
    ZODB manages the cache transparently, and automatically removes the objects that
    have not been accessed for a long time. The size of the cache can be configured,
    so that machines with more memory can take better advantage of it.
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 每次从数据库读取对象时，它都会保存在内存中的缓存中，这样后续访问该对象时就会消耗更少的资源和时间。ZODB透明地管理缓存，并自动删除长时间未访问的对象。缓存的大小可以配置，以便具有更多内存的机器可以更好地利用它。
- en: '**Undo:**'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**撤销：**'
- en: The ZODB provides a very simple mechanism for rolling back any committed transaction,
    which is possible because it keeps track of the database state before and after
    every transaction. This makes it possible to undo the changes in a transaction,
    even if more transactions have been committed after it. Of course, if the objects
    involved in this transaction that we need to undo have changed in later transactions,
    it will not be possible to undo it because of consistency requirements.
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ZODB提供了一个非常简单的机制来回滚任何已提交的事务，这是因为它跟踪每个事务之前和之后的数据库状态。这使得即使在之后提交了更多事务的情况下，也可以撤销事务中的更改。当然，如果涉及此事务且需要撤销的对象在后续事务中已更改，则由于一致性要求，将无法撤销。
- en: '**History:**'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**历史：**'
- en: As every transaction is kept in the database, it is possible to see an object
    as it was in previous transactions, and compare it with its current state. This
    allows a developer to quickly implement simple versioning functionality.
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于每个事务都保存在数据库中，因此可以查看对象在之前事务中的状态，并将其与当前状态进行比较。这允许开发者快速实现简单的版本控制功能。
- en: '**Save points:**'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**保存点：**'
- en: As changes made during a single transaction are kept in memory until the transaction
    is committed, memory usage can skyrocket during a transaction where lots of objects
    are modified at the same time (say, a for loop that changes a property on 100,000
    objects). Save points allow us to commit part of a transaction before it has finished,
    so that changes are written to the database and the memory that the changes had
    occupied is released. These changes in the save points are not really committed
    until the whole transaction is completed, so that if it is aborted, any save points
    will be rolled back as well.
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于在单个事务中进行的更改在事务提交之前都保存在内存中，因此在同时修改大量对象（例如，一个修改100,000个对象属性的自循环）的事务中，内存使用量可能会急剧增加。保存点允许我们在事务完成之前提交事务的一部分，这样更改就会被写入数据库，并且释放更改所占用的内存。这些保存点中的更改实际上只有在整个事务完成时才会真正提交，因此如果事务被中止，任何保存点也将回滚。
- en: '**Blobs (Binary large objects):**'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**二进制大对象（Blob）：**'
- en: Binary large objects, such as images or office documents, do not need all of
    the versioning facilities that the ZODB offers. In fact, if they were handled
    as regular object properties, blobs would make the size of a database increase
    greatly, and generally slow things down. That's why the ZODB uses a special storage
    for blobs, which makes it feasible to easily handle large files up to a few hundred
    megabytes without performance problems.
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 二进制大对象，如图像或办公文档，不需要 ZODB 提供的所有版本控制功能。实际上，如果它们被当作常规对象属性处理，blob 会大大增加数据库的大小，并通常减慢速度。这就是为什么
    ZODB 使用特殊的 blob 存储器，这使得处理高达几百兆字节的大文件而不会出现性能问题成为可能。
- en: '**Packing:**'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**打包：**'
- en: As we have seen, the ZODB keeps all versions of the objects stored in it. This
    means that the database grows with every object modification and can reach really
    large sizes, which may slow it down. The ZODB allows us to remove old revisions
    of stored objects via a procedure known as packing the database. The packing routine
    is flexible enough to allow only objects older than a specified number of days
    to be removed, keeping the newer revisions.
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 正如我们所见，ZODB 保留了存储在其中的所有对象的版本。这意味着数据库随着每个对象的修改而增长，可以达到非常大的大小，这可能会减慢速度。ZODB 允许我们通过称为打包数据库的程序来删除存储对象的旧版本。打包例程足够灵活，可以只删除超过指定天数的老对象，保留较新的版本。
- en: '**Pluggable storages:**'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可插拔存储：**'
- en: By default, the ZODB stores the database in a single file. The program that
    manages this is called a file storage. However, the ZODB is built in such a way
    that other storages can be plugged in without needing to modify it. This feature
    can be used to store ZODB data in other media or formats, as we'll see later in
    more detail.
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 默认情况下，ZODB 将数据库存储在一个单独的文件中。管理此文件的程序称为文件存储。然而，ZODB 是以这种方式构建的，可以无需修改即可插入其他存储。这个特性可以用来在其他媒体或格式中存储
    ZODB 数据，我们将在后面更详细地看到。
- en: ZEO
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ZEO
- en: '**ZEO** stands for **Zope Enterprise Objects** and is a network storage for
    the ZODB. By using ZEO, any number of Grok instances can connect to the same ZODB.
    ZEO can be used to provide scalability, because the load can be distributed between
    several ZEO clients instead of only one.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**ZEO** 代表 **Zope Enterprise Objects**，是 ZODB 的网络存储。通过使用 ZEO，任何数量的 Grok 实例都可以连接到同一个
    ZODB。ZEO 可以用来提供可伸缩性，因为负载可以在多个 ZEO 客户端之间分配，而不仅仅是单个客户端。'
- en: We'll learn more about ZEO in Chapter 14.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第 14 章中了解更多关于 ZEO 的内容。
- en: Using the ZODB
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 ZODB
- en: To store objects, the ZODB makes use of a root object, which is basically a
    container for other objects. Contained objects, in turn, can also act as containers,
    which means that the ZODB structure can be expressed using a tree.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 要存储对象，ZODB 使用一个根对象，这基本上是其他对象的容器。包含的对象反过来也可以作为容器，这意味着 ZODB 的结构可以用树来表示。
- en: The rules of persistence
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 持久化规则
- en: 'Not all object modifications can be automatically detected and transparently
    written to the database. As we saw earlier in this book, there are some rules
    about how to make an object persistent and what conditions require additional
    work:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有对象修改都可以自动检测并透明地写入数据库。正如我们在本书前面所看到的，有一些规则关于如何使对象持久化以及需要额外工作的条件：
- en: Inherit from `persistent.Persistent` (a class defined in the ZODB code) or one
    of its subclasses.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 `persistent.Persistent`（ZODB 代码中定义的一个类）或其子类继承。
- en: Class instances have to be related to each other in a hierarchical structure.
    The ZODB has a root object, and this object contains other objects, which can
    in turn contain further objects, thereby forming a tree.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类实例必须以层次结构相互关联。ZODB 有一个根对象，该对象包含其他对象，这些对象又可以包含进一步的对象，从而形成一个树。
- en: When modifying mutable attributes of persistent objects that are not persistent
    themselves, the persistence machinery has to be notified, by setting the special
    `_p_changed` attribute of the instance to `True`.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当修改非持久化自身的持久化对象的可变属性时，持久化机制必须通过将实例的特殊 `_p_changed` 属性设置为 `True` 来通知。
- en: Traversal
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 遍历
- en: To get to a particular object inside the database, the ZODB always starts with
    the root object and recursively goes inside any containers until it finds the
    object. This is called **traversal**, because every containing object in the visited
    object's path has to be touched to get to it.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问数据库中的特定对象，ZODB 总是从根对象开始，递归地进入任何容器，直到找到该对象。这被称为 **遍历**，因为访问的对象路径上的每个包含对象都必须被触及才能到达它。
- en: This means that a unique object can be identified by its path within the database.
    By design, URL paths can be mapped pretty well to a ZODB structure, so when we
    have a URL in Grok, every element of its path usually represents an object that
    has to be traversed to get to a specific object. The exception is sometimes the
    last element of the path, which can also represent a view.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着可以通过其在数据库中的路径来识别唯一的对象。按照设计，URL路径可以很好地映射到ZODB结构，因此当我们有Grok中的URL时，其路径的每个元素通常代表一个必须遍历以到达特定对象的对象。例外情况有时是路径的最后一个元素，它也可以代表一个视图。
- en: How Grok uses the ZODB
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Grok如何使用ZODB
- en: We haven't had to do anything directly with the ZODB so far, because Grok has
    already set up everything to take advantage of the ZODB's transparency. Grok's
    models and containers already inherit from `persistence.Persistent`, so modifications
    to any of our model objects are automatically saved to the database.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们还没有直接与ZODB打交道，因为Grok已经设置好了一切，以便利用ZODB的透明性。Grok的模型和容器已经继承自`persistence.Persistent`，因此对我们模型对象的任何修改都会自动保存到数据库中。
- en: In addition, Grok's URL-resolving mechanism uses traversal to get to the persisted
    objects, so we don't have to keep track of where we put what, in order for Grok
    to get us the correct object.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Grok的URL解析机制使用遍历来获取持久化对象，因此我们不需要跟踪我们放置了什么，以便Grok能为我们提供正确的对象。
- en: However, Grok can't help us avoid the ZODB requirement to signal the persistence
    machinery about changes to mutable objects. Remember, whenever changes are made
    to mutable attributes, the application needs to inform the ZODB that there has
    been a change. This is done by setting the special `_p_changed` attribute of the
    instance to `True:`
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Grok无法帮助我们避免ZODB对可变对象更改进行持久化机制信号的要求。记住，每当对可变属性进行更改时，应用程序需要通知ZODB已发生更改。这是通过将实例的特殊`_p_changed`属性设置为`True`来完成的：
- en: '[PRE0]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If you use regular Python mutable objects, such as lists and dictionaries,
    you have to remember this rule, which is not a lot to ask for, but still can be
    easy to forget. For precisely this reason, the ZODB package includes a couple
    of replacements for these built-in Python types:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用常规Python可变对象，如列表和字典，您必须记住这个规则，这不是很多要求，但仍可能容易忘记。正是出于这个原因，ZODB包包括这些内置Python类型的几个替代品：
- en: '[PRE1]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: These two types are exact equivalents of the built-in Python types, except they
    take care of setting `p_changed` when needed. Consider using them if you need
    a list or a dictionary in your applications.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种类型与内置Python类型完全等价，除了它们在需要时负责设置`p_changed`。如果您在应用程序中需要列表或字典，请考虑使用它们。
- en: Adding Blob support to our application
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向我们的应用程序添加Blob支持
- en: Many applications need to allow external files to be uploaded and stored, be
    it office documents, images, multimedia, or other kinds of files. As processing
    these files by using the ZODB can prove costly in terms of resources and bandwidth,
    it's better that we show how to take advantage of the ZODB Blob support now.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 许多应用程序需要允许上传和存储外部文件，无论是办公文档、图像、多媒体还是其他类型的文件。通过使用ZODB处理这些文件可能会在资源和带宽方面造成高昂的成本，因此现在展示如何利用ZODB
    Blob支持会更好。
- en: Adding messages to projects
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向项目中添加消息
- en: Right now, the projects in our application have only tasks. This was enough
    when we had a single-user application, but now that multiple users can log in
    and have different roles, a mechanism for communicating with other users about
    the state of the tasks would come in handy.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们应用程序中的项目只有任务。当我们的应用程序是单用户应用时，这已经足够了，但现在多个用户可以登录并具有不同的角色，一个用于与其他用户沟通任务状态的机制将很有用。
- en: Let's add a **messages** tab to the project view, where anyone can post a message.
    A message will have a title, the message text, and optionally will allow users
    to upload a file.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在项目视图中添加一个**消息**标签，任何人都可以发布消息。消息将包含标题、消息文本，并且可选地允许用户上传文件。
- en: The megrok.form package
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: megrok.form包
- en: We could add some code to enable a Grok form field to use blobs, but sometimes,
    it's a lot easier to find a package that already does what we need, and then integrate
    that into our project instead.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以添加一些代码来使Grok表单字段能够使用blob，但有时，找到已经做了我们需要的包并集成到我们的项目中要容易得多。
- en: As Grok uses the Zope Toolkit, there are hundreds of packages available to choose
    from. There are also many packages that have been created specifically for Grok.
    Just go to the Python Package Index (PyPI) page and you will see that there are
    a lot of packages ready for downloading.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Grok使用Zope工具包，有数百个包可供选择。还有许多专门为Grok创建的包。只需访问Python包索引（PyPI）页面，你就会看到有很多包可供下载。
- en: In this case, there is a package that does exactly what we need, which is to
    make the use of blobs easy. This package is called `megrok.form`, and we are going
    to integrate it into our project. It is available at [http://pypi.python.org/pypi/megrok.form](http://pypi.python.org/pypi/megrok.form).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，有一个包正好符合我们的需求，那就是使blob的使用变得简单。这个包叫做`megrok.form`，我们将将其集成到我们的项目中。它可以在[http://pypi.python.org/pypi/megrok.form](http://pypi.python.org/pypi/megrok.form)找到。
- en: Adding an external package to our project
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将外部包添加到我们的项目中
- en: 'Integrating a package from the PyPI is fairly easy with Grok. The first step
    is to add it to the project install requirements, which are specified inside the
    `setup.py` file at the root of our project. Find this file, and change the `install_requires`
    assignment to look like this:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Grok集成PyPI上的包相当简单。第一步是将它添加到项目安装需求中，这些需求在项目根目录下的`setup.py`文件中指定。找到这个文件，并将`install_requires`赋值更改为如下所示：
- en: '[PRE2]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Next, run `bin/buildout` from the command line. The `megrok.form` package and
    its dependencies will be downloaded and installed into the project. In this case,
    we added `megrok.form`, but of course, we could pick any other package from PyPI
    and add it to our project in the same way.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，从命令行运行`bin/buildout`。`megrok.form`包及其依赖项将被下载并安装到项目中。在这种情况下，我们添加了`megrok.form`，但当然，我们也可以从PyPI中选择任何其他包并以相同的方式将其添加到我们的项目中。
- en: How blob support is configured in Grok
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在Grok中如何配置blob支持
- en: 'By default, Grok is preconfigured to use the blob storage, so it''s simple
    to take advantage of it. You can see how this configuration is done if you take
    a look at the `zope.conf` file in the `parts/etc/` directory of our project. The
    relevant section looks like this:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Grok预先配置为使用blob存储，因此利用它很简单。如果你查看我们项目`parts/etc/`目录中的`zope.conf`文件，你可以看到如何完成此配置。相关部分看起来像这样：
- en: '[PRE3]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The messaging class and schema
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 消息类和模式
- en: Now that we have the supporting packages and configuration that we need, let's
    get the **messages** tab going. We'll go through the code quickly, as most of
    the concepts have been used earlier in our application.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经拥有了所需的支撑包和配置，让我们开始设置**消息**标签。我们将快速浏览代码，因为大多数概念已经在我们的应用中之前使用过了。
- en: 'First, we add a `Message` class that will store the messages and their attachments.
    The context of this class will be the `Project` class, as we want messages to
    be stored by project. Of course, we start by defining the interface for the class:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们添加一个`Message`类来存储消息及其附件。这个类的上下文将是`Project`类，因为我们希望消息按项目存储。当然，我们首先定义类的接口：
- en: '[PRE4]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We keep it simple, by adding only `subject, message`, and `attachment` fields.
    Note that the field where we''ll store the attachment is declared as a `BlobFile`.
    For this declaration to work, we of course need to include the following import
    at the top of the file:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们保持简单，只添加`subject, message`和`attachment`字段。请注意，我们将存储附件的字段声明为`BlobFile`。为了使此声明生效，我们当然需要在文件顶部包含以下导入：
- en: '[PRE5]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, find the actual class definition, where we just implement the interface,
    and add a `searchableText` method, to allow messages to appear in search results:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，找到实际的类定义，我们只是实现接口，并添加一个`searchableText`方法，以便消息出现在搜索结果中：
- en: '[PRE6]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We need a form for creating the messages and uploading the attachment, so that's
    our next step. This will create an `add_message` form that will require the `todo.changeitems`
    permission to be used. The fields come from the interface defined earlier, and
    we use the template for custom edit forms that we created in Chapter 5.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个用于创建消息和上传附件的表单，所以这是我们下一步要做的事情。这将创建一个`add_message`表单，使用它需要`todo.changeitems`权限。字段来自之前定义的接口，我们使用第5章中创建的定制编辑表单模板。
- en: '[PRE7]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The key part of the form is the add action, where the message is created and
    its properties are set with the values from the form. Notice that both messages
    and lists use the same `next_id` counter for their name, so the `content_type`
    class attribute becomes very important. This will be used to get only messages
    or only lists, depending upon the view:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 表单的关键部分是添加操作，在这里创建消息并使用表单中的值设置其属性。请注意，消息和列表都使用相同的 `next_id` 计数器作为它们的名称，因此 `content_type`
    类属性变得非常重要。这将用于根据视图获取仅消息或仅列表：
- en: '[PRE8]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You can see this form in action in the following screenshot:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下屏幕截图中看到这个表单的实际效果：
- en: '![The messaging class and schema](img/7481_09_01.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![消息类和模式](img/7481_09_01.jpg)'
- en: The message viewlet
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 消息视图小部件
- en: 'Next, we create the view and viewlet for showing the messages. The view performs
    a catalog search by using the content type. Of course, we first need to add to
    our `ProjectIndexes` class (from Chapter 6), so that it gets indexed, as now there
    are two different kinds of objects that can be stored inside a project (messages
    and lists). We also have to change the catalog search of `todo` lists to use this
    new index. Here is the view code:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建用于显示消息的视图和视图小部件。视图通过使用内容类型执行目录搜索。当然，我们首先需要将 `ProjectIndexes` 类（来自第 6
    章）添加到我们的类中，以便它被索引，因为现在项目内部可以存储两种不同类型的对象（消息和列表）。我们还必须将 `todo` 列表的目录搜索更改为使用这个新索引。以下是视图代码：
- en: '[PRE9]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'For the viewlet, we simply define a template and set the view to the one that
    we just created:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 对于视图小部件，我们只需定义一个模板并将视图设置为刚刚创建的那个：
- en: '[PRE10]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The message list template
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 消息列表模板
- en: 'The project messages viewlet uses a new template named `projectmessages_viewlet`.
    We will show a couple of links at the top that will function more or less like
    tabs, for switching between list and messages views:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 项目消息视图小部件使用一个名为 `projectmessages_viewlet` 的新模板。我们将在顶部显示几个链接，它们将大致像标签一样工作，用于在列表视图和消息视图之间切换：
- en: '[PRE11]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'After that, we show the messages and their contents by using a "repeat" structure.
    The most important part of the template for the purposes of this chapter is the
    link for downloading the attachment, which uses the `view.url` method to point
    to the download view. Note that a message may not include an attachment, which
    is why the paragraph with the link has a condition for either showing it or not:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们通过使用“重复”结构来显示消息及其内容。对于本章的目的，模板的关键部分是下载附件的链接，它使用 `view.url` 方法指向下载视图。请注意，一条消息可能不包含附件，这就是为什么带有链接的段落有一个条件来决定是否显示它：
- en: '[PRE12]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Some CSS styles were added to the project as well. These are not shown here.
    Please check the source code for this book to see what they are.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还向项目中添加了一些 CSS 样式。这里没有显示。请检查这本书的源代码以查看它们是什么。
- en: Downloading an attachment
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 下载附件
- en: 'The last step is to add a view for downloading an attachment. We do not need
    to show a template here; we have to return the file. This is how it is done:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是添加一个用于下载附件的视图。这里我们不需要显示模板；我们必须返回文件。这是如何操作的：
- en: '[PRE13]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: First, we get the filename and the file data from the attachment in question,
    in the `update` method. Then, in the `render` method, we set the `Content-Disposition
    response` header to `attachment` and pass the filename to it, so that the browser
    will know which file to download by using its original name, directly. Finally,
    we return the file data.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们在 `update` 方法中获取附件的文件名和文件数据。然后，在 `render` 方法中，我们将 `Content-Disposition`
    响应头设置为 `attachment` 并将其传递给文件名，这样浏览器就会知道通过使用其原始名称直接下载哪个文件。最后，我们返回文件数据。
- en: Testing the Blob support
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试 Blob 支持
- en: We are now ready to run the application. The following screenshot shows the
    way it should look. Try adding a few messages and files, and then take a look
    at the contents of the `blob` directory that you specified in the `zope.conf`
    file. You should see a `blobs` directory containing one directory for each file
    that you uploaded.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以运行应用程序了。以下屏幕截图显示了它应该看起来像什么。尝试添加一些消息和文件，然后查看您在 `zope.conf` 文件中指定的 `blob`
    目录的内容。您应该看到一个包含每个上传文件目录的 `blobs` 目录。
- en: '![Testing the Blob support](img/7481_09_02.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![测试 Blob 支持](img/7481_09_02.jpg)'
- en: Taking advantage of transactions
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用事务的优势
- en: We have been saying from the beginning of this chapter that the ZODB is transactional,
    but so far we haven't seen the benefits that we get from this. Possibly the most
    important benefit is the ability to roll back, or undo, a transaction.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从本章开始就说过 ZODB 是事务性的，但到目前为止，我们还没有看到我们从中获得的好处。可能最重要的好处是能够回滚或撤销事务。
- en: Using zope.app.undo
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 zope.app.undo
- en: 'As Grok handles the transaction commits for us, we haven''t had the chance
    to show it, but we''ll now see how to undo and even redo transactions. The easiest
    way to show this is to use the `zope.app.undo` package available in the PyPI.
    We will add it to the project in the same way that we inserted `megrok.form`,
    earlier in this chapter. Edit the `setup.py` file at the root of the project and
    add the following code to it:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Grok 为我们处理事务提交，我们还没有机会展示它，但现在我们将看到如何撤销和重做事务。展示这一点最简单的方法是使用 PyPI 上的 `zope.app.undo`
    包。我们将以与本章早期插入 `megrok.form` 相同的方式将其添加到项目中。编辑项目根目录下的 `setup.py` 文件，并添加以下代码：
- en: '[PRE14]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now rerun `bin/buildout` to let Grok download and install the package. No other
    action is needed to enable it just restart the application.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在重新运行 `bin/buildout`，让 Grok 下载并安装该包。无需其他操作即可启用它，只需重新启动应用程序。
- en: Testing the undo functionality
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试撤销功能
- en: Create an instance of the todo application, and add a project. Then add a list
    inside that project, with the title `test undo`. Now delete the list that you
    have just created. You will see an empty project once again.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个 todo 应用程序实例，并添加一个项目。然后在项目中添加一个列表，标题为 `test undo`。现在删除您刚刚创建的列表。您将再次看到一个空的项目。
- en: 'To undo the transaction, we''ll have to use the Grok management interface,
    which we used earlier, when learning about the catalog, in Chapter 6\. Point your
    browser to the following URL: [http://localhost:8080/todo/@@undoMore.html](http://localhost:8080/todo/@@undoMore.html).'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 要撤销事务，我们必须使用之前在第六章学习目录时使用的 Grok 管理界面。将您的浏览器指向以下 URL：[http://localhost:8080/todo/@@undoMore.html](http://localhost:8080/todo/@@undoMore.html)。
- en: You should see a list of transactions, similar to the one in the next screenshot.
    The screen shows the last ten transactions for the todo application instance visited.
    The transaction at the top is the last one committed. To revert it, simply select
    the checkbox to its left, and then click on the **Undo** button at the bottom
    of the screen.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该会看到一个事务列表，类似于下一张截图所示。屏幕显示了访问 todo 应用程序实例的最后十个事务。顶部的事务是最后提交的事务。要撤销它，只需选中左侧的复选框，然后点击屏幕底部的**撤销**按钮。
- en: Now go back to your project. The list that you deleted is magically back there.
    If you go back to the list, you'll notice that the undo operation itself is now
    listed as a transaction, so you can "redo" the old transaction, by undoing the
    transaction that is now at the top.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在回到您的项目。您删除的列表神奇地又回到了那里。如果您回到列表，您会注意到撤销操作现在被列为一个事务，因此您可以通过撤销现在顶部的事务来“重做”旧事务。
- en: '"Undo" is a powerful feature, and the one that can make you look like a hero
    in the eyes of your application users. It''s also possible to undo multiple transactions
    at the same time. However, a transaction can only be undone if the objects on
    which it operated have not been modified by a later transaction. This means that
    undoing a mistake is something that has to be done quickly, before new transactions
    can complicate things.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: “撤销”是一个强大的功能，它可以使您在应用程序用户眼中看起来像英雄。同时撤销多个事务也是可能的。然而，只有当事务操作的对象没有被后续事务修改时，才能撤销事务。这意味着在新的事务使事情复杂化之前，必须快速撤销错误。
- en: '![Testing the undo functionality](img/7481_09_03.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![测试撤销功能](img/7481_09_03.jpg)'
- en: ZODB maintenance
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ZODB 维护
- en: As with any other database system, the ZODB needs some maintenance, from time
    to time. The main thing that can happen is that the database size will grow to
    occupy a large amount of disk space, causing some tasks to become slower.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何其他数据库系统一样，ZODB 需要定期进行一些维护。可能发生的主要情况是数据库大小会增长，占用大量磁盘空间，导致某些任务变慢。
- en: File storage
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件存储
- en: As we mentioned before, the ZODB keeps track of all of the versions of a stored
    object, which makes ZODB grow every time an object changes. Packing allows the
    ZODB to get rid of older versions of objects, thus reducing the database size.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，ZODB 跟踪存储对象的全部版本，这使得每次对象更改时 ZODB 都会增长。打包允许 ZODB 丢弃旧版本的对象，从而减小数据库大小。
- en: The database is usually contained in a file named `Data.fs`, which is located
    under `parts/data` in our `project` directory.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库通常包含在一个名为`Data.fs`的文件中，该文件位于我们的`project`目录下的`parts/data`文件夹中。
- en: Packing is a process that can take some time, and thus it runs on a separate
    thread. A backup copy of the database file is created before the packing starts,
    in case something goes wrong, so be aware that you will need to have at least
    as much free disk space as the current size of the ZODB, in order to be able to
    pack it.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 打包是一个可能需要一些时间的操作，因此它在单独的线程上运行。在打包开始之前，会创建数据库文件的备份副本，以防万一出现问题，因此请注意，您至少需要与ZODB当前大小一样多的空闲磁盘空间，才能打包它。
- en: In Grok, the easiest way to pack the database is to go to the administration
    interface and click on the **Server Control** link. This will take you to a control
    panel where the option to pack the current database is shown (see the next screenshot).
    To pack the database, simply select the number of days beyond which object revisions
    should be removed. The packing process will be started, and when it's finished,
    there will be a message at the top of the control panel notifying you of this.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在Grok中，打包数据库最简单的方法是进入管理界面并点击**服务器控制**链接。这将带您到一个控制面板，其中显示了打包当前数据库的选项（参见下一张截图）。要打包数据库，只需选择超过多少天应该删除对象修订的数字。打包过程将开始，完成后，控制面板顶部将有一条消息通知您。
- en: '![File storage](img/7481_09_04.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![文件存储](img/7481_09_04.jpg)'
- en: Automatic packing
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动打包
- en: In most cases, packing will be a good thing to do frequently, unless for some
    reason you absolutely need to keep track of every revision of every object, ever.
    Packing the database once a week, for example, could be a good way to keep the
    database size in check and also to make tasks such as backing up, easier and faster.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，频繁地进行打包将是一件好事，除非出于某种原因你绝对需要跟踪每个对象的每个修订版本。例如，每周打包一次数据库可能是一个保持数据库大小可控并使备份等任务更容易、更快的好方法。
- en: Of course, manually packing the database every time could be a burden to an
    administrator, and is easily forgotten, so an automatic way of performing the
    packing comes in handy.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，每次手动打包数据库可能会给管理员带来负担，并且很容易被遗忘，因此自动执行打包操作会很有用。
- en: Packing is an expensive operation, and doing it from outside Grok requires a
    separate database connection, which is why using ZEO is a good idea, even if our
    scalability demands do not call for it. As ZEO allows multiple connections, packing
    can be done from another ZEO client, without needing to stop the regular service.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 打包是一个昂贵的操作，并且从Grok外部执行需要单独的数据库连接，这就是为什么即使我们的可扩展性需求不需要它，使用ZEO也是一个好主意。因为ZEO允许多个连接，所以可以从另一个ZEO客户端进行打包，而无需停止常规服务。
- en: 'This task is so necessary that the Grok installation already makes a script
    available to pack the ZODB by using ZEO. It''s called `zeopack`, and can be found
    under the `bin` directory of the main Grok installation. To use it, simply make
    sure that the ZEO server is running, and then call the script with the host and
    port of the site:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这个任务如此必要，以至于Grok安装已经提供了一个名为`zeopack`的脚本，用于通过ZEO打包ZODB。它位于Grok主安装的`bin`目录下。要使用它，只需确保ZEO服务器正在运行，然后使用站点的主机和端口调用脚本：
- en: '[PRE15]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This script call could be added to a UNIX cron script to perform the task weekly,
    or as frequently as needed.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将此脚本调用添加到UNIX cron脚本中，以每周或所需频率执行任务。
- en: Backing up
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 备份
- en: As with all important data handling services, backups are greatly encouraged
    when using the ZODB. Exactly how often to make backups can vary depending on the
    type of application, but it should be done regularly.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有重要的数据处理服务一样，在使用ZODB时，备份被强烈推荐。具体多久进行一次备份可以根据应用程序的类型而有所不同，但应该定期进行。
- en: 'The Grok installation includes a script, called `repozo`, to facilitate backups.
    This script allows incremental or full backups to be taken, and can be used both
    for backing up and restoring a `Data.fs` file. To backup our database, we can
    first create a directory, called `backups` inside our Grok main directory and
    then use:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: Grok安装包括一个名为`repozo`的脚本，用于简化备份。此脚本允许进行增量或完整备份，并且可以用于备份和恢复`Data.fs`文件。为了备份我们的数据库，我们可以在Grok主目录内创建一个名为`backups`的目录，然后使用：
- en: '[PRE16]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `-B` option means to perform a backup action. The `-f` options gives the
    path to the `Data.fs` file that we want to backup. The first time, `repozo` will
    make a full backup to the `backups` directory (specified by the `-r` option).
    Further calls will result in incremental backups unless the database has been
    packed after the last backup.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`-B` 选项表示执行备份操作。`-f` 选项给出了我们想要备份的 `Data.fs` 文件的路径。第一次，`repozo` 将在 `backups`
    目录（由 `-r` 选项指定）中进行完整备份。进一步的调用将导致增量备份，除非在最后一次备份后数据库已被打包。'
- en: 'To recover a `Data.fs` file from a `repozo` backup, we use the `-R` option:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 要从 `repozo` 备份中恢复 `Data.fs` 文件，我们使用 `-R` 选项：
- en: '[PRE17]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This command will recover the latest backup and output the recovered file to
    `RecoveredData.fs` (specified by the `-o` option). It's also possible to recover
    a backup from a specified date, by using the `-D` option with a date in the format
    "yyyy-mm-dd".
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将恢复最新的备份并将恢复的文件输出到 `RecoveredData.fs`（由 `-o` 选项指定）。也可以通过使用 `-D` 选项并指定 "yyyy-mm-dd"
    格式的日期来恢复指定日期的备份。
- en: Using the ZODB without Grok
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在没有 Grok 的情况下使用 ZODB
- en: The ZODB is a very powerful package, and there is no reason why we couldn't
    use it on regular applications outside Grok, too. In fact, many simple applications
    that are usually developed by using a relational database (mainly because that's
    what most developers are used to) can be even simpler if the ZODB is used.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: ZODB 是一个非常强大的包，我们没有理由不在 Grok 之外的正常用作应用程序中使用它。事实上，许多通常使用关系型数据库（主要是因为大多数开发者都习惯了）开发的应用程序，如果使用
    ZODB，甚至可以更简单。
- en: To show how easy it is to work with the ZODB from Python, we'll show a simple
    example. All that's needed to follow along is to have Python installed, and to
    use `easy_install` to get the ZODB3 egg, or download the ZODB package from [http://pypi.python.org/pypi/ZODB3](http://pypi.python.org/pypi/ZODB3).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示从 Python 使用 ZODB 的简便性，我们将展示一个简单的示例。要跟随示例，只需安装 Python 并使用 `easy_install`
    获取 ZODB3 egg，或者从 [http://pypi.python.org/pypi/ZODB3](http://pypi.python.org/pypi/ZODB3)
    下载 ZODB 包。
- en: 'Create a file named `zodb_demo.py`. First, let''s create a small class that
    will take care of opening and closing the connection to a `FileStorage`. Add the
    following code at the start of your `zodb_demo.py` file:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 `zodb_demo.py` 的文件。首先，让我们创建一个小的类来处理打开和关闭到 `FileStorage` 的连接。在您的 `zodb_demo.py`
    文件开始处添加以下代码：
- en: '[PRE18]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: First, we make a few imports. `FileStorage` is needed to define the file where
    the database will be stored, `DB` is the actual ZODB library, and `transaction`
    is used for committing changes to the database.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们进行一些导入。`FileStorage` 用于定义数据库存储的文件，`DB` 是实际的 ZODB 库，而 `transaction` 用于将更改提交到数据库。
- en: Next, we create a class named `ZODBHandler` that will take a file path and initialize
    a file storage for our ZODB. If the file passed in the path exists, it will be
    used as the database; if it does not exist, it will be created. Either way, we
    don't have to worry about this, as `FileStorage` takes care of it for us. With
    this, we have a storage that we can pass to the `DB` class on the following line.
    After that, we can open a connection and once this is done, we get the root object
    of the database and store it in `dbroot`. From there, we can work with the database,
    as we will see shortly.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个名为 `ZODBHandler` 的类，它将接受一个文件路径并为我们的 ZODB 初始化一个文件存储。如果传入路径的文件存在，它将被用作数据库；如果不存在，它将被创建。无论如何，我们不必担心这一点，因为
    `FileStorage` 会为我们处理。有了这个，我们就有了一个可以传递给下一行的 `DB` 类的存储。之后，我们可以打开一个连接，一旦完成，我们就获取数据库的根对象并将其存储在
    `dbroot` 中。从那里，我们可以像我们将要看到的那样与数据库一起工作。
- en: The other thing that our ZODB handler does, is close the connection and storage
    when we have finished using them, by means of a `close` method that we can call
    when we want.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 ZODB 处理器做的另一件事是在我们完成使用后通过一个 `close` 方法来关闭连接和存储。
- en: 'We can now initialize a database, and start writing data to it:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以初始化一个数据库，并开始向其中写入数据：
- en: '[PRE19]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We pass our handler a path that will create a file named `Data.fs` in the current
    directory. Next, we get the root object of the database that is stored there.
    We then add several objects, just to show that any Python object that is pickable
    can be stored in the database. Finally, we need to commit the transaction, in
    order to actually save the changes.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将一个路径传递给我们的处理器，该路径将在当前目录中创建一个名为 `Data.fs` 的文件。接下来，我们获取存储在那里的数据库的根对象。然后我们添加几个对象，只是为了展示任何可
    pick 的 Python 对象都可以存储在数据库中。最后，我们需要提交事务，以便实际保存更改。
- en: 'To fetch an object from the database, we simply need to refer to it by its
    key, much like a dictionary works:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 要从数据库中获取一个对象，我们只需通过其键来引用它，就像字典的工作方式一样：
- en: '[PRE20]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Deleting an object is also quite easy:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 删除一个对象也非常简单：
- en: '[PRE21]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Of course, most applications will not use built-in Python objects, but will
    create their own classes that subclass from `persistent.Persistent`. Insert the
    following class definition before the `if` statement, above:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，大多数应用程序不会使用内置的 Python 对象，而是会创建自己的类，这些类从 `persistent.Persistent` 继承。在上述 `if`
    语句之前插入以下类定义：
- en: '[PRE22]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We can now store projects transparently in our database. Append the following
    lines at the end of the program:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以透明地将项目存储到我们的数据库中。在程序末尾追加以下行：
- en: '[PRE23]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This is a very simple example, but hopefully you can see the potential for creating
    interesting ZODB-backed applications. No SQL is needed, just plain Python objects.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的例子，但希望你能看到创建有趣的 ZODB 支持的应用程序的潜力。不需要 SQL，只需普通的 Python 对象。
- en: Summary
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have learned more about the ZODB, and learned how to take
    advantage of its features, such as blob handling. We also learned a bit about
    ZODB maintenance and the need to pack the database frequently. Finally, we tried
    our hand at using the ZODB outside Grok, as a regular Python library.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们更多地了解了 ZODB，并学习了如何利用其功能，例如 blob 处理。我们还了解了一些关于 ZODB 维护和需要频繁打包数据库的内容。最后，我们尝试在
    Grok 之外使用 ZODB，作为一个常规的 Python 库。
