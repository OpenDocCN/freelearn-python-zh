- en: Chapter 6. Advanced Concepts – OOP, Decorators, and Iterators
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章. 高级概念 – 面向对象编程、装饰器和迭代器
- en: '|   | *"La classe non è acqua. (Class will out)"* |   |'
  id: totrans-1
  prefs: []
  type: TYPE_TB
  zh: '|    | *"La classe non è acqua. (类将超越)"* |    |'
- en: '|   | --*Italian saying* |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '|    | --*意大利谚语* |'
- en: I could probably write a small book about **object-oriented programming** (referred
    to as **OOP** henceforth) and classes. In this chapter, I'm facing the hard challenge
    of finding the balance between breadth and depth. There are simply too many things
    to tell, and there's plenty of them that would take more than this whole chapter
    if I described them alone in depth. Therefore, I will try to give you what I think
    is a good panoramic view of the fundamentals, plus a few things that may come
    in handy in the next chapters. Python's official documentation will help in filling
    the gaps.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我可能可以写一本关于**面向对象编程**（以下简称**OOP**）和类的书。在本章中，我面临着在广度和深度之间找到平衡的艰难挑战。有太多的事情要讲，而且有很多事情如果单独深入描述，将会超过整个章节。因此，我将尝试给你一个我认为是好的全景视图的基础知识，以及一些可能在下一章中派上用场的知识点。Python的官方文档将帮助填补这些空白。
- en: 'We''re going to explore three important concepts in this chapter: decorators,
    OOP, and iterators.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨三个重要的概念：装饰器、面向对象编程（以下简称OOP）和迭代器。
- en: Decorators
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 装饰器
- en: In the previous chapter, I measured the execution time of various expressions.
    If you recall, I had to initialize a variable to the start time, and subtract
    it from the current time after execution in order to calculate the elapsed time.
    I also printed it on the console after each measurement. That was very tedious.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我测量了各种表达式的执行时间。如果你还记得，我必须初始化一个变量为开始时间，然后在执行后从当前时间中减去它来计算经过的时间。我还必须在每次测量后在控制台上打印它。这非常繁琐。
- en: Every time you find yourself repeating things, an alarm bell should go off.
    Can you put that code in a function and avoid repetition? The answer most of the
    time is *yes*, so let's look at an example.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你发现自己重复某些事情时，应该响起一个警钟。你能把那段代码放入一个函数中并避免重复吗？大多数情况下答案是*是的*，让我们看看一个例子。
- en: '`decorators/time.measure.start.py`'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '`decorators/time.measure.start.py`'
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding code, I defined two functions, `f` and `g`, which do nothing
    but sleep (by 0.3 and 0.5 seconds respectively). I used the `sleep` function to
    suspend the execution for the desired amount of time. I also highlighted how we
    calculate the time elapsed by setting `t` to the current time and then subtracting
    it when the task is done. You can see that the measure is pretty accurate.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我定义了两个函数`f`和`g`，它们什么也不做，只是睡眠（分别睡眠0.3秒和0.5秒）。我使用了`sleep`函数来暂停执行所需的时间。我还突出显示了如何通过将`t`设置为当前时间，然后在任务完成后减去它来计算经过的时间。你可以看到这个测量非常准确。
- en: 'Now, how do we avoid repeating that code and those calculations? One first
    potential approach could be the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们要如何避免重复代码和计算呢？一个首先的潜在方法可能是以下这样：
- en: '`decorators/time.measure.dry.py`'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`decorators/time.measure.dry.py`'
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Ah, much better now. The whole timing mechanism has been encapsulated into a
    function so we don't repeat code. We print the function name dynamically and it's
    easy enough to code. What if we need to pass arguments to the function we measure?
    This code would get just a bit more complicated, so let's see an example.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 啊，现在好多了。整个计时机制已经被封装成一个函数，这样我们就不会重复代码。我们动态地打印函数名，编码起来也很容易。如果我们需要向测量的函数传递参数怎么办？这段代码会稍微复杂一点，让我们看看一个例子。
- en: '`decorators/time.measure.arguments.py`'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`decorators/time.measure.arguments.py`'
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now, `f` is expecting to be fed `sleep_time` (with a default value of `0.1`).
    I also had to change the `measure` function so that it is now accepting a function,
    any variable positional arguments, and any variable keyword arguments. In this
    way, whatever we call `measure` with, we redirect those arguments to the call
    to `f` we do inside.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`f`函数期望接收`sleep_time`参数（默认值为`0.1`）。我还不得不修改`measure`函数，使其现在可以接受一个函数、任意可变位置参数和任意可变关键字参数。这样，无论我们用什么调用`measure`，我们都会将这些参数重定向到我们在内部对`f`的调用。
- en: 'This is very good, but we can push it a little bit further. Let''s say we want
    to somehow have that timing behavior built-in in the `f` function, so that we
    could just call it and have that measure taken. Here''s how we could do it:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这很好，但我们还可以更进一步。假设我们想在`f`函数中内置那种计时行为，这样我们就可以直接调用它并获取测量结果。下面是我们如何做到这一点的方法：
- en: '`decorators/time.measure.deco1.py`'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`decorators/time.measure.deco1.py`'
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The preceding code is probably not so straightforward. I confess that, even
    today, it sometimes requires me some serious concentration to understand some
    decorators, they can be pretty nasty. Let's see what happens here. The magic is
    in the **decoration point**. We basically reassign `f` with whatever is returned
    by `measure` when we call it with `f` as an argument. Within `measure`, we define
    another function, `wrapper`, and then we return it. So, the net effect is that
    after the decoration point, when we call `f`, we're actually calling `wrapper`.
    Since the wrapper inside is calling `func`, which is `f`, we are actually closing
    the loop like that. If you don't believe me, take a look at the last line.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码可能不是那么直观。我承认，即使今天，有时我还需要集中精力才能理解一些装饰器，它们可能相当复杂。让我们看看这里发生了什么。魔法在于 **装饰点**。我们基本上在调用它时，将
    `f` 重新分配为 `measure` 返回的任何内容。在 `measure` 中，我们定义另一个函数 `wrapper`，然后返回它。所以，最终效果是在装饰点之后，当我们调用
    `f` 时，我们实际上是在调用 `wrapper`。由于包装器内部调用的是 `func`，也就是 `f`，所以我们实际上是这样闭合循环的。如果你不相信我，看看最后一行。
- en: '`wrapper` is actually... a wrapper. It takes variable and positional arguments,
    and calls `f` with them. It also does the time measurement trick around the call.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`wrapper` 实际上...就是一个包装器。它接受变量和位置参数，并用它们调用 `f`。它还在调用周围执行时间测量技巧。'
- en: 'This technique is called **decoration**, and `measure` is, at all effects,
    a **decorator**. This paradigm became so popular and widely used that at some
    point, Python added a special syntax for it (check **PEP 318**). Let''s explore
    three cases: one decorator, two decorators, and one decorator that takes arguments.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术被称为 **装饰器**，而 `measure` 在所有效果上，就是一个 **装饰器**。这种范式变得如此流行和广泛使用，以至于在某个时刻，Python
    为它添加了特殊的语法（检查 **PEP 318**）。让我们探索三个案例：一个装饰器，两个装饰器，以及一个接受参数的装饰器。
- en: '`decorators/syntax.py`'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`decorators/syntax.py`'
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Basically, instead of manually reassigning the function to what was returned
    by the decorator, we prepend the definition of the function with the special syntax
    `@decorator_name`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，我们不再手动将函数重新分配为装饰器返回的内容，而是在函数定义前使用特殊的语法 `@decorator_name`。
- en: 'We can apply multiple decorators to the same function in the following way:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下方式将多个装饰器应用于同一个函数：
- en: '`decorators/syntax.py`'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`decorators/syntax.py`'
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'When applying multiple decorators, pay attention to the order, should it matter.
    In the preceding example, `func` is decorated with `deco2` first, and the result
    is decorated with `deco1`. A good rule of thumb is: *the closer the decorator
    to the function, the sooner it is applied*.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用多个装饰器时，请注意顺序，这很重要。在前面的例子中，`func` 首先被 `deco2` 装饰，然后结果被 `deco1` 装饰。一个很好的经验法则是：*装饰器离函数越近，应用得越早*。
- en: Some decorators can take arguments. This technique is generally used to produce
    other decorators. Let's look at the syntax, and then we'll see an example of it.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 一些装饰器可以接受参数。这种技术通常用于生成其他装饰器。让我们看看语法，然后我们会看到一个例子。
- en: '`decorators/syntax.py`'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`decorators/syntax.py`'
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you can see, this case is a bit different. First `decoarg` is called with
    the given arguments, and then its return value (the actual decorator) is called
    with `func`. Before I give you another example, let's fix one thing that is bothering
    me. I don't want to lose the original function name and docstring (and the other
    attributes as well, check the documentation for the details) when I decorate it.
    But because inside our decorator we return `wrapper`, the original attributes
    from `func` are lost and `f` ends up being assigned the attributes of `wrapper`.
    There is an easy fix for that from `functools`, a wonderful module from the Python
    standard library. I will fix the last example, and I will also rewrite its syntax
    to use the `@` operator.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这个案例有点不同。首先 `decoarg` 使用给定的参数被调用，然后它的返回值（实际的装饰器）使用 `func` 被调用。在我给你另一个例子之前，让我们解决一个让我烦恼的问题。我不想在装饰它时丢失原始函数名称和文档字符串（以及其他属性，请参阅文档以获取详细信息）。但是，因为在我们装饰器内部我们返回
    `wrapper`，所以 `func` 最终会丢失原始属性并分配 `wrapper` 的属性。从 `functools` 中有一个简单的解决方案，这是一个来自
    Python 标准库的奇妙模块。我将修复最后一个例子，并将它的语法重写为使用 `@` 操作符。
- en: '`decorators/time.measure.deco2.py`'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`decorators/time.measure.deco2.py`'
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now we're talking! As you can see, all we need to do is to tell Python that
    `wrapper` actually wraps `func` (by means of the `wraps` function), and you can
    see that the original name and docstring are now maintained.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来谈谈重点！正如你所见，我们只需要告诉 Python，`wrapper` 实际上包装了 `func`（通过 `wraps` 函数实现），现在你可以看到原始名称和文档字符串现在都得到了保留。
- en: Let's see another example. I want a decorator that prints an error message when
    the result of a function is greater than a threshold. I will also take this opportunity
    to show you how to apply two decorators at once.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再看另一个例子。我想有一个装饰器，当函数的结果大于一个阈值时打印错误信息。我还会借此机会向你展示如何同时应用两个装饰器。
- en: '`decorators/two.decorators.py`'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`decorators/two.decorators.py`'
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Tip
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Take your time in studying the preceding example until you are sure you understand
    it well. If you do, I don't think there is any decorator you won't be able to
    write afterwards.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在研究前面的例子之前，请确保你已经很好地理解了它。如果你做到了，我想你不会写不出任何装饰器。
- en: I had to enhance the `measure` decorator, so that its `wrapper` now returns
    the result of the call to `func`. The `max_result` decorator does that as well,
    but before returning, it checks that `result` is not greater than 100, which is
    the maximum allowed.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我不得不增强`measure`装饰器，使其`wrapper`现在返回对`func`的调用结果。`max_result`装饰器也这样做，但在返回之前，它会检查`result`是否不大于100，这是允许的最大值。
- en: 'I decorated `cube` with both of them. First, `max_result` is applied, then
    `measure`. Running this code yields this result:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我用这两个装饰器装饰了`cube`。首先应用`max_result`，然后是`measure`。运行这段代码得到以下结果：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'For your convenience, I put a `#` to the right of the results of the first
    call: `print(cube(2))`. The result is 8, and therefore it passes the threshold
    check silently. The running time is measured and printed. Finally, we print the
    result (`8`).'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便起见，我在第一次调用的结果右侧加了一个`#`：`print(cube(2))`。结果是8，因此它默默地通过了阈值检查。测量并打印了运行时间。最后，我们打印了结果（`8`）。
- en: On the second call, the result is `125`, so the error message is printed, the
    result returned, and then it's the turn of `measure`, which prints the running
    time again, and finally, we print the result (`125`).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二次调用时，结果是`125`，所以打印了错误信息，返回了结果，然后轮到`measure`打印运行时间，最后我们打印了结果（`125`）。
- en: Had I decorated the `cube` function with the same two decorators but in a different
    order, the error message would follow the line that prints the running time, instead
    of preceding it.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我用相同的两个装饰器装饰了`cube`函数，但顺序不同，错误信息将跟随打印运行时间的行，而不是在其之前。
- en: A decorator factory
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 装饰器工厂
- en: 'Let''s simplify this example now, going back to a single decorator: `max_result`.
    I want to make it so that I can decorate different functions with different thresholds,
    and I don''t want to write one decorator for each threshold. Let''s amend `max_result`
    so that it allows us to decorate functions specifying the threshold dynamically.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们简化这个例子，回到一个单一的装饰器：`max_result`。我想让它能够用不同的阈值装饰不同的函数，而且我不想为每个阈值写一个装饰器。让我们修改`max_result`，使其能够让我们动态地指定阈值来装饰函数。
- en: '`decorators/decorators.factory.py`'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`decorators/decorators.factory.py`'
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This preceding code shows you how to write a **decorator factory**. If you recall,
    decorating a function with a decorator that takes arguments is the same as writing
    `func = decorator(argA, argB)(func)`, so when we decorate `cube` with `max_result(75)`,
    we're doing `cube = max_result(75)(cube)`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这段前面的代码展示了如何编写一个**装饰器工厂**。如果你还记得，用接受参数的装饰器装饰一个函数与写`func = decorator(argA, argB)(func)`相同，所以当我们用`max_result(75)`装饰`cube`时，我们实际上是在做`cube
    = max_result(75)(cube)`。
- en: Let's go through what happens, step by step. When we call `max_result(75)`,
    we enter its body. A `decorator` function is defined inside, which takes a function
    as its only argument. Inside that function, the usual decorator trick is performed.
    We define a wrapper, inside of which we check the result of the original function's
    call. The beauty of this approach is that from the innermost level, we can still
    refer to both `func` and `threshold`, which allows us to set the threshold dynamically.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一步一步地了解发生了什么。当我们调用`max_result(75)`时，我们进入其主体。在其中定义了一个装饰器函数，它只接受一个函数作为其唯一参数。在这个函数内部，执行了通常的装饰器技巧。我们定义了一个包装器，在其中我们检查原始函数调用的结果。这种方法的优点是从最内层开始，我们仍然可以引用`func`和`threshold`，这允许我们动态地设置阈值。
- en: '`wrapper` returns `result`, `decorator` returns `wrapper`, and `max_result`
    returns `decorator`. This means that our call `cube = max_result(75)(cube)`, actually
    becomes `cube = decorator(cube)`. Not just any `decorator` though, but one for
    which `threshold` has the value `75`. This is achieved by a mechanism called **closure**,
    which is outside of the scope of this chapter but nonetheless very interesting,
    so I mentioned it for you to do some research on it.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`wrapper` 返回 `result`，`decorator` 返回 `wrapper`，而 `max_result` 返回 `decorator`。这意味着我们的调用
    `cube = max_result(75)(cube)` 实际上变成了 `cube = decorator(cube)`。但这不仅仅是一个任意的 `decorator`，而是一个
    `threshold` 值为 `75` 的 `decorator`。这是通过称为**闭包**的机制实现的，它超出了本章的范围，但仍然非常有趣，所以我提到了它，以便你可以做一些研究。'
- en: 'Running the last example produces the following result:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 运行最后一个示例会产生以下结果：
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The preceding code allows me to use the `max_result` decorator with different
    thresholds at my own will, like this:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码允许我根据自己的意愿使用具有不同阈值的 `max_result` 装饰器，如下所示：
- en: '`decorators/decorators.factory.py`'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`decorators/decorators.factory.py`'
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note that every decoration uses a different `threshold` value.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，每个装饰器都使用不同的 `threshold` 值。
- en: Decorators are very popular in Python. They are used quite often and they simplify
    (and beautify, I dare say) the code a lot.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器在 Python 中非常流行。它们被频繁使用，并且极大地简化（甚至美化，我敢这么说）了代码。
- en: Object-oriented programming
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面向对象编程
- en: 'It''s been quite a long and hopefully nice journey and, by now, we should be
    ready to explore object-oriented programming. I''ll use the definition from *Kindler,
    E.; Krivy, I. (2011). Object-Oriented Simulation of systems with sophisticated
    control. International Journal of General Systems*, and adapt it to Python:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这已经是一段相当漫长且希望愉快的旅程了，到现在，我们应该准备好探索面向对象编程了。我将使用来自 *Kindler, E.; Krivy, I. (2011).
    Object-Oriented Simulation of systems with sophisticated control. International
    Journal of General Systems* 的定义，并将其应用于 Python：
- en: '*Object-oriented programming (OOP) is a programming paradigm based on the concept
    of "objects", which are data structures that contain data, in the form of attributes,
    and code, in the form of functions known as methods. A distinguishing feature
    of objects is that an object''s method can access and often modify the data attributes
    of the object with which they are associated (objects have a notion of "self").
    In OO programming, computer programs are designed by making them out of objects
    that interact with one another.*'
  id: totrans-65
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*面向对象编程（OOP）是一种基于“对象”概念的编程范式，对象是包含数据的数据结构，以属性的形式存在，以及以方法的形式存在的代码。对象的一个显著特征是，对象的方法可以访问并经常修改与之关联的对象的数据属性（对象有一个“自我”的概念）。在面向对象编程中，计算机程序是通过构建相互交互的对象来设计的。*'
- en: Python has full support for this paradigm. Actually, as we have already said,
    *everything in Python is an object*, so this shows that OOP is not just supported
    by Python, but it's part of its very core.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Python 完全支持这种范式。实际上，正如我们之前所说的，*Python 中的所有东西都是一个对象*，所以这表明面向对象编程不仅仅是 Python 支持的，而且是其核心的一部分。
- en: The two main players in OOP are **objects** and **classes**. Classes are used
    to create objects (objects are instances of the classes with which they were created),
    so we could see them as instance factories. When objects are created by a class,
    they inherit the class attributes and methods. They represent concrete items in
    the program's domain.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程（OOP）中的两个主要角色是**对象**和**类**。类用于创建对象（对象是它们被创建的类的实例），因此我们可以将它们视为实例工厂。当对象由一个类创建时，它们继承类的属性和方法。它们代表程序域中的具体项。
- en: The simplest Python class
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最简单的 Python 类
- en: I will start with the simplest class you could ever write in Python.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我将从你可以在 Python 中编写的最简单的类开始。
- en: '`oop/simplest.class.py`'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`oop/simplest.class.py`'
- en: '[PRE13]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let''s run the preceding code and explain it line by line:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行前面的代码并逐行解释它：
- en: '[PRE14]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `Simplest` class I defined only has the `pass` instruction for its body,
    which means it doesn't have any custom attributes or methods. I will print its
    type (`__main__` is the name of the scope in which top-level code executes), and
    I am aware that, in the comment, I wrote *object* instead of *class*. It turns
    out that, as you can see by the result of that `print`, *classes are actually
    objects*. To be precise, they are instances of `type`. Explaining this concept
    would lead to a talk about **metaclasses** and **metaprogramming**, advanced concepts
    that require a solid grasp of the fundamentals to be understood and alas this
    is beyond the scope of this chapter. As usual, I mentioned it to leave a pointer
    for you, for when you'll be ready to dig deeper.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我定义的`Simplest`类只有其主体中的`pass`指令，这意味着它没有任何自定义属性或方法。我将打印其类型（`__main__`是顶层代码执行的命名空间名称），并且我知道，在注释中，我写的是*object*而不是*class*。实际上，正如你可以通过那个`print`的结果看到的那样，*类实际上是对象*。更准确地说，它们是`type`的实例。解释这个概念将导致关于**元类**和**元编程**的讨论，这些是需要牢固掌握基础知识才能理解的高级概念，遗憾的是这超出了本章的范围。像往常一样，我提到它是为了给你留下一个线索，以便当你准备好深入研究时。
- en: 'Let''s go back to the example: I used `Simplest` to create an instance, `simp`.
    You can see that the *syntax to create an instance is the same we use to call
    a function*.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到例子：我使用`Simplest`创建了一个实例，`simp`。你可以看到，*创建实例的语法与我们调用函数时使用的语法相同*。
- en: Then we print what type `simp` belongs to and we verify that `simp` is in fact
    an instance of `Simplest`. I'll show you a better way of doing this later on in
    the chapter.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们打印`simp`所属的类型，并验证`simp`确实是一个`Simplest`的实例。我将在本章后面部分展示一个更好的方法来做这件事。
- en: 'Up to now, it''s all very simple. What happens when we write `class` `ClassName():
    pass`, though? Well, what Python does is create a class object and assign it a
    name. This is very similar to what happens when we declare a function using `def`.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '到目前为止，一切都很简单。当我们编写`class ClassName(): pass`时会发生什么呢？嗯，Python所做的是创建一个类对象并给它一个名称。这和当我们使用`def`声明一个函数时发生的情况非常相似。'
- en: Class and object namespaces
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类和对象命名空间
- en: After the class object has been created (which usually happens when the module
    is first imported), it basically represents a namespace. We can call that class
    to create its instances. Each instance inherits the class attributes and methods
    and is given its own namespace. We already know that, to walk a namespace, all
    we need to do is to use the dot (`.`) operator.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建类对象之后（这通常发生在模块首次导入时），它基本上代表了一个命名空间。我们可以调用这个类来创建它的实例。每个实例继承类属性和方法，并拥有自己的命名空间。我们已经知道，要遍历命名空间，我们只需要使用点(`.`)操作符。
- en: 'Let''s look at another example:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看另一个例子：
- en: '`oop/class.namespaces.py`'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`oop/class.namespaces.py`'
- en: '[PRE15]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the preceding example, I have defined a class attribute called `species`.
    Any variable defined in the body of a class is an attribute that belongs to that
    class. In the code, I have also defined `Person.alive`, which is another class
    attribute. You can see that there is no restriction on accessing that attribute
    from the class. You can see that `man`, which is an instance of `Person`, inherits
    both of them, and reflects them instantly when they change.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我定义了一个名为`species`的类属性。在类体中定义的任何变量都是属于该类的属性。在代码中，我还定义了`Person.alive`，这也是另一个类属性。你可以看到，从类中访问该属性没有限制。你可以看到`man`，它是`Person`的一个实例，继承了这两个属性，并且当它们改变时立即反映出来。
- en: '`man` has also two attributes which belong to its own namespace and therefore
    are called **instance attributes**: `name` and `surname`.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`man` 还有两个属于其自身命名空间属性，因此被称为**实例属性**：`name`和`surname`。'
- en: Note
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Class attributes are shared amongst all instances, while instance attributes
    are not; therefore, you should use class attributes to provide the states and
    behaviors to be shared by all instances, and use instance attributes for data
    that belongs just to one specific object.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 类属性在所有实例之间共享，而实例属性则不是；因此，你应该使用类属性来提供所有实例共享的状态和行为，并使用实例属性来存储仅属于特定对象的属性。
- en: Attribute shadowing
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性遮蔽
- en: 'When you search for an attribute in an object, if it is not found, Python keeps
    searching in the class that was used to create that object (and keeps searching
    until it''s either found or the end of the inheritance chain is reached). This
    leads to an interesting shadowing behavior. Let''s look at an example:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在对象中搜索一个属性时，如果找不到，Python会继续在创建该对象的类中搜索（并且会一直搜索，直到找到或者达到继承链的末尾）。这导致了一个有趣的遮蔽行为。让我们来看一个例子：
- en: '`oop/class.attribute.shadowing.py`'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`oop/class.attribute.shadowing.py`'
- en: '[PRE16]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The preceding code is very interesting. We have defined a class called `Point`
    with two class attributes, `x` and `y`. When we create an instance, `p`, you can
    see that we can print both `x` and `y` from `p`'s namespace (`p.x` and `p.y`).
    What happens when we do that is that Python doesn't find any `x` or `y` attributes
    on the instance, and therefore searches the class, and finds them there.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码非常有趣。我们定义了一个名为`Point`的类，它有两个类属性，`x`和`y`。当我们创建一个实例`p`时，你可以看到我们可以从`p`的命名空间中打印出`x`和`y`（`p.x`和`p.y`）。当我们这样做时，Python没有在实例上找到任何`x`或`y`属性，因此它搜索类，并在那里找到了它们。
- en: Then we give `p` its own `x` attribute by assigning `p.x = 12`. This behavior
    may appear a bit weird at first, but if you think about it, it's exactly the same
    as what happens in a function that declares `x = 12` when there is a global `x
    = 10` outside. We know that `x = 12` won't affect the global one, and for classes
    and instances, it is exactly the same.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们通过分配`p.x = 12`给`p`自己的`x`属性。这种行为一开始可能看起来有点奇怪，但如果你仔细想想，它与在全局`x = 10`外部声明`x
    = 12`的函数中发生的情况完全相同。我们知道`x = 12`不会影响全局的`x`，对于类和实例来说，情况也是一样的。
- en: After assigning `p.x = 12`, when we print it, the search doesn't need to read
    the class attributes, because `x` is found on the instance, therefore we get `12`
    printed out.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在分配`p.x = 12`之后，当我们打印它时，搜索不需要读取类属性，因为`x`已经在实例上找到了，因此我们打印出`12`。
- en: We also print `Point.x` which refers to `x` in the class namespace.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还打印了`Point.x`，它指的是类命名空间中的`x`。
- en: And then, we delete `x` from the namespace of `p`, which means that, on the
    next line, when we print it again, Python will go again and search for it in the
    class, because it won't be found in the instance any more.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们从`p`的命名空间中删除`x`，这意味着在下一行再次打印时，Python将再次在类中搜索它，因为实例中已经找不到它了。
- en: The last three lines show you that assigning attributes to an instance doesn't
    mean that they will be found in the class. Instances get whatever is in the class,
    but the opposite is not true.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 最后三行显示，将属性分配给实例并不意味着它们会在类中找到。实例会得到类中的任何东西，但反之则不然。
- en: What do you think about putting the `x` and `y` coordinates as class attributes?
    Do you think it was a good idea?
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 你认为将`x`和`y`坐标作为类属性怎么样？你认为这是一个好主意吗？
- en: I, me, and myself – using the self variable
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我，我自己，以及自我——使用self变量
- en: From within a class method we can refer to an instance by means of a special
    argument, called `self` by convention. `self` is always the first attribute of
    an instance method. Let's examine this behavior together with how we can share,
    not just attributes, but methods with all instances.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在类方法内部，我们可以通过一个特殊的参数来引用一个实例，这个参数按照惯例被称为`self`。`self`始终是实例方法的第一个属性。让我们一起来考察这种行为，以及我们如何共享，不仅仅是属性，还有方法给所有实例。
- en: '`oop/class.self.py`'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`oop/class.self.py`'
- en: '[PRE17]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Note how the `area` method is used by `sq`. The two calls, `Square.area(sq)`
    and `sq.area()`, are equivalent, and teach us how the mechanism works. Either
    you pass the instance to the method call (`Square.area(sq)`), which within the
    method will be called `self`, or you can use a more comfortable syntax: `sq.area()`
    and Python will translate that for you behind the curtains.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`area`方法是如何被`sq`使用的。两个调用`Square.area(sq)`和`sq.area()`是等价的，并教会我们机制是如何工作的。要么你将实例传递给方法调用（`Square.area(sq)`），在方法中它将被调用为`self`，或者你可以使用更舒适的语法：`sq.area()`，Python会为你幕后转换。
- en: 'Let''s look at a better example:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个更好的例子：
- en: '`oop/class.price.py`'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`oop/class.price.py`'
- en: '[PRE18]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The preceding code shows you that nothing prevents us from using arguments when
    declaring methods. We can use the exact same syntax as we used with the function,
    but we need to remember that the first argument will always be the instance.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码显示，我们可以在声明方法时使用参数。我们可以使用与函数相同的语法，但我们需要记住，第一个参数始终是实例。
- en: Initializing an instance
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化实例
- en: Have you noticed how, before calling `p1.final_price(...)`, we had to assign
    `net_price` to `p1`? There is a better way to do it. In other languages, this
    would be called a **constructor**, but in Python, it's not. It is actually an
    **initializer**, since it works on an already created instance, and therefore
    it's called `__init__`. It's a *magic method*, which is run right after the object
    is created. Python objects also have a `__new__` method, which is the actual constructor.
    In practice, it's not so common to have to override it though, it's a practice
    that is mostly used when coding metaclasses, which is a fairly advanced topic
    that we won't explore in the book.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 你有没有注意到，在调用`p1.final_price(...)`之前，我们必须将`net_price`分配给`p1`？有更好的方法来做这件事。在其他语言中，这会被称为**构造函数**，但在Python中不是这样。它实际上是一个**初始化器**，因为它作用于已经创建的实例，因此被称为`__init__`。它是一个**魔法方法**，在对象创建后立即运行。Python对象还有一个`__new__`方法，它是实际的构造函数。在实践中，通常不需要重写它，这是一个主要用于编写元类的实践，这是一个相当高级的话题，我们不会在本书中探讨。
- en: '`oop/class.init.py`'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`oop/class.init.py`'
- en: '[PRE19]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Things are finally starting to take shape. When an object is created, the `__init__`
    method is automatically run for us. In this case, I coded it so that when we create
    an object (by calling the class name like a function), we pass arguments to the
    creation call, like we would on any regular function call. The way we pass parameters
    follows the signature of the `__init__` method, and therefore, in the two creation
    statements, `10` and `7` will be `sideA` for `r1` and `r2` respectively, while
    `4` and `3` will be `sideB`. You can see that the call to `area()` from `r1` and
    `r2` reflects that they have different instance arguments.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 事情终于开始成形。当一个对象被创建时，`__init__`方法会自动为我们运行。在这种情况下，我编写了代码，当我们创建一个对象（通过像函数一样调用类名）时，我们向创建调用传递参数，就像在常规函数调用中做的那样。我们传递参数的方式遵循`__init__`方法的签名，因此，在两个创建语句中，`10`和`7`将分别是`r1`和`r2`的`sideA`，而`4`和`3`将是`sideB`。你可以看到，`r1`和`r2`从`area()`调用的调用反映了它们有不同的实例参数。
- en: Setting up objects in this way is much nicer and convenient.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式设置对象要更优雅、更方便。
- en: OOP is about code reuse
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 面向对象编程（OOP）是关于代码重用
- en: 'By now it should be pretty clear: *OOP is all about code reuse*. We define
    a class, we create instances, and those instances use methods that are defined
    only in the class. They will behave differently according to how the instances
    have been set up by the initializer.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在应该已经很清楚了：**面向对象编程（OOP）**完全是关于代码重用。我们定义一个类，创建实例，这些实例使用仅在类中定义的方法。它们的行为将根据初始化器如何设置实例而有所不同。
- en: Inheritance and composition
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 继承和组合
- en: 'But this is just half of the story, *OOP is much more powerful*. We have two
    main design constructs to exploit: inheritance and composition.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 但这只是故事的一半，**面向对象编程（OOP）**要强大得多。我们有两个主要的设计构造来利用：继承和组合。
- en: '**Inheritance** means that two objects are related by means of an *Is-A* type
    of relationship. On the other hand, **composition** means that two objects are
    related by means of a *Has-A* type of relationship. It''s all very easy to explain
    with an example:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '**继承**意味着两个对象通过**“是”**这种类型的关系相关联。另一方面，**组合**意味着两个对象通过**“有”**这种类型的关系相关联。用例子来解释这一切都非常简单：'
- en: '`oop/class.inheritance.py`'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`oop/class.inheritance.py`'
- en: '[PRE20]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The preceding example shows you both the *Is-A* and *Has-A* types of relationships
    between objects. First of all, let's consider `Engine`. It's a simple class that
    has two methods, `start` and `stop`. We then define `ElectricEngine` and `V8Engine`,
    which both inherit from `Engine`. You can see that by the fact that when we define
    them, we put `Engine` within the braces after the class name.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '上述示例展示了对象之间**“是”**和**“有”**两种类型的关系。首先，让我们考虑`Engine`类。它是一个简单的类，包含两个方法，`start`和`stop`。然后我们定义了`ElectricEngine`和`V8Engine`，这两个类都继承自`Engine`类。你可以看到，当我们定义它们时，我们在类名后面的大括号中放置了`Engine`。 '
- en: This means that both `ElectricEngine` and `V8Engine` inherit attributes and
    methods from the `Engine` class, which is said to be their **base class**.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着`ElectricEngine`和`V8Engine`都从`Engine`类继承属性和方法，这个类被称为它们的**基类**。
- en: The same happens with cars. `Car` is a base class for both `RaceCar` and `CityCar`.
    `RaceCar` is also the base class for `F1Car`. Another way of saying this is that
    `F1Car` inherits from `RaceCar`, which inherits from `Car`. Therefore, `F1Car`
    *Is-A* `RaceCar` and `RaceCar` *Is-A* `Car`. Because of the transitive property,
    we can say that `F1Car` *Is-A* `Car` as well. `CityCar` too, *Is-A* `Car`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 对于汽车来说，情况也是如此。`Car`是`RaceCar`和`CityCar`的基类。`RaceCar`也是`F1Car`的基类。另一种说法是，`F1Car`从`RaceCar`继承，而`RaceCar`从`Car`继承。因此，`F1Car`*是*`RaceCar`，`RaceCar`*是*`Car`。由于传递性质，我们可以说`F1Car`*是*`Car`。`CityCar`也是*是*`Car`。
- en: 'When we define `class A(B): pass`, we say `A` is the *child* of `B`, and `B`
    is the *parent* of `A`. *parent* and *base* are synonyms, as well as *child* and
    *derived*. Also, we say that a class inherits from another class, or that it extends
    it.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '当我们定义`class A(B): pass`时，我们说`A`是`B`的*子类*，而`B`是`A`的*父类*。*父类*和*基类*是同义词，同样*子类*和*派生类*也是。我们还说一个类继承自另一个类，或者扩展了它。'
- en: This is the inheritance mechanism.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是继承机制。
- en: On the other hand, let's go back to the code. Each class has a class attribute,
    `engine_cls`, which is a reference to the engine class we want to assign to each
    type of car. `Car` has a generic `Engine`, while the two race cars have a powerful
    V8 engine, and the city car has an electric one.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，让我们回到代码。每个类都有一个类属性，`engine_cls`，它是对我们想要分配给每种类型汽车的引擎类的引用。`Car`有一个通用的`Engine`，而两辆赛车都有强大的V8引擎，而城市车有一个电动引擎。
- en: When a car is created in the initializer method `__init__`, we create an instance
    of whatever engine class is assigned to the car, and set it as `engine` instance
    attribute.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当在初始化方法`__init__`中创建汽车时，我们创建一个引擎类的实例，并将其设置为`engine`实例属性。
- en: It makes sense to have `engine_cls` shared amongst all class instances because
    it's quite likely that the same instances of a car will have the same kind of
    engine. On the other hand, it wouldn't be good to have one single engine (an instance
    of any `Engine` class) as a class attribute, because we would be sharing one engine
    amongst all instances, which is incorrect.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有类实例之间共享`engine_cls`是有意义的，因为同一辆车的实例很可能具有相同类型的引擎。另一方面，将单个引擎（任何`Engine`类的实例）作为类属性是不好的，因为这会导致我们在所有实例之间共享一个引擎，这是不正确的。
- en: The type of relationship between a car and its engine is a *Has-A* type. A car
    *Has-A* engine. This is called **composition**, and reflects the fact that objects
    can be made of many other objects. A car *Has-A* engine, gears, wheels, a frame,
    doors, seats, and so on.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 汽车与其引擎之间的关系类型是*具有*类型。汽车*具有*引擎。这被称为**组合**，反映了对象可以由许多其他对象组成的事实。汽车*具有*引擎、变速箱、车轮、底盘、车门、座椅等等。
- en: When designing OOP code, it is of vital importance to describe objects in this
    way so that we can use inheritance and composition correctly to structure our
    code in the best way.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计面向对象（OOP）代码时，以这种方式描述对象至关重要，这样我们才能正确地使用继承和组合来以最佳方式构建我们的代码。
- en: 'Before we leave this paragraph, let''s check if I told you the truth with another
    example:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们离开这个段落之前，让我们用另一个例子来验证我是否告诉了您真相：
- en: '`oop/class.issubclass.isinstance.py`'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`oop/class.issubclass.isinstance.py`'
- en: '[PRE21]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As you can see, `car` is just an instance of `Car`, while `racecar` is an instance
    of `RaceCar` (and of `Car` by extension) and `f1car` is an instance of `F1Car`
    (and of both `RaceCar` and `Car`, by extension). A *banana* is an instance of
    *Banana*. But, also, it is a *Fruit*. Also, it is *Food*, right? This is the same
    concept.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`car`只是`Car`的一个实例，而`racecar`是`RaceCar`（以及通过扩展`Car`）的一个实例，`f1car`是`F1Car`（以及通过扩展`RaceCar`和`Car`）的一个实例。一个*香蕉*是*香蕉*的一个实例。但，它也是一个*水果*。也是*食物*，对吧？这是同一个概念。
- en: To check if an object is an instance of a class, use the `isinstance` method.
    It is recommended over sheer type comparison (`type(object) == Class`).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查一个对象是否是某个类的实例，请使用`isinstance`方法。它比单纯的类型比较（`type(object) == Class`）更推荐使用。
- en: 'Let''s also check inheritance, same setup, with different `for` loops:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也检查一下继承，同样的设置，使用不同的`for`循环：
- en: '`oop/class.issubclass.isinstance.py`'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`oop/class.issubclass.isinstance.py`'
- en: '[PRE22]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Interestingly, we learn that *a class is a subclass of itself*. Check the output
    of the preceding example to see that it matches the explanation I provided.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，我们了解到*一个类是其自身的子类*。检查前面示例的输出，看看它是否与我所提供的解释相符。
- en: Note
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: One thing to notice about conventions is that class names are always written
    using *CapWords*, which means *ThisWayIsCorrect*, as opposed to functions and
    methods, which are written *this_way_is_correct*. Also, when in the code you want
    to use a name which is a Python-reserved keyword or built-in function or class,
    the convention is to add a trailing underscore to the name. In the first `for`
    loop example, I'm looping through the class names using `for class_ in ...`, because
    `class` is a reserved word. But you already knew all this because you have thoroughly
    studied PEP8, right?
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 关于约定，有一点需要注意，即类名总是使用*CapWords*来书写，这意味着*ThisWayIsCorrect*，而函数和方法则是*this_way_is_correct*。此外，当你在代码中想要使用一个Python保留关键字或内置函数或类作为名称时，约定是在名称后面添加一个尾随下划线。在第一个`for`循环示例中，我使用`for
    class_ in ...`遍历类名，因为`class`是一个保留字。但因为你已经彻底研究了PEP8，所以你早就知道了这些，对吧？
- en: 'To help you picture the difference between *Is-A* and *Has-A*, take a look
    at the following diagram:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助你想象`Is-A`和`Has-A`之间的区别，看看下面的图示：
- en: '![Inheritance and composition](img/4715_06_01.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![继承与组合](img/4715_06_01.jpg)'
- en: Accessing a base class
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问基类
- en: 'We''ve already seen class declarations like `class ClassA: pass` and `class
    ClassB(BaseClassName): pass`. When we don''t specify a base class explicitly,
    Python will set the special **object** class as the base class for the one we''re
    defining. Ultimately, all classes derive from `object`. Note that, if you don''t
    specify a base class, braces are optional.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '我们已经看到了像`class ClassA: pass`和`class ClassB(BaseClassName): pass`这样的类声明。当我们没有明确指定基类时，Python会将特殊的**object**类作为我们定义的类的基类。最终，所有类都从`object`派生。注意，如果你没有指定基类，大括号是可选的。'
- en: 'Therefore, writing `class A: pass` or `class A(): pass` or `class A(object):
    pass` is exactly the same thing. *object* is a special class in that it has the
    methods that are common to all Python classes, and it doesn''t allow you to set
    any attributes on it.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '因此，编写`class A: pass`或`class A(): pass`或`class A(object): pass`是完全相同的事情。`object`是一个特殊的类，因为它拥有所有Python类共有的方法，并且不允许你对其设置任何属性。'
- en: Let's see how we can access a base class from within a class.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何在类内部访问基类。
- en: '`oop/super.duplication.py`'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`oop/super.duplication.py`'
- en: '[PRE23]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Take a look at the preceding code. I highlighted the part of `Ebook` initialization
    that is duplicated from its base class `Book`. This is quite bad practice because
    we now have two sets of instructions that are doing the same thing. Moreover,
    any change in the signature of `Book.__init__` will not reflect in `Ebook`. We
    know that `Ebook` *Is-A* `Book`, and therefore we would probably want changes
    to be reflected in the children classes.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 看看前面的代码。我突出显示了从其基类`Book`中复制的`Ebook`初始化部分。这相当糟糕的做法，因为我们现在有两套做同样事情的指令。此外，任何对`Book.__init__`签名的变化都不会反映在`Ebook`中。我们知道`Ebook`是`Book`的子类，因此我们可能希望这些变化在子类中得到反映。
- en: 'Let''s see one way to fix this issue:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一种修复这个问题的方法：
- en: '`oop/super.explicit.py`'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`oop/super.explicit.py`'
- en: '[PRE24]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Now, that's better. We have removed that nasty duplication. Basically, we tell
    Python to call the `__init__` method of the `Book` class, and we feed `self` to
    the call, making sure that we bind that call to the present instance.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这更好。我们移除了那个讨厌的重复。基本上，我们告诉Python调用`Book`类的`__init__`方法，并将`self`传递给调用，确保我们将这个调用绑定到当前实例。
- en: If we modify the logic within the `__init__` method of `Book`, we don't need
    to touch `Ebook`, it will auto adapt to the change.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们修改`Book`的`__init__`方法中的逻辑，我们不需要触摸`Ebook`，它将自动适应变化。
- en: This approach is good, but we can still do a bit better. Say that we change
    `Book`'s name to `Liber`, because we've fallen in love with Latin. We have to
    change the `__init__` method of `Ebook` to reflect the change. This can be avoided
    by using `super`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法不错，但我们还可以做得更好。比如说，我们把`Book`的名字改为`Liber`，因为我们爱上了拉丁文。我们必须更改`Ebook`的`__init__`方法来反映这一变化。这可以通过使用`super`来避免。
- en: '`oop/super.implicit.py`'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`oop/super.implicit.py`'
- en: '[PRE25]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '`super` is a function that returns a proxy object that delegates method calls
    to a parent or sibling class. In this case, it will delegate that call to `__init__`
    to the `Book` class, and the beauty of this method is that now we''re even free
    to change `Book` to `Liber` without having to touch the logic in the `__init__`
    method of `Ebook`.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`super`是一个返回代理对象的函数，该对象将方法调用委托给父类或兄弟类。在这种情况下，它将调用委托给`Book`类的`__init__`，这个方法的优点是现在我们可以自由地将`Book`改为`Liber`，而无需触及`Ebook`的`__init__`方法中的逻辑。'
- en: Now that we know how to access a base class from a child, let's explore Python's
    multiple inheritance.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何从子类访问基类，让我们来探索Python的多重继承。
- en: Multiple inheritance
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多重继承
- en: 'Apart from composing a class using more than one base class, what is of interest
    here is how an attribute search is performed. Take a look at the following diagram:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用多个基类来组合一个类之外，这里有趣的是属性搜索是如何进行的。看看下面的图示：
- en: '![Multiple inheritance](img/4715_06_02.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![多重继承](img/4715_06_02.jpg)'
- en: 'As you can see, `Shape` and `Plotter` act as base classes for all the others.
    `Polygon` inherits directly from them, `RegularPolygon` inherits from `Polygon`,
    and both `RegularHexagon` and `Square` inherit from `RegulaPolygon`. Note also
    that `Shape` and `Plotter` implicitly inherit from `object`, therefore we have
    what is called a **diamond** or, in simpler terms, more than one path to reach
    a base class. We''ll see why this matters in a few moments. Let''s translate it
    into some simple code:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，`Shape`和`Plotter`作为所有其他类的基类。`Polygon`直接从它们继承，`RegularPolygon`从`Polygon`继承，而`RegularHexagon`和`Square`都从`RegularPolygon`继承。注意，`Shape`和`Plotter`隐式地继承自`object`，因此我们有了所谓的**菱形**，或者说，有超过一条路径可以到达基类。我们将在稍后看到这为什么很重要。让我们将其翻译成一些简单的代码：
- en: '`oop/multiple.inheritance.py`'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`oop/multiple.inheritance.py`'
- en: '[PRE26]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Take a look at the preceding code: the class `Shape` has one attribute, `geometric_type`,
    and two methods: `area` and `get_geometric_type`. It''s quite common to use base
    classes (like `Shape`, in our example) to define an *interface*: methods for which
    children must provide an implementation. There are different and better ways to
    do this, but I want to keep this example as simple as possible.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 看看前面的代码：类`Shape`有一个属性`geometric_type`和两个方法：`area`和`get_geometric_type`。使用基类（如我们的例子中的`Shape`）来定义一个*接口*：子类必须提供实现的方法是很常见的。当然，有不同且更好的方法来做这件事，但我想尽量保持这个例子简单。
- en: We also have the `Plotter` class, which adds the `plot` method, thereby providing
    plotting capabilities for any class that inherits from it. Of course, the `plot`
    implementation is just a dummy `print` in this example. The first interesting
    class is `Polygon`, which inherits from both `Shape` and `Plotter`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一个`Plotter`类，它添加了`plot`方法，从而为从它继承的任何类提供了绘图功能。当然，在这个例子中，`plot`的实现只是一个简单的`print`。第一个有趣的是`Polygon`类，它从`Shape`和`Plotter`继承。
- en: There are many types of polygons, one of which is the regular one, which is
    both equiangular (all angles are equal) and equilateral (all sides are equal),
    so we create the `RegularPolygon` class that inherits from `Polygon`. Because
    for a regular polygon, all sides are equal, we can implement a simple `__init__`
    method on `RegularPolygon`, which takes the length of the side. Finally, we create
    the `RegularHexagon` and `Square` classes, which both inherit from `RegularPolygon`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 几何多边形有很多种类型，其中一种是正多边形，它既等角（所有角度相等）又等边（所有边相等），因此我们创建了继承自`Polygon`的`RegularPolygon`类。因为对于正多边形，所有边都相等，我们可以在`RegularPolygon`上实现一个简单的`__init__`方法，它接受边的长度。最后，我们创建了`RegularHexagon`和`Square`类，它们都继承自`RegularPolygon`。
- en: This structure is quite long, but hopefully gives you an idea of how to specialize
    the classification of your objects when you design the code.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结构相当长，但希望这能给你一个在设计代码时如何专门化对象分类的思路。
- en: Now, please take a look at the last eight lines. Note that when I call the `area`
    method on `hexagon` and `square`, I get the correct area for both. This is because
    they both provide the correct implementation logic for it. Also, I can call `get_geometric_type`
    on both of them, even though it is not defined on their classes, and Python has
    to go all the way up to `Shape` to find an implementation for it. Note that, even
    though the implementation is provided in the `Shape` class, the `self.geometric_type`
    used for the return value is correctly taken from the caller instance.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，请看看最后八行。注意，当我调用`hexagon`和`square`上的`area`方法时，我得到了两者的正确面积。这是因为它们都提供了正确的实现逻辑。此外，我可以在它们两个上调用`get_geometric_type`，即使这个方法没有定义在它们的类中，Python必须一直追溯到`Shape`来找到它的实现。注意，尽管实现是在`Shape`类中提供的，但用于返回值的`self.geometric_type`是正确地从调用实例中获取的。
- en: The `plot` method calls are also interesting, and show you how you can enrich
    your objects with capabilities they wouldn't otherwise have. This technique is
    very popular in web frameworks such as Django (which we'll explore in two later
    chapters), which provides special classes called **mixins**, whose capabilities
    you can just use out of the box. All you have to do is to define the desired mixin
    as one the base classes for your own, and that's it.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`plot`方法的调用也很有趣，展示了你可以如何通过这种技术丰富你的对象，使其拥有它们原本不具备的能力。这种技术在像Django这样的Web框架中非常流行（我们将在后面的两章中探讨），它提供了特殊的类，称为**混入（mixins**），你可以直接使用这些类的功能。你所要做的就是将所需的混入定义为你自己的基类之一，然后就可以了。'
- en: Multiple inheritance is powerful, but can also get really messy, so we need
    to make sure we understand what happens when we use it.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 多重继承功能强大，但也可能变得非常混乱，因此我们需要确保我们理解使用它时会发生什么。
- en: Method resolution order
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 方法解析顺序
- en: By now, we know that when you ask for `someobject.attribute`, and `attribute`
    is not found on that object, Python starts searching in the class `someobject`
    was created from. If it's not there either, Python searches up the inheritance
    chain until either `attribute` is found or the `object` class is reached. This
    is quite simple to understand if the inheritance chain is only comprised of single
    inheritance steps, which means that classes have only one parent. However, when
    multiple inheritance is involved, there are cases when it's not straightforward
    to predict what will be the next class that will be searched for if an attribute
    is not found.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们知道当你请求`someobject.attribute`，并且`attribute`没有在对象上找到时，Python会从`someobject`创建的类`someobject`开始搜索。如果那里也没有，Python会沿着继承链向上搜索，直到找到`attribute`或者到达`object`类。如果继承链只包含单继承步骤，这意味着类只有一个父类，那么这很容易理解。然而，当涉及多重继承时，有些情况下如果找不到属性，预测下一个将被搜索的类可能并不直接。
- en: 'Python provides a way to always know what is the order in which classes are
    searched on attribute lookup: the method resolution order.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: Python提供了一种方法，可以始终知道在属性查找时类被搜索的顺序：方法解析顺序。
- en: Note
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The **method resolution order** (**MRO**) is the order in which base classes
    are searched for a member during lookup. From version 2.3 Python uses an algorithm
    called **C3**, which guarantees monotonicity.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '**方法解析顺序**（**MRO**）是在查找成员时搜索基类的顺序。从版本2.3开始，Python使用一个称为**C3**的算法，它保证了单调性。'
- en: In Python 2.2, **new-style classes** were introduced. The way you write a new-style
    class in Python 2.* is to define it with an explicit `object` base class. Classic
    classes were not explicitly inheriting from `object` and have been removed in
    Python 3.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python 2.2中，引入了**新式类**。在Python 2.*中编写新式类的方法是使用显式的`object`基类定义它。经典类没有显式地从`object`继承，并且在Python
    3中被移除。
- en: One of the differences between classic and new style-classes in Python 2.* is
    that new-style classes are searched with the new MRO.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: Python 2.*中经典类和新式类之间的一个区别是，新式类使用新的MRO进行搜索。
- en: 'With regards to the previous example, let''s see what is the MRO for the `Square`
    class:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 关于前面的例子，让我们看看`Square`类的MRO是什么：
- en: '`oop/multiple.inheritance.py`'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`oop/multiple.inheritance.py`'
- en: '[PRE27]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: To get to the MRO of a class, we can go from the instance to its `__class__`
    attribute and from that to its `__mro__` attribute. Alternatively, we could have
    called `Square.__mro__`, or `Square.mro()` directly, but if you have to do it
    dynamically, it's more likely you will have an object in your hands rather than
    a class.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取类的MRO，我们可以从实例到其`__class__`属性，然后到其`__mro__`属性。或者，我们也可以直接调用`Square.__mro__`或`Square.mro()`，但如果需要动态执行，你更有可能手里有一个对象而不是一个类。
- en: Note that the only point of doubt is the bisection after `Polygon`, where the
    inheritance chain breaks into two ways, one leads to `Shape` and the other to
    `Plotter`. We know by scanning the MRO for the `Square` class that `Shape` is
    searched before `Plotter`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，唯一有疑问的地方是在`Polygon`之后的二分法，继承链分为两个方向，一个通向`Shape`，另一个通向`Plotter`。通过扫描`Square`类的MRO，我们知道`Shape`在`Plotter`之前被搜索。
- en: 'Why is this important? Well, imagine the following code:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这为什么重要呢？想象以下代码：
- en: '`oop/mro.simple.py`'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`oop/mro.simple.py`'
- en: '[PRE28]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Both `B` and `C` inherit from `A`, and `D` inherits from both `B` and `C`. This
    means that the lookup for the `label` attribute can reach the top (`A`) through
    both `B` or `C`. According to which is reached first, we get a different result.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`B` 和 `C` 都继承自 `A`，而 `D` 则继承自 `B` 和 `C`。这意味着 `label` 属性的查找可以通过 `B` 或 `C` 达到顶部（`A`）。根据哪个先到达，我们会得到不同的结果。'
- en: 'So, in the preceding example we get `''b''`, which is what we were expecting,
    since `B` is the leftmost one amongst base classes of `D`. But what happens if
    I remove the `label` attribute from `B`? This would be the confusing situation:
    Will the algorithm go all the way up to `A` or will it get to `C` first? Let''s
    find out!'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在上述例子中，我们得到 `'b'`，这正是我们所期望的，因为 `B` 是 `D` 的基类中最左边的一个。但如果我移除 `B` 中的 `label`
    属性呢？这将是一个令人困惑的情况：算法会一直向上到 `A` 吗？还是它会先到达 `C`？让我们来看看！
- en: '`oop/mro.py`'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`oop/mro.py`'
- en: '[PRE29]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: So, we learn that the MRO is `D-B-C-A-(object)`, which means when we ask for
    `d.label`, we get `'c'`, which is correct.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们了解到 MRO 是 `D-B-C-A-(object)`，这意味着当我们请求 `d.label` 时，我们得到 `'c'`，这是正确的。
- en: In day to day programming, it is not quite common to have to deal with the MRO,
    but the first time you fight against some mixin from a framework, I promise you'll
    be glad I spent a paragraph explaining it.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在日常编程中，处理 MRO 并不常见，但当你第一次与框架中的某个 mixin 作斗争时，我保证你会很高兴我花了一段文字来解释它。
- en: Static and class methods
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态和类方法
- en: 'Until now, we have coded classes with attributes in the form of data and instance
    methods, but there are two other types of methods that we can place inside a class:
    **static methods** and **class methods**.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们编写的类已经包含了以数据和实例方法形式存在的属性，但我们可以将两种其他类型的方法放入类中：**静态方法**和**类方法**。
- en: Static methods
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 静态方法
- en: As you may recall, when you create a class object, Python assigns a name to
    it. That name acts as a namespace, and sometimes it makes sense to group functionalities
    under it. Static methods are perfect for this use case since unlike instance methods,
    they are not passed any special argument. Let's look at an example of an imaginary
    `String` class.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所回忆的那样，当你创建一个类对象时，Python 会给它分配一个名称。这个名称充当一个命名空间，有时将功能分组在下面是有意义的。静态方法非常适合这种用例，因为与实例方法不同，它们没有传递任何特殊参数。让我们看看一个假设的
    `String` 类的例子。
- en: '`oop/static.methods.py`'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`oop/static.methods.py`'
- en: '[PRE30]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The preceding code is quite interesting. First of all, we learn that static
    methods are created by simply applying the `staticmethod` decorator to them. You
    can see that they aren't passed any special argument so, apart from the decoration,
    they really just look like functions.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码非常有趣。首先，我们了解到静态方法是通过简单地应用 `staticmethod` 装饰器来创建的。你可以看到它们没有传递任何特殊参数，所以除了装饰之外，它们实际上看起来就像函数一样。
- en: We have a class, `String`, which acts as a container for functions. Another
    approach would be to have a separate module with functions inside. It's really
    a matter of preference most of the time.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个名为 `String` 的类，它充当函数的容器。另一种方法是将函数放在一个单独的模块中。大多数情况下，这完全取决于个人喜好。
- en: The logic inside `is_palindrome` should be straightforward for you to understand
    by now, but, just in case, let's go through it. First we remove all characters
    from `s` that are not either letters or numbers. In order to do this, we use the
    `join` method of a string object (an empty string object, in this case). By calling
    `join` on an empty string, the result is that all elements in the iterable you
    pass to `join` will be concatenated together. We feed `join` a generator expression
    that says, *take any character from s if the character is either alphanumeric
    or a number*. I hope you have been able to find that out by yourself, maybe using
    the inside-out technique I showed you in one of the preceding chapters.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`is_palindrome` 函数内部的逻辑你现在应该已经很容易理解了，但以防万一，我们还是来过一遍。首先，我们从 `s` 中移除所有既不是字母也不是数字的字符。为了做到这一点，我们使用字符串对象的
    `join` 方法（在这个例子中是一个空字符串对象）。通过在空字符串上调用 `join`，结果是所有传递给 `join` 的可迭代对象中的元素将被连接在一起。我们给
    `join` 传递一个生成器表达式，它表示“从 s 中取出任何既是字母数字又是数字的字符”。我希望你已经自己找到了这个，也许是用我在前几章中展示的内外部技术。'
- en: We then lowercase `s` if `case_insensitive` is `True`, and then we proceed to
    check if it is a palindrome. In order to do this, we compare the first and last
    characters, then the second and the second to last, and so on. If at any point
    we find a difference, it means the string isn't a palindrome and therefore we
    can return `False`. On the other hand, if we exit the `for` loop normally, it
    means no differences were found, and we can therefore say the string is a palindrome.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`case_insensitive`为`True`，我们就会将`s`转换为小写，然后继续检查它是否是一个回文。为了做到这一点，我们比较第一个和最后一个字符，然后是第二个和倒数第二个，以此类推。如果在任何一点我们发现差异，这意味着字符串不是回文，因此我们可以返回`False`。另一方面，如果我们正常退出`for`循环，这意味着没有发现差异，因此我们可以断定字符串是回文。
- en: Notice that this code works correctly regardless of the length of the string,
    that is, if the length is odd or even. `len(s) // 2` reaches half of `s`, and
    if `s` is an odd amount of characters long, the middle one won't be checked (like
    in *RaDaR*, *D* is not checked), but we don't care; it would be compared with
    itself so it's always passing that check.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这段代码无论字符串的长度如何都能正确工作，也就是说，无论长度是奇数还是偶数。`len(s) // 2`达到`s`的一半，如果`s`的长度是奇数个字符，中间的那个字符不会被检查（比如在*RaDaR*中，*D*没有被检查），但我们并不关心；它会与自己比较，所以总是通过那个检查。
- en: '`get_unique_words` is much simpler, it just returns a set to which we feed
    a list with the words from a sentence. The `set` class removes any duplication
    for us, therefore we don''t need to do anything else.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_unique_words`要简单得多，它只是返回一个集合，我们将一个包含句子中单词的列表喂给这个集合。`set`类会为我们移除任何重复项，因此我们不需要做任何事情。'
- en: The `String` class provides us a nice container namespace for methods that are
    meant to work on strings. I could have coded a similar example with a `Math` class,
    and some static methods to work on numbers, but I wanted to show you something
    different.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`String`类为我们提供了一个很好的容器命名空间，用于那些旨在处理字符串的方法。我可以用一个`Math`类编写一个类似的例子，并添加一些用于处理数字的静态方法，但我想要展示一些不同的东西。'
- en: Class methods
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类方法
- en: Class methods are slightly different from instance methods in that they also
    take a special first argument, but in this case, it is the class object itself.
    Two very common use cases for coding class methods are to provide factory capability
    to a class and to allow breaking up static methods (which you have to then call
    using the class name) without having to hardcode the class name in your logic.
    Let's look at an example of both of them.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 类方法与实例方法略有不同，因为它们也接受一个特殊的第一个参数，但在这个情况下，它是类对象本身。编写类方法的两个非常常见的用例是为类提供工厂功能，以及允许拆分静态方法（你必须使用类名来调用它们），而无需在逻辑中硬编码类名。让我们看看这两个用例的例子。
- en: '`oop/class.methods.factory.py`'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`oop/class.methods.factory.py`'
- en: '[PRE31]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In the preceding code, I showed you how to use a class method to create a factory
    for the class. In this case, we want to create a `Point` instance by passing both
    coordinates (regular creation `p = Point(3, 7)`), but we also want to be able
    to create an instance by passing a tuple (`Point.from_tuple`) or another instance
    (`Point.from_point`).
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我向你展示了如何使用类方法来创建类的工厂。在这种情况下，我们想要通过传递两个坐标（常规创建`p = Point(3, 7)`）来创建一个`Point`实例，但我们还希望能够通过传递一个元组（`Point.from_tuple`）或另一个实例（`Point.from_point`）来创建一个实例。
- en: Within the two class methods, the `cls` argument refers to the `Point` class.
    As with instance method, which take `self` as the first argument, class method
    take a `cls` argument. Both `self` and `cls` are named after a convention that
    you are not forced to follow but are strongly encouraged to respect. This is something
    that no Python coder would change because it is so strong a convention that parsers,
    linters, and any tool that automatically does something with your code would expect,
    so it's much better to stick to it.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两个类方法中，`cls`参数指的是`Point`类。与实例方法一样，实例方法接受`self`作为第一个参数，类方法接受一个`cls`参数。`self`和`cls`都是按照一种约定来命名的，你不必强制遵循，但强烈建议你遵守。这是任何Python程序员都不会改变的事情，因为这是一个非常强的约定，解析器、linters以及任何自动处理你代码的工具都会期望，所以坚持这个约定会更好。
- en: 'Let''s look at an example of the other use case: splitting a static method.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个其他用例的例子：拆分一个静态方法。
- en: '`oop/class.methods.split.py`'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`oop/class.methods.split.py`'
- en: '[PRE32]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Compare this code with the previous version. First of all note that even though
    `is_palindrome` is now a class method, we call it in the same way we were calling
    it when it was a static one. The reason why we changed it to a class method is
    that after factoring out a couple of pieces of logic (`_strip_string` and `_is_palindrome`),
    we need to get a reference to them and if we have no `cls` in our method, the
    only option would be to call them like this: `String._strip_string(...)` and `String._is_palindrome(...)`,
    which is not good practice, because we would hardcode the class name in the `is_palindrome`
    method, thereby putting ourselves in the condition of having to modify it whenever
    we would change the class name. Using `cls` will act as the class name, which
    means our code won''t need any amendments.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 将此代码与上一个版本进行比较。首先请注意，尽管`is_palindrome`现在是一个类方法，但我们调用它的方式与它作为静态方法时相同。我们将其更改为类方法的原因是，在提取出几块逻辑（`_strip_string`和`_is_palindrome`）之后，我们需要获取它们的引用，如果没有`cls`在我们的方法中，唯一的选择就是像这样调用它们：`String._strip_string(...)`和`String._is_palindrome(...)`，这不是一个好的做法，因为我们会在`is_palindrome`方法中硬编码类名，从而使得每次我们更改类名时都必须修改它。使用`cls`将充当类名，这意味着我们的代码不需要任何修改。
- en: Note also that, by naming the *factored-out* methods with a leading underscore,
    I am hinting that those methods are not supposed to be called from outside the
    class, but this will be the subject of the next paragraph.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，通过将提取出的方法命名为前导下划线，我在暗示这些方法不应该从类外部调用，但这将是下一段的主题。
- en: Private methods and name mangling
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 私有方法和名称改写
- en: If you have any background with languages like Java, C#, C++, or similar, then
    you know they allow the programmer to assign a privacy status to attributes (both
    data and methods). Each language has its own slightly different flavor for this,
    but the gist is that public attributes are accessible from any point in the code,
    while private ones are accessible only within the scope they are defined in.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉像Java、C#、C++或类似的语言，那么你知道它们允许程序员为属性（数据和方法）分配隐私状态。每种语言都有自己略微不同的风味，但大意是公共属性可以从代码的任何位置访问，而私有属性只能在定义它们的范围内访问。
- en: In Python, there is no such thing. Everything is public; therefore, we rely
    on conventions and on a mechanism called **name mangling**.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，没有这样的事情。一切都是公开的；因此，我们依赖于约定和一种称为**名称改写**的机制。
- en: 'The convention is as follows: if an attribute''s name has no leading underscores
    it is considered public. This means you can access it and modify it freely. When
    the name has one leading underscore, the attribute is considered private, which
    means it''s probably meant to be used internally and you should not use it or
    modify it from the outside. A very common use case for private attributes are
    helper methods that are supposed to be used by public ones (possibly in call chains
    in conjunction with other methods), and internal data, like scaling factors, or
    any other data that ideally we would put in a constant (a variable that cannot
    change, but, surprise, surprise, Python doesn''t have those either).'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 约定如下：如果一个属性的名称没有前导下划线，则被认为是公开的。这意味着你可以自由地访问和修改它。当名称有一个前导下划线时，该属性被认为是私有的，这意味着它可能打算在内部使用，你不应该从外部使用或修改它。私有属性的一个非常常见的用例是辅助方法，这些方法应该由公共方法使用（可能在调用链中与其他方法一起使用），以及内部数据，如缩放因子，或任何我们理想中会放入常量（一个不能改变的变量）中的其他数据。
- en: This characteristic usually scares people from other backgrounds off; they feel
    threatened by the lack of privacy. To be honest, in my whole professional experience
    with Python, I've never heard anyone screaming *Oh my God, we have a terrible
    bug because Python lacks private attributes!* Not once, I swear.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这种特性通常会让来自其他背景的人感到害怕；他们觉得缺乏隐私是一种威胁。说实话，在我的整个Python专业经验中，我从未听说过有人尖叫着“哦，我的天哪，我们有一个可怕的错误，因为Python缺少私有属性！”我发誓，一次都没有。
- en: 'That said, the call for privacy actually makes sense because without it, you
    risk introducing bugs into your code for real. Let''s look at a simple example:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，对隐私的需求实际上是合理的，因为没有它，你真的可能会把错误引入你的代码。让我们看看一个简单的例子：
- en: '`oop/private.attrs.py`'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`oop/private.attrs.py`'
- en: '[PRE33]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In the preceding code, we have an attribute called `_factor`, and let's pretend
    it's very important that it isn't modified at runtime after the instance is created,
    because `op1` depends on it to function correctly. We've named it with a leading
    underscore, but the issue here is that when we call `obj.op2(42)`, we modify it,
    and this reflects in subsequent calls to `op1`.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们有一个名为`_factor`的属性，让我们假设它在实例创建后运行时未被修改非常重要，因为`op1`依赖于它来正确运行。我们用前导下划线命名了它，但问题在于当我们调用`obj.op2(42)`时，我们修改了它，这反映在随后的`op1`调用中。
- en: 'Let''s fix this undesired behavior by adding another leading underscore:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过添加另一个前导下划线来修复这种不希望的行为：
- en: '`oop/private.attrs.fixed.py`'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`oop/private.attrs.fixed.py`'
- en: '[PRE34]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Wow, look at that! Now it's working as desired. Python is kind of magic and
    in this case, what is happening is that the name mangling mechanism has kicked
    in.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 哇，看看这个！现在它按预期工作。Python有点神奇，在这种情况下，正在发生的是名字混淆机制已经启动。
- en: Name mangling means that any attribute name that has at least two leading underscores
    and at most one trailing underscore, like `__my_attr`, is replaced with a name
    that includes an underscore and the class name before the actual name, like `_ClassName__my_attr`.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 名字混淆意味着任何至少有两个前导下划线和最多一个尾随下划线的属性名，例如`__my_attr`，会被替换为一个包含下划线和类名的前缀的实际名称，例如`_ClassName__my_attr`。
- en: 'This means that when you inherit from a class, the mangling mechanism gives
    your private attribute two different names in the base and child classes so that
    name collision is avoided. Every class and instance object stores references to
    their attributes in a special attribute called `__dict__`, so let''s inspect `obj.__dict__`
    to see name mangling in action:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着当你从类继承时，混淆机制在基类和子类中为你的私有属性提供两个不同的名称，以避免名称冲突。每个类和实例对象都存储它们属性引用的特殊属性，称为`__dict__`，所以让我们检查`obj.__dict__`以查看名字混淆的实际操作：
- en: '`oop/private.attrs.py`'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`oop/private.attrs.py`'
- en: '[PRE35]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This is the `_factor` attribute that we find in the problematic version of
    this example. But look at the one that is using `__factor`:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们在这个示例有问题的版本中找到的`_factor`属性。但看看使用`__factor`的那个：
- en: '`oop/private.attrs.fixed.py`'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`oop/private.attrs.fixed.py`'
- en: '[PRE36]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: See? `obj` has two attributes now, `_A__factor` (mangled within the `A` class),
    and `_B__factor` (mangled within the `B` class). This is the mechanism that makes
    possible that when you do `obj.__factor = 42`, `__factor` in `A` isn't changed,
    because you're actually touching `_B__factor`, which leaves `_A__factor` safe
    and sound.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 看看？`obj`现在有两个属性了，`_A__factor`（在`A`类中混淆），和`_B__factor`（在`B`类中混淆）。这就是使得当你执行`obj.__factor
    = 42`时，`A`中的`__factor`没有被改变的原因，因为你实际上接触的是`_B__factor`，这使`_A__factor`保持安全无恙。
- en: If you're designing a library with classes that are meant to be used and extended
    by other developers, you will need to keep this in mind in order to avoid unintentional
    overriding of your attributes. Bugs like these can be pretty subtle and hard to
    spot.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在设计一个旨在被其他开发者使用和扩展的库，那么你需要记住这一点，以避免无意中覆盖你的属性。这样的错误可能相当微妙且难以发现。
- en: The property decorator
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性装饰器
- en: Another thing that would be a crime not to mention is the `property` decorator.
    Imagine that you have an `age` attribute in a `Person` class and at some point
    you want to make sure that when you change its value, you're also checking that
    `age` is within a proper range, like [18, 99]. You can write accessor methods,
    like `get_age()` and `set_age()` (also called **getters** and **setters**) and
    put the logic there. `get_age()` will most likely just return `age`, while `set_age()`
    will also do the range check. The problem is that you may already have a lot of
    code accessing the `age` attribute directly, which means you're now up to some
    good (and potentially dangerous and tedious) refactoring. Languages like Java
    overcome this problem by using the accessor pattern basically by default. Many
    Java **Integrated Development Environments** (**IDEs**) autocomplete an attribute
    declaration by writing getter and setter accessor methods stubs for you on the
    fly.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 另一件不应该被忽略的事情是 `property` 装饰器。想象一下，你有一个 `Person` 类中的 `age` 属性，在某个时刻你想要确保当你改变它的值时，你也在检查
    `age` 是否在合适的范围内，比如 [18, 99]。你可以编写访问器方法，如 `get_age()` 和 `set_age()`（也称为 **getters**
    和 **setters**），并将逻辑放在那里。`get_age()` 很可能只是返回 `age`，而 `set_age()` 将也会进行范围检查。问题是，你可能已经有很多代码直接访问
    `age` 属性，这意味着你现在需要进行一些很好的（并且可能危险且繁琐的）重构。像 Java 这样的语言通过默认使用访问器模式来克服这个问题。许多 Java
    **集成开发环境**（**IDEs**）会自动完成属性声明，并为你即时编写 getter 和 setter 访问器方法占位符。
- en: Python is smarter, and does this with the `property` decorator. When you decorate
    a method with `property`, you can use the name of the method as if it was a data
    attribute. Because of this, it's always best to refrain from putting logic that
    would take a while to complete in such methods because, by accessing them as attributes,
    we are not expecting to wait.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: Python 更聪明，它使用 `property` 装饰器来完成这项工作。当你用 `property` 装饰一个方法时，你可以像使用数据属性一样使用该方法的名称。正因为如此，最好避免在这样方法中放置需要较长时间完成逻辑，因为当我们把它们作为属性访问时，我们并不期望等待。
- en: 'Let''s look at an example:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个例子：
- en: '`oop/property.py`'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`oop/property.py`'
- en: '[PRE37]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The `Person` class may be the first version we write. Then we realize we need
    to put the range logic in place so, with another language, we would have to rewrite
    `Person` as the `PersonWithAccessors` class, and refactor all the code that was
    using `Person.age`. In Python, we rewrite `Person` as `PersonPythonic` (you normally
    wouldn't change the name, of course) so that the age is stored in a private `_age`
    variable, and we define property getters and setters using that decoration, which
    allow us to keep using the `person` instances as we were before. A **getter**
    is a method that is called when we access an attribute for reading. On the other
    hand, a **setter** is a method that is called when we access an attribute to write
    it. In other languages, like Java for example, it's customary to define them as
    `get_age()` and `set_age(int value)`, but I find the Python syntax much neater.
    It allows you to start writing simple code and refactor later on, only when you
    need it, there is no need to pollute your code with accessors only because they
    may be helpful in the future.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`Person` 类可能是我们最初编写的第一版。然后我们意识到我们需要放置范围逻辑，所以，在另一种语言中，我们不得不将 `Person` 重新编写为
    `PersonWithAccessors` 类，并重构所有使用 `Person.age` 的代码。在 Python 中，我们将 `Person` 重新编写为
    `PersonPythonic`（当然，你通常不会改变名称），这样年龄就被存储在一个私有的 `_age` 变量中，我们使用该装饰器定义属性获取器和设置器，这样我们就可以像以前一样继续使用
    `person` 实例。**获取器**是在我们访问属性进行读取时被调用的方法。另一方面，**设置器**是在我们访问属性以写入它时被调用的方法。在其他语言中，例如
    Java，通常将它们定义为 `get_age()` 和 `set_age(int value)`，但我发现 Python 的语法更整洁。它允许你开始编写简单的代码，并在需要时进行重构，没有必要因为它们可能在未来有帮助而将访问器污染你的代码。'
- en: The `property` decorator also allows for read-only data (no setter) and for
    special actions when the attribute is deleted. Please refer to the official documentation
    to dig deeper.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '`property` 装饰器还允许只读数据（没有 setter）以及在删除属性时的特殊操作。请参阅官方文档以深入了解。'
- en: Operator overloading
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运算符重载
- en: I find Python's approach to **operator overloading** to be brilliant. To overload
    an operator means to give it a meaning according to the context in which it is
    used. For example, the `+` operator means addition when we deal with numbers,
    but concatenation when we deal with sequences.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我发现 Python 对 **运算符重载** 的处理方式非常出色。重载运算符意味着根据它被使用的上下文给它一个意义。例如，当我们处理数字时，`+` 运算符表示加法，但当我们处理序列时，它表示连接。
- en: In Python, when you use operators, you're most likely calling the special methods
    of some objects behind the scenes. For example, the call `a[k]` roughly translates
    to `type(a).__getitem__(a, k)`.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，当你使用运算符时，你很可能会在幕后调用某些对象的特殊方法。例如，调用`a[k]`大致等同于`type(a).__getitem__(a,
    k)`。
- en: As an example, let's create a class that stores a string and evaluates to `True`
    if `'42'` is part of that string, and `False` otherwise. Also, let's give the
    class a length property which corresponds to that of the stored string.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们创建一个类，它存储一个字符串，如果`'42'`是该字符串的一部分，则评估为`True`，否则为`False`。此外，让我们给这个类一个长度属性，它与存储的字符串的长度相对应。
- en: '`oop/operator.overloading.py`'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '`oop/operator.overloading.py`'
- en: '[PRE38]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: That was fun, wasn't it? For the complete list of magic methods that you can
    override in order to provide your custom implementation of operators for your
    classes, please refer to the Python data model in the official documentation.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 那很有趣，不是吗？有关你可以覆盖以提供你类自定义运算符实现的完整方法列表，请参阅官方文档中的Python数据模型。
- en: Polymorphism – a brief overview
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多态——简要概述
- en: The word **polymorphism** comes from the Greek *polys* (many, much) and *morphē*
    (form, shape), and its meaning is the provision of a single interface for entities
    of different types.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 词语**多态**来源于希腊语*polys*（许多，多）和*morphē*（形式，形状），其含义是为不同类型的实体提供单一接口。
- en: In our car example, we call `engine.start()`, regardless of what kind of engine
    it is. As long as it exposes the start method, we can call it. That's polymorphism
    in action.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的汽车例子中，我们调用`engine.start()`，无论它是哪种类型的引擎。只要它公开了启动方法，我们就可以调用它。这就是多态的作用。
- en: In other languages, like Java, in order to give a function the ability to accept
    different types and call a method on them, those types need to be coded in such
    a way that they share an interface. In this way, the compiler knows that the method
    will be available regardless of the type of the object the function is fed (as
    long as it extends the proper interface, of course).
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他语言中，如Java，为了使一个函数能够接受不同类型并在它们上调用方法，这些类型需要以这种方式编码，即它们共享一个接口。这样，编译器就知道，无论函数接收的对象类型如何（只要它扩展了适当的接口，当然），该方法都将可用。
- en: In Python, things are different. Polymorphism is implicit, nothing prevents
    you to call a method on an object, therefore, technically, there is no need to
    implement interfaces or other patterns.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，情况不同。多态是隐式的，没有阻止你在对象上调用方法，因此，技术上，不需要实现接口或其他模式。
- en: 'There is a special kind of polymorphism called **ad hoc polymorphism**, which
    is what we saw in the last paragraph: operator overloading. The ability of an
    operator to change shape, according to the type of data it is fed.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种特殊的多态称为**临时多态**，这是我们上一段中看到的：运算符重载。运算符根据其接收的数据类型改变形状的能力。
- en: I cannot spend too much time on polymorphism, but I encourage you to check it
    out by yourself, it will expand your understanding of OOP. Good luck!
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我不能在多态上花费太多时间，但我鼓励你自己去探索它，这将扩展你对面向对象编程的理解。祝你好运！
- en: Writing a custom iterator
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写自定义迭代器
- en: 'Now we have all the tools to appreciate how we can write our own custom iterator.
    Let''s first define what is an iterable and an iterator:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了所有工具来欣赏我们如何编写自己的自定义迭代器。让我们首先定义什么是可迭代对象和迭代器：
- en: '**Iterable**: An object is said to be iterable if it''s capable of returning
    its members one at a time. Lists, tuples, strings, dicts, are all iterables. Custom
    objects that define either of `__iter__` or `__getitem__` methods are also iterables.'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可迭代对象**：如果一个对象能够一次返回其成员之一，那么它就被称作可迭代对象。列表、元组、字符串、字典等都是可迭代对象。定义了`__iter__`或`__getitem__`方法之一的自定义对象也是可迭代的。'
- en: '**Iterator**: An object is said to be an iterator if it represents a stream
    of data. A custom iterator is required to provide an implementation for `__iter__`
    that returns the object itself, and an implementation for `__next__`, which returns
    the next item of the data stream until the stream is exhausted, at which point
    all successive calls to `__next__` simply raise the `StopIteration` exception.
    Built-in functions such as `iter` and `next` are mapped to call `__iter__` and
    `__next__` on an object, behind the scenes.'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**迭代器**：如果一个对象代表了一串数据流，那么它就被称作迭代器。需要一个自定义迭代器来提供一个`__iter__`的实现，它返回对象本身，以及一个`__next__`的实现，它返回数据流的下一个项目，直到流耗尽，此时所有后续对`__next__`的调用都将简单地引发`StopIteration`异常。内置函数如`iter`和`next`在幕后被映射为调用对象的`__iter__`和`__next__`。'
- en: Let's write an iterator that returns all the odd characters from a string first,
    and then the even ones.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先写一个迭代器，它首先返回字符串中的所有奇数字符，然后是偶数字符。
- en: '`iterators/iterator.py`'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '`iterators/iterator.py`'
- en: '[PRE39]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: So, we needed to provide an implementation for `__iter__` which returned the
    object itself, and then one for `__next__`. Let's go through it. What needs to
    happen is that we return `_data[0]`, `_data[2]`, `_data[4]`, ..., `_data[1]`,
    `_data[3]`, `_data[5]`, ... until we have returned every item in the data. In
    order to do this, we prepare a list, indexes, like [0, 2, 4, 6, ..., 1, 3, 5,
    ...], and while there is at least an element in it, we pop the first one and return
    the element from the data that is at that position, thereby achieving our goal.
    When `indexes` is empty, we raise `StopIteration`, as required by the iterator
    protocol.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要提供一个`__iter__`的实现，它返回对象本身，然后是`__next__`的实现。让我们来分析一下。需要发生的事情是我们返回`_data[0]`、`_data[2]`、`_data[4]`、...、`_data[1]`、`_data[3]`、`_data[5]`、...，直到我们返回数据中的每个项目。为了做到这一点，我们准备了一个列表，索引，如[0,
    2, 4, 6, ..., 1, 3, 5, ...]，并且当列表中至少有一个元素时，我们弹出第一个元素，并从数据中返回该位置的元素，从而实现我们的目标。当`indexes`为空时，我们根据迭代器协议的要求抛出`StopIteration`异常。
- en: There are other ways to achieve the same result, so go ahead and try to code
    a different one yourself. Make sure the end result works for all edge cases, empty
    sequences, sequences of length 1, 2, and so on.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 有其他方法可以达到相同的结果，所以请尝试自己编写不同的代码。确保最终结果适用于所有边缘情况，空序列，长度为1、2等的序列。
- en: Summary
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we saw decorators, discovered the reasons for having them,
    and a few examples using one or more at the same time. We also saw decorators
    that take arguments, which are usually used as decorator factories.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了装饰器，发现了它们存在的原因，以及同时使用一个或多个装饰器的几个示例。我们还看到了接受参数的装饰器，这些参数通常用作装饰器工厂。
- en: We scratched the surface of object-oriented programming in Python. We covered
    all the basics in a way that you should now be able to understand fairly easily
    the code that will come in future chapters. We talked about all kinds of methods
    and attributes that one can write in a class, we explored inheritance versus composition,
    method overriding, properties, operator overloading, and polymorphism.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在Python中简要介绍了面向对象编程。我们以你应该现在能够轻松理解未来章节中的代码的方式涵盖了所有基础知识。我们讨论了一个人可以在类中编写的所有各种方法和属性，我们探讨了继承与组合、方法重写、属性、运算符重载和多态。
- en: At the end, we very briefly touched base on iterators, so now you have all the
    knowledge to also understand generators more deeply.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们非常简短地提到了迭代器，所以现在你拥有了深入了解生成器的所有知识。
- en: In the next chapter, we take a steep turn. It will start the second half of
    the book, which is much more project-oriented so, from now on, it will be less
    theory and more code, I hope you will enjoy following the examples and getting
    your hands dirty, very dirty.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将迎来一个陡峭的转折。这将开始本书的第二部分，这部分更加以项目为导向，因此从现在开始，理论将减少，代码将增多，我希望你会喜欢跟随示例，并且能够亲自动手，深入实践。
- en: They say that a smooth sea never made a skillful sailor, so keep exploring,
    break things, read the error messages as well as the documentation, and let's
    see if we can get to see that white rabbit.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 他们说，平静的海面永远不会造就一个熟练的水手，所以继续探索，打破常规，阅读错误消息以及文档，看看我们能否看到那只白兔。
