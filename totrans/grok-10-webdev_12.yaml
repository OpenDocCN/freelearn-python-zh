- en: Chapter 11. Key Concepts Behind Grok
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the first chapter of this book, we discussed the features of Grok, placing
    a strong emphasis on the importance of the **Zope Toolkit** (**ZTK**) and the
    **Zope Component Architecture** (**ZCA**). We also mentioned that Grok offers
    an agile way of using these.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout the preceding chapters, we used several ZTK packages and employed
    many ZCA patterns, introducing and explaining them, whenever needed. We also saw
    how agile Grok can be, as we grew our application bit by bit, while having a fully
    functional application from the very beginning.
  prefs: []
  type: TYPE_NORMAL
- en: With the material that we have covered so far, it's possible to create fairly
    complex applications, but to really get the most out of Grok, the concepts behind
    the ZCA and the tools that provide Grok's agility have to be explained at a more
    detailed level.
  prefs: []
  type: TYPE_NORMAL
- en: Although a full explanation of the ZCA and its patterns is beyond the scope
    of this book, this chapter will at least discuss its more important concepts and
    show their utility through small additions and extensions to our to-do list application.
    The author believes that it's easier to understand these concepts once we have
    seen practical examples of their use at work, which we can refer to when explaining
    them.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will look at these concepts in detail. In particular, we''ll
    discuss:'
  prefs: []
  type: TYPE_NORMAL
- en: What the ZCA is
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adapters, utilities, and events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application extension through events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application extension through adaptation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Zope Component Architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many agile web application frameworks were designed specifically to allow a
    quick turnaround from idea to working application. This is a good thing, but sometimes
    the emphasis on fast development cycles results in a little less attention being
    paid to things such as extensibility and code reuse. In contrast, Grok is based
    on a set of patterns whose primary concern is the maintainability and extensibility
    of applications. In fact, Grok applications can be extended even from the outside,
    without the need to touch their code. The set of patterns that allows this is
    known as the **Zope Component Architecture**.
  prefs: []
  type: TYPE_NORMAL
- en: Even though the word "Zope" is in its name, the ZCA is a set of general Python
    packages that can be used to create component-based applications, independent
    of the Zope web application server or the ZTK. In fact, we could use the ZCA to
    create any kind of Python application, and it's especially suited to the development
    of large systems.
  prefs: []
  type: TYPE_NORMAL
- en: The ZCA works by encapsulating the functionality of a Python object into an
    entity called a **component**, which has a well-defined behavior that can be described
    by using a separate object, known as an **interface**. The interface helps the
    developer to find out how to use a given component, or even replace it wholesale
    by implementing all of the functionality expressed therein.
  prefs: []
  type: TYPE_NORMAL
- en: Because the concept of breaking up the functionality of a system into multiple
    components requires the developer to keep track of a potentially large number
    of components, the ZCA offers a registry that can register and retrieve components
    based on their interfaces. This is truly the key part of the Zope Component Architecture,
    as working with it mainly consists of interacting with the registry in various
    ways.
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We introduced 'interfaces' in Chapter 5, when we used them for automatically
    generating forms. In that chapter, we explained that an interface is used to document
    the external behavior of objects.
  prefs: []
  type: TYPE_NORMAL
- en: An object that has its functionality defined in an interface is said to *provide*
    this interface. The interface defines what an object can do, but how the object
    internally complies with this contract is entirely decided by the implementor.
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces in the ZCA are used to register and find components in the registry.
    This allows us to find components on the basis of what they do, and easily replace,
    extend, or override a specific functionality in an application.
  prefs: []
  type: TYPE_NORMAL
- en: When a class includes the functionality described in an interface, it is said
    to *implement* that interface. The interface is independent of the class, though.
    One specific interface may be implemented by any number of classes. In addition,
    a class can implement any number of interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the interface that we defined in Chapter 6, to make the
    projects, lists, and items searchable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: An interface is a class that subclasses the `Interface` class defined in the
    `zope.interface` package. The `ISearchable` interface describes the attributes
    and methods that a searchable object must provide. Similar to our to-do list application,
    we may have several different content types, but as long as all of their class
    definitions promise to implement `ISearchable`, we can use the same search code
    on them without problems.
  prefs: []
  type: TYPE_NORMAL
- en: Notice how the `searchableText` method definition does not contain the `self`
    parameter that is used in Python classes. That's because although the interface
    documents the methods, it will never be instantiated itself, and so `self` is
    not required here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have defined an interface, we can create the classes that implement
    it. In our application, the `ISearchable` interface is implemented by several
    classes. For example, here''s how the `Project` content type declares its intention
    of abiding by the `ISearchable` contract:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In Grok, we use the `implements` class annotation to declare that a class implements
    one or more interfaces. We can see that, in addition to `ISearchable`, the `Project`
    class also implements `IProject` and `IMetadata`.
  prefs: []
  type: TYPE_NORMAL
- en: Once we create an actual `Project` object, it is said to *provide* `ISearchable`,
    which means that classes implement interfaces, and instances of those classes
    provide them.
  prefs: []
  type: TYPE_NORMAL
- en: 'An interface can also be used to define schemata for form generation. We have
    used this a lot throughout our application''s code. Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We already saw that by using the `grok.AutoFields` directive, we can turn this
    schema definition into HTML controls on a form.
  prefs: []
  type: TYPE_NORMAL
- en: Because interfaces are used as keys in the component registry, it's possible
    to find all of the objects that implement an interface. This comes in handy for
    finding objects belonging to some type, but can also be used for more interesting
    things, such as creating methods that work only with objects that provide an interface,
    or components that extend the functionality of any class that implements it.
  prefs: []
  type: TYPE_NORMAL
- en: This is generally useful when no special functionality needs to be defined for
    some interface, so sometimes we can come across empty interface definitions, known
    as **marker interfaces**. They basically mark an object as belonging to a certain
    type, which allows the registry to find them and register other components to
    work with them. We have not needed them so far in our application, but they can
    be a very useful addition to our arsenal.
  prefs: []
  type: TYPE_NORMAL
- en: Adapters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the principles of the ZCA is to use components instead of inheritance
    for extending application behavior, so that we can interconnect different components
    with each other to get the desired result.
  prefs: []
  type: TYPE_NORMAL
- en: 'This approach requires three things:'
  prefs: []
  type: TYPE_NORMAL
- en: Well-defined components, which is why we use interfaces. They mark a component
    as providing a specific behavior and also offer a sort of blueprint or contract
    for that functionality.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An easy way to keep track of multiple components. We already mentioned that
    the ZCA has a registry, and that interfaces are used as keys to retrieve the components
    according to their defined functionality. This also makes possible the complete
    replacement of a component for an entirely different one as long as it implements
    the same interface.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A way to make disparate components work together even if they have completely
    different interfaces. That's where adapters come in.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An **adapter** is simply a piece of code that takes an object with a certain
    interface and makes it provide an additional interface. In other words, it adapts
    the component, so that it offers new behavior, without requiring any change in
    its code.
  prefs: []
  type: TYPE_NORMAL
- en: Real-world adapters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It may be helpful to think of this in terms of real-world objects. Nowadays,
    cellphones are ubiquitous, and many people depend on them for their communication
    needs. However, they have a pretty short battery life and need constant recharging.
    When we buy a new cellphone, we usually get an AC adapter, which allows us to
    plug the phone into any wall outlet and charge it. In some cases, we may not have
    access to a wall outlet, for example, during a long car trip. In such a situation,
    we can of course get a car adapter to charge the phone by using the vehicle's
    power outlet.
  prefs: []
  type: TYPE_NORMAL
- en: Adapters for the ZCA are very similar to these phone adapters. They adapt a
    power source, be it the car or the wall outlet, and make it present in a different
    interface that can be used by the phone to get charged. Neither the power source
    nor the phone are changed in the least, or even need to know anything about the
    specific adapter used, as long as they conform to the established power and phone
    connection interfaces (now you see where the terminology came from).
  prefs: []
  type: TYPE_NORMAL
- en: Defining and using an adapter
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Up to now, we have not explicitly defined or used an adapter, so let''s take
    a quick look at how we would do this in Grok. Suppose that we want to show the
    number of days elapsed since the last modification to any content in our to-do
    list application. If we add the methods to each content type, we''ll have a lot
    of repeated code, and any change to one method''s logic would require making a
    change to all of the content types. By using an adapter, we get all of the code
    in one place, as shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: First, we define the interface for our 'day' calculation methods. We'll keep
    it simple, for demonstration purposes. The `grok.Adapter` component is used to
    define an adapter. We create one, and use the `grok.implements` directive to signal
    that it will implement the methods that we just defined in our interface.
  prefs: []
  type: TYPE_NORMAL
- en: All of the content in our application already implements the `ISearchable` interface,
    so to make every to-do application object provide this interface, we use the `grok.adapts`
    directive. Thus, `DaysOld` is an adapter that takes any object that provides `ISearchable`,
    and provides `IDayCalculations` for it.
  prefs: []
  type: TYPE_NORMAL
- en: The adapter instance will have both the `context` and the `request` attributes.
    This is because an adapter always receives, as parameters, the things that it
    adapts, in order to be able to get at their properties and use them in the implementation.
    In this example, `self.context` refers to the adapted `context` object, which
    can be a `TodoList`, a `Project`, a `TodoListItem`, and so on. As all of these
    objects implement `ISearchable`, we know that `modification_date` and `creation_date`
    will be available for the calculations.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could use this adapter inside any view for one of our content types, in
    the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we use the `update` method to insert the `days_modified` and
    `days_old` properties into the view, so that they will be available to the view
    template, when it's rendered. To get the adapter from the registry, we call the
    `IDayCalculations` interface itself, with the `context` object as parameter, which
    in this case is a `Project`. Once we have the adapter, we can simply call its
    methods, and it will behave as if these methods are a part of the `Project` component.
  prefs: []
  type: TYPE_NORMAL
- en: When first getting to know them, adapters might seem to be sort of a roundabout
    way of getting to the component that we need, but bear in mind that this whole
    system is designed for easy expansion and evolution. By using adapters, we could
    override components from within other packages and still have the system work
    fine without needing to modify the original code in any way.
  prefs: []
  type: TYPE_NORMAL
- en: Adapters that we have used in our application
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For adapters to be used in Grok, they first need to be registered with the ZCA.
    Grok itself performs a number of registrations when the application is started.
    In fact, we have used these already in our code. In Chapter 7, we added authentication
    to our application and we decided to add specific roles to every new user that
    was created, to simplify permission management.
  prefs: []
  type: TYPE_NORMAL
- en: 'A Grok site knows nothing about role assignment, so to be able to define roles
    for a principal, it uses a role manager. This **role manager** is an adapter that
    enables the site to provide the role manager interface. Take a look at the code
    that we used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are adding a new user, and immediately after that, we are assigning
    a role to the user. As we mentioned earlier, the site delegates this responsibility
    to a role manager. The role manager is an adapter that is registered as implementing
    the `IPrincipalRoleManager` interface for Grok sites, so we need to query the
    registry with this information to get the actual manager. The line that does this
    is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The interface itself performs the registry lookup, asking for a component that
    is registered for providing it to objects that implement the Grok site interface.
    Note that the Grok site itself is passed in as a parameter and not its interface,
    but the ZCA is smart enough to find the correct component, if it's registered.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the query gets us a role manager object that implements the `IPrincipalRoleManager`
    interface, so that we know that the `assignRoleToPrincipal` method will be available
    to assign the correct role to our new user.
  prefs: []
  type: TYPE_NORMAL
- en: 'Adapters can be named, so that we could use its name to get a specific `IPrincipalRoleManager`
    component. Also, it''s possible for an adapter to adapt more than one component
    at the same time, in which case, it''s called a **multiadapter**. For example,
    all of the views in Grok are multiadapters for a request and a context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The context is specified in the class body by using the `grok.context` directive,
    and the request refers to the current browser request. In the preceding code,
    `TodoListUpdateItems` is a multiadapter for a request and a `TodoList`. It uses
    the name `updateitems`. This multiadapter/view will be called by Grok only when
    the user requests the `updateitems` view while browsing through a `TodoList` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have also used multiadapters explicitly in our to-do list manager code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In Chapter 8, we showed how to get a form that is rendered inside a viewlet,
    and saw that we needed to get at the specific component that creates that specific
    form. Here, the registry lookup is performed by the `getMultiAdapter` method,
    which is imported from `zope.component`. We specifically want the 'add form' for
    a project, because we want to render the `AddProjectViewlet`. We know that we
    have a request and that the context is a `Todo` application, due to the `grok.context`
    directive above, so if we call `getMultiAdapter` and pass the request and the
    context along with the name of the required form, the ZCA machinery will find
    it for us.
  prefs: []
  type: TYPE_NORMAL
- en: Utilities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we have seen, the component registry mainly consists of adapters that are
    registered to specific interfaces. In some cases, it's also useful to register
    components that do not adapt anything, but provide some sort of service that we
    need to be able to override or replace. A database connection, an authentication
    backend, and a user source are examples of this.
  prefs: []
  type: TYPE_NORMAL
- en: The ZCA has the concept of a utility to cover this case. A **utility** is simply
    a component with a declared interface, which may also have a name. Utilities in
    the ZCA can be either local or global.
  prefs: []
  type: TYPE_NORMAL
- en: Global utilities
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A **global utility** is the one that is created and registered when Grok is
    started, but which is not persistent (that is, its state is not saved in the ZODB).
    Examples of global utilities that we have used include database connections and
    session credentials.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the utility that we added in Chapter 7, when we integrated
    authentication services into our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: To define a global utility, we inherit from the `grok.GlobalUtility` component
    and declare the interface provided by the component, by using the `grok.provides`
    directive. Named utilities also need to use the `grok.name` directive to register
    their names.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get a global utility from the registry, we use the `getUtility` function
    defined in `zope.component`. In this case, the `credentials` utility is not called
    directly by our code, but by the authentication mechanism itself. However, if
    we wanted to use this utility, we would get it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Local utilities
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A **local utility** is very similar to a global utility, but it gets saved in
    the database, so that its state and configuration are persistent. The Zope Toolkit
    catalog and the pluggable authentication mechanism used in our application are
    both examples of local utilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can take a look at the `UserAuthenticatorPlugin` that we defined in Chapter
    7, to see how to define a local utility:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that this works exactly the same way as a global utility does, except
    that we inherit from `grok.LocalUtility` instead. However, we can''t actually
    use a local utility until we explicitly add it to a `grok.Container` component.
    Take a look at the main application component for the `Todo` application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Our application contains two local utilities. There is a `UserAuthenticatorPlugin`
    utility, which is named, as we may want to work with several user sources. There
    is also a `PluggableAuthentication` utility, which will handle all of the authentication
    needs for our site, and thus does not need to be differentiated from other similar
    utilities by name.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, our application also contains a third local utility, the "Catalog",
    which is added automatically by Grok upon application creation. The Catalog is
    not a named utility.
  prefs: []
  type: TYPE_NORMAL
- en: 'To work with any of these utilities, we use the same `getUtility` function
    that we used for our global utility:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: One very important thing to keep in mind about local utilities is that, because
    they are added at an application's creation time and stored in the database, changing
    the initialization code of one will have no effect once the application is created.
    The easiest way to get a modified local utility to work, in this case, is to delete
    the application instance and create it again.
  prefs: []
  type: TYPE_NORMAL
- en: Events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Zope Toolkit defines a series of life cycle events that are fired whenever
    certain operations are performed on an object, such as creation or modification.
    An **event** can have one or more subscribers, which are called whenever the subscribed
    event takes place. These subscribers are known as **event handlers**, and Grok
    offers an easy way of defining them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some of the events that we can subscribe to by using Grok:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Event | Description | Event attributes |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `IObjectModifiedEvent` | An object has been modified. This is a general event
    that encompasses any change to a persistent object, such as adding, moving, copying,
    or removing objects. | `object``descriptions` |'
  prefs: []
  type: TYPE_TB
- en: '| `IContainerModifiedEvent` | The container has been modified. Container modifications
    are specific to addition, removal, or reordering of subobjects. Inherits from
    `grok.IObjectModifiedEvent.` | `object``descriptions` |'
  prefs: []
  type: TYPE_TB
- en: '| `IObjectMovedEvent` | An object has been moved. | `object``oldParent``oldName``newParent``newName`
    |'
  prefs: []
  type: TYPE_TB
- en: '| Event | Description | Event attributes |'
  prefs: []
  type: TYPE_TB
- en: '| `IObjectAddedEvent` | An object has been added to a container. | `object``oldParent``oldName``newParent``newName`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `IObjectCopiedEvent` | An object has been copied. | `object``original` |'
  prefs: []
  type: TYPE_TB
- en: '| `IObjectCreatedEvent` | An object has been created. This event is intended
    to happen before an object has been made persistent, that is, its location attributes
    (__name__ and `__parent__)` will usually be `None.` | `object` |'
  prefs: []
  type: TYPE_TB
- en: '| `IObjectRemovedEvent` | An object has been removed from a container. | `object``oldParent``oldName`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `IBeforeTraverseEvent` | The publisher is about to traverse an object. |
    `object``request` |'
  prefs: []
  type: TYPE_TB
- en: 'We can define an event handler in Grok by using the `grok.subscriber` decorator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This code will be executed every time a new `Project` is added to a container.
    The handler receives two parameters `obj`, which contains the object involved,
    and `event`, which contains the attributes that are listed in the preceding table.
  prefs: []
  type: TYPE_NORMAL
- en: As the subscription is really a kind of adapter, the first parameter to the
    `grok.subscribe` decorator can be any interface, thus allowing us to make the
    subscription as general or specific as we like. In the earlier example, we passed
    `Project` as a parameter, so the handler will be executed only when a `Project`
    is added, but we could pass `Interface` instead, in order to get all of the occurrences
    of the event, regardless of the object type. There can be additional subscribers
    to the same event, but the order in which they are called cannot be known in advance,
    so never depend on it.
  prefs: []
  type: TYPE_NORMAL
- en: Extending a Grok application from the outside
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Without a doubt, one of the nicest features of the Zope Component Architecture
    is that it makes it very easy to extend or override the functionality of an application
    without having to touch its code.
  prefs: []
  type: TYPE_NORMAL
- en: Many Grok components, such as views and utilities, are ready to be overriden
    without the developer having to do anything special. Other objects, such as viewlets,
    may need small modifications to add new functionality.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we are going to show, how easy it is to extend a Grok application
    from the outside, simply by creating an independent package that adds new functionality
    to our to-do application. The knowledge that we just obtained about the ZCA will
    come in handy for this task, so that hopefully we understand it a little better
    when our add-on is ready.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the original application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This demonstration will, of course, be more convincing if we keep modifications
    to the original application to a minimum. Fortunately, we need to make only one
    small addition to the `app.py` module, and a simple modification to the `navigation.pt`
    template.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following two lines at the top of `app.py`, just below the `import`
    statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This will allow us to use the master page and the form templates in the new
    application, by using a simple `import` statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'The only other change that we will make is to add an extra viewlet manager
    to the navigation viewlet, so that other applications can easily insert navigation
    options there. To do this, we need to add the viewlet manager definition to `app.py`,
    as shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to modify the navigation template to take into account the new
    viewlet manager. Change `app_templates/navigation.pt` to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The only thing that we added here is the "provider" line, to insert new viewlets
    after the link, to go back to the main page.
  prefs: []
  type: TYPE_NORMAL
- en: This is all that we need to do in order to leave the to-do application ready
    for extension by third-party packages. Of course, we could have added this code
    there from the beginning, but it's instructive to show how little code you have
    to add, even if you didn't think in terms of extensibility from the start.
  prefs: []
  type: TYPE_NORMAL
- en: The to-do plus package
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Imagine that we just found the to-do application somewhere on the net, and we
    think that it satisfies almost all of our requirements for a list manager, if
    only it had a couple of more features.
  prefs: []
  type: TYPE_NORMAL
- en: The code is available, so we could just extend the application directly. However,
    as we don't control its development, we basically are forking the code, which
    means that any new features added to the application by their original developers
    would need to be merged into our code in order for us to take advantage of them.
    Also, the code style for the original application might be different to the one
    that we are comfortable with, and we don't want to have mixed styles.
  prefs: []
  type: TYPE_NORMAL
- en: What would be best for us is to create a completely independent package that
    extends the original application, and is under our complete control. If we really
    don't need to modify the original application heavily, this is the way to go.
    Let's create a "to-do plus" package that adds a few features to the existing "to-do"
    package, which we'll declare as a dependency.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the new package
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In real life, the to-do package would be available as an "egg" that we could
    use in a new Grok project, but as we are still in the development stage here,
    we'll just add a new package to our project, instead of creating another one.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `buildout` created by the grokproject script that we used to initialize
    our project has a `src` directory to which we can add our new package. Go into
    that directory, and type the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This script will ask a few questions, but for now, you can just press the *Enter*
    key after every question, to accept the default values. A new directory, called
    `todo_plus` will be created. This directory will contain our new package.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to make sure that this package gets grokked at startup time,
    so we include `grok`, and grok the current package. As this package depends on
    the existence of the original `todo` application, we have to make sure that its
    dependencies are grokked as well. Create a `configure.zcml` file inside the `todo_plus/todo_plus`
    directory, with the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Notice that, unlike the `todo` package created for our original project, the
    `todo_plus` package has two subdirectory levels, so be careful to create this
    file inside the second level `todo_plus` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, create the `app_templates` and the `static` directories that are used
    by Grok applications:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, you must add the `todo` package to the `requires` section in the `todo_plus/setup.py`
    file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the `buildout.cfg` file needs to be updated to include the new package.
    This is how the top of the file should look after the `todo_plus` package has
    been added in the required parts (buildout will be discussed in more detail in
    Chapter 14):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In the `develop` line, we are telling `buildout` that, in addition to the package
    in the current directory (that is, the `todo` package itself), we'll be adding
    our new `todo_plus` development package. This will create a development "egg"
    for `todo_plus`, which should be added below the eggs line in the `[app]` section,
    right under the original todo package.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can rerun the `buildout` and our package will be ready to work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Adding a skin chooser form to the application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Chapter 8, we added themes to our application, although the only way to look
    at a different theme than the default was to use the ugly `++skin++` traversal
    helper in the URL. As we had mentioned then, we don't want the user to do that,
    so a way to select the desired skin from a form would be neat.
  prefs: []
  type: TYPE_NORMAL
- en: Let's make that the first feature our `todo_plus` package will add to the to-do
    list application. The objective is to have a form where we get a list of available
    screens, pick one, and then save it. After that, Grok should automatically use
    the chosen skin when we navigate through the to-do application.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a new skin
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First, we''ll have our package include its own skin layer to add to the three
    skins available in the original application. Of course, there are a few things
    we need to import from the to-do application, but it''s all very straightforward.
    Create a file named `app.py` inside the `src/todo_plus/todo_plus` directory, and
    add the following lines of code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Because we need to add a viewlet to the `HeadSlot` for this skin layer, we
    have to import it from `todo.app`. Everything else that we need, we already did
    in Chapter 8\. We add a new layer and turn it into a skin by using the `grok.skin`
    directive. After that, we add a viewlet and register it with the name ''head''
    for this layer, overriding the original viewlet from the default skin. Of course,
    we need a template for the new viewlet. Add the following code to `app_templates/head_plus`,
    at the top:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we can copy the `styles.css` file from the original app and save it
    as `styles_plus.css`. To keep it simple, as we did in Chapter 8, make some obvious
    modifications, such as changing the header background color, and leave it at that
    for now.
  prefs: []
  type: TYPE_NORMAL
- en: Restart the to-do application normally, by using paster and then navigate to
    [http://localhost/++skin++plus/todo/index](http://localhost/++skin++plus/todo/index),
    and you'll see the new skin. That's it. Not bad for a simple warm-up. Working
    from a completely separate package, we have added a new skin that transparently
    integrates with the to-do application.
  prefs: []
  type: TYPE_NORMAL
- en: The skin chooser form
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now, we are ready to add the form. We need a drop-down list with the names of
    all of the available skins, which currently are Basic (the default), martian,
    forest, and plus. We can use a `schema.Choice` field and pass these values to
    it, but then, if the original application adds a new skin or a third party comes
    up with another add-on package that has new skins, our skin list will be outdated.
    We need a dynamic way to specify the skin name values, so that we don't have to
    keep track of all of the skin names in the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, as we will frequently find out when we want to add new functionality
    to a Grok application, the Zope Toolkit already has a package called `zc.sourcefactory`
    that can help us in this situation. We can use this package by adding it to the
    `install_requires` section of the `src/todo_plus/setup.py` file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Rerun the `buildout` and the package will be downloaded and installed, as usual.
    We can now use it to define a dynamic choice field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: A **source** is simply a method that returns a list of values to be used inside
    a schema field, instead of static lists. The `BasicSourceFactory` subclass is
    used to define a source.
  prefs: []
  type: TYPE_NORMAL
- en: We have created a form schemata earlier, so the only new thing in the `ISkinChooser`
    schema definition is the `source=SkinNameSource()` parameter in the `Choice` field.
    This tells Grok to use a source factory named `SkinNameSource` to provide the
    skin name values.
  prefs: []
  type: TYPE_NORMAL
- en: To create a source, we just subclass from `BasicSourceFactory`, and add a `getValues`
    method that will return a list of the skin names. To get the skin names themselves,
    we have to use the component registry. In Zope, a skin is registered as a named
    utility with the interface `IBrowserSkinType` and the skin name.
  prefs: []
  type: TYPE_NORMAL
- en: How do we get all of the utilities registered for this interface? The `zope.component`
    package includes a function called `getAllUtilitiesRegisteredFor` that does this.
    To distinguish them from the Zope skins, Grok adds a tag to its skin components
    that identify them as Grok layers. This tag is the `grokcore.view.directive.skin`
    assigned to `skin_tag` in the preceding code. To get the Grok skin names, we start
    with a list with the value 'Basic' in it, to account for the default skin, which
    is not tagged by Grok. We then go through every registered skin and check if it
    has `skin_tag` on it. If it does, we add it to the list.
  prefs: []
  type: TYPE_NORMAL
- en: In this way, each time a new skin layer is added from a Grok package, it will
    automatically be listed in our 'skin chooser' form. The component registry takes
    care of the available skins for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we need to add the form, and also a `SkinChooser` view and a viewlet that
    includes the form on it. We have done all of this in Chapter 8, so it should seem
    familiar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The `SkinChooserForm` inherits from `grok.Form`, because we want a content-independent
    form. Its context is `ITodo` to make it show up only at the root application level.
    We use the fields defined in the `ISkinChooser` interface that we created earlier.
  prefs: []
  type: TYPE_NORMAL
- en: We need a way to store the skin selection so that it is available when the user
    navigates through the application. For this, we'll use the session mechanism that
    is defined in the `zope.app.session` package (yeah, the Zope Toolkit to the rescue,
    again). The session is an adapter for the request, so we can get it by issuing
    an `ISession(self.request)`. We use the `todo_plus` package name as a session
    key to avoid namespace clashes with other session objects.
  prefs: []
  type: TYPE_NORMAL
- en: In the `updateWidgets` method of the form, we try to get the value for `skin_name`
    from the session ('Basic' is returned, if `skin_name` has not been initialized).
    With this value, we can show the currently selected skin on the form by calling
    `setRenderedValue` on the choice widget.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, in the form action, we set the `skin_name` key of our session to the
    value returned in the form data submitted by the user, and redirect the user to
    the 'skin chooser' view.
  prefs: []
  type: TYPE_NORMAL
- en: '![The skin chooser form](img/7481_11_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The view and viewlet definitions contain nothing new, but notice how we use
    the components imported from the original to-do application to perform our registrations.
    The view is assigned `ITodo` as its context, and the viewlet is registered with
    the Main viewlet manager from that package.
  prefs: []
  type: TYPE_NORMAL
- en: Using events to show the selected skin
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So far, we have a `skin_chooser` form that can save the chosen skin name in
    the current session, but we still need to use that name to set the skin automatically
    on every page view. To do this, we will take advantage of Grok's event functionality,
    which is discussed in *The Zope Component Architecture* section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The ZCA provides an event registered with the interface `IBeforeTraverseEvent`
    that we can use to set the skin on every request. Grok has a very convenient `grok.subscribe`
    decorator that allows us to easily add a handler for this event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We register the `ITodo` interface with the `IBeforeTraverse` event, which means
    that just before Grok shows a view inside the to-do application instance, our
    `choose_skin` handler will be called.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the handler, we get the session object and find the skin name that is
    currently selected for that browser session. We then use the `getUtility` function
    to get the actual skin object by using this name, and then set the skin by using
    the `applySkin` function, which is imported from `zope.publisher.browser`. The
    result is that the chosen skin will be set just in time, before a page is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: Sending e-mail notifications on content creation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One feature that is usually requested in multiuser systems, where users can
    act on other users' content, is e-mail notification of changes. Our to-do plus
    package will surely earn its 'plus' moniker if we add such a feature to it.
  prefs: []
  type: TYPE_NORMAL
- en: We'll need a form for setting the notification properties, such as the destination
    e-mail and message subject. Of course, to keep the site layout consistent, we
    must also do our usual form-inside-a-viewlet registration dance. These are things
    that we already know how to do. More interesting is how we'll set up our e-mail
    handler by using an event subscription, and how the actual e-mail will be sent.
    Let's get going.
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, this feature will send notification messages to a specified list of
    e-mails, whenever a project is created. For this, we first need an interface definition
    for the form schema:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The `enabled` field will allow the manager to turn notifications on or off.
    If they are turned on, an e-mail with the specified message and `subject` field
    information will be sent to the list of e-mails specified in the `emails` field.
  prefs: []
  type: TYPE_NORMAL
- en: Object annotations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before we proceed with the form definition, we need to decide how to store the
    notification properties. We can't use the session, as we did with the skin chooser,
    because the notification properties will be global for the application. In fact,
    they could be considered as a part of the `Todo` instance itself, so the ideal
    thing would be to store them there. But that would require changing the original
    code to add these properties, right?
  prefs: []
  type: TYPE_NORMAL
- en: Well, no. Grok offers a special component called `annotation` that can be used
    to store information inside a specific context object, without needing to alter
    it directly. This is accomplished by using a persistent adapter registered for
    the context object. That is, behind the scenes, there is an `IAnnotation` interface
    that provides this writing service to any objects in the registry that implement
    the `IAnnotatable` interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'As usual, Grok simplifies the setup with a convenient component that we can
    subclass, called `grok.Annotation`. As discussed earlier, let''s register our
    `annotation` component to the main application''s `ITodo` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The `grok.context` directive indicates that annotations will be added to a component
    with the `ITodo` interface, which we know is the main application object. The
    `grok.implements` directive tells Grok to register this annotation adapter with
    the `ISetNotifications` interface, which is how we'll find it in the registry.
    Notice that this interface is the same as the one that we'll use in the 'notification
    properties' form. The variables defined after that represent the default values
    for the stored properties.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the form
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As we now know where the properties will be stored, we can go ahead and create
    the form. The code for the form definition looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: We use the `grok.AutoFields` directive to construct a form automatically, by
    using the fields that we previously defined in the `ISetNotifications` interface.
    As with the `skin_chooser` form, we use the form template imported from the original
    application, in order to keep the look and feel of the site, the same.
  prefs: []
  type: TYPE_NORMAL
- en: In the `setUpWidgets` method, we get the `annotation` object with the `ISetNotifications(self.context)`
    call, which searches the registry for an adapter that implements `ISetNotification`
    and that is registered for the current context, which is the `todo` application.
    Once we have that, we use the `setRenderedValue` method of each widget to make
    the form show the currently stored value when the form is displayed. We also alter
    the size of the various text fields (although, at the moment, this is not important).
  prefs: []
  type: TYPE_NORMAL
- en: In the `set_options` form submit handler, we fetch the annotation object again,
    but this time we store the submitted values inside their corresponding properties.
    After that, we just redirect the user to the same form.
  prefs: []
  type: TYPE_NORMAL
- en: 'All that''s left is to insert the form into a viewlet, and then add that viewlet
    to the `Main` viewlet manager in a view. The code for that is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'There is nothing new here. Just note that the permission to add projects will
    be required to edit the "e-mail notification" properties. The following screenshot
    shows the form in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the form](img/7481_11_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Sending the e-mail
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To send the e-mail, we need an e-mail delivery mechanism. Of course, the Zope
    Toolkit has a package called `zope.sendmail` that does this, so we just need to
    add this to our `setup.py`, file and then rerun the `buildout`, in order to use
    it. Edit the `setup.py` file, and add it to the `install_requires` line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Rerun the `buildout`. Now, we have to configure the mail delivery service.
    Unlike the Grok packages that we have used so far, this Zope Toolkit package requires
    configuration by using ZCML the XML-based Zope configuration language. Open the
    `configure.zcml` file in the `todo_plus` package, and modify it to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Note the addition of the `mail` namespace at the top of the file. This allows
    us to use the mail directives that appear after the normal Grok configuration.
    The `smtpMailer` directive represents a named SMTP server. Its parameters are
    `host, port, username`, and `password`. If your mail host does not require a password,
    simply omit the `username` and `password` parameters.
  prefs: []
  type: TYPE_NORMAL
- en: The `queuedDelivery` directive sets up a queue to use to send the mail messages.
    This gets done in an independent thread to allow the application to keep working
    even when numerous e-mails are sent. The `permission` argument refers to the permission
    needed for sending e-mails. Be sure to use the same name for the `mailer` parameter
    that was used in the SMTP mailer definition, above.
  prefs: []
  type: TYPE_NORMAL
- en: Now we are ready to register the event for sending the e-mail. We'll use the
    `grok.subscribe` directive to register our handler with the `IObjectAddedEvent`
    of `Project` objects.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The handler first finds the `annotation` object and checks the value of the
    `enabled` property. If it's `False`, the method just returns without doing anything
    else; if it's `True`, we get the property values and compose the message with
    the help of the Python e-mail module. One simple trick that we use here is to
    allow the message to insert the title, creator, and description of the newly created
    project by using simple string substitutions. Take a look at the screenshot under
    the *Creating a form* section of this chapter, to see how this works.
  prefs: []
  type: TYPE_NORMAL
- en: The `zope.sendmail` package registers the mailer utility by using an interface
    named `IMailDelivery`, so we import this and use the `getUtility` function from
    `zope.component` to find it and finally send the e-mail.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying additional navigation links
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, the to-do application has 'user management' and 'skin chooser' forms,
    but they don't show up in the site navigation. We have a viewlet manager set up
    for that in our original application, so we just need to register a viewlet with
    that manager and add a template, and we are done. This will demonstrate how easy
    it is to insert arbitrary page fragments in Grok, when the original views plan
    for it carefully.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add two viewlets one for regular user options, and one for manager-only
    options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Both of these viewlets are registered with the `ExtraNav` viewlet manager from
    the to-do application, but one requires only the `todo.changeitems` permission,
    while the other needs the `zope.ManageApplication` permission, which is usually
    assigned to the site manager. The page templates just include a couple of links.
    First, inside `manageroptions.pt`, we have:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: That's right, just a link to the `userlist` view, which will be inserted in
    the correct place by the viewlet manager.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other template, `useroptions.pt`, is almost as simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: That's all that is needed. You can see the result in the navigation section
    of the previous two screenshots of this chapter. The nice thing about this is
    that other third-party packages can add a navigation link as well, and this would
    be transparently integrated with the existing navigation options, without even
    having to know about the existence of these other packages.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter discussed the main concepts behind the Zope Component Architecture,
    and showed how to use some of the ZCA's patterns to extend our application. Most
    importantly, we showed how to extend a package without touching its code. In the
    next chapter, we'll see how Grok uses a library called Martian to permit agile
    configuration, and learn how to benefit from it, for our own work.
  prefs: []
  type: TYPE_NORMAL
