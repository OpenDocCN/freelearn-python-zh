<html><head></head><body>
  <div id="sbo-rt-content"><div class="chapter" title="Chapter 8. Extending unittest with nose2"><div class="titlepage"><div><div><h1 class="title"><a id="ch08"/>Chapter 8. Extending unittest with nose2</h1></div></div></div><p>So far we have been using the <code class="literal">unittest</code> test runner to run our tests. There are a number of other third-party test runners that have been created by the Python community. One of the most popular ones is<a id="id359" class="indexterm"/> nose2. nose2 provides additional features that improve on the default test runner.</p><div class="section" title="Getting started with nose2"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec57"/>Getting started with nose2</h1></div></div></div><p>Installing nose2 is <a id="id360" class="indexterm"/>a breeze. The easiest way to install it is via pip with the<a id="id361" class="indexterm"/> following command:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>pip install nose2</strong></span>
</pre></div><p>Let us now run our tests using nose2. From the stock alerter project directory, run the <code class="literal">nose2</code> command (we might have to add it to the path first). nose2 has test autodiscovery by default, so just running the command should give the following output:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>...............................................................</strong></span>
<span class="strong"><strong>----------------------------------------------------------------------</strong></span>
<span class="strong"><strong>Ran 63 tests in 0.109s</strong></span>

<span class="strong"><strong>OK</strong></span>
</pre></div><p>As we can see, the <code class="literal">nose2</code> command gives the same output as <code class="literal">unittest</code>. nose2 which also discovered the same tests and ran them. By default, nose2 autodiscover patterns are compatible with <code class="literal">unittest</code>, so we can just drop in nose2 as a replacement runner without changing any code.</p></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Writing tests for nose2"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec58"/>Writing tests for nose2</h1></div></div></div><p>Apart from<a id="id362" class="indexterm"/> picking up the existing tests written with the <code class="literal">unittest</code> module and running them, nose2 also supports new ways of writing tests.</p><p>To start with, nose2 allows tests to be regular functions. We don't need to create a class and inherit it from any base class. As long as the function starts with the word <code class="literal">test</code>, it is considered a <a id="id363" class="indexterm"/>test and executed.</p><p>We can take the following test:</p><div class="informalexample"><pre class="programlisting">class StockTest(unittest.TestCase):
    def setUp(self):
        self.goog = Stock("GOOG")

    def test_price_of_a_new_stock_class_should_be_None(self):
        self.assertIsNone(self.goog.price)</pre></div><p>And write the above test as follows:</p><div class="informalexample"><pre class="programlisting">def test_price_of_a_new_stock_class_should_be_None():
    goog = Stock("GOOG")
    assert goog.price is None</pre></div><p>As we can see, writing tests this way reduces some of the boilerplate code that we had to do before:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We no longer have to create a class to hold the tests in</li><li class="listitem" style="list-style-type: disc">We no longer have to inherit from any base class</li><li class="listitem" style="list-style-type: disc">We don't even have to import the <code class="literal">unittest</code> module</li></ul></div><p>We just write the tests as regular functions, and nose2 will autodiscover and run the tests.</p><p>Apart from moving the test to a regular function, there is one other change that we have made, and this is the way we are asserting on the expected result.</p><p>Previously, we did:</p><div class="informalexample"><pre class="programlisting">self.assertIsNone(self.goog.price)</pre></div><p>When the test is a function, we do the following:</p><div class="informalexample"><pre class="programlisting">assert goog.price is None</pre></div><p>Why this change? The <code class="literal">unittest.TestCase</code> class provides a lot of built-in assertion methods. When we inherit from this class, we can use those methods in our tests. When we write tests as a function, we no longer have access to those methods. Fortunately, nose2 supports Python's in-built <code class="literal">assert</code> statement, so we can just use that in our test.</p><p>The <code class="literal">assert</code> statement also supports taking a message parameter like the following:</p><div class="informalexample"><pre class="programlisting">assert goog.price is None, "Price of a new stock should be None"</pre></div><p>If a test fails, the message will be printed to the output as follows:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>======================================================================</strong></span>
<span class="strong"><strong>FAIL: stock_alerter.tests.test_stock.FunctionTestCase (test_price_of_a_new_stock_class_should_be_None)</strong></span>
<span class="strong"><strong>----------------------------------------------------------------------</strong></span>
<span class="strong"><strong>Traceback (most recent call last):</strong></span>
<span class="strong"><strong>  ...</strong></span>
<span class="strong"><strong>    assert goog.price is None, "Price of a new stock should be None"</strong></span>
<span class="strong"><strong>AssertionError: Price of a new stock should be None</strong></span>

<span class="strong"><strong>----------------------------------------------------------------------</strong></span>
</pre></div><div class="section" title="Setup and teardown"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec59"/>Setup and teardown</h2></div></div></div><p>nose2 also supports <a id="id364" class="indexterm"/>setup and teardown for function-style<a id="id365" class="indexterm"/> test cases. This is done by setting the <code class="literal">setup</code> and <code class="literal">teardown</code> attributes on the <span class="emphasis"><em>function object</em></span>. It works as follows:</p><div class="informalexample"><pre class="programlisting">def setup_test():
    global goog
    goog = Stock("GOOG")

def teardown_test():
    global goog
    goog = None

def test_price_of_a_new_stock_class_should_be_None():
    assert goog.price is None, "Price of a new stock should be None"

test_price_of_a_new_stock_class_should_be_None.setup = setup_test
test_price_of_a_new_stock_class_should_be_None.teardown = \ teardown_test</pre></div><p>Setup and teardown is limited with function-style tests in the sense that there is no way to pass state from the <code class="literal">setup</code> function to the test case and the teardown function. This is the reason why we have to declare that <code class="literal">goog</code> variable in the setup as global. This is the only way we can access it in the test case and the teardown function.</p></div><div class="section" title="Parameterized tests"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec60"/>Parameterized tests</h2></div></div></div><p>nose2 also<a id="id366" class="indexterm"/> supports parameterized tests. Also called<a id="id367" class="indexterm"/> data-driven tests, these are nothing but running the same test with different combinations of data.</p><p>Take a look at the following three tests that we wrote earlier:</p><div class="informalexample"><pre class="programlisting">class StockTrendTest(unittest.TestCase):
    def setUp(self):
        self.goog = Stock("GOOG")

    def given_a_series_of_prices(self, prices):
        timestamps = [datetime(2014, 2, 10), datetime(2014, 2, 11),
                      datetime(2014, 2, 12), datetime(2014, 2, 13)]
        for timestamp, price in zip(timestamps, prices):
            self.goog.update(timestamp, price)

    def test_increasing_trend_true_if_price_increase_for_3_updates(self):
        self.given_a_series_of_prices([8, 10, 12])
        self.assertTrue(self.goog.is_increasing_trend())

    def test_increasing_trend_is_false_if_price_decreases(self):
        self.given_a_series_of_prices([8, 12, 10])
        self.assertFalse(self.goog.is_increasing_trend())

    def test_increasing_trend_is_false_if_price_equal(self):
        self.given_a_series_of_prices([8, 10, 10])
        self.assertFalse(self.goog.is_increasing_trend())</pre></div><p>By<a id="id368" class="indexterm"/> parameterizing the test, we can write it like the<a id="id369" class="indexterm"/> following:</p><div class="informalexample"><pre class="programlisting">from nose2.tools.params import params

def given_a_series_of_prices(stock, prices):
    timestamps = [datetime(2014, 2, 10), datetime(2014, 2, 11),
                  datetime(2014, 2, 12), datetime(2014, 2, 13)]
    for timestamp, price in zip(timestamps, prices):
        stock.update(timestamp, price)

@params(
    ([8, 10, 12], True),
    ([8, 12, 10], False),
    ([8, 10, 10], False)
)
def test_stock_trends(prices, expected_output):
    goog = Stock("GOOG")
    given_a_series_of_prices(goog, prices)
    assert goog.is_increasing_trend() == expected_output</pre></div><p>The <code class="literal">params</code> decorator allows us to specify a series of different inputs. The test is run once with each input. An input is a tuple where each element of the tuple is passed to the test function as a parameter. In the example above, the test will first be run with <span class="emphasis"><em>prices=[8, 10, 12], expected_output=True</em></span>, then again with <span class="emphasis"><em>prices=[8, 12, 10], expected_output=False</em></span>, and so on.</p><p>When a test fails, the output looks like the following:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>======================================================================</strong></span>
<span class="strong"><strong>FAIL: stock_alerter.tests.test_stock.test_stock_trends:2</strong></span>
<span class="strong"><strong>[8, 12, 10], True</strong></span>
<span class="strong"><strong>----------------------------------------------------------------------</strong></span>
<span class="strong"><strong>Traceback (most recent call last):</strong></span>
<span class="strong"><strong>  ...</strong></span>
<span class="strong"><strong>    assert goog.is_increasing_trend() == expected_output</strong></span>
<span class="strong"><strong>AssertionError</strong></span>

<span class="strong"><strong>======================================================================</strong></span>
</pre></div><p>nose2 gives the<a id="id370" class="indexterm"/> parameter number that failed as <code class="literal">:2</code> and<a id="id371" class="indexterm"/> underneath the exact data that was passed to the test.</p><p>Parameterized tests are a great way to reduce repetitive tests, where we are doing the same sequence of steps, with different data each time.</p></div><div class="section" title="Generated tests"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec61"/>Generated tests</h2></div></div></div><p>Apart from<a id="id372" class="indexterm"/> parameterized tests, nose2 also supports <a id="id373" class="indexterm"/>generated tests. This is similar to parameterized tests. The difference is that parameterized tests have all the inputs hardcoded while writing the test, whereas they can be created at run time in generated tests.</p><p>The following is an example to clarify:</p><div class="informalexample"><pre class="programlisting">def test_trend_with_all_consecutive_values_upto_100():
    for i in range(100):
        yield stock_trends_with_consecutive_prices, [i, i+1, i+2]

def stock_trends_with_consecutive_prices(prices):
    goog = Stock("GOOG")
    given_a_series_of_prices(goog, prices)
    assert goog.is_increasing_trend()</pre></div><p>When we run the above test, we see that a hundred tests have been run. What is going on here? Let us look at it in a little more detail.</p><p>Unlike a regular test function, this one yields a value, making it a generator function. The <code class="literal">yield</code> statement returns the function to be executed followed by the data to be passed to the function. Each time through the loop, the test function yields, and the yielded function is executed with the corresponding parameters. Since the loop runs a hundred times, a hundred tests are generated and executed.</p><p>When a test fails, the following output is shown:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>======================================================================</strong></span>
<span class="strong"><strong>FAIL: stock_alerter.tests.test_stock.test_trend_with_all_consecutive_values_upto_100:100</strong></span>
<span class="strong"><strong>[99, 100, 100]</strong></span>
<span class="strong"><strong>----------------------------------------------------------------------</strong></span>
<span class="strong"><strong>Traceback (most recent call last):</strong></span>
<span class="strong"><strong>  ...</strong></span>
<span class="strong"><strong>    assert goog.is_increasing_trend()</strong></span>
<span class="strong"><strong>AssertionError</strong></span>

<span class="strong"><strong>----------------------------------------------------------------------</strong></span>
</pre></div><p>Like <a id="id374" class="indexterm"/>with the parameterized tests, the output shows the test<a id="id375" class="indexterm"/> number that failed along with the exact inputs that were used to execute the test.</p></div><div class="section" title="Layers"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec62"/>Layers</h2></div></div></div><p>If we <a id="id376" class="indexterm"/>look at the tests for our <code class="literal">Stock</code> class, we see that we have created three<a id="id377" class="indexterm"/> test classes: <code class="literal">StockTest</code>, <code class="literal">StockTrendTest</code>, and <code class="literal">StockCrossOverSignalTest</code>. All the three classes have some repetition in the <code class="literal">setUp</code> code, as shown in the following:</p><div class="informalexample"><pre class="programlisting">class StockTest(unittest.TestCase):
    def setUp(self):
        self.goog = Stock("GOOG")

class StockCrossOverSignalTest(unittest.TestCase):
    def setUp(self):
        self.goog = Stock("GOOG")</pre></div><p>What if we could share part of the setup between them?</p><p>nose2 has another way to write tests called <span class="strong"><strong>Layers</strong></span>. Layers allow us to organize our tests hierarchically. The following is an example of some of the <code class="literal">Stock</code> tests rewritten using Layers:</p><div class="informalexample"><pre class="programlisting">from nose2.tools import such

with such.A("Stock class") as it:

    @it.has_setup
    def setup():
        it.goog = Stock("GOOG")

    with it.having("a price method"):
        @it.has_setup
        def setup():
            it.goog.update(datetime(2014, 2, 12), price=10)

        @it.should("return the price")
        def test(case):
            assert it.goog.price == 10

        @it.should("return the latest price")
        def test(case):
            it.goog.update(datetime(2014, 2, 11), price=15)
            assert it.goog.price == 10

    with it.having("a trend method"):
        @it.should("return True if last three updates were increasing")
        def test(case):
            it.goog.update(datetime(2014, 2, 11), price=12)
            it.goog.update(datetime(2014, 2, 12), price=13)
            it.goog.update(datetime(2014, 2, 13), price=14)
            assert it.goog.is_increasing_trend()

    it.createTests(globals())</pre></div><p>The entire <a id="id378" class="indexterm"/>syntax is new, so let us look at it carefully.</p><p>First, we need <a id="id379" class="indexterm"/>to import <code class="literal">such</code>. <span class="strong"><strong>Such</strong></span> is the name of a domain specific language that makes it easy to write tests using nose2 layers. The following line imports it for us:</p><div class="informalexample"><pre class="programlisting">from nose2.tools import such</pre></div><p>Next, we set up the top most layer as follows:</p><div class="informalexample"><pre class="programlisting">with such.A("Stock class") as it:</pre></div><p>A layer can contain setup and teardown functions, test cases, and sub-layers. Such uses Python's context manager syntax to define a layer. We define the top topmost layer using the <code class="literal">such.A</code> method. It might sound strange to name a method as <code class="literal">A</code>, but the name has been chosen so that reading the line sounds natural to an English speaker. <code class="literal">such.A</code> takes a string as a parameter. This is just a descriptive string for the tests to follow.</p><p>The output of <code class="literal">such.A</code> is assigned to a variable. By convention it is called <code class="literal">it</code>, again the name being chosen so that the following usage will be like English sentences.</p><p>Having created the topmost layer, we then create the setup function for the layer, as shown in the following:</p><div class="informalexample"><pre class="programlisting">    @it.has_setup
    def setup():
        it.goog = Stock("GOOG")</pre></div><p>The name of the function can be anything, we just need to mark it as the setup function by decorating it with the <code class="literal">has_setup</code> decorator. This decorator is a method of the <code class="literal">it</code> object, hence we write <code class="literal">@it.has_setup</code>. Similarly, we can use the <code class="literal">has_teardown</code> decorator to<a id="id380" class="indexterm"/> mark a function to be used for teardown.</p><p>In the <code class="literal">setup</code> function, we <a id="id381" class="indexterm"/>can store any stateful information as attributes of the <code class="literal">it</code> object. These can be referenced in sub-layers or in test cases.</p><p>Next, we create a sub-layer by calling the having method, as shown in the following:</p><div class="informalexample"><pre class="programlisting">with it.having("a price method"):</pre></div><p>Again, this is a context manager, so we use it with the <code class="literal">with</code> statement. Unlike the top level layer, we don't need to assign it to any variable.</p><p>The sub-layer then defines its own setup function, as shown in the following:</p><div class="informalexample"><pre class="programlisting">        @it.has_setup
        def setup():
            it.goog.update(datetime(2014, 2, 12), price=10)</pre></div><p>This <code class="literal">setup</code> function is called in addition to the setup function of the parent layer.</p><p>Next, we create a test case, as shown in the following:</p><div class="informalexample"><pre class="programlisting">        @it.should("return the price")
        def test(case):
            assert it.goog.price == 10</pre></div><p>Test cases are marked using the <code class="literal">should</code> decorator. The decorator takes a description string which explains the test.</p><p>We continue with the same syntax to create another test, as shown in the following:</p><div class="informalexample"><pre class="programlisting">        @it.should("return the latest price")
        def test(case):
            it.goog.update(datetime(2014, 2, 11), price=15)
            assert it.goog.price == 10</pre></div><p>That ends the sub-layer. Back in the top layer, we create a second sub-layer to hold the tests for the <code class="literal">is_increasing_trend</code> function, as shown in the following:</p><div class="informalexample"><pre class="programlisting">    with it.having("a trend method"):
        @it.should("return True if last three updates were increasing")
        def test(case):
            it.goog.update(datetime(2014, 2, 11), price=12)
            it.goog.update(datetime(2014, 2, 12), price=13)
            it.goog.update(datetime(2014, 2, 13), price=14)
            assert it.goog.is_increasing_trend()</pre></div><p>Finally, we call the <code class="literal">createTests</code> method to convert all this code into test cases, as shown in the following:</p><div class="informalexample"><pre class="programlisting">    it.createTests(globals())</pre></div><p>The <code class="literal">createTests</code> method should be called at the end of the topmost layer. It takes a single <a id="id382" class="indexterm"/>parameter of the current <code class="literal">globals</code>.</p><p>If the <code class="literal">createTests</code> method<a id="id383" class="indexterm"/> is not called, none of the tests will be executed.</p><p>Let us now run the tests. Layers is actually implemented as a nose2 plugin, so we need to use the following command to enable the plugin and run the tests:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>nose2 --plugin nose2.plugins.layers</strong></span>
</pre></div><p>When we do this, the three tests written using Layers are executed along with all the other tests.</p><p>We can get nicer output by also enabling the Layer Reporter plugin with the following command:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>nose2 --plugin nose2.plugins.layers --layer-reporter -v</strong></span>
</pre></div><p>We now get the output like the following:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>A Stock class</strong></span>
<span class="strong"><strong>  having a price method</strong></span>
<span class="strong"><strong>    should return the price ... ok</strong></span>
<span class="strong"><strong>    should return the latest price ... ok</strong></span>
<span class="strong"><strong>  having a trend method</strong></span>
<span class="strong"><strong>    should return True if last three updates were increasing ... ok</strong></span>
</pre></div><p>The descriptive strings that we gave for the Layers and tests are outputted here. When written well, the text should be readable as regular English sentences.</p><p>As we can see, Layers allow us to organize tests logically, sharing fixtures between parent and child. A layer can have any number of sub-layers and those, in turn, can contain further layers.</p><p>Let us quickly summarize what we have just learned:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">such.A</code>: This is used as a context manager to create the topmost layer.</li><li class="listitem" style="list-style-type: disc"><code class="literal">it.has_setup</code>: This is a decorator to mark a setup function for a layer.</li><li class="listitem" style="list-style-type: disc"><code class="literal">it.has_teardown</code>: This is a decorator to mark a teardown function for a layer.</li><li class="listitem" style="list-style-type: disc"><code class="literal">it.having</code>: This is used as a context manager to create a sub-layer.</li><li class="listitem" style="list-style-type: disc"><code class="literal">it.should</code>: This is a decorator to mark a test case.</li><li class="listitem" style="list-style-type: disc"><code class="literal">it.createTests</code>: This is a method that converts all the Layers code into test cases. Call it<a id="id384" class="indexterm"/> as the last line of code in the topmost layer, passing<a id="id385" class="indexterm"/> in <code class="literal">globals()</code>.</li></ul></div></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="nose2 plugins"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec59"/>nose2 plugins</h1></div></div></div><p>In the previous<a id="id386" class="indexterm"/> section, we saw how we needed to enable the Layers plugin<a id="id387" class="indexterm"/> before we could run our layer tests. nose2 comes with a large set of plugins that enhance or extend its behavior. In fact, support for all the parameterized tests and generated tests that we saw earlier are actually implemented as nose2 plugins. The difference is that parameterized and generated tests are loaded by default, so we didn't need to explicitly enable them.</p><p>In this section, we'll take a look at some of the popular plugins. Keep in mind that there are many more plugins that we aren't going to discuss here.</p><div class="section" title="Doctest support"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec63"/>Doctest support</h2></div></div></div><p>If we have not integrated doctests into the unittest framework as described in the previous chapter, then <a id="id388" class="indexterm"/>we can configure nose2 to autodiscover <a id="id389" class="indexterm"/>and run doctests.</p><p>Activate the plugin with the following command:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>nose2 --plugin nose2.plugins.doctests --with-doctest</strong></span>
</pre></div><p>This will autodiscover and run doctests along with all the other kinds of tests.</p></div><div class="section" title="Writing test results to an XML file"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec64"/>Writing test results to an XML file</h2></div></div></div><p>nose2 has <a id="id390" class="indexterm"/>support for writing out test results into<a id="id391" class="indexterm"/> an XML file. Many tools can read this file format to understand the results of a test run. For example, continuous integration tools can find out if all the tests passed, and, if not, which tests failed.</p><p>Activate the plugin with the following command:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>nose2 --plugin nose2.plugins.junitxml --junit-xml</strong></span>
</pre></div><p>This will create a file called <code class="literal">nose2-junit.xml</code> in the current directory. The file will contain something like the following:</p><div class="informalexample"><pre class="programlisting">&lt;testsuite errors="0" failures="1" name="nose2-junit" skips="0" tests="166" time="0.172"&gt;

  &lt;testcase classname="stock_alerter.tests.test_action.EmailActionTest" name="test_connection_closed_after_sending_mail" time="0.000000" /&gt;

  ...

  &lt;testcase classname="stock_alerter.tests.test_stock.having a trend method" name="test 0000: should return True if the last three updates were increasing" time="0.000000"&gt;

    &lt;failure message="test failure"&gt;Traceback (most recent call last):
  File "...\src\stock_alerter\tests\test_stock.py", line 78, in test
    assert it.goog.is_increasing_trend()
AssertionError
    &lt;/failure&gt;

  &lt;/testcase&gt;
&lt;/testsuite&gt;</pre></div><p>The root<a id="id392" class="indexterm"/> element gives a summary of the <a id="id393" class="indexterm"/>entire test run, how many errors, failures, and skips there were, the number of tests, and the total time to run all the tests. Each child then summarizes a single test. If the test failed, then a traceback is included as well.</p></div><div class="section" title="Measuring test coverage"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec65"/>Measuring test coverage</h2></div></div></div><p>nose2 also<a id="id394" class="indexterm"/> supports measuring the test coverage. We can use this to identify if there are lines or branches of code that do not have tests, or <a id="id395" class="indexterm"/>which modules have poor test coverage.</p><p>Before we can use this plugin, we need to install some dependent packages with this command:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>pip install nose2[coverage-plugin]</strong></span>
</pre></div><p>This will install two packages—<code class="literal">cov-core</code> and <code class="literal">coverage</code>—which are used by this plugin.</p><p>Once installed, we can enable the plugin with this command:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>nose2 --with-coverage</strong></span>
</pre></div><p>Since this plugin is loaded by default, we don't need to give the <code class="literal">--plugin</code> parameter. Running the above command will give the following output:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>----------- coverage: platform win32, python 3.4.0-final-0 -----------</strong></span>
<span class="strong"><strong>Name                                  Stmts   Miss  Cover</strong></span>
<span class="strong"><strong>---------------------------------------------------------</strong></span>
<span class="strong"><strong>stock_alerter\__init__                    3      3     0%</strong></span>
<span class="strong"><strong>stock_alerter\action                     18      8    56%</strong></span>
<span class="strong"><strong>stock_alerter\alert                      13      4    69%</strong></span>
<span class="strong"><strong>stock_alerter\event                       8      4    50%</strong></span>
<span class="strong"><strong>stock_alerter\legacy                     36     12    67%</strong></span>
<span class="strong"><strong>stock_alerter\processor                   8      0   100%</strong></span>
<span class="strong"><strong>stock_alerter\reader                     15      5    67%</strong></span>
<span class="strong"><strong>stock_alerter\rule                       33     12    64%</strong></span>
<span class="strong"><strong>stock_alerter\stock                      52     19    63%</strong></span>
</pre></div><p>The output above shows how many statements are in each module, how many are not covered by tests, and the percentage of coverage.</p><p>The<a id="id396" class="indexterm"/> plugin also creates a file called .<code class="literal">coverage</code> that<a id="id397" class="indexterm"/> stores the coverage results in binary form. This file can be used to get different kinds of reports. For example, we can use the following command to get HTML output:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>nose2 --with-coverage --coverage-report html</strong></span>
</pre></div><p>The command will create a directory called <code class="literal">htmlcov</code>, which contains a set of files. If we open up <code class="literal">index.html</code> in a browser, then we get a fully interactive coverage report. We can click on any module and get details on exactly which lines were covered and which were not, as shown in the following screenshot:</p><div class="mediaobject"><img src="images/3125_08_01.jpg" alt="Measuring test coverage"/></div><p>Other options for report types are <code class="literal">term</code> for terminal output, <code class="literal">term-missing</code> to also output the uncovered lines on the terminal, and <code class="literal">annotate</code>, which creates a copy of each of the source files with an annotation on whether the line was covered or not.</p><p>Multiple<a id="id398" class="indexterm"/> options can be combined like the <a id="id399" class="indexterm"/>following:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>nose2 --with-coverage --coverage-report html --coverage-report term</strong></span>
</pre></div></div><div class="section" title="Debugging test failures"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec66"/>Debugging test failures</h2></div></div></div><p>Another useful <a id="id400" class="indexterm"/>nose2 plugin is the debugger <a id="id401" class="indexterm"/>plugin. This plugin will activate the Python Debugger (pdb) when <a id="id402" class="indexterm"/>a test fails, allowing us to investigate why exactly the failure occurred.</p><p>Activate the plugin with the following command:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>nose2 --plugin nose2.plugins.debugger --debugger</strong></span>
</pre></div><p>When a test fails, we drop into pdb and can use all the pdb commands to investigate the failure, as shown in the following:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>F</strong></span>
<span class="strong"><strong>&gt; c:\python34\lib\unittest\case.py(787)_baseAssertEqual()</strong></span>
<span class="strong"><strong>-&gt; raise self.failureException(msg)</strong></span>
<span class="strong"><strong>(Pdb) u</strong></span>
<span class="strong"><strong>&gt; c:\python34\lib\unittest\case.py(794)assertEqual()</strong></span>
<span class="strong"><strong>-&gt; assertion_func(first, second, msg=msg)</strong></span>
<span class="strong"><strong>(Pdb) u</strong></span>
<span class="strong"><strong>&gt; c:\projects\tdd_with_python\src\stock_alerter\tests\test_stock.py(60)test_stock_update()</strong></span>
<span class="strong"><strong>-&gt; self.assertEqual(100, self.goog.price)</strong></span>
<span class="strong"><strong>(Pdb) self.goog.price</strong></span>
<span class="strong"><strong>10</strong></span>
</pre></div><div class="section" title="nose2 configuration"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec02"/>nose2 configuration</h3></div></div></div><p>Running the <a id="id403" class="indexterm"/>various plugins requires using many <a id="id404" class="indexterm"/>command line switches. For example, if we want to run coverage, as well as doctest and XML output, the command is as follows:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>nose2 --with-coverage --coverage-report html --plugin nose2.plugins.junitxml --junit-xml --plugin nose2.plugins.doctests --with-doctest</strong></span>
</pre></div><p>This is cumbersome, and if we want to run this combination by default, then it is very painful to keep repeating the parameters over and over.</p><p>To solve this problem, nose2 supports putting all configurations in to a configuration file. nose2 will then read the settings from the file, and we won't need to pass anything on the command line.</p><p>Create a file called <code class="literal">nose2.cfg</code> in the <code class="literal">src</code> directory with the following contents:</p><div class="informalexample"><pre class="programlisting">[unittest]
test-file-pattern=test_*.py
test-method-prefix=test
plugins = nose2.plugins.coverage
          nose2.plugins.junitxml
          nose2.plugins.layers
exclude-plugins = nose2.plugins.doctest

[layer-reporter]
always-on = False
colors = True

[junit-xml]
always-on = True
path = nose2.xml

[coverage]
always-on = False
coverage-report = ["html", "xml"]</pre></div><p>Let us examine these contents.</p><p>nose2 uses the <a id="id405" class="indexterm"/>normal INI file syntax for its configuration. General configuration is put in the <code class="literal">[unittest]</code> section, while plugin specific options<a id="id406" class="indexterm"/> are under their own sections. Under each section, options are configured using key-value pairs.</p><p>We have configured the following above:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>test-file-pattern</strong></span>: This is the pattern to search for in the file name when identifying test files in autodiscovery.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>test-method-prefix</strong></span>: This is the prefix to search for to identify test case function and method names.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>plugins</strong></span>: These are the plugins to load by default. Put each plugin on a separate line, referring to the plugin module here. This is equivalent to the <code class="literal">--plugin</code> command line switch. Note that this only loads the plugin, and some plugins need to be explicitly turned on (for example, the <code class="literal">coverage</code> plugin).</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>exclude-plugin</strong></span>: These are any plugins that need to be turned off. Usually, this is applied to plugins that are turned on by default (for example, parameterized or generated tests support).</li></ul></div><p>We then configure the plugins. Each plugin has its own set of options. The one common option is as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>always-on</strong></span>: Set to <code class="literal">True</code> if this plugin is turned on by default. For example, when the <code class="literal">JUnit</code> plugin is always on, every test run will create the XML file output. Otherwise, we have to use the <code class="literal">--junit-xml</code> switch on the command line to activate it.</li></ul></div><p>nose2 also supports multiple configuration files. The <code class="literal">--config</code> switch can be used to specify which configuration file to use, as shown in the following:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>nose2 --config &lt;filename&gt;</strong></span>
</pre></div><p>This way you can use the default configuration for developer options and create specific config files for continuous integration or other uses. For example, you might want junitxml and coverage to be always on when running under automated tools, but have them off when developers run the tests.</p><p>nose2 configuration files can also be checked into source control, so that all the developers use the same set of options.</p></div></div></div></div>


  <div id="sbo-rt-content"><div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec60"/>Summary</h1></div></div></div><p>In this chapter, you looked at nose2, a powerful test runner and plugin suite, that extends the <code class="literal">unittest</code> framework. nose2 can be used as a drop-in replacement for the <code class="literal">unittest</code> test runner. It can also be used to extend <code class="literal">unittest</code> functionality with useful plugins. Finally, it can be used to write new types of tests such as function tests, parameterized tests, generated tests, and layer-based tests. nose2 also supports configuration files, so it can be run consistently between developers as well as integrating well with automation tools.</p><p>In the next chapter, you will take a look at some more advanced testing patterns.</p></div></div>
</body></html>