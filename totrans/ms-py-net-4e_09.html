<html><head></head><body>
  <div class="Basic-Text-Frame" id="_idContainer139">
    <h1 class="chapterNumber">9</h1>
    <h1 class="chapterTitle" id="_idParaDest-210">Building Network Web Services with Python</h1>
    <p class="normal">In the previous chapters, we were a consumer of the APIs provided by others. In <em class="chapterRef">Chapter 3</em>, <em class="italic">APIs and Intent-Driven Networking</em>, we saw that we can use an <code class="inlineCode">HTTP POST</code> request to NX-API at the <code class="inlineCode">http://&lt;your device ip&gt;/ins</code> URL with the <code class="inlineCode">CLI</code> command embedded in the <code class="inlineCode">HTTP POST</code> body to execute commands remotely on the Cisco Nexus device; the device then returns the command execution output in its HTTP response return. In <em class="chapterRef">Chapter 8</em>, <em class="italic">Network Monitoring with Python – Part 2</em>, we used the <code class="inlineCode">HTTP GET</code> method for our sFlow-RT at <code class="inlineCode">http://&lt;your host ip&gt;:8008/version</code> with an empty body to retrieve the version of the sFlow-RT software. These request-response exchanges are examples of RESTful web services.</p>
    <p class="normal">According to Wikipedia (<a href="https://en.wikipedia.org/wiki/Representational_state_transfer"><span class="url">https://en.wikipedia.org/wiki/Representational_state_transfer</span></a>):</p>
    <blockquote class="packt_quote">
      <p class="quote">”Representational state transfer (REST) or RESTful web services is one way of providing interoperability between computer systems on the internet. REST-compliant web services allow requesting systems to access and manipulate the textual representation of web resources using a uniform and predefined set of stateless operations.”</p>
    </blockquote>
    <p class="normal">As noted, the use of RESTful web services using the HTTP protocol is only one of many methods of information exchange on the web; other forms of web services also exist. However, it is the most commonly used web service today, with the associated <code class="inlineCode">GET</code>, <code class="inlineCode">POST</code>, <code class="inlineCode">PUT</code>, and <code class="inlineCode">DELETE</code> verbs as a predefined way of exchanging information.</p>
    <div class="note">
      <p class="normal">If you are wondering about HTTPS versus HTTP, for our discussion, we are treating HTTPS as a secure extension of HTTP (<a href="https://en.wikipedia.org/wiki/HTTPS"><span class="url">https://en.wikipedia.org/wiki/HTTPS</span></a>) and the same underlying protocol as a RESTful API.</p>
    </div>
    <p class="normal">On the provider side, one of the advantages of providing RESTful services to users is the ability to hide internal operations from the user. For example, in the case of sFlow-RT, if we were to log in to the device to see the version of the software installed instead of using its RESTful API, we would need more in-depth knowledge of the tool to know where to check. However, by providing the resources as a URL, the API provider abstracts the version-checking operations from the requester, making the operation much simpler. The abstraction also provides a layer of security as it can open up the endpoints only as needed.</p>
    <p class="normal">As the master of our network universe, RESTful web services provide many notable benefits that we can enjoy, such as the following:</p>
    <ul>
      <li class="bulletList">You can abstract the requester from learning about the internals of the network operations. For example, we can provide a web service to query the switch version without the requester knowing the exact CLI command or the switch API.</li>
      <li class="bulletList">We can consolidate and customize operations that uniquely fit our network needs, such as a resource to upgrade all our top-of-rack switches.</li>
      <li class="bulletList">We can provide better security by only exposing operations as needed. For example, we can provide read-only URLs (<code class="inlineCode">GET</code>) to core network devices and read-write URLs (<code class="inlineCode">GET</code>/<code class="inlineCode">POST</code>/<code class="inlineCode">PUT</code>/<code class="inlineCode">DELETE</code>) to access-level switches.</li>
    </ul>
    <p class="normal">In this chapter, we will use one of the most popular Python web frameworks, <strong class="keyWord">Flask</strong>, to create our RESTful web service for our network. In this chapter, we will learn about the following:</p>
    <ul>
      <li class="bulletList">Comparing Python web frameworks</li>
      <li class="bulletList">Introduction to Flask</li>
      <li class="bulletList">Operations involving static network content</li>
      <li class="bulletList">Operations involving dynamic network operations</li>
      <li class="bulletList">Authentication and authorization</li>
      <li class="bulletList">Running our web app in containers</li>
    </ul>
    <p class="normal">Let’s start by looking at the available Python web frameworks and why we chose Flask.</p>
    <h1 class="heading-1" id="_idParaDest-211">Comparing Python web frameworks</h1>
    <p class="normal">Python is known for its great many web frameworks. There is a running joke in the Python community about <a id="_idIndexMarker671"/>whether you can ever work as a full-time Python developer <a id="_idIndexMarker672"/>without working with any Python web frameworks. There are several Python web developer conferences, including DjangoCon US (<a href="https://djangocon.us/"><span class="url">https://djangocon.us/</span></a>), DjangoCon EU (<a href="https://djangocon.eu/"><span class="url">https://djangocon.eu/</span></a>), FlaskCon (<a href="https://flaskcon.com/"><span class="url">https://flaskcon.com/</span></a>), Python Web Conference (<a href="https://pythonwebconf.com/"><span class="url">https://pythonwebconf.com/</span></a>), and many local meetups. Each of the conferences attracts hundreds of attendees every year. Did I mention Python has a thriving web development community?</p>
    <p class="normal">If you <a id="_idIndexMarker673"/>sort the Python web frameworks at <a href="https://hotframeworks.com/languages/python"><span class="url">https://hotframeworks.com/languages/python</span></a>, you can see that there is no shortage of choices when it comes to Python and web frameworks:</p>
    <figure class="mediaobject"><img alt="Table  Description automatically generated" src="../Images/B18403_09_01.png"/></figure>
    <p class="packt_figref">Figure 9.1: Python Web Framework Rankings (source: https://hotframeworks.com/languages/python)</p>
    <p class="normal">In the most recent 2021 Python Developer Survey, Flask slightly edged Django as the most popular web framework: </p>
    <figure class="mediaobject"><img alt="A picture containing graphical user interface  Description automatically generated" src="../Images/B18403_09_02.png"/></figure>
    <p class="packt_figref">Figure 9.2: Python Developer Survey 2021 (source: https://lp.jetbrains.com/python-developers-survey-2021/)</p>
    <p class="normal">With so many options to choose from, which framework should we pick? Trying all the frameworks one by one would be time-consuming. The question of which web framework is <a id="_idIndexMarker674"/>better is also a passionate topic among web developers. If you ask this question on any of the forums, such as Quora, or search on Reddit, get ready for some highly opinionated answers and heated debates.</p>
    <div class="note">
      <p class="normal">Speaking of Quora and Reddit, here’s an interesting fact: both Quora and Reddit were written in Python. Reddit uses Pylons (<a href="https://www.reddit.com/wiki/faq#wiki_so_what_python_framework_do_you_use.3F"><span class="url">https://www.reddit.com/wiki/faq#wiki_so_what_python_framework_do_you_use.3F</span></a>), while Quora started with Pylons but replaced a portion of the framework with its in-house code (<a href="https://www.quora.com/What-languages-and-frameworks-are-used-to-code-Quora"><span class="url">https://www.quora.com/What-languages-and-frameworks-are-used-to-code-Quora</span></a>).</p>
    </div>
    <p class="normal">Of course, I am biased toward programming languages (Python!) and web frameworks (Flask and Django!). In this section, I hope to convey my reasoning behind choosing one over the other for any particular project. Let’s pick the top two frameworks from the preceding HotFrameworks list and compare them:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">Django</strong>: The self-proclaimed “web framework for perfectionists with deadlines” is a <a id="_idIndexMarker675"/>high-level Python web framework that encourages <a id="_idIndexMarker676"/>rapid development and clean, pragmatic design (<a href="https://www.djangoproject.com/"><span class="url">https://www.djangoproject.com/</span></a>). It is a large framework with pre-built code that provides an administrative panel and built-in content management.</li>
      <li class="bulletList"><strong class="keyWord">Flask</strong>: This is a <a id="_idIndexMarker677"/>microframework for Python and is based on Werkzeug, Jinja2, and other applications (<a href="https://palletsprojects.com/p/flask/"><span class="url">https://palletsprojects.com/p/flask/</span></a>). By being a <a id="_idIndexMarker678"/>microframework, Flask intends on keeping the core small and easy to extend when needed. The “micro” in microframework does not mean that Flask lacks functionality, nor does it mean it cannot work in a production environment.</li>
    </ul>
    <p class="normal">I use Django for some of the larger projects while using Flask for quick prototypes. The Django framework has a strong opinion on how things should be done; any deviation from it would sometimes leave the user feeling that they are “fighting with the framework.” For <a id="_idIndexMarker679"/>example, if you look at the Django database documentation (<a href="https://docs.djangoproject.com/en/4.0/ref/databases/"><span class="url">https://docs.djangoproject.com/en/4.0/ref/databases/</span></a>) you will notice that the framework supports several different SQL databases. However, they are all variants of a SQL database such as MySQL, PostgreSQL, SQLite, and others.</p>
    <p class="normal">What if we want to use a NoSQL database such as MongoDB or CouchDB? It might be possible, but it could leave us in our own hands because there is no official support from Django. Being an opinionated framework is certainly not a bad thing. It is just a matter of opinion (no pun intended).</p>
    <p class="normal">Keeping the core code small and extending it when needed is very appealing when we need something simple and fast. The initial example in the documentation to get Flask up and running consists of only six lines of code and is easy to understand, even if you don’t have any prior experience. Since Flask is built with extensions in mind, writing our extensions, such as a decorator, is relatively easy. Even though it is a microframework, the Flask core still includes the necessary components, such as a development server, debugger, integration with unit tests, RESTful request dispatching, and more, to get you started quickly.</p>
    <p class="normal">As you can see, Django and Flask are the two most popular Python web frameworks by almost all measures. We <a id="_idIndexMarker680"/>can’t really go wrong picking either as our starting point. The popularity that comes with both frameworks means both have extensive community contribution and support, and can quickly develop modern features. </p>
    <p class="normal">For the ease of deployment, I feel Flask is an ideal choice for us when it comes to building network web services to start with.</p>
    <h1 class="heading-1" id="_idParaDest-212">Flask and lab setup</h1>
    <p class="normal">In this chapter, we will <a id="_idIndexMarker681"/>continue to use a virtual environment to isolate the <a id="_idIndexMarker682"/>Python environment and dependencies. We can start a new virtual environment, or <a id="_idIndexMarker683"/>we can continue to use the existing virtual environment that we have been using. My preference is to start a new virtual environment. I will call mine <code class="inlineCode">ch09-venv</code>: </p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>python3 -m venv ch09-venv
<span class="hljs-con-meta">$ </span><span class="hljs-con-built_in">source</span> ch09-venv/bin/activate
</code></pre>
    <p class="normal">In this chapter, we will install quite a few Python packages. To make life easier, I have included a <code class="inlineCode">requirements.txt</code> file on this book’s GitHub repository; we can use it to install all the necessary packages (remember to activate your virtual environment). You should see packages being downloaded and successfully installed during the installation process:</p>
    <pre class="programlisting con"><code class="hljs-con">(ch09-venv) $ cat requirements.txt 
click==8.1.3
Flask==2.2.2
itsdangerous==2.1.2
Jinja2==3.1.2
MarkupSafe==2.1.1
Werkzeug==2.2.2 
…
(ch09-venv) $ pip install -r requirements.txt
</code></pre>
    <p class="normal">For our network topology, we will use the <code class="inlineCode">2_DC_Topology</code> that we have been using in the first few chapters, as shown here:</p>
    <figure class="mediaobject"><img alt="" src="../Images/B18403_09_03.png"/></figure>
    <p class="packt_figref">Figure 9.3: Lab Topology</p>
    <p class="normal">Let’s take a <a id="_idIndexMarker684"/>look at Flask in the next section.</p>
    <p class="normal">Please note that, from <a id="_idIndexMarker685"/>here on out, I will assume that you will always execute from the virtual environment and that you have installed the necessary packages in the <code class="inlineCode">requirements.txt</code> file.</p>
    <h1 class="heading-1" id="_idParaDest-213">Introduction to Flask</h1>
    <p class="normal">Like most popular open source <a id="_idIndexMarker686"/>projects, Flask has very good documentation, which is available at <a href="https://flask.palletsprojects.com/en/2.0.x/"><span class="url">https://flask.palletsprojects.com/en/2.0.x/</span></a>. If you’d like to dig deeper <a id="_idIndexMarker687"/>into Flask, the project documentation would be a great place to start.</p>
    <p class="normal">I highly recommend Miguel Grinberg’s work (<a href="https://blog.miguelgrinberg.com/"><span class="url">https://blog.miguelgrinberg.com/</span></a>) related to Flask. His blog, book, and video training have taught me a lot about Flask. Miguel’s class, <em class="italic">Building Web APIs with Flask</em>, inspired me to build my first Flask-based API, and inspired the writing of this chapter. You can take a look at his published code on GitHub: <a href="https://github.com/miguelgrinberg/"><span class="url">https://github.com/miguelgrinberg/</span></a>.</p>
    <h2 class="heading-2" id="_idParaDest-214">Flask versions</h2>
    <p class="normal">As of the time of <a id="_idIndexMarker688"/>writing, the latest version of Flask is version 2.2.2. Flask version 2.0.0 was released in May 2021 from version 1.1.4. There were several big changes introduced in the release, thus the big number jump in release numbers. Some of the big changes are listed below: </p>
    <ul>
      <li class="bulletList">Flask 2.0 officially dropped the support for Python 2 and Python 3.5. </li>
      <li class="bulletList">Python 3 type hinting is supported. </li>
      <li class="bulletList">The HTTP method decorator was introduced. </li>
    </ul>
    <p class="normal">These changes <a id="_idIndexMarker689"/>probably mean very little at this point because we are just getting started with Flask. For now, just keep in mind the big version change if we were searching for answers and examples. If possible, look for examples based on version 2 and beyond. </p>
    <h2 class="heading-2" id="_idParaDest-215">Flask examples</h2>
    <p class="normal">Our first Flask <a id="_idIndexMarker690"/>application is contained in one single file, <code class="inlineCode">chapter9_1.py</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask
app = Flask(__name__)
<span class="hljs-meta">@app.route(</span><span class="hljs-string">'/'</span><span class="hljs-meta">)</span>
<span class="hljs-keyword">def</span> <span class="hljs-title">hello_networkers</span>():
    <span class="hljs-keyword">return</span> <span class="hljs-string">'Hello Networkers!'</span>
<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    app.run(host=<span class="hljs-string">'</span><span class="hljs-string">0.0.0.0'</span>, debug=<span class="hljs-literal">True</span>)
</code></pre>
    <p class="normal">This is a simple design pattern for Flask apps. We create an instance of the <code class="inlineCode">Flask</code> class with the first argument as the name of the application’s module package. In this case, we used a single module that can be started as an application; later on, we will see how we can import it as a package. We then use the route decorator to tell Flask which URL should be handled by the <code class="inlineCode">hello_networkers()</code> function; in this case, we indicated the root path. We end the file with the usual name scope, checking when the script is run by itself (<a href="https://docs.python.org/3.10/library/__main__.html"><span class="url">https://docs.python.org/3.10/library/__main__.html</span></a>). </p>
    <p class="normal">We also add the <code class="inlineCode">host</code> and <code class="inlineCode">debug</code> options, which allow more verbose output and allow us to listen on all the host interfaces. We can run this application using the development server:</p>
    <pre class="programlisting con"><code class="hljs-con">(ch09-venv) $ python chapter9_1.py 
 * Serving Flask app 'chapter9_1'
 * Debug mode: on
WARNING: This is a development server. Do not use it in a production deployment. Use a production WSGI server instead.
 * Running on all addresses (0.0.0.0)
 * Running on http://127.0.0.1:5000
 * Running on http://192.168.2.126:5000
Press CTRL+C to quit
 * Restarting with stat
 * Debugger is active!
 * Debugger PIN: 218-520-639
</code></pre>
    <div class="note">
      <p class="normal">If you receive an error of <strong class="screenText">Address already in use</strong> from the development server, change the port Flask Development Server runs on via the <code class="inlineCode">port=xxxx</code> option, <a href="https://flask.palletsprojects.com/en/2.2.x/server/"><span class="url">https://flask.palletsprojects.com/en/2.2.x/server/</span></a>.</p>
    </div>
    <p class="normal">Now that we <a id="_idIndexMarker691"/>have a server running, let’s test the server response with an HTTP client.</p>
    <h2 class="heading-2" id="_idParaDest-216">The HTTPie client</h2>
    <p class="normal">We have already installed <code class="inlineCode">HTTPie</code> (<a href="https://httpie.org/"><span class="url">https://httpie.org/</span></a>) as part of the installation from the <code class="inlineCode">requirements.txt</code> file. This <a id="_idIndexMarker692"/>book is printed in black and white, so the example <a id="_idIndexMarker693"/>does not show color highlighting, but in your installation, you <a id="_idIndexMarker694"/>can see <code class="inlineCode">HTTPie</code> has better syntax highlighting for HTTP transactions. It also has a more intuitive command-line interaction with the RESTful HTTP server. </p>
    <p class="normal">We can use it to test our first Flask application (more examples on <code class="inlineCode">HTTPie</code> to follow). We will start a second terminal window on the management host, activate the virtual environment, and type the following in:</p>
    <pre class="programlisting con"><code class="hljs-con">(ch09-venv) $ http http://192.168.2.126:5000
HTTP/1.1 200 OK
Connection: close
Content-Length: 17
Content-Type: text/html; charset=utf-8
Date: Wed, 21 Sep 2022 02:54:54 GMT
Server: Werkzeug/2.2.2 Python/3.10.4
Hello Networkers!
</code></pre>
    <p class="normal">As a comparison, if we are using <code class="inlineCode">curl</code>, we will need to use the <code class="inlineCode">-i</code> switch to achieve the same output: <code class="inlineCode">curl -i http://192.168.2.126:5000</code>.</p>
    <p class="normal">We will use <code class="inlineCode">HTTPie</code> as our client for this chapter; it is worth taking a minute or two to take a look at its <a id="_idIndexMarker695"/>usage. We will use the free website HTTPBin (<a href="https://httpbin.org/"><span class="url">https://httpbin.org/</span></a>) to demonstrate the use of <code class="inlineCode">HTTPie</code>. The usage of <code class="inlineCode">HTTPie</code> follows this simple pattern:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>http [flags] [METHOD] URL [ITEM]
</code></pre>
    <p class="normal">Following the <a id="_idIndexMarker696"/>preceding pattern, a <code class="inlineCode">GET</code> request is very straightforward, as we <a id="_idIndexMarker697"/>have seen with our Flask development server:</p>
    <pre class="programlisting con"><code class="hljs-con">(ch09-venv) $ http GET https://httpbin.org/user-agent
HTTP/1.1 200 OK
Access-Control-Allow-Credentials: true
Access-Control-Allow-Origin: *
Connection: keep-alive
Content-Length: 35
Content-Type: application/json
Date: Wed, 21 Sep 2022 02:56:07 GMT
Server: gunicorn/19.9.0
{
    "user-agent": "HTTPie/3.2.1"
}
</code></pre>
    <p class="normal">JSON is the default implicit content type for <code class="inlineCode">HTTPie</code>. If your HTTP body contains just strings, no other operation is needed. If you need to apply non-string JSON fields, use :<code class="inlineCode">=</code> or other documented special characters. In the following example, we want the <code class="inlineCode">"married"</code> variable to be a <code class="inlineCode">Boolean</code> instead of a <code class="inlineCode">string</code>:</p>
    <pre class="programlisting con"><code class="hljs-con">(ch09-venv) $ http POST https://httpbin.org/post name=eric twitter=at_ericchou married:=true
…
Content-Type: application/json
…
{…
    "headers": {
        "Accept": "application/json, */*;q=0.5",
        …
        "Host": "httpbin.org",
        "User-Agent": "HTTPie/3.2.1",
	  …
    },
    "json": {
        "married": true,
        "name": "eric",
        "twitter": "at_ericchou"
    },
    "url": "https://httpbin.org/post"
}
</code></pre>
    <p class="normal">As you can <a id="_idIndexMarker698"/>see, <code class="inlineCode">HTTPie</code> is a big improvement from the traditional curl <a id="_idIndexMarker699"/>syntax and makes testing the REST API a breeze.</p>
    <div class="packt_tip">
      <p class="normal">More usage examples are available at <a href="https://httpie.io/docs/cli/usage"><span class="url">https://httpie.io/docs/cli/usage</span></a>.</p>
    </div>
    <p class="normal">Getting back to our Flask program, a large part of API building is based on the flow of URL routing. Let’s look deeper at the <code class="inlineCode">app.route()</code> decorator.</p>
    <h2 class="heading-2" id="_idParaDest-217">URL routing</h2>
    <p class="normal">We added two <a id="_idIndexMarker700"/>additional functions and paired them up with the <a id="_idIndexMarker701"/>appropriate <code class="inlineCode">app.route()</code> route in <code class="inlineCode">chapter9_2.py</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask
app = Flask(__name__)
<span class="hljs-meta">@app.route(</span><span class="hljs-string">'/'</span><span class="hljs-meta">)</span>
<span class="hljs-keyword">def</span> <span class="hljs-title">index</span>():
    <span class="hljs-keyword">return</span> <span class="hljs-string">'You are at index()'</span>
<span class="hljs-meta">@app.route(</span><span class="hljs-string">'/routers/'</span><span class="hljs-meta">)</span>
<span class="hljs-keyword">def</span> <span class="hljs-title">routers</span>():
    <span class="hljs-keyword">return</span> <span class="hljs-string">'You are at routers()'</span>
<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    app.run(host=<span class="hljs-string">'0.0.0.0'</span>, debug=<span class="hljs-literal">True</span>)
</code></pre>
    <p class="normal">The result is that different endpoints are passed to different functions. We can verify this with two <code class="inlineCode">http</code> requests:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"># </span>Server side
<span class="hljs-con-meta">$ </span>python chapter9_2.py 
&lt;skip&gt;
 * Running on http://0.0.0.0:5000/ (Press CTRL+C to quit)
<span class="hljs-con-meta"># </span>client side
<span class="hljs-con-meta">$ </span>http http://192.168.2.126:5000
&lt;skip&gt;
You are at index()
<span class="hljs-con-meta">$ </span>http http://192.168.2.126:5000/routers/
&lt;skip&gt;
You are at routers()
</code></pre>
    <p class="normal">As the requests are made from the client side, the server screen will see the requests coming in:</p>
    <pre class="programlisting con"><code class="hljs-con">(ch09-venv) $ python chapter9_2.py
&lt;skip&gt;
192.168.2.126 - - [20/Sep/2022 20:00:27] "GET / HTTP/1.1" 200 -
192.168.2.126 - - [20/Sep/2022 20:01:05] "GET /routers/ HTTP/1.1" 200 – 
</code></pre>
    <p class="normal">As we can see, the different endpoints correspond to different functions; whatever was returned from <a id="_idIndexMarker702"/>the function is what the server returns to the requester. Of <a id="_idIndexMarker703"/>course, the routing will be pretty limited if we have to keep it static all the time. There are ways to pass dynamic variables from the URL to Flask; we will look at an example of this in the next section.</p>
    <h2 class="heading-2" id="_idParaDest-218">URL variables</h2>
    <p class="normal">We can pass dynamic <a id="_idIndexMarker704"/>variables to the URL, as seen in the <code class="inlineCode">chapter9_3.py</code> examples:</p>
    <pre class="programlisting code"><code class="hljs-code">&lt;skip&gt;
<span class="hljs-meta">@app.route(</span><span class="hljs-string">'/routers/&lt;hostname&gt;'</span><span class="hljs-meta">)</span>
<span class="hljs-keyword">def</span> <span class="hljs-title">router</span>(<span class="hljs-params">hostname</span>):
    <span class="hljs-keyword">return</span> <span class="hljs-string">'You are at %s'</span> % hostname
<span class="hljs-meta">@app.route(</span><span class="hljs-string">'/routers/&lt;hostname&gt;/interface/&lt;int:interface_number&gt;'</span><span class="hljs-meta">)</span>
<span class="hljs-keyword">def</span> <span class="hljs-title">interface</span>(<span class="hljs-params">hostname, interface_number</span>):
    <span class="hljs-keyword">return</span> <span class="hljs-string">'You are at %s interface %d'</span> % (hostname, interface_number)
&lt;skip&gt;
</code></pre>
    <p class="normal">In the two functions, we <a id="_idIndexMarker705"/>pass in dynamic information such as the hostname and interface number at the time when the client is making the request. Note that, in the <code class="inlineCode">/routers/&lt;hostname&gt;</code> URL, we pass the <code class="inlineCode">&lt;hostname&gt;</code> variable as a string; in <code class="inlineCode">/routers/&lt;hostname&gt;/interface/&lt;int:interface_number&gt;</code> we specify the <code class="inlineCode">int</code> variable should only be an integer. Let’s run the example and make some requests:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"># </span>Server Side
(ch09-venv) $ python chapter9_3.py
(ch09-venv) # Client Side
<span class="hljs-con-meta">$ </span>http http://192.168.2.126:5000/routers/host1
HTTP/1.0 200 OK
&lt;skip&gt;
You are at host1
(venv) $ http http://192.168.2.126:5000/routers/host1/interface/1
HTTP/1.0 200 OK
&lt;skip&gt;
You are at host1 interface 1
</code></pre>
    <p class="normal">If the <code class="inlineCode">int</code> variable is NOT an integer, an error will be thrown:</p>
    <pre class="programlisting con"><code class="hljs-con">(venv) $ http http://192.168.2.126:5000/routers/host1/interface/one
HTTP/1.0 404 NOT FOUND
&lt;skip&gt;
&lt;!doctype html&gt;
&lt;html lang=en&gt;
&lt;title&gt;404 Not Found&lt;/title&gt;
&lt;h1&gt;Not Found&lt;/h1&gt;
&lt;p&gt;The requested URL was not found on the server. If you entered the URL manually please check your spelling and try again.&lt;/p&gt; 
</code></pre>
    <p class="normal">The converter includes integers, float, and path (it accepts slashes).</p>
    <p class="normal">Besides matching static <a id="_idIndexMarker706"/>routes with dynamic variables, we can also generate URLs upon <a id="_idIndexMarker707"/>application launch. This is very useful when we do not know the endpoint variable in advance or if the endpoint is based on other conditions, such as the values queried from a database. Let’s take a look at an example of this.</p>
    <h2 class="heading-2" id="_idParaDest-219">URL generation</h2>
    <p class="normal">In <code class="inlineCode">chapter9_4.py</code>, we <a id="_idIndexMarker708"/>wanted to dynamically create a URL during application launch <a id="_idIndexMarker709"/>in the form of <code class="inlineCode">/&lt;hostname&gt;/list_interfaces</code>, where the hostname could be <code class="inlineCode">r1</code>, <code class="inlineCode">r2</code>, or <code class="inlineCode">r3</code>. We already know we can statically configure three routes and three corresponding functions, but let’s see how we can do that upon application launch:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask, url_for
app = Flask(__name__)
<span class="hljs-meta">@app.route(</span><span class="hljs-string">'/&lt;hostname&gt;/list_interfaces'</span><span class="hljs-meta">)</span>
<span class="hljs-keyword">def</span> <span class="hljs-title">device</span>(<span class="hljs-params">hostname</span>):
    <span class="hljs-keyword">if</span> hostname <span class="hljs-keyword">in</span> routers:
        <span class="hljs-keyword">return</span> <span class="hljs-string">'Listing interfaces for %s'</span> % hostname
    <span class="hljs-keyword">else</span>: 
        <span class="hljs-keyword">return</span> <span class="hljs-string">'Invalid hostname'</span>
routers = [<span class="hljs-string">'r1'</span>, <span class="hljs-string">'r2'</span>, <span class="hljs-string">'r3'</span>]
<span class="hljs-keyword">for</span> router <span class="hljs-keyword">in</span> routers: 
    <span class="hljs-keyword">with</span> app.test_request_context():
        <span class="hljs-built_in">print</span>(url_for(<span class="hljs-string">'device'</span>, hostname=router))
<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    app.run(host=<span class="hljs-string">'0.0.0.0'</span>, debug=<span class="hljs-literal">True</span>)
</code></pre>
    <p class="normal">Upon its execution, we will have a few nice, logical URLs that loop around the routers list without statically defining each:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta"># </span>server side
<span class="hljs-con-meta">$ </span>python chapter9_4.py
&lt;skip&gt;
/r1/list_interfaces
/r2/list_interfaces
/r3/list_interfaces
<span class="hljs-con-meta"># </span>client side
(venv) $ http http://192.168.2.126:5000/r1/list_interfaces
&lt;skip&gt;
Listing interfaces for r1
(venv) $ http http://192.168.2.126:5000/r2/list_interfaces
&lt;skip&gt;
Listing interfaces for r2
<span class="hljs-con-meta"># </span>bad request
(venv) $ http http://192.168.2.126:5000/r1000/list_interfaces
&lt;skip&gt;
Invalid hostname
</code></pre>
    <p class="normal">For now, you can <a id="_idIndexMarker710"/>think of <code class="inlineCode">app.text_request_context()</code> as a dummy request <a id="_idIndexMarker711"/>object necessary for demonstration purposes. If you are interested in the local context, feel free to look at <a href="https://werkzeug.palletsprojects.com/en/2.2.x/local/"><span class="url">https://werkzeug.palletsprojects.com/en/2.2.x/local/</span></a>. The dynamic generation of URL endpoints greatly simplifies our code, saves time, and makes the code easier to read.</p>
    <h2 class="heading-2" id="_idParaDest-220">The jsonify return</h2>
    <p class="normal">Another <a id="_idIndexMarker712"/>time-saver in Flask is the <code class="inlineCode">jsonify()</code> return, which wraps <code class="inlineCode">json.dumps()</code> and <a id="_idIndexMarker713"/>turns the JSON output into a response object with <code class="inlineCode">application/json</code> as the content type in the HTTP header. We can tweak the <code class="inlineCode">chapter9_3.py</code> script a bit, as illustrated in <code class="inlineCode">chapter9_5.py</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask, jsonify
app = Flask(__name__)
<span class="hljs-meta">@app.route(</span><span class="hljs-string">'/routers/&lt;hostname&gt;/interface/&lt;int:interface_number&gt;'</span><span class="hljs-meta">)</span>
<span class="hljs-keyword">def</span> <span class="hljs-title">interface</span>(<span class="hljs-params">hostname, interface_number</span>):
    <span class="hljs-keyword">return</span> jsonify(name=hostname, interface=interface_number)
<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    app.run(host=<span class="hljs-string">'0.0.0.0'</span>, debug=<span class="hljs-literal">True</span>)
</code></pre>
    <p class="normal">With a few lines, the return result is now a <code class="inlineCode">JSON</code> object with the appropriate header:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>http http://192.168.2.126:5000/routers/r1/interface/1
HTTP/1.0 200 OK
Content-Length: 38
Content-Type: application/json
Date: Tue, 08 Oct 2019 21:48:51 GMT
Server: Werkzeug/0.16.0 Python/3.6.8
{
    "interface": 1,
    "name": "r1"
}
</code></pre>
    <p class="normal">Combine all <a id="_idIndexMarker714"/>the Flask features we have learned so far, and we are now ready to <a id="_idIndexMarker715"/>build an API for our network.</p>
    <h1 class="heading-1" id="_idParaDest-221">Network resource API</h1>
    <p class="normal">When we have network devices in production, each of the devices will have a certain state and information <a id="_idIndexMarker716"/>that you would like to keep in a persistent location so that you can easily retrieve them later on. This is often done in terms of storing data in a database. We saw many examples of such information storage in the monitoring chapters.</p>
    <p class="normal">However, we would not normally give other non-network administrative users who might want this information direct access to the database; nor would they want to learn all the complex SQL query <a id="_idIndexMarker717"/>language. For these cases, we can leverage Flask and the <strong class="keyWord">Flask-SQLAlchemy</strong> extension of Flask to give them the necessary information via a network API.</p>
    <p class="normal">You can <a id="_idIndexMarker718"/>learn more about Flask-SQLAlchemy at <a href="https://flask-sqlalchemy.palletsprojects.com/en/2.x/"><span class="url">https://flask-sqlalchemy.palletsprojects.com/en/2.x/</span></a>.</p>
    <h2 class="heading-2" id="_idParaDest-222">Flask-SQLAlchemy</h2>
    <p class="normal">SQLAlchemy and the Flask-SQLAlchemy <a id="_idIndexMarker719"/>extension are database abstraction and object-relational mappers, respectively. It’s a fancy way to use the <code class="inlineCode">Python</code> object for <a id="_idIndexMarker720"/>a database. To make things simple, we <a id="_idIndexMarker721"/>will use SQLite as the database, which is a flat file that acts as a self-contained SQL database. We will look at the content of <code class="inlineCode">chapter9_db_1.py</code> as an example of using Flask-SQLAlchemy to create a network database and insert a few table entries into the database. This is a multiple-step process, and we will look at the steps in this section.</p>
    <p class="normal">To begin, we will create a Flask application and load the configuration for SQLAlchemy, such as the database path and name, then create the <code class="inlineCode">SQLAlchemy</code> object by passing the application to it:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask
<span class="hljs-keyword">from</span> flask_sqlalchemy <span class="hljs-keyword">import</span> SQLAlchemy
<span class="hljs-comment"># Create Flask application, load configuration, and create</span>
<span class="hljs-comment"># the SQLAlchemy object</span>
app = Flask(__name__)
app.config[<span class="hljs-string">'SQLALCHEMY_DATABASE_URI'</span>] = <span class="hljs-string">'sqlite:///network.db'</span>
db = SQLAlchemy(app)
</code></pre>
    <p class="normal">We can then create a device <code class="inlineCode">database</code> object and its associated primary key and various columns:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"># This is the database model object</span>
<span class="hljs-keyword">class</span> <span class="hljs-title">Device</span>(db.Model):
    __tablename__ = <span class="hljs-string">'devices'</span>
    <span class="hljs-built_in">id</span> = db.Column(db.Integer, primary_key=<span class="hljs-literal">True</span>)
    hostname = db.Column(db.String(<span class="hljs-number">120</span>), index=<span class="hljs-literal">True</span>)
    vendor = db.Column(db.String(<span class="hljs-number">40</span>))
    <span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, hostname, vendor</span>):
        self.hostname = hostname
        self.vendor = vendor
    <span class="hljs-keyword">def</span> <span class="hljs-title">__repr__</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">return</span> <span class="hljs-string">'&lt;Device %r&gt;'</span> % self.hostname
</code></pre>
    <p class="normal">We can invoke the <code class="inlineCode">database</code> object, create entries, and insert them into the database table. Keep in mind that anything we add to the session needs to be committed to the database in order to be permanent:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    db.create_all()
    r1 = Device(<span class="hljs-string">'lax-dc1-core1'</span>, <span class="hljs-string">'Juniper'</span>)
    r2 = Device(<span class="hljs-string">'sfo-dc1-core1'</span>, <span class="hljs-string">'Cisco'</span>)
    db.session.add(r1)
    db.session.add(r2)
    db.session.commit()
</code></pre>
    <p class="normal">We will run the Python script and check for the existence of the database file:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>python chapter9_db_1.py
<span class="hljs-con-meta">$ </span><span class="hljs-con-built_in">ls</span> -l network.db 
-rw-r--r-- 1 echou echou 28672 Sep 21 10:43 network.db
</code></pre>
    <p class="normal">We can use the interactive prompt to check the database table entries:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">from</span> flask <span class="hljs-con-keyword">import</span> Flask
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">from</span> flask_sqlalchemy <span class="hljs-con-keyword">import</span> SQLAlchemy
<span class="hljs-con-meta">&gt;&gt;&gt;</span> app = Flask(__name__)
<span class="hljs-con-meta">&gt;&gt;&gt;</span> app.config[<span class="hljs-con-string">'SQLALCHEMY_DATABASE_URI'</span>] = <span class="hljs-con-string">'sqlite:///network.db'</span>
<span class="hljs-con-meta">&gt;&gt;&gt;</span> db = SQLAlchemy(app)
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">from</span> chapter9_db_1 <span class="hljs-con-keyword">import</span> Device
<span class="hljs-con-meta">&gt;&gt;&gt;</span> Device.query.<span class="hljs-con-built_in">all</span>()
[&lt;Device 'lax-dc1-core1'&gt;, &lt;Device 'sfo-dc1-core1'&gt;]
<span class="hljs-con-meta">&gt;&gt;&gt;</span> Device.query.filter_by(hostname=<span class="hljs-con-string">'sfo-dc1-core1'</span>)
&lt;flask_sqlalchemy.BaseQuery object at 0x7f09544a0e80&gt;
<span class="hljs-con-meta">&gt;&gt;&gt;</span> Device.query.filter_by(hostname=<span class="hljs-con-string">'sfo-dc1-core1'</span>).first()
&lt;Device 'sfo-dc1-core1'&gt;
</code></pre>
    <p class="normal">We can also create new entries in the same manner:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> r3 = Device(<span class="hljs-con-string">'lax-dc1-core2'</span>, <span class="hljs-con-string">'Juniper'</span>)
<span class="hljs-con-meta">&gt;&gt;&gt;</span> db.session.add(r3)
<span class="hljs-con-meta">&gt;&gt;&gt;</span> db.session.commit()
<span class="hljs-con-meta">&gt;&gt;&gt;</span> Device.query.filter_by(hostname=<span class="hljs-con-string">'lax-dc1-core2'</span>).first()
&lt;Device 'lax-dc1-core2'&gt;
</code></pre>
    <p class="normal">Let’s go ahead <a id="_idIndexMarker722"/>and delete the <code class="inlineCode">network.db</code> file <a id="_idIndexMarker723"/>so it does not conflict with our other examples using the same <code class="inlineCode">db</code> name:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span><span class="hljs-con-built_in">rm</span> network.db
</code></pre>
    <p class="normal">Now we are ready to move on to build our network content API.</p>
    <h2 class="heading-2" id="_idParaDest-223">The network content API</h2>
    <p class="normal">Before we dive <a id="_idIndexMarker724"/>into the code of building our API, let’s <a id="_idIndexMarker725"/>take a moment to think about the API structure we will create. Planning for an API is usually more an art than a science; it really depends on your situation and preference. What I suggest in this section is, by no means, the only way, but for now, stay with me for the purposes of getting started.</p>
    <p class="normal">Recall that, in our diagram, we have four Cisco IOSv devices. Let’s pretend that two of them, <code class="inlineCode">lax-edg-r1</code> and <code class="inlineCode">lax-edg-r2</code>, are in the network role of the spine. The other two devices, <code class="inlineCode">nyc-edg-r1</code> and <code class="inlineCode">nyc-edg-r2</code>, are in our network service as leaves. These are arbitrary choices and can be modified later on, but the point is that we want to serve data about our network devices and expose them via an API.</p>
    <p class="normal">To make things simple, we will create two APIs, a devices group API and a single-device API:</p>
    <figure class="mediaobject"><img alt="Text  Description automatically generated with medium confidence" src="../Images/B18403_09_04.png"/></figure>
    <p class="packt_figref">Figure 9.4: Network Content API</p>
    <p class="normal">The first API will be our <code class="inlineCode">http://192.168.2.126/devices/</code> endpoint, which supports two methods: <code class="inlineCode">GET</code> and <code class="inlineCode">POST</code>. The <code class="inlineCode">GET</code> request will return the current list of devices, while the <code class="inlineCode">POST</code> request with the proper JSON body will create the device. Of course, you can choose different endpoints for creation and querying, but in this design, we choose to differentiate the two by the HTTP methods.</p>
    <p class="normal">The second API will be specific to our device in the form of <code class="inlineCode">http://192.168.2.126/devices/&lt;device id&gt;</code>. The API with the <code class="inlineCode">GET</code> request will show the details of the device that we have entered into the database.</p>
    <p class="normal">The <code class="inlineCode">PUT</code> request will modify the entry with the update. Note that we use <code class="inlineCode">PUT</code> instead of <code class="inlineCode">POST</code>. This is typical of HTTP API usage; when we need to modify an existing entry, we will use <code class="inlineCode">PUT</code> instead of <code class="inlineCode">POST</code>.</p>
    <p class="normal">At this point, you should have a good idea about what your API will look like. To better visualize the final result, I will jump ahead and show the result quickly before we take a look at the code. If you want to follow the example, feel free to launch <code class="inlineCode">chapter9_6.py</code> as the Flask server.</p>
    <p class="normal">A <code class="inlineCode">POST</code> request to the <code class="inlineCode">/devices/</code> API will allow you to create an entry. In this case, I would like to create our network device with attributes such as hostname, loopback IP, management IP, role, vendor, and the operating system it runs on:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>http POST http://192.168.2.126:5000/devices/ <span class="hljs-con-string">'hostname'</span>=<span class="hljs-con-string">'lax-edg-r1'</span> <span class="hljs-con-string">'loopback'</span>=<span class="hljs-con-string">'192.168.0.10'</span> <span class="hljs-con-string">'mgmt_ip'</span>=<span class="hljs-con-string">'192.168.2.51'</span> <span class="hljs-con-string">'role'</span>=<span class="hljs-con-string">'spine'</span> <span class="hljs-con-string">'</span><span class="hljs-con-string">vendor'</span>=<span class="hljs-con-string">'Cisco'</span> <span class="hljs-con-string">'os'</span>=<span class="hljs-con-string">'15.8'</span>
HTTP/1.1 201 CREATED
Connection: close
Content-Length: 3
Content-Type: application/json
Date: Wed, 21 Sep 2022 18:01:33 GMT
Location: http://192.168.2.126:5000/devices/1
Server: Werkzeug/2.2.2 Python/3.10.4
{}
</code></pre>
    <p class="normal">I can repeat the preceding step for the three additional devices:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>http POST http://192.168.2.126:5000/devices/ <span class="hljs-con-string">'hostname'</span>=<span class="hljs-con-string">'lax-edg-r2'</span> <span class="hljs-con-string">'loopback'</span>=<span class="hljs-con-string">'192.168.0.11'</span> <span class="hljs-con-string">'mgmt_ip'</span>=<span class="hljs-con-string">'192.168.2.52'</span> <span class="hljs-con-string">'role'</span>=<span class="hljs-con-string">'spine'</span> <span class="hljs-con-string">'vendor'</span>=<span class="hljs-con-string">'Cisco'</span> <span class="hljs-con-string">'os'</span>=<span class="hljs-con-string">'15.8'</span>
<span class="hljs-con-meta">$ </span>http POST http://192.168.2.126:5000/devices/ <span class="hljs-con-string">'hostname'</span>=<span class="hljs-con-string">'nyc-edg-r1'</span> <span class="hljs-con-string">'loopback'</span>=<span class="hljs-con-string">'192.168.0.12'</span> <span class="hljs-con-string">'mgmt_ip'</span>=<span class="hljs-con-string">'192.168.2.61'</span> <span class="hljs-con-string">'role'</span>=<span class="hljs-con-string">'leaf'</span>
<span class="hljs-con-string">'vendor'</span>=<span class="hljs-con-string">'Cisco'</span> <span class="hljs-con-string">'os'</span>=<span class="hljs-con-string">'15.8'</span>
<span class="hljs-con-meta">$ </span>http POST http://192.168.2.126:5000/devices/ <span class="hljs-con-string">'hostname'</span>=<span class="hljs-con-string">'nyc-edg-r2'</span> <span class="hljs-con-string">'loopback'</span>=<span class="hljs-con-string">'192.168.0.13'</span> <span class="hljs-con-string">'mgmt_ip'</span>=<span class="hljs-con-string">'192.168.2.62'</span> <span class="hljs-con-string">'role'</span>=<span class="hljs-con-string">'leaf'</span> <span class="hljs-con-string">'vendor'</span>=<span class="hljs-con-string">'Cisco'</span> <span class="hljs-con-string">'os'</span>=<span class="hljs-con-string">'15.8'</span> 
</code></pre>
    <p class="normal">If we use the <a id="_idIndexMarker726"/>same API endpoint with the <code class="inlineCode">GET</code> request, we <a id="_idIndexMarker727"/>will be able to see the list of network devices that we created:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>http GET http://192.168.2.126:5000/devices/
HTTP/1.1 200 OK
Connection: close
Content-Length: 193
Content-Type: application/json
Date: Wed, 21 Sep 2022 18:07:16 GMT
Server: Werkzeug/2.2.2 Python/3.10.4
{
    "device": [
        "http://192.168.2.126:5000/devices/1",
        "http://192.168.2.126:5000/devices/2",
        "http://192.168.2.126:5000/devices/3",
        "http://192.168.2.126:5000/devices/4"
    ]
}
</code></pre>
    <p class="normal">Similarly, using the <code class="inlineCode">GET</code> request for <code class="inlineCode">/devices/&lt;id&gt;</code> will return specific information related to the device:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>http GET http://192.168.2.126:5000/devices/1
HTTP/1.1 200 OK
Connection: close
Content-Length: 199
Content-Type: application/json
Date: Wed, 21 Sep 2022 18:07:50 GMT
Server: Werkzeug/2.2.2 Python/3.10.4
{
    "hostname": "lax-edg-r1",
    "loopback": "192.168.0.10",
    "mgmt_ip": "192.168.2.51",
    "os": "15.8",
    "role": "spine",
    "self_url": "http://192.168.2.126:5000/devices/1",
    "vendor": "Cisco"
}
</code></pre>
    <p class="normal">Let’s pretend <a id="_idIndexMarker728"/>we have downgraded the <code class="inlineCode">lax-edg-r1</code> operating <a id="_idIndexMarker729"/>system from <code class="inlineCode">15.6</code> to <code class="inlineCode">14.6</code>. We can use the <code class="inlineCode">PUT</code> request to update the device record:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>http PUT http://192.168.2.126:5000/devices/1 <span class="hljs-con-string">'hostname'</span>=<span class="hljs-con-string">'lax-edg-r1'</span> <span class="hljs-con-string">'loopback'</span>=<span class="hljs-con-string">'192.168.0.10'</span> <span class="hljs-con-string">'</span><span class="hljs-con-string">mgmt_ip'</span>=<span class="hljs-con-string">'192.168.2.51'</span> <span class="hljs-con-string">'role'</span>=<span class="hljs-con-string">'spine'</span> <span class="hljs-con-string">'vendor'</span>=<span class="hljs-con-string">'Cisco'</span> <span class="hljs-con-string">'os'</span>=<span class="hljs-con-string">'14.6'</span>
HTTP/1.1 200 OK
<span class="hljs-con-meta"># </span>Verification
<span class="hljs-con-meta">$ </span>http GET http://192.168.2.126:5000/devices/1
HTTP/1.1 200 OK
Connection: close
Content-Length: 199
Content-Type: application/json
Date: Wed, 21 Sep 2022 18:10:37 GMT
Server: Werkzeug/2.2.2 Python/3.10.4
{
    "hostname": "lax-edg-r1",
    "loopback": "192.168.0.10",
    "mgmt_ip": "192.168.2.51",
    "os": "14.6",
    "role": "spine",
    "self_url": "http://192.168.2.126:5000/devices/1",
    "vendor": "Cisco"
}
</code></pre>
    <p class="normal">Now, let’s look at the code in <code class="inlineCode">chapter9_6.py</code> that created the preceding APIs. What’s cool, in my <a id="_idIndexMarker730"/>opinion, is that all of these APIs were done <a id="_idIndexMarker731"/>in a single file, including the database interaction. Later on, when we outgrow the APIs at hand, we can always separate the components, such as having a separate file for the database class.</p>
    <h2 class="heading-2" id="_idParaDest-224">The devices API</h2>
    <p class="normal">The <code class="inlineCode">chapter9_6.py</code> file <a id="_idIndexMarker732"/>starts with the necessary imports. Note that the following request <a id="_idIndexMarker733"/>import is the <code class="inlineCode">request</code> object from the client and not the <code class="inlineCode">requests</code> package that we were using in the previous chapters:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask, url_for, jsonify, request
<span class="hljs-keyword">from</span> flask_sqlalchemy <span class="hljs-keyword">import</span> SQLAlchemy
app = Flask(__name__)
app.config[<span class="hljs-string">'SQLALCHEMY_DATABASE_URI'</span>] = <span class="hljs-string">'sqlite:///network.db'</span>
db = SQLAlchemy(app)
</code></pre>
    <p class="normal">We declared a <code class="inlineCode">database</code> object with <code class="inlineCode">id</code> as the primary key and string fields for <code class="inlineCode">hostname</code>, <code class="inlineCode">loopback</code>, <code class="inlineCode">mgmt_ip</code>, <code class="inlineCode">role</code>, <code class="inlineCode">vendor</code>, and <code class="inlineCode">os</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span> <span class="hljs-title">Device</span>(db.Model):
    __tablename__ = <span class="hljs-string">'devices'</span>
    <span class="hljs-built_in">id</span> = db.Column(db.Integer, primary_key=<span class="hljs-literal">True</span>)
    hostname = db.Column(db.String(<span class="hljs-number">64</span>), unique=<span class="hljs-literal">True</span>)
    loopback = db.Column(db.String(<span class="hljs-number">120</span>), unique=<span class="hljs-literal">True</span>)
    mgmt_ip = db.Column(db.String(<span class="hljs-number">120</span>), unique=<span class="hljs-literal">True</span>)
    role = db.Column(db.String(<span class="hljs-number">64</span>))
    vendor = db.Column(db.String(<span class="hljs-number">64</span>))
    os = db.Column(db.String(<span class="hljs-number">64</span>))
</code></pre>
    <p class="normal">The <code class="inlineCode">get_url()</code> function under the <code class="inlineCode">Device</code> class returns a URL from the <code class="inlineCode">url_for()</code> function. Note that the <code class="inlineCode">get_device()</code> function that’s called is not defined just yet under the <code class="inlineCode">/devices/&lt;int:id&gt;</code> route:</p>
    <pre class="programlisting code"><code class="hljs-code">    <span class="hljs-keyword">def</span> <span class="hljs-title">get_url</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">return</span> url_for(<span class="hljs-string">'get_device'</span>, <span class="hljs-built_in">id</span>=self.<span class="hljs-built_in">id</span>, _external=<span class="hljs-literal">True</span>)
</code></pre>
    <p class="normal">The <code class="inlineCode">export_data()</code> and <code class="inlineCode">import_data()</code> functions are mirror images of each other. One is used to get the <a id="_idIndexMarker734"/>information from the database to the user <code class="inlineCode">(export_data())</code> when <a id="_idIndexMarker735"/>we use the <code class="inlineCode">GET</code> method. The other is to get information from the user to the database <code class="inlineCode">(import_data())</code> when we use the <code class="inlineCode">POST</code> or <code class="inlineCode">PUT</code> method:</p>
    <pre class="programlisting code"><code class="hljs-code">    <span class="hljs-keyword">def</span> <span class="hljs-title">export_data</span>(<span class="hljs-params">self</span>):
        <span class="hljs-keyword">return</span> {
            <span class="hljs-string">'self_url'</span>: self.get_url(),
            <span class="hljs-string">'hostname'</span>: self.hostname,
            <span class="hljs-string">'loopback'</span>: self.loopback,
            <span class="hljs-string">'mgmt_ip'</span>: self.mgmt_ip,
            <span class="hljs-string">'role'</span>: self.role,
            <span class="hljs-string">'vendor'</span>: self.vendor,
            <span class="hljs-string">'os'</span>: self.os
        }
    <span class="hljs-keyword">def</span> <span class="hljs-title">import_data</span>(<span class="hljs-params">self, data</span>):
        <span class="hljs-keyword">try</span>:
            self.hostname = data[<span class="hljs-string">'hostname'</span>]
            self.loopback = data[<span class="hljs-string">'loopback'</span>]
            self.mgmt_ip = data[<span class="hljs-string">'mgmt_ip'</span>]
            self.role = data[<span class="hljs-string">'role'</span>]
            self.vendor = data[<span class="hljs-string">'vendor'</span>]
            self.os = data[<span class="hljs-string">'os'</span>]
        <span class="hljs-keyword">except</span> KeyError <span class="hljs-keyword">as</span> e:
            <span class="hljs-keyword">raise</span> ValidationError(<span class="hljs-string">'Invalid device: missing '</span> + e.args[<span class="hljs-number">0</span>])
        <span class="hljs-keyword">return</span> self
</code></pre>
    <p class="normal">With the <code class="inlineCode">database</code> object in place and the import and export functions created, the URL dispatch is straightforward for device operations. The <code class="inlineCode">GET</code> request will return a list of devices by querying all the entries in the <code class="inlineCode">devices</code> table and returning the URL of each entry. The <code class="inlineCode">POST</code> method will use the <code class="inlineCode">import_data()</code> function with the global <code class="inlineCode">request</code> object as the input. It will then add the device and commit the information to the database:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">@app.route(</span><span class="hljs-string">'/devices/'</span><span class="hljs-params">, methods=[</span><span class="hljs-string">'GET'</span><span class="hljs-params">]</span><span class="hljs-meta">)</span>
<span class="hljs-keyword">def</span> <span class="hljs-title">get_devices</span>():
    <span class="hljs-keyword">return</span> jsonify({<span class="hljs-string">'device'</span>: [device.get_url() 
                               <span class="hljs-keyword">for</span> device <span class="hljs-keyword">in</span> Device.query.<span class="hljs-built_in">all</span>()]})
<span class="hljs-meta">@app.route(</span><span class="hljs-string">'/devices/'</span><span class="hljs-params">, methods=[</span><span class="hljs-string">'POST'</span><span class="hljs-params">]</span><span class="hljs-meta">)</span>
<span class="hljs-keyword">def</span> <span class="hljs-title">new_device</span>():
    device = Device()
    device.import_data(request.json)
    db.session.add(device)
    db.session.commit()
    <span class="hljs-keyword">return</span> jsonify({}), <span class="hljs-number">201</span>, {<span class="hljs-string">'Location'</span>: device.get_url()}
</code></pre>
    <p class="normal">If you look at <a id="_idIndexMarker736"/>the <code class="inlineCode">POST</code> method, the returned body is an empty JSON body, with the <a id="_idIndexMarker737"/>status code <code class="inlineCode">201</code> (created), as well as extra headers:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-attribute">HTTP</span>/<span class="hljs-number">1</span>.<span class="hljs-number">0</span> <span class="hljs-number">201</span> CREATED
<span class="hljs-attribute">Content</span>-Length: <span class="hljs-number">2</span>
<span class="hljs-attribute">Content</span>-Type: application/json Date: ...
<span class="hljs-attribute">Location</span>: http://<span class="hljs-number">192.168.2.126:5000</span>/devices/<span class="hljs-number">4</span>
<span class="hljs-attribute">Server</span>: Werkzeug/<span class="hljs-number">2</span>.<span class="hljs-number">2</span>.<span class="hljs-number">2</span> Python/<span class="hljs-number">3</span>.<span class="hljs-number">10</span>.<span class="hljs-number">4</span>
</code></pre>
    <p class="normal">Let’s look at the API that queries and returns information for individual devices.</p>
    <h2 class="heading-2" id="_idParaDest-225">The device ID API</h2>
    <p class="normal">The route for <a id="_idIndexMarker738"/>individual devices specifies that the ID should <a id="_idIndexMarker739"/>be an integer, which can act as our first line of defense against a bad request. The two endpoints follow the same design pattern as our <code class="inlineCode">/devices/</code> endpoint, where we use the same <code class="inlineCode">import</code> and <code class="inlineCode">export</code> functions:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">@app.route(</span><span class="hljs-string">'/devices/&lt;int:id&gt;'</span><span class="hljs-params">, methods=[</span><span class="hljs-string">'GET'</span><span class="hljs-params">]</span><span class="hljs-meta">)</span>
<span class="hljs-keyword">def</span> <span class="hljs-title">get_device</span>(<span class="hljs-built_in">id</span>):
    <span class="hljs-keyword">return</span> jsonify(Device.query.get_or_404(<span class="hljs-built_in">id</span>).export_data())
<span class="hljs-meta">@app.route(</span><span class="hljs-string">'/devices/&lt;int:id&gt;'</span><span class="hljs-params">, methods=[</span><span class="hljs-string">'PUT'</span><span class="hljs-params">]</span><span class="hljs-meta">)</span>
<span class="hljs-keyword">def</span> <span class="hljs-title">edit_device</span>(<span class="hljs-built_in">id</span>):
    device = Device.query.get_or_404(<span class="hljs-built_in">id</span>)
    device.import_data(request.json)
    db.session.add(device)
    db.session.commit()
    <span class="hljs-keyword">return</span> jsonify({})
</code></pre>
    <p class="normal">Note that the <code class="inlineCode">query_or_404()</code> method provides a convenient way of returning <code class="inlineCode">404 (not found)</code> if the database query returns negative for the ID passed in. This is a pretty elegant way of providing a quick check on the database query.</p>
    <p class="normal">Finally, the last part of the code creates the database table and starts the Flask development server:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:
    db.create_all()
    app.run(host=<span class="hljs-string">'0.0.0.0'</span>, debug=<span class="hljs-literal">True</span>)
</code></pre>
    <p class="normal">This is one of the longer Python scripts in this book, so we took more time to explain it in detail. The <a id="_idIndexMarker740"/>script provides a way to illustrate how <a id="_idIndexMarker741"/>we can utilize the database in the backend to keep track of the network devices and only expose them to the external world as APIs using Flask.</p>
    <p class="normal">In the next section, we will take a look at how to use the API to perform asynchronous tasks on either individual devices or a group of devices.</p>
    <h1 class="heading-1" id="_idParaDest-226">Network dynamic operations</h1>
    <p class="normal">Our API can now <a id="_idIndexMarker742"/>provide static information about the network; anything we can store in the database can be returned to the requester. It would be great if we could interact with our network directly, such as a query for device information or to push configuration changes to the device.</p>
    <p class="normal">We will start this process by leveraging a script we have already seen in <em class="chapterRef">Chapter 2</em>, <em class="italic">Low-Level Network Device Interactions</em>, for interacting with a device via Pexpect. We will modify the script slightly into a function we can repeatedly use in <code class="inlineCode">chapter9_pexpect_1.py</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> pexpect
<span class="hljs-keyword">def</span> <span class="hljs-title">show_version</span>(<span class="hljs-params">device, prompt, ip, username, password</span>):
    device_prompt = prompt
    child = pexpect.spawn(<span class="hljs-string">'telnet '</span> + ip)
    child.expect(<span class="hljs-string">'Username:'</span>)
    child.sendline(username)
    child.expect(<span class="hljs-string">'Password:'</span>)
    child.sendline(password)
    child.expect(device_prompt)
    child.sendline(<span class="hljs-string">'show version | i V'</span>)
    child.expect(device_prompt)
    result = child.before
    child.sendline(<span class="hljs-string">'exit'</span>)
    <span class="hljs-keyword">return</span> device, result
</code></pre>
    <p class="normal">We can test the new function via the interactive prompt:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">from</span> chapter9_pexpect_1 <span class="hljs-con-keyword">import</span> show_version
<span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-built_in">print</span>(show_version(<span class="hljs-con-string">'lax-edg-r1'</span>, <span class="hljs-con-string">'lax-edg-r1#'</span>, <span class="hljs-con-string">'192.168.2.51'</span>, <span class="hljs-con-string">'cisco'</span>, <span class="hljs-con-string">'cisco'</span>))
('lax-edg-r1', b'show version | i V\r\nCisco IOS Software, IOSv Software (VIOS-ADVENTERPRISEK9-M), Version 15.8(3)M2, RELEASE SOFTWARE (fc2)\r\nProcessor board ID 98U40DKV403INHIULHYHB\r\n')
</code></pre>
    <p class="normal">Make sure our Pexpect script works before proceeding. The following code assumes that we have entered <a id="_idIndexMarker743"/>the necessary database information from the previous section.</p>
    <p class="normal">We can add a new API for querying the device version in <code class="inlineCode">chapter9_7.py</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">from</span> chapter9_pexpect_1 <span class="hljs-keyword">import</span> show_version
&lt;skip&gt;
<span class="hljs-meta">@app.route(</span><span class="hljs-string">'/devices/&lt;int:id&gt;/version'</span><span class="hljs-params">, methods=[</span><span class="hljs-string">'GET'</span><span class="hljs-params">]</span><span class="hljs-meta">)</span>
<span class="hljs-keyword">def</span> <span class="hljs-title">get_device_version</span>(<span class="hljs-built_in">id</span>):
    device = Device.query.get_or_404(<span class="hljs-built_in">id</span>)
    hostname = device.hostname
    ip = device.mgmt_ip
    prompt = hostname+<span class="hljs-string">"#"</span>
    result = show_version(hostname, prompt, ip, <span class="hljs-string">'cisco'</span>, <span class="hljs-string">'cisco'</span>)
    <span class="hljs-keyword">return</span> jsonify({<span class="hljs-string">"version"</span>: <span class="hljs-built_in">str</span>(result)})
</code></pre>
    <p class="normal">The result will be returned to the requester:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>http GET http://192.168.2.126:5000/devices/1/version 
HTTP/1.1 200 OK
Connection: close
Content-Length: 216
Content-Type: application/json
Date: Wed, 21 Sep 2022 18:19:52 GMT
Server: Werkzeug/2.2.2 Python/3.10.4
{
    "version": "('lax-edg-r1', b'show version | i V\\r\\nCisco IOS Software, IOSv Software (VIOS-ADVENTERPRISEK9-M), Version 15.8(3)M2, RELEASE SOFTWARE (fc2)\\r\\nProcessor board ID 98U40DKV403INHIULHYHB\\r\\n')"
}
</code></pre>
    <p class="normal">We can also add another endpoint that will allow us to perform a bulk action on multiple devices <a id="_idIndexMarker744"/>based on their common fields. In the following example, the endpoint will take the <code class="inlineCode">device_role</code> attribute in the URL and match it up with the appropriate device(s):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">@app.route(</span><span class="hljs-string">'/devices/&lt;device_role&gt;/version'</span><span class="hljs-params">, methods=[</span><span class="hljs-string">'GET'</span><span class="hljs-params">]</span><span class="hljs-meta">)</span>
<span class="hljs-keyword">def</span> <span class="hljs-title">get_role_version</span>(<span class="hljs-params">device_role</span>):
    device_id_list = [device.<span class="hljs-built_in">id</span> <span class="hljs-keyword">for</span> device <span class="hljs-keyword">in</span> Device.query.<span class="hljs-built_in">all</span>() <span class="hljs-keyword">if</span> device.role == device_role]
    result = {}
    <span class="hljs-keyword">for</span> <span class="hljs-built_in">id</span> <span class="hljs-keyword">in</span> device_id_list:
        device = Device.query.get_or_404(<span class="hljs-built_in">id</span>)
        hostname = device.hostname
        ip = device.mgmt_ip
        prompt = hostname + <span class="hljs-string">"#"</span>
        device_result = show_version(hostname, prompt, ip, <span class="hljs-string">'cisco'</span>, <span class="hljs-string">'cisco'</span>)
        result[hostname] = <span class="hljs-built_in">str</span>(device_result)
    <span class="hljs-keyword">return</span> jsonify(result)
</code></pre>
    <p class="normal">Of course, looping through all the devices in <code class="inlineCode">Device.query.all()</code> is not efficient, as in the preceding code. In production, we will use a SQL query that specifically targets the role of the device.</p>
    <p class="normal">When we use the RESTful API, we can see that all the spine, as well as leaf, devices can be queried at the same time:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>http GET http://192.168.2.126:5000/devices/spine/version
HTTP/1.1 200 OK
Connection: close
Content-Length: 389
Content-Type: application/json
Date: Wed, 21 Sep 2022 18:20:57 GMT
Server: Werkzeug/2.2.2 Python/3.10.4
{
    "lax-edg-r1": "('lax-edg-r1', b'show version | i V\\r\\nCisco IOS Software, IOSv Software (VIOS-ADVENTERPRISEK9-M), Version 15.8(3)M2, RELEASE SOFTWARE (fc2)\\r\\nProcessor board ID 98U40DKV403INHIULHYHB\\r\\n')",
    "lax-edg-r2": "('lax-edg-r2', b'show version | i V\\r\\nCisco IOS Software, IOSv Software (VIOS-ADVENTERPRISEK9-M), Version 15.8(3)M2, RELEASE SOFTWARE (fc2)\\r\\n')"
}
</code></pre>
    <p class="normal">As illustrated, the new API endpoints query the device(s) in real time and return the result to the requester. This works relatively well when you can guarantee a response from the operation <a id="_idIndexMarker745"/>within the timeout value of the transaction (30 seconds, by default) or if you are OK with the HTTP session timing out before the operation is completed. One way to deal with the timeout issue is to perform the tasks asynchronously. We will look at how to do so in the next section.</p>
    <h2 class="heading-2" id="_idParaDest-227">Asynchronous operations</h2>
    <p class="normal">Asynchronous operations, when <a id="_idIndexMarker746"/>executing tasks out of the normal time sequence, are, in my opinion, an advanced <a id="_idIndexMarker747"/>topic of Flask. </p>
    <p class="normal">Luckily, Miguel Grinberg (<a href="https://blog.miguelgrinberg.com/"><span class="url">https://blog.miguelgrinberg.com/</span></a>), whose Flask work I am a big fan of, provides many posts and examples on his blog and his GitHub repository. For asynchronous operations, the example code in <code class="inlineCode">chapter9_8.py</code> referenced Miguel’s GitHub code on the <code class="inlineCode">Raspberry Pi</code> file (<a href="https://github.com/miguelgrinberg/oreilly-flask-apis-video/blob/master/camera/camera.py"><span class="url">https://github.com/miguelgrinberg/oreilly-flask-apis-video/blob/master/camera/camera.py</span></a>) for the background decorator. We will start by importing a few more modules:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">from</span> flask <span class="hljs-keyword">import</span> Flask, url_for, jsonify, request,\
    make_response, copy_current_request_context
<span class="hljs-keyword">from</span> flask_sqlalchemy <span class="hljs-keyword">import</span> SQLAlchemy
<span class="hljs-keyword">from</span> chapter9_pexpect_1 <span class="hljs-keyword">import</span> show_version
<span class="hljs-keyword">import</span> uuid
<span class="hljs-keyword">import</span> functools
<span class="hljs-keyword">from</span> threading <span class="hljs-keyword">import</span> Thread
</code></pre>
    <p class="normal">The background decorator takes in a function and runs it as a background task using the thread and UUID for the task ID. It returns the status code <code class="inlineCode">202</code> (accepted) and the location of the new resources for the requester to check. We will make a new URL for status checking:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">@app.route(</span><span class="hljs-string">'/status/&lt;id&gt;'</span><span class="hljs-params">, methods=[</span><span class="hljs-string">'GET'</span><span class="hljs-params">]</span><span class="hljs-meta">)</span>
<span class="hljs-keyword">def</span> <span class="hljs-title">get_task_status</span>(<span class="hljs-built_in">id</span>):
    <span class="hljs-keyword">global</span> background_tasks
    rv = background_tasks.get(<span class="hljs-built_in">id</span>)
    <span class="hljs-keyword">if</span> rv <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
        <span class="hljs-keyword">return</span> not_found(<span class="hljs-literal">None</span>)
    <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(rv, Thread):
        <span class="hljs-keyword">return</span> jsonify({}), <span class="hljs-number">202</span>, {<span class="hljs-string">'Location'</span>: url_for(<span class="hljs-string">'get_task_status'</span>, <span class="hljs-built_in">id</span>=<span class="hljs-built_in">id</span>)}
    <span class="hljs-keyword">if</span> app.config[<span class="hljs-string">'AUTO_DELETE_BG_TASKS'</span>]:
        <span class="hljs-keyword">del</span> background_tasks[<span class="hljs-built_in">id</span>]
    <span class="hljs-keyword">return</span> rv
</code></pre>
    <p class="normal">Once we retrieve the resource, it is deleted. This is done by setting <code class="inlineCode">app.config['AUTO_DELETE_BG_TASKS']</code> to <code class="inlineCode">true</code> at the top of the app. We will add this decorator to <a id="_idIndexMarker748"/>our version endpoints without <a id="_idIndexMarker749"/>changing the other part of the code because all of the complexity is hidden in the decorator (how cool is that?):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">@app.route(</span><span class="hljs-string">'/devices/&lt;int:id&gt;/version'</span><span class="hljs-params">, methods=[</span><span class="hljs-string">'GET'</span><span class="hljs-params">]</span><span class="hljs-meta">)</span>
<span class="hljs-meta">@background</span>
<span class="hljs-keyword">def</span> <span class="hljs-title">get_device_version</span>(<span class="hljs-built_in">id</span>):
    device = Device.query.get_or_404(<span class="hljs-built_in">id</span>)
&lt;skip&gt;
<span class="hljs-meta">@app.route(</span><span class="hljs-string">'/devices/&lt;device_role&gt;/version'</span><span class="hljs-params">, methods=[</span><span class="hljs-string">'GET'</span><span class="hljs-params">]</span><span class="hljs-meta">)</span>
<span class="hljs-meta">@background</span>
<span class="hljs-keyword">def</span> <span class="hljs-title">get_role_version</span>(<span class="hljs-params">device_role</span>):
    device_id_list = [device.<span class="hljs-built_in">id</span> <span class="hljs-keyword">for</span> device <span class="hljs-keyword">in</span> Device.query.<span class="hljs-built_in">all</span>() <span class="hljs-keyword">if</span> device.role == device_role]
&lt;skip&gt;
</code></pre>
    <p class="normal">The end result is a two-part process. We will perform the <code class="inlineCode">GET</code> request for the endpoint and receive the location header:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>http GET http://192.168.2.126:5000/devices/spine/version 
HTTP/1.1 202 ACCEPTED
Connection: close
Content-Length: 3
Content-Type: application/json
Date: Wed, 21 Sep 2022 18:25:25 GMT
Location: /status/bb57f6cac4c64e0aa2e67415eb7cabd0
Server: Werkzeug/2.2.2 Python/3.10.4
{}
</code></pre>
    <p class="normal">We can then make a second request to the location to retrieve the result:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>http GET http://192.168.2.126:5000/status/bb57f6cac4c64e0aa2e67415eb7cabd0
HTTP/1.1 200 OK
Connection: close
Content-Length: 389
Content-Type: application/json
Date: Wed, 21 Sep 2022 18:28:30 GMT
Server: Werkzeug/2.2.2 Python/3.10.4
{
    "lax-edg-r1": "('lax-edg-r1', b'show version | i V\\r\\nCisco IOS Software, IOSv Software (VIOS-ADVENTERPRISEK9-M), Version 15.8(3)M2, RELEASE SOFTWARE (fc2)\\r\\nProcessor board ID 98U40DKV403INHIULHYHB\\r\\n')",
    "lax-edg-r2": "('lax-edg-r2', b'show version | i V\\r\\nCisco IOS Software, IOSv Software (VIOS-ADVENTERPRISEK9-M), Version 15.8(3)M2, RELEASE SOFTWARE (fc2)\\r\\n')"
}
</code></pre>
    <p class="normal">To verify that the <a id="_idIndexMarker750"/>status code <code class="inlineCode">202</code> is returned when <a id="_idIndexMarker751"/>the resource is not ready, we will use the following script, <code class="inlineCode">chapter9_request_1.py</code>, to immediately make a request to the new resource:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> requests, time
server = <span class="hljs-string">'http://192.168.2.126:5000'</span>
endpoint = <span class="hljs-string">'/devices/1/version'</span>
<span class="hljs-comment"># First request to get the new resource</span>
r = requests.get(server+endpoint)
resource = r.headers[<span class="hljs-string">'location'</span>]
<span class="hljs-built_in">print</span>(<span class="hljs-string">"Status: {} Resource: {}"</span>.<span class="hljs-built_in">format</span>(r.status_code, resource))
<span class="hljs-comment"># Second request to get the resource status </span>
r = requests.get(server+<span class="hljs-string">"/"</span>+resource)
<span class="hljs-built_in">print</span>(<span class="hljs-string">"Immediate Status Query to Resource: "</span> + <span class="hljs-built_in">str</span>(r.status_code))
<span class="hljs-built_in">print</span>(<span class="hljs-string">"Sleep for 2 seconds"</span>)
time.sleep(<span class="hljs-number">2</span>)
<span class="hljs-comment"># Third request to get the resource status</span>
r = requests.get(server+<span class="hljs-string">"</span><span class="hljs-string">/"</span>+resource)
<span class="hljs-built_in">print</span>(<span class="hljs-string">"Status after 2 seconds: "</span> + <span class="hljs-built_in">str</span>(r.status_code))
</code></pre>
    <p class="normal">As you can see in the result, the status code is returned while the resource is still being run in the background as <code class="inlineCode">202</code>:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>python chapter9_request_1.py 
Status: 202 Resource: /status/960b3a4a81d04b2cb7206d725464ef71
Immediate Status Query to Resource: 202
Sleep for 2 seconds
Status after 2 seconds: 200
</code></pre>
    <p class="normal">Our APIs are <a id="_idIndexMarker752"/>coming along nicely! Because <a id="_idIndexMarker753"/>our network resource is valuable, we should secure API access to only authorized personnel. We will add basic security measures to our API in the next section.</p>
    <h1 class="heading-1" id="_idParaDest-228">Authentication and Authorization</h1>
    <p class="normal">For basic user <a id="_idIndexMarker754"/>authentication, we will use Flask’s <code class="inlineCode">httpauth</code> (<a href="https://flask-httpauth.readthedocs.io/en/latest/"><span class="url">https://flask-httpauth.readthedocs.io/en/latest/</span></a>) extension, written by Miguel Grinberg, as <a id="_idIndexMarker755"/>well as the password functions in Werkzeug. The <code class="inlineCode">httpauth</code> extension <a id="_idIndexMarker756"/>should have been installed as part of the <code class="inlineCode">requirements.txt</code> installation at the beginning of this chapter. The new file illustrating the security feature is named <code class="inlineCode">chapter9_9.py</code>. In the script, we will start with a few more module imports:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">from</span> werkzeug.security <span class="hljs-keyword">import</span> generate_password_hash, check_password_hash
<span class="hljs-keyword">from</span> flask_httpauth <span class="hljs-keyword">import</span> HTTPBasicAuth
</code></pre>
    <p class="normal">We will create an <code class="inlineCode">HTTPBasicAuth</code> object as well as the <code class="inlineCode">user database</code> object. Note that, during the user creation process, we will pass the password value; however, we are only storing <code class="inlineCode">password_hash</code> instead of the cleartext <code class="inlineCode">password</code> itself:</p>
    <pre class="programlisting code"><code class="hljs-code">auth = HTTPBasicAuth()
&lt;skip&gt;
<span class="hljs-keyword">class</span> <span class="hljs-title">User</span>(db.Model):
    __tablename__ = <span class="hljs-string">'users'</span>
    <span class="hljs-built_in">id</span> = db.Column(db.Integer, primary_key=<span class="hljs-literal">True</span>)
    username = db.Column(db.String(<span class="hljs-number">64</span>), index=<span class="hljs-literal">True</span>)
    password_hash = db.Column(db.String(<span class="hljs-number">128</span>))
    <span class="hljs-keyword">def</span> <span class="hljs-title">set_password</span>(<span class="hljs-params">self, password</span>):
        self.password_hash = generate_password_hash(password)
    <span class="hljs-keyword">def</span> <span class="hljs-title">verify_password</span>(<span class="hljs-params">self, password</span>):
        <span class="hljs-keyword">return</span> check_password_hash(self.password_hash, password)
</code></pre>
    <p class="normal">The <code class="inlineCode">auth</code> object has a <code class="inlineCode">verify_password</code> decorator that we can use, along with Flask’s <code class="inlineCode">g</code> global context object that was created when the user request started. Because <code class="inlineCode">g</code> is global, if we save the user to the <code class="inlineCode">g</code> variable, it will live through the entire transaction:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">@auth.verify_password</span>
<span class="hljs-keyword">def</span> <span class="hljs-title">verify_password</span>(<span class="hljs-params">username, password</span>):
    g.user = User.query.filter_by(username=username).first()
    <span class="hljs-keyword">if</span> g.user <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
    <span class="hljs-keyword">return</span> g.user.verify_password(password)
</code></pre>
    <p class="normal">There is a <a id="_idIndexMarker757"/>handy <code class="inlineCode">before_request</code> handler that can be used before any API <a id="_idIndexMarker758"/>endpoint is called. We will combine the <code class="inlineCode">auth.login_required</code> decorator with the <code class="inlineCode">before_request</code> handler that will be applied to all the API routes:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">@app.before_request</span>
<span class="hljs-meta">@auth.login_required</span>
<span class="hljs-keyword">def</span> <span class="hljs-title">before_request</span>():
    <span class="hljs-keyword">pass</span>
</code></pre>
    <p class="normal">Lastly, we will use the <code class="inlineCode">unauthorized</code> error handler to return a <code class="inlineCode">response</code> object for the <code class="inlineCode">401</code> unauthorized error:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">@auth.error_handler</span>
<span class="hljs-keyword">def</span> <span class="hljs-title">unathorized</span>():
    response = jsonify({<span class="hljs-string">'status'</span>: <span class="hljs-number">401</span>, <span class="hljs-string">'</span><span class="hljs-string">error'</span>: <span class="hljs-string">'unauthorized'</span>,
                        <span class="hljs-string">'message'</span>: <span class="hljs-string">'please authenticate'</span>})
    response.status_code = <span class="hljs-number">401</span>
    <span class="hljs-keyword">return</span> response
</code></pre>
    <p class="normal">Before we can test user authentication, we will need to create users in our database:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">&gt;&gt;&gt;</span> <span class="hljs-con-keyword">from</span> chapter9_9 <span class="hljs-con-keyword">import</span> db, User
<span class="hljs-con-meta">&gt;&gt;&gt;</span> db.create_all()
<span class="hljs-con-meta">&gt;&gt;&gt;</span> u = User(username=<span class="hljs-con-string">'eric'</span>)
<span class="hljs-con-meta">&gt;&gt;&gt;</span> u.set_password(<span class="hljs-con-string">'secret'</span>)
<span class="hljs-con-meta">&gt;&gt;&gt;</span> db.session.add(u)
<span class="hljs-con-meta">&gt;&gt;&gt;</span> db.session.commit()
<span class="hljs-con-meta">&gt;&gt;&gt;</span> exit()
</code></pre>
    <p class="normal">Once you start your Flask development server, try to make a request, like we did previously. You should see that, this time, the server will reject the request with a <code class="inlineCode">401</code> unauthorized error:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>http GET http://192.168.2.126:5000/devices/
HTTP/1.1 401 UNAUTHORIZED
Connection: close
Content-Length: 82
Content-Type: application/json
Date: Wed, 21 Sep 2022 18:39:06 GMT
Server: Werkzeug/2.2.2 Python/3.10.4
WWW-Authenticate: Basic realm="Authentication Required"
{
    "error": "unahtorized",
    "message": "please authenticate",
    "status": 401
}
</code></pre>
    <p class="normal">We will now <a id="_idIndexMarker759"/>need to provide the authentication header for our <a id="_idIndexMarker760"/>requests:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>http --auth eric:secret GET http://192.168.2.126:5000/devices/
HTTP/1.1 200 OK
Connection: close
Content-Length: 193
Content-Type: application/json
Date: Wed, 21 Sep 2022 18:39:42 GMT
Server: Werkzeug/2.2.2 Python/3.10.4
{
    "device": [
        "http://192.168.2.126:5000/devices/1",
        "http://192.168.2.126:5000/devices/2",
        "http://192.168.2.126:5000/devices/3",
        "http://192.168.2.126:5000/devices/4"
    ]
}
</code></pre>
    <p class="normal">We now have a decent RESTful API set up for our network. When our user wants to retrieve network device information, they can query for the static content of the network. They can also perform network operations for a single device or a group of devices. We also added basic security measures to ensure that only the users we created can retrieve the information from our API. The cool part is that this is all done within a single file in less than 250 lines of code (less than 200 if you subtract the comments)!</p>
    <div class="note">
      <p class="normal">For more information on user session management, logging in, logging out, and remembering <a id="_idIndexMarker761"/>user sessions, I highly recommend using the Flask-Login (<a href="https://flask-login.readthedocs.io/en/latest/"><span class="url">https://flask-login.readthedocs.io/en/latest/</span></a>) extension.</p>
    </div>
    <p class="normal">We have now <a id="_idIndexMarker762"/>abstracted the underlying vendor API away from our network <a id="_idIndexMarker763"/>and replaced them with our RESTful API. By providing the abstraction, we are free to use what is required in the backend, such as Pexpect, while providing a uniform frontend to our requester. We can even take a step forward and replace the underlying network device without impacting the users making API calls to us. Flask provides this abstraction in a compact and easy-to-use way for us. We can also run Flask with a smaller footprint, such as by using containers.</p>
    <h1 class="heading-1" id="_idParaDest-229">Running Flask in containers</h1>
    <p class="normal">Containers have <a id="_idIndexMarker764"/>become very popular in the last few years. They offer <a id="_idIndexMarker765"/>more abstractions and virtualization beyond hypervisor-based virtual machines. For interested readers, we will offer a simple example of how we can run our Flask app in a Docker container.</p>
    <p class="normal">We will build our example based on the free DigitalOcean Docker tutorial on building containers on Ubuntu 20.04 machines (<a href="https://www.digitalocean.com/community/tutorials/how-to-build-and-deploy-a-flask-application-using-docker-on-ubuntu-20-04"><span class="url">https://www.digitalocean.com/community/tutorials/how-to-build-and-deploy-a-flask-application-using-docker-on-ubuntu-20-04</span></a>). If you are new to containers, I would highly recommend that you go through that tutorial and return to this section after.</p>
    <p class="normal">Let’s make sure Docker is installed:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>sudo docker –version
Docker version 20.10.18, build b40c2f6
</code></pre>
    <p class="normal">We will make a directory named <code class="inlineCode">TestApp</code> to house our code:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span><span class="hljs-con-built_in">mkdir</span> TestApp
<span class="hljs-con-meta">$ </span><span class="hljs-con-built_in">cd</span> TestApp/
</code></pre>
    <p class="normal">In the directory, we will make another directory called <code class="inlineCode">app</code> and create the <code class="inlineCode">__init__.py</code> file:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span><span class="hljs-con-built_in">mkdir</span> app
<span class="hljs-con-meta">$ </span><span class="hljs-con-built_in">touch</span> app/__init__.py
</code></pre>
    <p class="normal">Under the <code class="inlineCode">app</code> directory is where we will contain the logic of our application. Since we have been using a single-file app up to this point, we can simply copy over the contents of our <code class="inlineCode">chapter9_6.py</code> file to the <code class="inlineCode">app/__init__.py</code> file:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span><span class="hljs-con-built_in">cat</span> app/__init__.py 
from flask import Flask, url_for, jsonify, request
from flask_sqlalchemy import SQLAlchemy
app = Flask(__name__)
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///network.db'
db = SQLAlchemy(app)
@app.route('/')
def home():
    return "Hello Python Networking!"
&lt;skip&gt;
class Device(db.Model):
    __tablename__ = 'devices'
    id = db.Column(db.Integer, primary_key=True)
    hostname = db.Column(db.String(64), unique=True)
    loopback = db.Column(db.String(120), unique=True)
    mgmt_ip = db.Column(db.String(120), unique=True)
    role = db.Column(db.String(64))
    vendor = db.Column(db.String(64))
    os = db.Column(db.String(64))
&lt;skip&gt;
</code></pre>
    <p class="normal">We can also <a id="_idIndexMarker766"/>copy the SQLite database file we created <a id="_idIndexMarker767"/>to this directory:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>tree app/
app/
├── __init__.py
├── network.db
</code></pre>
    <p class="normal">We will place the <code class="inlineCode">requirements.txt</code> file in the <code class="inlineCode">TestApp</code> directory:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span><span class="hljs-con-built_in">cat</span> requirements.txt 
Flask==1.1.1
Flask-HTTPAuth==3.3.0
Flask-SQLAlchemy==2.4.1
Jinja2==2.10.1
MarkupSafe==1.1.1
Pygments==2.4.2
SQLAlchemy==1.3.9
Werkzeug==0.16.0
httpie==1.0.3
itsdangerous==1.1.0
python-dateutil==2.8.0
requests==2.20.1
</code></pre>
    <div class="note">
      <p class="normal">Due to a conflict with the <code class="inlineCode">tiangolo/uwsgi-nginx-flask</code> image and some later versions of Flask packages, this requirements file is reverting to Flask 1.1.1. The portion of code we worked on works in both version 1.1.1 and the latest Flask version.</p>
    </div>
    <p class="normal">We will <a id="_idIndexMarker768"/>create the <code class="inlineCode">main.py</code> file as our entry point and <a id="_idIndexMarker769"/>an <code class="inlineCode">ini</code> file for <code class="inlineCode">uwsgi</code>:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span><span class="hljs-con-built_in">cat</span> main.py
from app import app
<span class="hljs-con-meta">$ </span><span class="hljs-con-built_in">cat</span> uwsgi.ini
[uwsgi]
module = main
callable = app
master = true
</code></pre>
    <p class="normal">We will use a pre-made Docker image and create a <code class="inlineCode">Dockerfile</code> that builds the Docker image:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span><span class="hljs-con-built_in">cat</span> Dockerfile 
FROM tiangolo/uwsgi-nginx-flask:python3.7-alpine3.7
RUN apk --update add bash vim
RUN mkdir /TestApp
ENV STATIC_URL /static
ENV STATIC_PATH /TestApp/static
COPY ./requirements.txt /TestApp/requirements.txt
RUN pip install -r /TestApp/requirements.txt 
</code></pre>
    <p class="normal">Our <code class="inlineCode">start.sh</code> shell script will build the image, run it as a daemon in the background, then forward port <code class="inlineCode">8000</code> to the Docker container:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span><span class="hljs-con-built_in">cat</span> start.sh 
<span class="hljs-con-meta">#</span>!/bin/bash
app="docker.test"
docker build -t ${app} .
docker run -d -p 8000:80 \
  --name=${app} \
  -v $PWD:/app ${app}
</code></pre>
    <p class="normal">We can now use the <code class="inlineCode">start.sh</code> script to build the image and launch our container:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>sudo bash start.sh 
Sending build context to Docker daemon  48.13kB
Step 1/7 : FROM tiangolo/uwsgi-nginx-flask:python3.8
python3.8: Pulling from tiangolo/uwsgi-nginx-flask
85bed84afb9a: Pulling fs layer 
5fdd409f4b2b: Pulling fs layer
&lt;skip&gt;
</code></pre>
    <p class="normal">Our Flask now <a id="_idIndexMarker770"/>runs in the container that can be viewed from <a id="_idIndexMarker771"/>our host machine port <code class="inlineCode">8000</code>:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>sudo docker ps
CONTAINER ID   IMAGE         COMMAND                  CREATED         STATUS         PORTS                                            NAMES
25c83da6082c   docker.test   "/entrypoint.sh /sta…"   2 minutes ago   Up 2 minutes   443/tcp, 0.0.0.0:8000-&gt;80/tcp, :::8000-&gt;80/tcp   docker.test
</code></pre>
    <p class="normal">We can <a id="_idIndexMarker772"/>see the <strong class="keyWord">management host IP</strong> displayed in the address bar as follows:</p>
    <figure class="mediaobject"><img alt="" src="../Images/B18403_09_05.png"/></figure>
    <p class="packt_figref">Figure 9.5: Management Host IP Forwarding</p>
    <p class="normal">We can <a id="_idIndexMarker773"/>see the <strong class="keyWord">Flask API endpoint</strong> as follows:</p>
    <figure class="mediaobject"><img alt="" src="../Images/B18403_09_06.png"/></figure>
    <p class="packt_figref">Figure 9.6: API Endpoint</p>
    <p class="normal">Once we <a id="_idIndexMarker774"/>are done, we can use the following commands <a id="_idIndexMarker775"/>to stop and delete the container:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>sudo docker stop &lt;container <span class="hljs-con-built_in">id</span>&gt;
<span class="hljs-con-meta">$ </span>sudo docker <span class="hljs-con-built_in">rm</span> &lt;containter <span class="hljs-con-built_in">id</span>&gt;
</code></pre>
    <p class="normal">We can also delete the Docker image:</p>
    <pre class="programlisting con"><code class="hljs-con"><span class="hljs-con-meta">$ </span>sudo docker images -a -q <span class="hljs-con-comment">#find the image id</span>
<span class="hljs-con-meta">$ </span>sudo docker rmi &lt;image <span class="hljs-con-built_in">id</span>&gt;
</code></pre>
    <p class="normal">As we can see, running Flask in a container gives us even more flexibility and the option to deploy our API abstraction in production. Containers, of course, offer their complexity and add more management tasks, so we need to weigh up the benefits and overhead when it comes to our deployment methods. We are close to the end of this chapter, so let’s look at what we have done so far before looking forward to the next chapters.</p>
    <h1 class="heading-1" id="_idParaDest-230">Summary</h1>
    <p class="normal">In this chapter, we started to move on to the path of building RESTful APIs for our network. We looked at popular Python web frameworks, namely Django and Flask, and compared and contrasted the two. By choosing Flask, we can start small and expand on features by using Flask extensions.</p>
    <p class="normal">In our lab, we used the virtual environment to separate the Flask installation base from our global site packages. The lab network consists of several IOSv nodes, two of which we have designated as spine routers while the other two as leaf routers. We took a tour of the basics of Flask and used the simple <code class="inlineCode">HTTPie</code> client to test our API setup.</p>
    <p class="normal">Among the different setups of Flask, we placed special emphasis on URL dispatch as well as URL variables because they are the initial logic between the requesters and our API system. We took a look at using Flask-SQLAlchemy and SQLite to store and return network elements that are static in nature. For operation tasks, we also created API endpoints while calling other programs, such as Pexpect, to accomplish configuration tasks. We improved the setup by adding asynchronous handling and user authentication to our API. We also looked at how to run our Flask API application in a Docker container.</p>
    <p class="normal">In Chapter 10, Introduction to Async IO, we will shift gears to look at one of the newer features in Python 3, Async IO, and how it can be applied to network engineering.</p>
    <h1 class="heading-1">Join our book community</h1>
    <p class="normal">To join our community for this book – where you can share feedback, ask questions to the author, and learn about new releases – follow the QR code below:</p>
    <p class="normal"><a href="https://packt.link/networkautomationcommunity"><span class="url">https://packt.link/networkautomationcommunity</span></a></p>
    <p class="normal"><img alt="" src="../Images/QR_Code2903617220506617062.png"/></p>
  </div>
</body></html>