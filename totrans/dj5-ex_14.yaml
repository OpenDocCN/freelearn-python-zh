- en: '14'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rendering and Caching Content
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, you used model inheritance and generic relations to
    create flexible course content models. You implemented a custom model field and
    you built a course management system using class-based views. Finally, you created
    a JavaScript drag-and-drop functionality using asynchronous HTTP requests to order
    course modules and their contents.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will build the functionality to create a student registration
    system and manage student enrollment in courses. You will implement rendering
    of the different types of course content and learn how to cache data using the
    Django cache framework.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering diverse content types is essential in e-learning platforms, where
    courses are typically structured with flexible modules that include a mix of text,
    images, videos, and documents. In this context, caching also becomes crucial.
    Since course content usually remains unchanged for extended periods – days, weeks,
    or even months – caching helps conserve computing power and reduces the need to
    query the database each time students access the same materials. By caching data,
    you not only save system resources but also improve performance when delivering
    content to a large number of students.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will:'
  prefs: []
  type: TYPE_NORMAL
- en: Create public views for displaying course information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build a student registration system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manage student enrollment in courses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Render diverse content for course modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Install and configure Memcached
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cache content using the Django cache framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the Memcached and Redis cache backends
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitor your Redis server in the Django administration site
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functional overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Figure 14.1* shows a representation of the views, templates, and functionalities
    that will be built in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_14_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.1: Diagram of functionalities built in Chapter 14'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will implement the `CourseListView` public view to list
    courses and `CourseDetailView` to show the details of a course. You will implement
    `StudentRegistrationView` to allow students to create user accounts and `StudentCourseListView`
    for students to enroll in courses. You will create the `StudentCourseListView`
    for students to see the list of courses they are enrolled in and the `StudentCourseDetailView`
    to access all the content of a course, organized in the different course modules.
    You will also add a cache to your views using the Django cache framework, first
    with the Memcached backend and then replacing it with the Redis cache backend.
  prefs: []
  type: TYPE_NORMAL
- en: The source code for this chapter can be found at [https://github.com/PacktPublishing/Django-5-by-example/tree/main/Chapter14](https://github.com/PacktPublishing/Django-5-by-example/tree/main/Chapter14).
  prefs: []
  type: TYPE_NORMAL
- en: All Python modules used in this chapter are included in the `requirements.txt`
    file in the source code that comes along with this chapter. You can follow the
    instructions to install each Python module below or you can install all requirements
    at once with the `python -m pip install -r requirements.txt` command.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying the catalog of courses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You might be eager to get to rendering and caching but there are a few items
    we must set up before we can do that. Let’s start with the course catalog. For
    your course catalog, you have to build the following functionalities:'
  prefs: []
  type: TYPE_NORMAL
- en: List all available courses, optionally filtered by subject
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Display a single course overview
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This will allow students to see all the courses available on the platform and
    enroll in those they are interested in. Edit the `views.py` file of the `courses`
    application and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the `CourseListView` view. It inherits from `TemplateResponseMixin`
    and `View`. In this view, the following tasks are performed:'
  prefs: []
  type: TYPE_NORMAL
- en: Retrieve all subjects using the ORM’s `annotate()` method with the `Count()`
    aggregation function to include the total number of courses for each subject.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Retrieve all available courses, including the total number of modules contained
    in each course.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If a subject slug URL parameter is given, retrieve the corresponding `subject`
    object and limit the query to the courses that belong to the given subject.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `render_to_response()` method provided by `TemplateResponseMixin` to
    render the objects to a template and return an HTTP response.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let’s create a detail view for displaying a single course overview. Add the
    following code to the `views.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This view inherits from the generic `DetailView` provided by Django. You specify
    the `model` and `template_name` attributes. Django’s `DetailView` expects a primary
    key (`pk`) or slug URL parameter to retrieve a single object for the given model.
    The view renders the template specified in `template_name`, including the `Course`
    object in the template context variable `object`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the main `urls.py` file of the `educa` project and add the following URL
    pattern to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: You add the `course_list` URL pattern to the main `urls.py` file of the project
    because you want to display the list of courses in the URL `http://127.0.0.1:8000/`,
    and all other URLs for the `courses` application have the `/course/` prefix.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `urls.py` file of the `courses` application and add the following
    URL patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You define the following URL patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: '`course_list_subject`: For displaying all courses for a subject'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`course_detail`: For displaying a single course overview'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s build templates for the `CourseListView` and `CourseDetailView` views.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the following file structure inside the `templates/courses/` directory
    of the `courses` application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Edit the `courses/course/list.html` template of the `courses` application and
    write the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Make sure that no template tag is split into multiple lines.
  prefs: []
  type: TYPE_NORMAL
- en: This is the template for listing the available courses. You create an HTML list
    to display all `Subject` objects and build a link to the `course_list_subject`
    URL for each of them. You also include the total number of courses for each subject
    and use the `pluralize` template filter to add a plural suffix to the word **course**
    when the number is different than `1`, to show *0 courses*, *1 course*, *2 courses*,
    etc. You add a `selected` HTML class to highlight the current subject if a subject
    is selected. You iterate over every `Course` object, displaying the total number
    of modules and the instructor’s name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the development server and open `http://127.0.0.1:8000/` in your browser.
    You should see a page similar to the following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application  Description automatically generated](img/B21088_14_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.2: The course list page'
  prefs: []
  type: TYPE_NORMAL
- en: The left sidebar contains all subjects, including the total number of courses
    for each of them. You can click any subject to filter the courses displayed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `courses/course/detail.html` template and add the following code to
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This template displays the overview and details for a single course. Open `http://127.0.0.1:8000/`
    in your browser and click on one of the courses. You should see a page with the
    following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A picture containing text  Description automatically generated](img/B21088_14_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.3: The course overview page'
  prefs: []
  type: TYPE_NORMAL
- en: You have created a public area for displaying courses. Next, you need to allow
    users to register as students and enroll in courses.
  prefs: []
  type: TYPE_NORMAL
- en: Adding student registration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We need to implement student registration to enable enrollment in courses and
    access to content. Create a new application using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Edit the `settings.py` file of the `educa` project and add the new application
    to the `INSTALLED_APPS` setting, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Creating a student registration view
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Edit the `views.py` file of the `students` application and write the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the view that allows students to register on your site. You use the
    generic `CreateView`, which provides the functionality for creating model objects.
    This view requires the following attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`template_name`: The path of the template to render this view.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`form_class`: The form for creating objects, which has to be `ModelForm`. You
    use Django’s `UserCreationForm` as the registration form to create `User` objects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`success_url`: The URL to redirect the user to when the form is successfully
    submitted. For this, you reverse the URL named `student_course_list`, which we
    will create in the *Accessing the course contents* section for listing the courses
    that students are enrolled in.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `form_valid()` method is executed when valid form data has been posted.
    It has to return an HTTP response. You override this method to log the user in
    after they have successfully signed up.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file inside the `students` application directory and name it `urls.py`.
    Add the following code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, edit the main `urls.py` of the `educa` project and include the URLs for
    the `students` application by adding the following pattern to your URL configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the following file structure inside the `students` application directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Edit the `students/student/registration.html` template and add the following
    code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the development server and open `http://127.0.0.1:8000/students/register/`
    in your browser. You should see a registration form like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application, email  Description automatically
    generated](img/B21088_14_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.4: The student registration form'
  prefs: []
  type: TYPE_NORMAL
- en: Note that the `student_course_list` URL specified in the `success_url` attribute
    of the `StudentRegistrationView` view doesn’t exist yet. If you submit the form,
    Django won’t find the URL to redirect you to after a successful registration.
    As mentioned, you will create this URL in the *Accessing the course contents*
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Enrolling in courses
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After users create an account, they should be able to enroll in courses. To
    store enrollments, you need to create a many-to-many relationship between the
    `Course` and `User` models.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `models.py` file of the `courses` application and add the following
    field to the `Course` model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'From the shell, execute the following command to create a migration for this
    change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see output similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, execute the next command to apply pending migrations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see some output that ends with the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: You can now associate students with the courses in which they are enrolled.
    Let’s create the functionality for students to enroll in courses.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file inside the `students` application directory and name it `forms.py`.
    Add the following code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This form will be used to enroll students in courses. The `course` field is
    for the course in which the user will be enrolled; therefore, it’s `ModelChoiceField`.
    You use a `HiddenInput` widget because this field is not intended to be visible
    to the user. Initially, you define the QuerySet as `Course.objects.none()`. Using
    `none()` creates an empty QuerySet that does not return any objects and, importantly,
    does not query the database. This avoids unnecessary database load during form
    initialization. You populate the actual QuerySet in the `__init__()` method of
    the form. This dynamic setting allows you to adapt the form to different situations,
    such as filtering available courses based on specific criteria. Overall, this
    approach gives you greater flexibility in managing form data, ensuring that data
    is fetched based on the context in which the form is used. This method also aligns
    with best practices in Django for handling form QuerySets efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: 'You are going to use this form in the `CourseDetailView` view to display a
    button to enroll. Edit the `views.py` file of the `students` application and add
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This is the `StudentEnrollCourseView` view. It handles the enrollment of students
    in courses. The view inherits from the `LoginRequiredMixin` mixin so that only
    logged-in users can access the view. It also inherits from Django’s `FormView`
    view, since it handles a form submission. You use the `CourseEnrollForm` form
    for the `form_class` attribute and also define a `course` attribute for storing
    the given `Course` object. When the form is valid, the current user is added to
    the students enrolled in the course.
  prefs: []
  type: TYPE_NORMAL
- en: The `get_success_url()` method returns the URL that the user will be redirected
    to if the form was successfully submitted. This method is equivalent to the `success_url`
    attribute. Then, you reverse the URL named `student_course_detail`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `urls.py` file of the `students` application and add the following
    URL pattern to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s add the enroll button form to the course overview page. Edit the `views.py`
    file of the `courses` application and modify `CourseDetailView` to make it look
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: You use the `get_context_data()` method to include the enrollment form in the
    context for rendering the templates. You initialize the hidden `course` field
    of the form with the current `Course` object so that it can be submitted directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `courses/course/detail.html` template and locate the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace it with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This is the button for enrolling in courses. If the user is authenticated, the
    enrollment button is displayed, including the hidden form that points to the `student_enroll_course`
    URL. If the user is not authenticated, a link to register on the platform will
    be displayed instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Make sure that the development server is running, open `http://127.0.0.1:8000/`
    in your browser, and click a course. If you are logged in, you should see an **ENROLL
    NOW** button placed below the course overview, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application, email  Description automatically
    generated](img/B21088_14_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.5: The course overview page, including an ENROLL NOW button'
  prefs: []
  type: TYPE_NORMAL
- en: If you are not logged in, you will see a **REGISTER TO ENROLL** button instead.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering course contents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once students are enrolled in courses, they need a central location to access
    all courses they are signed up for. We need to compile the list of courses the
    student is enrolled in and provide access to the contents of each course. Then,
    we need to implement a system to render various types of content, such as text,
    images, videos and documents, which make up the course modules. Let’s build the
    necessary views and templates for users to access course contents.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing course contents
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You need a view for displaying the courses that students are enrolled in and
    a view for accessing the actual course contents. Edit the `views.py` file of the
    `students` application and add the following code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This is the view to see courses that students are enrolled in. It inherits from
    `LoginRequiredMixin` to make sure that only logged-in users can access the view.
    It also inherits from the generic `ListView` for displaying a list of `Course`
    objects. You override the `get_queryset()` method to retrieve only the courses
    that a student is enrolled in; you filter the QuerySet by the student’s `ManyToManyField`
    field to do so.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, add the following code to the `views.py` file of the `students` application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This is the `StudentCourseDetailView` view. You override the `get_queryset()`
    method to limit the base QuerySet to courses in which the student is enrolled.
    You also override the `get_context_data()` method to set a course module in the
    context if the `module_id` URL parameter is given. Otherwise, you set the first
    module of the course. This way, enrolled students will be able to navigate through
    modules inside a course.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `urls.py` file of the `students` application and add the following
    URL patterns to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the following file structure inside the `templates/students/` directory
    of the `students` application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Edit the `students/course/list.html` template and add the following code to
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This template displays the courses that the student is enrolled in. Remember
    that when a new student successfully registers with the platform, they will be
    redirected to the `student_course_list` URL. Let’s also redirect students to this
    URL when they log in to the platform.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `settings.py` file of the `educa` project and add the following code
    to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This is the setting used by the `auth` module to redirect the student after
    a successful login if no `next` parameter is present in the request. After a successful
    login, a student will be redirected to the `student_course_list` URL to view the
    courses that they are enrolled in.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `students/course/detail.html` template and add the following code
    to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Make sure no template tag is split across multiple lines. This is the template
    for enrolled students to access the contents of a course. First, you build an
    HTML list including all course modules and highlighting the current module. Then,
    you iterate over the current module contents and access each content item to display
    it using `{{ item.render }}`. You will add the `render()` method to the content
    models next. This method will take care of rendering the content properly.
  prefs: []
  type: TYPE_NORMAL
- en: You can now access `http://127.0.0.1:8000/students/register/`, register a new
    student account, and enroll in any course.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering different types of content
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To display the course contents, you need to render the different content types
    that you created: *text*, *image*, *video*, and *file*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `models.py` file of the `courses` application and add the following
    `render()` method to the `ItemBase` model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This method uses the `render_to_string()` function for rendering a template
    and returning the rendered content as a string. Each kind of content is rendered
    using a template named after the content model. `self._meta.model_name` is used
    to generate the appropriate template name for each content model dynamically.
    The `render()` method provides a common interface for rendering diverse content.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the following file structure inside the `templates/courses/` directory
    of the `courses` application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Edit the `courses/content/text.html` template and write this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This is the template to render text content. The `linebreaks` template filter
    replaces line breaks in plain text with HTML line breaks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `courses/content/file.html` template and add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This is the template to render files. It generates a link to download the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `courses/content/image.html` template and write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This is the template to render images.
  prefs: []
  type: TYPE_NORMAL
- en: You also have to create a template for rendering `Video` objects. You will use
    `django-embed-video` for embedding video content. `django-embed-video` is a third-party
    Django application that allows you to embed videos in your templates, from sources
    such as YouTube or Vimeo, by simply providing their public URL.
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the package with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Edit the `settings.py` file of your project and add the application to the
    `INSTALLED_APPS` setting, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: You can find the `django-embed-video` application’s documentation at [https://django-embed-video.readthedocs.io/en/latest/.](https://django-embed-video.readthedocs.io/en/latest/.
    )
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `courses/content/video.html` template and write the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This is the template to render videos.
  prefs: []
  type: TYPE_NORMAL
- en: Now, run the development server and access `http://127.0.0.1:8000/course/mine/`
    in your browser. Access the site with a user that belongs to the `Instructors`
    group, and add multiple contents to a course. To include video content, you can
    just copy any YouTube URL, such as `https://www.youtube.com/watch?v=bgV39DlmZ2U`,
    and include it in the `url` field of the form.
  prefs: []
  type: TYPE_NORMAL
- en: 'After adding contents to the course, open `http://127.0.0.1:8000/`, click the
    course, and click on the **ENROLL NOW** button. You should be enrolled in the
    course and redirected to the `student_course_detail` URL. *Figure 14.6* shows
    a sample course contents page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, application, website  Description automatically
    generated](img/B21088_14_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.6: A course contents page'
  prefs: []
  type: TYPE_NORMAL
- en: Great! You have created a common interface for rendering courses with different
    types of content.
  prefs: []
  type: TYPE_NORMAL
- en: Using the cache framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Processing HTTP requests to your web application usually entails database access,
    data manipulation, and template rendering. It is much more expensive in terms
    of processing than just serving a static website. The overhead in some requests
    can be significant when your site starts getting more and more traffic. This is
    where caching becomes essential. By caching queries, calculation results, or rendered
    content in an HTTP request, you will avoid expensive operations in the following
    requests that need to return the same data. This translates into shorter response
    times and less processing on the server side.
  prefs: []
  type: TYPE_NORMAL
- en: Django includes a robust cache system that allows you to cache data with different
    levels of granularity. You can cache a single query, the output of a specific
    view, parts of rendered template content, or your entire site. Items are stored
    in the cache system for a default time, but you can specify the timeout when you
    cache data.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how the cache framework is usually used when your application processes
    an HTTP request:'
  prefs: []
  type: TYPE_NORMAL
- en: Try to find the requested data in the cache.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If found, return the cached data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If not found, perform the following steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Perform the database query or processing required to generate the data.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the generated data in the cache.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Return the data.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: You can read detailed information about Django’s cache system at [https://docs.djangoproject.com/en/5.0/topics/cache/](https://docs.djangoproject.com/en/5.0/topics/cache/).
  prefs: []
  type: TYPE_NORMAL
- en: Available cache backends
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Django comes with the following cache backends:'
  prefs: []
  type: TYPE_NORMAL
- en: '`backends.memcached.PyMemcacheCache` or `backends.memcached.PyLibMCCache`:
    Memcached backends. Memcached is a fast and efficient memory-based cache server.
    The backend to use depends on the Memcached Python bindings you choose.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`backends.redis.RedisCache`: A Redis cache backend. This backend was added
    in Django 4.0.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`backends.db.DatabaseCache`: Uses the database as a cache system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`backends.filebased.FileBasedCache`: Uses the file storage system. This serializes
    and stores each cache value as a separate file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`backends.locmem.LocMemCache`: A local memory cache backend. This is the default
    cache backend.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`backends.dummy.DummyCache`: A dummy cache backend intended only for development.
    It implements the cache interface without actually caching anything. This cache
    is per-process and thread-safe.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For optimal performance, use a memory-based cache backend like Memcached or
    Redis, since accessing memory is faster than accessing data from databases of
    files.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Memcached
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Memcached is a popular high-performance, memory-based cache server. We are going
    to use Memcached and the `PyMemcacheCache` Memcached backend.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the Memcached Docker image
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Run the following command from the shell to pull the Memcached Docker image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This will download the Memcached Docker image to your local machine. You can
    find more information about the official Memcached Docker image at [https://hub.docker.com/_/memcached](https://hub.docker.com/_/memcached).
    If you don’t want to use Docker, you can also download Memcached from [https://memcached.org/downloads](https://memcached.org/downloads).
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the Memcached Docker container with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Memcached runs on port `11211` by default. The `-p` option is used to publish
    the `11211` port to the same host interface port. The `-m` option is used to limit
    the memory for the container to `64` MB. Memcached runs in memory, and it is allotted
    a specified amount of RAM. When the allotted RAM is full, Memcached starts removing
    the oldest data to store new data. If you want to run the command in detached
    mode (in the background of your terminal), you can use the `-d` option.
  prefs: []
  type: TYPE_NORMAL
- en: You can find more information about Memcached at [https://memcached.org](https://memcached.org).
  prefs: []
  type: TYPE_NORMAL
- en: Installing the Memcached Python binding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After installing Memcached, you have to install a Memcached Python binding.
    We will install `pymemcache`, which is a fast, pure-Python Memcached client. Run
    the following command in the shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: You can read more information about the `pymemcache` library at [https://github.com/pinterest/pymemcache](https://github.com/pinterest/pymemcache).
  prefs: []
  type: TYPE_NORMAL
- en: Django cache settings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Django provides the following cache settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CACHES`: A dictionary containing all available caches for the project.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CACHE_MIDDLEWARE_ALIAS`: The cache alias to use for storage.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CACHE_MIDDLEWARE_KEY_PREFIX`: The prefix to use for cache keys. Set a prefix
    to avoid key collisions if you share the same cache between several sites.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CACHE_MIDDLEWARE_SECONDS`: The default number of seconds to cache pages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The caching system for the project can be configured using the `CACHES` settings.
    This setting allows you to specify the configuration for multiple caches. Each
    cache included in the `CACHES` dictionary can specify the following data:'
  prefs: []
  type: TYPE_NORMAL
- en: '`BACKEND`: The cache backend to use.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`KEY_FUNCTION`: A string containing a dotted path to a callable that takes
    a prefix, version, and key as arguments and returns a final cache key.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`KEY_PREFIX`: A string prefix for all cache keys, to avoid collisions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LOCATION`: The location of the cache. Depending on the cache backend, this
    might be a directory, a host and port, or a name for the in-memory backend.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OPTIONS`: Any additional parameters to be passed to the cache backend.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TIMEOUT`: The default timeout, in seconds, for storing the cache keys. It
    is 300 seconds by default, which is 5 minutes. If set to `None`, the cache keys
    will not expire.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VERSION`: The default version number for the cache keys. Useful for cache
    versioning.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can find more information about the `CACHES` settings at [https://docs.djangoproject.com/en/5.0/ref/settings/#caches](https://docs.djangoproject.com/en/5.0/ref/settings/#caches).
  prefs: []
  type: TYPE_NORMAL
- en: Adding Memcached to your project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s configure the cache for your project. Edit the `settings.py` file of
    the `educa` project and add the following code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: You are using the `PyMemcacheCache` backend. You specify its location using
    the `address:port` notation. If you have multiple Memcached instances, you can
    use a list for `LOCATION`.
  prefs: []
  type: TYPE_NORMAL
- en: You have set up Memcached for your project. Let’s start caching data!
  prefs: []
  type: TYPE_NORMAL
- en: Cache levels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Django provides the following levels of caching, listed here by ascending order
    of granularity:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Low-level cache API**: Provides the highest granularity. Allows you to cache
    specific queries or calculations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Template cache**: Allows you to cache template fragments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Per-view cache**: Provides caching for individual views.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Per-site cache**: The highest-level cache. It caches your entire site.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Think about your cache strategy before implementing caching. Focus first on
    expensive queries or calculations that are not calculated on a per-user basis.
  prefs: []
  type: TYPE_NORMAL
- en: In the upcoming sections, we will explore how to use each of these caching levels
    in our project.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start by learning how to use the low-level cache API in your Python code.
  prefs: []
  type: TYPE_NORMAL
- en: Using the low-level cache API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The low-level cache API allows you to store objects in the cache with any granularity.
    It is located at `django.core.cache`. You can import it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'This uses the default cache. It’s equivalent to `caches[''default'']`. Accessing
    a specific cache is also possible via its alias:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s take a look at how the cache API works. Open the Django shell with the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'You access the default cache backend and use `set(key, value, timeout)` to
    store a key named `''musician''` with a value that is the string `''Django Reinhardt''`
    for 20 seconds. If you don’t specify a timeout, Django uses the default timeout
    specified for the cache backend in the `CACHES` settings. Now, execute the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'You retrieve the key from the cache. Wait for 20 seconds and execute the same
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: No value is returned this time. The `'musician'` cache key has expired and the
    `get()` method returns `None` because the key is not in the cache anymore.
  prefs: []
  type: TYPE_NORMAL
- en: Always avoid storing a `None` value in a cache key because you won’t be able
    to distinguish between the actual value and a cache miss.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s cache a QuerySet with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'You perform a QuerySet on the `Subject` model and store the returned objects
    in the `''my_subjects''` key. Let’s retrieve the cached data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'You are going to cache some queries in your views. Edit the `views.py` file
    of the `courses` application and add the following import:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `get()` method of the `CourseListView`, find the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace the lines with the following ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: In this code, you try to get the `all_subjects` key from the cache using `cache.get()`.
    This returns `None` if the given key is not found. If no key is found (not cached
    yet or cached but timed out), the query is performed to retrieve all `Subject`
    objects and their number of courses, and the result is cached using `cache.set()`.
  prefs: []
  type: TYPE_NORMAL
- en: Checking cache requests with Django Debug Toolbar
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s add Django Debug Toolbar to the project to check the cache queries. You
    learned how to use Django Debug Toolbar in *Chapter 7*, *Tracking User Actions*.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, install Django Debug Toolbar with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Edit the `settings.py` file of your project and add `debug_toolbar` to the
    `INSTALLED_APPS` setting, as follows. The new line is highlighted in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'In the same file, add the following line highlighted in bold to the `MIDDLEWARE`
    setting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Remember that `DebugToolbarMiddleware` has to be placed before any other middleware,
    except for middleware that encodes the response’s content, such as `GZipMiddleware`,
    which, if present, should come first.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following lines at the end of the `settings.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Django Debug Toolbar will only display if your IP address matches an entry in
    the `INTERNAL_IPS` setting.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the main `urls.py` file of the project and add the following URL pattern
    to `urlpatterns`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Run the development server and open `http://127.0.0.1:8000/` in your browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should now see Django Debug Toolbar on the right side of the page. Click
    on **Cache** in the sidebar menu. You will see the following panel:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_14_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.7: The Cache panel of Django Debug Toolbar including cache requests
    for CourseListView on a cache miss'
  prefs: []
  type: TYPE_NORMAL
- en: Under **Total calls** you should see **2**. The first time the `CourseListView`
    view is executed, there are two cache requests. Under **Commands**, you will see
    that the `get` command has been executed once, and that the `set` command has
    been executed once as well. The `get` command corresponds to the call that retrieves
    the `all_subjects` cache key. This is the first call displayed under **Calls**.
    The first time the view is executed, a cache miss occurs because no data is cached
    yet. That’s why there is **1** under **Cache misses**. Then, the `set` command
    is used to store the results of the `subjects` QuerySet in the cache using the
    `all_subjects` cache key. This is the second call displayed under **Calls**.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the **SQL** menu item of Django Debug Toolbar, you will see the total number
    of SQL queries executed in this request. This includes the query to retrieve all
    subjects that are then stored in the cache:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, application  Description automatically generated](img/B21088_14_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.8: SQL queries executed for CourseListView on a cache miss'
  prefs: []
  type: TYPE_NORMAL
- en: 'Reload the page in the browser and click on **Cache** in the sidebar menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_14_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.9: The Cache panel of Django Debug Toolbar, including cache requests
    for the CourseListView view on a cache hit'
  prefs: []
  type: TYPE_NORMAL
- en: Now, there is only a single cache request. Under **Total calls**, you should
    see **1**, and under **Commands**,you can see that the cache request corresponds
    to a `get` command. In this case, there is a cache hit (see **Cache hits**) instead
    of a cache miss because the data has been found in the cache. Under **Calls**,
    you can see the `get` request to retrieve the `all_subjects` cache key.
  prefs: []
  type: TYPE_NORMAL
- en: 'Check the **SQL** menu item of the debug toolbar. You should see that there
    is one less SQL query in this request. You are saving one SQL query because the
    view finds the data in the cache and doesn’t need to retrieve it from the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, application  Description automatically generated](img/B21088_14_10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.10: SQL queries executed for CourseListView on a cache hit'
  prefs: []
  type: TYPE_NORMAL
- en: In this example, for a single request, it takes more time to retrieve the item
    from the cache than the time saved on the additional SQL query. However, when
    you have many users accessing your site, you will find that significant time reductions
    can be achieved by retrieving the data from the cache instead of hitting the database,
    and you will be able to serve the site to more concurrent users.
  prefs: []
  type: TYPE_NORMAL
- en: Successive requests to the same URL will retrieve the data from the cache. Since
    we didn’t specify a timeout when caching data with `cache.set('all_subjects',
    subjects)` in the `CourseListView` view, the default timeout will be used (300
    seconds by default, which is 5 minutes). When the timeout is reached, the next
    request to the URL will generate a cache miss, the QuerySet will be executed,
    and data will be cached for another 5 minutes. You can define a different default
    timeout in the `TIMEOUT` element of the `CACHES` setting.
  prefs: []
  type: TYPE_NORMAL
- en: Low-level caching based on dynamic data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Often, you will want to cache something that is based on dynamic data. In these
    cases, you have to build dynamic keys that contain all the information required
    to uniquely identify the cached data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `views.py` file of the `courses` application and modify the `CourseListView`
    view to make it look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: In this case, you also cache both all courses and courses filtered by subject.
    You use the `all_courses` cache key for storing all courses if no subject is given.
    If there is a subject, you build the key dynamically with `f'subject_{subject.id}_courses'`.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s important to note that you can’t use a cached QuerySet to build other
    QuerySets, since what you cached are actually the results of the QuerySet. So
    you can’t do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Instead, you have to create the base QuerySet `Course.objects.annotate(total_modules=Count('modules'))`,
    which is not going to be executed until it is forced, and use it to further restrict
    the QuerySet with `all_courses.filter(subject=subject)` for cases where the data
    was not found in the cache.
  prefs: []
  type: TYPE_NORMAL
- en: Caching template fragments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Caching template fragments is a higher-level approach. You need to load the
    cache template tags in your template using `{% load cache %}`. Then, you will
    be able to use the `{% cache %}` template tag to cache specific template fragments.
    You usually use the template tag as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'The `{% cache %}` template tag has two required arguments: the timeout in seconds
    and a name for the fragment. If you need to cache content depending on dynamic
    data, you can do so by passing additional arguments to the `{% cache %}` template
    tag to uniquely identify the fragment.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `/students/course/detail.html` file of the `students` application.
    Add the following code at the top of it, just after the `{% extends %}` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, find the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace them with the following ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: You cache this template fragment using the name `module_contents` and pass the
    current `Module` object to it. Thus, you uniquely identify the fragment. This
    is important to avoid caching a module’s contents and serving the wrong content
    when a different module is requested.
  prefs: []
  type: TYPE_NORMAL
- en: If the `USE_I18N` setting is set to `True`, the per-site middleware cache will
    respect the active language. If you use the `{% cache %}` template tag, you have
    to use one of the translation-specific variables available in templates to achieve
    the same result, such as `{% cache 600 name request.LANGUAGE_CODE %}`.
  prefs: []
  type: TYPE_NORMAL
- en: Caching views
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can cache the output of individual views using the `cache_page` decorator
    located at `django.views.decorators.cache`. The decorator requires a `timeout`
    argument (in seconds).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s use it in your views. Edit the `urls.py` file of the `students` application
    and add the following import:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, apply the `cache_page` decorator to the `student_course_detail` and `student_course_detail_module`
    URL patterns, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Now, the complete content returned by the `StudentCourseDetailView` is cached
    for 15 minutes.
  prefs: []
  type: TYPE_NORMAL
- en: The per-view cache uses the URL to build the cache key. Multiple URLs pointing
    to the same view will be cached separately.
  prefs: []
  type: TYPE_NORMAL
- en: Using the per-site cache
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is the highest-level cache. It allows you to cache your entire site. To
    allow the per-site cache, edit the `settings.py` file of your project and add
    the `UpdateCacheMiddleware` and `FetchFromCacheMiddleware` classes to the `MIDDLEWARE`
    setting, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Remember that middleware is executed in the given order during the request phase,
    and in reverse order during the response phase. `UpdateCacheMiddleware` is placed
    before `CommonMiddleware` because it runs during response time, when middleware
    is executed in reverse order. `FetchFromCacheMiddleware` is placed after `CommonMiddleware`
    intentionally because it needs to access the request data set by the latter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, add the following settings to the `settings.py` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: In these settings, you use the default cache for your cache middleware and set
    the global cache timeout to `15` minutes. You also specify a prefix for all cache
    keys to avoid collisions in case you use the same Memcached backend for multiple
    projects. Your site will now cache and return cached content for all `GET` requests.
  prefs: []
  type: TYPE_NORMAL
- en: You can access the different pages and check the cache requests using Django
    Debug Toolbar. The per-site cache is not viable for many sites because it affects
    all views, even the ones that you might not want to cache, like management views
    where you want data to be returned from the database to reflect the latest changes.
  prefs: []
  type: TYPE_NORMAL
- en: In this project, the best approach is to cache the templates or views that are
    used to display course contents to students while keeping the content management
    views for instructors without any cache.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s deactivate the per-site cache. Edit the `settings.py` file of your project
    and comment out the `UpdateCacheMiddleware` and `FetchFromCacheMiddleware` classes
    in the `MIDDLEWARE` setting, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: You have seen an overview of the different methods provided by Django to cache
    data. You should always define your cache strategy wisely, taking into account
    expensive QuerySets or calculations, data that won’t change frequently, and data
    that will be accessed concurrently by many users.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Redis cache backend
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Django also provides a Redis cache backend. Let’s change the settings to use
    Redis instead of Memcached as the cache backend for the project. Remember that
    you already used Redis in *Chapter 7*, *Tracking User Actions*, and in *Chapter
    10*, *Extending Your Shop*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Install `redis-py` in your environment using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, edit the `settings.py` file of the `educa` project and modify the `CACHES`
    setting, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: The project will now use the `RedisCache` cache backend. The location is defined
    in the format `redis://[host]:[port]`. You use `127.0.0.1` to point to the localhost
    and `6379`, which is the default port for Redis.
  prefs: []
  type: TYPE_NORMAL
- en: You can read more about the Redis cache backend at [https://docs.djangoproject.com/en/5.0/topics/cache/#redis](https://docs.djangoproject.com/en/5.0/topics/cache/#redis).
  prefs: []
  type: TYPE_NORMAL
- en: 'Initialize the Redis Docker container using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: If you want to run the command in the background (in detached mode), you can
    use the `-d` option.
  prefs: []
  type: TYPE_NORMAL
- en: Run the development server and open `http://127.0.0.1:8000/` in your browser.
    Check the cache requests in the **Cache** panel of Django Debug Toolbar. You are
    now using Redis as your project’s cache backend instead of Memcached.
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring Redis with Django Redisboard
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can monitor your Redis server using Django Redisboard. Django Redisboard
    adds Redis statistics to the Django administration site. You can find more information
    about Django Redisboard at [https://github.com/ionelmc/django-redisboard](https://github.com/ionelmc/django-redisboard).
  prefs: []
  type: TYPE_NORMAL
- en: 'Install `django-redisboard` in your environment using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Edit the `settings.py` file of your project and add the application to the
    `INSTALLED_APPS` setting, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following command from your project’s directory to run the Django Redisboard
    migrations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the development server and open `http://127.0.0.1:8000/admin/redisboard/redisserver/add/`
    in your browser to add a Redis server to monitor. For **Label**, enter `redis`,
    and for **URL**, enter `redis://localhost:6379/0`, as in *Figure 14.11*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application, email  Description automatically
    generated](img/B21088_14_11.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.11: The form to add a Redis server for Django Redisboard in the administration
    site'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will monitor the Redis instance running on our localhost, which runs on
    port `6379` and uses the Redis database numbered `0`. Click on **SAVE**. The information
    will be saved to the database, and you will be able to see the Redis configuration
    and metrics on the Django administration site:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21088_14_12.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14.12: The Redis monitoring of Django Redisboard on the administration
    site'
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You have successfully implemented caching for your project.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you implemented the public views for the course catalog. You
    built a system for students to register and enroll in courses. You also created
    the functionality to render different types of content for the course modules.
    Finally, you learned how to use the Django cache framework and you used the Memcached
    and Redis cache backends for your project.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will build a RESTful API for your project using Django
    REST framework and consume it using the Python Requests library.
  prefs: []
  type: TYPE_NORMAL
- en: Additional resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following resources provide additional information related to the topics
    covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Source code for this chapter: [https://github.com/PacktPublishing/Django-5-by-example/tree/main/Chapter14](https://github.com/PacktPublishing/Django-5-by-example/tree/main/Chapter14
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`django-embed-video` documentation: [https://django-embed-video.readthedocs.io/en/latest/](https://django-embed-video.readthedocs.io/en/latest/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Django’s cache framework documentation: [https://docs.djangoproject.com/en/5.0/topics/cache/](https://docs.djangoproject.com/en/5.0/topics/cache/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Memcached Docker image: [https://hub.docker.com/_/memcached](https://hub.docker.com/_/memcached)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Memcached downloads: [https://memcached.org/downloads](https://memcached.org/downloads)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Memcached official website: [https://memcached.org](https://memcached.org)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Django’s `CACHES` settings documentation: [https://docs.djangoproject.com/en/5.0/ref/settings/#caches](https://docs.djangoproject.com/en/5.0/ref/settings/#caches).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pymemcache`''s source code: [https://github.com/pinterest/pymemcache](https://github.com/pinterest/pymemcache)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Django Redis cache backend: [https://docs.djangoproject.com/en/5.0/topics/cache/#redis](https://docs.djangoproject.com/en/5.0/topics/cache/#redis)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Official Redis Docker image: [https://hub.docker.com/_/redis](https://hub.docker.com/_/redis)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Redis download options: [https://redis.io/download/](https://redis.io/download/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Django Redisboard source code: [https://github.com/ionelmc/django-redisboard](https://github.com/ionelmc/django-redisboard)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
