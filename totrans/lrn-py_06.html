<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Advanced Concepts – OOP, Decorators, and Iterators</h1></div></div></div><div><table border="0" width="100%" cellspacing="0" cellpadding="0" class="blockquote" summary="Block quote"><tr><td valign="top"> </td><td valign="top"><p><em>"La classe non è acqua. (Class will out)"</em></p></td><td valign="top"> </td></tr><tr><td valign="top"> </td><td colspan="2" align="right" valign="top" style="text-align: center">--<em>Italian saying</em></td></tr></table></div><p>I could probably write a small book about <strong>object-oriented programming</strong> (referred to as <strong>OOP</strong> henceforth) and classes. In this chapter, I'm facing the hard challenge of finding the balance<a id="id379" class="indexterm"/> between breadth and depth. There are simply too many things to tell, and there's plenty of them that would take more than this whole chapter if I described them alone in depth. Therefore, I will try to give you what I think is a good panoramic view of the fundamentals, plus a few things that may come in handy in the next chapters. Python's official documentation will help in filling the gaps.</p><p>We're going to explore three important concepts in this chapter: decorators, OOP, and iterators.</p><div><div><div><div><h1 class="title"><a id="ch06lvl1sec59"/>Decorators</h1></div></div></div><p>In the <a id="id380" class="indexterm"/>previous chapter, I measured the execution time of various expressions. If you recall, I had to initialize a variable to the start time, and subtract it from the current time after execution in order to calculate the elapsed time. I also printed it on the console after each measurement. That was very tedious.</p><p>Every time you find yourself repeating things, an alarm bell should go off. Can you put that code in a function and avoid repetition? The answer most of the time is <em>yes</em>, so let's look at an example.</p><p>
<code class="literal">decorators/time.measure.start.py</code>
</p><div><pre class="programlisting">from time import <strong>sleep</strong>, time

def f():
    sleep(.3)

def g():
    sleep(.5)

<strong>t = time()</strong>
f()
print('f took: ', <strong>time() - t</strong>)  # f took: 0.3003859519958496

t = time()
g()
print('g took:', time() - t)  # g took: 0.5005719661712646</pre></div><p>In the<a id="id381" class="indexterm"/> preceding code, I defined two functions, <code class="literal">f</code> and <code class="literal">g</code>, which do nothing but sleep (by 0.3 and 0.5 seconds respectively). I used the <code class="literal">sleep</code> function to suspend the execution for the desired amount of time. I also highlighted how we calculate the time elapsed by setting <code class="literal">t</code> to the current time and then subtracting it when the task is done. You can see that the measure is pretty accurate.</p><p>Now, how do we avoid repeating that code and those calculations? One first potential approach could be the following:</p><p>
<code class="literal">decorators/time.measure.dry.py</code>
</p><div><pre class="programlisting">from time import sleep, time

def f():
    sleep(.3)

def g():
    sleep(.5)

<strong>def measure(func):</strong>
<strong>    t = time()</strong>
<strong>    func()</strong>
<strong>    print(func.__name__, 'took:', time() - t)</strong>

measure(f)  # f took: 0.30041074752807617
measure(g)  # g took: 0.5006198883056641</pre></div><p>Ah, much better now. The whole timing mechanism has been encapsulated into a function so we don't repeat code. We print the function name dynamically and it's easy enough to code. What if we need to pass arguments to the function we measure? This code would get just a bit more complicated, so let's see an example.</p><p>
<code class="literal">decorators/time.measure.arguments.py</code>
</p><div><pre class="programlisting">from time import sleep, time

def f(<strong>sleep_time=0.1</strong>):
    sleep(sleep_time)

def measure(<strong>func, *args, **kwargs</strong>):
    t = time()
    <strong>func(*args, **kwargs)</strong>
    print(func.__name__, 'took:', time() - t)

measure(f, <strong>sleep_time=0.3</strong>)  # f took: 0.3004162311553955
measure(f, <strong>0.2</strong>)  # f took: 0.20028162002563477</pre></div><p>Now, <code class="literal">f</code> is <a id="id382" class="indexterm"/>expecting to be fed <code class="literal">sleep_time</code> (with a default value of <code class="literal">0.1</code>). I also had to change the <code class="literal">measure</code> function so that it is now accepting a function, any variable positional arguments, and any variable keyword arguments. In this way, whatever we call <code class="literal">measure</code> with, we redirect those arguments to the call to <code class="literal">f</code> we do inside.</p><p>This is very good, but we can push it a little bit further. Let's say we want to somehow have that timing behavior built-in in the <code class="literal">f</code> function, so that we could just call it and have that measure taken. Here's how we could do it:</p><p>
<code class="literal">decorators/time.measure.deco1.py</code>
</p><div><pre class="programlisting">from time import sleep, time

def f(sleep_time=0.1):
    sleep(sleep_time)

<strong>def measure(func):</strong>
<strong>    def wrapper(*args, **kwargs):</strong>
<strong>        t = time()</strong>
<strong>        func(*args, **kwargs)</strong>
<strong>        print(func.__name__, 'took:', time() - t)</strong>
<strong>    return wrapper</strong>

<strong>f = measure(f)  # decoration point</strong>

f(0.2)  # f took: 0.2002875804901123
f(sleep_time=0.3)  # f took: 0.3003721237182617
print(f.__name__)  # wrapper  &lt;- ouch!</pre></div><p>The preceding code is probably not so straightforward. I confess that, even today, it sometimes requires me some serious concentration to understand some decorators, they<a id="id383" class="indexterm"/> can be pretty nasty. Let's see what happens here. The magic is in the <strong>decoration point</strong>. We basically reassign <code class="literal">f</code> with whatever is returned by <code class="literal">measure</code> when we call it with <code class="literal">f</code> as an argument. Within <code class="literal">measure</code>, we define another function, <code class="literal">wrapper</code>, and then we return it. So, the net effect is that after the decoration point, when we call <code class="literal">f</code>, we're actually calling <code class="literal">wrapper</code>. Since the wrapper inside is calling <code class="literal">func</code>, which is <code class="literal">f</code>, we are actually closing the loop like that. If you don't believe me, take a look at the last line.</p><p>
<code class="literal">wrapper</code> is <a id="id384" class="indexterm"/>actually... a wrapper. It takes variable and positional arguments, and calls <code class="literal">f</code> with them. It also does the time measurement trick around the call.</p><p>This <a id="id385" class="indexterm"/>technique is called <strong>decoration</strong>, and <code class="literal">measure</code> is, at all effects, a <a id="id386" class="indexterm"/>
<strong>decorator</strong>. This paradigm became so popular and widely used that at some point, Python added a special syntax for it (check <strong>PEP 318</strong>). Let's explore three cases: one decorator, two decorators, and one decorator that takes arguments.</p><p>
<code class="literal">decorators/syntax.py</code>
</p><div><pre class="programlisting">def func(arg1, arg2, ...):
    pass
func = decorator(func)

# is equivalent to the following:

@decorator
def func(arg1, arg2, ...):
    pass</pre></div><p>Basically, instead of manually reassigning the function to what was returned by the decorator, we prepend the definition of the function with the special syntax <code class="literal">@decorator_name</code>.</p><p>We can apply multiple decorators to the same function in the following way:</p><p>
<code class="literal">decorators/syntax.py</code>
</p><div><pre class="programlisting">def func(arg1, arg2, ...):
    pass
func = deco1(deco2(func))

# is equivalent to the following:

@deco1
@deco2
def func(arg1, arg2, ...):
    pass</pre></div><p>When applying multiple decorators, pay attention to the order, should it matter. In the preceding example, <code class="literal">func</code> is decorated with <code class="literal">deco2</code> first, and the result is decorated with <code class="literal">deco1</code>. A good rule of thumb is: <em>the closer the decorator to the function, the sooner it is applied</em>.</p><p>Some decorators can take arguments. This technique is generally used to produce other decorators. Let's look at the syntax, and then we'll see an example of it.</p><p>
<code class="literal">decorators/syntax.py</code>
</p><div><pre class="programlisting">def func(arg1, arg2, ...):
    pass
func = decoarg(argA, argB)(func)

# is equivalent to the following:

@decoarg(argA, argB)
def func(arg1, arg2, ...):
    pass</pre></div><p>As you <a id="id387" class="indexterm"/>can see, this case is a bit different. First <code class="literal">decoarg</code> is called with the given arguments, and then its return value (the actual decorator) is called with <code class="literal">func</code>. Before I give you another example, let's fix one thing that is bothering me. I don't want to lose the original function name and docstring (and the other attributes as well, check the documentation for the details) when I decorate it. But because inside our decorator we return <code class="literal">wrapper</code>, the original attributes from <code class="literal">func</code> are lost and <code class="literal">f</code> ends up being assigned the attributes of <code class="literal">wrapper</code>. There is an easy fix for that from <code class="literal">functools</code>, a wonderful module from the Python standard library. I will fix the last example, and I will also rewrite its syntax to use the <code class="literal">@</code> operator.</p><p>
<code class="literal">decorators/time.measure.deco2.py</code>
</p><div><pre class="programlisting">from time import sleep, time
from functools import <strong>wraps</strong>

def measure(func):
    <strong>@wraps(func)</strong>
    def wrapper(*args, **kwargs):
        t = time()
        func(*args, **kwargs)
        print(func.__name__, 'took:', time() - t)
    return wrapper

<strong>@measure</strong>
def f(sleep_time=0.1):
    """I'm a cat. I love to sleep! """
    sleep(sleep_time)

f(sleep_time=0.3)  # f took: 0.30039525032043457
<strong>print(f.__name__, ':', f.__doc__)</strong>
# <strong>f : I'm a cat. I love to sleep!</strong>
</pre></div><p>Now we're talking! As you can see, all we need to do is to tell Python that <code class="literal">wrapper</code> actually wraps <code class="literal">func</code> (by means of the <code class="literal">wraps</code> function), and you can see that the original name and docstring are now maintained.</p><p>Let's see another example. I want a decorator that prints an error message when the result of a function is greater than a threshold. I will also take this opportunity to show you how to apply two <a id="id388" class="indexterm"/>decorators at once.</p><p>
<code class="literal">decorators/two.decorators.py</code>
</p><div><pre class="programlisting">from time import sleep, time
from functools import wraps

def measure(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        t = time()
        <strong>result</strong> = func(*args, **kwargs)
        print(func.__name__, 'took:', time() - t)
        <strong>return result</strong>
    return wrapper

def max_result(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        <strong>result</strong> = func(*args, **kwargs)
        <strong>if result &gt; 100:</strong>
            print('Result is too big ({0}). Max allowed is 100.'
                .format(result))
        <strong>return result</strong>
    return wrapper

@measure
@max_result
def cube(n):
    return n ** 3

print(cube(2))
print(cube(5))</pre></div><div><div><h3 class="title"><a id="tip14"/>Tip</h3><p>Take your time in studying the preceding example until you are sure you understand it well. If you do, I don't think there is any decorator you won't be able to write afterwards.</p></div></div><p>I had to enhance the <code class="literal">measure</code> decorator, so that its <code class="literal">wrapper</code> now returns the result of the call to <code class="literal">func</code>. The <code class="literal">max_result</code> decorator does that as well, but before returning, it checks that <code class="literal">result</code> is not greater than 100, which is the maximum allowed.</p><p>I decorated <code class="literal">cube</code> with both of them. First, <code class="literal">max_result</code> is applied, then <code class="literal">measure</code>. Running this<a id="id389" class="indexterm"/> code yields this result:</p><div><pre class="programlisting">
<strong>$ python two.decorators.py </strong>
<strong>cube took: 7.62939453125e-06  #</strong>
<strong>8  #</strong>
<strong>Result is too big (125). Max allowed is 100.</strong>
<strong>cube took: 1.1205673217773438e-05</strong>
<strong>125</strong>
</pre></div><p>For your convenience, I put a <code class="literal">#</code> to the right of the results of the first call: <code class="literal">print(cube(2))</code>. The result is 8, and therefore it passes the threshold check silently. The running time is measured and printed. Finally, we print the result (<code class="literal">8</code>).</p><p>On the second call, the result is <code class="literal">125</code>, so the error message is printed, the result returned, and then it's the turn of <code class="literal">measure</code>, which prints the running time again, and finally, we print the result (<code class="literal">125</code>).</p><p>Had I decorated the <code class="literal">cube</code> function with the same two decorators but in a different order, the error message would follow the line that prints the running time, instead of preceding it.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec79"/>A decorator factory</h2></div></div></div><p>Let's<a id="id390" class="indexterm"/> simplify this example now, going back to a single decorator: <code class="literal">max_result</code>. I want to make it so that I can decorate different functions with different thresholds, and I don't want to write one decorator for each threshold. Let's amend <code class="literal">max_result</code> so that it allows us to decorate functions specifying the threshold dynamically.</p><p>
<code class="literal">decorators/decorators.factory.py</code>
</p><div><pre class="programlisting">from functools import wraps

def <strong>max_result</strong>(threshold):
    def <strong>decorator</strong>(func):
        @wraps(func)
        def <strong>wrapper</strong>(*args, **kwargs):
            result = func(*args, **kwargs)
            if result &gt; threshold:
                print(
                    'Result is too big ({0}). Max allowed is {1}.'
                    .format(result, threshold))
            return result
        return wrapper
    return decorator

@max_result(75)
def cube(n):
    return n ** 3

print(cube(5))</pre></div><p>This<a id="id391" class="indexterm"/> preceding code shows you how to write a <strong>decorator factory</strong>. If you recall, decorating a function with a decorator that takes arguments is the same as writing <code class="literal">func = decorator(argA, argB)(func)</code>, so when we decorate <code class="literal">cube</code> with <code class="literal">max_result(75)</code>, we're doing <code class="literal">cube = max_result(75)(cube)</code>.</p><p>Let's go through what happens, step by step. When we call <code class="literal">max_result(75)</code>, we enter its body. A <code class="literal">decorator</code> function is defined inside, which takes a function as its only argument. Inside that function, the usual decorator trick is performed. We define a wrapper, inside of which we check the result of the original function's call. The beauty of this approach is that from the innermost level, we can still refer to both <code class="literal">func</code> and <code class="literal">threshold</code>, which allows us to set the threshold dynamically.</p><p>
<code class="literal">wrapper</code> returns <code class="literal">result</code>, <code class="literal">decorator</code> returns <code class="literal">wrapper</code>, and <code class="literal">max_result</code> returns <code class="literal">decorator</code>. This means that our call <code class="literal">cube = max_result(75)(cube)</code>, actually becomes <code class="literal">cube = decorator(cube)</code>. Not just any <code class="literal">decorator</code> though, but one for which <code class="literal">threshold</code> has the value <code class="literal">75</code>. This is achieved by a mechanism called <strong>closure</strong>, which is outside of the scope of this chapter but nonetheless very interesting, so I mentioned it for you to do some research on it.</p><p>Running the last example produces the following result:</p><div><pre class="programlisting">
<strong>$ python decorators.factory.py </strong>
<strong>Result is too big (125). Max allowed is 75.</strong>
<strong>125</strong>
</pre></div><p>The preceding code allows me to use the <code class="literal">max_result</code> decorator with different thresholds at my own will, like this:</p><p>
<code class="literal">decorators/decorators.factory.py</code>
</p><div><pre class="programlisting">@max_result(<strong>75</strong>)
def cube(n):
    return n ** 3

@max_result(<strong>100</strong>)
def square(n):
    return n ** 2

@max_result(<strong>1000</strong>)
def multiply(a, b):
    return a * b</pre></div><p>Note that<a id="id392" class="indexterm"/> every decoration uses a different <code class="literal">threshold</code> value.</p><p>Decorators are very popular in Python. They are used quite often and they simplify (and beautify, I dare say) the code a lot.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec60"/>Object-oriented programming</h1></div></div></div><p>It's been <a id="id393" class="indexterm"/>quite a long and hopefully nice journey and, by now, we should be ready to explore object-oriented programming. I'll use the definition from <em>Kindler, E.; Krivy, I. (2011). Object-Oriented Simulation of systems with sophisticated control. International Journal of General Systems</em>, and adapt it to Python:</p><div><blockquote class="blockquote"><p><em>Object-oriented programming (OOP) is a programming paradigm based on the concept of "objects", which are data structures that contain data, in the form of attributes, and code, in the form of functions known as methods. A distinguishing feature of objects is that an object's method can access and often modify the data attributes of the object with which they are associated (objects have a notion of "self"). In OO programming, computer programs are designed by making them out of objects that interact with one another.</em></p></blockquote></div><p>Python has full support for this paradigm. Actually, as we have already said, <em>everything in Python is an object</em>, so this shows that OOP is not just supported by Python, but it's part of its very core.</p><p>The two<a id="id394" class="indexterm"/> main players in OOP are <strong>objects</strong> and <strong>classes</strong>. Classes are used to <a id="id395" class="indexterm"/>create objects (objects are instances of the classes with which they were created), so we could see them as instance factories. When objects are created by a class, they inherit the class attributes and methods. They represent concrete items in the program's domain.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec80"/>The simplest Python class</h2></div></div></div><p>I will<a id="id396" class="indexterm"/> start with the simplest class you could ever write in Python.</p><p>
<code class="literal">oop/simplest.class.py</code>
</p><div><pre class="programlisting">
<strong>class Simplest():  # when empty, the braces are optional</strong>
<strong>    pass</strong>

print(type(Simplest))  # what type is this object?

simp = Simplest()  # we create an instance of Simplest: simp
print(type(simp))  # what type is simp?
# is simp an instance of Simplest?
print(<strong>type(simp) == Simplest</strong>)  # There's a better way for this</pre></div><p>Let's run <a id="id397" class="indexterm"/>the preceding code and explain it line by line:</p><div><pre class="programlisting">
<strong>$ python oop/simplest.class.py </strong>
<strong>&lt;class 'type'&gt;</strong>
<strong>&lt;class '__main__.Simplest'&gt;</strong>
<strong>True</strong>
</pre></div><p>The <code class="literal">Simplest</code> class I defined only has the <code class="literal">pass</code> instruction for its body, which means it doesn't have any custom attributes or methods. I will print its type (<code class="literal">__main__</code> is the name of the scope in which top-level code executes), and I am aware that, in the comment, I wrote <em>object</em> instead of <em>class</em>. It turns out that, as you can see by the result of that <code class="literal">print</code>, <em>classes are actually objects</em>. To be precise, they are instances of <code class="literal">type</code>. Explaining this concept <a id="id398" class="indexterm"/>would lead to a talk about <strong>metaclasses</strong> and <strong>metaprogramming</strong>, advanced<a id="id399" class="indexterm"/> concepts that require a solid grasp of the fundamentals to be understood and alas this is beyond the scope of this chapter. As usual, I mentioned it to leave a pointer for you, for when you'll be ready to dig deeper.</p><p>Let's go back to the example: I used <code class="literal">Simplest</code> to create an instance, <code class="literal">simp</code>. You can see that the <em>syntax to create an instance is the same we use to call a function</em>.</p><p>Then we print what type <code class="literal">simp</code> belongs to and we verify that <code class="literal">simp</code> is in fact an instance of <code class="literal">Simplest</code>. I'll show you a better way of doing this later on in the chapter.</p><p>Up to now, it's all very simple. What happens when we write <code class="literal">class</code> <code class="literal">ClassName(): pass</code>, though? Well, what Python does is create a class object and assign it a name. This is very similar to what happens when we declare a function using <code class="literal">def</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec81"/>Class and object namespaces</h2></div></div></div><p>After <a id="id400" class="indexterm"/>the class object has been created (which usually happens when the module is first imported), it basically represents a namespace. We can call that class to create its instances. Each instance inherits the class attributes and methods and is given its own namespace. We already know that, to walk a namespace, all we need to do is to use the dot (<code class="literal">.</code>) operator.</p><p>Let's look at another example:</p><p>
<code class="literal">oop/class.namespaces.py</code>
</p><div><pre class="programlisting">class Person():
    <strong>species = 'Human'</strong>

print(Person.species)  # Human
<strong>Person.alive = True  # Added dynamically!</strong>
print(Person.alive)  # True

man = Person()
print(<strong>man.species</strong>)  # Human (inherited)
print(<strong>man.alive</strong>)  # True (inherited)

<strong>Person.alive = False</strong>
print(<strong>man.alive</strong>)  # False (inherited)

<strong>man.name = 'Darth'</strong>
<strong>man.surname = 'Vader'</strong>
print(man.name, man.surname)  # Darth Vader</pre></div><p>In the<a id="id401" class="indexterm"/> preceding example, I have defined a class attribute called <code class="literal">species</code>. Any variable defined in the body of a class is an attribute that belongs to that class. In the code, I have also defined <code class="literal">Person.alive</code>, which is another class attribute. You can see that there is no restriction on accessing that attribute from the class. You can see that <code class="literal">man</code>, which is an instance of <code class="literal">Person</code>, inherits both of them, and reflects them instantly when they change.</p><p>
<code class="literal">man</code> has also<a id="id402" class="indexterm"/> two attributes which belong to its own namespace and therefore are called <strong>instance attributes</strong>: <code class="literal">name</code> and <code class="literal">surname</code>.</p><div><div><h3 class="title"><a id="note41"/>Note</h3><p>Class attributes are shared amongst all instances, while instance attributes are not; therefore, you should use class attributes to provide the states and behaviors to be shared by all instances, and use instance attributes for data that belongs just to one specific object.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec82"/>Attribute shadowing</h2></div></div></div><p>When <a id="id403" class="indexterm"/>you search for an attribute in an object, if it is not found, Python keeps searching in the class that was used to create that object (and keeps searching until it's either found or the end of the inheritance chain is reached). This leads to an interesting shadowing behavior. Let's look at an example:</p><p>
<code class="literal">oop/class.attribute.shadowing.py</code>
</p><div><pre class="programlisting">class Point():
    <strong>x = 10</strong>
<strong>    y = 7</strong>

<strong>p = Point()</strong>
print(p.x)  # 10 (from class attribute)
print(p.y)  # 7 (from class attribute)

<strong>p.x = 12  # p gets its own 'x' attribute</strong>
print(p.x)  # 12 (now found on the instance)
print(Point.x)  # 10 (class attribute still the same)

<strong>del p.x  # we delete instance attribute</strong>
print(p.x)  # 10 (now search has to go again to find class attr)

p.z = 3  # let's make it a 3D point
print(p.z)  # 3

print(Point.z)
# AttributeError: type object 'Point' has no attribute 'z'</pre></div><p>The <a id="id404" class="indexterm"/>preceding code is very interesting. We have defined a class called <code class="literal">Point</code> with two class attributes, <code class="literal">x</code> and <code class="literal">y</code>. When we create an instance, <code class="literal">p</code>, you can see that we can print both <code class="literal">x</code> and <code class="literal">y</code> from <code class="literal">p</code>'s namespace (<code class="literal">p.x</code> and <code class="literal">p.y</code>). What happens when we do that is that Python doesn't find any <code class="literal">x</code> or <code class="literal">y</code> attributes on the instance, and therefore searches the class, and finds them there.</p><p>Then we give <code class="literal">p</code> its own <code class="literal">x</code> attribute by assigning <code class="literal">p.x = 12</code>. This behavior may appear a bit weird at first, but if you think about it, it's exactly the same as what happens in a function that declares <code class="literal">x = 12</code> when there is a global <code class="literal">x = 10</code> outside. We know that <code class="literal">x = 12</code> won't affect the global one, and for classes and instances, it is exactly the same.</p><p>After assigning <code class="literal">p.x = 12</code>, when we print it, the search doesn't need to read the class attributes, because <code class="literal">x</code> is found on the instance, therefore we get <code class="literal">12</code> printed out.</p><p>We also print <code class="literal">Point.x</code> which refers to <code class="literal">x</code> in the class namespace.</p><p>And then, we delete <code class="literal">x</code> from the namespace of <code class="literal">p</code>, which means that, on the next line, when we print it again, Python will go again and search for it in the class, because it won't be found in the instance any more.</p><p>The last three lines show you that assigning attributes to an instance doesn't mean that they will be found in the class. Instances get whatever is in the class, but the opposite is not true.</p><p>What do you think about putting the <code class="literal">x</code> and <code class="literal">y</code> coordinates as class attributes? Do you think it was a good idea?</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec83"/>I, me, and myself – using the self variable</h2></div></div></div><p>From<a id="id405" class="indexterm"/> within a class method we can refer to an instance by means of a special argument, called <code class="literal">self</code> by convention. <code class="literal">self</code> is always the first attribute of an instance method. Let's examine this behavior together with how we can share, not just attributes, but methods with all instances.</p><p>
<code class="literal">oop/class.self.py</code>
</p><div><pre class="programlisting">class Square():
    side = 8
    def area(<strong>self</strong>):  # self is a reference to an instance
        return self.side ** 2

sq = Square()
print(sq.area())  # 64 (<strong>side</strong> is found on the class)
print(Square.area(sq))  # 64 (equivalent to sq.area())

sq.side = 10
print(sq.area())  # 100 (side is found on the instance)</pre></div><p>Note how the <code class="literal">area</code> method is used by <code class="literal">sq</code>. The two calls, <code class="literal">Square.area(sq)</code> and <code class="literal">sq.area()</code>, are equivalent, and teach us how the mechanism works. Either you pass the instance to the method call (<code class="literal">Square.area(sq)</code>), which within the method will be called <code class="literal">self</code>, or you can use a more comfortable syntax: <code class="literal">sq.area()</code> and Python will translate that for you behind the curtains.</p><p>Let's look at a better example:</p><p>
<code class="literal">oop/class.price.py</code>
</p><div><pre class="programlisting">class Price():
    def final_price(self, vat, discount=0):
        """Returns price after applying vat and fixed discount."""
        return (self.net_price * (100 + vat) / 100) - discount

p1 = Price()
p1.net_price = 100
print(<strong>Price.final_price(p1, 20, 10)</strong>)  # 110 (100 * 1.2 - 10)
print(<strong>p1.final_price(20, 10)</strong>)  # equivalent</pre></div><p>The preceding code shows you that nothing prevents us from using arguments when declaring methods. We can use the exact same syntax as we used with the function, but we need to remember that the first argument will always be the instance.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec84"/>Initializing an instance</h2></div></div></div><p>Have <a id="id406" class="indexterm"/>you noticed how, before calling <code class="literal">p1.final_price(...)</code>, we had to assign <code class="literal">net_price</code> to <code class="literal">p1</code>? There is a better way to do it. In other languages, this would be called a <strong>constructor</strong>, but in Python, it's not. It is <a id="id407" class="indexterm"/>actually an <strong>initializer</strong>, since it works on an already created <a id="id408" class="indexterm"/>instance, and therefore it's called <code class="literal">__init__</code>. It's a <em>magic method</em>, which is run right after the object is created. Python objects also have a <code class="literal">__new__</code> method, which is the actual constructor. In practice, it's not so common to have to override it though, it's a practice that is mostly used when coding metaclasses, which is a fairly advanced topic that we won't explore in the book.</p><p>
<code class="literal">oop/class.init.py</code>
</p><div><pre class="programlisting">class Rectangle():
    <strong>def __init__(self, sideA, sideB):</strong>
<strong>        self.sideA = sideA</strong>
<strong>        self.sideB = sideB</strong>

    def area(self):
        return self.sideA * self.sideB

r1 = Rectangle(10, 4)
print(r1.sideA, r1.sideB)  # 10 4
print(r1.area())  # 40

r2 = Rectangle(7, 3)
print(r2.area())  # 21</pre></div><p>Things are finally starting to take shape. When an object is created, the <code class="literal">__init__</code> method is automatically run for us. In this case, I coded it so that when we create an object (by calling the class name like a function), we pass arguments to the creation call, like we would on any regular function call. The way we pass parameters follows the signature of the <code class="literal">__init__</code> method, and therefore, in the two creation statements, <code class="literal">10</code> and <code class="literal">7</code> will be <code class="literal">sideA</code> for <code class="literal">r1</code> and <code class="literal">r2</code> respectively, while <code class="literal">4</code> and <code class="literal">3</code> will be <code class="literal">sideB</code>. You can see that the call to <code class="literal">area()</code> from <code class="literal">r1</code> and <code class="literal">r2</code> reflects that they have different instance arguments.</p><p>Setting up objects in this way is much nicer and convenient.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec85"/>OOP is about code reuse</h2></div></div></div><p>By<a id="id409" class="indexterm"/> now it should be pretty clear: <em>OOP is all about code reuse</em>. We define a class, we create instances, and those instances use methods that are defined only in the class. They will behave differently according to how the instances have been set up by the initializer.</p><div><div><div><div><h3 class="title"><a id="ch06lvl3sec12"/>Inheritance and composition</h3></div></div></div><p>But<a id="id410" class="indexterm"/> this is just half of the story, <em>OOP is much more powerful</em>. We have two main design constructs to exploit: inheritance and composition.</p><p>
<strong>Inheritance</strong> means<a id="id411" class="indexterm"/> that two objects are related by means of an <em>Is-A</em> type <a id="id412" class="indexterm"/>of relationship. On the other hand, <strong>composition</strong> means that two objects are related by means of a <em>Has-A</em> type of relationship. It's all very easy to explain with an example:</p><p>
<code class="literal">oop/class.inheritance.py</code>
</p><div><pre class="programlisting">class <strong>Engine</strong>():
    def start(self):
        pass

    def stop(self):
        pass

class ElectricEngine(<strong>Engine</strong>):  # <strong>Is-A Engine</strong>
    pass

class V8Engine(<strong>Engine</strong>):  # <strong>Is-A Engine</strong>
    pass

class <strong>Car</strong>():
    <strong>engine_cls = Engine</strong>

    def __init__(self):
        <strong>self.engine = self.engine_cls()  # Has-A Engine</strong>

    def start(self):
        print(
            'Starting engine <strong>{0}</strong> for car <strong>{1}</strong>... Wroom, wroom!'
            .format(
                <strong>self.engine.__class__.__name__</strong>,
                <strong>self.__class__.__name__</strong>)
        )
        self.engine.start()

    def stop(self):
        self.engine.stop()

class RaceCar(<strong>Car</strong>):  <strong># Is-A Car</strong>
    engine_cls = V8Engine

class CityCar(<strong>Car</strong>):  <strong># Is-A Car</strong>
    engine_cls = ElectricEngine

class F1Car(<strong>RaceCar</strong>):  <strong># Is-A RaceCar and also Is-A Car</strong>
    engine_cls = V8Engine

car = Car()
racecar = RaceCar()
citycar = CityCar()
f1car = F1Car()
cars = [car, racecar, citycar, f1car]

for car in cars:
    car.start()

""" Prints:
Starting engine <strong>Engine</strong> for car <strong>Car</strong>... Wroom, wroom!
Starting engine <strong>V8Engine</strong> for car <strong>RaceCar</strong>... Wroom, wroom!
Starting engine <strong>ElectricEngine</strong> for car <strong>CityCar</strong>... Wroom, wroom!
Starting engine <strong>V8Engine</strong> for car <strong>F1Car</strong>... Wroom, wroom!
"""</pre></div><p>The <a id="id413" class="indexterm"/>preceding example shows you both the <em>Is-A</em> and <em>Has-A</em> types of relationships between objects. First of all, let's consider <code class="literal">Engine</code>. It's a simple class that has two methods, <code class="literal">start</code> and <code class="literal">stop</code>. We then define <code class="literal">ElectricEngine</code> and <code class="literal">V8Engine</code>, which both inherit from <code class="literal">Engine</code>. You can see that by the fact that when we define them, we put <code class="literal">Engine</code> within the braces after the class name.</p><p>This means that both <code class="literal">ElectricEngine</code> and <code class="literal">V8Engine</code> inherit attributes and methods from the <code class="literal">Engine</code> class, which<a id="id414" class="indexterm"/> is said to be their <strong>base class</strong>.</p><p>The same happens with cars. <code class="literal">Car</code> is a base class for both <code class="literal">RaceCar</code> and <code class="literal">CityCar</code>. <code class="literal">RaceCar</code> is also the base class for <code class="literal">F1Car</code>. Another way of saying this is that <code class="literal">F1Car</code> inherits from <code class="literal">RaceCar</code>, which inherits from <code class="literal">Car</code>. Therefore, <code class="literal">F1Car</code> <em>Is-A</em> <code class="literal">RaceCar</code> and <code class="literal">RaceCar</code> <em>Is-A</em> <code class="literal">Car</code>. Because of the transitive property, we can say that <code class="literal">F1Car</code> <em>Is-A</em> <code class="literal">Car</code> as well. <code class="literal">CityCar</code> too, <em>Is-A</em> <code class="literal">Car</code>.</p><p>When we define <code class="literal">class A(B): pass</code>, we say <code class="literal">A</code> is the <em>child</em> of <code class="literal">B</code>, and <code class="literal">B</code> is the <em>parent</em> of <code class="literal">A</code>. <em>parent</em> and <em>base</em> are synonyms, as well as <em>child</em> and <em>derived</em>. Also, we say that a class inherits from another class, or that it extends it.</p><p>This is the inheritance mechanism.</p><p>On the other hand, let's go back to the code. Each class has a class attribute, <code class="literal">engine_cls</code>, which is a reference to the engine class we want to assign to each type of car. <code class="literal">Car</code> has a generic <code class="literal">Engine</code>, while the two race cars have a powerful V8 engine, and the city car has an electric one.</p><p>When a car is created in the initializer method <code class="literal">__init__</code>, we create an instance of whatever engine class is assigned to the car, and set it as <code class="literal">engine</code> instance attribute.</p><p>It makes sense to have <code class="literal">engine_cls</code> shared amongst all class instances because it's quite likely that the same instances of a car will have the same kind of engine. On the other hand, it wouldn't be good to have one single engine (an instance of any <code class="literal">Engine</code> class) as a class<a id="id415" class="indexterm"/> attribute, because we would be sharing one engine amongst all instances, which is incorrect.</p><p>The type of relationship between a car and its engine is a <em>Has-A</em> type. A car <em>Has-A</em> engine. This is<a id="id416" class="indexterm"/> called <strong>composition</strong>, and reflects the fact that objects can be made of many other objects. A car <em>Has-A</em> engine, gears, wheels, a frame, doors, seats, and so on.</p><p>When designing OOP code, it is of vital importance to describe objects in this way so that we can use inheritance and composition correctly to structure our code in the best way.</p><p>Before we leave this paragraph, let's check if I told you the truth with another example:</p><p>
<code class="literal">oop/class.issubclass.isinstance.py</code>
</p><div><pre class="programlisting">car = Car()
racecar = RaceCar()
f1car = F1Car()
cars = [(car, 'car'), (racecar, 'racecar'), (f1car, 'f1car')]
car_classes = [Car, RaceCar, F1Car]

for car, car_name in cars:
    for class_ in car_classes:
        <strong>belongs = isinstance(car, class_)</strong>
        msg = 'is a' if belongs else 'is not a'
        print(car_name, msg, class_.__name__)

""" Prints:
<strong>car is a Car</strong>
car is not a RaceCar
car is not a F1Car
<strong>racecar is a Car</strong>
<strong>racecar is a RaceCar</strong>
racecar is not a F1Car
<strong>f1car is a Car</strong>
<strong>f1car is a RaceCar</strong>
<strong>f1car is a F1Car</strong>
"""</pre></div><p>As you can see, <code class="literal">car</code> is just an instance of <code class="literal">Car</code>, while <code class="literal">racecar</code> is an instance of <code class="literal">RaceCar</code> (and of <code class="literal">Car</code> by extension) and <code class="literal">f1car</code> is an instance of <code class="literal">F1Car</code> (and of both <code class="literal">RaceCar</code> and <code class="literal">Car</code>, by extension). A <em>banana</em> is an instance of <em>Banana</em>. But, also, it is a <em>Fruit</em>. Also, it is <em>Food</em>, right? This is the same concept.</p><p>To check if an object is an instance of a class, use the <code class="literal">isinstance</code> method. It is recommended over sheer type comparison (<code class="literal">type(object) == Class</code>).</p><p>Let's also check inheritance, same setup, with different <code class="literal">for</code> loops:</p><p>
<code class="literal">oop/class.issubclass.isinstance.py</code>
</p><div><pre class="programlisting">for class1 in car_classes:
    for class2 in car_classes:
        <strong>is_subclass = issubclass(class1, class2)</strong>
        msg = '{0} a subclass of'.format(
            'is' if is_subclass else 'is not')
        print(class1.__name__, msg, class2.__name__)

""" Prints:
<strong>Car is a subclass of Car</strong>
Car is not a subclass of RaceCar
Car is not a subclass of F1Car
<strong>RaceCar is a subclass of Car</strong>
<strong>RaceCar is a subclass of RaceCar</strong>
RaceCar is not a subclass of F1Car
<strong>F1Car is a subclass of Car</strong>
<strong>F1Car is a subclass of RaceCar</strong>
<strong>F1Car is a subclass of F1Car</strong>
"""</pre></div><p>Interestingly, we learn that <em>a class is a subclass of itself</em>. Check the output of the preceding example to see that it <a id="id417" class="indexterm"/>matches the explanation I provided.</p><div><div><h3 class="title"><a id="note42"/>Note</h3><p>One thing to notice about conventions is that class names are always written using <em>CapWords</em>, which means <em>ThisWayIsCorrect</em>, as opposed to functions and methods, which are written <em>this_way_is_correct</em>. Also, when in the code you want to use a name which is a Python-reserved keyword or built-in function or class, the convention is to add a trailing underscore to the name. In the first <code class="literal">for</code> loop example, I'm looping through the class names using <code class="literal">for class_ in ...</code>, because <code class="literal">class</code> is a reserved word. But you already knew all this because you have thoroughly studied PEP8, right?</p></div></div><p>To help you picture the difference between <em>Is-A</em> and <em>Has-A</em>, take a look at the following diagram:</p><div><img src="img/4715_06_01.jpg" alt="Inheritance and composition"/></div></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec86"/>Accessing a base class</h2></div></div></div><p>We've <a id="id418" class="indexterm"/>already seen class declarations like <code class="literal">class ClassA: pass</code> and <code class="literal">class ClassB(BaseClassName): pass</code>. When we don't specify a base class explicitly, Python will set the special <strong>object</strong> class as the base class for the one we're defining. Ultimately, all classes derive from <code class="literal">object</code>. Note that, if you don't specify a base class, braces are optional.</p><p>Therefore, writing <code class="literal">class A: pass</code> or <code class="literal">class A(): pass</code> or <code class="literal">class A(object): pass</code> is exactly the same thing. <em>object</em> is a special class in that it has the methods that are common to all Python classes, and it doesn't allow you to set any attributes on it.</p><p>Let's see how we can access a base class from within a class.</p><p>
<code class="literal">oop/super.duplication.py</code>
</p><div><pre class="programlisting">class Book:
    def __init__(self, title, publisher, pages):
        self.title = title
        self.publisher = publisher
        self.pages = pages

class Ebook(Book):
    def __init__(self, title, publisher, pages, format_):
        <strong>self.title = title</strong>
<strong>        self.publisher = publisher</strong>
<strong>        self.pages = pages</strong>
        self.format_ = format_</pre></div><p>Take a look at the preceding code. I highlighted the part of <code class="literal">Ebook</code> initialization that is duplicated from its base class <code class="literal">Book</code>. This is quite bad practice because we now have two sets <a id="id419" class="indexterm"/>of instructions that are doing the same thing. Moreover, any change in the signature of <code class="literal">Book.__init__</code> will not reflect in <code class="literal">Ebook</code>. We know that <code class="literal">Ebook</code> <em>Is-A</em> <code class="literal">Book</code>, and therefore we would probably want changes to be reflected in the children classes.</p><p>Let's see one way to fix this issue:</p><p>
<code class="literal">oop/super.explicit.py</code>
</p><div><pre class="programlisting">class Book:
    def __init__(self, title, publisher, pages):
        self.title = title
        self.publisher = publisher
        self.pages = pages

class Ebook(Book):
    def __init__(self, title, publisher, pages, format_):
        <strong>Book.__init__(self, title, publisher, pages)</strong>
        self.format_ = format_

ebook = Ebook('Learning Python', 'Packt Publishing', 360, 'PDF')
print(ebook.title)  # Learning Python
print(ebook.publisher)  # Packt Publishing
print(ebook.pages)  # 360
print(ebook.format_)  # PDF</pre></div><p>Now, that's better. We have removed that nasty duplication. Basically, we tell Python to call the <code class="literal">__init__</code> method of the <code class="literal">Book</code> class, and we feed <code class="literal">self</code> to the call, making sure that we bind that call to the present instance.</p><p>If we modify the logic within the <code class="literal">__init__</code> method of <code class="literal">Book</code>, we don't need to touch <code class="literal">Ebook</code>, it will auto adapt to the change.</p><p>This approach is good, but we can still do a bit better. Say that we change <code class="literal">Book</code>'s name to <code class="literal">Liber</code>, because we've fallen in love with Latin. We have to change the <code class="literal">__init__</code> method of <code class="literal">Ebook</code> to reflect the change. This can be avoided by using <code class="literal">super</code>.</p><p>
<code class="literal">oop/super.implicit.py</code>
</p><div><pre class="programlisting">class Book:
    def __init__(self, title, publisher, pages):
        self.title = title
        self.publisher = publisher
        self.pages = pages

class Ebook(Book):
    def __init__(self, title, publisher, pages, format_):
        <strong>super().__init__(title, publisher, pages)</strong>
        # Another way to do the same thing is:
        # <strong>super(Ebook, self).__init__(title, publisher, pages)</strong>
        self.format_ = format_

ebook = Ebook('Learning Python', 'Packt Publishing', 360, 'PDF')
print(ebook.title)  # Learning Python
print(ebook.publisher)  # Packt Publishing
print(ebook.pages)  # 360
print(ebook.format_)  # PDF</pre></div><p>
<code class="literal">super</code> is<a id="id420" class="indexterm"/> a function that returns a proxy object that delegates method calls to a parent or sibling class. In this case, it will delegate that call to <code class="literal">__init__</code> to the <code class="literal">Book</code> class, and the beauty of this method is that now we're even free to change <code class="literal">Book</code> to <code class="literal">Liber</code> without having to touch the logic in the <code class="literal">__init__</code> method of <code class="literal">Ebook</code>.</p><p>Now that we know how to access a base class from a child, let's explore Python's multiple inheritance.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec87"/>Multiple inheritance</h2></div></div></div><p>Apart <a id="id421" class="indexterm"/>from composing a class using more than one base class, what is of interest here is how an attribute search is performed. Take a look at the following diagram:</p><div><img src="img/4715_06_02.jpg" alt="Multiple inheritance"/></div><p>As you <a id="id422" class="indexterm"/>can see, <code class="literal">Shape</code> and <code class="literal">Plotter</code> act as base classes for all the others. <code class="literal">Polygon</code> inherits directly from them, <code class="literal">RegularPolygon</code> inherits from <code class="literal">Polygon</code>, and both <code class="literal">RegularHexagon</code> and <code class="literal">Square</code> inherit from <code class="literal">RegulaPolygon</code>. Note also that <code class="literal">Shape</code> and <code class="literal">Plotter</code> implicitly inherit from <code class="literal">object</code>, therefore<a id="id423" class="indexterm"/> we have what is called a <strong>diamond</strong> or, in simpler terms, more than one path to reach a base class. We'll see why this matters in a few moments. Let's translate it into some simple code:</p><p>
<code class="literal">oop/multiple.inheritance.py</code>
</p><div><pre class="programlisting">class <strong>Shape</strong>:
    <strong>geometric_type</strong> = 'Generic Shape'

    def <strong>area</strong>(self):  # This acts as placeholder for the interface
        raise NotImplementedError

    def <strong>get_geometric_type</strong>(self):
        return self.geometric_type

class <strong>Plotter</strong>:

    def <strong>plot</strong>(self, ratio, topleft):
        # Imagine some nice plotting logic here...
        print('Plotting at {}, ratio {}.'.format(
            topleft, ratio))

class <strong>Polygon</strong>(<strong>Shape</strong>, <strong>Plotter</strong>):  # base class for polygons
    geometric_type = 'Polygon'

class <strong>RegularPolygon</strong>(<strong>Polygon</strong>):  # Is-A Polygon
    geometric_type = 'Regular Polygon'

    def <strong>__init__</strong>(self, side):
        self.side = side

class <strong>RegularHexagon</strong>(<strong>RegularPolygon</strong>): # Is-A RegularPolygon
    geometric_type = 'RegularHexagon'

    def <strong>area</strong>(self):
        return 1.5 * (3 ** .5 * self.side ** 2)

class <strong>Square</strong>(<strong>RegularPolygon</strong>):  # Is-A RegularPolygon
    geometric_type = 'Square'

    def <strong>area</strong>(self):
        return self.side * self.side

hexagon = RegularHexagon(10)
print(hexagon.area())  # 259.8076211353316
print(hexagon.get_geometric_type())  # RegularHexagon
hexagon.plot(0.8, (75, 77))  # Plotting at (75, 77), ratio 0.8.

square = Square(12)
print(square.area())  # 144
print(square.get_geometric_type())  # Square
square.plot(0.93, (74, 75))  # Plotting at (74, 75), ratio 0.93.</pre></div><p>Take a look at the preceding code: the class <code class="literal">Shape</code> has one attribute, <code class="literal">geometric_type</code>, and two methods: <code class="literal">area</code> and <code class="literal">get_geometric_type</code>. It's quite common to use base classes (like <code class="literal">Shape</code>, in our example) to define an <em>interface</em>: methods for which children must provide an implementation. There are different and better ways to do this, but I want to keep this example <a id="id424" class="indexterm"/>as simple as possible.</p><p>We also have the <code class="literal">Plotter</code> class, which adds the <code class="literal">plot</code> method, thereby providing plotting capabilities for any class that inherits from it. Of course, the <code class="literal">plot</code> implementation is just a dummy <code class="literal">print</code> in this example. The first interesting class is <code class="literal">Polygon</code>, which inherits from both <code class="literal">Shape</code> and <code class="literal">Plotter</code>.</p><p>There are many types of polygons, one of which is the regular one, which is both equiangular (all angles are equal) and equilateral (all sides are equal), so we create the <code class="literal">RegularPolygon</code> class that inherits from <code class="literal">Polygon</code>. Because for a regular polygon, all sides are equal, we can implement a simple <code class="literal">__init__</code> method on <code class="literal">RegularPolygon</code>, which takes the length of the side. Finally, we create the <code class="literal">RegularHexagon</code> and <code class="literal">Square</code> classes, which both inherit from <code class="literal">RegularPolygon</code>.</p><p>This structure is quite long, but hopefully gives you an idea of how to specialize the classification of your objects when you design the code.</p><p>Now, please take a look at the last eight lines. Note that when I call the <code class="literal">area</code> method on <code class="literal">hexagon</code> and <code class="literal">square</code>, I get the correct area for both. This is because they both provide the correct implementation logic for it. Also, I can call <code class="literal">get_geometric_type</code> on both of them, even though it is not defined on their classes, and Python has to go all the way up to <code class="literal">Shape</code> to find an implementation for it. Note that, even though the implementation is provided in the <code class="literal">Shape</code> class, the <code class="literal">self.geometric_type</code> used for the return value is correctly taken from the caller instance.</p><p>The <code class="literal">plot</code> method calls are also interesting, and show you how you can enrich your objects with capabilities they wouldn't otherwise have. This technique is very popular in web frameworks such as Django (which we'll explore in two later chapters), which provides special classes <a id="id425" class="indexterm"/>called <strong>mixins</strong>, whose capabilities you can just use out of the box. All you have to do is to define the desired mixin as one the base classes for your own, and that's it.</p><p>Multiple inheritance is powerful, but can also get really messy, so we need to make sure we understand what happens when we use it.</p><div><div><div><div><h3 class="title"><a id="ch06lvl3sec13"/>Method resolution order</h3></div></div></div><p>By now, <a id="id426" class="indexterm"/>we know that when you ask for <code class="literal">someobject.attribute</code>, and <code class="literal">attribute</code> is not found on that object, Python starts searching in the class <code class="literal">someobject</code> was created from. If it's not there either, Python searches up the inheritance chain until either <code class="literal">attribute</code> is found or the <code class="literal">object</code> class is reached. This is quite simple to understand if the inheritance chain is only comprised of single inheritance steps, which means that classes have only one parent. However, when multiple inheritance is involved, there are cases when it's not straightforward to predict what will be the next class that will be searched for if an attribute is not found.</p><p>Python<a id="id427" class="indexterm"/> provides a way to always know what is the order in which classes are searched on attribute lookup: the method resolution order.</p><div><div><h3 class="title"><a id="note43"/>Note</h3><p>The <strong>method resolution order</strong> (<strong>MRO</strong>) is the order in which base classes are searched <a id="id428" class="indexterm"/>for a member during lookup. From version 2.3 Python uses an algorithm called <strong>C3</strong>, which guarantees monotonicity.</p><p>In Python 2.2, <strong>new-style classes</strong> were introduced. The way you write a new-style class in Python 2.* is to define it with an explicit <code class="literal">object</code> base class. Classic classes were not explicitly inheriting from <code class="literal">object</code> and have been removed in Python 3.</p><p>One of the differences between classic and new style-classes in Python 2.* is that new-style classes are searched with the new MRO.</p></div></div><p>With regards to the previous example, let's see what is the MRO for the <code class="literal">Square</code> class:</p><p>
<code class="literal">oop/multiple.inheritance.py</code>
</p><div><pre class="programlisting">print(<strong>square.__class__.__mro__</strong>)
# prints:
# (&lt;class '__main__.Square'&gt;, &lt;class '__main__.RegularPolygon'&gt;,
#  &lt;class '__main__.Polygon'&gt;, &lt;class '__main__.Shape'&gt;,
#  &lt;class '__main__.Plotter'&gt;, &lt;class 'object'&gt;)</pre></div><p>To get to the MRO of a class, we can go from the instance to its <code class="literal">__class__</code> attribute and from that to its <code class="literal">__mro__</code> attribute. Alternatively, we could have called <code class="literal">Square.__mro__</code>, or <code class="literal">Square.mro()</code> directly, but if you have to do it dynamically, it's more likely you will have an object in your hands rather than a class.</p><p>Note that the only point of doubt is the bisection after <code class="literal">Polygon</code>, where the inheritance chain breaks into two ways, one leads to <code class="literal">Shape</code> and the other to <code class="literal">Plotter</code>. We know by scanning the MRO for the <code class="literal">Square</code> class that <code class="literal">Shape</code> is searched before <code class="literal">Plotter</code>.</p><p>Why is this important? Well, imagine the following code:</p><p>
<code class="literal">oop/mro.simple.py</code>
</p><div><pre class="programlisting">class A:
    label = 'a'

class B(A):
    label = 'b'

class C(A):
    label = 'c'

class D(B, C):
    pass

d = D()
print(d.label)  # Hypothetically this could be either 'b' or 'c'</pre></div><p>Both <code class="literal">B</code> and <code class="literal">C</code> inherit from <code class="literal">A</code>, and <code class="literal">D</code> inherits from both <code class="literal">B</code> and <code class="literal">C</code>. This means that the lookup for the <code class="literal">label</code> attribute can reach the top (<code class="literal">A</code>) through both <code class="literal">B</code> or <code class="literal">C</code>. According to which is reached <a id="id429" class="indexterm"/>first, we get a different result.</p><p>So, in the preceding example we get <code class="literal">'b'</code>, which is what we were expecting, since <code class="literal">B</code> is the leftmost one amongst base classes of <code class="literal">D</code>. But what happens if I remove the <code class="literal">label</code> attribute from <code class="literal">B</code>? This would be the confusing situation: Will the algorithm go all the way up to <code class="literal">A</code> or will it get to <code class="literal">C</code> first? Let's find out!</p><p>
<code class="literal">oop/mro.py</code>
</p><div><pre class="programlisting">class A:
    label = 'a'

class B(A):
    pass  # was: label = 'b'

class C(A):
    label = 'c'

class D(B, C):
    pass

d = D()
print(d.label)  <strong># 'c'</strong>
print(d.__class__.<strong>mro()</strong>)  # notice another way to get the MRO
# prints:
# [&lt;class '__main__.<strong>D</strong>'&gt;, &lt;class '__main__.<strong>B</strong>'&gt;,
#  &lt;class '__main__.<strong>C</strong>'&gt;, &lt;class '__main__.<strong>A</strong>'&gt;, &lt;class '<strong>object</strong>'&gt;]</pre></div><p>So, we learn that the MRO is <code class="literal">D-B-C-A-(object)</code>, which means when we ask for <code class="literal">d.label</code>, we get <code class="literal">'c'</code>, which is correct.</p><p>In day to day programming, it is not quite common to have to deal with the MRO, but the first time you fight against some mixin from a framework, I promise you'll be glad I spent a <a id="id430" class="indexterm"/>paragraph explaining it.</p></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec88"/>Static and class methods</h2></div></div></div><p>Until <a id="id431" class="indexterm"/>now, we have coded classes with attributes in the form of data and instance methods, but there are two other types of methods that we can place inside a class: <strong>static methods</strong> and <strong>class methods</strong>.</p><div><div><div><div><h3 class="title"><a id="ch06lvl3sec14"/>Static methods</h3></div></div></div><p>As you <a id="id432" class="indexterm"/>may recall, when you create a class object, Python assigns a name to it. That name acts as a namespace, and sometimes it makes sense to group functionalities under it. Static methods are perfect for this use case since unlike instance methods, they are not passed any special argument. Let's look at an example of an imaginary <code class="literal">String</code> class.</p><p>
<code class="literal">oop/static.methods.py</code>
</p><div><pre class="programlisting">class String:

    <strong>@staticmethod</strong>
    def is_palindrome(s, case_insensitive=True):
        # we allow only letters and numbers
        <strong>s = ''.join(c for c in s if c.isalnum())</strong>  # Study this!
        # For case insensitive comparison, we lower-case s
        if case_insensitive:
            s = s.lower()
        for c in range(len(s) // 2):
            if s[c] != s[-c -1]:
                return False
        return True

    <strong>@staticmethod</strong>
    def get_unique_words(sentence):
        return set(sentence.split())

print(String.is_palindrome(
    'Radar', case_insensitive=False))  # False: Case Sensitive
print(String.is_palindrome('A nut for a jar of tuna'))  # True
print(String.is_palindrome('Never Odd, Or Even!'))  # True
print(String.is_palindrome(
    'In Girum Imus Nocte Et Consumimur Igni')  # Latin! Show-off!
)  # True

print(String.get_unique_words(
    'I love palindromes. I really really love them!'))
# {'them!', 'really', 'palindromes.', 'I', 'love'}</pre></div><p>The preceding <a id="id433" class="indexterm"/>code is quite interesting. First of all, we learn that static methods are created by simply applying the <code class="literal">staticmethod</code> decorator to them. You can see that they aren't passed any special argument so, apart from the decoration, they really just look like functions.</p><p>We have a class, <code class="literal">String</code>, which acts as a container for functions. Another approach would be to have a separate module with functions inside. It's really a matter of preference most of the time.</p><p>The logic inside <code class="literal">is_palindrome</code> should be straightforward for you to understand by now, but, just in case, let's go through it. First we remove all characters from <code class="literal">s</code> that are not either letters or numbers. In order to do this, we use the <code class="literal">join</code> method of a string object (an empty string object, in this case). By calling <code class="literal">join</code> on an empty string, the result is that all elements in the iterable you pass to <code class="literal">join</code> will be concatenated together. We feed <code class="literal">join</code> a generator expression that says, <em>take any character from s if the character is either alphanumeric or a number</em>. I hope you have been able to find that out by yourself, maybe using the inside-out technique I showed you in one of the preceding chapters.</p><p>We then lowercase <code class="literal">s</code> if <code class="literal">case_insensitive</code> is <code class="literal">True</code>, and then we proceed to check if it is a palindrome. In order to do this, we compare the first and last characters, then the second and the second to last, and so on. If at any point we find a difference, it means the string isn't a palindrome and therefore we can return <code class="literal">False</code>. On the other hand, if we exit the <code class="literal">for</code> loop normally, it means no differences were found, and we can therefore say the string is a palindrome.</p><p>Notice that this code works correctly regardless of the length of the string, that is, if the length is odd or even. <code class="literal">len(s) // 2</code> reaches half of <code class="literal">s</code>, and if <code class="literal">s</code> is an odd amount of characters long, the middle one won't be checked (like in <em>RaDaR</em>, <em>D</em> is not checked), but we don't care; it would be compared with itself so it's always passing that check.</p><p>
<code class="literal">get_unique_words</code> is much simpler, it just returns a set to which we feed a list with the words from a sentence. The <code class="literal">set</code> class removes any duplication for us, therefore we don't need to do anything else.</p><p>The <code class="literal">String</code> class provides us a nice container namespace for methods that are meant to work on strings. I could have coded a similar example with a <code class="literal">Math</code> class, and some static methods to work on numbers, but I wanted to show you something different.</p></div><div><div><div><div><h3 class="title"><a id="ch06lvl3sec15"/>Class methods</h3></div></div></div><p>Class <a id="id434" class="indexterm"/>methods are slightly different from instance methods in that they also take a special first argument, but in this case, it is the class object itself. Two very common use cases for coding class methods are to provide factory capability to a class and to allow breaking up static methods (which you have to then call using the class name) without having to hardcode the class name in your logic. Let's look at an example of both of them.</p><p>
<code class="literal">oop/class.methods.factory.py</code>
</p><div><pre class="programlisting">class <strong>Point</strong>:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    @<strong>classmethod</strong>
    def from_tuple(<strong>cls</strong>, coords):  # cls is Point
        return <strong>cls(*coords)</strong>

    @<strong>classmethod</strong>
    def from_point(<strong>cls</strong>, point):  # cls is Point
        return <strong>cls(point.x, point.y)</strong>

p = Point.from_tuple((3, 7))
print(p.x, p.y)  # 3 7
q = Point.from_point(p)
print(q.x, q.y)  # 3 7</pre></div><p>In the <a id="id435" class="indexterm"/>preceding code, I showed you how to use a class method to create a factory for the class. In this case, we want to create a <code class="literal">Point</code> instance by passing both coordinates (regular creation <code class="literal">p = Point(3, 7)</code>), but we also want to be able to create an instance by passing a tuple (<code class="literal">Point.from_tuple</code>) or another instance (<code class="literal">Point.from_point</code>).</p><p>Within the two class methods, the <code class="literal">cls</code> argument refers to the <code class="literal">Point</code> class. As with instance method, which take <code class="literal">self</code> as the first argument, class method take a <code class="literal">cls</code> argument. Both <code class="literal">self</code> and <code class="literal">cls</code> are named after a convention that you are not forced to follow but are strongly encouraged to respect. This is something that no Python coder would change because it is so strong a convention that parsers, linters, and any tool that automatically does something with your code would expect, so it's much better to stick to it.</p><p>Let's look at an example of the other use case: splitting a static method.</p><p>
<code class="literal">oop/class.methods.split.py</code>
</p><div><pre class="programlisting">class String:

    @<strong>classmethod</strong>
    def is_palindrome(<strong>cls</strong>, s, case_insensitive=True):
        <strong>s = cls._strip_string(s)</strong>
        # For case insensitive comparison, we lower-case s
        if case_insensitive:
            s = s.lower()
        <strong>return cls._is_palindrome(s)</strong>

    @<strong>staticmethod</strong>
    def <strong>_strip_string</strong>(s):
        return ''.join(c for c in s if c.isalnum())

    @<strong>staticmethod</strong>
    def <strong>_is_palindrome</strong>(s):
        for c in range(len(s) // 2):
            if s[c] != s[-c -1]:
                return False
        return True

    @staticmethod
    def get_unique_words(sentence):
        return set(sentence.split())

print(<strong>String.is_palindrome('A nut for a jar of tuna')</strong>)  # True
print(<strong>String.is_palindrome('A nut for a jar of beans')</strong>)  # False</pre></div><p>Compare this<a id="id436" class="indexterm"/> code with the previous version. First of all note that even though <code class="literal">is_palindrome</code> is now a class method, we call it in the same way we were calling it when it was a static one. The reason why we changed it to a class method is that after factoring out a couple of pieces of logic (<code class="literal">_strip_string</code> and <code class="literal">_is_palindrome</code>), we need to get a reference to them and if we have no <code class="literal">cls</code> in our method, the only option would be to call them like this: <code class="literal">String._strip_string(...)</code> and <code class="literal">String._is_palindrome(...)</code>, which is not good practice, because we would hardcode the class name in the <code class="literal">is_palindrome</code> method, thereby putting ourselves in the condition of having to modify it whenever we would change the class name. Using <code class="literal">cls</code> will act as the class name, which means our code won't need any amendments.</p><p>Note also that, by naming the <em>factored-out</em> methods with a leading underscore, I am hinting that those methods are not supposed to be called from outside the class, but this will be the subject of the next paragraph.</p></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec89"/>Private methods and name mangling</h2></div></div></div><p>If you<a id="id437" class="indexterm"/> have any background with languages <a id="id438" class="indexterm"/>like Java, C#, C++, or similar, then you know they allow the programmer to assign a privacy status to attributes (both data and methods). Each language has its own slightly different flavor for this, but the gist is that public attributes are accessible from any point in the code, while private ones are accessible only within the scope they are defined in.</p><p>In Python, there is no such thing. Everything is public; therefore, we rely on conventions and on<a id="id439" class="indexterm"/> a mechanism called <strong>name mangling</strong>.</p><p>The convention is as follows: if an attribute's name has no leading underscores it is considered public. This means you can access it and modify it freely. When the name has one<a id="id440" class="indexterm"/> leading underscore, the attribute is<a id="id441" class="indexterm"/> considered private, which means it's probably meant to be used internally and you should not use it or modify it from the outside. A very common use case for private attributes are helper methods that are supposed to be used by public ones (possibly in call chains in conjunction with other methods), and internal data, like scaling factors, or any other data that ideally we would put in a constant (a variable that cannot change, but, surprise, surprise, Python doesn't have those either).</p><p>This characteristic usually scares people from other backgrounds off; they feel threatened by the lack of privacy. To be honest, in my whole professional experience with Python, I've never heard anyone screaming <em>Oh my God, we have a terrible bug because Python lacks private attributes!</em> Not once, I swear.</p><p>That said, the call for privacy actually makes sense because without it, you risk introducing bugs into your code for real. Let's look at a simple example:</p><p>
<code class="literal">oop/private.attrs.py</code>
</p><div><pre class="programlisting">class A:
    def __init__(self, factor):
        <strong>self._factor</strong> = factor

    def op1(self):
        print('Op1 with factor {}...'.format(<strong>self._factor</strong>))

class B(A):
    def op2(self, factor):
        <strong>self._factor = factor</strong>
        print('Op2 with factor {}...'.format(<strong>self._factor</strong>))


obj = B(100)
obj.op1()    # Op1 with factor 100...
obj.op2(42)  # Op2 with factor 42...
obj.op1()    # <strong>Op1 with factor 42...  &lt;- This is BAD</strong>
</pre></div><p>In the preceding code, we have an attribute called <code class="literal">_factor</code>, and let's pretend it's very important that it isn't modified at runtime after the instance is created, because <code class="literal">op1</code> depends on it to function correctly. We've named it with a leading underscore, but the issue here is that when we call <code class="literal">obj.op2(42)</code>, we modify it, and this reflects in subsequent calls to <code class="literal">op1</code>.</p><p>Let's fix this undesired behavior by adding another leading underscore:</p><p>
<code class="literal">oop/private.attrs.fixed.py</code>
</p><div><pre class="programlisting">class A:
    def __init__(self, factor):
        <strong>self.__factor = factor</strong>

    def op1(self):
        print('Op1 with factor {}...'.format(<strong>self.__factor</strong>))

class B(A):
    def op2(self, factor):
        <strong>self.__factor = factor</strong>
        print('Op2 with factor {}...'.format(<strong>self.__factor</strong>))


obj = B(100)
obj.op1()    # Op1 with factor 100...
obj.op2(42)  # Op2 with factor 42...
obj.op1()    # <strong>Op1 with factor 100...  &lt;- Wohoo! Now it's GOOD!</strong>
</pre></div><p>Wow, look<a id="id442" class="indexterm"/> at that! Now it's working<a id="id443" class="indexterm"/> as desired. Python is kind of magic and in this case, what is happening is that the name mangling mechanism has kicked in.</p><p>Name mangling means that any attribute name that has at least two leading underscores and at most one trailing underscore, like <code class="literal">__my_attr</code>, is replaced with a name that includes an underscore and the class name before the actual name, like <code class="literal">_ClassName__my_attr</code>.</p><p>This means that when you inherit from a class, the mangling mechanism gives your private attribute two different names in the base and child classes so that name collision is avoided. Every class and instance object stores references to their attributes in a special attribute called <code class="literal">__dict__</code>, so let's inspect <code class="literal">obj.__dict__</code> to see name mangling in action:</p><p>
<code class="literal">oop/private.attrs.py</code>
</p><div><pre class="programlisting">print(<strong>obj.__dict__.keys()</strong>)
# <strong>dict_keys(['_factor'])</strong>
</pre></div><p>This is the <code class="literal">_factor</code> attribute that we find in the problematic version of this example. But look at the one that is using <code class="literal">__factor</code>:</p><p>
<code class="literal">oop/private.attrs.fixed.py</code>
</p><div><pre class="programlisting">print(<strong>obj.__dict__.keys()</strong>)
# <strong>dict_keys(['_A__factor', '_B__factor'])</strong>
</pre></div><p>See? <code class="literal">obj</code> has two attributes now, <code class="literal">_A__factor</code> (mangled within the <code class="literal">A</code> class), and <code class="literal">_B__factor</code> (mangled within the <code class="literal">B</code> class). This is the mechanism that makes possible that when you do <code class="literal">obj.__factor = 42</code>, <code class="literal">__factor</code> in <code class="literal">A</code> isn't changed, because you're actually touching <code class="literal">_B__factor</code>, which leaves <code class="literal">_A__factor</code> safe and sound.</p><p>If you're<a id="id444" class="indexterm"/> designing a library with classes<a id="id445" class="indexterm"/> that are meant to be used and extended by other developers, you will need to keep this in mind in order to avoid unintentional overriding of your attributes. Bugs like these can be pretty subtle and hard to spot.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec90"/>The property decorator</h2></div></div></div><p>Another<a id="id446" class="indexterm"/> thing that would be a crime not to mention is the <code class="literal">property</code> decorator. Imagine that you have an <code class="literal">age</code> attribute in a <code class="literal">Person</code> class and at some point you want to make sure that when you change its value, you're also checking that <code class="literal">age</code> is within a proper range, like [18, 99]. You can write accessor methods, like <code class="literal">get_age()</code> and <code class="literal">set_age()</code> (also called <strong>getters</strong> and <strong>setters</strong>) and put <a id="id447" class="indexterm"/>the logic there. <code class="literal">get_age()</code> will most likely just return <code class="literal">age</code>, while <code class="literal">set_age()</code> will also do the range check. The problem is that you may already have a lot of code accessing the <code class="literal">age</code> attribute directly, which means you're now up to<a id="id448" class="indexterm"/> some good (and potentially dangerous and tedious) refactoring. Languages like Java overcome this problem by using the accessor pattern basically by default. Many Java <strong>Integrated Development Environments</strong> (<strong>IDEs</strong>) autocomplete an attribute declaration by writing getter and setter accessor methods stubs for you on the fly.</p><p>Python is smarter, and does this with the <code class="literal">property</code> decorator. When you decorate a method with <code class="literal">property</code>, you can use the name of the method as if it was a data attribute. Because of this, it's always best to refrain from putting logic that would take a while to complete in such methods because, by accessing them as attributes, we are not expecting to wait.</p><p>Let's look at an example:</p><p>
<code class="literal">oop/property.py</code>
</p><div><pre class="programlisting">class Person:
    def __init__(self, age):
        self.age = age  # anyone can modify this freely

class PersonWithAccessors:
    def __init__(self, age):
        self._age = age

    def <strong>get_age</strong>(self):
        return self._age

    def <strong>set_age</strong>(self):
        if 18 &lt;= age &lt;= 99:
            self._age = age
        else:
            raise ValueError('Age must be within [18, 99]')

class <strong>PersonPythonic</strong>:
    def __init__(self, age):
        self._age = age

    @<strong>property</strong>
    def age(self):
        return self._age

    @<strong>age.setter</strong>
    def age(self, age):
        if 18 &lt;= age &lt;= 99:
            self._age = age
        else:
            raise ValueError('Age must be within [18, 99]')

person = PersonPythonic(39)
print(<strong>person.age</strong>)  # 39 - Notice we access as data attribute
<strong>person.age</strong> = 42  # Notice we access as data attribute
print(<strong>person.age</strong>)  # 42
person.age = 100  # ValueError: Age must be within [18, 99]</pre></div><p>The <code class="literal">Person</code> class may be the first version we write. Then we realize we need to put the range<a id="id449" class="indexterm"/> logic in place so, with another language, we would have to rewrite <code class="literal">Person</code> as the <code class="literal">PersonWithAccessors</code> class, and refactor all the code that was using <code class="literal">Person.age</code>. In Python, we rewrite <code class="literal">Person</code> as <code class="literal">PersonPythonic</code> (you normally wouldn't change the name, of course) so that the age is stored in a private <code class="literal">_age</code> variable, and we define property getters and setters using that decoration, which allow us to keep using the <code class="literal">person</code> instances as we were before. A <strong>getter</strong> is a <a id="id450" class="indexterm"/>method that is called when we access an attribute <a id="id451" class="indexterm"/>for reading. On the other hand, a <strong>setter</strong> is a method that is called when we access an attribute to write it. In other languages, like Java for example, it's customary to define them as <code class="literal">get_age()</code> and <code class="literal">set_age(int value)</code>, but I find the Python syntax much neater. It allows you to start writing simple code and refactor later on, only when you need it, there is no need to pollute your code with accessors only because they may be helpful in the future.</p><p>The <code class="literal">property</code> decorator also allows for read-only data (no setter) and for special actions when the attribute is deleted. Please refer to the official documentation to dig deeper.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec91"/>Operator overloading</h2></div></div></div><p>I find <a id="id452" class="indexterm"/>Python's approach to <strong>operator overloading</strong> to be brilliant. To overload an operator means to give it a meaning according<a id="id453" class="indexterm"/> to the context in which it is used. For example, the <code class="literal">+</code> operator means addition when we deal with numbers, but concatenation when we deal with sequences.</p><p>In Python, when you use operators, you're most likely calling the special methods of some objects behind the scenes. For example, the call <code class="literal">a[k]</code> roughly translates to <code class="literal">type(a).__getitem__(a, k)</code>.</p><p>As an example, let's create a class that stores a string and evaluates to <code class="literal">True</code> if <code class="literal">'42'</code> is part of that string, and <code class="literal">False</code> otherwise. Also, let's give the class a length property which corresponds to that of the stored string.</p><p>
<code class="literal">oop/operator.overloading.py</code>
</p><div><pre class="programlisting">class Weird:
    def __init__(self, s):
        self._s = s

    def __len__(self):
        return len(self._s)

    def __bool__(self):
        return '42' in self._s


weird = Weird('Hello! I am 9 years old!')
print(len(weird))  # 24
print(bool(weird))  # False

weird2 = Weird('Hello! I am 42 years old!')
print(len(weird2))  # 25
print(bool(weird2))  # True</pre></div><p>That was fun, wasn't it? For the complete list of magic methods that you can override in order to provide your custom implementation of operators for your classes, please refer to the Python data model in the official documentation.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec92"/>Polymorphism – a brief overview</h2></div></div></div><p>The <a id="id454" class="indexterm"/>word <strong>polymorphism</strong> comes from <a id="id455" class="indexterm"/>the Greek <em>polys</em> (many, much) and <em>morphē</em> (form, shape), and its meaning is the provision of a single interface for entities of different types.</p><p>In our car example, we call <code class="literal">engine.start()</code>, regardless of what kind of engine it is. As long as it exposes the start method, we can call it. That's polymorphism in action.</p><p>In other languages, like Java, in order to give a function the ability to accept different types and call a method on them, those types need to be coded in such a way that they share an interface. In this way, the compiler knows that the method will be available regardless of the type of the object the function is fed (as long as it extends the proper interface, of course).</p><p>In Python, things are different. Polymorphism is implicit, nothing prevents you to call a method on an object, therefore, technically, there is no need to implement interfaces or other patterns.</p><p>There is <a id="id456" class="indexterm"/>a special kind of polymorphism called <strong>ad hoc polymorphism</strong>, which is what we saw in the last paragraph: operator overloading. The ability of an operator to change shape, according to the type of data it is fed.</p><p>I cannot spend too much time on polymorphism, but I encourage you to check it out by yourself, it will expand your understanding of OOP. Good luck!</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec61"/>Writing a custom iterator</h1></div></div></div><p>Now <a id="id457" class="indexterm"/>we have all the tools to appreciate how we can write our own custom iterator. Let's first define what is an iterable and an iterator:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Iterable</strong>: An<a id="id458" class="indexterm"/> object is said to be iterable if it's capable of returning its members one at a time. Lists, tuples, strings, dicts, are all iterables. Custom objects that define either of <code class="literal">__iter__</code> or <code class="literal">__getitem__</code> methods are also iterables.</li><li class="listitem" style="list-style-type: disc"><strong>Iterator</strong>: An<a id="id459" class="indexterm"/> object is said to be an iterator if it represents a stream of data. A custom iterator is required to provide an implementation for <code class="literal">__iter__</code> that returns the object itself, and an implementation for <code class="literal">__next__</code>, which returns the next item of the data stream until the stream is exhausted, at which point all successive calls to <code class="literal">__next__</code> simply raise the <code class="literal">StopIteration</code> exception. Built-in functions such as <code class="literal">iter</code> and <code class="literal">next</code> are mapped to call <code class="literal">__iter__</code> and <code class="literal">__next__</code> on an object, behind the scenes.</li></ul></div><p>Let's write an iterator that returns all the odd characters from a string first, and then the even ones.</p><p>
<code class="literal">iterators/iterator.py</code>
</p><div><pre class="programlisting">class OddEven:

    def __init__(self, data):
        self._data = data
        <strong>self.indexes = (list(range(0, len(data), 2)) +</strong>
<strong>            list(range(1, len(data), 2)))</strong>

    def __iter__(self):
        return self

    def __next__(self):
        if <strong>self.indexes</strong>:
            return self._data[<strong>self.indexes.pop(0)</strong>]
        raise StopIteration

oddeven = OddEven('ThIsIsCoOl!')
print(''.join(c for c in oddeven))  # TIICO!hssol

oddeven = OddEven('HoLa')  # or manually...
it = iter(oddeven)  # this calls oddeven.__iter__ internally
print(next(it))  # H
print(next(it))  # L
print(next(it))  # o
print(next(it))  # a</pre></div><p>So, we<a id="id460" class="indexterm"/> needed to provide an implementation for <code class="literal">__iter__</code> which returned the object itself, and then one for <code class="literal">__next__</code>. Let's go through it. What needs to happen is that we return <code class="literal">_data[0]</code>, <code class="literal">_data[2]</code>, <code class="literal">_data[4]</code>, ..., <code class="literal">_data[1]</code>, <code class="literal">_data[3]</code>, <code class="literal">_data[5]</code>, ... until we have returned every item in the data. In order to do this, we prepare a list, indexes, like [0, 2, 4, 6, ..., 1, 3, 5, ...], and while there is at least an element in it, we pop the first one and return the element from the data that is at that position, thereby achieving our goal. When <code class="literal">indexes</code> is empty, we raise <code class="literal">StopIteration</code>, as required by the iterator protocol.</p><p>There are other ways to achieve the same result, so go ahead and try to code a different one yourself. Make sure the end result works for all edge cases, empty sequences, sequences of length 1, 2, and so on.</p></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec62"/>Summary</h1></div></div></div><p>In this chapter, we saw decorators, discovered the reasons for having them, and a few examples using one or more at the same time. We also saw decorators that take arguments, which are usually used as decorator factories.</p><p>We scratched the surface of object-oriented programming in Python. We covered all the basics in a way that you should now be able to understand fairly easily the code that will come in future chapters. We talked about all kinds of methods and attributes that one can write in a class, we explored inheritance versus composition, method overriding, properties, operator overloading, and polymorphism.</p><p>At the end, we very briefly touched base on iterators, so now you have all the knowledge to also understand generators more deeply.</p><p>In the next chapter, we take a steep turn. It will start the second half of the book, which is much more project-oriented so, from now on, it will be less theory and more code, I hope you will enjoy following the examples and getting your hands dirty, very dirty.</p><p>They say that a smooth sea never made a skillful sailor, so keep exploring, break things, read the error messages as well as the documentation, and let's see if we can get to see that white rabbit.</p></div></body></html>