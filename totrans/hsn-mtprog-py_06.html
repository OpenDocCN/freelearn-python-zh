<html><head></head><body>
<div><div><h1 id="_idParaDest-54"><em class="italic"><a id="_idTextAnchor056"/>Chapter 4</em>: Working with Metaclasses</h1>
<p>Metaclasses, the<a id="_idIndexMarker166"/> focal point of this chapter, can manipulate the way a new class is created by decorating the arguments without impacting the actual class definition itself. Metaclasses are not very frequently used in Python application development unless there is a need for more advanced implementations of frameworks or APIs that need features such as manipulation of classes or dynamic class generation and so on.</p>
<p>In the previous chapter, we looked at the concept of decorators with some examples. Understanding decorators helps in following metaclasses with more ease since both decorators and metaclasses deal with metaprogramming on Python 3 program objects by manipulating them externally.</p>
<p>In this chapter, we will cover the following main topics:</p>
<ul>
<li>Overview of metaclasses</li>
<li>The structure of a metaclass</li>
<li>The application of metaclasses</li>
<li>Switching metaclasses</li>
<li>Inheritance in metaclasses</li>
<li>Manipulating class variables</li>
</ul>
<p>By the end of this chapter, you should be able to create your own metaclasses, implement inheritance on metaclasses, and reuse ones that are already created.</p>
<h1 id="_idParaDest-55"><a id="_idTextAnchor057"/>Technical requirements</h1>
<p>The code examples shared in this chapter are available on GitHub under the code for this chapter here: <a href="https://github.com/PacktPublishing/Metaprogramming-with-Python/tree/main/Chapter04">https://github.com/PacktPublishing/Metaprogramming-with-Python/tree/main/Chapter04</a>.</p>
<h1 id="_idParaDest-56"><a id="_idTextAnchor058"/>Overview of metaclasses</h1>
<p>Metaclasses are <a id="_idIndexMarker167"/>classes that can be created separately with certain features that can alter the behavior of other classes or can help in dynamically manufacturing new classes. The base class of all metaclasses is the <code>type</code> class and the object or instance of a metaclass will be a class. Any custom metaclass that we create will be inherited from the <code>type</code> class. <code>type</code> is the class of all data types in Python as well and everything else in Python 3 is an object of the <code>type</code> class. We can test this statement by checking the type of different program objects in Python, as follows:</p>
<pre class="source-code">class TestForType:  </pre>
<pre class="source-code">    pass  </pre>
<pre class="source-code">type(TestForType)</pre>
<pre class="source-code"><strong class="bold">type</strong></pre>
<pre class="source-code">type(int)</pre>
<pre class="source-code"><strong class="bold">type</strong></pre>
<pre class="source-code">type(str)</pre>
<pre class="source-code"><strong class="bold">type</strong></pre>
<pre class="source-code">type(object)</pre>
<pre class="source-code"><strong class="bold">type</strong></pre>
<pre class="source-code">type(float)</pre>
<pre class="source-code"><strong class="bold">type</strong></pre>
<pre class="source-code">type(list)</pre>
<pre class="source-code"><strong class="bold">type</strong></pre>
<p>In this chapter, we will look at some examples of how to use these metaclasses, how to implement them, and how to reuse them. We will continue with our <em class="italic">ABC Megamart</em> examples to proceed further with the understanding of metaclasses.</p>
<h1 id="_idParaDest-57"><a id="_idTextAnchor059"/>The structure of a metaclass</h1>
<p>A metaclass is<a id="_idIndexMarker168"/> like any other class, but it has the ability to alter the behavior of other classes that take it as their metaclass. Understanding the structure of a metaclass helps us create our own customized metaclasses, which can be used further in manipulating new classes. The superclass of a metaclass is the type itself. When we create a class with <code>type</code> as its superclass and override the <code>__new__</code> method to manipulate the metadata of a class it returns, then we have created a metaclass. Let’s take a closer look with the help of some simple examples. </p>
<p>The <code>__new__</code> method takes <code>cls</code> as its first argument, which is the class itself. The members of the class that has <code>cls</code> as its first argument can be accessed by the class name and the rest of the arguments as other metadata of the class, as seen here:</p>
<pre class="source-code">class ExampleMetaClass1(type):  </pre>
<pre class="source-code">    def __new__(classitself, *args):  </pre>
<pre class="source-code">        print('class itself: ', classitself)  </pre>
<pre class="source-code">        print('Others: ', args)  </pre>
<pre class="source-code">        return type.__new__(classitself, *args)  </pre>
<p>In the preceding code, we have created the class <code>ExampleMetaClass1</code>, which inherits the class <code>type</code> and overrides the <code>__new__</code> method to print the class instance and its other arguments. </p>
<p>Let’s now create the class <code>ExampleClass1</code> and add the preceding metaclass to it:</p>
<pre class="source-code">class ExampleClass1(metaclass = ExampleMetaClass1):      </pre>
<pre class="source-code">    int1 = 123  </pre>
<pre class="source-code">    str1 = 'test'  </pre>
<pre class="source-code">      </pre>
<pre class="source-code">    def test():  </pre>
<pre class="source-code">        print('test')  </pre>
<p>Running the preceding code displays the following result:</p>
<pre class="source-code"><strong class="bold">class itself:  &lt;class '__main__.ExampleMetaClass1'&gt;</strong></pre>
<pre class="source-code"><strong class="bold">Others:  ('ExampleClass1', (), {'__module__': '__main__', '__qualname__': 'ExampleClass1', 'int1': 123, 'str1': 'test', 'test': &lt;function ExampleClass1.test at 0x00000194A377E1F0&gt;})</strong></pre>
<p>The first part <a id="_idIndexMarker169"/>of this output is the class instance <code>&lt;class '__main__.ExampleMetaClass1'&gt;</code> and the remaining arguments are the class name and the arguments of the class. A simple representation of the metaclass definition is as follows:</p>
<div><div><img alt="Figure 4.1 – Example metaclass definition " height="241" src="img/B13426_04_01.jpg" width="549"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.1 – Example metaclass definition</p>
<p>Let’s dive into a little more detail with another example in our next subsection.</p>
<h2 id="_idParaDest-58"><a id="_idTextAnchor060"/>Analyzing the arguments</h2>
<p>We now will <a id="_idIndexMarker170"/>dig deeper into the arguments of the <code>__new__</code> method of a metaclass. Analyzing the arguments of a metaclass will provide clarity on what information of a class can be customized using a metaclass. The data that can be manipulated in the classes that adds a metaclass while defining is represented in the following figure:</p>
<div><div><img alt="Figure 4.2 – Example metaclass with more arguments " height="557" src="img/B13426_04_02.jpg" width="845"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.2 – Example metaclass with more arguments</p>
<p>Let’s now follow<a id="_idIndexMarker171"/> these steps to see how the behavior of arguments affects classes:</p>
<ol>
<li>First, look at the following code where we have all arguments of a metaclass segregated—class instance; class name; all parent classes, superclasses, or base classes of the class; and all variables and methods created within the class:<pre>class ExampleMetaClass2(type):  
    def __new__(classitself, classname, baseclasses, 
                attributes):  
        print('class itself: ', classitself)  
        print('class name: ', classname)  
        print('parent class list: ', baseclasses)  
        print('attribute list: ', attributes)  
        return type.__new__(classitself, classname, 
            baseclasses, attributes)  </pre></li>
<li>Next, we<a id="_idIndexMarker172"/> will be creating two parent classes—<code>ExampleParentClass1</code> and <code>ExampleParentClass2</code>:<pre>class ExampleParentClass1():      
       def test1():  
            print('parent1 - test1')  
class ExampleParentClass2():      
       def test2():  
            print('parent2 - test2')  </pre></li>
<li>Now, we will create the class <code>ExampleClass2</code> where we will be inheriting both of the preceding parent classes and adding the metaclass as <code>ExampleMetaClass2</code>:<pre>class ExampleClass2(ExampleParentClass1,ExampleParentClass2, metaclass = ExampleMetaClass2):      
    int1 = 123  
    str1 = 'test'  
      
    def test3():  
        print('child1 - test3')  </pre></li>
<li>Executing the preceding code results in the following output:<pre>class itself:  <strong class="bold">&lt;class '__main__.ExampleMetaClass2'&gt;</strong>
class name:  <strong class="bold">ExampleClass2</strong>
parent class:  <strong class="bold">(&lt;class '__main__.ExampleParentClass1'&gt;, &lt;class '__main__.ExampleParentClass2'&gt;)</strong>
attributes:  <strong class="bold">{'__module__': '__main__', '__qualname__': 'ExampleClass2', 'int1': 123, 'str1': 'test', 'test3': &lt;function ExampleClass2.test3 at 0x00000194A3994E50&gt;}</strong></pre></li>
</ol>
<p>This example shows us the highlighted arguments that are returned by the metaclass and gives an overview of which values can possibly be manipulated from a class using metaprogramming.</p>
<ol>
<li value="5">Let us look <a id="_idIndexMarker173"/>at the type of each of the classes created in this example:<pre>type(ExampleParentClass1)
<strong class="bold">type</strong>
type(ExampleParentClass2)
<strong class="bold">type</strong>
type(ExampleMetaClass2)
<strong class="bold">type</strong>
type(ExampleClass2)
__main__.ExampleMetaClass2</pre></li>
</ol>
<p>As we can see, the <a id="_idIndexMarker174"/>type of all other classes is the type itself whereas the type of <code>ExampleClass2</code> is <code>ExampleMetaClass2</code>.</p>
<p>Now that you understand the structure of a metaclass, we can look further into applications of metaclasses on our <em class="italic">ABC Megamart</em> example.</p>
<h1 id="_idParaDest-59"><a id="_idTextAnchor061"/>The application of metaclasses</h1>
<p>In this section, we will look<a id="_idIndexMarker175"/> at an example where we will create a metaclass that can automatically modify the user-defined method attributes of any branch class that is newly created. To test this, let us follow these steps:</p>
<ol>
<li value="1">Create a metaclass with the name <code>BranchMetaclass</code>:<pre>class BranchMetaclass(type):  </pre></li>
<li>Create a <code>__new__</code> method with class instance, class name, base classes, and attributes as its arguments. In the <code>__new__</code> method, import the <code>inspect</code> library, which can help inspect the input attributes:<pre>    def __new__(classitself, classname, baseclasses, 
         attributes):  
        import inspect  </pre></li>
<li>Create a new dictionary, <code>newattributes</code>:<pre>     newattributes = {}  </pre></li>
</ol>
<p>Iterate over the class attributes, check that the attributes start with <code>__</code>, and don’t change the value. </p>
<ol>
<li value="4">Continue<a id="_idIndexMarker176"/> iterating over the other attributes and check if the attributes are functions. If they are functions, prefix <code>branch</code> to the class method and convert the method name into title case:<pre>for attribute, value in attributes.items():  
            if attribute.startswith("__"):  
                newattributes[attribute] = value  
            elif inspect.isfunction(value):  
                newattributes['branch' +
                    attribute.title()] = value for a
                    attribute, value in 
                    attributes.items():
            if attribute.startswith("__"):  
                newattributes[attribute] = value  
            elif inspect.isfunction(value):  
                newattributes['branch' + 
                    attribute.title()] = value  </pre></li>
<li>If the preceding conditions are not met, save the value of the attribute as it is:<pre>else:  
                newattributes[attribute] = value  </pre></li>
<li>Return the <code>new</code> method with new attributes:<pre>                     return type.__new__(classitself, 
                         classname, baseclasses, 
                         newattributes) </pre></li>
<li>Within <a id="_idIndexMarker177"/>the metaclass, also create a regular user-defined method, <code>buy_product</code>, to calculate the sales price of a product:<pre>def buy_product(product,unit_price,quantity,statetax_rate,promotiontype):  
        statetax_rate = statetax_rate          
        initialprice = unit_price*quantity   
        sales_price = initialprice + 
            initialprice*statetax_rate  
        return sales_price, product,promotiontype  </pre></li>
<li>Next, we will create another new class, <code>Brooklyn</code>, and add this metaclass to the class. By adding the metaclass, we want the methods in the class <code>Brooklyn</code> to have a prefix branch and change the methods to title case while creating the methods of <code>Brooklyn</code>. </li>
</ol>
<p>The <code>Brooklyn</code> class has four variables, <code>product_id</code>, <code>product_name</code>, <code>product_category</code>, and <code>unit_price</code>. We will also create a method to calculate the maintenance cost and this method should be converted from <code>maintenance_cost</code> to <code>branchMaintenance_cost</code> due to the metaclass that alters the behavior of the newly created class. Here’s the new class:</p>
<pre>class Brooklyn(metaclass = BranchMetaclass):  
    product_id = 100902  
    product_name = 'Iphone X'  
    product_category = 'Electronics'  
    unit_price = 700  
      
    def maintenance_cost(self,product_type, quantity):
        self.product_type = product_type  
        self.quantity = quantity  
        cold_storage_cost = 100  
        if (product_type == 'Electronics'):  
            maintenance_cost = self.quantity * 0.25 + 
                cold_storage_cost      
            return maintenance_cost  
        else:  
            return "We don't stock this product"  </pre>
<ol>
<li value="9">We can<a id="_idIndexMarker178"/> list all the arguments of the class <code>Brooklyn</code> and check if the metaclass has altered its behavior:<pre>dir(Brooklyn)
['__class__',
 '__delattr__',
 '__dict__',
 ‚__dir__',
 ‚__doc__',
 ‚__eq__',
 ‚__format__',
 ‚__ge__',
 ‚__getattribute__',
 ‚__gt__',
 ‚__hash__',
 ‚__init__',
 ‚__init_subclass__',
 ‚__le__',
 ‚__lt__',
 ‚__module__',
 ‚__ne__',
 ‚__new__',
 ‚__reduce__',
 ‚__reduce_ex__',
 ‚__repr__',
 ‚__setattr__',
 ‚__sizeof__',
 ‚__str__',
 ‚__subclasshook__',
 ‚__weakref__',
 <strong class="bold">'branchMaintenance_cost'</strong>,
 'product_category',
 'product_id',
 'product_name',
 'unit_price']</pre></li>
<li>Let us now <a id="_idIndexMarker179"/>create an object and look at its methods and variables, as follows:<pre>brooklyn = Brooklyn()
brooklyn.branchMaintenance_Cost('Electronics',10)
<strong class="bold">102.5</strong>
brooklyn.product_id
<strong class="bold">100902</strong>
brooklyn.product_name
<strong class="bold">'Iphone X'</strong>
brooklyn.product_type
<strong class="bold">'Electronics'</strong></pre></li>
</ol>
<p>A simple <a id="_idIndexMarker180"/>representation of this example is as follows:</p>
<div><div><img alt="Figure 4.3 – Application of metaclass on ABC Megamart – Branch example " height="542" src="img/B13426_04_03.jpg" width="894"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.3 – Application of metaclass on ABC Megamart – Branch example</p>
<p>So far, we’ve looked at an overview of a metaclass, understood its structure, performed an analysis of its arguments, and applied our understanding by creating a custom metaclass on our core example. We will look at a few more applications in the following section.</p>
<h2 id="_idParaDest-60"><a id="_idTextAnchor062"/>Inheriting the metaclass</h2>
<p>In this section, we will<a id="_idIndexMarker181"/> walk through an example where we will inherit the metaclass to check whether it can be inherited as a regular parent class without altering the behavior of the new class that is being created. Take a look at the following code:</p>
<pre class="source-code">class Queens(BranchMetaclass):  </pre>
<pre class="source-code">    def maintenance_cost(product_type, quantity):  </pre>
<pre class="source-code">        product_type = product_type  </pre>
<pre class="source-code">        quantity = quantity  </pre>
<pre class="source-code">        if (product_type == ‹FMCG›):  </pre>
<pre class="source-code">            maintenance_cost = quantity * 0.05  </pre>
<pre class="source-code">            return maintenance_cost  </pre>
<pre class="source-code">        else:  </pre>
<pre class="source-code">            return "We don't stock this product"  </pre>
<p>Let's now create an object for the preceding class to check if an object can be created:</p>
<pre class="source-code">queens = Queens()</pre>
<p>We get the following <code>TypeError</code>:</p>
<div><div><img alt="Figure 4.4 – Error while creating an object for the class inheriting a metaclass " height="157" src="img/B13426_04_04.jpg" width="995"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.4 – Error while creating an object for the class inheriting a metaclass</p>
<p>This error occurred as <code>__new__</code> is a static method that is called to create a new instance for the class and it expects three arguments of the class, which are not provided while creating the class object. However, there is another way of calling the newly created class, <code>Queens</code>. The class can be called directly, and its methods can be used without having to create an object:</p>
<pre class="source-code">Queens.maintenance_cost('FMCG',120)</pre>
<pre class="source-code"><strong class="bold">6.0</strong></pre>
<p>The <code>maintenance_cost</code> method did not get modified into <code>branchMaintenance_cost</code> since the metaclass is not used as a metaclass but as a parent class. Since the <a id="_idIndexMarker182"/>metaclass is inherited, <code>Queens</code> also inherits the user-defined methods of <code>BranchMetaclass</code> as follows:</p>
<pre class="source-code">Queens.buy_product('Iphone',1000,1,0.04,None)</pre>
<pre class="source-code"><strong class="bold">(1040.0, 'Iphone', None)</strong></pre>
<h2 id="_idParaDest-61"><a id="_idTextAnchor063"/>Inheriting as a parent and metaclass</h2>
<p>Let’s now look<a id="_idIndexMarker183"/> at what happens when we inherit a class as a parent and also add it as a metaclass while creating a new class:</p>
<pre class="source-code">class Queens(BranchMetaclass, metaclass = BranchMetaclass):  </pre>
<pre class="source-code">    def maintenance_cost(product_type, quantity):  </pre>
<pre class="source-code">        product_type = product_type  </pre>
<pre class="source-code">        quantity = quantity  </pre>
<pre class="source-code">        if (product_type == ‹FMCG›):  </pre>
<pre class="source-code">            maintenance_cost = quantity * 0.05  </pre>
<pre class="source-code">            return maintenance_cost  </pre>
<pre class="source-code">        else:  </pre>
<pre class="source-code">            return "We don't stock this product"  </pre>
<p>In the preceding code, we have added <code>BranchMetaclass</code> as the parent class for the class <code>Queens</code> and we have also added it as a metaclass. This definition should make the class <code>Queens</code> inherit the custom methods from <code>BranchMetaclass</code> and also change the <code>maintenance_cost</code> method into <code>branchMaintenance_cost</code>. Let’s see if it does:</p>
<pre class="source-code">Queens.branchMaintenance_Cost('FMCG',2340)</pre>
<pre class="source-code"><strong class="bold">117.0</strong></pre>
<p>In the<a id="_idIndexMarker184"/> preceding code execution and output, the <code>maintenance_cost</code> method is converted into the <code>branchMaintenance_cost</code> method as expected. Now run the following command:</p>
<pre class="source-code">Queens.buy_product('Iphone',1500,1,0.043,None)</pre>
<pre class="source-code"><strong class="bold">(1564.5, 'Iphone', None)</strong></pre>
<p>The <code>buy_product</code> method, which is a custom method from <code>BranchMetaclass</code>, is also inherited since it is a parent class. </p>
<p>Here is a simple representation of this example:</p>
<div><div><img alt="Figure 4.5 – Application of metaclass and also inheriting it on ABC Megamart branch example " height="605" src="img/B13426_04_05.jpg" width="923"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.5 – Application of metaclass and also inheriting it on ABC Megamart branch example</p>
<p>Let us look further into examples of switching metaclasses from one class to another. </p>
<h1 id="_idParaDest-62"><a id="_idTextAnchor064"/>Switching metaclasses</h1>
<p>We can now look into<a id="_idIndexMarker185"/> the concept of switching metaclasses for a class. You may think, <em class="italic">why do we need to switch metaclasses?</em> Switching metaclasses reinforces the reusability concept of metaprogramming and in this case, it helps in understanding how a metaclass created for use on one class can also be used for a different class without impacting the class definition. </p>
<p>In the example for this section, we will be creating two meta classes – <code>IncomeStatementMetaClass</code> and <code>BalanceSheetMetaClass</code>. For the Malibu branch of <em class="italic">ABC Megamart</em>, we will create a class to capture the information required for its financial statements. The two financial statements relevant for this example are Income Statement attributes and Balance Sheet attributes for the Malibu branch. To differentiate where a particular attribute or method of a class should go, we will be creating two metaclasses that look at the names of the attributes and tag them under Income Statement or Balance Sheet accordingly.</p>
<p>The following is <a id="_idIndexMarker186"/>a simple representation of the attributes that will be manipulated by the aforementioned metaclasses:</p>
<div><div><img alt="Figure 4.6 – Finance attributes used in this metaclass example " height="285" src="img/B13426_04_06.jpg" width="513"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.6 – Finance attributes used in this metaclass example</p>
<p>Take a look at the following code snippet:</p>
<pre class="source-code">class IncomeStatementMetaClass(type):  </pre>
<pre class="source-code">    def __new__(classitself, classname, baseclasses, </pre>
<pre class="source-code">                attributes):  </pre>
<pre class="source-code">          </pre>
<pre class="source-code">        newattributes = {}  </pre>
<pre class="source-code">        for attribute, value in attributes.items():  </pre>
<pre class="source-code">            if attribute.startswith("__"):  </pre>
<pre class="source-code">                newattributes[attribute] = value  </pre>
<pre class="source-code">            elif («revenue» in attribute) or \  </pre>
<pre class="source-code">            ("expense" in attribute) or \  </pre>
<pre class="source-code">            ("profit" in attribute) or \  </pre>
<pre class="source-code">            ("loss" in attribute):  </pre>
<pre class="source-code">                newattributes['IncomeStatement_' + </pre>
<pre class="source-code">                    attribute.title()] = value  </pre>
<pre class="source-code">            else:  </pre>
<pre class="source-code">                newattributes[attribute] = value  </pre>
<pre class="source-code">        return type.__new__(classitself, classname, </pre>
<pre class="source-code">            baseclasses, newattributes)  </pre>
<p>Here, the <code>new</code> method is modified to check for attributes that have the key as one of the parameters<a id="_idIndexMarker187"/> that belong to an income statement such as <code>revenue</code>, <code>expense</code>, <code>profit</code>, or <code>loss</code>. If any of this terminology occurs in the method name or variable name, we will add a prefix of <code>IncomeStatement</code> to segregate those methods and variables.</p>
<p>To test this metaclass, we will be creating a new class, <code>Malibu</code>, with four variables and four methods, as follows:</p>
<pre class="source-code">class Malibu(metaclass = IncomeStatementMetaClass):  </pre>
<pre class="source-code">    profit = 4354365  </pre>
<pre class="source-code">    loss = 43000  </pre>
<pre class="source-code">    assets = 15000  </pre>
<pre class="source-code">    liabilities = 4000  </pre>
<pre class="source-code">    def calc_revenue(quantity,unitsales_price):  </pre>
<pre class="source-code">        totalrevenue = quantity * unitsales_price   </pre>
<pre class="source-code">        return totalrevenue  </pre>
<pre class="source-code">      </pre>
<pre class="source-code">    def calc_expense(totalrevenue,netincome, netloss):  </pre>
<pre class="source-code">        totalexpense = totalrevenue - (netincome + netloss)  </pre>
<pre class="source-code">        return totalexpense    </pre>
<pre class="source-code">      </pre>
<pre class="source-code">    def calc_totalassets(cash,inventory,accountsreceivable):</pre>
<pre class="source-code">        totalassets = cash + inventory + accountsreceivable  </pre>
<pre class="source-code">        return totalassets  </pre>
<pre class="source-code">      </pre>
<pre class="source-code">    def calc_totalliabilities(debt,accruedexpense,</pre>
<pre class="source-code">         accountspayable):  </pre>
<pre class="source-code">        totalliabilities = debt + accruedexpense + </pre>
<pre class="source-code">            accountspayable  </pre>
<pre class="source-code">        return totalliabilities  </pre>
<p>In the<a id="_idIndexMarker188"/> preceding code, we have added the metaclass <code>IncomeStatementMetaClass</code> and we see that the attributes of the class <code>Malibu</code> modify the behavior of variables and methods as follows:</p>
<div><div><img alt="Figure 4.7 – Malibu without metaclass (left) and Malibu with metaclass (right) " height="245" src="img/B13426_04_07.jpg" width="668"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.7 – Malibu without metaclass (left) and Malibu with metaclass (right)</p>
<p>We will further add another metaclass, <code>BalanceSheetMetaClass</code>, to deal with the balance sheet-related attributes in the class <code>Malibu</code>. In the following metaclass, the new method is modified to check for attributes that have the key as one of the parameters that belong to a balance sheet such as <code>assets</code>, <code>liabilities</code>, <code>goodwill</code>, and<a id="_idIndexMarker189"/> cash. If any of these terms occur in the method name or variable name, we will add a prefix of <code>BalanceSheet</code> to segregate those methods and variables:</p>
<pre class="source-code">class BalanceSheetMetaClass(type):  </pre>
<pre class="source-code">    def __new__(classitself, classname, baseclasses, </pre>
<pre class="source-code">                attributes):  </pre>
<pre class="source-code">        newattributes = {}  </pre>
<pre class="source-code">        for attribute, value in attributes.items():  </pre>
<pre class="source-code">            if attribute.startswith("__"):  </pre>
<pre class="source-code">                newattributes[attribute] = value  </pre>
<pre class="source-code">            elif («assets» in attribute) or \  </pre>
<pre class="source-code">            ("liabilities" in attribute) or \  </pre>
<pre class="source-code">            ("goodwill" in attribute) or \  </pre>
<pre class="source-code">            ("cash" in attribute):  </pre>
<pre class="source-code">                newattributes['BalanceSheet_' + </pre>
<pre class="source-code">                    attribute.title()] = value  </pre>
<pre class="source-code">            else:  </pre>
<pre class="source-code">                newattributes[attribute] = value  </pre>
<pre class="source-code">        return type.__new__(classitself, classname, </pre>
<pre class="source-code">            baseclasses, newattributes)  </pre>
<p>In the preceding <a id="_idIndexMarker190"/>code, we have added the metaclass <code>BalanceSheetMetaClass</code> and we see that the attributes of the class <code>Malibu</code> modify the behavior of variables and methods as follows:</p>
<div><div><img alt="Figure 4.8 – Malibu with IncomeStatementMetaClass (left) and Malibu with BalanceSheetMetaClass (right) " height="234" src="img/B13426_04_08.jpg" width="810"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.8 – Malibu with IncomeStatementMetaClass (left) and Malibu with BalanceSheetMetaClass (right)</p>
<p>Now that you know <a id="_idIndexMarker191"/>why we need to switch metaclasses, let us look at the application of metaclasses in inheritance.</p>
<h1 id="_idParaDest-63"><a id="_idTextAnchor065"/>Inheritance in metaclasses</h1>
<p><strong class="bold">Inheritance</strong>, in a literal<a id="_idIndexMarker192"/> sense, means a child acquiring the properties of a parent<a id="_idIndexMarker193"/> and it means the same in the case of object-oriented programming too. A new class can inherit the attributes and methods of a parent class and it can also have its own properties and methods.</p>
<p>In this example, we will look at how inheritance works on metaclasses by creating two classes, <code>California</code> and <code>Pasadena</code> – <code>California</code> being the parent class and <code>Pasadena</code> the child class. </p>
<p>Let’s check these steps out to understand inheritance better:</p>
<ol>
<li value="1">In the previous section, we already created two metaclasses that inherited type as their parent class – <code>IncomeStatementMetaClass</code> and <code>BalanceSheetMetaClass</code>. We will start by creating the class <code>California</code> with the <code>IncomeStatement</code> metaclass:<pre>class California(metaclass = IncomeStatementMetaClass):  
    profit = 4354365  
    loss = 43000  
    def calc_revenue(quantity,unitsales_price):  
        totalrevenue = quantity * unitsaleprice   
        return totalrevenue  
      
    def calc_expense(totalrevenue,netincome, netloss):  
        totalexpense = totalrevenue - (netincome + netloss)  
        return totalexpense   </pre></li>
</ol>
<p>Here, we have<a id="_idIndexMarker194"/> defined only those attributes that can be modified <a id="_idIndexMarker195"/>by the <code>IncomeStatement</code> metaclass. </p>
<ol>
<li value="2">Next, we will create another class, <code>Pasadena</code>, with the <code>BalanceSheet</code> metaclass:<pre>class Pasadena(California,metaclass = BalanceSheetMetaClass):  
    assets = 18000  
    liabilities = 5000  
    def calc_totalassets(cash,inventory,
        accountsreceivable):  
        totalassets = cash + inventory + 
            accountsreceivable  
        return totalassets  
      
    def calc_totalliabilities(debt,accruedexpense,
        accountspayable):  
        totalliabilities = debt + accruedexpense + 
            accountspayable  
        return totalliabilities  </pre></li>
</ol>
<p>We have defined here only those attributes that can be modified by the <code>BalanceSheet</code> metaclass. </p>
<ol>
<li value="3">Executing the<a id="_idIndexMarker196"/> code of the <code>Pasadena</code> class results in the following<a id="_idIndexMarker197"/> error:</li>
</ol>
<div><div><img alt="Figure 4.9 – Error while executing a child class that has a different metaclass " height="256" src="img/B13426_04_09.jpg" width="994"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.9 – Error while executing a child class that has a different metaclass</p>
<p>This error was thrown since <code>Pasadena</code> inherited the parent class <code>California</code>, which has a different metaclass, <code>IncomeStatementMetaClass</code>, which is inherited from type, and Pasadena’s metaclass <code>BalanceSheetMetaClass</code> is also inherited from type.</p>
<ol>
<li value="4">To resolve <a id="_idIndexMarker198"/>this <a id="_idIndexMarker199"/>error, we can redefine the <code>BalanceSheetMetaClass</code> with the parent class as <code>IncomeStatementMetaClass</code> instead of the type class, as follows:<pre>class BalanceSheetMetaClass(IncomeStatementMetaClass):  
    def __new__(classitself, classname, baseclasses, 
                attributes):  
        newattributes = {}  
        for attribute, value in attributes.items():  
            if attribute.startswith("__"):  
                newattributes[attribute] = value  
            elif («assets» in attribute) or \  
            ("liabilities" in attribute) or \  
            ("goodwill" in attribute) or \  
            ("cash" in attribute):  
                newattributes['BalanceSheet_' + 
                    attribute.title()] = value  
            else:  
                newattributes[attribute] = value  
        return type.__new__(classitself, classname, 
            baseclasses, newattributes)  </pre></li>
<li>Let’s now <a id="_idIndexMarker200"/>rerun the <code>California</code> parent class and also the <code>Pasadena</code> child <a id="_idIndexMarker201"/>class to check if the behavior modification of both the metaclasses is implemented in the <code>Pasadena</code> class:<pre>class California(metaclass = IncomeStatementMetaClass):  
    profit = 4354365  
    loss = 43000  
    def calc_revenue(quantity,unitsales_price):  
        totalrevenue = quantity * unitsaleprice   
        return totalrevenue  
    def calc_expense(totalrevenue,netincome, netloss):  
        totalexpense = totalrevenue - (netincome + 
            netloss)  
        return totalexpense    
class Pasadena(California,metaclass = BalanceSheetMetaClass):  
    assets = 18000  
    liabilities = 5000  
    def calc_totalassets(cash,inventory,
        accountsreceivable):  
        totalassets = cash + inventory + 
            accountsreceivable  
        return totalassets  
    def calc_totalliabilities(debt,accruedexpense,
        accountspayable):  
        totalliabilities = debt + accruedexpense + 
            accountspayable  
        return totalliabilities  </pre></li>
<li>Here is the<a id="_idIndexMarker202"/> output from the <code>Pasadena</code> class, and as we can see, both<a id="_idIndexMarker203"/> the <code>BalanceSheet</code> and <code>IncomeStatement</code> attributes are modified as per their metaclasses:</li>
</ol>
<div><div><img alt="Figure 4.10 – Pasadena class with inheritance" height="243" src="img/B13426_04_10.jpg" width="439"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.10 – Pasadena class with inheritance</p>
<p>A simple representation of this application is as follows:</p>
<div><div><img alt="Figure 4.11 – Inheritance in metaclasses " height="469" src="img/B13426_04_11.jpg" width="887"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.11 – Inheritance in metaclasses</p>
<p>In this case, we have<a id="_idIndexMarker204"/> redefined the parent class of <code>BalanceSheetMetaClass</code> to be <code>IncomeStatementMetaClass</code> since Python does not automatically resolve <a id="_idIndexMarker205"/>their parent classes while they were both inherited by type and instead throws a metaclass conflict. Redefining the parent class of <code>BalanceSheetMetaClass</code> not only resolves the error but will also not impact the overall functionality of the class since <code>IncomeStatementMetaClass</code> is in turn inherited from type.</p>
<p>Let us look at another example where we will be adding additional information to class attributes.</p>
<h1 id="_idParaDest-64"><a id="_idTextAnchor066"/>Manipulating class variables</h1>
<p>In this section, we <a id="_idIndexMarker206"/>will take an example to look at manipulating class variables further using metaclasses. We will be creating a metaclass named <code>SchemaMetaClass</code> and will define the <code>__new__</code> method to manipulate attributes of a class if they are variables of data types that belong to <code>integer</code>, <code>float</code>, <code>string</code>, or <code>boolean</code>. Let’s go through the steps real quick:</p>
<ol>
<li value="1">We will now create the <code>SchemaMetaClass</code> with the parent class as type and have modified the <code>new</code> method to check the following conditions:<pre>class SchemaMetaClass(type):  </pre></li>
<li>Create the dictionary object <code>newattributes</code>. If the <code>class</code> attribute is a built-in <code>class</code> method that starts with <code>__</code>, then the attribute’s value is stored as such in <code>newattributes</code>:<pre>    def __new__(classitself, classname, baseclasses, 
                attributes):  
        
        newattributes = {}  
        for attribute, value in attributes.items():  
            if attribute.startswith("__"):  
                newattributes[attribute] = value </pre></li>
<li>If the <code>class</code> attribute is an integer or float variable, then the class returns a dictionary item with the attribute name as <code>ColumnName</code>, the value as <code>Value</code>, <code>Type</code> as <code>NUMERIC</code>, and <code>Length</code> as the length of the value:<pre>            elif type(value)==int or type(value)==float:  
                newattributes[attribute] = {}  
                newattributes[attribute]['ColumnName']
                     = attribute.title()  
                newattributes[attribute]['Value'] 
                     = value  
                newattributes[attribute]['Type'] 
                     = 'NUMERIC'  
                newattributes[attribute]['Length'] = len(str(value))  </pre></li>
<li>If the <code>class</code> attribute<a id="_idIndexMarker207"/> is a string variable, then the class returns a similar dictionary item with <code>Type</code> as <code>VARCHAR</code>:<pre>            elif type(value)==str:  
                newattributes[attribute] = {}  
                newattributes[attribute]['ColumnName']
                     = attribute.title()  
                newattributes[attribute]['Value']
                     = value  
                newattributes[attribute]['Type']
                     = 'VARCHAR'  
                newattributes[attribute]['Length']
                     = len(value)  </pre></li>
<li>Similarly, if the <code>class</code> attribute is a boolean object, a similar kind of dictionary item with <code>Type</code> as <code>BOOLEAN</code> is returned:<pre>            elif type(value)==bool:  
                newattributes[attribute] = {}  
                newattributes[attribute]['ColumnName']
                     = attribute.title()  
                newattributes[attribute]['Value']
                     = value  
                newattributes[attribute]['Type']
                     = 'BOOLEAN'  
                newattributes[attribute]['Length']
                     = None  </pre></li>
<li>Any <a id="_idIndexMarker208"/>other variable or method is stored like so in <code>newattributes</code>:<pre>            else:  
                newattributes[attribute] = value                  
        return type.__new__(classitself, classname,
             baseclasses, newattributes)  </pre></li>
<li>We will now create the class <code>Arizona</code> with the metaclass as <code>SchemaMetaClass</code>, define all the variables for a product, and define a method that creates a schema out of the metaprogrammed class attributes:<pre>class Arizona(metaclass = SchemaMetaClass):  
    product_id = 200443  
    product_name = 'Iphone'  
    product_category = 'Electronics'  
    sales_quantity = 2  
    tax_rate = 0.05  
    sales_price = 1200  
    profit = 70  
    loss = 0  
    sales_margin = 0.1  
    promotion = '20%Off'  
    promotion_reason = 'New Year'    
    in_stock = True  
      
    def create_schema(self):  
        import pandas as pd  
        tableschema = pd.DataFrame([self.product_id,  
                                  self.product_name,  
                              self.product_category,  
                                self.sales_quantity,  
                                      self.tax_rate,  
                                   self.sales_price,  
                                        self.profit,  
                                          self.loss,  
                                  self.sales_margin,  
                                     self.promotion,  
                              self.promotion_reason,  
                                     self.in_stock])  
        tableschema.drop(labels = ['Value'], axis = 1,
                         inplace = True)  
        return tableschema   </pre></li>
</ol>
<p>We have added product details of an example product  (in this case, an iPhone) and the variables are a combination of different data types – <code>string</code>, <code>integer</code>, <code>float</code>, and <code>bool</code>. We will define the method <code>create_schema</code>, which imports the pandas library to create a DataFrame that gives a table-like structure to the variables and returns the data frame as a table schema.</p>
<ol>
<li value="8">Now, consider <a id="_idIndexMarker209"/>a scenario where the metaclass is not added to the preceding code. Calling the <code>product_name</code> variable would have resulted in the following:<pre>objarizona = Arizona()  
objarizona.product_name  
<strong class="bold">'Iphone'</strong></pre></li>
<li>Since we have added the metaclass in the preceding <code>Arizona</code> class definition, calling the <code>product_name</code> results in the following:<pre>objarizona = Arizona()
objarizona.product_name
<strong class="bold">{'ColumnName': 'Product_name',</strong>
<strong class="bold"> 'Value': 'Iphone',</strong>
<strong class="bold"> 'Type': 'VARCHAR',</strong>
<strong class="bold"> 'Length': 6}</strong></pre></li>
<li>Similarly, we can look at the results of a few other variables as follows:<pre>objarizona.product_category  
  
<strong class="bold">{'ColumnName': 'Product_category',  </strong>
<strong class="bold"> 'Value': 'Electronics',  </strong>
<strong class="bold"> 'Type': 'VARCHAR',  </strong>
<strong class="bold"> 'Length': 11}  </strong>
  
objarizona.sales_quantity  
<strong class="bold">{'ColumnName': 'Sales_quantity', 'Value': 2, 'Type': 'NUMERIC', 'Length': 1}  </strong>
  
objarizona.tax_rate  
<strong class="bold">{'ColumnName': 'Tax_rate', 'Value': 0.05, 'Type': 'NUMERIC', 'Length': 4}  </strong></pre></li>
<li>Using the<a id="_idIndexMarker210"/> metaprogrammed class variables further, we have defined the method <code>create_schema</code> to return a table schema:<pre>objarizona.create_schema()</pre></li>
</ol>
<p>We get the following table, which includes all of the variables defined in the class:</p>
<div><div><img alt="Figure 4.12 – Output of the method create_schema " height="417" src="img/B13426_04_12.jpg" width="324"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.12 – Output of the method create_schema</p>
<p>These are some examples <a id="_idIndexMarker211"/>of how metaclasses can be used in developing applications. Metaclasses can further be used in more complex scenarios such as automated code generation and framework development.</p>
<h1 id="_idParaDest-65"><a id="_idTextAnchor067"/>Summary</h1>
<p>In this chapter, we have learned how to create metaclasses and some applications of metaclasses. </p>
<p>We then saw how to switch metaclasses, reuse the functionalities, and how to implement inheritance on classes that use metaclasses. Finally, we also saw how to manipulate the variables of metaclasses further.</p>
<p>All of these concepts are part of Python metaprogramming and they are used to change the behavior of a class externally and without impacting the internal functionalities of the class itself.</p>
<p>In the next chapter, we will be looking at the concept of reflection with different examples.</p>
</div>
</div></body></html>