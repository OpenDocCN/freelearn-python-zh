<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer065">
<h1 id="_idParaDest-54"><em class="italic"><a id="_idTextAnchor056"/>Chapter 4</em>: Working with Metaclasses</h1>
<p>Metaclasses, the<a id="_idIndexMarker166"/> focal point of this chapter, can manipulate the way a new class is created by decorating the arguments without impacting the actual class definition itself. Metaclasses are not very frequently used in Python application development unless there is a need for more advanced implementations of frameworks or APIs that need features such as manipulation of classes or dynamic class generation and so on.</p>
<p>In the previous chapter, we looked at the concept of decorators with some examples. Understanding decorators helps in following metaclasses with more ease since both decorators and metaclasses deal with metaprogramming on Python 3 program objects by manipulating them externally.</p>
<p>In this chapter, we will cover the following main topics:</p>
<ul>
<li>Overview of metaclasses</li>
<li>The structure of a metaclass</li>
<li>The application of metaclasses</li>
<li>Switching metaclasses</li>
<li>Inheritance in metaclasses</li>
<li>Manipulating class variables</li>
</ul>
<p>By the end of this chapter, you should be able to create your own metaclasses, implement inheritance on metaclasses, and reuse ones that are already created.</p>
<h1 id="_idParaDest-55"><a id="_idTextAnchor057"/>Technical requirements</h1>
<p>The code examples shared in this chapter are available on GitHub under the code for this chapter here: <a href="https://github.com/PacktPublishing/Metaprogramming-with-Python/tree/main/Chapter04">https://github.com/PacktPublishing/Metaprogramming-with-Python/tree/main/Chapter04</a>.</p>
<h1 id="_idParaDest-56"><a id="_idTextAnchor058"/>Overview of metaclasses</h1>
<p>Metaclasses are <a id="_idIndexMarker167"/>classes that can be created separately with certain features that can alter the behavior of other classes or can help in dynamically manufacturing new classes. The base class of all metaclasses is the <strong class="source-inline">type</strong> class and the object or instance of a metaclass will be a class. Any custom metaclass that we create will be inherited from the <strong class="source-inline">type</strong> class. <strong class="source-inline">type</strong> is the class of all data types in Python as well and everything else in Python 3 is an object of the <strong class="source-inline">type</strong> class. We can test this statement by checking the type of different program objects in Python, as follows:</p>
<pre class="source-code">class TestForType:  </pre>
<pre class="source-code">    pass  </pre>
<pre class="source-code">type(TestForType)</pre>
<pre class="source-code"><strong class="bold">type</strong></pre>
<pre class="source-code">type(int)</pre>
<pre class="source-code"><strong class="bold">type</strong></pre>
<pre class="source-code">type(str)</pre>
<pre class="source-code"><strong class="bold">type</strong></pre>
<pre class="source-code">type(object)</pre>
<pre class="source-code"><strong class="bold">type</strong></pre>
<pre class="source-code">type(float)</pre>
<pre class="source-code"><strong class="bold">type</strong></pre>
<pre class="source-code">type(list)</pre>
<pre class="source-code"><strong class="bold">type</strong></pre>
<p>In this chapter, we will look at some examples of how to use these metaclasses, how to implement them, and how to reuse them. We will continue with our <em class="italic">ABC Megamart</em> examples to proceed further with the understanding of metaclasses.</p>
<h1 id="_idParaDest-57"><a id="_idTextAnchor059"/>The structure of a metaclass</h1>
<p>A metaclass is<a id="_idIndexMarker168"/> like any other class, but it has the ability to alter the behavior of other classes that take it as their metaclass. Understanding the structure of a metaclass helps us create our own customized metaclasses, which can be used further in manipulating new classes. The superclass of a metaclass is the type itself. When we create a class with <strong class="source-inline">type</strong> as its superclass and override the <strong class="source-inline">__new__</strong> method to manipulate the metadata of a class it returns, then we have created a metaclass. Let’s take a closer look with the help of some simple examples. </p>
<p>The <strong class="source-inline">__new__</strong> method takes <strong class="source-inline">cls</strong> as its first argument, which is the class itself. The members of the class that has <strong class="source-inline">cls</strong> as its first argument can be accessed by the class name and the rest of the arguments as other metadata of the class, as seen here:</p>
<pre class="source-code">class ExampleMetaClass1(type):  </pre>
<pre class="source-code">    def __new__(classitself, *args):  </pre>
<pre class="source-code">        print('class itself: ', classitself)  </pre>
<pre class="source-code">        print('Others: ', args)  </pre>
<pre class="source-code">        return type.__new__(classitself, *args)  </pre>
<p>In the preceding code, we have created the class <strong class="source-inline">ExampleMetaClass1</strong>, which inherits the class <strong class="source-inline">type</strong> and overrides the <strong class="source-inline">__new__</strong> method to print the class instance and its other arguments. </p>
<p>Let’s now create the class <strong class="source-inline">ExampleClass1</strong> and add the preceding metaclass to it:</p>
<pre class="source-code">class ExampleClass1(metaclass = ExampleMetaClass1):      </pre>
<pre class="source-code">    int1 = 123  </pre>
<pre class="source-code">    str1 = 'test'  </pre>
<pre class="source-code">      </pre>
<pre class="source-code">    def test():  </pre>
<pre class="source-code">        print('test')  </pre>
<p>Running the preceding code displays the following result:</p>
<pre class="source-code"><strong class="bold">class itself:  &lt;class '__main__.ExampleMetaClass1'&gt;</strong></pre>
<pre class="source-code"><strong class="bold">Others:  ('ExampleClass1', (), {'__module__': '__main__', '__qualname__': 'ExampleClass1', 'int1': 123, 'str1': 'test', 'test': &lt;function ExampleClass1.test at 0x00000194A377E1F0&gt;})</strong></pre>
<p>The first part <a id="_idIndexMarker169"/>of this output is the class instance <strong class="source-inline">&lt;class '__main__.ExampleMetaClass1'&gt;</strong> and the remaining arguments are the class name and the arguments of the class. A simple representation of the metaclass definition is as follows:</p>
<div>
<div class="IMG---Figure" id="_idContainer053">
<img alt="Figure 4.1 – Example metaclass definition " height="241" src="image/B13426_04_01.jpg" width="549"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.1 – Example metaclass definition</p>
<p>Let’s dive into a little more detail with another example in our next subsection.</p>
<h2 id="_idParaDest-58"><a id="_idTextAnchor060"/>Analyzing the arguments</h2>
<p>We now will <a id="_idIndexMarker170"/>dig deeper into the arguments of the <strong class="source-inline">__new__</strong> method of a metaclass. Analyzing the arguments of a metaclass will provide clarity on what information of a class can be customized using a metaclass. The data that can be manipulated in the classes that adds a metaclass while defining is represented in the following figure:</p>
<div>
<div class="IMG---Figure" id="_idContainer054">
<img alt="Figure 4.2 – Example metaclass with more arguments " height="557" src="image/B13426_04_02.jpg" width="845"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.2 – Example metaclass with more arguments</p>
<p>Let’s now follow<a id="_idIndexMarker171"/> these steps to see how the behavior of arguments affects classes:</p>
<ol>
<li>First, look at the following code where we have all arguments of a metaclass segregated—class instance; class name; all parent classes, superclasses, or base classes of the class; and all variables and methods created within the class:<p class="source-code">class ExampleMetaClass2(type):  </p><p class="source-code">    def __new__(classitself, classname, baseclasses, </p><p class="source-code">                attributes):  </p><p class="source-code">        print('class itself: ', classitself)  </p><p class="source-code">        print('class name: ', classname)  </p><p class="source-code">        print('parent class list: ', baseclasses)  </p><p class="source-code">        print('attribute list: ', attributes)  </p><p class="source-code">        return type.__new__(classitself, classname, </p><p class="source-code">            baseclasses, attributes)  </p></li>
<li>Next, we<a id="_idIndexMarker172"/> will be creating two parent classes—<strong class="source-inline">ExampleParentClass1</strong> and <strong class="source-inline">ExampleParentClass2</strong>:<p class="source-code">class ExampleParentClass1():      </p><p class="source-code">       def test1():  </p><p class="source-code">            print('parent1 - test1')  </p><p class="source-code">class ExampleParentClass2():      </p><p class="source-code">       def test2():  </p><p class="source-code">            print('parent2 - test2')  </p></li>
<li>Now, we will create the class <strong class="source-inline">ExampleClass2</strong> where we will be inheriting both of the preceding parent classes and adding the metaclass as <strong class="source-inline">ExampleMetaClass2</strong>:<p class="source-code">class ExampleClass2(ExampleParentClass1,ExampleParentClass2, metaclass = ExampleMetaClass2):      </p><p class="source-code">    int1 = 123  </p><p class="source-code">    str1 = 'test'  </p><p class="source-code">      </p><p class="source-code">    def test3():  </p><p class="source-code">        print('child1 - test3')  </p></li>
<li>Executing the preceding code results in the following output:<p class="source-code">class itself:  <strong class="bold">&lt;class '__main__.ExampleMetaClass2'&gt;</strong></p><p class="source-code">class name:  <strong class="bold">ExampleClass2</strong></p><p class="source-code">parent class:  <strong class="bold">(&lt;class '__main__.ExampleParentClass1'&gt;, &lt;class '__main__.ExampleParentClass2'&gt;)</strong></p><p class="source-code">attributes:  <strong class="bold">{'__module__': '__main__', '__qualname__': 'ExampleClass2', 'int1': 123, 'str1': 'test', 'test3': &lt;function ExampleClass2.test3 at 0x00000194A3994E50&gt;}</strong></p></li>
</ol>
<p>This example shows us the highlighted arguments that are returned by the metaclass and gives an overview of which values can possibly be manipulated from a class using metaprogramming.</p>
<ol>
<li value="5">Let us look <a id="_idIndexMarker173"/>at the type of each of the classes created in this example:<p class="source-code">type(ExampleParentClass1)</p><p class="source-code"><strong class="bold">type</strong></p><p class="source-code">type(ExampleParentClass2)</p><p class="source-code"><strong class="bold">type</strong></p><p class="source-code">type(ExampleMetaClass2)</p><p class="source-code"><strong class="bold">type</strong></p><p class="source-code">type(ExampleClass2)</p><p class="source-code">__main__.ExampleMetaClass2</p></li>
</ol>
<p>As we can see, the <a id="_idIndexMarker174"/>type of all other classes is the type itself whereas the type of <strong class="source-inline">ExampleClass2</strong> is <strong class="source-inline">ExampleMetaClass2</strong>.</p>
<p>Now that you understand the structure of a metaclass, we can look further into applications of metaclasses on our <em class="italic">ABC Megamart</em> example.</p>
<h1 id="_idParaDest-59"><a id="_idTextAnchor061"/>The application of metaclasses</h1>
<p>In this section, we will look<a id="_idIndexMarker175"/> at an example where we will create a metaclass that can automatically modify the user-defined method attributes of any branch class that is newly created. To test this, let us follow these steps:</p>
<ol>
<li value="1">Create a metaclass with the name <strong class="source-inline">BranchMetaclass</strong>:<p class="source-code">class BranchMetaclass(type):  </p></li>
<li>Create a <strong class="source-inline">__new__</strong> method with class instance, class name, base classes, and attributes as its arguments. In the <strong class="source-inline">__new__</strong> method, import the <strong class="source-inline">inspect</strong> library, which can help inspect the input attributes:<p class="source-code">    def __new__(classitself, classname, baseclasses, </p><p class="source-code">         attributes):  </p><p class="source-code">        import inspect  </p></li>
<li>Create a new dictionary, <strong class="source-inline">newattributes</strong>:<p class="source-code">     newattributes = {}  </p></li>
</ol>
<p>Iterate over the class attributes, check that the attributes start with <strong class="source-inline">__</strong>, and don’t change the value. </p>
<ol>
<li value="4">Continue<a id="_idIndexMarker176"/> iterating over the other attributes and check if the attributes are functions. If they are functions, prefix <strong class="source-inline">branch</strong> to the class method and convert the method name into title case:<p class="source-code">for attribute, value in attributes.items():  </p><p class="source-code">            if attribute.startswith("__"):  </p><p class="source-code">                newattributes[attribute] = value  </p><p class="source-code">            elif inspect.isfunction(value):  </p><p class="source-code">                newattributes['branch' +</p><p class="source-code">                    attribute.title()] = value for a</p><p class="source-code">                    attribute, value in </p><p class="source-code">                    attributes.items():</p><p class="source-code">            if attribute.startswith("__"):  </p><p class="source-code">                newattributes[attribute] = value  </p><p class="source-code">            elif inspect.isfunction(value):  </p><p class="source-code">                newattributes['branch' + </p><p class="source-code">                    attribute.title()] = value  </p></li>
<li>If the preceding conditions are not met, save the value of the attribute as it is:<p class="source-code">else:  </p><p class="source-code">                newattributes[attribute] = value  </p></li>
<li>Return the <strong class="source-inline">new</strong> method with new attributes:<p class="source-code">                     return type.__new__(classitself, </p><p class="source-code">                         classname, baseclasses, </p><p class="source-code">                         newattributes) </p></li>
<li>Within <a id="_idIndexMarker177"/>the metaclass, also create a regular user-defined method, <strong class="source-inline">buy_product</strong>, to calculate the sales price of a product:<p class="source-code">def buy_product(product,unit_price,quantity,statetax_rate,promotiontype):  </p><p class="source-code">        statetax_rate = statetax_rate          </p><p class="source-code">        initialprice = unit_price*quantity   </p><p class="source-code">        sales_price = initialprice + </p><p class="source-code">            initialprice*statetax_rate  </p><p class="source-code">        return sales_price, product,promotiontype  </p></li>
<li>Next, we will create another new class, <strong class="source-inline">Brooklyn</strong>, and add this metaclass to the class. By adding the metaclass, we want the methods in the class <strong class="source-inline">Brooklyn</strong> to have a prefix branch and change the methods to title case while creating the methods of <strong class="source-inline">Brooklyn</strong>. </li>
</ol>
<p>The <strong class="source-inline">Brooklyn</strong> class has four variables, <strong class="source-inline">product_id</strong>, <strong class="source-inline">product_name</strong>, <strong class="source-inline">product_category</strong>, and <strong class="source-inline">unit_price</strong>. We will also create a method to calculate the maintenance cost and this method should be converted from <strong class="source-inline">maintenance_cost</strong> to <strong class="source-inline">branchMaintenance_cost</strong> due to the metaclass that alters the behavior of the newly created class. Here’s the new class:</p>
<p class="source-code">class Brooklyn(metaclass = BranchMetaclass):  </p>
<p class="source-code">    product_id = 100902  </p>
<p class="source-code">    product_name = 'Iphone X'  </p>
<p class="source-code">    product_category = 'Electronics'  </p>
<p class="source-code">    unit_price = 700  </p>
<p class="source-code">      </p>
<p class="source-code">    def maintenance_cost(self,product_type, quantity):</p>
<p class="source-code">        self.product_type = product_type  </p>
<p class="source-code">        self.quantity = quantity  </p>
<p class="source-code">        cold_storage_cost = 100  </p>
<p class="source-code">        if (product_type == 'Electronics'):  </p>
<p class="source-code">            maintenance_cost = self.quantity * 0.25 + </p>
<p class="source-code">                cold_storage_cost      </p>
<p class="source-code">            return maintenance_cost  </p>
<p class="source-code">        else:  </p>
<p class="source-code">            return "We don't stock this product"  </p>
<ol>
<li value="9">We can<a id="_idIndexMarker178"/> list all the arguments of the class <strong class="source-inline">Brooklyn</strong> and check if the metaclass has altered its behavior:<p class="source-code">dir(Brooklyn)</p><p class="source-code">['__class__',</p><p class="source-code"> '__delattr__',</p><p class="source-code"> '__dict__',</p><p class="source-code"> ‚__dir__',</p><p class="source-code"> ‚__doc__',</p><p class="source-code"> ‚__eq__',</p><p class="source-code"> ‚__format__',</p><p class="source-code"> ‚__ge__',</p><p class="source-code"> ‚__getattribute__',</p><p class="source-code"> ‚__gt__',</p><p class="source-code"> ‚__hash__',</p><p class="source-code"> ‚__init__',</p><p class="source-code"> ‚__init_subclass__',</p><p class="source-code"> ‚__le__',</p><p class="source-code"> ‚__lt__',</p><p class="source-code"> ‚__module__',</p><p class="source-code"> ‚__ne__',</p><p class="source-code"> ‚__new__',</p><p class="source-code"> ‚__reduce__',</p><p class="source-code"> ‚__reduce_ex__',</p><p class="source-code"> ‚__repr__',</p><p class="source-code"> ‚__setattr__',</p><p class="source-code"> ‚__sizeof__',</p><p class="source-code"> ‚__str__',</p><p class="source-code"> ‚__subclasshook__',</p><p class="source-code"> ‚__weakref__',</p><p class="source-code"> <strong class="bold">'branchMaintenance_cost'</strong>,</p><p class="source-code"> 'product_category',</p><p class="source-code"> 'product_id',</p><p class="source-code"> 'product_name',</p><p class="source-code"> 'unit_price']</p></li>
<li>Let us now <a id="_idIndexMarker179"/>create an object and look at its methods and variables, as follows:<p class="source-code">brooklyn = Brooklyn()</p><p class="source-code">brooklyn.branchMaintenance_Cost('Electronics',10)</p><p class="source-code"><strong class="bold">102.5</strong></p><p class="source-code">brooklyn.product_id</p><p class="source-code"><strong class="bold">100902</strong></p><p class="source-code">brooklyn.product_name</p><p class="source-code"><strong class="bold">'Iphone X'</strong></p><p class="source-code">brooklyn.product_type</p><p class="source-code"><strong class="bold">'Electronics'</strong></p></li>
</ol>
<p>A simple <a id="_idIndexMarker180"/>representation of this example is as follows:</p>
<div>
<div class="IMG---Figure" id="_idContainer055">
<img alt="Figure 4.3 – Application of metaclass on ABC Megamart – Branch example " height="542" src="image/B13426_04_03.jpg" width="894"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.3 – Application of metaclass on ABC Megamart – Branch example</p>
<p>So far, we’ve looked at an overview of a metaclass, understood its structure, performed an analysis of its arguments, and applied our understanding by creating a custom metaclass on our core example. We will look at a few more applications in the following section.</p>
<h2 id="_idParaDest-60"><a id="_idTextAnchor062"/>Inheriting the metaclass</h2>
<p>In this section, we will<a id="_idIndexMarker181"/> walk through an example where we will inherit the metaclass to check whether it can be inherited as a regular parent class without altering the behavior of the new class that is being created. Take a look at the following code:</p>
<pre class="source-code">class Queens(BranchMetaclass):  </pre>
<pre class="source-code">    def maintenance_cost(product_type, quantity):  </pre>
<pre class="source-code">        product_type = product_type  </pre>
<pre class="source-code">        quantity = quantity  </pre>
<pre class="source-code">        if (product_type == ‹FMCG›):  </pre>
<pre class="source-code">            maintenance_cost = quantity * 0.05  </pre>
<pre class="source-code">            return maintenance_cost  </pre>
<pre class="source-code">        else:  </pre>
<pre class="source-code">            return "We don't stock this product"  </pre>
<p>Let's now create an object for the preceding class to check if an object can be created:</p>
<pre class="source-code">queens = Queens()</pre>
<p>We get the following <strong class="source-inline">TypeError</strong>:</p>
<div>
<div class="IMG---Figure" id="_idContainer056">
<img alt="Figure 4.4 – Error while creating an object for the class inheriting a metaclass " height="157" src="image/B13426_04_04.jpg" width="995"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.4 – Error while creating an object for the class inheriting a metaclass</p>
<p>This error occurred as <strong class="source-inline">__new__</strong> is a static method that is called to create a new instance for the class and it expects three arguments of the class, which are not provided while creating the class object. However, there is another way of calling the newly created class, <strong class="source-inline">Queens</strong>. The class can be called directly, and its methods can be used without having to create an object:</p>
<pre class="source-code">Queens.maintenance_cost('FMCG',120)</pre>
<pre class="source-code"><strong class="bold">6.0</strong></pre>
<p>The <strong class="source-inline">maintenance_cost</strong> method did not get modified into <strong class="source-inline">branchMaintenance_cost</strong> since the metaclass is not used as a metaclass but as a parent class. Since the <a id="_idIndexMarker182"/>metaclass is inherited, <strong class="source-inline">Queens</strong> also inherits the user-defined methods of <strong class="source-inline">BranchMetaclass</strong> as follows:</p>
<pre class="source-code">Queens.buy_product('Iphone',1000,1,0.04,None)</pre>
<pre class="source-code"><strong class="bold">(1040.0, 'Iphone', None)</strong></pre>
<h2 id="_idParaDest-61"><a id="_idTextAnchor063"/>Inheriting as a parent and metaclass</h2>
<p>Let’s now look<a id="_idIndexMarker183"/> at what happens when we inherit a class as a parent and also add it as a metaclass while creating a new class:</p>
<pre class="source-code">class Queens(BranchMetaclass, metaclass = BranchMetaclass):  </pre>
<pre class="source-code">    def maintenance_cost(product_type, quantity):  </pre>
<pre class="source-code">        product_type = product_type  </pre>
<pre class="source-code">        quantity = quantity  </pre>
<pre class="source-code">        if (product_type == ‹FMCG›):  </pre>
<pre class="source-code">            maintenance_cost = quantity * 0.05  </pre>
<pre class="source-code">            return maintenance_cost  </pre>
<pre class="source-code">        else:  </pre>
<pre class="source-code">            return "We don't stock this product"  </pre>
<p>In the preceding code, we have added <strong class="source-inline">BranchMetaclass</strong> as the parent class for the class <strong class="source-inline">Queens</strong> and we have also added it as a metaclass. This definition should make the class <strong class="source-inline">Queens</strong> inherit the custom methods from <strong class="source-inline">BranchMetaclass</strong> and also change the <strong class="source-inline">maintenance_cost</strong> method into <strong class="source-inline">branchMaintenance_cost</strong>. Let’s see if it does:</p>
<pre class="source-code">Queens.branchMaintenance_Cost('FMCG',2340)</pre>
<pre class="source-code"><strong class="bold">117.0</strong></pre>
<p>In the<a id="_idIndexMarker184"/> preceding code execution and output, the <strong class="source-inline">maintenance_cost</strong> method is converted into the <strong class="source-inline">branchMaintenance_cost</strong> method as expected. Now run the following command:</p>
<pre class="source-code">Queens.buy_product('Iphone',1500,1,0.043,None)</pre>
<pre class="source-code"><strong class="bold">(1564.5, 'Iphone', None)</strong></pre>
<p>The <strong class="source-inline">buy_product</strong> method, which is a custom method from <strong class="source-inline">BranchMetaclass</strong>, is also inherited since it is a parent class. </p>
<p>Here is a simple representation of this example:</p>
<div>
<div class="IMG---Figure" id="_idContainer057">
<img alt="Figure 4.5 – Application of metaclass and also inheriting it on ABC Megamart branch example " height="605" src="image/B13426_04_05.jpg" width="923"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.5 – Application of metaclass and also inheriting it on ABC Megamart branch example</p>
<p>Let us look further into examples of switching metaclasses from one class to another. </p>
<h1 id="_idParaDest-62"><a id="_idTextAnchor064"/>Switching metaclasses</h1>
<p>We can now look into<a id="_idIndexMarker185"/> the concept of switching metaclasses for a class. You may think, <em class="italic">why do we need to switch metaclasses?</em> Switching metaclasses reinforces the reusability concept of metaprogramming and in this case, it helps in understanding how a metaclass created for use on one class can also be used for a different class without impacting the class definition. </p>
<p>In the example for this section, we will be creating two meta classes – <strong class="source-inline">IncomeStatementMetaClass</strong> and <strong class="source-inline">BalanceSheetMetaClass</strong>. For the Malibu branch of <em class="italic">ABC Megamart</em>, we will create a class to capture the information required for its financial statements. The two financial statements relevant for this example are Income Statement attributes and Balance Sheet attributes for the Malibu branch. To differentiate where a particular attribute or method of a class should go, we will be creating two metaclasses that look at the names of the attributes and tag them under Income Statement or Balance Sheet accordingly.</p>
<p>The following is <a id="_idIndexMarker186"/>a simple representation of the attributes that will be manipulated by the aforementioned metaclasses:</p>
<div>
<div class="IMG---Figure" id="_idContainer058">
<img alt="Figure 4.6 – Finance attributes used in this metaclass example " height="285" src="image/B13426_04_06.jpg" width="513"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.6 – Finance attributes used in this metaclass example</p>
<p>Take a look at the following code snippet:</p>
<pre class="source-code">class IncomeStatementMetaClass(type):  </pre>
<pre class="source-code">    def __new__(classitself, classname, baseclasses, </pre>
<pre class="source-code">                attributes):  </pre>
<pre class="source-code">          </pre>
<pre class="source-code">        newattributes = {}  </pre>
<pre class="source-code">        for attribute, value in attributes.items():  </pre>
<pre class="source-code">            if attribute.startswith("__"):  </pre>
<pre class="source-code">                newattributes[attribute] = value  </pre>
<pre class="source-code">            elif («revenue» in attribute) or \  </pre>
<pre class="source-code">            ("expense" in attribute) or \  </pre>
<pre class="source-code">            ("profit" in attribute) or \  </pre>
<pre class="source-code">            ("loss" in attribute):  </pre>
<pre class="source-code">                newattributes['IncomeStatement_' + </pre>
<pre class="source-code">                    attribute.title()] = value  </pre>
<pre class="source-code">            else:  </pre>
<pre class="source-code">                newattributes[attribute] = value  </pre>
<pre class="source-code">        return type.__new__(classitself, classname, </pre>
<pre class="source-code">            baseclasses, newattributes)  </pre>
<p>Here, the <strong class="source-inline">new</strong> method is modified to check for attributes that have the key as one of the parameters<a id="_idIndexMarker187"/> that belong to an income statement such as <strong class="source-inline">revenue</strong>, <strong class="source-inline">expense</strong>, <strong class="source-inline">profit</strong>, or <strong class="source-inline">loss</strong>. If any of this terminology occurs in the method name or variable name, we will add a prefix of <strong class="source-inline">IncomeStatement</strong> to segregate those methods and variables.</p>
<p>To test this metaclass, we will be creating a new class, <strong class="source-inline">Malibu</strong>, with four variables and four methods, as follows:</p>
<pre class="source-code">class Malibu(metaclass = IncomeStatementMetaClass):  </pre>
<pre class="source-code">    profit = 4354365  </pre>
<pre class="source-code">    loss = 43000  </pre>
<pre class="source-code">    assets = 15000  </pre>
<pre class="source-code">    liabilities = 4000  </pre>
<pre class="source-code">    def calc_revenue(quantity,unitsales_price):  </pre>
<pre class="source-code">        totalrevenue = quantity * unitsales_price   </pre>
<pre class="source-code">        return totalrevenue  </pre>
<pre class="source-code">      </pre>
<pre class="source-code">    def calc_expense(totalrevenue,netincome, netloss):  </pre>
<pre class="source-code">        totalexpense = totalrevenue - (netincome + netloss)  </pre>
<pre class="source-code">        return totalexpense    </pre>
<pre class="source-code">      </pre>
<pre class="source-code">    def calc_totalassets(cash,inventory,accountsreceivable):</pre>
<pre class="source-code">        totalassets = cash + inventory + accountsreceivable  </pre>
<pre class="source-code">        return totalassets  </pre>
<pre class="source-code">      </pre>
<pre class="source-code">    def calc_totalliabilities(debt,accruedexpense,</pre>
<pre class="source-code">         accountspayable):  </pre>
<pre class="source-code">        totalliabilities = debt + accruedexpense + </pre>
<pre class="source-code">            accountspayable  </pre>
<pre class="source-code">        return totalliabilities  </pre>
<p>In the<a id="_idIndexMarker188"/> preceding code, we have added the metaclass <strong class="source-inline">IncomeStatementMetaClass</strong> and we see that the attributes of the class <strong class="source-inline">Malibu</strong> modify the behavior of variables and methods as follows:</p>
<div>
<div class="IMG---Figure" id="_idContainer059">
<img alt="Figure 4.7 – Malibu without metaclass (left) and Malibu with metaclass (right) " height="245" src="image/B13426_04_07.jpg" width="668"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.7 – Malibu without metaclass (left) and Malibu with metaclass (right)</p>
<p>We will further add another metaclass, <strong class="source-inline">BalanceSheetMetaClass</strong>, to deal with the balance sheet-related attributes in the class <strong class="source-inline">Malibu</strong>. In the following metaclass, the new method is modified to check for attributes that have the key as one of the parameters that belong to a balance sheet such as <strong class="source-inline">assets</strong>, <strong class="source-inline">liabilities</strong>, <strong class="source-inline">goodwill</strong>, and<a id="_idIndexMarker189"/> cash. If any of these terms occur in the method name or variable name, we will add a prefix of <strong class="source-inline">BalanceSheet</strong> to segregate those methods and variables:</p>
<pre class="source-code">class BalanceSheetMetaClass(type):  </pre>
<pre class="source-code">    def __new__(classitself, classname, baseclasses, </pre>
<pre class="source-code">                attributes):  </pre>
<pre class="source-code">        newattributes = {}  </pre>
<pre class="source-code">        for attribute, value in attributes.items():  </pre>
<pre class="source-code">            if attribute.startswith("__"):  </pre>
<pre class="source-code">                newattributes[attribute] = value  </pre>
<pre class="source-code">            elif («assets» in attribute) or \  </pre>
<pre class="source-code">            ("liabilities" in attribute) or \  </pre>
<pre class="source-code">            ("goodwill" in attribute) or \  </pre>
<pre class="source-code">            ("cash" in attribute):  </pre>
<pre class="source-code">                newattributes['BalanceSheet_' + </pre>
<pre class="source-code">                    attribute.title()] = value  </pre>
<pre class="source-code">            else:  </pre>
<pre class="source-code">                newattributes[attribute] = value  </pre>
<pre class="source-code">        return type.__new__(classitself, classname, </pre>
<pre class="source-code">            baseclasses, newattributes)  </pre>
<p>In the preceding <a id="_idIndexMarker190"/>code, we have added the metaclass <strong class="source-inline">BalanceSheetMetaClass</strong> and we see that the attributes of the class <strong class="source-inline">Malibu</strong> modify the behavior of variables and methods as follows:</p>
<div>
<div class="IMG---Figure" id="_idContainer060">
<img alt="Figure 4.8 – Malibu with IncomeStatementMetaClass (left) and Malibu with BalanceSheetMetaClass (right) " height="234" src="image/B13426_04_08.jpg" width="810"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.8 – Malibu with IncomeStatementMetaClass (left) and Malibu with BalanceSheetMetaClass (right)</p>
<p>Now that you know <a id="_idIndexMarker191"/>why we need to switch metaclasses, let us look at the application of metaclasses in inheritance.</p>
<h1 id="_idParaDest-63"><a id="_idTextAnchor065"/>Inheritance in metaclasses</h1>
<p><strong class="bold">Inheritance</strong>, in a literal<a id="_idIndexMarker192"/> sense, means a child acquiring the properties of a parent<a id="_idIndexMarker193"/> and it means the same in the case of object-oriented programming too. A new class can inherit the attributes and methods of a parent class and it can also have its own properties and methods.</p>
<p>In this example, we will look at how inheritance works on metaclasses by creating two classes, <strong class="source-inline">California</strong> and <strong class="source-inline">Pasadena</strong> – <strong class="source-inline">California</strong> being the parent class and <strong class="source-inline">Pasadena</strong> the child class. </p>
<p>Let’s check these steps out to understand inheritance better:</p>
<ol>
<li value="1">In the previous section, we already created two metaclasses that inherited type as their parent class – <strong class="source-inline">IncomeStatementMetaClass</strong> and <strong class="source-inline">BalanceSheetMetaClass</strong>. We will start by creating the class <strong class="source-inline">California</strong> with the <strong class="source-inline">IncomeStatement</strong> metaclass:<p class="source-code">class California(metaclass = IncomeStatementMetaClass):  </p><p class="source-code">    profit = 4354365  </p><p class="source-code">    loss = 43000  </p><p class="source-code">    def calc_revenue(quantity,unitsales_price):  </p><p class="source-code">        totalrevenue = quantity * unitsaleprice   </p><p class="source-code">        return totalrevenue  </p><p class="source-code">      </p><p class="source-code">    def calc_expense(totalrevenue,netincome, netloss):  </p><p class="source-code">        totalexpense = totalrevenue - (netincome + netloss)  </p><p class="source-code">        return totalexpense   </p></li>
</ol>
<p>Here, we have<a id="_idIndexMarker194"/> defined only those attributes that can be modified <a id="_idIndexMarker195"/>by the <strong class="source-inline">IncomeStatement</strong> metaclass. </p>
<ol>
<li value="2">Next, we will create another class, <strong class="source-inline">Pasadena</strong>, with the <strong class="source-inline">BalanceSheet</strong> metaclass:<p class="source-code">class Pasadena(California,metaclass = BalanceSheetMetaClass):  </p><p class="source-code">    assets = 18000  </p><p class="source-code">    liabilities = 5000  </p><p class="source-code">    def calc_totalassets(cash,inventory,</p><p class="source-code">        accountsreceivable):  </p><p class="source-code">        totalassets = cash + inventory + </p><p class="source-code">            accountsreceivable  </p><p class="source-code">        return totalassets  </p><p class="source-code">      </p><p class="source-code">    def calc_totalliabilities(debt,accruedexpense,</p><p class="source-code">        accountspayable):  </p><p class="source-code">        totalliabilities = debt + accruedexpense + </p><p class="source-code">            accountspayable  </p><p class="source-code">        return totalliabilities  </p></li>
</ol>
<p>We have defined here only those attributes that can be modified by the <strong class="source-inline">BalanceSheet</strong> metaclass. </p>
<ol>
<li value="3">Executing the<a id="_idIndexMarker196"/> code of the <strong class="source-inline">Pasadena</strong> class results in the following<a id="_idIndexMarker197"/> error:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer061">
<img alt="Figure 4.9 – Error while executing a child class that has a different metaclass " height="256" src="image/B13426_04_09.jpg" width="994"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.9 – Error while executing a child class that has a different metaclass</p>
<p>This error was thrown since <strong class="source-inline">Pasadena</strong> inherited the parent class <strong class="source-inline">California</strong>, which has a different metaclass, <strong class="source-inline">IncomeStatementMetaClass</strong>, which is inherited from type, and Pasadena’s metaclass <strong class="source-inline">BalanceSheetMetaClass</strong> is also inherited from type.</p>
<ol>
<li value="4">To resolve <a id="_idIndexMarker198"/>this <a id="_idIndexMarker199"/>error, we can redefine the <strong class="source-inline">BalanceSheetMetaClass</strong> with the parent class as <strong class="source-inline">IncomeStatementMetaClass</strong> instead of the type class, as follows:<p class="source-code">class BalanceSheetMetaClass(IncomeStatementMetaClass):  </p><p class="source-code">    def __new__(classitself, classname, baseclasses, </p><p class="source-code">                attributes):  </p><p class="source-code">        newattributes = {}  </p><p class="source-code">        for attribute, value in attributes.items():  </p><p class="source-code">            if attribute.startswith("__"):  </p><p class="source-code">                newattributes[attribute] = value  </p><p class="source-code">            elif («assets» in attribute) or \  </p><p class="source-code">            ("liabilities" in attribute) or \  </p><p class="source-code">            ("goodwill" in attribute) or \  </p><p class="source-code">            ("cash" in attribute):  </p><p class="source-code">                newattributes['BalanceSheet_' + </p><p class="source-code">                    attribute.title()] = value  </p><p class="source-code">            else:  </p><p class="source-code">                newattributes[attribute] = value  </p><p class="source-code">        return type.__new__(classitself, classname, </p><p class="source-code">            baseclasses, newattributes)  </p></li>
<li>Let’s now <a id="_idIndexMarker200"/>rerun the <strong class="source-inline">California</strong> parent class and also the <strong class="source-inline">Pasadena</strong> child <a id="_idIndexMarker201"/>class to check if the behavior modification of both the metaclasses is implemented in the <strong class="source-inline">Pasadena</strong> class:<p class="source-code">class California(metaclass = IncomeStatementMetaClass):  </p><p class="source-code">    profit = 4354365  </p><p class="source-code">    loss = 43000  </p><p class="source-code">    def calc_revenue(quantity,unitsales_price):  </p><p class="source-code">        totalrevenue = quantity * unitsaleprice   </p><p class="source-code">        return totalrevenue  </p><p class="source-code">    def calc_expense(totalrevenue,netincome, netloss):  </p><p class="source-code">        totalexpense = totalrevenue - (netincome + </p><p class="source-code">            netloss)  </p><p class="source-code">        return totalexpense    </p><p class="source-code">class Pasadena(California,metaclass = BalanceSheetMetaClass):  </p><p class="source-code">    assets = 18000  </p><p class="source-code">    liabilities = 5000  </p><p class="source-code">    def calc_totalassets(cash,inventory,</p><p class="source-code">        accountsreceivable):  </p><p class="source-code">        totalassets = cash + inventory + </p><p class="source-code">            accountsreceivable  </p><p class="source-code">        return totalassets  </p><p class="source-code">    def calc_totalliabilities(debt,accruedexpense,</p><p class="source-code">        accountspayable):  </p><p class="source-code">        totalliabilities = debt + accruedexpense + </p><p class="source-code">            accountspayable  </p><p class="source-code">        return totalliabilities  </p></li>
<li>Here is the<a id="_idIndexMarker202"/> output from the <strong class="source-inline">Pasadena</strong> class, and as we can see, both<a id="_idIndexMarker203"/> the <strong class="source-inline">BalanceSheet</strong> and <strong class="source-inline">IncomeStatement</strong> attributes are modified as per their metaclasses:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer062">
<img alt="Figure 4.10 – Pasadena class with inheritance" height="243" src="image/B13426_04_10.jpg" width="439"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.10 – Pasadena class with inheritance</p>
<p>A simple representation of this application is as follows:</p>
<div>
<div class="IMG---Figure" id="_idContainer063">
<img alt="Figure 4.11 – Inheritance in metaclasses " height="469" src="image/B13426_04_11.jpg" width="887"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.11 – Inheritance in metaclasses</p>
<p>In this case, we have<a id="_idIndexMarker204"/> redefined the parent class of <strong class="source-inline">BalanceSheetMetaClass</strong> to be <strong class="source-inline">IncomeStatementMetaClass</strong> since Python does not automatically resolve <a id="_idIndexMarker205"/>their parent classes while they were both inherited by type and instead throws a metaclass conflict. Redefining the parent class of <strong class="source-inline">BalanceSheetMetaClass</strong> not only resolves the error but will also not impact the overall functionality of the class since <strong class="source-inline">IncomeStatementMetaClass</strong> is in turn inherited from type.</p>
<p>Let us look at another example where we will be adding additional information to class attributes.</p>
<h1 id="_idParaDest-64"><a id="_idTextAnchor066"/>Manipulating class variables</h1>
<p>In this section, we <a id="_idIndexMarker206"/>will take an example to look at manipulating class variables further using metaclasses. We will be creating a metaclass named <strong class="source-inline">SchemaMetaClass</strong> and will define the <strong class="source-inline">__new__</strong> method to manipulate attributes of a class if they are variables of data types that belong to <strong class="source-inline">integer</strong>, <strong class="source-inline">float</strong>, <strong class="source-inline">string</strong>, or <strong class="source-inline">boolean</strong>. Let’s go through the steps real quick:</p>
<ol>
<li value="1">We will now create the <strong class="source-inline">SchemaMetaClass</strong> with the parent class as type and have modified the <strong class="source-inline">new</strong> method to check the following conditions:<p class="source-code">class SchemaMetaClass(type):  </p></li>
<li>Create the dictionary object <strong class="source-inline">newattributes</strong>. If the <strong class="source-inline">class</strong> attribute is a built-in <strong class="source-inline">class</strong> method that starts with <strong class="source-inline">__</strong>, then the attribute’s value is stored as such in <strong class="source-inline">newattributes</strong>:<p class="source-code">    def __new__(classitself, classname, baseclasses, </p><p class="source-code">                attributes):  </p><p class="source-code">        </p><p class="source-code">        newattributes = {}  </p><p class="source-code">        for attribute, value in attributes.items():  </p><p class="source-code">            if attribute.startswith("__"):  </p><p class="source-code">                newattributes[attribute] = value </p></li>
<li>If the <strong class="source-inline">class</strong> attribute is an integer or float variable, then the class returns a dictionary item with the attribute name as <strong class="source-inline">ColumnName</strong>, the value as <strong class="source-inline">Value</strong>, <strong class="source-inline">Type</strong> as <strong class="source-inline">NUMERIC</strong>, and <strong class="source-inline">Length</strong> as the length of the value:<p class="source-code">            elif type(value)==int or type(value)==float:  </p><p class="source-code">                newattributes[attribute] = {}  </p><p class="source-code">                newattributes[attribute]['ColumnName']</p><p class="source-code">                     = attribute.title()  </p><p class="source-code">                newattributes[attribute]['Value'] </p><p class="source-code">                     = value  </p><p class="source-code">                newattributes[attribute]['Type'] </p><p class="source-code">                     = 'NUMERIC'  </p><p class="source-code">                newattributes[attribute]['Length'] = len(str(value))  </p></li>
<li>If the <strong class="source-inline">class</strong> attribute<a id="_idIndexMarker207"/> is a string variable, then the class returns a similar dictionary item with <strong class="source-inline">Type</strong> as <strong class="source-inline">VARCHAR</strong>:<p class="source-code">            elif type(value)==str:  </p><p class="source-code">                newattributes[attribute] = {}  </p><p class="source-code">                newattributes[attribute]['ColumnName']</p><p class="source-code">                     = attribute.title()  </p><p class="source-code">                newattributes[attribute]['Value']</p><p class="source-code">                     = value  </p><p class="source-code">                newattributes[attribute]['Type']</p><p class="source-code">                     = 'VARCHAR'  </p><p class="source-code">                newattributes[attribute]['Length']</p><p class="source-code">                     = len(value)  </p></li>
<li>Similarly, if the <strong class="source-inline">class</strong> attribute is a boolean object, a similar kind of dictionary item with <strong class="source-inline">Type</strong> as <strong class="source-inline">BOOLEAN</strong> is returned:<p class="source-code">            elif type(value)==bool:  </p><p class="source-code">                newattributes[attribute] = {}  </p><p class="source-code">                newattributes[attribute]['ColumnName']</p><p class="source-code">                     = attribute.title()  </p><p class="source-code">                newattributes[attribute]['Value']</p><p class="source-code">                     = value  </p><p class="source-code">                newattributes[attribute]['Type']</p><p class="source-code">                     = 'BOOLEAN'  </p><p class="source-code">                newattributes[attribute]['Length']</p><p class="source-code">                     = None  </p></li>
<li>Any <a id="_idIndexMarker208"/>other variable or method is stored like so in <strong class="source-inline">newattributes</strong>:<p class="source-code">            else:  </p><p class="source-code">                newattributes[attribute] = value                  </p><p class="source-code">        return type.__new__(classitself, classname,</p><p class="source-code">             baseclasses, newattributes)  </p></li>
<li>We will now create the class <strong class="source-inline">Arizona</strong> with the metaclass as <strong class="source-inline">SchemaMetaClass</strong>, define all the variables for a product, and define a method that creates a schema out of the metaprogrammed class attributes:<p class="source-code">class Arizona(metaclass = SchemaMetaClass):  </p><p class="source-code">    product_id = 200443  </p><p class="source-code">    product_name = 'Iphone'  </p><p class="source-code">    product_category = 'Electronics'  </p><p class="source-code">    sales_quantity = 2  </p><p class="source-code">    tax_rate = 0.05  </p><p class="source-code">    sales_price = 1200  </p><p class="source-code">    profit = 70  </p><p class="source-code">    loss = 0  </p><p class="source-code">    sales_margin = 0.1  </p><p class="source-code">    promotion = '20%Off'  </p><p class="source-code">    promotion_reason = 'New Year'    </p><p class="source-code">    in_stock = True  </p><p class="source-code">      </p><p class="source-code">    def create_schema(self):  </p><p class="source-code">        import pandas as pd  </p><p class="source-code">        tableschema = pd.DataFrame([self.product_id,  </p><p class="source-code">                                  self.product_name,  </p><p class="source-code">                              self.product_category,  </p><p class="source-code">                                self.sales_quantity,  </p><p class="source-code">                                      self.tax_rate,  </p><p class="source-code">                                   self.sales_price,  </p><p class="source-code">                                        self.profit,  </p><p class="source-code">                                          self.loss,  </p><p class="source-code">                                  self.sales_margin,  </p><p class="source-code">                                     self.promotion,  </p><p class="source-code">                              self.promotion_reason,  </p><p class="source-code">                                     self.in_stock])  </p><p class="source-code">        tableschema.drop(labels = ['Value'], axis = 1,</p><p class="source-code">                         inplace = True)  </p><p class="source-code">        return tableschema   </p></li>
</ol>
<p>We have added product details of an example product  (in this case, an iPhone) and the variables are a combination of different data types – <strong class="source-inline">string</strong>, <strong class="source-inline">integer</strong>, <strong class="source-inline">float</strong>, and <strong class="source-inline">bool</strong>. We will define the method <strong class="source-inline">create_schema</strong>, which imports the pandas library to create a DataFrame that gives a table-like structure to the variables and returns the data frame as a table schema.</p>
<ol>
<li value="8">Now, consider <a id="_idIndexMarker209"/>a scenario where the metaclass is not added to the preceding code. Calling the <strong class="source-inline">product_name</strong> variable would have resulted in the following:<p class="source-code">objarizona = Arizona()  </p><p class="source-code">objarizona.product_name  </p><p class="source-code"><strong class="bold">'Iphone'</strong></p></li>
<li>Since we have added the metaclass in the preceding <strong class="source-inline">Arizona</strong> class definition, calling the <strong class="source-inline">product_name</strong> results in the following:<p class="source-code">objarizona = Arizona()</p><p class="source-code">objarizona.product_name</p><p class="source-code"><strong class="bold">{'ColumnName': 'Product_name',</strong></p><p class="source-code"><strong class="bold"> 'Value': 'Iphone',</strong></p><p class="source-code"><strong class="bold"> 'Type': 'VARCHAR',</strong></p><p class="source-code"><strong class="bold"> 'Length': 6}</strong></p></li>
<li>Similarly, we can look at the results of a few other variables as follows:<p class="source-code">objarizona.product_category  </p><p class="source-code">  </p><p class="source-code"><strong class="bold">{'ColumnName': 'Product_category',  </strong></p><p class="source-code"><strong class="bold"> 'Value': 'Electronics',  </strong></p><p class="source-code"><strong class="bold"> 'Type': 'VARCHAR',  </strong></p><p class="source-code"><strong class="bold"> 'Length': 11}  </strong></p><p class="source-code">  </p><p class="source-code">objarizona.sales_quantity  </p><p class="source-code"><strong class="bold">{'ColumnName': 'Sales_quantity', 'Value': 2, 'Type': 'NUMERIC', 'Length': 1}  </strong></p><p class="source-code">  </p><p class="source-code">objarizona.tax_rate  </p><p class="source-code"><strong class="bold">{'ColumnName': 'Tax_rate', 'Value': 0.05, 'Type': 'NUMERIC', 'Length': 4}  </strong></p></li>
<li>Using the<a id="_idIndexMarker210"/> metaprogrammed class variables further, we have defined the method <strong class="source-inline">create_schema</strong> to return a table schema:<p class="source-code">objarizona.create_schema()</p></li>
</ol>
<p>We get the following table, which includes all of the variables defined in the class:</p>
<div>
<div class="IMG---Figure" id="_idContainer064">
<img alt="Figure 4.12 – Output of the method create_schema " height="417" src="image/B13426_04_12.jpg" width="324"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.12 – Output of the method create_schema</p>
<p>These are some examples <a id="_idIndexMarker211"/>of how metaclasses can be used in developing applications. Metaclasses can further be used in more complex scenarios such as automated code generation and framework development.</p>
<h1 id="_idParaDest-65"><a id="_idTextAnchor067"/>Summary</h1>
<p>In this chapter, we have learned how to create metaclasses and some applications of metaclasses. </p>
<p>We then saw how to switch metaclasses, reuse the functionalities, and how to implement inheritance on classes that use metaclasses. Finally, we also saw how to manipulate the variables of metaclasses further.</p>
<p>All of these concepts are part of Python metaprogramming and they are used to change the behavior of a class externally and without impacting the internal functionalities of the class itself.</p>
<p>In the next chapter, we will be looking at the concept of reflection with different examples.</p>
</div>
</div></body></html>