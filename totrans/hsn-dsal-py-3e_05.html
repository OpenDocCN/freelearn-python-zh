<html><head></head><body>
  <div id="_idContainer142" class="Basic-Text-Frame">
    <h1 class="chapterNumber">5</h1>
    <h1 id="_idParaDest-110" class="chapterTitle">Stacks and Queues</h1>
    <p class="normal">In this chapter, we will discuss two very important data structures: stacks and queues. Stacks and queues have many important applications, such as form operating system architecture, arithmetic expression evaluation, load balancing, managing printing jobs, and traversing data. In stack and queue data structures, the data is stored sequentially, like arrays and linked lists, but unlike arrays and linked lists, the data is handled in a specific order with certain constraints, which we will be discussing in detail in this chapter. Moreover, we will also examine how we can implement stacks and queues using linked lists and arrays.</p>
    <p class="normal">In this chapter, we will discuss constraints and methods to handle the data in stacks and queues. We will also implement these data structures and learn how to apply different operations to these data structures in Python.</p>
    <p class="normal">In this chapter, we will cover the following:</p>
    <ul>
      <li class="bulletList">How to implement stacks and queues using various methods</li>
      <li class="bulletList">Some real-life example applications of stacks and queues</li>
    </ul>
    <h1 id="_idParaDest-111" class="heading-1">Stacks</h1>
    <p class="normal">A stack is a data <a id="_idIndexMarker387"/>structure that stores data, similar to a stack of plates in a kitchen. You can put a plate on the top of the stack, and when you need a plate, you take it from the top of the stack. </p>
    <p class="normal">The last plate that was added to the stack will be the first to be picked up from the stack:</p>
    <figure class="mediaobject"><img src="../Images/B17217_05_01.png" alt=""/></figure>
    <p class="packt_figref">Figure 5.1: Example of a stack</p>
    <p class="normal">The preceding diagram depicts a stack of plates. Adding a plate to the pile is only possible by <a id="_idIndexMarker388"/>leaving that plate on top of the pile. To remove a plate from the pile of plates means to remove the plate that is on top of the pile.</p>
    <p class="normal">A stack is a data structure that stores the data in a specific order similar to arrays and linked lists, with several constraints:</p>
    <ul>
      <li class="bulletList">Data elements in a stack can only be inserted at the end (<code class="inlineCode">push</code> operation)</li>
      <li class="bulletList">Data elements in a stack can only be deleted from the end (<code class="inlineCode">pop</code> operation)</li>
      <li class="bulletList">Only the last data element can be read from the stack (<code class="inlineCode">peek</code> operation)</li>
    </ul>
    <p class="normal">A stack data structure allows us to store and read data from one end, and the element which is <a id="_idIndexMarker389"/>added last is <a id="_idIndexMarker390"/>picked up first. Thus, a stack is a <strong class="keyWord">last in first out</strong> (<strong class="keyWord">LIFO)</strong> structure, or <strong class="keyWord">last in last out</strong> (<strong class="keyWord">LILO</strong>).</p>
    <p class="normal">There are two <a id="_idIndexMarker391"/>primary operations performed on stacks – <code class="inlineCode">push</code> and <code class="inlineCode">pop</code>. When an <a id="_idIndexMarker392"/>element is added to the top of the stack, it is called a <code class="inlineCode">push</code> operation, and when an element is to be picked up (that is, removed) from the top of the stack, it is called a <code class="inlineCode">pop</code> operation. Another operation is <code class="inlineCode">peek</code>, in which the top element of the stack can be viewed without removing it from the stack. All the operations in the stack are performed through a pointer, which is generally named <code class="inlineCode">top</code>. All these operations are shown in <em class="italic">Figure 5.2</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17217_05_02.png" alt=""/></figure>
    <p class="packt_figref">Figure 5.2: Demonstration of push and pop operations in a stack</p>
    <p class="normal">The<a id="_idIndexMarker393"/> following <a id="_idIndexMarker394"/>table demonstrates<a id="_idIndexMarker395"/> the use of two important stack operations (<code class="inlineCode">push</code> and <code class="inlineCode">pop</code>) in the stack:</p>
    <table id="table001-3" class="table-container">
      <tbody>
        <tr>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Stack operation </strong></p>
          </td>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Size </strong></p>
          </td>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Contents </strong></p>
          </td>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Operation results </strong></p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">stack()</code></p>
          </td>
          <td class="table-cell">
            <p class="normal">0</p>
          </td>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">[]</code></p>
          </td>
          <td class="table-cell">
            <p class="normal">Stack object created, which is empty.</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">push "egg"</code></p>
          </td>
          <td class="table-cell">
            <p class="normal">1</p>
          </td>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">['egg']</code></p>
          </td>
          <td class="table-cell">
            <p class="normal">One item <code class="inlineCode">egg</code> is added to the stack.</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">push "ham"</code></p>
          </td>
          <td class="table-cell">
            <p class="normal">2</p>
          </td>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">['egg', 'ham']</code></p>
          </td>
          <td class="table-cell">
            <p class="normal">One more item, <code class="inlineCode">ham</code>, is added to the stack.</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">peek()</code></p>
          </td>
          <td class="table-cell">
            <p class="normal">2</p>
          </td>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">['egg', 'ham']</code></p>
          </td>
          <td class="table-cell">
            <p class="normal">The top element, <code class="inlineCode">ham</code>, is returned.</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">pop()</code></p>
          </td>
          <td class="table-cell">
            <p class="normal">1</p>
          </td>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">['egg']</code></p>
          </td>
          <td class="table-cell">
            <p class="normal">The <code class="inlineCode">ham</code> item is popped off and returned. (This item was added last, so it is removed first.)</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">pop()</code></p>
          </td>
          <td class="table-cell">
            <p class="normal">0</p>
          </td>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">[]</code></p>
          </td>
          <td class="table-cell">
            <p class="normal">The <code class="inlineCode">egg</code> item is popped off and returned. (This is the first item added, so it is returned last.)</p>
          </td>
        </tr>
      </tbody>
    </table>
    <p class="packt_figref">Table 5.1: Illustration of different operations in a stack with examples</p>
    <p class="normal">Stacks are used for a number of things. One common usage for stacks is to keep track of the return address during function calls. Let’s imagine that we have the following program:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">b</span><span class="hljs-function">():</span> 
    <span class="hljs-built_in">print</span>(<span class="hljs-string">'b'</span>) 
<span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">a</span><span class="hljs-function">():</span> 
    b() 
a() 
<span class="hljs-built_in">print</span>(<span class="hljs-string">"</span><span class="hljs-string">done"</span>)
</code></pre>
    <p class="normal">When the <a id="_idIndexMarker396"/>program execution gets to the call to <code class="inlineCode">a()</code>, a sequence of events will be followed in order to complete the execution of this program. A visualization of all these steps is shown in <em class="italic">Figure 5.3</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17217_05_03.png" alt=""/></figure>
    <p class="packt_figref">Figure 5.3: Steps for a sequence of events during function calls in our sample program </p>
    <p class="normal">The sequence of events is as follows:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">First, the address of the current instruction is pushed onto the stack, and then execution jumps to the definition of <code class="inlineCode">a</code></li>
      <li class="numberedList">Inside function <code class="inlineCode">a()</code>, function <code class="inlineCode">b()</code> is called</li>
      <li class="numberedList">The return address of function <code class="inlineCode">b()</code> is pushed onto the stack. Once the execution of the instructions and functions in <code class="inlineCode">b()</code> are complete, the return address is popped off the stack, which takes us back to function <code class="inlineCode">a()</code></li>
      <li class="numberedList">When all the instructions in function <code class="inlineCode">a()</code> are completed, the return address is again popped off the stack, which takes us back to the main program and the <code class="inlineCode">print</code> statement</li>
    </ol>
    <p class="normal">The output <a id="_idIndexMarker397"/>of the above program is as follows:</p>
    <pre class="programlisting con"><code class="hljs-con">b
done
</code></pre>
    <p class="normal">We have now discussed the concept of the stack data structure. Now, let us understand its implementation in Python using array and linked list data structures.</p>
    <h2 id="_idParaDest-112" class="heading-2">Stack implementation using arrays</h2>
    <p class="normal">Stacks store data in sequential order like arrays and linked lists, with a specific constraint <a id="_idIndexMarker398"/>that the data can only be stored and read from <a id="_idIndexMarker399"/>one end of the stack following the <strong class="keyWord">last in first out</strong> (<strong class="keyWord">LIFO</strong>) principle. In general, stacks can be implemented using arrays and linked lists. Array-based<a id="_idIndexMarker400"/> implementations will have fixed lengths for the stack, whereas linked list-based implementations can have stacks of variable lengths.</p>
    <p class="normal">In the case of the array-based implementation of a stack (where the stack has a fixed size), it is important to check whether the stack is full or not, since trying to push an element into a full stack will generate an error, called an overflow. Likewise, trying to apply a <code class="inlineCode">pop</code> operation to an empty stack causes an error known as an underflow.</p>
    <p class="normal">Let us understand the implementation of a stack using an array with an example in which we wish to push three data elements, “egg”, “ham”, and “spam”, into the stack. Firstly, to insert new elements into a stack using the <code class="inlineCode">push</code> operation, we check the overflow condition, which is when the <code class="inlineCode">top</code> pointer is pointing to the end index of the array. The <code class="inlineCode">top</code> pointer is the index position of the top element in the stack. If the top element is equal to the overflow condition, the new element cannot be added. This is a stack overflow condition. If there is free space in the array to insert new elements, new data is pushed into the stack. An overview of the <code class="inlineCode">push</code> operation on a stack using an array is shown in <em class="italic">Figure 5.4</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17217_05_04.png" alt=""/></figure>
    <p class="packt_figref">Figure 5.4: Sequence of push operations in a stack implementation using an array</p>
    <p class="normal">The Python <a id="_idIndexMarker401"/>code for the <code class="inlineCode">push</code> operation is as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">size = <span class="hljs-number">3</span>
data = [<span class="hljs-number">0</span>]*(size)   <span class="hljs-comment">#Initialize the stack</span>
top = -<span class="hljs-number">1</span>
<span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">push</span><span class="hljs-function">(</span><span class="hljs-params">x</span><span class="hljs-function">):</span>
     <span class="hljs-keyword">global</span> top
     <span class="hljs-keyword">if</span> top &gt;= size - <span class="hljs-number">1</span>:
           <span class="hljs-built_in">print</span>(<span class="hljs-string">"Stack Overflow"</span>)
     <span class="hljs-keyword">else</span>:
           top = top + <span class="hljs-number">1</span>
           data[top] = x
</code></pre>
    <p class="normal">In the <a id="_idIndexMarker402"/>above code, we initialize the stack with a fixed size (say, 3 in this example), and also the <code class="inlineCode">top</code> pointer to –1, which indicates that the stack is empty. Further, in the push method, the <code class="inlineCode">top</code> pointer is compared with the size of the stack to check the overflow condition and, if the stack is full, the stack overflow message is printed. If the stack is not full, the top pointer is incremented by 1, and the new data element is added to the top of the stack. The following code is used to insert data elements into the stack:</p>
    <pre class="programlisting code"><code class="hljs-code">push(<span class="hljs-string">'egg'</span>)
push(<span class="hljs-string">'ham'</span>)
push(<span class="hljs-string">'spam'</span>)
<span class="hljs-built_in">print</span>(data[<span class="hljs-number">0</span> : top + <span class="hljs-number">1</span>] ) 
push(<span class="hljs-string">'new'</span>)
push(<span class="hljs-string">'new2'</span>)
</code></pre>
    <p class="normal">In the above code, when we try to insert the first three elements, they are added since there was enough space, but when we try to add the data elements <code class="inlineCode">new</code> and <code class="inlineCode">new2</code>, the stack is already full, hence these two elements cannot be added to the stack. The output of this code is as follows:</p>
    <pre class="programlisting con"><code class="hljs-con">['egg', 'ham', 'spam'] 
Stack Overflow 
Stack Overflow 
</code></pre>
    <p class="normal">Next, the <code class="inlineCode">pop</code> operation returns the value of the top element of the stack and removes it from the <a id="_idIndexMarker403"/>stack. Firstly, we check if the stack is empty <a id="_idIndexMarker404"/>or not. If the stack is already empty, a stack underflow message is printed. Otherwise, the top is removed from the stack. An overview of the <code class="inlineCode">pop</code> operation is shown in <em class="italic">Figure 5.5</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17217_05_05.png" alt=""/></figure>
    <p class="packt_figref">Figure 5.5: Sequence of the pop operation in a stack implementation using an array</p>
    <p class="normal">The Python code for the <code class="inlineCode">pop</code> operation is as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">pop</span><span class="hljs-function">():</span>
    <span class="hljs-keyword">global</span> top
    <span class="hljs-keyword">if</span> top == -<span class="hljs-number">1</span>:
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"Stack Underflow"</span>)
    <span class="hljs-keyword">else</span>:
        top = top – <span class="hljs-number">1</span>
        data[top] = <span class="hljs-number">0</span>
        <span class="hljs-keyword">return</span> data[top+<span class="hljs-number">1</span>]
</code></pre>
    <p class="normal">In the above code, we first check the underflow condition by checking whether the stack is empty or not. If the <code class="inlineCode">top</code> pointer has a value of –1, it means the stack is empty. Otherwise, the data elements in the stack are removed by decrementing the <code class="inlineCode">top</code> pointer by 1, and the top data element is returned to the main function.</p>
    <p class="normal">Let’s assume we already added three data elements to the stack, and then we call the <code class="inlineCode">pop</code> function four times. Since there are only three elements in the stack, the initial three data <a id="_idIndexMarker405"/>elements are removed, and when we try to <a id="_idIndexMarker406"/>call the <code class="inlineCode">pop</code> operation a fourth time, the stack underflow message is printed. This is shown in the following code snippet:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-built_in">print</span>(data[<span class="hljs-number">0</span> : top + <span class="hljs-number">1</span>])
pop()
pop()
pop()
pop()
<span class="hljs-built_in">print</span>(data[<span class="hljs-number">0</span> : top + <span class="hljs-number">1</span>])
</code></pre>
    <p class="normal">The output of the above code is as follows:</p>
    <pre class="programlisting con"><code class="hljs-con">['egg', 'ham', 'spam']
Stack Underflow 
[]
</code></pre>
    <p class="normal">Next, let us see an implementation of the <code class="inlineCode">peek</code> operation in which we return the value of the top element of the stack. The Python code for this is as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">peek</span><span class="hljs-function">():</span>
   <span class="hljs-keyword">global</span> top
   <span class="hljs-keyword">if</span> top == -<span class="hljs-number">1</span>:
       <span class="hljs-built_in">print</span>(<span class="hljs-string">"Stack is empty"</span>)
   <span class="hljs-keyword">else</span>:
       <span class="hljs-built_in">print</span>(data[top])
</code></pre>
    <p class="normal">In the above code, firstly, we check the position of the <code class="inlineCode">top</code> pointer in the stack. If the value of the <code class="inlineCode">top</code> pointer is –1, it means that the stack is empty, otherwise, we print the value of the top element of the stack. </p>
    <p class="normal">We have discussed the Python implementation of a stack using an array, so next let us discuss stack implementation using linked lists.</p>
    <h2 id="_idParaDest-113" class="heading-2">Stack implementation using linked lists</h2>
    <p class="normal">In order <a id="_idIndexMarker407"/>to implement the stacks using linked <a id="_idIndexMarker408"/>lists, we will write the <code class="inlineCode">Stack</code> class in which all the methods will be declared; however, we will also use the <code class="inlineCode">node</code> class similar to what we discussed in the previous chapter:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">Node</span><span class="hljs-class">:</span> 
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">__init__</span><span class="hljs-function">(</span><span class="hljs-params">self, data=</span><span class="hljs-literal">None</span><span class="hljs-function">):</span> 
        self.data = data 
        self.<span class="hljs-built_in">next</span> = <span class="hljs-literal">None</span> 
</code></pre>
    <p class="normal">As we know, a <code class="inlineCode">node</code> in a linked list holds data and a reference to the next item in the linked list. Implementing the stack data structure using a linked list can be treated as a standard linked list with some constraints, including that elements can be added or removed from the end of the list (<code class="inlineCode">push</code> and <code class="inlineCode">pop</code> operations) through the <code class="inlineCode">top</code> pointer. This is shown in <em class="italic">Figure 5.6</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17217_05_06.png" alt=""/></figure>
    <p class="packt_figref">Figure 5.6: Representation of the stack using a linked list</p>
    <p class="normal">Now let us look at the <code class="inlineCode">stack</code> class. Its implementation is quite similar to a singly linked list. In addition, we need two things to implement a stack:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">We first need to know which node is at the top of the stack so that we can apply the <code class="inlineCode">push</code> and <code class="inlineCode">pop</code> operations through this node</li>
      <li class="numberedList">We would also like to keep track of the number of nodes in the stack, so we add a <code class="inlineCode">size</code> variable to the <code class="inlineCode">Stack</code> class</li>
    </ol>
    <p class="normal">Consider the following code snippet for the <code class="inlineCode">Stack</code> class:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">Stack</span><span class="hljs-class">:</span> 
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">__init__</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">):</span> 
        self.top = <span class="hljs-literal">None</span> 
        self.size = <span class="hljs-number">0</span> 
</code></pre>
    <p class="normal">In the <a id="_idIndexMarker409"/>above code, we have declared the <code class="inlineCode">top</code> and <code class="inlineCode">size</code> variables, which <a id="_idIndexMarker410"/>are initialized to <code class="inlineCode">None</code> and <code class="inlineCode">0</code>. Once we have initialized the <code class="inlineCode">Stack</code> class, next, we will implement different operations in the <code class="inlineCode">Stack</code> class. First, let us start with a discussion of the <code class="inlineCode">push</code> operation.</p>
    <h2 id="_idParaDest-114" class="heading-2">Push operation</h2>
    <p class="normal">The <code class="inlineCode">push</code> operation is <a id="_idIndexMarker411"/>an important operation on a stack; it is used to <a id="_idIndexMarker412"/>add an element at the top of the stack. In order to add a new node to the stack, firstly, we check if the stack already has some items in it or if it is empty. We are not required here to check the overflow condition because we are not required to fix the length of the stack, unlike the stack implementation using arrays.</p>
    <p class="normal">If the stack already has some elements, then we have to do two things:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">The new node must have its next pointer pointing to the node that was at the top earlier</li>
      <li class="numberedList">We put this new node at the top of the stack by pointing <code class="inlineCode">self.top</code> to the newly added node</li>
    </ol>
    <p class="normal">See the two instructions in the following <em class="italic">Figure 5.7</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17217_05_07.png" alt=""/></figure>
    <p class="packt_figref">Figure 5.7: Workings of the push operation on the stack</p>
    <p class="normal">If the <a id="_idIndexMarker413"/>existing stack is empty, and the new node to be added is the first <a id="_idIndexMarker414"/>element, we need to make this node the top node of the element. Thus, <code class="inlineCode">self.top</code> will point to this new node. See the following <em class="italic">Figure 5.8</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17217_05_08.png" alt=""/></figure>
    <p class="packt_figref">Figure 5.8: Insertion of the data element “egg” into an empty stack</p>
    <p class="normal">The following is the complete implementation of the <code class="inlineCode">push</code> operation, which should be defined in the <code class="inlineCode">Stack</code> class:</p>
    <pre class="programlisting code"><code class="hljs-code">   <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">push</span><span class="hljs-function">(</span><span class="hljs-params">self, data</span><span class="hljs-function">):</span>
        <span class="hljs-comment"># create a new node</span>
       node = Node(data)
       <span class="hljs-keyword">if</span> self.top:
           node.<span class="hljs-built_in">next</span> = self.top
           self.top = node
       <span class="hljs-keyword">else</span>: 
           self.top = node
       self.size += <span class="hljs-number">1</span>
</code></pre>
    <p class="normal">In the above code, we create a new node and store the data in that. Then we check the position of the <code class="inlineCode">top</code> pointer. If it is not null, that means the stack is not empty, and we add the <a id="_idIndexMarker415"/>new node, updating two pointers as shown in <em class="italic">Figure 5.7</em>. In the <code class="inlineCode">else</code> part, we make the <code class="inlineCode">top</code> pointer point to the new node. Finally, we increase the size <a id="_idIndexMarker416"/>of the stack by incrementing the <code class="inlineCode">self.size</code> variable.</p>
    <p class="normal">To create a stack of three data elements, we use the following code:</p>
    <pre class="programlisting code"><code class="hljs-code">words = Stack()
words.push(<span class="hljs-string">'egg'</span>)
words.push(<span class="hljs-string">'ham'</span>)
words.push(<span class="hljs-string">'spam'</span>)
<span class="hljs-comment">#print the stack elements.</span>
current = words.top
<span class="hljs-keyword">while</span> current:
      <span class="hljs-built_in">print</span>(current.data)
      current = current.<span class="hljs-built_in">next</span>
</code></pre>
    <p class="normal">The output of the above code is as follows:</p>
    <pre class="programlisting con"><code class="hljs-con">spam
ham
egg
</code></pre>
    <p class="normal">In the above code, we created a stack of three elements – egg, ham, and spam. Next, we will discuss the <code class="inlineCode">pop</code> operation in stack data structures.</p>
    <h2 id="_idParaDest-115" class="heading-2">Pop operation</h2>
    <p class="normal">Another important <a id="_idIndexMarker417"/>operation that is applied to the stack is the <code class="inlineCode">pop</code> operation. In <a id="_idIndexMarker418"/>this operation, the topmost element of the stack is read, and then removed from the stack. The <code class="inlineCode">pop</code> method returns the topmost element of the stack and returns <code class="inlineCode">None</code> if the stack is empty.</p>
    <p class="normal">To implement the <code class="inlineCode">pop</code> operation on a stack, we do following:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">First, check if <a id="_idIndexMarker419"/>the stack is empty. The <code class="inlineCode">pop</code> operation <a id="_idIndexMarker420"/>is not allowed on an empty stack.</li>
      <li class="numberedList">If the stack is not empty, check whether the top node has its next attribute pointing to some other node. If so, it means the stack contains elements, and the topmost node is pointing to the next node in the stack. To apply the <code class="inlineCode">pop</code> operation, we have to change the top pointer. The next node should be at the top. We do this by pointing <code class="inlineCode">self.top</code> to <code class="inlineCode">self.top.next</code>. See the following <em class="italic">Figure 5.9</em> to understand this:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B17217_05_09.png" alt=""/></figure>
    <p class="packt_figref">Figure 5.9: Workings of the pop operation on the stack</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="3">When there is only one node in the stack, the stack will be empty after the <code class="inlineCode">pop</code> operation. We have to change the top pointer to <code class="inlineCode">None</code>. See the following <em class="italic">Figure 5.10</em>:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B17217_05_10.png" alt="Diagram, engineering drawing  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 5.10: The pop operation on a stack with one element</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="4">Removing this node results in <code class="inlineCode">self.top</code> pointing to <code class="inlineCode">None</code>, as shown in <em class="italic">Figure 5.10</em>.</li>
      <li class="numberedList">We also <a id="_idIndexMarker421"/>decrement the size of the stack by <code class="inlineCode">1</code> if the stack is not empty.</li>
    </ol>
    <p class="normal">Here is the <a id="_idIndexMarker422"/>code for the <code class="inlineCode">pop</code> operation for the stack in Python, which should be defined in the <code class="inlineCode">Stack</code> class:</p>
    <pre class="programlisting code"><code class="hljs-code">    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">pop</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">):</span> 
        <span class="hljs-keyword">if</span> self.top: 
            data = self.top.data 
            self.size -= <span class="hljs-number">1</span>  
            <span class="hljs-keyword">if</span> self.top.<span class="hljs-built_in">next</span>:  <span class="hljs-comment">#check if there is more than one node.</span>
                self.top = self.top.<span class="hljs-built_in">next</span> 
            <span class="hljs-keyword">else</span>: 
                self.top = <span class="hljs-literal">None</span> 
            <span class="hljs-keyword">return</span> data 
        <span class="hljs-keyword">else</span>: 
            <span class="hljs-built_in">print</span>(<span class="hljs-string">"Stack is empty"</span>)
</code></pre>
    <p class="normal">In the above code, firstly, we check the position of the <code class="inlineCode">top</code> pointer. If it is not null, it means the stack is not empty, and we can apply the <code class="inlineCode">pop</code> operation such that if there is more than one data element in the stack, we move the <code class="inlineCode">top</code> pointer to point to the next node (see <em class="italic">Figure 5.9</em>), and if that is the last node, we make the <code class="inlineCode">top</code> pointer point to <code class="inlineCode">None</code> (see <em class="italic">Figure 5.10</em>). We also decrease the size of the stack by decrementing the <code class="inlineCode">self.size</code> variable.</p>
    <p class="normal">Let’s say we have three data elements in a stack. We can use the following code to apply the <code class="inlineCode">pop</code> operation to the stack:</p>
    <pre class="programlisting code"><code class="hljs-code">words.pop()
current = words.top
<span class="hljs-keyword">while</span> current:
     <span class="hljs-built_in">print</span>(current.data)
     current = current.<span class="hljs-built_in">next</span>
</code></pre>
    <p class="normal">The output <a id="_idIndexMarker423"/>of the above <a id="_idIndexMarker424"/>code is as follows:</p>
    <pre class="programlisting con"><code class="hljs-con">ham
egg
</code></pre>
    <p class="normal">In the above code, we popped off the top element from the stack of three elements – <code class="inlineCode">egg</code>, <code class="inlineCode">ham</code>, <code class="inlineCode">spam</code>.</p>
    <p class="normal">Next, we will discuss the <code class="inlineCode">peek</code> operation used on stack data structures.</p>
    <h2 id="_idParaDest-116" class="heading-2">Peek operation</h2>
    <p class="normal">There is another important operation that can be applied to stacks—the <code class="inlineCode">peek</code> method. This method <a id="_idIndexMarker425"/>returns the top element from the stack without deleting it from the stack. The only difference between <code class="inlineCode">peek</code> and <code class="inlineCode">pop</code> is that the <code class="inlineCode">peek</code> method <a id="_idIndexMarker426"/>just returns the topmost element; however, in the case of a <code class="inlineCode">pop</code> method, the topmost element is returned, and that element is also deleted from the stack.</p>
    <p class="normal">The <code class="inlineCode">peek</code> operation allows us to look at the top element without changing the stack. This operation is very straightforward. If there is a top element, return its data; otherwise, return <code class="inlineCode">None</code> (thus, the behavior of <code class="inlineCode">peek</code> matches that of <code class="inlineCode">pop</code>). The implementation of the <code class="inlineCode">peek</code> method is as follows (this should be defined in the <code class="inlineCode">Stack</code> class):</p>
    <pre class="programlisting code"><code class="hljs-code">    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">peek</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">):</span> 
        <span class="hljs-keyword">if</span> self.top: 
             <span class="hljs-keyword">return</span> self.top.data 
        <span class="hljs-keyword">else</span>: 
            <span class="hljs-built_in">print</span>(<span class="hljs-string">"Stack is empty"</span>)
         
</code></pre>
    <p class="normal">In the above code, we first check the position of the <code class="inlineCode">top</code> pointer using <code class="inlineCode">self.top</code>. If it is not null, this means the stack is not empty, and we return the data value of the topmost node, otherwise, we print the message that the stack is empty. We can use the <code class="inlineCode">peek</code> method to get the top element of the stack through the following code:</p>
    <pre class="programlisting code"><code class="hljs-code">words.peek()
</code></pre>
    <p class="normal">The output of the above code is:</p>
    <pre class="programlisting con"><code class="hljs-con">spam
</code></pre>
    <p class="normal">As per our <a id="_idIndexMarker427"/>original example of the three data elements being added to <a id="_idIndexMarker428"/>the stack, if we use the <code class="inlineCode">peek</code> method, we get the top element, <code class="inlineCode">spam</code>, as an output.</p>
    <p class="normal">Stacks are an important data structure with several real-world applications. To better understand the concept of the stack, we will discuss one of these applications: bracket matching utilizing stacks.</p>
    <h2 id="_idParaDest-117" class="heading-2">Applications of stacks</h2>
    <p class="normal">As we know, array and linked list data structures can do whatever the stack or queue data structures (that we will discuss shortly) can do. </p>
    <p class="normal">Despite this, these data structures are important <a id="_idIndexMarker429"/>because of their many applications. For example, in any application, it may be required to add or delete any element in a particular order. stack and queues can be used for this to avoid any potential bug in the program, perhaps accessing/deleting an element from the middle of the list (which can happen in the cases of arrays and linked lists).</p>
    <p class="normal">Now let us look at an example bracket-matching application and see how we can use our stack to implement it.</p>
    <p class="normal">Let us write a function <code class="inlineCode">check_brackets</code> that will verify whether a given expression containing brackets—<code class="inlineCode">( )</code>, <code class="inlineCode">[ ]</code>, or <code class="inlineCode">{ }</code>— is balanced or not, that is, whether the number of closing brackets matches the number of opening brackets. Stacks can be used for traversing a list of items in reverse order since they follow the <strong class="keyWord">LILO</strong> rule, which makes them a good choice for this problem.</p>
    <p class="normal">The following code is for a separate <code class="inlineCode">check_brackets</code> method defined outside the <code class="inlineCode">Stack</code> class. This method will use the <code class="inlineCode">Stack</code> class that we discussed in the previous section. The method takes an expression consisting of alphabetical characters and brackets as input and produces <code class="inlineCode">True</code> or <code class="inlineCode">False</code> as output for whether the given expression is valid or not, respectively. The code for the <code class="inlineCode">check_brackets</code> method is as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">check_brackets</span><span class="hljs-function">(</span><span class="hljs-params">expression</span><span class="hljs-function">):</span>  
    brackets_stack = Stack()     <span class="hljs-comment">#The stack class, we defined in previous section. </span>
    last = <span class="hljs-string">'</span><span class="hljs-string"> '</span> 
    <span class="hljs-keyword">for</span> ch <span class="hljs-keyword">in</span> expression:  
        <span class="hljs-keyword">if</span> ch <span class="hljs-keyword">in</span> (<span class="hljs-string">'{'</span>, <span class="hljs-string">'['</span>, <span class="hljs-string">'('</span>):  
            brackets_stack.push(ch)  
        <span class="hljs-keyword">if</span> ch <span class="hljs-keyword">in</span> (<span class="hljs-string">'</span><span class="hljs-string">}'</span>, <span class="hljs-string">']'</span>, <span class="hljs-string">')'</span>): 
            last = brackets_stack.pop()  
            <span class="hljs-keyword">if</span> last == <span class="hljs-string">'{'</span> <span class="hljs-keyword">and</span> ch == <span class="hljs-string">'}'</span>: 
                <span class="hljs-keyword">continue</span>  
            <span class="hljs-keyword">elif</span> last == <span class="hljs-string">'['</span> <span class="hljs-keyword">and</span> ch == <span class="hljs-string">']'</span>: 
                <span class="hljs-keyword">continue</span>  
            <span class="hljs-keyword">elif</span> last == <span class="hljs-string">'('</span> <span class="hljs-keyword">and</span> ch == <span class="hljs-string">')'</span>:  
                <span class="hljs-keyword">continue</span>  
            <span class="hljs-keyword">else</span>:  
                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>  
    <span class="hljs-keyword">if</span> brackets_stack.size &gt; <span class="hljs-number">0</span>: 
        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>  
    <span class="hljs-keyword">else</span>:
        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>
</code></pre>
    <p class="normal">The above function parses each character in the expression passed to it. If it gets an open bracket, it pushes it onto the stack. If it gets a closing bracket, it pops the top element off the stack and compares the two brackets to make sure their types match-<code class="inlineCode">(</code> should match <code class="inlineCode">)</code>, <code class="inlineCode">[</code> should match <code class="inlineCode">]</code>, and <code class="inlineCode">{</code> should match <code class="inlineCode">}</code>. If they don’t, we return <code class="inlineCode">False</code>; otherwise, we continue parsing.</p>
    <p class="normal">Once we reach <a id="_idIndexMarker430"/>the end of the expression, we need to do one last check. If the stack is empty, then it is fine and we can return <code class="inlineCode">True</code>. But if the stack is not empty, then we have an opening bracket that does not have a matching closing bracket and we will return <code class="inlineCode">False</code>.</p>
    <p class="normal">We can test the bracket-matcher with the following code:</p>
    <pre class="programlisting code"><code class="hljs-code">sl = ( 
   <span class="hljs-string">"{(foo)(bar)}[hello](((this)is)a)test"</span>, 
   <span class="hljs-string">"{(foo)(bar)}[hello](((this)is)atest"</span>, 
   <span class="hljs-string">"</span><span class="hljs-string">{(foo)(bar)}[hello](((this)is)a)test))"</span> 
) 
<span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> sl: 
   m = check_brackets(s) 
   <span class="hljs-built_in">print</span>(<span class="hljs-string">"{}: {}"</span>.<span class="hljs-built_in">format</span>(s, m))
</code></pre>
    <p class="normal">Only the first of the three statements should match. When we run the code, we get the following output:</p>
    <pre class="programlisting con"><code class="hljs-con">{(foo)(bar)}[hello](((this)is)a)test: True
{(foo)(bar)}[hello](((this)is)atest: False 
{(foo)(bar)}[hello](((this)is)a)test)): False
</code></pre>
    <p class="normal">In the above sample three expressions, we can see that the first expression is valid, while the other two are not valid expressions. Hence, the output of the preceding code is <code class="inlineCode">True</code>, <code class="inlineCode">False</code>, and <code class="inlineCode">False</code>.</p>
    <p class="normal">In summary, the <code class="inlineCode">push</code>, <code class="inlineCode">pop</code>, and <code class="inlineCode">peek</code> operations of the stack data structure have a time complexity of <code class="inlineCode">O(1)</code> since the addition and deletion operations can be directly performed in constant <a id="_idIndexMarker431"/>time through the <code class="inlineCode">top</code> pointer. The stack data structure is simple; however, it is used to implement many functionalities in real-world applications. For example, the back and forward buttons in web browsers are implemented using stacks. Stacks are also used to implement the undo and redo functionalities in word processors.</p>
    <p class="normal">We have discussed the stack data structure and its implementations using arrays and linked lists. In the next section, we will discuss the queue data structure and the different operations that can be applied to queues.</p>
    <h1 id="_idParaDest-118" class="heading-1">Queues</h1>
    <p class="normal">Another important data structure is the queue, which is used to store data similarly to stacks and linked lists, with some constraints and in a specific order. The queue data structure is very <a id="_idIndexMarker432"/>similar to the regular queue you are accustomed to in real life. It is just like a line of people waiting to be served in sequential order at a shop. Queues are a fundamentally important concept to grasp since many other data structures are built on them.</p>
    <p class="normal">A queue works as follows. The first person to join the queue usually gets served first, and everyone will be served in the order in which they joined the queue. The acronym <strong class="keyWord">FIFO</strong> best explains the <a id="_idIndexMarker433"/>concept of a queue. <strong class="keyWord">FIFO</strong> stands for <strong class="keyWord">first in, first out</strong>. When people are standing in a queue waiting for their turn to be served, service is only rendered at the front of the queue. Therefore, people are dequeued from the front of the queue and enqueued from the back where they wait their turn. The only time people exit the queue is when they have been served, which only occurs at the very front of the queue. Refer to the following diagram, where people are standing in the queue, and the person at the front will be served first:</p>
    <figure class="mediaobject"><img src="../Images/B17217_05_11.png" alt=""/></figure>
    <p class="packt_figref">Figure 5.11: Illustration of a queue</p>
    <p class="normal">To join the <a id="_idIndexMarker434"/>queue, participants must stand behind the last person in the queue. This is the only legal or permitted way the queue accepts new entrants. The length of the queue does not matter.</p>
    <p class="normal">A queue is a list of elements stored in sequence with the following constraints:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Data elements can only be inserted from one end, the rear end/tail of the queue.</li>
      <li class="numberedList">Data elements can only be deleted from the other end, the front/head of the queue.</li>
      <li class="numberedList">Only data elements from the front of the queue can be read.</li>
    </ol>
    <p class="normal">The operation to add an element to the queue is known as <code class="inlineCode">enqueue</code>. Deleting an element from the queue uses the <code class="inlineCode">dequeue</code> operation. Whenever an element is enqueued, the length or size of the queue increments by 1, and dequeuing an item reduces the number of elements in the queue by 1. </p>
    <p class="normal">We can see this concept in the doubly linked list shown in <em class="italic">Figure 5.12</em>, in which we can add new elements to the tail/rear end and elements can only be deleted from the head/front end of the queue:</p>
    <figure class="mediaobject"><img src="../Images/B17217_05_12.png" alt=""/></figure>
    <p class="packt_figref">Figure 5.12: Queue implementation using the stack data structure</p>
    <p class="normal">The reader is advised to not confuse the notation: the <code class="inlineCode">enqueue</code> operation will be performed only at the <strong class="keyWord">tail/rear</strong> end and the <code class="inlineCode">dequeue</code> operation will be performed from the <strong class="keyWord">head/front</strong> end. It should be fixed that one end will be used for <code class="inlineCode">enqueue</code> operations and the other end will be used for <code class="inlineCode">dequeue</code> operations; however, either end can be used for each of these <a id="_idIndexMarker435"/>operations. It is good in general practice to fix that we perform <code class="inlineCode">enqueue</code> operations from the <strong class="keyWord">rear</strong> end and <code class="inlineCode">dequeue</code> operations from the <strong class="keyWord">front</strong> end. To demonstrate these two operations, the following table shows the effects of adding and removing elements from a queue:</p>
    <table id="table002-3" class="table-container">
      <tbody>
        <tr>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Queue operation</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Size</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Contents</strong></p>
          </td>
          <td class="table-cell">
            <p class="normal"><strong class="keyWord">Operation results</strong></p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">queue()</code></p>
          </td>
          <td class="table-cell">
            <p class="normal">0</p>
          </td>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">[]</code></p>
          </td>
          <td class="table-cell">
            <p class="normal">Queue object created, which is empty.</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">enqueue- "packt" </code></p>
          </td>
          <td class="table-cell">
            <p class="normal">1</p>
          </td>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">['packt']</code></p>
          </td>
          <td class="table-cell">
            <p class="normal">One item, <code class="inlineCode">packt</code>, is added to the queue.</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">enqueue "publishing"</code></p>
          </td>
          <td class="table-cell">
            <p class="normal">2</p>
          </td>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">[ 'packt', 'publishing']</code></p>
          </td>
          <td class="table-cell">
            <p class="normal">One more item, <code class="inlineCode">publishing</code>, is added to the queue.</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">Size()</code></p>
          </td>
          <td class="table-cell">
            <p class="normal">2</p>
          </td>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">[ 'packt', 'publishing']</code></p>
          </td>
          <td class="table-cell">
            <p class="normal">Return the number of items in the queue, which is 2 in this example.</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">dequeue()</code></p>
          </td>
          <td class="table-cell">
            <p class="normal">1</p>
          </td>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">['publishing']</code></p>
          </td>
          <td class="table-cell">
            <p class="normal">The <code class="inlineCode">packt</code> item is dequeued and returned. (This item was added first, so it is removed first.)</p>
          </td>
        </tr>
        <tr>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">dequeue()</code></p>
          </td>
          <td class="table-cell">
            <p class="normal">0</p>
          </td>
          <td class="table-cell">
            <p class="normal"><code class="inlineCode">[]</code></p>
          </td>
          <td class="table-cell">
            <p class="normal">The <code class="inlineCode">publishing</code> item is dequeued and returned. (This is the last item added, so it is returned last.)</p>
          </td>
        </tr>
      </tbody>
    </table>
    <p class="packt_figref">Table 5.2: Illustration of different operations on an example queue</p>
    <p class="normal">Queue data structures <a id="_idIndexMarker436"/>in Python have a built-in implementation, <code class="inlineCode">queue.Queue</code>, and can also be implemented using the <code class="inlineCode">deque</code> class from the <code class="inlineCode">collections</code> module. Queue data structures can be implemented using various methods in Python, namely, (1) Python’s built-in list, (2) stacks, and (3) node-based linked lists. We will discuss them one by one in detail.</p>
    <h2 id="_idParaDest-119" class="heading-2">Python’s list-based queues</h2>
    <p class="normal">Firstly, in <a id="_idIndexMarker437"/>order to implement a queue based on Python’s <code class="inlineCode">list</code> data structure, we create a <code class="inlineCode">ListQueue</code> class, in which we declare and define the <a id="_idIndexMarker438"/>different functionalities of queue. In this method, we store the actual data in Python’s <code class="inlineCode">list</code> data structure. The <code class="inlineCode">ListQueue</code> class is defined as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">ListQueue</span><span class="hljs-class">:</span> 
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">__init__</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">):</span> 
        self.items = [] 
        self.front = self.rear = <span class="hljs-number">0</span>
        self.size = <span class="hljs-number">3</span>     <span class="hljs-comment"># maximum capacity of the queue</span>
</code></pre>
    <p class="normal">In the <code class="inlineCode">__init__</code> initialization method, the <code class="inlineCode">items</code> instance variable is set to <code class="inlineCode">[]</code>, which means the queue is empty when created. The size of the queue is also set to <code class="inlineCode">4</code> (as an example in this code), which is the maximum capacity for the number of elements that can be stored in the queue. Moreover, the initial position of the rear and front indices are also set to <code class="inlineCode">0</code>. <code class="inlineCode">enqueue</code> and <code class="inlineCode">dequeue</code> are important methods in queues, and we will discuss them next.</p>
    <h3 id="_idParaDest-120" class="heading-3">The enqueue operation</h3>
    <p class="normal">The <code class="inlineCode">enqueue</code> operation adds <a id="_idIndexMarker439"/>an item at the end of the queue. Consider the example of adding elements to the queue to understand the concept shown in <em class="italic">Figure 5.13</em>. We start with an empty list. Initially, we add an item <code class="inlineCode">3</code> at index <code class="inlineCode">0</code>. </p>
    <p class="normal">Next, we add an item <code class="inlineCode">11</code> at index <code class="inlineCode">1</code>, and move the rear pointer every time we add an element:</p>
    <figure class="mediaobject"><img src="../Images/B17217_05_13.png" alt=""/></figure>
    <p class="packt_figref">Figure 5.13: Example of an enqueue operation on the queue</p>
    <p class="normal">In order to implement the enqueue operation, we use the <code class="inlineCode">append</code> method of the <code class="inlineCode">List</code> class to append items (or data) to the end of the queue. See the following code for the implementation of the <code class="inlineCode">enqueue</code> method. This should be defined in the <code class="inlineCode">ListQueue</code> class:</p>
    <pre class="programlisting code"><code class="hljs-code">    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">enqueue</span><span class="hljs-function">(</span><span class="hljs-params">self, data</span><span class="hljs-function">):</span>  
        <span class="hljs-keyword">if</span> self.size == self.rear:
            <span class="hljs-built_in">print</span>(<span class="hljs-string">"\n Queue is full"</span>)
        <span class="hljs-keyword">else</span>:   
            self.items.append(data)  
            self.rear += <span class="hljs-number">1</span>
</code></pre>
    <p class="normal">Here, we first <a id="_idIndexMarker440"/>check whether the queue is full by comparing the maximum capacity of the queue with the position of the <code class="inlineCode">rear</code> index. Further, if there is space in the queue, we use the <code class="inlineCode">append</code> method of the <code class="inlineCode">List</code> class to add the data at the end of the queue and increase the rear pointer by <code class="inlineCode">1</code>.</p>
    <p class="normal">To create a queue using the <code class="inlineCode">ListQueue</code> class, we use the following code:</p>
    <pre class="programlisting code"><code class="hljs-code">q= ListQueue()
q.enqueue(<span class="hljs-number">20</span>)
q.enqueue(<span class="hljs-number">30</span>)
q.enqueue(<span class="hljs-number">40</span>)
q.enqueue(<span class="hljs-number">50</span>)
<span class="hljs-built_in">print</span>(q.items)
</code></pre>
    <p class="normal">The output <a id="_idIndexMarker441"/>of the above code is as follows:</p>
    <pre class="programlisting con"><code class="hljs-con">Queue is full
[20, 30, 40]
</code></pre>
    <p class="normal">In the above code, we add can a maximum of three data elements since we have set the maximum capacity of the queue to be <code class="inlineCode">3</code>. After adding three elements, when we try to add another new element, we get a message that the queue is full.</p>
    <h3 id="_idParaDest-121" class="heading-3">The dequeue operation</h3>
    <p class="normal">The <code class="inlineCode">dequeue</code> operation is used to read and delete items from the queue. This method returns the <a id="_idIndexMarker442"/>front item from the queue and deletes it. Consider the example of dequeuing elements from the queue shown in <em class="italic">Figure 5.14</em>. Here, we have a queue containing elements <code class="inlineCode">{3, 11, 7, 1, 4, 2}</code>. In order to dequeue any element from this queue, the element inserted first will be removed first, so the item <code class="inlineCode">3</code> is removed. When we dequeue any element from the queue, we also decrease the <code class="inlineCode">rear</code> pointer by 1:</p>
    <figure class="mediaobject"><img src="../Images/B17217_05_14.png" alt=""/></figure>
    <p class="packt_figref">Figure 5.14. Example of a dequeue operation on a queue</p>
    <p class="normal">The following is the implementation of the <code class="inlineCode">dequeue</code> method, which should be defined in the <code class="inlineCode">ListQueue</code> class:</p>
    <pre class="programlisting code"><code class="hljs-code">    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">dequeue</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">):</span>
        <span class="hljs-keyword">if</span> self.front == self.rear:
            <span class="hljs-built_in">print</span>(<span class="hljs-string">"</span><span class="hljs-string">Queue is empty"</span>)
        <span class="hljs-keyword">else</span>:
            data = self.items.pop(<span class="hljs-number">0</span>)    <span class="hljs-comment"># delete the item from front end of the queue        </span>
            self.rear -= <span class="hljs-number">1</span>
            <span class="hljs-keyword">return</span> data
</code></pre>
    <p class="normal">In the <a id="_idIndexMarker443"/>above code, we firstly check whether the queue is already empty by comparing the front and rear pointers. If both rear and front pointers are same, it means the queue is empty. If there are some elements in the queue, we use the <code class="inlineCode">pop</code> method to dequeue an element. The Python <code class="inlineCode">List</code> class has a method called <code class="inlineCode">pop()</code>. The <code class="inlineCode">pop</code> method does the following:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Deletes the last item from the list</li>
      <li class="numberedList">Returns the deleted item from the list back to the user or code that called it</li>
    </ol>
    <p class="normal">The item at the first position pointed to by the front variable is popped and saved in the <code class="inlineCode">data</code> variable. We also decrease the rear variable by <code class="inlineCode">1</code>, since one data item has been deleted from the queue. Finally, in the last line of the method, the data is returned.</p>
    <p class="normal">To dequeue any element from an existing queue (say items <code class="inlineCode">{20, 30, 40}</code>), we use the following code:</p>
    <pre class="programlisting code"><code class="hljs-code">data = q.dequeue()
<span class="hljs-built_in">print</span>(data)
<span class="hljs-built_in">print</span>(q.items)
</code></pre>
    <p class="normal">The output of the above code is as follows:</p>
    <pre class="programlisting con"><code class="hljs-con">20
[30, 40]
</code></pre>
    <p class="normal">In the above code, when we dequeue an element from the queue, we get the element 20, which was the first added.</p>
    <p class="normal">The limitation of this approach to queue implementation is that the length of the queue is fixed, which may be not desirable for an efficient implementation of a queue. Now, let’s discuss the linked list-based implementation of queues.</p>
    <h2 id="_idParaDest-122" class="heading-2">Linked list based queues</h2>
    <p class="normal">A queue data structure can also be implemented using any linked list, such as singly-linked or <a id="_idIndexMarker444"/>doubly-linked lists. We already discussed the implementation of singly or doubly linked lists in the previous <em class="chapterRef">Chapter 4</em>, <em class="italic">Linked Lists</em>. We implement <a id="_idIndexMarker445"/>queues using linked lists that follow the <strong class="keyWord">FIFO</strong> property of the queue data structure.</p>
    <p class="normal">Let us discuss the implementation of a queue using a doubly-linked list. For this, we start with the implementation of the <code class="inlineCode">node</code> class the same as the <code class="inlineCode">node</code> we defined when we discussed doubly-linked lists in the previous <em class="chapterRef">Chapter 4</em>, <em class="italic">Linked Lists</em>. Moreover, the <code class="inlineCode">Queue</code> class is very similar to that of the doubly-linked list class. Here, we have <code class="inlineCode">head</code> and <code class="inlineCode">tail</code> pointers, where <code class="inlineCode">tail</code> points to the end of the queue (the rear end) that will be used for adding new elements, and the <code class="inlineCode">head</code> pointer points to the start of the queue (the front end) that will be used for dequeuing the elements from the queue. The implementation of the <code class="inlineCode">Queue</code> class is shown in the following code:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">Node</span><span class="hljs-class">(</span><span class="hljs-built_in">object</span><span class="hljs-class">):</span>
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">__init__</span><span class="hljs-function">(</span><span class="hljs-params">self, data=</span><span class="hljs-literal">None</span><span class="hljs-params">, </span><span class="hljs-built_in">next</span><span class="hljs-params">=</span><span class="hljs-literal">None</span><span class="hljs-params">, prev=</span><span class="hljs-literal">None</span><span class="hljs-function">):</span>
        self.data = data
        self.<span class="hljs-built_in">next</span> = <span class="hljs-built_in">next</span>
        self.prev = prev
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">Queue</span><span class="hljs-class">:</span> 
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">__init__</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">):</span> 
        self.head = <span class="hljs-literal">None</span> 
        self.tail = <span class="hljs-literal">None</span> 
        self.count = <span class="hljs-number">0</span> 
</code></pre>
    <p class="normal">Initially, the <code class="inlineCode">self.head</code> and <code class="inlineCode">self.tail</code> pointers are set to <code class="inlineCode">None</code> upon creation of an instance of the <code class="inlineCode">Queue</code> class. To keep a count of the number of nodes in <code class="inlineCode">Queue</code>, the <code class="inlineCode">count</code> instance variable is also maintained here and initially set to <code class="inlineCode">0</code>.</p>
    <h3 id="_idParaDest-123" class="heading-3">The enqueue operation</h3>
    <p class="normal">Elements are added to a <code class="inlineCode">Queue</code> object via the <code class="inlineCode">enqueue</code> method. The data elements are added <a id="_idIndexMarker446"/>through nodes. The <code class="inlineCode">enqueue</code> method code is very similar to the <code class="inlineCode">append</code> operation of the doubly-linked list that we discussed in <em class="chapterRef">Chapter 4, </em><em class="italic">Linked Lists</em>.</p>
    <p class="normal">The enqueue operation creates a node from the data passed to it and appends it to the <code class="inlineCode">tail</code> of the queue. </p>
    <p class="normal">Firstly, we check if the new node to be enqueued is the first node, and whether the queue is empty or not. If it is empty, the new node becomes the first node of the queue, as shown in <em class="italic">Figure 5.15</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17217_05_15.png" alt=""/></figure>
    <p class="packt_figref">Figure 5.15: Illustration of enqueuing a new node in an empty queue</p>
    <p class="normal">If the queue is not empty, the new node is appended to the rear end of the queue. In order to <a id="_idIndexMarker447"/>do this and enqueue an element to an existing queue, we append the node by updating three links: (1) the previous pointer of the new node should point to the tail of the queue, (2) the next pointer of the tail node should point to the new node, and (3) the tail pointer should be updated to the new node. All these links are shown in <em class="italic">Figure 5.16</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17217_05_16.png" alt=""/></figure>
    <p class="packt_figref">Figure 5.16: Illustration of links to be updated for an enqueue operation in a queue</p>
    <p class="normal">The <code class="inlineCode">enqueue</code> operation is implemented in the <code class="inlineCode">Queue</code> class, as shown in the following code:</p>
    <pre class="programlisting code"><code class="hljs-code">    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">enqueue</span><span class="hljs-function">(</span><span class="hljs-params">self, data</span><span class="hljs-function">):</span> 
        new_node = Node(data, <span class="hljs-literal">None</span>, <span class="hljs-literal">None</span>) 
        <span class="hljs-keyword">if</span> self.head == <span class="hljs-literal">None</span>: 
            self.head = new_node 
            self.tail = self.head 
        <span class="hljs-keyword">else</span>: 
            new_node.prev = self.tail 
            self.tail.<span class="hljs-built_in">next</span> = new_node 
            self.tail = new_node 
        self.count += <span class="hljs-number">1</span>
</code></pre>
    <p class="normal">In the above code, we first check whether the queue is empty or not. If <code class="inlineCode">head</code> points to <code class="inlineCode">None</code>, this means the queue is empty. If it is empty, the new node is made the first node of the queue, and we make both <code class="inlineCode">self.head</code> and <code class="inlineCode">self.tail</code> point to the newly created node. If the <a id="_idIndexMarker448"/>queue is not empty, we append the new node to the rear of the queue by updating the three links shown in <em class="italic">Figure 5.16</em>. Finally, the total count of elements in the queue is increased by the line <code class="inlineCode">self.count += 1</code>.</p>
    <p class="normal">The worst-case time complexity of an <code class="inlineCode">enqueue</code> operation on the queue is <code class="inlineCode">O(1)</code>, since any item can be appended directly through the <code class="inlineCode">tail</code> pointer in constant time.</p>
    <h3 id="_idParaDest-124" class="heading-3">The dequeue operation</h3>
    <p class="normal">The other <a id="_idIndexMarker449"/>operation that makes a doubly-linked list behave like a queue is the <code class="inlineCode">dequeue</code> method. This method removes the node at the front of the queue, as shown in <em class="italic">Figure 5.17</em>. Here, we first check whether the dequeuing element is the last node in the queue, and if so, we will make the queue empty after the <code class="inlineCode">dequeue</code> operation. If this is not the case, we dequeue the first element by updating the front/head pointer to the next node and the previous pointer of the new head to <code class="inlineCode">None</code>, as shown in <em class="italic">Figure 5.17</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17217_05_17.png" alt=""/></figure>
    <p class="packt_figref">Figure 5.17: Illustration of the dequeue operation on a queue </p>
    <p class="normal">The implementation of the <code class="inlineCode">dequeue</code> operation on a queue is very similar to deleting the first element from the given doubly-linked list, as the following code for the <code class="inlineCode">dequeue</code> operation shows:</p>
    <pre class="programlisting code"><code class="hljs-code">    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">dequeue</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">):</span> 
        <span class="hljs-keyword">if</span> self.count == <span class="hljs-number">1</span>: 
            self.count -= <span class="hljs-number">1</span> 
            self.head = <span class="hljs-literal">None</span> 
            self.tail = <span class="hljs-literal">None</span> 
        <span class="hljs-keyword">elif</span> self.count &gt; <span class="hljs-number">1</span>: 
            self.head = self.head.<span class="hljs-built_in">next</span> 
            self.head.prev = <span class="hljs-literal">None</span> 
        <span class="hljs-keyword">elif</span> self.count &lt;<span class="hljs-number">1</span>:
            <span class="hljs-built_in">print</span>(<span class="hljs-string">"Queue is empty"</span>)
        self.count -= <span class="hljs-number">1</span>
</code></pre>
    <p class="normal">In order <a id="_idIndexMarker450"/>to dequeue any element from the queue, we firstly check the number of items in the queue using the <code class="inlineCode">self.count</code> variable. If the <code class="inlineCode">self.count</code> variable is equal to <code class="inlineCode">1</code>, it means the dequeuing element is the last element, and we update the head and tail pointers to <code class="inlineCode">None</code>.</p>
    <p class="normal">If the queue has many nodes, then the head pointer is shifted to point to the next node after <code class="inlineCode">self.head</code> by updating the two links shown in <em class="italic">Figure 5.17</em>. We also check whether there is an item left in the queue, and if not, then a message is printed that the queue is empty. Finally, the <code class="inlineCode">self.count</code> variable is decremented by <code class="inlineCode">1</code>.</p>
    <p class="normal">The worst-case time complexity of a dequeue operation in the queue is <code class="inlineCode">O(1)</code>, since any item can be directly removed via the <code class="inlineCode">head</code> pointer in constant time.</p>
    <h2 id="_idParaDest-125" class="heading-2">Stack-based queues</h2>
    <p class="normal">A queue <a id="_idIndexMarker451"/>is a linear data structure in which enqueue operations <a id="_idIndexMarker452"/>are performed from one end and deletion (dequeue) operations are performed from the other end following the <strong class="keyWord">FIFO</strong> principle. There are two methods to implement queues using stacks:</p>
    <ul>
      <li class="bulletList">When the dequeue operation is costly</li>
      <li class="bulletList">When the enqueue operation is costly</li>
    </ul>
    <h3 id="_idParaDest-126" class="heading-3">Approach 1: When the dequeue operation is costly</h3>
    <p class="normal">We use two stacks for the implementation of the queue. In this approach, the enqueue operation <a id="_idIndexMarker453"/>is straightforward. A new element can be enqueued in the queue using the push operation on the first of the two stacks (in other words, Stack-1) used for the implementation of the queue. </p>
    <p class="normal">The enqueue operation is depicted in <em class="italic">Figure 5.18</em>, showing an example of enqueuing elements <code class="inlineCode">{23, 13, 11}</code> to the queue:</p>
    <figure class="mediaobject"><img src="../Images/B17217_05_18.png" alt=""/></figure>
    <p class="packt_figref">Figure 5.18: Illustration of an enqueue operation in the queue using approach 1</p>
    <p class="normal">Further more, the dequeue operation can be implemented with two stacks (Stack-1 and Stack-2) using the following steps:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Firstly, the elements are removed (popped off) from Stack-1, and then one by one all the elements are added (pushed) to Stack-2.</li>
      <li class="numberedList">The topmost data element will be popped off Stack-2 and will be returned as the desired element.</li>
      <li class="numberedList">Finally, the remaining elements are popped off Stack-2 one by one and then pushed again to Stack-1.</li>
    </ol>
    <p class="normal">Let’s look at an example<a id="_idIndexMarker454"/> to help understand this concept. Let’s say we have three elements stored in the queue <code class="inlineCode">{23, 13, 11}</code>, and now we want to dequeue an element from this queue. The complete process is shown in <em class="italic">Figure 5.19</em> following the above three steps. As you might notice, this implementation follows the <strong class="keyWord">FIFO</strong> property of queues and hence 23 is returned, as it was added first:</p>
    <figure class="mediaobject"><img src="../Images/B17217_05_19.png" alt=""/></figure>
    <p class="packt_figref">Figure 5.19: Illustration of a dequeue operation in the queue using approach 1</p>
    <p class="normal">The worst-case time complexity of enqueue operations is <code class="inlineCode">O(1)</code>, since any element can be added directly to the first stack, and the time complexity of the dequeue operation is <code class="inlineCode">O(n)</code>, since all elements are accessed and transferred from Stack-1 to Stack-2.</p>
    <h3 id="_idParaDest-127" class="heading-3">Approach 2: When the enqueue operation is costly</h3>
    <p class="normal">In this method, the enqueue operation is quite similar to the dequeue operation of the previous <a id="_idIndexMarker455"/>approach we just discussed, and the dequeue operation is likewise similar to the previous enqueue operation.</p>
    <p class="normal">In order to implement the enqueue operation, we follow the steps:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Move all the elements from Stack-1 to Stack-2.</li>
      <li class="numberedList">Push the element we want to enqueue to Stack-2.</li>
    </ol>
    <p class="normal">Move all the elements from Stack-2 to Stack-1 one by one. Pop the elements from Stack-2 and push them to Stack-1.</p>
    <p class="normal">Let’s take an example to understand this concept. Let’s say we want to enqueue three elements <code class="inlineCode">{23, 13, 11}</code> in the queue one by one. We do this by following the above three steps, as shown in <em class="italic">Figure 5.20</em>, <em class="italic">Figure 5.21</em>, and <em class="italic">Figure 5.22</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17217_05_20.png" alt=""/></figure>
    <p class="packt_figref">Figure 5.20: Enqueueing element 23 to an empty queue using approach 2</p>
    <figure class="mediaobject"><img src="../Images/B17217_05_21.png" alt=""/></figure>
    <p class="packt_figref">Figure 5.21: Enqueueing element 13 to the existing queue using approach 2</p>
    <figure class="mediaobject"><img src="../Images/B17217_05_22.png" alt=""/></figure>
    <p class="packt_figref">Figure 5.22: Enqueueing element 11 to the queue using approach 2</p>
    <p class="normal">The dequeue <a id="_idIndexMarker456"/>operation can be directly implemented by applying a pop operation to Stack-1. Let’s take an example to understand this. Assuming we have already enqueued three elements, and we want to apply the dequeue operation, we can simply pop the top element off the stack, as shown in <em class="italic">Figure 5.23</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17217_05_23.png" alt=""/></figure>
    <p class="packt_figref">Figure 5.23: Illustration of a dequeue operation on a queue using approach 2</p>
    <p class="normal">In this second approach, the time complexity for the enqueue operation is <code class="inlineCode">O(n)</code>, and for the dequeue operation, it is <code class="inlineCode">O(1)</code>.</p>
    <p class="normal">Next, we discuss the implementation of a queue using two stacks using approach-1, in which the dequeue <a id="_idIndexMarker457"/>operation is costly. In order to implement queues using two stacks, we initially set two stack instance variables to create an empty queue upon initialization. The stacks, in this case, are simply Python lists that allow us to call the <code class="inlineCode">push</code> and <code class="inlineCode">pop</code> methods on them, which allow us to get the functionality of the <code class="inlineCode">enqueue</code> and <code class="inlineCode">dequeue</code> operations. Here is the <code class="inlineCode">Queue</code> class:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">Queue</span><span class="hljs-class">:</span> 
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">__init__</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">):</span> 
        self.Stack1 = [] 
        self.Stack2 = [] 
</code></pre>
    <p class="normal"><code class="inlineCode">Stack1</code> is only used to store elements that are added to the queue. No other operation can be performed on this stack.</p>
    <h3 id="_idParaDest-128" class="heading-3">Enqueue operation</h3>
    <p class="normal">The <code class="inlineCode">enqueue</code> method <a id="_idIndexMarker458"/>is used to add items to the queue. This method only receives the <code class="inlineCode">data</code> that is to be appended to the queue. This data is then passed to the <code class="inlineCode">append</code> method of <code class="inlineCode">Stack1</code> in the <code class="inlineCode">Queue</code> class. Further, the <code class="inlineCode">append</code> method is used to mimic the <code class="inlineCode">push</code> operation, which pushes elements to the top of the stack. The following code is the implementation of <code class="inlineCode">enqueue</code> using the stack in Python, which should be defined in the <code class="inlineCode">Queue</code> class:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">enqueue</span><span class="hljs-function">(</span><span class="hljs-params">self, data</span><span class="hljs-function">):</span> 
    self.Stack1.append(data) 
</code></pre>
    <p class="normal">To enqueue <a id="_idIndexMarker459"/>data onto <code class="inlineCode">Stack1</code>, the following code does the job:</p>
    <pre class="programlisting code"><code class="hljs-code">queue = Queue() 
queue.enqueue(<span class="hljs-number">23</span>) 
queue.enqueue(<span class="hljs-number">13</span>) 
queue.enqueue(<span class="hljs-number">11</span>) 
<span class="hljs-built_in">print</span>(queue.Stack1)
</code></pre>
    <p class="normal">The output of <code class="inlineCode">Stack1</code> on the queue is as follows:</p>
    <pre class="programlisting con"><code class="hljs-con">[23, 13, 11]
</code></pre>
    <p class="normal">Next, we will examine the implementation of the <code class="inlineCode">dequeue</code> operation.</p>
    <h3 id="_idParaDest-129" class="heading-3">Dequeue operation</h3>
    <p class="normal">The <code class="inlineCode">dequeue</code> operation is used to delete the elements from the queue in the same order in which <a id="_idIndexMarker460"/>the items were added, according to the <strong class="keyWord">FIFO</strong> principle. New elements are added to the queue in <code class="inlineCode">Stack1</code>. Further, we use another stack, that is, <code class="inlineCode">Stack2</code>, to delete the elements from the queue. The delete (dequeue) operation will only be performed through <code class="inlineCode">Stack2</code>. To better understand how <code class="inlineCode">Stack2</code> can be used to delete the items from the queue, let us consider the following example.</p>
    <p class="normal">Initially, assume that <code class="inlineCode">Stack2</code> was filled with the elements <strong class="keyWord">5</strong>, <strong class="keyWord">6</strong>, and <strong class="keyWord">7</strong>, as shown in <em class="italic">Figure 5.24</em>:</p>
    <figure class="mediaobject"><img src="../Images/B17217_05_24.png" alt=""/></figure>
    <p class="packt_figref">Figure 5.24. Example of Stack1 in a queue</p>
    <p class="normal">Next, we check if the <code class="inlineCode">Stack2</code> is empty or not. As it is empty at the start, we move all the elements <a id="_idIndexMarker461"/>delete from <code class="inlineCode">Stack1</code> to <code class="inlineCode">Stack2</code> using the <code class="inlineCode">pop</code> operation on <code class="inlineCode">Stack1</code> for all the element and then push them to <code class="inlineCode">Stack2</code>. Now, <code class="inlineCode">Stack1</code> becomes empty and <code class="inlineCode">Stack2</code> has all the elements. We show this in <em class="italic">Figure 5.25</em> for more clarity:</p>
    <figure class="mediaobject"><img src="../Images/B17217_05_25.png" alt=""/></figure>
    <p class="packt_figref">Figure 5.25. Demonstration of Stack1 and Stack2 in a queue</p>
    <p class="normal">Now, if the <code class="inlineCode">Stack</code> is not empty, in order to pop an element from this queue, we apply the <code class="inlineCode">pop</code> operation to <code class="inlineCode">Stack2</code>, and we get the element <code class="inlineCode">5</code>, which is correct as it was added first and should be the first element to be popped off from the queue.</p>
    <p class="normal">Here is the implementation of the <code class="inlineCode">dequeue</code> method for the queue, which should be defined in the <code class="inlineCode">Queue</code> class:</p>
    <pre class="programlisting code"><code class="hljs-code">    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">dequeue</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">):</span>   
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.Stack2:  
            <span class="hljs-keyword">while</span> self.Stack1:  
                self.Stack2.append(self.Stack1.pop())  
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.Stack2:
            <span class="hljs-built_in">print</span>(<span class="hljs-string">"No element to dequeue"</span>)
            <span class="hljs-keyword">return</span>
        <span class="hljs-keyword">return</span> self.Stack2.pop()
</code></pre>
    <p class="normal">The <code class="inlineCode">if</code> statement first checks whether <code class="inlineCode">Stack2</code> is empty. If it is not empty, we proceed to <a id="_idIndexMarker462"/>remove the element at the front of the queue using the <code class="inlineCode">pop</code> method, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">return</span> self.Stack2.pop() 
</code></pre>
    <p class="normal">If <code class="inlineCode">Stack2</code> is empty, all the elements of <code class="inlineCode">Stack1</code> are moved to <code class="inlineCode">Stack2</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">while</span> self.Stack1: 
    self.Stack2.append(self.Stack1.pop()) 
</code></pre>
    <p class="normal">The <code class="inlineCode">while</code> loop will continue to be executed as long as there are elements in <code class="inlineCode">Stack1</code>.</p>
    <p class="normal">The <code class="inlineCode">self.Stack1.pop()</code> statement will remove the last element added to <code class="inlineCode">Stack1</code> and immediately pass the popped data to the <code class="inlineCode">self.Stack2.append()</code> method.</p>
    <p class="normal">Let us consider some example code to understand the operations on the queue. We firstly use the <code class="inlineCode">Queue</code> implementation to add three items to the queue, that is, <code class="inlineCode">5</code>, <code class="inlineCode">6</code>, and <code class="inlineCode">7</code>. Next, we apply <code class="inlineCode">dequeue</code> operations to remove items from the queue using the following code:</p>
    <pre class="programlisting code"><code class="hljs-code">queue = Queue()  
queue.enqueue(<span class="hljs-number">23</span>)  
queue.enqueue(<span class="hljs-number">13</span>)  
queue.enqueue(<span class="hljs-number">11</span>)  
<span class="hljs-built_in">print</span>(queue.Stack1) 
 
queue.dequeue()    
<span class="hljs-built_in">print</span>(queue.Stack2)
</code></pre>
    <p class="normal">The output for the preceding code is as follows:</p>
    <pre class="programlisting con"><code class="hljs-con"> [23, 13, 11] 
 [13, 11] 
 
</code></pre>
    <p class="normal">The preceding code snippet firstly adds elements to a queue and prints out the elements within the queue. Next, the <code class="inlineCode">dequeue</code> method is called, after which a change in the number of elements is observed when the queue is printed out again.</p>
    <p class="normal">The enqueue and dequeue operations on the queue data structure using a stack with approach 1 have time complexities of <code class="inlineCode">O(1)</code>, and <code class="inlineCode">O(n)</code> respectively. The reason for this is that the <a id="_idIndexMarker463"/>enqueue operation is straightforward as a new element can be appended directly, whereas in the dequeue operation, all the n elements need to be accessed and moved to the other stack.</p>
    <p class="normal">Overall, the linked list-based implementation is the most efficient since both the enqueue and dequeue operations can be performed in <code class="inlineCode">O(1)</code> time and there is no constraint on the size of the queue. In the stack-based implementation of queues, one of the operations is costly, be it enqueue or dequeue.</p>
    <h2 id="_idParaDest-130" class="heading-2">Applications of queues</h2>
    <p class="normal">Queues can be used to implement a variety of functionalities in many real computer-based applications. For instance, instead of providing each computer on a network with its own printer, a network <a id="_idIndexMarker464"/>of computers can be made to share one printer by queuing what each computer wants to print. When the printer is ready to print, it will pick one of the items (usually called jobs) in the queue to print out. It will print the command from the computer that has given the command first and will choose the following jobs in the order in which they were submitted by the different computers.</p>
    <p class="normal">Operating systems also queue processes to be executed by the CPU. Let’s create an application that makes use of a queue to create a bare-bones media player.</p>
    <p class="normal">Most music player software allows users to add songs to a playlist. Upon hitting the play button, all the songs in the main playlist are played one after the other. Sequential playing of the songs can be implemented with queues because the first song to be queued is the first song that is to be played. This aligns with the <strong class="keyWord">FIFO</strong> acronym. We will implement our own playlist queue to play songs in the <strong class="keyWord">FIFO</strong> manner.</p>
    <p class="normal">Our media player queue will only allow for the addition of tracks and a way to play all the tracks in the queue. In a full-blown music player, threads would be used to improve how the queue is interacted with, while the music player continues to be used to select the next song to be played, paused, or even stopped.</p>
    <p class="normal">The <code class="inlineCode">track</code> class will simulate a musical track:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">from</span> random <span class="hljs-keyword">import</span> randint 
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">Track</span><span class="hljs-class">:</span> 
    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">__init__</span><span class="hljs-function">(</span><span class="hljs-params">self, title=</span><span class="hljs-literal">None</span><span class="hljs-function">):</span> 
        self.title = title 
        self.length = randint(<span class="hljs-number">5</span>, <span class="hljs-number">10</span>) 
</code></pre>
    <p class="normal">Each track holds a reference to the title of the song and also the length of the song. The length of the song <a id="_idIndexMarker465"/>is a random number between <code class="inlineCode">5</code> and <code class="inlineCode">10</code>. The <code class="inlineCode">random</code> module in Python provides the <code class="inlineCode">randint</code> function to enable us to generate random numbers. The class represents any MP3 track or file that contains music. The random length of a track is used to simulate the number of seconds it takes to play a track.</p>
    <p class="normal">To create a few tracks and print out their lengths, we do the following:</p>
    <pre class="programlisting code"><code class="hljs-code">track1 = Track(<span class="hljs-string">"white whistle"</span>) 
track2 = Track(<span class="hljs-string">"butter butter"</span>) 
<span class="hljs-built_in">print</span>(track1.length) 
<span class="hljs-built_in">print</span>(track2.length) 
</code></pre>
    <p class="normal">The output of the preceding code is as follows:</p>
    <pre class="programlisting con"><code class="hljs-con">6
7
</code></pre>
    <p class="normal">Your output may be different depending on the random length generated for the two tracks.</p>
    <p class="normal">Now, let’s create our queue using inheritance. We simply inherit from the <code class="inlineCode">Queue</code> class:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> time 
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">MediaPlayerQueue</span><span class="hljs-class">(</span><span class="hljs-params">Queue</span><span class="hljs-class">):</span> 
</code></pre>
    <p class="normal">To add tracks to the queue, an <code class="inlineCode">add_track</code> method is created in the <code class="inlineCode">MediaPlayerQueue</code> class:</p>
    <pre class="programlisting code"><code class="hljs-code">    <span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">add_track</span><span class="hljs-function">(</span><span class="hljs-params">self, track</span><span class="hljs-function">):</span>
        self.enqueue(track) 
</code></pre>
    <p class="normal">The method passes a <code class="inlineCode">track</code> object to the <code class="inlineCode">enqueue</code> method of the queue <code class="inlineCode">super</code> class. This will, in effect, create a <code class="inlineCode">Node</code> using the <code class="inlineCode">track</code> object (as the node’s data) and point either the tail if the queue is not empty, or both the head and tail if the queue is empty, to this new node.</p>
    <p class="normal">Assuming the tracks <a id="_idIndexMarker466"/>in the queue are played sequentially, from the first track added to the last (<strong class="keyWord">FIFO</strong>), then the <code class="inlineCode">play</code> function has to loop through the elements in the queue:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">def</span><span class="hljs-function"> </span><span class="hljs-title">play</span><span class="hljs-function">(</span><span class="hljs-params">self</span><span class="hljs-function">):</span>
        <span class="hljs-keyword">while</span> self.count &gt; <span class="hljs-number">0</span>:
            current_track_node = self.dequeue()
            <span class="hljs-built_in">print</span>(<span class="hljs-string">"Now playing {}"</span>.<span class="hljs-built_in">format</span>(current_track_node.data.title)) 
            time.sleep(current_track_node.data.length)
</code></pre>
    <p class="normal"><code class="inlineCode">self.count</code> keeps count of when a track is added to our queue and when tracks have been dequeued. If the queue is not empty, a call to the <code class="inlineCode">dequeue</code> method will return the node (which houses the <code class="inlineCode">track</code> object) at the front of the queue. The <code class="inlineCode">print</code> statement then accesses the title of the track through the <code class="inlineCode">data</code> attribute of the node. To further simulate the playing of a track, the <code class="inlineCode">time.sleep()</code> method halts program execution till the number of seconds for the track has elapsed:</p>
    <pre class="programlisting code"><code class="hljs-code">time.sleep(current_track_node.data.length)
</code></pre>
    <p class="normal">The media player queue is made up of nodes. When a track is added to the queue, the track is hidden in a newly <a id="_idIndexMarker467"/>created node and associated with the data attribute of the node. That explains why we access a node’s <code class="inlineCode">track</code> object through the data property of the node returned by the call to <code class="inlineCode">dequeue</code>.</p>
    <p class="normal">You can see that, instead of our <code class="inlineCode">node</code> object just storing any data, it stores tracks in this case.</p>
    <p class="normal">Let’s take our music player for a spin:</p>
    <pre class="programlisting code"><code class="hljs-code">track1 = Track(<span class="hljs-string">"white whistle"</span>) 
track2 = Track(<span class="hljs-string">"butter butter"</span>) 
track3 = Track(<span class="hljs-string">"Oh black star"</span>) 
track4 = Track(<span class="hljs-string">"Watch that chicken"</span>) 
track5 = Track(<span class="hljs-string">"Don't go"</span>) 
</code></pre>
    <p class="normal">We create five track objects with random words as titles, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-built_in">print</span>(track1.length) 
<span class="hljs-built_in">print</span>(track2.length) 
</code></pre>
    <p class="normal">The output is as follows:</p>
    <pre class="programlisting con"><code class="hljs-con"> 8
 9
</code></pre>
    <p class="normal">The output may be different from what you get on your machine due to the random length.</p>
    <p class="normal">Next, an instance of the <code class="inlineCode">MediaPlayerQueue</code> class is created using the following code snippet:</p>
    <pre class="programlisting code"><code class="hljs-code">media_player = MediaPlayerQueue()
</code></pre>
    <p class="normal">The tracks will <a id="_idIndexMarker468"/>be added, and the output of the <code class="inlineCode">play</code> function should print out the tracks being played in the same order in which we queued them:</p>
    <pre class="programlisting code"><code class="hljs-code">media_player.add_track(track1) 
media_player.add_track(track2) 
media_player.add_track(track3) 
media_player.add_track(track4) 
media_player.add_track(track5) 
media_player.play() 
</code></pre>
    <p class="normal">The output of the preceding code is as follows:</p>
    <pre class="programlisting con"><code class="hljs-con">    Now playing white whistle
    Now playing butter butter
    Now playing Oh black star
    Now playing Watch that chicken
    Now playing Don't go
</code></pre>
    <p class="normal">Upon execution of the program, it can be seen that the tracks are played in the order in which they were queued. When playing each track, the system also pauses for the number of seconds equal to the length of the track.</p>
    <h1 id="_idParaDest-131" class="heading-1">Summary</h1>
    <p class="normal">In this chapter, we discussed two important data structures, namely, stacks and queues. We have seen how these data structures closely mimic stacks and queues in the real world. Concrete implementations, together with their varying types, were explored. We later applied the concepts of stacks and queues to write real-life programs.</p>
    <p class="normal">We will consider trees in the next chapter. The major operations on trees will be discussed, along with the different spheres of application of this data structure.</p>
    <h1 id="_idParaDest-132" class="heading-1">Exercises</h1>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Which of the following options is a true queue implementation using linked lists?<ol class="alphabeticList" style="list-style-type: lower-alpha;">
          <li class="alphabeticList" value="1">If, in the enqueue operation, new data elements are added at the start of the list, then the dequeue operation must be performed from the end.</li>
          <li class="alphabeticList">If, in the enqueue operation, new data elements are added to the end of the list, then the enqueue operation must be performed from the start of the list.</li>
          <li class="alphabeticList">Both of the above.</li>
          <li class="alphabeticList">None of the above.</li>
        </ol>
      </li>
      <li class="numberedList">Assume a queue is implemented using a singly-linked list that has head and tail pointers. The enqueue operation is implemented at the head, and the dequeue operation is implemented at the tail of the queue. What will be the time complexity of the enqueue and dequeue operations?</li>
      <li class="numberedList">What is the minimum number of stacks required to implement a queue?</li>
      <li class="numberedList">The enqueue and dequeue operations in a queue are implemented efficiently using an array. What will be the time complexity for both of these operations?</li>
      <li class="numberedList">How can we print the data elements of a queue data structure in reverse order?</li>
    </ol>
    <h1 class="heading-1">Join our community on Discord</h1>
    <p class="normal">Join our community’s Discord space for discussions with the author and other readers: <a href="https://packt.link/MEvK4"><span class="url">https://packt.link/MEvK4</span></a></p>
    <p class="normal"><img src="../Images/QR_Code1421249772551223062.png" alt=""/></p>
  </div>
</body></html>