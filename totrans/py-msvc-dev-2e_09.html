<html><head></head><body>
  <div><h1 class="chapterNumber">9</h1>
    <h1 id="_idParaDest-152" class="chapterTitle">Packaging and Running Python</h1>
    <p class="normal">When the Python programming language was first released in the early 1990s, a Python application was run by pointing the Python scripts to the interpreter. Everything related to packaging, releasing, and distributing Python projects was done manually. There was no real standard back then, and each project had a long README on how to install it with all its dependencies.</p>
    <p class="normal">Bigger projects used system packaging tools to release their work—whether it was Debian packages, RPM packages for Red Hat Linux distributions, or MSI packages under Windows. Eventually, the Python modules from those projects all ended up in the <code class="Code-In-Text--PACKT-">site-packages</code> directory of the Python installation, sometimes after a compilation phase, if they had a C extension.</p>
    <p class="normal">The Python packaging ecosystem has evolved a lot since then. In 1998, <code class="Code-In-Text--PACKT-">Distutils</code> was added to the standard library to provide essential support to create installable distributions for Python projects. Since then, a lot of new tools have emerged from the community to improve how a Python project can be packaged, released, and distributed. This chapter is going to explain how to use the latest Python packaging tools for your microservices.</p>
    <p class="normal">The other hot topic around packaging is how it fits in with your day-to-day work. When building microservices-based software, you need to deal with many moving parts. When you are working in a particular microservice, you can get away with using the TDD and mocking approach most of the time, which we discussed in <em class="chapterRef">Chapter 3</em>, <em class="italic">Coding, Testing, and Documentation: the Virtuous Cycle</em>.</p>
    <p class="normal">However, if you want to do some realistic testing, and examine all the parts of the system, you need the whole stack running either locally or on a test cloud instance. Moreover, developing in such a context can be tedious if you need to reinstall new versions of your microservices all the time. This leads to one question in particular: <em class="italic">how can you correctly install the whole stack in your environment and develop in it?</em></p>
    <p class="normal">It also means you have to run all the microservices if you want to play with the app. In the case of Jeeves, having to open multiple different shells to run all the microservices is not something a developer would want to do every time they need to run the app.</p>
    <p class="normal">In this chapter, we are going to look at how we can leverage the packaging tools to run all microservices from the same environment, and then how to run them all from a single <strong class="keyword">Command-Line Interface</strong> (<strong class="keyword">CLI</strong>) by using a dedicated process manager. First, however, we will look at how to package your projects, and which tools should be utilized.</p>
    <h1 id="_idParaDest-153" class="title">The packaging toolchain</h1>
    <p class="normal">Python has come a long way<a id="_idIndexMarker553"/> since the days of those early packaging methods. Numerous <strong class="keyword">Python Enhancement Proposals</strong> (<strong class="keyword">PEPs</strong>) were written to improve how to install, release, and<a id="_idIndexMarker554"/> distribute Python projects.</p>
    <p class="normal"><code class="Code-In-Text--PACKT-">Distutils</code> had some flaws that made it a little tedious to release software. The biggest pain points were its lack of dependency management and the way it handled compilation and binary releases. For everything related to compiling, what worked well in the nineties started to get old-fashioned ten years later. No one in the core team made the library evolve due to lack of interest, and also because <code class="Code-In-Text--PACKT-">Distutils</code> was good enough to compile Python and most <a id="_idIndexMarker555"/>projects. People who needed advanced toolchains used other tools, like <code class="Code-In-Text--PACKT-">SCons</code> (<a href="http://scons.org/">http://scons.org/</a>).</p>
    <p class="normal">In any case, improving the toolchain was not an easy task because of the existing legacy system based on <code class="Code-In-Text--PACKT-">Distutils</code>. Starting a new packaging system from scratch was quite hard, since <code class="Code-In-Text--PACKT-">Distutils</code> was part of the standard library, but introducing backward-compatible changes was also hard to do properly. The improvements were made in between. Projects like <code class="Code-In-Text--PACKT-">Setuptools</code> and <code class="Code-In-Text--PACKT-">virtualenv</code> were created outside the standard library, and some changes were made directly in Python.</p>
    <p class="normal">As of the time of writing, you still find the scars from these changes, and it is still quite hard to know exactly how things should be done. For instance, the <code class="Code-In-Text--PACKT-">pyvenv</code> command was added in early versions of Python 3 and then removed in Python 3.6, but Python still ships with its virtual environment module, although there are also tools such as <code class="Code-In-Text--PACKT-">virtualenv</code> to help make life easier.</p>
    <p class="normal">The best bet is to use the tools that are developed and maintained outside the standard library, because their release cycle is shorter than Python's. In other words, a change in the standard library takes months to be released, whereas a change in a third-party project can be made available much faster. All third-party projects that are considered as being part of the de facto standard packaging toolchain are now all grouped under the <strong class="keyword">PyPA</strong> (<a href="https://www.pypa.io">https://www.pypa.io</a>) umbrella<a id="_idIndexMarker556"/> project.</p>
    <p class="normal">Besides developing the tools, <code class="Code-In-Text--PACKT-">PyPA</code> also works on improving the packaging standards through proposing PEPs for Python and developing its early specifications—refer to <a href="https://www.pypa.io/en/latest/roadmap/">https://www.pypa.io/en/latest/roadmap/</a>. There are often new tools and experiments in packaging and dependency management that let us learn new things whether or not they become popular. For this chapter, we will stick with the core, well-known tools.</p>
    <p class="normal">Before we start to look <a id="_idIndexMarker557"/>at the tools that should be used, we need to go through a few definitions to avoid any confusion.</p>
    <h2 id="_idParaDest-154" class="title">A few definitions</h2>
    <p class="normal">When we talk about packaging Python projects, a few terms can be confusing, because their definitions have evolved over time, and also because they can mean slightly different things outside the Python world. We need to define a Python package, a Python project, a Python library, and a Python application. They are defined as follows:</p>
    <ul>
      <li class="bullet">A <strong class="keyword">Python package</strong> is a directory<a id="_idIndexMarker558"/> tree containing Python modules. You can import it, and it is part of the module namespace.</li>
      <li class="bullet">A <strong class="keyword">Python project</strong> can contain<a id="_idIndexMarker559"/> several packages, modules, and other resources and is what you release. Each microservice you build with Flask is a Python project.</li>
      <li class="bullet">A <strong class="keyword">Python application</strong> is a Python <a id="_idIndexMarker560"/>project that can be directly used through a user interface. The user interface can be a command-line script or a web server.</li>
      <li class="bullet">Lastly, a <strong class="keyword">Python library</strong> is a specific<a id="_idIndexMarker561"/> kind of Python project that provides features to be used in other Python projects and has no direct end-user interface.</li>
    </ul>
    <p class="normal">The distinction between an application and a library can be quite vague, since some libraries sometimes offer some command-line tools to use some of their features, even if the first use case is to provide Python packages for other projects. Moreover, sometimes, a project that was a library becomes an application. </p>
    <p class="normal">To simplify the process, the best option is to make no distinction between applications and libraries. The only technical difference is that applications ship with more data files and console scripts.</p>
    <p class="normal">Now that we have defined the terminology around a Python package, project, application, and library, let's look at how projects are packaged.</p>
    <h2 id="_idParaDest-155" class="title">Packaging</h2>
    <p class="normal">When you package your Python project, there are three standard files you need to have alongside your <a id="_idIndexMarker562"/>Python packages:</p>
    <ul>
      <li class="bullet"><code class="Code-In-Text--PACKT-">pyproject.toml</code>: A configuration file for the project's build system</li>
      <li class="bullet"><code class="Code-In-Text--PACKT-">setup.py</code> or <code class="Code-In-Text--PACKT-">setup.cfg</code>: A special module that controls packaging and metadata about the project</li>
      <li class="bullet"><code class="Code-In-Text--PACKT-">requirements.txt</code>: A file listing dependencies</li>
    </ul>
    <p class="normal">Let's look at each one of them in detail.</p>
    <h3 id="_idParaDest-156" class="title">The setup.py file</h3>
    <p class="normal">The <code class="Code-In-Text--PACKT-">setup.py</code> file is what governs<a id="_idIndexMarker563"/> everything when you want to interact with a Python project. When the <code class="Code-In-Text--PACKT-">setup()</code> function is executed, it generates a static metadata file that follows the <code class="Code-In-Text--PACKT-">PEP 314</code> format. The metadata file holds all the metadata for the project, but you need to regenerate it via a <code class="Code-In-Text--PACKT-">setup()</code> call to get it to the Python environment you are using.</p>
    <p class="normal">The reason why you cannot use a static version is that the author of a project might have platform-specific code in <code class="Code-In-Text--PACKT-">setup.py</code>, which generates a different metadata file depending on the platform and Python versions. Relying on running a Python module to extract static information about a project has always been a problem. You need to make sure that the code in the module can run in the target Python interpreter. If you are going to make your microservices available to the community, you need to keep that in mind, as the installation happens in many different Python environments.</p>
    <p class="normal">A common mistake when creating the <code class="Code-In-Text--PACKT-">setup.py</code> file is to import your package into it when you have third-party dependencies. If a tool like <code class="Code-In-Text--PACKT-">pip</code> tries to read the metadata by running <code class="Code-In-Text--PACKT-">setup.py</code>, it might raise an import error before it has a chance to list all the dependencies to install. The only dependency you can afford to import directly in your <code class="Code-In-Text--PACKT-">setup.py</code> file is <code class="Code-In-Text--PACKT-">Setuptools</code>, because you can assume that anyone trying to install your project is likely to have it in their environment.</p>
    <p class="normal">Another important consideration is the metadata you want to include to describe your project. Your project can work with just a name, a version, a URL, and an author, but this is obviously not enough information to describe your project. Metadata fields are set through <code class="Code-In-Text--PACKT-">setup()</code> arguments. Some of them match directly with the name of the metadata, while some do not.</p>
    <p class="normal">The following is a useful set of arguments you could use for your microservices projects:</p>
    <ul>
      <li class="bullet"><code class="Code-In-Text--PACKT-">name</code>: The name of the package; should be short and lowercase</li>
      <li class="bullet"><code class="Code-In-Text--PACKT-">version</code>: The version of the project, as defined in <code class="Code-In-Text--PACKT-">PEP 440</code></li>
      <li class="bullet"><code class="Code-In-Text--PACKT-">url</code>: A URL for the project; can be its repository or home page</li>
      <li class="bullet"><code class="Code-In-Text--PACKT-">description</code>: One sentence to describe the project</li>
      <li class="bullet"><code class="Code-In-Text--PACKT-">long_description</code>: A reStructuredText or Markdown document</li>
      <li class="bullet"><code class="Code-In-Text--PACKT-">author</code> and <code class="Code-In-Text--PACKT-">author_email</code>: The name and email of the author—can be an organization</li>
      <li class="bullet"><code class="Code-In-Text--PACKT-">license</code>: The license used for the project (MIT, Apache2, GPL, and so on)</li>
      <li class="bullet"><code class="Code-In-Text--PACKT-">classifiers</code>: A list of classifiers picked from a fixed list, as defined in <code class="Code-In-Text--PACKT-">PEP 301</code></li>
      <li class="bullet"><code class="Code-In-Text--PACKT-">keywords</code>: Tags to <a id="_idIndexMarker564"/>describe your project—this is useful if you publish the project to the <strong class="keyword">Python Package Index</strong> (<strong class="keyword">PyPI</strong>)</li>
      <li class="bullet"><code class="Code-In-Text--PACKT-">packages</code>: A list of packages that your project includes—<code class="Code-In-Text--PACKT-">Setuptools</code> can populate that option automatically with the <code class="Code-In-Text--PACKT-">find_packages()</code> method</li>
      <li class="bullet"><code class="Code-In-Text--PACKT-">entry_points</code>: A list of <code class="Code-In-Text--PACKT-">Setuptools</code> hooks, like console scripts (this is a <code class="Code-In-Text--PACKT-">Setuptools</code> option)</li>
      <li class="bullet"><code class="Code-In-Text--PACKT-">include_package_data</code>: A flag that simplifies the inclusion of non-Python files</li>
      <li class="bullet"><code class="Code-In-Text--PACKT-">zip_safe</code>: A flag that prevents <code class="Code-In-Text--PACKT-">Setuptools</code> from installing the project as a ZIP file, which is a historical standard (executable eggs)</li>
    </ul>
    <p class="normal">If you are missing any critical<a id="_idIndexMarker565"/> options, then <code class="Code-In-Text--PACKT-">Setuptools</code> will provide information about the ones it needs when you try to use it. The following is an example of a <code class="Code-In-Text--PACKT-">setup.py</code> file that includes these options:</p>
    <pre class="programlisting code"><code class="hljs-code">    from setuptools import setup, find_packages
 
    with open("README.rst") as f:
        LONG_DESC = f.read()
 
    setup(
        name="MyProject",
        version="1.0.0",
        url="http://example.com",
        description="This is a cool microservice based on Quart.",
        long_description=LONG_DESC,
        long_description_content_type="text/x-rst",
        author="Simon",
        author_email="simon@example.com",
        license="MIT",
        classifiers=[
            "Development Status :: 3 - Alpha",
            "License :: OSI Approved :: MIT License",
            "Programming Language :: Python :: 3",
        ],
        keywords=["quart", "microservice"],
        packages=find_packages(),
        include_package_data=True,
        zip_safe=False,
        install_requires=["quart"],
    ) 
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">long_description</code> option is usually <a id="_idIndexMarker566"/>pulled from a <code class="Code-In-Text--PACKT-">README.rst</code> file, so you do not have to deal with including a large piece of reStructuredText string in your function.</p>
    <p class="normal">The <code class="Code-In-Text--PACKT-">Twine</code> project (<a href="https://pypi.org/project/twine/">https://pypi.org/project/twine/</a>)—which we will use later to upload packages to PyPI—has a<a id="_idIndexMarker567"/> check command to ensure the long description can be rendered properly. Adding this check to <strong class="keyword">Continuous Integration</strong> (<strong class="keyword">CI</strong>) as part of a standard test suite is a good idea, to <a id="_idIndexMarker568"/>ensure the documentation on PyPI is readable. The other benefit of separating the description is that it's automatically recognized, parsed, and displayed by most editors. For instance, GitHub uses it as your project landing page in your repository, while also offering an inline reStructuredText editor to change it directly from the browser. PyPI does the same to display the front page of the project.</p>
    <p class="normal">The <code class="Code-In-Text--PACKT-">license</code> field is freeform, as long as people can recognize the license being used. <a href="https://choosealicense.com/">https://choosealicense.com/</a> offers impartial advice about which open-source software license is most appropriate for you, if you plan to release the source code—and you should strongly consider it, as our progress through this book and the myriad of tools used have all been based on open-source projects, and adding more to the community helps everyone involved. In any case, you should add, alongside your <code class="Code-In-Text--PACKT-">setup.py</code> file, a <code class="Code-In-Text--PACKT-">LICENCE</code> file with the official text of that license. In open-source projects it is common practice now to also include a "Code Of Conduct," such as the <code class="Code-In-Text--PACKT-">Contributor Covenant</code>: <a href="https://www.contributor-covenant.org/">https://www.contributor-covenant.org/</a>.</p>
    <p class="normal">This is because working with people from around the world involves many different cultures and expectations, and being open about the nature of the community is another aspect that helps everyone.</p>
    <p class="normal">The classifiers option is probably the most painful one to write. You need to use strings from <a href="https://pypi.python.org/pypi?%3Aaction=list_classifiers">https://pypi.python.org/pypi?%3Aaction=list_classifiers</a> that classify your project. The three most common classifiers that developers use are the list of supported Python versions, the license (which duplicates and should match the license option), and the development status, which is a hint about the maturity of the project.</p>
    <p class="normal">The <code class="Code-In-Text--PACKT-">Trove</code> classifier is machine-parsable metadata that can be used by tools interacting with <code class="Code-In-Text--PACKT-">PyPI</code>. For example, the <code class="Code-In-Text--PACKT-">zc.buildout</code> tool looks for packages with the <code class="Code-In-Text--PACKT-">Framework :: Buildout :: Recipe</code> classifier. A list of <a id="_idIndexMarker569"/>valid classifiers is available at <a href="https://pypi.org/classifiers/">https://pypi.org/classifiers/</a>.</p>
    <p class="normal">Keywords are a good way to make <a id="_idIndexMarker570"/>your project visible if you publish it to the Python Package Index. For instance, if you are creating a <code class="Code-In-Text--PACKT-">Quart</code> microservice, you should use "quart" and "microservice" as keywords.</p>
    <p class="normal">The <code class="Code-In-Text--PACKT-">entry_points</code> section is an INI-like string that defines ways to interact with your Python module through callables—most commonly a console script. When you add functions in that section, a command-line script will be installed alongside the Python interpreter, and the function hooked to it via the entry point. This is a good way to create a CLI for your project. In the example, <code class="Code-In-Text--PACKT-">mycli</code> should be directly reachable in the shell when the project is installed. Lastly, <code class="Code-In-Text--PACKT-">install_requires</code> lists all the dependencies. It's a list of Python projects the project uses and can be used by projects like <code class="Code-In-Text--PACKT-">pip</code> when the installation occurs. The tool will grab them if they are published in PyPI and install them. It is also possible to read the dependencies from the file we will be discussing next, <code class="Code-In-Text--PACKT-">requirements.txt</code>, and to read the version from a separate text file—or JSON file—so that the version can be easily used in multiple places if it's needed in the release pipeline. Since the JSON module is part of the standard library, there is no extra dependency added by importing it.</p>
    <p class="normal">Once this <code class="Code-In-Text--PACKT-">setup.py</code> file is created, a good way to try it is by creating a local virtual environment.</p>
    <p class="normal">Assuming you have <code class="Code-In-Text--PACKT-">virtualenv</code> installed, and you run these commands in the directory containing the <code class="Code-In-Text--PACKT-">setup.py</code> file, it will create a few directories, including a <code class="Code-In-Text--PACKT-">bin</code> directory containing a local Python interpreter, and drop you into a local shell:</p>
    <pre class="programlisting con"><code class="hljs-con">$ python3 –m venv ./my-project-venv 
$ source ./my-project-venv/bin/activate 
(my-project-venv) $ 
</code></pre>
    <p class="normal">There are several helper tools to make managing your virtual environments easier, such as <code class="Code-In-Text--PACKT-">virtualenvwrapper</code> (<a href="https://virtualenvwrapper.readthedocs.io/en/latest/">https://virtualenvwrapper.readthedocs.io/en/latest/</a>), but we will keep to the core functionality with our examples.</p>
    <p class="normal">From here, running the <code class="Code-In-Text--PACKT-">pip install -e command</code> will install the project in editable mode. This command installs the project by reading its setup file, but unlike <code class="Code-In-Text--PACKT-">install</code>, the installation occurs in-place. Installing in-place means that you will be able to work directly on the Python modules in the project, and they will be linked to the local Python installation via its <code class="Code-In-Text--PACKT-">site-packages</code> directory.</p>
    <p class="normal">Using a regular <code class="Code-In-Text--PACKT-">install</code> call would have <a id="_idIndexMarker571"/>created copies of the files in the local <code class="Code-In-Text--PACKT-">site-packages</code> directory, and changing the source code would have had no impact on the installed version.</p>
    <p class="normal">The <code class="Code-In-Text--PACKT-">pip</code> call also generates a <code class="Code-In-Text--PACKT-">MyProject.egg-info</code> directory, which contains the metadata. pip generates version 1.1 of the metadata spec under the <code class="Code-In-Text--PACKT-">PKG-INFO</code> name:</p>
    <pre class="programlisting con"><code class="hljs-con">$ more MyProject.egg-info/PKG-INFO
Metadata-Version: 2.1
Name: MyProject
Version: 1.0.0
Summary: This is a cool microservice based on Quart.
Home-page: http://example.com
Author: Simon
Author-email: simon@example.com
License: MIT
Description: long description!
 
Keywords: quart,microservice
Platform: UNKNOWN
Classifier: Development Status :: 3 - Alpha
Classifier: License :: OSI Approved :: MIT License
Classifier: Programming Language :: Python :: 3
Description-Content-Type: text/x-rst
</code></pre>
    <p class="normal">This metadata file is what describes your project, and is used to register it to PyPI via other commands, as we will see later in the chapter.</p>
    <p class="normal">The pip call also pulls all the project dependencies by looking for them in PyPI on <a href="https://pypi.python.org/pypi">https://pypi.python.org/pypi</a> and installs them in the local <code class="Code-In-Text--PACKT-">site-packages</code>. Running this command is a good way to make sure everything works as expected.</p>
    <h3 id="_idParaDest-157" class="title">The requirements.txt file</h3>
    <p class="normal">One standard that emerged from<a id="_idIndexMarker572"/> the pip community is to use a <code class="Code-In-Text--PACKT-">requirements.txt</code> file, which lists all the project dependencies, but also proposes an extended syntax to install editable dependencies. Refer to <a href="https://pip.pypa.io/en/stable/cli/pip_install/#requirements-file-format">https://pip.pypa.io/en/stable/cli/pip_install/#requirements-file-format</a>.</p>
    <p class="normal">The following is an example of such a file:</p>
    <pre class="programlisting code"><code class="hljs-code">arrow 
python-dateutil 
pytz 
requests 
six 
stravalib 
units 
</code></pre>
    <p class="normal">Using this file has been widely<a id="_idIndexMarker573"/> adopted by the community, because it makes it easier to document your dependencies. You can create as many requirements files as you want in a project, and have your users call the <code class="Code-In-Text--PACKT-">pip install -r requirements.txt</code> command to install the packages described in them.</p>
    <p class="normal">For instance, you could have a <code class="Code-In-Text--PACKT-">dev-requirements.txt</code> file, which contains extra tools for development, and a <code class="Code-In-Text--PACKT-">prod-requirements.txt</code>, which has production-specific dependencies. The format allows inheritance to help you manage requirements files' collections.</p>
    <p class="normal">Using the <code class="Code-In-Text--PACKT-">requirements</code> files duplicates some of the information contained in the <code class="Code-In-Text--PACKT-">setup.py</code> file's <code class="Code-In-Text--PACKT-">install_requires</code> section. As noted earlier, we could read in the <code class="Code-In-Text--PACKT-">requirements.txt</code> file and include the data in <code class="Code-In-Text--PACKT-">setup.py</code>. Some developers deliberately keep these sources separate to distinguish between an application and a library, allowing a library more flexibility in its dependencies in order to co-operate with other installed libraries. This does mean keeping two sources of information up to date, which is often a source of confusion.</p>
    <p class="normal">As we said earlier in the chapter, we do not want to make our life complicated by having two different ways to describe Python project dependencies, since the distinction between an application and a library can be quite vague. To avoid duplicating the information in both places, there are some tools in the community that offer some syncing automation between <code class="Code-In-Text--PACKT-">setup.py</code> and requirements files.</p>
    <p class="normal">The <code class="Code-In-Text--PACKT-">pip-tools</code> (<a href="https://github.com/jazzband/pip-tools">https://github.com/jazzband/pip-tools</a>) tool is one of these utilities, and it generates a <code class="Code-In-Text--PACKT-">requirements.txt</code> file (or any other filename) via a <code class="Code-In-Text--PACKT-">pip-compile</code> CLI, as follows:</p>
    <pre class="programlisting con"><code class="hljs-con">$ pip install pip-tools 
... 
$ pip-compile 
#
# This file is autogenerated by pip-compile
# To update, run:
#
#	pip-compile
#
aiofiles==0.6.0
	# via quart
blinker==1.4
	# via quart
click==7.1.2
	# via quart
h11==0.12.0
	# via
	#   hypercorn
	#   wsproto
…
</code></pre>
    <p class="normal">With no other arguments, <code class="Code-In-Text--PACKT-">pip-compile</code> will examine <code class="Code-In-Text--PACKT-">setup.py</code>. It's also possible to pass it an unpinned<a id="_idIndexMarker574"/> version file, such as <code class="Code-In-Text--PACKT-">requirements.in</code> as a list of packages to use instead.</p>
    <p class="normal">Notice that all the dependencies are pinned—the version we want is in the file. This is always a good idea in a production environment, as we want our application to be reproducible. If we do not specify a version to install, then we will get whatever is the latest, and that may break our application. By specifying the version, we know that all the tests we have run will still be valid no matter how far in the future we deploy that version of our app.</p>
    <p class="normal">It's also a good idea to add the hash of the dependency to the <code class="Code-In-Text--PACKT-">requirements.txt</code> file, as this avoids any issue with someone uploading a package without updating the version number, or a malicious actor replacing an existing version of a package. These hashes will be compared to the downloaded files on installation, and are only used if they match:</p>
    <pre class="programlisting con"><code class="hljs-con">$ pip-compile —generate-hashes
#
# This file is autogenerated by pip-compile
# To update, run:
#
#	pip-compile —generate-hashes
#
aiofiles==0.6.0 \
	—hash=sha256:bd3019af67f83b739f8e4053c6c0512a7f545b9a8d91aaeab55e6e0f9d123c27 \
	—hash=sha256:e0281b157d3d5d59d803e3f4557dcc9a3dff28a4dd4829a9ff478adae50ca092
	# via quart
blinker==1.4 \
	—hash=sha256:471aee25f3992bd325afa3772f1063dbdbbca947a041b8b89466dc00d606f8b6
	# via quart
click==7.1.2 \
	—hash=sha256:d2b5255c7c6349bc1bd1e59e08cd12acbbd63ce649f2588755783aa94dfb6b1a \
	—hash=sha256:dacca89f4bfadd5de3d7489b7c8a566eee0d3676333fbb50030263894c38c0dc
	# via quart
</code></pre>
    <p class="normal">If you don't use <code class="Code-In-Text--PACKT-">pip-tools</code>, pip has a built-in command called <code class="Code-In-Text--PACKT-">freeze</code>, which you can use to generate a list of all the <a id="_idIndexMarker575"/>current versions that are installed in your Python virtual environment. Using <code class="Code-In-Text--PACKT-">pip freeze</code> without a virtual environment is likely to result in a lot of packages that have been used for other projects, rather than just your own work:</p>
    <pre class="programlisting con"><code class="hljs-con">$ pip freeze
aiofiles==0.6.0
blinker==1.4
click==7.1.2
h11==0.12.0
h2==4.0.0
hpack==4.0.0
…
... 
</code></pre>
    <p class="normal">The only problem when you pin your dependencies is when another project has the same dependencies, but is pinned with other versions. pip will complain and fail to meet both the requirements sets, and you will not be able to install everything. If you are producing a library, and you expect other people to use and add to their own list of dependencies, it is a good idea to specify a range of versions that you support, so that pip can try to sort out any dependency conflicts. For example:</p>
    <pre class="programlisting con"><code class="hljs-con">quart&gt;0.13.0,&lt;0.15.0
</code></pre>
    <p class="normal">It's also common practice to leave the dependencies unpinned in the <code class="Code-In-Text--PACKT-">setup.py</code> file and pin the <code class="Code-In-Text--PACKT-">requirements.txt</code> file. That way, pip can install the latest version for each package, and when you <a id="_idIndexMarker576"/>deploy, specifically in stage or production, you can refresh the versions by running the <code class="Code-In-Text--PACKT-">pip install -r requirements.txt</code> command. pip will then upgrade/downgrade all the dependencies to match the versions, and if you need to, you can tweak them in the requirements file.</p>
    <p class="normal">To summarize, defining dependencies should be done in each project's <code class="Code-In-Text--PACKT-">setup.py</code> file, and requirements files can be provided with pinned dependencies if you have a reproducible process to generate them from the <code class="Code-In-Text--PACKT-">setup.py</code> file to avoid duplication.</p>
    <p class="normal">The next useful file your projects could have is the <code class="Code-In-Text--PACKT-">MANIFEST.in</code> file.</p>
    <h3 id="_idParaDest-158" class="title">The MANIFEST.in file</h3>
    <p class="normal">When creating a source or<a id="_idIndexMarker577"/> binary release, <code class="Code-In-Text--PACKT-">Setuptools</code> will include all the package modules and data files, the <code class="Code-In-Text--PACKT-">setup.py</code> file, and a few other files automatically in the package archive. Files like <code class="Code-In-Text--PACKT-">pip requirements</code> will not be included. To add them to your distribution, you need to add a <code class="Code-In-Text--PACKT-">MANIFEST.in</code> file, which contains the list of files to include.</p>
    <p class="normal">The file follows a simple glob-like syntax, described at the following, where you refer to a file or a directory pattern and say whether you want to include or prune the matches: <a href="https://docs.python.org/3/distutils/commandref.html#creating-a-source-distribution-the-sdist-command">https://docs.python.org/3/distutils/commandref.html#creating-a-source-distribution-the-sdist-command</a>.</p>
    <p class="normal">Here's an example from Jeeves:</p>
    <pre class="programlisting code"><code class="hljs-code">include requirements.txt 
include README.rst 
include LICENSE 
recursive-include myservice *.ini 
recursive-include docs *.rst *.png *.svg *.css *.html conf.py 
prune docs/build/* 
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">docs/directory</code> containing the Sphinx doc will be integrated in the source distribution, but any artifact generated locally in <code class="Code-In-Text--PACKT-">docs/build/</code> when the doc is built will be pruned.</p>
    <p class="normal">Once you have the <code class="Code-In-Text--PACKT-">MANIFEST.in</code> file in place, all the files should be added in your distribution when your project is released.</p>
    <p class="normal">A typical microservice <a id="_idIndexMarker578"/>project, as described in this book, will have the following list of files:</p>
    <ul>
      <li class="bullet"><code class="Code-In-Text--PACKT-">setup.py</code>: The setup file</li>
      <li class="bullet"><code class="Code-In-Text--PACKT-">README.rst</code>: The content of the <code class="Code-In-Text--PACKT-">long_description</code> option</li>
      <li class="bullet"><code class="Code-In-Text--PACKT-">MANIFEST.in</code>: The MANIFEST template if it is needed</li>
      <li class="bullet">A code of conduct, if the code is an open-source project</li>
      <li class="bullet"><code class="Code-In-Text--PACKT-">requirements.txt</code>: pip requirement files generated from <code class="Code-In-Text--PACKT-">install_requires</code></li>
      <li class="bullet"><code class="Code-In-Text--PACKT-">docs/</code>: The Sphinx documentation</li>
      <li class="bullet">A directory containing the microservice code, which will typically be named after the microservice, or <code class="Code-In-Text--PACKT-">src/</code></li>
    </ul>
    <p class="normal">From there, releasing your project consists of creating a source distribution, which is basically an archive of this structure. If you have some C extensions, you can also create a binary distribution.</p>
    <p class="normal">Before we learn how to create those releases, let's look at how to pick version numbers for your microservices.</p>
    <h2 id="_idParaDest-159" class="title">Versioning</h2>
    <p class="normal">Python packaging<a id="_idIndexMarker579"/> tools do not enforce a specific versioning pattern, although the version field should be one that can be converted using the packaging module into a meaningful version. Let's discuss what counts as a meaningful version number. To understand a versioning scheme, an installer needs to know how to sort and compare versions. The installer needs to be able to parse the string and know whether a version is older than another one.</p>
    <p class="normal">Some software uses a scheme based on the date of release, like <code class="Code-In-Text--PACKT-">20210101</code> if your software was released on January 1,<a id="_idIndexMarker580"/> 2021. For some use cases this works perfectly well. If you are practicing <strong class="keyword">Continuous Deployment</strong> (<strong class="keyword">CD</strong>), where every change that reaches the release branch is pushed to production, then there may be such a large number of changes that fixed version numbers are hard to work with. In that sort of situation, a date-based version, or a version from the version control hash, may work well.</p>
    <p class="normal">Date- or commit-based versioning won't work very well if you do branched releases. For instance, if your software has a large change in behavior and you need to support the older version for a while as people transition, then having versions 1 and 2 makes things clear, but using dates in this situation will make some of your "version 1" releases appear as if they were more recent than some of the "version 2" releases, and confuse anyone trying to determine what they should install. Some software combines incremental versions and <a id="_idIndexMarker581"/>dates for that reason, but it became obvious that using dates was not the best way to handle branches.</p>
    <p class="normal">There is also the problem of releasing beta, alpha, release candidates, and dev versions. Developers want to have the ability to mark releases as being pre-releases. For instance, when Python is about to ship a new version, it will ship release candidates using an <code class="Code-In-Text--PACKT-">rcX</code> marker so that the community can try it before the final release is shipped, for example, <code class="Code-In-Text--PACKT-">3.10.0rc1</code> or <code class="Code-In-Text--PACKT-">3.10.0rc2</code>.</p>
    <p class="normal">For a microservice that you are not releasing to the community, using such markers is often unnecessary—but when you start to have people from outside your organization using your software, it may become useful.</p>
    <p class="normal">Release candidates can be useful if you are about to ship a backward-incompatible version of a project. It's always a good idea to have your users try it out before it's published. For the usual release though, using candidate releases is probably overkill, as publishing a new release when a problem is found is cheap.</p>
    <p class="normal">pip does a fairly good job of figuring out most patterns, ultimately falling back to some alphanumeric sorting, but the world would be a better place if all projects were using the same versioning scheme. <code class="Code-In-Text--PACKT-">PEP 386</code>, then <code class="Code-In-Text--PACKT-">440</code>, was written to try to come up with a versioning scheme for the Python community. It's derived from the standard <code class="Code-In-Text--PACKT-">MAJOR.MINOR[.PATCH]</code> scheme, which is widely adopted among developers, with some specific rules for pre and post versions.</p>
    <p class="normal">The <strong class="keyword">Semantic Versioning</strong> (<strong class="keyword">SemVer</strong>) (<a href="http://semver.org/">http://semver.org/</a>) scheme is another standard that emerged in the community, which is used in many places outside Python. If you use SemVer, you will be compatible with <code class="Code-In-Text--PACKT-">PEP 440</code> and the pip installer as long as you don't use pre-release markers. For instance, <code class="Code-In-Text--PACKT-">3.6.0rc2</code> translates to <code class="Code-In-Text--PACKT-">3.6.0-rc2</code> in SemVer.</p>
    <p class="normal">Unlike <code class="Code-In-Text--PACKT-">PEP 440</code>, SemVer asks that you always provide the three version numbers. For instance, <code class="Code-In-Text--PACKT-">1.0</code> should be <code class="Code-In-Text--PACKT-">1.0.0</code>. The <code class="Code-In-Text--PACKT-">python-semver</code> library will help a great deal with comparing different versions: <a href="https://github.com/python-semver/python-semver">https://github.com/python-semver/python-semver</a>:</p>
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; import semver
&gt;&gt;&gt; version1 = semver.parse_version_info('2.2.3-rc2')
&gt;&gt;&gt; version2 = semver.parse_version_info('2.3.1')
&gt;&gt;&gt; version1 &lt; version2
    True
</code></pre>
    <p class="normal">For your microservice<a id="_idIndexMarker582"/> project, or any Python project for that matter, you should start with the <code class="Code-In-Text--PACKT-">0.1.0</code> version to make it clear that it is not yet stable and may change drastically during early development, and that backward compatibility is not guaranteed. From there, you can increment the <code class="Code-In-Text--PACKT-">MINOR</code> number at will until you feel the software is mature enough.</p>
    <p class="normal">Once maturity has been reached, a common pattern is to release <code class="Code-In-Text--PACKT-">1.0.0</code>, and then start to follow these rules:</p>
    <ul>
      <li class="bullet"><code class="Code-In-Text--PACKT-">MAJOR</code> is incremented when you introduce a backward-incompatible change for the existing API.</li>
      <li class="bullet"><code class="Code-In-Text--PACKT-">MINOR</code> is incremented when you add new features that do not break the existing API.</li>
      <li class="bullet"><code class="Code-In-Text--PACKT-">PATCH</code> is incremented just for bug fixes.</li>
    </ul>
    <p class="normal">Being strict about this scheme with the <code class="Code-In-Text--PACKT-">0.x.x</code> series when the software is in its early phase does not make much sense, because you will make a lot of backward-incompatible changes, and your <code class="Code-In-Text--PACKT-">MAJOR</code> version would reach a high number in no time.</p>
    <p class="normal">The <code class="Code-In-Text--PACKT-">1.0.0</code> release is often emotionally charged for developers. They want it to be the first stable release they will give to the world—that's why it's common to use the <code class="Code-In-Text--PACKT-">0.x.x</code> versions and bump to <code class="Code-In-Text--PACKT-">1.0.0</code> when the software is deemed stable.</p>
    <p class="normal">For a library, what we call the API is all the public and documented functions and classes one may import and use. For a microservice, there's a distinction between the code API and the HTTP API. You may completely change the whole implementation in a microservice project and still implement the exact same HTTP API. You need to treat those two versions distinctly.</p>
    <p class="normal">It's important to remember that version numbers are not decimals, or really any form of counting number, and so while it may look like the next version after <code class="Code-In-Text--PACKT-">3.9</code> should be <code class="Code-In-Text--PACKT-">4.0</code>, it does not have to be—<code class="Code-In-Text--PACKT-">3.10</code> and onward are perfectly acceptable. The numbers are simply a way to order the values and tell which is lower or greater than another.</p>
    <p class="normal">Now that we know how to deal with version numbers, let's do some releasing.</p>
    <h2 id="_idParaDest-160" class="title">Releasing</h2>
    <p class="normal">To release your project, we must <a id="_idIndexMarker583"/>build a package that can be either uploaded to a package repository such as PyPI or installed directly wherever it is needed. Python has a build utility that makes this process straightforward.</p>
    <p class="normal">In the following example, we install the build utility, and then run it in the example project we used earlier in this chapter. The output can be quite long, so only some of it is included below:</p>
    <pre class="programlisting con"><code class="hljs-con">$ pip install --upgrade build 
...
$ python -m build
...
running bdist_wheel
running build
installing to build/bdist.macosx-10.15-x86_64/wheel
running install
running install_egg_info
running egg_info
writing MyProject.egg-info/PKG-INFO
writing dependency_links to MyProject.egg-info/dependency_links.txt
writing requirements to MyProject.egg-info/requires.txt
writing top-level names to MyProject.egg-info/top_level.txt
reading manifest file 'MyProject.egg-info/SOURCES.txt'
writing manifest file 'MyProject.egg-info/SOURCES.txt'
Copying MyProject.egg-info to build/bdist.macosx-10.15-x86_64/wheel/MyProject-1.0.0-py3.8.egg-info
running install_scripts
creating build/bdist.macosx-10.15-x86_64/wheel/MyProject-1.0.0.dist-info/WHEEL
creating '/Users/simon/github/PythonMicroservices/CodeSamples/Chapter9/pyproject-example/dist/tmpcqfu71ms/MyProject-1.0.0-py3-none-any.whl' and adding 'build/bdist.macosx-10.15-x86_64/wheel' to it
adding 'MyProject-1.0.0.dist-info/METADATA'
adding 'MyProject-1.0.0.dist-info/WHEEL'
adding 'MyProject-1.0.0.dist-info/top_level.txt'
adding 'MyProject-1.0.0.dist-info/RECORD'
removing build/bdist.macosx-10.15-x86_64/wheel 
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">build</code> command reads the information from <code class="Code-In-Text--PACKT-">setup.py</code> and <code class="Code-In-Text--PACKT-">MANIFEST.in</code>, collects all the files, and puts them in an archive. The result is created in the <code class="Code-In-Text--PACKT-">dist</code> directory:</p>
    <pre class="programlisting con"><code class="hljs-con"> $ ls dist/
MyProject-1.0.0-py3-none-any.whl	MyProject-1.0.0.tar.gz
</code></pre>
    <p class="normal">Notice that the name of the archive is composed of the name of the project and its version. The archive is in the <code class="Code-In-Text--PACKT-">Wheel</code> format, defined in <code class="Code-In-Text--PACKT-">PEP 427</code>, which is currently the best format for<a id="_idIndexMarker584"/> distributing Python packages, although there have been different methods in the past, which you may encounter in existing projects. This archive can be used directly with pip to install the project as follows:</p>
    <pre class="programlisting con"><code class="hljs-con">$ pip install dist/MyProject-1.0.0-py3-none-any.whl
Processing ./dist/MyProject-1.0.0-py3-none-any.whl
Collecting quart
  Using cached Quart-0.15.1-py3-none-any.whl (89 kB)
Collecting hypercorn&gt;=0.11.2
  Using cached Hypercorn-0.11.2-py3-none-any.whl (54 kB)
Collecting itsdangerous
  Using cached itsdangerous-2.0.1-py3-none-any.whl (18 kB) 
…
Installing collected packages: hyperframe, hpack, h11, wsproto, priority, MarkupSafe, h2, werkzeug, jinja2, itsdangerous, hypercorn, click, blinker, aiofiles, quart, MyProject
Successfully installed MarkupSafe-2.0.1 MyProject-1.0.0 aiofiles-0.7.0 blinker-1.4 click-8.0.1 h11-0.12.0 h2-4.0.0 hpack-4.0.0 hypercorn-0.11.2 hyperframe-6.0.1 itsdangerous-2.0.1 jinja2-3.0.1 priority-2.0.0 quart-0.15.1 werkzeug-2.0.1 wsproto-1.0.0
</code></pre>
    <p class="normal">Once you have your archive ready, it's time to distribute it.</p>
    <h2 id="_idParaDest-161" class="title">Distributing</h2>
    <p class="normal">If you are developing in an <a id="_idIndexMarker585"/>open-source project, it is good practice to publish your project to PyPI, so that it can be used by a wide range of people. This can <a id="_idIndexMarker586"/>be found at: <a href="https://pypi.python.org/pypi">https://pypi.python.org/pypi</a>. If the project is private, or internal to a company, then you may have a package repository for your work that operates in a similar way to PyPI that is only visible to your own organization's infrastructure.</p>
    <p class="normal">Like most modern language ecosystems, PYPI can be browsed by installers that are looking for releases to download. When you call the <code class="Code-In-Text--PACKT-">pip install &lt;project&gt;</code> command, pip will browse PyPI to see whether that project exists, and whether there are some suitable releases for your platform.</p>
    <p class="normal">The public name is the name you use in your <code class="Code-In-Text--PACKT-">setup.py</code> file, and you need to register it at PyPI to be able to publish releases. The index uses the first-come, first-serve principle, so if the name you have picked is already taken, then you will have to choose another one.</p>
    <p class="normal">When creating microservices for <a id="_idIndexMarker587"/>an application or organization, you can use a common prefix for all your projects' names. It is also possible to set up your own private version of PyPI for projects that should not be released to the wider world. If at all possible, though, it helps everyone to contribute to the open-source community.</p>
    <p class="normal">At the package level, a prefix can also sometimes be useful to avoid conflicts. Python has a namespace package feature, which allows you to create a top-level package name (like <code class="Code-In-Text--PACKT-">jeeves</code>), and then have packages in separate Python projects, which will end up being installed under the top-level <code class="Code-In-Text--PACKT-">jeeves</code> package.</p>
    <p class="normal">The effect is that every package gets a common <code class="Code-In-Text--PACKT-">jeeves</code> namespace when you import them, which is quite an elegant way to group your code under the same banner. The feature is available through the <code class="Code-In-Text--PACKT-">pkgutil</code> module from the standard library.</p>
    <p class="normal">To do this, you just need to create the same top-level directory in every project, with the <code class="Code-In-Text--PACKT-">__init__.py</code> file, containing and prefixing all absolute imports with the top-level name:</p>
    <pre class="programlisting code"><code class="hljs-code">from pkgutil import extend_path 
__path__ = extend_path(__path__, __name__) 
</code></pre>
    <p class="normal">For example, in Jeeves, if we decide to release everything under the same namespace, each project can have the same top-level package name. In the <code class="Code-In-Text--PACKT-">tokendealer</code>, it could be as follows:</p>
    <ul>
      <li class="bullet"><code class="Code-In-Text--PACKT-">jeeves</code>
        <ul>
          <li class="bullet-l2"><code class="Code-In-Text--PACKT-">__init__.py</code>: Contains the <code class="Code-In-Text--PACKT-">extend_path</code> call</li>
          <li class="bullet-l2"><code class="Code-In-Text--PACKT-">tokendealer/</code></li>
          <li class="bullet-l2">... the actual code...</li>
        </ul>
      </li>
    </ul>
    <p class="normal">And then in the <code class="Code-In-Text--PACKT-">dataservice</code> directory, like this: </p>
    <ul>
      <li class="bullet"><code class="Code-In-Text--PACKT-">jeeves</code>
        <ul>
          <li class="bullet-l2">__init__.py: Contains the <code class="Code-In-Text--PACKT-">extend_path</code> call</li>
          <li class="bullet-l2"><code class="Code-In-Text--PACKT-">dataservice/</code></li>
          <li class="bullet-l2">... the actual code...</li>
        </ul>
      </li>
    </ul>
    <p class="normal">Both will ship a <code class="Code-In-Text--PACKT-">jeeves</code> top-level namespace, and when pip installs them, the <code class="Code-In-Text--PACKT-">tokendealer</code> and <code class="Code-In-Text--PACKT-">dataservice</code> packages will both end up installed and available underneath the name <code class="Code-In-Text--PACKT-">jeeves</code>:</p>
    <pre class="programlisting con"><code class="hljs-con">&gt;&gt;&gt; from jeeves import tokendealer, dataservice
</code></pre>
    <p class="normal">This feature is not that <a id="_idIndexMarker588"/>useful in production, where each microservice is deployed in a separate installation, but it does not hurt, and it can be useful if you start to create a lot of libraries that are used across projects. For now, we will make the assumption that each project is independent, and each name is available at PyPI.</p>
    <p class="normal">To publish the releases at PyPI, you first need to register a new user using the form at <a href="https://pypi.org/account/register/">https://pypi.org/account/register/</a>, which will look like that shown in <em class="italic">Figure 9.1</em>.</p>
    <figure class="mediaobject"><img src="img/B17108_09_01.png" alt="image1.png"/></figure>
    <p class="packt_figref">Figure 9.1: Creating an account on PyPI</p>
    <p class="normal">It's also worth registering at <a id="_idIndexMarker589"/>the test version of PyPI, as this will let you experiment with uploads and try out all the commands without publishing anything to the real index. Use <a href="https://test.pypi.org/account/register/">https://test.pypi.org/account/register/</a> for an account on the test service.</p>
    <p class="normal">Python <code class="Code-In-Text--PACKT-">Distutils</code> has a <code class="Code-In-Text--PACKT-">register</code> and <code class="Code-In-Text--PACKT-">upload</code> command to register a new project at PyPI, but it is better to use <code class="Code-In-Text--PACKT-">Twine</code> (<a href="https://github.com/pypa/twine">https://github.com/pypa/twine</a>), which comes with a better user interface. Once you've installed <code class="Code-In-Text--PACKT-">Twine</code> (using the <code class="Code-In-Text--PACKT-">pip install twine</code> command), the next step is to register your package using the following command:</p>
    <pre class="programlisting con"><code class="hljs-con">$ twine register dist/jeeves-dataservice-0.1.0.tar.gz 
</code></pre>
    <p class="normal">Once done, you can go <a id="_idIndexMarker590"/>ahead and upload the releases. Let's upload to the test version of PyPI first, to make sure everything works. After the upload, we give pip some extra arguments so that it knows to use the test version of the PyPI version, and then to fall back to the real package index to sort out the other dependencies:</p>
    <pre class="programlisting con"><code class="hljs-con">$ twine upload —repository testpypi dist/*
$ pip install —index-url https://test.pypi.org/simple/ —extra-index-url https://pypi.org/simple jeeves-dataservice
</code></pre>
    <p class="normal">Once we know everything is working, we can upload to the real package index:</p>
    <pre class="programlisting con"><code class="hljs-con">$ twine upload dist/* 
</code></pre>
    <p class="normal">From there, your package should appear in the index, with an HTML home page at <code class="Code-In-Text--PACKT-">https://pypi.python.org/pypi/&lt;project&gt;</code>. The <code class="Code-In-Text--PACKT-">pip install &lt;project&gt;</code> command should work!</p>
    <p class="normal">Now that we know how to package each microservice, let us see how to run them all in the same box for development purposes.</p>
    <h1 id="_idParaDest-162" class="title">Running all microservices</h1>
    <p class="normal">So far, we have run our <code class="Code-In-Text--PACKT-">Quart</code> applications using the built-in Quart wrapper, or using the <code class="Code-In-Text--PACKT-">run()</code> function. This works well for <a id="_idIndexMarker591"/>development, as the app can detect changes to its source code and reload itself, saving time when making changes. However, there are limitations to this, not least of which is that this is running the server in a development mode, with extra diagnostics turned on that slow down the server's operation.</p>
    <p class="normal">Instead, we should run our <a id="_idIndexMarker592"/>applications using <code class="Code-In-Text--PACKT-">Hypercorn</code> (<a href="https://pgjones.gitlab.io/hypercorn/">https://pgjones.gitlab.io/hypercorn/</a>), an ASGI web server that allows <code class="Code-In-Text--PACKT-">Quart</code> to run to its full potential, supporting <code class="Code-In-Text--PACKT-">HTTP/2</code>, <code class="Code-In-Text--PACKT-">HTTP/3</code>, as well as <code class="Code-In-Text--PACKT-">WebSocket</code>. It's already installed alongside Quart and is very straightforward to use. For our dataservice application, we would run:</p>
    <pre class="programlisting con"><code class="hljs-con">$ hypercorn dataservice:app
</code></pre>
    <p class="normal">Hypercorn is the latest in a mine of WSGI and ASGI servers that aim to serve web applications, and if you are searching the Flask documentation when looking into extensions, you may come across mention of <code class="Code-In-Text--PACKT-">Gunicorn</code> (<code class="Code-In-Text--PACKT-">https://gunicorn.org/</code>), as it is a common equivalent to Hypercorn for synchronous applications, using a worker pool model to provide concurrency, an option we discussed in <em class="chapterRef">Chapter 1</em>, <em class="italic">Understanding Microservices</em>. For <code class="Code-In-Text--PACKT-">Quart</code>, though, we will stick with <code class="Code-In-Text--PACKT-">Hypercorn</code>.</p>
    <p class="normal">The last piece of the <a id="_idIndexMarker593"/>puzzle is to avoid having to run each console script in a separate Bash window. We want to manage those processes with a single script. Let's see in the next section how we can do this with a process manager.</p>
    <h1 id="_idParaDest-163" class="title">Process management</h1>
    <p class="normal">Hypercorn <a id="_idIndexMarker594"/>specializes in running web apps. If you want to deploy a development environment with a few other processes, you have to manage several different Python microservices, a RabbitMQ instance, a database, and whatever else you use. In order to make life easier in your development environment, you will need to use another process manager.</p>
    <p class="normal">A good option is a<a id="_idIndexMarker595"/> tool like <code class="Code-In-Text--PACKT-">Circus</code> (<a href="http://circus.readthedocs.io">http://circus.readthedocs.io</a>), which can run any kind of process, even when they are not ASGI or WSGI applications. It also has the ability to bind sockets and make them available for the managed processes. In other words, Circus can run a <code class="Code-In-Text--PACKT-">Quart</code> app with several processes, and can also manage some other processes if needed.</p>
    <p class="normal">Circus is a Python application, so, to use it, you can simply run the command <code class="Code-In-Text--PACKT-">pip install circus</code>. Once Circus is installed, it provides a few commands—through the <code class="Code-In-Text--PACKT-">entry_points</code> method described earlier. The two principal commands are <code class="Code-In-Text--PACKT-">circusd</code>, which is the process manager, and <code class="Code-In-Text--PACKT-">circusctl</code>, which lets you control the process manager from the command line. Circus uses an INI-like configuration file, where you can list the commands to run in dedicated sections—and, for each one of them, the number of processes you want to use.</p>
    <p class="normal">Circus can also bind sockets, and let the<a id="_idIndexMarker596"/> forked process use them via their file descriptors. When a socket is created on your system, it uses a <strong class="keyword">File Descriptor</strong> (<strong class="keyword">FD</strong>), which is a system handle a program can use to reach a file or an I/O resource like sockets. A process that is forked from another one inherits all its file descriptors. That is, through this mechanism, all the processes launched by Circus can share the same sockets.</p>
    <p class="normal">In the following example, two commands are being run. One will run five processes for the Quart application, located in the <code class="Code-In-Text--PACKT-">server.py</code> module, using the <code class="Code-In-Text--PACKT-">virtualenv</code> provided in the <code class="Code-In-Text--PACKT-">virtualenv</code> path, and the <a id="_idIndexMarker597"/>second command will run one Redis server process:</p>
    <pre class="programlisting con"><code class="hljs-con">[watcher:web]
cmd = hypercorn —bind fd://$(circus.sockets.web) server:app
use_sockets = True
numprocesses = 5
virtualenv = ./venvs/circus-virtualenv/
copy_env = True 
[watcher:redis] 
cmd = /usr/local/bin/redis-server 
use_sockets = False 
numprocesses = 1 
 
[socket:web] 
host = 0.0.0.0 
port = 8000 
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">socket:web</code> section describes what host and port to use to bind the TCP socket, and the <code class="Code-In-Text--PACKT-">watcher:web</code> section uses it via the <code class="Code-In-Text--PACKT-">$(circus.sockets.web)</code> variable. When Circus runs, it replaces that variable with the FD value for the socket. To run this script, you can use the <code class="Code-In-Text--PACKT-">circusd</code> command line:</p>
    <pre class="programlisting con"><code class="hljs-con">$ circusd myconfig.ini 
</code></pre>
    <p class="normal">For our<a id="_idIndexMarker598"/> microservices, using Circus means we can simply create a watcher and a socket section per service and start them all using the <code class="Code-In-Text--PACKT-">circusd</code> command.</p>
    <p class="normal">Circus also offers options to redirect the <code class="Code-In-Text--PACKT-">stdout</code> and <code class="Code-In-Text--PACKT-">stderr</code> streams to log files to facilitate debugging and numerous other features that can be found at <a href="https://circus.readthedocs.io/en/latest/for-ops/configuration/">https://circus.readthedocs.io/en/latest/for-ops/configuration/</a>.</p>
    <h1 id="_idParaDest-164" class="title">Summary</h1>
    <p class="normal">In this chapter, we have looked at how to package, release, and distribute each microservice. The current state of the art in Python packaging still requires some knowledge about the legacy tools, and this will be the case for some years until all the ongoing work in Python and <code class="Code-In-Text--PACKT-">PyPA</code> becomes mainstream. But, provided you have a standard, reproducible, and documented way to package and install your microservices, you should be fine.</p>
    <p class="normal">Having numerous projects to run a single application adds a lot of complexity when you are developing it, and it's important to be able to run all pieces from within the same box. Tools like pip's development mode and Circus are useful for this, as it allows you to simplify how you run the whole stack—but they still require that you install tools on your system, even if it is inside a <code class="Code-In-Text--PACKT-">virtualenv</code>.</p>
    <p class="normal">The other issue with running everything from your local computer is that you might not use an operating system that will be used to run your services in production, or you may have some libraries installed for other purposes, which might interfere.</p>
    <p class="normal">The best way to prevent this problem is to run your stack in an isolated environment. This is what the next chapter will cover: how to run your services inside a container.</p>
  </div>
</body></html>