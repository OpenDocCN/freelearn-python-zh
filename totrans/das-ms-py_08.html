<html><head></head><body>
        

                            
                    <h1 class="header-title">Metaprogramming</h1>
                
            
            
                
<p>In the previous chapter, we discussed asynchronous I/O and coroutines. In this chapter, we turn our attention to metaprogramming and programmable syntax. We'll discuss various ways that Python allows us to control or alter the meaning of syntactic elements and use these features beneficially.</p>
<p>We'll look at another programmable syntax feature of Python that meshes nicely with function decorators. We'll also discuss class decorators and how they're similar to, and different from, function decorators. Then we'll see a different way of programmatically modifying classes using metaclasses. We'll move on to a less esoteric topic and discuss context managers. Finally, we'll look at one more way of programming the semantics of basic Python operations when we look at descriptors.</p>
<p>Metaprogramming is a blanket term for techniques where programs use program code or data structures constructed directly from program code as data to be manipulated. Python has a number of different features that can be thought of as metaprogramming.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Using function decorators</li>
<li>Function annotations</li>
<li>Class decorators</li>
<li>Metaclasses</li>
<li>Context managers</li>
<li>Descriptors</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Using function decorators</h1>
                
            
            
                
<p>In this section, we're going to look at one of the most ubiquitous <strong>function decorators</strong>. We'll see how to construct a decorator, how to use it, and how it works.</p>
<p>The basic definition of a decorator is simple. It's just a function that takes another function as its input, does something with it, and then returns the result of its operations, as shown here:</p>
<div><img height="53" width="252" class="aligncenter size-full wp-image-566 image-border" src="img/51381066-7461-4764-b3a1-13cf3f4d4a70.jpg"/></div>
<p>The return value replaces the original input function, so the changes a decorator can make are potentially quite drastic. A decorator that doesn't change anything at all is a function that accepts one parameter and immediately returns it.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Using the @ syntax in a function decorator</h1>
                
            
            
                
<p>Python has a special syntax for applying a decorator to a function, using the <kbd>@</kbd> syntax. With this syntax, we just write an <kbd>@</kbd> symbol, followed by an expression that evaluates to a decorator function. We put that on the line right before the definition of the function we want to decorate, as shown in the following code example:</p>
<div><img height="66" width="170" class="aligncenter size-full wp-image-567 image-border" src="img/5e18b84c-bb01-4eef-9114-7ae309e8ab52.jpg"/></div>
<p>This syntax means that as soon as we're done defining the function, we call the decorator function on it and then assign the return value of the decorator to the variable that would have contained the function, as shown here:</p>
<div><img height="205" width="273" class="aligncenter size-full wp-image-569 image-border" src="img/d716911d-7c64-49ce-9e32-5e8b56b94478.jpg"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Global decorator - @staticmethod</h1>
                
            
            
                
<p>Python includes a few decorators in the global namespace and an expanding list of them in the standard library. The most commonly used global decorator is <kbd>@staticmethod</kbd>. It makes the class member function callable through the class, rather than an instance, just like <kbd>@staticmethod</kbd> decorators in other languages. The following screenshot illustrates the code example for <kbd>@staticmethod</kbd>:</p>
<div><img height="216" width="131" class="aligncenter size-full wp-image-570 image-border" src="img/9d82efa3-3883-4ea2-8aa9-2404de41e4e5.jpg"/></div>
<p>It's also possible to use multiple <kbd>@</kbd> lines before <kbd>def</kbd>; with this, multiple decorators will be invoked. The decorator that's closest to <kbd>def</kbd> will be called first, and then its return value will be passed to the next closest decorator, and so on. Eventually, the return value of the topmost decorator will be assigned to the function's name in the containing scope, as shown in the following code example:</p>
<div><img height="166" width="322" class="aligncenter size-full wp-image-868 image-border" src="img/67e98fdd-2068-47b4-ab75-1ec9e9144f8b.jpg"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Attributes</h1>
                
            
            
                
<p>One of the most common uses of decorators—in fact, the reason they're called decorators—is to add attributes to function objects. These attributes can be used by code in other parts of the program to distinguish decorated functions from each other and from under undecorated functions.</p>
<p>Adding attributes is easy. Inside the decorator, assign an attribute to the function, just like we would for any other object, and then return it. Then, elsewhere in the code, check for the attribute and respond accordingly.</p>
<p>That's all well and good and often quite useful, but we could do a lot more with decorators. For example, we can enclose the function in a wrapper that performs some computation before or after calling the function.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Enclosing the function in a wrapper</h1>
                
            
            
                
<p>To enclose a function in a wrapper, first we want the function to find the wrapper inside a decorator (refer to the following code example). If you haven't seen this before, it is exactly how it looks—the definition of a <kbd>wrapper</kbd> function actually lies inside of <kbd>@ints_only</kbd>. So when <kbd>@ints_only</kbd> is called, it defines and then returns the <kbd>wrapper</kbd> function.</p>
<p>Each time <kbd>@ints_only</kbd> is called, it defines a new <kbd>wrapper</kbd> function.</p>
<p>When a function is defined inside another function, the containing function's local variables remain available to the inner function. Refer to the following code example:</p>
<div><img height="215" width="244" class="aligncenter size-full wp-image-873 image-border" src="img/75ea39d1-3bec-4a89-a827-2ff4b3cf394c.jpg"/></div>
<p>In the preceding case, the <kbd>wrapper</kbd> does some manipulation of the function arguments and then calls the wrapped function and returns its results. We imported and used the decorator called <kbd>@wraps</kbd> in the preceding example.</p>
<p>The <kbd>@wraps</kbd> decorator's job is pretty straightforward; it makes the wrapper look like a wrapped function for tools such as <kbd>pydoc</kbd>. However, <kbd>@wraps</kbd> takes a parameter.</p>
<p>How does it work if the decorator always accepts just one parameter and that's the function it's being applied to? Let's find out.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The @wraps decorator</h1>
                
            
            
                
<p>The key is that the <kbd>@</kbd> symbol isn't followed by the name of a decorator per se; it's followed by an expression that evaluates to a decorator. So, wraps isn't actually a decorator. Strictly speaking, it's a function that returns the decorator.</p>
<p>When Python evaluates the function call expression, <kbd>@wraps</kbd> returns a decorator function, which is then applied to our wrapper.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The only function</h1>
                
            
            
                
<p>If we were to modify our <kbd>@ints_only</kbd> decorator so that we could specify an arbitrary function that could be applied to all the parameters, it would look like the preceding example. So now we have a function called <kbd>only</kbd>, which returns a decorator, which in turn returns a wrapper. This wrapper calls the original function.</p>
<p>That might look terribly inefficient, but in fact the only overhead comes from invoking the wrapper. Each time we call the function, the outer two layers of code only run once when the function is defined. So that's how you use function decorators and taste the sort of things we can use them for.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Function annotations</h1>
                
            
            
                
<p>In this section, we'll take a look at how to associate metadata with functions beyond docstrings, which we discussed in <a href="f119f22a-e6c5-40aa-993a-f77c46c6e931.xhtml">Chapter 4</a>, <em>Basic Best Practices</em>. In the previous section, one of our examples was a decorator that automatically passed all our decorated function arguments through an adapter.</p>
<p>That's pretty cool, but what if we want to handle each parameter differently?</p>
<p>Sure, we could pass a whole bunch of adapters to the wrapper, but it becomes ugly and clumsy as we start dealing with functions that accept more parameters. What we'd really like to do is attach metadata directly to a function's parameters. Fortunately, that's exactly what function annotations are for.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Function annotation syntax</h1>
                
            
            
                
<p>The following code example shows off Python's function annotation syntax: </p>
<div><img height="48" width="277" class="aligncenter size-full wp-image-572 image-border" src="img/e4034570-ef3d-48c6-8bbb-62690b438bce.jpg"/></div>
<p>To associate a value with a parameter, we put a colon (<kbd>:</kbd>) after the parameter name and then write an expression. This expression will be evaluated when the function is defined and the result stored along with a parameter name.</p>
<p>We can also annotate the return value of a function by writing a <kbd>-&gt;</kbd> arrow symbol after the function's parameter list and then an expression, which will also be evaluated when the function is defined. The result is stored along with the word <kbd>return</kbd>. Because <kbd>return</kbd> is a keyword, there is no chance that it will collide with a parameter name.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Accessing annotation data</h1>
                
            
            
                
<p>All the annotations are stored in a dictionary called <kbd>__annotations__</kbd>, which is an attribute of the function itself:</p>
<div><img height="43" width="485" class="aligncenter size-full wp-image-573 image-border" src="img/575c82bf-0238-4b5f-bf6d-bf6a98862028.jpg"/></div>
<p>As we can see in the preceding code example, annotations are not type declarations, though they could certainly be used for that purpose and they resemble the typing syntax used in some other languages, as shown here:</p>
<div><img height="86" width="415" class="aligncenter size-full wp-image-574 image-border" src="img/4036a092-3ec6-4849-82ad-6fe8fcaaf69f.jpg"/></div>
<p>They are arbitrary expressions, which means that arbitrary values can be stored in the <kbd>__annotations__</kbd> dictionary. They don't add any meaning to Python itself, except that it should store the values. That said, defining parameter and return types is a common use of function annotations.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The @no_type_check decorator</h1>
                
            
            
                
<p>If you find yourselves using a tool that assumes annotations are type declarations but you want to use them for some other purpose, use the standard <kbd>@no_type_check</kbd> decorator to exempt your function from such processing, as shown here:</p>
<div><img height="65" width="315" class="aligncenter size-full wp-image-902 image-border" src="img/fc411a42-63d4-4823-9c30-000dc64896c5.jpg"/></div>
<p>Normally, this isn't needed because most tools that use annotations have a way of recognizing the ones meant for them. The decorator is for protecting corner cases where things are ambiguous.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Annotations as input to function decorators</h1>
                
            
            
                
<p>Annotations combine well with decorators because annotation values make a good way to provide input to a decorator, and decorator-generated wrappers are a good place to put code that gives meaning to annotations.</p>
<p>For example, let's rewrite the decorator example from the previous section. We'll switch to only accepting keyword arguments, just to keep the example relatively simple:</p>
<div><img height="269" width="271" class="aligncenter size-full wp-image-897 image-border" src="img/4b420257-af28-4f46-a3de-ecbcf361539f.jpg"/></div>
<p>So, the <kbd>adapted</kbd> decorator encloses the function in a <kbd>wrapper</kbd>. This <kbd>wrapper</kbd> only accepts keyword arguments, which means that even, if the original function could accept positional arguments, they have to be specified by name.</p>
<p>Once the function is wrapped, <kbd>wrapper</kbd> also looks for adapters in the function's parameter annotations and applies them before passing the arguments to the real function.</p>
<p>Once the function returns, the wrapper checks for a return value adapter; if it finds one, it applies it to the return value before finally returning it.</p>
<p>When we consider the implications of what's happening here, they're pretty impressive. We've actually modified what it means to pass a parameter to a function or return a value.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Keyword arguments</h1>
                
            
            
                
<p>Let's look at another example (refer to the following example). Sometimes, one or more of a method's parameters don't require any processing, except assigning them to an attribute of self. Can we use decorators and annotations to make this happen automatically? Of course we can.</p>
<div><img height="276" width="353" class="aligncenter size-full wp-image-875 image-border" src="img/cc0effef-5ecd-4373-b1bd-e5a849623f27.jpg"/></div>
<p>Let's say that if a parameter is annotated with a string, the value assigned to that parameter will be assigned to an attribute of self, using the string as the name. And if the parameter is annotated with true, the attribute will have the same name as the parameter. If there's no annotation or, if it's not a string or true, nothing will happen.</p>
<p>Again, for simplicity's sake, let's limit ourselves to keyword arguments. As you can see in the preceding example, annotations simplify all sorts of code base manipulations of code. Here, we're basically using the same techniques as in the previous example but we're doing something entirely different with them.</p>
<p>We've been looking at decorators as the primary consumers of function annotations, but that's not necessarily the case. Any code that uses function objects might be written to benefit from annotations. This means, anywhere we pass a function as a callback, we could potentially use function annotation data to make the code smarter about what it does with the function.</p>
<p>Some of the possibilities are presented in the following list:</p>
<ul>
<li>Event handlers could be annotated with the names of the values the handler wants to receive</li>
<li>Dependency injection could be automated in a similar way</li>
<li>Constraint-based systems could be provided with the constraints that could be applied to each parameter</li>
<li>Probabilistic reasoning systems could be annotated with prior probability distributions</li>
<li>Parameters could be annotated with the proper user interface element to display in order to have the user input that parameter's value</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Inspecting the package signature function</h1>
                
            
            
                
<p>Before we wrap up this section, I'd like to point out one thing that may be helpful down the road. Our example decorators that worked with annotations were all limited to keyword arguments for simplicity:</p>
<div><img height="68" width="419" class="aligncenter size-full wp-image-905 image-border" src="img/03be0ba7-3f74-4b3b-8b16-a5d4821b8ace.jpg"/></div>
<p>However, if you find yourself wanting to do similar things and also handle all sorts of parameters at the same time, the <kbd>inspect</kbd> package's <kbd>signature</kbd> function will simplify the process significantly.</p>
<p>So, function annotations are a great way of adding metadata to functions; however, they might affect the handling of functions later in all sorts of ways.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Class decorators</h1>
                
            
            
                
<p>In this section, we'll look at class decorators, which are conceptually similar to function decorators but open different doors.</p>
<p>Class decorators work in the same basic way that function decorators do. A class decorator receives the class as its only parameter, and whatever it returns replaces that class. This is illustrated in the following image:</p>
<div><img height="113" width="303" class="aligncenter size-full wp-image-605 image-border" src="img/d485a8e2-ce84-4f26-9116-164f4eb61116.jpg"/></div>
<p>The return value doesn't have to be the same class or even a class at all, but it should be something that is meaningful. When it's bound to the class's name, it's rarely useful for a decorator to return none.</p>
<p>Also, like a function decorator, a class decorator can modify the attributes of the class or enclose the whole class in wrapper code. However, modifying the attributes of the class is effectively the same as modifying the class of the source code. This means that unlike functions, a class decorator can actually alter the structure of the decorated code, not just wrap it.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Modifying class attributes</h1>
                
            
            
                
<p>Modifying class attributes is straightforward; we just use the built-in <kbd>getattr</kbd>, <kbd>setattr</kbd>, and <kbd>delattr</kbd> functions, as shown in the following code example:</p>
<div><img height="330" width="323" class="aligncenter size-full wp-image-876 image-border" src="img/4d0996ef-23ea-4594-91de-cdf706e31fdb.jpg"/></div>
<p>In the preceding example, we see a simple class decorator that makes the attributes of the decorated class readable through the <kbd>[]</kbd> syntax; at the same time, it makes sure the class doesn't allow you to set or delete values through the <kbd>[]</kbd> syntax. While rewriting classes via decorators can be a powerful technique, it's not a complicated or surprising task, so there's nothing much to say about it.</p>
<p>We can also wrap up classes in their entirety. One common use of this technique is that it helps replace a class with a <kbd>factory</kbd> function. Using a <kbd>factory</kbd> function as an interface to create class instances lets us choose when to return an existing object, if there's one interface we think is more appropriate, rather than actually creating a new instance.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The factory function</h1>
                
            
            
                
<p>Calling a <kbd>factory</kbd> function means <em>give me the right object for these parameters, rather than giving me a new object for these parameters</em>. Let's take a look at an example class decorator that replaces the class object with a factory function.</p>
<p>For instances of this class, we'll assume that any two instances that were created with the same parameters should actually be the same object, as shown here:</p>
<div><img height="230" width="332" class="aligncenter size-full wp-image-877 image-border" src="img/9ee20857-154c-46f2-b84d-ac9ba4ced7ce.jpg"/></div>
<p>In the preceding example, we used <kbd>WeakValueDictionary</kbd> to keep track of the existing instances of the class and what parameters that were constructed with.</p>
<p>This doesn't have anything to do with class decorators per se; instead, we did it because we didn't want the cache to prevent the instances from being garbage collected. That's a good practice!</p>
<p>Whenever we make a <kbd>factory</kbd> function, it keeps track of the instances it creates. Another bit of good practice that we demonstrated in this example is that we decide the class itself as an attribute of the <kbd>factory</kbd> function. This means that the code outside of the <kbd>factory</kbd> function can still access the class object if it really needs to.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The factory_constructed function</h1>
                
            
            
                
<p>So, let's take a look at our factory-making decorator in action. Refer to the following screenshot:</p>
<div><img height="305" width="474" class="aligncenter size-full wp-image-575 image-border" src="img/124cdda1-8000-4723-bbfb-c86d03b81482.jpg"/></div>
<p>Notice that the thing named <kbd>Unique</kbd> is in fact the <kbd>factory</kbd> function that was created for the <kbd>Unique</kbd> class, rather than the <kbd>Unique</kbd> class itself. The actual class ends up being named <kbd>Unique.type</kbd>. Also, notice that <kbd>u1</kbd> and <kbd>u3</kbd> are not just equal but actually the same object; meanwhile, <kbd>u2</kbd>, which was created with different arguments, is different.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Class definitions</h1>
                
            
            
                
<p>Now we're going to take a look at something really wild. The syntax we use for defining classes is pretty generic; it could be used to represent all sorts of different data structures. So, why not use class decorators to transform class definitions into objects of various types?</p>
<p>By doing this, we can achieve a sort of sideways decorative programming paradigm. For our example (the one that will follow), let's say we want to connect to a sqlite database and create some tables in it if they don't already exist. We can make Python's class syntax work for us as a convenient way of expressing this idea:</p>
<div><img height="172" width="481" class="aligncenter size-full wp-image-576 image-border" src="img/f19db3ba-1eb4-4ecb-a14d-5355650eebb1.jpg"/></div>
<p>We want the usage to look something like this code example, where the class structure and attributes provide the information that's needed to construct and configure a database connection for us. The end result should be a <kbd>connection</kbd> object, which we can use to issue queries according to the Python Database API.</p>
<p>There are a great many details that are ignored or handled simplistically by this example, but it captures the general idea. The class objects that Python creates automatically, when it's evaluating these statements, are used to provide structured data input to the decorator called <kbd>@database</kbd> and then discarded.</p>
<p>The following code example shows the <kbd>@database</kbd> decorator:</p>
<div><img height="382" width="506" class="aligncenter size-full wp-image-879 image-border" src="img/e90cc3b4-abb2-4b91-9061-869a21cded79.jpg"/></div>
<p>The <kbd>@database</kbd> decorator returns an open Python Database API connection object, not a class of any sort.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Metaclasses</h1>
                
            
            
                
<p>In this section, we'll look at metaclasses, which affect the creation of class objects right from the beginning.</p>
<p>Like class decorators, metaclasses are a tool we can use to adjust the basic meaning of a class. In concept though, they're very different. A class decorator takes an already created class and transforms it in some way. A metaclass, on the other hand, can affect how a class is created, how it behaves, and even how classes that inherit from the modified class are created and behave.</p>
<p>To understand metaclasses, first we have to grasp the idea that classes are objects, and more than that, they are instances of another class called <kbd>type</kbd>. Whenever we create a new class, we create an instance of <kbd>type</kbd>, unless the class has a metaclass, as shown here:</p>
<div><img height="175" width="348" class="aligncenter size-full wp-image-577 image-border" src="img/abd062ca-26bf-4088-ac38-43c25db46e64.jpg"/></div>
<p>If the class we're creating as a metaclass is specified or inherits a metaclass from its ancestors, then the new class is an instance of the metaclass rather than a direct instance of <kbd>type</kbd>.</p>
<p>This sounds like we could change the behavior of a class completely by giving it an unusual metaclass, but actually all metaclasses have to resemble <kbd>type</kbd> or Python wouldn't be able to use them properly. Most of the time, metaclasses are actually subclasses of <kbd>type</kbd>, which makes things simple.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">What can we do with a metaclass?</h1>
                
            
            
                
<p>First of all, we can run code before the code inside the <kbd>class</kbd> block is evaluated for each class, which is an instance of the metaclass. We do this by having the metaclass set as a <kbd>__prepare__</kbd> method, which should be a class method or a static method because it will be called before the instance is created.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The __prepare__method</h1>
                
            
            
                
<p>The <kbd>__prepare__</kbd> method is passed with the name of the new class and its list of parent classes as well as any keyword arguments supplied by the user. It can do whatever we want it to, but it should also return a dictionary or similar object that could be used to hold the class's attributes (refer to the previous example).</p>
<p>We can preassign values to the attribute dictionary from inside of <kbd>__prepare__</kbd>, so we can actually assign attributes to the class before it even exists. That brings us to the second thing that metaclasses can easily control-the <strong>class's namespace</strong>.</p>
<p>In our previous example, we returned a <kbd>dict()</kbd> instance from <kbd>__prepare__</kbd>, so instances of this metaclass use a normal dictionary to store their attributes while their code is being evaluated; however, we can return any dictionary-like object from <kbd>__prepare__</kbd>. For example, we can return <kbd>OrderedDict</kbd> if we want to keep track of the order in which attributes were created or <kbd>DefaultDict</kbd> if we want all the attributes to have a default value.</p>
<p>We could even use <kbd>WeakValueDictionary</kbd> if, for some reason, we want the class to not protect its attributes from being garbage collected while it is evaluated. Of course, <kbd>WeakValueDictionary</kbd> is a just dictionary-like class that exists in the standard library.</p>
<p>We can also return a custom dictionary-like class from <kbd>__prepare__</kbd>, which could conceivably do almost anything. If we want a class that ignores the case of attribute names while its code is being evaluated, we can do that.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The __new__ method</h1>
                
            
            
                
<p>There's a reason why I keep saying <em>while the code is being evaluated</em>. After <kbd>__prepare__</kbd> is called, the code inside the class block is run and it uses the dictionary that was returned from <kbd>__prepare__</kbd> as its namespace, as shown here: </p>
<div><img height="219" width="408" class="aligncenter size-full wp-image-578 image-border" src="img/eeef9e1d-33cc-4cde-8ea3-70d5d6abfb65.jpg"/></div>
<p>However, after that, the metaclass's <kbd>__new__</kbd> method is called. One of the things <kbd>__new__</kbd> needs to do is call <kbd>type.__new__</kbd> to actually allocate and initialize a chunk of memory to contain the class data, and one of the things <kbd>type.__new__</kbd> does is convert whatever we pass as a namespace for the object into a normal <kbd>dict</kbd>.</p>
<p>This means that if we want to retain special information that our <kbd>namespace</kbd> object knows, we need to store it somewhere where we can find it later.</p>
<p>We can make whatever changes we want to the internals of the class, shown in the following code example:</p>
<div><img height="91" width="395" class="aligncenter size-full wp-image-880 image-border" src="img/f93207c8-a624-428f-bcf3-98414aacfb10.jpg"/></div>
<p>Once we've created the class object in the <kbd>__new__</kbd> method of the metaclass, we can programmatically add, remove, replace, or wrap the class contents, much as we could in a class decorator. We can also return something that isn't actually a class object at all, just as we could with a class decorator.</p>
<p>The difference, aside from a bit of extra typing, is that the subclasses of a class that has a metaclass will also inherit that metaclass, while class decorators are not inherited.</p>
<p>This means that using a metaclass, we can make our unusual behaviors inheritable.</p>
<p>In this example, you learned that any class that descends from the class where the metaclass was originally applied can find all the other classes that also descend from that ancestor.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Context managers</h1>
                
            
            
                
<p>In this section, we'll look at what is maybe Python's most-used programmable semantic element—context managers.</p>
<p>Context managers are pieces of code that plug into Python's <kbd>with</kbd> statement. A <kbd>with</kbd> statement contains a block of code, and the context manager is able to run its own code, both before and after that block is executed, along with the after code guaranteed to run no matter what happens in the block.</p>
<p>The Python standard library makes quite a lot of use of context managers:</p>
<ul>
<li><kbd>open</kbd> files can be used as context managers, which guarantees that the file will be closed at the end of the block:</li>
</ul>
<div><img height="70" width="297" class="aligncenter size-full wp-image-579 image-border" src="img/02bd6e0c-88b2-4e73-83ff-6dc09dfccef1.jpg"/></div>
<ul>
<li><kbd>lock</kbd> objects could be used as context managers, in which case they acquire the lock before the block and release it when the block is finished executing:</li>
</ul>
<div><img height="119" width="604" class="aligncenter size-full wp-image-580 image-border" src="img/c5a6f978-1fbe-4ee0-a53e-f02daaf68173.jpg"/></div>
<ul>
<li>SQLite database connections can be used as context managers, allowing them to automatically commit or roll back the transaction when the block finishes:</li>
</ul>
<div><img height="94" width="436" class="aligncenter size-full wp-image-581 image-border" src="img/8fa45d31-5e26-4665-9af5-93e6d3388439.jpg"/></div>
<p>There are other examples. We can already see in the preceding examples how useful context managers can be. They simplify the code by combining setup and cleanup, and they improve the code by guaranteeing that they will run the cleanup code.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Defining a context manager as a generator</h1>
                
            
            
                
<p>So how can we write our own context managers? There are two ways.</p>
<p>The simplest is to use the <kbd>@contextlib.contextmanager</kbd> decorator on a generator function, as we see in the following example:</p>
<div><img height="216" width="276" class="aligncenter size-full wp-image-582 image-border" src="img/e80dcba4-2c4f-4603-9052-6c36be7d0e5b.jpg"/></div>
<p>When we create a context manager this way, we can write it as one continuous piece of code. We can think of the <kbd>yield</kbd> statement as a proxy for the whole code block that the <kbd>with</kbd> statement contains.</p>
<p>If this block raises an exception, it will look toward our context manager code as if the <kbd>yield</kbd> statement was responsible for raising that exception, so we can wrap it in a <kbd>try</kbd> statement to deal with any exceptions that might occur.</p>
<p>We saw the <kbd>as</kbd> clause of the <kbd>with</kbd> statement when we used file opening as an example of a context manager (refer to the code example of the <kbd>open</kbd> file); it lets us find a value returned from the context manager to a variable accessible within the with block. If we yield a value from our context manager code, that value will be the one assigned through <kbd>as</kbd>.</p>
<p>In the preceding example, we yield a function that prints the word <kbd>during</kbd> so that the entire result of our <kbd>with</kbd> statement is that it prints <kbd>before</kbd>, <kbd>during</kbd>, and <kbd>after</kbd>, in that order.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Adding context manager behavior to a class</h1>
                
            
            
                
<p>We can also write context managers by adding <kbd>__enter__</kbd> and <kbd>__exit__</kbd> methods to objects. Any object that properly implements these methods can be used as a context manager, which is how objects such as open files and database connections are able to work extra as context managers.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Synchronous-coroutine-based context managers</h1>
                
            
            
                
<p>The following is an example in which we create a specialized version of a dictionary, which could serve as a context manager:</p>
<div><img height="154" width="323" class="aligncenter size-full wp-image-882 image-border" src="img/5ad893e2-79d5-4b4b-9352-dfdf85857900.jpg"/></div>
<p>Within the scope of the <kbd>with</kbd> block, we can read and write data through the object that we returned from <kbd>__enter__</kbd>, but these changes will only be applied to the main dictionary. If the block exits without raising an exception, the return value of the inner method will be used by the <kbd>with</kbd> statement for the value to be assigned through the <kbd>as</kbd> clause.</p>
<p>Refer to the following code example, the variable <kbd>trans</kbd> contains the <kbd>ChainMap</kbd> instance. <kbd>ChainMap</kbd> objects are dictionaries that can have a parent dictionary. If <kbd>'a'</kbd> looking in <kbd>ChainMap</kbd> fails, it tries to look up the same key in its parent.</p>
<div><img height="208" width="308" class="aligncenter size-full wp-image-883 image-border" src="img/5e01cf9b-a024-440a-8da5-40e714ce565f.jpg"/></div>
<p>The <kbd>__exit__</kbd> method needs to accept parameters that specify the types <kbd>exc_type</kbd>, <kbd>exc_val</kbd>, and <kbd>tb</kbd>, if an exception is raised in the <kbd>with</kbd> block. If no exception is raised, all these parameters will contain <kbd>None</kbd>. If an exception is raised, we would need to decide whether and how the context manager will handle them.</p>
<p>In our preceding example, we decided to apply the changes to the main dictionary based on whether or not an exception was raised; otherwise, we would have ignored the exception. If we want Python to consider the exception to be handled, we could return <kbd>true</kbd> from the <kbd>__exit__</kbd> method.</p>
<p>This would be functionally equivalent to catching the function with a <kbd>try-except</kbd> statement. There's another variation of the class-based context manager, which supports asynchronous-coroutine-based context management.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating an asynchronous-coroutine-based context manager</h1>
                
            
            
                
<p>For the asynchronous protocol, the <kbd>__enter__</kbd> and <kbd>__exit__</kbd> methods are replaced by <kbd>__aenter__</kbd> and <kbd>__aexit__</kbd> coroutine methods and the context manager is invoked by an <kbd>async with</kbd> statement, as shown here:</p>
<div><img height="148" width="364" class="aligncenter size-full wp-image-899 image-border" src="img/c4c0fb06-e0ef-4cca-9f32-035cf276306f.jpg"/></div>
<p>This small change buys us the ability to have the <kbd>__enter__</kbd> and <kbd>__exit__</kbd> methods invoke other coroutines, wait for data to come in from the network, and behave nicely in an <kbd>asyncio</kbd>-based program.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Descriptors</h1>
                
            
            
                
<p>In this section, we'll take a look at one last way of altering the semantics of a Python-based syntax, using descriptors. Reading and writing variables is one of the most fundamental aspects of programming. Python's descriptors let us alter how it works.</p>
<p>A descriptor is an object that is stored in a class and controls what it means to get, set, and delete a specific single attribute for instances of that class. If we want that sort of control over multiple attributes, we just add a descriptor to the class for each attribute we want to control.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Using @property to create a descriptor</h1>
                
            
            
                
<p>Python's built-in <kbd>@property</kbd> decorator provides a simple way to create a descriptor. Let's consider an example (refer to the following code example) to illustrate this:</p>
<div><img height="213" width="275" class="aligncenter size-full wp-image-601 image-border" src="img/97a25b0f-b511-4599-acea-cd43681b6189.jpg"/></div>
<p>The first <kbd>prop</kbd> method we wrote in the preceding code example tells Python how to figure out the value of an attribute called <kbd>prop</kbd>, which in this case just means fetching it from another attribute and printing the value.</p>
<p>The latter two <kbd>prop</kbd> methods are decorated to turn them into <kbd>setter</kbd> and <kbd>deleter</kbd> for the <kbd>prop</kbd> attribute. This means that assigning a value to a prop actually means calling the <kbd>setter</kbd> method, and deleting a prop attribute actually means calling the <kbd>deleter</kbd> method.</p>
<p>Both the methods are optional for properties. Leaving them out makes the attribute that the property describes into a read-only attribute.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Writing descriptors as classes</h1>
                
            
            
                
<p>Properties simplify the construction of descriptors for a common case, but there are use cases where we need a descriptor that the property can't handle well. For example, what if we were planning on making a class that represented remote data and we wanted its attributes to push and pull data from a remote source? We could do this with properties, but we'd end up writing very similar code over and over as we implement each attribute.</p>
<p>It would be better to have a <kbd>RemoteResource</kbd> descriptor class and just add a bunch of instances to our local stub class. Let's go ahead and do that as an example using the <kbd>RemoteResource</kbd> descriptor; refer to the following code example:</p>
<p><img height="311" width="715" class="aligncenter size-full wp-image-900 image-border" src="img/b509c9e9-e28e-492c-9287-497d8475e376.jpg"/></p>
<p>Actually, interacting with the network requires a fair amount of code, so it's a good thing we can avoid repeating it over and over.</p>
<p>The <kbd>RemoteResource</kbd> class we have in the preceding example has <kbd>__get__</kbd>, <kbd>__set__</kbd>, and <kbd>__delete__</kbd> methods, which determine what happens when an attribute that is controlled by an instance in this class is accessed.</p>
<ul>
<li>The <kbd>__get__</kbd> method, perhaps surprisingly, takes two parameters-the <kbd>instance</kbd> through which the attribute's being accessed and the <kbd>class</kbd> through which the attribute is being accessed. It's like this so we can handle both <kbd>instance</kbd> attribute access and <kbd>class</kbd> attribute access.
<ul>
<li>When accessing a <kbd>class</kbd> attribute, the <kbd>instance</kbd> parameter is <kbd>None</kbd>. In our case, we just returned the descriptor in case somebody tries to access the attribute as a class member instead of an instance member, which is a reasonable default in a lot of cases.</li>
</ul>
</li>
</ul>
<ul>
<li>The <kbd>__set__</kbd> method is passed as an instance and value, and it conceptually represents setting the control attribute of that instance to the value. Unlike <kbd>__get__</kbd>, it doesn't have support for setting a <kbd>class</kbd> attribute, so the instance will never be <kbd>None</kbd> and we don't need <kbd>class_parameter</kbd>.</li>
<li>The <kbd>__delete__</kbd> method is just passed as an instance and represents removing the control attribute from that instance.</li>
</ul>
<p>None of the descriptor methods are told which attribute they represent. The assumption is that their <kbd>self</kbd> parameter will specify that one way or another.</p>
<p>In our code (in the preceding code example), we've chosen to pass the necessary information to the descriptor's constructor and store it as an attribute of self. But, in other circumstances, we might use <kbd>self</kbd> or <kbd>selfs ID</kbd> as a key in a dictionary to store the per-instance state of the descriptor or use the instance as a key in a dictionary stored in <kbd>self</kbd> as shown in the following code example:</p>
<pre>
class Record:<br/>    name = RemoteResource('name')<br/>    age = RemoteInt('age')<br/>    def __init__(self, pk, reader, writer):<br/>        self.out = writer<br/>        self.in = reader<br/>        self.pk = pk
</pre>
<p>We can't just store per-instance data as attributes of <kbd>self</kbd>, though. Descriptors are attributes of the class, not the instance, so their self values are shared by all the instances of the class that contains them. Either way, we can control what it means to get, set, or delete an instance attribute.</p>
<p>Once we have the <kbd>RemoteResource</kbd> class, creating classes that have remote attributes becomes easy, as demonstrated by the <kbd>Record</kbd> class shown in the preceding image.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we saw several other ways of altering the meaning and execution of Python code, allowing us to conform the language to our specialized needs.</p>
<p>We saw how function decorators use functions as input data for manipulation. We took a look at function annotations and particularly how they interact with function decorators. We saw how class decorators work exactly as function decorators do, but because they operate on classes, the possibilities are very different. We saw how to modify classes, wrap them, or even replace them using decorators. We discussed how to use a metaclass to affect the construction of a class object and how to make unusual behavior inheritable by making it part of a class's metaclass. We looked at context manager, both synchronous and asynchronous. We saw how context managers work and learned how to make our own for use in either synchronous or asynchronous code. We saw how to create simple descriptors using the <kbd>property</kbd> function and more complex descriptors as classes.</p>
<p>In the next chapter, we'll look at automated unit testing—testing a set of techniques that could dramatically improve the process of writing a program.</p>


            

            
        
    </body></html>