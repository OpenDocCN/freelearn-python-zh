- en: Unit Testing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试
- en: In the previous chapter, we saw various approaches to metaprogramming and programmable
    syntax in Python. In this chapter, we're going to take a look at the ideas behind
    unit testing, then move on to several test automation tools we can use to make
    our testing easier and more useful. We'll focus on what unit testing is, and the
    ideas that motivate it. We'll also discuss Python's standard `unittest` package
    and how it works.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们看到了Python中元编程和可编程语法的各种方法。在这一章中，我们将探讨单元测试背后的理念，然后转向我们可以使用的一些测试自动化工具，使我们的测试更容易、更有用。我们将关注单元测试是什么，以及推动它的理念。我们还将讨论Python的标准`unittest`包及其工作原理。
- en: Finally, you'll learn how to use `unittest.mock` to control the environment
    that your test code will run in so that the test will remain focused on making
    sure one thing works properly.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你将学习如何使用`unittest.mock`来控制测试代码运行的 环境，以确保测试能够专注于确保一件事情正常工作。
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Understanding the principle of unit testing
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解单元测试的原则
- en: Using the unittest package
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用unittest包
- en: Using unittest.mock
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用unittest.mock
- en: Using unittest's test discovery
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用unittest的测试发现
- en: Using nose for unified test discovery and reporting
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用nose进行统一的测试发现和报告
- en: Understanding the principle of unit testing
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解单元测试的原则
- en: 'Testing is often something of an afterthought for programmers because it tends
    to be laborious and annoying. Also, we usually have a high degree of confidence
    in our work and testing it seems unnecessary. It''s also a fact, though, that
    the confidence is often misplaced. Source code is a complex and subtle language,
    and it''s easy to make mistakes while writing it and not even notice them. We
    all know this from experience, but that doesn''t make it any easier to make time
    for something that is laborious, annoying, and feels unnecessary. The following
    flow diagram illustrates a simple example of testing:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 测试通常是程序员事后才考虑的事情，因为它往往既费力又令人烦恼。此外，我们通常对自己的工作有很高的信心，测试似乎是不必要的。然而，这也是一个事实，即这种信心往往被误放。源代码是一种复杂而微妙的语言，在编写它时很容易出错，甚至没有注意到。我们从经验中都知道这一点，但这并不使为这种费力、令人烦恼且感觉不必要的事情腾出时间变得容易。以下流程图说明了测试的简单示例：
- en: '![](img/946c5ebf-b5e3-4b24-83a8-1151da7c5ade.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![](img/946c5ebf-b5e3-4b24-83a8-1151da7c5ade.png)'
- en: So, the first question about testing is, *How can we do it in a way that doesn't
    feel like a painful waste of time?* Finding a way to overcome this psychological
    barrier is the first step toward creating a testing method that will actually
    work for a lot of programmers. Unit testing does this by reducing the effort needed
    to run tests, integrating testing with the development process, and making the
    tests themselves visibly useful.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，关于测试的第一个问题是，*我们如何以不感觉像是一种痛苦的浪费时间的方式来进行测试？* 找到克服这种心理障碍的方法是创建一种对许多程序员真正有效的测试方法的第一步。单元测试通过减少运行测试所需的努力，将测试与开发过程集成，并使测试本身变得明显有用来实现这一点。
- en: What is a unit test?
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是单元测试？
- en: First of all, let's find out what is a unit test. A **unit test** is a single
    small chunk of test code that tests correct behavior or a single specific flaw
    within an isolated small chunk of program code.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们弄清楚什么是单元测试。**单元测试**是一小段测试代码，它测试一个隔离的小块程序代码中的正确行为或单个特定的缺陷。
- en: There are reasons for each part of this definition. A unit test is source code
    because one of the secrets of unit testing is that we put the maximum amount of
    the effort of testing on the computer, which is where it should belong.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 每个定义部分都有原因。单元测试是源代码，因为单元测试的一个秘密是我们将尽可能多的测试努力放在计算机上，这是它应该属于的地方。
- en: The test code tells the computer how to perform the test, which allows us to
    perform the test often and easily. A unit test is small because a large test is
    almost inevitably testing for more than one thing.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 测试代码告诉计算机如何执行测试，这使得我们能够经常且容易地执行测试。单元测试之所以小，是因为大测试几乎不可避免地会测试多个事物。
- en: 'This can be summarized as:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以总结为：
- en: Small, simple code
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单、简单的代码
- en: Checks a small piece of the program
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查程序的一小部分
- en: Answers a single yes-or-no question about program functionality
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回答关于程序功能的一个是或否问题
- en: If we want to test for more than one thing, we should write more than one test.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要测试多个事物，我们应该编写多个测试。
- en: 'There are two rules for a unit test. These are:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试有两个规则。这些是：
- en: A unit test only checks a single aspect of the program code because when a test
    fails, we want it to tell us exactly what the problem is
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试只检查程序代码的一个方面，因为当测试失败时，我们希望它能确切地告诉我们问题是什么。
- en: A unit test only involves a narrow region of the program code because when a
    test fails, we want it to tell us exactly where the problem is
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试只涉及程序代码的一个狭窄区域，因为当测试失败时，我们希望它能确切地告诉我们问题所在。
- en: If we write a collection of tests that follow these rules, they are called a
    **unit test suite**.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们编写了一组遵循这些规则的测试，它们就被称为**单元测试套件**。
- en: With proper tools, we can run our whole test suite with a single command, and
    the output of this command will immediately tell us the status of our code with
    respect to the test. If the test fails, it tells us what we need to work on next.
    If it succeeds, it gives us a reason to build our confidence in the code it tested.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 使用适当的工具，我们可以用单个命令运行整个测试套件，这个命令的输出将立即告诉我们代码相对于测试的状态。如果测试失败，它会告诉我们接下来需要做什么。如果测试成功，它给了我们一个理由来增强我们对测试代码的信心。
- en: 'The availability of automated unit testing leads to a programming paradigm
    called **test-driven development** (**TDD**), as illustrated in the following
    diagram:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化单元测试的可用性导致了一种称为**测试驱动开发**（**TDD**）的编程范式，如下面的图示所示：
- en: '![](img/fe2f8b4b-45c7-4c35-8aa2-069f0cc3fd2b.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fe2f8b4b-45c7-4c35-8aa2-069f0cc3fd2b.png)'
- en: The basic idea of TDD is that since a failing test tells us what to do next,
    we should never write program code except when we want to make a failing test
    pass. If all the presently available tests pass and the program isn't finished,
    we first add another test to the test suite, and then write program code to make
    it pass.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: TDD的基本思想是，由于失败的测试告诉我们下一步该做什么，因此我们不应该在除了想要让失败的测试通过之外的情况下编写程序代码。如果所有当前可用的测试都通过了，而程序还没有完成，我们首先向测试套件中添加另一个测试，然后编写程序代码使其通过。
- en: Doing things this way ensures that there are tests that cover most or all of
    the source code and that the tests are run often, which makes it very difficult
    for bugs and regressions to sneak into the code without being noticed. It also
    lets us break the development process down into a series of short-term goals,
    which produce a visible result when we achieve them.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式做事可以确保有测试覆盖了大部分或所有源代码，并且测试经常运行，这使得错误和回归很难在不被注意的情况下悄悄进入代码。这也让我们可以将开发过程分解成一系列短期目标，当我们实现这些目标时，会产生明显的成果。
- en: This is psychologically useful because it makes the programming process feel
    more productive, and it's much easier to perform a task that feels rewarding.
    Further, debugging tends to dominate the time needed for a project, and TDD reduces
    the time needed to deal with bugs.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这在心理上是有益的，因为它使编程过程感觉更有成效，而且执行感觉有回报的任务要容易得多。此外，调试往往占据项目所需的大部分时间，而TDD减少了处理错误所需的时间。
- en: So, when applied properly, unit testing principles and tools help us produce
    better code, perform the test faster, and enjoy the process more. It's an all-round
    win.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当正确应用时，单元测试的原则和工具帮助我们产生更好的代码，更快地执行测试，并享受这个过程。这是一个全面的胜利。
- en: So far, we've had a high-level discussion of the reasons for and the benefits
    of automated unit testing and TDD. Python includes a framework for automated unit
    testing, and we'll take a look at it in the next section.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了自动化单元测试和TDD的原因和好处。Python包含了一个自动化单元测试的框架，我们将在下一节中对其进行探讨。
- en: Using the unittest package
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用unittest包
- en: In this section, we're going to look at Python's standard `unittest` package.
    We'll talk about how to structure a test file and how to write tests and draw
    a comparison between what happens and what should happen in these tests. Let's
    jump straight into it!
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨Python的标准`unittest`包。我们将讨论如何构建测试文件，如何编写测试，以及在这些测试中实际发生的情况与应该发生的情况之间的比较。让我们直接进入正题！
- en: Structuring a test file
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建测试文件
- en: The unittest module contains a framework for performing automated unit testing.
    Most of this functionality is based around the `unittest.TestCase` class, which
    we will inherit from to create our own tests.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: unittest模块包含了一个执行自动化单元测试的框架。大部分功能都是围绕`unittest.TestCase`类构建的，我们将从这个类继承以创建自己的测试。
- en: 'In the following example, we see the basic features of `TestCase` in action
    and also test and assert methods:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们可以看到`TestCase`的基本功能在实际操作中的表现，以及测试和断言方法：
- en: '![](img/dc0b2b97-8c1c-4d63-94ed-c0b2d50ef1dc.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/dc0b2b97-8c1c-4d63-94ed-c0b2d50ef1dc.jpg)'
- en: Any method that we define using a class inherited from `TestCase`, and that
    has a name that starts with the word **test**, is assumed to be a unit test. In
    the preceding example, this means that the `test_addition` method is a unit test;
    however, if we had added another method to the class, called `connect`, the unittest
    module would not have treated it as a unit test.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用从`TestCase`类继承的类定义的任何方法，并且其名称以单词**test**开头，都被假定为单元测试。在先前的例子中，这意味着`test_addition`方法是一个单元测试；然而，如果我们向类中添加另一个名为`connect`的方法，unittest模块不会将其视为单元测试。
- en: A `TestCase` class can contain more than one unit test and should run when those
    tests are logically related and require the same operating environment.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`TestCase`类可以包含多个单元测试，并且应该在那些测试在逻辑上相关且需要相同的运行环境时运行。'
- en: assert methods
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: assert方法
- en: 'Inside our `test_addition` method, which is a unit test, we used a method called
    `assertEqual` to actually check that the result of the code was as expected. `TestCase`
    provides a wide range of these assert methods that test for various relationships
    between our results and what we expected. This is shown in the following code
    example:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的单元测试`test_addition`方法中，我们使用了一个名为`assertEqual`的方法来实际检查代码的结果是否符合预期。`TestCase`提供了一系列这些assert方法，用于测试我们的结果和预期之间的各种关系。这在下述代码示例中显示：
- en: '![](img/becea722-e559-4054-8783-07e2beede181.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](img/becea722-e559-4054-8783-07e2beede181.png)'
- en: 'Let''s take a closer look at what these assert methods actually do:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看这些assert方法实际上做了什么：
- en: We've already seen the `assertEqual` method in the previous code example; it
    checks whether two values are equal and makes the test fail if they are not. The
    `assertNotEqual` method performs the inverse operation, checking whether two values
    are equal and failing the test if they are.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们已经在之前的代码示例中看到了`assertEqual`方法；它检查两个值是否相等，如果不相等则使测试失败。`assertNotEqual`方法执行相反的操作，检查两个值是否相等，如果相等则使测试失败。
- en: The `assertAlmostEqual` and `assertNotAlmostEqual` methods are for use with
    floating point numbers.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertAlmostEqual`和`assertNotAlmostEqual`方法用于浮点数。'
- en: The way computers handle floating point numbers indicates that numbers that
    should be exactly equal actually differ in their least significant bits. For example,
    if we square the square root of seven, the result is not exactly seven, so `assertEqual`
    will treat it as *not equal*. However, `assertAlmostEqual` will recognize that
    the two numbers are the same for practical purposes.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机处理浮点数的方式表明，本应完全相等的数字实际上在最低有效位上有所不同。例如，如果我们平方七的平方根，结果不是正好七，所以`assertEqual`会将其视为*不相等*。然而，`assertAlmostEqual`会认识到这两个数字在实用目的上是相同的。
- en: The `assertGreaterEqual`, `assertLess`, and `assertLessEqual` methods check
    for ordering relationships between their arguments.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertGreaterEqual`、`assertLess`和`assertLessEqual`方法检查它们参数之间的顺序关系。'
- en: The `assertIs` and `assertIsNot` methods check whether their arguments are references
    to the exact same object.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertIs`和`assertIsNot`方法检查它们的参数是否是相同对象的引用。'
- en: The `assertIsNone` and `assertIsNotNone` methods are a special case of `assertIs`
    and `assertIsNot` methods and check whether their single argument is in fact `None`.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertIsNone`和`assertIsNotNone`方法是`assertIs`和`assertIsNot`方法的特例，并检查它们的单个参数是否实际上是`None`。'
- en: The `assertIsInstance` and `assertIsNotInstant` methods check whether the object
    in the first argument is an instance of the type in their second argument.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertIsInstance`和`assertIsNotInstance`方法检查第一个参数中的对象是否是其第二个参数中类型的实例。'
- en: The `assertIn` and `assertNotIn` check whether the object in the first argument
    is a member of the container in their second argument.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertIn`和`assertNotIn`检查第一个参数中的对象是否是第二个参数中容器的一个成员。'
- en: The `assertCountEqual` method is interesting. If we want to check whether two
    sequences are the same, we could just use `assertEqual`, but `assertCountEqual`
    is for when we want to check whether two sequences contain the same values but
    don't care about the order.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assertCountEqual`方法很有趣。如果我们想检查两个序列是否相同，我们可以直接使用`assertEqual`，但`assertCountEqual`是在我们想检查两个序列包含相同的值但不在乎顺序时使用的。'
- en: The method will cause a test to fail if any of the members of either sequence
    appears in the other sequence a different number of times. So, if `a` is in the
    first sequence twice, it has to be in the second sequence twice as well, but we
    don't care where.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果任一序列中的任何成员在另一个序列中出现的次数不同，该方法将导致测试失败。因此，如果`a`在第一个序列中出现两次，它必须在第二个序列中也出现两次，但我们不在乎它在哪。
- en: Finally, we have `assertRaises`, which functions a little differently because
    it needs to catch the exception raised by running some code. This is a situation
    tailor-made for a context manager, and that's what `assertRaises` is.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们有`assertRaises`，它的工作方式略有不同，因为它需要捕获运行某些代码时抛出的异常。这是一个非常适合上下文管理器的情况，这就是`assertRaises`的作用。
- en: Used in a `with` statement, `assertRaises` makes the test fail if the code inside
    the with block does not raise the expected exception. This could seem a little
    backward, but it's correct. The test fails if the expected exception is not raised.
    Sometimes, raising an exception is the correct behavior. For example, passing
    `None` to the end constructor should raise a type error, and if it doesn't, that's
    a bug.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在`with`语句中使用，如果`with`块内的代码没有抛出预期的异常，`assertRaises`会使测试失败。这看起来可能有些反直觉，但这是正确的。如果预期的异常没有被抛出，测试就会失败。有时抛出异常是正确的行为。例如，将`None`传递给构造函数的末尾应该抛出一个类型错误，如果没有抛出，那就是一个错误。
- en: Comparing what happens to what should happen in unit tests
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比较单元测试中发生的情况和应该发生的情况
- en: I mentioned in passing that all the unit tests in a `TestCase` class should
    share the same operating environment. What does that mean?
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我顺便提了一下，一个`TestCase`类中的所有单元测试都应该共享相同的操作环境。这意味着什么？
- en: It means that each of them expects any external data that they access to be
    in the same state. For example, each of the tests accesses a particular file and
    each of them expects to find the same information inside that file.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着它们中的每一个都期望它们访问的任何外部数据都处于相同的状态。例如，每个测试都访问一个特定的文件，并且每个测试都期望在文件中找到相同的信息。
- en: 'Let''s have a look at a code example:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个代码示例：
- en: '![](img/98fa707d-ae87-44d6-9552-ee7c54299fb3.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/98fa707d-ae87-44d6-9552-ee7c54299fb3.jpg)'
- en: In the preceding example, we have two tests that both read and write in the
    same text file. Both of them expected to come in to contain the same specific
    information when they started running. In other words, both of them have the same
    expectations about their operating environment.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们有两个测试，它们都在同一个文本文件中读写。它们都期望在开始运行时包含相同的具体信息。换句话说，它们对它们的操作环境有相同的期望。
- en: When we have multiple tests that share the same expectations and they're logically
    related, we should group them into a single `TestCase` class. Then, we should
    give that class a `setUp` method, which would be responsible for making sure those
    shared expectations are met, and possibly a `tearDown` method, which would clean
    up any changes that `setup` may have made or the tests left lying around.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有多组具有相同期望且逻辑上相关的测试时，我们应该将它们组合成一个单独的`TestCase`类。然后，我们应该给这个类提供一个`setUp`方法，该方法是负责确保这些共享期望得到满足的，可能还有一个`tearDown`方法，该方法是清理`setup`可能做出的任何更改或测试留下的任何更改。
- en: The name of the class itself doesn't matter; simply inheriting from `TestCase`
    is sufficient to identify them.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 类的名称本身并不重要；仅仅从`TestCase`继承就足以识别它们。
- en: The `setUp` method is run before each unit test in `TestCase`. So, in our code
    example, which has two unit tests, `setUp` is run twice. Similarly, `tearDown`
    runs after each unit test. That way, the changes that one test might make to the
    operating environment are removed before the next test is run.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`setUp`方法在`TestCase`中的每个单元测试之前运行。因此，在我们的代码示例中，它有两个单元测试，`setUp`运行两次。同样，`tearDown`在每个单元测试之后运行。这样，一个测试可能对操作环境所做的更改在下一个测试运行之前就会被清除。'
- en: The starting environment is the same for each unit test in `TestCase`. So, that's
    the basic mechanics of Python's unit test framework, as far as writing tests goes.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在`TestCase`中的每个单元测试的起始环境都是相同的。因此，这就是Python单元测试框架在编写测试方面的基本机制。
- en: To run the tests, we just need to invoke the `unittest` package from the command
    line. We tell it the name of the module we want to run the tests from and it finds
    the `TestCase` classes in that module, creates instances of them, runs all their
    tests, and gives us a report on which test has passed and which failed.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行测试，我们只需要从命令行调用`unittest`包。我们告诉它我们想要从中运行测试的模块的名称，它会找到该模块中的`TestCase`类，创建它们的实例，运行所有测试，并给我们一个报告，告诉我们哪些测试通过了，哪些失败了。
- en: In this section, we've seen how to write basic unit tests and run them. There
    are even easier ways to run a test, but we'll look at them after we examine unit
    test mock objects.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们看到了如何编写基本的单元测试并运行它们。还有更简单的方式来运行测试，但我们在检查单元测试模拟对象之后会讨论它们。
- en: Using unittest.mock
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用unittest.mock
- en: In this section, we'll take a look at a subpackage of unit tests, called **mock**.
    The tools in the `mock` package help us keep our test isolated, so they aren't
    made to succeed or fail based on the behavior of the code, which isn't supposed
    to be covered by the test.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨一个单元测试子包，称为**mock**。`mock`包中的工具帮助我们保持测试的隔离性，因此它们不是基于代码的行为来成功或失败，而这些代码本不应该被测试覆盖。
- en: We talked about how important it is that unit tests only interact with a small
    section of code, but how can we arrange for this when so many pieces of code interact
    with objects and functions originating from all over the source tree? One answer
    is that we can replace those objects and functions with mock objects.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了单元测试只与一小部分代码交互的重要性，但当我们有这么多代码与来自整个源树的代码和函数交互时，我们如何安排这种情况？一个答案是我们可以用模拟对象替换那些对象和函数。
- en: What is a mock object?
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是模拟对象？
- en: 'A mock object is a clever piece of code; it could pretend to be almost any
    kind of object or function, but instead of doing whatever the original did, it
    just records what is done with it so we can check it later. Let''s play with a
    mock object for a moment to get a feel for them:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟对象是一段巧妙的代码；它可以假装成几乎任何类型的对象或函数，但它不会执行原始对象所做的任何事情，而是记录与之交互的内容，以便我们稍后进行检查。让我们暂时玩一下模拟对象，以了解它们：
- en: '![](img/7f6f5d9c-a63d-47f0-a209-5acfeae4291d.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7f6f5d9c-a63d-47f0-a209-5acfeae4291d.png)'
- en: 'Refer to the preceding screenshot. We can access pretty much any attribute
    of the mock object without defining it ahead of time. The result is another mock
    object. Similarly, we can call almost any method we want without defining it ahead
    of time and the result is yet another mock object, as shown here:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 参考前面的截图。我们可以访问模拟对象的几乎所有属性，而无需事先定义它。结果是另一个模拟对象。同样，我们可以调用几乎任何我们想要的方法，而无需事先定义它，结果是另一个模拟对象，如下所示：
- en: '![](img/5b47ead3-58d4-4b53-ad62-45733cb5c96c.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5b47ead3-58d4-4b53-ad62-45733cb5c96c.png)'
- en: This by itself is enough to let a mock object replace a large range of functions
    and objects that our tested code might interact with. But, we can go further if
    we take time to preconfigure our mock objects.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 仅此一项就足以让模拟对象替代我们测试代码可能与之交互的大量函数和对象。但是，如果我们花时间预先配置我们的模拟对象，我们还可以更进一步。
- en: Preconfiguring mock objects
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 预配置模拟对象
- en: 'We can assign non-mock objects to a mock object''s attributes, so that when
    we access the attribute, we''d get a specific value instead of a generic mock
    object. This is illustrated by the following simple code example:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将非模拟对象分配给模拟对象的属性，这样当我们访问属性时，我们会得到一个特定的值，而不是一个通用的模拟对象。以下简单的代码示例说明了这一点：
- en: '![](img/19118bc9-a4f4-4b04-9ac5-99a35565a323.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/19118bc9-a4f4-4b04-9ac5-99a35565a323.png)'
- en: 'We can also assign a customized mock object in place of a method so that we
    can make the mocked method act more like the original, but in a way, this is controlled
    by the test. We do this by passing a return value parameter to the `mock` constructor,
    which tells the mock object that every time it''s called, it should return this
    value, as shown in the following code example:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将自定义的模拟对象分配给方法，这样我们就可以使模拟方法更像原始方法，但以某种方式，这是由测试控制的。我们通过将返回值参数传递给`mock`构造函数来实现这一点，这告诉模拟对象每次被调用时都应该返回这个值，如下面的代码示例所示：
- en: '![](img/d3f02ce0-f6fc-4068-9296-62b6c58f5af9.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d3f02ce0-f6fc-4068-9296-62b6c58f5af9.png)'
- en: 'If we want the mock to return different values each time it''s called, we use
    a different parameter of the constructor, called `side_effect`, as shown next:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望模拟每次调用时返回不同的值，我们使用构造函数的另一个参数，称为`side_effect`，如下所示：
- en: '![](img/569e85fd-7bb3-440d-97c1-c9417abb0980.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/569e85fd-7bb3-440d-97c1-c9417abb0980.png)'
- en: We have to know how many times the test will call the mock as a function so
    we can provide a return value for each call; otherwise, this doesn't present a
    difficulty.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须知道测试将多少次将模拟对象作为函数调用，这样我们才能为每次调用提供返回值；否则，这不会构成困难。
- en: 'We can also make the mock object raise an exception by passing that exception
    as `side_effect` or a member of the `side_effect` sequence, as shown in the following
    code example:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过传递异常作为`side_effect`或`side_effect`序列的成员来使模拟对象引发异常，如下面的代码示例所示：
- en: '![](img/ccc3c1a1-9c8a-4d86-a112-76fbd4cda1a4.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ccc3c1a1-9c8a-4d86-a112-76fbd4cda1a4.png)'
- en: That pretty well covers how to make a mock that can, in a controlled way, stand
    in for real objects and code while we run our test. However, to really support
    testing, we also need to be able to check the mock and confirm whether it was
    used as expected.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上涵盖了如何创建一个模拟对象，在测试运行期间，以受控的方式代替真实对象和代码。然而，为了真正支持测试，我们还需要能够检查模拟对象并确认它是否按预期使用。
- en: assert methods of mock objects
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟对象的断言方法
- en: We've already seen the `method_calls` attribute that mock objects use to track
    their interactions, but mock objects also have their own assert methods that are
    usually easier to use than accessing the method calls' list directly.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了模拟对象使用的`method_calls`属性，用于跟踪它们的交互，但模拟对象也有它们自己的断言方法，通常比直接访问方法调用列表更容易使用。
- en: 'The most useful mock object assertion method is `assert_called_with` (refer
    to the following code example):'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 最有用的模拟对象断言方法是`assert_called_with`（请参考以下代码示例）：
- en: '![](img/6df0132d-256c-402b-b856-50ada446cdb3.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6df0132d-256c-402b-b856-50ada446cdb3.png)'
- en: It checks whether the most recent call to the mock object was done with a specified
    argument and `assert_any_call`, which checks whether the mock has ever been called
    with specified arguments.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 它检查最近对模拟对象的调用是否使用了指定的参数，以及`assert_any_call`，它检查模拟对象是否曾经使用指定的参数被调用。
- en: So, we know what mock objects are for, how to create them, and how to check
    the record of what has been done with them. That's enough for replacing the parameters
    of a tested function with mock objects.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们知道模拟对象的作用，如何创建它们，以及如何检查对它们的操作记录。这足以用模拟对象替换测试函数的参数。
- en: 'We can even replace the `self` parameter of methods if we call the method via
    the class instead of a real instance:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以通过类而不是真实实例来调用方法，从而替换方法的`self`参数：
- en: '![](img/69345cc7-00c3-45e4-954c-c75ebfb17d07.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/69345cc7-00c3-45e4-954c-c75ebfb17d07.png)'
- en: The unittest.mock patch function
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: unittest.mock的patch函数
- en: What do we do, though, when the code we're testing reaches out to the system
    automatically and accesses something we want to replace with a mock object? For
    example, what if the code we're testing calls `time.time`? This is where the `unittest.mock``patch`
    function comes into play.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当我们测试的代码自动向系统发出请求并访问我们想要用模拟对象替换的内容时，我们该怎么办呢？例如，如果我们正在测试的代码调用了`time.time`，那会怎样？这就是`unittest.mock`中的`patch`函数发挥作用的地方。
- en: 'The `patch` function is a context manager and it could temporarily replace
    nearly any object in any package or module with a mock object. Once the with block
    exits, the real object is restored to its position, as shown in the following
    code example:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`patch`函数是一个上下文管理器，它可以临时用模拟对象替换任何包或模块中的任何对象。一旦退出with块，真实对象就会恢复到其位置，如下面的代码示例所示：'
- en: '![](img/a79484dd-4f79-4a7b-af0c-66fe2b7650ac.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a79484dd-4f79-4a7b-af0c-66fe2b7650ac.png)'
- en: Something to be aware of is that patch doesn't replace every reference to the
    target object with a mock; it only replaces the single reference that we specified
    in the first argument.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，patch不会替换对目标对象的每个引用，它只替换我们在第一个参数中指定的单个引用。
- en: In the preceding example, any code that accesses the time function by looking
    up the reference in the `time` module will get our mock object; however, if there
    were any code that had used `from time``import time` to create a local reference
    to the `time` function, then that reference would still refer to the real-time
    function. If we want to patch the time function for code that has a local reference
    to it, we need to pass the path to that local reference into the patch.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，任何通过在`time`模块中查找引用来访问时间函数的代码都将得到我们的模拟对象；然而，如果有任何代码使用了`from time import
    time`来创建对`time`函数的局部引用，那么这个引用仍然会指向真实的时间函数。如果我们想为有局部引用的代码修补时间函数，我们需要将那个局部引用的路径传递给patch。
- en: OK, we're pretty much good to go with mock objects now. This means we know everything
    we need to write powerful tests easily. All we are left to do is find out how
    to run our test suites, which is our next topic.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们现在对模拟对象已经相当熟悉了。这意味着我们知道我们需要的一切来轻松编写强大的测试。我们剩下要做的就是找出如何运行我们的测试套件，这是我们下一个话题。
- en: Using unittest's test discovery
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用unittest的测试发现
- en: In this section, we'll take a look at the `unittest` package's ability to run
    many tests at once with a single command.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨`unittest`包使用单个命令同时运行多个测试的能力。
- en: We've seen how to easily run all the tests in a particular file, but for a large
    project, putting all the tests into a single file would be troublesome. They need
    to be separated into different files according to logical groupings, or the test
    suite will become unmanageable. On the other hand, it would be a pain to have
    to manually tell unittests to run the test and a whole bunch of files if we were
    to test or list out each file.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何轻松地运行特定文件中的所有测试，但对于大型项目来说，将所有测试放入单个文件中将会很麻烦。它们需要根据逻辑分组分离到不同的文件中，否则测试套件将变得难以管理。另一方面，如果我们需要手动告诉
    unittests 运行测试和一大堆文件，这将是一件痛苦的事情。
- en: 'Fortunately, there''s a way to split our test suites into many files and still
    run them with a simple command, as shown in the following code:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们可以将测试套件拆分成多个文件，同时仍然可以通过简单的命令来运行它们，如下面的代码所示：
- en: '![](img/6033f8db-20e3-48e9-9200-4678b4313bbd.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6033f8db-20e3-48e9-9200-4678b4313bbd.png)'
- en: We use a unit testing tool that supports test discovery. This basically just
    means it looks at the available files and decides for itself which ones seems
    like a test file; then it loads the test from those files and runs them.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用支持测试发现的单元测试工具。这基本上意味着它会查看可用的文件，并自行决定哪些看起来像测试文件；然后它从这些文件中加载测试并运行。
- en: Unittest's discovery tool
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Unittest的发现工具
- en: 'The `unittest` package has a basic but useful built-in test discovery tool.
    When we run `python -m unittest discover`, it searches the current directory for
    Python S, whose names start with the word `test`. In addition, it recursively
    performs the same scan on any subdirectories that contain an `init.py` file. Once
    it collects the names of all the matching modules, it runs the test just as if
    we''d specified the modules on the command line ourselves. This can be illustrated
    using the following code example:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`unittest` 包有一个基本但有用的内置测试发现工具。当我们运行 `python -m unittest discover` 时，它会搜索当前目录中的
    Python S，其名称以单词 `test` 开头。此外，它还会递归地对包含 `init.py` 文件的任何子目录执行相同的扫描。一旦收集到所有匹配模块的名称，它就会像我们自己在命令行上指定模块一样运行测试。这可以通过以下代码示例来说明：'
- en: '![](img/c5e2ebaf-4813-499b-b5ab-b4d73113f842.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c5e2ebaf-4813-499b-b5ab-b4d73113f842.png)'
- en: Command-line options in unit test discovery
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试发现中的命令行选项
- en: There are a few command-line options we can use to adjust the behavior of unit
    test discovery. The first, which we saw in the previous code example, is the `-v`
    switch. This switch makes test reports somewhat more verbose. We used it in the
    previous code so we could see that the discovery had worked properly.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用一些命令行选项来调整单元测试发现的行为。第一个，我们在之前的代码示例中看到了，是 `-v` 开关。此开关使得测试报告更加详细。我们在之前的代码中使用它，以便可以看到发现是否正常工作。
- en: 'We can also use the `-p` command-line option (as shown in the following code
    example) to change the pattern that is used to recognize test files:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用 `-p` 命令行选项（如下面的代码示例所示）来更改用于识别测试文件的模式：
- en: '![](img/ef21fcda-2637-4042-be24-205bf43016f7.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ef21fcda-2637-4042-be24-205bf43016f7.png)'
- en: Here, we've changed it so that the filenames ending in the word `one.py` are
    recognized as test files.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将其修改为将以单词 `one.py` 结尾的文件识别为测试文件。
- en: 'The unittest discover code also recognizes `-s` to specify the directory where
    the test search should start. This is shown in the following code example:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: unittest discover 代码还识别 `-s` 来指定测试搜索应该开始的目录。这如下面的代码示例所示：
- en: '![](img/8642c979-0002-47b1-bee8-224ba8ca01ca.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8642c979-0002-47b1-bee8-224ba8ca01ca.png)'
- en: 'Notice that by making a suite act as the starting directory for the search,
    we''ve stopped it from being recognized as a package containing the test. If that''s
    a problem, we could supplement the `-s` option with `-t` (refer to the following
    code example), which tells you to test where to find the top-level directory for
    this run:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，通过使套件作为搜索的起始目录，我们阻止了它被识别为包含测试的包。如果这成问题，我们可以通过添加 `-t` 选项来补充 `-s` 选项（参考以下代码示例），这会告诉你在哪里找到此运行的顶层目录：
- en: '![](img/6dfdadf5-033f-4820-ad29-364dbc8bff55.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6dfdadf5-033f-4820-ad29-364dbc8bff55.png)'
- en: Using both `-s` and `-t`, we're able to narrow the test search to a particular
    subdirectory while still running the tests in the context of a parent directory.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `-s` 和 `-t` 两个选项，我们能够将测试搜索缩小到特定的子目录，同时仍然在父目录的上下文中运行测试。
- en: There's a bit of a pitfall to be aware of when using unit test discovery code
    or any other test discovery that works by importing modules to check whether they
    contain tests. This pitfall is that the modules are imported.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用单元测试发现代码或任何通过导入模块来检查是否包含测试的其他测试发现时，需要注意一些陷阱。这个陷阱是模块被导入。
- en: Most of the time, that's not a problem, but if a piece of test discovery code
    imports the module that was meant to be a program's entry point, it might result
    in actually running the program, which is not the desired behavior. It's easy
    to avoid this problem when we're writing an entry point by wrapping the entry
    point code in the `if '__name__' = = '__main__'` statement.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，这不会成为问题，但如果一段测试发现代码导入了本应作为程序入口点的模块，它可能会实际运行程序，这不是我们期望的行为。当我们编写入口点时，通过将入口点代码包裹在`if
    '__name__' == '__main__'`语句中，很容易避免这个问题。
- en: However, if we, or somebody else, skips this check and unittest thinks the file
    looks like a test file, running unit test discovery code will have surprising
    results. That's all there is in regard to unittest's test discovery tool. It doesn't
    have many features, but it does have the features that everybody needs, and there's
    a good chance that it's all we'll need for the majority of our projects.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们或其他人跳过了这个检查，而单元测试认为文件看起来像是一个测试文件，运行单元测试发现代码将会得到令人惊讶的结果。这就是关于unittest测试发现工具的所有内容。它没有很多功能，但它确实拥有大家需要的功能，而且有很大可能性，对于我们的大多数项目来说，这已经足够了。
- en: For cases where we need more from our test discovery tool, we can use `nose`,
    which we'll look at in the next section.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们需要从测试发现工具中获得更多功能的情况，我们可以使用`nose`，我们将在下一节中探讨。
- en: Using nose for unified test discovery and reporting
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用nose进行统一的测试发现和报告
- en: 'Note that `nose` is a third-party tool available via `pip` and Python Package
    Index. It does basically the same job as a unittest `discover` command, but it
    supports more control and customization as well as recognizing a wider range of
    tests. It can be installed using the following command line:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`nose`是一个通过`pip`和Python包索引提供的第三方工具。它基本上与unittest的`discover`命令做相同的工作，但它提供了更多的控制和定制，以及识别更广泛的测试。可以使用以下命令行安装：
- en: '[PRE0]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '****![](img/10500722-c392-45b0-a574-59846bb4432a.jpg)****'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '****![图片](img/10500722-c392-45b0-a574-59846bb4432a.jpg)****'
- en: Running our tests with nose
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用nose运行我们的测试
- en: 'We''re going to look at two specific features among the many that nose provides.
    These are:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨nose提供的众多功能中的两个特定功能。这些是：
- en: It can generate a code coverage report that tells us how much of the code our
    test actually tested
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以生成一个代码覆盖率报告，告诉我们我们的测试实际上测试了多少代码
- en: It can run tests across multiple processes, allowing them to be executed in
    parallel on multiple CPUs
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以在多个进程中运行测试，允许它们在多个CPU上并行执行
- en: 'In order to get a coverage report, we first need to make sure that the coverage
    module is installed. We could do this with a simple `pip` command, as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获取覆盖率报告，我们首先需要确保覆盖率模块已安装。我们可以使用简单的`pip`命令来完成，如下所示：
- en: '[PRE1]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '****![](img/e2995c59-4230-46cc-a2bd-aebd4a404923.jpg)****'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '****![图片](img/e2995c59-4230-46cc-a2bd-aebd4a404923.jpg)****'
- en: Once we have the `coverage` module in place, we can enable a coverage report
    for our test with nothing more than a couple of nose's command-line options.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了`coverage`模块，我们只需使用几个nose的命令行选项，就可以为我们的测试启用覆盖率报告。
- en: 'Strictly speaking, only the `--with-coverage` option is required to enable
    the coverage report, as shown in the following code example:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 严格来说，只需要`--with-coverage`选项来启用覆盖率报告，如下面的代码示例所示：
- en: '![](img/d070144f-452a-4ba8-9b6c-c0605a196ba0.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d070144f-452a-4ba8-9b6c-c0605a196ba0.png)'
- en: However, if we don't include `--cover-erase` as well, coverage data from previous
    test runs will get mixed with our current run, which will make the results harder
    to interpret.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们没有包括`--cover-erase`，之前的测试运行中的覆盖率数据将与当前的运行混合，这将使结果更难解释。
- en: The cover-package option
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: cover-package选项
- en: 'There''s a third coverage-related command-line option that is sometimes useful.
    It is the `cover-package` option; it narrows down the code coverage report to
    only a specific package, as shown in the following code example:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个与覆盖率相关的命令行选项有时很有用。它是`cover-package`选项；它将代码覆盖率报告限制为仅针对特定包，如下面的代码示例所示：
- en: '![](img/630e8538-4e98-408f-8698-4a3ddf272273.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/630e8538-4e98-408f-8698-4a3ddf272273.png)'
- en: Focusing the report this way can make it easier to read and extract useful information.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式聚焦报告可以使阅读和提取有用信息变得更容易。
- en: Testing multiple worker processes
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试多个工作进程
- en: 'The other nose feature we''re going to look at is the ability to farm out tests
    to multiple worker processes and thus spread them across the available CPU cores.
    To test multiple worker processes, we just have to provide the `--processes=`
    command-line option and tell it how many processes to use. If we pass `-1` to
    indicate the number of processes, it uses the detected number of CPU cores, which
    is probably what we want anyway (refer to the following code example):'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要探讨的另一个nose功能是能够将测试分配给多个工作进程，并将它们分散到可用的CPU核心上。要测试多个工作进程，我们只需提供`--processes=`命令行选项，并告诉它要使用多少个进程。如果我们传递`-1`来表示进程数，它将使用检测到的CPU核心数，这可能是我们想要的（参考以下代码示例）：
- en: '![](img/69feb791-f01e-40d2-9bc9-84b05d60e7a2.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/69feb791-f01e-40d2-9bc9-84b05d60e7a2.jpg)'
- en: So, unless we have a specific reason to do otherwise, we should always just
    use `-1`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，除非我们有特定的理由要这样做，否则我们应该始终只使用`-1`。
- en: If we look carefully at the preceding code example, we can see that it actually
    took longer to run our test suite on multiple processes. That's because conducting
    the tests themselves involves low effort, but it's not the same when it comes
    to launching a worker process. Fortunately, that's a fixed cost, so when we start
    running larger test suites that contain more expensive tests, we start seeing
    the benefits of parallel execution.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们仔细观察前面的代码示例，我们可以看到在多个进程中运行我们的测试套件实际上花费了更长的时间。这是因为执行测试本身涉及到的努力很小，但当涉及到启动工作进程时，情况就不同了。幸运的是，这是一个固定成本，所以当我们开始运行包含更多昂贵测试的大型测试套件时，我们开始看到并行执行的好处。
- en: This was just a taste of the sort of features that nose supports and that's
    without writing our own nose plugins to customize it further. It's a very capable
    system, so if we find ourselves needing a particular feature from our test runner,
    a good first step is to see whether nose already has that feature.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是对nose支持的功能类型的一个尝鲜，而且这还不包括我们编写自己的nose插件来进一步定制它的情况。这是一个非常强大的系统，所以如果我们发现自己需要测试运行器中的特定功能，一个好的第一步是看看nose是否已经具备该功能。
- en: Summary
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to use the `unittest` and `unittest.mock` packages
    to write an automated test; we also learned the process of test-driven development.
    Next, we saw how to use `unittest.mock` to control the environment that our test
    code runs in so that the test can remain focused on making sure one thing works
    properly. Post this, we learned how to run a test using Python's built-in unit
    test tools, and finally, we discussed how to take advantage of a couple of features
    of the nose test runner.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用`unittest`和`unittest.mock`包来编写自动化测试；我们还学习了测试驱动开发的过程。接下来，我们看到了如何使用`unittest.mock`来控制测试代码运行的环境，以便测试可以保持专注于确保某件事正确工作。在此之后，我们学习了如何使用Python内置的单元测试工具运行测试，最后，我们讨论了如何利用nose测试运行器的几个功能。
- en: In the next chapter, we're going to take a look at the reactive programming
    paradigm and RxPY.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨响应式编程范式和RxPY。
