- en: Chapter 8. Introduction to Arduino Networking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we used a hardwired serial connection to interact with Arduino, a serial
    monitor to observe the Arduino serial data, and a Python serial library (`pySerial`)
    to transfer data between the Arduino and Python applications. During this entire
    exchange, the range of communication was limited due to the hardwired serial connection.
    As a solution, you can use a wireless protocol such as **ZigBee**, **Bluetooth**,
    or other RF channels to establish a communication channel for a remote serial
    interface. These wireless protocols are extensively used in remote hardware applications,
    and they use the serial interface to transfer data. Due to their use of serial
    communication, these protocols require very little to no additional programming
    changes on the Arduino or Python side. You may require additional hardware to
    enable these protocols, however. The major benefit of these protocols is that
    they are really easy to implement. However, they are restricted with only a small
    geographical coverage area and limited data bandwidth.
  prefs: []
  type: TYPE_NORMAL
- en: Besides serial communication methods, the other way to remotely access your
    Arduino device is to use a computer network. Today, computer networks are the
    most prolific way of communicating between computing units. In the next two chapters,
    we will explore various networking techniques using Arduino and Python, which
    range from establishing very basic Ethernet connectivity to developing complex,
    cloud-based web applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The fundamentals of networking and hardware extensions that enable networking
    for Arduino
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python frameworks used to develop **Hypertext Transfer Protocol** (**HTTP**)
    web servers on your computer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interfacing Arduino-based HTTP clients with the Python web server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IoT messaging protocol MQTT (we will install a middleware tool called **Mosquitto**
    to enable MQTT on our computer)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Utilizing the publisher/subscriber paradigm, used by MQTT, to develop Arduino-Python
    web applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arduino and the computer networking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Computer networking is a huge domain, and covering every aspect of networking
    is not the main objective of this book. We will, however, try to explain a few
    fundamentals of computer networking wherever this knowledge will need to be applied.
    Unlike the serial interface approach, where a point-to-point connection is required
    between devices, the network-based approach provides distributed access to resources.
    Specifically in hardware applications where a single hardware unit is required
    to be accessed by multiple endpoints (for example, in a personal computer, mobile
    phone, or remote server), the computer network stands superior.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will cover the basics of networking and hardware components
    that enable networking in Arduino. Later in this chapter, we will use the Arduino
    library and a built-in example to demonstrate how remote access to Arduino using
    your local network works.
  prefs: []
  type: TYPE_NORMAL
- en: Networking fundamentals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Whenever you see a computer or mobile device, you are also looking at some type
    of computer network being used to connect those devices with other devices. In
    simple terms, a computer network is a group of interconnected computational devices
    (also called network nodes) that allow the exchange of data between these devices.
    These network nodes include various devices such as your personal computers, mobile
    phones, servers, tablets, routers, and other pieces of networking hardware.
  prefs: []
  type: TYPE_NORMAL
- en: A computer network can be classified into numerous types according to parameters
    such as geographical location, network topology, and organizational scope. In
    terms of geographical scale, a network can be categorized into **local area network**
    (**LAN**), **home area network** (**HAN**), **wide area network** (**WAN**), and
    so on. When you are utilizing your home router to connect to the Internet, you
    are using the LAN created by your router. With regards to the organization that
    handles the network, LAN can be configured as Intranet, Extranet, and Internet.
    The Internet is the largest example of any computer network, as it interconnects
    all types of networks deployed globally. In your implementation of various projects
    throughout this book, you will mostly be using your LAN and the Internet for the
    exchange of data between an Arduino, your computer, the Raspberry Pi, and the
    cloud services.
  prefs: []
  type: TYPE_NORMAL
- en: To standardize communication between network nodes, various governing bodies
    and organizations have created a set of rules called **protocols**. In the large
    list of standard protocols, there are a few protocols that your computer uses
    on a daily basis. The examples of those protocols associated with the local area
    network include Ethernet and Wi-Fi. In the IEEE 802 family of standards, the IEEE
    802.3 standard describes different types of wired connectivity between nodes in
    a local area network, also called Ethernet. Similarly, Wireless LAN (also referred
    to as Wi-Fi), is part of the IEEE 802.11 standard, where a communication channel
    uses wireless frequency bands to exchange data.
  prefs: []
  type: TYPE_NORMAL
- en: Most network nodes deployed with IEEE 802 standards (that is, Ethernet, Wi-Fi,
    and so on) have a unique identifier assigned to the network interface hardware,
    called a **media access control** (**MAC**) address. This address is assigned
    by the manufacturer and is mostly fixed for each network interface. While using
    Arduino for network connectivity, we will need the MAC address to enable networking.
    A MAC address is a 48-bit address, and in human-friendly form it contains six
    groups of two hexadecimal digits. For example, 01:23:45:67:89:ab is the human-readable
    form of a 48-bit MAC address.
  prefs: []
  type: TYPE_NORMAL
- en: While the MAC address is associated with the hardware-level (that is, "physical")
    protocols, the **Internet Protocol** (**IP**) is a communication protocol that
    is widely used at the Internet level to enable internetworking between networked
    nodes. In the implementation of version 4 of the IP protocol suite (IPv4), each
    network node is assigned a 32-bit number called the **IP address** (for example,
    192.168.0.1). When you connect a computer, phone, or any other device to your
    local home network, an IP address is assigned to that device by your router. One
    of the most popular IP addresses is 127.0.0.1, which is also called the **localhost**
    IP address. Apart from the IP address assigned to a computer by the network, each
    computer also has the localhost IP address associated with it. The localhost IP
    address is very useful when you want to internally access or call your computer
    from the same device. In the case of a remote-access application, you need to
    know the IP address assigned by the network.
  prefs: []
  type: TYPE_NORMAL
- en: Obtaining the IP address of your computer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Arduino is a resource-constrained device, and therefore it can only demonstrate
    a limited amount of network capability. While working with Arduino-based projects
    that include the utilization of a computer network, you will require a server
    or Gateway interface. These interfaces include, but are not limited to, a desktop
    computer, a laptop, the Raspberry Pi, and other remote computing instances. If
    you are using these interfaces as part of your hardware project, you will need
    their IP addresses. Ensure that they are under the same network as your Arduino.
    The following are the techniques to obtain IP addresses in major operating systems.
  prefs: []
  type: TYPE_NORMAL
- en: Windows
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In most versions of the Windows OS, you can obtain the IP address from the
    **Network Connection** utility in **Control Panel**. Navigate to **Control Panel**
    | **Network and Internet** | **Network Connections** and open the **Local Area
    Connection Status** window. Click on the **Details** button to see the details
    of the **Network Connection Details** window. As you can see in this screenshot,
    the IP address of the network interface is listed as **IPv4 Address** in the opened
    window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Windows](img/5938OS_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can also obtain the IP address of your computer using the built-in `ipconfig`
    utility. Open the Command Prompt and enter the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the following screenshot, the IP address of your computer
    is listed under the Ethernet adapter. If you are using a wireless connection to
    connect to your network, the Ethernet adapter will be replaced by the wireless
    Ethernet adapter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Windows](img/5938OS_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Mac OS X
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are using Mac OS X, you can obtain the IP address from the network settings.
    Open **System Preferences** and click on the **Network** icon. You will see a
    window similar to what is shown in the next screenshot. In the left sidebar, click
    on the interface you are looking to obtain the IP address of.
  prefs: []
  type: TYPE_NORMAL
- en: '![Mac OS X](img/5938OS_08_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If you want to get the IP address using the terminal, you can use the following
    command. This command will require you to enter the system name of the interface,
    `en0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are connected to multiple networks and are not aware of the network
    name, you can find the list of IP addresses associated with your computer, using
    the command shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in this screenshot, you will get all the network addresses associated
    with your Mac computer and other network parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Mac OS X](img/5938OS_08_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Linux
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'On the Ubuntu OS, you can obtain the IP address of your computer from the **Network
    Settings** utility. To open it, navigate to **System Settings** | **Network**
    and click on the adapter through which the computer is connected to your home
    network. You can select an appropriate adapter to obtain the IP address, as displayed
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Linux](img/5938OS_08_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In a Linux-based system, there are multiple ways of obtaining the IP address
    from the command line. You can use the same command (`ifconfig`) that we used
    in Mac OS X in the Linux environment to obtain the IP address of your computer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You can obtain the IP address from the `inet addr` field of the appropriate
    adapter, as displayed in this screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Linux](img/5938OS_08_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If supported by your operating system, another command that can be utilized
    to obtain the IP address is `hostname`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Be careful when using this utility to obtain the IP address, as you may end
    up getting the IP address of a different adapter if you are not familiar with
    the supported command options of the utility.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are going to connect your Arduino to the same local area network as your
    computer, make sure you are choosing the proper IP address that is covered by
    the same domain as that of your computer. Also ensure that no other network device
    is using the same IP address that you have selected for your Arduino. This practice
    will help you avoid IP address conflicts within the network.
  prefs: []
  type: TYPE_NORMAL
- en: Networking extensions for Arduino
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are various hardware devices available in the Arduino community that enable
    networking for the Arduino platform. Among these devices, a few can be used as
    extensions for your existing Arduino board, while others exist as standalone Arduino
    modules with networking capabilities. The most popular extensions used to enable
    networking are the Arduino Ethernet Shield and Arduino WiFi Shield. Similarly,
    Arduino Yún is an example of a standalone Arduino platform that includes built-in
    networking capabilities. In this book, we are going to develop various networking
    applications around the Arduino Ethernet Shield. There are also a few other extensions
    (Arduino GSM Shield) and standalone Arduino platforms (Arduino Ethernet, Arduino
    Tre, and so on), but we are not going to cover them in detail. Let's get familiar
    with the following Arduino extensions and board.
  prefs: []
  type: TYPE_NORMAL
- en: Arduino Ethernet Shield
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Arduino Ethernet Shield is an officially supported and open source network
    extension designed to work with Arduino Uno. The Ethernet Shield is equipped with
    an RJ45 connector to enable Ethernet networking. The Ethernet Shield is designed
    to mount on top of Arduino Uno and it extends the layout of the pins from your
    Arduino Uno to the top of the board. The Ethernet Shield is also equipped with
    a microSD card slot to store important files over the network. Just like most
    of these shield extensions, the Ethernet Shield is powered by the Arduino board
    it is attached to.
  prefs: []
  type: TYPE_NORMAL
- en: '![Arduino Ethernet Shield](img/5938OS_08_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Source: [http://arduino.cc/en/uploads/Main/ArduinoEthernetShield_R3_Front.jpg](http://arduino.cc/en/uploads/Main/ArduinoEthernetShield_R3_Front.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Every Ethernet Shield board is equipped with a unique hardware (MAC) address.
    You can see it on the back of the board. You may want to note down this hardware
    address, as it will be required frequently in the upcoming exercises. Also make
    sure that you get familiar with mounting the Arduino Ethernet Shield for those
    exercises. Buy an Arduino Ethernet Shield module from SparkFun or Amazon before
    your start working on any exercises. You can obtain additional information about
    this Shield at [http://arduino.cc/en/Main/ArduinoEthernetShield](http://arduino.cc/en/Main/ArduinoEthernetShield).
  prefs: []
  type: TYPE_NORMAL
- en: Arduino WiFi Shield
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Arduino WiFi Shield has a layout similar to that of the Arduino Ethernet
    Shield as far as mounting on top of the Arduino board is concerned. Instead of
    the Ethernet RJ45 connector, the WiFi Shield contains components to enable wireless
    networking. Using the WiFi Shield, you can connect to the IEEE 802.11 (Wi-Fi)
    wireless networks, which is one of the most popular ways of connecting computers
    to the home network nowadays.
  prefs: []
  type: TYPE_NORMAL
- en: '![Arduino WiFi Shield](img/5938OS_08_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Source: [http://arduino.cc/en/uploads/Main/A000058_front.jpg](http://arduino.cc/en/uploads/Main/A000058_front.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: The Arduino WiFi Shield requires additional power through a USB connector. It
    also contains a microSD slot to save files. Just like the Ethernet Shield, you
    can view the MAC address on the back of the board. More information about the
    Arduino WiFi Shield can be found at [http://arduino.cc/en/Main/ArduinoWi-FiShield](http://arduino.cc/en/Main/ArduinoWi-FiShield).
  prefs: []
  type: TYPE_NORMAL
- en: Arduino Yún
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Unlike the Ethernet Shield and the WiFi Shield, the Arduino Yún is a standalone
    variant of the Arduino board. It includes both Ethernet- and Wi-Fi-based network
    connectivity, in addition to the basic Arduino component—the microcontroller.
    Yún is equipped with the latest and more powerful processing units compared to
    Uno. Instead of the traditional way of using Arduino code, Yún supports a lightweight
    version of the Linux operating system, providing functionality similar to a single-board
    computer such as the Raspberry Pi. You can use your Arduino IDE to program Yún
    even while running Unix shell scripts.
  prefs: []
  type: TYPE_NORMAL
- en: '![Arduino Yún](img/5938OS_08_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Source: [http://arduino.cc/en/uploads/Main/ArduinoYunFront_2.jpg](http://arduino.cc/en/uploads/Main/ArduinoYunFront_2.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: You can find more information about Yún at the Arduino official website, at
    [http://arduino.cc/en/Main/ArduinoBoardYun](http://arduino.cc/en/Main/ArduinoBoardYun).
  prefs: []
  type: TYPE_NORMAL
- en: Arduino Ethernet library
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Arduino Ethernet library provides support for the Ethernet protocol, and
    hence provides support for Ethernet extensions of Arduino, such as the Ethernet
    Shield. This is a standard Arduino library and it gets deployed with the Arduino
    IDE.
  prefs: []
  type: TYPE_NORMAL
- en: 'The library is designed to accept incoming connection requests when deployed
    as a server and while making outgoing connections to other servers when being
    utilized as a client. The library concurrently supports up to four connections
    due to the limited computation capability of the Arduino board. To use the Ethernet
    library in your Arduino program, the first step you have to take is to import
    it in to your Arduino sketch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The Ethernet library implements various functionalities through specific classes,
    which are described as follows.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We are going to describe only the important methods provided by these classes.
    You can obtain more information regarding this library and its classes from [http://arduino.cc/en/Reference/Ethernet](http://arduino.cc/en/Reference/Ethernet).
  prefs: []
  type: TYPE_NORMAL
- en: The Ethernet class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `Ethernet` class is a core class of the Ethernet library, and it provides
    methods to initialize this library and the network settings. This is an essential
    class for any program that wants to use the Ethernet library to establish connections
    through the Ethernet Shield. The primary information required to establish this
    connection is the MAC address of the device. You''ll need to create a variable
    that has the MAC address as an array of 6 bytes, as described here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The Ethernet library supports the **Dynamic Host Control Protocol** (**DHCP**),
    which is responsible for dynamically assigning IP addresses to new network nodes.
    If your home network is configured to support DHCP, you can establish the Ethernet
    connection using the `begin(mac)` method from the `Ethernet` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Keep in mind that when you are initializing an Ethernet connection using this
    class, you are only initializing the Ethernet connection and setting up the IP
    address. This means that you still need to configure Arduino as a server or a
    client in order to enable further communication.
  prefs: []
  type: TYPE_NORMAL
- en: The IPAddress class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In applications where you have to manually assign the IP address to your Arduino
    device, you will have to use the `IPAddress` class of the Ethernet library. This
    class provides methods to specify the IP address, which can be either local or
    remote depending upon the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The IP address created using this method can be used in the initialization
    of the network connection that we performed in the previous section. If you want
    to assign a manual IP address to your Arduino, you can use the `begin(mac, ip)`
    method with the MAC and IP addresses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The Server class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `Server` class is designed to create a server using the Ethernet library
    on Arduino, which listens to incoming connection requests for a specific port.
    The `EthernetServer()` method, when specified with in integer value of the port
    number, initializes the server on Arduino:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'By specifying port `80` in the previous line of code (which represents the
    HTTP protocol on the TCP/IP suite), we have specifically created a web server
    using the Ethernet library. To start listening to the incoming connection requests,
    you have to use the `begin()` method on the `server` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Once the connection is established, you can respond to a request using various
    methods supported by the server class, such as `write()`, `print()`, and `println()`.
  prefs: []
  type: TYPE_NORMAL
- en: The Client class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `Client` class provides methods to create an Ethernet client to connect
    and communicate with servers. The `EthernetClient()` method initializes a client
    that can be connected to a specific server using its IP address and port number.
    The `connect(ip, port)` method on the `client` object will establish a connection
    with the server on the mentioned IP address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Client` class also has the `connected()` method, which provides the status
    of the current connection in binary. This status can be `true` (connected) or
    `false` (disconnected). This method is useful for the periodic monitoring of the
    connection status:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Other important client methods include `read()` and `write()`. These methods
    help the Ethernet client to read the request from the server and to send messages
    to the server respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 1 – a web server, your first Arduino network program
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The best way to test the Arduino Ethernet library and the Ethernet Shield is
    by using the built-in examples that are deployed with the Arduino IDE. If you
    are using version 1.x of the Arduino IDE, you can find a bunch of Ethernet examples
    by navigating to **File** | **Examples** | **Ethernet**. By utilizing one of these
    examples, we are going to build a web server that delivers the sensor values when
    requested by a web browser. As Arduino will be connected to your home network
    through the Ethernet, you will be able to access it from any other computer connected
    to your network. The major goals for this exercise are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: Use the Arduino Ethernet library with the Arduino Ethernet Shield extension
    to create a web server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remotely access Arduino using your home computer network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Utilize a default Arduino example to provide humidity and motion sensor values
    using a web server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To achieve these goals, the exercise is divided into the following stages:'
  prefs: []
  type: TYPE_NORMAL
- en: Design and build hardware for the exercise using your Arduino and the Ethernet
    Shield
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run a default example from the Arduino IDE as the starting point of the exercise
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modify the example to accommodate your hardware design and redeploy the code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The following is a Fritzing diagram of the circuit required for this exercise.
    The first thing you should do is mount the Ethernet Shield on top of your Arduino
    Uno. Ensure that all the pins of the Ethernet Shield are aligned with the corresponding
    pins of the Arduino Uno. Then you need to connect the previously used humidity
    sensor, HIH-4030, and the PIR motion sensor.
  prefs: []
  type: TYPE_NORMAL
- en: '![Exercise 1 – a web server, your first Arduino network program](img/5938OS_08_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While deploying the Arduino hardware for remote connectivity without USB, you
    will have to provide external power for the board, as you no longer have a USB
    connection to power the board.
  prefs: []
  type: TYPE_NORMAL
- en: Now connect your Arduino Uno to a computer using a USB cable. You will also
    need to connect Arduino to your local home network using an Ethernet cable. To
    do that, use a straight CAT5 or CAT6 cable and connect one end of the cable to
    your home router. This router should be the same device that provides network
    access to the computer you are using. Connect the other end of the Ethernet cable
    to the Ethernet port of the Arduino Ethernet Shield board. If the physical-level
    connection has been established correctly, you should see a green light on the
    port.
  prefs: []
  type: TYPE_NORMAL
- en: '![Exercise 1 – a web server, your first Arduino network program](img/5938OS_08_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now it''s time to start coding your first Ethernet example. Open the **WebServer**
    example by navigating to **File** | **Examples** | **Ethernet** | **WebServer**
    in your Arduino IDE. As you can see, the Ethernet library is included with the
    other required libraries and the supported code. In the code, you will need to
    change the MAC and IP addresses to make it work for your configuration. While
    you can obtain the MAC address of the Ethernet Shield from the back of the board,
    you will have to select an IP address according to your home network configuration.
    As you have already obtained the IP address of the computer you are working with,
    select another address in the range. Ensure that no other network node is using
    this IP address. Use these MAC and IP addresses to update the following values
    in your code. You will need to repeat these steps for every exercise when you
    are dealing with Arduino Ethernet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the IP network, the visible range of IP addresses for your network is a function
    of another address called **subnetwork** or **subnet**. The subnet of your LAN
    IP network can help you select the appropriate IP address for the Ethernet Shield
    in the range of the IP address of your computer. You can learn about the basics
    of the subnet at [http://en.wikipedia.org/wiki/Subnetwork](http://en.wikipedia.org/wiki/Subnetwork).
  prefs: []
  type: TYPE_NORMAL
- en: Before venturing further into the code, compile the code with these modifications
    and upload it to your Arduino. Once the uploading process is completed successfully,
    open a web browser and enter the IP address that you had specified in the Arduino
    sketch. If everything goes fine, you should see text displaying the values of
    the analog pins.
  prefs: []
  type: TYPE_NORMAL
- en: 'To better understand what happened here, let''s go back to the code. As you
    can see, at the beginning of the code we initialize the Ethernet server library
    on port `80` using the `EthernetServer` method from the Ethernet library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'During the execution of `setup()`, the program initializes the Ethernet connection
    through the Ethernet Shield using the `Ethernet.being()` method with the `mac`
    and `ip` variables that you defined earlier. The `server.begin()` method will
    start the server from here. Both of these steps are mandatory to start a server
    if you are using the Ethernet library for server code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `loop()` function, we initialize a `client` object to listen to incoming
    client requests using the `EthernetClient` method. This object will respond to
    any request coming from connected clients that try to access the Ethernet server
    through port `80`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'On receiving the request, the program will wait for the request payload to
    end. Then it will reply to the client with formatted HTML data using the `client.print()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'If you try to access the Arduino server from the browser, you will see that
    the web server replies to the clients with the analog pin readings. Now, to obtain
    the proper values of the humidity and PIR sensors that we connected in the hardware
    design, you will have to perform the following modification to the code. You will
    notice here that we are replying to the clients with the calculated values of
    relative humidity, instead of raw readings from all the analog pins. We have also
    modified the text that will be printed in the web browser to match the proper
    sensor title:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In this process, we also added an Arduino function, `getHumidity()`, that will
    calculate the relative humidity from the values observed from the analog pins.
    We have already used a similar function to calculate relative humidity in one
    of the previous projects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: You can implement these changes to the **WebServer** Arduino example for the
    testing phase, or just open the `WebServer_Custom.ino` sketch from the `Exercise
    1 - Web Server` folder of your code directory. As you can see in the opened sketch
    file, we have already modified the code to reflect the changes, but you will still
    have to change the MAC and IP addresses to the appropriate addresses. Once you
    are done with these minor changes, compile and upload the sketch to Arduino.
  prefs: []
  type: TYPE_NORMAL
- en: If everything goes as planned, you should be able to access the web server using
    your web browser. Open the IP address of your recently prepared Arduino in the
    web browser. You should be able to receive a similar response as displayed in
    the following screenshot. Although we are only displaying humidity values through
    this sketch, you can easily attach motion sensor values using additional `client.print()`
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: '![Exercise 1 – a web server, your first Arduino network program](img/5938OS_08_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Just like the mechanism we implemented in this exercise, a web server responds
    to the request made by a web browser and delivers the web pages you are looking
    for. Although this method is very popular and universally used to deliver web
    pages, the payload contains a lot of additional metadata compared to the actual
    size of the sensor information. Also, the server implementation using the Ethernet
    server library occupies a lot of the Arduino's resources. Arduino, being a resource-constrained
    device, is not suitable for running a server application, as the Arduino's resources
    should be prioritized to handle the sensors rather than communication. Moreover,
    the web server created using the Ethernet library supports a very limited amount
    of connections at a time, making it unusable for large-scale applications and
    multiuser systems.
  prefs: []
  type: TYPE_NORMAL
- en: The best approach to overcome this problem is by using Arduino as a client device,
    or by using lightweight communication protocols that are designed to work with
    resource-constrained hardware devices. In the next few sections, you are going
    to learn and implement these approaches for Arduino communication on the Ethernet.
  prefs: []
  type: TYPE_NORMAL
- en: Developing web applications using Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By implementing the previous program, you have enabled networking on Arduino.
    In the preceding example, we created an HTTP web server using methods available
    from the Ethernet library. By creating an Arduino web server, we made the Arduino
    resources available on the network. Similarly, Python also provides extensibility
    by way of various libraries to create web server interfaces. By running the Python-based
    web server on your computer or other devices such as the Raspberry Pi, you can
    avoid using Arduino to host the web server. Web applications created using high-level
    languages such as Python can also provide additional capabilities and extensibility
    compared to Arduino.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will use the Python library, `web.py`, to create a Python
    web server. We will also use this library to create interactive web applications
    that will enable the transfer of data between an Arduino client and a web browser.
    After you have learned the basics of `web.py`, we will interface Arduino with
    `web.py` using serial ports to make Arduino accessible through the Python web
    server. Then we will upgrade the Arduino communication method from the serial
    interface to HTTP-based messaging.
  prefs: []
  type: TYPE_NORMAL
- en: Python web framework – web.py
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A web server can be developed in Python using various web frameworks such as
    `Django`, `bottle`, `Pylon`, and `web.py`. We have selected `web.py` as the preferred
    web framework due to its simple yet powerful functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: The `web.py` library was initially developed by the late Aaron Swartz with the
    goal of developing an easy and straightforward approach to create web applications
    using Python. This library provides two main methods, `GET` and `POST`, to support
    the HTTP **Representation State Transfer** (**REST**) architecture. This architecture
    is designed to support the HTTP protocol by sending and receiving data between
    clients and the server. Today, the REST architecture is implemented by a huge
    number of websites to transfer data over HTTP.
  prefs: []
  type: TYPE_NORMAL
- en: Installing web.py
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To get started with `web.py`, you need to install the `web.py` library using
    Setuptools. We installed Setuptools for various operating systems in [Chapter
    1](ch01.html "Chapter 1. Getting Started with Python and Arduino"), *Getting Started
    with Python and Arduino*. On Linux and Mac OS X, execute either of these commands
    on the terminal to install `web.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'On Windows, open the **Command Prompt** and execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'If Setuptools is set up correctly, you should be able to install the library
    without any difficulty. To verify the installation of the library, open the Python
    interactive prompt and run this command to see whether you have imported the library
    without any errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Your first Python web application
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Implementing a web server using `web.py` is a very simple and straightforward
    process. The `web.py` library requires the declaration of a mandatory method,
    `GET`, to successfully start the web server. When a client tries to access the
    server using a web browser or another client, `web.py` receives a `GET` request
    and returns data as specified by the method. To create a simple web application
    using the `web.py` library, create a Python file using the following lines of
    code and execute the file using Python. You can also run the `webPyBasicExample.py`
    file from the code folder of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: On execution, you will see that the server is now running and accessible through
    the `http://0.0.0.0:8080` address. As the server program is running on the `0.0.0.0`
    IP address, you can access it using the same computer, localhost, or any other
    computer from the same network.
  prefs: []
  type: TYPE_NORMAL
- en: 'To check out the server, open a web browser and go to `http://0.0.0.0:8080`.
    When you are trying to access the server from the same computer, you can also
    use `http://127.0.0.1:8080` or `http://localhost:8080`. The `127.0.0.1` IP address
    actually stands for localhost, that is, the network address of the same computer
    on which the program is running. You will be able to see the response of the server
    displayed in the browser, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Your first Python web application](img/5938OS_08_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To understand how this simple code works, check out the `GET` method in the
    previous code snippet. As you can see, when the web browser requests the URL,
    the `GET` method returns the `Hello, world!` string to the browser. Meanwhile,
    you can also observe two other mandatory `web.py` components in your code: the
    `urls` and `web.application()` methods. The `web.py` library requires initialization
    of the response location in the declaration of the `urls` variable. Every `web.py`-based
    web application requires the `application(urls, global())` method to be called
    to initialize the web server. By default, the `web.py` applications run on port
    number `8080`, which can be changed to another port number by specifying it during
    execution. For example, if you want to run your `web.py` application on port `8888`,
    execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Although this only returns simple text, you have now successfully created your
    first web application using Python. We will take it forward from here and create
    more complex web applications in the upcoming chapters using the `web.py` library.
    To develop these complex applications, we will require more than just the `GET`
    method. Let's start exploring advance concepts to further enhance your familiarity
    with the `web.py` library.
  prefs: []
  type: TYPE_NORMAL
- en: Essential web.py concepts for developing complex web applications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `web.py` library has been designed to provide convenient and simple methods
    to develop dynamic websites and web applications using Python. Using `web.py`,
    it is really easy to build complex websites by utilizing just a few additional
    Python concepts along with what you already know. Due to this limited learning
    curve and easy-to-implement methods, `web.py` is one of the quickest ways to create
    web applications in any programming language. Let's begin with understanding these
    `web.py` concepts in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Handling URLs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You might have noticed that in our first `web.py` program, we defined a variable
    called `urls` that points to the root location (`/`) of the `Index` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding declaration, the first part, `''/''`, is a regular expression
    used to match the actual URL requests. You can use regular expressions to handle
    complex queries coming to your `web.py` server and point them to the appropriate
    class. In `web.py`, you can associate different landing page locations with appropriate
    classes. For example, if you want to redirect the `/data` location to the `data`
    class in addition to the `Index` class, you can change the `urls` variable as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: With this provision, when a client sends a request to access the `http://<ip-address>:8080/data`
    address, the request will be directed towards the `data` class and then the `GET`
    or `POST` method of that class.
  prefs: []
  type: TYPE_NORMAL
- en: The GET and POST methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In exercise 1, where we created an Arduino-based web server running on port
    `80`, we used a web browser to access the web server. Web browsers are one of
    the most popular types of web clients used to access a web server; cURL, Wget,
    and web crawlers are the other types. A web browser uses HTTP to communicate with
    any web servers, including the Arduino web server that we used. `GET` and `POST`
    are two fundamental methods supported by the HTTP protocol to address server requests
    coming from a web browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'Whenever you are trying to open a website in your browser or any other HTTP
    client, you are actually requesting the `GET` function from the web server; for
    example, when you open a website URL, `http://www.example.com/`, you are requesting
    that the web server that hosts this website serves you the `GET` request for the
    `''/''` location. In the *Handling URLs* section, you learned how to associate
    the `web.py` classes with URL landing locations. Using the `GET` method provided
    by the `web.py` library, you can associate the `GET` request with individual classes.
    Once you have captured the `GET` request, you need to return appropriate values
    as the response to the client. The following code snippet shows how the `GET()`
    function will be called when anyone makes a `GET` request to the `''/''` location:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The `POST` function of the HTTP protocol is mainly used to submit a form or
    any other data to the web server. In most cases, `POST` is embedded in a web page,
    and a request to the server is generated when a user submits the component carrying
    the `POST` function. The `web.py` library also provides the `POST()` function,
    which is called when a web client tries to contact the `web.py` server using the
    `POST` method. In most implementations of the `POST()` function, the request includes
    some kind of data submitted through forms. You can retrieve individual form elements
    using `f[''Celsius''].value` which will give you a value associated with the form
    element called `Celsius`. Once the `POST()` function has performed the provided
    actions, you can return appropriate information to the client in response to the
    `POST` request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Templates
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now you know how to redirect an HTTP request to an appropriate URL, and also
    how to implement methods to respond to these HTTP requests (that is, `GET` and
    `POST`). But what about the web page that needs to be rendered once the request
    is received? To understand the rendering process, let''s start with creating a
    folder called `templates` in the same directory where our `web.py` program is
    going to be placed. This folder will store the templates that will be used to
    render the web pages when requested. You have to specify the location of this
    template folder in the program using the `template.render()` function, as displayed
    in the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Once you have instantiated the rendering folder, it is time to create template
    files for your program. According to the requirements of your program, you can
    create as many template files as you want. A language called **Templetor** is
    used to create these template files in `web.py`. You can learn more about it at
    [http://webpy.org/templetor](http://webpy.org/templetor). Each template file created
    using Templetor needs to be stored in the HTML format with the `.html` extension.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a file called `test.html` in the `templates` folder using a text
    editor and paste the following code snippet in to the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the preceding code snippet, the template file begins with
    the `$def with()` expression, where you need to specify the input arguments as
    variables within the brackets. Once the template is rendered, these will be the
    only variables you can utilize for the web page; for example, in the previous
    code snippet, we passed two variables (`form` and `i`) as input variables. We
    utilized the `form` object using `$:form.render()` to render it inside the web
    page. When you need to render the `form` object, you can directly pass the other
    variable by simply declaring it (that is, `$:i`). Templetor will render the HTML
    code of the template file as it is, while utilizing the variables in the instances
    where they are being used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you have a template file, `test.html`, ready to be used in your `web.py`
    program. Whenever a `GET()` or `POST()` function is executed, you are required
    to return a value to the requesting client. Although you can return any variable
    for these requests, including `None`, you will have to render a template file
    where the response is associated with loading a web page. You can return the template
    file using the `render()` function, followed by the filename of the template file
    and input arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the preceding line of code, we are returning the rendered
    `test.html` page by specifying the `render.test()` function, where `test()` is
    just the filename without the `.html` extension. The function also includes a
    form object, `f`, and variable, `i`, that will be passed as input arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Forms
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `web.py` library provides simple ways of creating form elements using the
    `Form` module. This module includes the capability to create HTML form elements,
    obtain inputs from users, and validate these inputs before utilizing them in the
    Python program. In the following code snippet, we are creating two form elements,
    `Textbox` and `Button`, using the `Form` library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Besides `Textbox` (which obtains text input from users) and `Button` (which
    submits the form), the `Form` module also provides a few other form elements,
    such as `Password` to obtain hidden text input, `Dropbox` to obtain a mutually
    exclusive input from a drop-down list, `Radio` to obtain mutually exclusive inputs
    from multiple options, and `Checkbox` to select a binary input from the given
    options. While all of these elements are very easy to implement, you should select
    form elements only according to your program requirements.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `web.py` implementation of `Form`, the web page needs to execute the
    `POST` method every time the form is submitted. As you can in see in the following
    implementation of the form in the template file, we are explicitly declaring the
    form submission method as `POST`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Exercise 2 – playing with web.py concepts using the Arduino serial interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now you have a general idea of the basic `web.py` concepts used to build a web
    application. In this exercise, we will utilize the concepts you learned to create
    an application to provide the Arduino with sensor information. As the goal of
    this exercise is to demonstrate the `web.py` server for Arduino data, we are not
    going to utilize the Ethernet Shield for communication. Instead, we will capture
    the Arduino data using the serial interface, while using the `web.py` server to
    respond to the requests coming from different clients.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the following diagram, we are using the same hardware that
    you designed for exercise 1, but without utilizing the Ethernet connection to
    our home router. Your computer running the `web.py` server, which is also a part
    of your home network, will serve the client requests.
  prefs: []
  type: TYPE_NORMAL
- en: '![Exercise 2 – playing with web.py concepts using the Arduino serial interface](img/5938OS_08_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the first step, we are going to code Arduino to periodically send the humidity
    sensor value to the serial interface. For the Arduino code, open the `WebPySerialExample_Arduino.ino`
    sketch from the `Exercise 2` folder of your code directory. As you can see in
    the following code snippet of the Arduino sketch, we are sending raw values from
    the analog port to the serial interface. Now compile and upload the sketch to
    your Arduino board. Open the **Serial Monitor** window from the Arduino IDE to
    confirm that you are receiving the raw humidity observations. Once you have confirmed
    it, close the **Serial Monitor** window. You won''t be able to run the Python
    code if the **Serial Monitor** window is using the port:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the Arduino code is running properly, it is time to execute the Python
    program, which contains the `web.py` server. The Python program for this exercise
    is located in the `WebPySerialExample_Python` directory. Open the `webPySerialExample.py`
    file in your code editor. The Python program is organized in two sections: capturing
    sensor data from the serial interface using the `pySerial` library, and using
    the `web.py` server-based server to respond to the requests from the clients.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the first stage of the code, we are interfacing the serial port using the
    `Serial()` method from the `pySerial` library. Don''t forget to change the serial
    port name as it may be different for your computer, depending on the operating
    system and physical port that you are using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the `port` object for the serial port is created, the program starts reading
    the text coming from the physical port, using the `readline()` method. Using the
    `relativeHumidity()` function, we convert the raw humidity data to appropriate
    relative humidity observations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'On the web server side, we will be using all the major `web.py` components
    you learned in the previous section to complete this goal. As part of it, we are
    implementing an input form for the temperature value. We will capture this user
    input and utilize it with the raw sensor data to calculate relative humidity.
    Therefore, we need to define the `render` object to use the `template` directory.
    In this exercise, we are only using the default landing page location ( `''/''`)
    for the web server, which is directed towards the `Index` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in the `WebPySerialExample_Python` folder, we have a directory
    called `templates`. This directory contains a template with the `base.html` filename.
    As this is an HTML file, it is likely that if you just click on the file, it opens
    in a web browser. Make sure that you open the file in a text editor. In the opened
    file, you''ll see that we are initializing the template file with `$def with(form,
    humidity)`. In this initialization, `form` and `humidity` are input variables
    that are required by the template during the rendering process. The template declares
    the actual `<form>` element with the `$:form.render()` method, while displaying
    the humidity value using the `$humidity` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Although the template file renders the `form` variable, we have to define this
    variable in the Python program first. As you can see in the following code snippet,
    we have declared a variable called `submit_form` using the `form.Form()` method
    of the `web.py` library. The `submit_form` variable includes a `Textbox` element
    to capture the temperature value and a `Button` element to enable the submit action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'When you want to access the current submitted values of the `submit_form` variable,
    you will have to validate the form using the `validates()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Now we have the user-facing web page and input components designed for the exercise.
    It is time to define the two main methods, `GET` and `POST`, to respond to the
    request coming from the web page. When you launch or refresh the web page, the
    `web.py` server generates the `GET` request, which is then handled by the `GET`
    function of the `Index` class. So during the execution of the `GET` method, the
    program obtains the latest raw humidity value from the serial port and calculates
    the relative humidity using the `relativeHumidity()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the process of dealing with the `GET` request, we are not submitting any
    form with the user input. For this reason, in the `GET` method, we will use the
    default value of temperature (`25`) for the `relativeHumidity()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the humidity value is derived, the program will render the `base` template
    using the `render.base()` function, as displayed in the following code snippet,
    where `base()` refers to the base template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Contrary to the `GET` method, the `POST` method is invoked when the form is
    submitted to the web page. The submitted form includes the temperature value provided
    by the user, which will be used to obtain the value of the relative humidity.
    Like the `GET()` function, the `POST()` function also renders the `base` template
    with the recent humidity value once the humidity is calculated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Now it is time to run the `web.py`-based web server. In the Python program,
    make the necessary changes to accommodate the serial port name and any other appropriate
    values. If everything is configured correctly, you will be able to execute the
    program from the terminal without any errors. You can access the web server, which
    is running on port `8080`, from a web browser on the same computer, that is, `http://localhost:8080`.
    Now the goal of the exercise is to demonstrate the remote accessibility of the
    web server from your home network, and you can do this by opening the website
    from another computer in your network, that is, `http://<ip-address>:8080`, where
    `<ip-address>` refers to the IP address of the computer that is running the `web.py`
    service.
  prefs: []
  type: TYPE_NORMAL
- en: '![Exercise 2 – playing with web.py concepts using the Arduino serial interface](img/5938OS_08_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The preceding screenshot shows how the web application will look when opened
    in a web browser. When you load the website, you will be able to see a relative
    humidity value obtained using the `GET` method. Now you can enter an appropriate
    temperature value and press the **submit** button to invoke the `POST` method.
    On successful execution, you will be able to see the latest relative humidity
    value, which is calculated based on the temperature value that you submitted.
  prefs: []
  type: TYPE_NORMAL
- en: RESTful web applications with Arduino and Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous exercise, we implemented the `GET` and `POST` requests using
    the `web.py` library. These requests are actually part of the most popular communication
    architecture of the **World Wide Web** (**WWW**) called REST. The REST architecture
    implements a client-server paradigm using the HTTP protocol for operations such
    as `POST`, `READ`, and `DELETE`. The `GET()` and `POST()` functions, implemented
    using `web.py`, are functional subsets of these standard HTTP REST operations,
    that is, `GET`, `POST`, `UPDATE`, and `DELETE`. The REST architecture is designed
    for network applications, websites, and web services to establish communication
    through HTTP-based calls. Rather than being just a set of standard rules, the
    REST architecture utilizes existing web technologies and protocols, making it
    a core component of the majority of the websites we use today. Due to this reason,
    the WWW can be considered to be the largest implementation of REST-based architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Designing REST-based Arduino applications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The REST architecture uses a client-server model, where the server acts as a
    centralized node in the network. It responds to the requests made by the distributed
    network nodes (called **clients**) that query it. In this paradigm, the client
    initiates a request for the state directed towards the server, while the server
    responds to the state request without storing the client context. This communication
    is always one-directional and always initiated from the client side.
  prefs: []
  type: TYPE_NORMAL
- en: '![Designing REST-based Arduino applications](img/5938OS_08_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To further explain the state transfer for the `GET` and `POST` requests, check
    out the previous diagram. When a client sends a `GET` request to a server using
    a URL, the server responds with raw data as the HTTP response. Similarly, in the
    `POST` request, the client sends data as payload to the server, while the server
    responds with simply a "received confirmation" message.
  prefs: []
  type: TYPE_NORMAL
- en: REST methods are relatively simple to implement and develop using simple HTTP
    calls. We are going to start developing Arduino networking applications using
    REST-based requests, as they are easy to implement and understand and are directly
    available through examples. We will begin by individually implementing REST-based
    Arduino clients for HTTP-based `GET` and `POST` methods. Later in this chapter,
    we will go through an exercise to combine the `GET` and `POST` methods through
    the same Arduino REST client, while developing the HTTP server using `web.py`.
  prefs: []
  type: TYPE_NORMAL
- en: Working with the GET request from Arduino
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we will implement the HTTP `GET` client on Arduino, while
    using an HTTP server that was developed using `web.py`. The premise of this programming
    exercise is to use the Ethernet Shield extension and the Ethernet library to develop
    a physical Arduino HTTP client that supports the `GET` request.
  prefs: []
  type: TYPE_NORMAL
- en: The Arduino code to generate the GET request
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Arduino IDE ships with a few basic examples that utilize the Ethernet library.
    One of these examples is **WebClient**, which can be found by navigating to **File**
    | **Examples** | **Ethernet** | **WebClient**. It is designed to demonstrate the
    `GET` request by implementing the HTTP client on Arduino. Open this sketch in
    the Arduino IDE, as we are going to use this sketch and modify it to accommodate
    the Arduino hardware we created.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing you need to change in the opened sketch is the IP address and
    the MAC address of your Arduino Ethernet Shield. Replace the following variables
    with the variables appropriate for your system. The following code snippet shows
    the IP address and the MAC address for our hardware, and you need to change it
    to accommodate yours:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the example uses Google as a server to get a response. You
    need to change this address to reflect the IP address of your computer, which
    will host the `web.py` server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `setup()` function, you will have to change the server IP address again.
    Also change the default HTTP port (`80`) to the port used by `web.py` (`8080`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Once you have made all of these changes, go to the `Arduino_GET_Webpy\ArduinoGET`
    folder and open the `ArduinoGET.ino` sketch. Compare your modified sketch with
    this sketch and perform the appropriate changes. Now you can save your sketch
    and compile your code for any errors.
  prefs: []
  type: TYPE_NORMAL
- en: At this stage, we are assuming that you have the Arduino Ethernet Shield mounted
    on your Arduino Uno. Connect the Ethernet Shield to your local network using an
    Ethernet cable, and connect Uno with your computer using a USB cable. Upload the
    sketch to the Arduino board and open the **Serial Monitor** window to check the
    activity. At this stage, Arduino would not be able to connect to the server because
    your `web.py` server is still not running. You can close the serial monitor for
    now.
  prefs: []
  type: TYPE_NORMAL
- en: The HTTP server using web.py to handle the GET request
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In your first `web.py` application, you developed a server that returned `Hello,
    world!` when requested from a web browser. Despite all the additional tasks it
    can perform, your web browser is an HTTP client at its core. This means that if
    your first `web.py` server code was able to respond to the `GET` request made
    by the web browser, it should also be able to respond to the Arduino web client.
    To check this out, open your first `web.py` program, `webPyBasicExample.py`, and
    change the return string from `Hello World!` to `test`. We are performing this
    string change to differentiate it from the other instances of this program. Execute
    the Python program from the terminal and open the **Serial Monitor** window in
    the Arduino IDE again. This time, you will be able to see that your Arduino client
    is receiving a response for the `GET` request it sent to the `web.py` server.
    As you can see in the following screenshot, you will be able to see the `test`
    string printed in the **Serial Monitor** window, which is returned by the `web.py`
    server for the `GET` request:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The HTTP server using web.py to handle the GET request](img/5938OS_08_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Although in this example we are returning a simple string for the `GET` request,
    you can extend this method to obtain different user-specified parameters from
    the web server. This `GET` implementation can be used in a large number of applications
    where Arduino requires repeated input from the user or other programs. But what
    if the web server requires input from the Arduino? In that case, we will have
    to use the `POST` request. Let's develop an Arduino program to accommodate the
    HTTP `POST` request.
  prefs: []
  type: TYPE_NORMAL
- en: Working with the POST request from Arduino
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since we have now implemented the `GET` request, we can use a similar approach
    to exercise the `POST` request. Instead of asking the server to provide a response
    for a state request, we will send sensor data as payload from Arduino in the implementation
    of the `POST` request. Similarly, on the server side, we will utilize `web.py`
    to accept the `POST` request and display it through a web browser.
  prefs: []
  type: TYPE_NORMAL
- en: The Arduino code to generate the POST request
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Open the Arduino sketch `ArduinoPOST.ino` from the `Arduino_POST_Webpy\ArduinoPOST`
    folder of the code repository. As in the previous exercise, you will first have
    to provide the IP address and the MAC address of your Arduino.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have completed these basic changes, observe the following code snippet
    for the implementation of the `POST` request. You might notice that we are creating
    payload for the `POST` request as the variable data from the values obtained from
    analog pin 0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following Arduino code, we''ll first create a `client` object using
    the Ethernet library. In the recurring `loop()` function, we''ll use this `client`
    object to connect to the `web.py` server running on our computer. You will have
    to replace the IP address in the `connect()` method with the IP address of your
    `web.py` server. Once connected, we''ll create a custom `POST` message with the
    payload data we calculated previously. The Arduino `loop()` function will periodically
    send the updated sensor value generated by this code sample to the `web.py` server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Once you have performed the changes, compile and upload this sketch to the Arduino
    board. As the `web.py` server is yet not implemented, the `POST` request that
    originated from Arduino will not be able to reach its destination successfully,
    so let's create the `web.py` server to accept `POST` requests.
  prefs: []
  type: TYPE_NORMAL
- en: The HTTP server using web.py to handle the POST request
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this implementation of the `POST` method, we require two `web.py` classes,
    `index` and `data`, to individually serve requests from the web browser and Arduino
    respectively. As we are going to use two separate classes to update common sensor
    values (that is, `humidity` and `temperature`), we are going to declare them as
    global variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'As you may have noticed in the Arduino code (`client.println("POST /data HTTP/1.1")`),
    we were sending the `POST` request to the URL located at `/data`. Similarly, we
    will use the default root location, `''/''`, to land any request coming from the
    web browser. These requests for the root location will be handled by the `index`
    class, just as we covered in exercise 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The `data` class takes care of any `POST` request originating from the `/data`
    location. In this case, these `POST` requests contain payload that has sensor
    information attached by the Arduino `POST` client. On receiving the message, the
    method splits the payload string into sensor-type and value, updating the global
    value of the `humidity` variable in this process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Each `POST` request received from Arduino updates the raw humidity value, which
    is represented by the `data` variable. We are using the same code from exercise
    2 to obtain manual temperature values from the user. The relative humidity value,
    `humidity`, is updated according to the temperature value you updated using the
    web browser and the raw humidity value is obtained from your Arduino.
  prefs: []
  type: TYPE_NORMAL
- en: '![The HTTP server using web.py to handle the POST request](img/5938OS_08_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To check out the Python code, open the `WebPyEthernetPOST.py` file from the
    code repository. After making the appropriate changes, execute the code from the
    terminal. If you don't start getting any updates from the Arduino on the terminal,
    you should restart Arduino to reestablish the connection with the `web.py` server.
    Once you start seeing periodic updates from the Arduino `POST` requests at the
    terminal, open the location of the web application in your browser. You will be
    able to see something similar to the preceding screenshot. Here, you can submit
    the manual temperature value using the form, while the browser will reload with
    the updated relative humidity according to the temperature value entered.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 3 – a RESTful Arduino web application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The goal of this exercise is to simply combine the `GET` and `POST` methods
    you learned in the previous two sections in order to create a complete REST experience
    using Arduino and Python. The architecture for this exercise can be described
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The Arduino client periodically uses the `GET` request to obtain the sensor
    type from the server. It uses this sensor type to select a sensor for observation.
    In our case, it is either a humidity or motion sensor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The web server responds to the `GET` request by returning the current sensor
    type of the sensor selected by the user. The user provides this selection through
    a web application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After receiving the sensor type, the Arduino client utilizes `POST` to send
    sensor observation to the server.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The web server receives the `POST` data and updates the sensor observation for
    that particular sensor type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the user side, the web server obtains the current sensor type through the
    web browser.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the **submit** button in the browser is pressed, the server updates the
    sensor value in the browser with the latest value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Arduino sketch for the exercise
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Using the same Arduino hardware we built, open the Arduino sketch named `WebPyEthernetArduinoGETPOST.ino`
    from the `Exercise 3 - RESTful application Arduino and webpy` code folder. As
    we described in the exercise''s architecture earlier, the Arduino client should
    periodically send `GET` requests to the server and get the corresponding value
    of the sensor type in the response. After comparing the sensor type, the Arduino
    client fetches the current sensor observation from the Arduino pins and sends
    that observation back to the server using `POST`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: After changing the appropriate server's IP address in the code, compile and
    upload it to the Arduino. Open the **Serial Monitor** window, where you will find
    unsuccessful connection attempts, as your `web.py` server is not yet running.
    Close any other instance or program of the `web.py` server running on your computer.
  prefs: []
  type: TYPE_NORMAL
- en: The web.py application to support REST requests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Open the `WebPyEthernetGETPOST.py` file from the `Exercise 3 - RESTful application
    Arduino and webpy` code folder. As you can see, the `web.py` based web server
    implements two separate classes, `index` and `data`, to support the REST architecture
    for the web browser and the Arduino client, respectively. We are introducing a
    new concept for the `Form` element, called `Dropdown()`. Using this `Form` method,
    you can implement the drop-down selection menu and ask the user to select one
    option from the list of options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous `web.py` program, we implemented the `GET` and `POST` methods
    for the `index` class and only the `POST` method for the `data` class. Moving
    forward in this exercise, we''ll also add the `GET` method to the `data` class.
    This method returns the value of the `sensorType` variable when the `GET` request
    is made for the `/data` location. From the user side, the value of the `sensorType`
    variable is updated when the form gets submitted with an option. This action sends
    a selected value to the `POST` method of the `index` class, ultimately updating
    the `sensorType` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Before you run this Python program, make sure you have checked every component
    of the code and updated the values where needed. Then execute the code from the
    terminal. Your web server will now run on your local computer on the port number
    `8080`. Power-cycle your Arduino device in case the connection attempt from Arduino
    fails. To test your system, open the web application from your web browser. You
    will see a web page open in your browser, as displayed in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The web.py application to support REST requests](img/5938OS_08_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can choose the sensor type from the **dropdown** menu ( **Humidity** or
    **Motion**) before pressing the **Submit** button. On submission, you will be
    able to see the page updated with the appropriate sensor type and its current
    value.
  prefs: []
  type: TYPE_NORMAL
- en: Why do we need a resource-constrained messaging protocol?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous section, you learned how to use the HTTP `REST` architecture
    to send and receive data between your Arduino and the host server. The HTTP protocol
    was originally designed to serve textual data through web pages on the Internet.
    The data delivery mechanism used by HTTP requires a comparatively large amount
    of computation and network resources, which may be sufficient for a computer system
    but not for resource-constrained hardware platforms such as Arduino. As we discussed
    earlier, the client-server paradigm implemented by the HTTP REST architecture
    creates a tightly coupled system. In this paradigm, both sides (the client and
    the server) need to be constantly active, or live, to respond. Also, the REST
    architecture only allows unidirectional communication from client to server, where
    requests are always initialized by the client and the server responds to the client.
    This request-response-based architecture is not suitable for constrained hardware
    devices because of (but not limited to) the following reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: These devices should avoid active communication mode to save power
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The communication should have less data overhaul to save network resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They usually do not have enough computational resources to enable bidirectional
    REST communication, that is, implementing both client and server mechanisms on
    each side
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code should have a smaller footprint due to storage constraints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: The REST-based architecture can still be useful when the application specifically
    requires a request-response architecture, but most sensor-based hardware applications
    are limited due to the preceding points.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Among other data delivery paradigms that solve the preceding problems, the architecture
    based on **publisher/subscriber** (**pub/sub**) stands tall. The pub/sub architecture
    enables bidirectional communication capabilities between the node that generates
    the data (**Publisher**) and the node that consumes the data (**Subscriber**).
    We are going to use MQTT as the protocol that uses the pub/sub model of message
    transportation. Let's begin by covering the pub/sub architecture and MQTT in detail.
  prefs: []
  type: TYPE_NORMAL
- en: MQTT – A lightweight messaging protocol
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Just like REST, pub/sub is one of the most popular messaging patterns, mostly
    deployed to transfer short messages between nodes. Instead of deploying client-server-based
    architecture, the pub/sub paradigm implements messaging middleware called a **broker**
    to receive, queue, and relay messages between the subscriber and publisher clients:'
  prefs: []
  type: TYPE_NORMAL
- en: '![MQTT – A lightweight messaging protocol](img/5938OS_08_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The pub/sub architecture utilizes a topic-based system to select and process
    messages, where each message is labeled with a specific topic name. Instead of
    sending a message directly to the subscriber, the publisher sends it first to
    the broker with a topic name. In a totally independent process, the subscriber
    registers its subscription for particular topics with the broker. In the event
    of receiving a message from the publisher, the broker performs topic-based filtering
    on that message before forwarding it to the subscribers registered for that topic.
    As publishers are loosely coupled to subscribers in this architecture, the publishers
    do not need to know the whereabouts of the subscribers and can work uninterrupted
    without worrying about their status.
  prefs: []
  type: TYPE_NORMAL
- en: While discussing the limitations of the REST architecture, we noticed that it
    requires the implementation of both the HTTP client and server on the Arduino
    end to enable bidirectional communication with Arduino. With the broker-based
    architecture demonstrated by pub/sub, you only need to implement lightweight code
    for the publisher or subscriber client on Arduino, while the broker can be implemented
    on a device with more computation resources. Henceforth, you will have bidirectional
    communication enabled on Arduino without using significant resources.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to MQTT
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Message Queue Telemetry Transport** (**MQTT**) is a very simple, easy, and
    open implementation of the pub/sub paradigm. IBM has been working on standardizing
    and supporting the MQTT protocol. The documentation for the latest specification
    of the MQTT protocol, v3.1, can be obtained from the official MQTT website at
    [http://www.mqtt.org](http://www.mqtt.org).'
  prefs: []
  type: TYPE_NORMAL
- en: As a standard for machine messaging, MQTT is designed to be extremely lightweight
    and with a smaller footprint for code, while also using a lower network bandwidth
    for communication. MQTT is very specifically designed to work on embedded systems—like
    hardware platforms such as Arduino and other appliances—that carry limited processor
    and memory resources. While MQTT is a transport layer messaging protocol, it uses
    TCP/IP for network-level connectivity. As MQTT is designed to support the pub/sub
    messaging paradigm, the implementation of MQTT on your hardware application provides
    support for one-to-many distributed messaging, eliminating the limitation of unidirectional
    communication demonstrated by HTTP REST. As MQTT is agnostic of the content of
    the payload, there is no restriction on the type of message you can pass using
    this protocol.
  prefs: []
  type: TYPE_NORMAL
- en: Due to all the benefits associated with the pub/sub paradigm and its implementation
    in the MQTT protocol, we will be using the MQTT protocol for the rest of the exercises
    to have messages communicated between Arduino and its networked computer. To achieve
    this, we will be using the MQTT broker to provide the ground work for message
    communication and host topics, while deploying the MQTT publisher and subscriber
    clients at the Arduino and Python ends.
  prefs: []
  type: TYPE_NORMAL
- en: Mosquitto – an open source MQTT broker
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we described, MQTT is just a protocol standard, and it still requires software
    tools so that it can be implemented in actual applications. **Mosquitto** is an
    open source implementation of the message broker, which supports the latest version
    of the MQTT protocol standard. The Mosquitto broker enables the pub/sub paradigm
    implemented by the MQTT protocol, while providing a lightweight mechanism to enable
    messaging between machines. Development of Mosquitto is supported through community
    efforts. Mosquitto is one of the most popular MQTT implementations, freely available
    and widely supported on the Internet. You can obtain further information regarding
    the actual tool and community from its website, at [http://www.mosquitto.org](http://www.mosquitto.org).
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Mosquitto
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The installation and configuration of Mosquitto are very straightforward processes.
    At the time of writing this book, the latest version of Mosquitto is 1.3.4\. You
    can also obtain the latest updates and installation information regarding Mosquitto
    at [http://www.mosquitto.org/download/](http://www.mosquitto.org/download/).
  prefs: []
  type: TYPE_NORMAL
- en: 'On Windows, you can simply download the latest version of the installation
    files for Windows, which is made for Win32 or Win64 systems. Download and run
    the executable file to install the Mosquitto broker. To run Mosquitto from the
    command prompt, you will have to add the Mosquitto directory to the `PATH` variables
    in the environment variables of the system properties. In [Chapter 1](ch01.html
    "Chapter 1. Getting Started with Python and Arduino"), *Getting Started with Python
    and Arduino*, we comprehensively described the process of adding a `PATH` variable
    to install Python. Using the same method, add the path of the Mosquitto installation
    directory at the end of the `PATH` value. If you are using a 64-bit operating
    system, you should use `C:\Program Files (x86)\mosquitto`. For a 32-bit operating
    system, you should use `C:\Program Files\mosquitto` as the path. Once you are
    done with adding this value at the end of the `PATH` value, close any existing
    command prompt windows and open a new Command Prompt window. You can validate
    the installation by typing the following command in the newly opened window. If
    everything is installed and configured correctly, the following command should
    execute without any errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'For Mac OS X, the best way to install Mosquitto is to use the Homebrew tool.
    We already went through the process of installing and configuring Homebrew in
    [Chapter 1](ch01.html "Chapter 1. Getting Started with Python and Arduino"), *Getting
    Started with Python and Arduino*. Install the Mosquitto broker by simply executing
    the following script on the terminal. This script will install Mosquitto with
    the Mosquitto utilities and also configure them to run from the terminal as commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'On Ubuntu, the default repository already has the installation package for
    Mosquitto. Depending on the version of Ubuntu you are using, this Mosquitto version
    could be older than the current version. In that case, you must add this repository
    first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can install the Mosquitto packages by simply running the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Getting familiar with Mosquitto
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Due to the multiple installation methods involved for different operating systems,
    the initialization of Mosquitto may be different for your instance. In some cases,
    Mosquitto might already be running on your computer. For a Unix-based operating
    system, you can check whether Mosquitto is running or not with this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Unless you find a running instance of the broker, you can start Mosquitto by
    executing the following command in the terminal. After executing it, you should
    be able to see the broker running while printing the initialization parameters
    and other requests coming to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: When you installed the Mosquitto broker, the installation process would also
    have installed a few Mosquitto utilities, which include the MQTT clients for the
    publisher and the subscriber. These client utilities can be used to communicate
    with any Mosquitto broker.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the subscriber client utility, `mosquitto_sub`, use the following command
    at the terminal with the IP address of the Mosquitto broker. As we are communicating
    to the Mosquitto broker running on the same computer, you can avoid the `–h <Broker-IP>`
    option. The subscriber utility uses the `–t` option to specify the name of the
    topic that you are planning to subscribe. As you can see, we are subscribing to
    the `test` topic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Similar to the subscriber client, the publisher client (`mosquitto_pub`) can
    be used to publish a message to the broker for a specific topic. As described
    in the following command, you are required to use the `–m` option followed by
    a message to successfully publish it. In this command, we are publishing a `Hello`
    message for the `test` topic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Other important Mosquitto utilities include `mosquitto_password` and `mosquitto.conf`,
    which can be used to manage the Mosquitto password files and the setup broker
    configuration, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with MQTT on Arduino and Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you have the Mosquitto broker installed on your computer, it means
    that you have a working broker that implements the MQTT protocol. Our next goal
    is to develop the MQTT clients in Arduino and also in Python so that they will
    work as publishers and subscribers. After implementing the MQTT clients, we will
    have a fully-functional MQTT system, where these clients communicate through the
    Mosquitto broker. Let's begin with deploying MQTT on the Arduino platform.
  prefs: []
  type: TYPE_NORMAL
- en: MQTT on Arduino using the PubSubClient library
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As MQTT is a network-based messaging protocol, you will always need an Ethernet
    Shield to communicate with your network. For the following exercise, we will continue
    using the same hardware that we have been using throughout this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the PubSubClient library
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To use Arduino for pub/sub and enable simple MQTT messaging, you need the Arduino
    client library for MQTT, also known as the `PubSubClient` library. The `PubSubClient`
    library helps you develop Arduino as an MQTT client, which can then communicate
    with the MQTT server (Mosquitto broker in our case) running on your computer.
    As the library provides methods to create only an MQTT client and not a broker,
    the footprint of the Arduino code is quite small compared to other messaging paradigms.
    The `PubSubClient` library extensively utilizes the default Arduino Ethernet library
    and implements the MQTT client as a subclass of the Ethernet client.
  prefs: []
  type: TYPE_NORMAL
- en: To get started with the `PubSubClient` library, you'll first need to import
    the library to your Arduino IDE. Download the latest version of the `PubSubClient`
    Arduino library from [https://github.com/knolleary/pubsubclient/](https://github.com/knolleary/pubsubclient/).
    Once you have the file downloaded, import it to your Arduino IDE.
  prefs: []
  type: TYPE_NORMAL
- en: We will be using one of the examples installed with the `PubSubClient` library
    to get started. The goal of the exercise is to utilize a basic example to create
    an Arduino MQTT client, while performing minor modifications to accommodate the
    local network parameters. We will then use the Mosquitto commands you learned
    in the previous section to test the Arduino MQTT client. Meanwhile, ensure that
    your Mosquitto broker is running in the background.
  prefs: []
  type: TYPE_NORMAL
- en: Developing the Arduino MQTT client
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s start with opening the `mqtt_basic` example by navigating to **File**
    | **Examples** | **PubSubClient** in our Arduino IDE menu. In the opened program,
    change the MAC and IP address values for Arduino by updating the `mac[]` and `ip[]`
    variables, respectively. In the previous section, you successfully installed and
    tested the Mosquitto broker. Use the IP address of the computer running Mosquitto
    to update the `server[]` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in the code, we are initializing the client using the IP address
    of the server, Mosquitto port number, and Ethernet client. Before using any other
    method for the `PubSubClient` library, you will always have to initialize the
    MQTT client using a similar method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Further on in the code, we are using the `publish()` and `subscribe()` methods
    on the `client` class to publish a message for the `outTopic` topic and subscribe
    to the `inTopic` topic. You can specify the name of the client using the `client.connect()`
    method. As you can see in the following code snippet, we are declaring `arduinoClient`
    as the name for this client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'As we are using this code in the `setup()` function, the client will only publish
    the `hello world` message once—during the initialization of the code—while the
    `subscribe` method will keep looking for new messages for `inTopic` due to the
    use of the `client.loop()` method in the Arduino `loop()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, while running Mosquitto in the background, open another terminal window.
    In this terminal window, run the following command. This command will use a computer-based
    Mosquitto client to subscribe to the `outTopic` topic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Compile your Arduino sketch and upload it. As soon as the upload process is
    complete, you will be able to see the `hello world` string printed. Basically,
    as soon as the Arduino code starts running, the Arduino MQTT client will publish
    the `hello world` string to the Mosquitto broker for the `outTopic` topic. On
    the other side, that is, on the side of the Mosquitto client, you've started using
    the `mosquitto_sub` utility and will receive this message, as it is subscribed
    to `outTopic`.
  prefs: []
  type: TYPE_NORMAL
- en: Although you ran the modified Arduino example, `mqtt_basic`, you can also find
    the code for this exercise from this chapter's code folder. In this exercise,
    the Arduino client is also subscribed to `inTopic` to receive any message that
    originates for this topic. Unfortunately, the program doesn't display or deal
    with messages it obtains as a subscriber. To test the subscriber functionalities
    of the Arduino MQTT client, let's open the `mqtt_advance` Arduino sketch from
    this chapter's code folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see in the following code snippet, we have added code to display
    the received message in the `callback()` method. The `callback()` method will
    be called when the client receives any message from the subscribed topics. Therefore,
    you can implement all types of functionality on the received message from the
    `callback()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'In this `mqtt_advance` Arduino sketch, we have also moved the publishing statement
    of `outTopic` from `setup()` to the `loop()` function. This action will help us
    to periodically publish the value for `outTopic`. In future, we will expand this
    method to use sensor information as messages so that the other devices can obtain
    those sensor values by subscribing to these sensor topics:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'After updating the `mqtt_advance` sketch with the appropriate network addresses,
    compile and upload the sketch to your Arduino hardware. To test the Arduino client,
    use the same `mosquitto_sub` command to subscribe to `outTopic`. This time, you
    will periodically get updates for `outTopic` on the terminal. To check out the
    subscriber functionality of your Arduino client, open your **Serial Monitor**
    window in your Arduino IDE. Once the **Serial Monitor** window begins running,
    execute the following command in the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: You can see in the **Serial Monitor** window that the `Test` text is printed
    with the topic name as `inTopic`. Henceforth, your Arduino will serve as both
    an MQTT publisher and an MQTT subscriber. Now let's develop a Python program to
    implement the MQTT clients.
  prefs: []
  type: TYPE_NORMAL
- en: MQTT on Python using paho-mqtt
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous exercise, we tested the Arduino MQTT client using command-line
    utilities. Unless the published and subscribed messages are captured in Python,
    we cannot utilize them to develop all the other applications we've built so far.
    To transfer messages between the Mosquitto broker and the Python interpreter,
    we use a Python library called `paho-mqtt`. This library used to be called `mosquitto-python`
    before it was donated to the Paho project. Identical to the Arduino MQTT client
    library, the `paho-mqtt` library provides similar methods to develop the MQTT
    pub/sub client using Python.
  prefs: []
  type: TYPE_NORMAL
- en: Installing paho-mqtt
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Like all other Python libraries we used, `paho-mqtt` can also be installed
    using Setuptools. To install the library, run this command in the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'For the Windows operating system, use `easy_install.exe` to install the library.
    Once it is installed, you can check the successful installation of the library
    using the following command in the Python interactive terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Using the paho-mqtt Python library
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `paho-mqtt` Python library provides very simple methods to connect to your
    Mosquitto broker. Let''s open the `mqttPython.py` file from this chapter''s code
    folder. As you can see, we have initialized the code by importing the `paho.mqtt.client`
    library method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Just like the Arduino MQTT library, the `paho-mqtt` library also provides methods
    to connect to the Mosquitto broker. As you can see, we have named our client `mosquittoPython`
    by simply using the `Client()` method. The library also provides methods for activities,
    for example, when the client receives a message, `on_message`, and publishes a
    message, `on_publish`. Once you have initialized these methods, you can connect
    your client to the Mosquitto server by specifying the server IP address and the
    port number.
  prefs: []
  type: TYPE_NORMAL
- en: 'To subscribe to or publish for a topic, you simply need to implement the `subscribe()`
    and `publish()` methods on the client, respectively, as displayed in the following
    code snippet. In this exercise, we are using the `loop_forever()` method for the
    client to periodically check the broker for any new messages. As you can see in
    the code, we are executing the `publishTest()` function before the control enters
    the loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: It is very important to run all the required functions or pieces of code before
    you enter the loop, as the program will enter the loop with the Mosquitto server
    once `loop_forever()` is executed. During this period, the client will only execute
    the `on_publish` and `on_message` methods for any update on the subscribed or
    published topics.
  prefs: []
  type: TYPE_NORMAL
- en: To overcome this situation, we are implementing the multithreading paradigm
    of the Python programming language. Although we are not going to dive deep into
    multithreading, the following example will teach you enough to implement basic
    programming logic. To understand more about the Python threading library and supported
    methods, visit [https://docs.python.org/2/library/threading.html](https://docs.python.org/2/library/threading.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'To better understand our implementation of the threading method, check out
    the following code snippet. As you can see in the code, we are implementing recursion
    for the `publishTest()` function every 5 seconds, using the `Timer()` threading
    method. Using this method, the program will start a new thread that is separate
    from the main program thread that contains the loop for Mosquitto. Every 5 seconds,
    the `publishTest()` function will be executed, recursively running the `publish()`
    method, and ultimately publishing a message for `inTopic`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, in the main thread, when the client gets a new message from the subscribed
    topics, the thread invokes the `onMessage()` function. In the current implementation
    of this function, we are just printing the topic and message for demonstration
    purposes. In real applications, this function can be used to implement any kind
    of operation on the received message, for example, writing a message to a database,
    running an Arduino command, selecting an input, calling other functions, and so
    on. In short, this function is the entry point of any input you receive through
    the Mosquitto broker from your subscribed topics:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, every time you publish a message from the second thread, the `onPublish()`
    function is executed by the program. Just like the previous function, you can
    implement various operations within this function, while the function behaves
    as the exit point of any message published using this Python MQTT client. In the
    current implementation of `onPublish()`, we are not performing any operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: In the opened Python file, `mqttPython.py`, you will only need to change the
    IP address of the server running the Mosquitto broker. If you are running the
    Mosquitto broker on the same computer, you can use `127.0.0.1` as the IP address
    of the localhost. Before you execute this Python file, ensure that your Arduino
    is running with the MQTT client we created in the previous exercise. Once you
    run this code, you can start seeing the messages being sent from your Arduino
    in the Python terminal, as displayed in the following screenshot. Whenever a new
    message is received, the Python program prints the **outTopic** topic name followed
    by the **From Arduino** message. This confirms that the Python client is receiving
    messages for `outTopic`, to which it is subscribed. If you look back at the Arduino
    code, you will notice that it is the same message that we were publishing from
    the Arduino client.
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the paho-mqtt Python library](img/5938OS_08_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now, to confirm the publishing operation of the Python MQTT client, let's open
    the **Serial Monitor** window from your Arduino IDE. As you can see in the **Serial
    Monitor** window, text that contains the **inTopic** topic name and the **From
    Python** message is being printed every 5 seconds. This validates the Python publisher,
    as we are publishing the same message for the same topic every 5 seconds through
    the `publishTest()` function.
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the paho-mqtt Python library](img/5938OS_08_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Exercise 4 – MQTT Gateway for Arduino
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In exercise 3, we used the REST architecture to transfer motion and humidity
    sensor data between our Arduino and the web browser. In this exercise, we will
    develop an MQTT Gateway using the Mosquitto broker and the MQTT clients to transfer
    sensor information from our Arduino to the web browser. The goal of the exercise
    is to replicate the same components that we implemented in the REST exercise,
    but with the MQTT protocol.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the architectural sketch of the system, we have Arduino with
    the Ethernet Shield connected to our home network, while the computer is running
    the Mosquitto broker and the Python applications on the same network. We are using
    the same sensors (that is, a motion sensor and a humidity sensor) and the same
    hardware design that we used in the previous exercises in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Exercise 4 – MQTT Gateway for Arduino](img/5938OS_08_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the software architecture, we have the Arduino code that interfaces with
    the humidity and motion sensors using analog pin 0 and digital pin 3, respectively.
    Using the `PubSubClient` library, the Arduino publishes sensor information to
    the Mosquitto broker. On the MQTT Gateway, we have two different Python programs
    running on the computer. The first program uses the `paho-mqtt` library to subscribe
    and retrieve sensor information from the Mosquitto broker and then `post` it to
    the web application. The second Python program, which is based on `web.py`, implements
    the web applications while obtaining sensor values from the first Python program.
    This program provides a user interface front for the MQTT Gateway.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although both of the preceding Python programs can be part of a single application,
    we are delegating the tasks of communicating with Mosquitto and serving information
    using the web application to separate applications for the following reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: We want to demonstrate the functions of both libraries, `paho-mqtt` and `web.py`,
    in separate applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you want to run routines based on `paho-mqtt` and `web.py` in the same application,
    you will have to implement multithreading, as both of these routines need to be
    run independently
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We also want to demonstrate the transfer of information between the two Python
    programs using Python-based REST methods with the help of the `httplib` library![Exercise
    4 – MQTT Gateway for Arduino](img/5938OS_08_24.jpg)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this exercise, we are labeling humidity and motion sensor information with
    the topic labels `Arduino/humidity` and `Arduino/motion`, respectively. The Arduino-based
    MQTT publisher and the Python-based MQTT subscriber will be utilizing these topic
    names if they want to transfer information through the Mosquitto broker. Before
    we begin with implementing the MQTT client on our Arduino, let's start the Mosquitto
    broker on our computer.
  prefs: []
  type: TYPE_NORMAL
- en: Developing Arduino as the MQTT client
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The goal of the Arduino MQTT client is to periodically publish the humidity
    and motion data to the Mosquitto broker running on your computer. Open the `Step1_Arduino.ino`
    sketch from the `Exercise 4 - MQTT gateway` folder in your code repository. Like
    all the other exercises, you first need to change the MAC address and the server
    address value, and assign an IP address for your Arduino client. Once you are
    done with these modifications, you can see the `setup()` function that we are
    publishing as a one-time connection message to the Mosquitto broker to check the
    connection. You can implement a similar function on a periodic basis if you have
    a problem with keeping your Mosquitto connection alive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: In the `loop()` method, we are executing the `publishData()` function every
    5 seconds. It contains the code to publish sensor information. The `client.loop()`
    method also helps us keep the Mosquitto connection alive and avoids the connection
    timeout from the Mosquitto broker.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in the following code snippet, the `publishData()` function
    obtains the sensor values and publishes them using the appropriate topic labels.
    You might have noticed that we are using the `dtostrf()` function in this function
    to change the data format before publishing. The `dtostrf()` function is a function
    provided by the default Arduino library that converts a double value into an ASCII
    string representation. We are also adding a delay of another 5 seconds between
    the successive publishing of sensor data to avoid any data buffering issues:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Complete any other modification you want to implement, and then compile your
    code. If your code is compiled successfully, you can upload it to your Arduino
    board. If your Mosquitto is running, you will be able see that a new client is
    connected as Arduino, which is the client name you specified in the preceding
    Arduino code.
  prefs: []
  type: TYPE_NORMAL
- en: Developing the MQTT Gateway using Mosquitto
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can have the Mosquitto broker running on the same computer as the Mosquitto
    Gateway, or on any other node in your local network. For this exercise, let''s
    run it on the same computer. Open the program file named `mosquittoGateway.py`
    for this stage from the `Step2_Gateway_mosquitto` folder, which is inside the
    `Exercise 4 - MQTT gateway` folder. The first stage of the Gateway application
    includes the `paho-mqtt` based Python program, which subscribes to the Mosquitto
    broker for the `Arduino/humidity` and `Arduino/motion` topics:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: When this MQTT subscriber program receives a message from the broker, it calls
    the `onMessage()` function, as we've already described in the previous coding
    exercise. This method then identifies the appropriate sensor type and sends the
    data to the `web.py` program using the `POST` method. We are using the default
    Python library, `httplib`, to implement the `POST` method in this program. While
    using the `httplib` library, you have to use the `HTTPConnection()` method to
    connect to the web application running on port number `8080`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although this program requires that your web application (second stage) must
    run in parallel, we are going to implement this web application in the upcoming
    section. Make sure that you first run the web application from the next section
    before executing this program; otherwise you will end up with errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation of this library requires that you first import the library
    into your program. Being a built-in library, `httplib` does not require an additional
    setup process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the connection is established with the web application, you have to prepare
    the data that needs to be sent in the `POST` method. The `httplib` method uses
    the `request()` method on the opened connection to post the data. You can also
    use the same method in other applications to implement the `GET` function. Once
    you are done with sending the data, you can close the connection using the `close()`
    method. In the current implementation of the `httplib` library, we are creating
    and closing the connection on each message. You can also declare the connection
    outside the `onMessage()` function and close it when you terminate the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Once you have performed the appropriate modifications, such as changing the
    IP address of the Mosquitto broker and the `web.py` application, go to the next
    exercise before running the code.
  prefs: []
  type: TYPE_NORMAL
- en: Extending the MQTT Gateway using web.py
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The MQTT Gateway code provides the user interface with the sensor information
    using the `web.py` based web application. The code is quite similar to what you
    implemented in exercise 3\. The program file is named `GatewayWebApplication.py`
    and located in your `Exercise 4 - MQTT gateway` code folder. In this application,
    we have removed the sensor selection process by simply implementing a button,
    displayed as **Refresh**. This application waits for the `POST` message from the
    previous program, which will be received on the `http://<ip-address>:8080/data`
    URL, ultimately triggering the `data` class. The `POST` method in this class will
    split the received string to identify and update the value of the `humidity` and
    `motion` global sensor variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'The default URL, `http://<ip-address>:8080/`, displays the `base` template
    with the **Refresh** button, populated using the `Form()` method. As displayed
    in the following code snippet, the default `index` class renders the template
    with the updated (current) `humidity` and `motion` values when it receives the
    `GET` or `POST` request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Run the program from the command line. Make sure that you are running both programs
    from separate terminal windows.
  prefs: []
  type: TYPE_NORMAL
- en: Testing your Mosquitto Gateway
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You have to follow these steps in the specified order to successfully execute
    and test all the components of this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: Run the Mosquitto broker.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the Arduino client. If it is running already, restart the program by powering
    off the Arduino client and powering it on again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Execute the web application in your terminal or from the Command Prompt.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the `paho-mqtt` Gateway program.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you follow this sequence, all of your programs will start without any errors.
    If you get any errors while executing, make sure that you follow all the instructions
    correctly, while also confirming the IP addresses in your programs. To check out
    your Arduino MQTT client, open the **Serial Monitor** window in your Arduino IDE.
    You will be able to see the periodic publication of the sensor information, as
    displayed in this screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing your Mosquitto Gateway](img/5938OS_08_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now open a web browser on your computer and go to the URL of your web application.
    You should be able to see a window that looks like what is shown in the following
    screenshot. You can click on the **Refresh** button to check out the updated sensor
    values.
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing your Mosquitto Gateway](img/5938OS_08_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have set a delay of 5 seconds between successive sensor updates. Henceforth,
    you won't be able to see the updated values if you rapidly press the **Refresh**
    button.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the Gateway program terminal, you will be able to see the label of the topic
    every time the program receives a new message from Mosquitto. If the delay between
    successive sensor updates is not sufficient and `httplib` doesn''t have enough
    time to get the response back from the `web.py` application, the program will
    generate an error message with the `httplib` function. Although we require an
    additional delay for `httplib` to successively send the data and receive the response,
    we will be able to avoid this delay when we implement the core Python code with
    threading, avoiding the entire notion of `POST` in between the programs:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing your Mosquitto Gateway](img/5938OS_08_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: With this exercise, you have implemented two different types of messaging architecture
    to transfer data between your Arduino and your computer or web applications using
    your home network. Although we recommend the use of hardware-centric and lightweight
    MQTT messaging paradigms over REST architecture, you can use either of these communication
    methods according to the application's requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Connectivity to computer networks can really open up limitless possibilities
    for future application development using Arduino. We started the chapter by explaining
    important computer network fundamentals, while also covering hardware extensions
    that enable computer networking for Arduino. Regarding the various methods of
    enabling networking, we began the chapter by establishing a web server for Arduino.
    We concluded that the web server on Arduino is not the best way for network communication
    due to the limited number of connections offered by the web server. Then we demonstrated
    the use of Arduino as a web client to enable HTTP-based `GET` and `POST` requests.
    Although this method is useful for request-based communication and requires fewer
    resources compared to a web server, it is still not the best way for sensor communication
    due to the additional data overhead. In the later part of the chapter, we described
    a lightweight messaging protocol, MQTT, designed specifically for sensor communication.
    We demonstrated its superiority to HTTP-based protocols using a few exercises.
  prefs: []
  type: TYPE_NORMAL
- en: With the help of each method of Arduino Ethernet communication, you learned
    about compatible Python libraries used to support these communication methods.
    We used the `web.py` library to develop a web server using Python, and demonstrated
    the use of the library with multiple examples. To support the MQTT protocol, we
    explored an MQTT broker, Mosquitto, and employed the Python library, `paho_mqtt`,
    to serve the MQTT requests.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, we covered every major aspect of Arduino and Python communication methods
    throughout this chapter, and demonstrated them with simple exercises. In the upcoming
    chapters, we will build upon the basics you learned in this chapter, in order
    to develop advanced Arduino-Python projects that will enable remote access to
    our Arduino hardware through the Internet.
  prefs: []
  type: TYPE_NORMAL
