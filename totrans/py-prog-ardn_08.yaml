- en: Chapter 8. Introduction to Arduino Networking
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 8 章。Arduino 网络简介
- en: So far, we used a hardwired serial connection to interact with Arduino, a serial
    monitor to observe the Arduino serial data, and a Python serial library (`pySerial`)
    to transfer data between the Arduino and Python applications. During this entire
    exchange, the range of communication was limited due to the hardwired serial connection.
    As a solution, you can use a wireless protocol such as **ZigBee**, **Bluetooth**,
    or other RF channels to establish a communication channel for a remote serial
    interface. These wireless protocols are extensively used in remote hardware applications,
    and they use the serial interface to transfer data. Due to their use of serial
    communication, these protocols require very little to no additional programming
    changes on the Arduino or Python side. You may require additional hardware to
    enable these protocols, however. The major benefit of these protocols is that
    they are really easy to implement. However, they are restricted with only a small
    geographical coverage area and limited data bandwidth.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们使用硬连线串行连接与 Arduino 交互，使用串行监视器来观察 Arduino 的串行数据，以及使用 Python 串行库 (`pySerial`)
    在 Arduino 和 Python 应用程序之间传输数据。在整个交换过程中，由于硬连线串行连接的限制，通信范围有限。作为解决方案，你可以使用无线协议，如
    **ZigBee**、**蓝牙** 或其他射频通道来为远程串行接口建立通信通道。这些无线协议在远程硬件应用中被广泛使用，并且它们使用串行接口来传输数据。由于它们使用串行通信，这些协议在
    Arduino 或 Python 方面几乎不需要额外的编程更改。然而，你可能需要额外的硬件来启用这些协议。这些协议的主要好处是它们非常容易实现。然而，它们的地理覆盖范围有限，数据带宽也有限。
- en: Besides serial communication methods, the other way to remotely access your
    Arduino device is to use a computer network. Today, computer networks are the
    most prolific way of communicating between computing units. In the next two chapters,
    we will explore various networking techniques using Arduino and Python, which
    range from establishing very basic Ethernet connectivity to developing complex,
    cloud-based web applications.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 除了串行通信方法之外，另一种远程访问你的 Arduino 设备的方法是使用计算机网络。如今，计算机网络是计算单元之间通信的最普遍方式。在接下来的两章中，我们将探讨使用
    Arduino 和 Python 的各种网络技术，这些技术从建立非常基本的以太网连接到开发复杂的基于云的 Web 应用程序。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: The fundamentals of networking and hardware extensions that enable networking
    for Arduino
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络和硬件扩展的基本原理，这些扩展使得 Arduino 能够进行网络通信
- en: Python frameworks used to develop **Hypertext Transfer Protocol** (**HTTP**)
    web servers on your computer
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于在您的计算机上开发 **超文本传输协议** (**HTTP**) 网络服务器的 Python 框架
- en: Interfacing Arduino-based HTTP clients with the Python web server
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将基于 Arduino 的 HTTP 客户端与 Python 网络服务器进行接口连接
- en: IoT messaging protocol MQTT (we will install a middleware tool called **Mosquitto**
    to enable MQTT on our computer)
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 物联网消息协议 MQTT（我们将在电脑上安装一个名为 **Mosquitto** 的中间件工具以启用 MQTT）
- en: Utilizing the publisher/subscriber paradigm, used by MQTT, to develop Arduino-Python
    web applications
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用 MQTT 中使用的发布/订阅范式来开发 Arduino-Python 网络应用
- en: Arduino and the computer networking
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Arduino 和计算机网络
- en: Computer networking is a huge domain, and covering every aspect of networking
    is not the main objective of this book. We will, however, try to explain a few
    fundamentals of computer networking wherever this knowledge will need to be applied.
    Unlike the serial interface approach, where a point-to-point connection is required
    between devices, the network-based approach provides distributed access to resources.
    Specifically in hardware applications where a single hardware unit is required
    to be accessed by multiple endpoints (for example, in a personal computer, mobile
    phone, or remote server), the computer network stands superior.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机网络是一个庞大的领域，本书的主要目标不是涵盖网络的所有方面。然而，我们将尝试在需要应用这些知识的地方解释计算机网络的几个基本原理。与需要设备之间点对点连接的串行接口方法不同，基于网络的方法提供了对资源的分布式访问。特别是在需要单个硬件单元被多个端点访问的硬件应用中（例如，在个人电脑、移动电话或远程服务器中），计算机网络具有优越性。
- en: In this section, we will cover the basics of networking and hardware components
    that enable networking in Arduino. Later in this chapter, we will use the Arduino
    library and a built-in example to demonstrate how remote access to Arduino using
    your local network works.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍网络和硬件组件的基本原理，这些组件使得 Arduino 能够进行网络通信。在本章的后面部分，我们将使用 Arduino 库和内置示例来演示如何通过本地网络远程访问
    Arduino。
- en: Networking fundamentals
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网络基础知识
- en: Whenever you see a computer or mobile device, you are also looking at some type
    of computer network being used to connect those devices with other devices. In
    simple terms, a computer network is a group of interconnected computational devices
    (also called network nodes) that allow the exchange of data between these devices.
    These network nodes include various devices such as your personal computers, mobile
    phones, servers, tablets, routers, and other pieces of networking hardware.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你看到一台计算机或移动设备时，你也在看着某种类型的计算机网络，它被用来将这些设备与其他设备连接起来。简单来说，计算机网络是一组相互连接的计算设备（也称为网络节点），允许这些设备之间交换数据。这些网络节点包括各种设备，如你的个人电脑、手机、服务器、平板电脑、路由器以及其他网络硬件。
- en: A computer network can be classified into numerous types according to parameters
    such as geographical location, network topology, and organizational scope. In
    terms of geographical scale, a network can be categorized into **local area network**
    (**LAN**), **home area network** (**HAN**), **wide area network** (**WAN**), and
    so on. When you are utilizing your home router to connect to the Internet, you
    are using the LAN created by your router. With regards to the organization that
    handles the network, LAN can be configured as Intranet, Extranet, and Internet.
    The Internet is the largest example of any computer network, as it interconnects
    all types of networks deployed globally. In your implementation of various projects
    throughout this book, you will mostly be using your LAN and the Internet for the
    exchange of data between an Arduino, your computer, the Raspberry Pi, and the
    cloud services.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 根据地理位置、网络拓扑和组织范围等参数，计算机网络可以划分为多种类型。在地理规模方面，网络可以分为**局域网**（**LAN**）、**家庭区域网**（**HAN**）、**广域网**（**WAN**）等。当你使用你的家庭路由器连接到互联网时，你正在使用由你的路由器创建的LAN。关于管理网络的机构，LAN可以配置为内网、外网和互联网。互联网是任何计算机网络中最大的例子，因为它连接了全球部署的所有类型的网络。在你这本书中的各种项目实现中，你将主要使用你的LAN和互联网来在Arduino、你的电脑、树莓派和云服务之间交换数据。
- en: To standardize communication between network nodes, various governing bodies
    and organizations have created a set of rules called **protocols**. In the large
    list of standard protocols, there are a few protocols that your computer uses
    on a daily basis. The examples of those protocols associated with the local area
    network include Ethernet and Wi-Fi. In the IEEE 802 family of standards, the IEEE
    802.3 standard describes different types of wired connectivity between nodes in
    a local area network, also called Ethernet. Similarly, Wireless LAN (also referred
    to as Wi-Fi), is part of the IEEE 802.11 standard, where a communication channel
    uses wireless frequency bands to exchange data.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了标准化网络节点之间的通信，各种管理机构和组织制定了一套称为**协议**的规则。在庞大的标准协议列表中，有一些协议是你在日常生活中经常使用的。与局域网相关的那些协议的例子包括以太网和Wi-Fi。在IEEE
    802系列标准中，IEEE 802.3标准描述了局域网中节点之间不同类型的有线连接，也称为以太网。同样，无线局域网（也称为Wi-Fi）是IEEE 802.11标准的一部分，其中通信通道使用无线频段来交换数据。
- en: Most network nodes deployed with IEEE 802 standards (that is, Ethernet, Wi-Fi,
    and so on) have a unique identifier assigned to the network interface hardware,
    called a **media access control** (**MAC**) address. This address is assigned
    by the manufacturer and is mostly fixed for each network interface. While using
    Arduino for network connectivity, we will need the MAC address to enable networking.
    A MAC address is a 48-bit address, and in human-friendly form it contains six
    groups of two hexadecimal digits. For example, 01:23:45:67:89:ab is the human-readable
    form of a 48-bit MAC address.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数使用IEEE 802标准（即以太网、Wi-Fi等）部署的网络节点都有一个分配给网络接口硬件的唯一标识符，称为**媒体访问控制**（**MAC**）地址。这个地址由制造商分配，并且对于每个网络接口通常是固定的。在使用Arduino进行网络连接时，我们需要MAC地址来启用网络功能。MAC地址是一个48位的地址，以人类友好的形式包含六组两位十六进制数字。例如，01:23:45:67:89:ab是48位MAC地址的人类可读形式。
- en: While the MAC address is associated with the hardware-level (that is, "physical")
    protocols, the **Internet Protocol** (**IP**) is a communication protocol that
    is widely used at the Internet level to enable internetworking between networked
    nodes. In the implementation of version 4 of the IP protocol suite (IPv4), each
    network node is assigned a 32-bit number called the **IP address** (for example,
    192.168.0.1). When you connect a computer, phone, or any other device to your
    local home network, an IP address is assigned to that device by your router. One
    of the most popular IP addresses is 127.0.0.1, which is also called the **localhost**
    IP address. Apart from the IP address assigned to a computer by the network, each
    computer also has the localhost IP address associated with it. The localhost IP
    address is very useful when you want to internally access or call your computer
    from the same device. In the case of a remote-access application, you need to
    know the IP address assigned by the network.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然MAC地址与硬件级别的（即，“物理”）协议相关联，但**互联网协议**（**IP**）是一种在互联网级别广泛使用的通信协议，它使得网络节点之间能够进行互连。在IP协议套件（IPv4）的版本4实现中，每个网络节点被分配一个32位的数字，称为**IP地址**（例如，192.168.0.1）。当您将计算机、手机或任何其他设备连接到您的本地家庭网络时，您的路由器将为该设备分配一个IP地址。最流行的IP地址之一是127.0.0.1，也称为**本地主机**IP地址。除了网络分配给计算机的IP地址外，每台计算机还有一个与其关联的本地主机IP地址。当您想从同一设备内部访问或调用您的计算机时，本地主机IP地址非常有用。在远程访问应用程序的情况下，您需要知道网络分配的IP地址。
- en: Obtaining the IP address of your computer
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取您计算机的IP地址
- en: Arduino is a resource-constrained device, and therefore it can only demonstrate
    a limited amount of network capability. While working with Arduino-based projects
    that include the utilization of a computer network, you will require a server
    or Gateway interface. These interfaces include, but are not limited to, a desktop
    computer, a laptop, the Raspberry Pi, and other remote computing instances. If
    you are using these interfaces as part of your hardware project, you will need
    their IP addresses. Ensure that they are under the same network as your Arduino.
    The following are the techniques to obtain IP addresses in major operating systems.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Arduino是一种资源受限的设备，因此它只能展示有限的网络功能。当您与基于Arduino的项目合作，这些项目包括利用计算机网络时，您将需要一个服务器或网关接口。这些接口包括但不限于台式计算机、笔记本电脑、树莓派和其他远程计算实例。如果您将这些接口作为您硬件项目的一部分使用，您将需要它们的IP地址。确保它们与您的Arduino处于同一网络下。以下是在主要操作系统中获得IP地址的技术。
- en: Windows
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Windows
- en: 'In most versions of the Windows OS, you can obtain the IP address from the
    **Network Connection** utility in **Control Panel**. Navigate to **Control Panel**
    | **Network and Internet** | **Network Connections** and open the **Local Area
    Connection Status** window. Click on the **Details** button to see the details
    of the **Network Connection Details** window. As you can see in this screenshot,
    the IP address of the network interface is listed as **IPv4 Address** in the opened
    window:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows操作系统的多数版本中，您可以从**控制面板**中的**网络连接**实用程序中获取IP地址。导航到**控制面板** | **网络和互联网**
    | **网络连接**并打开**本地连接状态**窗口。点击**详细信息**按钮以查看**网络连接详细信息**窗口的详细信息。如您在此截图中所见，网络接口的IP地址在打开的窗口中列示为**IPv4地址**：
- en: '![Windows](img/5938OS_08_01.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![Windows](img/5938OS_08_01.jpg)'
- en: 'You can also obtain the IP address of your computer using the built-in `ipconfig`
    utility. Open the Command Prompt and enter the following command:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用内置的`ipconfig`实用程序获取您计算机的IP地址。打开命令提示符并输入以下命令：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can see in the following screenshot, the IP address of your computer
    is listed under the Ethernet adapter. If you are using a wireless connection to
    connect to your network, the Ethernet adapter will be replaced by the wireless
    Ethernet adapter.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在以下截图中所见，您的计算机的IP地址列在以太网适配器下。如果您使用无线连接连接到您的网络，以太网适配器将被无线以太网适配器替换。
- en: '![Windows](img/5938OS_08_02.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![Windows](img/5938OS_08_02.jpg)'
- en: Mac OS X
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Mac OS X
- en: If you are using Mac OS X, you can obtain the IP address from the network settings.
    Open **System Preferences** and click on the **Network** icon. You will see a
    window similar to what is shown in the next screenshot. In the left sidebar, click
    on the interface you are looking to obtain the IP address of.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用Mac OS X，您可以从网络设置中获取IP地址。打开**系统偏好设置**并点击**网络**图标。您将看到一个类似于下一张截图的窗口。在左侧侧边栏中，点击您想要获取IP地址的接口。
- en: '![Mac OS X](img/5938OS_08_03.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![Mac OS X](img/5938OS_08_03.jpg)'
- en: 'If you want to get the IP address using the terminal, you can use the following
    command. This command will require you to enter the system name of the interface,
    `en0`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想通过终端获取IP地址，可以使用以下命令。此命令需要你输入接口的系统名称，`en0`：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If you are connected to multiple networks and are not aware of the network
    name, you can find the list of IP addresses associated with your computer, using
    the command shown here:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你连接到多个网络且不知道网络名称，你可以使用以下命令找到与电脑关联的IP地址列表：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'As you can see in this screenshot, you will get all the network addresses associated
    with your Mac computer and other network parameters:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如此截图所示，你将得到与你的Mac电脑和其他网络参数相关的所有网络地址：
- en: '![Mac OS X](img/5938OS_08_04.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![Mac OS X](img/5938OS_08_04.jpg)'
- en: Linux
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Linux
- en: 'On the Ubuntu OS, you can obtain the IP address of your computer from the **Network
    Settings** utility. To open it, navigate to **System Settings** | **Network**
    and click on the adapter through which the computer is connected to your home
    network. You can select an appropriate adapter to obtain the IP address, as displayed
    in the following screenshot:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在Ubuntu OS上，你可以从**网络设置**实用程序中获取电脑的IP地址。要打开它，请转到**系统设置** | **网络**，然后点击电脑连接到家庭网络的适配器。你可以选择一个合适的适配器来获取IP地址，如图所示：
- en: '![Linux](img/5938OS_08_05.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![Linux](img/5938OS_08_05.jpg)'
- en: 'In a Linux-based system, there are multiple ways of obtaining the IP address
    from the command line. You can use the same command (`ifconfig`) that we used
    in Mac OS X in the Linux environment to obtain the IP address of your computer:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于Linux的系统上，有多种从命令行获取IP地址的方法。你可以在Linux环境中使用与在Mac OS X中相同的命令（`ifconfig`）来获取电脑的IP地址：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You can obtain the IP address from the `inet addr` field of the appropriate
    adapter, as displayed in this screenshot:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从适当的适配器的`inet addr`字段中获取IP地址，如图所示：
- en: '![Linux](img/5938OS_08_06.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![Linux](img/5938OS_08_06.jpg)'
- en: 'If supported by your operating system, another command that can be utilized
    to obtain the IP address is `hostname`:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的操作系统支持，另一个可以用来获取IP地址的命令是`hostname`：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Be careful when using this utility to obtain the IP address, as you may end
    up getting the IP address of a different adapter if you are not familiar with
    the supported command options of the utility.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此实用程序获取IP地址时请小心，因为你可能不熟悉该实用程序的受支持命令选项，最终得到的是不同适配器的IP地址。
- en: Note
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you are going to connect your Arduino to the same local area network as your
    computer, make sure you are choosing the proper IP address that is covered by
    the same domain as that of your computer. Also ensure that no other network device
    is using the same IP address that you have selected for your Arduino. This practice
    will help you avoid IP address conflicts within the network.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打算将你的Arduino连接到与电脑相同的局域网，请确保你选择了一个与电脑域名相同的正确IP地址。同时，请确保没有其他网络设备正在使用你为Arduino选择的相同IP地址。这种做法将帮助你避免网络中的IP地址冲突。
- en: Networking extensions for Arduino
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Arduino网络扩展
- en: There are various hardware devices available in the Arduino community that enable
    networking for the Arduino platform. Among these devices, a few can be used as
    extensions for your existing Arduino board, while others exist as standalone Arduino
    modules with networking capabilities. The most popular extensions used to enable
    networking are the Arduino Ethernet Shield and Arduino WiFi Shield. Similarly,
    Arduino Yún is an example of a standalone Arduino platform that includes built-in
    networking capabilities. In this book, we are going to develop various networking
    applications around the Arduino Ethernet Shield. There are also a few other extensions
    (Arduino GSM Shield) and standalone Arduino platforms (Arduino Ethernet, Arduino
    Tre, and so on), but we are not going to cover them in detail. Let's get familiar
    with the following Arduino extensions and board.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在Arduino社区中，有多种硬件设备可用于为Arduino平台提供网络功能。在这些设备中，一些可以用作现有Arduino板的扩展，而其他则是具有网络功能的独立Arduino模块。最常用的扩展是Arduino以太网盾和Arduino
    WiFi盾。同样，Arduino Yún是一个包含内置网络功能的独立Arduino平台的例子。在这本书中，我们将围绕Arduino以太网盾开发各种网络应用。还有一些其他扩展（Arduino
    GSM盾）和独立Arduino平台（Arduino以太网、Arduino Tre等），但我们不会详细讨论它们。让我们熟悉以下Arduino扩展和板。
- en: Arduino Ethernet Shield
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Arduino以太网盾
- en: The Arduino Ethernet Shield is an officially supported and open source network
    extension designed to work with Arduino Uno. The Ethernet Shield is equipped with
    an RJ45 connector to enable Ethernet networking. The Ethernet Shield is designed
    to mount on top of Arduino Uno and it extends the layout of the pins from your
    Arduino Uno to the top of the board. The Ethernet Shield is also equipped with
    a microSD card slot to store important files over the network. Just like most
    of these shield extensions, the Ethernet Shield is powered by the Arduino board
    it is attached to.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Arduino以太网盾是官方支持的开源网络扩展，旨在与Arduino Uno配合使用。以太网盾配备了RJ45连接器，以实现以太网联网。以太网盾设计用于安装在Arduino
    Uno的顶部，它将Arduino Uno的引脚布局扩展到板子的顶部。以太网盾还配备了microSD卡槽，用于在网络中存储重要文件。就像大多数这些盾扩展一样，以太网盾由其连接的Arduino板供电。
- en: '![Arduino Ethernet Shield](img/5938OS_08_07.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![Arduino以太网盾](img/5938OS_08_07.jpg)'
- en: 'Source: [http://arduino.cc/en/uploads/Main/ArduinoEthernetShield_R3_Front.jpg](http://arduino.cc/en/uploads/Main/ArduinoEthernetShield_R3_Front.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 来源：[http://arduino.cc/en/uploads/Main/ArduinoEthernetShield_R3_Front.jpg](http://arduino.cc/en/uploads/Main/ArduinoEthernetShield_R3_Front.jpg)
- en: Every Ethernet Shield board is equipped with a unique hardware (MAC) address.
    You can see it on the back of the board. You may want to note down this hardware
    address, as it will be required frequently in the upcoming exercises. Also make
    sure that you get familiar with mounting the Arduino Ethernet Shield for those
    exercises. Buy an Arduino Ethernet Shield module from SparkFun or Amazon before
    your start working on any exercises. You can obtain additional information about
    this Shield at [http://arduino.cc/en/Main/ArduinoEthernetShield](http://arduino.cc/en/Main/ArduinoEthernetShield).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 每个以太网盾板都配备了一个唯一的硬件（MAC）地址。您可以在板子的背面看到它。您可能需要记下这个硬件地址，因为在接下来的练习中会经常需要它。同时，确保您熟悉安装Arduino以太网盾的步骤。在开始任何练习之前，从SparkFun或Amazon购买Arduino以太网盾模块。您可以在[http://arduino.cc/en/Main/ArduinoEthernetShield](http://arduino.cc/en/Main/ArduinoEthernetShield)找到有关此盾的更多信息。
- en: Arduino WiFi Shield
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Arduino WiFi盾
- en: The Arduino WiFi Shield has a layout similar to that of the Arduino Ethernet
    Shield as far as mounting on top of the Arduino board is concerned. Instead of
    the Ethernet RJ45 connector, the WiFi Shield contains components to enable wireless
    networking. Using the WiFi Shield, you can connect to the IEEE 802.11 (Wi-Fi)
    wireless networks, which is one of the most popular ways of connecting computers
    to the home network nowadays.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Arduino WiFi盾在安装在Arduino板上的布局方面与Arduino以太网盾相似。而不是以太网RJ45连接器，WiFi盾包含用于实现无线联网的组件。使用WiFi盾，您可以连接到IEEE
    802.11（Wi-Fi）无线网络，这是目前将计算机连接到家庭网络最流行的方式之一。
- en: '![Arduino WiFi Shield](img/5938OS_08_08.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![Arduino WiFi盾](img/5938OS_08_08.jpg)'
- en: 'Source: [http://arduino.cc/en/uploads/Main/A000058_front.jpg](http://arduino.cc/en/uploads/Main/A000058_front.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 来源：[http://arduino.cc/en/uploads/Main/A000058_front.jpg](http://arduino.cc/en/uploads/Main/A000058_front.jpg)
- en: The Arduino WiFi Shield requires additional power through a USB connector. It
    also contains a microSD slot to save files. Just like the Ethernet Shield, you
    can view the MAC address on the back of the board. More information about the
    Arduino WiFi Shield can be found at [http://arduino.cc/en/Main/ArduinoWi-FiShield](http://arduino.cc/en/Main/ArduinoWi-FiShield).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Arduino WiFi盾需要通过USB连接器额外供电。它还包含一个microSD插槽用于保存文件。就像以太网盾一样，您可以在板子的背面查看MAC地址。更多关于Arduino
    WiFi盾的信息可以在[http://arduino.cc/en/Main/ArduinoWi-FiShield](http://arduino.cc/en/Main/ArduinoWi-FiShield)找到。
- en: Arduino Yún
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Arduino Yún
- en: Unlike the Ethernet Shield and the WiFi Shield, the Arduino Yún is a standalone
    variant of the Arduino board. It includes both Ethernet- and Wi-Fi-based network
    connectivity, in addition to the basic Arduino component—the microcontroller.
    Yún is equipped with the latest and more powerful processing units compared to
    Uno. Instead of the traditional way of using Arduino code, Yún supports a lightweight
    version of the Linux operating system, providing functionality similar to a single-board
    computer such as the Raspberry Pi. You can use your Arduino IDE to program Yún
    even while running Unix shell scripts.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 与以太网盾和WiFi盾不同，Arduino Yún是Arduino板的独立变体。它包括基于以太网和Wi-Fi的网络连接，以及基本的Arduino组件——微控制器。与Uno相比，Yún配备了最新且更强大的处理单元。Yún不仅支持传统的Arduino代码使用方式，还支持轻量级的Linux操作系统版本，提供类似于Raspberry
    Pi等单板计算机的功能。您可以在运行Unix shell脚本的同时使用Arduino IDE来编程Yún。
- en: '![Arduino Yún](img/5938OS_08_09.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![Arduino Yún](img/5938OS_08_09.jpg)'
- en: 'Source: [http://arduino.cc/en/uploads/Main/ArduinoYunFront_2.jpg](http://arduino.cc/en/uploads/Main/ArduinoYunFront_2.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 来源：[http://arduino.cc/en/uploads/Main/ArduinoYunFront_2.jpg](http://arduino.cc/en/uploads/Main/ArduinoYunFront_2.jpg)
- en: You can find more information about Yún at the Arduino official website, at
    [http://arduino.cc/en/Main/ArduinoBoardYun](http://arduino.cc/en/Main/ArduinoBoardYun).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在Arduino官方网站上找到更多关于Yún的信息，在[http://arduino.cc/en/Main/ArduinoBoardYun](http://arduino.cc/en/Main/ArduinoBoardYun)。
- en: Arduino Ethernet library
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Arduino以太网库
- en: The Arduino Ethernet library provides support for the Ethernet protocol, and
    hence provides support for Ethernet extensions of Arduino, such as the Ethernet
    Shield. This is a standard Arduino library and it gets deployed with the Arduino
    IDE.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Arduino以太网库提供了对以太网协议的支持，因此也支持Arduino的以太网扩展，如以太网盾片。这是一个标准的Arduino库，它随Arduino
    IDE一起部署。
- en: 'The library is designed to accept incoming connection requests when deployed
    as a server and while making outgoing connections to other servers when being
    utilized as a client. The library concurrently supports up to four connections
    due to the limited computation capability of the Arduino board. To use the Ethernet
    library in your Arduino program, the first step you have to take is to import
    it in to your Arduino sketch:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 该库设计为在作为服务器部署时接受传入的连接请求，并在作为客户端使用时向其他服务器发起连接。由于Arduino板计算能力的限制，该库同时支持最多四个连接。要在Arduino程序中使用Ethernet库，你必须首先将其导入到Arduino草图：
- en: '[PRE5]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The Ethernet library implements various functionalities through specific classes,
    which are described as follows.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Ethernet库通过特定的类实现各种功能，以下将逐一描述。
- en: Tip
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: We are going to describe only the important methods provided by these classes.
    You can obtain more information regarding this library and its classes from [http://arduino.cc/en/Reference/Ethernet](http://arduino.cc/en/Reference/Ethernet).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将仅描述这些类提供的重要方法。有关此库及其类的更多信息，请参阅[http://arduino.cc/en/Reference/Ethernet](http://arduino.cc/en/Reference/Ethernet)。
- en: The Ethernet class
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Ethernet类
- en: 'The `Ethernet` class is a core class of the Ethernet library, and it provides
    methods to initialize this library and the network settings. This is an essential
    class for any program that wants to use the Ethernet library to establish connections
    through the Ethernet Shield. The primary information required to establish this
    connection is the MAC address of the device. You''ll need to create a variable
    that has the MAC address as an array of 6 bytes, as described here:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`Ethernet`类是Ethernet库的核心类，它提供了初始化此库和网络设置的方法。对于任何想要通过以太网盾片使用Ethernet库建立连接的程序来说，这是一个必不可少的类。建立此连接所需的主要信息是设备的MAC地址。你需要创建一个变量，该变量将MAC地址作为6字节的数组，具体描述如下：'
- en: '[PRE6]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The Ethernet library supports the **Dynamic Host Control Protocol** (**DHCP**),
    which is responsible for dynamically assigning IP addresses to new network nodes.
    If your home network is configured to support DHCP, you can establish the Ethernet
    connection using the `begin(mac)` method from the `Ethernet` class:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Ethernet库支持**动态主机控制协议**（**DHCP**），该协议负责为新网络节点动态分配IP地址。如果你的家庭网络配置为支持DHCP，你可以使用`Ethernet`类的`begin(mac)`方法建立Ethernet连接：
- en: '[PRE7]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Keep in mind that when you are initializing an Ethernet connection using this
    class, you are only initializing the Ethernet connection and setting up the IP
    address. This means that you still need to configure Arduino as a server or a
    client in order to enable further communication.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，当你使用此类初始化Ethernet连接时，你只是在初始化Ethernet连接并设置IP地址。这意味着你仍然需要将Arduino配置为服务器或客户端，以便启用进一步的通信。
- en: The IPAddress class
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: IPAddress类
- en: 'In applications where you have to manually assign the IP address to your Arduino
    device, you will have to use the `IPAddress` class of the Ethernet library. This
    class provides methods to specify the IP address, which can be either local or
    remote depending upon the application:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在需要手动为Arduino设备分配IP地址的应用中，你必须使用Ethernet库中的`IPAddress`类。此类提供了指定IP地址的方法，这可以是本地或远程的，具体取决于应用：
- en: '[PRE8]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The IP address created using this method can be used in the initialization
    of the network connection that we performed in the previous section. If you want
    to assign a manual IP address to your Arduino, you can use the `begin(mac, ip)`
    method with the MAC and IP addresses:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此方法创建的 IP 地址可以用于我们在上一节中执行的初始化网络连接。如果您想为 Arduino 分配一个手动 IP 地址，可以使用带有 MAC 和
    IP 地址的 `begin(mac, ip)` 方法：
- en: '[PRE9]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The Server class
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 服务器类
- en: 'The `Server` class is designed to create a server using the Ethernet library
    on Arduino, which listens to incoming connection requests for a specific port.
    The `EthernetServer()` method, when specified with in integer value of the port
    number, initializes the server on Arduino:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`Server` 类旨在在 Arduino 上使用 Ethernet 库创建服务器，该服务器监听指定端口的传入连接请求。当指定端口号的整数值时，`EthernetServer()`
    方法将在 Arduino 上初始化服务器：'
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'By specifying port `80` in the previous line of code (which represents the
    HTTP protocol on the TCP/IP suite), we have specifically created a web server
    using the Ethernet library. To start listening to the incoming connection requests,
    you have to use the `begin()` method on the `server` object:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一行代码中指定端口 `80`（代表 TCP/IP 套件中的 HTTP 协议），我们已特别使用 Ethernet 库创建了一个网络服务器。要开始监听传入的连接请求，您必须在
    `server` 对象上使用 `begin()` 方法：
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Once the connection is established, you can respond to a request using various
    methods supported by the server class, such as `write()`, `print()`, and `println()`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦建立连接，您可以使用服务器类支持的各种方法来响应请求，例如 `write()`、`print()` 和 `println()`。
- en: The Client class
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 客户端类
- en: 'The `Client` class provides methods to create an Ethernet client to connect
    and communicate with servers. The `EthernetClient()` method initializes a client
    that can be connected to a specific server using its IP address and port number.
    The `connect(ip, port)` method on the `client` object will establish a connection
    with the server on the mentioned IP address:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`Client` 类提供了创建 Ethernet 客户端以连接和与服务器通信的方法。`EthernetClient()` 方法初始化一个客户端，该客户端可以使用其
    IP 地址和端口号连接到特定的服务器。`client` 对象上的 `connect(ip, port)` 方法将与指定 IP 地址的服务器建立连接：'
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `Client` class also has the `connected()` method, which provides the status
    of the current connection in binary. This status can be `true` (connected) or
    `false` (disconnected). This method is useful for the periodic monitoring of the
    connection status:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`Client` 类也包含 `connected()` 方法，该方法以二进制形式提供当前连接的状态。此状态可以是 `true`（已连接）或 `false`（未连接）。此方法对于定期监控连接状态很有用：'
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Other important client methods include `read()` and `write()`. These methods
    help the Ethernet client to read the request from the server and to send messages
    to the server respectively.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 其他重要的客户端方法包括 `read()` 和 `write()`。这些方法帮助 Ethernet 客户端从服务器读取请求，并分别向服务器发送消息。
- en: Exercise 1 – a web server, your first Arduino network program
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 1 – 一个网络服务器，您的第一个 Arduino 网络程序
- en: 'The best way to test the Arduino Ethernet library and the Ethernet Shield is
    by using the built-in examples that are deployed with the Arduino IDE. If you
    are using version 1.x of the Arduino IDE, you can find a bunch of Ethernet examples
    by navigating to **File** | **Examples** | **Ethernet**. By utilizing one of these
    examples, we are going to build a web server that delivers the sensor values when
    requested by a web browser. As Arduino will be connected to your home network
    through the Ethernet, you will be able to access it from any other computer connected
    to your network. The major goals for this exercise are listed here:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 测试 Arduino Ethernet 库和 Ethernet 扩展板最好的方式是使用与 Arduino IDE 一起部署的内置示例。如果您使用的是 Arduino
    IDE 1.x 版本，可以通过导航到 **文件** | **示例** | **Ethernet** 来找到一系列的 Ethernet 示例。通过利用这些示例之一，我们将构建一个当通过网页浏览器请求时提供传感器值的网络服务器。由于
    Arduino 将通过 Ethernet 连接到您的家庭网络，您将能够从网络中的任何其他计算机访问它。本练习的主要目标如下：
- en: Use the Arduino Ethernet library with the Arduino Ethernet Shield extension
    to create a web server
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Arduino Ethernet 库和 Arduino Ethernet 扩展板创建网络服务器
- en: Remotely access Arduino using your home computer network
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用您的家庭电脑网络远程访问 Arduino
- en: Utilize a default Arduino example to provide humidity and motion sensor values
    using a web server
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用默认的 Arduino 示例，通过网络服务器提供湿度和运动传感器值
- en: 'To achieve these goals, the exercise is divided into the following stages:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这些目标，练习被分为以下阶段：
- en: Design and build hardware for the exercise using your Arduino and the Ethernet
    Shield
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用您的 Arduino 和 Ethernet 扩展板设计并构建练习所需的硬件
- en: Run a default example from the Arduino IDE as the starting point of the exercise
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以Arduino IDE中的默认示例作为练习的起点
- en: Modify the example to accommodate your hardware design and redeploy the code
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改示例以适应您的硬件设计并重新部署代码
- en: The following is a Fritzing diagram of the circuit required for this exercise.
    The first thing you should do is mount the Ethernet Shield on top of your Arduino
    Uno. Ensure that all the pins of the Ethernet Shield are aligned with the corresponding
    pins of the Arduino Uno. Then you need to connect the previously used humidity
    sensor, HIH-4030, and the PIR motion sensor.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是为此练习所需的电路的Fritzing图。您应该做的第一件事是将以太网盾安装到Arduino Uno的顶部。确保所有以太网盾的引脚都与Arduino
    Uno的相应引脚对齐。然后您需要连接之前使用的湿度传感器HIH-4030和PIR运动传感器。
- en: '![Exercise 1 – a web server, your first Arduino network program](img/5938OS_08_10.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![练习1 – 一个网络服务器，您的第一个Arduino网络程序](img/5938OS_08_10.jpg)'
- en: Note
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: While deploying the Arduino hardware for remote connectivity without USB, you
    will have to provide external power for the board, as you no longer have a USB
    connection to power the board.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在部署Arduino硬件以实现无USB的远程连接时，您将不得不为板子提供外部电源，因为您不再有USB连接来为板子供电。
- en: Now connect your Arduino Uno to a computer using a USB cable. You will also
    need to connect Arduino to your local home network using an Ethernet cable. To
    do that, use a straight CAT5 or CAT6 cable and connect one end of the cable to
    your home router. This router should be the same device that provides network
    access to the computer you are using. Connect the other end of the Ethernet cable
    to the Ethernet port of the Arduino Ethernet Shield board. If the physical-level
    connection has been established correctly, you should see a green light on the
    port.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用USB线将您的Arduino Uno连接到计算机。您还需要使用以太网线将Arduino连接到您的本地家庭网络。为此，使用直通CAT5或CAT6线，并将线的一端连接到您的家庭路由器。这个路由器应该是提供您所使用计算机网络访问的同一设备。将以太网线的另一端连接到Arduino以太网盾板的以太网端口。如果物理级连接已经正确建立，您应该在该端口看到一个绿色的指示灯。
- en: '![Exercise 1 – a web server, your first Arduino network program](img/5938OS_08_11.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![练习1 – 一个网络服务器，您的第一个Arduino网络程序](img/5938OS_08_11.jpg)'
- en: 'Now it''s time to start coding your first Ethernet example. Open the **WebServer**
    example by navigating to **File** | **Examples** | **Ethernet** | **WebServer**
    in your Arduino IDE. As you can see, the Ethernet library is included with the
    other required libraries and the supported code. In the code, you will need to
    change the MAC and IP addresses to make it work for your configuration. While
    you can obtain the MAC address of the Ethernet Shield from the back of the board,
    you will have to select an IP address according to your home network configuration.
    As you have already obtained the IP address of the computer you are working with,
    select another address in the range. Ensure that no other network node is using
    this IP address. Use these MAC and IP addresses to update the following values
    in your code. You will need to repeat these steps for every exercise when you
    are dealing with Arduino Ethernet:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候开始编写您的第一个以太网示例了。在Arduino IDE中，通过导航到**文件** | **示例** | **以太网** | **WebServer**来打开**WebServer**示例。如您所见，以太网库已包含在其他所需库和支持代码中。在代码中，您需要更改MAC和IP地址以使其适用于您的配置。虽然您可以从板子的背面获得以太网盾的MAC地址，但您必须根据您的家庭网络配置选择一个IP地址。既然您已经获得了您正在工作的计算机的IP地址，请选择该范围内的另一个地址。确保没有其他网络节点使用此IP地址。使用这些MAC和IP地址来更新代码中的以下值。当您处理Arduino以太网时，您需要为每个练习重复这些步骤：
- en: '[PRE14]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Tip
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: In the IP network, the visible range of IP addresses for your network is a function
    of another address called **subnetwork** or **subnet**. The subnet of your LAN
    IP network can help you select the appropriate IP address for the Ethernet Shield
    in the range of the IP address of your computer. You can learn about the basics
    of the subnet at [http://en.wikipedia.org/wiki/Subnetwork](http://en.wikipedia.org/wiki/Subnetwork).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在IP网络中，您的网络可见的IP地址范围是另一个称为**子网**或**子网**的地址的函数。您的局域网IP网络的子网可以帮助您在计算机IP地址范围内选择适合以太网盾的IP地址。您可以在[http://en.wikipedia.org/wiki/Subnetwork](http://en.wikipedia.org/wiki/Subnetwork)上了解子网的基本知识。
- en: Before venturing further into the code, compile the code with these modifications
    and upload it to your Arduino. Once the uploading process is completed successfully,
    open a web browser and enter the IP address that you had specified in the Arduino
    sketch. If everything goes fine, you should see text displaying the values of
    the analog pins.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: 'To better understand what happened here, let''s go back to the code. As you
    can see, at the beginning of the code we initialize the Ethernet server library
    on port `80` using the `EthernetServer` method from the Ethernet library:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'During the execution of `setup()`, the program initializes the Ethernet connection
    through the Ethernet Shield using the `Ethernet.being()` method with the `mac`
    and `ip` variables that you defined earlier. The `server.begin()` method will
    start the server from here. Both of these steps are mandatory to start a server
    if you are using the Ethernet library for server code:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In the `loop()` function, we initialize a `client` object to listen to incoming
    client requests using the `EthernetClient` method. This object will respond to
    any request coming from connected clients that try to access the Ethernet server
    through port `80`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'On receiving the request, the program will wait for the request payload to
    end. Then it will reply to the client with formatted HTML data using the `client.print()`
    method:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If you try to access the Arduino server from the browser, you will see that
    the web server replies to the clients with the analog pin readings. Now, to obtain
    the proper values of the humidity and PIR sensors that we connected in the hardware
    design, you will have to perform the following modification to the code. You will
    notice here that we are replying to the clients with the calculated values of
    relative humidity, instead of raw readings from all the analog pins. We have also
    modified the text that will be printed in the web browser to match the proper
    sensor title:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In this process, we also added an Arduino function, `getHumidity()`, that will
    calculate the relative humidity from the values observed from the analog pins.
    We have already used a similar function to calculate relative humidity in one
    of the previous projects:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You can implement these changes to the **WebServer** Arduino example for the
    testing phase, or just open the `WebServer_Custom.ino` sketch from the `Exercise
    1 - Web Server` folder of your code directory. As you can see in the opened sketch
    file, we have already modified the code to reflect the changes, but you will still
    have to change the MAC and IP addresses to the appropriate addresses. Once you
    are done with these minor changes, compile and upload the sketch to Arduino.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: If everything goes as planned, you should be able to access the web server using
    your web browser. Open the IP address of your recently prepared Arduino in the
    web browser. You should be able to receive a similar response as displayed in
    the following screenshot. Although we are only displaying humidity values through
    this sketch, you can easily attach motion sensor values using additional `client.print()`
    methods.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '![Exercise 1 – a web server, your first Arduino network program](img/5938OS_08_12.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
- en: Just like the mechanism we implemented in this exercise, a web server responds
    to the request made by a web browser and delivers the web pages you are looking
    for. Although this method is very popular and universally used to deliver web
    pages, the payload contains a lot of additional metadata compared to the actual
    size of the sensor information. Also, the server implementation using the Ethernet
    server library occupies a lot of the Arduino's resources. Arduino, being a resource-constrained
    device, is not suitable for running a server application, as the Arduino's resources
    should be prioritized to handle the sensors rather than communication. Moreover,
    the web server created using the Ethernet library supports a very limited amount
    of connections at a time, making it unusable for large-scale applications and
    multiuser systems.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: The best approach to overcome this problem is by using Arduino as a client device,
    or by using lightweight communication protocols that are designed to work with
    resource-constrained hardware devices. In the next few sections, you are going
    to learn and implement these approaches for Arduino communication on the Ethernet.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: Developing web applications using Python
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By implementing the previous program, you have enabled networking on Arduino.
    In the preceding example, we created an HTTP web server using methods available
    from the Ethernet library. By creating an Arduino web server, we made the Arduino
    resources available on the network. Similarly, Python also provides extensibility
    by way of various libraries to create web server interfaces. By running the Python-based
    web server on your computer or other devices such as the Raspberry Pi, you can
    avoid using Arduino to host the web server. Web applications created using high-level
    languages such as Python can also provide additional capabilities and extensibility
    compared to Arduino.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will use the Python library, `web.py`, to create a Python
    web server. We will also use this library to create interactive web applications
    that will enable the transfer of data between an Arduino client and a web browser.
    After you have learned the basics of `web.py`, we will interface Arduino with
    `web.py` using serial ports to make Arduino accessible through the Python web
    server. Then we will upgrade the Arduino communication method from the serial
    interface to HTTP-based messaging.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: Python web framework – web.py
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A web server can be developed in Python using various web frameworks such as
    `Django`, `bottle`, `Pylon`, and `web.py`. We have selected `web.py` as the preferred
    web framework due to its simple yet powerful functionalities.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: The `web.py` library was initially developed by the late Aaron Swartz with the
    goal of developing an easy and straightforward approach to create web applications
    using Python. This library provides two main methods, `GET` and `POST`, to support
    the HTTP **Representation State Transfer** (**REST**) architecture. This architecture
    is designed to support the HTTP protocol by sending and receiving data between
    clients and the server. Today, the REST architecture is implemented by a huge
    number of websites to transfer data over HTTP.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: Installing web.py
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To get started with `web.py`, you need to install the `web.py` library using
    Setuptools. We installed Setuptools for various operating systems in [Chapter
    1](ch01.html "Chapter 1. Getting Started with Python and Arduino"), *Getting Started
    with Python and Arduino*. On Linux and Mac OS X, execute either of these commands
    on the terminal to install `web.py`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'On Windows, open the **Command Prompt** and execute the following command:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If Setuptools is set up correctly, you should be able to install the library
    without any difficulty. To verify the installation of the library, open the Python
    interactive prompt and run this command to see whether you have imported the library
    without any errors:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Your first Python web application
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Implementing a web server using `web.py` is a very simple and straightforward
    process. The `web.py` library requires the declaration of a mandatory method,
    `GET`, to successfully start the web server. When a client tries to access the
    server using a web browser or another client, `web.py` receives a `GET` request
    and returns data as specified by the method. To create a simple web application
    using the `web.py` library, create a Python file using the following lines of
    code and execute the file using Python. You can also run the `webPyBasicExample.py`
    file from the code folder of this chapter:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: On execution, you will see that the server is now running and accessible through
    the `http://0.0.0.0:8080` address. As the server program is running on the `0.0.0.0`
    IP address, you can access it using the same computer, localhost, or any other
    computer from the same network.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: 'To check out the server, open a web browser and go to `http://0.0.0.0:8080`.
    When you are trying to access the server from the same computer, you can also
    use `http://127.0.0.1:8080` or `http://localhost:8080`. The `127.0.0.1` IP address
    actually stands for localhost, that is, the network address of the same computer
    on which the program is running. You will be able to see the response of the server
    displayed in the browser, as shown in the following screenshot:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '![Your first Python web application](img/5938OS_08_13.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
- en: 'To understand how this simple code works, check out the `GET` method in the
    previous code snippet. As you can see, when the web browser requests the URL,
    the `GET` method returns the `Hello, world!` string to the browser. Meanwhile,
    you can also observe two other mandatory `web.py` components in your code: the
    `urls` and `web.application()` methods. The `web.py` library requires initialization
    of the response location in the declaration of the `urls` variable. Every `web.py`-based
    web application requires the `application(urls, global())` method to be called
    to initialize the web server. By default, the `web.py` applications run on port
    number `8080`, which can be changed to another port number by specifying it during
    execution. For example, if you want to run your `web.py` application on port `8888`,
    execute the following command:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Although this only returns simple text, you have now successfully created your
    first web application using Python. We will take it forward from here and create
    more complex web applications in the upcoming chapters using the `web.py` library.
    To develop these complex applications, we will require more than just the `GET`
    method. Let's start exploring advance concepts to further enhance your familiarity
    with the `web.py` library.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: Essential web.py concepts for developing complex web applications
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `web.py` library has been designed to provide convenient and simple methods
    to develop dynamic websites and web applications using Python. Using `web.py`,
    it is really easy to build complex websites by utilizing just a few additional
    Python concepts along with what you already know. Due to this limited learning
    curve and easy-to-implement methods, `web.py` is one of the quickest ways to create
    web applications in any programming language. Let's begin with understanding these
    `web.py` concepts in detail.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: Handling URLs
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You might have noticed that in our first `web.py` program, we defined a variable
    called `urls` that points to the root location (`/`) of the `Index` class:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In the preceding declaration, the first part, `''/''`, is a regular expression
    used to match the actual URL requests. You can use regular expressions to handle
    complex queries coming to your `web.py` server and point them to the appropriate
    class. In `web.py`, you can associate different landing page locations with appropriate
    classes. For example, if you want to redirect the `/data` location to the `data`
    class in addition to the `Index` class, you can change the `urls` variable as
    follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: With this provision, when a client sends a request to access the `http://<ip-address>:8080/data`
    address, the request will be directed towards the `data` class and then the `GET`
    or `POST` method of that class.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: The GET and POST methods
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In exercise 1, where we created an Arduino-based web server running on port
    `80`, we used a web browser to access the web server. Web browsers are one of
    the most popular types of web clients used to access a web server; cURL, Wget,
    and web crawlers are the other types. A web browser uses HTTP to communicate with
    any web servers, including the Arduino web server that we used. `GET` and `POST`
    are two fundamental methods supported by the HTTP protocol to address server requests
    coming from a web browser.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: 'Whenever you are trying to open a website in your browser or any other HTTP
    client, you are actually requesting the `GET` function from the web server; for
    example, when you open a website URL, `http://www.example.com/`, you are requesting
    that the web server that hosts this website serves you the `GET` request for the
    `''/''` location. In the *Handling URLs* section, you learned how to associate
    the `web.py` classes with URL landing locations. Using the `GET` method provided
    by the `web.py` library, you can associate the `GET` request with individual classes.
    Once you have captured the `GET` request, you need to return appropriate values
    as the response to the client. The following code snippet shows how the `GET()`
    function will be called when anyone makes a `GET` request to the `''/''` location:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `POST` function of the HTTP protocol is mainly used to submit a form or
    any other data to the web server. In most cases, `POST` is embedded in a web page,
    and a request to the server is generated when a user submits the component carrying
    the `POST` function. The `web.py` library also provides the `POST()` function,
    which is called when a web client tries to contact the `web.py` server using the
    `POST` method. In most implementations of the `POST()` function, the request includes
    some kind of data submitted through forms. You can retrieve individual form elements
    using `f[''Celsius''].value` which will give you a value associated with the form
    element called `Celsius`. Once the `POST()` function has performed the provided
    actions, you can return appropriate information to the client in response to the
    `POST` request:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Templates
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now you know how to redirect an HTTP request to an appropriate URL, and also
    how to implement methods to respond to these HTTP requests (that is, `GET` and
    `POST`). But what about the web page that needs to be rendered once the request
    is received? To understand the rendering process, let''s start with creating a
    folder called `templates` in the same directory where our `web.py` program is
    going to be placed. This folder will store the templates that will be used to
    render the web pages when requested. You have to specify the location of this
    template folder in the program using the `template.render()` function, as displayed
    in the following line of code:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Once you have instantiated the rendering folder, it is time to create template
    files for your program. According to the requirements of your program, you can
    create as many template files as you want. A language called **Templetor** is
    used to create these template files in `web.py`. You can learn more about it at
    [http://webpy.org/templetor](http://webpy.org/templetor). Each template file created
    using Templetor needs to be stored in the HTML format with the `.html` extension.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a file called `test.html` in the `templates` folder using a text
    editor and paste the following code snippet in to the file:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: As you can see in the preceding code snippet, the template file begins with
    the `$def with()` expression, where you need to specify the input arguments as
    variables within the brackets. Once the template is rendered, these will be the
    only variables you can utilize for the web page; for example, in the previous
    code snippet, we passed two variables (`form` and `i`) as input variables. We
    utilized the `form` object using `$:form.render()` to render it inside the web
    page. When you need to render the `form` object, you can directly pass the other
    variable by simply declaring it (that is, `$:i`). Templetor will render the HTML
    code of the template file as it is, while utilizing the variables in the instances
    where they are being used.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you have a template file, `test.html`, ready to be used in your `web.py`
    program. Whenever a `GET()` or `POST()` function is executed, you are required
    to return a value to the requesting client. Although you can return any variable
    for these requests, including `None`, you will have to render a template file
    where the response is associated with loading a web page. You can return the template
    file using the `render()` function, followed by the filename of the template file
    and input arguments:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: As you can see in the preceding line of code, we are returning the rendered
    `test.html` page by specifying the `render.test()` function, where `test()` is
    just the filename without the `.html` extension. The function also includes a
    form object, `f`, and variable, `i`, that will be passed as input arguments.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: Forms
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `web.py` library provides simple ways of creating form elements using the
    `Form` module. This module includes the capability to create HTML form elements,
    obtain inputs from users, and validate these inputs before utilizing them in the
    Python program. In the following code snippet, we are creating two form elements,
    `Textbox` and `Button`, using the `Form` library:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Besides `Textbox` (which obtains text input from users) and `Button` (which
    submits the form), the `Form` module also provides a few other form elements,
    such as `Password` to obtain hidden text input, `Dropbox` to obtain a mutually
    exclusive input from a drop-down list, `Radio` to obtain mutually exclusive inputs
    from multiple options, and `Checkbox` to select a binary input from the given
    options. While all of these elements are very easy to implement, you should select
    form elements only according to your program requirements.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `web.py` implementation of `Form`, the web page needs to execute the
    `POST` method every time the form is submitted. As you can in see in the following
    implementation of the form in the template file, we are explicitly declaring the
    form submission method as `POST`:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Exercise 2 – playing with web.py concepts using the Arduino serial interface
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now you have a general idea of the basic `web.py` concepts used to build a web
    application. In this exercise, we will utilize the concepts you learned to create
    an application to provide the Arduino with sensor information. As the goal of
    this exercise is to demonstrate the `web.py` server for Arduino data, we are not
    going to utilize the Ethernet Shield for communication. Instead, we will capture
    the Arduino data using the serial interface, while using the `web.py` server to
    respond to the requests coming from different clients.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the following diagram, we are using the same hardware that
    you designed for exercise 1, but without utilizing the Ethernet connection to
    our home router. Your computer running the `web.py` server, which is also a part
    of your home network, will serve the client requests.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '![Exercise 2 – playing with web.py concepts using the Arduino serial interface](img/5938OS_08_14.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
- en: 'In the first step, we are going to code Arduino to periodically send the humidity
    sensor value to the serial interface. For the Arduino code, open the `WebPySerialExample_Arduino.ino`
    sketch from the `Exercise 2` folder of your code directory. As you can see in
    the following code snippet of the Arduino sketch, we are sending raw values from
    the analog port to the serial interface. Now compile and upload the sketch to
    your Arduino board. Open the **Serial Monitor** window from the Arduino IDE to
    confirm that you are receiving the raw humidity observations. Once you have confirmed
    it, close the **Serial Monitor** window. You won''t be able to run the Python
    code if the **Serial Monitor** window is using the port:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Once the Arduino code is running properly, it is time to execute the Python
    program, which contains the `web.py` server. The Python program for this exercise
    is located in the `WebPySerialExample_Python` directory. Open the `webPySerialExample.py`
    file in your code editor. The Python program is organized in two sections: capturing
    sensor data from the serial interface using the `pySerial` library, and using
    the `web.py` server-based server to respond to the requests from the clients.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: 'In the first stage of the code, we are interfacing the serial port using the
    `Serial()` method from the `pySerial` library. Don''t forget to change the serial
    port name as it may be different for your computer, depending on the operating
    system and physical port that you are using:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Once the `port` object for the serial port is created, the program starts reading
    the text coming from the physical port, using the `readline()` method. Using the
    `relativeHumidity()` function, we convert the raw humidity data to appropriate
    relative humidity observations:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'On the web server side, we will be using all the major `web.py` components
    you learned in the previous section to complete this goal. As part of it, we are
    implementing an input form for the temperature value. We will capture this user
    input and utilize it with the raw sensor data to calculate relative humidity.
    Therefore, we need to define the `render` object to use the `template` directory.
    In this exercise, we are only using the default landing page location ( `''/''`)
    for the web server, which is directed towards the `Index` class:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'As you can see in the `WebPySerialExample_Python` folder, we have a directory
    called `templates`. This directory contains a template with the `base.html` filename.
    As this is an HTML file, it is likely that if you just click on the file, it opens
    in a web browser. Make sure that you open the file in a text editor. In the opened
    file, you''ll see that we are initializing the template file with `$def with(form,
    humidity)`. In this initialization, `form` and `humidity` are input variables
    that are required by the template during the rendering process. The template declares
    the actual `<form>` element with the `$:form.render()` method, while displaying
    the humidity value using the `$humidity` variable:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Although the template file renders the `form` variable, we have to define this
    variable in the Python program first. As you can see in the following code snippet,
    we have declared a variable called `submit_form` using the `form.Form()` method
    of the `web.py` library. The `submit_form` variable includes a `Textbox` element
    to capture the temperature value and a `Button` element to enable the submit action:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'When you want to access the current submitted values of the `submit_form` variable,
    you will have to validate the form using the `validates()` method:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Now we have the user-facing web page and input components designed for the exercise.
    It is time to define the two main methods, `GET` and `POST`, to respond to the
    request coming from the web page. When you launch or refresh the web page, the
    `web.py` server generates the `GET` request, which is then handled by the `GET`
    function of the `Index` class. So during the execution of the `GET` method, the
    program obtains the latest raw humidity value from the serial port and calculates
    the relative humidity using the `relativeHumidity()` method.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the process of dealing with the `GET` request, we are not submitting any
    form with the user input. For this reason, in the `GET` method, we will use the
    default value of temperature (`25`) for the `relativeHumidity()` method.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the humidity value is derived, the program will render the `base` template
    using the `render.base()` function, as displayed in the following code snippet,
    where `base()` refers to the base template:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Contrary to the `GET` method, the `POST` method is invoked when the form is
    submitted to the web page. The submitted form includes the temperature value provided
    by the user, which will be used to obtain the value of the relative humidity.
    Like the `GET()` function, the `POST()` function also renders the `base` template
    with the recent humidity value once the humidity is calculated:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Now it is time to run the `web.py`-based web server. In the Python program,
    make the necessary changes to accommodate the serial port name and any other appropriate
    values. If everything is configured correctly, you will be able to execute the
    program from the terminal without any errors. You can access the web server, which
    is running on port `8080`, from a web browser on the same computer, that is, `http://localhost:8080`.
    Now the goal of the exercise is to demonstrate the remote accessibility of the
    web server from your home network, and you can do this by opening the website
    from another computer in your network, that is, `http://<ip-address>:8080`, where
    `<ip-address>` refers to the IP address of the computer that is running the `web.py`
    service.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '![Exercise 2 – playing with web.py concepts using the Arduino serial interface](img/5938OS_08_15.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
- en: The preceding screenshot shows how the web application will look when opened
    in a web browser. When you load the website, you will be able to see a relative
    humidity value obtained using the `GET` method. Now you can enter an appropriate
    temperature value and press the **submit** button to invoke the `POST` method.
    On successful execution, you will be able to see the latest relative humidity
    value, which is calculated based on the temperature value that you submitted.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: RESTful web applications with Arduino and Python
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous exercise, we implemented the `GET` and `POST` requests using
    the `web.py` library. These requests are actually part of the most popular communication
    architecture of the **World Wide Web** (**WWW**) called REST. The REST architecture
    implements a client-server paradigm using the HTTP protocol for operations such
    as `POST`, `READ`, and `DELETE`. The `GET()` and `POST()` functions, implemented
    using `web.py`, are functional subsets of these standard HTTP REST operations,
    that is, `GET`, `POST`, `UPDATE`, and `DELETE`. The REST architecture is designed
    for network applications, websites, and web services to establish communication
    through HTTP-based calls. Rather than being just a set of standard rules, the
    REST architecture utilizes existing web technologies and protocols, making it
    a core component of the majority of the websites we use today. Due to this reason,
    the WWW can be considered to be the largest implementation of REST-based architecture.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: Designing REST-based Arduino applications
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The REST architecture uses a client-server model, where the server acts as a
    centralized node in the network. It responds to the requests made by the distributed
    network nodes (called **clients**) that query it. In this paradigm, the client
    initiates a request for the state directed towards the server, while the server
    responds to the state request without storing the client context. This communication
    is always one-directional and always initiated from the client side.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '![Designing REST-based Arduino applications](img/5938OS_08_16.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
- en: To further explain the state transfer for the `GET` and `POST` requests, check
    out the previous diagram. When a client sends a `GET` request to a server using
    a URL, the server responds with raw data as the HTTP response. Similarly, in the
    `POST` request, the client sends data as payload to the server, while the server
    responds with simply a "received confirmation" message.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: REST methods are relatively simple to implement and develop using simple HTTP
    calls. We are going to start developing Arduino networking applications using
    REST-based requests, as they are easy to implement and understand and are directly
    available through examples. We will begin by individually implementing REST-based
    Arduino clients for HTTP-based `GET` and `POST` methods. Later in this chapter,
    we will go through an exercise to combine the `GET` and `POST` methods through
    the same Arduino REST client, while developing the HTTP server using `web.py`.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: Working with the GET request from Arduino
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we will implement the HTTP `GET` client on Arduino, while
    using an HTTP server that was developed using `web.py`. The premise of this programming
    exercise is to use the Ethernet Shield extension and the Ethernet library to develop
    a physical Arduino HTTP client that supports the `GET` request.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: The Arduino code to generate the GET request
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Arduino IDE ships with a few basic examples that utilize the Ethernet library.
    One of these examples is **WebClient**, which can be found by navigating to **File**
    | **Examples** | **Ethernet** | **WebClient**. It is designed to demonstrate the
    `GET` request by implementing the HTTP client on Arduino. Open this sketch in
    the Arduino IDE, as we are going to use this sketch and modify it to accommodate
    the Arduino hardware we created.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing you need to change in the opened sketch is the IP address and
    the MAC address of your Arduino Ethernet Shield. Replace the following variables
    with the variables appropriate for your system. The following code snippet shows
    the IP address and the MAC address for our hardware, and you need to change it
    to accommodate yours:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'As you can see, the example uses Google as a server to get a response. You
    need to change this address to reflect the IP address of your computer, which
    will host the `web.py` server:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'In the `setup()` function, you will have to change the server IP address again.
    Also change the default HTTP port (`80`) to the port used by `web.py` (`8080`):'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Once you have made all of these changes, go to the `Arduino_GET_Webpy\ArduinoGET`
    folder and open the `ArduinoGET.ino` sketch. Compare your modified sketch with
    this sketch and perform the appropriate changes. Now you can save your sketch
    and compile your code for any errors.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: At this stage, we are assuming that you have the Arduino Ethernet Shield mounted
    on your Arduino Uno. Connect the Ethernet Shield to your local network using an
    Ethernet cable, and connect Uno with your computer using a USB cable. Upload the
    sketch to the Arduino board and open the **Serial Monitor** window to check the
    activity. At this stage, Arduino would not be able to connect to the server because
    your `web.py` server is still not running. You can close the serial monitor for
    now.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: The HTTP server using web.py to handle the GET request
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In your first `web.py` application, you developed a server that returned `Hello,
    world!` when requested from a web browser. Despite all the additional tasks it
    can perform, your web browser is an HTTP client at its core. This means that if
    your first `web.py` server code was able to respond to the `GET` request made
    by the web browser, it should also be able to respond to the Arduino web client.
    To check this out, open your first `web.py` program, `webPyBasicExample.py`, and
    change the return string from `Hello World!` to `test`. We are performing this
    string change to differentiate it from the other instances of this program. Execute
    the Python program from the terminal and open the **Serial Monitor** window in
    the Arduino IDE again. This time, you will be able to see that your Arduino client
    is receiving a response for the `GET` request it sent to the `web.py` server.
    As you can see in the following screenshot, you will be able to see the `test`
    string printed in the **Serial Monitor** window, which is returned by the `web.py`
    server for the `GET` request:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '![The HTTP server using web.py to handle the GET request](img/5938OS_08_17.jpg)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
- en: Although in this example we are returning a simple string for the `GET` request,
    you can extend this method to obtain different user-specified parameters from
    the web server. This `GET` implementation can be used in a large number of applications
    where Arduino requires repeated input from the user or other programs. But what
    if the web server requires input from the Arduino? In that case, we will have
    to use the `POST` request. Let's develop an Arduino program to accommodate the
    HTTP `POST` request.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: Working with the POST request from Arduino
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since we have now implemented the `GET` request, we can use a similar approach
    to exercise the `POST` request. Instead of asking the server to provide a response
    for a state request, we will send sensor data as payload from Arduino in the implementation
    of the `POST` request. Similarly, on the server side, we will utilize `web.py`
    to accept the `POST` request and display it through a web browser.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: The Arduino code to generate the POST request
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Open the Arduino sketch `ArduinoPOST.ino` from the `Arduino_POST_Webpy\ArduinoPOST`
    folder of the code repository. As in the previous exercise, you will first have
    to provide the IP address and the MAC address of your Arduino.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have completed these basic changes, observe the following code snippet
    for the implementation of the `POST` request. You might notice that we are creating
    payload for the `POST` request as the variable data from the values obtained from
    analog pin 0:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'In the following Arduino code, we''ll first create a `client` object using
    the Ethernet library. In the recurring `loop()` function, we''ll use this `client`
    object to connect to the `web.py` server running on our computer. You will have
    to replace the IP address in the `connect()` method with the IP address of your
    `web.py` server. Once connected, we''ll create a custom `POST` message with the
    payload data we calculated previously. The Arduino `loop()` function will periodically
    send the updated sensor value generated by this code sample to the `web.py` server:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Once you have performed the changes, compile and upload this sketch to the Arduino
    board. As the `web.py` server is yet not implemented, the `POST` request that
    originated from Arduino will not be able to reach its destination successfully,
    so let's create the `web.py` server to accept `POST` requests.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: The HTTP server using web.py to handle the POST request
  id: totrans-245
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this implementation of the `POST` method, we require two `web.py` classes,
    `index` and `data`, to individually serve requests from the web browser and Arduino
    respectively. As we are going to use two separate classes to update common sensor
    values (that is, `humidity` and `temperature`), we are going to declare them as
    global variables:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'As you may have noticed in the Arduino code (`client.println("POST /data HTTP/1.1")`),
    we were sending the `POST` request to the URL located at `/data`. Similarly, we
    will use the default root location, `''/''`, to land any request coming from the
    web browser. These requests for the root location will be handled by the `index`
    class, just as we covered in exercise 2:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The `data` class takes care of any `POST` request originating from the `/data`
    location. In this case, these `POST` requests contain payload that has sensor
    information attached by the Arduino `POST` client. On receiving the message, the
    method splits the payload string into sensor-type and value, updating the global
    value of the `humidity` variable in this process:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Each `POST` request received from Arduino updates the raw humidity value, which
    is represented by the `data` variable. We are using the same code from exercise
    2 to obtain manual temperature values from the user. The relative humidity value,
    `humidity`, is updated according to the temperature value you updated using the
    web browser and the raw humidity value is obtained from your Arduino.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '![The HTTP server using web.py to handle the POST request](img/5938OS_08_18.jpg)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
- en: To check out the Python code, open the `WebPyEthernetPOST.py` file from the
    code repository. After making the appropriate changes, execute the code from the
    terminal. If you don't start getting any updates from the Arduino on the terminal,
    you should restart Arduino to reestablish the connection with the `web.py` server.
    Once you start seeing periodic updates from the Arduino `POST` requests at the
    terminal, open the location of the web application in your browser. You will be
    able to see something similar to the preceding screenshot. Here, you can submit
    the manual temperature value using the form, while the browser will reload with
    the updated relative humidity according to the temperature value entered.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 3 – a RESTful Arduino web application
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The goal of this exercise is to simply combine the `GET` and `POST` methods
    you learned in the previous two sections in order to create a complete REST experience
    using Arduino and Python. The architecture for this exercise can be described
    as follows:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: The Arduino client periodically uses the `GET` request to obtain the sensor
    type from the server. It uses this sensor type to select a sensor for observation.
    In our case, it is either a humidity or motion sensor.
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The web server responds to the `GET` request by returning the current sensor
    type of the sensor selected by the user. The user provides this selection through
    a web application.
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After receiving the sensor type, the Arduino client utilizes `POST` to send
    sensor observation to the server.
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The web server receives the `POST` data and updates the sensor observation for
    that particular sensor type.
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the user side, the web server obtains the current sensor type through the
    web browser.
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the **submit** button in the browser is pressed, the server updates the
    sensor value in the browser with the latest value.
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Arduino sketch for the exercise
  id: totrans-263
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Using the same Arduino hardware we built, open the Arduino sketch named `WebPyEthernetArduinoGETPOST.ino`
    from the `Exercise 3 - RESTful application Arduino and webpy` code folder. As
    we described in the exercise''s architecture earlier, the Arduino client should
    periodically send `GET` requests to the server and get the corresponding value
    of the sensor type in the response. After comparing the sensor type, the Arduino
    client fetches the current sensor observation from the Arduino pins and sends
    that observation back to the server using `POST`:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: After changing the appropriate server's IP address in the code, compile and
    upload it to the Arduino. Open the **Serial Monitor** window, where you will find
    unsuccessful connection attempts, as your `web.py` server is not yet running.
    Close any other instance or program of the `web.py` server running on your computer.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: The web.py application to support REST requests
  id: totrans-267
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Open the `WebPyEthernetGETPOST.py` file from the `Exercise 3 - RESTful application
    Arduino and webpy` code folder. As you can see, the `web.py` based web server
    implements two separate classes, `index` and `data`, to support the REST architecture
    for the web browser and the Arduino client, respectively. We are introducing a
    new concept for the `Form` element, called `Dropdown()`. Using this `Form` method,
    you can implement the drop-down selection menu and ask the user to select one
    option from the list of options:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'In the previous `web.py` program, we implemented the `GET` and `POST` methods
    for the `index` class and only the `POST` method for the `data` class. Moving
    forward in this exercise, we''ll also add the `GET` method to the `data` class.
    This method returns the value of the `sensorType` variable when the `GET` request
    is made for the `/data` location. From the user side, the value of the `sensorType`
    variable is updated when the form gets submitted with an option. This action sends
    a selected value to the `POST` method of the `index` class, ultimately updating
    the `sensorType` value:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Before you run this Python program, make sure you have checked every component
    of the code and updated the values where needed. Then execute the code from the
    terminal. Your web server will now run on your local computer on the port number
    `8080`. Power-cycle your Arduino device in case the connection attempt from Arduino
    fails. To test your system, open the web application from your web browser. You
    will see a web page open in your browser, as displayed in the following screenshot:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '![The web.py application to support REST requests](img/5938OS_08_19.jpg)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
- en: You can choose the sensor type from the **dropdown** menu ( **Humidity** or
    **Motion**) before pressing the **Submit** button. On submission, you will be
    able to see the page updated with the appropriate sensor type and its current
    value.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: Why do we need a resource-constrained messaging protocol?
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous section, you learned how to use the HTTP `REST` architecture
    to send and receive data between your Arduino and the host server. The HTTP protocol
    was originally designed to serve textual data through web pages on the Internet.
    The data delivery mechanism used by HTTP requires a comparatively large amount
    of computation and network resources, which may be sufficient for a computer system
    but not for resource-constrained hardware platforms such as Arduino. As we discussed
    earlier, the client-server paradigm implemented by the HTTP REST architecture
    creates a tightly coupled system. In this paradigm, both sides (the client and
    the server) need to be constantly active, or live, to respond. Also, the REST
    architecture only allows unidirectional communication from client to server, where
    requests are always initialized by the client and the server responds to the client.
    This request-response-based architecture is not suitable for constrained hardware
    devices because of (but not limited to) the following reasons:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: These devices should avoid active communication mode to save power
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The communication should have less data overhaul to save network resources
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They usually do not have enough computational resources to enable bidirectional
    REST communication, that is, implementing both client and server mechanisms on
    each side
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code should have a smaller footprint due to storage constraints
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  id: totrans-281
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: The REST-based architecture can still be useful when the application specifically
    requires a request-response architecture, but most sensor-based hardware applications
    are limited due to the preceding points.
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Among other data delivery paradigms that solve the preceding problems, the architecture
    based on **publisher/subscriber** (**pub/sub**) stands tall. The pub/sub architecture
    enables bidirectional communication capabilities between the node that generates
    the data (**Publisher**) and the node that consumes the data (**Subscriber**).
    We are going to use MQTT as the protocol that uses the pub/sub model of message
    transportation. Let's begin by covering the pub/sub architecture and MQTT in detail.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: MQTT – A lightweight messaging protocol
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Just like REST, pub/sub is one of the most popular messaging patterns, mostly
    deployed to transfer short messages between nodes. Instead of deploying client-server-based
    architecture, the pub/sub paradigm implements messaging middleware called a **broker**
    to receive, queue, and relay messages between the subscriber and publisher clients:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '![MQTT – A lightweight messaging protocol](img/5938OS_08_20.jpg)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
- en: The pub/sub architecture utilizes a topic-based system to select and process
    messages, where each message is labeled with a specific topic name. Instead of
    sending a message directly to the subscriber, the publisher sends it first to
    the broker with a topic name. In a totally independent process, the subscriber
    registers its subscription for particular topics with the broker. In the event
    of receiving a message from the publisher, the broker performs topic-based filtering
    on that message before forwarding it to the subscribers registered for that topic.
    As publishers are loosely coupled to subscribers in this architecture, the publishers
    do not need to know the whereabouts of the subscribers and can work uninterrupted
    without worrying about their status.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: While discussing the limitations of the REST architecture, we noticed that it
    requires the implementation of both the HTTP client and server on the Arduino
    end to enable bidirectional communication with Arduino. With the broker-based
    architecture demonstrated by pub/sub, you only need to implement lightweight code
    for the publisher or subscriber client on Arduino, while the broker can be implemented
    on a device with more computation resources. Henceforth, you will have bidirectional
    communication enabled on Arduino without using significant resources.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to MQTT
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Message Queue Telemetry Transport** (**MQTT**) is a very simple, easy, and
    open implementation of the pub/sub paradigm. IBM has been working on standardizing
    and supporting the MQTT protocol. The documentation for the latest specification
    of the MQTT protocol, v3.1, can be obtained from the official MQTT website at
    [http://www.mqtt.org](http://www.mqtt.org).'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: As a standard for machine messaging, MQTT is designed to be extremely lightweight
    and with a smaller footprint for code, while also using a lower network bandwidth
    for communication. MQTT is very specifically designed to work on embedded systems—like
    hardware platforms such as Arduino and other appliances—that carry limited processor
    and memory resources. While MQTT is a transport layer messaging protocol, it uses
    TCP/IP for network-level connectivity. As MQTT is designed to support the pub/sub
    messaging paradigm, the implementation of MQTT on your hardware application provides
    support for one-to-many distributed messaging, eliminating the limitation of unidirectional
    communication demonstrated by HTTP REST. As MQTT is agnostic of the content of
    the payload, there is no restriction on the type of message you can pass using
    this protocol.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: Due to all the benefits associated with the pub/sub paradigm and its implementation
    in the MQTT protocol, we will be using the MQTT protocol for the rest of the exercises
    to have messages communicated between Arduino and its networked computer. To achieve
    this, we will be using the MQTT broker to provide the ground work for message
    communication and host topics, while deploying the MQTT publisher and subscriber
    clients at the Arduino and Python ends.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: Mosquitto – an open source MQTT broker
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we described, MQTT is just a protocol standard, and it still requires software
    tools so that it can be implemented in actual applications. **Mosquitto** is an
    open source implementation of the message broker, which supports the latest version
    of the MQTT protocol standard. The Mosquitto broker enables the pub/sub paradigm
    implemented by the MQTT protocol, while providing a lightweight mechanism to enable
    messaging between machines. Development of Mosquitto is supported through community
    efforts. Mosquitto is one of the most popular MQTT implementations, freely available
    and widely supported on the Internet. You can obtain further information regarding
    the actual tool and community from its website, at [http://www.mosquitto.org](http://www.mosquitto.org).
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Mosquitto
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The installation and configuration of Mosquitto are very straightforward processes.
    At the time of writing this book, the latest version of Mosquitto is 1.3.4\. You
    can also obtain the latest updates and installation information regarding Mosquitto
    at [http://www.mosquitto.org/download/](http://www.mosquitto.org/download/).
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: 'On Windows, you can simply download the latest version of the installation
    files for Windows, which is made for Win32 or Win64 systems. Download and run
    the executable file to install the Mosquitto broker. To run Mosquitto from the
    command prompt, you will have to add the Mosquitto directory to the `PATH` variables
    in the environment variables of the system properties. In [Chapter 1](ch01.html
    "Chapter 1. Getting Started with Python and Arduino"), *Getting Started with Python
    and Arduino*, we comprehensively described the process of adding a `PATH` variable
    to install Python. Using the same method, add the path of the Mosquitto installation
    directory at the end of the `PATH` value. If you are using a 64-bit operating
    system, you should use `C:\Program Files (x86)\mosquitto`. For a 32-bit operating
    system, you should use `C:\Program Files\mosquitto` as the path. Once you are
    done with adding this value at the end of the `PATH` value, close any existing
    command prompt windows and open a new Command Prompt window. You can validate
    the installation by typing the following command in the newly opened window. If
    everything is installed and configured correctly, the following command should
    execute without any errors:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'For Mac OS X, the best way to install Mosquitto is to use the Homebrew tool.
    We already went through the process of installing and configuring Homebrew in
    [Chapter 1](ch01.html "Chapter 1. Getting Started with Python and Arduino"), *Getting
    Started with Python and Arduino*. Install the Mosquitto broker by simply executing
    the following script on the terminal. This script will install Mosquitto with
    the Mosquitto utilities and also configure them to run from the terminal as commands:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'On Ubuntu, the default repository already has the installation package for
    Mosquitto. Depending on the version of Ubuntu you are using, this Mosquitto version
    could be older than the current version. In that case, you must add this repository
    first:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Now you can install the Mosquitto packages by simply running the following
    command:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Getting familiar with Mosquitto
  id: totrans-305
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Due to the multiple installation methods involved for different operating systems,
    the initialization of Mosquitto may be different for your instance. In some cases,
    Mosquitto might already be running on your computer. For a Unix-based operating
    system, you can check whether Mosquitto is running or not with this command:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Unless you find a running instance of the broker, you can start Mosquitto by
    executing the following command in the terminal. After executing it, you should
    be able to see the broker running while printing the initialization parameters
    and other requests coming to it:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: When you installed the Mosquitto broker, the installation process would also
    have installed a few Mosquitto utilities, which include the MQTT clients for the
    publisher and the subscriber. These client utilities can be used to communicate
    with any Mosquitto broker.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the subscriber client utility, `mosquitto_sub`, use the following command
    at the terminal with the IP address of the Mosquitto broker. As we are communicating
    to the Mosquitto broker running on the same computer, you can avoid the `–h <Broker-IP>`
    option. The subscriber utility uses the `–t` option to specify the name of the
    topic that you are planning to subscribe. As you can see, we are subscribing to
    the `test` topic:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Similar to the subscriber client, the publisher client (`mosquitto_pub`) can
    be used to publish a message to the broker for a specific topic. As described
    in the following command, you are required to use the `–m` option followed by
    a message to successfully publish it. In this command, we are publishing a `Hello`
    message for the `test` topic:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Other important Mosquitto utilities include `mosquitto_password` and `mosquitto.conf`,
    which can be used to manage the Mosquitto password files and the setup broker
    configuration, respectively.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with MQTT on Arduino and Python
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you have the Mosquitto broker installed on your computer, it means
    that you have a working broker that implements the MQTT protocol. Our next goal
    is to develop the MQTT clients in Arduino and also in Python so that they will
    work as publishers and subscribers. After implementing the MQTT clients, we will
    have a fully-functional MQTT system, where these clients communicate through the
    Mosquitto broker. Let's begin with deploying MQTT on the Arduino platform.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: MQTT on Arduino using the PubSubClient library
  id: totrans-318
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As MQTT is a network-based messaging protocol, you will always need an Ethernet
    Shield to communicate with your network. For the following exercise, we will continue
    using the same hardware that we have been using throughout this chapter.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: Installing the PubSubClient library
  id: totrans-320
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To use Arduino for pub/sub and enable simple MQTT messaging, you need the Arduino
    client library for MQTT, also known as the `PubSubClient` library. The `PubSubClient`
    library helps you develop Arduino as an MQTT client, which can then communicate
    with the MQTT server (Mosquitto broker in our case) running on your computer.
    As the library provides methods to create only an MQTT client and not a broker,
    the footprint of the Arduino code is quite small compared to other messaging paradigms.
    The `PubSubClient` library extensively utilizes the default Arduino Ethernet library
    and implements the MQTT client as a subclass of the Ethernet client.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: To get started with the `PubSubClient` library, you'll first need to import
    the library to your Arduino IDE. Download the latest version of the `PubSubClient`
    Arduino library from [https://github.com/knolleary/pubsubclient/](https://github.com/knolleary/pubsubclient/).
    Once you have the file downloaded, import it to your Arduino IDE.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: We will be using one of the examples installed with the `PubSubClient` library
    to get started. The goal of the exercise is to utilize a basic example to create
    an Arduino MQTT client, while performing minor modifications to accommodate the
    local network parameters. We will then use the Mosquitto commands you learned
    in the previous section to test the Arduino MQTT client. Meanwhile, ensure that
    your Mosquitto broker is running in the background.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: Developing the Arduino MQTT client
  id: totrans-324
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s start with opening the `mqtt_basic` example by navigating to **File**
    | **Examples** | **PubSubClient** in our Arduino IDE menu. In the opened program,
    change the MAC and IP address values for Arduino by updating the `mac[]` and `ip[]`
    variables, respectively. In the previous section, you successfully installed and
    tested the Mosquitto broker. Use the IP address of the computer running Mosquitto
    to update the `server[]` variable:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'As you can see in the code, we are initializing the client using the IP address
    of the server, Mosquitto port number, and Ethernet client. Before using any other
    method for the `PubSubClient` library, you will always have to initialize the
    MQTT client using a similar method:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Further on in the code, we are using the `publish()` and `subscribe()` methods
    on the `client` class to publish a message for the `outTopic` topic and subscribe
    to the `inTopic` topic. You can specify the name of the client using the `client.connect()`
    method. As you can see in the following code snippet, we are declaring `arduinoClient`
    as the name for this client:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'As we are using this code in the `setup()` function, the client will only publish
    the `hello world` message once—during the initialization of the code—while the
    `subscribe` method will keep looking for new messages for `inTopic` due to the
    use of the `client.loop()` method in the Arduino `loop()` function:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Now, while running Mosquitto in the background, open another terminal window.
    In this terminal window, run the following command. This command will use a computer-based
    Mosquitto client to subscribe to the `outTopic` topic:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Compile your Arduino sketch and upload it. As soon as the upload process is
    complete, you will be able to see the `hello world` string printed. Basically,
    as soon as the Arduino code starts running, the Arduino MQTT client will publish
    the `hello world` string to the Mosquitto broker for the `outTopic` topic. On
    the other side, that is, on the side of the Mosquitto client, you've started using
    the `mosquitto_sub` utility and will receive this message, as it is subscribed
    to `outTopic`.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: Although you ran the modified Arduino example, `mqtt_basic`, you can also find
    the code for this exercise from this chapter's code folder. In this exercise,
    the Arduino client is also subscribed to `inTopic` to receive any message that
    originates for this topic. Unfortunately, the program doesn't display or deal
    with messages it obtains as a subscriber. To test the subscriber functionalities
    of the Arduino MQTT client, let's open the `mqtt_advance` Arduino sketch from
    this chapter's code folder.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see in the following code snippet, we have added code to display
    the received message in the `callback()` method. The `callback()` method will
    be called when the client receives any message from the subscribed topics. Therefore,
    you can implement all types of functionality on the received message from the
    `callback()` method:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'In this `mqtt_advance` Arduino sketch, we have also moved the publishing statement
    of `outTopic` from `setup()` to the `loop()` function. This action will help us
    to periodically publish the value for `outTopic`. In future, we will expand this
    method to use sensor information as messages so that the other devices can obtain
    those sensor values by subscribing to these sensor topics:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'After updating the `mqtt_advance` sketch with the appropriate network addresses,
    compile and upload the sketch to your Arduino hardware. To test the Arduino client,
    use the same `mosquitto_sub` command to subscribe to `outTopic`. This time, you
    will periodically get updates for `outTopic` on the terminal. To check out the
    subscriber functionality of your Arduino client, open your **Serial Monitor**
    window in your Arduino IDE. Once the **Serial Monitor** window begins running,
    execute the following command in the terminal:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: You can see in the **Serial Monitor** window that the `Test` text is printed
    with the topic name as `inTopic`. Henceforth, your Arduino will serve as both
    an MQTT publisher and an MQTT subscriber. Now let's develop a Python program to
    implement the MQTT clients.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: MQTT on Python using paho-mqtt
  id: totrans-344
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous exercise, we tested the Arduino MQTT client using command-line
    utilities. Unless the published and subscribed messages are captured in Python,
    we cannot utilize them to develop all the other applications we've built so far.
    To transfer messages between the Mosquitto broker and the Python interpreter,
    we use a Python library called `paho-mqtt`. This library used to be called `mosquitto-python`
    before it was donated to the Paho project. Identical to the Arduino MQTT client
    library, the `paho-mqtt` library provides similar methods to develop the MQTT
    pub/sub client using Python.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: Installing paho-mqtt
  id: totrans-346
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Like all other Python libraries we used, `paho-mqtt` can also be installed
    using Setuptools. To install the library, run this command in the terminal:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'For the Windows operating system, use `easy_install.exe` to install the library.
    Once it is installed, you can check the successful installation of the library
    using the following command in the Python interactive terminal:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Using the paho-mqtt Python library
  id: totrans-351
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `paho-mqtt` Python library provides very simple methods to connect to your
    Mosquitto broker. Let''s open the `mqttPython.py` file from this chapter''s code
    folder. As you can see, we have initialized the code by importing the `paho.mqtt.client`
    library method:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Just like the Arduino MQTT library, the `paho-mqtt` library also provides methods
    to connect to the Mosquitto broker. As you can see, we have named our client `mosquittoPython`
    by simply using the `Client()` method. The library also provides methods for activities,
    for example, when the client receives a message, `on_message`, and publishes a
    message, `on_publish`. Once you have initialized these methods, you can connect
    your client to the Mosquitto server by specifying the server IP address and the
    port number.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: 'To subscribe to or publish for a topic, you simply need to implement the `subscribe()`
    and `publish()` methods on the client, respectively, as displayed in the following
    code snippet. In this exercise, we are using the `loop_forever()` method for the
    client to periodically check the broker for any new messages. As you can see in
    the code, we are executing the `publishTest()` function before the control enters
    the loop:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: It is very important to run all the required functions or pieces of code before
    you enter the loop, as the program will enter the loop with the Mosquitto server
    once `loop_forever()` is executed. During this period, the client will only execute
    the `on_publish` and `on_message` methods for any update on the subscribed or
    published topics.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: To overcome this situation, we are implementing the multithreading paradigm
    of the Python programming language. Although we are not going to dive deep into
    multithreading, the following example will teach you enough to implement basic
    programming logic. To understand more about the Python threading library and supported
    methods, visit [https://docs.python.org/2/library/threading.html](https://docs.python.org/2/library/threading.html).
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: 'To better understand our implementation of the threading method, check out
    the following code snippet. As you can see in the code, we are implementing recursion
    for the `publishTest()` function every 5 seconds, using the `Timer()` threading
    method. Using this method, the program will start a new thread that is separate
    from the main program thread that contains the loop for Mosquitto. Every 5 seconds,
    the `publishTest()` function will be executed, recursively running the `publish()`
    method, and ultimately publishing a message for `inTopic`:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Now, in the main thread, when the client gets a new message from the subscribed
    topics, the thread invokes the `onMessage()` function. In the current implementation
    of this function, we are just printing the topic and message for demonstration
    purposes. In real applications, this function can be used to implement any kind
    of operation on the received message, for example, writing a message to a database,
    running an Arduino command, selecting an input, calling other functions, and so
    on. In short, this function is the entry point of any input you receive through
    the Mosquitto broker from your subscribed topics:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Similarly, every time you publish a message from the second thread, the `onPublish()`
    function is executed by the program. Just like the previous function, you can
    implement various operations within this function, while the function behaves
    as the exit point of any message published using this Python MQTT client. In the
    current implementation of `onPublish()`, we are not performing any operations:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: In the opened Python file, `mqttPython.py`, you will only need to change the
    IP address of the server running the Mosquitto broker. If you are running the
    Mosquitto broker on the same computer, you can use `127.0.0.1` as the IP address
    of the localhost. Before you execute this Python file, ensure that your Arduino
    is running with the MQTT client we created in the previous exercise. Once you
    run this code, you can start seeing the messages being sent from your Arduino
    in the Python terminal, as displayed in the following screenshot. Whenever a new
    message is received, the Python program prints the **outTopic** topic name followed
    by the **From Arduino** message. This confirms that the Python client is receiving
    messages for `outTopic`, to which it is subscribed. If you look back at the Arduino
    code, you will notice that it is the same message that we were publishing from
    the Arduino client.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the paho-mqtt Python library](img/5938OS_08_21.jpg)'
  id: totrans-366
  prefs: []
  type: TYPE_IMG
- en: Now, to confirm the publishing operation of the Python MQTT client, let's open
    the **Serial Monitor** window from your Arduino IDE. As you can see in the **Serial
    Monitor** window, text that contains the **inTopic** topic name and the **From
    Python** message is being printed every 5 seconds. This validates the Python publisher,
    as we are publishing the same message for the same topic every 5 seconds through
    the `publishTest()` function.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the paho-mqtt Python library](img/5938OS_08_22.jpg)'
  id: totrans-368
  prefs: []
  type: TYPE_IMG
- en: Exercise 4 – MQTT Gateway for Arduino
  id: totrans-369
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In exercise 3, we used the REST architecture to transfer motion and humidity
    sensor data between our Arduino and the web browser. In this exercise, we will
    develop an MQTT Gateway using the Mosquitto broker and the MQTT clients to transfer
    sensor information from our Arduino to the web browser. The goal of the exercise
    is to replicate the same components that we implemented in the REST exercise,
    but with the MQTT protocol.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the architectural sketch of the system, we have Arduino with
    the Ethernet Shield connected to our home network, while the computer is running
    the Mosquitto broker and the Python applications on the same network. We are using
    the same sensors (that is, a motion sensor and a humidity sensor) and the same
    hardware design that we used in the previous exercises in this chapter.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: '![Exercise 4 – MQTT Gateway for Arduino](img/5938OS_08_23.jpg)'
  id: totrans-372
  prefs: []
  type: TYPE_IMG
- en: In the software architecture, we have the Arduino code that interfaces with
    the humidity and motion sensors using analog pin 0 and digital pin 3, respectively.
    Using the `PubSubClient` library, the Arduino publishes sensor information to
    the Mosquitto broker. On the MQTT Gateway, we have two different Python programs
    running on the computer. The first program uses the `paho-mqtt` library to subscribe
    and retrieve sensor information from the Mosquitto broker and then `post` it to
    the web application. The second Python program, which is based on `web.py`, implements
    the web applications while obtaining sensor values from the first Python program.
    This program provides a user interface front for the MQTT Gateway.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: 'Although both of the preceding Python programs can be part of a single application,
    we are delegating the tasks of communicating with Mosquitto and serving information
    using the web application to separate applications for the following reasons:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: We want to demonstrate the functions of both libraries, `paho-mqtt` and `web.py`,
    in separate applications
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you want to run routines based on `paho-mqtt` and `web.py` in the same application,
    you will have to implement multithreading, as both of these routines need to be
    run independently
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We also want to demonstrate the transfer of information between the two Python
    programs using Python-based REST methods with the help of the `httplib` library![Exercise
    4 – MQTT Gateway for Arduino](img/5938OS_08_24.jpg)
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this exercise, we are labeling humidity and motion sensor information with
    the topic labels `Arduino/humidity` and `Arduino/motion`, respectively. The Arduino-based
    MQTT publisher and the Python-based MQTT subscriber will be utilizing these topic
    names if they want to transfer information through the Mosquitto broker. Before
    we begin with implementing the MQTT client on our Arduino, let's start the Mosquitto
    broker on our computer.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: Developing Arduino as the MQTT client
  id: totrans-379
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The goal of the Arduino MQTT client is to periodically publish the humidity
    and motion data to the Mosquitto broker running on your computer. Open the `Step1_Arduino.ino`
    sketch from the `Exercise 4 - MQTT gateway` folder in your code repository. Like
    all the other exercises, you first need to change the MAC address and the server
    address value, and assign an IP address for your Arduino client. Once you are
    done with these modifications, you can see the `setup()` function that we are
    publishing as a one-time connection message to the Mosquitto broker to check the
    connection. You can implement a similar function on a periodic basis if you have
    a problem with keeping your Mosquitto connection alive:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: In the `loop()` method, we are executing the `publishData()` function every
    5 seconds. It contains the code to publish sensor information. The `client.loop()`
    method also helps us keep the Mosquitto connection alive and avoids the connection
    timeout from the Mosquitto broker.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'As you can see in the following code snippet, the `publishData()` function
    obtains the sensor values and publishes them using the appropriate topic labels.
    You might have noticed that we are using the `dtostrf()` function in this function
    to change the data format before publishing. The `dtostrf()` function is a function
    provided by the default Arduino library that converts a double value into an ASCII
    string representation. We are also adding a delay of another 5 seconds between
    the successive publishing of sensor data to avoid any data buffering issues:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Complete any other modification you want to implement, and then compile your
    code. If your code is compiled successfully, you can upload it to your Arduino
    board. If your Mosquitto is running, you will be able see that a new client is
    connected as Arduino, which is the client name you specified in the preceding
    Arduino code.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: Developing the MQTT Gateway using Mosquitto
  id: totrans-387
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can have the Mosquitto broker running on the same computer as the Mosquitto
    Gateway, or on any other node in your local network. For this exercise, let''s
    run it on the same computer. Open the program file named `mosquittoGateway.py`
    for this stage from the `Step2_Gateway_mosquitto` folder, which is inside the
    `Exercise 4 - MQTT gateway` folder. The first stage of the Gateway application
    includes the `paho-mqtt` based Python program, which subscribes to the Mosquitto
    broker for the `Arduino/humidity` and `Arduino/motion` topics:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: When this MQTT subscriber program receives a message from the broker, it calls
    the `onMessage()` function, as we've already described in the previous coding
    exercise. This method then identifies the appropriate sensor type and sends the
    data to the `web.py` program using the `POST` method. We are using the default
    Python library, `httplib`, to implement the `POST` method in this program. While
    using the `httplib` library, you have to use the `HTTPConnection()` method to
    connect to the web application running on port number `8080`.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-391
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although this program requires that your web application (second stage) must
    run in parallel, we are going to implement this web application in the upcoming
    section. Make sure that you first run the web application from the next section
    before executing this program; otherwise you will end up with errors.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation of this library requires that you first import the library
    into your program. Being a built-in library, `httplib` does not require an additional
    setup process:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Once the connection is established with the web application, you have to prepare
    the data that needs to be sent in the `POST` method. The `httplib` method uses
    the `request()` method on the opened connection to post the data. You can also
    use the same method in other applications to implement the `GET` function. Once
    you are done with sending the data, you can close the connection using the `close()`
    method. In the current implementation of the `httplib` library, we are creating
    and closing the connection on each message. You can also declare the connection
    outside the `onMessage()` function and close it when you terminate the program:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Once you have performed the appropriate modifications, such as changing the
    IP address of the Mosquitto broker and the `web.py` application, go to the next
    exercise before running the code.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: Extending the MQTT Gateway using web.py
  id: totrans-398
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The MQTT Gateway code provides the user interface with the sensor information
    using the `web.py` based web application. The code is quite similar to what you
    implemented in exercise 3\. The program file is named `GatewayWebApplication.py`
    and located in your `Exercise 4 - MQTT gateway` code folder. In this application,
    we have removed the sensor selection process by simply implementing a button,
    displayed as **Refresh**. This application waits for the `POST` message from the
    previous program, which will be received on the `http://<ip-address>:8080/data`
    URL, ultimately triggering the `data` class. The `POST` method in this class will
    split the received string to identify and update the value of the `humidity` and
    `motion` global sensor variables:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'The default URL, `http://<ip-address>:8080/`, displays the `base` template
    with the **Refresh** button, populated using the `Form()` method. As displayed
    in the following code snippet, the default `index` class renders the template
    with the updated (current) `humidity` and `motion` values when it receives the
    `GET` or `POST` request:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Run the program from the command line. Make sure that you are running both programs
    from separate terminal windows.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: Testing your Mosquitto Gateway
  id: totrans-404
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You have to follow these steps in the specified order to successfully execute
    and test all the components of this exercise:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: Run the Mosquitto broker.
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the Arduino client. If it is running already, restart the program by powering
    off the Arduino client and powering it on again.
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Execute the web application in your terminal or from the Command Prompt.
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the `paho-mqtt` Gateway program.
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you follow this sequence, all of your programs will start without any errors.
    If you get any errors while executing, make sure that you follow all the instructions
    correctly, while also confirming the IP addresses in your programs. To check out
    your Arduino MQTT client, open the **Serial Monitor** window in your Arduino IDE.
    You will be able to see the periodic publication of the sensor information, as
    displayed in this screenshot:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing your Mosquitto Gateway](img/5938OS_08_25.jpg)'
  id: totrans-411
  prefs: []
  type: TYPE_IMG
- en: Now open a web browser on your computer and go to the URL of your web application.
    You should be able to see a window that looks like what is shown in the following
    screenshot. You can click on the **Refresh** button to check out the updated sensor
    values.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing your Mosquitto Gateway](img/5938OS_08_26.jpg)'
  id: totrans-413
  prefs: []
  type: TYPE_IMG
- en: Note
  id: totrans-414
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have set a delay of 5 seconds between successive sensor updates. Henceforth,
    you won't be able to see the updated values if you rapidly press the **Refresh**
    button.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: 'On the Gateway program terminal, you will be able to see the label of the topic
    every time the program receives a new message from Mosquitto. If the delay between
    successive sensor updates is not sufficient and `httplib` doesn''t have enough
    time to get the response back from the `web.py` application, the program will
    generate an error message with the `httplib` function. Although we require an
    additional delay for `httplib` to successively send the data and receive the response,
    we will be able to avoid this delay when we implement the core Python code with
    threading, avoiding the entire notion of `POST` in between the programs:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing your Mosquitto Gateway](img/5938OS_08_27.jpg)'
  id: totrans-417
  prefs: []
  type: TYPE_IMG
- en: With this exercise, you have implemented two different types of messaging architecture
    to transfer data between your Arduino and your computer or web applications using
    your home network. Although we recommend the use of hardware-centric and lightweight
    MQTT messaging paradigms over REST architecture, you can use either of these communication
    methods according to the application's requirements.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-419
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Connectivity to computer networks can really open up limitless possibilities
    for future application development using Arduino. We started the chapter by explaining
    important computer network fundamentals, while also covering hardware extensions
    that enable computer networking for Arduino. Regarding the various methods of
    enabling networking, we began the chapter by establishing a web server for Arduino.
    We concluded that the web server on Arduino is not the best way for network communication
    due to the limited number of connections offered by the web server. Then we demonstrated
    the use of Arduino as a web client to enable HTTP-based `GET` and `POST` requests.
    Although this method is useful for request-based communication and requires fewer
    resources compared to a web server, it is still not the best way for sensor communication
    due to the additional data overhead. In the later part of the chapter, we described
    a lightweight messaging protocol, MQTT, designed specifically for sensor communication.
    We demonstrated its superiority to HTTP-based protocols using a few exercises.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: With the help of each method of Arduino Ethernet communication, you learned
    about compatible Python libraries used to support these communication methods.
    We used the `web.py` library to develop a web server using Python, and demonstrated
    the use of the library with multiple examples. To support the MQTT protocol, we
    explored an MQTT broker, Mosquitto, and employed the Python library, `paho_mqtt`,
    to serve the MQTT requests.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: Overall, we covered every major aspect of Arduino and Python communication methods
    throughout this chapter, and demonstrated them with simple exercises. In the upcoming
    chapters, we will build upon the basics you learned in this chapter, in order
    to develop advanced Arduino-Python projects that will enable remote access to
    our Arduino hardware through the Internet.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
