- en: Fun with Canvas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Canvas is undoubtedly one of the most versatile widgets of Tkinter. Given that
    it provides direct control over the drawing of each individual pixel, combine
    it with some maths and it can be used to create all sorts of neat visualizations.
    While the possibilities are endless, we will explore how to implement some of
    the important mathematical ideas in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The key objectives for this chapter are:'
  prefs: []
  type: TYPE_NORMAL
- en: Learning to animate with the Tkinter canvas
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the usage of polar and Cartesian coordinates on the canvas
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing ordinary differential equations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modeling simulations given a list of formulas
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modeling 3D graphics and studying some common transformation matrices used in
    3D animation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that many of the code samples in this chapter requires heavy computations.
    However, code optimization for speed is not our first preference. The primary
    goal here is comprehension of the underlying concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Building a screen saver
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will start by building a screen saver. The program will consist of several random-colored
    and random-sized balls bouncing all over the screen at random velocity, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d4b6f8f8-1f84-457e-9a31-2139efebfe4a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s create a class to generate balls with random attributes. Accordingly,
    we define a new class named `RandomBall`. Refer the code file `8.01_screensaver`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the description for the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: Two key methods here are `create_ball` and `move_ball`. All other methods are
    helpers to these two methods. The `__init__` method takes a `canvas` as a parameter
    and then calls the `create_ball` method to draw the ball on the given canvas.
    To move the ball around, we will explicitly need to call the `move_ball` method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `create_ball` method uses the `canvas.create_oval()` method and `move_ball`
    uses the `canvas.move(item, dx, dy)` method, where `dx` and `dy` are `x` and `y`
    offsets for the canvas item.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also, note how we create a random color for the ball. Because the hexadecimal
    color coding system uses up to four hexadecimal digits for each of red, green,
    and blue, there are up to `0xffff` possibilities for each color. We, therefore,
    create a lambda function that generates a random number from `0-0xffff`, and use
    this function to generate three random numbers. We convert this decimal number
    to its two-digit equivalent hexadecimal notation using the format specifier `#{:04x}{:04x}{:04x} `to
    get a random color code for the ball.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That is all there is to the `RandomBall` class. We can use this class to create
    as many ball objects as we want to display in our screensaver.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s create the `ScreenSaver` class that will show the actual screensaver:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The description of the code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The `__init__` method of the ScreenSaver class takes the number of balls (`number_of_balls`)
    as its argument
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We use `root.attributes ( -fullscreen, True )` to remove the enclosing frame
    from the parent window and make it a full-screen window.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `quit_on_interaction` method binds the root to call our `quit_screensaver`
    method in case of any interactions from the user's end.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We then create a canvas to cover the entire screen with `Canvas(self.root)` with
    `pack ( expand=1, fill=BOTH )` options to fill the entire screen.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We create several random ball objects using the `RandomBall` class, passing
    along the Canvas widget instance as its arguments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We finally make a call to the `animate_balls` method, which uses the standard
    `widget.after()` method to keep running the animation in a loop at a regular interval
    of 30 milliseconds.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To run the screen saver, we instantiate an object from our `ScreenSaver` class,
    passing the number of balls as its argument as follows: `ScreenSaver(number_of_balls=18)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our screensaver is now ready! In fact, if you are working on the Windows platform, and
    when you learn to create an executable program from Python programs (discussed
    in [Chapter 10](cabe3587-e359-4987-9dde-52d04270aba3.xhtml), *Miscellaneous Tips*),
    you can create an executable file with a `.exe` extension for this screensaver.
    You can then change its extension from `.exe` to `.scr`, right-click, and select
    Install to add it to your list of screensavers.
  prefs: []
  type: TYPE_NORMAL
- en: Graphing with Tkinter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tkinter is not a graphing tool. However, should you need to draw graphs with Tkinter,
    you can use the Canvas widget to draw graphs.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this iteration, we will draw the following graphs:'
  prefs: []
  type: TYPE_NORMAL
- en: Pie chart (`8.02_pie_chart.py`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bar graph (`8.03_bar_graph.py`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scatter plot (`8.04_scatter_plot.py`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The three graphs show up as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/07e15b42-6540-4937-87a7-dc635ed13f19.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's look at the pie chart first. You can easily create a pie chart in Tkinter
    using the Canvas widget's `create_arc` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `create_arc` method has the following signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Point (`x1`, `y1`) is the top-left corner and point (`x2`, `y2`) is the bottom-right
    corner of the rectangle into which the arc fits. If the bounding rectangle is
    a square, it makes a circle. The method also takes two arguments, named `start`
    and `extent`, which we will use to create the pie chart.
  prefs: []
  type: TYPE_NORMAL
- en: The `start` option specifies the start angle for the arc, measured in degrees
    from the `+x` direction. When omitted, you get the complete ellipse. The `extent`
    option specifies the width of the arc in degrees.
  prefs: []
  type: TYPE_NORMAL
- en: The arc begins at the angle given by the `start` option and draws counterclockwise up
    to the degrees specified by the `extent` option.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create the pie chart, let''s define a method that, given a number *n*, divides
    the circle into, say, 1,000 equal parts and then, given a number less than 1,000,
    returns the equivalent angle in the arc. Since there are 360 degrees in a circle,
    the method is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we plot the various sections of the pie chart using code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: You can check out an example of a pie chart in `8.02_pie_chart.py`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, the bar graph. This is very simple. We use `create_rectangle` to draw a
    bar graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: One important thing to note here. Since the Canvas widget represents the `y` coordinate
    starting from the top-left corner, we need to subtract the `y` position from the
    canvas height to get the `y` coordinate for the graphs.
  prefs: []
  type: TYPE_NORMAL
- en: You can check out the complete code of the bar graph in `8.03_bar_graph.py`.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, we use the `create_oval` method to draw the scatter plot. Check out
    the code for the scatter plot in `8.04_scatter_plot.py`*.*
  prefs: []
  type: TYPE_NORMAL
- en: Next, let us see how to embed `matplotlib` graphs in Tkinter.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Tkinter canvas to draw graphs may work fine for trivial cases. However, Tkinter
    is not the best choice when it comes to drawing more sophisticated and interactive
    graphs.
  prefs: []
  type: TYPE_NORMAL
- en: Several Python modules have been developed for making graphs. However, `matplotlib`
    stands out as a clear winner for producing professional-quality interactive graphs
    with Python.
  prefs: []
  type: TYPE_NORMAL
- en: Although a detailed discussion on `matplotlib` is beyond the scope of this book,
    we will take a brief look at embedding matplotlib-generated graphs on a Tkinter
    canvas.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can install `matplotlib` and NumPy (a dependency for `matplotlib`) using
    the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The `matplotlib` targets many types of use cases and output formats. Some of
    the different use cases for `matplotlib` are to:'
  prefs: []
  type: TYPE_NORMAL
- en: Make interactive graphs from the Python shell
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Embed `matplotlib` in GUI modules such as Tkinter, wxPython, or PyGTK
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generate postscript images from simulations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serve on web pages from backend web servers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In order to target all these use cases, `matplotlib` uses the concept of a backend.
    In order to display a `matplotlib` graph on Tkinter, we use a backend called `TkAgg`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We import the backend into `matplotlib` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We then create the `matplotlib` graph as we would normally do in the `matplotlib`
    API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we embed the generated graph in the `tkinter` main loop using the
    `TkAgg` backend as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also embed the navigation toolbar of `matplotlib` using the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code (`8.05_matplotlib_embedding_graphs.py`) generates a graph as
    shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5cde33cc-6f63-4a28-9a94-fb9ce7b86b51.png)'
  prefs: []
  type: TYPE_IMG
- en: Polar plots with Tkinter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A point in space can be represented using the Cartesian coordinate using two
    numbers **x** and **y**.  The same point can also be represented in the polar
    coordinate by using the distance from the origin (**r**) and the angle from the
    *x* axis (theta), as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eefd2e49-44e1-4572-b7de-e4df3234d708.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To convert between polar and Cartesian coordinates, we use the following equalities:'
  prefs: []
  type: TYPE_NORMAL
- en: '*x= r cos(θ) and y = rsin(θ)*'
  prefs: []
  type: TYPE_NORMAL
- en: 'It is easier to plot equations expressed in terms of **r** and **θ** on a special
    kind of graph called the **polar plot**, which is divided into small concentric
    circles and radial lines emanating from the center. The radial lines are normally
    spaced at intervals of 15◦, while the radius of concentric circles depends on
    the scale on which the distance is to be measured from the center.  Here''s an
    example of a polar plot that we will draw:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/39b67f13-33c1-42c4-b2ad-46c1b2ddfd13.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The Tkinter canvas understands Cartesian coordinates. It is, however, easy
    to convert from polar to Cartesian coordinates. We  accordingly define a method
    named `polar_to_cartesian`; see `8.06_polar_plot.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s a brief description of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: The method converts an input of  (`r`, `theta`) value to (`x`, `y`) coordinates
    using the equalities *x= r cos(**θ) and y = rsin(θ)*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `scaling_factor` in the preceding equation decides how many pixels will
    equal to one unit in our polar plot and is set to a constant value. Changing it
    changes the size of the plot.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We add the `x_center` and `y_center` values to the final results. `x_center`
    is defined as half the `window_width` while `y_center` is half the window size.
    We add these as offsets because Canvas considers (*0*,*0*) as the top left of
    the canvas, while we want to consider the center of the canvas as (*0*,*0*).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We begin by creating a canvas in a Tkinter root window, and add radial lines
    and concentric circles to the canvas using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that our graph paper is ready, it''s time to plot the actual polar plot.
    The following code plots `3000` points of the polar equation `r = 2*math.sin(2*theta)` on
    the graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates the curve of the `form. r = a sin nθ`, where `n` is even. It is
    a  **2n-leaved rose**. If `n` is odd, it will form an **n-leaved rose**. There
    are many other good looking plots that you can plot by changing the `r` equation
    in the previous method. A few other equations that you can try are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: You can also play with the parameters of the individual equation to see the
    difference they make to the plot.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes the iteration.
  prefs: []
  type: TYPE_NORMAL
- en: Gravity simulation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's now simulate gravity. We will simulate the movement of four planets (Mercury,
    Venus, Earth, and Mars), and our very own Moon, using Newton's law of universal
    gravitation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our simulation assumes the Sun at the center, but it does not draw an oval
    for the Sun as that would make our planets invisible at that scale. Our simulation
    programs shows the four planets and moon revolving in circular orbits (`8.07_gravity_simulation.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2abbba07-1d86-4467-93b2-7e166b78f881.png)'
  prefs: []
  type: TYPE_IMG
- en: While the system could be extended to include other planets from the solar system
    - putting them all on the rectangular window of our screen would not be possible
    as the differences in planet sizes and distances are so disproportionate that
    making one planet, such as Jupiter, show up would make sizes and distances of
    planets such as Earth  smaller than a pixel, making them invisible. So our visualization
    sticks to just the four relatively nearby planets and our Moon. A very insightful
    interactive visualization of the entire solar system, titled *If the moon were
    only 1 pixel*, can be found here: [http://joshworth.com/dev/pixelspace/pixelspace_solarsystem.html](http://joshworth.com/dev/pixelspace/pixelspace_solarsystem.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Newton''s law of gravitation established the fact that gravitation is universal
    and that all objects attract each other with a force of gravity that is related
    to the mass of the two bodies and the distance between them, using this formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9677f10d-b22c-4e26-adf1-a08659666779.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Where:'
  prefs: []
  type: TYPE_NORMAL
- en: '**F** = Force of attraction between two objects'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**m1** = Mass of object 1'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**m2** = Mass of object 2'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**d** = Distance between the two objects'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**G** = 6.673 x 10^(-11) N m²/kg^²'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once the preceding equation yields us the gravitational force, we can then
    find the angular velocity of the object using this formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9fc254f4-bbb3-48e2-a944-e1dd6f513c77.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The preceding formula holds true for motion in circular paths, which is somewhat
    an approximation of the actual motion of planets in an elliptical orbit. With
    angular velocity in hand, we can get the angular position (θ):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d7681fc0-bc81-4a5e-b733-fe16083c3cbb.png)'
  prefs: []
  type: TYPE_IMG
- en: With the distance from the Sun (center) and θ in hand, we can convert it from
    a polar coordinate to a Cartesian coordinate as we have done in previous examples.
    Next, it's just a matter of drawing spheres on the Tkinter canvas at various locations.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the formulas in hand, we define a `Planet` class (`8.07_gravity_simulation.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: While most of the preceding code is a simple instantiation of variables, note
    that it takes in a canvas as an input on which it will draw the planet.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to scale down the planet distances and radii to fit into our window
    screen, so we have defined two methods in the class to scale distance and radius
    (`8.07_gravity_simulation.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: For scaling the distance, we take the maximum distance and scale it to fit in
    half of the canvas width. For scaling radius, we take the maximum and minimum
    radii from the first four planets and multiply them with the arbitrary number
    16, so that the planets' scales look acceptable on the screen. Most of the preceding
    code was obtained by experimenting with what looks best on the screen, and the
    numbers were chosen purely arbitrarily.
  prefs: []
  type: TYPE_NORMAL
- en: The constructor then calls a method, `draw_initial_planet`, which creates an
    oval of a scaled radius and at a scaled distance on the canvas. It also returns
    the unique ID of the created oval so that the oval's position can be updated using
    the id as a handle.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then define two helper methods using the formulas we discussed earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we calculate the angular position (`theta`), convert it from polar to Cartesian
    coordinates, and update the *x*, *y* position for the oval pertaining to the planet.
    We also leave a 1-pixel trail for the planet''s position using `create_rectangle`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The code to convert from polar to Cartesian coordinates is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Next, we define a `Moon` class, which is similar in all aspects to the `Planet`
    class, so it inherits from the `Planet` class. However, the most important difference
    is that instead of taking distance from the Sun and the mass of the Sun as a reference,
    it takes distance from Earth and the mass of Earth as a reference. As scaling
    on actual values would have made the Moon's size smaller than 1 pixel, we have
    also hardcoded the scaled distance and scaled radius values for Moon to make it
    visible on the screen. Since Moon needs to go round Earth, we also need to pass
    Earth as an extra argument to the `__init__` method of the `Moon` class (`8.07_gravity_simulation.py`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we create the four planets and the Moon, passing in their actual values
    taken from Wikipedia:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we create a Tkinter canvas and define an `update_bodies_positions` method
    that runs every 100 ms, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: That concludes the gravity simulation project. If you now go and run `8.07_gravity_simulation.py`,
    you can see the planets and our Moon responding to gravitational force.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing fractals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A fractal is a never-ending pattern that repeats itself at all scales. Fractals
    are found everywhere in nature. We find them in our blood vessels, branches of
    trees, and in the structure of our galaxies, and the beauty of them lies in the
    fact that they are made out of simple formulas.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will demonstrate the simplicity of these seemingly complex-looking phenomena
    by drawing a fractal named a Mandelbrot set. We assume a basic knowledge of set
    theory and complex numbers in this section.  Our code produces a Mandelbrot set
    that looks like the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bf88fd1a-298b-4302-b1b2-7cf48f33b8a4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The Mandelbrot set  is defined as a set of complex numbers, *c*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/aa4f32fe-a773-4ebd-92a8-52c2036389f3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'So that the complex number *c* obeys the following recurrence relation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dc255dd5-3718-4b28-a33e-0ab66f2d6417.png)'
  prefs: []
  type: TYPE_IMG
- en: Think of recurrence relations as functions where the last output is fed as input
    into the same function in the next iteration.
  prefs: []
  type: TYPE_NORMAL
- en: So the Mandelbrot set is a set that only includes those complex numbers for
    which the previous equation does not, after any number of iterations, blow up
    the value of *z*[n] to infinity.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a clearer understanding, if we take the number 1 as *c* and apply it to
    the preceding equation (note that 1 is also a complex number with no imaginary
    component—so real numbers are a subset of complex numbers and hence they too lie
    on the complex plane):'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Value of z after n iterations(z[n])** | **Value of z[n+1 =] z² [n] + c
    for c = 1** |'
  prefs: []
  type: TYPE_TB
- en: '| z[0] | 0² + 1 = 1 |'
  prefs: []
  type: TYPE_TB
- en: '| z[1] | 1² + 1 = 2 |'
  prefs: []
  type: TYPE_TB
- en: '| z[2] | 2² +1 = 5 |'
  prefs: []
  type: TYPE_TB
- en: '| z[3] | 5² +1 = 26 |'
  prefs: []
  type: TYPE_TB
- en: It is clear that the previous series will blow up to infinity as the number
    of iterations tends to infinity. Since this complex number 1 blows up the equation,
    it is not a part of the Mandelbrot set.
  prefs: []
  type: TYPE_NORMAL
- en: 'Contrast this with another number, c = -1  the values for which are plotted
    in the next table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Value of z after n  iterations(z[n])** | **Value of  z[n+1] = z² [n] +
    c for c = -1** |'
  prefs: []
  type: TYPE_TB
- en: '| z[0] | 0² + -1 = -1 |'
  prefs: []
  type: TYPE_TB
- en: '| z[1] | -1² + -1  = 0 |'
  prefs: []
  type: TYPE_TB
- en: '| z[2] | 0² + -1 = -1 |'
  prefs: []
  type: TYPE_TB
- en: '| z[3] | -1² + -1 = 0 |'
  prefs: []
  type: TYPE_TB
- en: Note that you may continue the preceding series up to infinity but the value
    will keep alternating between *-1* and *0*, thus never exploding. This makes the
    complex number *-1* eligible for inclusion in the Mandelbrot set.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let us try to model the preceding equation.
  prefs: []
  type: TYPE_NORMAL
- en: One immediate problem to overcome is that we cannot model infinity in the previous
    equation. Fortunately, it can be seen from the equation that if the absolute value
    of *z* ever exceeds *2*, the equation will eventually blow up.
  prefs: []
  type: TYPE_NORMAL
- en: 'So a definitive way to check whether the equation blows up is to check whether
    the magnitude of *Z > 2*. The magnitude of a complex number *a + ib* is defined
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d870b266-0079-44cd-9d8b-41b99dcae571.png)'
  prefs: []
  type: TYPE_IMG
- en: 'So in order to check whether a complex number *a+ib* blows up the preceding
    equation, we need to check the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2ad774df-1d79-44fb-a18f-9db0c23a0821.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Or:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d8b37d55-6d6d-4991-9c3a-4dc9db53b699.png)'
  prefs: []
  type: TYPE_IMG
- en: The next question to consider is how many times should we iterate *Zn* to see
    if its magnitude exceeds *2* or not?
  prefs: []
  type: TYPE_NORMAL
- en: 'The answer to this depends on the kind of image resolution you seek to obtain
    in the final image. In general, the higher the maximum number of iterations, the
    greater the image resolution, subject to the limitation of individual pixel size,
    beyond which you can never go in terms of details. In practice, an iteration of
    a few hundred times is sufficient. We use a maximum iteration of `200` as that
    is enough to determine whether or not the equation blows up for a small-scale
    image that we will draw. Accordingly, we define a variable in `8.08_Mandelbrot.py` as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Next, we define a method that takes in the real and imaginary components of
    a complex number, and tells whether the equation blows up for the complex number input.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the method should return `2` for an input of `1`, as the path
    to blow up is sensed right in the second iteration for the input value `1`. However,
    if we give it an input of `-1`, the equation never blows up so it runs for the
    maximum number of iterations and returns the `maximum_iteration_count`, which
    we have defined as `200` and is akin to saying that the said number belongs to
    the Mandelbrot set (`8.08_Mandelbrot.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Accordingly, we define the `mandelbrot_set_check` method as follows (`8.08_Mandelbrot.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The code simply implements the recurrence relation for the Mandelbrot set.
  prefs: []
  type: TYPE_NORMAL
- en: While it's sufficient to know whether a complex number lies in the Mandelbrot
    set, we also keep a track of the iteration count, also called the escape time,
    which is the number of iterations it took a complex number to blow up, if it does
    blow up.  If the iteration count returns as `maximum_number_of_iterations`, it
    means the complex number does not blow up the equation and the escape time is
    infinite, that is, the number is a part of the Mandelbrot set. We keep track of
    the iteration count as we will use this data to paint areas with different escape
    times in different colors.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a way to tell whether or not a complex number belongs to the
    Mandelbrot set, we need a set of complex numbers to run through this method. In
    order to do that, we first define a maximum and a minimum complex number, between
    which we will check for inclusion in the Mandelbrot set. Note that in the following
    example, we have set the range of complex numbers between *-1.5-1i and 0.7+1i. *
  prefs: []
  type: TYPE_NORMAL
- en: 'You can try different ranges of these complex numbers, as long as the area
    falls inside a circle of radius 2,  and it will print different regions of the
    Mandelbrot set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s next proceed by defining the `image_width` and `image_height` variables
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: To draw the Mandelbrot set in an image, we need to map each pixel coordinate
    of the image to our complex numbers. Having defined the maximum and minimum range
    for the real and imaginary parts of our complex numbers, it's simply a matter
    of interpolating the complex numbers to map them to the pixel coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following two methods do that for us (`8.08_Mandelbrot.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we are ready to draw the actual image. We create a Tkinter root window,
    draw a canvas atop it, and then run the following loops:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code takes each pixel in the image, maps its `x`, `y` coordinates
    to a real and imaginary number respectively, and then send this number out to
    the `mandelbrot_set_check` method, which in turn returns the number of iterations
    it took for the number to blow up. If the number did not blow up, it returns the
    value of `maximum_number_of_iterations. `With this number in hand, we call another
    method that gives an RGB color code, which is just based on some arbitrary numbers.
    It just adds the cosmetic value, and you can play with different arbitrarily designed
    color mapping schemes to generate Mandelbrot images of different colors. Finally,
    we use this color to fill the (*x*, *y*)^(th) pixel on the canvas.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes the iteration. Our code can now generate the Mandelbrot set.
    However, note that this code takes some time to generate the Mandelbrot set.
  prefs: []
  type: TYPE_NORMAL
- en: Voronoi diagrams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will now draw a Voronoi diagram. Voronoi diagrams are a simple yet very powerful
    tool used in modeling lots of physical systems. Wikipedia ([https://en.wikipedia.org/wiki/Voronoi_diagram#Applications](https://en.wikipedia.org/wiki/Voronoi_diagram#Applications))  lists
    more than 20 disciplines of science and technology where Voronoi diagrams are
    used to model and solve real-world problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many little variations to the rules for drawing Voronoi diagrams,
     but the most common type of Voronoi diagram is made by choosing a finite number
    of points on a 2D plane. We call these points the seeds or the attractors. The
    tiny blue dots shown in the following image are attractor points.  We then map
    or attach all the points on the plane to their nearest attractor point. All points
    closer to a particular attractor point is drawn in one color, which partitions
    the plane into what are called **Voronoi cells**, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d8f62e37-5420-43f4-bdf0-2f43884694ce.png)'
  prefs: []
  type: TYPE_IMG
- en: Voronoi diagrams can be drawn in spaces of arbitrary dimensions, but we stick
    to studying them in a two-dimensional plane.
  prefs: []
  type: TYPE_NORMAL
- en: There are many efficient but complicated algorithms for drawing Voronoi diagrams.
    However, we will use the simplest algorithm to understand. However, being simple
    comes at a cost. The algorithm requires more time to compute when compared to
    other faster but more complex algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will begin by creating a fixed number of random attractor points on a canvas
    of given width and height. Accordingly, we define three variables in the program
    (`8.09_vornoi_diagram.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we create a canvas on a Tkinter root window with the preceding width
    and height and pass the canvas to a method named `generate_vornoi_diagram`, which
    does all the processing and drawing for us. Its code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s a brief description of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: We begin by creating two lists. The first `for` loop is used to populate the
    `attractor_points` list with tuples (*x*, *y*) for each of the attractor points.
    We also create another list, `colors`, which holds the random color hexadecimal
    string for the cell of each attractor point.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second triple nested `for` loops goes through each pixel on the canvas and
    finds the index of the nearest attractor. Once that has been established, it colors
    the individual pixel using the color assigned to that attractor point.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last `for` loop then draws an overlapping blue colored square for each of
    the attractor points. This loop is deliberately run last to ensure that the attractor
    point draws over the colored cell region.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since the preceding code has to go through three nested loops for checking each
    *x*,*y* location on the plane against each attractor point, it has a computational
    complexity of O(n³) as per Big-O notation. This means that the algorithm is not
    at all scalable to drawing images of larger sizes and explains why this code takes
    some time to generate the Voronoi diagram, even for this modest-sized image. More
    efficient algorithms are available and if you do not want to reinvent the wheel,
    you can even use the `Voronoi` class from the `scipy.spatial` module to implement
    this much faster. That is left as an exercise for you to explore.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes the section. If you now run the `8.09_vornoi_diagram.py` program,
    it should generate a Voronoi diagram.
  prefs: []
  type: TYPE_NORMAL
- en: Spring pendulum simulation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A lot of real-world phenomena can be called **dynamical systems**.  The state
    of such systems varies with time. Modeling such systems requires the use of **differential
    equations**. We will take here an example of modeling a pendulum attached to a
    spring, as shown in the following image. The pendulum swings to and fro. Furthermore,
    since the bob is attached to a spring, the bob also oscillates up and down:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1f6149ef-e83f-4274-b07c-ebe23df86a7d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We study the evolution of two variables over time:'
  prefs: []
  type: TYPE_NORMAL
- en: Length l of the spring
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Angle (θ) between the spring and the center line, as shown in the preceding
    diagram.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Since there are two variables changing over time, the state of our system at
    any time can be represented by using four state variables:'
  prefs: []
  type: TYPE_NORMAL
- en: Spring length (l)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Change in spring length (dl/dt), which is  velocity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Angle (θ)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Change in angle (dθ/dt), which is the angular velocity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'They are modeled by the following four differential equations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bb296051-9f19-419a-8f0a-ee8f0e9749bc.png)'
  prefs:
  - PREF_UL
  type: TYPE_IMG
- en: '![](img/6cad5a03-616a-42d2-9116-a2b0da1c47a2.png)'
  prefs:
  - PREF_UL
  type: TYPE_IMG
- en: '![](img/5d321d29-5b86-4872-ad58-deafa87db22d.png)'
  prefs:
  - PREF_UL
  type: TYPE_IMG
- en: '![](img/a4b83c6d-bccd-4279-a615-f102a1dc2a8f.png)'
  prefs:
  - PREF_UL
  type: TYPE_IMG
- en: The first equation measures linear velocity, which is the rate of change of
    *L* over time. The second equation is a second derivative and gives us the acceleration.
    The third equation measures change in theta over time and hence represents the
    angular velocity. The last equation is the second derivative of theta over time
    and hence it represents the angular acceleration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us begin by defining the following constants:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Accordingly, let us begin by defining the initial value for all these four
    state variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we define the `differentials_functions`  method which returns an array
    of the four differential functions defined previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will use `scipy.integrate.odeint`  to solve the differential equations.
    This method can be used to solve a system of ordinary differential equations of
    the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/492ae2f7-b43c-4395-ac54-3ee8545e1644.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here''s the signature of `scipy.integrate.odeint`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Where:'
  prefs: []
  type: TYPE_NORMAL
- en: '`func`: Callable(y, t0, ...), which computes the derivative of y at t0'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`y0`: Array of initial condition (can be a vector)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`t`: Array of time points for which to solve for y'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The initial value point should be the first element of this sequence.
  prefs: []
  type: TYPE_NORMAL
- en: This method takes as input the derivative function (`func`), an array of initial
    state values (`yθ`), and an array of times (`t`). It returns an array of state
    values corresponding to those times.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we are differentiating against time, we need a variable to track time
    (`8.10_spring_pendulum.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The number `37` here is the step size for sampling time. Changing this value
    will change the speed of simulation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we finally solve the sets of differential equations using `scipy.integrate.odeint`
    as follows (`8.10_spring_pendulum.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Since we have set the number of simulation steps to 500 and there are four state
    variables, the `odeint` method returns a numpy array of the shape (*500*, *4*),
    where each row represents the value of the four state variables at a given point
    of time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now recall that our state vector is a list of four values, `[''l'', ''dl/dt'',
    ''θ'', ''dθ/dt'']`. So the 0^(th) column returns the value `''l''` and the 2^(nd)
    column represents the value `''θ''`.  This is the polar format representation.
    Our canvas understands the Cartesian coordinate system. So we obtain the Cartesian
    coordinates (*x*, *y*) for the values of each value of (*l*, *θ*) as follows (`8.10_spring_pendulum.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'With that data in hand, it''s now just a matter of plotting it on the canvas.
    So we create a Canvas widget in a `mainloop` and call an `update_graph `method that
    runs every 15 milliseconds, deleting everything on the canvas and redrawing the
    line and an oval (pendulum bob).  We also add an increment variable, `plot_step`,
    which is reset to zero every time the simulation ends. This keeps the pendulum
    swinging forever (`8.10_spring_pendulum.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'This will create a spring pendulum, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3eb3d837-7cf3-44c5-8fa4-17e10c581d98.png)'
  prefs: []
  type: TYPE_IMG
- en: That concludes the iteration. You can explore this simulation by changing the
    values of the constants (mass, spring constant, and gravity). Also, change the
    initial state vector elements, such as the angle and velocity, and the program
    should respond as it would in a real-world situation.
  prefs: []
  type: TYPE_NORMAL
- en: We saw how to obtain ODE, which is a derivative with respect to only one variable. An
    extension of this concept is **partial differential equations** (**PDEs**), which
    are derivatives with respect to several variables. More complex phenomena, such
    as electromagnetism, fluid mechanics, heat transfer, electromagnetic theory and
    various biological models, are all modeled by partial differential equations.
  prefs: []
  type: TYPE_NORMAL
- en: The FEniCS computing platform ([https://fenicsproject.org/](https://fenicsproject.org/))
    is a popular open-source software tool for solving PDEs with a Python binding.
  prefs: []
  type: TYPE_NORMAL
- en: Chaos game – building triangles out of randomness
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Chaos game refers to the emergence of fractal patterns with random numbers
    when the selection of random numbers are subject to some constraints. Let''s look
    at the rules of one of the simplest chaos games:'
  prefs: []
  type: TYPE_NORMAL
- en: We start by creating three points on a plane to form a triangle.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To begin the game, we draw a random point inside the triangle.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We then roll a dice. Given the outcome, we move halfway between the last point
    and any one of the vertices of the triangle. For example, if the outcome is 1
    or 2, we move halfway between the last point and vertex A. If the outcome is 3
    or 4, we move halfway from the current point towards vertex B, or if the outcome
    is 5 or 6, we draw the next point halfway between the current point and vertex
    C, as shown in the following image. This is repeated over and over again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/4ef6d36e-c739-4336-a64d-c14c1878d497.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here is the surprise part of it. While all the points except for the three
    vertexes were selected at random, the end result is not a haphazard set of points
    but rather a fractal—a set of repeating patterns of triangles called the Sierpinski
    triangle, shown in the following screenshot. This, according to some mathematicians,
    is a glimpse into the orderliness of the universe hidden inside what appears to
    be otherwise chaotic:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00afbbfe-41d0-4207-8f13-1f0cde1c4f8d.png)'
  prefs: []
  type: TYPE_IMG
- en: Note that repeating this same rule inside a set of four points does not create
    a fractal. However, placing some specific kinds of restrictions on the choice
    of vertices produces a variety of interesting fractal shapes. You can read more
    about different varieties of fractals generated out of chaos games at [https://en.wikipedia.org/wiki/Chaos_game](https://en.wikipedia.org/wiki/Chaos_game).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us now code this program.  We first define the three vertices of the triangle,
    as shown in the preceding screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Here, `WIDTH` and `HEIGHT` are the window dimensions.
  prefs: []
  type: TYPE_NORMAL
- en: Our next task is to choose a random point inside our triangle as the starting
    point. This can be done using what are called **barycentric coordinates**.
  prefs: []
  type: TYPE_NORMAL
- en: Let *V1*, *V2*, *V3* be the three vertices of a triangle. A point *P* inside
    the triangle can be expressed as *P = aV[1] + bV[2] + cV[3]*, where *a+b+c=1*
    and *a,b,c* are each *≥ 0*. If we know and *b*, we can calculate *c* as *1-a-b*.
  prefs: []
  type: TYPE_NORMAL
- en: So we generate two random numbers, `a` and `b`, each in the range [*0*,*1*]
    so that their sum ≤ 1\. If the sum of two random points exceeds 1, we replace
    a with 1-a and b with 1-b, so that their sum falls back below 1\.  Then,  aV[1]
    + bV[2] + cV[3] is uniformly distributed inside the triangle.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have the barycentric coordinates a, b, and c,  we can compute point
    P inside the triangle as  aV1 + bV2 + cV3\. Here is the idea expressed in code
    (`8.11_chaos_game.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'We next define a method to calculate the halfway distance between two points:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This is a simple linear interpolation between two points based on the Pythagorean
    theorem. Note that in Python, the `/` operator does floating point division while
    `//` does integer division (dropping the remainder).
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we put the laws of the game in a method called `get_next_point`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we create a Tkinter canvas and define a method, `update`, to draw
    the individual pixels every 1 millisecond as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Calling this `update` method creates the fractal pattern in our chaos game.
  prefs: []
  type: TYPE_NORMAL
- en: Phyllotaxy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Phyllotaxy is derived from the Greek words phýllon (meaning leaf) and táxis
    (meaning arrangement). Accordingly, phyllotaxy is the study of the spiral arrangements
    found in leaves and flowers.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will code the following floral pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7ddf3794-1d86-4007-895a-699e8f729751.png)'
  prefs: []
  type: TYPE_IMG
- en: The mathematical details for this program have been taken from *Chapter 4* of
    the book  *Algorithmic Botany of Plants*—a PDF of which can be obtained from here: [http://algorithmicbotany.org/papers/abop/abop-ch4.pdf.](http://algorithmicbotany.org/papers/abop/abop-ch4.pdf)
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the two formulas from the chapter that we will be using:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5a5db8a9-72ab-4c74-bc8e-4f56e981f834.png)   and   ![](img/a77cada8-49e1-452c-ba4d-5580ccd5e115.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/052e08bf-e3b2-4780-8928-33a38ee15dd1.png) represents the polar coordinate
    of each point on the canvas. As you shall see, our phyllotaxy will be made up
    of dots arranged in a spiral pattern. So the variable *n* in the preceding example
    represents the count or the index of the *n*^(th) dot starting at zero at the
    center of the spiral. The variable c is used as a scale factor that in turn decides
    how near or far the dots will appear in the final image. The angle `137.5` is
    related to the golden ratio and the Fibonacci angle and looks the most natural.
    You can read more about it in the linked PDF.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin with, we define all the values that we discussed so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we create a Tkinter canvas and add colors to the `colors` list. We also
    create the dots using `create_oval` and save the reference to all ovals in the
    `dots` list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The color defined in the preceding code is based on the value of `r` and is
    purely arbitrary. We could have used any other variable or rule for defining the
    color.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, we define the update function, which calculates the value of the `r`
    and `∅` values every 15 milliseconds and updates the coordinates of all the ovals
    on the canvas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: You should now see the phyllotaxy pattern. Try changing all the parameters to
    see how the image changes.
  prefs: []
  type: TYPE_NORMAL
- en: 3D graphics with Tkinter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tkinter's Canvas widget provides for drawing with exact coordinate specifications. Therefore,
    it can be used to create all sorts of 3D graphics. Furthermore, we have already
    seen the animation abilities of Tkinter. We can apply these abilities to also
    animate in 3D.
  prefs: []
  type: TYPE_NORMAL
- en: Let's create a simple application where we create a cube in the center. We add
    event listeners to rotate the cube on mouse events. We also make a small animation
    in which the cube keeps rotating by itself when no mouse intervention occurs.
  prefs: []
  type: TYPE_NORMAL
- en: 'In its final form, the application would look as follows (`8.13_3D_graphics.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dab367b8-d190-4fd3-bc90-e4d34f94ded1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Transposing or unzipping can be done in Python by using the special * operator,
    any point in a 3D space can be represented by *x*, *y*, and *z* coordinates. This
    is usually represented by a vector of the form:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/245c7267-8d78-4f8c-b3f8-e95f79a1b053.png)'
  prefs: []
  type: TYPE_IMG
- en: This is an example of a row vector as all three points are written in a single
    row.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is convenient for humans to read. However, as per convention and for some mathematical
    advantage that we will see later, positions are taken as a column vector. So it
    is written in a column as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dfda0a51-6d8d-4018-bee1-e7dd4a2ccda9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Since a shape is a collection of points, it is, therefore, a collection of
    column vectors. A collection of column vectors is a matrix, where each individual
    column of the matrix represents a single point in 3D space:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/39fe396f-ca68-4f28-8535-9c7100c7a2d1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s take the example of a cube. A cube has eight defining vertices. A representative cube
    could have the following eight points with its center located at [*0*,*0*,*0*]:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'However, here the vertices are represented as row vectors. To represent the
    vectors as column vectors, we need to transpose the preceding matrix. Since transposition will
    be a common operation, let''s start by building a class called `MatrixHelpers`
    and defining a method named `transpose_matrix`( `8.13_3D_graphics.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Transposing or unzipping can be done in Python by using the special `*` operator,
    which makes zip its own inverse.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another issue with the preceding coordinates is that it centers at (*0*,*0*,*0*).
    This means that if we try to plot the preceding points on a canvas, it will show
    up only partly, centered at the top-left corner of the canvas, something like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3691b678-dcc7-4559-8ddf-71bf07a5223d.png)'
  prefs: []
  type: TYPE_IMG
- en: We need to move all the points to the center of the screen. We can achieve this
    by adding *x* and *y* offset values to the original matrix.
  prefs: []
  type: TYPE_NORMAL
- en: 'We accordingly define a new method named `translate_matrix` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s draw the actual cube. We define a new class named `Cube` that inherits from
    the `MatrixHelper` class because we want to use the `transpose_matrix` and `translate_vector`
    methods defined in the `MatrixHelper` class (see `code 8.13_3D_graphics.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The `__init__` method simply calls four new methods. The `init_data` method
    sets the coordinate values for all the eight vertices of the cube (`8.13_3D_graphics.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The `create_canvas` method creates a `400` x `400` sized canvas on top of the
    root window and assigns a background and fill color to the canvas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, we define the `draw_cube `method, which uses `canvas.create_line` to
    draw lines between selected points. We do not want lines between all the points,
    but rather lines between some selected vertices to create a cube. We accordingly
    define the method as follows (`8.13_3D_graphics.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: This code draws a cube on the canvas. However, since the cube draws upfront,
    all we see is a square from the front. In order to see the cube, we need to rotate
    the cube to a different angle. That brings us to the topic of 3D transformations.
  prefs: []
  type: TYPE_NORMAL
- en: A wide variety of 3D transformations, such as scaling, rotation, shearing, reflection,
    and orthogonal projections, can be accomplished by multiplying the shape matrix
    with another matrix known as a transformation matrix.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the transformation matrix for scaling a shape is:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/063945c9-1566-4227-9861-69c36eb9efaa.png)'
  prefs: []
  type: TYPE_IMG
- en: Where *S*[x], *S*[y], and *S*[z] are scaling factors in *x*, *y*, and *z* directions.
    Multiply any shape matrix with this matrix and you get the matrices for the scaled
    shape.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s, therefore, add a new method named `matrix_multiply` to our `MatrixHelper` class
    (`8.13_3D_graphics.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s add the ability to rotate the cube. We will be using the rotation
    transformation matrix. Furthermore, since rotation can happen along any of the
    *x*, *y*, or *z* axes, there are actually three different transformation matrices.
    The three rotation matrices are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4dcd5250-3d43-4975-9566-ea5afea1faa1.png)'
  prefs: []
  type: TYPE_IMG
- en: Multiply the shape coordinates by the first matrix for a given value of *a*
    and you get the shape rotated by an angle *a* about the *x *axis in a counterclockwise direction.
    Similarly, the other two matrices rotate along the *y *axis and *z *axis respectively.
  prefs: []
  type: TYPE_NORMAL
- en: To rotate in a clockwise direction, we simply need to flip the sign of all sin
    values in the preceding matrix.
  prefs: []
  type: TYPE_NORMAL
- en: Note, however, that the order of rotation matters. So if you first rotate along
    the *x *axis and then rotate along the *y *axis, it is not the same as first rotating
    along *y* and then along the *x *axis.
  prefs: []
  type: TYPE_NORMAL
- en: More details on rotation matrices can be found at [https://en.wikipedia.org/wiki/Rotation_matrix](https://en.wikipedia.org/wiki/Rotation_matrix).
  prefs: []
  type: TYPE_NORMAL
- en: 'So now that we know the three rotation matrices, let''s define the following
    three methods in our `MatrixHelper` class (`8.13_3D_graphics.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we define a method named `continually_rotate` and call this method from the
    `__init__` method of our `Cube` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: The method uses `root.after` to call itself back every 15 milliseconds. At each
    loop, the coordinates of the cube are rotated by `0.01` degrees along all three
    axes. This is followed by a call to draw the cube with a fresh set of coordinates.
    Now, if you run this code, the cube rotates continuously.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's bind the rotation of the cube to a mouse button click and mouse
    motion. This will let the user rotate the cube by clicking and dragging the mouse
    over the cube.
  prefs: []
  type: TYPE_NORMAL
- en: 'Accordingly, we define the following method and call it from the `__init__`
    method of the `Cube` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The methods linked from the preceding event binding are defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Note that the preceding method maps mouse displacements along the *y *axis to rotations
    along the *x *axis and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: Also, note that the last line of the code calls `on_mouse_clicked()` to update
    the value of `last_x` and `last_y`. If you skip that line, the rotation becomes
    exceedingly fast as you increase the displacement from the last clicked position.
  prefs: []
  type: TYPE_NORMAL
- en: 'The method also refers to another method, named epsilon, which translates the distance
    into an equivalent angle for rotation. The epsilon method is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The epsilon here is obtained by multiplying the displacement, d, with an arbitrary value
    of 0.01\. You can increase or decrease the sensitivity of rotation to mouse displacement
    by changing this value.
  prefs: []
  type: TYPE_NORMAL
- en: Now the cube becomes responsive to mouse click and drag over the canvas. This
    concludes the last project of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we have just scratched the surface of 3D graphics. A much more detailed discussion
    on 3D programming with Tkinter can be found at [https://sites.google.com/site/3dprogramminginpython/](https://sites.google.com/site/3dprogramminginpython/).
  prefs: []
  type: TYPE_NORMAL
- en: There have also been attempts to further abstract and build 3D programming frameworks
    for Tkinter. You can find an example of a 3D framework for Tkinter at [https://github.com/calroc/Tkinter3D](https://github.com/calroc/Tkinter3D).
  prefs: []
  type: TYPE_NORMAL
- en: That concludes the chapter, and also our experiments with the Canvas widget.
    In the next chapter, we will look at some of the most commonly recurring themes
    of writing GUI applications, such as using a queue data structure, database programming,
    network programming, interprocess communication, use of the `asyncio` module,
    and a few other important concepts in programming.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's summarize the concepts we discussed in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We built a screen saver and in the process saw how to implement animations on
    the Tkinter canvas. Next, we saw how to create Cartesian and polar plots on the
    canvas. We also saw how to embed `matplotlib` plots on a Tkinter window.
  prefs: []
  type: TYPE_NORMAL
- en: We then implemented a basic gravity simulation that showed how we could take
    a physical model and implement it using a Tkinter canvas. We got a glimpse into
    the implementation of Voronoi diagrams, which are being used to model and solve
    so many practical real-world problems.
  prefs: []
  type: TYPE_NORMAL
- en: We also build some nice visualizations such as the Mandelbrot set and Phyllotaxies.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we learned how to use a Tkinter canvas to draw and animate 3D graphics
    using transformation matrices.
  prefs: []
  type: TYPE_NORMAL
- en: QA section
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are a few questions to reflect upon:'
  prefs: []
  type: TYPE_NORMAL
- en: How do you convert between polar and Cartesian coordinates? When should we prefer
    one coordinate system over the other?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do you animate on a Tkinter canvas? What determines the speed of the animation?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How do we model real-world phenomena on a Tkinter canvas using differential
    equations?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are some real-world applications of fractals?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fractals are still under active research. Can you find out more about some cutting-edge
    technology that relies on the use of fractals?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are some of the real-world applications of Voronoi diagrams?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can we extend our 3D cube program to show meshes of other objects—say the
    model of a car, or a human body, or a real-world object?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A close cousin of the Mandelbrot set is the Julia set. Read about the Julia
    set and then modify `8.07_Mandelbrot.py` to produce a Julia set. Fractals are
    a very interesting topic to study and a lot of the maths behind them is still
    unexplored.  Besides the fact that they are beautiful to look at, they are also
    used in a lot of practical applications. See [https://en.wikipedia.org/wiki/Fractal#Applications_in_technology](https://en.wikipedia.org/wiki/Fractal#Applications_in_technology).
  prefs: []
  type: TYPE_NORMAL
- en: If fractals pique your interest, you can also take a look at other variants
    of the Mandelbrot set such as the Magnet 1 fractal and Buddhabrot.
  prefs: []
  type: TYPE_NORMAL
- en: If you are interested in learning more about chaotic behavior, try to plot Hénon’s
    Function on a Tkinter canvas.
  prefs: []
  type: TYPE_NORMAL
- en: We modeled a spring pendulum and it worked in a deterministic manner. However,
    adding two pendulums together to form a double pendulum creates a dynamic system
    that is chaotic. Even though such systems follow the ordinary differential equation,
    the net outcome may vary immensely, even for a very small change in the initial
    condition. It may be worth trying to model a double pendulum by modifying our
    spring pendulum.
  prefs: []
  type: TYPE_NORMAL
- en: 'We used the built-in odeint method from `scipy`. However, we could have written
    our own variation using either the Euler''s method or Runge-Kutta method. You
    can read more about these numerical methods for approximating ordinary differential
    equations over here:  [https://en.wikipedia.org/wiki/Numerical_methods_for_ordinary_differential_equations.](https://en.wikipedia.org/wiki/Numerical_methods_for_ordinary_differential_equations)'
  prefs: []
  type: TYPE_NORMAL
- en: 'If neat or intriguing visualizations looks like a fun thing to do,  here are
    a few more interesting canvas projects that you can undertake: Barnsley fern,
    the cellular automata, the Lorenz attractor, and simulating tearable cloth with
    verlet integration.'
  prefs: []
  type: TYPE_NORMAL
- en: Ray tracing is another powerful but very simple to implement 3D rendering technique
    that can be easily implemented in about 100 lines of code.
  prefs: []
  type: TYPE_NORMAL
