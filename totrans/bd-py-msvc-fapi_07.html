<html><head></head><body>
		<div><h1 id="_idParaDest-187" class="chapter-number"><a id="_idTextAnchor190"/>7</h1>
			<h1 id="_idParaDest-188"><a id="_idTextAnchor191"/>Securing the REST APIs</h1>
			<p>Building microservices means exposing the entire application to the worldwide web. For every request-response transaction, the client accesses the endpoint of the API publicly, which poses potential risks to the application. Unlike web-based applications, API services have weak mechanisms to manage user access using login controls. Thus, this chapter will provide several ways to protect the API services created using the FastAPI framework. </p>
			<p>There is no such thing as perfect security. The main goal is to establish policies and solutions related to the <em class="italic">confidentiality</em>, <em class="italic">integrity</em>, and <em class="italic">availability</em> of these services. The<em class="italic"> confidentiality policy</em> requires tokens, encryption and decryption, and certificates as mechanisms to make some APIs private. On the other hand, the <em class="italic">integrity policy</em> involves maintaining the data exchange as authentic, accurate, and reliable by using a "state" and hashed codes during the authentication and authorization process. The <em class="italic">availability policy</em> means protecting the endpoint access from DoS attacks, phishing, and timing attacks using reliable tools and Python modules. Overall, these three aspects of the security model are the essential elements to consider when building security solutions for our microservices.</p>
			<p>Although FastAPI has no built-in security framework, it supports different authentication modes such as <em class="italic">Basic</em> and <em class="italic">Digest</em>. It also has built-in modules that implement security specifications such as <em class="italic">OAuth2</em>, <em class="italic">OpenID</em>, and <em class="italic">OpenAPI</em>. The following main topics will be covered in this chapter to explain and illustrate the concepts and solutions for securing our FastAPI services:</p>
			<ul>
				<li>Implementing Basic and Digest authentication</li>
				<li>Implementing password-based authentication</li>
				<li>Applying JWTs</li>
				<li>Creating scope-based authorization</li>
				<li>Building the authorization code flow</li>
				<li>Applying the OpenID Connect specification</li>
				<li>Using built-in middleware for authentication</li>
			</ul>
			<h1 id="_idParaDest-189"><a id="_idTextAnchor192"/>Technical requirements</h1>
			<p>The software prototype for this chapter is a <em class="italic">secure online auction system</em> designed to manage online bidding on various items auctioned by its registered users. The system can bid on any items based within a price range and even declare those who won the bidding. The system needs to secure some sensitive transactions to avoid data breaches and biased results. The prototype will be using <em class="italic">SQLAlchemy</em> as the ORM for managing data. There will be 10 versions of our prototype and each will showcase a different authentication scheme. All 10 of these projects (<code>ch07a</code> to <code>ch07j</code>) can be found here: <a href="https://github.com/PacktPublishing/Building-Python-Microservices-with-FastAPI">https://github.com/PacktPublishing/Building-Python-Microservices-with-FastAPI</a>.</p>
			<h1 id="_idParaDest-190"><a id="_idTextAnchor193"/>Implementing Basic and Digest authentication</h1>
			<p>The <a id="_idIndexMarker534"/>Basic and <a id="_idIndexMarker535"/>Digest authentication schemes are the easiest authentication solutions that we can use to secure API endpoints. Both schemes are alternative authentication mechanisms that can be applied to small and low-risk applications without requiring complex configuration and coding. Let us now use these schemes to secure our prototype.</p>
			<h2 id="_idParaDest-191"><a id="_idTextAnchor194"/>Using Basic authentication</h2>
			<p>The most <a id="_idIndexMarker536"/>straightforward way to secure the API endpoint is the <em class="italic">Basic authentication</em> approach. However, this authentication mechanism must not be applied to high-risk applications because the credentials, commonly a username and password, sent from the client to the security scheme provider are in the <em class="italic">Base64-encoded</em> format, which is vulnerable to many attacks such as <em class="italic">brute force</em>, <em class="italic">timing attacks</em>, and <em class="italic">sniffing</em>. Base64 is not an encryption algorithm but simply a way of representing the credentials in <em class="italic">ciphertext</em> format.</p>
			<h3>Applying HttpBasic and HttpBasicCredentials</h3>
			<p>The <a id="_idIndexMarker537"/>prototype, <code>ch07a</code>, uses the Basic authentication <a id="_idIndexMarker538"/>mode to secure its administration and bidding and auctioning transactions. Its implementation in the <code>/security/secure.py</code> module is shown in the following code:</p>
			<pre class="source-code">
<strong class="bold">from passlib.context import CryptContext</strong>
<strong class="bold">from fastapi.security import HTTPBasicCredentials</strong>
<strong class="bold">from fastapi.security import HTTPBasic</strong>
<strong class="bold">from secrets import compare_digest</strong>
from models.data.sqlalchemy_models import Login
<strong class="bold">crypt_context = CryptContext(schemes=["sha256_crypt", </strong>
                    <strong class="bold">"md5_crypt"])</strong>
<strong class="bold">http_basic = HTTPBasic()</strong></pre>
			<p>The FastAPI framework supports different authentication modes and specifications through its <code>fastapi.security</code> module. To pursue the <em class="italic">Basic</em> authentication scheme, we need to instantiate the <code>HTTPBasic</code> class of the module and inject it into each API service to secure the endpoint access. The <code>http_basic</code> instance, once injected into the API services, causes the browser to pop up a login form, through which we type the <code>username</code> and <code>password</code> credentials. Logging in will trigger the browser to send a header with the credentials to the application. If the application encounters a problem with receiving it, the <code>HTTPBasic</code> scheme will throw an <em class="italic">HTTP status code 401 </em>with an <em class="italic">"Unauthorized"</em> message. If there are no errors in the form handling, the application must receive a <code>WWW-Authenticate</code> header with a <code>Basic</code> value and an optional <code>realm</code> parameter.</p>
			<p>On the other hand, the <code>/ch07/login</code> service will call the <code>authentication()</code>method to verify whether the browser credentials are authentic and correct. We need to be very careful in accepting user credentials from browsers since they are prone to various attacks. First, we can require endpoint users to use an <em class="italic">email address</em> as their username and require long passwords with a combination of different characters, numbers, and symbols. All stored passwords must be encoded using the most reliable encryption tools, such as the <code>CryptContext</code> class from the <code>passlib</code> module. The <code>passlib</code> extension provides more secured hashing algorithms than any Python encryption module. Our application uses <code>SHA256</code> and <code>MD5</code> hashing algorithms instead of the recommended <code>bcrypt</code>, which is slower and prone to attacks.</p>
			<p>Second, we can avoid storing the credentials in the source code and use database storage or a<code>.env</code> file instead. The <code>authenticate()</code> method checks the credentials against the <code>Login</code> database record provided by the API service for correctness. </p>
			<p>Lastly, always use the <code>compare_digest()</code> from the <code>secret</code> module when comparing credentials from the browser with the <code>Login</code> credentials stored in the database. This function randomly compares two strings while guarding the operation against timing attacks. A <em class="italic">timing attack</em> is a <a id="_idIndexMarker539"/>kind of attack that compromises the crypto-algorithm<a id="_idIndexMarker540"/> execution, which happens when there is a<a id="_idIndexMarker541"/> linear comparison of strings in the system:</p>
			<pre class="source-code">
def verify_password(plain_password, hashed_password):
    return crypt_context.verify(plain_password, 
        hashed_password)
def authenticate(credentials: HTTPBasicCredentials, 
         account:Login):
    try:
        is_username = compare_digest(credentials.username,
             account.username)
        is_password = compare_digest(credentials.password, 
             account.username)
        verified_password = 
             verify_password(credentials.password, 
                   account.passphrase)
        return (verified_password and is_username and 
               is_password)
    except Exception as e:
        return False</pre>
			<p>Our <code>authenticate()</code> method has all the needed requirements to help reduce attacks from outside factors. But the ultimate solution to secure Basic authentication is to install and configure a <em class="italic">Transport Layer Security </em>(<em class="italic">TLS</em>) (or <em class="italic">HTTPS</em>, or <em class="italic">SSL</em>) connection for the application. </p>
			<p>Now, we<a id="_idIndexMarker542"/> need to implement a <code>/ch07/login</code> endpoint <a id="_idIndexMarker543"/>to apply the <em class="italic">Basic</em> authentication scheme. The <code>http_basic</code> instance is injected into this API service to extract <code>HTTPBasicCredentials</code>, which is the object that contains the <em class="italic">username</em> and <em class="italic">password</em> details from the browser. This service is also the one that calls the <code>authenticate()</code> method to check the user credentials. If the method returns a <code>False</code> value, the service will raise an <em class="italic">HTTP status code 400</em> with an <em class="italic">"Incorrect credentials"</em> message:</p>
			<pre class="source-code">
from fastapi import APIRouter, Depends, HTTPException
<strong class="bold">from fastapi.security import HTTPBasicCredentials</strong>
from security.secure import authenticate, 
            get_password_hash, http_basic
router = APIRouter()
<strong class="bold">@router.get("/login")</strong>
def login(credentials: HTTPBasicCredentials = 
     Depends(http_basic), sess:Session = Depends(sess_db)):
    
    loginrepo = LoginRepository(sess)
    <strong class="bold">account = loginrepo.get_all_login_username(</strong>
                     <strong class="bold">credentials.username)</strong>
    if authenticate(credentials, account) and 
            not account == None:
        return account
    else:
        <strong class="bold">raise HTTPException(</strong>
            status_code=400, 
               <strong class="bold">detail="Incorrect credentials")</strong>
        
<strong class="bold">@router.get("/login/users/list")</strong>
def list_all_login(credentials: HTTPBasicCredentials = 
     Depends(http_basic), sess:Session = Depends(sess_db)):
    loginrepo = LoginRepository(sess)
    users = loginrepo.get_all_login()
    return jsonable_encoder(users)</pre>
			<p>Each <a id="_idIndexMarker544"/>endpoint of the <em class="italic">online auction system</em> must <a id="_idIndexMarker545"/>have the injected <code>http_basic</code> instance to secure it from public access. For instance, the cited <code>list_all_login()</code> service can only return a list of all users if the user is an authenticated one. By the way, there is no reliable procedure to log off using <em class="italic">Basic</em> authentication. If the <code>WWW-Authenticate</code> header has been issued and recognized by the browser, we will seldom see the login form of the browser pop up.</p>
			<h3>Executing the login transaction</h3>
			<p>We can<a id="_idIndexMarker546"/> use either the <code>curl</code> command or the browser to perform the <code>/ch07/login</code> transaction. But to highlight the support of FastAPI, we will be using its OpenAPI dashboard to run <code>/ch07/login</code>. After accessing <code>http://localhost:8000/docs</code> on the browser, locate the <code>/ch07/login</code> GET transaction and click the <strong class="bold">Try it out</strong> button. The browser’s login form, as shown in <em class="italic">Figure 7.1</em>, will pop up after clicking the button:</p>
			<div><div><img src="img/Figure_7.01_B17975.jpg" alt="Figure 7.1 – The browser’s login form&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.1 – The browser’s login form</p>
			<p>After the <code>/ch07/signup/add</code> and <code>/ch07/approve/signup</code> to add the user credentials you want to test. Remember that all stored passwords are encrypted. <em class="italic">Figure 7.2</em> shows how <code>/ch07/login</code> will output the user’s <code>Login</code> record after the authentication process finds that the user credentials are valid:</p>
			<div><div><img src="img/Figure_7.02_B17975.jpg" alt="Figure 7.2 – The /login response&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.2 – The /login response</p>
			<p>Now that the user is authenticated, run <code>/ch07/login/users/list</code> through the OpenAPI dashboard to retrieve the list of login details. The <code>uvicorn</code> server log will show the following log message:</p>
			<pre>INFO: 127.0.0.1:53150 - "GET /ch07/login/users/list HTTP/1.1" 200 OK</pre>
			<p>This means <a id="_idIndexMarker547"/>that the user is authorized to run the endpoint. Now, let us apply the Digest authentication scheme to our prototype.</p>
			<h2 id="_idParaDest-192"><a id="_idTextAnchor195"/>Using Digest authentication</h2>
			<p>Digest authentication<a id="_idIndexMarker548"/> is more secure than the Basic scheme because the former needs to hash the user credentials first before sending the hashed version to the application. Digest authentication in FastAPI does not include an automatic encryption process of user credentials using the default <em class="italic">MD5</em> encryption. It is an authentication scheme that stores credentials in a <code>.env</code> or <code>.config</code> property file and creates a hashed string value for these credentials before the authentication. The <code>ch07b</code> project applies the Digest authentication scheme to secure the bidding and auctioning transactions.</p>
			<h3>Generating the hashed credentials</h3>
			<p>So, before we start the<a id="_idIndexMarker549"/> implementation, we first need to create a custom utility script, <code>generate_hash.py</code>, that generates a digest in binary form using Base64 encoding. The script must have the following code:</p>
			<pre class="source-code">
<strong class="bold">from base64 import urls<a id="_idTextAnchor196"/>afe_b64encode</strong>
h = urlsafe_b64encode(b"sjctrags:sjctrags")</pre>
			<p>The <code>urlsafe_b64encode()</code> function from the <code>base64</code> module creates a digest in binary format from the <code>username:password</code> credential format. After running the script, we save the digest value anywhere safe, but not in the source code. </p>
			<h3>Passing the user credentials</h3>
			<p>Aside <a id="_idIndexMarker550"/>from the digest, we also need to save the user credentials for the Digest scheme provider later. Unlike the standard Digest authentication procedure, where the user negotiates with the browser, FastAPI requires storing the user credentials in a<code>.env</code> or <code>.config</code> file inside our application to be retrieved by the authentication process. In the <code>ch07b</code> project, we save the username and password inside the <code>.config</code> file, in this manner:</p>
			<pre class="source-code">
[CREDENTIALS]
USERNAME=sjctrags
PASSWORD=sjctrags</pre>
			<p>Then, we create a parser through the <code>ConfigParser</code> utility to extract the following details from the <code>.config</code> file and build a <code>dict</code> out of the serialized user details. The following <code>build_map()</code> is an example of the parser implementation:</p>
			<pre class="source-code">
import os
<strong class="bold">from configparser import ConfigParser</strong>
def build_map():
    <strong class="bold">env = os.getenv("ENV", ".config")</strong>
    if env == ".config":
        <strong class="bold">config = ConfigParser()</strong>
        <strong class="bold">config.read(".config")</strong>
        <strong class="bold">config = config["CREDENTIALS"]</strong>
    else:
        config = {
            "USERNAME": os.getenv("USERNAME", "guest"),
            "PASSWORD": os.getenv("PASSWORD", "guest"),
        }
    return config</pre>
			<h3>Using HTTPDigest and HTTPAuthorizationCredentials</h3>
			<p>The FastAPI<a id="_idIndexMarker551"/> framework has an <code>HTTPDigest</code> from its <code>fastapi.security</code> module that implements a Digest authentication <a id="_idIndexMarker552"/>scheme with a different approach to managing user credentials and generating the digest. Unlike in Basic authentication, the <code>HTTPDigest</code> authentication process happens at the <code>APIRouter</code> level. We inject the following <code>authenticate()</code>dependable into the API services through the HTTP operator, including <code>/login</code>, where the authentication starts:</p>
			<pre class="source-code">
from fastapi import Security, HTTPException, status
<strong class="bold">from fastapi.security import HTTPAuthorizationCredentials</strong>
<strong class="bold">from fastapi.security import HTTPDigest</strong>
from secrets import compare_digest
<strong class="bold">from base64 import standard_b64encode</strong>
<strong class="bold">http_digest = HTTPDigest()</strong>
def authenticate(credentials: 
    HTTPAuthorizationCredentials = Security(http_digest)):
    
    <strong class="bold">hashed_credentials = credentials.credentials</strong>
    <strong class="bold">config = build_map()</strong>
    <strong class="bold">expected_credentials = standard_b64encode(</strong>
        <strong class="bold">bytes(f"{config['USERNAME']}:{config['PASSWORD']}",</strong>
           <strong class="bold">encoding="UTF-8")</strong>
    <strong class="bold">)</strong>
    is_credentials = compare_digest(
          bytes(hashed_credentials, encoding="UTF-8"),
               expected_credentials)
    
    if not is_credentials:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect digest token",
            headers={"WWW-Authenticate": "Digest"},
        )</pre>
			<p>The <code>authenticate()</code> method<a id="_idIndexMarker553"/> is where the <code>http_digest</code> is<a id="_idIndexMarker554"/> injected to extract the <code>HTTPAuthorizationCredentials</code> that contains the digest byte value. After extraction, it checks whether the digest matches the credentials saved in the <code>.config</code> file. We also use <code>compare_digest</code> to compare <code>hashed_credentials</code> from the header and the Base64-encoded credentials from the <code>.config</code> file. </p>
			<h3>Executing the login transaction</h3>
			<p>After<a id="_idIndexMarker555"/> implementing the <code>authenticate()</code> method, we inject it into the API services, not in the method parameter, but in its HTTP operator. Notice that the <code>http_digest</code> object is not injected directly into the API services, unlike in the <em class="italic">Basic</em> authentication scheme. The following implementation shows how the <code>authenticate()</code> dependable is applied to secure all the crucial endpoints of the application:</p>
			<pre class="source-code">
from security.secure import authenticate
<strong class="bold">@router.get("/login", dependencies=[Depends(authenticate)])</strong>
def login(sess:Session = Depends(sess_db)):
    return {"success": "true"}
        
<strong class="bold">@router.get("/login/users/list",   </strong>
      <strong class="bold">dependencies=[Depends(authenticate)])</strong>
def list_all_login(sess:Session = Depends(sess_db)):
    loginrepo = LoginRepository(sess)
    users = loginrepo.get_all_login()
    return jsonable_encoder(users)</pre>
			<p>Since the<a id="_idIndexMarker556"/> Digest authentication scheme behaves like the <em class="italic">OpenID authentication</em>, we will be using the <code>curl</code> command to run <code>/ch07/login</code>. The crucial part of the command is the issuance of the <code>Authorization</code> header with the value containing the Base64-encoded <code>username:password</code> digest generated by the <code>generate_hash.py</code> script we executed beforehand. The following <code>curl</code> command is the correct way of logging into our FastAPI application that uses the Digest authentication scheme:</p>
			<pre>curl --request GET --url http://localhost:8000/ch07/login --header "accept: application/json"                  --header "Authorization: Digest c2pjdHJhZ3M6c2pjdHJhZ3M=" --header "Content-Type: application/json"</pre>
			<p>We also use the same command to run the rest of the secured API services.</p>
			<p>Most enterprise applications nowadays seldom use Basic and Digest authentication schemes because of their vulnerability to many attacks. More than that, both authentication schemes require sending credentials to the secured API services, which is also another risk. Moreover, at the time of writing, FastAPI does not yet fully support the standard <a id="_idIndexMarker557"/>Digest authentication, which is also a disadvantage to other applications that need the standard one. So, let us now explore the solution to secure API endpoints using the <em class="italic">OAuth 2.0 specification</em>.</p>
			<h1 id="_idParaDest-193"><a id="_idTextAnchor197"/>Implementing password-based authentication</h1>
			<p>The <em class="italic">OAuth 2.0 specification</em>, or OAuth2, is the<a id="_idIndexMarker558"/> most preferred solution for authenticating API endpoint access. The OAuth2 authorization framework defines the four <a id="_idIndexMarker559"/>authorization flows, which are <em class="italic">implicit</em>, <em class="italic">client credentials</em>, <em class="italic">authorization code</em>, and <em class="italic">resource password flows</em>. The first three of these can be used with third-party authentication providers, which will authorize the access of the API endpoints. In the FastAPI platform, the resource password flow can be customized and implemented within the application to carry out the authentication procedure. Let us now explore how FastAPI supports the OAuth2 specification.</p>
			<h2 id="_idParaDest-194"><a id="_idTextAnchor198"/>Installing the python-multipart module</h2>
			<p>Since OAuth2 <a id="_idIndexMarker560"/>authentication will not be possible without a form handling procedure, we need to install the <code>python-multipart</code> module before pursuing the implementation part. We can run the following command to install the extension:</p>
			<pre>pip install python-multipart</pre>
			<h2 id="_idParaDest-195"><a id="_idTextAnchor199"/>Using OAuth2PasswordBearer and OAuth2PasswordRequestForm</h2>
			<p>The FastAPI<a id="_idIndexMarker561"/> framework fully <a id="_idIndexMarker562"/>supports OAuth2, especially the password flow type of the OAuth2 specification. Its <code>fastapi.security</code> module has an <code>OAuth2PasswordBearer</code> that serves as the provider for password-based authentication. It also has <code>OAuth2PasswordRequestForm</code>, which can declare a form body with required parameters, <code>username</code> and <code>password</code>, and some optional ones such as <code>scope</code>, <code>grant_type</code>, <code>client_id</code>, and <code>client_secret</code>. This class is directly injected into the <code>/ch07/login</code> API endpoint to extract all the parameter values from the browser’s login form. But it is always an option to use <code>Form(…)</code> to capture all the individual parameters.</p>
			<p>So, let us start the solution by creating the <code>OAuth2PasswordBearer</code> to be injected into a custom function dependency that will validate the user credentials. The following implementation shows that <code>get_current_user()</code> is the injectable function in our new application, <code>ch07c</code>, which utilizes the <code>oath2_scheme</code> injectable to extract a <code>token</code>:</p>
			<pre class="source-code">
<strong class="bold">from fastapi.security import OAuth2PasswordBearer</strong>
from sqlalchemy.orm import Session
from repository.login import LoginRepository
from db_config.sqlalchemy_connect import sess_db
<strong class="bold">oauth2_scheme = </strong>
    <strong class="bold">OAuth2PasswordBearer(tokenUrl="ch07/login/token")</strong>
def get_current_user(token: str = Depends(oauth2_scheme), 
           sess:Session = Depends(sess_db) ):
    loginrepo = LoginRepository(sess)
    <strong class="bold">user = loginrepo.get_all_login_username(token)</strong>
    if user == None:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid authentication credentials",
            headers={"WWW-Authenticate": "Bearer"},
        )
    return user</pre>
			<p>For the <a id="_idIndexMarker563"/>resource password <a id="_idIndexMarker564"/>flow, injecting <code>oauth2_scheme</code> will return a <code>username</code> as a token. <code>get_current_user()</code> will check whether that username belongs to a valid user account stored in the database. </p>
			<h2 id="_idParaDest-196"><a id="_idTextAnchor200"/>Executing the login transaction</h2>
			<p>In this<a id="_idIndexMarker565"/> authentication scheme, <code>/ch07/login/token</code> is also the <code>tokenUrl</code> parameter of <code>OAuth2PasswordBearer</code>. The <code>tokenUrl</code> parameter is required for password-based OAuth2 authentication because this is the endpoint service that will capture the user credentials from the browser’s login form. <code>OAuth2PasswordRequestForm</code> is injected into <code>/cho07/login/token</code> to retrieve the <code>username</code>, <code>password</code>, and <code>grant_type</code> parameters of the unauthenticated user. These three parameters are the essential requirements to invoke <code>/ch07/login/token</code> for <em class="italic">token</em> generation. This dependency is shown in the following implementation of the login API service:</p>
			<pre class="source-code">
from sqlalchemy.orm import Session
from db_config.sqlalchemy_connect import sess_db
from repository.login import LoginRepository
from fastapi.security import OAuth2PasswordRequestForm
from security.secure import get_current_user, authenticate
<strong class="bold">@router.post("/login/token")</strong>
def login(form_data: OAuth2PasswordRequestForm = Depends(),
             sess:Session = Depends(sess_db)):
    <strong class="bold">username = form_data.username</strong>
    <strong class="bold">password = form_data.password</strong>
    loginrepo = LoginRepository(sess)
    <strong class="bold">account = loginrepo.get_all_login_username(username)</strong>
    if authenticate(username, password, account) and 
              not account == None:
        return {"access_token": form_data.username, 
                  "token_type": "bearer"}
    else:
        raise HTTPException(
            status_code=400, 
               detail="Incorrect username or password")</pre>
			<p>Aside from verifying from the database, the <code>login()</code> service will also check whether the <code>password</code> value matches the encrypted passphrase from the queried <code>account</code>. If all the verification succeeds,  <code>/ch07/login/token</code> must return a JSON object with the required properties, <code>access_token</code> and <code>token_type</code>. The <code>access_token</code> property must have the <code>username</code> value, and <code>token_type</code> the <code>"bearer"</code> value.</p>
			<p>Instead of creating<a id="_idIndexMarker566"/> a custom frontend for the login form, we will be utilizing the OAuth2 form provided by OpenAPI in the framework. We just click the <strong class="bold">Authorize</strong> button on the upper-right-hand side of the OpenAPI dashboard, as shown in <em class="italic">Figure 7.3</em>:</p>
			<div><div><img src="img/Figure_7.03_B17975.jpg" alt="Figure 7.3 – The Authorize button&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.3 – The Authorize button</p>
			<p>The button will trigger a built-in login form to pop up, shown in <em class="italic">Figure 7.4</em>, which we can use to test our solution:</p>
			<div><div><img src="img/Figure_7.04_B17975.jpg" alt="Figure 7.4 – The OAuth2 login form&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.4 – The OAuth2 login form</p>
			<p>Everything is fine if the<a id="_idIndexMarker567"/> OAuth2 login form detects the correct <code>tokenURL</code> specified in the <code>OAuth2PasswordBearer</code> instantiation. The OAuth2 flow or <code>grant_type</code> indicated in the login form must be <code>"password"</code>. After logging the verified credential, the form’s <strong class="bold">Authorize</strong> button will redirect the user to an authorization form, shown in <em class="italic">Figure 7.5</em>, which will prompt the user to log out or proceed with the authenticated access:</p>
			<div><div><img src="img/Figure_7.05_B17975.jpg" alt="Figure 7.5 – The authorization form"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.5 – The authorization form</p>
			<p>Generally, the <a id="_idIndexMarker568"/>OAuth2 specification recognizes two client or application types: <em class="italic">confidential</em> and <em class="italic">public</em> clients. The confidential clients utilize authentication servers for security, such as in this <em class="italic">online auction system</em> that uses the FastAPI server through the OpenAPI platform. In its setup, it is not mandatory to provide the <code>client_id</code> and <code>client_secret</code> values to the login form since the server will generate these parameters during the authentication process. But unfortunately, these values are not revealed to the client, as shown in <em class="italic">Figure 7.5</em>. On the other hand, the public clients do not have any means to generate and use client secrets as in typical web-based and mobile applications. Therefore, these applications must include <code>client_id</code>, <code>client_secret</code>, and other required parameters during login.</p>
			<h2 id="_idParaDest-197"><a id="_idTextAnchor201"/>Securing the endpoints</h2>
			<p>To secure the<a id="_idIndexMarker569"/> API endpoints, we need to inject the <code>get_current_user()</code> method into each API service method. The following is an implementation of a secured <code>add_auction()</code> service that utilizes the <code>get_current_user()</code> method:</p>
			<pre class="source-code">
<strong class="bold">@router.post("/auctions/add")</strong>
def add_auction(req: AuctionsReq, 
      current_user: Login = Depends(get_current_user), 
      sess:Session = Depends(sess_db)): 
    auc_dict = req.dict(exclude_unset=True)
    repo:AuctionsRepository = AuctionsRepository(sess)
    auction = Auctions(**auc_dict)
    result = repo.insert_auction(auction)
    if result == True:
        return auction
    else: 
        return JSONResponse(content=
         {'message':'create auction problem encountered'}, 
            status_code=500)  </pre>
			<p>The <code>get_current_user()</code> injectable will return a valid <code>Login</code> account if the access is allowed. Moreover, you will notice that all padlock icons of the secured API endpoints that include <code>/ch07/auctions/add</code>, shown in <em class="italic">Figure 7.6</em>, are closed. This indicates that <a id="_idIndexMarker570"/>they are ready to be executed since the user is already an authenticated one:</p>
			<div><div><img src="img/Figure_7.06_B17975.jpg" alt="Figure 7.6 – An OpenAPI dashboard showing secured APIs&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.6 – An OpenAPI dashboard showing secured APIs</p>
			<p>This solution is a<a id="_idIndexMarker571"/> problem for an open network setup, for instance, because the token used is a password. This setup allows attackers to easily forge or modify the token during its transmission from the issuer to the client. One way to protect the<a id="_idIndexMarker572"/> token is to use a <strong class="bold">JSON Web Token</strong> (<strong class="bold">JWT</strong>). </p>
			<h1 id="_idParaDest-198"><a id="_idTextAnchor202"/>Applying JWTs</h1>
			<p>JWT is an <a id="_idIndexMarker573"/>open source standard used to define a solution for sending any information during the authentication and authorization between issuers and clients. Its goal is to generate <code>access_token</code> properties that are digitally signed, URL-safe, and always verifiable by the client. However, it is not perfectly safe because anyone can decode the token if needed. Thus, it is advisable not to include all the valuable and confidential information in the token string. A JWT is an effective way of providing OAuth2 and OpenID specifications with more reliable tokens than passwords.</p>
			<h2 id="_idParaDest-199"><a id="_idTextAnchor203"/>Generating the secret key</h2>
			<p>But before we start building <a id="_idIndexMarker574"/>the authentication scheme, we first need to generate a <em class="italic">secret key</em>, which is an essential element in creating the <em class="italic">signature</em>. The JWT has a <code>ssh</code> or <code>openssl</code> is the appropriate utility to generate this long and randomized key. Here, in <code>ch07d</code>, we run the following <code>openssl</code> command from a GIT tool or any SSL generator to create the key:</p>
			<pre>openssl rand -hex 32</pre>
			<h2 id="_idParaDest-200"><a id="_idTextAnchor204"/>Creating the access_token</h2>
			<p>In the <code>ch07d</code> project, we <a id="_idIndexMarker578"/>will store the <em class="italic">secret key</em> and <em class="italic">algorithm type</em> in some reference variables in its <code>/security/secure.py</code> module script. These variables are used by the JWT-encoding procedure to generate the token, as shown in the following code:</p>
			<pre class="source-code">
<strong class="bold">from jose import jwt, JWTError</strong>
from datetime import datetime, timedelta
<strong class="bold">SECRET_KEY = "tbWivbkVxfsuTxCP8A+Xg67LcmjXXl/sszHXwH+TX9w="</strong>
<strong class="bold">ALGORITHM = "HS256"</strong>
ACCESS_TOKEN_EXPIRE_MINUTES = 30
def create_access_token(data: dict, 
           expires_after: timedelta):
    plain_text = data.copy()
    expire = datetime.utcnow() + expires_after
    plain_text.update({"exp": expire})
    <strong class="bold">encoded_jwt = jwt.encode(plain_text, SECRET_KEY, </strong>
            <strong class="bold">algorithm=ALGORITHM)</strong>
    return encoded_jwt</pre>
			<p>Within the JWT Python extension, we chose the <code>python-jose</code> module to generate the token because it is reliable and has additional cryptographic functions that can sign complex data content. Install this module first using the <code>pip</code> command before using it. </p>
			<p>So now, the <code>/ch07/login/token</code> endpoint will invoke the <code>create_access_token()</code> method to request the JWT. The <em class="italic">login</em> service will provide the data, usually <code>username</code>, to comprise the payload portion of the token. Since the JWT must be short-lived, the process must update the <code>expire</code> portion of the payload to some <code>datetime</code> value in minutes or seconds suited to the application. </p>
			<h2 id="_idParaDest-201"><a id="_idTextAnchor205"/>Creating the login transaction</h2>
			<p>The implementation <a id="_idIndexMarker579"/>of the <em class="italic">login</em> service is similar to the previous password-based OAuth2 authentication, except that this version has a <code>create_access_token()</code> call for the JWT generation to replace the password credential. The following script shows the <code>/ch07/login/token</code> service of the <code>ch07d</code> project:</p>
			<pre class="source-code">
@router.post("/login/token")
def login(form_data: OAuth2PasswordRequestForm = Depends(),
          sess:Session = Depends(sess_db)):
    username = form_data.username
    password = form_data.password
    loginrepo = LoginRepository(sess)
    account = loginrepo.get_all_login_username(username)
    if authenticate(username, password, account):
        <strong class="bold">access_token = create_access_token(</strong>
          <strong class="bold">data={"sub": username}, </strong>
           <strong class="bold">expires_after=timedelta(</strong>
              <strong class="bold">minutes=ACCESS_TOKEN_EXPIRE_MINUTES))</strong>
        <strong class="bold">return {"access_token": access_token, </strong>
             <strong class="bold">"token_type": "bearer"}</strong>
    else:
        raise HTTPException(
            status_code=400, 
            detail="Incorrect username or password")</pre>
			<p>The endpoint should still return <code>access_token</code> and <code>token_type</code> since this is still a password-based<a id="_idIndexMarker580"/> OAuth2 authentication, which retrieves the user credentials from <code>OAuth2PasswordRequestForm</code>. </p>
			<h2 id="_idParaDest-202"><a id="_idTextAnchor206"/>Accessing the secured endpoints</h2>
			<p>As with the previous<a id="_idIndexMarker581"/> OAuth2 schemes, we need to inject <code>get_current_user()</code>into every API service to impose security and restrict access. The injected <code>OAuthPasswordBearer</code> instance will return the JWT for payload extraction using the JOSE decoders with the specified decoding algorithm. If the token is tampered with, modified, or expired, the method will throw an change to - exception. Otherwise, we need to continue the payload data extraction, retrieve the username, and store that in an <code>@dataclass</code> instance, such as <code>TokenData</code>. Then, the username will undergo further verification, such as checking the database for a <code>Login</code> account with that username. The following snippet shows this decoding process, found in the <code>/security/secure.py</code> module of the <code>ch07d</code> project:</p>
			<pre class="source-code">
<strong class="bold">from models.request.tokens import TokenData</strong>
<strong class="bold">from fastapi.security import OAuth2PasswordBearer</strong>
from jose import jwt, JWTError
from models.data.sqlalchemy_models import Login
from sqlalchemy.orm import Session
from db_config.sqlalchemy_connect import sess_db
from repository.login import LoginRepository
from datetime import datetime, timedelta
<strong class="bold">oauth2_scheme = </strong>
     <strong class="bold">OAuth2PasswordBearer(tokenUrl="ch07/login/token")</strong>
def get_current_user(token: str = Depends(oauth2_scheme),
    sess:Session = Depends(sess_db)):
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"}
    )
    try:
        <strong class="bold">payload = jwt.decode(token, SECRET_KEY, </strong>
           <strong class="bold">algorithms=[ALGORITHM])</strong>
        <strong class="bold">username: str = payload.get("sub")</strong>
        if username is None:
            raise credentials_exception
        <strong class="bold">token_data = TokenData(username=username)</strong>
    except JWTError:
        raise credentials_exception
    
    loginrepo = LoginRepository(sess)
    user = 
      <strong class="bold">loginrepo.get_all_login_username(token_data.username)</strong>
    if user is None:
        raise credentials_exception
    return user</pre>
			<p><code>get_current_user()</code> must be injected into each service implementation to restrict <a id="_idIndexMarker582"/>access from users. But this time, the method will not only verify the credentials but also perform <em class="italic">JWT payload decoding</em>. The next step is adding <em class="italic">user authorization </em>to the OAuth2 solution.</p>
			<h1 id="_idParaDest-203"><a id="_idTextAnchor207"/>Creating scope-based authorization</h1>
			<p>FastAPI fully<a id="_idIndexMarker583"/> supports <em class="italic">scope-based authentication</em>, which uses the <code>scopes</code> parameter of the OAuth2 protocol to specify which endpoints are accessible to a group of users. A <code>scopes</code> parameter is a kind of permission placed in a token to provide additional fine-grained restrictions to users. In this version of the project, <code>ch07e</code>, we will be showcasing OAuth2 password-based authentication with user authorization. </p>
			<h2 id="_idParaDest-204"><a id="_idTextAnchor208"/>Customizing the OAuth2 class</h2>
			<p>First, we need to <a id="_idIndexMarker584"/>create a custom class that inherits the properties of the <code>OAuth2</code> API class from the <code>fastapi.security</code> module to include the <code>scopes</code> parameter or "role" options in the user credentials. The following is the <code>OAuth2PasswordBearerScopes</code> class, a custom OAuth2 class that will implement the authentication flow with authorization:</p>
			<pre class="source-code">
<strong class="bold">class OAuth2PasswordBearerScopes(OAuth2):</strong>
    def __init__(
        self,
        tokenUrl: str,
        scheme_name: str = None,
        <strong class="bold">scopes: dict = None,</strong>
        auto_error: bool = True,
        
    ):
    if not scopes:
         scopes = {}
    <strong class="bold">flows = OAuthFlowsModel(</strong>
       <strong class="bold">password={"tokenUrl": tokenUrl, "scopes": scopes})</strong>
    super().__init__(<strong class="bold">flows=flows</strong>, 
       <strong class="bold">scheme_name=scheme_name</strong>, auto_error=auto_error)
    async def __call__(self, request: Request) -&gt; 
             Optional[str]:
        <strong class="bold">header_authorization: str = </strong>
              <strong class="bold">request.headers.get("Authorization")</strong>
        … … … … … …
        return param</pre>
			<p>This <code>OAuth2PasswordBearerScopes</code> class requires two constructor parameters, <code>tokenUrl</code> and <code>scopes</code>, to <a id="_idIndexMarker585"/>pursue an auth flow. <code>OAuthFlowsModel</code> defines the <code>scopes</code> parameter as part of the user credentials for authentication using the <code>Authorization</code> header.</p>
			<h2 id="_idParaDest-205"><a id="_idTextAnchor209"/>Building the permission dictionary</h2>
			<p>Before we proceed with the <a id="_idIndexMarker586"/>auth implementation, we need to first build the <code>scopes</code> parameters that the OAuth2 scheme will be applying during authentication. This setup is part of the <code>OAuth2PasswordBearerScopes</code> instantiation, where we assign these parameters to its <code>scopes</code> parameter. The following script shows how all the custom-defined user scopes are saved in a <em class="italic">dictionary</em>, with the <em class="italic">keys</em> as the scope names and the <em class="italic">values</em> as their corresponding descriptions:</p>
			<pre class="source-code">
oauth2_scheme = <strong class="bold">OAuth2PasswordBearerScopes</strong>(
    tokenUrl="/ch07/login/token",
    <strong class="bold">scopes={"admin_read": </strong>
              <strong class="bold">"admin role that has read only role",</strong>
            <strong class="bold">"admin_write":</strong>
              <strong class="bold">"admin role that has write only role",</strong>
            <strong class="bold">"bidder_read":</strong>
              <strong class="bold">"customer role that has read only role",</strong>
            <strong class="bold">"bidder_write":</strong>
              <strong class="bold">"customer role that has write only role",</strong>
            <strong class="bold">"auction_read":</strong>
              <strong class="bold">"buyer role that has read only role",</strong>
            <strong class="bold">"auction_write":</strong>
              <strong class="bold">"buyer role that has write only role",</strong>
            <strong class="bold">"user":"valid user of the application",</strong>
            <strong class="bold">"guest":"visitor of the site"},</strong>
)</pre>
			<p>There is no<a id="_idIndexMarker587"/> feasible way to directly connect the <code>OAuth2PasswordBearerScopes</code> class to the database for the dynamic lookup of permission sets during the implementation of this project. The only solution is to statically store all these authorization "roles" directly into the constructor of  <code>OAuth2PasswordBearerScopes</code>.</p>
			<h2 id="_idParaDest-206"><a id="_idTextAnchor210"/>Implementing the login transaction</h2>
			<p>All the scopes will be <a id="_idIndexMarker588"/>added to the OAuth2 form login as an option and will be part of the user’s login credentials. The following implementation of <code>/ch07/login/token</code> in this new <code>ch07e</code> project shows how to retrieve the scope parameter(s) and the credentials from <code>OAuth2PasswordRequestForm</code>:</p>
			<pre class="source-code">
@router.post("/login/token")
def login(form_data: OAuth2PasswordRequestForm = Depends(),
         sess:Session = Depends(sess_db)):
    username = form_data.username
    password = form_data.password
    loginrepo = LoginRepository(sess)
    account = loginrepo.get_all_login_username(username)
    if authenticate(username, password, account):
        access_token = create_access_token(
            data={"sub": username, "scopes": 
              form_data.scopes},  
               expires_delta=timedelta(
               minutes=ACCESS_TOKEN_EXPIRE_MINUTES))
        return {"access_token": access_token, 
                "token_type": "bearer"}
    else:
        raise HTTPException(
            status_code=400, 
            detail="Incorrect username or password")</pre>
			<p>The selected <a id="_idIndexMarker589"/>scopes are stored in a list, such as <code>['user', 'admin_read', 'admin_write', 'bidder_write']</code>, which means that a user has <em class="italic">user</em>, <em class="italic">administrator (write)</em>, <em class="italic">administrator (read)</em>, and <em class="italic">bidder (write)</em> permissions. <code>create_access_token()</code> will include this list of scopes or "roles" as part of the <em class="italic">payload</em>, which will be decoded and extracted by <code>get_current_valid_user()</code> through the <code>get_current_user()</code> injectable. By the way, <code>get_current_valid_user()</code> secures every API from the user access by <a id="_idIndexMarker590"/>applying the authentication scheme.</p>
			<h2 id="_idParaDest-207"><a id="_idTextAnchor211"/>Applying the scopes to endpoints</h2>
			<p>The <code>Security</code> API<a id="_idIndexMarker591"/> from the <code>fastapi</code> module replaces the <code>Depends</code> class in injecting the <code>get_current_valid_user()</code> because of its capability to assign scopes to each API service, aside from its capability to perform DI. It has the <code>scopes</code> attribute, where a list of valid scope parameters is defined that restricts the user from access. For instance, the following <code>update_profile()</code> service is accessible only to users whose scopes contain the <code>bidder_write</code> and <code>buyer_write</code> roles:   </p>
			<pre class="source-code">
<strong class="bold">from fastapi.security import SecurityScopes</strong>
<strong class="bold">@router.patch("/profile/update")</strong>
def update_profile(id:int, req: ProfileReq, 
    <strong class="bold">current_user: Login = Security(get_current_valid_user, </strong>
        scopes=["bidder_write", "buyer_write"]), 
    sess:Session = Depends(sess_db)): 
    … … … … … …
    if result: 
        return JSONResponse(content=
         {'message':'profile updated successfully'}, 
              status_code=201)
    else: 
        return JSONResponse(content=
           {'message':'update profile error'}, 
               status_code=500)</pre>
			<p>Now, the following code snippet shows the implementation of the <code>get_current_valid_user()</code> injected into every API service by <code>Security</code>:</p>
			<pre class="source-code">
def get_current_valid_user(current_user: 
   Login = Security(get_current_user, scopes=["user"])):
    if current_user == None:
        raise HTTPException(status_code=400, 
           detail="Invalid user")
    return current_user</pre>
			<p>This method <a id="_idIndexMarker592"/>relies on <code>get_current_user()</code> when it comes to JWT payload decoding, credential validation, and user scope verification. The user must at least have the <code>user</code> scope for the authorization process to proceed. The <code>Security</code> class is responsible for injecting <code>get_current_user()</code> into <code>get_current_valid_user()</code> together with the default <code>user</code> scope. Here is the implementation of the <code>get_current_user()</code> method:</p>
			<pre class="source-code">
def get_current_user(security_scopes: SecurityScopes, 
      token: str = Depends(oauth2_scheme), 
           sess:Session = Depends(sess_db)):
    <strong class="bold">if security_scopes.scopes:</strong>
        <strong class="bold">authenticate_value = </strong>
          <strong class="bold">f'Bearer scope="{security_scopes.scope_str}"'</strong>
    else:
        authenticate_value = f"Bearer" 
    … … … … … …
    try:
        payload = jwt.decode(token, SECRET_KEY, 
                   algorithms=[ALGORITHM])
        username: str = payload.get("sub")
        if username is None:
            raise credentials_exception
        <strong class="bold">token_scopes = payload.get("scopes", [])</strong>
        <strong class="bold">token_data = TokenData(scopes=token_scopes, </strong>
               <strong class="bold">username=username)</strong>
    except JWTError:
        raise credentials_exception
    … … … … … …
    <strong class="bold">for scope in security_scopes.scopes:</strong>
        <strong class="bold">if scope not in token_data.scopes:</strong>
            <strong class="bold">raise HTTPException(</strong>
                <strong class="bold">status_code=status.HTTP_401_UNAUTHORIZED,</strong>
                <strong class="bold">detail="Not enough permissions",</strong>
                <strong class="bold">headers={"WWW-Authenticate": </strong>
                    <strong class="bold">authenticate_value},</strong>
            <strong class="bold">)</strong>
    return user</pre>
			<p>The <code>SecurityScopes</code> class of the given <code>get_current_user()</code> extracts the scopes assigned to the API service that the user is trying to access. It has a <code>scope</code> instance variable<a id="_idIndexMarker593"/> that contains all these scope parameters of the API. On the other hand, <code>token_scopes</code> carries all the scopes or "roles" of the user extracted from the decoded JWT payload. <code>get_current_user()</code> traverses the API scopes in <code>SecurityScopes</code> to check whether all of them appear in the <code>token_scopes</code> of the user. If <code>True</code>, <code>get_current_user()</code> authenticates and authorizes the user to access the API service. Otherwise, it throws an change to - exception. The purpose of <code>TokenData</code> is to manage the scope parameters from the <code>token_scopes</code> payload value and the username. </p>
			<p>The next type of OAuth2 authentication scheme that FastAPI can support is the authorization code flow approach.</p>
			<h1 id="_idParaDest-208"><a id="_idTextAnchor212"/>Building the authorization code flow</h1>
			<p>If the application is<a id="_idIndexMarker594"/> a <em class="italic">public</em> type and there is no authorization server to process the <code>client_id</code> parameter, the <code>client_secret</code> parameter, and other related parameters, this OAuth2 authorization code flow approach is appropriate to use. In this scheme, the client creates an authorization request for a short-lived <em class="italic">authorization code</em> from an <code>authorizationUrl</code>. The client will then ask for the token from <code>tokenUrl</code> in exchange for the generated code. In this discussion, we will be showcasing another version of our <em class="italic">online auction system</em> that will use the OAuth2 <em class="italic">authorization code flow s</em>cheme.</p>
			<h2 id="_idParaDest-209"><a id="_idTextAnchor213"/>Applying OAuth2AuthorizationCodeBearer</h2>
			<p>The <code>OAuth2AuthorizationCodeBearer</code> class<a id="_idIndexMarker595"/> is a class from the <code>fastapi.security</code> module that builds the authorization code flow. Its constructor requires <code>authorizationUrl</code>, <code>tokenUrl</code>, and the optional <code>scopes</code> before instantiation. The following code shows how this API class is created before its injection into the <code>get_current_user()</code> method:</p>
			<pre class="source-code">
<strong class="bold">from fastapi.security import OAuth2AuthorizationCodeBearer</strong>
oauth2_scheme = OAuth2AuthorizationCodeBearer(
    authorizationUrl='ch07/oauth2/authorize',
    <strong class="bold">tokenUrl="ch07/login/token",  </strong>
    scopes={"admin_read": "admin … read only role",
            "admin_write":"admin … write only role",
            … … … … … …
            "guest":"visitor of the site"},
    )</pre>
			<p>The two endpoints, <code>authorizationUrl</code> and <code>tokenUrl</code>, are crucial parameters in the authentication and authorization process of this scheme. Unlike the previous solutions, we will not rely on the authorization server when generating <code>access_token</code>. Instead, we will be implementing an <code>authorizationUrl</code> endpoint that will capture essential parameters from the client that will comprise the authorization <a id="_idIndexMarker596"/>request for <code>access_token</code> generation. The <code>client_secret</code> parameter will always remain unexposed to the client.</p>
			<h2 id="_idParaDest-210"><a id="_idTextAnchor214"/>Implementing the authorization request</h2>
			<p>In the<a id="_idIndexMarker597"/> previous schemes, the <code>/ch07/login/</code> token or the <code>tokenUrl</code> endpoint is always the redirection point after a login transaction. But this time, the user will be forwarded to the custom <code>/ch07/oauth2/authorize</code> or the <code>authorizationUrl</code> endpoint for <em class="italic">auth code</em> generation. Query parameters such as <code>response_type</code>, <code>client_id</code>, <code>redirect_uri</code>, <code>scope</code>, and <code>state</code> are the essential inputs to the <code>authorizationUrl</code> service. The following code from the <code>/security/secure.py</code> module of the <code>ch07f</code> project will showcase the implementation of the <code>authorizationUrl</code> transaction:</p>
			<pre class="source-code">
<strong class="bold">@router.get("/oauth2/authorize")</strong>
def authorizationUrl(state:str, client_id: str, 
       redirect_uri: str, scope: str, response_type: str, 
       sess:Session = Depends(sess_db)):
      
    <strong class="bold">global state_server</strong>
    <strong class="bold">state_server = state</strong>
    
    loginrepo = LoginRepository(sess)
    account = loginrepo.get_all_login_username(client_id)
    <strong class="bold">auth_code = f"{account.username}:{account.password}</strong>
                    <strong class="bold">:{scope}"</strong>
    <strong class="bold">if authenticate(account.username, </strong>
              <strong class="bold">account.password, account):</strong>
        <strong class="bold">return RedirectResponse(url=redirect_uri </strong>
          <strong class="bold">+ "?code=" + auth_code </strong>
          <strong class="bold">+ "&amp;grant_type=" + response_type</strong>
          <strong class="bold">+ "&amp;redirect_uri=" + redirect_uri </strong>
          <strong class="bold">+ "&amp;state=" + state)</strong>
    else:
        raise HTTPException(status_code=400, 
               detail="Invalid account")</pre>
			<p>These are the query <a id="_idIndexMarker598"/>parameters needed by the <code>authorizationUrl</code> transaction:</p>
			<ul>
				<li><code>response_type</code>: Custom-generated authorization code </li>
				<li><code>client_id</code>: The public identifier of the app, such as <code>username</code></li>
				<li><code>redirect_uri</code>: The server default URI or a custom endpoint designed to redirect the user back to the application</li>
				<li><code>scope</code>: A scope parameter(s) string, separated by spaces if at least two parameters are involved</li>
				<li><code>state</code>: An arbitrary string value that determines the state of the request</li>
			</ul>
			<p>The <code>redirect_uri</code> parameter is the destination point where the authentication and authorization processes will occur together with these query parameters. </p>
			<p>The generation of <code>auth_code</code> is one of the crucial tasks of the <code>authorizationUrl</code> transaction, including the authentication process. The <em class="italic">auth code</em> indicates an ID for the authentication process and is usually unique from all other authentication. There are many ways to generate the code, but in our app, it is simply the combination of user credentials. Conventionally, <code>auth_code</code> needs to be encrypted because it comprises the user credentials, scope, and other request-related details.</p>
			<p>If the user is valid, the <code>authorizationUrl</code> transaction will redirect the user to the <code>redirect_uri</code> parameter, back to the FastAPI layer, with the <code>auth_code</code>, <code>grant_type</code>, and <code>state</code> parameters, and the <code>redirect_uri</code> parameter itself. The <code>grant_type</code> and <code>redirect_uri</code> parameters are optional only if the application does not require them. This response will invoke the <code>tokenUrl</code> endpoint, which happens to be<a id="_idIndexMarker599"/> the <code>redirectURL</code> parameter, to pursue the continuation of the authentication process with scoped-based authorization.</p>
			<h2 id="_idParaDest-211"><a id="_idTextAnchor215"/>Implementing the authorization code response</h2>
			<p>The <code>/ch07/login/token</code> service, or <code>tokenUrl</code>, must have the <code>Form(…)</code> parameter to<a id="_idIndexMarker600"/> capture the <code>code</code>, <code>grant_type</code>, and <code>redirect_uri</code> parameters from the <code>authorizationUrl</code> transaction instead of <code>OAuth2PasswordRequestForm</code>. The following code snippet shows its implementation:</p>
			<pre class="source-code">
<strong class="bold">@router.post("/login/token")</strong>
def access_token(code: str = Form(...), 
  grant_type:str = Form(...), redirect_uri:str = Form(...), 
  sess:Session = Depends(sess_db)):
    access_token_expires = 
       timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    
    <strong class="bold">code_data = code.split(':')</strong>
    <strong class="bold">scopes = code_data[2].split("+")</strong>
    <strong class="bold">password = code_data[1]</strong>
    <strong class="bold">username = code_data[0]</strong>
    
    loginrepo = LoginRepository(sess)
    account = loginrepo.get_all_login_username(username)
    if authenticate(username, password, account):
        <strong class="bold">access_token = create_access_token(</strong>
            <strong class="bold">data={"sub": username, "scopes": scopes},</strong>
            <strong class="bold">expires_delta=access_token_expires,</strong>
        <strong class="bold">)</strong>
    
        <strong class="bold">global state_server</strong>
        <strong class="bold">state = state_server</strong>
        return {
            "access_token": access_token,
            "expires_in": access_token_expires,
            "token_type": "Bearer",
            "userid": username,
            "state": state,
            "scope": "SCOPE"
        }
    else:
        raise HTTPException(
            status_code=400, 
             detail="Incorrect credentials")</pre>
			<p>The only <a id="_idIndexMarker601"/>response data sent by <code>authorizationUrl</code> that is not accessible by <code>tokenUrl</code> is the <code>state</code> parameter. One workaround is to declare the <code>state</code> variable in <code>authorizationURL</code> as a <code>global</code> one to make it accessible anywhere. The <code>state</code> variable is part of the JSON response of the service, which the API authentication requires. Likewise, <code>tokenUrl</code> has no access to the user credentials but parsing <code>auth_code</code> is a possible way to derive the username, password, and scopes.</p>
			<p>If the user is valid, <code>tokenUrl</code> must submit the JSON data containing <code>access_token</code>, <code>expires_in</code>, <code>token_type</code>, <code>userid</code>, and <code>state</code> to proceed with the authentication scheme. </p>
			<p>This authorization <a id="_idIndexMarker602"/>code flow scheme provides the baseline protocol for the <em class="italic">OpenID Connect</em> authentication. Various identity and access management solutions, such as <em class="italic">Okta</em>, <em class="italic">Auth0</em>, and <em class="italic">Keycloak</em>, apply the authorization requests and responses involving response_type code. The next topic will highlight the FastAPI's support of the OpenID Connect specification.</p>
			<h1 id="_idParaDest-212"><a id="_idTextAnchor216"/>Applying the OpenID Connect specification</h1>
			<p>There are<a id="_idIndexMarker603"/> three <em class="italic">online auction</em> projects created to impose the <em class="italic">OAuth2 OpenID Connect </em>authentication scheme. All these projects use third-party tools to perform authentication and authorization procedures. The <code>ch07g</code> project uses <em class="italic">Auth0</em>, <code>ch07h</code> uses <em class="italic">Okta</em>, and <code>ch07i</code> applies a <em class="italic">Keycloak</em> policy in authenticating client access to the API services. Let us first highlight Keycloak’s support for the OpenID Connect protocol. </p>
			<h2 id="_idParaDest-213"><a id="_idTextAnchor217"/>Using HTTPBearer</h2>
			<p>The <code>HTTPBearer</code> class is a <a id="_idIndexMarker604"/>utility class from the <code>fastapi.security</code> module that provides an authorization scheme that relies directly on the authorization header with the <code>Bearer</code> tokens. Unlike the other OAuth2 schemes, this requires the generation of an <code>access_token</code> on the <em class="italic">Keycloak</em> side before running the authentication server. At this point, the framework has no straightforward way of accessing the credentials and the <code>access_token</code> from Keycloak’s identity provider. To utilize this class, we only need to instantiate it without any constructor parameters.</p>
			<h2 id="_idParaDest-214"><a id="_idTextAnchor218"/>Installing and configuring the Keycloak environment</h2>
			<p>Keycloak<a id="_idIndexMarker605"/> is a Java-based application that we<a id="_idIndexMarker606"/> can download from the following link: <a href="https://www.keycloak.org/downloads">https://www.keycloak.org/downloads</a>. After downloading, we can unzip its content to any directory. But before <a id="_idIndexMarker607"/>running it, we need to install at least the Java 12 SDK on our development machine. Once you have completed the setup, run its <code>bin\standalone.bat</code> or <code>bin\standalone.sh</code> on the console and then open <code>http://localhost:8080</code> on the browser. Afterward, create an administration account to set up the <em class="italic">realm</em>, <em class="italic">clients</em>, <em class="italic">users</em>, and <em class="italic">scopes</em>.</p>
			<h2 id="_idParaDest-215"><a id="_idTextAnchor219"/>Setting the Keycloak realm and clients</h2>
			<p>A Keycloak <em class="italic">realm</em> is an<a id="_idIndexMarker608"/> object that encompasses all the <a id="_idIndexMarker609"/>clients together with their <em class="italic">credentials</em>, <em class="italic">scopes</em>, and <em class="italic">roles</em>. The first step before creating the user profiles is to build a realm, as shown in <em class="italic">Figure 7.7</em>:</p>
			<div><div><img src="img/Figure_7.07_B17975.jpg" alt="Figure 7.7 - Creating a Keycloak realm"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.7 - Creating a Keycloak realm</p>
			<p>After the realm, the Keycloak <em class="italic">client</em>, which <a id="_idIndexMarker610"/>manages the user profiles <a id="_idIndexMarker611"/>and credentials, is the next priority. It is created on the <strong class="bold">Configure</strong> | <strong class="bold">Clients</strong> panel, as shown:</p>
			<div><div><img src="img/Figure_7.08_B17975.jpg" alt="Figure 7.8 – Creating the Keycloak clients&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.8 – Creating the Keycloak clients</p>
			<p>After creating the clients, we need to edit each Client profile to input the following details:</p>
			<ul>
				<li>Its access type must be <code>confidential</code></li>
				<li><code>Authorization Enabled</code> is turned <code>ON</code></li>
				<li>Provide values for <code>Root URL</code>, <code>Base URL</code>, and <code>Admin URL</code>, which all refer to the <code>http://localhost:8000</code> of the API service application</li>
				<li>Specify a <code>Valid Redirect URI</code> endpoint, or we can just assign <code>http://localhost:8080/*</code> if we have no specific custom endpoint </li>
				<li>In <code>Advanced Settings</code>, set <code>Access Token Lifespan</code> (e.g., 15 minutes)</li>
				<li>Under <code>Authentication Flow Overrides</code>, set <code>Browser Flow</code> to <code>browser</code> and<a id="_idIndexMarker612"/> <code>Direct Grant Flow</code> to <code>direct grant</code>.</li>
			</ul>
			<p>In the <code>client_secret</code> value is located. After the setup, we can now assign users to the clients.</p>
			<h2 id="_idParaDest-216"><a id="_idTextAnchor220"/>Creating users and user roles</h2>
			<p>First, we<a id="_idIndexMarker613"/> create <em class="italic">roles</em> on the <strong class="bold">Configure | Roles</strong> panel, in<a id="_idIndexMarker614"/> preparation for user assignment later. <em class="italic">Figure 7.9</em> shows three user roles that will handle the application’s <em class="italic">administration</em>, <em class="italic">auctioning</em>, and <em class="italic">bidding </em>tasks:</p>
			<div><div><img src="img/Figure_7.09_B17975.jpg" alt="Figure 7.9 – Creating user roles&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.9 – Creating user roles</p>
			<p>After creating the roles, we need to build the list of users on the <strong class="bold">Manage | U</strong><strong class="bold">sers</strong> panel. <em class="italic">Figure 7.10</em> shows the three created users, each with the mapped roles: </p>
			<div><div><img src="img/Figure_7.10_B17975.jpg" alt="Figure 7.10 – Creating client users&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.10 – Creating client users</p>
			<p>To provide users with their roles, we need to click the <code>joey_admin</code> has the <code>auc_admin_role</code> role, authorizing the user to do the administrative tasks for the app. By the way, do not forget to create a password for each user on the <strong class="bold">Credentials</strong><em class="italic"> </em>panel:</p>
			<div><div><img src="img/Figure_7.11_B17975.jpg" alt="Figure 7.11 – Mapping user roles&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.11 – Mapping user roles</p>
			<h2 id="_idParaDest-217"><a id="_idTextAnchor221"/>Assigning roles to clients</h2>
			<p>Aside from user roles, clients <a id="_idIndexMarker615"/>can also have assigned roles. A <em class="italic">client role</em> defines the type of users a client must have under its coverage. It also provides the client’s boundary when accessing the API services. <em class="italic">Figure 7.12</em> shows <code>auc_admin</code> with an <code>admin</code> role:</p>
			<div><div><img src="img/Figure_7.12_B17975.jpg" alt="Figure 7.12 – Creating client roles"/>
				</div>
			</div>
			<p class="IMG---Figure"> </p>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.12 – Creating client roles</p>
			<p>Then, we need to return to the <code>joey_admin</code> has the <code>admin</code> role because the <code>auc_admin</code> role was added to its profile. All users with the <code>auc_admin</code> client added to their setup have <em class="italic">admin</em> access to the app, including <code>joey_admin</code>:</p>
			<div><div><img src="img/Figure_7.13_B17975.jpg" alt="Figure 7.13 – Mapping client roles to users"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.13 – Mapping client roles to users</p>
			<h2 id="_idParaDest-218"><a id="_idTextAnchor222"/>Creating user permissions through scopes</h2>
			<p>To assign permission to each<a id="_idIndexMarker616"/> client, we need to create <em class="italic">client scopes</em> on the <code>Audience</code>-type token mapper. <em class="italic">Figure 7.14</em> shows the <code>admin:read</code> and <code>admin:write</code> scopes for the <code>auc_admin</code> client, <code>auction:read</code> and <code>auction:write</code> for <code>auc_customer</code>, and <code>bidder:write</code> and <code>bidder:read</code> for <code>auc_bidder</code>:</p>
			<div><div><img src="img/Figure_7.14_B17975.jpg" alt="Figure 7.14 – Creating the client scopes&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.14 – Creating the client scopes</p>
			<p>These <em class="italic">client scopes</em> are essential details within the <code>Security</code> injection for each API service if <em class="italic">scope-based authorization</em> is part of the scheme.</p>
			<h2 id="_idParaDest-219"><a id="_idTextAnchor223"/>Integrating Keycloak with FastAPI</h2>
			<p>Since the <a id="_idIndexMarker617"/>FastAPI application cannot directly access the Keycloak client credentials for authentication, the application has a <code>login_keycloak()</code> service to redirect the user to the <em class="italic">AuctionRealm URI</em>, our custom <code>authorizationUrl</code> in Keycloak. The URI is <code>/auth/realms/AuctionRealm/protocol/openid-connect/auth</code>. First, access <code>http://localhost:8080/auth/realms/AuctionRealm/account/</code> to log in using the authorized user credentials, such as <code>joey_admin</code>, before invoking the <code>login_keycloak()</code> service.</p>
			<p>Now, the redirection must include <code>client_id</code>, as with the <code>auc_admin</code> client, and the custom callback handler called <code>redirect_uri</code>. All the Keycloak realm details must be in the <code>.config</code> property file. The following code shows the implementation of the <code>login_keycloak()</code> service:</p>
			<pre class="source-code">
<strong class="bold">import hashlib</strong>
import os
import urllib.parse as parse
<strong class="bold">@router.get("/auth/login")</strong>
def login_keycloak() -&gt; RedirectResponse:
    config = set_up()
    <strong class="bold">state = hashlib.sha256(os.urandom(32)).hexdigest()</strong>
 
    AUTH_BASE_URL = f"{config['KEYCLOAK_BASE_URL']}
     <strong class="bold">/auth/realms/AuctionRealm/protocol/</strong>
         openid-connect/auth"
    AUTH_URL = AUTH_BASE_URL + 
     '?{}'.format(parse.urlencode({
        'client_id': config["CLIENT_ID"],
        'redirect_uri': config["REDIRECT_URI"],
        'state': state,
        <strong class="bold">'response_type': 'code'</strong>
    }))
    response = RedirectResponse(AUTH_URL)
    response.set_cookie(key="AUTH_STATE", value=state)
    return response</pre>
			<p>A <em class="italic">state</em> is part of <code>login_keycloak()</code>’s response for the callback method to verify the authentication, a similar approach we had in utilizing <code>OAuth2AuthorizationCodeBearer</code>. The service used the <code>hashlib</code> module to generate a <a id="_idIndexMarker618"/>randomized hash string value for the state using the <em class="italic">SHA256</em> encryption algorithm. On the other hand, Keycloak’s <em class="italic">AuctionRealm URI</em> must return a JSON result as follows:</p>
			<pre class="source-code">
{"access_token":"eyJhbGciOiJSUzI1NiIsInR5cCIgOiAiSldUIiwia2lkI iA6ICJJMFR3YVhiZnh0MVNQSnNzVTByQ09hMzVDaTdZNDkzUnJIeDJTM3paa0V VIn0.eyJleHAiOjE2NDU0MTgzNTAsImlhdCI6MTY0NTQxNzQ1MCwiYXV0aF90a W1lIjoxNjQ1NDE3NDM3LCJqdGkiOiI4YTQzMjBmYi0xMzg5LTQ2NzU……………………………2YTU2In0.UktwOX7H2ZdoyP1VZ5V2MXUX2Gj41D2cuusvwEZXBtVMvnoTDh KJgN8XWL7P3ozv4A1ZlBmy4NX1HHjPbSGsp2cvkAWwlyXmhyUzfQslf8Su00-4 e9FR4i4rOQtNQfqHM7cLhrzr3-od-uyj1m9KsrpbqdLvPEl3KZnmOfFbTwUXfE 9YclBFa8zwytEWb4qvLvKrA6nPv7maF2_MagMD_0Mh9t95N9_aY9dfquS9tcEV Whr3d9B3ZxyOtjO8WiQSJyjLCT7IW1hesa8RL3WsiG3QQQ4nUKVHhnciK8efRm XeaY6iZ_-8jm-mqMBxw00-jchJE8hMtLUPQTMIK0eopA","expires_in":900,"refresh_expires_in":1800,"refresh_token":"eyJhbGciOiJIUzI1NiIs InR5cCIgOiAiSldUIiwia2lkIiA6ICJhNmVmZGQ0OS0yZDIxLTQ0NjQtOGUyOC0 4ZWJkMjdiZjFmOTkifQ.eyJleHAiOjE2NDU0MTkyNTAsImlhdCI6MTY0NTQxNzQ 1MCwianRpIjoiMzRiZmMzMmYtYjAzYi00MDM3LTk5YzMt………………………zc2lvbl9z dGF0ZSI6ImM1NTE3ZDIwLTMzMTgtNDFlMi1hNTlkLWU2MGRiOWM1NmE1NiIsIn Njb3BlIjoiYWRtaW46d3JpdGUgYWRtaW46cmVhZCB1c2VyIiwic2lkIjoiYzU1 MTdkMjAtMzMxOC00MWUyLWE1OWQtZTYwZGI5YzU2YTU2In0.xYYQPr8dm7_o1G KplnS5cWmLbpJTCBDfm1WwZLBhM6k","token_type":"Bearer","not-before-policy":0,"session_state":"c5517d20-3318-41e2-a59d-e60d b9c56a56","scope":"admin:write admin:read user"}</pre>
			<p>This contains <a id="_idIndexMarker619"/>the essential credentials, such as <code>access_token</code>, <code>expires_in</code>, <code>session_state</code>, and <code>scope</code>.</p>
			<h2 id="_idParaDest-220"><a id="_idTextAnchor224"/>Implementing the token verification</h2>
			<p>The <a id="_idIndexMarker620"/>application’s <code>HTTPBearer</code> needs <code>access_token</code> to pursue the client-side authentication. On the OpenAPI dashboard, we click the <code>access_token</code> value provided by Keycloak’s <code>authorizationUrl</code>. After the successful authentication, <code>get_current_user()</code> will verify the access to each API endpoint based on the credentials extracted from <code>access_token</code>. The following code highlights the <code>get_current_user()</code>, <code>which</code> builds the user credentials from Keycloak’s <em class="italic">token</em> using the <code>PyJWT</code> utility and algorithms such as <code>RSAAlgorithm</code>:</p>
			<pre class="source-code">
<strong class="bold">from jwt.algorithms import RSAAlgorithm</strong>
from urllib.request import urlopen
import jwt
def get_current_user(security_scopes: SecurityScopes, 
        <code>token: str = Depends(token_auth_scheme)</code>):
    token = token.credentials
    config = set_up()
    <strong class="bold">jsonurl = urlopen(f'{config["KEYCLOAK_BASE_URL"]}</strong>
        <strong class="bold">/auth/realms/AuctionRealm/protocol</strong>
        <strong class="bold">/openid-connect/certs')</strong>
    <strong class="bold">jwks = json.loads(jsonurl.read())</strong>
    <strong class="bold">unverified_header = jwt.get_unverified_header(token)</strong>
   
    rsa_key = {}
    <strong class="bold">for key in jwks["keys"]:</strong>
        <strong class="bold">if key["kid"] == unverified_header["kid"]:</strong>
            <strong class="bold">rsa_key = {</strong>
                <strong class="bold">"kty": key["kty"],</strong>
                <strong class="bold">"kid": key["kid"],</strong>
                <strong class="bold">"use": key["use"],</strong>
                <strong class="bold">"n": key["n"],</strong>
                <strong class="bold">"e": key["e"]</strong>
            <strong class="bold">}</strong>
    
    if rsa_key:
        try:
                <strong class="bold">public_key = RSAAlgorithm.from_jwk(rsa_key)</strong>
                <strong class="bold">payload = jwt.decode(</strong>
                    <strong class="bold">token,</strong>
                    public_key,
                    <strong class="bold">algorithms=config["ALGORITHMS"],</strong>
                    <strong class="bold">options=dict(</strong>
                           <strong class="bold">verify_aud=False,</strong>
                           <strong class="bold">verify_sub=False,</strong>
                           <strong class="bold">verify_exp=False,</strong>
                     )
                )
    … … … … … …
    <strong class="bold">token_scopes = payload.get("scope", "").split()</strong>
   
    <strong class="bold">for scope in security_scopes.scopes:</strong>
        if scope not in token_scopes:
            raise AuthError(
               {
                 "code": "Unauthorized",
                 "description": Invalid Keycloak details,
               },403,
            )
    return payload</pre>
			<p>Install the <code>PyJWT</code> module<a id="_idIndexMarker621"/> first to utilize the needed encoders and decoder functions. The <code>jwt</code> module has <code>RSAAlgorithm</code>, <code>which</code> can help decode the rsa_key from the token with some options disabled, such as the verification of the client’s <code>audience</code>. </p>
			<h2 id="_idParaDest-221"><a id="_idTextAnchor225"/>Integrating Auth0 with FastAPI</h2>
			<p><em class="italic">Auth0</em> can also be a third-party <a id="_idIndexMarker622"/>authentication provider that can authenticate and authorize access to the API endpoints of our app. But first, we need to sign up for an account at <a href="https://auth0.com/">https://auth0.com/</a>. </p>
			<p>After signing up for an account, create an Auth0 application to derive <strong class="bold">Domain</strong>, <strong class="bold">Client ID</strong>, and <strong class="bold">Client Secret</strong>, and configure some URI- and token-related details. <em class="italic">Figure 7.15</em> shows the dashboard that creates the Auth0 application:</p>
			<div><div><img src="img/Figure_7.15_B17975.jpg" alt="Figure 7.15 – Creating the Auth0 application&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.15 – Creating the Auth0 application</p>
			<p>The Auth0 application also has the generated <em class="italic">Audience API</em> URI that the client-side authentication needs. On the other hand, part of the authentication parameters is the <em class="italic">issuer</em>, which we can derive from the <code>/oauth/token</code> service that generates the <code>auth_token</code> once requested, similar to the Keycloak’s realm. We place all these Auth0 details in the <code>.config</code> file, including the <code>PyJWT</code> algorithm for decoding <code>auth_token</code>.</p>
			<p><code>ch07g</code> has its <a id="_idIndexMarker623"/>own version of <code>get_current_user()</code> that processes the <em class="italic">payload</em> for API authentication and authorization from the Auth0 details in the <code>.config</code> file. But first, the <code>HTTPBearer</code> class needs the <code>auth_token</code> value and gets it by running the following <code>tokenURL</code> of our Auth0 application, <em class="italic">AuctionApp</em>:</p>
			<pre>curl --request POST                                      --url https://dev-fastapi1.us.auth0.com/oauth/token   --header
'content-type: application/json'              --data "{"client_id":"KjdwFzHrOLXC3IKe kw8t6YhX4xUV1ZNd",   "client_secret":"_KyPEUOB7DA5Z3mmRXpnqWA3EXfrjLw2R5SoUW7m1wLMj7 KoElMyDLiZU8SgMQYr","audience":"https://fastapi.auction.com/","grant_type":"client_credentials"}"</pre>
			<h2 id="_idParaDest-222"><a id="_idTextAnchor226"/>Integrating Okta with FastAPI</h2>
			<p>Some of the <a id="_idIndexMarker624"/>processes performed in Auth0 are also found in Okta’s procedures when extracting the <code>ch07h</code> project has these details stored in the <code>app.env</code> file to be retrieved by its <code>get_current_user()</code> for the payload generation. But then again, the <code>HTTPBearer</code> class needs an <code>auth_token</code> from executing the following Okta’s <code>tokenURL</code>, based on the account’s issuer:</p>
			<pre>curl --location --request POST "https://dev-5180227.okta.com/oauth2/default/v1/token?grant_type=client_credentials&amp;client_id=0oa3tvejee5UPt7QZ5d7&amp;client_secret=LA4WP8lACWKu4Ke9fReol0fNSUvxsxTvGLZdDS5-"   --header "Content-Type: application/x-www-form-urlencoded"</pre>
			<p>Aside from the Basic, Digest, OAuth2, and OpenID Connect authentication schemes, FastAPI can utilize some built-in middlewares to help secure API endpoints. Let us now determine whether these middlewares can provide a custom authentication process.</p>
			<h1 id="_idParaDest-223"><a id="_idTextAnchor227"/>Using built-in middlewares for authentication</h1>
			<p>FastAPI <a id="_idIndexMarker625"/>can use Starlette middleware <a id="_idIndexMarker626"/>such as <code>AuthenticationMiddleware</code> to implement any custom authentication. It needs <code>AuthenticationBackend</code> to implement the scheme for our app’s security model. The following custom <code>AuthenticationBackend</code> checks whether the <code>Authorization</code> credential is a <code>Bearer</code> class and verifies whether the <code>username</code> token is equivalent to a fixed username credential provided by the middleware:</p>
			<pre class="source-code">
<strong class="bold">class UsernameAuthBackend(AuthenticationBackend):</strong>
    <strong class="bold">def __init__(self, username): </strong>
        <strong class="bold">self.username = username    </strong>
        
    async def authenticate(self, request):
        if "Authorization" not in request.headers:
            return
        <strong class="bold">auth = request.headers["Authorization"]</strong>
        try:
            <strong class="bold">scheme, username = auth.split()</strong>
            <strong class="bold">if scheme.lower().strip() != 'bearer'.strip():</strong>
                return
        except:
            raise AuthenticationError(
             'Invalid basic auth credentials')
        if not username == self.username:
            return
       
        return AuthCredentials(["authenticated"]), 
             SimpleUser(username)</pre>
			<p>Activating <a id="_idIndexMarker627"/>this <code>UsernameAuthBackend</code> means <a id="_idIndexMarker628"/>injecting it into the FastAPI constructor in <code>main.py</code> with <code>AuthenticationMiddleware</code>. It also needs the designated <code>username</code> for its authentication process to work. The following snippet shows how to activate the whole authentication scheme in the <code>main.py</code> file:</p>
			<pre class="source-code">
<strong class="bold">from security.secure import UsernameAuthBackend</strong>
<strong class="bold">from starlette.middleware import Middleware</strong>
<strong class="bold">from starlette.middleware.authentication import </strong>
    <strong class="bold">AuthenticationMiddleware</strong>
<strong class="bold">middleware = [Middleware(AuthenticationMiddleware, </strong>
    <strong class="bold">backend=UsernameAuthBackend("sjctrags"))]</strong>
app = FastAPI(middleware=middleware)</pre>
			<p>Injecting <a id="_idIndexMarker629"/>FastAPI’s <code>Request</code> is the first step in<a id="_idIndexMarker630"/> applying the authentication scheme. Then, we decorate each API with <code>@requires("authenticated")</code> after the <code>@router</code> decorator. We can extend the <code>UsernameAuthBackend</code> process further by adding JWT encoding and decoding, encryption, or custom roles-based authorization.</p>
			<h1 id="_idParaDest-224"><a id="_idTextAnchor228"/>Summary</h1>
			<p>Securing any applications is always the main priority in producing quality software. We always choose frameworks that support reliable and credible security solutions, and that can at least prevent malicious attacks from the outside environment. Although we know for a fact that a perfect security model is a myth, we always develop security solutions that can cope with the threats we know. </p>
			<p>FastAPI is one of the API frameworks that has built-in support for many popular authentication processes, from Basic to the OpenID Connect specification. It fully supports all effective OAuth2 authentication schemes and is even open to further customization of its security APIs. </p>
			<p>Although it has no direct support for the OpenID Connect specification, it can still integrate seamlessly with different popular identities and user management systems, such as Auth0, Okta, and Keycloak. This framework may still surprise us with many security utilities and classes in the future that we can apply to build scalable microservice applications.</p>
			<p>The next chapter will focus on topics regarding non-blocking API services, events, and message-driven transactions.</p>
		</div>
		<div><div></div>
		</div>
	</body></html>