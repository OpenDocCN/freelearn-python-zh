<html><head></head><body>
		<div id="_idContainer056">
			<h1 id="_idParaDest-187" class="chapter-number"><a id="_idTextAnchor190"/>7</h1>
			<h1 id="_idParaDest-188"><a id="_idTextAnchor191"/>Securing the REST APIs</h1>
			<p>Building microservices means exposing the entire application to the worldwide web. For every request-response transaction, the client accesses the endpoint of the API publicly, which poses potential risks to the application. Unlike web-based applications, API services have weak mechanisms to manage user access using login controls. Thus, this chapter will provide several ways to protect the API services created using the FastAPI framework. </p>
			<p>There is no such thing as perfect security. The main goal is to establish policies and solutions related to the <em class="italic">confidentiality</em>, <em class="italic">integrity</em>, and <em class="italic">availability</em> of these services. The<em class="italic"> confidentiality policy</em> requires tokens, encryption and decryption, and certificates as mechanisms to make some APIs private. On the other hand, the <em class="italic">integrity policy</em> involves maintaining the data exchange as authentic, accurate, and reliable by using a "state" and hashed codes during the authentication and authorization process. The <em class="italic">availability policy</em> means protecting the endpoint access from DoS attacks, phishing, and timing attacks using reliable tools and Python modules. Overall, these three aspects of the security model are the essential elements to consider when building security solutions for our microservices.</p>
			<p>Although FastAPI has no built-in security framework, it supports different authentication modes such as <em class="italic">Basic</em> and <em class="italic">Digest</em>. It also has built-in modules that implement security specifications such as <em class="italic">OAuth2</em>, <em class="italic">OpenID</em>, and <em class="italic">OpenAPI</em>. The following main topics will be covered in this chapter to explain and illustrate the concepts and solutions for securing our FastAPI services:</p>
			<ul>
				<li>Implementing Basic and Digest authentication</li>
				<li>Implementing password-based authentication</li>
				<li>Applying JWTs</li>
				<li>Creating scope-based authorization</li>
				<li>Building the authorization code flow</li>
				<li>Applying the OpenID Connect specification</li>
				<li>Using built-in middleware for authentication</li>
			</ul>
			<h1 id="_idParaDest-189"><a id="_idTextAnchor192"/>Technical requirements</h1>
			<p>The software prototype for this chapter is a <em class="italic">secure online auction system</em> designed to manage online bidding on various items auctioned by its registered users. The system can bid on any items based within a price range and even declare those who won the bidding. The system needs to secure some sensitive transactions to avoid data breaches and biased results. The prototype will be using <em class="italic">SQLAlchemy</em> as the ORM for managing data. There will be 10 versions of our prototype and each will showcase a different authentication scheme. All 10 of these projects (<strong class="source-inline">ch07a</strong> to <strong class="source-inline">ch07j</strong>) can be found here: <a href="https://github.com/PacktPublishing/Building-Python-Microservices-with-FastAPI">https://github.com/PacktPublishing/Building-Python-Microservices-with-FastAPI</a>.</p>
			<h1 id="_idParaDest-190"><a id="_idTextAnchor193"/>Implementing Basic and Digest authentication</h1>
			<p>The <a id="_idIndexMarker534"/>Basic and <a id="_idIndexMarker535"/>Digest authentication schemes are the easiest authentication solutions that we can use to secure API endpoints. Both schemes are alternative authentication mechanisms that can be applied to small and low-risk applications without requiring complex configuration and coding. Let us now use these schemes to secure our prototype.</p>
			<h2 id="_idParaDest-191"><a id="_idTextAnchor194"/>Using Basic authentication</h2>
			<p>The most <a id="_idIndexMarker536"/>straightforward way to secure the API endpoint is the <em class="italic">Basic authentication</em> approach. However, this authentication mechanism must not be applied to high-risk applications because the credentials, commonly a username and password, sent from the client to the security scheme provider are in the <em class="italic">Base64-encoded</em> format, which is vulnerable to many attacks such as <em class="italic">brute force</em>, <em class="italic">timing attacks</em>, and <em class="italic">sniffing</em>. Base64 is not an encryption algorithm but simply a way of representing the credentials in <em class="italic">ciphertext</em> format.</p>
			<h3>Applying HttpBasic and HttpBasicCredentials</h3>
			<p>The <a id="_idIndexMarker537"/>prototype, <strong class="source-inline">ch07a</strong>, uses the Basic authentication <a id="_idIndexMarker538"/>mode to secure its administration and bidding and auctioning transactions. Its implementation in the <strong class="source-inline">/security/secure.py</strong> module is shown in the following code:</p>
			<pre class="source-code">
<strong class="bold">from passlib.context import CryptContext</strong>
<strong class="bold">from fastapi.security import HTTPBasicCredentials</strong>
<strong class="bold">from fastapi.security import HTTPBasic</strong>
<strong class="bold">from secrets import compare_digest</strong>
from models.data.sqlalchemy_models import Login
<strong class="bold">crypt_context = CryptContext(schemes=["sha256_crypt", </strong>
                    <strong class="bold">"md5_crypt"])</strong>
<strong class="bold">http_basic = HTTPBasic()</strong></pre>
			<p>The FastAPI framework supports different authentication modes and specifications through its <strong class="source-inline">fastapi.security</strong> module. To pursue the <em class="italic">Basic</em> authentication scheme, we need to instantiate the <strong class="source-inline">HTTPBasic</strong> class of the module and inject it into each API service to secure the endpoint access. The <strong class="source-inline">http_basic</strong> instance, once injected into the API services, causes the browser to pop up a login form, through which we type the <strong class="source-inline">username</strong> and <strong class="source-inline">password</strong> credentials. Logging in will trigger the browser to send a header with the credentials to the application. If the application encounters a problem with receiving it, the <strong class="source-inline">HTTPBasic</strong> scheme will throw an <em class="italic">HTTP status code 401 </em>with an <em class="italic">"Unauthorized"</em> message. If there are no errors in the form handling, the application must receive a <strong class="source-inline">WWW-Authenticate</strong> header with a <strong class="source-inline">Basic</strong> value and an optional <strong class="source-inline">realm</strong> parameter.</p>
			<p>On the other hand, the <strong class="source-inline">/ch07/login</strong> service will call the <strong class="source-inline">authentication()</strong>method to verify whether the browser credentials are authentic and correct. We need to be very careful in accepting user credentials from browsers since they are prone to various attacks. First, we can require endpoint users to use an <em class="italic">email address</em> as their username and require long passwords with a combination of different characters, numbers, and symbols. All stored passwords must be encoded using the most reliable encryption tools, such as the <strong class="source-inline">CryptContext</strong> class from the <strong class="source-inline">passlib</strong> module. The <strong class="source-inline">passlib</strong> extension provides more secured hashing algorithms than any Python encryption module. Our application uses <strong class="source-inline">SHA256</strong> and <strong class="source-inline">MD5</strong> hashing algorithms instead of the recommended <strong class="source-inline">bcrypt</strong>, which is slower and prone to attacks.</p>
			<p>Second, we can avoid storing the credentials in the source code and use database storage or a<strong class="source-inline">.env</strong> file instead. The <strong class="source-inline">authenticate()</strong> method checks the credentials against the <strong class="source-inline">Login</strong> database record provided by the API service for correctness. </p>
			<p>Lastly, always use the <strong class="source-inline">compare_digest()</strong> from the <strong class="source-inline">secret</strong> module when comparing credentials from the browser with the <strong class="source-inline">Login</strong> credentials stored in the database. This function randomly compares two strings while guarding the operation against timing attacks. A <em class="italic">timing attack</em> is a <a id="_idIndexMarker539"/>kind of attack that compromises the crypto-algorithm<a id="_idIndexMarker540"/> execution, which happens when there is a<a id="_idIndexMarker541"/> linear comparison of strings in the system:</p>
			<pre class="source-code">
def verify_password(plain_password, hashed_password):
    return crypt_context.verify(plain_password, 
        hashed_password)
def authenticate(credentials: HTTPBasicCredentials, 
         account:Login):
    try:
        is_username = compare_digest(credentials.username,
             account.username)
        is_password = compare_digest(credentials.password, 
             account.username)
        verified_password = 
             verify_password(credentials.password, 
                   account.passphrase)
        return (verified_password and is_username and 
               is_password)
    except Exception as e:
        return False</pre>
			<p>Our <strong class="source-inline">authenticate()</strong> method has all the needed requirements to help reduce attacks from outside factors. But the ultimate solution to secure Basic authentication is to install and configure a <em class="italic">Transport Layer Security </em>(<em class="italic">TLS</em>) (or <em class="italic">HTTPS</em>, or <em class="italic">SSL</em>) connection for the application. </p>
			<p>Now, we<a id="_idIndexMarker542"/> need to implement a <strong class="source-inline">/ch07/login</strong> endpoint <a id="_idIndexMarker543"/>to apply the <em class="italic">Basic</em> authentication scheme. The <strong class="source-inline">http_basic</strong> instance is injected into this API service to extract <strong class="source-inline">HTTPBasicCredentials</strong>, which is the object that contains the <em class="italic">username</em> and <em class="italic">password</em> details from the browser. This service is also the one that calls the <strong class="source-inline">authenticate()</strong> method to check the user credentials. If the method returns a <strong class="source-inline">False</strong> value, the service will raise an <em class="italic">HTTP status code 400</em> with an <em class="italic">"Incorrect credentials"</em> message:</p>
			<pre class="source-code">
from fastapi import APIRouter, Depends, HTTPException
<strong class="bold">from fastapi.security import HTTPBasicCredentials</strong>
from security.secure import authenticate, 
            get_password_hash, http_basic
router = APIRouter()
<strong class="bold">@router.get("/login")</strong>
def login(credentials: HTTPBasicCredentials = 
     Depends(http_basic), sess:Session = Depends(sess_db)):
    
    loginrepo = LoginRepository(sess)
    <strong class="bold">account = loginrepo.get_all_login_username(</strong>
                     <strong class="bold">credentials.username)</strong>
    if authenticate(credentials, account) and 
            not account == None:
        return account
    else:
        <strong class="bold">raise HTTPException(</strong>
            status_code=400, 
               <strong class="bold">detail="Incorrect credentials")</strong>
        
<strong class="bold">@router.get("/login/users/list")</strong>
def list_all_login(credentials: HTTPBasicCredentials = 
     Depends(http_basic), sess:Session = Depends(sess_db)):
    loginrepo = LoginRepository(sess)
    users = loginrepo.get_all_login()
    return jsonable_encoder(users)</pre>
			<p>Each <a id="_idIndexMarker544"/>endpoint of the <em class="italic">online auction system</em> must <a id="_idIndexMarker545"/>have the injected <strong class="source-inline">http_basic</strong> instance to secure it from public access. For instance, the cited <strong class="source-inline">list_all_login()</strong> service can only return a list of all users if the user is an authenticated one. By the way, there is no reliable procedure to log off using <em class="italic">Basic</em> authentication. If the <strong class="source-inline">WWW-Authenticate</strong> header has been issued and recognized by the browser, we will seldom see the login form of the browser pop up.</p>
			<h3>Executing the login transaction</h3>
			<p>We can<a id="_idIndexMarker546"/> use either the <strong class="source-inline">curl</strong> command or the browser to perform the <strong class="source-inline">/ch07/login</strong> transaction. But to highlight the support of FastAPI, we will be using its OpenAPI dashboard to run <strong class="source-inline">/ch07/login</strong>. After accessing <strong class="source-inline">http://localhost:8000/docs</strong> on the browser, locate the <strong class="source-inline">/ch07/login</strong> GET transaction and click the <strong class="bold">Try it out</strong> button. The browser’s login form, as shown in <em class="italic">Figure 7.1</em>, will pop up after clicking the button:</p>
			<div>
				<div id="_idContainer041" class="IMG---Figure">
					<img src="image/Figure_7.01_B17975.jpg" alt="Figure 7.1 – The browser’s login form&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.1 – The browser’s login form</p>
			<p>After the <strong class="bold">Username</strong> and <strong class="bold">Password</strong> input, click the <strong class="bold">Sign in</strong> button on the login form to check whether the credentials are in the database. Otherwise, the app has <strong class="source-inline">/ch07/signup/add</strong> and <strong class="source-inline">/ch07/approve/signup</strong> to add the user credentials you want to test. Remember that all stored passwords are encrypted. <em class="italic">Figure 7.2</em> shows how <strong class="source-inline">/ch07/login</strong> will output the user’s <strong class="source-inline">Login</strong> record after the authentication process finds that the user credentials are valid:</p>
			<div>
				<div id="_idContainer042" class="IMG---Figure">
					<img src="image/Figure_7.02_B17975.jpg" alt="Figure 7.2 – The /login response&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.2 – The /login response</p>
			<p>Now that the user is authenticated, run <strong class="source-inline">/ch07/login/users/list</strong> through the OpenAPI dashboard to retrieve the list of login details. The <strong class="source-inline">uvicorn</strong> server log will show the following log message:</p>
			<p class="source-code">INFO: 127.0.0.1:53150 - "GET /ch07/login/users/list HTTP/1.1" 200 OK</p>
			<p>This means <a id="_idIndexMarker547"/>that the user is authorized to run the endpoint. Now, let us apply the Digest authentication scheme to our prototype.</p>
			<h2 id="_idParaDest-192"><a id="_idTextAnchor195"/>Using Digest authentication</h2>
			<p>Digest authentication<a id="_idIndexMarker548"/> is more secure than the Basic scheme because the former needs to hash the user credentials first before sending the hashed version to the application. Digest authentication in FastAPI does not include an automatic encryption process of user credentials using the default <em class="italic">MD5</em> encryption. It is an authentication scheme that stores credentials in a <strong class="source-inline">.env</strong> or <strong class="source-inline">.config</strong> property file and creates a hashed string value for these credentials before the authentication. The <strong class="source-inline">ch07b</strong> project applies the Digest authentication scheme to secure the bidding and auctioning transactions.</p>
			<h3>Generating the hashed credentials</h3>
			<p>So, before we start the<a id="_idIndexMarker549"/> implementation, we first need to create a custom utility script, <strong class="source-inline">generate_hash.py</strong>, that generates a digest in binary form using Base64 encoding. The script must have the following code:</p>
			<pre class="source-code">
<strong class="bold">from base64 import urls<a id="_idTextAnchor196"/>afe_b64encode</strong>
h = urlsafe_b64encode(b"sjctrags:sjctrags")</pre>
			<p>The <strong class="source-inline">urlsafe_b64encode()</strong> function from the <strong class="source-inline">base64</strong> module creates a digest in binary format from the <strong class="source-inline">username:password</strong> credential format. After running the script, we save the digest value anywhere safe, but not in the source code. </p>
			<h3>Passing the user credentials</h3>
			<p>Aside <a id="_idIndexMarker550"/>from the digest, we also need to save the user credentials for the Digest scheme provider later. Unlike the standard Digest authentication procedure, where the user negotiates with the browser, FastAPI requires storing the user credentials in a<strong class="source-inline">.env</strong> or <strong class="source-inline">.config</strong> file inside our application to be retrieved by the authentication process. In the <strong class="source-inline">ch07b</strong> project, we save the username and password inside the <strong class="source-inline">.config</strong> file, in this manner:</p>
			<pre class="source-code">
[CREDENTIALS]
USERNAME=sjctrags
PASSWORD=sjctrags</pre>
			<p>Then, we create a parser through the <strong class="source-inline">ConfigParser</strong> utility to extract the following details from the <strong class="source-inline">.config</strong> file and build a <strong class="source-inline">dict</strong> out of the serialized user details. The following <strong class="source-inline">build_map()</strong> is an example of the parser implementation:</p>
			<pre class="source-code">
import os
<strong class="bold">from configparser import ConfigParser</strong>
def build_map():
    <strong class="bold">env = os.getenv("ENV", ".config")</strong>
    if env == ".config":
        <strong class="bold">config = ConfigParser()</strong>
        <strong class="bold">config.read(".config")</strong>
        <strong class="bold">config = config["CREDENTIALS"]</strong>
    else:
        config = {
            "USERNAME": os.getenv("USERNAME", "guest"),
            "PASSWORD": os.getenv("PASSWORD", "guest"),
        }
    return config</pre>
			<h3>Using HTTPDigest and HTTPAuthorizationCredentials</h3>
			<p>The FastAPI<a id="_idIndexMarker551"/> framework has an <strong class="source-inline">HTTPDigest</strong> from its <strong class="source-inline">fastapi.security</strong> module that implements a Digest authentication <a id="_idIndexMarker552"/>scheme with a different approach to managing user credentials and generating the digest. Unlike in Basic authentication, the <strong class="source-inline">HTTPDigest</strong> authentication process happens at the <strong class="source-inline">APIRouter</strong> level. We inject the following <strong class="source-inline">authenticate()</strong>dependable into the API services through the HTTP operator, including <strong class="source-inline">/login</strong>, where the authentication starts:</p>
			<pre class="source-code">
from fastapi import Security, HTTPException, status
<strong class="bold">from fastapi.security import HTTPAuthorizationCredentials</strong>
<strong class="bold">from fastapi.security import HTTPDigest</strong>
from secrets import compare_digest
<strong class="bold">from base64 import standard_b64encode</strong>
<strong class="bold">http_digest = HTTPDigest()</strong>
def authenticate(credentials: 
    HTTPAuthorizationCredentials = Security(http_digest)):
    
    <strong class="bold">hashed_credentials = credentials.credentials</strong>
    <strong class="bold">config = build_map()</strong>
    <strong class="bold">expected_credentials = standard_b64encode(</strong>
        <strong class="bold">bytes(f"{config['USERNAME']}:{config['PASSWORD']}",</strong>
           <strong class="bold">encoding="UTF-8")</strong>
    <strong class="bold">)</strong>
    is_credentials = compare_digest(
          bytes(hashed_credentials, encoding="UTF-8"),
               expected_credentials)
    
    if not is_credentials:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect digest token",
            headers={"WWW-Authenticate": "Digest"},
        )</pre>
			<p>The <strong class="source-inline">authenticate()</strong> method<a id="_idIndexMarker553"/> is where the <strong class="source-inline">http_digest</strong> is<a id="_idIndexMarker554"/> injected to extract the <strong class="source-inline">HTTPAuthorizationCredentials</strong> that contains the digest byte value. After extraction, it checks whether the digest matches the credentials saved in the <strong class="source-inline">.config</strong> file. We also use <strong class="source-inline">compare_digest</strong> to compare <strong class="source-inline">hashed_credentials</strong> from the header and the Base64-encoded credentials from the <strong class="source-inline">.config</strong> file. </p>
			<h3>Executing the login transaction</h3>
			<p>After<a id="_idIndexMarker555"/> implementing the <strong class="source-inline">authenticate()</strong> method, we inject it into the API services, not in the method parameter, but in its HTTP operator. Notice that the <strong class="source-inline">http_digest</strong> object is not injected directly into the API services, unlike in the <em class="italic">Basic</em> authentication scheme. The following implementation shows how the <strong class="source-inline">authenticate()</strong> dependable is applied to secure all the crucial endpoints of the application:</p>
			<pre class="source-code">
from security.secure import authenticate
<strong class="bold">@router.get("/login", dependencies=[Depends(authenticate)])</strong>
def login(sess:Session = Depends(sess_db)):
    return {"success": "true"}
        
<strong class="bold">@router.get("/login/users/list",   </strong>
      <strong class="bold">dependencies=[Depends(authenticate)])</strong>
def list_all_login(sess:Session = Depends(sess_db)):
    loginrepo = LoginRepository(sess)
    users = loginrepo.get_all_login()
    return jsonable_encoder(users)</pre>
			<p>Since the<a id="_idIndexMarker556"/> Digest authentication scheme behaves like the <em class="italic">OpenID authentication</em>, we will be using the <strong class="source-inline">curl</strong> command to run <strong class="source-inline">/ch07/login</strong>. The crucial part of the command is the issuance of the <strong class="source-inline">Authorization</strong> header with the value containing the Base64-encoded <strong class="source-inline">username:password</strong> digest generated by the <strong class="source-inline">generate_hash.py</strong> script we executed beforehand. The following <strong class="source-inline">curl</strong> command is the correct way of logging into our FastAPI application that uses the Digest authentication scheme:</p>
			<p class="source-code">curl --request GET --url http://localhost:8000/ch07/login --header "accept: application/json"                  --header "Authorization: Digest c2pjdHJhZ3M6c2pjdHJhZ3M=" --header "Content-Type: application/json"</p>
			<p>We also use the same command to run the rest of the secured API services.</p>
			<p>Most enterprise applications nowadays seldom use Basic and Digest authentication schemes because of their vulnerability to many attacks. More than that, both authentication schemes require sending credentials to the secured API services, which is also another risk. Moreover, at the time of writing, FastAPI does not yet fully support the standard <a id="_idIndexMarker557"/>Digest authentication, which is also a disadvantage to other applications that need the standard one. So, let us now explore the solution to secure API endpoints using the <em class="italic">OAuth 2.0 specification</em>.</p>
			<h1 id="_idParaDest-193"><a id="_idTextAnchor197"/>Implementing password-based authentication</h1>
			<p>The <em class="italic">OAuth 2.0 specification</em>, or OAuth2, is the<a id="_idIndexMarker558"/> most preferred solution for authenticating API endpoint access. The OAuth2 authorization framework defines the four <a id="_idIndexMarker559"/>authorization flows, which are <em class="italic">implicit</em>, <em class="italic">client credentials</em>, <em class="italic">authorization code</em>, and <em class="italic">resource password flows</em>. The first three of these can be used with third-party authentication providers, which will authorize the access of the API endpoints. In the FastAPI platform, the resource password flow can be customized and implemented within the application to carry out the authentication procedure. Let us now explore how FastAPI supports the OAuth2 specification.</p>
			<h2 id="_idParaDest-194"><a id="_idTextAnchor198"/>Installing the python-multipart module</h2>
			<p>Since OAuth2 <a id="_idIndexMarker560"/>authentication will not be possible without a form handling procedure, we need to install the <strong class="source-inline">python-multipart</strong> module before pursuing the implementation part. We can run the following command to install the extension:</p>
			<p class="source-code">pip install python-multipart</p>
			<h2 id="_idParaDest-195"><a id="_idTextAnchor199"/>Using OAuth2PasswordBearer and OAuth2PasswordRequestForm</h2>
			<p>The FastAPI<a id="_idIndexMarker561"/> framework fully <a id="_idIndexMarker562"/>supports OAuth2, especially the password flow type of the OAuth2 specification. Its <strong class="source-inline">fastapi.security</strong> module has an <strong class="source-inline">OAuth2PasswordBearer</strong> that serves as the provider for password-based authentication. It also has <strong class="source-inline">OAuth2PasswordRequestForm</strong>, which can declare a form body with required parameters, <strong class="source-inline">username</strong> and <strong class="source-inline">password</strong>, and some optional ones such as <strong class="source-inline">scope</strong>, <strong class="source-inline">grant_type</strong>, <strong class="source-inline">client_id</strong>, and <strong class="source-inline">client_secret</strong>. This class is directly injected into the <strong class="source-inline">/ch07/login</strong> API endpoint to extract all the parameter values from the browser’s login form. But it is always an option to use <strong class="source-inline">Form(…)</strong> to capture all the individual parameters.</p>
			<p>So, let us start the solution by creating the <strong class="source-inline">OAuth2PasswordBearer</strong> to be injected into a custom function dependency that will validate the user credentials. The following implementation shows that <strong class="source-inline">get_current_user()</strong> is the injectable function in our new application, <strong class="source-inline">ch07c</strong>, which utilizes the <strong class="source-inline">oath2_scheme</strong> injectable to extract a <strong class="source-inline">token</strong>:</p>
			<pre class="source-code">
<strong class="bold">from fastapi.security import OAuth2PasswordBearer</strong>
from sqlalchemy.orm import Session
from repository.login import LoginRepository
from db_config.sqlalchemy_connect import sess_db
<strong class="bold">oauth2_scheme = </strong>
    <strong class="bold">OAuth2PasswordBearer(tokenUrl="ch07/login/token")</strong>
def get_current_user(token: str = Depends(oauth2_scheme), 
           sess:Session = Depends(sess_db) ):
    loginrepo = LoginRepository(sess)
    <strong class="bold">user = loginrepo.get_all_login_username(token)</strong>
    if user == None:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid authentication credentials",
            headers={"WWW-Authenticate": "Bearer"},
        )
    return user</pre>
			<p>For the <a id="_idIndexMarker563"/>resource password <a id="_idIndexMarker564"/>flow, injecting <strong class="source-inline">oauth2_scheme</strong> will return a <strong class="source-inline">username</strong> as a token. <strong class="source-inline">get_current_user()</strong> will check whether that username belongs to a valid user account stored in the database. </p>
			<h2 id="_idParaDest-196"><a id="_idTextAnchor200"/>Executing the login transaction</h2>
			<p>In this<a id="_idIndexMarker565"/> authentication scheme, <strong class="source-inline">/ch07/login/token</strong> is also the <strong class="source-inline">tokenUrl</strong> parameter of <strong class="source-inline">OAuth2PasswordBearer</strong>. The <strong class="source-inline">tokenUrl</strong> parameter is required for password-based OAuth2 authentication because this is the endpoint service that will capture the user credentials from the browser’s login form. <strong class="source-inline">OAuth2PasswordRequestForm</strong> is injected into <strong class="source-inline">/cho07/login/token</strong> to retrieve the <strong class="source-inline">username</strong>, <strong class="source-inline">password</strong>, and <strong class="source-inline">grant_type</strong> parameters of the unauthenticated user. These three parameters are the essential requirements to invoke <strong class="source-inline">/ch07/login/token</strong> for <em class="italic">token</em> generation. This dependency is shown in the following implementation of the login API service:</p>
			<pre class="source-code">
from sqlalchemy.orm import Session
from db_config.sqlalchemy_connect import sess_db
from repository.login import LoginRepository
from fastapi.security import OAuth2PasswordRequestForm
from security.secure import get_current_user, authenticate
<strong class="bold">@router.post("/login/token")</strong>
def login(form_data: OAuth2PasswordRequestForm = Depends(),
             sess:Session = Depends(sess_db)):
    <strong class="bold">username = form_data.username</strong>
    <strong class="bold">password = form_data.password</strong>
    loginrepo = LoginRepository(sess)
    <strong class="bold">account = loginrepo.get_all_login_username(username)</strong>
    if authenticate(username, password, account) and 
              not account == None:
        return {"access_token": form_data.username, 
                  "token_type": "bearer"}
    else:
        raise HTTPException(
            status_code=400, 
               detail="Incorrect username or password")</pre>
			<p>Aside from verifying from the database, the <strong class="source-inline">login()</strong> service will also check whether the <strong class="source-inline">password</strong> value matches the encrypted passphrase from the queried <strong class="source-inline">account</strong>. If all the verification succeeds,  <strong class="source-inline">/ch07/login/token</strong> must return a JSON object with the required properties, <strong class="source-inline">access_token</strong> and <strong class="source-inline">token_type</strong>. The <strong class="source-inline">access_token</strong> property must have the <strong class="source-inline">username</strong> value, and <strong class="source-inline">token_type</strong> the <strong class="source-inline">"bearer"</strong> value.</p>
			<p>Instead of creating<a id="_idIndexMarker566"/> a custom frontend for the login form, we will be utilizing the OAuth2 form provided by OpenAPI in the framework. We just click the <strong class="bold">Authorize</strong> button on the upper-right-hand side of the OpenAPI dashboard, as shown in <em class="italic">Figure 7.3</em>:</p>
			<div>
				<div id="_idContainer043" class="IMG---Figure">
					<img src="image/Figure_7.03_B17975.jpg" alt="Figure 7.3 – The Authorize button&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.3 – The Authorize button</p>
			<p>The button will trigger a built-in login form to pop up, shown in <em class="italic">Figure 7.4</em>, which we can use to test our solution:</p>
			<div>
				<div id="_idContainer044" class="IMG---Figure">
					<img src="image/Figure_7.04_B17975.jpg" alt="Figure 7.4 – The OAuth2 login form&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.4 – The OAuth2 login form</p>
			<p>Everything is fine if the<a id="_idIndexMarker567"/> OAuth2 login form detects the correct <strong class="source-inline">tokenURL</strong> specified in the <strong class="source-inline">OAuth2PasswordBearer</strong> instantiation. The OAuth2 flow or <strong class="source-inline">grant_type</strong> indicated in the login form must be <strong class="source-inline">"password"</strong>. After logging the verified credential, the form’s <strong class="bold">Authorize</strong> button will redirect the user to an authorization form, shown in <em class="italic">Figure 7.5</em>, which will prompt the user to log out or proceed with the authenticated access:</p>
			<div>
				<div id="_idContainer045" class="IMG---Figure">
					<img src="image/Figure_7.05_B17975.jpg" alt="Figure 7.5 – The authorization form"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.5 – The authorization form</p>
			<p>Generally, the <a id="_idIndexMarker568"/>OAuth2 specification recognizes two client or application types: <em class="italic">confidential</em> and <em class="italic">public</em> clients. The confidential clients utilize authentication servers for security, such as in this <em class="italic">online auction system</em> that uses the FastAPI server through the OpenAPI platform. In its setup, it is not mandatory to provide the <strong class="source-inline">client_id</strong> and <strong class="source-inline">client_secret</strong> values to the login form since the server will generate these parameters during the authentication process. But unfortunately, these values are not revealed to the client, as shown in <em class="italic">Figure 7.5</em>. On the other hand, the public clients do not have any means to generate and use client secrets as in typical web-based and mobile applications. Therefore, these applications must include <strong class="source-inline">client_id</strong>, <strong class="source-inline">client_secret</strong>, and other required parameters during login.</p>
			<h2 id="_idParaDest-197"><a id="_idTextAnchor201"/>Securing the endpoints</h2>
			<p>To secure the<a id="_idIndexMarker569"/> API endpoints, we need to inject the <strong class="source-inline">get_current_user()</strong> method into each API service method. The following is an implementation of a secured <strong class="source-inline">add_auction()</strong> service that utilizes the <strong class="source-inline">get_current_user()</strong> method:</p>
			<pre class="source-code">
<strong class="bold">@router.post("/auctions/add")</strong>
def add_auction(req: AuctionsReq, 
      current_user: Login = Depends(get_current_user), 
      sess:Session = Depends(sess_db)): 
    auc_dict = req.dict(exclude_unset=True)
    repo:AuctionsRepository = AuctionsRepository(sess)
    auction = Auctions(**auc_dict)
    result = repo.insert_auction(auction)
    if result == True:
        return auction
    else: 
        return JSONResponse(content=
         {'message':'create auction problem encountered'}, 
            status_code=500)  </pre>
			<p>The <strong class="source-inline">get_current_user()</strong> injectable will return a valid <strong class="source-inline">Login</strong> account if the access is allowed. Moreover, you will notice that all padlock icons of the secured API endpoints that include <strong class="source-inline">/ch07/auctions/add</strong>, shown in <em class="italic">Figure 7.6</em>, are closed. This indicates that <a id="_idIndexMarker570"/>they are ready to be executed since the user is already an authenticated one:</p>
			<div>
				<div id="_idContainer046" class="IMG---Figure">
					<img src="image/Figure_7.06_B17975.jpg" alt="Figure 7.6 – An OpenAPI dashboard showing secured APIs&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.6 – An OpenAPI dashboard showing secured APIs</p>
			<p>This solution is a<a id="_idIndexMarker571"/> problem for an open network setup, for instance, because the token used is a password. This setup allows attackers to easily forge or modify the token during its transmission from the issuer to the client. One way to protect the<a id="_idIndexMarker572"/> token is to use a <strong class="bold">JSON Web Token</strong> (<strong class="bold">JWT</strong>). </p>
			<h1 id="_idParaDest-198"><a id="_idTextAnchor202"/>Applying JWTs</h1>
			<p>JWT is an <a id="_idIndexMarker573"/>open source standard used to define a solution for sending any information during the authentication and authorization between issuers and clients. Its goal is to generate <strong class="source-inline">access_token</strong> properties that are digitally signed, URL-safe, and always verifiable by the client. However, it is not perfectly safe because anyone can decode the token if needed. Thus, it is advisable not to include all the valuable and confidential information in the token string. A JWT is an effective way of providing OAuth2 and OpenID specifications with more reliable tokens than passwords.</p>
			<h2 id="_idParaDest-199"><a id="_idTextAnchor203"/>Generating the secret key</h2>
			<p>But before we start building <a id="_idIndexMarker574"/>the authentication scheme, we first need to generate a <em class="italic">secret key</em>, which is an essential element in creating the <em class="italic">signature</em>. The JWT has a <strong class="bold">JSON Object Signing and Encryption (JOSE</strong>) <em class="italic">header</em>, which is<a id="_idIndexMarker575"/> the metadata that describes which algorithm to use for plain-text encoding, while the <em class="italic">payload</em> is the <a id="_idIndexMarker576"/>data we need to encode into the token. When the client requests to log in, the authorization server signs a JWT using a <em class="italic">signature</em>. But the signature will only be generated by the algorithm indicated in the header, which will take the header, payload, and secret key as inputs. This <em class="italic">secret key</em> is a<a id="_idIndexMarker577"/> Base64-encoded string manually created outside of the server and should be stored separately within the authorization server. <strong class="source-inline">ssh</strong> or <strong class="source-inline">openssl</strong> is the appropriate utility to generate this long and randomized key. Here, in <strong class="source-inline">ch07d</strong>, we run the following <strong class="source-inline">openssl</strong> command from a GIT tool or any SSL generator to create the key:</p>
			<p class="source-code">openssl rand -hex 32</p>
			<h2 id="_idParaDest-200"><a id="_idTextAnchor204"/>Creating the access_token</h2>
			<p>In the <strong class="source-inline">ch07d</strong> project, we <a id="_idIndexMarker578"/>will store the <em class="italic">secret key</em> and <em class="italic">algorithm type</em> in some reference variables in its <strong class="source-inline">/security/secure.py</strong> module script. These variables are used by the JWT-encoding procedure to generate the token, as shown in the following code:</p>
			<pre class="source-code">
<strong class="bold">from jose import jwt, JWTError</strong>
from datetime import datetime, timedelta
<strong class="bold">SECRET_KEY = "tbWivbkVxfsuTxCP8A+Xg67LcmjXXl/sszHXwH+TX9w="</strong>
<strong class="bold">ALGORITHM = "HS256"</strong>
ACCESS_TOKEN_EXPIRE_MINUTES = 30
def create_access_token(data: dict, 
           expires_after: timedelta):
    plain_text = data.copy()
    expire = datetime.utcnow() + expires_after
    plain_text.update({"exp": expire})
    <strong class="bold">encoded_jwt = jwt.encode(plain_text, SECRET_KEY, </strong>
            <strong class="bold">algorithm=ALGORITHM)</strong>
    return encoded_jwt</pre>
			<p>Within the JWT Python extension, we chose the <strong class="source-inline">python-jose</strong> module to generate the token because it is reliable and has additional cryptographic functions that can sign complex data content. Install this module first using the <strong class="source-inline">pip</strong> command before using it. </p>
			<p>So now, the <strong class="source-inline">/ch07/login/token</strong> endpoint will invoke the <strong class="source-inline">create_access_token()</strong> method to request the JWT. The <em class="italic">login</em> service will provide the data, usually <strong class="source-inline">username</strong>, to comprise the payload portion of the token. Since the JWT must be short-lived, the process must update the <strong class="source-inline">expire</strong> portion of the payload to some <strong class="source-inline">datetime</strong> value in minutes or seconds suited to the application. </p>
			<h2 id="_idParaDest-201"><a id="_idTextAnchor205"/>Creating the login transaction</h2>
			<p>The implementation <a id="_idIndexMarker579"/>of the <em class="italic">login</em> service is similar to the previous password-based OAuth2 authentication, except that this version has a <strong class="source-inline">create_access_token()</strong> call for the JWT generation to replace the password credential. The following script shows the <strong class="source-inline">/ch07/login/token</strong> service of the <strong class="source-inline">ch07d</strong> project:</p>
			<pre class="source-code">
@router.post("/login/token")
def login(form_data: OAuth2PasswordRequestForm = Depends(),
          sess:Session = Depends(sess_db)):
    username = form_data.username
    password = form_data.password
    loginrepo = LoginRepository(sess)
    account = loginrepo.get_all_login_username(username)
    if authenticate(username, password, account):
        <strong class="bold">access_token = create_access_token(</strong>
          <strong class="bold">data={"sub": username}, </strong>
           <strong class="bold">expires_after=timedelta(</strong>
              <strong class="bold">minutes=ACCESS_TOKEN_EXPIRE_MINUTES))</strong>
        <strong class="bold">return {"access_token": access_token, </strong>
             <strong class="bold">"token_type": "bearer"}</strong>
    else:
        raise HTTPException(
            status_code=400, 
            detail="Incorrect username or password")</pre>
			<p>The endpoint should still return <strong class="source-inline">access_token</strong> and <strong class="source-inline">token_type</strong> since this is still a password-based<a id="_idIndexMarker580"/> OAuth2 authentication, which retrieves the user credentials from <strong class="source-inline">OAuth2PasswordRequestForm</strong>. </p>
			<h2 id="_idParaDest-202"><a id="_idTextAnchor206"/>Accessing the secured endpoints</h2>
			<p>As with the previous<a id="_idIndexMarker581"/> OAuth2 schemes, we need to inject <strong class="source-inline">get_current_user()</strong>into every API service to impose security and restrict access. The injected <strong class="source-inline">OAuthPasswordBearer</strong> instance will return the JWT for payload extraction using the JOSE decoders with the specified decoding algorithm. If the token is tampered with, modified, or expired, the method will throw an change to - exception. Otherwise, we need to continue the payload data extraction, retrieve the username, and store that in an <strong class="source-inline">@dataclass</strong> instance, such as <strong class="source-inline">TokenData</strong>. Then, the username will undergo further verification, such as checking the database for a <strong class="source-inline">Login</strong> account with that username. The following snippet shows this decoding process, found in the <strong class="source-inline">/security/secure.py</strong> module of the <strong class="source-inline">ch07d</strong> project:</p>
			<pre class="source-code">
<strong class="bold">from models.request.tokens import TokenData</strong>
<strong class="bold">from fastapi.security import OAuth2PasswordBearer</strong>
from jose import jwt, JWTError
from models.data.sqlalchemy_models import Login
from sqlalchemy.orm import Session
from db_config.sqlalchemy_connect import sess_db
from repository.login import LoginRepository
from datetime import datetime, timedelta
<strong class="bold">oauth2_scheme = </strong>
     <strong class="bold">OAuth2PasswordBearer(tokenUrl="ch07/login/token")</strong>
def get_current_user(token: str = Depends(oauth2_scheme),
    sess:Session = Depends(sess_db)):
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"}
    )
    try:
        <strong class="bold">payload = jwt.decode(token, SECRET_KEY, </strong>
           <strong class="bold">algorithms=[ALGORITHM])</strong>
        <strong class="bold">username: str = payload.get("sub")</strong>
        if username is None:
            raise credentials_exception
        <strong class="bold">token_data = TokenData(username=username)</strong>
    except JWTError:
        raise credentials_exception
    
    loginrepo = LoginRepository(sess)
    user = 
      <strong class="bold">loginrepo.get_all_login_username(token_data.username)</strong>
    if user is None:
        raise credentials_exception
    return user</pre>
			<p><strong class="source-inline">get_current_user()</strong> must be injected into each service implementation to restrict <a id="_idIndexMarker582"/>access from users. But this time, the method will not only verify the credentials but also perform <em class="italic">JWT payload decoding</em>. The next step is adding <em class="italic">user authorization </em>to the OAuth2 solution.</p>
			<h1 id="_idParaDest-203"><a id="_idTextAnchor207"/>Creating scope-based authorization</h1>
			<p>FastAPI fully<a id="_idIndexMarker583"/> supports <em class="italic">scope-based authentication</em>, which uses the <strong class="source-inline">scopes</strong> parameter of the OAuth2 protocol to specify which endpoints are accessible to a group of users. A <strong class="source-inline">scopes</strong> parameter is a kind of permission placed in a token to provide additional fine-grained restrictions to users. In this version of the project, <strong class="source-inline">ch07e</strong>, we will be showcasing OAuth2 password-based authentication with user authorization. </p>
			<h2 id="_idParaDest-204"><a id="_idTextAnchor208"/>Customizing the OAuth2 class</h2>
			<p>First, we need to <a id="_idIndexMarker584"/>create a custom class that inherits the properties of the <strong class="source-inline">OAuth2</strong> API class from the <strong class="source-inline">fastapi.security</strong> module to include the <strong class="source-inline">scopes</strong> parameter or "role" options in the user credentials. The following is the <strong class="source-inline">OAuth2PasswordBearerScopes</strong> class, a custom OAuth2 class that will implement the authentication flow with authorization:</p>
			<pre class="source-code">
<strong class="bold">class OAuth2PasswordBearerScopes(OAuth2):</strong>
    def __init__(
        self,
        tokenUrl: str,
        scheme_name: str = None,
        <strong class="bold">scopes: dict = None,</strong>
        auto_error: bool = True,
        
    ):
    if not scopes:
         scopes = {}
    <strong class="bold">flows = OAuthFlowsModel(</strong>
       <strong class="bold">password={"tokenUrl": tokenUrl, "scopes": scopes})</strong>
    super().__init__(<strong class="bold">flows=flows</strong>, 
       <strong class="bold">scheme_name=scheme_name</strong>, auto_error=auto_error)
    async def __call__(self, request: Request) -&gt; 
             Optional[str]:
        <strong class="bold">header_authorization: str = </strong>
              <strong class="bold">request.headers.get("Authorization")</strong>
        … … … … … …
        return param</pre>
			<p>This <strong class="source-inline">OAuth2PasswordBearerScopes</strong> class requires two constructor parameters, <strong class="source-inline">tokenUrl</strong> and <strong class="source-inline">scopes</strong>, to <a id="_idIndexMarker585"/>pursue an auth flow. <strong class="source-inline">OAuthFlowsModel</strong> defines the <strong class="source-inline">scopes</strong> parameter as part of the user credentials for authentication using the <strong class="source-inline">Authorization</strong> header.</p>
			<h2 id="_idParaDest-205"><a id="_idTextAnchor209"/>Building the permission dictionary</h2>
			<p>Before we proceed with the <a id="_idIndexMarker586"/>auth implementation, we need to first build the <strong class="source-inline">scopes</strong> parameters that the OAuth2 scheme will be applying during authentication. This setup is part of the <strong class="source-inline">OAuth2PasswordBearerScopes</strong> instantiation, where we assign these parameters to its <strong class="source-inline">scopes</strong> parameter. The following script shows how all the custom-defined user scopes are saved in a <em class="italic">dictionary</em>, with the <em class="italic">keys</em> as the scope names and the <em class="italic">values</em> as their corresponding descriptions:</p>
			<pre class="source-code">
oauth2_scheme = <strong class="bold">OAuth2PasswordBearerScopes</strong>(
    tokenUrl="/ch07/login/token",
    <strong class="bold">scopes={"admin_read": </strong>
              <strong class="bold">"admin role that has read only role",</strong>
            <strong class="bold">"admin_write":</strong>
              <strong class="bold">"admin role that has write only role",</strong>
            <strong class="bold">"bidder_read":</strong>
              <strong class="bold">"customer role that has read only role",</strong>
            <strong class="bold">"bidder_write":</strong>
              <strong class="bold">"customer role that has write only role",</strong>
            <strong class="bold">"auction_read":</strong>
              <strong class="bold">"buyer role that has read only role",</strong>
            <strong class="bold">"auction_write":</strong>
              <strong class="bold">"buyer role that has write only role",</strong>
            <strong class="bold">"user":"valid user of the application",</strong>
            <strong class="bold">"guest":"visitor of the site"},</strong>
)</pre>
			<p>There is no<a id="_idIndexMarker587"/> feasible way to directly connect the <strong class="source-inline">OAuth2PasswordBearerScopes</strong> class to the database for the dynamic lookup of permission sets during the implementation of this project. The only solution is to statically store all these authorization "roles" directly into the constructor of  <strong class="source-inline">OAuth2PasswordBearerScopes</strong>.</p>
			<h2 id="_idParaDest-206"><a id="_idTextAnchor210"/>Implementing the login transaction</h2>
			<p>All the scopes will be <a id="_idIndexMarker588"/>added to the OAuth2 form login as an option and will be part of the user’s login credentials. The following implementation of <strong class="source-inline">/ch07/login/token</strong> in this new <strong class="source-inline">ch07e</strong> project shows how to retrieve the scope parameter(s) and the credentials from <strong class="source-inline">OAuth2PasswordRequestForm</strong>:</p>
			<pre class="source-code">
@router.post("/login/token")
def login(form_data: OAuth2PasswordRequestForm = Depends(),
         sess:Session = Depends(sess_db)):
    username = form_data.username
    password = form_data.password
    loginrepo = LoginRepository(sess)
    account = loginrepo.get_all_login_username(username)
    if authenticate(username, password, account):
        access_token = create_access_token(
            data={"sub": username, "scopes": 
              form_data.scopes},  
               expires_delta=timedelta(
               minutes=ACCESS_TOKEN_EXPIRE_MINUTES))
        return {"access_token": access_token, 
                "token_type": "bearer"}
    else:
        raise HTTPException(
            status_code=400, 
            detail="Incorrect username or password")</pre>
			<p>The selected <a id="_idIndexMarker589"/>scopes are stored in a list, such as <strong class="source-inline">['user', 'admin_read', 'admin_write', 'bidder_write']</strong>, which means that a user has <em class="italic">user</em>, <em class="italic">administrator (write)</em>, <em class="italic">administrator (read)</em>, and <em class="italic">bidder (write)</em> permissions. <strong class="source-inline">create_access_token()</strong> will include this list of scopes or "roles" as part of the <em class="italic">payload</em>, which will be decoded and extracted by <strong class="source-inline">get_current_valid_user()</strong> through the <strong class="source-inline">get_current_user()</strong> injectable. By the way, <strong class="source-inline">get_current_valid_user()</strong> secures every API from the user access by <a id="_idIndexMarker590"/>applying the authentication scheme.</p>
			<h2 id="_idParaDest-207"><a id="_idTextAnchor211"/>Applying the scopes to endpoints</h2>
			<p>The <strong class="source-inline">Security</strong> API<a id="_idIndexMarker591"/> from the <strong class="source-inline">fastapi</strong> module replaces the <strong class="source-inline">Depends</strong> class in injecting the <strong class="source-inline">get_current_valid_user()</strong> because of its capability to assign scopes to each API service, aside from its capability to perform DI. It has the <strong class="source-inline">scopes</strong> attribute, where a list of valid scope parameters is defined that restricts the user from access. For instance, the following <strong class="source-inline">update_profile()</strong> service is accessible only to users whose scopes contain the <strong class="source-inline">bidder_write</strong> and <strong class="source-inline">buyer_write</strong> roles:   </p>
			<pre class="source-code">
<strong class="bold">from fastapi.security import SecurityScopes</strong>
<strong class="bold">@router.patch("/profile/update")</strong>
def update_profile(id:int, req: ProfileReq, 
    <strong class="bold">current_user: Login = Security(get_current_valid_user, </strong>
        scopes=["bidder_write", "buyer_write"]), 
    sess:Session = Depends(sess_db)): 
    … … … … … …
    if result: 
        return JSONResponse(content=
         {'message':'profile updated successfully'}, 
              status_code=201)
    else: 
        return JSONResponse(content=
           {'message':'update profile error'}, 
               status_code=500)</pre>
			<p>Now, the following code snippet shows the implementation of the <strong class="source-inline">get_current_valid_user()</strong> injected into every API service by <strong class="source-inline">Security</strong>:</p>
			<pre class="source-code">
def get_current_valid_user(current_user: 
   Login = Security(get_current_user, scopes=["user"])):
    if current_user == None:
        raise HTTPException(status_code=400, 
           detail="Invalid user")
    return current_user</pre>
			<p>This method <a id="_idIndexMarker592"/>relies on <strong class="source-inline">get_current_user()</strong> when it comes to JWT payload decoding, credential validation, and user scope verification. The user must at least have the <strong class="source-inline">user</strong> scope for the authorization process to proceed. The <strong class="source-inline">Security</strong> class is responsible for injecting <strong class="source-inline">get_current_user()</strong> into <strong class="source-inline">get_current_valid_user()</strong> together with the default <strong class="source-inline">user</strong> scope. Here is the implementation of the <strong class="source-inline">get_current_user()</strong> method:</p>
			<pre class="source-code">
def get_current_user(security_scopes: SecurityScopes, 
      token: str = Depends(oauth2_scheme), 
           sess:Session = Depends(sess_db)):
    <strong class="bold">if security_scopes.scopes:</strong>
        <strong class="bold">authenticate_value = </strong>
          <strong class="bold">f'Bearer scope="{security_scopes.scope_str}"'</strong>
    else:
        authenticate_value = f"Bearer" 
    … … … … … …
    try:
        payload = jwt.decode(token, SECRET_KEY, 
                   algorithms=[ALGORITHM])
        username: str = payload.get("sub")
        if username is None:
            raise credentials_exception
        <strong class="bold">token_scopes = payload.get("scopes", [])</strong>
        <strong class="bold">token_data = TokenData(scopes=token_scopes, </strong>
               <strong class="bold">username=username)</strong>
    except JWTError:
        raise credentials_exception
    … … … … … …
    <strong class="bold">for scope in security_scopes.scopes:</strong>
        <strong class="bold">if scope not in token_data.scopes:</strong>
            <strong class="bold">raise HTTPException(</strong>
                <strong class="bold">status_code=status.HTTP_401_UNAUTHORIZED,</strong>
                <strong class="bold">detail="Not enough permissions",</strong>
                <strong class="bold">headers={"WWW-Authenticate": </strong>
                    <strong class="bold">authenticate_value},</strong>
            <strong class="bold">)</strong>
    return user</pre>
			<p>The <strong class="source-inline">SecurityScopes</strong> class of the given <strong class="source-inline">get_current_user()</strong> extracts the scopes assigned to the API service that the user is trying to access. It has a <strong class="source-inline">scope</strong> instance variable<a id="_idIndexMarker593"/> that contains all these scope parameters of the API. On the other hand, <strong class="source-inline">token_scopes</strong> carries all the scopes or "roles" of the user extracted from the decoded JWT payload. <strong class="source-inline">get_current_user()</strong> traverses the API scopes in <strong class="source-inline">SecurityScopes</strong> to check whether all of them appear in the <strong class="source-inline">token_scopes</strong> of the user. If <strong class="source-inline">True</strong>, <strong class="source-inline">get_current_user()</strong> authenticates and authorizes the user to access the API service. Otherwise, it throws an change to - exception. The purpose of <strong class="source-inline">TokenData</strong> is to manage the scope parameters from the <strong class="source-inline">token_scopes</strong> payload value and the username. </p>
			<p>The next type of OAuth2 authentication scheme that FastAPI can support is the authorization code flow approach.</p>
			<h1 id="_idParaDest-208"><a id="_idTextAnchor212"/>Building the authorization code flow</h1>
			<p>If the application is<a id="_idIndexMarker594"/> a <em class="italic">public</em> type and there is no authorization server to process the <strong class="source-inline">client_id</strong> parameter, the <strong class="source-inline">client_secret</strong> parameter, and other related parameters, this OAuth2 authorization code flow approach is appropriate to use. In this scheme, the client creates an authorization request for a short-lived <em class="italic">authorization code</em> from an <strong class="source-inline">authorizationUrl</strong>. The client will then ask for the token from <strong class="source-inline">tokenUrl</strong> in exchange for the generated code. In this discussion, we will be showcasing another version of our <em class="italic">online auction system</em> that will use the OAuth2 <em class="italic">authorization code flow s</em>cheme.</p>
			<h2 id="_idParaDest-209"><a id="_idTextAnchor213"/>Applying OAuth2AuthorizationCodeBearer</h2>
			<p>The <strong class="source-inline">OAuth2AuthorizationCodeBearer</strong> class<a id="_idIndexMarker595"/> is a class from the <strong class="source-inline">fastapi.security</strong> module that builds the authorization code flow. Its constructor requires <strong class="source-inline">authorizationUrl</strong>, <strong class="source-inline">tokenUrl</strong>, and the optional <strong class="source-inline">scopes</strong> before instantiation. The following code shows how this API class is created before its injection into the <strong class="source-inline">get_current_user()</strong> method:</p>
			<pre class="source-code">
<strong class="bold">from fastapi.security import OAuth2AuthorizationCodeBearer</strong>
oauth2_scheme = OAuth2AuthorizationCodeBearer(
    authorizationUrl='ch07/oauth2/authorize',
    <strong class="bold">tokenUrl="ch07/login/token",  </strong>
    scopes={"admin_read": "admin … read only role",
            "admin_write":"admin … write only role",
            … … … … … …
            "guest":"visitor of the site"},
    )</pre>
			<p>The two endpoints, <strong class="source-inline">authorizationUrl</strong> and <strong class="source-inline">tokenUrl</strong>, are crucial parameters in the authentication and authorization process of this scheme. Unlike the previous solutions, we will not rely on the authorization server when generating <strong class="source-inline">access_token</strong>. Instead, we will be implementing an <strong class="source-inline">authorizationUrl</strong> endpoint that will capture essential parameters from the client that will comprise the authorization <a id="_idIndexMarker596"/>request for <strong class="source-inline">access_token</strong> generation. The <strong class="source-inline">client_secret</strong> parameter will always remain unexposed to the client.</p>
			<h2 id="_idParaDest-210"><a id="_idTextAnchor214"/>Implementing the authorization request</h2>
			<p>In the<a id="_idIndexMarker597"/> previous schemes, the <strong class="source-inline">/ch07/login/</strong> token or the <strong class="source-inline">tokenUrl</strong> endpoint is always the redirection point after a login transaction. But this time, the user will be forwarded to the custom <strong class="source-inline">/ch07/oauth2/authorize</strong> or the <strong class="source-inline">authorizationUrl</strong> endpoint for <em class="italic">auth code</em> generation. Query parameters such as <strong class="source-inline">response_type</strong>, <strong class="source-inline">client_id</strong>, <strong class="source-inline">redirect_uri</strong>, <strong class="source-inline">scope</strong>, and <strong class="source-inline">state</strong> are the essential inputs to the <strong class="source-inline">authorizationUrl</strong> service. The following code from the <strong class="source-inline">/security/secure.py</strong> module of the <strong class="source-inline">ch07f</strong> project will showcase the implementation of the <strong class="source-inline">authorizationUrl</strong> transaction:</p>
			<pre class="source-code">
<strong class="bold">@router.get("/oauth2/authorize")</strong>
def authorizationUrl(state:str, client_id: str, 
       redirect_uri: str, scope: str, response_type: str, 
       sess:Session = Depends(sess_db)):
      
    <strong class="bold">global state_server</strong>
    <strong class="bold">state_server = state</strong>
    
    loginrepo = LoginRepository(sess)
    account = loginrepo.get_all_login_username(client_id)
    <strong class="bold">auth_code = f"{account.username}:{account.password}</strong>
                    <strong class="bold">:{scope}"</strong>
    <strong class="bold">if authenticate(account.username, </strong>
              <strong class="bold">account.password, account):</strong>
        <strong class="bold">return RedirectResponse(url=redirect_uri </strong>
          <strong class="bold">+ "?code=" + auth_code </strong>
          <strong class="bold">+ "&amp;grant_type=" + response_type</strong>
          <strong class="bold">+ "&amp;redirect_uri=" + redirect_uri </strong>
          <strong class="bold">+ "&amp;state=" + state)</strong>
    else:
        raise HTTPException(status_code=400, 
               detail="Invalid account")</pre>
			<p>These are the query <a id="_idIndexMarker598"/>parameters needed by the <strong class="source-inline">authorizationUrl</strong> transaction:</p>
			<ul>
				<li><strong class="source-inline">response_type</strong>: Custom-generated authorization code </li>
				<li><strong class="source-inline">client_id</strong>: The public identifier of the app, such as <strong class="source-inline">username</strong></li>
				<li><strong class="source-inline">redirect_uri</strong>: The server default URI or a custom endpoint designed to redirect the user back to the application</li>
				<li><strong class="source-inline">scope</strong>: A scope parameter(s) string, separated by spaces if at least two parameters are involved</li>
				<li><strong class="source-inline">state</strong>: An arbitrary string value that determines the state of the request</li>
			</ul>
			<p>The <strong class="source-inline">redirect_uri</strong> parameter is the destination point where the authentication and authorization processes will occur together with these query parameters. </p>
			<p>The generation of <strong class="source-inline">auth_code</strong> is one of the crucial tasks of the <strong class="source-inline">authorizationUrl</strong> transaction, including the authentication process. The <em class="italic">auth code</em> indicates an ID for the authentication process and is usually unique from all other authentication. There are many ways to generate the code, but in our app, it is simply the combination of user credentials. Conventionally, <strong class="source-inline">auth_code</strong> needs to be encrypted because it comprises the user credentials, scope, and other request-related details.</p>
			<p>If the user is valid, the <strong class="source-inline">authorizationUrl</strong> transaction will redirect the user to the <strong class="source-inline">redirect_uri</strong> parameter, back to the FastAPI layer, with the <strong class="source-inline">auth_code</strong>, <strong class="source-inline">grant_type</strong>, and <strong class="source-inline">state</strong> parameters, and the <strong class="source-inline">redirect_uri</strong> parameter itself. The <strong class="source-inline">grant_type</strong> and <strong class="source-inline">redirect_uri</strong> parameters are optional only if the application does not require them. This response will invoke the <strong class="source-inline">tokenUrl</strong> endpoint, which happens to be<a id="_idIndexMarker599"/> the <strong class="source-inline">redirectURL</strong> parameter, to pursue the continuation of the authentication process with scoped-based authorization.</p>
			<h2 id="_idParaDest-211"><a id="_idTextAnchor215"/>Implementing the authorization code response</h2>
			<p>The <strong class="source-inline">/ch07/login/token</strong> service, or <strong class="source-inline">tokenUrl</strong>, must have the <strong class="source-inline">Form(…)</strong> parameter to<a id="_idIndexMarker600"/> capture the <strong class="source-inline">code</strong>, <strong class="source-inline">grant_type</strong>, and <strong class="source-inline">redirect_uri</strong> parameters from the <strong class="source-inline">authorizationUrl</strong> transaction instead of <strong class="source-inline">OAuth2PasswordRequestForm</strong>. The following code snippet shows its implementation:</p>
			<pre class="source-code">
<strong class="bold">@router.post("/login/token")</strong>
def access_token(code: str = Form(...), 
  grant_type:str = Form(...), redirect_uri:str = Form(...), 
  sess:Session = Depends(sess_db)):
    access_token_expires = 
       timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    
    <strong class="bold">code_data = code.split(':')</strong>
    <strong class="bold">scopes = code_data[2].split("+")</strong>
    <strong class="bold">password = code_data[1]</strong>
    <strong class="bold">username = code_data[0]</strong>
    
    loginrepo = LoginRepository(sess)
    account = loginrepo.get_all_login_username(username)
    if authenticate(username, password, account):
        <strong class="bold">access_token = create_access_token(</strong>
            <strong class="bold">data={"sub": username, "scopes": scopes},</strong>
            <strong class="bold">expires_delta=access_token_expires,</strong>
        <strong class="bold">)</strong>
    
        <strong class="bold">global state_server</strong>
        <strong class="bold">state = state_server</strong>
        return {
            "access_token": access_token,
            "expires_in": access_token_expires,
            "token_type": "Bearer",
            "userid": username,
            "state": state,
            "scope": "SCOPE"
        }
    else:
        raise HTTPException(
            status_code=400, 
             detail="Incorrect credentials")</pre>
			<p>The only <a id="_idIndexMarker601"/>response data sent by <strong class="source-inline">authorizationUrl</strong> that is not accessible by <strong class="source-inline">tokenUrl</strong> is the <strong class="source-inline">state</strong> parameter. One workaround is to declare the <strong class="source-inline">state</strong> variable in <strong class="source-inline">authorizationURL</strong> as a <strong class="source-inline">global</strong> one to make it accessible anywhere. The <strong class="source-inline">state</strong> variable is part of the JSON response of the service, which the API authentication requires. Likewise, <strong class="source-inline">tokenUrl</strong> has no access to the user credentials but parsing <strong class="source-inline">auth_code</strong> is a possible way to derive the username, password, and scopes.</p>
			<p>If the user is valid, <strong class="source-inline">tokenUrl</strong> must submit the JSON data containing <strong class="source-inline">access_token</strong>, <strong class="source-inline">expires_in</strong>, <strong class="source-inline">token_type</strong>, <strong class="source-inline">userid</strong>, and <strong class="source-inline">state</strong> to proceed with the authentication scheme. </p>
			<p>This authorization <a id="_idIndexMarker602"/>code flow scheme provides the baseline protocol for the <em class="italic">OpenID Connect</em> authentication. Various identity and access management solutions, such as <em class="italic">Okta</em>, <em class="italic">Auth0</em>, and <em class="italic">Keycloak</em>, apply the authorization requests and responses involving response_type code. The next topic will highlight the FastAPI's support of the OpenID Connect specification.</p>
			<h1 id="_idParaDest-212"><a id="_idTextAnchor216"/>Applying the OpenID Connect specification</h1>
			<p>There are<a id="_idIndexMarker603"/> three <em class="italic">online auction</em> projects created to impose the <em class="italic">OAuth2 OpenID Connect </em>authentication scheme. All these projects use third-party tools to perform authentication and authorization procedures. The <strong class="source-inline">ch07g</strong> project uses <em class="italic">Auth0</em>, <strong class="source-inline">ch07h</strong> uses <em class="italic">Okta</em>, and <strong class="source-inline">ch07i</strong> applies a <em class="italic">Keycloak</em> policy in authenticating client access to the API services. Let us first highlight Keycloak’s support for the OpenID Connect protocol. </p>
			<h2 id="_idParaDest-213"><a id="_idTextAnchor217"/>Using HTTPBearer</h2>
			<p>The <strong class="source-inline">HTTPBearer</strong> class is a <a id="_idIndexMarker604"/>utility class from the <strong class="source-inline">fastapi.security</strong> module that provides an authorization scheme that relies directly on the authorization header with the <strong class="source-inline">Bearer</strong> tokens. Unlike the other OAuth2 schemes, this requires the generation of an <strong class="source-inline">access_token</strong> on the <em class="italic">Keycloak</em> side before running the authentication server. At this point, the framework has no straightforward way of accessing the credentials and the <strong class="source-inline">access_token</strong> from Keycloak’s identity provider. To utilize this class, we only need to instantiate it without any constructor parameters.</p>
			<h2 id="_idParaDest-214"><a id="_idTextAnchor218"/>Installing and configuring the Keycloak environment</h2>
			<p>Keycloak<a id="_idIndexMarker605"/> is a Java-based application that we<a id="_idIndexMarker606"/> can download from the following link: <a href="https://www.keycloak.org/downloads">https://www.keycloak.org/downloads</a>. After downloading, we can unzip its content to any directory. But before <a id="_idIndexMarker607"/>running it, we need to install at least the Java 12 SDK on our development machine. Once you have completed the setup, run its <strong class="source-inline">bin\standalone.bat</strong> or <strong class="source-inline">bin\standalone.sh</strong> on the console and then open <strong class="source-inline">http://localhost:8080</strong> on the browser. Afterward, create an administration account to set up the <em class="italic">realm</em>, <em class="italic">clients</em>, <em class="italic">users</em>, and <em class="italic">scopes</em>.</p>
			<h2 id="_idParaDest-215"><a id="_idTextAnchor219"/>Setting the Keycloak realm and clients</h2>
			<p>A Keycloak <em class="italic">realm</em> is an<a id="_idIndexMarker608"/> object that encompasses all the <a id="_idIndexMarker609"/>clients together with their <em class="italic">credentials</em>, <em class="italic">scopes</em>, and <em class="italic">roles</em>. The first step before creating the user profiles is to build a realm, as shown in <em class="italic">Figure 7.7</em>:</p>
			<div>
				<div id="_idContainer047" class="IMG---Figure">
					<img src="image/Figure_7.07_B17975.jpg" alt="Figure 7.7 - Creating a Keycloak realm"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.7 - Creating a Keycloak realm</p>
			<p>After the realm, the Keycloak <em class="italic">client</em>, which <a id="_idIndexMarker610"/>manages the user profiles <a id="_idIndexMarker611"/>and credentials, is the next priority. It is created on the <strong class="bold">Configure</strong> | <strong class="bold">Clients</strong> panel, as shown:</p>
			<div>
				<div id="_idContainer048" class="IMG---Figure">
					<img src="image/Figure_7.08_B17975.jpg" alt="Figure 7.8 – Creating the Keycloak clients&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.8 – Creating the Keycloak clients</p>
			<p>After creating the clients, we need to edit each Client profile to input the following details:</p>
			<ul>
				<li>Its access type must be <strong class="source-inline">confidential</strong></li>
				<li><strong class="source-inline">Authorization Enabled</strong> is turned <strong class="source-inline">ON</strong></li>
				<li>Provide values for <strong class="source-inline">Root URL</strong>, <strong class="source-inline">Base URL</strong>, and <strong class="source-inline">Admin URL</strong>, which all refer to the <strong class="source-inline">http://localhost:8000</strong> of the API service application</li>
				<li>Specify a <strong class="source-inline">Valid Redirect URI</strong> endpoint, or we can just assign <strong class="source-inline">http://localhost:8080/*</strong> if we have no specific custom endpoint </li>
				<li>In <strong class="source-inline">Advanced Settings</strong>, set <strong class="source-inline">Access Token Lifespan</strong> (e.g., 15 minutes)</li>
				<li>Under <strong class="source-inline">Authentication Flow Overrides</strong>, set <strong class="source-inline">Browser Flow</strong> to <strong class="source-inline">browser</strong> and<a id="_idIndexMarker612"/> <strong class="source-inline">Direct Grant Flow</strong> to <strong class="source-inline">direct grant</strong>.</li>
			</ul>
			<p>In the <strong class="bold">Credentials</strong> panel, we can find the <em class="italic">client credentials</em>, in which the auto-generated <strong class="source-inline">client_secret</strong> value is located. After the setup, we can now assign users to the clients.</p>
			<h2 id="_idParaDest-216"><a id="_idTextAnchor220"/>Creating users and user roles</h2>
			<p>First, we<a id="_idIndexMarker613"/> create <em class="italic">roles</em> on the <strong class="bold">Configure | Roles</strong> panel, in<a id="_idIndexMarker614"/> preparation for user assignment later. <em class="italic">Figure 7.9</em> shows three user roles that will handle the application’s <em class="italic">administration</em>, <em class="italic">auctioning</em>, and <em class="italic">bidding </em>tasks:</p>
			<div>
				<div id="_idContainer049" class="IMG---Figure">
					<img src="image/Figure_7.09_B17975.jpg" alt="Figure 7.9 – Creating user roles&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.9 – Creating user roles</p>
			<p>After creating the roles, we need to build the list of users on the <strong class="bold">Manage | U</strong><strong class="bold">sers</strong> panel. <em class="italic">Figure 7.10</em> shows the three created users, each with the mapped roles: </p>
			<div>
				<div id="_idContainer050" class="IMG---Figure">
					<img src="image/Figure_7.10_B17975.jpg" alt="Figure 7.10 – Creating client users&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.10 – Creating client users</p>
			<p>To provide users with their roles, we need to click the <strong class="bold">Edit</strong> link for each user and assign the appropriate <strong class="bold">Realm Roles</strong>. <em class="italic">Figure 7.11</em> shows that the user <strong class="source-inline">joey_admin</strong> has the <strong class="source-inline">auc_admin_role</strong> role, authorizing the user to do the administrative tasks for the app. By the way, do not forget to create a password for each user on the <strong class="bold">Credentials</strong><em class="italic"> </em>panel:</p>
			<div>
				<div id="_idContainer051" class="IMG---Figure">
					<img src="image/Figure_7.11_B17975.jpg" alt="Figure 7.11 – Mapping user roles&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.11 – Mapping user roles</p>
			<h2 id="_idParaDest-217"><a id="_idTextAnchor221"/>Assigning roles to clients</h2>
			<p>Aside from user roles, clients <a id="_idIndexMarker615"/>can also have assigned roles. A <em class="italic">client role</em> defines the type of users a client must have under its coverage. It also provides the client’s boundary when accessing the API services. <em class="italic">Figure 7.12</em> shows <strong class="source-inline">auc_admin</strong> with an <strong class="source-inline">admin</strong> role:</p>
			<div>
				<div id="_idContainer052" class="IMG---Figure">
					<img src="image/Figure_7.12_B17975.jpg" alt="Figure 7.12 – Creating client roles"/>
				</div>
			</div>
			<p class="IMG---Figure"> </p>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.12 – Creating client roles</p>
			<p>Then, we need to return to the <strong class="bold">Manage </strong>| <strong class="bold">Users</strong> panel and assign the <em class="italic">user</em> its role(s) through the <em class="italic">client</em>. For instance, <em class="italic">Figure 7.13</em> shows that <strong class="source-inline">joey_admin</strong> has the <strong class="source-inline">admin</strong> role because the <strong class="source-inline">auc_admin</strong> role was added to its profile. All users with the <strong class="source-inline">auc_admin</strong> client added to their setup have <em class="italic">admin</em> access to the app, including <strong class="source-inline">joey_admin</strong>:</p>
			<div>
				<div id="_idContainer053" class="IMG---Figure">
					<img src="image/Figure_7.13_B17975.jpg" alt="Figure 7.13 – Mapping client roles to users"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.13 – Mapping client roles to users</p>
			<h2 id="_idParaDest-218"><a id="_idTextAnchor222"/>Creating user permissions through scopes</h2>
			<p>To assign permission to each<a id="_idIndexMarker616"/> client, we need to create <em class="italic">client scopes</em> on the <strong class="bold">Configure | Client Scopes</strong> panel. Each client scope must have an <strong class="source-inline">Audience</strong>-type token mapper. <em class="italic">Figure 7.14</em> shows the <strong class="source-inline">admin:read</strong> and <strong class="source-inline">admin:write</strong> scopes for the <strong class="source-inline">auc_admin</strong> client, <strong class="source-inline">auction:read</strong> and <strong class="source-inline">auction:write</strong> for <strong class="source-inline">auc_customer</strong>, and <strong class="source-inline">bidder:write</strong> and <strong class="source-inline">bidder:read</strong> for <strong class="source-inline">auc_bidder</strong>:</p>
			<div>
				<div id="_idContainer054" class="IMG---Figure">
					<img src="image/Figure_7.14_B17975.jpg" alt="Figure 7.14 – Creating the client scopes&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.14 – Creating the client scopes</p>
			<p>These <em class="italic">client scopes</em> are essential details within the <strong class="source-inline">Security</strong> injection for each API service if <em class="italic">scope-based authorization</em> is part of the scheme.</p>
			<h2 id="_idParaDest-219"><a id="_idTextAnchor223"/>Integrating Keycloak with FastAPI</h2>
			<p>Since the <a id="_idIndexMarker617"/>FastAPI application cannot directly access the Keycloak client credentials for authentication, the application has a <strong class="source-inline">login_keycloak()</strong> service to redirect the user to the <em class="italic">AuctionRealm URI</em>, our custom <strong class="source-inline">authorizationUrl</strong> in Keycloak. The URI is <strong class="source-inline">/auth/realms/AuctionRealm/protocol/openid-connect/auth</strong>. First, access <strong class="source-inline">http://localhost:8080/auth/realms/AuctionRealm/account/</strong> to log in using the authorized user credentials, such as <strong class="source-inline">joey_admin</strong>, before invoking the <strong class="source-inline">login_keycloak()</strong> service.</p>
			<p>Now, the redirection must include <strong class="source-inline">client_id</strong>, as with the <strong class="source-inline">auc_admin</strong> client, and the custom callback handler called <strong class="source-inline">redirect_uri</strong>. All the Keycloak realm details must be in the <strong class="source-inline">.config</strong> property file. The following code shows the implementation of the <strong class="source-inline">login_keycloak()</strong> service:</p>
			<pre class="source-code">
<strong class="bold">import hashlib</strong>
import os
import urllib.parse as parse
<strong class="bold">@router.get("/auth/login")</strong>
def login_keycloak() -&gt; RedirectResponse:
    config = set_up()
    <strong class="bold">state = hashlib.sha256(os.urandom(32)).hexdigest()</strong>
 
    AUTH_BASE_URL = f"{config['KEYCLOAK_BASE_URL']}
     <strong class="bold">/auth/realms/AuctionRealm/protocol/</strong>
         openid-connect/auth"
    AUTH_URL = AUTH_BASE_URL + 
     '?{}'.format(parse.urlencode({
        'client_id': config["CLIENT_ID"],
        'redirect_uri': config["REDIRECT_URI"],
        'state': state,
        <strong class="bold">'response_type': 'code'</strong>
    }))
    response = RedirectResponse(AUTH_URL)
    response.set_cookie(key="AUTH_STATE", value=state)
    return response</pre>
			<p>A <em class="italic">state</em> is part of <strong class="source-inline">login_keycloak()</strong>’s response for the callback method to verify the authentication, a similar approach we had in utilizing <strong class="source-inline">OAuth2AuthorizationCodeBearer</strong>. The service used the <strong class="source-inline">hashlib</strong> module to generate a <a id="_idIndexMarker618"/>randomized hash string value for the state using the <em class="italic">SHA256</em> encryption algorithm. On the other hand, Keycloak’s <em class="italic">AuctionRealm URI</em> must return a JSON result as follows:</p>
			<pre class="source-code">
{"access_token":"eyJhbGciOiJSUzI1NiIsInR5cCIgOiAiSldUIiwia2lkI iA6ICJJMFR3YVhiZnh0MVNQSnNzVTByQ09hMzVDaTdZNDkzUnJIeDJTM3paa0V VIn0.eyJleHAiOjE2NDU0MTgzNTAsImlhdCI6MTY0NTQxNzQ1MCwiYXV0aF90a W1lIjoxNjQ1NDE3NDM3LCJqdGkiOiI4YTQzMjBmYi0xMzg5LTQ2NzU……………………………2YTU2In0.UktwOX7H2ZdoyP1VZ5V2MXUX2Gj41D2cuusvwEZXBtVMvnoTDh KJgN8XWL7P3ozv4A1ZlBmy4NX1HHjPbSGsp2cvkAWwlyXmhyUzfQslf8Su00-4 e9FR4i4rOQtNQfqHM7cLhrzr3-od-uyj1m9KsrpbqdLvPEl3KZnmOfFbTwUXfE 9YclBFa8zwytEWb4qvLvKrA6nPv7maF2_MagMD_0Mh9t95N9_aY9dfquS9tcEV Whr3d9B3ZxyOtjO8WiQSJyjLCT7IW1hesa8RL3WsiG3QQQ4nUKVHhnciK8efRm XeaY6iZ_-8jm-mqMBxw00-jchJE8hMtLUPQTMIK0eopA","expires_in":900,"refresh_expires_in":1800,"refresh_token":"eyJhbGciOiJIUzI1NiIs InR5cCIgOiAiSldUIiwia2lkIiA6ICJhNmVmZGQ0OS0yZDIxLTQ0NjQtOGUyOC0 4ZWJkMjdiZjFmOTkifQ.eyJleHAiOjE2NDU0MTkyNTAsImlhdCI6MTY0NTQxNzQ 1MCwianRpIjoiMzRiZmMzMmYtYjAzYi00MDM3LTk5YzMt………………………zc2lvbl9z dGF0ZSI6ImM1NTE3ZDIwLTMzMTgtNDFlMi1hNTlkLWU2MGRiOWM1NmE1NiIsIn Njb3BlIjoiYWRtaW46d3JpdGUgYWRtaW46cmVhZCB1c2VyIiwic2lkIjoiYzU1 MTdkMjAtMzMxOC00MWUyLWE1OWQtZTYwZGI5YzU2YTU2In0.xYYQPr8dm7_o1G KplnS5cWmLbpJTCBDfm1WwZLBhM6k","token_type":"Bearer","not-before-policy":0,"session_state":"c5517d20-3318-41e2-a59d-e60d b9c56a56","scope":"admin:write admin:read user"}</pre>
			<p>This contains <a id="_idIndexMarker619"/>the essential credentials, such as <strong class="source-inline">access_token</strong>, <strong class="source-inline">expires_in</strong>, <strong class="source-inline">session_state</strong>, and <strong class="source-inline">scope</strong>.</p>
			<h2 id="_idParaDest-220"><a id="_idTextAnchor224"/>Implementing the token verification</h2>
			<p>The <a id="_idIndexMarker620"/>application’s <strong class="source-inline">HTTPBearer</strong> needs <strong class="source-inline">access_token</strong> to pursue the client-side authentication. On the OpenAPI dashboard, we click the <strong class="bold">Authorize</strong> button and paste the <strong class="source-inline">access_token</strong> value provided by Keycloak’s <strong class="source-inline">authorizationUrl</strong>. After the successful authentication, <strong class="source-inline">get_current_user()</strong> will verify the access to each API endpoint based on the credentials extracted from <strong class="source-inline">access_token</strong>. The following code highlights the <strong class="source-inline">get_current_user()</strong>, <strong class="source-inline">which</strong> builds the user credentials from Keycloak’s <em class="italic">token</em> using the <strong class="source-inline">PyJWT</strong> utility and algorithms such as <strong class="source-inline">RSAAlgorithm</strong>:</p>
			<pre class="source-code">
<strong class="bold">from jwt.algorithms import RSAAlgorithm</strong>
from urllib.request import urlopen
import jwt
def get_current_user(security_scopes: SecurityScopes, 
        <strong class="source-inline">token: str = Depends(token_auth_scheme)</strong>):
    token = token.credentials
    config = set_up()
    <strong class="bold">jsonurl = urlopen(f'{config["KEYCLOAK_BASE_URL"]}</strong>
        <strong class="bold">/auth/realms/AuctionRealm/protocol</strong>
        <strong class="bold">/openid-connect/certs')</strong>
    <strong class="bold">jwks = json.loads(jsonurl.read())</strong>
    <strong class="bold">unverified_header = jwt.get_unverified_header(token)</strong>
   
    rsa_key = {}
    <strong class="bold">for key in jwks["keys"]:</strong>
        <strong class="bold">if key["kid"] == unverified_header["kid"]:</strong>
            <strong class="bold">rsa_key = {</strong>
                <strong class="bold">"kty": key["kty"],</strong>
                <strong class="bold">"kid": key["kid"],</strong>
                <strong class="bold">"use": key["use"],</strong>
                <strong class="bold">"n": key["n"],</strong>
                <strong class="bold">"e": key["e"]</strong>
            <strong class="bold">}</strong>
    
    if rsa_key:
        try:
                <strong class="bold">public_key = RSAAlgorithm.from_jwk(rsa_key)</strong>
                <strong class="bold">payload = jwt.decode(</strong>
                    <strong class="bold">token,</strong>
                    public_key,
                    <strong class="bold">algorithms=config["ALGORITHMS"],</strong>
                    <strong class="bold">options=dict(</strong>
                           <strong class="bold">verify_aud=False,</strong>
                           <strong class="bold">verify_sub=False,</strong>
                           <strong class="bold">verify_exp=False,</strong>
                     )
                )
    … … … … … …
    <strong class="bold">token_scopes = payload.get("scope", "").split()</strong>
   
    <strong class="bold">for scope in security_scopes.scopes:</strong>
        if scope not in token_scopes:
            raise AuthError(
               {
                 "code": "Unauthorized",
                 "description": Invalid Keycloak details,
               },403,
            )
    return payload</pre>
			<p>Install the <strong class="source-inline">PyJWT</strong> module<a id="_idIndexMarker621"/> first to utilize the needed encoders and decoder functions. The <strong class="source-inline">jwt</strong> module has <strong class="source-inline">RSAAlgorithm</strong>, <strong class="source-inline">which</strong> can help decode the rsa_key from the token with some options disabled, such as the verification of the client’s <strong class="source-inline">audience</strong>. </p>
			<h2 id="_idParaDest-221"><a id="_idTextAnchor225"/>Integrating Auth0 with FastAPI</h2>
			<p><em class="italic">Auth0</em> can also be a third-party <a id="_idIndexMarker622"/>authentication provider that can authenticate and authorize access to the API endpoints of our app. But first, we need to sign up for an account at <a href="https://auth0.com/">https://auth0.com/</a>. </p>
			<p>After signing up for an account, create an Auth0 application to derive <strong class="bold">Domain</strong>, <strong class="bold">Client ID</strong>, and <strong class="bold">Client Secret</strong>, and configure some URI- and token-related details. <em class="italic">Figure 7.15</em> shows the dashboard that creates the Auth0 application:</p>
			<div>
				<div id="_idContainer055" class="IMG---Figure">
					<img src="image/Figure_7.15_B17975.jpg" alt="Figure 7.15 – Creating the Auth0 application&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.15 – Creating the Auth0 application</p>
			<p>The Auth0 application also has the generated <em class="italic">Audience API</em> URI that the client-side authentication needs. On the other hand, part of the authentication parameters is the <em class="italic">issuer</em>, which we can derive from the <strong class="bold">Domain</strong> value of the Auth0 application. The issuer is a base URI to the <strong class="source-inline">/oauth/token</strong> service that generates the <strong class="source-inline">auth_token</strong> once requested, similar to the Keycloak’s realm. We place all these Auth0 details in the <strong class="source-inline">.config</strong> file, including the <strong class="source-inline">PyJWT</strong> algorithm for decoding <strong class="source-inline">auth_token</strong>.</p>
			<p><strong class="source-inline">ch07g</strong> has its <a id="_idIndexMarker623"/>own version of <strong class="source-inline">get_current_user()</strong> that processes the <em class="italic">payload</em> for API authentication and authorization from the Auth0 details in the <strong class="source-inline">.config</strong> file. But first, the <strong class="source-inline">HTTPBearer</strong> class needs the <strong class="source-inline">auth_token</strong> value and gets it by running the following <strong class="source-inline">tokenURL</strong> of our Auth0 application, <em class="italic">AuctionApp</em>:</p>
			<p class="source-code">curl --request POST                                      --url https://dev-fastapi1.us.auth0.com/oauth/token   --header</p>
			<p class="source-code">'content-type: application/json'              --data "{"client_id":"KjdwFzHrOLXC3IKe kw8t6YhX4xUV1ZNd",   "client_secret":"_KyPEUOB7DA5Z3mmRXpnqWA3EXfrjLw2R5SoUW7m1wLMj7 KoElMyDLiZU8SgMQYr","audience":"https://fastapi.auction.com/","grant_type":"client_credentials"}"</p>
			<h2 id="_idParaDest-222"><a id="_idTextAnchor226"/>Integrating Okta with FastAPI</h2>
			<p>Some of the <a id="_idIndexMarker624"/>processes performed in Auth0 are also found in Okta’s procedures when extracting the <strong class="bold">Client ID</strong>, <strong class="bold">Client Secret</strong>, <strong class="bold">Domain</strong>, issuer, and Audience API information from the Okta account. The <strong class="source-inline">ch07h</strong> project has these details stored in the <strong class="source-inline">app.env</strong> file to be retrieved by its <strong class="source-inline">get_current_user()</strong> for the payload generation. But then again, the <strong class="source-inline">HTTPBearer</strong> class needs an <strong class="source-inline">auth_token</strong> from executing the following Okta’s <strong class="source-inline">tokenURL</strong>, based on the account’s issuer:</p>
			<p class="source-code">curl --location --request POST "https://dev-5180227.okta.com/oauth2/default/v1/token?grant_type=client_credentials&amp;client_id=0oa3tvejee5UPt7QZ5d7&amp;client_secret=LA4WP8lACWKu4Ke9fReol0fNSUvxsxTvGLZdDS5-"   --header "Content-Type: application/x-www-form-urlencoded"</p>
			<p>Aside from the Basic, Digest, OAuth2, and OpenID Connect authentication schemes, FastAPI can utilize some built-in middlewares to help secure API endpoints. Let us now determine whether these middlewares can provide a custom authentication process.</p>
			<h1 id="_idParaDest-223"><a id="_idTextAnchor227"/>Using built-in middlewares for authentication</h1>
			<p>FastAPI <a id="_idIndexMarker625"/>can use Starlette middleware <a id="_idIndexMarker626"/>such as <strong class="source-inline">AuthenticationMiddleware</strong> to implement any custom authentication. It needs <strong class="source-inline">AuthenticationBackend</strong> to implement the scheme for our app’s security model. The following custom <strong class="source-inline">AuthenticationBackend</strong> checks whether the <strong class="source-inline">Authorization</strong> credential is a <strong class="source-inline">Bearer</strong> class and verifies whether the <strong class="source-inline">username</strong> token is equivalent to a fixed username credential provided by the middleware:</p>
			<pre class="source-code">
<strong class="bold">class UsernameAuthBackend(AuthenticationBackend):</strong>
    <strong class="bold">def __init__(self, username): </strong>
        <strong class="bold">self.username = username    </strong>
        
    async def authenticate(self, request):
        if "Authorization" not in request.headers:
            return
        <strong class="bold">auth = request.headers["Authorization"]</strong>
        try:
            <strong class="bold">scheme, username = auth.split()</strong>
            <strong class="bold">if scheme.lower().strip() != 'bearer'.strip():</strong>
                return
        except:
            raise AuthenticationError(
             'Invalid basic auth credentials')
        if not username == self.username:
            return
       
        return AuthCredentials(["authenticated"]), 
             SimpleUser(username)</pre>
			<p>Activating <a id="_idIndexMarker627"/>this <strong class="source-inline">UsernameAuthBackend</strong> means <a id="_idIndexMarker628"/>injecting it into the FastAPI constructor in <strong class="source-inline">main.py</strong> with <strong class="source-inline">AuthenticationMiddleware</strong>. It also needs the designated <strong class="source-inline">username</strong> for its authentication process to work. The following snippet shows how to activate the whole authentication scheme in the <strong class="source-inline">main.py</strong> file:</p>
			<pre class="source-code">
<strong class="bold">from security.secure import UsernameAuthBackend</strong>
<strong class="bold">from starlette.middleware import Middleware</strong>
<strong class="bold">from starlette.middleware.authentication import </strong>
    <strong class="bold">AuthenticationMiddleware</strong>
<strong class="bold">middleware = [Middleware(AuthenticationMiddleware, </strong>
    <strong class="bold">backend=UsernameAuthBackend("sjctrags"))]</strong>
app = FastAPI(middleware=middleware)</pre>
			<p>Injecting <a id="_idIndexMarker629"/>FastAPI’s <strong class="source-inline">Request</strong> is the first step in<a id="_idIndexMarker630"/> applying the authentication scheme. Then, we decorate each API with <strong class="source-inline">@requires("authenticated")</strong> after the <strong class="source-inline">@router</strong> decorator. We can extend the <strong class="source-inline">UsernameAuthBackend</strong> process further by adding JWT encoding and decoding, encryption, or custom roles-based authorization.</p>
			<h1 id="_idParaDest-224"><a id="_idTextAnchor228"/>Summary</h1>
			<p>Securing any applications is always the main priority in producing quality software. We always choose frameworks that support reliable and credible security solutions, and that can at least prevent malicious attacks from the outside environment. Although we know for a fact that a perfect security model is a myth, we always develop security solutions that can cope with the threats we know. </p>
			<p>FastAPI is one of the API frameworks that has built-in support for many popular authentication processes, from Basic to the OpenID Connect specification. It fully supports all effective OAuth2 authentication schemes and is even open to further customization of its security APIs. </p>
			<p>Although it has no direct support for the OpenID Connect specification, it can still integrate seamlessly with different popular identities and user management systems, such as Auth0, Okta, and Keycloak. This framework may still surprise us with many security utilities and classes in the future that we can apply to build scalable microservice applications.</p>
			<p>The next chapter will focus on topics regarding non-blocking API services, events, and message-driven transactions.</p>
		</div>
		<div>
			<div id="_idContainer057">
			</div>
		</div>
	</body></html>