- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating Your Add-Ons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Add-ons are extensions that expand the capabilities of Blender and can be enabled
    in the preferences. Some of them, such as Math Vis, encountered in [*Chapter 2*](B18375_02.xhtml#_idTextAnchor033),
    are official features distributed as optional functionalities. Others are third-party
    expansions that can be installed by a user.
  prefs: []
  type: TYPE_NORMAL
- en: At their core, add-ons are Python modules that contain information used by Blender
    to install, enable, and remove them like in a plugin system.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn how to write and install an add-on in Blender,
    and how to enable add-ons while they are still in the making. We will also implement
    a new command that groups objects into collections and make it part of the object
    context menu.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Scripting Blender extensions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running and updating our add-on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixing errors and improving our code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will use Blender and **Visual Studio Code** (**VS Code**). The examples created
    in this chapter can be found at [https://github.com/PacktPublishing/Python-Scripting-in-Blender/tree/main/ch3](https://github.com/PacktPublishing/Python-Scripting-in-Blender/tree/main/ch3).
  prefs: []
  type: TYPE_NORMAL
- en: Installing our add-ons in Blender
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can write a very simple add-on using VS Code. This add-on doesn’t really
    do anything; it just shows up in the extensions list.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we must create a folder for the code of this chapter. We can use the
    file manager or the navigation sidebar that comes with most IDEs. In this example,
    we will use VS Code, which we met in the *External editors* section of [*Chapter
    1*](B18375_01.xhtml#_idTextAnchor014):'
  prefs: []
  type: TYPE_NORMAL
- en: Open your **PythonScriptingBlender** project in VS Code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new folder by clicking the **New** **Folder** icon.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.1: Creating a folder in Visual Studio Code](img/Figure_3.01_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.1: Creating a folder in Visual Studio Code'
  prefs: []
  type: TYPE_NORMAL
- en: Name the new folder `ch3`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, we can create a Python file for our add-on:'
  prefs: []
  type: TYPE_NORMAL
- en: Make sure the `ch3` folder is selected in the **VS Code** explorer, and then
    create a new file by clicking the **New** **File** icon.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.2: Creating a file in VS Code](img/Figure_3.02_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.2: Creating a file in VS Code'
  prefs: []
  type: TYPE_NORMAL
- en: Name the new file `the_simplest_add_on.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the file via a double click.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We are ready to write our add-on; let’s look at what is required.
  prefs: []
  type: TYPE_NORMAL
- en: Add-on requirements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To be considered an add-on, our code must contain three things:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Script meta info** – that is, information about the add-on'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `register()` function to enable the add-on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An `unregister()` function to disable the add-on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Script meta info
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The information displayed in the preferences tab comes from the `bl_info` variable,
    a dictionary located at the top of the `.py` file. The dictionary must contain
    the name of the author, a short description of the add-on, and the version of
    Blender for which it is written. Here is the info for our simple add-on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Start with a blank!
  prefs: []
  type: TYPE_NORMAL
- en: It is better to leave a blank line at the start and the end of our code – `.py`
    files that do not start with a blank line might fail to register as add-ons and
    cause a `missing` `bl_info` error.
  prefs: []
  type: TYPE_NORMAL
- en: Registration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `register()` function is executed when an add-on is enabled. There is not
    much going on for now – only a `pass` statement, as our function doesn’t do anything:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `unregister()` function is invoked when the add-on is disabled. Much like
    `register()`, it doesn’t do anything yet, but it is required as an add-on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Installation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, it’s time to install our add-on in Blender:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the preferences window via **Edit** | **Preferences** from the top menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **Add-ons** tab in the left column.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the **Install** button at the top right of the add-ons preferences.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the file browser, navigate to `PythonScriptingBlender\ch3` and select `the_simplest_add_on.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the **Install Add-on** button at the bottom
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Our add-on has been copied and installed in Blender; the filter entry on the
    top left is filled so that only the new add-on is displayed. We can click the
    add-on checkbox to enable it. Expanding the disclosure triangle displays more
    information from `bl_info`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3: A very simple add-on as listed in Blender](img/Figure_3.3_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.3: A very simple add-on as listed in Blender'
  prefs: []
  type: TYPE_NORMAL
- en: The `warning` entry from our dictionary is displayed with a triangle icon. That
    line is to warn the users of potentially unstable code.
  prefs: []
  type: TYPE_NORMAL
- en: Now that our add-on has served its purpose, it’s time to remove it.
  prefs: []
  type: TYPE_NORMAL
- en: Uninstall
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Clicking the big **Remove** button in the add-on preferences will display a
    confirmation dialog that asks whether it is fine to delete the add-on. This operation
    cannot be undone, but in this case, it is fine to go along and remove **The**
    **Simplest Add-on**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.4: Add-on removal in Blender](img/Figure_3.4_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.4: Add-on removal in Blender'
  prefs: []
  type: TYPE_NORMAL
- en: The path displayed in the **Remove** dialog informs that the add-on was installed
    inside Blender user preferences. That’s not always the case, as we will see how
    to point the scripts path to our working directory in the next paragraph.
  prefs: []
  type: TYPE_NORMAL
- en: The scripts path
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Reinstalling an add-on at every change during development would end up being
    impractical. Programmers usually set up a **system path** for Python scripts and
    work on their add-ons from there.
  prefs: []
  type: TYPE_NORMAL
- en: System paths can be found in **Blender Preferences**, by choosing the **File
    Paths** tab in the left column.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.5: The File Paths preferences window](img/Figure_3.5_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.5: The File Paths preferences window'
  prefs: []
  type: TYPE_NORMAL
- en: We can set this path to the directory that we will use for scripting, such as
    the `PythonScriptingBlender/ch3` folder that hosts the code of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The addons folder
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that blender will look in our scripting folder, we can create a directory
    for our add-ons. We can do that from VS Code:'
  prefs: []
  type: TYPE_NORMAL
- en: Select `PythonScriptingBlender/ch3` in VS Code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new folder by clicking the **New** **Folder** icon.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the new folder `addons`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is important that `addons` is the exact name of this folder; otherwise, Blender
    will not look for extensions. We need to restart Blender for the **File Paths**
    settings to take effect, but once we do, Blender will be able to load the add-ons
    on which we are working, with no installation needed.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can work on a new add-on that adds functionality to Blender. In the
    next section, we will write an add-on that groups the objects of a scene into
    collections.
  prefs: []
  type: TYPE_NORMAL
- en: Creating our first add-on – object collector
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are going to write an add-on that groups the objects of a scene in collections
    that reflect their type – one collection for all the meshes, one for all the lights,
    one for the curves, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we have set up `PythonScriptingBlender/ch3` as the directory for our
    add-ons, we will proceed in VS Code:'
  prefs: []
  type: TYPE_NORMAL
- en: Select `PythonScriptingBlender/ch3/addons` in VS Code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new file by clicking the **New** **File** icon.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the new file `object_collector.py`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the file via a double click.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This Python script’s name starts with `object`, since it affects object data.
    It is a *soft convention*, as this filename scheme is suggested but not enforced.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this stage, the add-on is very similar to the previous one – we haven’t
    added any code yet. Note how, besides the obvious difference in names and descriptions,
    we haven’t put a `warning` entry – we intend to make a non-experimental add-on:'
  prefs: []
  type: TYPE_NORMAL
- en: object_collector.py
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Remove carefully!
  prefs: []
  type: TYPE_NORMAL
- en: It is better to not remove add-ons loaded from the script path using the **Remove**
    button – we risk erasing our working (and perhaps only) copy!
  prefs: []
  type: TYPE_NORMAL
- en: Blender will show up this add-on in the preferences panel. In order to add functionalities,
    our add-on must contain an **operator**. Operators are the entities that carry
    on the execution of code; we will now learn how to write them.
  prefs: []
  type: TYPE_NORMAL
- en: Operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Operator` class allows calling functions from the graphic interface. They
    are, essentially, commands that can be run in Blender.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, we subclass the `bpy.types.Operator` class to make our code available
    to users.
  prefs: []
  type: TYPE_NORMAL
- en: Operator requirements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A class deriving `bpy.types.Operators` must implement these members:'
  prefs: []
  type: TYPE_NORMAL
- en: A static string named `bl_idname` that contains a unique name by which the operator
    goes internally
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A static string named `bl_label` that contains the displayed name of the operator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `poll()` class method that verifies that the conditions for executing the
    operator are met and return either `True` or `False`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An `execute()` method that runs when the operator is executed, returning a set
    of possible running states
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optionally, a docstring that Blender will display as additional information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are going to fill in this information so that our add-on will contain an
    operator that can be executed.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a basic operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s start to create our operator class. Following the Blender guidelines,
    the name starts with `OBJECT_OT`. Soon after the (optional) docstring comes `bl_idname`
    and `bl_label`, the two attributes that Blender uses respectively as an identifier
    and description of the operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `poll()` and `execute()` methods, at this stage, neither allow nor perform
    any action. We are going to implement them in the following pages, using what
    we have learned in [*Chapter 2*](B18375_02.xhtml#_idTextAnchor033), when dealing
    with Blender data.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the poll() method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`poll()` verifies that the conditions for running the operator are met. That
    restricts the possibility of error and makes the intended use of the operator
    more evident. This method is marked with a `@classmethod` decorator that allows
    us to validate the conditions before the operator is run.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Since our operator collects objects in the scene, we should not be able to
    use it if the scene is empty:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Implementing the execute() method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: After an operator is invoked, Blender runs its `execute()` method. This `execute()`
    function contains our operations. Breaking them down into single steps will help
    to code them in Python.
  prefs: []
  type: TYPE_NORMAL
- en: Planning our execution
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We must know what to expect when we execute our operator. For instance, running
    it on the default scene, we would end up with three new collections – **Mesh**
    for the **Cube** object, **Camera** for the **Camera** object, and **Light** for
    the **Light** object.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.6: The expected result after running Collector](img/Figure_3.6_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.6: The expected result after running Collector'
  prefs: []
  type: TYPE_NORMAL
- en: There is more than one way to reach this result, but to accomplish it by hand,
    we will need to create the **Mesh**, **Light**, and **Camera** collections and
    bring each object under each one of them.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will translate these actions into Python.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the execution code
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We have seen in [*Chapter 2*](B18375_02.xhtml#_idTextAnchor033) how new collections
    can be created and linked to `scene.collection.children`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can process the objects using a `for` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we always return an operation state when we exit the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This operator is still in progress and needs refining, but we can already use
    it. To do that, we must inform Blender of its existence using the `register_class()`
    function from `bpy.utils`.
  prefs: []
  type: TYPE_NORMAL
- en: Loading operators in our add-on
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our add-on adds an operator to Blender when enabled and removes it when it
    is disabled. This is done via the `bpy.utils.register_class()` and `bpy.utils.unregister_class()`
    functions that we call, respectively, inside the add-on’s `register()` and `unregister()`
    functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Enabling the **Collector** add-on will add **Create Type Collections** to Blender
    and allow you to call it from the user interface.
  prefs: []
  type: TYPE_NORMAL
- en: Running our add-on
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Even if we have yet to add any graphic element, our add-on is ready for its
    first launch. We can use two tricks in order to run add-ons that are not yet listed,
    which is quite common in development.
  prefs: []
  type: TYPE_NORMAL
- en: Refreshing the add-on list
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since we have added a new script folder and just changed its content, we need
    to either restart Blender or refresh the add-on information. To do that, we can
    click the **Refresh** button at the top right in the **Add-ons** preferences window.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.7: The Collector add-on, loaded from the project folder](img/Figure_3.7_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.7: The Collector add-on, loaded from the project folder'
  prefs: []
  type: TYPE_NORMAL
- en: If we start typing the name of our add-on in the filter bar, the entries in
    the list will narrow down until **Collector** becomes easy to find and enable.
    Now, it’s time to execute our operator via the **Blender** **Source Bar**.
  prefs: []
  type: TYPE_NORMAL
- en: Running from the Search Toolbar
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Operators that are not part of any graphic element are for internal usage –
    that is, callable by other operators but not by the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make every operator searchable, make sure that **Developers Extra** is enabled
    in the **Preferences** | **Interface** tab, as we did in [*Chapter 2*](B18375_02.xhtml#_idTextAnchor033).
    If this option is active, here is how we can call our operator:'
  prefs: []
  type: TYPE_NORMAL
- en: Press the *F3* button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start typing `create type`, and the operator will show up in the search box.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.8: The Create Type Collections operator, showing up in the search
    bar](img/Figure_3.8_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.8: The Create Type Collections operator, showing up in the search
    bar'
  prefs: []
  type: TYPE_NORMAL
- en: Click on the operator to execute it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can see in the outliner that our operator succeeded.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_3.9_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'figure 3.9: Each object is grouped under its type collection'
  prefs: []
  type: TYPE_NORMAL
- en: Our add-on is at an early stage; it has a few bugs and limitations that we are
    going to fix. For instance, the **Mesh**, **Light**, and **Camera** collections
    are created without checking whether they already exist, which will create duplicates.
    Also, we are only handling these three categories, skipping **Curves**, **Armatures**,
    and all the other object types entirely.
  prefs: []
  type: TYPE_NORMAL
- en: Nevertheless, if we are using version control for our folder, as seen in [*Chapter
    1*](B18375_01.xhtml#_idTextAnchor014), we can commit our new files. We are going
    to improve our add-on in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Improving our code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Fixing bugs or starting with a row prototype that will be completed at a later
    stage is common practice in development. In this section, we will complete our
    add-on to its finished form, reload it in Blender, and deal with the versioning
    of the scripts path.
  prefs: []
  type: TYPE_NORMAL
- en: Saving our edits automatically
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The **Auto Save** option will make VS Code save every file change to disk automatically.
    To activate this option, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the **File** menu in the **Visual Studio Code** menu bar.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Auto Save** to enable this entry.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There are developers that prefer to save manually to have more control of their
    files. Which solution is better depends on personal tastes and workflows. Generally,
    if version control is used, the advantage of **Auto Save** outweighs the danger
    of unwanted changes.
  prefs: []
  type: TYPE_NORMAL
- en: In some cases, we want to turn off version control on specific files. For instance,
    there are files that Python generates when it executes code; we have no interest
    in tracking them. In the following paragraph, we are going to see how to ignore
    specific files.
  prefs: []
  type: TYPE_NORMAL
- en: Ignoring bytecode files (.pyc)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If we execute code from our development folder, the `.pyc` file, along with
    our `.``py` files.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.10: A temporary .pyc file can be seen alongside our scripts](img/Figure_3.10_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.10: A temporary .pyc file can be seen alongside our scripts'
  prefs: []
  type: TYPE_NORMAL
- en: When a `.py` file is executed, Python translates it to an internal format and
    saves it as `.pyc`. We don’t need to concern ourselves with `.pyc` files, and
    usually, we don’t need to keep track of them.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a .gitignore file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A text file named `.gitignore`, containing the names of files and directories
    that we don’t want to track, will have an immediate effect when placed in a version
    control-managed folder. We can create it manually or follow these steps inside
    VS Code:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `.pyc` file listed under **Changes**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the context menu, select **Add** **to .gitignore**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.11: Adding to the git ignore list in VS Code](img/Figure_3.11_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.11: Adding to the git ignore list in VS Code'
  prefs: []
  type: TYPE_NORMAL
- en: Once the`.gitignore` file is created, the `.pyc` file stops showing up in the
    changes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If we open the `.gitignore` file, we will see that it contains the full path
    of the `.``pyc` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We don’t need to ignore that specific file; we can blacklist all the directories
    called `__pycache__`. To do that, we take the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And change it to this, then save:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Source control applies to the `.gitignore` file itself; we have to stage and
    commit this file, along with the other changes made in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.12: Staging the current changes for this chapter](img/Figure_3.12_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.12: Staging the current changes for this chapter'
  prefs: []
  type: TYPE_NORMAL
- en: Once we have committed our changes, we can go back to working on our script,
    fixing its flows, and expanding its capabilities. We will see how simplifying
    the logic of a script improves readability, behavior, and functionality at the
    same time.
  prefs: []
  type: TYPE_NORMAL
- en: Fixing the operator logic
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The most evident flow in our operator is that it tries to recreate existing
    collections. Running it twice in a row creates the **Mesh.001** and **Light.001**
    collections, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.13: Unwanted collections are created](img/Figure_3.13_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.13: Unwanted collections are created'
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding duplicate collections
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We should create the mesh collection only if it doesn’t exist already. Note
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of that, we should create a new one, only if looking it up causes a
    `KeyError` error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: To be more generic, we can write a function that takes the collection name as
    an argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'The function presented in the following code block starts with a very descriptive
    docstring that can help to give a better idea of what a function should do and
    how to implement it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Querying object types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We could create unique collections using the preceding function – for instance,
    `get_collection("Mesh")` – but we don’t need to mention the object type explicitly;
    the `Object.type` parameter returns the type as a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Strings can also be formatted nicely via their `.``title()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is our operator execution block after the rewrite:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This version is more elegant and supports objects of any type. There is still
    a bug that we will fix shortly. Before we come to that, we need to reload the
    script to use this new version.
  prefs: []
  type: TYPE_NORMAL
- en: Reloading scripts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Blender and Python store used scripts in memory; therefore, changes made to
    the code will not have an immediate effect. There is a Blender command that reloads
    the scripts, which we can look up in the search bar:'
  prefs: []
  type: TYPE_NORMAL
- en: Press the *F3* key to go to the search bar.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start typing `reload scr` in the search field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the operator, **script.reload ·** **Reload Scripts**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.14: Invoking the Reload Scripts operator](img/Figure_3.14_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.14: Invoking the Reload Scripts operator'
  prefs: []
  type: TYPE_NORMAL
- en: This command reloads all the scripts and spares us from having to restart Blender
    every time. Our add-ons now use the latest `.py` files on disk, and we can verify
    that our collections are created only once.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding re-assignment errors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While executing `RuntimeError` error. We’ll see this error pop up if we run
    our operator a second time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to enclose object linking in a `try`/`catch` statement to avoid that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This should be replaced with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This way, no action is taken for objects that were already collected and the
    operator moves on to the rest of the scene.
  prefs: []
  type: TYPE_NORMAL
- en: Don’t try too hard!
  prefs: []
  type: TYPE_NORMAL
- en: We should always make sure that the actions contained inside a `try` block are
    minimal – these statements should not be used lightly. There is no obvious rule,
    but if we are trying more than two lines in a block, we should probably rethink
    our code so that it is less error-prone.
  prefs: []
  type: TYPE_NORMAL
- en: Our final operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can add more objects to the scene by invoking the **Add** menu from the viewport
    or using the *Shift* + *A* shortcut. We can add objects of different types, such
    as **Text**, **Speaker**, **Empty** | **Plain Axes**, and even a few new meshes
    such as **Cylinder** and **Sphere**, and run **Create Type Collections** again.
    We can see that each object is assigned to a collection named after its type.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.15: Every object type gets its own collection](img/Figure_3.15_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.15: Every object type gets its own collection'
  prefs: []
  type: TYPE_NORMAL
- en: The nice thing is we didn’t have to account manually for all the object types
    – once a procedural workflow is in place, it will work with objects of all types,
    even those that will be added in future releases of Blender.
  prefs: []
  type: TYPE_NORMAL
- en: Our operator is complete; what is missing is an easy way to invoke it. We will
    finish the chapter by learning how to display an operator inside a menu of the
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: Extending menus
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Menus present many advantages – they are everywhere in the application, they
    cover a specific aspect of the 3D workflow, and new items can be added easily.
    We are going to handle the addition and removal of new menu entries in our add-on
    – our operator will be displayed only when our add-on is enabled.
  prefs: []
  type: TYPE_NORMAL
- en: Draw functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Blender menus accept new items in the form of functions. These functions describe
    how a menu should draw a new entry; they must accept the `self` and `context`
    arguments passed by their menu and have the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We will gain a better grasp of UI elements in [*Chapter 5*](B18375_05.xhtml#_idTextAnchor100).
    For now, we will only add our operator to a menu row. This is how our function
    will look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We can now append this function to a Blender menu and let it display our operator.
  prefs: []
  type: TYPE_NORMAL
- en: Adding menu entries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Blender menus are stored in the `bpy.types` namespace. By convention, the name
    of a menu type follows the following scheme:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'For instance, menus in the 3D view start with `bpy.types.VIEW3D_MT_`. Typing
    that in the Python console and pressing *Tab* will show the menus available in
    the viewport as a suggestion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Since `bpy.types.VIEW3D_MT_object` menus:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The `bpy.types.VIEW3D_MT_object` is the `VIEW3D_MT_pose_context_menu`. We use
    this one in our example, but we could very well use any other menu.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `append()` and `remove()` methods add and remove a draw function from a
    menu. That can be done in the `register()`/`unregister()` functions of our add-on,
    so it becomes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Reloading the scripts, and invoking the right-click menu while in **Object Mode**
    displays our option at the bottom. Now that there is a way to invoke our operator
    in the UI, we can consider our add-on complete and commit our changes.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.16: Our operator added to the context menu](img/Figure_3.16_B18375.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.16: Our operator added to the context menu'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have coded a complete add-on that expands Blender functionalities
    and integrates seamlessly into an application. We have also learned how to work
    on our code while it is being used and improve our tools through consecutive steps
    of refinement.
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 4*](B18375_04.xhtml#_idTextAnchor075)*,* we will learn how to affect
    the position and rotation of Blender objects via Python, and we will add interactive
    properties to our operator.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the difference between a Python script and a Blender add-on?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which advantages does an add-on provide over sparse code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What do operators do?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do we define the conditions under which an operator can be executed?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can we work on an add-on while it is being used? How do we update it?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do we ignore bytecode (`.pyc`) files in Git version control?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do we avoid creating duplicates?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
