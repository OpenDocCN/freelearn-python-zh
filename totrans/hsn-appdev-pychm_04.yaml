- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Editing and Formatting with Ease in PyCharm
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在PyCharm中轻松编辑和格式化
- en: 'Leonardo Da Vinci, the great painter and sculptor, mused that his sculptures
    were fully formed in the blocks of stone from the quarry before he even saw the
    marble. Da Vinci explained that all he did was remove the pieces of marble that
    were not required for the form. In other words, his masterpieces were completed
    in his mind before a chisel touched the crude stone. In many ways, you are Da
    Vinci. You have a project in your head, fully formed, and you are eager to show
    the world your masterpiece. Instead of using a hammer and chisel to write your
    code, you are using PyCharm. In the previous chapters, we worked through the installation
    process and configuration of PyCharm. We also set up an interpreter for your project.
    Next up: the exploration of the main tools that you will use to craft your masterpiece,
    which mainly reside in the editor.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 列奥纳多·达·芬奇，这位伟大的画家和雕塑家，曾沉思他的雕塑在看到大理石之前就已经在采石场的石块中完全成型。达·芬奇解释说，他所做的只是移除那些对于形状不需要的大理石块。换句话说，他的杰作是在雕刻刀触及粗糙的石头之前，在他的脑海中完成的。在许多方面，你就是达·芬奇。你心中有一个完整的项目，渴望向世界展示你的杰作。你不用锤子和雕刻刀来编写代码，而是使用PyCharm。在前几章中，我们完成了PyCharm的安装过程和配置。我们还为你的项目设置了解释器。接下来：探索你将用来打造杰作的主要工具，这些工具主要位于编辑器中。
- en: By now, you have discovered many of the obvious features of the editor. We know
    it handles a lot of the PEP-8 syntax rules automatically. We know we get the color-coded
    syntax. We also have observed that the **integrated development environment**
    (**IDE**) will make suggestions on several different areas of coding, ranging
    from linting style rules to auto-completion.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经发现了编辑器中许多明显的功能。我们知道它自动处理许多PEP-8语法规则。我们知道我们得到了彩色编码的语法。我们还观察到，**集成开发环境**（**IDE**）将在编码的多个不同领域提供建议，从代码风格规则检查到自动补全。
- en: 'This chapter will focus on the features of the editor that are less obvious.
    The product’s documentation provides keyboard shortcuts and editor basics that
    will not be discussed in this chapter. Instead, the following topics will be covered:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将重点关注编辑器中不那么明显的功能。产品的文档提供了键盘快捷键和编辑器基础知识，这些内容在本章中不会讨论。相反，以下主题将被涵盖：
- en: Real-time code inspection with automated fixes, which allows you to focus on
    development goals rather than on the rules of Python coding.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实时代码检查和自动修复，这允许你专注于开发目标，而不是Python编码的规则。
- en: Various code-completion support features in PyCharm and how to leverage them.
    By using these, you’ll be able to code more quickly and more accurately. We will
    only focus on those tools that ship with PyCharm versus third-party **artificial
    intelligence** (**AI**) enhancements that require plugins such as Kite or GitHub
    Copilot. These will be covered in [*Chapter 15*](B19644_15.xhtml#_idTextAnchor379).
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PyCharm中的各种代码补全支持功能以及如何利用它们。通过使用这些功能，你将能够更快、更准确地编写代码。我们只会关注PyCharm自带而非需要插件如Kite或GitHub
    Copilot的第三方**人工智能**（**AI**）增强工具。这些将在[*第15章*](B19644_15.xhtml#_idTextAnchor379)中介绍。
- en: Refactoring tools that allow you to polish and refine your code into the masterpiece
    that it can become through patience, discipline, and good tooling.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重构工具，允许你通过耐心、纪律和良好的工具将你的代码打磨成杰作。
- en: Documentation tools that will take you from the level of “good developer” to
    the level of “master developer.” It’s one thing to invent an amazing work of code.
    Documenting it so others can benefit from it takes your work to another level.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文档工具，将带你从“优秀开发者”的水平提升到“大师开发者”的水平。发明一个惊人的代码作品是一回事。记录它，让其他人从中受益，则将你的工作提升到了另一个层次。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In order to proceed through this chapter and the rest of the book, you will
    need the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了继续阅读本章和本书的其余部分，你需要以下内容：
- en: An installed and working Python interpreter. I’ll be using the latest from [https://python.org](https://python.org).
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个已安装并正常工作的Python解释器。我将使用来自[https://python.org](https://python.org)的最新版本。
- en: Installed copies of `pip` and `virtualenv`. You get these automatically when
    you install Python on Windows, and MacOS has them included on every system. If
    you are using Linux, you need to install the package managers, such as `pip`,
    and virtual environment tools, such as `virtualenv`, separately. Our examples
    will use `pip` and `virtualenv`.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装好的`pip`和`virtualenv`副本。当您在Windows上安装Python时，这些会自动获得，而MacOS则将它们包含在每一个系统中。如果您使用Linux，您需要单独安装包管理器，如`pip`，以及虚拟环境工具，如`virtualenv`。我们的示例将使用`pip`和`virtualenv`。
- en: An installed and working copy of PyCharm. Installation was covered in [*Chapter
    2*](B19644_02.xhtml#_idTextAnchor028).
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装并运行PyCharm的副本。安装过程在[*第二章*](B19644_02.xhtml#_idTextAnchor028)中已有介绍。
- en: This book’s sample source code from GitHub can be found at [https://github.com/PacktPublishing/Hands-On-Application-Development-with-PyCharm---Second-Edition/tree/main/chapter-04](https://github.com/PacktPublishing/Hands-On-Application-Development-with-PyCharm---Second-Edition/tree/main/chapter-04).
    We covered cloning the code in [*Chapter 2*](B19644_02.xhtml#_idTextAnchor028),
    *Installation* *and Configuration*.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以在GitHub上找到这本书的示例源代码，地址为[https://github.com/PacktPublishing/Hands-On-Application-Development-with-PyCharm---Second-Edition/tree/main/chapter-04](https://github.com/PacktPublishing/Hands-On-Application-Development-with-PyCharm---Second-Edition/tree/main/chapter-04)。我们已经在[*第二章*](B19644_02.xhtml#_idTextAnchor028)中介绍了代码的克隆，*安装*和*配置*。
- en: Code analysis, inspection, and suggestion
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码分析、检查和建议
- en: Intelligent code completion is essential to any programming tool’s adoption.
    The definition of a good code completion engine is one that is aware of high-level
    aspects of programming, including specifics of language syntax. The engine also
    must be aware of the lower-level specifics of the program you write. Many enhanced
    text editors support code completion but lack this level of sophistication. PyCharm
    stands out as an exceptionally sophisticated code editor, encompassing both the
    historical and modern aspects of code editors and offering a level of sophistication
    that surpasses many other enhanced text editors in terms of intelligent code completion.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 智能代码补全对于任何编程工具的采用都是必不可少的。一个好的代码补全引擎的定义是它能够了解编程的高级方面，包括语言语法的具体细节。引擎还必须了解你所编写的程序的底层具体细节。许多增强型文本编辑器支持代码补全，但缺乏这种高级的复杂性。PyCharm作为一个异常复杂的代码编辑器脱颖而出，它包含了代码编辑器的历史和现代方面，并且在智能代码补全方面超越了其他许多增强型文本编辑器。
- en: 'The most common form of code completion is a large picklist of words that are
    matched as you type. The list of possibilities narrows as more letters are typed.
    Notepad++ is an enhanced text editor widely used by developers. I consider it
    a must-have tool for quick and easy edits when I am too impatient to wait on an
    IDE to fully load. *Figure 4**.1* shows a session where I began typing some Python
    code:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 代码补全最常见的形式是在您输入时匹配的单词的大列表。随着更多字母的输入，可能性的列表会缩小。Notepad++是一个被开发者广泛使用的增强型文本编辑器。当我太没有耐心等待IDE完全加载时，我认为它是快速轻松编辑的必备工具。*图4.1*显示了我在输入一些Python代码的会话：
- en: '![Figure 4.1: Notepad++ uses a very simple mechanism for code highlighting
    and completion](img/B19644_04_01.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图4.1：Notepad++使用一个非常简单的机制进行代码高亮和补全](img/B19644_04_01.jpg)'
- en: 'Figure 4.1: Notepad++ uses a very simple mechanism for code highlighting and
    completion'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1：Notepad++使用一个非常简单的机制进行代码高亮和补全
- en: 'The tool does not intuitively know what is being typed; therefore, I must tell
    it that I am coding in Python. After the language is set, it will attempt to autocomplete
    everything, even though such an exercise is clearly futile. In *Figure 4**.1*,
    I was going to type the following:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 工具并不能直观地知道正在输入什么；因此，我必须告诉它我正在用Python编写代码。在设置完语言后，它将尝试自动补全一切，尽管这样的练习显然是徒劳的。在*图4.1*中，我打算输入以下内容：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This clearly isn’t going to win me any Jolt awards. You see in the screenshot
    that the list is filtering a known list of words. Its only contextual point of
    reference is knowing that the file is a Python file. This isn’t very effective,
    but it is better than nothing.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这显然不会为我赢得任何Jolt奖项。您可以从截图看到，列表正在过滤一个已知的单词列表。它的唯一上下文参考点是知道该文件是一个Python文件。这并不非常有效，但总比没有好。
- en: 'Systems like these are little more than spell checkers. While a seasoned pro
    might scoff at the usefulness of such a simple system, the earliest IDEs that
    displayed this level of wizardry pioneered a feature we are now unwilling to live
    without: code completion.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的系统几乎只是拼写检查器。虽然经验丰富的专业人士可能会嘲笑这样一个简单系统的有用性，但最早显示这种魔法般功能的IDE开创了一个我们现在不愿意没有的功能：代码完成。
- en: 'PyCharm lies at the opposite end of the spectrum with respect to sophistication.
    Like Notepad++, PyCharm is aware of the keywords that comprise PyCharm. PyCharm,
    though, is able to glean insight into the structure of the objects that make up
    the standard library. *Figure 4**.2* shows me typing some code into PyCharm, having
    created a simple file for this example:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: PyCharm在复杂度方面处于光谱的另一端。就像Notepad++一样，PyCharm能够识别构成PyCharm的关键词。然而，PyCharm还能够洞察组成标准库的对象结构。“图4.2”展示了我在PyCharm中输入一些代码，为这个示例创建了一个简单的文件：
- en: '![Figure 4.2: PyCharm auto-completes based on its understanding of the time
    library](img/B19644_04_02.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图4.2：PyCharm根据其对时间库的理解进行自动完成](img/B19644_04_02.jpg)'
- en: 'Figure 4.2: PyCharm auto-completes based on its understanding of the time library'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2：PyCharm根据其对时间库的理解进行自动完成
- en: In this case, I have imported the `time` library just as I did in the Notepad++
    example from *Figure 4**.1*. I’m a little further along here. I have my function
    defined, and I’m going to simply print the current local time using the `time`
    library I had already imported. As you can see in *Figure 4**.2*, PyCharm is offering
    completion against the contents of the time library.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我像在“图4.1”中的Notepad++示例中那样导入了`time`库。我已经进行了一步，定义了我的函数，接下来我将简单地使用已经导入的`time`库打印当前本地时间。正如您在“图4.2”中可以看到的，PyCharm正在根据对时间库的理解提供自动完成建议。
- en: Completing the auto-completion
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 完成自动完成
- en: Once the auto-completion list appears, you can press *Tab* or *Enter* to select
    the highlighted option. You can use the up and down arrow keys to move through
    the list, or you can click any of the list items with your mouse. You’ll work
    fastest, though, if you keep your fingers on the keyboard.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦自动完成列表出现，您可以按*Tab*或*Enter*键选择高亮选项。您可以使用上箭头和下箭头键在列表中移动，或者用鼠标点击列表中的任何项。不过，如果您保持手指在键盘上，您的工作速度会更快。
- en: By now, you are starting to appreciate the code completion system offered by
    PyCharm. Let us further explore the capabilities of this important tool.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，您已经开始欣赏PyCharm提供的代码完成系统。让我们进一步探索这个重要工具的功能。
- en: It duzunt assewm yew cna spel
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它duzunt assewm yew cna spel
- en: Our simplistic word-list example from Notepad++ earlier already stands in sharp
    contrast to the more sophisticated features of PyCharm’s auto-completion engine.
    Let’s dig a little deeper. If your tool relies on a word list, then the second
    your spelling steps out of line, your suggestion list dries up. In effect, the
    word-list method requires you to know what it is you are looking for while requiring
    it to be spelled correctly.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前从Notepad++中的简单单词列表示例已经与PyCharm自动完成引擎的更复杂功能形成了鲜明对比。让我们进一步挖掘。如果您的工具依赖于单词列表，那么一旦您的拼写出错，建议列表就会枯竭。实际上，单词列表方法要求您知道您要找的是什么，同时要求拼写正确。
- en: 'In *Figure 4**.3*, you will see something a little different:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在“图4.3”中，您将看到一些不同之处：
- en: '![Figure 4.3: PyCharm finds all possibilities containing the text you’ve typed](img/B19644_04_03.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图4.3：PyCharm找到包含您已输入文本的所有可能性](img/B19644_04_03.jpg)'
- en: 'Figure 4.3: PyCharm finds all possibilities containing the text you’ve typed'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3：PyCharm找到包含您已输入文本的所有可能性
- en: PyCharm is designed to offer suggestions based on the letters that are typed.
    In other words, as you type `cl`, the word *clock* might appear. The word *clock*
    will also appear if you type `lo`, `ck`, or any consecutive letters contained
    in the list of keywords matched. Perfectly spelled words are not necessary. Just
    get in the ballpark, and the word you are searching for will likely pop up.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: PyCharm被设计成根据输入的字母提供建议。换句话说，当您输入`cl`时，单词`clock`可能会出现。如果您输入`lo`、`ck`或任何包含在匹配关键词列表中的连续字母，`clock`单词也会出现。不需要拼写正确。只要接近正确，您要找的单词很可能会出现。
- en: It understands your code
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它理解您的代码
- en: Good code completion is able to understand and autocomplete based on the language
    and the libraries in use. In our case, that’s Python, which has an enormous standard
    library compared to other languages. Python is designed around a “batteries included”
    philosophy. Contrast that with JavaScript as implemented in Node.js, where the
    only libraries you get are file and HTTP libraries. The .NET languages give you
    a small core. You can say the same about Golang. Most languages require you to
    use the package manager. The fact that PyCharm can do this is spectacular by itself.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的代码补全功能能够根据所使用的语言和库来理解和自动补全。在我们的案例中，那就是Python，与其他语言相比，Python拥有庞大的标准库。Python的设计理念是“内置电池”。与之相比，在Node.js中实现的JavaScript，你只能获得文件和HTTP库。.NET语言给你的是一个小的核心。对于Golang也可以这么说。大多数语言都需要你使用包管理器。PyCharm能够做到这一点本身就非常出色。
- en: 'PyCharm, being a great IDE, can also understand the code you’ve written. *Figure
    4**.4* shows the `autocomplete_demo.py` file, where I have added an import to
    the `no_problemo.py` file. The `no_problemo.py` file has one function in it called
    `perfection()`. As you can see, PyCharm is able to see inside the file and provide
    autocompletion on the code I have written versus simply doing auto-complete from
    a language-based word list:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: PyCharm作为一个优秀的IDE，也能理解您所编写的代码。*图4*.4显示了`autocomplete_demo.py`文件，我在其中添加了对`no_problemo.py`文件的导入。`no_problemo.py`文件中有一个名为`perfection()`的函数。正如您所看到的，PyCharm能够查看文件内部并提供关于我所编写代码的自动补全，而不仅仅是基于语言词汇表的自动补全：
- en: '![Figure 4.4: PyCharm provides autocompletion suggestions on the code you’ve
    written, as well as standard Python language and the standard library](img/B19644_04_04.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图4.4：PyCharm在您所编写的代码上提供自动补全建议，以及标准Python语言和标准库](img/B19644_04_04.jpg)'
- en: 'Figure 4.4: PyCharm provides autocompletion suggestions on the code you’ve
    written, as well as standard Python language and the standard library'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4：PyCharm在您所编写的代码上提供自动补全建议，以及标准Python语言和标准库
- en: I am offered auto-completion on the function name, as well as hints on the **method
    signature**. If you’re unfamiliar with the term *method signature*, it simply
    refers to the name, argument list, and return values for a function or method.
    If you’ve included type hints, PyCharm will remind you of the argument names and
    types the function or method requires. This works with modules as well as classes
    if you’re using **object-oriented** **programming** (**OOP**).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我得到了关于函数名的自动补全，以及关于**方法签名**的提示。如果您不熟悉“方法签名”这个术语，它仅仅是指函数或方法的名称、参数列表和返回值。如果您已经包含了类型提示，PyCharm会提醒您函数或方法需要的参数名称和类型。这同样适用于模块以及类，如果您正在使用**面向对象**的**编程**（**OOP**）。
- en: Postfix code completion
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 后缀代码补全
- en: 'Traditional code completion has been taken to the next level in PyCharm, but
    we are far from finished. Usually, hitting the period (*.*) key on your keyboard
    triggers a list to appear. We are now used to that list containing what might
    come after the dot. However, what if PyCharm could give you suggestions on what
    might come *before* the dot? In *Figure 4**.5*, we see an example of postfix code
    completion, which you will find in the `postfix_example.py` file in the [*Chapter
    4*](B19644_04.xhtml#_idTextAnchor077) sample code:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在PyCharm中，传统的代码补全已经被提升到了一个新的水平，但我们还没有完成。通常，在键盘上按住句号(*)键会触发一个列表出现。我们已经习惯了这个列表包含点之后可能出现的代码。然而，如果PyCharm能够给出点之前可能出现的代码建议呢？在*图4*.5中，我们看到一个后缀代码补全的例子，您可以在[*第4章*](B19644_04.xhtml#_idTextAnchor077)示例代码中的`postfix_example.py`文件中找到：
- en: '![Figure 4.5: Postfix completion in PyCharm can suggest what might come before
    the dot rather than simply what might come after](img/B19644_04_05.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图4.5：PyCharm中的后缀补全可以建议在点之前可能出现的代码，而不仅仅是点之后可能出现的代码](img/B19644_04_05.jpg)'
- en: 'Figure 4.5: Postfix completion in PyCharm can suggest what might come before
    the dot rather than simply what might come after'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.5：PyCharm中的后缀补全可以建议在点之前可能出现的代码，而不仅仅是点之后可能出现的代码
- en: 'I can’t blame you if you are confused by seeing `.if` (if expr) as a possibility
    following what is clearly a string-typed variable. The `.if` suggestion is not
    part of Python. It is a **postfix suggestion**. If you complete this suggestion
    your code is transformed. The following code isn’t viable Python syntax:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您看到`.if`（if expr）作为紧跟一个明显是字符串类型的变量的可能选项而感到困惑，我并不怪您。`.if`建议不是Python的一部分。它是一个**后缀建议**。如果您完成这个建议，您的代码将被转换。以下代码不是有效的Python语法：
- en: '[PRE1]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Therefore, it is converted to the following:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，它被转换为以下内容：
- en: '[PRE2]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Just imagine the possibilities! However, if you’re not the imaginative type,
    check out *Figure 4**.6*, which shows PyCharm’s **Postfix Completion** configuration
    options:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下所有可能的情况！然而，如果你不是那种富有想象力的人，请查看*图4**.6*，它显示了PyCharm的**后缀完成**配置选项：
- en: '![Figure 4.6: PyCharm’s Postfix Completion configuration options](img/B19644_04_06.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图4.6：PyCharm的后缀完成配置选项](img/B19644_04_06.jpg)'
- en: 'Figure 4.6: PyCharm’s Postfix Completion configuration options'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.6：PyCharm的后缀完成配置选项
- en: Naturally, these options are fully configurable. You can even add your own!
    The templates are not limited to Python. You can see in the list that there are
    configurations for TypeScript, JavaScript, and **Structured Query Language** (**SQL**).
    This is important because application development is rarely limited to the scope
    of just the Python language.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 自然，这些选项是完全可配置的。你甚至可以添加自己的！模板不仅限于Python。你可以在列表中看到，有TypeScript、JavaScript和**结构化查询语言**（**SQL**）的配置。这是因为应用程序开发很少仅限于Python语言的范围。
- en: Hippie completion
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 嘿皮士完成
- en: Hey, man! You wanna see something that is like totally far out? It’s called
    **cyclic word expansion**. Only total squares call it that, though. If you wanna
    be *hip*, you’ll call it **hippie completion**!
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 嘿，伙计！你想看看一些绝对超凡脱俗的东西吗？它被称为**循环词扩展**。不过，只有真正的老派人才会这样叫它。如果你想显得*嬉皮士*，你会称它为**嬉皮士完成**！
- en: 'Hippie completion is invoked by pressing *Alt* + */* (Windows and Linux) or
    *⌥* + */* on macOS. Once triggered, PyCharm will index all the files you currently
    have open and provide auto-completion suggestions based on words within that context.
    In effect, you are using the simplest form of auto-complete; a word list. The
    word list is generated on the fly from the words in the files you have open. They
    don’t have to be code. Plain text files, markup, markdown, or really any text
    will show up in the suggestions list based on a simple forward match. As you type,
    the list narrows. You can see an example in *Figure 4**.7*:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 嘿皮士完成是通过按*Alt* + */*（Windows和Linux）或*⌥* + */*在macOS上触发的。一旦触发，PyCharm将索引你当前打开的所有文件，并根据该上下文中的单词提供自动完成建议。实际上，你正在使用最简单的自动完成形式；一个单词列表。单词列表是实时从你打开的文件中的单词生成的。它们不必是代码。纯文本文件、标记、Markdown或任何文本都会根据简单的正向匹配出现在建议列表中。随着你输入，列表会缩小。你可以在*图4**.7*中看到一个例子：
- en: '![Figure 4.7: Hippie completion is totally far-out!](img/B19644_04_07.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图4.7：嬉皮士完成绝对超凡脱俗！](img/B19644_04_07.jpg)'
- en: 'Figure 4.7: Hippie completion is totally far-out!'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.7：嬉皮士完成绝对超凡脱俗！
- en: The text file on the right contains a list of words I generated at [https://fungenerators.com/lorem-ipsum/hippie/](https://fungenerators.com/lorem-ipsum/hippie/).
    Unfortunately, it turns out, a lot of the iconic words from the hippie generation
    in the United States cannot be printed in a book of this caliber. We have the
    highest standards! So, I edited the list, and this was all that was left. These
    words are random, so please don’t try to construe any meaning from them, despite
    all the allegations about there being secret backward messages on albums by The
    Beatles. The code on the right can expand from that list using hippie completion.
    To make this work, I typed `print("pat` then pressed *Alt* + */*. The word *patchouli*
    magically appeared! I hope this example was worth it for you. I may never get
    that smell out of my keyboard!
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 右侧的文本文件包含了我从[https://fungenerators.com/lorem-ipsum/hippie/](https://fungenerators.com/lorem-ipsum/hippie/)生成的单词列表。不幸的是，结果发现，美国嬉皮士一代的许多标志性词汇无法在这个级别的书中印刷。我们的标准是最高的！因此，我编辑了列表，这就是剩下的所有内容。这些单词是随机的，所以请不要试图从它们中推断出任何含义，尽管有关于披头士专辑上存在秘密反向信息的所有指控。右侧的代码可以使用嬉皮士完成从该列表中扩展。为了使这起作用，我输入了`print("pat`然后按了*Alt*
    + */*。神奇地出现了单词*patchouli*！我希望这个例子对你来说是有价值的。我可能永远无法从我的键盘上消除那种气味！
- en: You can use *Alt* + *Shift* + */* or *⌥* + *Shift* + */* to enable backward
    cyclic word expansion, which matches from the end of the words backward to the
    beginning. If the powers that be had asked me (and they didn’t, because they never
    do) I’d have called this `#GingerRogersCompletion` and reference this book, it
    might catch on!
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用*Alt* + *Shift* + */*或*⌥* + *Shift* + */*来启用反向循环词扩展，它从单词的末尾向后匹配到开头。如果当权者问我（他们没有，因为他们从不这样做）我会称这个为`#GingerRogersCompletion`并引用这本书，它可能会流行起来！
- en: Pro hippie tip
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 嘿皮士小贴士
- en: Repeatedly pressing *Alt* + */* (Windows and Linux) or *⌥* + */* on macOS cycles
    through the list. You can just keep hitting the key combination until the word
    you are looking for appears.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 重复按 *Alt* + */*（Windows 和 Linux）或 *⌥* + */*（macOS）会在列表中循环。你可以一直按这个键组合，直到出现你想要的单词。
- en: Indexing
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 索引
- en: 'There are various engines at work in powering PyCharm’s various code completion
    techniques. You might be wondering how it works. It isn’t dark sorcery, I assure
    you. The key to understanding it is to pay attention when PyCharm loads a project.
    *Figure 4**.8* calls your attention to the bottom of the PyCharm application window.
    PyCharm kicks off several background processes that comb through your code and
    index every character. The index is then converted into an in-memory database
    that is used by the various engines at play:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在为 PyCharm 的各种代码补全技术提供动力方面，有各种引擎在发挥作用。你可能想知道它是如何工作的。我向你保证，这并不是黑暗魔法。理解它的关键是注意
    PyCharm 加载项目时的行为。*图 4.8* 引导你的注意力到 PyCharm 应用程序窗口的底部。PyCharm 启动几个后台进程，这些进程会遍历你的代码并对每个字符进行索引。然后，索引被转换成一个内存数据库，该数据库被各种引擎使用：
- en: '![Figure 4.8: Keep an eye on the bottom of the PyCharm window to know when
    background processes such as indexing are running](img/B19644_04_08.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.8：注意 PyCharm 窗口的底部，以了解索引等后台进程何时运行](img/B19644_04_08.jpg)'
- en: 'Figure 4.8: Keep an eye on the bottom of the PyCharm window to know when background
    processes such as indexing are running'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.8：注意 PyCharm 窗口的底部，以了解索引等后台进程何时运行
- en: Normally, I don’t really care how the magic works, but it is worth bringing
    up because there will be times when PyCharm seems slow or unresponsive. When PyCharm
    seems slow or if auto-completion isn’t working, check the area of the screen indicated
    in *Figure 4**.8* and see whether there are indexing processes running. You’ll
    probably notice your CPU spike as well if you monitor such things. This is temporary.
    Once the indexing process completes, PyCharm will become responsive again.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我并不真的关心魔法是如何工作的，但这是值得提及的，因为有时 PyCharm 可能会显得缓慢或无响应。当 PyCharm 显得缓慢或自动补全功能不起作用时，检查
    *图 4.8* 中指示的屏幕区域，看看是否有索引进程正在运行。如果你监控这类事情，你可能会注意到你的 CPU 会突然升高。这是暂时的。一旦索引过程完成，PyCharm
    将再次变得响应。
- en: Power Save Mode
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 节能模式
- en: 'One of the more cryptic entries in the PyCharm menu, shown in *Figure 4**.9*,
    is **Power** **Save Mode**:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: PyCharm 菜单中较为晦涩的条目之一，如 *图 4.9* 所示，是 **节能模式**：
- en: '![Figure 4.9: The Power Save Mode menu option can be found under the File menu](img/B19644_04_09.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.9：节能模式菜单选项可以在文件菜单下找到](img/B19644_04_09.jpg)'
- en: 'Figure 4.9: The Power Save Mode menu option can be found under the File menu'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.9：节能模式菜单选项可以在文件菜单下找到
- en: I remember the first time I clicked it. The streetlights throughout the city
    block where I live instantly got brighter. My electric meter that was spinning
    like a buzzsaw mere minutes ago was now lazily spinning slower than an abandoned
    top. Once, a guy at the power company even called and thanked me for doing my
    part in saving the planet.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我记得第一次点击它的时候。我住的城市街道的街灯瞬间变得更亮了。几分钟前像锯子一样旋转的电表现在懒洋洋地转得比废弃的陀螺还慢。有一次，电力公司的一个家伙甚至打电话来感谢我为拯救地球做出的贡献。
- en: 'OK, I’m making all that up, except for the part about the guy from the power
    company. That totally happened. The `b.if` from the earlier example:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，我编造了所有那些内容，除了关于电力公司那人的部分。那绝对是真实发生的。早期示例中的 `b.if`：
- en: '![Figure 4.10: A message reminds you that power save mode is on and that you
    will not be receiving the usual level of assistance from PyCharm](img/B19644_04_10.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.10：一条消息提醒你节能模式已开启，并且你将不会从 PyCharm 收到通常的水平支持](img/B19644_04_10.jpg)'
- en: 'Figure 4.10: A message reminds you that power save mode is on and that you
    will not be receiving the usual level of assistance from PyCharm'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.10：一条消息提醒你节能模式已开启，并且你将不会从 PyCharm 收到通常的水平支持
- en: Personally, I consider this utterly barbaric! How are we supposed to work like
    this? Next, you’ll be telling me I don’t have access to the internet, Kite, GitHub
    Copilot, ChatGPT, or Stack Overflow! You’ll strip me of my very reasonably priced
    subscription to [packtpub.com](http://packtpub.com), where I can get all the e-books
    I can read for one low price. Then you’ll take away my Herman Miller Aeron Chair
    and limit me to only one $14 mezzo-Grande half-fat triple foam double shot latte
    with rainbow jasmine-infused sprinkles per day! Why don’t you enact a dress code
    while you’re at it? Strike! Strike! Strike!
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 个人来说，我认为这完全是野蛮的！我们该如何工作呢？接下来，您会告诉我我没有访问互联网、Kite、GitHub Copilot、ChatGPT或Stack
    Overflow！您将剥夺我合理价格的[packtpub.com](http://packtpub.com)订阅权，在那里我可以以一个低廉的价格阅读所有我可以读的电子书。然后您会拿走我的Herman
    Miller Aeron椅子，并限制我每天只能喝一杯14美元的中等大杯半脂三倍泡沫双份浓缩咖啡，上面撒上彩虹茉莉花味的糖霜！为什么您还要实施着装规定呢？打倒！打倒！打倒！
- en: 'Sorry. I got a little carried away. Needless to say, this is probably the least
    favorite feature of the IDE. Maybe it is useful if you chewed up your laptop’s
    battery playing *Ghost Recon: Breakpoint* on an overseas flight, and upon landing,
    you suddenly get a call from the boss who needs something fixed right away. Suddenly,
    you need to squeeze every second out of that 5% battery level you have left. I
    hate it when that happens.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 抱歉。我有点过于激动了。不用说，这可能是IDE中最不受欢迎的功能。也许如果您在国外航班上玩*幽灵行动：断点*耗尽了笔记本电脑的电池，着陆后突然接到老板的电话，需要立即修复某些东西，这可能会有些用。突然，您需要从剩余的5%电池电量中榨取每一秒。当这种情况发生时，我真的很讨厌。
- en: Customizing code completion
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义代码补全
- en: Customization within PyCharm is an ongoing theme. It might have been easier
    to show you what you can’t customize, except that I haven’t actually found anything
    yet. Code completion is no different. Whether you prefer a very lightweight experience
    with little to no help or you want your handheld on every line of code, there
    is a way to make PyCharm into the editor you want to use every day.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在PyCharm中进行自定义是一个持续的主题。展示您无法自定义的内容可能更容易，但我实际上还没有找到任何东西。代码补全也不例外。无论您更喜欢非常轻量级的体验，几乎不需要帮助，还是希望每行代码都有指导，PyCharm都可以满足您的需求。
- en: 'To open the settings for code completion, venture back to the settings dialog
    we explored in [*Chapter 2*](B19644_02.xhtml#_idTextAnchor028), *Installation
    and Configuration*. You can reach it easily by clicking the **File** menu item
    and selecting **Settings**. That brings up the settings dialog. If you recall
    from [*Chapter 2*](B19644_02.xhtml#_idTextAnchor028), *Installation and Configuration*,
    this dialog is massive! We’re looking for **Editor** | **General** | **Code Completion**,
    as shown in *Figure 4**.11*:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 要打开代码补全的设置，请回到我们在[*第2章*](B19644_02.xhtml#_idTextAnchor028)，*安装和配置*中探索的设置对话框。您可以通过点击**文件**菜单项并选择**设置**轻松访问它。这会弹出设置对话框。如果您还记得[*第2章*](B19644_02.xhtml#_idTextAnchor028)，*安装和配置*，这个对话框是巨大的！我们正在寻找**编辑器**
    | **常规** | **代码补全**，如图*图4.11*所示。11*：
- en: '![Figure 4.11: The Code Completion settings allow you to customize the behavior
    of PyCharm’s Code Completion engine](img/B19644_04_11.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图4.11：代码补全设置允许您自定义PyCharm代码补全引擎的行为](img/B19644_04_11.jpg)'
- en: 'Figure 4.11: The Code Completion settings allow you to customize the behavior
    of PyCharm’s Code Completion engine'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.11：代码补全设置允许您自定义PyCharm代码补全引擎的行为
- en: You should spend a moment going through everything you can do on this screen.
    PyCharm gives you a great deal of control! I promised this wouldn’t be a tedious
    accounting of every option. Instead, draw your attention to the most popular and
    potentially most useful settings available.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该花点时间浏览一下这个屏幕上您可以做的事情。PyCharm给了您很大的控制权！我承诺这不是一个对每个选项的繁琐记录。相反，我将您的注意力引向最流行和最有潜力的设置。
- en: Match case
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 区分大小写
- en: Located at the top of the window, this option specifies whether items in the
    suggestion list should match the case of whatever you are typing. For example,
    if I wanted to type in an exception expression for the `KeyboardInterrupt` exception
    in Python and the `K` for the correct class name to be included in the suggestion
    list. Next to the **Match case** checkbox, you can also choose only the first
    letter’s case should be matched or whether this should apply to all the letters.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 位于窗口顶部，此选项指定建议列表中的项目是否应该与您输入的内容的大小写匹配。例如，如果我想为Python中的`KeyboardInterrupt`异常输入一个异常表达式，并且想要将正确的类名`K`包含在建议列表中。在**匹配大小写**复选框旁边，您还可以选择仅匹配第一个字母的大小写，或者是否应该匹配所有字母。
- en: 'I personally always disable this checkbox so that I only have to type in, for
    example, a lowercase `k` to take advantage of code completion. When I am learning
    a new language or API, this setting can help me with a practice I call *property
    shopping*. I don’t know what properties and methods are available, so an alphabetized
    list can be helpful. For example, every programming language has some sort of
    string-handling class or library. It is a very safe bet that the said library
    will have functions for trimming, which is to remove extra spaces from the front,
    end, or both ends of a string. There is always some sort of `toUpper` and `toLower`
    methods. These are all vital parts of defensive programming. A password input
    where a user accidentally includes a space at the beginning or end of the password
    makes for a frustrating user experience. Any conditional logic you use involving
    user input is easier to handle if you make everything upper or lowercase. Given
    these are so fundamental to our work, we know they will be on the list, but every
    language calls them something different. I work on projects that require switching
    between two or three languages, and it is very easy to type in the wrong function
    name. Take the method that converts a string to uppercase. In JavaScript, such
    a function looks like this:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我个人总是禁用此复选框，这样我只需输入，例如，小写的`k`，就能利用代码补全功能。当我学习一门新语言或API时，此设置可以帮助我进行我称之为*属性购物*的练习。我不知道有哪些属性和方法可用，因此一个按字母顺序排列的列表可能会有所帮助。例如，每种编程语言都有某种形式的字符串处理类或库。可以非常肯定地说，该库将具有修剪函数，即从字符串的前面、后面或两边去除额外空格。这些`toUpper`和`toLower`方法都是防御性编程的重要组成部分。如果用户在密码输入时意外地在密码的开始或结尾处包含空格，这将导致用户体验不佳。如果您使用涉及用户输入的任何条件逻辑，那么将所有内容都转换为大写或小写将更容易处理。鉴于这些都是我们工作的基础，我们知道它们将在列表中，但每种语言都称它们为不同的名称。我从事的项目需要在不同两种或三种语言之间切换，很容易输入错误的功能名称。以将字符串转换为上档的方法为例。在JavaScript中，这样的函数看起来是这样的：
- en: '[PRE3]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The same code in PyCharm, which I might be creating only minutes later, would
    look like this:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在PyCharm中相同的代码，我可能几分钟内就会创建，看起来是这样的：
- en: '[PRE4]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In order to be effective, I need the word upper to be a match regardless of
    whether it is uppercase or lowercase.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 为了有效匹配，我需要单词“upper”无论大小写都能匹配。
- en: Like everything we have seen in code completion, and for that matter, like everything
    in programming, there is a trade-off to this practice. Specifically, if **Match
    case** is disabled, sometimes the suggestion list might be populated by many more
    irrelevant options, which makes finding the correct API more difficult. At the
    same time, though, you will see a full list of what is possible, which can help
    you learn your way around and sometimes discover features in an API you had not
    imagined were available.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在代码补全中看到的一切，以及编程中的所有事物一样，这种做法也有其权衡。具体来说，如果**匹配大小写**被禁用，有时建议列表可能会包含许多更多的不相关选项，这使得找到正确的API变得更加困难。然而，同时，您将看到所有可能性的完整列表，这可以帮助您熟悉环境，有时还可以发现API中您未曾想象到的功能。
- en: Sorting suggestions alphabetically
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 按字母顺序排序建议
- en: As its name suggests, this option allows you to sort the items in the suggestion
    list in alphabetical order. This feature is useful for long suggestion lists that
    require the developer to scroll through them carefully to find what they are looking
    for if they were not ordered alphabetically.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 正如其名所示，此选项允许您按字母顺序对建议列表中的项目进行排序。对于需要开发者仔细滚动查找所需内容的较长的建议列表，此功能非常有用。
- en: 'On multiple occasions, we have seen the dynamic nature of PyCharm, and it is
    once again demonstrated in this feature. Specifically, while interacting with
    a suggestion list in the editor, you can change the order of the items in the
    list at any time by clicking on the icon located in the bottom-right corner of
    the suggestion window, as shown in *Figure 4**.12*:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.12: You can change the way suggestions are sorted within the list
    itself](img/B19644_04_12.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.12: You can change the way suggestions are sorted within the list
    itself'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: 'Clicking the **…** (ellipsis) element allows you to change how the suggestions
    are sorted: by relevance or alphabetically by name.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: Machine learning assisted completions
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This newer option is simultaneously magical and scary. Enabled by default, PyCharm
    will train a machine learning model based on your code. This allows PyCharm to
    make suggestions based not only on your code but also that of thousands of other
    developers. Traditional code completion usually gives you suggestions for the
    next keyword, property, method name, or parameter you are about to type. Do not
    be surprised if PyCharm offers complete entire functions or blocks of code for
    you with machine learning assisted completions. You will see this for common tasks
    such as connecting to databases, working with pandas data frames, or validating
    user input.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: The settings merely allow you to turn on various languages supported by PyCharm.
    Python, JavaScript, and TypeScript are enabled by default. Only SQL, a special-purpose
    language used for working with relational databases, is not enabled by default.
    I suspect this is because there are additional settings around your preferred
    SQL dialect both at the global and project level that contribute to suggestions.
    It would be awkward to expect a tight list of suggestions given the number of
    databases PyCharm supports and the differences in their implementation of language
    elements not defined by standardized SQL. We’ll look at SQL and relational databases
    later in *Chapter 11*, *Understanding Database Management with PyCharm*. I promise
    the experience will not leave you bankrupt.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: Showing the documentation popup in [...] ms
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you enable this feature, you will see the documentation in addition to
    the suggestion code. You will be able to understand what the code you are typing
    does rather than blindly accepting the suggestions. This is great for new developers,
    whether they are totally new to coding or just new to Python. The advantage of
    this feature is that you can go through the documentation of all the suggested
    items dynamically as you simply move the cursor down the items.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: This is especially beneficial when working with classes and methods that have
    similar APIs. We will discuss this feature, along with other documentation-related
    functionalities, in the last section of this chapter.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: Parameter info
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Scroll down past the JavaScript section, as seen in *Figure 4**.13*, and you’ll
    find an option for suggesting parameter information:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.13: Scroll down past JavaScript to find options for showing parameter
    information](img/B19644_04_11.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.13: Scroll down past JavaScript to find options for showing parameter
    information'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: The first option is straightforward. It controls the amount of time that must
    elapse before a suggestion appears. In general, suggestions are great unless you
    are teaching, doing a code review, or doing some sort of demo, in which case they
    can clutter up your screen. Sometimes it’s a good idea to raise the time limit
    so the suggestions or documentation are shown only if you linger for a few seconds.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: The second option allows you to toggle, showing the full method signature. I
    love this feature. The code hint will show you the whole method signature so you
    can see all the arguments at once.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: 'A method signature uniquely defines a function or method within the scope where
    it is declared. It consists of a name for the function. Along with the names,
    and preferably hints, for the type of the function’s arguments with some hints
    about the return type. These are not unique to Python. In fact, they are a little
    bit fuzzy in Python. Now compare it with a static language such as C#, which uses
    more strict programming structures. In Python, you can use type hints, which help
    developers to remember the expected types of the arguments being passed. Let’s
    look at an example of a method signature without hints:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This is OK. This code will work as intended, and the intention of the developer
    is clear. Let’s look at the same function with hints:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This is much better! Now we know for certain the types that are expected as
    input parameters, and we know the type that is going to be returned. I said earlier
    that method signatures are “fuzzy” in Python. I said this because both code samples
    will work. Python ignores the hints entirely during compilation. The hints are
    just used by the tooling and make your Python code easier to read and understand.
    Adding hints to your code whenever possible will enhance the way you, and your
    teammates, see your method signatures if you turn on the **Show full method**
    **signatures** option.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: Code analysis and automated fixes
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Code completion is a standard feature of most code editors and IDEs. As we’ve
    seen, not all completion engines are created equally. The same can be true for
    analysis engines. A code analysis engine is an extension of code completion in
    concept, if not in implementation. Code completion tries to predict the code you
    are writing and helps you finish more quickly. Code analysis examines the code
    you’ve written and attempts to determine whether or not the code will work when
    you run it. Just as with code completion, there are differing levels of complexity
    at play here and different processes examining different things.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: The simplest form of analysis is called *linting*. Pretty much every programming
    language has a linting tool, and Python is no exception. While there are many
    to choose from, PyCharm uses the popular `pylint` library by default.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: 'A linter runs a tacit analysis of your code through a process of pattern matching.
    There are two linting operations: **logical lint** and **stylistic lint**. A logical
    lint looks for code errors, code with potentially unintentional results or side
    effects, and dangerous code patterns. A stylistic lint looks for code that doesn’t
    conform to common conventions. This is less of a problem with Python since the
    language already has a strict set of code formatting rules called **Python Enhancement
    Proposal #8**. Nobody calls it that. Those in the know simply call it **PEP-8**.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: Combined, you can think of `pylint` and, by extension, all linters, much like
    a spelling and grammar checker for regular text. The linter looks for misspelled
    keywords, malformed code, and obvious syntax errors. A linter can also enforce
    style guidelines, though really Python is already designed to enforce rules to
    make your code as human-readable as possible.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: While it’s one thing to point out problems in your code, it is entirely more
    useful if the tool also suggests and even implements fixes to those problems.
    The same is true of humans. It is easy to point out flaws. Anybody can do that.
    Good advice on how to fix your flaws is more useful than criticism. So, in addition
    to linting, PyCharm offers a system that will offer to help you fix the problems
    exposed by the linter.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: Problem detection
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Problem detection is performed by PyCharm in real time as you type your code.
    The indexing process we’ve mentioned before plays a role here, but we’ll come
    back to that. First, let’s focus on the visible interface in the editor that shows
    you where your problems lie. There are four places to look, as shown in *Figure
    4**.14*:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.14: Four places in the user interface tell you that you have problems](img/B19644_04_14.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.14: Four places in the user interface tell you that you have problems'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: The right gutter of the editor (1) will show you where all the problematic lines
    lie in the currently open file. This gutter is a compressed, miniature representation
    of your file. It is pretty common for a file to have hundreds or maybe even thousands
    of lines. You can click on the area in the gutter where you see the colored marks,
    and the editor will scroll to that location.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: 'PyCharm will classify the problems into three basic categories: errors (red),
    warnings (yellow), and weak warnings (gray). This is reported for the whole file
    at the top of the gutter column with counts of each problem type (2). In addition
    to colors, this area gives you different shapes. The error icon is a round red
    circle with an exclamation point within it. Warnings are a triangle with an exclamation
    point. Weak warnings are also depicted using a triangle with an exclamation, but
    they appear considerably dimmer. If no problems are detected, you are rewarded
    with a green check mark. *Figure 4**.15* shows two files. One has no problems
    (1), while the other has a number of issues in different categories (2):'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.15: The file on the bottom is devoid of any problems, while the
    one on top isn’t quite as lucky](img/B19644_04_15.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.15: The file on the bottom is devoid of any problems, while the one
    on top isn’t quite as lucky'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: Anything marked in red is an error that will probably prevent your program from
    running correctly or at all. A warning means your code will probably run, but
    there are some obvious cases where it won’t perform as expected. A weak warning
    is usually a minor flaw, such as a variable name that doesn’t conform to an English
    dictionary word. If your locale is set to a language other than English, PyCharm
    will flag words from your local language.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: The second place to look for problems is within the editor window itself. Look
    back at *Figure 4**.15* at line 13\. You’ll see a squiggly red (trust me) underline
    beneath the word `math`. The colors of the lines correspond with the severity
    of the problem. The right-hand gutter shows you where the problem is located,
    while the underlines show you the problem directly on the offending line. If you
    hover your mouse over whatever is underlined, you’ll get a description of the
    problem. I’ll go into more depth on this later in this chapter when we talk about
    **intentions**, which are suggestions about how to fix problems in your code.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: 'The third place you’ll find indicators of problems is the project explorer.
    Refer back to *Figure 4**.15*, area 3\. There is a Python package called `bad_actor`.
    That file isn’t open in *Figure 4**.15*, but I opened it when I created it, typed
    in some incomplete code, then closed the file. You can see the file open in *Figure
    4**.16*:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.16: Silly me! I started typing in the file but never finished](img/B19644_04_16.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.16: Silly me! I started typing in the file but never finished'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: If there is an error in the file you aren’t currently working on, you’ll find
    it flagged in the file list. The warning will bubble up through the directory
    system. There’s a red squiggly line at the top project folder, another in the
    folder for the package, and still another underline beneath the file where the
    problem lies. PyCharm doesn’t examine closed files. It only examines files you
    open, but once it finds the problem, it will remember where it is and continue
    to warn you until you fix the problem.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: Bad actor
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: I needed an exemplary bad actor for the previous visual pun. Kevin Costner is
    a bad American actor. He certainly isn’t the worst, but he’s easily in the top
    10\. If you don’t believe me, watch the movie *Dances with Wolves*. If you still
    don’t believe me, watch *The Bodyguard*. If you still think he’s great, watch
    *Waterworld* and realize he financed that movie out of his own pocket because
    he was convinced it would be a mega-hit.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: 'The fourth place is the problems window. In *Figure 4**.17*, you can see a
    red dot over an icon in area 4 in the screenshot. Click the icon, and the problems
    window will open and show you a list of faults, as seen in *Figure 4**.17*:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.17: Open the problem window to see a list of all your problems.
    Only your code problems are displayed. Life problems are not shown](img/B19644_04_17.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.17: Open the problem window to see a list of all your problems. Only
    your code problems are displayed. Life problems are not shown'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: Syntax errors
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Syntax errors are usually the shallowest errors exposed by an IDE. We’ve seen
    a few already. *Figure 4**.17* shows an incomplete function definition, so it
    is flagged in red as a syntax error. In *Figure 4**.14*, line 13 has a red underline
    beneath the word `math`. PyCharm recognizes this as a reference to the Python
    `math` library, which I have neglected to import. This throws an unresolved reference
    error. These kinds of errors are always marked in red as severe errors because
    they will prevent the program from running.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: Duplicated code
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you make a habit of copying and pasting code within your project or even
    between different projects, you can expect a warning from PyCharm. Duplicated
    code is a sign your project is in trouble.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: The best practice is to follow the concept called **Don’t Repeat Yourself**
    (**DRY**). I’ll say it again. You want your code to always be DRY. Never repeat
    your code by copying and pasting. Make sure it’s DRY. OK, I’ll stop if you promise
    to heed PyCharm’s warnings about code not being DRY.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: When you find this problem within a single project, you can usually fix it by
    hoisting the duplicated code into a function and calling the function from the
    parts of your code where the duplicates lie.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: If you get flagged for copying and pasting between projects, you should turn
    the duplicated code into a Python package that can be shared between projects.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: PEP-8 problems
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: PyCharm’s linter alerts you to styling problems in your code that violate PEP-8\.
    The biggest problem for developers new to Python is dealing with the rules around
    white space. Indentions and empty lines between functions are all part of the
    PEP-8 rules designed to keep your code very readable. Most PEP-8 problems are
    flagged as warnings.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: Dead code
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is my personal pet peeve. Someone writes some code, which ultimately gets
    replaced with a different function. Both the old and the unused function are sitting
    in the code file, along with the new one. They might have similar names. They
    might even be in different files. When I was a kid, I had a poster on my wall
    titled Murphy’s Laws of Technology. The poster espoused a pessimistic but, in
    my experience (and probably yours if you’ve been doing this for a while), totally
    accurate worldview. Here’s a sampling of Murphy’s Laws with respect to technology:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: You can never tell which direction the train traveled by looking at the track
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logic is a systematic method of coming to the wrong conclusion with confidence
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whenever a system becomes completely defined, some fool discovers something
    which either abolishes the system or expands it beyond recognition
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Technology is dominated by those who manage what they don’t understand: if
    builders built buildings the way programmers wrote programs, then the first woodpecker
    that came along would destroy civilization'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The attention span of a computer is only as long as its electrical cord
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An expert is one who knows more and more about less and less until he knows
    absolutely everything about nothing
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is relevant because, at least for me, the likelihood that I will find and
    attempt to modify dead code (thinking it to be very much alive and the obvious
    source of all my problems) in a software system asymptotically approaches 100%.
    The tiny degree of variance somewhere between 99% and 100% seems to be affected
    by my present level of caffeination and whether I skipped breakfast. These effects
    appear to be inversely proportional.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: I thank goodness for a system that warns me that I’m looking at dead code. My
    usual rant is that you should take dead code out. You won’t need it, and if you
    do, that’s what revision control systems are for.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: Method signature mismatches
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A method signature mismatch happens when a function requires more or fewer arguments
    than the number you supplied. PyCharm will warn you when this happens.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: The road to good code is paved with PyCharm’s intentions
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we’ve spent time learning about our flaws, let’s look at some tools
    that help us fix them. PyCharm features a mechanism called intentions designed
    to automate fixing and improving your code. Take a look at *Figure 4**.18*:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.18: Hover your mouse over any underlined code to see why it is underlined,
    along with possible fixes](img/B19644_04_18.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.18: Hover your mouse over any underlined code to see why it is underlined,
    along with possible fixes'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: In the case of the code shown, the problem is I invoked the `sqrt()` method,
    which finds the square root. The method is a static method in the `math` class.
    The problem is I failed to import that class. The description of the problem appears
    just below the underline when I hover. Below the problem description is the most
    likely fix. Pressing *Alt* + *Shift* + *Enter* will automatically fix the problem
    by adding `import math` to the top of the file.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: If you’d like to try this out, you can use the `inspection` project in the `chapter-04`
    folder of the sample code we cloned in [*Chapter 2*](B19644_02.xhtml#_idTextAnchor028),
    *Installation* *and Configuration*.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: Note this might not be the only possible fix. In *Figure 4**.18*, we can also
    see **More actions…** prompting us to either click the link or press *Alt* + *Enter*
    to see more possibilities.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: 'Truly astute readers might have noticed the lightbulb. This is an alternate
    vector to the same feature. Check out *Figure 4**.19* to see the lightbulb in
    action:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.19: The lightbulb is another way to get the intentions](img/B19644_04_19.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.19: The lightbulb is another way to get the intentions'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: Clicking the lightbulb shows a list of possible intentions. This time, we see
    a preview. The intention is going to add `import math` at line 1 of the file.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: The lightbulbs can be tricky sometimes because they have a tendency to disappear
    if you move off the line where they originally appeared. If you’d like to use
    the lightbulb, just click anywhere within the underline and wait for a tick. It
    will appear at the beginning of the line where the problem lies.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: In the case we’re exploring, the problem is a legitimate error. The program
    won’t run until we fix the problem. You can’t see it in the previous two figures,
    but the lightbulb is red. You’ll also see yellow lightbulbs for less egregious
    problems.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: Now if you’re like me, you want to see a clean file with a green check and no
    underlines. Let me tell you, that will probably never happen. PyCharm will almost
    always find something to change. Sometimes the suggested changes are not very
    useful. You might heed a suggestion that changes your code in some minor way.
    Right after you do this, the lightbulb comes back, and PyCharm offers to change
    the code back to the way it was. Yellow light bulbs are not your enemy unless
    they have an exclamation point in them.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most good IDEs, and development-focused text editors, for that matter, feature
    some level of tooling for refactoring. Refactoring is a very important practice
    that is often neglected. In my book, which is available on Amazon (or wherever
    the finest technical books are sold), *Real-World Implementation of C# Design
    Patterns*, I cover some of the entropic forces that lead a well-intended coding
    project to ruin. Your code starts off pristine, and the whole team commits to
    maintaining zero technical debt. But it never lasts. Factors such as time pressure,
    developer skill level, inevitable change, visibility, and complexity cause a process
    of devolution. Your code goes from a well-constructed, perfectly architected masterpiece
    to a big ball of mud on a plate of spaghetti!
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: I realize that I am pointing to a C# book here, but if you have a Packt subscription,
    I urge you to read the first two chapters of the book. The chapters discuss the
    common problems and preventions of work degradation. One thing you can do is to
    be vigilant and never dismiss the value of refactoring your code as a regular
    part of the development practice.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: What is refactoring?
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Simply put, refactoring is improving code without changing its functionality.
    If you have unit tests (you do, RIGHT!?!??!), they should pass before and after
    refactoring without any changes to the tests themselves. You are looking for ways
    to optimize your code in terms of readability and performance. Maybe you skipped
    some code niceties, such as adding **docstrings**, which we’ll cover later in
    this chapter. Maybe you didn’t add type hints to your method signatures. Perhaps
    there are opportunities to leverage design patterns or SOLID principles to make
    your code more flexible.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: The idea behind refactoring is that you are taking a second look at your code,
    preferably after a little time has passed. Have you ever looked at code you wrote
    a month or even a year ago and wondered what possessed you to type that horrible
    function body? Why in the world did you _________? (Fill in the blank with something
    silly you did.) You can’t believe that was you. You are smarter than that. Consider
    having regular peer reviews of your code. This can happen at any time during the
    writing process. Also, having someone less invested in your work will be able
    to spot unrealized opportunities for improvement. Almost always, this will involve
    refactoring. Flip things around. How many times have you been handed some code
    written by another developer? Maybe the person that has left the company? You
    look it over and conclude that whoever wrote the code was clearly a recent escapee
    from the local asylum. It must be totally rewritten. This is you refactoring someone
    else’s code.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring tools in PyCharm
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: PyCharm has a set of menu options dedicated to refactoring. There are a few
    that are not explicitly called out as refactoring tools.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: Cleaning up your code
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: PyCharm has a very thorough **Code Cleanup** tool. This tool, in effect, runs
    the same inspections you have seen so far, but it does them in bulk. You can have
    PyCharm try to fix all the problems as well. This feature is useful when you import
    a project created outside of PyCharm, say with a tool that doesn’t offer the kind
    of assistance you have seen in PyCharm.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: 'You can clean up an open file or all files in your project. To be honest, I
    don’t recommend you do this at the project level since you can’t really predict
    what the engine will do to a large set of files you haven’t even opened. *Figure
    4**.20* shows the menu location for **Code Cleanup****…**:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.20: The Code Cleanup tools can be found in the Code menu](img/B19644_04_20.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.20: The Code Cleanup tools can be found in the Code menu'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you click the menu option, you’ll see a dialog asking about the scope
    of the clean-up, as seen in *Figure 4**.21*:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.21: Specify the scope of the code cleanup](img/B19644_04_21.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.21: Specify the scope of the code cleanup'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: You can clean up the whole project, uncommitted files, the current file (which
    for me is `main.py` from the `inspection` project in the `chapter-04` folder of
    the sample source code), or a custom scope. My recommendation is not to try to
    boil the ocean. Do not do a whole project cleanup on a massive project. It is
    usually smarter to let PyCharm work its magic on small batches of files. The **Uncommitted
    files** option is a nice step you can take before you commit changes to your version
    control system.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: Renaming
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Donald Knuth, one of the most respected software developers of all time, wrote
    in his book *The Art of Computer Programming*, that there are two things in programming
    that are hard: naming things (e.g., variables, functions, classes, files, and
    so on) well, and invalidating your caches. How true this is! It is an art form
    to write meaningful variable definitions that are self-documenting while making
    your intentions clear. It usually takes several tries to get it right. PyCharm
    has a tool that easily allows a name change. You can right-click on anything you’ve
    named and select **Rename**. Type the new name of the thing that is to be renamed.
    PyCharm will affect the change everywhere the named thing is referenced. It will
    even find and change references in comments and docstrings.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: If the scope of the change is small, for example, you are renaming something
    scoped to a local function, the rename operation happens immediately. If you are
    attempting a rename with a broader scope, such as one that entails multiple files,
    PyCharm will preview the change for you by showing you all the files that will
    be affected. You can inspect all the changes before they are made to make sure
    the changes are appropriate. After you are satisfied, you can apply those changes.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: There is no rename menu option for files!
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: This is confusing if you come from another tool such as Visual Studio Code,
    where renaming files is a simple matter of picking the file from the explorer
    view and clicking twice or pressing *F2*. You’ll hunt for the rename option for
    files, and you will not find one. That’s because it is in the **Refactor** menu.
    PyCharm considers renaming a file a refactor. Unlike other tools, PyCharm will
    make sure renaming the file doesn’t affect your code.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: Inlining variables
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'PyCharm gives you the ability to automatically inline your variables. In fact,
    this is among the more common suggestions PyCharm provides. Consider this code:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The sum variable isn’t really needed. If you inline the variable, the code
    becomes the following:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We’ve removed the line that declared the `sum` variable and assigned it the
    value of `num1 +` `num2`.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Extracting methods
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Earlier, I mentioned a concept called DRY, or Don’t Repeat Yourself. Yes, I
    realize that by mentioning it again, I am breaking the rule. I am doing so with
    a purpose. Remember, the IDE points out errors and then provides advice and tools
    to fix the problem. I’d like to present a very useful feature. PyCharm gives you
    a tool to easily extract code into a separate function. You will want to do this
    under a couple of circumstances. First, if you find yourself copying and pasting
    code within your project. You probably need to make that code a function and then
    call it from the places where you are pasting the copied code. Secondly, when
    you find a function that breaks the single responsibility principle. If you’ve
    never heard of this, you can guess what it means. A well-written program should
    contain functions that do only one thing. Written code that contains functions
    or methods that perform multiple responsibilities could be broken into separate
    functions.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at an easy example of such an opportunity. Open the `chapter-04/not_dry.py`
    file in the sample code. The code within is truly egregious! Sensitive viewers
    might want to sit down before opening the file. Behold! Something everybody has
    done at least once before they learned it was a bad idea:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'OK, so far, it is fine. We’ve got a dictionary of people who took a computer
    science class along with their grades. By the way, those aren’t random names.
    After you finish this chapter, see whether you can figure out who these illustrious
    individuals might be. I apologize to some of the illustrious individuals for the
    numbers themselves. They are meant to be more or less random keys except for Mr.
    van Rossum, who would obviously have gotten a perfect grade. I’m sure they all
    did very well in real life. Following that, we have another set of class grades:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'While it is a different subject and a different group of people, it’s the same
    idea. Now suppose we need to figure out the class average for each class. I can
    make a function for computing the average in the computer science class:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Our method signature gives lots of good hints. We have a descriptive function
    name. The function takes one parameter, and our hint tells us we’re expecting
    a dictionary. The function is expected to return a float.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: 'The function body creates a variable called `raw_total` and sets it to `0`.
    Next, we loop through the values of `dict` and, on each iteration, add `value`
    to `raw_total`. Once we have the total, we divide it by the number of keys (`len`)
    in `dict`, and voila! We have the class average. Towards the bottom of the file,
    we can see where this function is called:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Wonderful! We have a call to our `computer_science_average` function along
    with a highly judgmental (and probably inaccurate since it might have been your
    favorite class) variable assignment. So, what’s wrong with any of this? Nothing.
    It’s what comes next that presents a problem and an opportunity to extract a method.
    The next function computes a different class: advanced theoretical and applied
    recess. This is a field that I personally pioneered, and within this field, I
    have no rival. Unfortunately, since I spent more time on the playground perfecting
    my art and less time in computer science class, I have all but duplicated the
    function we wrote earlier:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'It’s the same function with a different name! We need to consolidate! To do
    this, you need to highlight everything between the colon that ends the method
    signature and the `return` statement. Refer to *Figure 4**.22*. Don’t include
    the `return` statement, or PyCharm won’t generate a `return` statement in your
    extracted function:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.22: Select the code to extract into a new function or method](img/B19644_04_22.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.22: Select the code to extract into a new function or method'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, right-click the selected code and click **Refactor** | **Extract Method**,
    as shown in *Figure 4**.23*:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.23: Right-click the selected code, then click Refactor, then Extract
    Method](img/B19644_04_23.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.23: Right-click the selected code, then click Refactor, then Extract
    Method'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: 'This brings up a user interface that allows you to define the new method, as
    seen in *Figure 4**.24*:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 4.24: The \uFEFFExtract \uFEFFMethod dialog in PyCharm](img/B19644_04_24.jpg)"
  id: totrans-224
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.24: The Extract Method dialog in PyCharm'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: 'Set the name of the extract method. I set mine to `compute_average`. PyCharm
    has filled in the rest automatically. Click **OK**, and your code will change.
    *Figure 4**.25* shows the result of my refactoring:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.25: The result of the refactoring. Note the compute_average function
    was generated automatically from the selected code](img/B19644_04_25.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.25: The result of the refactoring. Note the compute_average function
    was generated automatically from the selected code'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at the resulting code PyCharm generated from the refactor. First,
    `computer_science_average` has changed to this:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This function is now calling the extracted function. The extracted function
    looks like this:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This is the code we selected for extraction. PyCharm generated the function
    for me. I must tell you, at this point, that I’m usually wary of generated code.
    It is rarely perfect. Here, I would have preferred a type hint on the `grades`
    parameter and a hint on the return type. Those are minor issues, though, and the
    result saved me some typing.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: 'One lingering question might remain. Why didn’t PyCharm detect and flag the
    duplicated code? The quick answer: our sample code is too short. If I were to
    add a few more lines to the duplicated functions, it would appear as a duplicate.
    Let’s try it out. Modify the code in both functions so it looks like this:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'All I did was add a bunch of fake variable declarations. They don’t do anything
    important except make the duplicate code fragment longer. By default, PyCharm
    only looks for duplicated fragments that are 10 lines or longer. Short duplications
    don’t make the cut. I bring this up because the magic of method extraction handles
    duplicates automatically. Let’s do the same exercise. First, look at PyCharm with
    the changes in place. You should see some indicators that we have problems, as
    shown in *Figure 4**.26*:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.26: Now that our duplicated code is longer, it gets detected and
    flagged](img/B19644_04_26.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.26: Now that our duplicated code is longer, it gets detected and flagged'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see that PyCharm has noticed our duplicated code. Highlight the code
    for extraction, as shown in *Figure 4**.27*:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.27: Mark the code for extraction](img/B19644_04_27.jpg)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.27: Mark the code for extraction'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: 'Right-click the highlighted code and click **Refactor** | **Extract Method**,
    as shown in *Figure 4**.28*:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.28: Extract the method by right-clicking, clicking Refactor, then
    Extract Method](img/B19644_04_28.jpg)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.28: Extract the method by right-clicking, clicking Refactor, then
    Extract Method'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: 'Name the extracted function `compute_average`, as shown in *Figure 4**.29*:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.29: Name the extracted function compute_average](img/B19644_04_29.jpg)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.29: Name the extracted function compute_average'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: 'Click **OK**. This time things are a little different. You’ll find that PyCharm
    creates the function extraction as before, but this time you are prompted to replace
    the duplicate code as well, as shown in *Figure 4**.30*:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.30: PyCharm asks whether you’d like to replace the duplicated fragment
    with a reference to the extracted function](img/B19644_04_30.jpg)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.30: PyCharm asks whether you’d like to replace the duplicated fragment
    with a reference to the extracted function'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: Exporting a function to another file
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: How often have you written a nifty utility function in the wrong place? Maybe
    you put it in a module or class that is designed to do something specific, but
    your utility function turns out to be generally used in lots of places. The single
    responsibility principle that applies to functions also applies to modules and
    classes. Having a function that connects to a database is a great example. Let’s
    say you just got a job working for Billy Blanca’s Candy Factory. They need you
    to write some scripts that will import lists of candies they make from several
    different text formats and store them in a database. The first requirement comes
    in, and you need to read from a plain text file and write to an SQLite database.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the project in `chapter-04/move_function/read_input_file_a.py`. Let’s
    review the contents:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'These first two lines import the `sqlite3` library from the standard library.
    If you haven’t worked with `sqlite3` before, here’s all you need to know for now:
    it is a file-based relational database. By this, we mean you don’t need to install
    a server as you would with databases such as Postgres or MariaDB. This makes it
    a good database to use for teaching and prototype work. We’ll cover databases
    in detail in [*Chapter 11*](B19644_11.xhtml#_idTextAnchor266), *Understanding
    Database Management in PyCharm*. Let’s continue with the definition for the function
    that will open the file, read the contents, and insert them into the database:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We’ve opened the file. For each line in the file, we are reading it in as text
    and removing the newline character. This is necessary for the database insert
    to work properly. Once the string is cleaned, we are calling a function that writes
    to the database:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'I’ve included the database file in the code repository, so there is no code
    needed to create the database. This function just opens the database, then creates
    a cursor. A cursor is used to execute commands against the database using SQL.
    Even if you don’t know SQL, I’m sure you can figure out what is happening. There
    is a table in the database called `candy`. The table has only one field: `name`.
    We’re keeping it very simple here. I have neglected to create a primary key because,
    for now, the database doesn’t really matter. We should be focused on the function
    more than how it works.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: Having generated a SQL statement to insert the `candy` name from the `candy`
    name in the current line of the text file, I execute the SQL statement, which
    will insert one row into the `candy` table.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: 'As a general rule in programming, whatever you create, you should destroy,
    and whatever you open, you should always close. So, I close my cursor and my database
    connection to avoid any resource locks later down the road. Finally, I use the
    common dunder-name convention to run the file for testing:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In PyCharm, I can execute this by setting my run configuration to **Current
    File** and clicking the **Run** button. It works! The file is read, and we get
    no errors.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: Dunderscores
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: A `__init__`? You could say, “*underscore underscore init underscore underscore.*”
    But that is cumbersome. If you just say, “init” you’re not being specific enough
    since there could be another function or method called `init` without the underscores.
    So, you say “*dunderscore init*” or even just “*dunder init*”, and everybody knows
    what you’re talking about.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: 'The next day we come to work and learn of a new requirement. We need another
    script that reads data from a **JavaScript Object Notation** (**JSON**) file.
    The JSON file just contains an array like this:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'It’s still just a list of candy, but we need to process it differently. Open
    up `chapter-04/move_function/input/read_input_file_b.py`. You’ll find its code
    is similar to the other code:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We know we need to work with JSON, so I’ve imported the `json` package. I also
    know I’ll need to write to the same database as before. I know code reuse is a
    good thing, so I import the function from the other script. Then I set to creating
    a version of the code that reads JSON files:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `json.load` method takes the raw text and converts it into a regular Python
    3 `dict`. As you can see from the preceding file listing, `dict` will have one
    thing in it: an array of candy with the key of data. So, I grab that and put it
    in the `candies` variable, then I loop over that array and call the `write_to_database`
    function for each `candy` in the array. Wow! It’s not even lunchtime! Maybe I
    can walk around the factory? I hear they’ve got some little girl testing some
    gum that turns people into a raspberry.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: Not so fast! This code could be improved. Our input scripts are really designed
    to read data from text. It doesn’t make sense to have one of the scripts contain
    the database function because it simply doesn’t belong inside the script that
    reads text input files. It really should be in its own package. Let’s extract
    it to its own file.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `chapter-04/move_function/input/read_input_file_a.py`. Right-click on
    the name of the function we’re going to move, as shown in *Figure 4**.31*:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.31: Right-click the function you want to move, then click Refactor,
    then Move](img/B19644_04_31.jpg)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.31: Right-click the function you want to move, then click Refactor,
    then Move'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: In the context menu, click `database_helper.py` filename. Click **OK**. Watch
    carefully because a lot is about to happen.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: 'I get a new file called `database_helper.py`:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This is the extracted function moved to its own file. PyCharm discovered the
    relevant import statement and moved that here as well. I had a constant for the
    file name called `CANDY_DB`. It didn’t move that, which would be my preference.
    Unfortunately, the current release of PyCharm is not psychic. I’ll just have to
    move that myself. Other than that, this file looks perfect.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: 'If you check the contents of `input_file_a.py`, you’ll see it has changed.
    The first line in the file now reads as follows:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Likewise, if I open `input_file_b.py`, I’ll find the input there as well. PyCharm
    extracted the function to its own file, then changed every reference in every
    file to point to the new location.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: Now, I realize I probably should have put this in its own module, and I realize
    you probably would have done this totally differently. Before you go bashing me
    on Twitter, remember this book is about PyCharm, not software architecture. I’m
    trying to keep it simple on purpose.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: Documentation
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: No programmer can doubt the importance of documentation in software engineering
    and development. That said, the process of creating documentation for a program
    can be quite tedious. Furthermore, the end result might not even be effective
    if the person doing the documentation was not following standard practices.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: 'Keeping that in mind, PyCharm looks to streamline this process of documentation
    and make it as straightforward and seamless as possible. Regarding documentation,
    there are two components we will consider for this process: viewing and creating
    documentation. We will learn that PyCharm offers great support for both processes.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: Working with docstrings
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Documentation in Python is known as docstrings, defined as a string literal
    that is placed before any of the statements in a module, function, class, or method
    in Python. You can look at examples of Python docstrings by going into the source
    code of the various built-in Python functions. It is also recommended that any
    custom API you write also has the appropriate docstrings for readability and maintainability.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: 'The most noteworthy subtlety in creating docstrings is the practice of using
    triple-double quotes to surround a docstring (which we will see examples of in
    the next subsection). For more details about docstring conventions, take a look
    at this PEP article: [www.python.org/dev/peps/pep-0257/](http://www.python.org/dev/peps/pep-0257/).'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: Creating documentation
  id: totrans-291
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this subsection, we will look into the process of writing a docstring for
    functions with the help of PyCharm. Let’s get started.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the project in the sample source code in `chapter-04/documentation`. Open
    the `prime_test.py` file, which looks like this:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The file goes on after that, but the part I need you to focus on is the line
    right below the method signature for the `prime_check` function. There is a `TODO`
    there. If you’re from a Spanish-speaking country, realize this doesn’t mean *all*.
    It refers to a “to-do” item in the code. In this case, the original developer,
    who happens to be Quan Nguyen, the author of the first edition of this book, is
    stating he didn’t write the docstring for this function. He is signaling here
    that he knows that, and he intends to come back and fix this later. Let’s help
    him out with a little PyCharm magic. Before you get too excited, I’m sad to report
    that there isn’t a tool in PyCharm that can read your code and generate the docstring.
    Given how much developers hate writing documentation, I’ll wager there is a fast-and-furious
    effort underway somewhere to have AI do this. But we’re sticking with what PyCharm
    lets us do out of the box.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: 'Delete the `# TODO` line and, in its place, type three double quotation marks
    (`"""`) and press *Enter*. You’ll find a generated docstring template appears:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This template needs some filling-in in order to become a proper docstring.
    Note the gap beneath the first set of triple quotes. Here, you are expected to
    write about what the function does. Maybe something like this:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Below that is a section for the parameters expected by the function. Here,
    the function takes one argument called `n`. We should write a little bit about
    that parameter, including its type:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The last part is the documentation for the return value:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Consider the generated template of the docstring after we hit *Return/Enter*
    to expand the pair of triple-double quotes. `:param` and `:return:` are part of
    the template and will be included every time we expand a docstring in the same
    way. PyCharm allows us to change this format of docstring templates, making it
    highly customizable and accommodating.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: Customizing the docstring templates
  id: totrans-305
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As usual, the docstring templates are highly customizable. You’ll find the
    customization settings by going into the **Settings** window, covered extensively
    in [*Chapter 3*](B19644_03.xhtml#_idTextAnchor052), *Customizing Interpreters
    and Virtual Environments*. Just search on docstring, and you’ll find the areas
    that should capture your attention. The first is shown in *Figure 4**.32*:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.32: You can change the general format used to render your docstrings
    to one of several industry-standard formats](img/B19644_04_32.jpg)'
  id: totrans-307
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.32: You can change the general format used to render your docstrings
    to one of several industry-standard formats'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: The other group of settings is part of the color scheme settings, which allow
    you to customize the color used to render the docstring in the PyCharm editor.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: Viewing documentation
  id: totrans-310
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Imagine a situation where you are using a specific method from one package,
    but you are not entirely sure which parameters the method takes in and/or what
    its return type is. Therefore, you need to go online and look into the documentation
    of the package for that specific method.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: 'As a PyCharm user, you can achieve the same thing with two simple actions:
    `prime_check.py` script from the previous section, move your cursor to the line
    where we use the `math.sqrt()` function in the `prime_check()` function; it should
    be around line 19.'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: Quick Documentation
  id: totrans-313
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s say we’d like to see the documentation of this function. You can simply
    hover your mouse over the function call and wait a moment. Alternatively, you
    can choose **View** | **Quick Documentation** for this or its corresponding keyboard
    shortcut. You will see a pop-up window showing documentation similar to *Figure
    4**.33*:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.33: Quick Documentation shows the documentation for the selected
    function](img/B19644_04_33.jpg)'
  id: totrans-315
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.33: Quick Documentation shows the documentation for the selected function'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: What’s more, you can also view the documentation for your own functions, methods,
    classes, and so on using the same action. PyCharm’s indexing process finds and
    generates this information when you open the project.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: 'If you move your cursor to the call to `prime_check()` in the main scope in
    the following line (which should be around line 38):'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: '`if prime_check(num):`'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: 'After waiting a moment, you will be able to see the same docstring that we
    entered earlier, as shown in *Figure 4**.34*:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.34: Quick Documentation shows the documentation for the selected
    function on line 38](img/B19644_04_34.jpg)'
  id: totrans-321
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.34: Quick Documentation shows the documentation for the selected function
    on line 38'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: Note the format of the docstring in the documentation matches the documentation
    shown in the window.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: Quick definition
  id: totrans-324
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Quick Definition** operates in the same manner as **Quick Documentation**.
    This is useful when the documentation does not provide enough information, and
    you would like to see how a specific function is defined within the source code.
    To do this, place your cursor at a specific API call, and go to **View** | **Quick
    Definition** to evoke the action.'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, *Figure 4**.35* shows the quick definition evoked on the call
    to `prime_check()` in our example:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.35: Quick Definition shows the actual code definition for the function,
    which naturally includes the docstring if one is present](img/B19644_04_35.jpg)'
  id: totrans-327
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.35: Quick Definition shows the actual code definition for the function,
    which naturally includes the docstring if one is present'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: Overall PyCharm provides powerful options when it comes to dynamically viewing
    documentation and definitions within the IDE. Significant time and energy can
    be saved when programmers do not have to switch from their development environment
    to look for documentation.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-330
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this chapter, we examined PyCharm’s features regarding various aspects
    of programming, including code analysis, code completion, refactoring, and documenting.
    In all of these processes, PyCharm’s intelligent code analyzer provides smart
    and convenient options for editing and fixing problems in your code in real time
    and in a dynamic way.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: Aside from a wide number of options the intelligent code analyzer can support,
    PyCharm also allows users to customize the behavior of the analyzer to their liking.
    This can be achieved in various sections of the general settings. Overall, these
    support features look to improve your productivity as a developer in a way that
    is customized and beneficial to you.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we will focus on a particular aspect of programming: version
    control. We will learn about the specifics of the version control process with
    Git and how PyCharm supports and streamlines this process.'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What levels of severity in terms of problems in a Python program are determined
    by PyCharm’s code analyzer?
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are some common problems that PyCharm can detect and help fix via its intelligent
    code analyzer?
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How is PyCharm’s code completion support different from others?
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are some common code completion options that PyCharm offers?
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the common causes for PyCharm’s code completion support not working?
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are some common refactoring options that PyCharm offers?
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-341
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Jolt Awards: *The Best Books For* *Developers* ([informationweek.com](http://informationweek.com))'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Pylint home page: [https://www.pylint.org/](https://www.pylint.org/)'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Murphy’s laws on technology: [https://www.netlingo.com/word/murphys-laws-on-technology.php](https://www.netlingo.com/word/murphys-laws-on-technology.php)'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Be sure to check out the companion website for the book at [https://www.pycharm-book.com](https://www.pycharm-book.com).
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
