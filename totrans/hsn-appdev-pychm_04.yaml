- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Editing and Formatting with Ease in PyCharm
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在PyCharm中轻松编辑和格式化
- en: 'Leonardo Da Vinci, the great painter and sculptor, mused that his sculptures
    were fully formed in the blocks of stone from the quarry before he even saw the
    marble. Da Vinci explained that all he did was remove the pieces of marble that
    were not required for the form. In other words, his masterpieces were completed
    in his mind before a chisel touched the crude stone. In many ways, you are Da
    Vinci. You have a project in your head, fully formed, and you are eager to show
    the world your masterpiece. Instead of using a hammer and chisel to write your
    code, you are using PyCharm. In the previous chapters, we worked through the installation
    process and configuration of PyCharm. We also set up an interpreter for your project.
    Next up: the exploration of the main tools that you will use to craft your masterpiece,
    which mainly reside in the editor.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 列奥纳多·达·芬奇，这位伟大的画家和雕塑家，曾沉思他的雕塑在看到大理石之前就已经在采石场的石块中完全成型。达·芬奇解释说，他所做的只是移除那些对于形状不需要的大理石块。换句话说，他的杰作是在雕刻刀触及粗糙的石头之前，在他的脑海中完成的。在许多方面，你就是达·芬奇。你心中有一个完整的项目，渴望向世界展示你的杰作。你不用锤子和雕刻刀来编写代码，而是使用PyCharm。在前几章中，我们完成了PyCharm的安装过程和配置。我们还为你的项目设置了解释器。接下来：探索你将用来打造杰作的主要工具，这些工具主要位于编辑器中。
- en: By now, you have discovered many of the obvious features of the editor. We know
    it handles a lot of the PEP-8 syntax rules automatically. We know we get the color-coded
    syntax. We also have observed that the **integrated development environment**
    (**IDE**) will make suggestions on several different areas of coding, ranging
    from linting style rules to auto-completion.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经发现了编辑器中许多明显的功能。我们知道它自动处理许多PEP-8语法规则。我们知道我们得到了彩色编码的语法。我们还观察到，**集成开发环境**（**IDE**）将在编码的多个不同领域提供建议，从代码风格规则检查到自动补全。
- en: 'This chapter will focus on the features of the editor that are less obvious.
    The product’s documentation provides keyboard shortcuts and editor basics that
    will not be discussed in this chapter. Instead, the following topics will be covered:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将重点关注编辑器中不那么明显的功能。产品的文档提供了键盘快捷键和编辑器基础知识，这些内容在本章中不会讨论。相反，以下主题将被涵盖：
- en: Real-time code inspection with automated fixes, which allows you to focus on
    development goals rather than on the rules of Python coding.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实时代码检查和自动修复，这允许你专注于开发目标，而不是Python编码的规则。
- en: Various code-completion support features in PyCharm and how to leverage them.
    By using these, you’ll be able to code more quickly and more accurately. We will
    only focus on those tools that ship with PyCharm versus third-party **artificial
    intelligence** (**AI**) enhancements that require plugins such as Kite or GitHub
    Copilot. These will be covered in [*Chapter 15*](B19644_15.xhtml#_idTextAnchor379).
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PyCharm中的各种代码补全支持功能以及如何利用它们。通过使用这些功能，你将能够更快、更准确地编写代码。我们只会关注PyCharm自带而非需要插件如Kite或GitHub
    Copilot的第三方**人工智能**（**AI**）增强工具。这些将在[*第15章*](B19644_15.xhtml#_idTextAnchor379)中介绍。
- en: Refactoring tools that allow you to polish and refine your code into the masterpiece
    that it can become through patience, discipline, and good tooling.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重构工具，允许你通过耐心、纪律和良好的工具将你的代码打磨成杰作。
- en: Documentation tools that will take you from the level of “good developer” to
    the level of “master developer.” It’s one thing to invent an amazing work of code.
    Documenting it so others can benefit from it takes your work to another level.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文档工具，将带你从“优秀开发者”的水平提升到“大师开发者”的水平。发明一个惊人的代码作品是一回事。记录它，让其他人从中受益，则将你的工作提升到了另一个层次。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In order to proceed through this chapter and the rest of the book, you will
    need the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了继续阅读本章和本书的其余部分，你需要以下内容：
- en: An installed and working Python interpreter. I’ll be using the latest from [https://python.org](https://python.org).
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个已安装并正常工作的Python解释器。我将使用来自[https://python.org](https://python.org)的最新版本。
- en: Installed copies of `pip` and `virtualenv`. You get these automatically when
    you install Python on Windows, and MacOS has them included on every system. If
    you are using Linux, you need to install the package managers, such as `pip`,
    and virtual environment tools, such as `virtualenv`, separately. Our examples
    will use `pip` and `virtualenv`.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装好的`pip`和`virtualenv`副本。当您在Windows上安装Python时，这些会自动获得，而MacOS则将它们包含在每一个系统中。如果您使用Linux，您需要单独安装包管理器，如`pip`，以及虚拟环境工具，如`virtualenv`。我们的示例将使用`pip`和`virtualenv`。
- en: An installed and working copy of PyCharm. Installation was covered in [*Chapter
    2*](B19644_02.xhtml#_idTextAnchor028).
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装并运行PyCharm的副本。安装过程在[*第二章*](B19644_02.xhtml#_idTextAnchor028)中已有介绍。
- en: This book’s sample source code from GitHub can be found at [https://github.com/PacktPublishing/Hands-On-Application-Development-with-PyCharm---Second-Edition/tree/main/chapter-04](https://github.com/PacktPublishing/Hands-On-Application-Development-with-PyCharm---Second-Edition/tree/main/chapter-04).
    We covered cloning the code in [*Chapter 2*](B19644_02.xhtml#_idTextAnchor028),
    *Installation* *and Configuration*.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以在GitHub上找到这本书的示例源代码，地址为[https://github.com/PacktPublishing/Hands-On-Application-Development-with-PyCharm---Second-Edition/tree/main/chapter-04](https://github.com/PacktPublishing/Hands-On-Application-Development-with-PyCharm---Second-Edition/tree/main/chapter-04)。我们已经在[*第二章*](B19644_02.xhtml#_idTextAnchor028)中介绍了代码的克隆，*安装*和*配置*。
- en: Code analysis, inspection, and suggestion
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码分析、检查和建议
- en: Intelligent code completion is essential to any programming tool’s adoption.
    The definition of a good code completion engine is one that is aware of high-level
    aspects of programming, including specifics of language syntax. The engine also
    must be aware of the lower-level specifics of the program you write. Many enhanced
    text editors support code completion but lack this level of sophistication. PyCharm
    stands out as an exceptionally sophisticated code editor, encompassing both the
    historical and modern aspects of code editors and offering a level of sophistication
    that surpasses many other enhanced text editors in terms of intelligent code completion.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 智能代码补全对于任何编程工具的采用都是必不可少的。一个好的代码补全引擎的定义是它能够了解编程的高级方面，包括语言语法的具体细节。引擎还必须了解你所编写的程序的底层具体细节。许多增强型文本编辑器支持代码补全，但缺乏这种高级的复杂性。PyCharm作为一个异常复杂的代码编辑器脱颖而出，它包含了代码编辑器的历史和现代方面，并且在智能代码补全方面超越了其他许多增强型文本编辑器。
- en: 'The most common form of code completion is a large picklist of words that are
    matched as you type. The list of possibilities narrows as more letters are typed.
    Notepad++ is an enhanced text editor widely used by developers. I consider it
    a must-have tool for quick and easy edits when I am too impatient to wait on an
    IDE to fully load. *Figure 4**.1* shows a session where I began typing some Python
    code:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 代码补全最常见的形式是在您输入时匹配的单词的大列表。随着更多字母的输入，可能性的列表会缩小。Notepad++是一个被开发者广泛使用的增强型文本编辑器。当我太没有耐心等待IDE完全加载时，我认为它是快速轻松编辑的必备工具。*图4.1*显示了我在输入一些Python代码的会话：
- en: '![Figure 4.1: Notepad++ uses a very simple mechanism for code highlighting
    and completion](img/B19644_04_01.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图4.1：Notepad++使用一个非常简单的机制进行代码高亮和补全](img/B19644_04_01.jpg)'
- en: 'Figure 4.1: Notepad++ uses a very simple mechanism for code highlighting and
    completion'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1：Notepad++使用一个非常简单的机制进行代码高亮和补全
- en: 'The tool does not intuitively know what is being typed; therefore, I must tell
    it that I am coding in Python. After the language is set, it will attempt to autocomplete
    everything, even though such an exercise is clearly futile. In *Figure 4**.1*,
    I was going to type the following:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 工具并不能直观地知道正在输入什么；因此，我必须告诉它我正在用Python编写代码。在设置完语言后，它将尝试自动补全一切，尽管这样的练习显然是徒劳的。在*图4.1*中，我打算输入以下内容：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This clearly isn’t going to win me any Jolt awards. You see in the screenshot
    that the list is filtering a known list of words. Its only contextual point of
    reference is knowing that the file is a Python file. This isn’t very effective,
    but it is better than nothing.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这显然不会为我赢得任何Jolt奖项。您可以从截图看到，列表正在过滤一个已知的单词列表。它的唯一上下文参考点是知道该文件是一个Python文件。这并不非常有效，但总比没有好。
- en: 'Systems like these are little more than spell checkers. While a seasoned pro
    might scoff at the usefulness of such a simple system, the earliest IDEs that
    displayed this level of wizardry pioneered a feature we are now unwilling to live
    without: code completion.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的系统几乎只是拼写检查器。虽然经验丰富的专业人士可能会嘲笑这样一个简单系统的有用性，但最早显示这种魔法般功能的IDE开创了一个我们现在不愿意没有的功能：代码完成。
- en: 'PyCharm lies at the opposite end of the spectrum with respect to sophistication.
    Like Notepad++, PyCharm is aware of the keywords that comprise PyCharm. PyCharm,
    though, is able to glean insight into the structure of the objects that make up
    the standard library. *Figure 4**.2* shows me typing some code into PyCharm, having
    created a simple file for this example:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: PyCharm在复杂度方面处于光谱的另一端。就像Notepad++一样，PyCharm能够识别构成PyCharm的关键词。然而，PyCharm还能够洞察组成标准库的对象结构。“图4.2”展示了我在PyCharm中输入一些代码，为这个示例创建了一个简单的文件：
- en: '![Figure 4.2: PyCharm auto-completes based on its understanding of the time
    library](img/B19644_04_02.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图4.2：PyCharm根据其对时间库的理解进行自动完成](img/B19644_04_02.jpg)'
- en: 'Figure 4.2: PyCharm auto-completes based on its understanding of the time library'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2：PyCharm根据其对时间库的理解进行自动完成
- en: In this case, I have imported the `time` library just as I did in the Notepad++
    example from *Figure 4**.1*. I’m a little further along here. I have my function
    defined, and I’m going to simply print the current local time using the `time`
    library I had already imported. As you can see in *Figure 4**.2*, PyCharm is offering
    completion against the contents of the time library.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我像在“图4.1”中的Notepad++示例中那样导入了`time`库。我已经进行了一步，定义了我的函数，接下来我将简单地使用已经导入的`time`库打印当前本地时间。正如您在“图4.2”中可以看到的，PyCharm正在根据对时间库的理解提供自动完成建议。
- en: Completing the auto-completion
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 完成自动完成
- en: Once the auto-completion list appears, you can press *Tab* or *Enter* to select
    the highlighted option. You can use the up and down arrow keys to move through
    the list, or you can click any of the list items with your mouse. You’ll work
    fastest, though, if you keep your fingers on the keyboard.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦自动完成列表出现，您可以按*Tab*或*Enter*键选择高亮选项。您可以使用上箭头和下箭头键在列表中移动，或者用鼠标点击列表中的任何项。不过，如果您保持手指在键盘上，您的工作速度会更快。
- en: By now, you are starting to appreciate the code completion system offered by
    PyCharm. Let us further explore the capabilities of this important tool.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，您已经开始欣赏PyCharm提供的代码完成系统。让我们进一步探索这个重要工具的功能。
- en: It duzunt assewm yew cna spel
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它duzunt assewm yew cna spel
- en: Our simplistic word-list example from Notepad++ earlier already stands in sharp
    contrast to the more sophisticated features of PyCharm’s auto-completion engine.
    Let’s dig a little deeper. If your tool relies on a word list, then the second
    your spelling steps out of line, your suggestion list dries up. In effect, the
    word-list method requires you to know what it is you are looking for while requiring
    it to be spelled correctly.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前从Notepad++中的简单单词列表示例已经与PyCharm自动完成引擎的更复杂功能形成了鲜明对比。让我们进一步挖掘。如果您的工具依赖于单词列表，那么一旦您的拼写出错，建议列表就会枯竭。实际上，单词列表方法要求您知道您要找的是什么，同时要求拼写正确。
- en: 'In *Figure 4**.3*, you will see something a little different:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在“图4.3”中，您将看到一些不同之处：
- en: '![Figure 4.3: PyCharm finds all possibilities containing the text you’ve typed](img/B19644_04_03.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图4.3：PyCharm找到包含您已输入文本的所有可能性](img/B19644_04_03.jpg)'
- en: 'Figure 4.3: PyCharm finds all possibilities containing the text you’ve typed'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3：PyCharm找到包含您已输入文本的所有可能性
- en: PyCharm is designed to offer suggestions based on the letters that are typed.
    In other words, as you type `cl`, the word *clock* might appear. The word *clock*
    will also appear if you type `lo`, `ck`, or any consecutive letters contained
    in the list of keywords matched. Perfectly spelled words are not necessary. Just
    get in the ballpark, and the word you are searching for will likely pop up.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: PyCharm被设计成根据输入的字母提供建议。换句话说，当您输入`cl`时，单词`clock`可能会出现。如果您输入`lo`、`ck`或任何包含在匹配关键词列表中的连续字母，`clock`单词也会出现。不需要拼写正确。只要接近正确，您要找的单词很可能会出现。
- en: It understands your code
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它理解您的代码
- en: Good code completion is able to understand and autocomplete based on the language
    and the libraries in use. In our case, that’s Python, which has an enormous standard
    library compared to other languages. Python is designed around a “batteries included”
    philosophy. Contrast that with JavaScript as implemented in Node.js, where the
    only libraries you get are file and HTTP libraries. The .NET languages give you
    a small core. You can say the same about Golang. Most languages require you to
    use the package manager. The fact that PyCharm can do this is spectacular by itself.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的代码补全功能能够根据所使用的语言和库来理解和自动补全。在我们的案例中，那就是Python，与其他语言相比，Python拥有庞大的标准库。Python的设计理念是“内置电池”。与之相比，在Node.js中实现的JavaScript，你只能获得文件和HTTP库。.NET语言给你的是一个小的核心。对于Golang也可以这么说。大多数语言都需要你使用包管理器。PyCharm能够做到这一点本身就非常出色。
- en: 'PyCharm, being a great IDE, can also understand the code you’ve written. *Figure
    4**.4* shows the `autocomplete_demo.py` file, where I have added an import to
    the `no_problemo.py` file. The `no_problemo.py` file has one function in it called
    `perfection()`. As you can see, PyCharm is able to see inside the file and provide
    autocompletion on the code I have written versus simply doing auto-complete from
    a language-based word list:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: PyCharm作为一个优秀的IDE，也能理解您所编写的代码。*图4*.4显示了`autocomplete_demo.py`文件，我在其中添加了对`no_problemo.py`文件的导入。`no_problemo.py`文件中有一个名为`perfection()`的函数。正如您所看到的，PyCharm能够查看文件内部并提供关于我所编写代码的自动补全，而不仅仅是基于语言词汇表的自动补全：
- en: '![Figure 4.4: PyCharm provides autocompletion suggestions on the code you’ve
    written, as well as standard Python language and the standard library](img/B19644_04_04.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图4.4：PyCharm在您所编写的代码上提供自动补全建议，以及标准Python语言和标准库](img/B19644_04_04.jpg)'
- en: 'Figure 4.4: PyCharm provides autocompletion suggestions on the code you’ve
    written, as well as standard Python language and the standard library'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4：PyCharm在您所编写的代码上提供自动补全建议，以及标准Python语言和标准库
- en: I am offered auto-completion on the function name, as well as hints on the **method
    signature**. If you’re unfamiliar with the term *method signature*, it simply
    refers to the name, argument list, and return values for a function or method.
    If you’ve included type hints, PyCharm will remind you of the argument names and
    types the function or method requires. This works with modules as well as classes
    if you’re using **object-oriented** **programming** (**OOP**).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我得到了关于函数名的自动补全，以及关于**方法签名**的提示。如果您不熟悉“方法签名”这个术语，它仅仅是指函数或方法的名称、参数列表和返回值。如果您已经包含了类型提示，PyCharm会提醒您函数或方法需要的参数名称和类型。这同样适用于模块以及类，如果您正在使用**面向对象**的**编程**（**OOP**）。
- en: Postfix code completion
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 后缀代码补全
- en: 'Traditional code completion has been taken to the next level in PyCharm, but
    we are far from finished. Usually, hitting the period (*.*) key on your keyboard
    triggers a list to appear. We are now used to that list containing what might
    come after the dot. However, what if PyCharm could give you suggestions on what
    might come *before* the dot? In *Figure 4**.5*, we see an example of postfix code
    completion, which you will find in the `postfix_example.py` file in the [*Chapter
    4*](B19644_04.xhtml#_idTextAnchor077) sample code:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在PyCharm中，传统的代码补全已经被提升到了一个新的水平，但我们还没有完成。通常，在键盘上按住句号(*)键会触发一个列表出现。我们已经习惯了这个列表包含点之后可能出现的代码。然而，如果PyCharm能够给出点之前可能出现的代码建议呢？在*图4*.5中，我们看到一个后缀代码补全的例子，您可以在[*第4章*](B19644_04.xhtml#_idTextAnchor077)示例代码中的`postfix_example.py`文件中找到：
- en: '![Figure 4.5: Postfix completion in PyCharm can suggest what might come before
    the dot rather than simply what might come after](img/B19644_04_05.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图4.5：PyCharm中的后缀补全可以建议在点之前可能出现的代码，而不仅仅是点之后可能出现的代码](img/B19644_04_05.jpg)'
- en: 'Figure 4.5: Postfix completion in PyCharm can suggest what might come before
    the dot rather than simply what might come after'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.5：PyCharm中的后缀补全可以建议在点之前可能出现的代码，而不仅仅是点之后可能出现的代码
- en: 'I can’t blame you if you are confused by seeing `.if` (if expr) as a possibility
    following what is clearly a string-typed variable. The `.if` suggestion is not
    part of Python. It is a **postfix suggestion**. If you complete this suggestion
    your code is transformed. The following code isn’t viable Python syntax:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您看到`.if`（if expr）作为紧跟一个明显是字符串类型的变量的可能选项而感到困惑，我并不怪您。`.if`建议不是Python的一部分。它是一个**后缀建议**。如果您完成这个建议，您的代码将被转换。以下代码不是有效的Python语法：
- en: '[PRE1]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Therefore, it is converted to the following:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，它被转换为以下内容：
- en: '[PRE2]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Just imagine the possibilities! However, if you’re not the imaginative type,
    check out *Figure 4**.6*, which shows PyCharm’s **Postfix Completion** configuration
    options:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下所有可能的情况！然而，如果你不是那种富有想象力的人，请查看*图4**.6*，它显示了PyCharm的**后缀完成**配置选项：
- en: '![Figure 4.6: PyCharm’s Postfix Completion configuration options](img/B19644_04_06.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图4.6：PyCharm的后缀完成配置选项](img/B19644_04_06.jpg)'
- en: 'Figure 4.6: PyCharm’s Postfix Completion configuration options'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.6：PyCharm的后缀完成配置选项
- en: Naturally, these options are fully configurable. You can even add your own!
    The templates are not limited to Python. You can see in the list that there are
    configurations for TypeScript, JavaScript, and **Structured Query Language** (**SQL**).
    This is important because application development is rarely limited to the scope
    of just the Python language.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 自然，这些选项是完全可配置的。你甚至可以添加自己的！模板不仅限于Python。你可以在列表中看到，有TypeScript、JavaScript和**结构化查询语言**（**SQL**）的配置。这是因为应用程序开发很少仅限于Python语言的范围。
- en: Hippie completion
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 嘿皮士完成
- en: Hey, man! You wanna see something that is like totally far out? It’s called
    **cyclic word expansion**. Only total squares call it that, though. If you wanna
    be *hip*, you’ll call it **hippie completion**!
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 嘿，伙计！你想看看一些绝对超凡脱俗的东西吗？它被称为**循环词扩展**。不过，只有真正的老派人才会这样叫它。如果你想显得*嬉皮士*，你会称它为**嬉皮士完成**！
- en: 'Hippie completion is invoked by pressing *Alt* + */* (Windows and Linux) or
    *⌥* + */* on macOS. Once triggered, PyCharm will index all the files you currently
    have open and provide auto-completion suggestions based on words within that context.
    In effect, you are using the simplest form of auto-complete; a word list. The
    word list is generated on the fly from the words in the files you have open. They
    don’t have to be code. Plain text files, markup, markdown, or really any text
    will show up in the suggestions list based on a simple forward match. As you type,
    the list narrows. You can see an example in *Figure 4**.7*:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 嘿皮士完成是通过按*Alt* + */*（Windows和Linux）或*⌥* + */*在macOS上触发的。一旦触发，PyCharm将索引你当前打开的所有文件，并根据该上下文中的单词提供自动完成建议。实际上，你正在使用最简单的自动完成形式；一个单词列表。单词列表是实时从你打开的文件中的单词生成的。它们不必是代码。纯文本文件、标记、Markdown或任何文本都会根据简单的正向匹配出现在建议列表中。随着你输入，列表会缩小。你可以在*图4**.7*中看到一个例子：
- en: '![Figure 4.7: Hippie completion is totally far-out!](img/B19644_04_07.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图4.7：嬉皮士完成绝对超凡脱俗！](img/B19644_04_07.jpg)'
- en: 'Figure 4.7: Hippie completion is totally far-out!'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.7：嬉皮士完成绝对超凡脱俗！
- en: The text file on the right contains a list of words I generated at [https://fungenerators.com/lorem-ipsum/hippie/](https://fungenerators.com/lorem-ipsum/hippie/).
    Unfortunately, it turns out, a lot of the iconic words from the hippie generation
    in the United States cannot be printed in a book of this caliber. We have the
    highest standards! So, I edited the list, and this was all that was left. These
    words are random, so please don’t try to construe any meaning from them, despite
    all the allegations about there being secret backward messages on albums by The
    Beatles. The code on the right can expand from that list using hippie completion.
    To make this work, I typed `print("pat` then pressed *Alt* + */*. The word *patchouli*
    magically appeared! I hope this example was worth it for you. I may never get
    that smell out of my keyboard!
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 右侧的文本文件包含了我从[https://fungenerators.com/lorem-ipsum/hippie/](https://fungenerators.com/lorem-ipsum/hippie/)生成的单词列表。不幸的是，结果发现，美国嬉皮士一代的许多标志性词汇无法在这个级别的书中印刷。我们的标准是最高的！因此，我编辑了列表，这就是剩下的所有内容。这些单词是随机的，所以请不要试图从它们中推断出任何含义，尽管有关于披头士专辑上存在秘密反向信息的所有指控。右侧的代码可以使用嬉皮士完成从该列表中扩展。为了使这起作用，我输入了`print("pat`然后按了*Alt*
    + */*。神奇地出现了单词*patchouli*！我希望这个例子对你来说是有价值的。我可能永远无法从我的键盘上消除那种气味！
- en: You can use *Alt* + *Shift* + */* or *⌥* + *Shift* + */* to enable backward
    cyclic word expansion, which matches from the end of the words backward to the
    beginning. If the powers that be had asked me (and they didn’t, because they never
    do) I’d have called this `#GingerRogersCompletion` and reference this book, it
    might catch on!
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用*Alt* + *Shift* + */*或*⌥* + *Shift* + */*来启用反向循环词扩展，它从单词的末尾向后匹配到开头。如果当权者问我（他们没有，因为他们从不这样做）我会称这个为`#GingerRogersCompletion`并引用这本书，它可能会流行起来！
- en: Pro hippie tip
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 嘿皮士小贴士
- en: Repeatedly pressing *Alt* + */* (Windows and Linux) or *⌥* + */* on macOS cycles
    through the list. You can just keep hitting the key combination until the word
    you are looking for appears.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 重复按 *Alt* + */*（Windows 和 Linux）或 *⌥* + */*（macOS）会在列表中循环。你可以一直按这个键组合，直到出现你想要的单词。
- en: Indexing
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 索引
- en: 'There are various engines at work in powering PyCharm’s various code completion
    techniques. You might be wondering how it works. It isn’t dark sorcery, I assure
    you. The key to understanding it is to pay attention when PyCharm loads a project.
    *Figure 4**.8* calls your attention to the bottom of the PyCharm application window.
    PyCharm kicks off several background processes that comb through your code and
    index every character. The index is then converted into an in-memory database
    that is used by the various engines at play:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在为 PyCharm 的各种代码补全技术提供动力方面，有各种引擎在发挥作用。你可能想知道它是如何工作的。我向你保证，这并不是黑暗魔法。理解它的关键是注意
    PyCharm 加载项目时的行为。*图 4.8* 引导你的注意力到 PyCharm 应用程序窗口的底部。PyCharm 启动几个后台进程，这些进程会遍历你的代码并对每个字符进行索引。然后，索引被转换成一个内存数据库，该数据库被各种引擎使用：
- en: '![Figure 4.8: Keep an eye on the bottom of the PyCharm window to know when
    background processes such as indexing are running](img/B19644_04_08.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.8：注意 PyCharm 窗口的底部，以了解索引等后台进程何时运行](img/B19644_04_08.jpg)'
- en: 'Figure 4.8: Keep an eye on the bottom of the PyCharm window to know when background
    processes such as indexing are running'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.8：注意 PyCharm 窗口的底部，以了解索引等后台进程何时运行
- en: Normally, I don’t really care how the magic works, but it is worth bringing
    up because there will be times when PyCharm seems slow or unresponsive. When PyCharm
    seems slow or if auto-completion isn’t working, check the area of the screen indicated
    in *Figure 4**.8* and see whether there are indexing processes running. You’ll
    probably notice your CPU spike as well if you monitor such things. This is temporary.
    Once the indexing process completes, PyCharm will become responsive again.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我并不真的关心魔法是如何工作的，但这是值得提及的，因为有时 PyCharm 可能会显得缓慢或无响应。当 PyCharm 显得缓慢或自动补全功能不起作用时，检查
    *图 4.8* 中指示的屏幕区域，看看是否有索引进程正在运行。如果你监控这类事情，你可能会注意到你的 CPU 会突然升高。这是暂时的。一旦索引过程完成，PyCharm
    将再次变得响应。
- en: Power Save Mode
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 节能模式
- en: 'One of the more cryptic entries in the PyCharm menu, shown in *Figure 4**.9*,
    is **Power** **Save Mode**:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: PyCharm 菜单中较为晦涩的条目之一，如 *图 4.9* 所示，是 **节能模式**：
- en: '![Figure 4.9: The Power Save Mode menu option can be found under the File menu](img/B19644_04_09.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.9：节能模式菜单选项可以在文件菜单下找到](img/B19644_04_09.jpg)'
- en: 'Figure 4.9: The Power Save Mode menu option can be found under the File menu'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.9：节能模式菜单选项可以在文件菜单下找到
- en: I remember the first time I clicked it. The streetlights throughout the city
    block where I live instantly got brighter. My electric meter that was spinning
    like a buzzsaw mere minutes ago was now lazily spinning slower than an abandoned
    top. Once, a guy at the power company even called and thanked me for doing my
    part in saving the planet.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我记得第一次点击它的时候。我住的城市街道的街灯瞬间变得更亮了。几分钟前像锯子一样旋转的电表现在懒洋洋地转得比废弃的陀螺还慢。有一次，电力公司的一个家伙甚至打电话来感谢我为拯救地球做出的贡献。
- en: 'OK, I’m making all that up, except for the part about the guy from the power
    company. That totally happened. The `b.if` from the earlier example:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，我编造了所有那些内容，除了关于电力公司那人的部分。那绝对是真实发生的。早期示例中的 `b.if`：
- en: '![Figure 4.10: A message reminds you that power save mode is on and that you
    will not be receiving the usual level of assistance from PyCharm](img/B19644_04_10.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.10：一条消息提醒你节能模式已开启，并且你将不会从 PyCharm 收到通常的水平支持](img/B19644_04_10.jpg)'
- en: 'Figure 4.10: A message reminds you that power save mode is on and that you
    will not be receiving the usual level of assistance from PyCharm'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.10：一条消息提醒你节能模式已开启，并且你将不会从 PyCharm 收到通常的水平支持
- en: Personally, I consider this utterly barbaric! How are we supposed to work like
    this? Next, you’ll be telling me I don’t have access to the internet, Kite, GitHub
    Copilot, ChatGPT, or Stack Overflow! You’ll strip me of my very reasonably priced
    subscription to [packtpub.com](http://packtpub.com), where I can get all the e-books
    I can read for one low price. Then you’ll take away my Herman Miller Aeron Chair
    and limit me to only one $14 mezzo-Grande half-fat triple foam double shot latte
    with rainbow jasmine-infused sprinkles per day! Why don’t you enact a dress code
    while you’re at it? Strike! Strike! Strike!
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 个人来说，我认为这完全是野蛮的！我们该如何工作呢？接下来，您会告诉我我没有访问互联网、Kite、GitHub Copilot、ChatGPT或Stack
    Overflow！您将剥夺我合理价格的[packtpub.com](http://packtpub.com)订阅权，在那里我可以以一个低廉的价格阅读所有我可以读的电子书。然后您会拿走我的Herman
    Miller Aeron椅子，并限制我每天只能喝一杯14美元的中等大杯半脂三倍泡沫双份浓缩咖啡，上面撒上彩虹茉莉花味的糖霜！为什么您还要实施着装规定呢？打倒！打倒！打倒！
- en: 'Sorry. I got a little carried away. Needless to say, this is probably the least
    favorite feature of the IDE. Maybe it is useful if you chewed up your laptop’s
    battery playing *Ghost Recon: Breakpoint* on an overseas flight, and upon landing,
    you suddenly get a call from the boss who needs something fixed right away. Suddenly,
    you need to squeeze every second out of that 5% battery level you have left. I
    hate it when that happens.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 抱歉。我有点过于激动了。不用说，这可能是IDE中最不受欢迎的功能。也许如果您在国外航班上玩*幽灵行动：断点*耗尽了笔记本电脑的电池，着陆后突然接到老板的电话，需要立即修复某些东西，这可能会有些用。突然，您需要从剩余的5%电池电量中榨取每一秒。当这种情况发生时，我真的很讨厌。
- en: Customizing code completion
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义代码补全
- en: Customization within PyCharm is an ongoing theme. It might have been easier
    to show you what you can’t customize, except that I haven’t actually found anything
    yet. Code completion is no different. Whether you prefer a very lightweight experience
    with little to no help or you want your handheld on every line of code, there
    is a way to make PyCharm into the editor you want to use every day.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在PyCharm中进行自定义是一个持续的主题。展示您无法自定义的内容可能更容易，但我实际上还没有找到任何东西。代码补全也不例外。无论您更喜欢非常轻量级的体验，几乎不需要帮助，还是希望每行代码都有指导，PyCharm都可以满足您的需求。
- en: 'To open the settings for code completion, venture back to the settings dialog
    we explored in [*Chapter 2*](B19644_02.xhtml#_idTextAnchor028), *Installation
    and Configuration*. You can reach it easily by clicking the **File** menu item
    and selecting **Settings**. That brings up the settings dialog. If you recall
    from [*Chapter 2*](B19644_02.xhtml#_idTextAnchor028), *Installation and Configuration*,
    this dialog is massive! We’re looking for **Editor** | **General** | **Code Completion**,
    as shown in *Figure 4**.11*:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 要打开代码补全的设置，请回到我们在[*第2章*](B19644_02.xhtml#_idTextAnchor028)，*安装和配置*中探索的设置对话框。您可以通过点击**文件**菜单项并选择**设置**轻松访问它。这会弹出设置对话框。如果您还记得[*第2章*](B19644_02.xhtml#_idTextAnchor028)，*安装和配置*，这个对话框是巨大的！我们正在寻找**编辑器**
    | **常规** | **代码补全**，如图*图4.11*所示。11*：
- en: '![Figure 4.11: The Code Completion settings allow you to customize the behavior
    of PyCharm’s Code Completion engine](img/B19644_04_11.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图4.11：代码补全设置允许您自定义PyCharm代码补全引擎的行为](img/B19644_04_11.jpg)'
- en: 'Figure 4.11: The Code Completion settings allow you to customize the behavior
    of PyCharm’s Code Completion engine'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.11：代码补全设置允许您自定义PyCharm代码补全引擎的行为
- en: You should spend a moment going through everything you can do on this screen.
    PyCharm gives you a great deal of control! I promised this wouldn’t be a tedious
    accounting of every option. Instead, draw your attention to the most popular and
    potentially most useful settings available.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该花点时间浏览一下这个屏幕上您可以做的事情。PyCharm给了您很大的控制权！我承诺这不是一个对每个选项的繁琐记录。相反，我将您的注意力引向最流行和最有潜力的设置。
- en: Match case
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 区分大小写
- en: Located at the top of the window, this option specifies whether items in the
    suggestion list should match the case of whatever you are typing. For example,
    if I wanted to type in an exception expression for the `KeyboardInterrupt` exception
    in Python and the `K` for the correct class name to be included in the suggestion
    list. Next to the **Match case** checkbox, you can also choose only the first
    letter’s case should be matched or whether this should apply to all the letters.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 位于窗口顶部，此选项指定建议列表中的项目是否应该与您输入的内容的大小写匹配。例如，如果我想为Python中的`KeyboardInterrupt`异常输入一个异常表达式，并且想要将正确的类名`K`包含在建议列表中。在**匹配大小写**复选框旁边，您还可以选择仅匹配第一个字母的大小写，或者是否应该匹配所有字母。
- en: 'I personally always disable this checkbox so that I only have to type in, for
    example, a lowercase `k` to take advantage of code completion. When I am learning
    a new language or API, this setting can help me with a practice I call *property
    shopping*. I don’t know what properties and methods are available, so an alphabetized
    list can be helpful. For example, every programming language has some sort of
    string-handling class or library. It is a very safe bet that the said library
    will have functions for trimming, which is to remove extra spaces from the front,
    end, or both ends of a string. There is always some sort of `toUpper` and `toLower`
    methods. These are all vital parts of defensive programming. A password input
    where a user accidentally includes a space at the beginning or end of the password
    makes for a frustrating user experience. Any conditional logic you use involving
    user input is easier to handle if you make everything upper or lowercase. Given
    these are so fundamental to our work, we know they will be on the list, but every
    language calls them something different. I work on projects that require switching
    between two or three languages, and it is very easy to type in the wrong function
    name. Take the method that converts a string to uppercase. In JavaScript, such
    a function looks like this:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我个人总是禁用此复选框，这样我只需输入，例如，小写的`k`，就能利用代码补全功能。当我学习一门新语言或API时，此设置可以帮助我进行我称之为*属性购物*的练习。我不知道有哪些属性和方法可用，因此一个按字母顺序排列的列表可能会有所帮助。例如，每种编程语言都有某种形式的字符串处理类或库。可以非常肯定地说，该库将具有修剪函数，即从字符串的前面、后面或两边去除额外空格。这些`toUpper`和`toLower`方法都是防御性编程的重要组成部分。如果用户在密码输入时意外地在密码的开始或结尾处包含空格，这将导致用户体验不佳。如果您使用涉及用户输入的任何条件逻辑，那么将所有内容都转换为大写或小写将更容易处理。鉴于这些都是我们工作的基础，我们知道它们将在列表中，但每种语言都称它们为不同的名称。我从事的项目需要在不同两种或三种语言之间切换，很容易输入错误的功能名称。以将字符串转换为上档的方法为例。在JavaScript中，这样的函数看起来是这样的：
- en: '[PRE3]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The same code in PyCharm, which I might be creating only minutes later, would
    look like this:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在PyCharm中相同的代码，我可能几分钟内就会创建，看起来是这样的：
- en: '[PRE4]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In order to be effective, I need the word upper to be a match regardless of
    whether it is uppercase or lowercase.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 为了有效匹配，我需要单词“upper”无论大小写都能匹配。
- en: Like everything we have seen in code completion, and for that matter, like everything
    in programming, there is a trade-off to this practice. Specifically, if **Match
    case** is disabled, sometimes the suggestion list might be populated by many more
    irrelevant options, which makes finding the correct API more difficult. At the
    same time, though, you will see a full list of what is possible, which can help
    you learn your way around and sometimes discover features in an API you had not
    imagined were available.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在代码补全中看到的一切，以及编程中的所有事物一样，这种做法也有其权衡。具体来说，如果**匹配大小写**被禁用，有时建议列表可能会包含许多更多的不相关选项，这使得找到正确的API变得更加困难。然而，同时，您将看到所有可能性的完整列表，这可以帮助您熟悉环境，有时还可以发现API中您未曾想象到的功能。
- en: Sorting suggestions alphabetically
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 按字母顺序排序建议
- en: As its name suggests, this option allows you to sort the items in the suggestion
    list in alphabetical order. This feature is useful for long suggestion lists that
    require the developer to scroll through them carefully to find what they are looking
    for if they were not ordered alphabetically.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 正如其名所示，此选项允许您按字母顺序对建议列表中的项目进行排序。对于需要开发者仔细滚动查找所需内容的较长的建议列表，此功能非常有用。
- en: 'On multiple occasions, we have seen the dynamic nature of PyCharm, and it is
    once again demonstrated in this feature. Specifically, while interacting with
    a suggestion list in the editor, you can change the order of the items in the
    list at any time by clicking on the icon located in the bottom-right corner of
    the suggestion window, as shown in *Figure 4**.12*:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在多次事件中，我们已经看到了 PyCharm 的动态特性，这一特性在此功能中再次得到了体现。具体来说，当在编辑器中与建议列表交互时，您可以通过点击建议窗口右下角图标来随时更改列表中项目的顺序，如图
    *图 4.12* 所示。12*：
- en: '![Figure 4.12: You can change the way suggestions are sorted within the list
    itself](img/B19644_04_12.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.12：您可以在列表内部更改建议的排序方式](img/B19644_04_12.jpg)'
- en: 'Figure 4.12: You can change the way suggestions are sorted within the list
    itself'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.12：您可以在列表内部更改建议的排序方式
- en: 'Clicking the **…** (ellipsis) element allows you to change how the suggestions
    are sorted: by relevance or alphabetically by name.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 点击 **…**（省略号）元素，您可以更改建议的排序方式：按相关性或按名称字母顺序排序。
- en: Machine learning assisted completions
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 机器学习辅助补全
- en: This newer option is simultaneously magical and scary. Enabled by default, PyCharm
    will train a machine learning model based on your code. This allows PyCharm to
    make suggestions based not only on your code but also that of thousands of other
    developers. Traditional code completion usually gives you suggestions for the
    next keyword, property, method name, or parameter you are about to type. Do not
    be surprised if PyCharm offers complete entire functions or blocks of code for
    you with machine learning assisted completions. You will see this for common tasks
    such as connecting to databases, working with pandas data frames, or validating
    user input.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新选项既神奇又令人恐惧。默认情况下启用，PyCharm 将根据您的代码训练一个机器学习模型。这使得 PyCharm 能够基于您的代码以及成千上万个其他开发者的代码提出建议。传统的代码补全通常只会为您建议下一个关键字、属性、方法名或您即将输入的参数。如果
    PyCharm 提供了由机器学习辅助的完整函数或代码块供您选择，请不要感到惊讶。您会在连接数据库、处理 pandas 数据框或验证用户输入等常见任务中看到这一点。
- en: The settings merely allow you to turn on various languages supported by PyCharm.
    Python, JavaScript, and TypeScript are enabled by default. Only SQL, a special-purpose
    language used for working with relational databases, is not enabled by default.
    I suspect this is because there are additional settings around your preferred
    SQL dialect both at the global and project level that contribute to suggestions.
    It would be awkward to expect a tight list of suggestions given the number of
    databases PyCharm supports and the differences in their implementation of language
    elements not defined by standardized SQL. We’ll look at SQL and relational databases
    later in *Chapter 11*, *Understanding Database Management with PyCharm*. I promise
    the experience will not leave you bankrupt.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 设置仅允许您开启 PyCharm 支持的各种语言。Python、JavaScript 和 TypeScript 默认启用。只有 SQL，一种用于处理关系数据库的特殊用途语言，默认未启用。我怀疑这是因为您在全局和项目级别都有关于您首选
    SQL 语言的额外设置，这些设置有助于建议。考虑到 PyCharm 支持的数据库数量以及它们对未由标准化 SQL 定义的元素的不同实现，期望有一个紧密的建议列表会显得有些尴尬。我们将在
    *第 11 章*，*使用 PyCharm 理解数据库管理* 中稍后查看 SQL 和关系数据库。我保证您不会失望。
- en: Showing the documentation popup in [...] ms
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 [...] 毫秒内显示文档弹出窗口
- en: When you enable this feature, you will see the documentation in addition to
    the suggestion code. You will be able to understand what the code you are typing
    does rather than blindly accepting the suggestions. This is great for new developers,
    whether they are totally new to coding or just new to Python. The advantage of
    this feature is that you can go through the documentation of all the suggested
    items dynamically as you simply move the cursor down the items.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当您启用此功能时，您将看到文档以及建议的代码。您将能够理解您正在输入的代码的功能，而不仅仅是盲目接受建议。这对于新开发者来说是个大优点，无论是完全对编码新手还是对
    Python 新手来说都是如此。此功能的优点是，您可以在将光标向下移动到项目时动态地查看所有建议项的文档。
- en: This is especially beneficial when working with classes and methods that have
    similar APIs. We will discuss this feature, along with other documentation-related
    functionalities, in the last section of this chapter.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当与具有相似 API 的类和方法一起工作时，这一点尤其有益。我们将在本章的最后部分讨论此功能，以及其他与文档相关的功能。
- en: Parameter info
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参数信息
- en: 'Scroll down past the JavaScript section, as seen in *Figure 4**.13*, and you’ll
    find an option for suggesting parameter information:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 滚动到JavaScript部分以下，如*图4.13*所示，你会找到一个建议参数信息的选项：
- en: '![Figure 4.13: Scroll down past JavaScript to find options for showing parameter
    information](img/B19644_04_11.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![图4.13：滚动到JavaScript以下以找到显示参数信息的选项](img/B19644_04_11.jpg)'
- en: 'Figure 4.13: Scroll down past JavaScript to find options for showing parameter
    information'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.13：滚动到JavaScript以下以找到显示参数信息的选项
- en: The first option is straightforward. It controls the amount of time that must
    elapse before a suggestion appears. In general, suggestions are great unless you
    are teaching, doing a code review, or doing some sort of demo, in which case they
    can clutter up your screen. Sometimes it’s a good idea to raise the time limit
    so the suggestions or documentation are shown only if you linger for a few seconds.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个选项很简单。它控制了在出现建议之前必须经过的时间量。一般来说，建议是很好的，除非你在教学、进行代码审查或进行某种演示，在这种情况下，它们可能会让你的屏幕变得杂乱。有时提高时间限制是个好主意，这样建议或文档只有在停留几秒钟后才会显示。
- en: The second option allows you to toggle, showing the full method signature. I
    love this feature. The code hint will show you the whole method signature so you
    can see all the arguments at once.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个选项允许你切换显示完整方法签名。我喜欢这个功能。代码提示会显示整个方法签名，这样你可以一次性看到所有参数。
- en: 'A method signature uniquely defines a function or method within the scope where
    it is declared. It consists of a name for the function. Along with the names,
    and preferably hints, for the type of the function’s arguments with some hints
    about the return type. These are not unique to Python. In fact, they are a little
    bit fuzzy in Python. Now compare it with a static language such as C#, which uses
    more strict programming structures. In Python, you can use type hints, which help
    developers to remember the expected types of the arguments being passed. Let’s
    look at an example of a method signature without hints:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 方法签名独特地定义了在声明它的作用域内的函数或方法。它包括函数的名称。以及函数参数的类型名称，最好还有关于返回类型的提示。这些并不特指Python。实际上，在Python中它们有点模糊。现在让我们将其与使用更严格编程结构的静态语言，如C#，进行比较。在Python中，你可以使用类型提示，这有助于开发者记住传递的参数的预期类型。让我们看看一个没有提示的方法签名的例子：
- en: '[PRE5]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This is OK. This code will work as intended, and the intention of the developer
    is clear. Let’s look at the same function with hints:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这是可以的。这段代码将按预期工作，开发者的意图是清晰的。让我们看看带有提示的相同函数：
- en: '[PRE6]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This is much better! Now we know for certain the types that are expected as
    input parameters, and we know the type that is going to be returned. I said earlier
    that method signatures are “fuzzy” in Python. I said this because both code samples
    will work. Python ignores the hints entirely during compilation. The hints are
    just used by the tooling and make your Python code easier to read and understand.
    Adding hints to your code whenever possible will enhance the way you, and your
    teammates, see your method signatures if you turn on the **Show full method**
    **signatures** option.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这好多了！现在我们确切地知道了作为输入参数期望的类型，以及将要返回的类型。我之前说过，Python中的方法签名是“模糊”的。我说这个是因为两个代码示例都会工作。Python在编译过程中完全忽略了提示。提示只是由工具使用，使你的Python代码更容易阅读和理解。尽可能地在你的代码中添加提示将增强你和你队友在开启**显示完整方法签名**选项时看到的方法签名的方式。
- en: Code analysis and automated fixes
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码分析和自动化修复
- en: Code completion is a standard feature of most code editors and IDEs. As we’ve
    seen, not all completion engines are created equally. The same can be true for
    analysis engines. A code analysis engine is an extension of code completion in
    concept, if not in implementation. Code completion tries to predict the code you
    are writing and helps you finish more quickly. Code analysis examines the code
    you’ve written and attempts to determine whether or not the code will work when
    you run it. Just as with code completion, there are differing levels of complexity
    at play here and different processes examining different things.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 代码补全是最多代码编辑器和IDE的标准功能。正如我们所见，并非所有补全引擎都是相同的。分析引擎也是如此。从概念上讲，代码分析引擎是代码补全的扩展，如果不是在实现上。代码补全试图预测你正在编写的代码，并帮助你更快地完成。代码分析检查你已编写的代码，并试图确定代码在运行时是否有效。就像代码补全一样，这里存在不同的复杂程度，不同的过程检查不同的事情。
- en: The simplest form of analysis is called *linting*. Pretty much every programming
    language has a linting tool, and Python is no exception. While there are many
    to choose from, PyCharm uses the popular `pylint` library by default.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的分析形式被称为*代码检查*。几乎每种编程语言都有代码检查工具，Python也不例外。虽然有很多可供选择，但PyCharm默认使用流行的`pylint`库。
- en: 'A linter runs a tacit analysis of your code through a process of pattern matching.
    There are two linting operations: **logical lint** and **stylistic lint**. A logical
    lint looks for code errors, code with potentially unintentional results or side
    effects, and dangerous code patterns. A stylistic lint looks for code that doesn’t
    conform to common conventions. This is less of a problem with Python since the
    language already has a strict set of code formatting rules called **Python Enhancement
    Proposal #8**. Nobody calls it that. Those in the know simply call it **PEP-8**.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 代码检查器通过模式匹配的过程对代码进行隐式分析。有两种代码检查操作：**逻辑检查**和**样式检查**。逻辑检查查找代码错误、可能产生意外结果或副作用以及危险的代码模式。样式检查查找不符合常见约定的代码。在Python中，这个问题不太严重，因为该语言已经有一套严格的代码格式化规则，称为**Python增强提案#8**。没有人会这样称呼它。了解的人只是简单地称之为**PEP-8**。
- en: Combined, you can think of `pylint` and, by extension, all linters, much like
    a spelling and grammar checker for regular text. The linter looks for misspelled
    keywords, malformed code, and obvious syntax errors. A linter can also enforce
    style guidelines, though really Python is already designed to enforce rules to
    make your code as human-readable as possible.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 结合使用`pylint`以及所有类似工具，你可以将其视为类似于常规文本中的拼写和语法检查器。代码检查器会查找拼写错误的关键字、格式不正确的代码和明显的语法错误。代码检查器还可以强制执行样式指南，尽管实际上Python已经设计得尽可能使代码易于阅读，并强制执行规则。
- en: While it’s one thing to point out problems in your code, it is entirely more
    useful if the tool also suggests and even implements fixes to those problems.
    The same is true of humans. It is easy to point out flaws. Anybody can do that.
    Good advice on how to fix your flaws is more useful than criticism. So, in addition
    to linting, PyCharm offers a system that will offer to help you fix the problems
    exposed by the linter.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当指出代码中的问题时，这固然很重要，但如果工具还能提出甚至实施解决问题的方案，那就更有用了。对于人类来说也是如此。指出缺陷很容易，任何人都能做到。关于如何改正你的缺陷的好建议比批评更有用。因此，除了代码检查之外，PyCharm还提供了一个系统，它会主动帮助你修复由代码检查器暴露的问题。
- en: Problem detection
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题检测
- en: 'Problem detection is performed by PyCharm in real time as you type your code.
    The indexing process we’ve mentioned before plays a role here, but we’ll come
    back to that. First, let’s focus on the visible interface in the editor that shows
    you where your problems lie. There are four places to look, as shown in *Figure
    4**.14*:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编写代码时，PyCharm会实时执行问题检测。我们之前提到的索引过程在这里也发挥作用，但我们会稍后再谈。首先，让我们关注编辑器中显示你问题所在位置的可见界面。有四个地方可以查看，如图*图4.14*所示：
- en: '![Figure 4.14: Four places in the user interface tell you that you have problems](img/B19644_04_14.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图4.14：用户界面中的四个地方告诉你存在问题](img/B19644_04_14.jpg)'
- en: 'Figure 4.14: Four places in the user interface tell you that you have problems'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.14：用户界面中的四个地方告诉你存在问题
- en: The right gutter of the editor (1) will show you where all the problematic lines
    lie in the currently open file. This gutter is a compressed, miniature representation
    of your file. It is pretty common for a file to have hundreds or maybe even thousands
    of lines. You can click on the area in the gutter where you see the colored marks,
    and the editor will scroll to that location.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑器的右侧空白处（1）会显示当前打开文件中所有问题所在的行。这个空白处是文件的一个压缩、微型表示。一个文件有数百行甚至数千行是很常见的。你可以点击空白处中看到彩色标记的区域，编辑器会滚动到该位置。
- en: 'PyCharm will classify the problems into three basic categories: errors (red),
    warnings (yellow), and weak warnings (gray). This is reported for the whole file
    at the top of the gutter column with counts of each problem type (2). In addition
    to colors, this area gives you different shapes. The error icon is a round red
    circle with an exclamation point within it. Warnings are a triangle with an exclamation
    point. Weak warnings are also depicted using a triangle with an exclamation, but
    they appear considerably dimmer. If no problems are detected, you are rewarded
    with a green check mark. *Figure 4**.15* shows two files. One has no problems
    (1), while the other has a number of issues in different categories (2):'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: PyCharm 将问题分为三个基本类别：错误（红色）、警告（黄色）和弱警告（灰色）。这将在空白区域的顶部报告整个文件，并显示每种问题类型的计数（2）。除了颜色外，这个区域还提供了不同的形状。错误图标是一个带有感叹号的圆形红色圆圈。警告是一个带有感叹号的三角形。弱警告也使用带有感叹号的三角形来表示，但它们看起来相当暗淡。如果没有检测到任何问题，你将得到一个绿色的勾号。*图4.15*显示了两个文件。一个没有问题（1），而另一个在不同类别中存在多个问题（2）：
- en: '![Figure 4.15: The file on the bottom is devoid of any problems, while the
    one on top isn’t quite as lucky](img/B19644_04_15.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![图4.15：底部的文件没有任何问题，而顶部的文件则不太幸运](img/B19644_04_15.jpg)'
- en: 'Figure 4.15: The file on the bottom is devoid of any problems, while the one
    on top isn’t quite as lucky'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.15：底部的文件没有任何问题，而顶部的文件则不太幸运
- en: Anything marked in red is an error that will probably prevent your program from
    running correctly or at all. A warning means your code will probably run, but
    there are some obvious cases where it won’t perform as expected. A weak warning
    is usually a minor flaw, such as a variable name that doesn’t conform to an English
    dictionary word. If your locale is set to a language other than English, PyCharm
    will flag words from your local language.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 任何标红的都是可能阻止你的程序正确运行或根本无法运行的错误。警告意味着你的代码可能能够运行，但在一些明显的情况下它可能不会按预期执行。弱警告通常是一个小缺陷，比如一个不符合英语词典单词的变量名。如果你的区域设置不是英语，PyCharm
    将标记来自你本地语言的单词。
- en: The second place to look for problems is within the editor window itself. Look
    back at *Figure 4**.15* at line 13\. You’ll see a squiggly red (trust me) underline
    beneath the word `math`. The colors of the lines correspond with the severity
    of the problem. The right-hand gutter shows you where the problem is located,
    while the underlines show you the problem directly on the offending line. If you
    hover your mouse over whatever is underlined, you’ll get a description of the
    problem. I’ll go into more depth on this later in this chapter when we talk about
    **intentions**, which are suggestions about how to fix problems in your code.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个寻找问题的地点是在编辑器窗口内部。回顾一下*图4.15*的第13行。你会看到单词`math`下面有一个波浪形的红色下划线（相信我）。这些线的颜色与问题的严重程度相对应。右侧的空白区域显示了问题所在的位置，而下划线则直接显示了问题所在的行。如果你将鼠标悬停在任何下划线上，你会得到关于问题的描述。我将在本章后面更深入地讨论这个问题，当我们谈到**意图**时，这些意图是关于如何修复代码中问题的建议。
- en: 'The third place you’ll find indicators of problems is the project explorer.
    Refer back to *Figure 4**.15*, area 3\. There is a Python package called `bad_actor`.
    That file isn’t open in *Figure 4**.15*, but I opened it when I created it, typed
    in some incomplete code, then closed the file. You can see the file open in *Figure
    4**.16*:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现问题的第三个指示是在项目资源管理器中。回顾一下*图4.15*，区域3。有一个名为`bad_actor`的Python包。在*图4.15*中，该文件没有打开，但我在创建它时打开了它，输入了一些不完整的代码，然后关闭了文件。你可以在*图4.16*中看到该文件已打开：
- en: '![Figure 4.16: Silly me! I started typing in the file but never finished](img/B19644_04_16.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![图4.16：真傻！我开始在文件中输入，但从未完成](img/B19644_04_16.jpg)'
- en: 'Figure 4.16: Silly me! I started typing in the file but never finished'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.16：真傻！我开始在文件中输入，但从未完成
- en: If there is an error in the file you aren’t currently working on, you’ll find
    it flagged in the file list. The warning will bubble up through the directory
    system. There’s a red squiggly line at the top project folder, another in the
    folder for the package, and still another underline beneath the file where the
    problem lies. PyCharm doesn’t examine closed files. It only examines files you
    open, but once it finds the problem, it will remember where it is and continue
    to warn you until you fix the problem.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在工作的文件中存在错误，你会在文件列表中找到它。警告会通过目录系统冒泡。项目文件夹顶部有一个红色波浪线，包文件夹中有一个，问题所在的文件下方还有一个下划线。PyCharm不会检查已关闭的文件。它只检查你打开的文件，但一旦它找到问题，它会记住位置并继续警告你，直到你解决问题。
- en: Bad actor
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 糟糕的演员
- en: I needed an exemplary bad actor for the previous visual pun. Kevin Costner is
    a bad American actor. He certainly isn’t the worst, but he’s easily in the top
    10\. If you don’t believe me, watch the movie *Dances with Wolves*. If you still
    don’t believe me, watch *The Bodyguard*. If you still think he’s great, watch
    *Waterworld* and realize he financed that movie out of his own pocket because
    he was convinced it would be a mega-hit.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我需要一个典型的反面教材来展示之前的视觉双关语。凯文·科斯特纳是一个糟糕的美国演员。他当然不是最糟糕的，但他在前10名之内。如果你不相信我，看看电影《与狼共舞》。如果你仍然不相信我，看看《保镖》。如果你仍然认为他很好，看看《水世界》，并意识到他自掏腰包投资这部电影，因为他坚信它将是一个大热门。
- en: 'The fourth place is the problems window. In *Figure 4**.17*, you can see a
    red dot over an icon in area 4 in the screenshot. Click the icon, and the problems
    window will open and show you a list of faults, as seen in *Figure 4**.17*:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 第四位是问题窗口。在**图4**.17中，你可以看到截图区域4中的图标上有一个红色圆点。点击图标，问题窗口将打开并显示错误列表，如图**4**.17所示：
- en: '![Figure 4.17: Open the problem window to see a list of all your problems.
    Only your code problems are displayed. Life problems are not shown](img/B19644_04_17.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![图4.17：打开问题窗口，查看所有问题列表。只显示你的代码问题。生活问题不会显示](img/B19644_04_17.jpg)'
- en: 'Figure 4.17: Open the problem window to see a list of all your problems. Only
    your code problems are displayed. Life problems are not shown'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.17：打开问题窗口，查看所有问题列表。只显示你的代码问题。生活问题不会显示
- en: Syntax errors
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 语法错误
- en: Syntax errors are usually the shallowest errors exposed by an IDE. We’ve seen
    a few already. *Figure 4**.17* shows an incomplete function definition, so it
    is flagged in red as a syntax error. In *Figure 4**.14*, line 13 has a red underline
    beneath the word `math`. PyCharm recognizes this as a reference to the Python
    `math` library, which I have neglected to import. This throws an unresolved reference
    error. These kinds of errors are always marked in red as severe errors because
    they will prevent the program from running.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 语法错误通常是IDE暴露的最浅显的错误。我们已经看到了几个。**图4**.17显示了一个不完整的函数定义，因此它被标记为红色语法错误。在**图4**.14中，第13行在单词`math`下方有一个红色下划线。PyCharm将其识别为对Python
    `math`库的引用，而我忘记导入它。这引发了一个未解决的引用错误。这类错误总是被标记为红色严重错误，因为它们将阻止程序运行。
- en: Duplicated code
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重复的代码
- en: If you make a habit of copying and pasting code within your project or even
    between different projects, you can expect a warning from PyCharm. Duplicated
    code is a sign your project is in trouble.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你习惯在项目内部或甚至在不同项目之间复制粘贴代码，你可能会收到PyCharm的警告。重复的代码是项目出现问题的信号。
- en: The best practice is to follow the concept called **Don’t Repeat Yourself**
    (**DRY**). I’ll say it again. You want your code to always be DRY. Never repeat
    your code by copying and pasting. Make sure it’s DRY. OK, I’ll stop if you promise
    to heed PyCharm’s warnings about code not being DRY.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳实践是遵循名为**不要重复自己**（**DRY**）的概念。我再重复一遍。你希望你的代码始终保持DRY。永远不要通过复制粘贴来重复代码。确保它是DRY。好吧，如果你答应注意PyCharm关于代码不是DRY的警告，我就不再说了。
- en: When you find this problem within a single project, you can usually fix it by
    hoisting the duplicated code into a function and calling the function from the
    parts of your code where the duplicates lie.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在单个项目中找到这个问题时，你通常可以通过将重复的代码提升到函数中并从代码中重复的部分调用该函数来解决它。
- en: If you get flagged for copying and pasting between projects, you should turn
    the duplicated code into a Python package that can be shared between projects.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你因为在不同项目之间复制粘贴而被标记，你应该将重复的代码转换成一个可以在项目之间共享的Python包。
- en: PEP-8 problems
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PEP-8问题
- en: PyCharm’s linter alerts you to styling problems in your code that violate PEP-8\.
    The biggest problem for developers new to Python is dealing with the rules around
    white space. Indentions and empty lines between functions are all part of the
    PEP-8 rules designed to keep your code very readable. Most PEP-8 problems are
    flagged as warnings.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: PyCharm的代码检查器会提醒你代码中的样式问题，这些问题违反了PEP-8。对于新接触Python的开发者来说，最大的问题是处理空白规则。函数之间的缩进和空行都是PEP-8规则的一部分，旨在使你的代码非常易于阅读。大多数PEP-8问题都被标记为警告。
- en: Dead code
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 死代码
- en: 'This is my personal pet peeve. Someone writes some code, which ultimately gets
    replaced with a different function. Both the old and the unused function are sitting
    in the code file, along with the new one. They might have similar names. They
    might even be in different files. When I was a kid, I had a poster on my wall
    titled Murphy’s Laws of Technology. The poster espoused a pessimistic but, in
    my experience (and probably yours if you’ve been doing this for a while), totally
    accurate worldview. Here’s a sampling of Murphy’s Laws with respect to technology:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我个人的一个小烦恼。有人编写了一些代码，最终被不同的函数所取代。旧的、未使用的函数和新函数都坐在代码文件中。它们可能具有相似的名字。它们甚至可能在不同的文件中。当我还是个孩子的时候，我在墙上贴了一张标题为“墨菲的技术法则”的海报。海报宣扬了一种悲观但在我（以及你可能已经做了很长时间的你的）经验中，完全准确的世界观。以下是关于技术的墨菲法则的一些样本：
- en: You can never tell which direction the train traveled by looking at the track
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你无法通过看轨道来判断火车行驶的方向
- en: Logic is a systematic method of coming to the wrong conclusion with confidence
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逻辑是一种系统地得出错误结论的方法，而且信心十足
- en: Whenever a system becomes completely defined, some fool discovers something
    which either abolishes the system or expands it beyond recognition
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每当一个系统变得完全定义后，总有一些傻瓜会发现一些东西，这些东西要么废除该系统，要么将其扩展到无法识别的程度
- en: 'Technology is dominated by those who manage what they don’t understand: if
    builders built buildings the way programmers wrote programs, then the first woodpecker
    that came along would destroy civilization'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 技术被那些管理他们不理解的事物的人所主导：如果建造者像程序员编写程序那样建造建筑，那么第一个出现的啄木鸟就会摧毁文明
- en: The attention span of a computer is only as long as its electrical cord
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算机的注意力跨度只与其电源线一样长
- en: An expert is one who knows more and more about less and less until he knows
    absolutely everything about nothing
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 专家是那些对越来越少的事物了解越来越多，直到他对什么都不了解的人
- en: This is relevant because, at least for me, the likelihood that I will find and
    attempt to modify dead code (thinking it to be very much alive and the obvious
    source of all my problems) in a software system asymptotically approaches 100%.
    The tiny degree of variance somewhere between 99% and 100% seems to be affected
    by my present level of caffeination and whether I skipped breakfast. These effects
    appear to be inversely proportional.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我至少有关，因为我找到并尝试修改死代码（认为它非常活跃，是所有问题的明显来源）的可能性几乎达到100%。在99%和100%之间微小的差异似乎受到我当前咖啡因摄入量和是否跳过早餐的影响。这些影响似乎成反比。
- en: I thank goodness for a system that warns me that I’m looking at dead code. My
    usual rant is that you should take dead code out. You won’t need it, and if you
    do, that’s what revision control systems are for.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我感谢一个警告我正在查看死代码的系统。我通常的抱怨是，你应该删除死代码。你不需要它，如果你需要，那就是版本控制系统的作用。
- en: Method signature mismatches
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法签名不匹配
- en: A method signature mismatch happens when a function requires more or fewer arguments
    than the number you supplied. PyCharm will warn you when this happens.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数需要的参数多于或少于你提供的数量时，就会发生方法签名不匹配。当这种情况发生时，PyCharm会警告你。
- en: The road to good code is paved with PyCharm’s intentions
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 好代码的道路是用PyCharm的意图铺就的
- en: 'Now that we’ve spent time learning about our flaws, let’s look at some tools
    that help us fix them. PyCharm features a mechanism called intentions designed
    to automate fixing and improving your code. Take a look at *Figure 4**.18*:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经花时间了解我们的缺点，让我们看看一些帮助我们修复它们的工具。PyCharm有一个名为“意图”的机制，旨在自动化修复和改进你的代码。看看*图4.18*：
- en: '![Figure 4.18: Hover your mouse over any underlined code to see why it is underlined,
    along with possible fixes](img/B19644_04_18.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![图4.18：将鼠标悬停在任何下划线代码上，查看为什么它被下划线标记，以及可能的修复方法](img/B19644_04_18.jpg)'
- en: 'Figure 4.18: Hover your mouse over any underlined code to see why it is underlined,
    along with possible fixes'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.18：将鼠标悬停在任何下划线代码上，查看为什么它被下划线标记，以及可能的修复方法
- en: In the case of the code shown, the problem is I invoked the `sqrt()` method,
    which finds the square root. The method is a static method in the `math` class.
    The problem is I failed to import that class. The description of the problem appears
    just below the underline when I hover. Below the problem description is the most
    likely fix. Pressing *Alt* + *Shift* + *Enter* will automatically fix the problem
    by adding `import math` to the top of the file.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在显示的代码的情况下，问题是调用了`sqrt()`方法，该方法找到平方根。该方法是在`math`类中的静态方法。问题是未能导入该类。当我悬停在问题描述下方时，问题描述就会出现。在问题描述下方是最可能的修复方案。按下*Alt*
    + *Shift* + *Enter*将自动修复问题，通过在文件顶部添加`import math`。
- en: If you’d like to try this out, you can use the `inspection` project in the `chapter-04`
    folder of the sample code we cloned in [*Chapter 2*](B19644_02.xhtml#_idTextAnchor028),
    *Installation* *and Configuration*.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要尝试这个，你可以在我们克隆的示例代码的`chapter-04`文件夹中的`inspection`项目中尝试，该代码在[*第2章*](B19644_02.xhtml#_idTextAnchor028)，*安装*
    *和配置*。
- en: Note this might not be the only possible fix. In *Figure 4**.18*, we can also
    see **More actions…** prompting us to either click the link or press *Alt* + *Enter*
    to see more possibilities.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这可能不是唯一的解决方案。在*图4.18*中，我们还可以看到**更多操作…**提示我们点击链接或按*Alt* + *Enter*来查看更多可能性。
- en: 'Truly astute readers might have noticed the lightbulb. This is an alternate
    vector to the same feature. Check out *Figure 4**.19* to see the lightbulb in
    action:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 真正敏锐的读者可能会注意到灯泡。这是同一功能的另一个向量。查看*图4.19*以查看灯泡的实际操作：
- en: '![Figure 4.19: The lightbulb is another way to get the intentions](img/B19644_04_19.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![图4.19：灯泡是获取意图的另一种方式](img/B19644_04_19.jpg)'
- en: 'Figure 4.19: The lightbulb is another way to get the intentions'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.19：灯泡是获取意图的另一种方式
- en: Clicking the lightbulb shows a list of possible intentions. This time, we see
    a preview. The intention is going to add `import math` at line 1 of the file.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 点击灯泡会显示可能意图的列表。这次，我们看到一个预览。意图是在文件的第1行添加`import math`。
- en: The lightbulbs can be tricky sometimes because they have a tendency to disappear
    if you move off the line where they originally appeared. If you’d like to use
    the lightbulb, just click anywhere within the underline and wait for a tick. It
    will appear at the beginning of the line where the problem lies.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候灯泡可能会有些棘手，因为如果你离开它们最初出现的那条线，它们有消失的倾向。如果你想使用灯泡，只需点击下划线内的任何位置并等待一个滴答声。它将出现在问题所在行的开头。
- en: In the case we’re exploring, the problem is a legitimate error. The program
    won’t run until we fix the problem. You can’t see it in the previous two figures,
    but the lightbulb is red. You’ll also see yellow lightbulbs for less egregious
    problems.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们正在探讨的情况下，问题是一个合法的错误。程序在问题修复之前无法运行。你可能在前面两个图中没有看到，但灯泡是红色的。你还会看到黄色灯泡表示不那么严重的错误。
- en: Now if you’re like me, you want to see a clean file with a green check and no
    underlines. Let me tell you, that will probably never happen. PyCharm will almost
    always find something to change. Sometimes the suggested changes are not very
    useful. You might heed a suggestion that changes your code in some minor way.
    Right after you do this, the lightbulb comes back, and PyCharm offers to change
    the code back to the way it was. Yellow light bulbs are not your enemy unless
    they have an exclamation point in them.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你如果像我一样，想看到带有绿色勾选和没有下划线的干净文件。让我告诉你，那可能永远不会发生。PyCharm几乎总是会发现一些需要更改的地方。有时建议的更改并不很有用。你可能会听从一个建议，以某种小的方式更改你的代码。在你这样做之后，灯泡会回来，PyCharm会提供将代码改回原来的方式。除非它们里面有感叹号，否则黄色灯泡不是你的敌人。
- en: Refactoring
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重构
- en: Most good IDEs, and development-focused text editors, for that matter, feature
    some level of tooling for refactoring. Refactoring is a very important practice
    that is often neglected. In my book, which is available on Amazon (or wherever
    the finest technical books are sold), *Real-World Implementation of C# Design
    Patterns*, I cover some of the entropic forces that lead a well-intended coding
    project to ruin. Your code starts off pristine, and the whole team commits to
    maintaining zero technical debt. But it never lasts. Factors such as time pressure,
    developer skill level, inevitable change, visibility, and complexity cause a process
    of devolution. Your code goes from a well-constructed, perfectly architected masterpiece
    to a big ball of mud on a plate of spaghetti!
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数优秀的集成开发环境（IDE）以及专注于开发的文本编辑器，在这方面都有一定程度的重构工具。重构是一项非常重要的实践，但常常被忽视。在我的书中，这本书可在亚马逊（或任何销售最优秀技术书籍的地方）购买，《C#
    设计模式的实际应用》，我讨论了一些导致本意良好的编码项目走向失败的无序力。你的代码一开始是纯洁的，整个团队都承诺保持零技术债务。但这种情况从未持续过。时间压力、开发者技能水平、不可避免的变化、可见性和复杂性等因素导致了一个退化的过程。你的代码从精心构建、完美架构的杰作变成了盘子上的一团泥巴！
- en: I realize that I am pointing to a C# book here, but if you have a Packt subscription,
    I urge you to read the first two chapters of the book. The chapters discuss the
    common problems and preventions of work degradation. One thing you can do is to
    be vigilant and never dismiss the value of refactoring your code as a regular
    part of the development practice.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道我在这里指向的是一本C#的书，但如果你有Packt订阅，我强烈建议你阅读这本书的前两章。这两章讨论了工作退化的常见问题和预防措施。你可以做的一件事是保持警惕，永远不要忽视将代码重构作为开发实践常规部分的价值。
- en: What is refactoring?
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是重构？
- en: Simply put, refactoring is improving code without changing its functionality.
    If you have unit tests (you do, RIGHT!?!??!), they should pass before and after
    refactoring without any changes to the tests themselves. You are looking for ways
    to optimize your code in terms of readability and performance. Maybe you skipped
    some code niceties, such as adding **docstrings**, which we’ll cover later in
    this chapter. Maybe you didn’t add type hints to your method signatures. Perhaps
    there are opportunities to leverage design patterns or SOLID principles to make
    your code more flexible.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，重构是在不改变其功能的情况下改进代码。如果你有单元测试（你有，对吧！？），它们应该在重构前后通过，而无需对测试本身进行任何更改。你正在寻找优化代码的可读性和性能的方法。也许你忽略了某些代码优雅之处，比如添加**文档字符串**，我们将在本章后面讨论。也许你没有给你的方法签名添加类型提示。也许有机会利用设计模式或SOLID原则使你的代码更加灵活。
- en: The idea behind refactoring is that you are taking a second look at your code,
    preferably after a little time has passed. Have you ever looked at code you wrote
    a month or even a year ago and wondered what possessed you to type that horrible
    function body? Why in the world did you _________? (Fill in the blank with something
    silly you did.) You can’t believe that was you. You are smarter than that. Consider
    having regular peer reviews of your code. This can happen at any time during the
    writing process. Also, having someone less invested in your work will be able
    to spot unrealized opportunities for improvement. Almost always, this will involve
    refactoring. Flip things around. How many times have you been handed some code
    written by another developer? Maybe the person that has left the company? You
    look it over and conclude that whoever wrote the code was clearly a recent escapee
    from the local asylum. It must be totally rewritten. This is you refactoring someone
    else’s code.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 重构背后的理念是，你在代码上再次审视，最好是经过一段时间之后。你有没有曾经看过自己一个月或甚至一年前写的代码，想知道是什么让你编写了那样糟糕的函数体？你究竟为什么要这样做？（在空白处填入你做过的愚蠢事情。）你无法相信那会是你。你比那聪明。考虑定期进行代码同行评审。这可以在写作过程的任何时间进行。此外，有一个人对你的工作投入较少，将能够发现未实现改进的机会。几乎总是，这会涉及到重构。反过来想。你有多少次接过其他开发者编写的代码？可能是离开公司的那个人？你检查了一下，得出结论，编写代码的人显然是最近从当地的精神病院逃出来的。这必须完全重写。这就是你重构别人的代码。
- en: Refactoring tools in PyCharm
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PyCharm中的重构工具
- en: PyCharm has a set of menu options dedicated to refactoring. There are a few
    that are not explicitly called out as refactoring tools.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: PyCharm有一套专门用于重构的菜单选项。其中有一些并不是明确标明为重构工具。
- en: Cleaning up your code
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 清理你的代码
- en: PyCharm has a very thorough **Code Cleanup** tool. This tool, in effect, runs
    the same inspections you have seen so far, but it does them in bulk. You can have
    PyCharm try to fix all the problems as well. This feature is useful when you import
    a project created outside of PyCharm, say with a tool that doesn’t offer the kind
    of assistance you have seen in PyCharm.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: PyCharm有一个非常全面的**代码清理**工具。实际上，这个工具运行了您迄今为止看到的相同检查，但它是以批量方式进行的。您可以让PyCharm尝试修复所有问题。当您导入在PyCharm之外创建的项目时，这个功能非常有用，比如使用不提供PyCharm中看到的帮助的工具。
- en: 'You can clean up an open file or all files in your project. To be honest, I
    don’t recommend you do this at the project level since you can’t really predict
    what the engine will do to a large set of files you haven’t even opened. *Figure
    4**.20* shows the menu location for **Code Cleanup****…**:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以清理一个打开的文件或您项目中的所有文件。说实话，我不建议您在项目级别上这样做，因为您真的无法预测引擎会对您尚未打开的大量文件做什么。*图4.20*显示了**代码清理**菜单的位置：
- en: '![Figure 4.20: The Code Cleanup tools can be found in the Code menu](img/B19644_04_20.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![图4.20：代码清理工具可以在代码菜单中找到](img/B19644_04_20.jpg)'
- en: 'Figure 4.20: The Code Cleanup tools can be found in the Code menu'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.20：代码清理工具可以在代码菜单中找到
- en: 'Once you click the menu option, you’ll see a dialog asking about the scope
    of the clean-up, as seen in *Figure 4**.21*:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您点击菜单选项，您将看到一个对话框询问清理的范围，如图*图4.21*所示：
- en: '![Figure 4.21: Specify the scope of the code cleanup](img/B19644_04_21.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![图4.21：指定代码清理的范围](img/B19644_04_21.jpg)'
- en: 'Figure 4.21: Specify the scope of the code cleanup'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.21：指定代码清理的范围
- en: You can clean up the whole project, uncommitted files, the current file (which
    for me is `main.py` from the `inspection` project in the `chapter-04` folder of
    the sample source code), or a custom scope. My recommendation is not to try to
    boil the ocean. Do not do a whole project cleanup on a massive project. It is
    usually smarter to let PyCharm work its magic on small batches of files. The **Uncommitted
    files** option is a nice step you can take before you commit changes to your version
    control system.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以清理整个项目、未提交的文件、当前文件（对我而言是来自`chapter-04`文件夹中`inspection`项目的`main.py`文件），或者自定义范围。我的建议是不要试图一口吃成胖子。不要在大型项目上做整个项目的清理。通常让PyCharm在小批次的文件上施展魔法更明智。**未提交的文件**选项是在您将更改提交到版本控制系统之前可以采取的一个很好的步骤。
- en: Renaming
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重命名
- en: 'Donald Knuth, one of the most respected software developers of all time, wrote
    in his book *The Art of Computer Programming*, that there are two things in programming
    that are hard: naming things (e.g., variables, functions, classes, files, and
    so on) well, and invalidating your caches. How true this is! It is an art form
    to write meaningful variable definitions that are self-documenting while making
    your intentions clear. It usually takes several tries to get it right. PyCharm
    has a tool that easily allows a name change. You can right-click on anything you’ve
    named and select **Rename**. Type the new name of the thing that is to be renamed.
    PyCharm will affect the change everywhere the named thing is referenced. It will
    even find and change references in comments and docstrings.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 世界上最受尊敬的软件开发者之一唐纳德·克努斯在他的书《计算机程序设计艺术》中写道，编程中有两件事很难：给事物命名（例如，变量、函数、类、文件等）以及使缓存失效。这有多么真实！编写有意义的变量定义，使其自文档化同时使意图明确，是一种艺术形式。通常需要多次尝试才能做到正确。PyCharm有一个工具可以轻松地允许更改名称。您可以对任何已命名的对象右键单击并选择**重命名**。输入要重命名的对象的新的名称。PyCharm将在引用命名对象的所有地方进行更改。它甚至会在注释和文档字符串中找到并更改引用。
- en: If the scope of the change is small, for example, you are renaming something
    scoped to a local function, the rename operation happens immediately. If you are
    attempting a rename with a broader scope, such as one that entails multiple files,
    PyCharm will preview the change for you by showing you all the files that will
    be affected. You can inspect all the changes before they are made to make sure
    the changes are appropriate. After you are satisfied, you can apply those changes.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果更改的范围很小，例如，您正在重命名一个局部函数范围内的某个事物，重命名操作会立即发生。如果您尝试进行范围更广的重命名，例如涉及多个文件的重命名，PyCharm会通过显示所有受影响的文件来为您预览更改。您可以在更改实际应用之前检查所有更改，以确保更改是适当的。在您满意后，您可以应用这些更改。
- en: There is no rename menu option for files!
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 文件没有重命名菜单选项！
- en: This is confusing if you come from another tool such as Visual Studio Code,
    where renaming files is a simple matter of picking the file from the explorer
    view and clicking twice or pressing *F2*. You’ll hunt for the rename option for
    files, and you will not find one. That’s because it is in the **Refactor** menu.
    PyCharm considers renaming a file a refactor. Unlike other tools, PyCharm will
    make sure renaming the file doesn’t affect your code.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你来自像Visual Studio Code这样的其他工具，这可能会让你感到困惑，在Visual Studio Code中，重命名文件只是从资源管理器视图中选择文件并点击两次或按*F2*这么简单的事情。你会在文件中寻找重命名选项，但你不会找到。那是因为它位于**重构**菜单中。PyCharm认为重命名文件是一种重构。与其他工具不同，PyCharm会确保重命名文件不会影响你的代码。
- en: Inlining variables
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 内联变量
- en: 'PyCharm gives you the ability to automatically inline your variables. In fact,
    this is among the more common suggestions PyCharm provides. Consider this code:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: PyCharm让你能够自动内联你的变量。实际上，这是PyCharm提供的更常见建议之一。考虑以下代码：
- en: '[PRE7]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The sum variable isn’t really needed. If you inline the variable, the code
    becomes the following:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`sum`变量实际上并不需要。如果你内联变量，代码将变成以下这样：'
- en: '[PRE8]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We’ve removed the line that declared the `sum` variable and assigned it the
    value of `num1 +` `num2`.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经移除了声明`sum`变量并将其赋值为`num1 + num2`的行。
- en: Extracting methods
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提取方法
- en: Earlier, I mentioned a concept called DRY, or Don’t Repeat Yourself. Yes, I
    realize that by mentioning it again, I am breaking the rule. I am doing so with
    a purpose. Remember, the IDE points out errors and then provides advice and tools
    to fix the problem. I’d like to present a very useful feature. PyCharm gives you
    a tool to easily extract code into a separate function. You will want to do this
    under a couple of circumstances. First, if you find yourself copying and pasting
    code within your project. You probably need to make that code a function and then
    call it from the places where you are pasting the copied code. Secondly, when
    you find a function that breaks the single responsibility principle. If you’ve
    never heard of this, you can guess what it means. A well-written program should
    contain functions that do only one thing. Written code that contains functions
    or methods that perform multiple responsibilities could be broken into separate
    functions.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '之前，我提到了一个称为DRY（不要重复自己）的概念。是的，我意识到再次提到它是在打破规则。我这样做是有目的的。记住，IDE会指出错误，然后提供建议和工具来解决问题。我想展示一个非常实用的功能。PyCharm为你提供了一个工具，可以轻松地将代码提取到单独的函数中。你会在几种情况下想要这样做。首先，如果你发现自己正在项目中复制和粘贴代码。你可能需要将那段代码做成一个函数，然后从你粘贴复制的代码的地方调用它。其次，当你找到一个违反单一职责原则的函数时。如果你从未听说过这个，你可以猜到它的意思。一个编写良好的程序应该只包含执行单一任务的函数。包含执行多个职责的函数或方法的代码可能是错误的，应该被拆分成单独的函数。 '
- en: 'Take a look at an easy example of such an opportunity. Open the `chapter-04/not_dry.py`
    file in the sample code. The code within is truly egregious! Sensitive viewers
    might want to sit down before opening the file. Behold! Something everybody has
    done at least once before they learned it was a bad idea:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 看一个这样的机会的简单例子。在示例代码中打开`chapter-04/not_dry.py`文件。其中的代码确实很糟糕！敏感的观众在打开文件之前可能需要坐下来。看吧！每个人在学习到这是坏主意之前至少做过一次的事情：
- en: '[PRE9]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'OK, so far, it is fine. We’ve got a dictionary of people who took a computer
    science class along with their grades. By the way, those aren’t random names.
    After you finish this chapter, see whether you can figure out who these illustrious
    individuals might be. I apologize to some of the illustrious individuals for the
    numbers themselves. They are meant to be more or less random keys except for Mr.
    van Rossum, who would obviously have gotten a perfect grade. I’m sure they all
    did very well in real life. Following that, we have another set of class grades:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，到目前为止，一切正常。我们已经得到了一个包含参加计算机科学课程的人及其成绩的字典。顺便说一句，那些名字并不是随机的。在你完成这一章后，看看你是否能猜出这些杰出人物是谁。我为这些杰出人物对数字本身表示歉意。它们原本应该是大致随机的键，除了范·罗素先生，显然他会得到满分。我相信他们在现实生活中都做得很好。接下来，我们还有另一组课程成绩：
- en: '[PRE10]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'While it is a different subject and a different group of people, it’s the same
    idea. Now suppose we need to figure out the class average for each class. I can
    make a function for computing the average in the computer science class:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是不同的主题和不同的人群，但理念是相同的。现在假设我们需要计算每个班级的平均分。我可以为计算机科学课程编写一个计算平均分的函数：
- en: '[PRE11]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Our method signature gives lots of good hints. We have a descriptive function
    name. The function takes one parameter, and our hint tells us we’re expecting
    a dictionary. The function is expected to return a float.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的方法签名提供了很多有用的提示。我们有一个描述性的函数名。该函数接受一个参数，我们的提示告诉我们我们期望一个字典。该函数预期返回一个浮点数。
- en: 'The function body creates a variable called `raw_total` and sets it to `0`.
    Next, we loop through the values of `dict` and, on each iteration, add `value`
    to `raw_total`. Once we have the total, we divide it by the number of keys (`len`)
    in `dict`, and voila! We have the class average. Towards the bottom of the file,
    we can see where this function is called:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 函数体创建了一个名为`raw_total`的变量并将其设置为`0`。接下来，我们遍历`dict`的值，并在每次迭代中，将`value`添加到`raw_total`中。一旦我们有了总数，我们就将其除以`dict`中的键的数量（`len`），
    voila！我们就有了班级平均分。在文件的底部，我们可以看到这个函数被调用的地方：
- en: '[PRE12]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Wonderful! We have a call to our `computer_science_average` function along
    with a highly judgmental (and probably inaccurate since it might have been your
    favorite class) variable assignment. So, what’s wrong with any of this? Nothing.
    It’s what comes next that presents a problem and an opportunity to extract a method.
    The next function computes a different class: advanced theoretical and applied
    recess. This is a field that I personally pioneered, and within this field, I
    have no rival. Unfortunately, since I spent more time on the playground perfecting
    my art and less time in computer science class, I have all but duplicated the
    function we wrote earlier:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！我们调用了`computer_science_average`函数，并附带了高度主观（并且可能不准确，因为那可能曾是你的最爱课程）的变量赋值。那么，这有什么问题吗？没有。问题出在接下来，这提供了一个提取方法的机会。下一个函数计算的是不同的类别：高级理论和应用退行。这是一个我本人开创的领域，在这个领域内，我没有对手。不幸的是，由于我在游乐场花更多的时间来完善我的技艺，而在计算机科学课程上花的时间较少，我几乎复制了我们之前写的函数：
- en: '[PRE13]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'It’s the same function with a different name! We need to consolidate! To do
    this, you need to highlight everything between the colon that ends the method
    signature and the `return` statement. Refer to *Figure 4**.22*. Don’t include
    the `return` statement, or PyCharm won’t generate a `return` statement in your
    extracted function:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对同一个函数的不同命名！我们需要合并！为此，你需要突出显示方法签名结束的冒号和`return`语句之间的所有内容。参见图4.22。不要包括`return`语句，否则PyCharm不会在你的提取函数中生成`return`语句：
- en: '![Figure 4.22: Select the code to extract into a new function or method](img/B19644_04_22.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![图4.22：选择代码以提取到新的函数或方法](img/B19644_04_22.jpg)'
- en: 'Figure 4.22: Select the code to extract into a new function or method'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.22：选择代码以提取到新的函数或方法
- en: 'Next, right-click the selected code and click **Refactor** | **Extract Method**,
    as shown in *Figure 4**.23*:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，右键单击所选代码，然后点击**重构**|**提取方法**，如*图4.23*所示：
- en: '![Figure 4.23: Right-click the selected code, then click Refactor, then Extract
    Method](img/B19644_04_23.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![图4.23：右键单击所选代码，然后点击重构，然后提取方法](img/B19644_04_23.jpg)'
- en: 'Figure 4.23: Right-click the selected code, then click Refactor, then Extract
    Method'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.23：右键单击所选代码，然后点击重构，然后提取方法
- en: 'This brings up a user interface that allows you to define the new method, as
    seen in *Figure 4**.24*:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这会弹出一个用户界面，允许你定义新的方法，如*图4.24*所示：
- en: "![Figure 4.24: The \uFEFFExtract \uFEFFMethod dialog in PyCharm](img/B19644_04_24.jpg)"
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![图4.24：PyCharm中的提取方法对话框](img/B19644_04_24.jpg)'
- en: 'Figure 4.24: The Extract Method dialog in PyCharm'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.24：PyCharm中的提取方法对话框
- en: 'Set the name of the extract method. I set mine to `compute_average`. PyCharm
    has filled in the rest automatically. Click **OK**, and your code will change.
    *Figure 4**.25* shows the result of my refactoring:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 设置提取方法的名称。我将其设置为`compute_average`。PyCharm已自动填写其余部分。点击**确定**，你的代码将发生变化。*图4.25*显示了重构的结果：
- en: '![Figure 4.25: The result of the refactoring. Note the compute_average function
    was generated automatically from the selected code](img/B19644_04_25.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![图4.25：重构的结果。注意compute_average函数是从所选代码自动生成的](img/B19644_04_25.jpg)'
- en: 'Figure 4.25: The result of the refactoring. Note the compute_average function
    was generated automatically from the selected code'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.25：重构的结果。注意compute_average函数是从所选代码自动生成的
- en: 'Let’s look at the resulting code PyCharm generated from the refactor. First,
    `computer_science_average` has changed to this:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看PyCharm从重构中生成的代码。首先，`computer_science_average`已更改为以下内容：
- en: '[PRE14]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This function is now calling the extracted function. The extracted function
    looks like this:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数现在正在调用提取的函数。提取的函数看起来像这样：
- en: '[PRE15]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This is the code we selected for extraction. PyCharm generated the function
    for me. I must tell you, at this point, that I’m usually wary of generated code.
    It is rarely perfect. Here, I would have preferred a type hint on the `grades`
    parameter and a hint on the return type. Those are minor issues, though, and the
    result saved me some typing.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们要提取的代码。PyCharm 为我生成了函数。我必须告诉你，在这个阶段，我通常对生成的代码持谨慎态度。它很少完美。在这里，我更希望对 `grades`
    参数有一个类型提示，以及对返回类型有一个提示。尽管这些都是小问题，但结果节省了我一些打字。
- en: 'One lingering question might remain. Why didn’t PyCharm detect and flag the
    duplicated code? The quick answer: our sample code is too short. If I were to
    add a few more lines to the duplicated functions, it would appear as a duplicate.
    Let’s try it out. Modify the code in both functions so it looks like this:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 可能还有一个悬而未决的问题。为什么 PyCharm 没有检测并标记重复的代码？简短的回答是：我们的示例代码太短。如果我在重复的函数中添加几行代码，它就会被视为重复。让我们试试。修改两个函数中的代码，使其看起来像这样：
- en: '[PRE16]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'All I did was add a bunch of fake variable declarations. They don’t do anything
    important except make the duplicate code fragment longer. By default, PyCharm
    only looks for duplicated fragments that are 10 lines or longer. Short duplications
    don’t make the cut. I bring this up because the magic of method extraction handles
    duplicates automatically. Let’s do the same exercise. First, look at PyCharm with
    the changes in place. You should see some indicators that we have problems, as
    shown in *Figure 4**.26*:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我所做的只是添加了一堆虚假的变量声明。它们并不做任何重要的事情，除了使重复的代码片段更长。默认情况下，PyCharm 只查找长度为 10 行或更长的重复片段。短的重复不会通过筛选。我提这一点是因为方法提取的魔力可以自动处理重复。让我们做同样的练习。首先，查看更改后的
    PyCharm。你应该会看到一些指示我们有问题的指标，如 *图 4.26* 所示：
- en: '![Figure 4.26: Now that our duplicated code is longer, it gets detected and
    flagged](img/B19644_04_26.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.26：现在我们的重复代码更长，因此被检测并标记](img/B19644_04_26.jpg)'
- en: 'Figure 4.26: Now that our duplicated code is longer, it gets detected and flagged'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.26：现在我们的重复代码更长，因此被检测并标记
- en: 'We can see that PyCharm has noticed our duplicated code. Highlight the code
    for extraction, as shown in *Figure 4**.27*:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到 PyCharm 已经注意到了我们的重复代码。按照 *图 4.27* 所示，突出显示代码以进行提取：
- en: '![Figure 4.27: Mark the code for extraction](img/B19644_04_27.jpg)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.27：标记要提取的代码](img/B19644_04_27.jpg)'
- en: 'Figure 4.27: Mark the code for extraction'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.27：标记要提取的代码
- en: 'Right-click the highlighted code and click **Refactor** | **Extract Method**,
    as shown in *Figure 4**.28*:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 右键单击突出显示的代码，然后点击 **重构** | **提取方法**，如 *图 4.28* 所示：
- en: '![Figure 4.28: Extract the method by right-clicking, clicking Refactor, then
    Extract Method](img/B19644_04_28.jpg)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.28：通过右键单击，点击重构，然后提取方法提取方法](img/B19644_04_28.jpg)'
- en: 'Figure 4.28: Extract the method by right-clicking, clicking Refactor, then
    Extract Method'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.28：通过右键单击，点击重构，然后提取方法
- en: 'Name the extracted function `compute_average`, as shown in *Figure 4**.29*:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 按照图 4.29 所示，命名提取的函数 `compute_average`：
- en: '![Figure 4.29: Name the extracted function compute_average](img/B19644_04_29.jpg)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.29：命名提取的函数 compute_average](img/B19644_04_29.jpg)'
- en: 'Figure 4.29: Name the extracted function compute_average'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.29：命名提取的函数 compute_average
- en: 'Click **OK**. This time things are a little different. You’ll find that PyCharm
    creates the function extraction as before, but this time you are prompted to replace
    the duplicate code as well, as shown in *Figure 4**.30*:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 点击 **确定**。这次情况略有不同。你会发现 PyCharm 仍然像以前一样创建函数提取，但这次你被提示替换重复的代码，如 *图 4.30* 所示：
- en: '![Figure 4.30: PyCharm asks whether you’d like to replace the duplicated fragment
    with a reference to the extracted function](img/B19644_04_30.jpg)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.30：PyCharm 询问是否要替换重复的片段为提取的函数的引用](img/B19644_04_30.jpg)'
- en: 'Figure 4.30: PyCharm asks whether you’d like to replace the duplicated fragment
    with a reference to the extracted function'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.30：PyCharm 询问是否要替换重复的片段为提取的函数的引用
- en: Exporting a function to another file
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将函数导出到另一个文件
- en: How often have you written a nifty utility function in the wrong place? Maybe
    you put it in a module or class that is designed to do something specific, but
    your utility function turns out to be generally used in lots of places. The single
    responsibility principle that applies to functions also applies to modules and
    classes. Having a function that connects to a database is a great example. Let’s
    say you just got a job working for Billy Blanca’s Candy Factory. They need you
    to write some scripts that will import lists of candies they make from several
    different text formats and store them in a database. The first requirement comes
    in, and you need to read from a plain text file and write to an SQLite database.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 你有多少次在错误的地方编写了一个实用的函数？也许你把它放在一个设计用来做特定事情的模块或类中，但你的实用函数最终在许多地方都被广泛使用。适用于函数的单一职责原则也适用于模块和类。有一个连接数据库的函数是一个很好的例子。假设你刚刚得到一份在比利·布兰卡糖果厂工作的工作。他们需要你编写一些脚本，从几种不同的文本格式中导入他们制作的糖果列表，并将它们存储在数据库中。第一个需求来了，你需要从纯文本文件中读取并写入
    SQLite 数据库。
- en: 'Open the project in `chapter-04/move_function/read_input_file_a.py`. Let’s
    review the contents:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `chapter-04/move_function/read_input_file_a.py` 中打开项目。让我们回顾一下内容：
- en: '[PRE17]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'These first two lines import the `sqlite3` library from the standard library.
    If you haven’t worked with `sqlite3` before, here’s all you need to know for now:
    it is a file-based relational database. By this, we mean you don’t need to install
    a server as you would with databases such as Postgres or MariaDB. This makes it
    a good database to use for teaching and prototype work. We’ll cover databases
    in detail in [*Chapter 11*](B19644_11.xhtml#_idTextAnchor266), *Understanding
    Database Management in PyCharm*. Let’s continue with the definition for the function
    that will open the file, read the contents, and insert them into the database:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这前两行是从标准库中导入 `sqlite3` 库。如果你之前没有使用过 `sqlite3`，那么现在你需要知道的是：它是一个基于文件的数据库。通过这种方式，我们指的是你不需要像
    Postgres 或 MariaDB 这样的数据库那样安装服务器。这使得它成为教学和原型工作的好数据库。我们将在 [*第 11 章*](B19644_11.xhtml#_idTextAnchor266)
    中详细讲解数据库，*在 PyCharm 中理解数据库管理*。让我们继续定义将打开文件、读取内容并将其插入数据库的函数：
- en: '[PRE18]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We’ve opened the file. For each line in the file, we are reading it in as text
    and removing the newline character. This is necessary for the database insert
    to work properly. Once the string is cleaned, we are calling a function that writes
    to the database:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经打开了文件。对于文件中的每一行，我们将其作为文本读取，并删除换行符。这对于数据库插入正常工作是必要的。一旦字符串被清理，我们就调用一个写入数据库的函数：
- en: '[PRE19]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'I’ve included the database file in the code repository, so there is no code
    needed to create the database. This function just opens the database, then creates
    a cursor. A cursor is used to execute commands against the database using SQL.
    Even if you don’t know SQL, I’m sure you can figure out what is happening. There
    is a table in the database called `candy`. The table has only one field: `name`.
    We’re keeping it very simple here. I have neglected to create a primary key because,
    for now, the database doesn’t really matter. We should be focused on the function
    more than how it works.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经将数据库文件包含在代码仓库中，因此不需要编写代码来创建数据库。这个函数只是打开数据库，然后创建一个游标。游标用于使用 SQL 对数据库执行命令。即使你不知道
    SQL，我也相信你能弄清楚发生了什么。数据库中有一个名为 `candy` 的表。该表只有一个字段：`name`。我们在这里保持非常简单。我忘记创建主键了，因为现在数据库并不重要。我们应该更多地关注函数本身，而不是它的工作方式。
- en: Having generated a SQL statement to insert the `candy` name from the `candy`
    name in the current line of the text file, I execute the SQL statement, which
    will insert one row into the `candy` table.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在生成一个 SQL 语句来从文本文件的当前行中的 `candy` 名称插入 `candy` 表的 `candy` 名称后，我执行了 SQL 语句，这将向
    `candy` 表中插入一行。
- en: 'As a general rule in programming, whatever you create, you should destroy,
    and whatever you open, you should always close. So, I close my cursor and my database
    connection to avoid any resource locks later down the road. Finally, I use the
    common dunder-name convention to run the file for testing:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程中，有一个一般规则：你创建的，你应该销毁；你打开的，你应该始终关闭。因此，我关闭了我的游标和数据库连接，以避免将来出现任何资源锁定。最后，我使用常见的双下划线命名约定来运行文件进行测试：
- en: '[PRE20]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In PyCharm, I can execute this by setting my run configuration to **Current
    File** and clicking the **Run** button. It works! The file is read, and we get
    no errors.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在 PyCharm 中，我可以通过将我的运行配置设置为 **Current File** 并点击 **Run** 按钮来执行此操作。它成功了！文件被读取，我们没有出现错误。
- en: Dunderscores
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 下划线
- en: A `__init__`? You could say, “*underscore underscore init underscore underscore.*”
    But that is cumbersome. If you just say, “init” you’re not being specific enough
    since there could be another function or method called `init` without the underscores.
    So, you say “*dunderscore init*” or even just “*dunder init*”, and everybody knows
    what you’re talking about.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 `__init__`？你可以这么说，“*下划线下划线 init 下划线下划线*”。但这很麻烦。如果你只说“init”，你不够具体，因为可能还有另一个没有下划线的名为
    `init` 的函数或方法。所以，你说“*下划线 init*”或者甚至只说“*下划线 init*”，大家就知道你在说什么了。
- en: 'The next day we come to work and learn of a new requirement. We need another
    script that reads data from a **JavaScript Object Notation** (**JSON**) file.
    The JSON file just contains an array like this:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 第二天我们来到工作地点，得知有一个新的需求。我们需要另一个脚本，用于从 **JavaScript 对象表示法**（**JSON**）文件中读取数据。这个
    JSON 文件只包含一个数组，如下所示：
- en: '[PRE21]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'It’s still just a list of candy, but we need to process it differently. Open
    up `chapter-04/move_function/input/read_input_file_b.py`. You’ll find its code
    is similar to the other code:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 它仍然只是一个糖果列表，但我们需要以不同的方式处理它。打开 `chapter-04/move_function/input/read_input_file_b.py`。你会发现它的代码与其他代码类似：
- en: '[PRE22]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We know we need to work with JSON, so I’ve imported the `json` package. I also
    know I’ll need to write to the same database as before. I know code reuse is a
    good thing, so I import the function from the other script. Then I set to creating
    a version of the code that reads JSON files:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道我们需要处理 JSON，所以我导入了 `json` 包。我也知道我需要写入之前相同的数据库。我知道代码重用是好事，所以我从另一个脚本中导入了函数。然后我开始创建一个读取
    JSON 文件的代码版本：
- en: '[PRE23]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `json.load` method takes the raw text and converts it into a regular Python
    3 `dict`. As you can see from the preceding file listing, `dict` will have one
    thing in it: an array of candy with the key of data. So, I grab that and put it
    in the `candies` variable, then I loop over that array and call the `write_to_database`
    function for each `candy` in the array. Wow! It’s not even lunchtime! Maybe I
    can walk around the factory? I hear they’ve got some little girl testing some
    gum that turns people into a raspberry.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '`json.load` 方法将原始文本转换为常规 Python 3 `dict`。正如您从前面的文件列表中可以看到，`dict` 中将包含一个东西：一个以
    `data` 为键的糖果数组。所以我抓取那个并将其放入 `candies` 变量中，然后我遍历这个数组，为数组中的每个 `candy` 调用 `write_to_database`
    函数。哇！甚至还没到午饭时间！也许我可以四处走走？我听说工厂里有个小女孩在测试一种能让人变成树莓的口香糖。'
- en: Not so fast! This code could be improved. Our input scripts are really designed
    to read data from text. It doesn’t make sense to have one of the scripts contain
    the database function because it simply doesn’t belong inside the script that
    reads text input files. It really should be in its own package. Let’s extract
    it to its own file.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 别急！这段代码可以改进。我们的输入脚本实际上是为了读取文本数据设计的。让其中一个脚本包含数据库函数没有意义，因为它根本不属于读取文本输入文件的脚本。它真的应该在自己的包中。让我们将其提取到自己的文件中。
- en: 'Open `chapter-04/move_function/input/read_input_file_a.py`. Right-click on
    the name of the function we’re going to move, as shown in *Figure 4**.31*:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `chapter-04/move_function/input/read_input_file_a.py`。右键点击我们要移动的函数名，如图 *图
    4**.31* 所示：
- en: '![Figure 4.31: Right-click the function you want to move, then click Refactor,
    then Move](img/B19644_04_31.jpg)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.31：右键点击要移动的函数，然后点击重构，然后移动](img/B19644_04_31.jpg)'
- en: 'Figure 4.31: Right-click the function you want to move, then click Refactor,
    then Move'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.31：右键点击要移动的函数，然后点击重构，然后移动
- en: In the context menu, click `database_helper.py` filename. Click **OK**. Watch
    carefully because a lot is about to happen.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在上下文菜单中，点击 `database_helper.py` 文件名。点击 **确定**。仔细观察，因为接下来会发生很多事情。
- en: 'I get a new file called `database_helper.py`:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我得到了一个新的文件名为 `database_helper.py`：
- en: '[PRE24]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This is the extracted function moved to its own file. PyCharm discovered the
    relevant import statement and moved that here as well. I had a constant for the
    file name called `CANDY_DB`. It didn’t move that, which would be my preference.
    Unfortunately, the current release of PyCharm is not psychic. I’ll just have to
    move that myself. Other than that, this file looks perfect.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 这是移动到其自身文件中的提取函数。PyCharm 发现了相关的导入语句，并将其也移动到这里。我有一个名为 `CANDY_DB` 的文件名常量。它没有移动那个，那将是我更愿意看到的。不幸的是，PyCharm
    当前版本并不是先知。我只好自己移动它。除此之外，这个文件看起来完美无缺。
- en: 'If you check the contents of `input_file_a.py`, you’ll see it has changed.
    The first line in the file now reads as follows:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你检查 `input_file_a.py` 的内容，你会看到它已经改变了。文件中的第一行现在如下所示：
- en: '[PRE25]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Likewise, if I open `input_file_b.py`, I’ll find the input there as well. PyCharm
    extracted the function to its own file, then changed every reference in every
    file to point to the new location.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果我打开`input_file_b.py`，我也能在那里找到输入。PyCharm将函数提取到自己的文件中，然后更改了每个文件中指向新位置的每个引用。
- en: Now, I realize I probably should have put this in its own module, and I realize
    you probably would have done this totally differently. Before you go bashing me
    on Twitter, remember this book is about PyCharm, not software architecture. I’m
    trying to keep it simple on purpose.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我意识到我可能应该将其放入自己的模块中，我也意识到你可能会有完全不同的做法。在你准备在Twitter上批评我之前，请记住这本书是关于PyCharm的，而不是软件架构。我故意让它保持简单。
- en: Documentation
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文档
- en: No programmer can doubt the importance of documentation in software engineering
    and development. That said, the process of creating documentation for a program
    can be quite tedious. Furthermore, the end result might not even be effective
    if the person doing the documentation was not following standard practices.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 没有程序员会怀疑文档在软件工程和开发中的重要性。然而，为程序创建文档的过程可能相当繁琐。此外，如果编写文档的人没有遵循标准实践，最终结果可能甚至不会有效。
- en: 'Keeping that in mind, PyCharm looks to streamline this process of documentation
    and make it as straightforward and seamless as possible. Regarding documentation,
    there are two components we will consider for this process: viewing and creating
    documentation. We will learn that PyCharm offers great support for both processes.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，PyCharm致力于简化文档过程，使其尽可能直接和流畅。关于文档，我们将考虑此过程中的两个组成部分：查看和创建文档。我们将了解到PyCharm为这两个过程提供了极大的支持。
- en: Working with docstrings
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与docstrings一起工作
- en: Documentation in Python is known as docstrings, defined as a string literal
    that is placed before any of the statements in a module, function, class, or method
    in Python. You can look at examples of Python docstrings by going into the source
    code of the various built-in Python functions. It is also recommended that any
    custom API you write also has the appropriate docstrings for readability and maintainability.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: Python中的文档被称为docstrings，定义为放置在Python模块、函数、类或方法中的任何语句之前的一个字符串字面量。你可以通过查看各种内置Python函数的源代码来查看Python
    docstrings的示例。还建议任何你编写的自定义API也应具有适当的docstrings，以提高可读性和可维护性。
- en: 'The most noteworthy subtlety in creating docstrings is the practice of using
    triple-double quotes to surround a docstring (which we will see examples of in
    the next subsection). For more details about docstring conventions, take a look
    at this PEP article: [www.python.org/dev/peps/pep-0257/](http://www.python.org/dev/peps/pep-0257/).'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 创建docstrings时最值得注意的微妙之处在于使用三重双引号包围docstring的实践（我们将在下一小节中看到示例）。有关docstring约定的更多详细信息，请参阅这篇PEP文章：[www.python.org/dev/peps/pep-0257/](http://www.python.org/dev/peps/pep-0257/)。
- en: Creating documentation
  id: totrans-291
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建文档
- en: In this subsection, we will look into the process of writing a docstring for
    functions with the help of PyCharm. Let’s get started.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在本小节中，我们将借助PyCharm了解为函数编写docstring的过程。让我们开始吧。
- en: 'Open the project in the sample source code in `chapter-04/documentation`. Open
    the `prime_test.py` file, which looks like this:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`chapter-04/documentation`中的示例源代码项目。打开`prime_test.py`文件，它看起来像这样：
- en: '[PRE26]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The file goes on after that, but the part I need you to focus on is the line
    right below the method signature for the `prime_check` function. There is a `TODO`
    there. If you’re from a Spanish-speaking country, realize this doesn’t mean *all*.
    It refers to a “to-do” item in the code. In this case, the original developer,
    who happens to be Quan Nguyen, the author of the first edition of this book, is
    stating he didn’t write the docstring for this function. He is signaling here
    that he knows that, and he intends to come back and fix this later. Let’s help
    him out with a little PyCharm magic. Before you get too excited, I’m sad to report
    that there isn’t a tool in PyCharm that can read your code and generate the docstring.
    Given how much developers hate writing documentation, I’ll wager there is a fast-and-furious
    effort underway somewhere to have AI do this. But we’re sticking with what PyCharm
    lets us do out of the box.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 文件继续进行，但您需要关注的是`prime_check`函数方法签名下面的那一行。那里有一个`TODO`。如果您来自讲西班牙语的国家，请意识到这并不意味着*所有*。它指的是代码中的“待办”项。在这种情况下，原始开发者，也就是这本书第一版的作者Quan
    Nguyen，表示他没有为这个函数编写文档字符串。他在这里表示他知道这一点，并打算稍后回来修复它。让我们用一点PyCharm的魔法来帮助他。在您过于兴奋之前，我遗憾地报告说，PyCharm中没有工具可以读取您的代码并生成文档字符串。鉴于开发者们讨厌编写文档，我敢打赌，某个地方正在进行一项快速而激烈的努力，让AI来完成这项工作。但我们将坚持PyCharm提供的原装功能。
- en: 'Delete the `# TODO` line and, in its place, type three double quotation marks
    (`"""`) and press *Enter*. You’ll find a generated docstring template appears:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 删除`# TODO`行，并替换为三个双引号(`"""`)，然后按*Enter*键。您会发现一个生成的文档字符串模板出现：
- en: '[PRE27]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This template needs some filling-in in order to become a proper docstring.
    Note the gap beneath the first set of triple quotes. Here, you are expected to
    write about what the function does. Maybe something like this:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 此模板需要一些填充才能成为一个合适的文档字符串。注意第一组三重引号下面的空白。在这里，您需要写关于函数做了什么的内容。可能像这样：
- en: '[PRE28]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Below that is a section for the parameters expected by the function. Here,
    the function takes one argument called `n`. We should write a little bit about
    that parameter, including its type:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面是函数期望的参数部分。在这里，函数接受一个名为`n`的参数。我们应该对此参数写一些内容，包括其类型：
- en: '[PRE29]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The last part is the documentation for the return value:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 最后部分是关于返回值的文档：
- en: '[PRE30]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Consider the generated template of the docstring after we hit *Return/Enter*
    to expand the pair of triple-double quotes. `:param` and `:return:` are part of
    the template and will be included every time we expand a docstring in the same
    way. PyCharm allows us to change this format of docstring templates, making it
    highly customizable and accommodating.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑我们在按下*Return/Enter*键后生成的文档字符串模板。`:param`和`:return:`是模板的一部分，并且每次我们扩展文档字符串时都会包含在内。PyCharm允许我们更改文档字符串模板的格式，使其高度可自定义并适应需求。
- en: Customizing the docstring templates
  id: totrans-305
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自定义文档字符串模板
- en: 'As usual, the docstring templates are highly customizable. You’ll find the
    customization settings by going into the **Settings** window, covered extensively
    in [*Chapter 3*](B19644_03.xhtml#_idTextAnchor052), *Customizing Interpreters
    and Virtual Environments*. Just search on docstring, and you’ll find the areas
    that should capture your attention. The first is shown in *Figure 4**.32*:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 与往常一样，文档字符串模板具有高度的自定义性。您可以通过进入**设置**窗口来找到自定义设置，该窗口在[*第3章*](B19644_03.xhtml#_idTextAnchor052)中进行了详细说明，*自定义解释器和虚拟环境*。只需搜索文档字符串，您就会找到应该引起您注意的区域。第一个如图*图4**.32*所示：
- en: '![Figure 4.32: You can change the general format used to render your docstrings
    to one of several industry-standard formats](img/B19644_04_32.jpg)'
  id: totrans-307
  prefs: []
  type: TYPE_IMG
  zh: '![图4.32：您可以将用于渲染您的文档字符串的通用格式更改为几种行业标准格式](img/B19644_04_32.jpg)'
- en: 'Figure 4.32: You can change the general format used to render your docstrings
    to one of several industry-standard formats'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.32：您可以将用于渲染文档字符串的通用格式更改为几种行业标准格式之一
- en: The other group of settings is part of the color scheme settings, which allow
    you to customize the color used to render the docstring in the PyCharm editor.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 另一组设置是颜色方案设置的一部分，它允许您自定义在PyCharm编辑器中渲染文档字符串所使用的颜色。
- en: Viewing documentation
  id: totrans-310
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查看文档
- en: Imagine a situation where you are using a specific method from one package,
    but you are not entirely sure which parameters the method takes in and/or what
    its return type is. Therefore, you need to go online and look into the documentation
    of the package for that specific method.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下这种情况：您正在使用一个包中的特定方法，但您并不完全确定该方法接受哪些参数以及其返回类型。因此，您需要上网查找该特定方法的文档。
- en: 'As a PyCharm user, you can achieve the same thing with two simple actions:
    `prime_check.py` script from the previous section, move your cursor to the line
    where we use the `math.sqrt()` function in the `prime_check()` function; it should
    be around line 19.'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 作为 PyCharm 用户，您可以通过两个简单的操作实现相同的功能：将上一节中的`prime_check.py`脚本移动到使用`math.sqrt()`函数的`prime_check()`函数所在的行；它应该在大约第
    19 行。
- en: Quick Documentation
  id: totrans-313
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 快速文档
- en: 'Let’s say we’d like to see the documentation of this function. You can simply
    hover your mouse over the function call and wait a moment. Alternatively, you
    can choose **View** | **Quick Documentation** for this or its corresponding keyboard
    shortcut. You will see a pop-up window showing documentation similar to *Figure
    4**.33*:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想查看此函数的文档。您只需将鼠标悬停在函数调用上并等待片刻。或者，您可以选择**视图** | **快速文档**或其对应的快捷键。您将看到一个弹出窗口，显示类似于
    *图 4**.33* 的文档：
- en: '![Figure 4.33: Quick Documentation shows the documentation for the selected
    function](img/B19644_04_33.jpg)'
  id: totrans-315
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.33：快速文档显示所选函数的文档](img/B19644_04_33.jpg)'
- en: 'Figure 4.33: Quick Documentation shows the documentation for the selected function'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.33：快速文档显示所选函数的文档
- en: What’s more, you can also view the documentation for your own functions, methods,
    classes, and so on using the same action. PyCharm’s indexing process finds and
    generates this information when you open the project.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的是，您还可以使用相同的操作查看您自己的函数、方法、类等文档。当您打开项目时，PyCharm 的索引过程会找到并生成这些信息。
- en: 'If you move your cursor to the call to `prime_check()` in the main scope in
    the following line (which should be around line 38):'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您将光标移至以下行中主作用域的`prime_check()`调用处（应该在大约第 38 行）：
- en: '`if prime_check(num):`'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '`if prime_check(num):`'
- en: 'After waiting a moment, you will be able to see the same docstring that we
    entered earlier, as shown in *Figure 4**.34*:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在等待片刻后，您将能够看到之前输入的相同文档字符串，如图 *图 4**.34* 所示：
- en: '![Figure 4.34: Quick Documentation shows the documentation for the selected
    function on line 38](img/B19644_04_34.jpg)'
  id: totrans-321
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.34：快速文档显示第 38 行所选函数的文档](img/B19644_04_34.jpg)'
- en: 'Figure 4.34: Quick Documentation shows the documentation for the selected function
    on line 38'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.34：快速文档显示第 38 行所选函数的文档
- en: Note the format of the docstring in the documentation matches the documentation
    shown in the window.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 注意文档中的文档字符串格式与窗口中显示的文档格式相匹配。
- en: Quick definition
  id: totrans-324
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 快速定义
- en: '**Quick Definition** operates in the same manner as **Quick Documentation**.
    This is useful when the documentation does not provide enough information, and
    you would like to see how a specific function is defined within the source code.
    To do this, place your cursor at a specific API call, and go to **View** | **Quick
    Definition** to evoke the action.'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速定义**与**快速文档**操作方式相同。这在文档提供的信息不足时非常有用，您希望查看特定函数在源代码中的定义方式。为此，将光标置于特定的 API
    调用处，然后转到**视图** | **快速定义**以触发操作。'
- en: 'For example, *Figure 4**.35* shows the quick definition evoked on the call
    to `prime_check()` in our example:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，*图 4**.35* 显示了在示例中对`prime_check()`的调用上触发的快速定义：
- en: '![Figure 4.35: Quick Definition shows the actual code definition for the function,
    which naturally includes the docstring if one is present](img/B19644_04_35.jpg)'
  id: totrans-327
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.35：快速定义显示了函数的实际代码定义，如果存在，则自然包括文档字符串](img/B19644_04_35.jpg)'
- en: 'Figure 4.35: Quick Definition shows the actual code definition for the function,
    which naturally includes the docstring if one is present'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.35：快速定义显示了函数的实际代码定义，如果存在，则自然包括文档字符串
- en: Overall PyCharm provides powerful options when it comes to dynamically viewing
    documentation and definitions within the IDE. Significant time and energy can
    be saved when programmers do not have to switch from their development environment
    to look for documentation.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，PyCharm 在 IDE 中动态查看文档和定义方面提供了强大的选项。当程序员无需从开发环境切换到查找文档时，可以节省大量的时间和精力。
- en: Summary
  id: totrans-330
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Throughout this chapter, we examined PyCharm’s features regarding various aspects
    of programming, including code analysis, code completion, refactoring, and documenting.
    In all of these processes, PyCharm’s intelligent code analyzer provides smart
    and convenient options for editing and fixing problems in your code in real time
    and in a dynamic way.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了PyCharm在编程各个方面（包括代码分析、代码补全、重构和文档化）的功能。在这些所有过程中，PyCharm的智能代码分析器提供了智能和便捷的选项，以便在实时和动态方式中编辑和修复代码中的问题。
- en: Aside from a wide number of options the intelligent code analyzer can support,
    PyCharm also allows users to customize the behavior of the analyzer to their liking.
    This can be achieved in various sections of the general settings. Overall, these
    support features look to improve your productivity as a developer in a way that
    is customized and beneficial to you.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 除了智能代码分析器可以支持的众多选项之外，PyCharm还允许用户根据个人喜好自定义分析器的行为。这可以通过通用设置的各个部分实现。总的来说，这些支持功能旨在以定制和有益于您的方式提高您作为开发者的生产力。
- en: 'In the next chapter, we will focus on a particular aspect of programming: version
    control. We will learn about the specifics of the version control process with
    Git and how PyCharm supports and streamlines this process.'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将专注于编程的一个特定方面：版本控制。我们将学习Git版本控制过程的具体细节以及PyCharm如何支持和简化这一过程。
- en: Questions
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What levels of severity in terms of problems in a Python program are determined
    by PyCharm’s code analyzer?
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Python程序中，PyCharm的代码分析器如何确定问题的严重程度级别？
- en: What are some common problems that PyCharm can detect and help fix via its intelligent
    code analyzer?
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: PyCharm可以通过其智能代码分析器检测并帮助修复哪些常见问题？
- en: How is PyCharm’s code completion support different from others?
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: PyCharm的代码补全支持与其他工具有何不同？
- en: What are some common code completion options that PyCharm offers?
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: PyCharm提供了哪些常见的代码补全选项？
- en: What are the common causes for PyCharm’s code completion support not working?
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么PyCharm的代码补全支持可能无法正常工作？
- en: What are some common refactoring options that PyCharm offers?
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: PyCharm提供了哪些常见的重构选项？
- en: Further reading
  id: totrans-341
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Jolt Awards: *The Best Books For* *Developers* ([informationweek.com](http://informationweek.com))'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jolt Awards：*为开发者推荐的* *最佳书籍* ([informationweek.com](http://informationweek.com))
- en: 'Pylint home page: [https://www.pylint.org/](https://www.pylint.org/)'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pylint主页：[https://www.pylint.org/](https://www.pylint.org/)
- en: 'Murphy’s laws on technology: [https://www.netlingo.com/word/murphys-laws-on-technology.php](https://www.netlingo.com/word/murphys-laws-on-technology.php)'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 技术领域的墨菲定律：[https://www.netlingo.com/word/murphys-laws-on-technology.php](https://www.netlingo.com/word/murphys-laws-on-technology.php)
- en: Be sure to check out the companion website for the book at [https://www.pycharm-book.com](https://www.pycharm-book.com).
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请务必查看本书的配套网站：[https://www.pycharm-book.com](https://www.pycharm-book.com)。
