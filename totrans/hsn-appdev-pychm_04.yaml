- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Editing and Formatting with Ease in PyCharm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Leonardo Da Vinci, the great painter and sculptor, mused that his sculptures
    were fully formed in the blocks of stone from the quarry before he even saw the
    marble. Da Vinci explained that all he did was remove the pieces of marble that
    were not required for the form. In other words, his masterpieces were completed
    in his mind before a chisel touched the crude stone. In many ways, you are Da
    Vinci. You have a project in your head, fully formed, and you are eager to show
    the world your masterpiece. Instead of using a hammer and chisel to write your
    code, you are using PyCharm. In the previous chapters, we worked through the installation
    process and configuration of PyCharm. We also set up an interpreter for your project.
    Next up: the exploration of the main tools that you will use to craft your masterpiece,
    which mainly reside in the editor.'
  prefs: []
  type: TYPE_NORMAL
- en: By now, you have discovered many of the obvious features of the editor. We know
    it handles a lot of the PEP-8 syntax rules automatically. We know we get the color-coded
    syntax. We also have observed that the **integrated development environment**
    (**IDE**) will make suggestions on several different areas of coding, ranging
    from linting style rules to auto-completion.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will focus on the features of the editor that are less obvious.
    The product’s documentation provides keyboard shortcuts and editor basics that
    will not be discussed in this chapter. Instead, the following topics will be covered:'
  prefs: []
  type: TYPE_NORMAL
- en: Real-time code inspection with automated fixes, which allows you to focus on
    development goals rather than on the rules of Python coding.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Various code-completion support features in PyCharm and how to leverage them.
    By using these, you’ll be able to code more quickly and more accurately. We will
    only focus on those tools that ship with PyCharm versus third-party **artificial
    intelligence** (**AI**) enhancements that require plugins such as Kite or GitHub
    Copilot. These will be covered in [*Chapter 15*](B19644_15.xhtml#_idTextAnchor379).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refactoring tools that allow you to polish and refine your code into the masterpiece
    that it can become through patience, discipline, and good tooling.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documentation tools that will take you from the level of “good developer” to
    the level of “master developer.” It’s one thing to invent an amazing work of code.
    Documenting it so others can benefit from it takes your work to another level.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to proceed through this chapter and the rest of the book, you will
    need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: An installed and working Python interpreter. I’ll be using the latest from [https://python.org](https://python.org).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installed copies of `pip` and `virtualenv`. You get these automatically when
    you install Python on Windows, and MacOS has them included on every system. If
    you are using Linux, you need to install the package managers, such as `pip`,
    and virtual environment tools, such as `virtualenv`, separately. Our examples
    will use `pip` and `virtualenv`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An installed and working copy of PyCharm. Installation was covered in [*Chapter
    2*](B19644_02.xhtml#_idTextAnchor028).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This book’s sample source code from GitHub can be found at [https://github.com/PacktPublishing/Hands-On-Application-Development-with-PyCharm---Second-Edition/tree/main/chapter-04](https://github.com/PacktPublishing/Hands-On-Application-Development-with-PyCharm---Second-Edition/tree/main/chapter-04).
    We covered cloning the code in [*Chapter 2*](B19644_02.xhtml#_idTextAnchor028),
    *Installation* *and Configuration*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code analysis, inspection, and suggestion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Intelligent code completion is essential to any programming tool’s adoption.
    The definition of a good code completion engine is one that is aware of high-level
    aspects of programming, including specifics of language syntax. The engine also
    must be aware of the lower-level specifics of the program you write. Many enhanced
    text editors support code completion but lack this level of sophistication. PyCharm
    stands out as an exceptionally sophisticated code editor, encompassing both the
    historical and modern aspects of code editors and offering a level of sophistication
    that surpasses many other enhanced text editors in terms of intelligent code completion.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most common form of code completion is a large picklist of words that are
    matched as you type. The list of possibilities narrows as more letters are typed.
    Notepad++ is an enhanced text editor widely used by developers. I consider it
    a must-have tool for quick and easy edits when I am too impatient to wait on an
    IDE to fully load. *Figure 4**.1* shows a session where I began typing some Python
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1: Notepad++ uses a very simple mechanism for code highlighting
    and completion](img/B19644_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.1: Notepad++ uses a very simple mechanism for code highlighting and
    completion'
  prefs: []
  type: TYPE_NORMAL
- en: 'The tool does not intuitively know what is being typed; therefore, I must tell
    it that I am coding in Python. After the language is set, it will attempt to autocomplete
    everything, even though such an exercise is clearly futile. In *Figure 4**.1*,
    I was going to type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This clearly isn’t going to win me any Jolt awards. You see in the screenshot
    that the list is filtering a known list of words. Its only contextual point of
    reference is knowing that the file is a Python file. This isn’t very effective,
    but it is better than nothing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Systems like these are little more than spell checkers. While a seasoned pro
    might scoff at the usefulness of such a simple system, the earliest IDEs that
    displayed this level of wizardry pioneered a feature we are now unwilling to live
    without: code completion.'
  prefs: []
  type: TYPE_NORMAL
- en: 'PyCharm lies at the opposite end of the spectrum with respect to sophistication.
    Like Notepad++, PyCharm is aware of the keywords that comprise PyCharm. PyCharm,
    though, is able to glean insight into the structure of the objects that make up
    the standard library. *Figure 4**.2* shows me typing some code into PyCharm, having
    created a simple file for this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2: PyCharm auto-completes based on its understanding of the time
    library](img/B19644_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.2: PyCharm auto-completes based on its understanding of the time library'
  prefs: []
  type: TYPE_NORMAL
- en: In this case, I have imported the `time` library just as I did in the Notepad++
    example from *Figure 4**.1*. I’m a little further along here. I have my function
    defined, and I’m going to simply print the current local time using the `time`
    library I had already imported. As you can see in *Figure 4**.2*, PyCharm is offering
    completion against the contents of the time library.
  prefs: []
  type: TYPE_NORMAL
- en: Completing the auto-completion
  prefs: []
  type: TYPE_NORMAL
- en: Once the auto-completion list appears, you can press *Tab* or *Enter* to select
    the highlighted option. You can use the up and down arrow keys to move through
    the list, or you can click any of the list items with your mouse. You’ll work
    fastest, though, if you keep your fingers on the keyboard.
  prefs: []
  type: TYPE_NORMAL
- en: By now, you are starting to appreciate the code completion system offered by
    PyCharm. Let us further explore the capabilities of this important tool.
  prefs: []
  type: TYPE_NORMAL
- en: It duzunt assewm yew cna spel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our simplistic word-list example from Notepad++ earlier already stands in sharp
    contrast to the more sophisticated features of PyCharm’s auto-completion engine.
    Let’s dig a little deeper. If your tool relies on a word list, then the second
    your spelling steps out of line, your suggestion list dries up. In effect, the
    word-list method requires you to know what it is you are looking for while requiring
    it to be spelled correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Figure 4**.3*, you will see something a little different:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3: PyCharm finds all possibilities containing the text you’ve typed](img/B19644_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.3: PyCharm finds all possibilities containing the text you’ve typed'
  prefs: []
  type: TYPE_NORMAL
- en: PyCharm is designed to offer suggestions based on the letters that are typed.
    In other words, as you type `cl`, the word *clock* might appear. The word *clock*
    will also appear if you type `lo`, `ck`, or any consecutive letters contained
    in the list of keywords matched. Perfectly spelled words are not necessary. Just
    get in the ballpark, and the word you are searching for will likely pop up.
  prefs: []
  type: TYPE_NORMAL
- en: It understands your code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Good code completion is able to understand and autocomplete based on the language
    and the libraries in use. In our case, that’s Python, which has an enormous standard
    library compared to other languages. Python is designed around a “batteries included”
    philosophy. Contrast that with JavaScript as implemented in Node.js, where the
    only libraries you get are file and HTTP libraries. The .NET languages give you
    a small core. You can say the same about Golang. Most languages require you to
    use the package manager. The fact that PyCharm can do this is spectacular by itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'PyCharm, being a great IDE, can also understand the code you’ve written. *Figure
    4**.4* shows the `autocomplete_demo.py` file, where I have added an import to
    the `no_problemo.py` file. The `no_problemo.py` file has one function in it called
    `perfection()`. As you can see, PyCharm is able to see inside the file and provide
    autocompletion on the code I have written versus simply doing auto-complete from
    a language-based word list:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4: PyCharm provides autocompletion suggestions on the code you’ve
    written, as well as standard Python language and the standard library](img/B19644_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.4: PyCharm provides autocompletion suggestions on the code you’ve
    written, as well as standard Python language and the standard library'
  prefs: []
  type: TYPE_NORMAL
- en: I am offered auto-completion on the function name, as well as hints on the **method
    signature**. If you’re unfamiliar with the term *method signature*, it simply
    refers to the name, argument list, and return values for a function or method.
    If you’ve included type hints, PyCharm will remind you of the argument names and
    types the function or method requires. This works with modules as well as classes
    if you’re using **object-oriented** **programming** (**OOP**).
  prefs: []
  type: TYPE_NORMAL
- en: Postfix code completion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Traditional code completion has been taken to the next level in PyCharm, but
    we are far from finished. Usually, hitting the period (*.*) key on your keyboard
    triggers a list to appear. We are now used to that list containing what might
    come after the dot. However, what if PyCharm could give you suggestions on what
    might come *before* the dot? In *Figure 4**.5*, we see an example of postfix code
    completion, which you will find in the `postfix_example.py` file in the [*Chapter
    4*](B19644_04.xhtml#_idTextAnchor077) sample code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.5: Postfix completion in PyCharm can suggest what might come before
    the dot rather than simply what might come after](img/B19644_04_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.5: Postfix completion in PyCharm can suggest what might come before
    the dot rather than simply what might come after'
  prefs: []
  type: TYPE_NORMAL
- en: 'I can’t blame you if you are confused by seeing `.if` (if expr) as a possibility
    following what is clearly a string-typed variable. The `.if` suggestion is not
    part of Python. It is a **postfix suggestion**. If you complete this suggestion
    your code is transformed. The following code isn’t viable Python syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Therefore, it is converted to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Just imagine the possibilities! However, if you’re not the imaginative type,
    check out *Figure 4**.6*, which shows PyCharm’s **Postfix Completion** configuration
    options:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.6: PyCharm’s Postfix Completion configuration options](img/B19644_04_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.6: PyCharm’s Postfix Completion configuration options'
  prefs: []
  type: TYPE_NORMAL
- en: Naturally, these options are fully configurable. You can even add your own!
    The templates are not limited to Python. You can see in the list that there are
    configurations for TypeScript, JavaScript, and **Structured Query Language** (**SQL**).
    This is important because application development is rarely limited to the scope
    of just the Python language.
  prefs: []
  type: TYPE_NORMAL
- en: Hippie completion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Hey, man! You wanna see something that is like totally far out? It’s called
    **cyclic word expansion**. Only total squares call it that, though. If you wanna
    be *hip*, you’ll call it **hippie completion**!
  prefs: []
  type: TYPE_NORMAL
- en: 'Hippie completion is invoked by pressing *Alt* + */* (Windows and Linux) or
    *⌥* + */* on macOS. Once triggered, PyCharm will index all the files you currently
    have open and provide auto-completion suggestions based on words within that context.
    In effect, you are using the simplest form of auto-complete; a word list. The
    word list is generated on the fly from the words in the files you have open. They
    don’t have to be code. Plain text files, markup, markdown, or really any text
    will show up in the suggestions list based on a simple forward match. As you type,
    the list narrows. You can see an example in *Figure 4**.7*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.7: Hippie completion is totally far-out!](img/B19644_04_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.7: Hippie completion is totally far-out!'
  prefs: []
  type: TYPE_NORMAL
- en: The text file on the right contains a list of words I generated at [https://fungenerators.com/lorem-ipsum/hippie/](https://fungenerators.com/lorem-ipsum/hippie/).
    Unfortunately, it turns out, a lot of the iconic words from the hippie generation
    in the United States cannot be printed in a book of this caliber. We have the
    highest standards! So, I edited the list, and this was all that was left. These
    words are random, so please don’t try to construe any meaning from them, despite
    all the allegations about there being secret backward messages on albums by The
    Beatles. The code on the right can expand from that list using hippie completion.
    To make this work, I typed `print("pat` then pressed *Alt* + */*. The word *patchouli*
    magically appeared! I hope this example was worth it for you. I may never get
    that smell out of my keyboard!
  prefs: []
  type: TYPE_NORMAL
- en: You can use *Alt* + *Shift* + */* or *⌥* + *Shift* + */* to enable backward
    cyclic word expansion, which matches from the end of the words backward to the
    beginning. If the powers that be had asked me (and they didn’t, because they never
    do) I’d have called this `#GingerRogersCompletion` and reference this book, it
    might catch on!
  prefs: []
  type: TYPE_NORMAL
- en: Pro hippie tip
  prefs: []
  type: TYPE_NORMAL
- en: Repeatedly pressing *Alt* + */* (Windows and Linux) or *⌥* + */* on macOS cycles
    through the list. You can just keep hitting the key combination until the word
    you are looking for appears.
  prefs: []
  type: TYPE_NORMAL
- en: Indexing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are various engines at work in powering PyCharm’s various code completion
    techniques. You might be wondering how it works. It isn’t dark sorcery, I assure
    you. The key to understanding it is to pay attention when PyCharm loads a project.
    *Figure 4**.8* calls your attention to the bottom of the PyCharm application window.
    PyCharm kicks off several background processes that comb through your code and
    index every character. The index is then converted into an in-memory database
    that is used by the various engines at play:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.8: Keep an eye on the bottom of the PyCharm window to know when
    background processes such as indexing are running](img/B19644_04_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.8: Keep an eye on the bottom of the PyCharm window to know when background
    processes such as indexing are running'
  prefs: []
  type: TYPE_NORMAL
- en: Normally, I don’t really care how the magic works, but it is worth bringing
    up because there will be times when PyCharm seems slow or unresponsive. When PyCharm
    seems slow or if auto-completion isn’t working, check the area of the screen indicated
    in *Figure 4**.8* and see whether there are indexing processes running. You’ll
    probably notice your CPU spike as well if you monitor such things. This is temporary.
    Once the indexing process completes, PyCharm will become responsive again.
  prefs: []
  type: TYPE_NORMAL
- en: Power Save Mode
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the more cryptic entries in the PyCharm menu, shown in *Figure 4**.9*,
    is **Power** **Save Mode**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.9: The Power Save Mode menu option can be found under the File menu](img/B19644_04_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.9: The Power Save Mode menu option can be found under the File menu'
  prefs: []
  type: TYPE_NORMAL
- en: I remember the first time I clicked it. The streetlights throughout the city
    block where I live instantly got brighter. My electric meter that was spinning
    like a buzzsaw mere minutes ago was now lazily spinning slower than an abandoned
    top. Once, a guy at the power company even called and thanked me for doing my
    part in saving the planet.
  prefs: []
  type: TYPE_NORMAL
- en: 'OK, I’m making all that up, except for the part about the guy from the power
    company. That totally happened. The `b.if` from the earlier example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.10: A message reminds you that power save mode is on and that you
    will not be receiving the usual level of assistance from PyCharm](img/B19644_04_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.10: A message reminds you that power save mode is on and that you
    will not be receiving the usual level of assistance from PyCharm'
  prefs: []
  type: TYPE_NORMAL
- en: Personally, I consider this utterly barbaric! How are we supposed to work like
    this? Next, you’ll be telling me I don’t have access to the internet, Kite, GitHub
    Copilot, ChatGPT, or Stack Overflow! You’ll strip me of my very reasonably priced
    subscription to [packtpub.com](http://packtpub.com), where I can get all the e-books
    I can read for one low price. Then you’ll take away my Herman Miller Aeron Chair
    and limit me to only one $14 mezzo-Grande half-fat triple foam double shot latte
    with rainbow jasmine-infused sprinkles per day! Why don’t you enact a dress code
    while you’re at it? Strike! Strike! Strike!
  prefs: []
  type: TYPE_NORMAL
- en: 'Sorry. I got a little carried away. Needless to say, this is probably the least
    favorite feature of the IDE. Maybe it is useful if you chewed up your laptop’s
    battery playing *Ghost Recon: Breakpoint* on an overseas flight, and upon landing,
    you suddenly get a call from the boss who needs something fixed right away. Suddenly,
    you need to squeeze every second out of that 5% battery level you have left. I
    hate it when that happens.'
  prefs: []
  type: TYPE_NORMAL
- en: Customizing code completion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Customization within PyCharm is an ongoing theme. It might have been easier
    to show you what you can’t customize, except that I haven’t actually found anything
    yet. Code completion is no different. Whether you prefer a very lightweight experience
    with little to no help or you want your handheld on every line of code, there
    is a way to make PyCharm into the editor you want to use every day.
  prefs: []
  type: TYPE_NORMAL
- en: 'To open the settings for code completion, venture back to the settings dialog
    we explored in [*Chapter 2*](B19644_02.xhtml#_idTextAnchor028), *Installation
    and Configuration*. You can reach it easily by clicking the **File** menu item
    and selecting **Settings**. That brings up the settings dialog. If you recall
    from [*Chapter 2*](B19644_02.xhtml#_idTextAnchor028), *Installation and Configuration*,
    this dialog is massive! We’re looking for **Editor** | **General** | **Code Completion**,
    as shown in *Figure 4**.11*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.11: The Code Completion settings allow you to customize the behavior
    of PyCharm’s Code Completion engine](img/B19644_04_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.11: The Code Completion settings allow you to customize the behavior
    of PyCharm’s Code Completion engine'
  prefs: []
  type: TYPE_NORMAL
- en: You should spend a moment going through everything you can do on this screen.
    PyCharm gives you a great deal of control! I promised this wouldn’t be a tedious
    accounting of every option. Instead, draw your attention to the most popular and
    potentially most useful settings available.
  prefs: []
  type: TYPE_NORMAL
- en: Match case
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Located at the top of the window, this option specifies whether items in the
    suggestion list should match the case of whatever you are typing. For example,
    if I wanted to type in an exception expression for the `KeyboardInterrupt` exception
    in Python and the `K` for the correct class name to be included in the suggestion
    list. Next to the **Match case** checkbox, you can also choose only the first
    letter’s case should be matched or whether this should apply to all the letters.
  prefs: []
  type: TYPE_NORMAL
- en: 'I personally always disable this checkbox so that I only have to type in, for
    example, a lowercase `k` to take advantage of code completion. When I am learning
    a new language or API, this setting can help me with a practice I call *property
    shopping*. I don’t know what properties and methods are available, so an alphabetized
    list can be helpful. For example, every programming language has some sort of
    string-handling class or library. It is a very safe bet that the said library
    will have functions for trimming, which is to remove extra spaces from the front,
    end, or both ends of a string. There is always some sort of `toUpper` and `toLower`
    methods. These are all vital parts of defensive programming. A password input
    where a user accidentally includes a space at the beginning or end of the password
    makes for a frustrating user experience. Any conditional logic you use involving
    user input is easier to handle if you make everything upper or lowercase. Given
    these are so fundamental to our work, we know they will be on the list, but every
    language calls them something different. I work on projects that require switching
    between two or three languages, and it is very easy to type in the wrong function
    name. Take the method that converts a string to uppercase. In JavaScript, such
    a function looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The same code in PyCharm, which I might be creating only minutes later, would
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In order to be effective, I need the word upper to be a match regardless of
    whether it is uppercase or lowercase.
  prefs: []
  type: TYPE_NORMAL
- en: Like everything we have seen in code completion, and for that matter, like everything
    in programming, there is a trade-off to this practice. Specifically, if **Match
    case** is disabled, sometimes the suggestion list might be populated by many more
    irrelevant options, which makes finding the correct API more difficult. At the
    same time, though, you will see a full list of what is possible, which can help
    you learn your way around and sometimes discover features in an API you had not
    imagined were available.
  prefs: []
  type: TYPE_NORMAL
- en: Sorting suggestions alphabetically
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As its name suggests, this option allows you to sort the items in the suggestion
    list in alphabetical order. This feature is useful for long suggestion lists that
    require the developer to scroll through them carefully to find what they are looking
    for if they were not ordered alphabetically.
  prefs: []
  type: TYPE_NORMAL
- en: 'On multiple occasions, we have seen the dynamic nature of PyCharm, and it is
    once again demonstrated in this feature. Specifically, while interacting with
    a suggestion list in the editor, you can change the order of the items in the
    list at any time by clicking on the icon located in the bottom-right corner of
    the suggestion window, as shown in *Figure 4**.12*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.12: You can change the way suggestions are sorted within the list
    itself](img/B19644_04_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.12: You can change the way suggestions are sorted within the list
    itself'
  prefs: []
  type: TYPE_NORMAL
- en: 'Clicking the **…** (ellipsis) element allows you to change how the suggestions
    are sorted: by relevance or alphabetically by name.'
  prefs: []
  type: TYPE_NORMAL
- en: Machine learning assisted completions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This newer option is simultaneously magical and scary. Enabled by default, PyCharm
    will train a machine learning model based on your code. This allows PyCharm to
    make suggestions based not only on your code but also that of thousands of other
    developers. Traditional code completion usually gives you suggestions for the
    next keyword, property, method name, or parameter you are about to type. Do not
    be surprised if PyCharm offers complete entire functions or blocks of code for
    you with machine learning assisted completions. You will see this for common tasks
    such as connecting to databases, working with pandas data frames, or validating
    user input.
  prefs: []
  type: TYPE_NORMAL
- en: The settings merely allow you to turn on various languages supported by PyCharm.
    Python, JavaScript, and TypeScript are enabled by default. Only SQL, a special-purpose
    language used for working with relational databases, is not enabled by default.
    I suspect this is because there are additional settings around your preferred
    SQL dialect both at the global and project level that contribute to suggestions.
    It would be awkward to expect a tight list of suggestions given the number of
    databases PyCharm supports and the differences in their implementation of language
    elements not defined by standardized SQL. We’ll look at SQL and relational databases
    later in *Chapter 11*, *Understanding Database Management with PyCharm*. I promise
    the experience will not leave you bankrupt.
  prefs: []
  type: TYPE_NORMAL
- en: Showing the documentation popup in [...] ms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you enable this feature, you will see the documentation in addition to
    the suggestion code. You will be able to understand what the code you are typing
    does rather than blindly accepting the suggestions. This is great for new developers,
    whether they are totally new to coding or just new to Python. The advantage of
    this feature is that you can go through the documentation of all the suggested
    items dynamically as you simply move the cursor down the items.
  prefs: []
  type: TYPE_NORMAL
- en: This is especially beneficial when working with classes and methods that have
    similar APIs. We will discuss this feature, along with other documentation-related
    functionalities, in the last section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Parameter info
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Scroll down past the JavaScript section, as seen in *Figure 4**.13*, and you’ll
    find an option for suggesting parameter information:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.13: Scroll down past JavaScript to find options for showing parameter
    information](img/B19644_04_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.13: Scroll down past JavaScript to find options for showing parameter
    information'
  prefs: []
  type: TYPE_NORMAL
- en: The first option is straightforward. It controls the amount of time that must
    elapse before a suggestion appears. In general, suggestions are great unless you
    are teaching, doing a code review, or doing some sort of demo, in which case they
    can clutter up your screen. Sometimes it’s a good idea to raise the time limit
    so the suggestions or documentation are shown only if you linger for a few seconds.
  prefs: []
  type: TYPE_NORMAL
- en: The second option allows you to toggle, showing the full method signature. I
    love this feature. The code hint will show you the whole method signature so you
    can see all the arguments at once.
  prefs: []
  type: TYPE_NORMAL
- en: 'A method signature uniquely defines a function or method within the scope where
    it is declared. It consists of a name for the function. Along with the names,
    and preferably hints, for the type of the function’s arguments with some hints
    about the return type. These are not unique to Python. In fact, they are a little
    bit fuzzy in Python. Now compare it with a static language such as C#, which uses
    more strict programming structures. In Python, you can use type hints, which help
    developers to remember the expected types of the arguments being passed. Let’s
    look at an example of a method signature without hints:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This is OK. This code will work as intended, and the intention of the developer
    is clear. Let’s look at the same function with hints:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This is much better! Now we know for certain the types that are expected as
    input parameters, and we know the type that is going to be returned. I said earlier
    that method signatures are “fuzzy” in Python. I said this because both code samples
    will work. Python ignores the hints entirely during compilation. The hints are
    just used by the tooling and make your Python code easier to read and understand.
    Adding hints to your code whenever possible will enhance the way you, and your
    teammates, see your method signatures if you turn on the **Show full method**
    **signatures** option.
  prefs: []
  type: TYPE_NORMAL
- en: Code analysis and automated fixes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Code completion is a standard feature of most code editors and IDEs. As we’ve
    seen, not all completion engines are created equally. The same can be true for
    analysis engines. A code analysis engine is an extension of code completion in
    concept, if not in implementation. Code completion tries to predict the code you
    are writing and helps you finish more quickly. Code analysis examines the code
    you’ve written and attempts to determine whether or not the code will work when
    you run it. Just as with code completion, there are differing levels of complexity
    at play here and different processes examining different things.
  prefs: []
  type: TYPE_NORMAL
- en: The simplest form of analysis is called *linting*. Pretty much every programming
    language has a linting tool, and Python is no exception. While there are many
    to choose from, PyCharm uses the popular `pylint` library by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'A linter runs a tacit analysis of your code through a process of pattern matching.
    There are two linting operations: **logical lint** and **stylistic lint**. A logical
    lint looks for code errors, code with potentially unintentional results or side
    effects, and dangerous code patterns. A stylistic lint looks for code that doesn’t
    conform to common conventions. This is less of a problem with Python since the
    language already has a strict set of code formatting rules called **Python Enhancement
    Proposal #8**. Nobody calls it that. Those in the know simply call it **PEP-8**.'
  prefs: []
  type: TYPE_NORMAL
- en: Combined, you can think of `pylint` and, by extension, all linters, much like
    a spelling and grammar checker for regular text. The linter looks for misspelled
    keywords, malformed code, and obvious syntax errors. A linter can also enforce
    style guidelines, though really Python is already designed to enforce rules to
    make your code as human-readable as possible.
  prefs: []
  type: TYPE_NORMAL
- en: While it’s one thing to point out problems in your code, it is entirely more
    useful if the tool also suggests and even implements fixes to those problems.
    The same is true of humans. It is easy to point out flaws. Anybody can do that.
    Good advice on how to fix your flaws is more useful than criticism. So, in addition
    to linting, PyCharm offers a system that will offer to help you fix the problems
    exposed by the linter.
  prefs: []
  type: TYPE_NORMAL
- en: Problem detection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Problem detection is performed by PyCharm in real time as you type your code.
    The indexing process we’ve mentioned before plays a role here, but we’ll come
    back to that. First, let’s focus on the visible interface in the editor that shows
    you where your problems lie. There are four places to look, as shown in *Figure
    4**.14*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.14: Four places in the user interface tell you that you have problems](img/B19644_04_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.14: Four places in the user interface tell you that you have problems'
  prefs: []
  type: TYPE_NORMAL
- en: The right gutter of the editor (1) will show you where all the problematic lines
    lie in the currently open file. This gutter is a compressed, miniature representation
    of your file. It is pretty common for a file to have hundreds or maybe even thousands
    of lines. You can click on the area in the gutter where you see the colored marks,
    and the editor will scroll to that location.
  prefs: []
  type: TYPE_NORMAL
- en: 'PyCharm will classify the problems into three basic categories: errors (red),
    warnings (yellow), and weak warnings (gray). This is reported for the whole file
    at the top of the gutter column with counts of each problem type (2). In addition
    to colors, this area gives you different shapes. The error icon is a round red
    circle with an exclamation point within it. Warnings are a triangle with an exclamation
    point. Weak warnings are also depicted using a triangle with an exclamation, but
    they appear considerably dimmer. If no problems are detected, you are rewarded
    with a green check mark. *Figure 4**.15* shows two files. One has no problems
    (1), while the other has a number of issues in different categories (2):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.15: The file on the bottom is devoid of any problems, while the
    one on top isn’t quite as lucky](img/B19644_04_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.15: The file on the bottom is devoid of any problems, while the one
    on top isn’t quite as lucky'
  prefs: []
  type: TYPE_NORMAL
- en: Anything marked in red is an error that will probably prevent your program from
    running correctly or at all. A warning means your code will probably run, but
    there are some obvious cases where it won’t perform as expected. A weak warning
    is usually a minor flaw, such as a variable name that doesn’t conform to an English
    dictionary word. If your locale is set to a language other than English, PyCharm
    will flag words from your local language.
  prefs: []
  type: TYPE_NORMAL
- en: The second place to look for problems is within the editor window itself. Look
    back at *Figure 4**.15* at line 13\. You’ll see a squiggly red (trust me) underline
    beneath the word `math`. The colors of the lines correspond with the severity
    of the problem. The right-hand gutter shows you where the problem is located,
    while the underlines show you the problem directly on the offending line. If you
    hover your mouse over whatever is underlined, you’ll get a description of the
    problem. I’ll go into more depth on this later in this chapter when we talk about
    **intentions**, which are suggestions about how to fix problems in your code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The third place you’ll find indicators of problems is the project explorer.
    Refer back to *Figure 4**.15*, area 3\. There is a Python package called `bad_actor`.
    That file isn’t open in *Figure 4**.15*, but I opened it when I created it, typed
    in some incomplete code, then closed the file. You can see the file open in *Figure
    4**.16*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.16: Silly me! I started typing in the file but never finished](img/B19644_04_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.16: Silly me! I started typing in the file but never finished'
  prefs: []
  type: TYPE_NORMAL
- en: If there is an error in the file you aren’t currently working on, you’ll find
    it flagged in the file list. The warning will bubble up through the directory
    system. There’s a red squiggly line at the top project folder, another in the
    folder for the package, and still another underline beneath the file where the
    problem lies. PyCharm doesn’t examine closed files. It only examines files you
    open, but once it finds the problem, it will remember where it is and continue
    to warn you until you fix the problem.
  prefs: []
  type: TYPE_NORMAL
- en: Bad actor
  prefs: []
  type: TYPE_NORMAL
- en: I needed an exemplary bad actor for the previous visual pun. Kevin Costner is
    a bad American actor. He certainly isn’t the worst, but he’s easily in the top
    10\. If you don’t believe me, watch the movie *Dances with Wolves*. If you still
    don’t believe me, watch *The Bodyguard*. If you still think he’s great, watch
    *Waterworld* and realize he financed that movie out of his own pocket because
    he was convinced it would be a mega-hit.
  prefs: []
  type: TYPE_NORMAL
- en: 'The fourth place is the problems window. In *Figure 4**.17*, you can see a
    red dot over an icon in area 4 in the screenshot. Click the icon, and the problems
    window will open and show you a list of faults, as seen in *Figure 4**.17*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.17: Open the problem window to see a list of all your problems.
    Only your code problems are displayed. Life problems are not shown](img/B19644_04_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.17: Open the problem window to see a list of all your problems. Only
    your code problems are displayed. Life problems are not shown'
  prefs: []
  type: TYPE_NORMAL
- en: Syntax errors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Syntax errors are usually the shallowest errors exposed by an IDE. We’ve seen
    a few already. *Figure 4**.17* shows an incomplete function definition, so it
    is flagged in red as a syntax error. In *Figure 4**.14*, line 13 has a red underline
    beneath the word `math`. PyCharm recognizes this as a reference to the Python
    `math` library, which I have neglected to import. This throws an unresolved reference
    error. These kinds of errors are always marked in red as severe errors because
    they will prevent the program from running.
  prefs: []
  type: TYPE_NORMAL
- en: Duplicated code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you make a habit of copying and pasting code within your project or even
    between different projects, you can expect a warning from PyCharm. Duplicated
    code is a sign your project is in trouble.
  prefs: []
  type: TYPE_NORMAL
- en: The best practice is to follow the concept called **Don’t Repeat Yourself**
    (**DRY**). I’ll say it again. You want your code to always be DRY. Never repeat
    your code by copying and pasting. Make sure it’s DRY. OK, I’ll stop if you promise
    to heed PyCharm’s warnings about code not being DRY.
  prefs: []
  type: TYPE_NORMAL
- en: When you find this problem within a single project, you can usually fix it by
    hoisting the duplicated code into a function and calling the function from the
    parts of your code where the duplicates lie.
  prefs: []
  type: TYPE_NORMAL
- en: If you get flagged for copying and pasting between projects, you should turn
    the duplicated code into a Python package that can be shared between projects.
  prefs: []
  type: TYPE_NORMAL
- en: PEP-8 problems
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: PyCharm’s linter alerts you to styling problems in your code that violate PEP-8\.
    The biggest problem for developers new to Python is dealing with the rules around
    white space. Indentions and empty lines between functions are all part of the
    PEP-8 rules designed to keep your code very readable. Most PEP-8 problems are
    flagged as warnings.
  prefs: []
  type: TYPE_NORMAL
- en: Dead code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is my personal pet peeve. Someone writes some code, which ultimately gets
    replaced with a different function. Both the old and the unused function are sitting
    in the code file, along with the new one. They might have similar names. They
    might even be in different files. When I was a kid, I had a poster on my wall
    titled Murphy’s Laws of Technology. The poster espoused a pessimistic but, in
    my experience (and probably yours if you’ve been doing this for a while), totally
    accurate worldview. Here’s a sampling of Murphy’s Laws with respect to technology:'
  prefs: []
  type: TYPE_NORMAL
- en: You can never tell which direction the train traveled by looking at the track
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logic is a systematic method of coming to the wrong conclusion with confidence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whenever a system becomes completely defined, some fool discovers something
    which either abolishes the system or expands it beyond recognition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Technology is dominated by those who manage what they don’t understand: if
    builders built buildings the way programmers wrote programs, then the first woodpecker
    that came along would destroy civilization'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The attention span of a computer is only as long as its electrical cord
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An expert is one who knows more and more about less and less until he knows
    absolutely everything about nothing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is relevant because, at least for me, the likelihood that I will find and
    attempt to modify dead code (thinking it to be very much alive and the obvious
    source of all my problems) in a software system asymptotically approaches 100%.
    The tiny degree of variance somewhere between 99% and 100% seems to be affected
    by my present level of caffeination and whether I skipped breakfast. These effects
    appear to be inversely proportional.
  prefs: []
  type: TYPE_NORMAL
- en: I thank goodness for a system that warns me that I’m looking at dead code. My
    usual rant is that you should take dead code out. You won’t need it, and if you
    do, that’s what revision control systems are for.
  prefs: []
  type: TYPE_NORMAL
- en: Method signature mismatches
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A method signature mismatch happens when a function requires more or fewer arguments
    than the number you supplied. PyCharm will warn you when this happens.
  prefs: []
  type: TYPE_NORMAL
- en: The road to good code is paved with PyCharm’s intentions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we’ve spent time learning about our flaws, let’s look at some tools
    that help us fix them. PyCharm features a mechanism called intentions designed
    to automate fixing and improving your code. Take a look at *Figure 4**.18*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.18: Hover your mouse over any underlined code to see why it is underlined,
    along with possible fixes](img/B19644_04_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.18: Hover your mouse over any underlined code to see why it is underlined,
    along with possible fixes'
  prefs: []
  type: TYPE_NORMAL
- en: In the case of the code shown, the problem is I invoked the `sqrt()` method,
    which finds the square root. The method is a static method in the `math` class.
    The problem is I failed to import that class. The description of the problem appears
    just below the underline when I hover. Below the problem description is the most
    likely fix. Pressing *Alt* + *Shift* + *Enter* will automatically fix the problem
    by adding `import math` to the top of the file.
  prefs: []
  type: TYPE_NORMAL
- en: If you’d like to try this out, you can use the `inspection` project in the `chapter-04`
    folder of the sample code we cloned in [*Chapter 2*](B19644_02.xhtml#_idTextAnchor028),
    *Installation* *and Configuration*.
  prefs: []
  type: TYPE_NORMAL
- en: Note this might not be the only possible fix. In *Figure 4**.18*, we can also
    see **More actions…** prompting us to either click the link or press *Alt* + *Enter*
    to see more possibilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'Truly astute readers might have noticed the lightbulb. This is an alternate
    vector to the same feature. Check out *Figure 4**.19* to see the lightbulb in
    action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.19: The lightbulb is another way to get the intentions](img/B19644_04_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.19: The lightbulb is another way to get the intentions'
  prefs: []
  type: TYPE_NORMAL
- en: Clicking the lightbulb shows a list of possible intentions. This time, we see
    a preview. The intention is going to add `import math` at line 1 of the file.
  prefs: []
  type: TYPE_NORMAL
- en: The lightbulbs can be tricky sometimes because they have a tendency to disappear
    if you move off the line where they originally appeared. If you’d like to use
    the lightbulb, just click anywhere within the underline and wait for a tick. It
    will appear at the beginning of the line where the problem lies.
  prefs: []
  type: TYPE_NORMAL
- en: In the case we’re exploring, the problem is a legitimate error. The program
    won’t run until we fix the problem. You can’t see it in the previous two figures,
    but the lightbulb is red. You’ll also see yellow lightbulbs for less egregious
    problems.
  prefs: []
  type: TYPE_NORMAL
- en: Now if you’re like me, you want to see a clean file with a green check and no
    underlines. Let me tell you, that will probably never happen. PyCharm will almost
    always find something to change. Sometimes the suggested changes are not very
    useful. You might heed a suggestion that changes your code in some minor way.
    Right after you do this, the lightbulb comes back, and PyCharm offers to change
    the code back to the way it was. Yellow light bulbs are not your enemy unless
    they have an exclamation point in them.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most good IDEs, and development-focused text editors, for that matter, feature
    some level of tooling for refactoring. Refactoring is a very important practice
    that is often neglected. In my book, which is available on Amazon (or wherever
    the finest technical books are sold), *Real-World Implementation of C# Design
    Patterns*, I cover some of the entropic forces that lead a well-intended coding
    project to ruin. Your code starts off pristine, and the whole team commits to
    maintaining zero technical debt. But it never lasts. Factors such as time pressure,
    developer skill level, inevitable change, visibility, and complexity cause a process
    of devolution. Your code goes from a well-constructed, perfectly architected masterpiece
    to a big ball of mud on a plate of spaghetti!
  prefs: []
  type: TYPE_NORMAL
- en: I realize that I am pointing to a C# book here, but if you have a Packt subscription,
    I urge you to read the first two chapters of the book. The chapters discuss the
    common problems and preventions of work degradation. One thing you can do is to
    be vigilant and never dismiss the value of refactoring your code as a regular
    part of the development practice.
  prefs: []
  type: TYPE_NORMAL
- en: What is refactoring?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Simply put, refactoring is improving code without changing its functionality.
    If you have unit tests (you do, RIGHT!?!??!), they should pass before and after
    refactoring without any changes to the tests themselves. You are looking for ways
    to optimize your code in terms of readability and performance. Maybe you skipped
    some code niceties, such as adding **docstrings**, which we’ll cover later in
    this chapter. Maybe you didn’t add type hints to your method signatures. Perhaps
    there are opportunities to leverage design patterns or SOLID principles to make
    your code more flexible.
  prefs: []
  type: TYPE_NORMAL
- en: The idea behind refactoring is that you are taking a second look at your code,
    preferably after a little time has passed. Have you ever looked at code you wrote
    a month or even a year ago and wondered what possessed you to type that horrible
    function body? Why in the world did you _________? (Fill in the blank with something
    silly you did.) You can’t believe that was you. You are smarter than that. Consider
    having regular peer reviews of your code. This can happen at any time during the
    writing process. Also, having someone less invested in your work will be able
    to spot unrealized opportunities for improvement. Almost always, this will involve
    refactoring. Flip things around. How many times have you been handed some code
    written by another developer? Maybe the person that has left the company? You
    look it over and conclude that whoever wrote the code was clearly a recent escapee
    from the local asylum. It must be totally rewritten. This is you refactoring someone
    else’s code.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring tools in PyCharm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: PyCharm has a set of menu options dedicated to refactoring. There are a few
    that are not explicitly called out as refactoring tools.
  prefs: []
  type: TYPE_NORMAL
- en: Cleaning up your code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: PyCharm has a very thorough **Code Cleanup** tool. This tool, in effect, runs
    the same inspections you have seen so far, but it does them in bulk. You can have
    PyCharm try to fix all the problems as well. This feature is useful when you import
    a project created outside of PyCharm, say with a tool that doesn’t offer the kind
    of assistance you have seen in PyCharm.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can clean up an open file or all files in your project. To be honest, I
    don’t recommend you do this at the project level since you can’t really predict
    what the engine will do to a large set of files you haven’t even opened. *Figure
    4**.20* shows the menu location for **Code Cleanup****…**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.20: The Code Cleanup tools can be found in the Code menu](img/B19644_04_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.20: The Code Cleanup tools can be found in the Code menu'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you click the menu option, you’ll see a dialog asking about the scope
    of the clean-up, as seen in *Figure 4**.21*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.21: Specify the scope of the code cleanup](img/B19644_04_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.21: Specify the scope of the code cleanup'
  prefs: []
  type: TYPE_NORMAL
- en: You can clean up the whole project, uncommitted files, the current file (which
    for me is `main.py` from the `inspection` project in the `chapter-04` folder of
    the sample source code), or a custom scope. My recommendation is not to try to
    boil the ocean. Do not do a whole project cleanup on a massive project. It is
    usually smarter to let PyCharm work its magic on small batches of files. The **Uncommitted
    files** option is a nice step you can take before you commit changes to your version
    control system.
  prefs: []
  type: TYPE_NORMAL
- en: Renaming
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Donald Knuth, one of the most respected software developers of all time, wrote
    in his book *The Art of Computer Programming*, that there are two things in programming
    that are hard: naming things (e.g., variables, functions, classes, files, and
    so on) well, and invalidating your caches. How true this is! It is an art form
    to write meaningful variable definitions that are self-documenting while making
    your intentions clear. It usually takes several tries to get it right. PyCharm
    has a tool that easily allows a name change. You can right-click on anything you’ve
    named and select **Rename**. Type the new name of the thing that is to be renamed.
    PyCharm will affect the change everywhere the named thing is referenced. It will
    even find and change references in comments and docstrings.'
  prefs: []
  type: TYPE_NORMAL
- en: If the scope of the change is small, for example, you are renaming something
    scoped to a local function, the rename operation happens immediately. If you are
    attempting a rename with a broader scope, such as one that entails multiple files,
    PyCharm will preview the change for you by showing you all the files that will
    be affected. You can inspect all the changes before they are made to make sure
    the changes are appropriate. After you are satisfied, you can apply those changes.
  prefs: []
  type: TYPE_NORMAL
- en: There is no rename menu option for files!
  prefs: []
  type: TYPE_NORMAL
- en: This is confusing if you come from another tool such as Visual Studio Code,
    where renaming files is a simple matter of picking the file from the explorer
    view and clicking twice or pressing *F2*. You’ll hunt for the rename option for
    files, and you will not find one. That’s because it is in the **Refactor** menu.
    PyCharm considers renaming a file a refactor. Unlike other tools, PyCharm will
    make sure renaming the file doesn’t affect your code.
  prefs: []
  type: TYPE_NORMAL
- en: Inlining variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'PyCharm gives you the ability to automatically inline your variables. In fact,
    this is among the more common suggestions PyCharm provides. Consider this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The sum variable isn’t really needed. If you inline the variable, the code
    becomes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We’ve removed the line that declared the `sum` variable and assigned it the
    value of `num1 +` `num2`.
  prefs: []
  type: TYPE_NORMAL
- en: Extracting methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Earlier, I mentioned a concept called DRY, or Don’t Repeat Yourself. Yes, I
    realize that by mentioning it again, I am breaking the rule. I am doing so with
    a purpose. Remember, the IDE points out errors and then provides advice and tools
    to fix the problem. I’d like to present a very useful feature. PyCharm gives you
    a tool to easily extract code into a separate function. You will want to do this
    under a couple of circumstances. First, if you find yourself copying and pasting
    code within your project. You probably need to make that code a function and then
    call it from the places where you are pasting the copied code. Secondly, when
    you find a function that breaks the single responsibility principle. If you’ve
    never heard of this, you can guess what it means. A well-written program should
    contain functions that do only one thing. Written code that contains functions
    or methods that perform multiple responsibilities could be broken into separate
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at an easy example of such an opportunity. Open the `chapter-04/not_dry.py`
    file in the sample code. The code within is truly egregious! Sensitive viewers
    might want to sit down before opening the file. Behold! Something everybody has
    done at least once before they learned it was a bad idea:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'OK, so far, it is fine. We’ve got a dictionary of people who took a computer
    science class along with their grades. By the way, those aren’t random names.
    After you finish this chapter, see whether you can figure out who these illustrious
    individuals might be. I apologize to some of the illustrious individuals for the
    numbers themselves. They are meant to be more or less random keys except for Mr.
    van Rossum, who would obviously have gotten a perfect grade. I’m sure they all
    did very well in real life. Following that, we have another set of class grades:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'While it is a different subject and a different group of people, it’s the same
    idea. Now suppose we need to figure out the class average for each class. I can
    make a function for computing the average in the computer science class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Our method signature gives lots of good hints. We have a descriptive function
    name. The function takes one parameter, and our hint tells us we’re expecting
    a dictionary. The function is expected to return a float.
  prefs: []
  type: TYPE_NORMAL
- en: 'The function body creates a variable called `raw_total` and sets it to `0`.
    Next, we loop through the values of `dict` and, on each iteration, add `value`
    to `raw_total`. Once we have the total, we divide it by the number of keys (`len`)
    in `dict`, and voila! We have the class average. Towards the bottom of the file,
    we can see where this function is called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Wonderful! We have a call to our `computer_science_average` function along
    with a highly judgmental (and probably inaccurate since it might have been your
    favorite class) variable assignment. So, what’s wrong with any of this? Nothing.
    It’s what comes next that presents a problem and an opportunity to extract a method.
    The next function computes a different class: advanced theoretical and applied
    recess. This is a field that I personally pioneered, and within this field, I
    have no rival. Unfortunately, since I spent more time on the playground perfecting
    my art and less time in computer science class, I have all but duplicated the
    function we wrote earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'It’s the same function with a different name! We need to consolidate! To do
    this, you need to highlight everything between the colon that ends the method
    signature and the `return` statement. Refer to *Figure 4**.22*. Don’t include
    the `return` statement, or PyCharm won’t generate a `return` statement in your
    extracted function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.22: Select the code to extract into a new function or method](img/B19644_04_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.22: Select the code to extract into a new function or method'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, right-click the selected code and click **Refactor** | **Extract Method**,
    as shown in *Figure 4**.23*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.23: Right-click the selected code, then click Refactor, then Extract
    Method](img/B19644_04_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.23: Right-click the selected code, then click Refactor, then Extract
    Method'
  prefs: []
  type: TYPE_NORMAL
- en: 'This brings up a user interface that allows you to define the new method, as
    seen in *Figure 4**.24*:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 4.24: The \uFEFFExtract \uFEFFMethod dialog in PyCharm](img/B19644_04_24.jpg)"
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.24: The Extract Method dialog in PyCharm'
  prefs: []
  type: TYPE_NORMAL
- en: 'Set the name of the extract method. I set mine to `compute_average`. PyCharm
    has filled in the rest automatically. Click **OK**, and your code will change.
    *Figure 4**.25* shows the result of my refactoring:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.25: The result of the refactoring. Note the compute_average function
    was generated automatically from the selected code](img/B19644_04_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.25: The result of the refactoring. Note the compute_average function
    was generated automatically from the selected code'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at the resulting code PyCharm generated from the refactor. First,
    `computer_science_average` has changed to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This function is now calling the extracted function. The extracted function
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This is the code we selected for extraction. PyCharm generated the function
    for me. I must tell you, at this point, that I’m usually wary of generated code.
    It is rarely perfect. Here, I would have preferred a type hint on the `grades`
    parameter and a hint on the return type. Those are minor issues, though, and the
    result saved me some typing.
  prefs: []
  type: TYPE_NORMAL
- en: 'One lingering question might remain. Why didn’t PyCharm detect and flag the
    duplicated code? The quick answer: our sample code is too short. If I were to
    add a few more lines to the duplicated functions, it would appear as a duplicate.
    Let’s try it out. Modify the code in both functions so it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'All I did was add a bunch of fake variable declarations. They don’t do anything
    important except make the duplicate code fragment longer. By default, PyCharm
    only looks for duplicated fragments that are 10 lines or longer. Short duplications
    don’t make the cut. I bring this up because the magic of method extraction handles
    duplicates automatically. Let’s do the same exercise. First, look at PyCharm with
    the changes in place. You should see some indicators that we have problems, as
    shown in *Figure 4**.26*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.26: Now that our duplicated code is longer, it gets detected and
    flagged](img/B19644_04_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.26: Now that our duplicated code is longer, it gets detected and flagged'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see that PyCharm has noticed our duplicated code. Highlight the code
    for extraction, as shown in *Figure 4**.27*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.27: Mark the code for extraction](img/B19644_04_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.27: Mark the code for extraction'
  prefs: []
  type: TYPE_NORMAL
- en: 'Right-click the highlighted code and click **Refactor** | **Extract Method**,
    as shown in *Figure 4**.28*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.28: Extract the method by right-clicking, clicking Refactor, then
    Extract Method](img/B19644_04_28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.28: Extract the method by right-clicking, clicking Refactor, then
    Extract Method'
  prefs: []
  type: TYPE_NORMAL
- en: 'Name the extracted function `compute_average`, as shown in *Figure 4**.29*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.29: Name the extracted function compute_average](img/B19644_04_29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.29: Name the extracted function compute_average'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click **OK**. This time things are a little different. You’ll find that PyCharm
    creates the function extraction as before, but this time you are prompted to replace
    the duplicate code as well, as shown in *Figure 4**.30*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.30: PyCharm asks whether you’d like to replace the duplicated fragment
    with a reference to the extracted function](img/B19644_04_30.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.30: PyCharm asks whether you’d like to replace the duplicated fragment
    with a reference to the extracted function'
  prefs: []
  type: TYPE_NORMAL
- en: Exporting a function to another file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: How often have you written a nifty utility function in the wrong place? Maybe
    you put it in a module or class that is designed to do something specific, but
    your utility function turns out to be generally used in lots of places. The single
    responsibility principle that applies to functions also applies to modules and
    classes. Having a function that connects to a database is a great example. Let’s
    say you just got a job working for Billy Blanca’s Candy Factory. They need you
    to write some scripts that will import lists of candies they make from several
    different text formats and store them in a database. The first requirement comes
    in, and you need to read from a plain text file and write to an SQLite database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the project in `chapter-04/move_function/read_input_file_a.py`. Let’s
    review the contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'These first two lines import the `sqlite3` library from the standard library.
    If you haven’t worked with `sqlite3` before, here’s all you need to know for now:
    it is a file-based relational database. By this, we mean you don’t need to install
    a server as you would with databases such as Postgres or MariaDB. This makes it
    a good database to use for teaching and prototype work. We’ll cover databases
    in detail in [*Chapter 11*](B19644_11.xhtml#_idTextAnchor266), *Understanding
    Database Management in PyCharm*. Let’s continue with the definition for the function
    that will open the file, read the contents, and insert them into the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ve opened the file. For each line in the file, we are reading it in as text
    and removing the newline character. This is necessary for the database insert
    to work properly. Once the string is cleaned, we are calling a function that writes
    to the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'I’ve included the database file in the code repository, so there is no code
    needed to create the database. This function just opens the database, then creates
    a cursor. A cursor is used to execute commands against the database using SQL.
    Even if you don’t know SQL, I’m sure you can figure out what is happening. There
    is a table in the database called `candy`. The table has only one field: `name`.
    We’re keeping it very simple here. I have neglected to create a primary key because,
    for now, the database doesn’t really matter. We should be focused on the function
    more than how it works.'
  prefs: []
  type: TYPE_NORMAL
- en: Having generated a SQL statement to insert the `candy` name from the `candy`
    name in the current line of the text file, I execute the SQL statement, which
    will insert one row into the `candy` table.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a general rule in programming, whatever you create, you should destroy,
    and whatever you open, you should always close. So, I close my cursor and my database
    connection to avoid any resource locks later down the road. Finally, I use the
    common dunder-name convention to run the file for testing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In PyCharm, I can execute this by setting my run configuration to **Current
    File** and clicking the **Run** button. It works! The file is read, and we get
    no errors.
  prefs: []
  type: TYPE_NORMAL
- en: Dunderscores
  prefs: []
  type: TYPE_NORMAL
- en: A `__init__`? You could say, “*underscore underscore init underscore underscore.*”
    But that is cumbersome. If you just say, “init” you’re not being specific enough
    since there could be another function or method called `init` without the underscores.
    So, you say “*dunderscore init*” or even just “*dunder init*”, and everybody knows
    what you’re talking about.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next day we come to work and learn of a new requirement. We need another
    script that reads data from a **JavaScript Object Notation** (**JSON**) file.
    The JSON file just contains an array like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'It’s still just a list of candy, but we need to process it differently. Open
    up `chapter-04/move_function/input/read_input_file_b.py`. You’ll find its code
    is similar to the other code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We know we need to work with JSON, so I’ve imported the `json` package. I also
    know I’ll need to write to the same database as before. I know code reuse is a
    good thing, so I import the function from the other script. Then I set to creating
    a version of the code that reads JSON files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The `json.load` method takes the raw text and converts it into a regular Python
    3 `dict`. As you can see from the preceding file listing, `dict` will have one
    thing in it: an array of candy with the key of data. So, I grab that and put it
    in the `candies` variable, then I loop over that array and call the `write_to_database`
    function for each `candy` in the array. Wow! It’s not even lunchtime! Maybe I
    can walk around the factory? I hear they’ve got some little girl testing some
    gum that turns people into a raspberry.'
  prefs: []
  type: TYPE_NORMAL
- en: Not so fast! This code could be improved. Our input scripts are really designed
    to read data from text. It doesn’t make sense to have one of the scripts contain
    the database function because it simply doesn’t belong inside the script that
    reads text input files. It really should be in its own package. Let’s extract
    it to its own file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `chapter-04/move_function/input/read_input_file_a.py`. Right-click on
    the name of the function we’re going to move, as shown in *Figure 4**.31*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.31: Right-click the function you want to move, then click Refactor,
    then Move](img/B19644_04_31.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.31: Right-click the function you want to move, then click Refactor,
    then Move'
  prefs: []
  type: TYPE_NORMAL
- en: In the context menu, click `database_helper.py` filename. Click **OK**. Watch
    carefully because a lot is about to happen.
  prefs: []
  type: TYPE_NORMAL
- en: 'I get a new file called `database_helper.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This is the extracted function moved to its own file. PyCharm discovered the
    relevant import statement and moved that here as well. I had a constant for the
    file name called `CANDY_DB`. It didn’t move that, which would be my preference.
    Unfortunately, the current release of PyCharm is not psychic. I’ll just have to
    move that myself. Other than that, this file looks perfect.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you check the contents of `input_file_a.py`, you’ll see it has changed.
    The first line in the file now reads as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Likewise, if I open `input_file_b.py`, I’ll find the input there as well. PyCharm
    extracted the function to its own file, then changed every reference in every
    file to point to the new location.
  prefs: []
  type: TYPE_NORMAL
- en: Now, I realize I probably should have put this in its own module, and I realize
    you probably would have done this totally differently. Before you go bashing me
    on Twitter, remember this book is about PyCharm, not software architecture. I’m
    trying to keep it simple on purpose.
  prefs: []
  type: TYPE_NORMAL
- en: Documentation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: No programmer can doubt the importance of documentation in software engineering
    and development. That said, the process of creating documentation for a program
    can be quite tedious. Furthermore, the end result might not even be effective
    if the person doing the documentation was not following standard practices.
  prefs: []
  type: TYPE_NORMAL
- en: 'Keeping that in mind, PyCharm looks to streamline this process of documentation
    and make it as straightforward and seamless as possible. Regarding documentation,
    there are two components we will consider for this process: viewing and creating
    documentation. We will learn that PyCharm offers great support for both processes.'
  prefs: []
  type: TYPE_NORMAL
- en: Working with docstrings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Documentation in Python is known as docstrings, defined as a string literal
    that is placed before any of the statements in a module, function, class, or method
    in Python. You can look at examples of Python docstrings by going into the source
    code of the various built-in Python functions. It is also recommended that any
    custom API you write also has the appropriate docstrings for readability and maintainability.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most noteworthy subtlety in creating docstrings is the practice of using
    triple-double quotes to surround a docstring (which we will see examples of in
    the next subsection). For more details about docstring conventions, take a look
    at this PEP article: [www.python.org/dev/peps/pep-0257/](http://www.python.org/dev/peps/pep-0257/).'
  prefs: []
  type: TYPE_NORMAL
- en: Creating documentation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this subsection, we will look into the process of writing a docstring for
    functions with the help of PyCharm. Let’s get started.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the project in the sample source code in `chapter-04/documentation`. Open
    the `prime_test.py` file, which looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The file goes on after that, but the part I need you to focus on is the line
    right below the method signature for the `prime_check` function. There is a `TODO`
    there. If you’re from a Spanish-speaking country, realize this doesn’t mean *all*.
    It refers to a “to-do” item in the code. In this case, the original developer,
    who happens to be Quan Nguyen, the author of the first edition of this book, is
    stating he didn’t write the docstring for this function. He is signaling here
    that he knows that, and he intends to come back and fix this later. Let’s help
    him out with a little PyCharm magic. Before you get too excited, I’m sad to report
    that there isn’t a tool in PyCharm that can read your code and generate the docstring.
    Given how much developers hate writing documentation, I’ll wager there is a fast-and-furious
    effort underway somewhere to have AI do this. But we’re sticking with what PyCharm
    lets us do out of the box.
  prefs: []
  type: TYPE_NORMAL
- en: 'Delete the `# TODO` line and, in its place, type three double quotation marks
    (`"""`) and press *Enter*. You’ll find a generated docstring template appears:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This template needs some filling-in in order to become a proper docstring.
    Note the gap beneath the first set of triple quotes. Here, you are expected to
    write about what the function does. Maybe something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Below that is a section for the parameters expected by the function. Here,
    the function takes one argument called `n`. We should write a little bit about
    that parameter, including its type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The last part is the documentation for the return value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Consider the generated template of the docstring after we hit *Return/Enter*
    to expand the pair of triple-double quotes. `:param` and `:return:` are part of
    the template and will be included every time we expand a docstring in the same
    way. PyCharm allows us to change this format of docstring templates, making it
    highly customizable and accommodating.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing the docstring templates
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As usual, the docstring templates are highly customizable. You’ll find the
    customization settings by going into the **Settings** window, covered extensively
    in [*Chapter 3*](B19644_03.xhtml#_idTextAnchor052), *Customizing Interpreters
    and Virtual Environments*. Just search on docstring, and you’ll find the areas
    that should capture your attention. The first is shown in *Figure 4**.32*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.32: You can change the general format used to render your docstrings
    to one of several industry-standard formats](img/B19644_04_32.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.32: You can change the general format used to render your docstrings
    to one of several industry-standard formats'
  prefs: []
  type: TYPE_NORMAL
- en: The other group of settings is part of the color scheme settings, which allow
    you to customize the color used to render the docstring in the PyCharm editor.
  prefs: []
  type: TYPE_NORMAL
- en: Viewing documentation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Imagine a situation where you are using a specific method from one package,
    but you are not entirely sure which parameters the method takes in and/or what
    its return type is. Therefore, you need to go online and look into the documentation
    of the package for that specific method.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a PyCharm user, you can achieve the same thing with two simple actions:
    `prime_check.py` script from the previous section, move your cursor to the line
    where we use the `math.sqrt()` function in the `prime_check()` function; it should
    be around line 19.'
  prefs: []
  type: TYPE_NORMAL
- en: Quick Documentation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s say we’d like to see the documentation of this function. You can simply
    hover your mouse over the function call and wait a moment. Alternatively, you
    can choose **View** | **Quick Documentation** for this or its corresponding keyboard
    shortcut. You will see a pop-up window showing documentation similar to *Figure
    4**.33*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.33: Quick Documentation shows the documentation for the selected
    function](img/B19644_04_33.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.33: Quick Documentation shows the documentation for the selected function'
  prefs: []
  type: TYPE_NORMAL
- en: What’s more, you can also view the documentation for your own functions, methods,
    classes, and so on using the same action. PyCharm’s indexing process finds and
    generates this information when you open the project.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you move your cursor to the call to `prime_check()` in the main scope in
    the following line (which should be around line 38):'
  prefs: []
  type: TYPE_NORMAL
- en: '`if prime_check(num):`'
  prefs: []
  type: TYPE_NORMAL
- en: 'After waiting a moment, you will be able to see the same docstring that we
    entered earlier, as shown in *Figure 4**.34*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.34: Quick Documentation shows the documentation for the selected
    function on line 38](img/B19644_04_34.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.34: Quick Documentation shows the documentation for the selected function
    on line 38'
  prefs: []
  type: TYPE_NORMAL
- en: Note the format of the docstring in the documentation matches the documentation
    shown in the window.
  prefs: []
  type: TYPE_NORMAL
- en: Quick definition
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Quick Definition** operates in the same manner as **Quick Documentation**.
    This is useful when the documentation does not provide enough information, and
    you would like to see how a specific function is defined within the source code.
    To do this, place your cursor at a specific API call, and go to **View** | **Quick
    Definition** to evoke the action.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, *Figure 4**.35* shows the quick definition evoked on the call
    to `prime_check()` in our example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.35: Quick Definition shows the actual code definition for the function,
    which naturally includes the docstring if one is present](img/B19644_04_35.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.35: Quick Definition shows the actual code definition for the function,
    which naturally includes the docstring if one is present'
  prefs: []
  type: TYPE_NORMAL
- en: Overall PyCharm provides powerful options when it comes to dynamically viewing
    documentation and definitions within the IDE. Significant time and energy can
    be saved when programmers do not have to switch from their development environment
    to look for documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this chapter, we examined PyCharm’s features regarding various aspects
    of programming, including code analysis, code completion, refactoring, and documenting.
    In all of these processes, PyCharm’s intelligent code analyzer provides smart
    and convenient options for editing and fixing problems in your code in real time
    and in a dynamic way.
  prefs: []
  type: TYPE_NORMAL
- en: Aside from a wide number of options the intelligent code analyzer can support,
    PyCharm also allows users to customize the behavior of the analyzer to their liking.
    This can be achieved in various sections of the general settings. Overall, these
    support features look to improve your productivity as a developer in a way that
    is customized and beneficial to you.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we will focus on a particular aspect of programming: version
    control. We will learn about the specifics of the version control process with
    Git and how PyCharm supports and streamlines this process.'
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What levels of severity in terms of problems in a Python program are determined
    by PyCharm’s code analyzer?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are some common problems that PyCharm can detect and help fix via its intelligent
    code analyzer?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How is PyCharm’s code completion support different from others?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are some common code completion options that PyCharm offers?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the common causes for PyCharm’s code completion support not working?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are some common refactoring options that PyCharm offers?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Jolt Awards: *The Best Books For* *Developers* ([informationweek.com](http://informationweek.com))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Pylint home page: [https://www.pylint.org/](https://www.pylint.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Murphy’s laws on technology: [https://www.netlingo.com/word/murphys-laws-on-technology.php](https://www.netlingo.com/word/murphys-laws-on-technology.php)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Be sure to check out the companion website for the book at [https://www.pycharm-book.com](https://www.pycharm-book.com).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
