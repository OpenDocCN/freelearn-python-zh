- en: '11'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Legacy to Clean: Refactoring Python for Maintainability'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While previous chapters demonstrated Clean Architecture principles through greenfield
    development, real-world systems often present a different challenge. Existing
    applications, built under time pressure or before architectural best practices
    were established, frequently violate Clean Architecture’s fundamental principles.
    Their domain logic becomes tangled with frameworks, business rules mix with infrastructure
    concerns, and dependencies flow in all directions. Yet these systems often serve
    critical business needs and cannot simply be replaced.
  prefs: []
  type: TYPE_NORMAL
- en: Through our exploration of Clean Architecture transformation, we’ll discover
    how to systematically evolve legacy systems while maintaining their business value.
    We’ll see how Clean Architecture’s explicit boundaries and dependency rules provide
    clear guidance for improving existing systems, even under real-world constraints.
    You’ll learn how to identify architectural violations, establish clean boundaries
    incrementally, and maintain system stability during transformation.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you’ll understand how to apply Clean Architecture
    principles to legacy systems through staged implementation. You’ll be able to
    evaluate existing systems through Clean Architecture’s lens and implement bounded
    transformations that respect business constraints while maintaining system stability.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Evaluating and planning architectural transformation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Progressive Clean Architecture implementation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code examples presented in this chapter and throughout the rest of the book
    are tested with Python 3.13\. For brevity, most code examples in the chapter are
    only partially implemented. Complete versions of all examples can be found in
    the book’s accompanying GitHub repository at [https://github.com/PacktPublishing/Clean-Architecture-with-Python](https://github.com/PacktPublishing/Clean-Architecture-with-Python).
  prefs: []
  type: TYPE_NORMAL
- en: Evaluating and planning architectural transformation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Improving maintainability and reducing risk in complex applications requires
    a systematic approach to architectural evolution. Applications with tangled dependencies
    and blurred responsibilities consume disproportionate maintenance effort. Feature
    additions that should take days stretch into weeks; bug fixes trigger unexpected,
    persistent failures; and developer onboarding becomes painfully slow. These symptoms
    don’t just reflect technical issues; they also have direct business impacts that
    need addressing.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout previous chapters, we’ve seen how Clean Architecture naturally minimizes
    maintenance burdens through clear boundaries and explicit dependencies. Now, we
    can apply this same architectural lens to evaluate existing systems, identifying
    where violations occur and how to address them systematically. This doesn’t mean
    forcing an ideal Clean Architecture onto legacy systems all at once but, rather,
    taking a balanced, incremental approach that respects business constraints while
    progressively improving the system.
  prefs: []
  type: TYPE_NORMAL
- en: By analyzing legacy code through Clean Architecture principles, we can uncover
    natural system boundaries waiting to be established, domain concepts ready to
    be isolated, and interfaces eager to emerge. This evaluation forms the foundation
    for our transformation strategy, guiding decisions about what to change, when
    to change it, and how to minimize risk throughout the process. With each incremental
    improvement, we reduce both the maintenance burden and the instability associated
    with future changes, creating measurable business value beyond the technical improvements.
  prefs: []
  type: TYPE_NORMAL
- en: Evaluating through a Clean Architecture lens
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Transforming an existing system begins with evaluating its current state with
    respect to Clean Architecture principles. This evaluation isn’t about documenting
    every detail, but rather aims at identifying key architectural violations and
    gauging their business impact. Since wholesale transformation introduces unacceptable
    risk, we need a balanced approach that provides enough understanding to inform
    stakeholder discussions while enabling meaningful progress. This measured assessment
    creates the foundation for deeper collaborative analysis once initial stakeholder
    support is secured.
  prefs: []
  type: TYPE_NORMAL
- en: Conducting preliminary architectural analysis
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before engaging stakeholders, we need to conduct a targeted preliminary architectural
    analysis focused on identifying key technical issues that can be effectively communicated
    to non-technical audiences. This initial assessment isn’t exhaustive but provides
    enough insight to illustrate architectural problems in business-relevant terms.
  prefs: []
  type: TYPE_NORMAL
- en: 'A focused preliminary analysis might include:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Architectural inventory**: Identify major components and their interactions,
    creating a baseline understanding without documenting every detail.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dependency mapping**: Sketch high-level dependency flows that reveal the
    most problematic circular dependencies and framework coupling that violates Clean
    Architecture’s principles.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Framework penetration assessment**: Spotlight examples where framework code
    has significantly permeated business logic, focusing on areas with visible impact
    on maintenance or flexibility.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Domain logic dispersion**: Identify a few clear examples where business rules
    are fragmented across the codebase, particularly those affecting functionality
    that changes frequently.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, in analyzing a Python e-commerce system, we might discover that
    Django models contain critical business rules, validation logic is duplicated
    across multiple views, and payment processing code directly references native
    database queries. This preliminary analysis provides concrete examples that non-technical
    stakeholders can understand: *When we need to change how pricing works, we currently
    have to modify code in seven different places across three different modules*.'
  prefs: []
  type: TYPE_NORMAL
- en: This analysis serves as a communication tool, translated into business impact
    terms like increased time-to-market, elevated bug rates, and diminished ability
    to respond to changing requirements. By framing architectural issues in business
    terms before beginning the transformation, we create the foundation for stakeholder
    support and appropriate resource allocation.
  prefs: []
  type: TYPE_NORMAL
- en: This preliminary architectural assessment serves as an entry point for transformation,
    not an exhaustive blueprint. Focus on identifying just enough specific violations
    to engage stakeholders with credible examples that illustrate business impact.
    Resist the temptation to diagram every relationship at this stage. Your understanding
    will deepen substantially during the collaborative domain analysis that follows.
    The goal is to gather sufficient evidence to make the case for transformation
    while setting the stage for deeper exploration with stakeholders.
  prefs: []
  type: TYPE_NORMAL
- en: Building stakeholder alignment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the preliminary architectural analysis complete and key issues identified,
    the next step is communicating these findings to stakeholders and securing initial
    buy-in for transformation. This initial engagement isn’t about getting final approval
    for specific changes, but rather aims to build shared awareness of architectural
    issues and establish support for a more collaborative discovery process. The insights
    gained from our analysis must now be translated into business-impact terms that
    resonate with different stakeholder groups, creating the foundation for the deeper
    collaborative analysis that will follow.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is involving the right stakeholders:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Engineering teams** who understand the technical details and implementation
    constraints'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Product owners** who can articulate business priorities and validate the
    value of architectural changes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Operations personnel** who manage system deployment and reliability concerns'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**End users** who can share pain points related to system stability and feature
    delivery'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The scope of stakeholder involvement should correspond directly to the scale
    of transformation planned. Smaller refactorings might only require coordination
    with your immediate team, while system-wide architectural overhauls may need engagement
    all the way up to the CTO or VP of Engineering.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have stakeholders aligned around a shared transformation vision, the
    next critical step is establishing baseline measurements that will track progress
    and demonstrate value. These metrics create accountability and provide clear evidence
    of improvement throughout the transformation journey:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Maintenance metrics**: time spent on bug fixes, feature delivery lead time'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Quality indicators**: defect rates, test coverage, static analysis scores'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Team effectiveness**: developer onboarding time, deployment frequency'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Business outcomes**: customer satisfaction, feature adoption rates'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These metrics serve multiple purposes throughout the transformation. Initially,
    they justify the effort and help secure leadership support. As work progresses,
    they validate effectiveness and highlight areas needing adjustment. They also
    help define what *done* means for the transformation, recognizing that the goal
    is sustainable improvement rather than architectural perfection. Most importantly,
    metrics translate technical improvements into business value language, creating
    a feedback loop that keeps the transformation aligned with both technical goals
    and business priorities.
  prefs: []
  type: TYPE_NORMAL
- en: Deeper domain analysis
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Business domains naturally evolve over time, making architectural transformation
    an ideal opportunity to realign systems with current business needs. After securing
    initial stakeholder support, the next step is deepening our understanding through
    collaborative domain discovery techniques. This phase connects our technical insights
    with business domain knowledge, identifying meaningful boundaries while solidifying
    stakeholder buy-in through active involvement. Where our preliminary analysis
    focused on technical issues, collaborative discovery bridges these findings with
    evolving business requirements, ensuring the transformed system not only has better
    architecture but also better serves current needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Several collaborative approaches can help bridge technical understanding with
    domain expertise:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Event storming workshops** to map business processes and domain events ([https://www.eventstorming.com/](https://www.eventstorming.com/))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Domain storytelling sessions** where stakeholders narrate key workflows ([https://domainstorytelling.org/](https://domainstorytelling.org/))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Context mapping exercises** to identify system boundaries and integration
    points ([https://contextmapper.org/](https://contextmapper.org/))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Among these approaches, **event storming** stands out as particularly valuable
    for Clean Architecture transformations. It brings together stakeholders in facilitated
    workshops to validate domain understanding and identify architectural boundaries.
    Participants use color-coded sticky notes on a shared modeling space, creating
    a visual timeline of business processes. The color coding intentionally maps to
    Clean Architecture layers: orange domain events represent core entities at the
    center of the architecture, blue commands align with use cases in the Application
    layer, and purple business rules reflect domain rules that remain independent
    of external concerns. Typical domain events include *Order Placed*, while commands
    might include actions like *Process Payments*. This visual approach makes architectural
    boundaries tangible to all stakeholders, helping identify natural separation points
    when transforming legacy systems. While specific color schemes may vary between
    teams, maintaining a consistent visual language is what matters most.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.1: Event storming visualization for an e-commerce system, showing
    domain events, commands, actors, and potential bounded contexts](img/B31577_11_1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.1: Event storming visualization for an e-commerce system, showing
    domain events, commands, actors, and potential bounded contexts'
  prefs: []
  type: TYPE_NORMAL
- en: This collaborative approach builds directly on the domain modeling principles
    from [*Chapter 4*](Chapter_04.xhtml#_idTextAnchor091), applying them to discover
    boundaries in existing systems. The same concepts of Entities, Value Objects,
    and Aggregates now help identify what the legacy system *should* have separated
    but didn’t. For example, an event storming session might reveal that the *Order
    Processing* domain contains distinct events like *Order Placed*, *Payment Approved*,
    *Inventory Reserved*, and *Shipment Created*. Be sure to separate business concerns
    that could be cleanly divided into discrete use cases rather than handled by a
    monolithic Order Controller.
  prefs: []
  type: TYPE_NORMAL
- en: The resulting visual artifacts serve as powerful communication tools, helping
    stakeholders see how architectural boundaries translate to business benefits like
    faster delivery or reduced errors. This shared language often reveals insights
    that technical analysis alone would miss, such as Order and Payment processing
    having different change patterns that indicate natural separation points. With
    these boundaries identified through stakeholder collaboration, we can move from
    discovery to action, translating insights into a prioritized roadmap for architectural
    improvement.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a staged implementation roadmap
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With architectural boundaries identified and prioritized based on business value,
    the focus now shifts to tactical execution planning. Transforming legacy systems
    isn’t just about knowing what to change, it’s about organizing the work into manageable,
    low-risk increments that maintain system stability while progressively improving
    architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Effective transformation planning requires breaking down the work into distinct
    stages with clear deliverables. Rather than overwhelming teams with a massive
    refactoring effort, a staged implementation creates natural checkpoints to validate
    progress, gather feedback, and adjust course as needed.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.2: Clean Architecture transformation stages showing progression
    from foundation to optimization](img/B31577_11_2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.2: Clean Architecture transformation stages showing progression from
    foundation to optimization'
  prefs: []
  type: TYPE_NORMAL
- en: The **foundation stage** establishes core domain concepts and abstractions that
    serve as building blocks for later work. This often begins with creating clean
    entity models alongside existing implementations and defining interfaces for repositories
    and services. By starting with these core elements, teams establish a clear target
    architecture while minimizing initial changes to the running system.
  prefs: []
  type: TYPE_NORMAL
- en: As the foundation takes shape, the **interface stage** focuses on implementing
    adapters that bridge the clean core and external concerns. This includes building
    repository implementations that work with existing databases, creating service
    adapters for third-party integrations, and developing controllers that translate
    between frameworks and the domain. These adapters create a protective layer around
    the emerging Clean Architecture.
  prefs: []
  type: TYPE_NORMAL
- en: The **integration stage** gradually migrates existing functionality to the new
    architecture. Teams replace direct database access with repository implementations,
    substitute hard-coded business rules with domain services, and integrate new components
    with legacy systems through appropriate adapters. This stage often progresses
    feature by feature or domain by domain, allowing for controlled, incremental changes.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the **optimization stage** refines and enhances the architecture based
    on real-world experience. Teams address performance considerations in repository
    implementations, expand test coverage, and improve error handling and resilience
    patterns. This stage acknowledges that the target architecture isn’t achieved
    in one pass, but rather through continuous refinement.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this staged approach, the baseline metrics established earlier serve
    a crucial role in validating progress and communicating the transformation’s impact.
    By tracking metrics such as maintenance time, defect rates, and feature delivery
    speed before, during, and after each transformation stage, teams can demonstrate
    tangible improvements and adjust their approach based on actual results rather
    than assumptions. These metrics also help teams identify when they’ve reached
    acceptable levels of architectural improvement, allowing organizations to balance
    architectural refinement with ongoing business needs.
  prefs: []
  type: TYPE_NORMAL
- en: Approaches for doing the transformation work
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The execution complexity of architectural transformation requires careful logistics
    planning beyond the technical aspects. Teams must decide how to organize the work
    alongside ongoing feature development and maintenance. Several approaches are
    worth considering:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Dedicated transformation iterations** allocate specific sprint cycles exclusively
    to architectural work. This approach provides focused time for complex refactoring
    but may delay feature delivery. It works well for components that need significant
    changes but which can be completed within one or two iterations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Parallel transformation tracks** create dedicated teams focused on architectural
    improvements while other teams continue feature development. This approach maintains
    delivery velocity but requires careful coordination to prevent conflicts. It’s
    particularly effective for larger systems where transformation will span multiple
    quarters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Opportunity-based transformation** integrates architectural improvements
    with feature work in related areas. As new features touch a component, teams refactor
    it toward Clean Architecture. This approach minimizes isolated refactoring risk
    but makes progress dependent on feature priorities and may result in uneven transformation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most successful transformations combine these approaches based on business priorities
    and team structure. Critical components might warrant dedicated efforts, while
    less frequently changed areas can evolve through opportunity-based transformation.
    The key is to explicitly plan how each component will be transformed rather than
    assume a one-size-fits-all approach.
  prefs: []
  type: TYPE_NORMAL
- en: Navigating the in-flight transformation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'During transformation, the system will temporarily contain a mixture of old
    and new architectural approaches. Careful planning of these transitional states
    is crucial to maintain system stability. For each component being transformed,
    the plan should address:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Parallel operation strategy**: How old and new implementations will coexist'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Verification approach**: Methods to confirm functional equivalence'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cutover criteria**: Clear conditions for switching to the new implementation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rollback procedures**: Safety mechanisms if issues emerge'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comprehensive testing strategies are essential during these transitions. Regression
    test suites validate that new implementations maintain existing functionality,
    while interface compatibility tests ensure that transformed components correctly
    integrate with the broader system. **Feature flags** provide an effective cutover
    mechanism, allowing teams to selectively enable new implementations for specific
    users or scenarios while maintaining the ability to instantly revert if issues
    arise.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to recognize that while this section outlines a general approach
    to transformation planning, every legacy system presents unique challenges based
    on its size, complexity, technology stack, and business constraints. The scale
    of work will differ dramatically between systems, and teams should adapt these
    guidelines to their specific circumstances. Additional research into techniques
    specific to your technology stack or domain will help you tailor this approach
    to your needs. The key is to maintain a pragmatic mindset, taking Clean Architecture
    principles as a guide rather than a rigid prescription.
  prefs: []
  type: TYPE_NORMAL
- en: With a comprehensive transformation plan that addresses both the technical changes
    and their implementation logistics, teams are well-positioned to begin the actual
    transformation work. The subsequent sections will explore concrete techniques
    for implementing these plans, starting with establishing core domain boundaries
    and progressively refactoring toward a Clean Architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Progressive Clean Architecture implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With our evaluation complete and transformation strategy established, we now
    turn to practical implementation. This section demonstrates how to progressively
    transform a legacy system through carefully staged improvements that deliver the
    greatest architectural value. Rather than attempting to cover the transformation
    process exhaustively, which would require a book of its own, we’ll highlight strategic
    refactoring patterns that establish Clean Architecture boundaries incrementally
    while maintaining system stability.
  prefs: []
  type: TYPE_NORMAL
- en: The following examples, drawn from an order processing system rather than our
    previous task management application, illustrate how to apply Clean Architecture
    principles to legacy code in a practical manner. Each implementation stage builds
    on the previous one, gradually moving from tangled dependencies toward clean separation
    of concerns, from establishing domain boundaries to creating interfaces that bridge
    old and new architectures.
  prefs: []
  type: TYPE_NORMAL
- en: Initial system analysis
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this hypothetical scenario, you find yourself responsible for an order processing
    subsystem that has evolved over several years. What started as a simple Flask
    application for managing customer orders has grown to include payment processing
    and basic order fulfillment. While functionally complete, the codebase exhibits
    significant technical debt, with tangled dependencies, blurred responsibilities,
    and architectural inconsistencies that make even simple changes risky and time-consuming.
  prefs: []
  type: TYPE_NORMAL
- en: 'The team faces recurring issues that highlight the architectural problems:
    a simple change to the order calculation logic requires modifications in three
    different files; adding a new payment method takes three weeks instead of three
    days; and every deployment comes with the fear of unexpected side effects. Most
    telling, new developers need months to become productive, frequently breaking
    functionality in seemingly unrelated areas when making changes.'
  prefs: []
  type: TYPE_NORMAL
- en: Building on the preliminary architectural analysis and domain discovery phases
    described in the first section of this chapter, we’ve identified key architectural
    issues to address in our transformation. Let’s begin by examining the current
    state of the system through the lens of Clean Architecture, identifying specific
    violations and architectural boundaries that need reinforcement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s examine one such file that handles order creation—a central piece of
    the system’s functionality and a prime candidate for our transformation efforts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The beginning of this file already reveals several architectural issues. The
    route handler imports SQLite and requests directly, establishing hard dependencies
    on these specific implementations. The `get_db_connection` function creates a
    direct connection to a specific database, with no abstraction layer. These structural
    choices violate Clean Architecture’s Dependency Rule by allowing outer-layer concerns
    (web framework, database) to penetrate into business logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Continuing down the `create_order` function, let’s examine how the route handler
    processes orders:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This middle section demonstrates several Clean Architecture violations. Core
    business logic like inventory checking and price calculation is mixed directly
    with database access. The payment processing logic makes direct HTTP calls to
    an external service, creating a hard dependency that would be difficult to test
    or change. These implementation details should be hidden behind interfaces, in
    accordance with Clean Architecture principles, not exposed directly in business
    logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, closing out the `create_order` function, we complete the order processing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The code analysis reveals fundamental architectural problems throughout this
    handler. Direct SQL statements are intertwined with business logic, HTTP responses,
    and external service calls, which are all crammed into a single function with
    no separation of concerns. This structure violates the Single Responsibility Principle
    we discussed in [*Chapter 2*](Chapter_02.xhtml#_idTextAnchor040) and makes changes
    extremely risky, as modifications in one area frequently affect seemingly unrelated
    functionality.
  prefs: []
  type: TYPE_NORMAL
- en: The system lacks the rich domain model we established in [*Chapter 4*](Chapter_04.xhtml#_idTextAnchor091)
    as orders and products exist only as database records and dictionaries rather
    than as proper entities with encapsulated behavior and business rules.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.3: Entangled responsibilities in the current order processing handler](img/B31577_11_3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.3: Entangled responsibilities in the current order processing handler'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 11.3* illustrates how a single Flask route handler encompasses multiple
    responsibilities that should be separated according to Clean Architecture principles.
    The business logic is directly connected to infrastructure concerns such as database
    connections and external APIs, violating the Dependency Rule we explored in [*Chapter
    1*](Chapter_01.xhtml#_idTextAnchor015).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on our analysis, we’ve identified key architectural issues to address
    in our transformation:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Boundary violations**: The route handler crosses multiple architectural boundaries,
    mixing web, business logic, and infrastructure concerns'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Missing domain model**: We need to establish proper domain entities like
    Order and Product as the core of our system'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dependency inversion needed**: Direct infrastructure dependencies should
    be replaced with abstractions following the principles from [*Chapter 2*](Chapter_02.xhtml#_idTextAnchor040)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Interface separation required**: Clear interfaces between architectural layers
    will help maintain proper boundaries'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are key architectural issues in our order creation process; we can see
    a system that evolved without architectural guidance. Business logic, data access,
    and external services are tightly coupled, with no clear boundaries between concerns.
    The system works, but its structure makes it increasingly difficult to maintain,
    extend, or test.
  prefs: []
  type: TYPE_NORMAL
- en: With this understanding of the current system, we’re now ready to begin our
    transformation journey. We’ll start by establishing a clean domain model in the
    next section, creating proper boundaries between layers as we progressively refactor
    toward a Clean Architecture.
  prefs: []
  type: TYPE_NORMAL
- en: 'Stage 1: establishing domain boundaries'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Having analyzed our legacy system, we begin our transformation by establishing
    a clean domain model that will serve as our architectural foundation. Starting
    with the Domain layer provides a stable core around which we can progressively
    rebuild the outer layers of our system.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our order processing system, we need to extract the implicit domain concepts
    buried in our database queries and controller logic. The most critical entities
    in our system appear to be:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Order**: The central business entity'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Customer**: The buyer placing the order'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Product**: Items being purchased'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**OrderItem**: The association between orders and products'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s begin by implementing the `Order` entity and its related value objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Here we’ve defined an `OrderStatus` enum to replace the string constants previously
    used throughout the code. We’ve also created an `OrderItem` value object to represent
    the relationship between orders and products. This approach aligns with the value
    object pattern we explored in [*Chapter 4*](Chapter_04.xhtml#_idTextAnchor091),
    creating immutable objects that represent important domain concepts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s implement the `Order` entity itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Our `Order` entity now properly encapsulates core business concepts that were
    previously scattered throughout the codebase. We’ve implemented methods that enforce
    business rules, such as validating state transitions when marking an order as
    paid. These validations were previously buried in controller logic but now reside
    in their proper home within the entity itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to create the remaining domain entities to complete our core model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `Product` entity now encapsulates inventory management logic that was previously
    spread across controller methods. It enforces business rules such as preventing
    negative stock or excessive withdrawals. This is an example of the *tell, don’t
    ask* principle that helps maintain domain integrity.
  prefs: []
  type: TYPE_NORMAL
- en: 'With our core domain entities defined, we need to create abstractions for the
    supporting services and repositories. Following the Dependency Inversion Principle
    we’ll define interfaces that the domain needs without coupling to specific implementations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This abstract `OrderRepository` defines the operations our Domain layer needs
    without specifying how they’re implemented. We’ll create similar interfaces for
    `ProductRepository` and other necessary repositories. These abstractions are a
    crucial element of Clean Architecture, as they allow our Domain layer to remain
    independent of specific persistence mechanisms.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you recall the task management system from previous chapters, we established
    similar repository interfaces such as `TaskRepository` in [*Chapter 5*](Chapter_05.xhtml#_idTextAnchor123).
    Both follow the same pattern: defining abstract methods that domain components
    require without specifying implementation details. This consistency demonstrates
    how Clean Architecture’s principles apply across different domains and applications,
    creating a reliable pattern for maintaining proper boundaries.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s define service interfaces for external operations like payments
    and notifications:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'With these core domain components defined, we’ve created a clean foundation
    for our system. The business rules and concepts that were previously scattered
    across controllers and utility functions now have a proper home in a well-structured
    domain model. This transformation provides several immediate benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Business rules centralization**: Rules like *cannot mark a non-CREATED order
    as PAID* are now explicitly defined in the domain model'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Improved testability**: Domain entities and services can be tested in isolation
    without requiring database connections or web frameworks'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Clearer boundaries**: The separation between core business concepts and infrastructure
    concerns is now explicit'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Richer domain model**: We’ve moved from anemic database records to a rich
    domain model with behavior'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s take a moment to review this new Domain layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.4: The newly established domain model with clean boundaries](img/B31577_11_4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.4: The newly established domain model with clean boundaries'
  prefs: []
  type: TYPE_NORMAL
- en: 'This diagram illustrates our first major transformation step: establishing
    a proper Domain layer with clean boundaries. We’ve created entities, value objects,
    and service interfaces that encapsulate our core business concepts and rules.
    Comparing this with *Figure 11.2*, we can see significant progress toward untangling
    the responsibilities that were previously mixed in our legacy controller implementation.'
  prefs: []
  type: TYPE_NORMAL
- en: Incremental integration strategies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In real-world transformations, a common pitfall is attempting to implement the
    entire Clean Architecture in isolation before integration. This *big bang release*
    approach introduces significant risk since by the time integration occurs, the
    production system may have evolved substantially, creating complex merge conflicts
    and unexpected behavior changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'To mitigate this risk, several incremental integration strategies can be employed:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Adapter pattern**: Create adapters that bridge legacy components and new
    domain entities, allowing them to coexist within the running system. This enables
    gradual adoption without disrupting existing functionality.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Parallel implementation**: Implement new functionality using Clean Architecture
    alongside legacy code, with feature flags controlling which implementation handles
    requests. This provides an easy rollback mechanism if issues arise.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Strangler Fig pattern**: Incrementally replace pieces of the legacy application
    while maintaining the same external interfaces, gradually supplanting the old
    implementation until it can be safely removed ([https://martinfowler.com/bliki/StranglerFigApplication.html](https://martinfowler.com/bliki/StranglerFigApplication.html)).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Shadow mode**: Run new implementations alongside the production code by use
    of a proxy that duplicates all requests. This gives the new implementation the
    opportunity to process its copy of the request and we compare the outputs with
    the legacy system. This validates behavior without affecting users.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Throughout this incremental transformation, comprehensive **regression testing**
    is absolutely essential. Before making any architectural changes, establish a
    thorough test suite that captures existing system behavior. These tests serve
    multiple purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: They verify that refactoring hasn’t broken existing functionality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They document current system behavior for reference
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They provide confidence to stakeholders that the transformation is proceeding
    safely
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we discussed in [*Chapter 8*](Chapter_08.xhtml#_idTextAnchor192), testing
    provides crucial safety nets during architectural transformation. For our order
    processing system, we would establish **end-to-end tests** that verify complete
    order flows before beginning our transformation, then supplement these with more
    granular tests as we establish clean architectural boundaries.
  prefs: []
  type: TYPE_NORMAL
- en: By adopting these incremental strategies and prioritizing regression testing,
    we can transform our system while maintaining stability and continuing to deliver
    business value. In the next section, we’ll begin implementing the production integration
    approach described above, building on our domain model by implementing the Interface
    Adapters layer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Stage 2: Interface layer implementation'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With our domain entities and interfaces established, we now face a critical
    transition challenge: integrating this clean foundation with our existing codebase.
    Unlike greenfield development, transformation requires us to evolve our system
    incrementally while maintaining continuous operation. The **Interface layer**
    provides our first opportunity to bridge old and new architectures.'
  prefs: []
  type: TYPE_NORMAL
- en: Identifying transformation boundaries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first step in our transformation is identifying viable seams where we can
    introduce clean interfaces without overly disrupting the existing system. Looking
    back at our legacy controller, the order creation process stands out as a natural
    boundary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This controller method represents a self-contained workflow with clear inputs
    and outputs, making it an ideal candidate for our initial transformation. Before
    modifying this code, we need to establish comprehensive test coverage that captures
    its current behavior. These tests will serve as our safety net during refactoring,
    ensuring we maintain functionality while improving architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: With tests in place, we can begin implementing the Interface layer components
    that will bridge our clean domain model and the existing infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing repository adapters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our first step is creating **repository adapters** that satisfy our clean domain
    interfaces while interacting with the existing database schema. This crucial component
    bridges our domain entities and legacy infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This repository adapter plays a vital role in our transformation strategy. You
    may recall from [*Chapter 6*](Chapter_06.xhtml#_idTextAnchor144) that we introduced
    similar repository implementations for our task management system. Like those
    examples, this adapter implements our clean `OrderRepository` interface (from
    *Stage 1*) while handling the details of our existing database schema. The adapter
    translates between domain entities and database records, managing the impedance
    mismatch between our rich domain model and the flat relational structure.
  prefs: []
  type: TYPE_NORMAL
- en: We would also implement a similar `SQLiteProductRepository` that follows the
    same pattern, implementing a clean domain interface while interacting with the
    existing database schema. These repository implementations handle all database
    access details, connection management, and error handling, providing a clean interface
    to the rest of our architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, we would implement adapters for external services like payment
    processing. These service adapters would follow the same pattern, implementing
    our clean domain interfaces while encapsulating the details of external service
    interactions. For brevity, we won’t show these implementations here, but the complete
    code is available in the book’s GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: With these infrastructure adapters in place, we now have a bridge between our
    clean domain model and the legacy infrastructure. This enables us to implement
    use cases that work with proper domain entities while seamlessly interacting with
    the existing database and external services via interfaces versus interacting
    directly with concrete implementations.
  prefs: []
  type: TYPE_NORMAL
- en: Building clean use cases
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that we have repository and service adapters that connect to our existing
    infrastructure, we can implement the use cases that orchestrate our business logic.
    In [*Chapter 5*](Chapter_05.xhtml#_idTextAnchor123), we established that use cases
    serve as application-specific business rules that coordinate domain entities to
    fulfill specific user requirements. Following this pattern, let’s look at the
    order creation use case that will replace our tangled legacy implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `execute` method of our use case begins by creating an `Order` entity and
    adds items to it, checking inventory availability in the process. Note how it
    works with proper domain entities rather than raw database records.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s now examine the remainder of the `execute` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The second half of our `execute` method continues the order creation process
    by handling payment processing, updating the order status, and saving the completed
    order.
  prefs: []
  type: TYPE_NORMAL
- en: 'This use case demonstrates Clean Architecture’s separation of concerns in action.
    It orchestrates the order creation process by:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating an `Order` entity with basic information
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adding items to the order, checking inventory
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Processing payment
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Updating the order status and saving it
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Each step interacts with the domain model through well-defined interfaces, without
    knowledge of the underlying infrastructure. The use case depends on abstract `OrderRepository`,
    `ProductRepository`, and `PaymentService` interfaces, not on concrete implementations.
  prefs: []
  type: TYPE_NORMAL
- en: Notice how the business rules are now explicit and centralized in this use case.
    Inventory checking, payment processing, and order status management all flow through
    a clean, organized process rather than being scattered across controller methods
    and utility functions. This clarity makes the code more maintainable and adaptable
    to changing requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing clean controllers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'With our repositories and use cases in place, we now implement **controllers**
    that bridge our web framework and application core. As we established in [*Chapter
    6*](Chapter_06.xhtml#_idTextAnchor144), controllers serve as translation layers
    at the boundary of our architecture, converting external request formats into
    inputs our use cases can process. These controllers maintain the separation between
    our application core and delivery mechanisms, ensuring that web-specific concerns
    don’t penetrate our Clean Architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This controller shows Clean Architecture boundaries at work, functioning as
    a translation layer between external requests and our domain operations. The heart
    of this controller is the single line `order = self.create_use_case.execute(request)`,
    which represents the critical boundary between our Interface layer and application
    core. Notice how the controller doesn’t reference Flask, HTTP status codes, or
    JSON formatting. These web-specific concerns are handled at the framework boundary,
    maintaining a clean separation between our application logic and delivery mechanism.
    This framework independence allows our controller to remain focused on its core
    responsibility, transforming external requests into domain operations and translating
    results back to a format suitable for the caller.
  prefs: []
  type: TYPE_NORMAL
- en: 'Stage 3: integration strategy: bridging legacy and clean implementations'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now comes the crucial step: integrating our clean implementation with the existing
    system. Rather than immediately replacing the entire legacy route handler, we’ll
    modify it to delegate to our clean controller using the adapter pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The key portion of this modification is the feature flag conditional. When `USE_CLEAN_ARCHITECTURE`
    is enabled, we delegate order processing to our new controller, which then invokes
    the clean use case. This creates a controlled pathway into our Clean Architecture
    implementation without disturbing the existing code path. The feature flag gives
    us a simple mechanism to toggle between implementations, either globally or for
    specific requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'This modified route handler demonstrates several key transformation patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Feature flag control**: We use a configuration setting to determine which
    implementation processes the request, allowing us to gradually transition traffic.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Consistent interfaces**: Both implementations produce identical response
    formats, ensuring a seamless transition from the user’s perspective.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Incremental migration**: The legacy code remains fully functional, serving
    as a fallback if issues arise with the clean implementation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Exception translation**: We map domain-specific exceptions to appropriate
    HTTP responses at the framework boundary.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When integrating with specific frameworks like Flask, we must attend to framework-specific
    details at the system boundaries. In the case of Flask, we need to configure our
    dependency injection container, register our Clean Architecture components, and
    establish the feature flagging mechanism. We create a central configuration point
    that instantiates all necessary components (repositories, services, use cases,
    and controllers) and wires them together according to Clean Architecture’s dependency
    rules. This configuration happens at application startup, keeping all framework-specific
    initialization code at the system’s edge where it belongs. We saw this in action
    in our task management application in [*Chapter 7*](Chapter_07.xhtml#_idTextAnchor168).
  prefs: []
  type: TYPE_NORMAL
- en: Incremental transformation approach
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: During this transformation process, comprehensive testing is absolutely essential.
    We leverage our regression test suite to ensure that refactoring hasn’t broken
    existing functionality. These tests verify both the legacy implementation and
    our new Clean Architecture components, providing confidence that the transformation
    maintains functional parity.
  prefs: []
  type: TYPE_NORMAL
- en: Each step of our transformation is carefully validated before proceeding to
    the next. We don’t move forward until we’ve verified that our changes maintain
    system behavior and stability. This incremental approach minimizes risk and allows
    us to deliver value continuously throughout the transformation process.
  prefs: []
  type: TYPE_NORMAL
- en: At a high level, our approach aligns with the Strangler Fig pattern ([https://martinfowler.com/bliki/StranglerFigApplication.html](https://martinfowler.com/bliki/StranglerFigApplication.html)),
    where we gradually replace pieces of the legacy application while maintaining
    the same external interfaces. This approach minimizes risk by allowing incremental
    validation and rollback if needed.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.5: Current system architecture showing parallel implementations](img/B31577_11_5.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.5: Current system architecture showing parallel implementations'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 11.5* illustrates our current architectural state, with both legacy
    and clean implementations coexisting in the system. The legacy components represent
    the tangled, unstructured code that directly mixes business logic with infrastructure
    concerns. In contrast, the Clean Architecture implementation shows proper separation
    of concerns with distinct layers and well-defined interfaces.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Through this incremental implementation approach, we’ve made significant progress
    in our transformation journey:'
  prefs: []
  type: TYPE_NORMAL
- en: We’ve established a clean domain model with proper entities and value objects
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We’ve implemented repository adapters that bridge our domain model and the existing
    database
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We’ve created use cases that orchestrate the business logic using our domain
    model
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We’ve built controllers that translate between web requests and our domain language
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We’ve integrated our clean implementation alongside the legacy code using the
    adapter pattern
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Through this incremental implementation approach, we’ve demonstrated how to
    transform a legacy system using Clean Architecture principles while maintaining
    system stability and functionality throughout the process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Stage 4: optimization stage'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While our example has focused primarily on the foundation, interface, and integration
    stages, a complete transformation would eventually include an optimization stage.
    This final phase typically involves performance tuning, expanded test coverage,
    and improved error-handling patterns based on real-world usage.
  prefs: []
  type: TYPE_NORMAL
- en: Rather than providing detailed examples of this stage, we’ll note that optimization
    should be approached with the same incremental mindset. Teams should prioritize
    optimizations that deliver the greatest business value, gradually removing feature
    flags as clean implementations prove stable, and ultimately decommissioning legacy
    code paths entirely.
  prefs: []
  type: TYPE_NORMAL
- en: The optimization stage acknowledges that architectural transformation is not
    a one-time effort but rather a continuous refinement process that balances technical
    excellence with business priorities. Teams should define clear metrics for when
    *good enough* has been achieved, avoiding the trap of endless perfectionism.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we’ve explored how to apply Clean Architecture principles to
    legacy systems through systematic transformation. We began by examining how to
    evaluate existing systems through Clean Architecture’s lens, identifying architectural
    violations, and creating a staged approach to transformation.
  prefs: []
  type: TYPE_NORMAL
- en: We established a framework for building stakeholder alignment by translating
    technical debt into business impact terms and gathering deeper domain understanding
    through collaborative techniques like event storming. This collaborative approach
    directly informed our staged implementation plan, grounding our architectural
    decisions in business priorities.
  prefs: []
  type: TYPE_NORMAL
- en: Through our order processing example, we demonstrated a progressive implementation
    approach that maintains system stability while establishing clean architectural
    boundaries. We started with the Domain layer, creating proper entities and value
    objects that encapsulate business rules previously scattered throughout the codebase.
    We then implemented repository interfaces that protect our domain from infrastructure
    details, followed by use cases that orchestrate business operations.
  prefs: []
  type: TYPE_NORMAL
- en: The Interface Adapters layer provided a bridge between our clean implementation
    and legacy code, enabling incremental adoption through feature flags and adapter
    patterns. This staged approach allowed us to validate our transformation while
    minimizing risk, demonstrating how Clean Architecture can be applied pragmatically
    to real-world systems.
  prefs: []
  type: TYPE_NORMAL
- en: By following these transformation patterns, you can systematically improve architectural
    quality in existing systems, reducing maintenance costs and increasing adaptability
    while continuing to deliver business value. This approach embodies Clean Architecture’s
    core principles while recognizing the practical constraints of evolving production
    systems.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Working Effectively with Legacy Code* ([https://www.oreilly.com/library/view/working-effectively-with/0131177052/](https://www.oreilly.com/library/view/working-effectively-with/0131177052/))
    by Michael Feathers. Provides techniques for working with existing codebases,
    including strategies for safely introducing tests and making incremental improvements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Event Storming* ([https://www.eventstorming.com](https://www.eventstorming.com)).
    A great resource for learning more about and planning event storming sessions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
