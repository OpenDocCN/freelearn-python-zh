<html><head></head><body>
        

                            
                    <h1 class="header-title">Creating Layouts</h1>
                
            
            
                
<p class="mce-root">This chapter will finalize our understanding of the concepts related to arranging and positioning items in our application. If elements have a fixed size and position and you need to resize the window, these elements will not resize accordingly and there will be a graphical representation fault. Also, if the application will be used with devices that have different resolutions (as is the case in real life), the results of the graphical visualization will vary (and this tends to err on the bad side). The construction of layouts for the items is one of the basic instruments for making an application independent from the resizing of windows and the native device resolution. Layouts play the role of geometry managers in applications with GUIs. </p>
<p class="mce-root">In the previous examples of application development, layouts have already been used, and we have some insight into this mechanism. This chapter will complete our understanding of the following topics:</p>
<ul>
<li>Layouts</li>
<li>Box layouts</li>
<li>Grid layout</li>
<li>Form layout</li>
<li>Stacked layout</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Layouts</h1>
                
            
            
                
<p>As we have seen in the examples, layouts are a convenient way to arrange items in an application, such as the arrangement of widgets and resizing items automatically according to device resolution, available space, size, and so on. In this section, we will cover the basics of layouts in the Qt library.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">QLayout</h1>
                
            
            
                
<p>This is an abstract base class for implementing layouts with the Qt framework. All the layouts in this chapter inherit the functionality of this class; <kbd>QLayout</kbd> is included in the <kbd>QtWidgets</kbd> module and can be reimplemented in a custom class. The syntax of the reimplementation is as follows:</p>
<pre>...<br/>class ULayout(QtWidgets.QLayout):<br/><br/>    def __init__(self, parent=None):<br/>        super(ULayout, self).__init__(parent)<br/>...</pre>
<p>The <kbd>QLayout</kbd> class enhances functionality with the following functions.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">add</h1>
                
            
            
                
<p>These functions add elements to the layout:</p>
<p><kbd>addChildLayout(QtWidgets.QLayout)</kbd>: This adds a sub-layout, specified in the parameter, as a child layout for this layout.</p>
<p><kbd>addChildWidget(QtWidgets.QWidget)</kbd>: This adds a managed widget, specified in the parameter, to this layout.</p>
<p><kbd>addItem(QtWidgets.QLayoutItem)</kbd>: This adds an item, specified in the parameter, to this layout.</p>
<p><kbd>addWidget(QtWidgets.QWidget)</kbd>: This adds the widget, specified in the parameter, to this layout.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">set</h1>
                
            
            
                
<p>These functions set the parameters/properties of the layout:</p>
<p><kbd>setAlignment(QtWidgets.QWidget, QtCore.Qt.Alignment)</kbd>: This sets the alignment (the second parameter) for the widget (the first parameter).</p>
<p><kbd>setAlignment(QtWidgets.QLayout, QtCore.Qt.Alignment)</kbd>: This sets the alignment (the second parameter) for the layout (the first parameter).</p>
<p><kbd>setContentsMargins(QtCore.QMargins)</kbd>: This sets the margins, specified in the parameter, that will be used around this layout.</p>
<p><kbd>setContentsMargins(int, int, int, int)</kbd>: This sets the margins for the left (the first parameter), top (the second parameter), right (the third parameter), and bottom (the fourth parameter) sides that will be used around this layout.</p>
<p><kbd>setEnabled(bool)</kbd>: If the parameter is <kbd>True</kbd>, it enables this layout.</p>
<p><kbd>setMenuBar(QtWidgets.QWidget)</kbd>: This sets the menu bar widget, specified in the parameter, at the top of the parent widget.</p>
<p><kbd>setSizeConstraint(QtWidgets.QLayout.SizeConstraint)</kbd>: This sets the resize mode, specified in the parameter, for this layout. The available resizing modes are as follows:</p>
<ul>
<li><kbd>QtWidgets.QLayout.SetDefaultConstraint</kbd>—<kbd>0</kbd>: The minimum size of the widget is set to <kbd>minimumSize()</kbd>.</li>
<li><kbd>QtWidgets.QLayout.SetNoConstraint</kbd>—<kbd>1</kbd>: The widget is not constrained.</li>
<li><kbd>QtWidgets.QLayout.SetMinimumSize</kbd>—<kbd>2</kbd>: The minimum size of the widget is set to <kbd>minimumSize()</kbd>.</li>
<li><kbd>QtWidgets.QLayout.SetFixedSize</kbd>—<kbd>3</kbd>: The widget is set to <kbd>sizeHint()</kbd> and cannot be resized.</li>
<li><kbd>QtWidgets.QLayout.SetMaximumSize</kbd>—<kbd>4</kbd>: The maximum size of the widget is set to <kbd>maximumSize()</kbd>.</li>
<li><kbd>QtWidgets.QLayout.SetMinAndMaxSize</kbd>—<kbd>5</kbd>: The maximum and minimum size of the widget are set to <kbd>maximumSize()</kbd> and <kbd>minimumSize()</kbd>.</li>
</ul>
<p><kbd>setSpacing(int)</kbd>: This sets the spacing between widgets inside this layout.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">is</h1>
                
            
            
                
<p>This function returns a Boolean value (<kbd>bool</kbd>) related to this layout's state:</p>
<p><kbd>isEnabled()</kbd>: This returns <kbd>True</kbd> if this layout is enabled. Otherwise, it returns <kbd>False</kbd>.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">functional</h1>
                
            
            
                
<p>These functions relate to the current values of the layout, changes in functionality, and so on:</p>
<p><kbd>activate()</kbd>: This redoes the layout for the parent widget of this layout.</p>
<p><kbd>alignmentRect(QtCore.QRect)</kbd>: This returns a rectangle of the <kbd>QtCore.QRect</kbd> type that will be covered when this layout's geometry is set to the rectangle specified in the parameter.</p>
<p><kbd>closestAcceptableSize(QtWidgets.QWidget, QtCore.QSize)</kbd>: This returns the size that satisfies all the constraints on the widget (the first parameter) and is close to the size specified (the second parameter).</p>
<p><kbd>contentsMargins()</kbd>: This returns the margins of the <kbd>QtCore.QMargins</kbd> type that are used around this layout.</p>
<p><kbd>contentsRect()</kbd>: This returns a rectangle of the <kbd>QtCore.QRect</kbd> type of the layout's geometry, with the content's margins.</p>
<p><kbd>count()</kbd>: This returns the number of items in this layout.</p>
<p><kbd>getContentsMargins()</kbd>: This returns the margins for the left, top, right, and bottom sides that are used around the layout.</p>
<p><kbd>indexOf(QtWidgets.QWidget)</kbd>: This returns the index of the widget, specified in the parameter, that is found in this layout.</p>
<p><kbd>indexOf(QtWidgets.QLayoutItem)</kbd>: This returns the index of the item's layout, specified in the parameter, that is found in this layout.</p>
<p><kbd>itemAt(int)</kbd>: This returns the item of the <kbd>QtWidgets.QLayoutItem</kbd> type at the index specified in the parameter.</p>
<p><kbd>menuBar()</kbd>: This returns the menu bar of the <kbd>QtWidgets.QWidget</kbd> type for this layout, if the menu bar exists.</p>
<p><kbd>parentWidget()</kbd>: This returns the parent widget of the <kbd>QtWidgets.QWidget</kbd> type for this layout. It returns the parent widget of the parent layout, if this is a sub-layout.</p>
<p><kbd>removeItem(QtWidgets.QLayoutItem)</kbd>: This removes the layout item, specified in the parameter, from this layout.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p><kbd>removeWidget(QtWidgets.QWidget)</kbd>: This removes the widget, specified in the parameter, from this layout.</p>
<p><kbd>replaceWidget(QtWidgets.QWidget, QtWidgets.QWidget, QtCore.Qt.FindChildOptions)</kbd>: This replaces a widget (the first parameter) with another widget (the second parameter) using options (the third parameter), and returns an item of the <kbd>QtWidgets.QLayoutItem</kbd> type that contains the new widget.</p>
<p><kbd>sizeConstraint()</kbd>: This returns the resize mode of the <kbd>QtWidgets.QLayout.SizeConstraint</kbd> type for this layout.</p>
<p><kbd>spacing()</kbd>: This returns the spacing between the widgets inside this layout.</p>
<p><kbd>takeAt(int)</kbd>: This returns the item of the <kbd>QtWidgets.QLayoutItem</kbd> type at the index specified in the parameter and removes it.</p>
<p><kbd>update()</kbd>: This updates this layout for the parent widget.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">events</h1>
                
            
            
                
<p>These are functions related to events, such as event handlers:</p>
<p><kbd>childEvent(QtCore.QChildEvent)</kbd>: This event handler receives child events of the layout, with the event passed in the parameter.</p>
<p><kbd>widgetEvent(QtCore.QEvent)</kbd>: This event handler receives parent widget resize events of the layout, with the event passed in the parameter.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">QLayoutItem</h1>
                
            
            
                
<p>This class creates an abstract item for the layout implementation with the Qt library. The layouts that will be described in this chapter and the <kbd>QLayout</kbd> class can use this functionality and manipulate these items in the custom layout constructions; <kbd>QLayoutItem</kbd> is included in the <kbd>QtWidgets</kbd> module and can be reimplemented in a custom class. The syntax of the reimplementation is as follows:</p>
<pre>...<br/>class ULayoutItem(QtWidgets.QLayoutItem):<br/><br/>    def __init__(self, parent=None):ss.<br/>        super(ULayoutItem, self).__init__(parent)<br/>...</pre>
<p>The <kbd>QLayoutItem</kbd> class enhances functionality with the following functions.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">set</h1>
                
            
            
                
<p>These functions set the parameters/properties of the layout item:</p>
<p><kbd>setAlignment(QtCore.Qt.Alignment)</kbd>: This sets the alignment, specified in the parameter, for this layout item.</p>
<p><kbd>setGeometry(QtCore.QRect)</kbd>: This sets the geometry, specified in the parameter, for this layout item.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">has/is</h1>
                
            
            
                
<p>These functions return a Boolean value, <kbd>bool</kbd>, related to this layout item's state:</p>
<p><kbd>hasHeightForWidth()</kbd>: This returns <kbd>True</kbd> if the preferred height of this layout depends on its width.</p>
<p><kbd>isEmpty()</kbd>: This returns <kbd>True</kbd> if this layout item is empty, or <kbd>False</kbd> if it contains any widgets.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">functional</h1>
                
            
            
                
<p>These functions relate to the current values of the layout item, changes in functionality, and so on:</p>
<p><kbd>alignment()</kbd>: This returns the alignment of the <kbd>QtCore.Qt.Alignment</kbd> type for this layout item.</p>
<p><kbd>controlTypes()</kbd>: This returns the control types of the <strong><kbd>QtWidgets.QSizePolicy.ControlTypes</kbd></strong> type for this layout item.</p>
<p><kbd>expandingDirections()</kbd>: This returns the directions of the <kbd>QtCore.Qt.Orientations</kbd> type so that this layout item can make use of more space.</p>
<p><kbd>geometry()</kbd>: This returns the rectangle of the <kbd>QtCore.QRect</kbd> type covered by this layout item.</p>
<p><kbd>heightForWidth(int)</kbd>: This returns the preferred height for this layout item in relation to the width specified in the parameter.</p>
<p><kbd>invalidate()</kbd>: This invalidates this layout item's cached information.</p>
<p><kbd>layout()</kbd>: This returns the layout of the <kbd>QtWidgets.QLayout</kbd> type if this item has a relative layout.</p>
<p><kbd>maximumSize()</kbd>: This returns the maximum size of the <kbd>QtCore.QSize</kbd> type for this layout item.</p>
<p><kbd>minimumHeightForWidth(int)</kbd>: This returns the minimum height for this widget relative to the width specified in the parameter.</p>
<p><kbd>minimumSize()</kbd>: This returns the minimum size of the <kbd>QtCore.QSize</kbd> type for this layout item.</p>
<p><kbd>sizeHint()</kbd>: This returns the preferred size of the <kbd>QtCore.QSize</kbd> type for this layout item.</p>
<p><kbd>spacerItem()</kbd>: This returns a spacer item (a blank space) of the <kbd>QtWidgets.QSpacerItem</kbd> type if this item is a spacer item.</p>
<p><kbd>widget()</kbd>: This returns widget of the <kbd>QtWidgets.QWidget</kbd> type if this item manages a widget.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">QSizePolicy</h1>
                
            
            
                
<p>This class can be used to set the resizing policy for the widgets in the layout. The size policy of a widget describes how it will be resized and treated by the layout engine. Usually, this policy attribute is used for widgets in layouts. The policy can be added by using <kbd>setSizePolicy()</kbd> with the parameter related to the size policy. The declaration syntax of this class is as follows:</p>
<pre><strong>size_policy</strong> = QtWidgets.QSizePolicy()</pre>
<p>The <kbd>QSizePolicy</kbd> class enhances functionality with the following functions.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">set</h1>
                
            
            
                
<p>These functions set the parameters/properties of the size policy:</p>
<p><kbd>size_policy.setControlType(QtWidgets.QSizePolicy.ControlType)</kbd>: This sets the control type for the associated widget to which the size policy will be applied. The available control types are as follows:</p>
<ul>
<li><kbd>QtWidgets.QSizePolicy.DefaultType</kbd>: The default type; <kbd>None</kbd> is specified.</li>
<li><kbd>QtWidgets.QSizePolicy.ButtonBox</kbd>: This is a <kbd>QtWidgets.QDialogButtonBox</kbd> instance.</li>
<li><kbd>QtWidgets.QSizePolicy.CheckBox</kbd>: This is a <kbd>QtWidgets.QCheckBox</kbd> instance.</li>
<li><kbd>QtWidgets.QSizePolicy.ComboBox</kbd>: This is a <kbd>QtWidgets.QComboBox</kbd> instance.</li>
<li><kbd>QtWidgets.QSizePolicy.Frame</kbd>: This is a <kbd>QtWidgets.QFrame</kbd> instance.</li>
<li><kbd>QtWidgets.QSizePolicy.GroupBox</kbd>: This is a <kbd>QtWidgets.QGroupBox</kbd> instance.</li>
<li><kbd>QtWidgets.QSizePolicy.Label</kbd>: This is a <kbd>QtWidgets.QLabel</kbd> instance.</li>
<li><kbd>QtWidgets.QSizePolicy.Line</kbd>: This is a <kbd>QtWidgets.QFrame.HLine</kbd> or <kbd>QtWidgets.QFrame.VLine</kbd> instance.</li>
<li><kbd>QtWidgets.QSizePolicy.LineEdit</kbd>: This is a <kbd>QtWidgets.QLineEdit</kbd> instance.</li>
<li><kbd>QtWidgets.QSizePolicy.PushButton</kbd>: This is a <kbd>QtWidgets.QPushButton</kbd> instance.</li>
<li><kbd>QtWidgets.QSizePolicy.RadioButton</kbd>: This is a <kbd>QtWidgets.QRadioButton</kbd> instance.</li>
<li><kbd>QtWidgets.QSizePolicy.Slider</kbd>: This is a <kbd>QtWidgets.QAbstractSlider</kbd> instance.</li>
<li><kbd>QtWidgets.QSizePolicy.SpinBox</kbd>: This is a <kbd>QtWidgets.QAbstractSpinBox</kbd> instance.</li>
<li><kbd>QtWidgets.QSizePolicy.TabWidget</kbd>: This is a <kbd>QtWidgets.QTabWidget</kbd> instance.</li>
<li><kbd>QtWidgets.QSizePolicy.ToolButton</kbd>: This is a <kbd>QtWidgets.QToolButton</kbd> instance.</li>
</ul>
<p><kbd>size_policy.setHeightForWidth(bool)</kbd>: If the parameter is <kbd>True</kbd>, it sets that the preferred height depends on the width of the widget.</p>
<p><kbd>size_policy.setHorizontalPolicy(QtWidgets.QSizePolicy.Policy)</kbd>: This sets the horizontal policy, specified in the parameter, for this size policy. The available policies are as follows:</p>
<ul>
<li><strong><kbd>QtWidgets.QSizePolicy.Fixed</kbd></strong>: The widget has a fixed-size policy; it can never grow or shrink.</li>
<li><kbd>QtWidgets.QSizePolicy.Minimum</kbd>: The widget can be expanded, but it cannot be smaller than the minimum <kbd>sizeHint()</kbd>.</li>
<li><kbd>QtWidgets.QSizePolicy.Maximum</kbd>: The widget can be shrunk, but it cannot be larger than the maximum <kbd>sizeHint()</kbd>.</li>
<li><kbd>QtWidgets.QSizePolicy.Preferred</kbd>: The widget`s <kbd>sizeHint()</kbd> is as preferred.</li>
<li><kbd>QtWidgets.QSizePolicy.Expanding</kbd>: The widget's <kbd>sizeHint()</kbd> is a sensible size. The widget can be expanded.</li>
<li><kbd>QtWidgets.QSizePolicy.MinimumExpanding</kbd>: The widget's <kbd>sizeHint()</kbd> is minimal and sufficient.</li>
<li><kbd>QtWidgets.QSizePolicy.Ignored</kbd>: The widget's <kbd>sizeHint()</kbd> is ignored.</li>
</ul>
<p>Also, the following flags can be used, combined together with the <kbd>|</kbd> operator:</p>
<ul>
<li><kbd>QtWidgets.QSizePolicy.GrowFlag</kbd>—<kbd>1</kbd>: The widget can grow more than the size hint.</li>
<li><kbd>QtWidgets.QSizePolicy.ExpandFlag</kbd>—<kbd>2</kbd>: The widget can take as much space as is available.</li>
<li><kbd>QtWidgets.QSizePolicy.ShrinkFlag</kbd>—<kbd>4</kbd>: The widget can shrink more than the size hint.</li>
<li><kbd>QtWidgets.QSizePolicy.IgnoreFlag</kbd>—<kbd>8</kbd>: The size hint is ignored. The widget will get as much space as possible.</li>
</ul>
<p><kbd>size_policy.setHorizontalStretch(int)</kbd>: This sets the horizontal stretch factor, specified in the parameter, for this size policy.</p>
<p><kbd>size_policy.setRetainSizeWhenHidden(bool)</kbd>: If the parameter is <kbd>True</kbd>, it determines that this layout will retain the size of the widget when it's hidden.</p>
<p><kbd>size_policy.setVerticalPolicy(QtWidgets.QSizePolicy.Policy)</kbd>: This sets the vertical policy, specified in the parameter, for this size policy. The available policies are described in the earlier bullets.</p>
<p><kbd>size_policy.setVerticalStretch(int)</kbd>: This sets the vertical stretch factor, specified in the parameter, for this size policy.</p>
<p><kbd>size_policy.setWidthForHeight(bool)</kbd>: If the parameter is <kbd>True</kbd>, it sets that the preferred width depends on the height of this widget.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">has</h1>
                
            
            
                
<p>These functions return a Boolean value (<kbd>bool</kbd>) related to this size policy's state:</p>
<p><kbd>size_policy.hasHeightForWidth()</kbd>: This returns <kbd>True</kbd> if the preferred height of the widget depends on its width.</p>
<p><kbd>size_policy.hasWidthForHeight()</kbd>: This returns <kbd>True</kbd> if the preferred width of the widget depends on its height.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">functional</h1>
                
            
            
                
<p>These functions relate to the current values of the size policy, changes in functionality, and so on:</p>
<p><kbd>size_policy.controlType()</kbd>: This returns the control type of the <kbd>QtWidgets.QSizePolicy.ControlType</kbd> type that is associated with the widget to which the size policy will be applied.</p>
<p><kbd>size_policy.expandingDirections()</kbd>: This returns the direction of the <kbd>QtCore.Qt.Orientations</kbd> type where the widget can make use of more space than is indicated in the <kbd>sizeHint()</kbd> function.</p>
<p><kbd>size_policy.horizontalPolicy()</kbd>: This returns the horizontal policy of the <kbd>QtWidgets.QSizePolicy.Policy</kbd> type of this size policy.</p>
<p><kbd>size_policy.horizontalStretch()</kbd>: This returns the horizontal stretch factor used in this size policy.</p>
<p><kbd>size_policy.retainSizeWhenHidden()</kbd>: This returns <kbd>True</kbd>, if this layout retains the size of the widget when hidden. The default is <kbd>False</kbd>.</p>
<p><kbd>size_policy.transpose()</kbd>: This swaps the horizontal/vertical policies/stretches.</p>
<p><kbd>size_policy.transposed()</kbd>: This returns the swapped size policy of the <kbd>QtWidgets.QSizePolicy</kbd> type with the horizontal/vertical policies/stretches.</p>
<p><kbd>size_policy.verticalPolicy()</kbd>: This returns the vertical policy of the <kbd>QtWidgets.QSizePolicy.Policy</kbd> type for this size policy.</p>
<p><kbd>size_policy.verticalStretch()</kbd>: This returns the vertical stretch factor of this size policy.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Box layouts</h1>
                
            
            
                
<p>The simplest way to arrange items in an application's widgets is to use a <strong>box layout</strong> construction. Box layouts arrange items horizontally or vertically. Horizontally, the items will be in a row, and vertically, they will be in a column. The class that provides the basic functionality is <kbd>QBoxLayout</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">QBoxLayout</h1>
                
            
            
                
<p>This is the basic class for box layouts. It can arrange items horizontally/vertically in a row/column arrangement. The direction of the box layout, such as left to right (row) or top to bottom (column), needs to be defined in the declaration of the class with the relevant parameter. The declaration syntax is as follows:</p>
<pre><strong>box_layout</strong> = QtWidgets.QBoxLayout(QtWidgets.QBoxLayout.LeftToRight)</pre>
<p><kbd>QBoxLayout</kbd> inherits the <kbd>QLayout</kbd> class and enhances its functionality with the following functions:</p>


            

            
        
    

        

                            
                    <h1 class="header-title">add</h1>
                
            
            
                
<p>These functions add elements to the layout:</p>
<p><kbd>box_layout.addLayout(QtWidgets.QLayout, int)</kbd>: This adds the layout (the first parameter) to this box layout using the stretch factor (the second parameter).</p>
<p><kbd>box_layout.addSpacerItem(QtWidgets.QSpacerItem)</kbd>: This adds a spacer item, specified in the parameter, to this box layout.</p>
<p><kbd>box_layout.addSpacing(int)</kbd>: This adds a non-stretchable space to this layout with the size specified in the parameter.</p>
<p><kbd>box_layout.addStretch(int)</kbd>: This adds a stretchable space to this layout, with the stretch factor specified in the parameter.</p>
<p><kbd>box_layout.addStrut(int)</kbd>: This adds the limits, specified in the parameter, for the perpendicular dimension of this box layout.</p>
<p><kbd>box_layout.addWidget(QtWidgets.QWidget, int, QtCore.Qt.Alignment)</kbd>: This adds the widget (the first parameter) to this box layout, using the stretch factor (the second parameter) and alignment (the third parameter).</p>


            

            
        
    

        

                            
                    <h1 class="header-title">insert</h1>
                
            
            
                
<p>These functions insert elements into the layout:</p>
<p><kbd>box_layout.insertItem(int, QtWidgets.QLayoutItem)</kbd>: This inserts an item (the second parameter) into this layout at the index (the first parameter).</p>
<p><kbd>box_layout.insertLayout(int, QtWidgets.QLayout, int)</kbd>: This inserts a layout (the second parameter) into this layout at the index (the first parameter) with a stretch factor (the third parameter).</p>
<p><kbd>box_layout.insertSpacerItem(int, QtWidgets.QSpacerItem)</kbd>: This inserts a spacer item (the second parameter) into this layout at the index (the first parameter).</p>
<p><kbd>box_layout.insertSpacing(int, int)</kbd>: This inserts a non-stretchable space with a certain size (the second parameter) into this layout at the index (the first parameter).</p>
<p><kbd>box_layout.insertStretch(int, int)</kbd>: This inserts a stretchable space with a certain size (the second parameter) into this layout at the index (the first parameter).</p>
<p><kbd>box_layout.insertWidget(int, QtWidgets.QWidget, int, QtCore.Qt.Alignment)</kbd>: This inserts a widget (the second parameter) into this layout at the index (the first parameter) with a stretch factor (the third parameter) and alignment (the fourth parameter).</p>


            

            
        
    

        

                            
                    <h1 class="header-title">set</h1>
                
            
            
                
<p>These functions set the parameters/properties of the layout:</p>
<p><kbd>box_layout.setDirection(QtWidgets.QBoxLayout.Direction)</kbd>: This sets the direction, specified in the parameter, for this box layout. The available directions are as follows:</p>
<ul>
<li><strong><kbd>QtWidgets.QBoxLayout.LeftToRight</kbd></strong>—<kbd>0</kbd>: From left to right.</li>
<li><kbd>QtWidgets.QBoxLayout.RightToLeft</kbd>—<kbd>1</kbd>: From right to left.</li>
<li><kbd>QtWidgets.QBoxLayout.TopToBottom</kbd>—<kbd>2</kbd>: From top to bottom.</li>
<li><kbd>QtWidgets.QBoxLayout.BottomToTop</kbd>—<kbd>3</kbd>: From bottom to top.</li>
</ul>
<p><kbd>box_layout.setSpacing(int)</kbd>: This sets the spacing between widgets inside this box layout.</p>
<p><kbd>box_layout.setStretch(int, int)</kbd>: This sets the stretch factor (the second parameter) for this layout at the index (the first parameter).</p>
<p><kbd>box_layout.setStretchFactor(QtWidgets.QWidget, int)</kbd>: This sets the stretch factor (the second parameter) for the widget (the first parameter) in this box layout.</p>
<p><kbd>box_layout.setStretchFactor(QtWidgets.QLayout, int)</kbd>: This sets the stretch factor (the second parameter) for the layout (the first parameter) in this box layout.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">functional</h1>
                
            
            
                
<p>These functions relate to the current values of the layout, changes in functionality, and so on:</p>
<p><kbd>box_layout.direction()</kbd>: This returns the direction of the <strong><kbd>QtWidgets.QBoxLayout.Direction</kbd></strong> type used for this box layout.</p>
<p><kbd>box_layout.stretch(int)</kbd>: This returns the stretch factor at the position specified by the index.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">QHBoxLayout</h1>
                
            
            
                
<p>This class can be used to construct layouts that can arrange items horizontally in a row, placing the widgets inside the row. It is an additional class for implementing box layouts and can be used for horizontal arrangement. It is very useful when constructing a simple application window with some elements that will be arranged at the top or bottom, or with additional windows/widgets whose elements will have a similar direction. The available directions for this layout are <kbd>RightToLeft</kbd> and <kbd>LeftToRight</kbd> (the default). The declaration syntax of this class is as follows:</p>
<pre><strong>hbox_layout</strong> = QtWidgets.QHBoxLayout()</pre>
<p><kbd>QHBoxLayout</kbd> inherits <kbd>QBoxLayout</kbd> with features and functions that are available and can be implemented in the horizontal layout relatively.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">QVBoxLayout</h1>
                
            
            
                
<p>This class can be used to construct layouts that can arrange items vertically in a column, placing the widgets inside the column. It is an additional class for implementing box layouts, and can be used for vertical arrangement. It is very useful when constructing a simple application window with some elements that will be arranged on the left or right side, or with additional windows/widgets whose elements have a similar direction. The available directions for this layout are <kbd>TopToBottom</kbd> (the default) and <kbd>BottomToTop</kbd>. The declaration syntax of this class is as follows:</p>
<pre><strong>vbox_layout</strong> = QtWidgets.QVBoxLayout()</pre>
<p><kbd>QVBoxLayout</kbd> inherits <kbd>QBoxLayout</kbd> with features and functions that are available and can be implemented in the vertical layout relatively.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">QGridLayout</h1>
                
            
            
                
<p>This class arranges items in a grid. The grid means that each item will be positioned in a specified row and column in relation to the cell. This is a very useful and popular layout for constructing applications with various elements that have different positions, directions, and sizes in relation to the application's windows. The declaration syntax of this class is as follows:</p>
<pre><strong>grid_layout</strong> = QtWidgets.QGridLayout()</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">QGridLayout functions</h1>
                
            
            
                
<p><kbd>QGridLayout</kbd> inherits the <kbd>QLayout</kbd> class and enhances its functionality with the following functions.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">add</h1>
                
            
            
                
<p>These functions add elements to the grid layout:</p>
<p><kbd>grid_layout.addItem(QtWidgets.QLayoutItem, int, int, int, int, QtCore.Qt.Alignment)</kbd>: This adds the layout item (the first parameter) to the position in this grid layout specified by the row (the second parameter) and column (the third parameter). It will occupy a number of rows (the fourth parameter) and columns (the fifth parameter), and it also has an alignment (sixth parameter).</p>
<p><kbd>grid_layout.addLayout(QtWidgets.QLayout, int, int, QtCore.Qt.Alignment)</kbd>: This adds the layout (the first parameter) to the position in this grid layout specified by the row (the second parameter) and column (the third parameter), with an alignment (the fourth parameter).</p>
<p><kbd>grid_layout.addLayout(QtWidgets.QLayout, int, int, int, int, QtCore.Qt.Alignment)</kbd>: This adds the layout (the first parameter) to the position in this grid layout specified by the row (the second parameter) and column (the third parameter). It will occupy a number of rows (the fourth parameter) and columns (the fifth parameter), with an alignment (sixth parameter).</p>
<p><kbd>grid_layout.addWidget(QtWidgets.QWidget, int, int, QtCore.Qt.Alignment)</kbd>: This adds the widget (the first parameter) to the position in this grid layout specified by the row (the second parameter) and column (the third parameter), with an alignment (the fourth parameter).</p>
<p><kbd>grid_layout.addWidget(QtWidgets.QWidget, int, int, int, int, QtCore.Qt.Alignment)</kbd>: This adds the widget (the first parameter) to the position in this grid layout specified by the row (the second parameter) and column (the third parameter). It will occupy a number of rows (the fourth parameter) and columns (the fifth parameter), with an alignment (sixth parameter).</p>


            

            
        
    

        

                            
                    <h1 class="header-title">set</h1>
                
            
            
                
<p>These functions set the parameters/properties of the grid layout:</p>
<p><kbd>grid_layout.setColumnMinimumWidth(int, int)</kbd>: This sets the minimum width in pixels (the second parameter) for the columns (the first parameter) in this grid layout.</p>
<p><kbd>grid_layout.setColumnStretch(int, int)</kbd>: This sets the stretch factor (the second parameter) for the columns (the first parameter) of this grid layout.</p>
<p><kbd>grid_layout.setDefaultPositioning(int, QtCore.Qt.Orientation)</kbd>: This sets the positioning mode that expands this layout to the number of columns/rows (the first parameter). If the orientation (the second parameter) is <kbd>QtCore.Qt.Horizontal</kbd>, it will get expanded by columns. If the orientation is <kbd>QtCore.Qt.Vertical</kbd>, it will get expanded by rows.</p>
<p><kbd>grid_layout.setHorizontalSpacing(int)</kbd>: This sets the horizontal spacing, specified in the parameter, between the widgets of this grid layout.</p>
<p><kbd>grid_layout.setOriginCorner(QtCore.Qt.Corner)</kbd>: This sets the origin corner, specified in the parameter, for this grid layout.</p>
<p><kbd>grid_layout.setRowMinimumHeight(int, int)</kbd>: This sets the minimum height in pixels (the second parameter) for the rows (the first parameter) of this grid layout.</p>
<p><kbd>grid_layout.setRowStretch(int, int)</kbd>: This sets the stretch factor (the second parameter) for the rows (the first parameter) of this grid layout.</p>
<p><kbd>grid_layout.setVerticalSpacing(int)</kbd>: This sets the vertical spacing, specified in the parameter, between the widgets in this grid layout.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">functional</h1>
                
            
            
                
<p>These functions relate to the current values of the grid layout:</p>
<p><kbd>grid_layout.cellRect(int, int)</kbd>: This returns the geometry of the cell as a <kbd>QtCore.QRect</kbd> type, with the row (the first parameter) and column (the second parameter) specified.</p>
<p><kbd>grid_layout.columnCount()</kbd>: This returns the number of columns in this grid layout.</p>
<p><kbd>grid_layout.columnMinimumWidth(int)</kbd>: This returns the minimum width, specified in the parameter, for the columns of this grid layout.</p>
<p><kbd>grid_layout.columnStretch(int)</kbd>: This returns the stretch factor, specified in the parameter, for the columns in this grid layout.</p>
<p><kbd>grid_layout.getItemPosition(int)</kbd>: This returns the position of the item that has the index specified in the parameter in this grid layout.</p>
<p><kbd>grid_layout.horizontalSpacing()</kbd>: This returns the spacing between widgets that are laid horizontally.</p>
<p><kbd>grid_layout.itemAtPosition(int, int)</kbd>: This returns the item of the <kbd>QtWidgets.QLayoutItem</kbd> type that occupies a row (the first parameter) and a column (the second parameter).</p>
<p><kbd>grid_layout.originCorner()</kbd>: This returns the corner of the <kbd>QtCore.Qt.Corner</kbd> type used for the origin of this grid layout.</p>
<p><kbd>grid_layout.rowCount()</kbd>: This returns the number of rows in this grid layout.</p>
<p><strong><kbd>grid_layout.rowMinimumHeight(int)</kbd></strong>: This returns the minimum height, specified in the parameter, for the columns of this grid layout.</p>
<p><kbd>grid_layout.rowStretch(int)</kbd>: This returns the stretch factor, specified in the parameter, for the rows of this grid layout.</p>
<p><kbd>grid_layout.verticalSpacing()</kbd>: This returns the spacing between widgets that are laid vertically.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">QGridLayout example</h1>
                
            
            
                
<p>In the earlier chapters of this book, we arranged the elements in the main application window, and additional widgets with the <kbd>QGridLayout</kbd> class. So, it is not necessary to provide examples of this class, because they were shown before.</p>
<p>Let's add some properties to the layouts to demonstrate the features described, such as adding the content margins and modifying the spacing around layouts to make them more representative:</p>
<ol>
<li>In the <kbd>UApp</kbd> class of the <kbd>u_app.py</kbd> files, add these lines:</li>
</ol>
<pre style="padding-left: 60px">...<br/>class UApp(UWindow, UTools):<br/>    <br/>    def __init__(self, parent=None):<br/>        ...<br/>        self.layfr1.setContentsMargins(0, 0, 0, 0)<br/>        ...<br/>        self.layfr2_1.setSpacing(3)<br/>        ...<br/>        self.layfr2.setSpacing(3)<br/>        self.layfr2.setContentsMargins(3, 3, 3, 3)<br/>    ...<br/>...</pre>
<p style="padding-left: 60px">Content margins for each side will be added for the layouts, and the spacing of the elements of the layout is <kbd>3</kbd> pixels. This doesn't make any big changes, and the result will look like this:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/7ef52ff2-dfc0-40c8-811d-cbd65f9ab1f1.png" style="width:47.67em;height:28.67em;"/></p>
<p class="mce-root"/>
<p>This is an optional example. You can experiment with some other features. Use them at your discretion.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">QFormLayout</h1>
                
            
            
                
<p>This class provides layout constructions for various forms with items. The form layout includes input widgets and labels that are associated with these inputs. This form has two columns. The first column usually consists of labels, and the second column is an input widget. These similar form layouts give you the possibility of arranging the items in a simple form representation.  The declaration syntax of this class is as follows:</p>
<pre><strong>form_layout</strong> = QtWidgets.QFormLayout()</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">QFormLayout functions</h1>
                
            
            
                
<p><kbd>QFormLayout</kbd> inherits the <kbd>QLayout</kbd> class and enhances its functionality with the following functions.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">add</h1>
                
            
            
                
<p>These functions add elements to the form layout:</p>
<p><kbd>form_layout.addRow(QtWidgets.QWidget)</kbd>: This adds a row with a widget, specified in the parameter, to this form layout. The added widget will occupy both columns in the row.</p>
<p><kbd>form_layout.addRow(QtWidgets.QLayout)</kbd>: This adds a row with a layout, specified in the parameter, to this form layout. The added layout will occupy both columns in the row.</p>
<p><kbd>form_layout.addRow(QtWidgets.QWidget, QtWidgets.QWidget)</kbd>: This adds a row with two columns to this form layout. The first widget (the first parameter) will occupy the first column and the second widget (the second parameter) will occupy the second column.</p>
<p><kbd>form_layout.addRow(QtWidgets.QWidget, QtWidgets.QLayout)</kbd>: This adds a row with two columns to this form layout. The widget (the first parameter) will occupy the first column and the layout (the second parameter) will occupy the second column.</p>
<p><strong><kbd>form_layout.addRow(str, QtWidgets.QWidget)</kbd></strong>: This adds a row with two columns to this form layout. A label with text (the first parameter) will be added automatically and will occupy the first column, and a widget (the second parameter) will occupy the second column.</p>
<p><kbd>form_layout.addRow(str, QtWidgets.QLayout)</kbd>: This adds a row with two columns to this form layout. A label with text (the first parameter) will be added automatically and will occupy the first column, and a layout (the second parameter) will occupy the second column.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">insert</h1>
                
            
            
                
<p>These functions insert elements into the form layout:</p>
<p><kbd>form_layout.insertRow(int, QtWidgets.QWidget)</kbd>: This inserts a row with two columns into this form layout at the index (the first parameter). The added widget (the second parameter) will occupy both columns in the row.</p>
<p><kbd>form_layout.insertRow(int, QtWidgets.QLayout)</kbd>: This inserts a row with two columns into this form layout at the index (the first parameter). The added layout (the second parameter) will occupy both columns in the row.</p>
<p><kbd>form_layout.insertRow(int, QtWidgets.QWidget, QtWidgets.QWidget)</kbd>: This inserts a row with two columns into this form layout at the index (the first parameter). The first widget (the second parameter) will occupy the first column, and the second widget (the third parameter) will occupy the second column.</p>
<p><kbd>form_layout.insertRow(int, QtWidgets.QWidget, QtWidgets.QLayout)</kbd>: This inserts a row with two columns into this form layout at the index (the first parameter). The widget (the second parameter) will occupy the first column, and the layout (the third parameter) will occupy the second column.</p>
<p><kbd>form_layout.insertRow(int, str, QtWidgets.QWidget)</kbd>: This inserts a row with two columns into this form layout at the index (the first parameter). A label with text (the second parameter) will be added automatically and will occupy the first column, and a widget (the third parameter) will occupy the second column.</p>
<p><kbd>form_layout.insertRow(int, str, QtWidgets.QLayout)</kbd>: This inserts a row with two columns into this form layout at the index (the first parameter). A label with text (the second parameter) will be added automatically and will occupy the first column, and a layout (the third parameter) will occupy the second column.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">set</h1>
                
            
            
                
<p>These functions set the parameters/properties of the form layout:</p>
<p><kbd>form_layout.setFieldGrowthPolicy(QtWidgets.QFormLayout.FieldGrowthPolicy)</kbd>: This sets the growth policy for the fields in this form layout. The available policies are as follows:</p>
<ul>
<li><kbd>QtWidgets.QFormLayout.FieldsStayAtSizeHint</kbd>—<kbd>0</kbd>: The fields never grow more than the effective size hint.</li>
<li><kbd>QtWidgets.QFormLayout.ExpandingFieldsGrow</kbd>—<kbd>1</kbd>: The fields with <kbd>Expanding</kbd> or <kbd>MinimumExpanding</kbd> will grow to fill the available space. Otherwise, they never grow more than the effective size hint.</li>
<li><kbd>QtWidgets.QFormLayout.AllNonFixedFieldsGrow</kbd>—<kbd>2</kbd>: The fields with a size policy will grow to fill the available space.</li>
</ul>
<p><kbd>form_layout.setFormAlignment(QtCore.Qt.Alignment)</kbd>: This sets the alignment for the contents of this form layout.</p>
<p><kbd>form_layout.setHorizontalSpacing(int)</kbd>: This sets the horizontal spacing, specified in the parameter, between the widgets in this form layout.</p>
<p><kbd>form_layout.setItem(int, QtWidgets.QFormLayout.ItemRole, QtWidgets.QLayoutItem)</kbd>: This sets the item in the row (the first parameter) with the role (the second parameter) to an item (the third parameter).</p>
<p><kbd>form_layout.setLabelAlignment(QtCore.Qt.Alignment)</kbd>: This sets the horizontal alignment, specified in the parameter, for the labels in this form layout.</p>
<p><kbd>form_layout.setLayout(int, QtWidgets.QFormLayout.ItemRole, QtWidgets.QLayout)</kbd>: This sets the sub-layout (the third parameter) in the row (the first parameter) for the role (the second parameter) of this form layout.</p>
<p><kbd>form_layout.setRowWrapPolicy(QtWidgets.QFormLayout.RowWrapPolicy)</kbd>: This sets the row's wrap policy, specified in the parameter, for the form of this layout. The available policies are as follows:</p>
<ul>
<li><strong><kbd>QtWidgets.QFormLayout.DontWrapRows</kbd></strong>—<kbd>0</kbd>: The rows don't wrap.</li>
<li><kbd>QtWidgets.QFormLayout.WrapLongRows</kbd>—<kbd>1</kbd>: There's enough horizontal space to fit the widest label, and the rest of the space is for the fields.</li>
<li><kbd>QtWidgets.QFormLayout.WrapAllRows</kbd>—<kbd>2</kbd>: The fields are always below their labels.</li>
</ul>
<p><kbd>form_layout.setVerticalSpacing(int)</kbd>: This sets the vertical spacing, specified in the parameter, between the widgets in this form layout.</p>
<p><kbd>form_layout.setWidget(int, QtWidgets.QFormLayout.ItemRole, QtWidgets.QWidget)</kbd>: This sets the widget (the third parameter) in the row (the first parameter) for the role (the second parameter). The available item roles are as follows:</p>
<ul>
<li><kbd>QtWidgets.QFormLayout.LabelRole</kbd>—<kbd>0</kbd>: A label widget.</li>
<li><kbd>QtWidgets.QFormLayout.FieldRole</kbd>—<kbd>1</kbd>: A field widget.</li>
<li><kbd>QtWidgets.QFormLayout.SpanningRole</kbd>—<kbd>2</kbd>: A widget that spans label and field columns.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">functional</h1>
                
            
            
                
<p>These functions relate to the current values of the form layout, changes in functionality, and so on:</p>
<p><kbd>form_layout.fieldGrowthPolicy()</kbd>: This returns the growth policy of the <kbd>QtWidgets.QFormLayout.FieldGrowthPolicy</kbd> type.</p>
<p><kbd>form_layout.formAlignment()</kbd>: This returns the alignment of the <kbd>QtCore.Qt.Alignment</kbd> type used for this form layout.</p>
<p><kbd>form_layout.getItemPosition(int)</kbd>: This retrieves the row and role of the item specified by the index in the parameter.</p>
<p><kbd>form_layout.getLayoutPosition(QtWidgets.QLayout)</kbd>: This retrieves the row and role of the child layout specified in the parameter.</p>
<p><kbd>form_layout.getWidgetPosition(QtWidgets.QWidget)</kbd>: This retrieves the row and role of the widget specified in the parameter.</p>
<p><kbd>form_layout.horizontalSpacing()</kbd>: This returns the spacing between widgets that are laid horizontally in this form layout.</p>
<p><kbd>form_layout.itemAt(int, QtWidgets.QFormLayout.ItemRole)</kbd>: This returns the layout item at the row (the first parameter) with the item's role (the second parameter).</p>
<p><kbd>form_layout.labelAlignment()</kbd>: This returns the horizontal alignment of the <kbd>QtCore.Qt.Alignment</kbd> type for the labels in this form layout.</p>
<p><kbd>form_layout.labelForField(QtWidgets.QWidget)</kbd>: This returns the label associated with the widget specified in the parameter.</p>
<p><kbd>form_layout.labelForField(QtWidgets.QLayout)</kbd>: This returns the label associated with the layout specified in the parameter.</p>
<p><kbd>form_layout.removeRow(int)</kbd>: This removes the row specified in the parameter from this form layout.</p>
<p><kbd>form_layout.removeRow(QtWidgets.QWidget)</kbd>: This removes the row associated with the widget specified in the parameter from this form layout.</p>
<p><strong><kbd>form_layout.removeRow(QtWidgets.QLayout)</kbd></strong>: This removes the row associated with the layout specified in the parameter from this form layout.</p>
<p><kbd>form_layout.rowCount()</kbd>: This returns the number of rows in this form layout.</p>
<p><kbd>form_layout.rowWrapPolicy()</kbd>: This returns the row wrap policy of the <kbd>QtWidgets.QFormLayout.RowWrapPolicy</kbd> type in this layout.</p>
<p><kbd>form_layout.takeRow(int)</kbd>: This removes the row specified in the parameter from this form layout without deleting it.</p>
<p><kbd>form_layout.takeRow(QtWidgets.QWidget)</kbd>: This removes the widget specified in the parameter from this form layout without deleting it.</p>
<p><kbd>form_layout.takeRow(QtWidgets.QLayout)</kbd>: This removes the layout specified in the parameter from this form layout without deleting it.</p>
<p><kbd>form_layout.verticalSpacing()</kbd>: This returns the spacing between widgets that are laid vertically.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">QFormLayout example</h1>
                
            
            
                
<p>Let's look at an example of the form layout that will be used in this application. Let's create the <kbd>Settings</kbd> option in the <kbd>Options</kbd> section at the top panel of the application:</p>
<ol>
<li>To do this, create two files called <kbd>u_settings.py</kbd>, one in <kbd>App/App_PySide2/</kbd> and one in <kbd>App/App_PyQt5/</kbd>, and add the following code:</li>
</ol>
<ul>
<li style="padding-left: 30px">Add the following to the <kbd>App_PySide2/u_settings.py</kbd>  file's <kbd>import</kbd> section:</li>
</ul>
<pre style="padding-left: 90px">...<br/>from PySide2 import QtWidgets, QtCore, QtGui<br/>from u_style import ULineEd, UBut1<br/>...</pre>
<ul>
<li style="padding-left: 30px">Add the following to the <kbd>App_PyQt5/u_settings.py</kbd> file's <kbd>import</kbd> section:</li>
</ul>
<pre style="padding-left: 90px">...<br/>from PyQt5 import QtWidgets, QtCore, QtGui<br/>from u_style import ULineEd, UBut1<br/>...</pre>
<ol start="2">
<li>Add the <kbd>USets</kbd> class to this file with lines that will open and read the <kbd>settings.txt</kbd> file:</li>
</ol>
<pre style="padding-left: 60px">...<br/>class USets(QtWidgets.QWidget):<br/><br/>    def __init__(self, parent=None):<br/>        super(USets, self).__init__(parent)<br/>        self.setWindowTitle("U App settings")<br/>        win_icon = QtGui.QIcon("Icons/python1.png")<br/>        color_icon = QtGui.QIcon("Icons/colors.png")<br/>        self.setWindowIcon(win_icon)<br/>        rstop = open("settings.txt", "r")<br/>        rstyle = rstop.read().split(" ")<br/>        rstop.close()<br/>        ...<br/>    ...<br/>...</pre>
<p style="padding-left: 60px">This class inherits the <kbd>QWidget</kbd> class that will be displayed as a separate window of the application.</p>
<ol start="3">
<li>Add the first line edit field for the first background color of the app with the button to open the color dialog to the <kbd>__init__()</kbd> function of the <kbd>USets</kbd> class:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>        ... <br/>        self.bgle1 = ULineEd(self, tmrgl=30, tmrgt=20,<br/>                                     tmrgr=0, tmrgb=20)<br/>        self.bgle1.setText(rstyle[0])<br/>        self.bgle1.setMinimumWidth(270)<br/>        self.bgb1 = UBut1(self.bgle1, pad=1)<br/>        self.bgb1.setIcon(color_icon)<br/>        ...<br/>    ...<br/>...</pre>
<p style="padding-left: 60px">We've made an instance of the first line edit field with some text of the first color from the <kbd>settings.txt</kbd> file, and a button to call the color dialog window.</p>
<ol start="4">
<li>Add the second line edit field for the second background color of the app with the button to open a color dialog to the <kbd>__init__()</kbd> function of the <kbd>USets</kbd> class:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>        ...<br/>        self.bgle2 = ULineEd(self, tmrgl=30, tmrgt=20,<br/>                                     tmrgr=0, tmrgb=20)<br/>        self.bgle2.setText(rstyle[1])<br/>        self.bgb2 = UBut1(self.bgle2, pad=1)<br/>        self.bgb2.setIcon(color_icon)<br/>        ...<br/>    ...<br/>...</pre>
<p style="padding-left: 60px">We've created an instance of the second line edit field with a text of the second color from the <kbd>settings.txt</kbd> file, and a button to call the color dialog window.</p>
<ol start="5">
<li>Add the third line edit field for the first additional color (for the text, and for the hover effect) of the app with the button to open a color dialog to the <kbd>__init__()</kbd> function of the <kbd>USets</kbd> class:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>        ...<br/>        self.colle1 = ULineEd(self, tmrgl=30, tmrgt=20,<br/>                                      tmrgr=0, tmrgb=20)<br/>        self.colle1.setText(rstyle[2])<br/>        self.colb1 = UBut1(self.colle1, pad=1)<br/>        self.colb1.setIcon(color_icon)<br/>        ...<br/>    ...<br/>...</pre>
<p style="padding-left: 60px">We've added an instance of the third line edit field with a text of the third color from the <kbd>settings.txt</kbd> file, and a button to call the color dialog window.</p>
<ol start="6">
<li>Add the fourth line edit field for the second additional color (for the text, and for the hover effect) of the app with a button that opens a color dialog to the <kbd>__init__()</kbd> function of the <kbd>USets</kbd> class:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>        ...<br/>        self.colle2 = ULineEd(self, tmrgl=30, tmrgt=20,<br/>                                      tmrgr=0, tmrgb=20)<br/>        self.colle2.setText(rstyle[3])<br/>        self.colb2 = UBut1(self.colle2, pad=1)<br/>        self.colb2.setIcon(color_icon)<br/>        ...<br/>    ...<br/>...</pre>
<p style="padding-left: 60px">We've added an instance of the third line edit field with a text of the third color from the <kbd>settings.txt</kbd> file, and a button to call the color dialog window.</p>
<ol start="7">
<li>Add the <kbd>Reset</kbd> and <kbd>Save</kbd> buttons to this widget:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>        ...<br/>        self.lbinfo = QtWidgets.QLabel(self)<br/>        self.lbinfo.setText("""These settings will be saved and\n<br/>                                application will be restarted""")<br/>        self.breset = UBut1(self, fixw=95, fixh=59)<br/>        self.breset.setText("Reset")<br/>        self.bsave = UBut1(self, fixw=95, fixh=59)<br/>        self.bsave.setText("Save")<br/>        ...<br/>    ...<br/>...</pre>
<p style="padding-left: 60px">It is recommended to fix the size of the buttons. For the very best construction of your layouts, this is required.</p>
<ol start="8">
<li>Add the horizontal box layout for the label and buttons:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>        ...<br/>        hlay = QtWidgets.QHBoxLayout()<br/>        hlay.addWidget(self.lbinfo)<br/>        hlay.addWidget(self.breset)<br/>        hlay.addWidget(self.bsave)<br/>        ...<br/>    ...<br/>...</pre>
<p style="padding-left: 60px">This will be an addition to the main form layout.</p>
<ol start="9">
<li>Add the form layout with text labels (automatically created) and line edit fields:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>        ...<br/>        form_layout = QtWidgets.QFormLayout()<br/>        form_layout.addRow("Background color 1", self.bgle1)<br/>        form_layout.addRow("Background color 2", self.bgle2)<br/>        form_layout.addRow("Color 1", self.colle1)<br/>        form_layout.addRow("Color 2", self.colle2)<br/>        ...<br/>    ...<br/>...</pre>
<p style="padding-left: 60px">This demonstrates the form layout construction in the application. Each row has a label and a line edit field.</p>
<ol start="10">
<li>Add a vertical layout for the form layout and for the horizontal layout when adding this layout to the widget:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>        ...<br/>        vlay = QtWidgets.QVBoxLayout()<br/>        vlay.addLayout(form_layout)<br/>        vlay.addLayout(hlay)<br/>        self.setLayout(vlay)<br/>        ...<br/>    ...<br/>...</pre>
<p style="padding-left: 60px">We've combined two layouts into one. This demonstrates that we can create any nesting layout constructions.</p>
<ol start="11">
<li>At the end of the <kbd>__init__()</kbd> function, add the signals:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>        ...<br/>        self.bgb1.clicked.connect(self.b1_fd)<br/>        self.bgb2.clicked.connect(self.b2_fd)<br/>        self.colb1.clicked.connect(self.b3_fd)<br/>        self.colb2.clicked.connect(self.b4_fd)<br/>        ...<br/>    ...<br/>...</pre>
<p style="padding-left: 60px">These signals will call the color dialog windows for each line of the form layout if the corresponding button is clicked.</p>
<ol start="12">
<li>Now add the functions that will call the function that opens the color dialog when a button is clicked:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>    def b1_fd(self):<br/>        self.color_fd(le=self.bgle1)<br/><br/>    def b2_fd(self):<br/>        self.color_fd(le=self.bgle2)<br/><br/>    def b3_fd(self):<br/>        self.color_fd(le=self.colle1)<br/><br/>    def b4_fd(self):<br/>        self.color_fd(le=self.colle2)<br/>    ...<br/>...</pre>
<p style="padding-left: 60px">Each function will call the color dialog window with the option to choose a color for the background of the application window and the text color of the elements.</p>
<ol start="13">
<li>Add the function that opens the color dialog and sets the text with the selected color to the related line edit field:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>    def color_fd(self, le=None):<br/>        fd = QtWidgets.QColorDialog()<br/>        fd.setWindowIcon(QtGui.QIcon("Icons/python1.png"))<br/>        if fd.exec_() == QtWidgets.QDialog.Accepted:<br/>            fc = fd.selectedColor()<br/>            color = "rgba(%s,%s,%s,%s)" % (fc.red(), fc.green(), <br/>                        fc.blue(), fc.alpha())<br/>            le.setText(color)<br/>...</pre>
<p style="padding-left: 60px">This function will display the color dialog window. If a favorite color is chosen and a dialog window is accepted by clicking Ok, Accept, or another similar button, it will set the text to an RGBA color in the corresponding line edit field.</p>
<ol start="14">
<li>We can add the bottom section of the file if we use this widget separately from the application as a window:</li>
</ol>
<pre style="padding-left: 60px">...o<br/>if __name__ == "__main__":<br/>    import sys<br/>    sapp = QtWidgets.QApplication(sys.argv)<br/>    uset = USets()<br/>    uset.show()<br/>    sys.exit(sapp.exec_())<br/>...</pre>
<p>Now we need to add lines to the <kbd>u_app.py</kbd> file for running this settings widget from the application:</p>
<ol start="1">
<li>In the <kbd>UApp</kbd> class  <kbd>__init__()</kbd> function, at the bottom, add the following signal:</li>
</ol>
<pre style="padding-left: 60px">...<br/>class UApp(UWindow, UTools):<br/>    <br/>    def __init__(self, parent=None):<br/>        ...<br/>        self.mb3.triggered.connect(self.settings)<br/>        ...<br/>    ...<br/>...</pre>
<p style="padding-left: 60px">Using the <kbd>triggered()</kbd> signal of the third menu section, we will call the <kbd>settings()</kbd> function.</p>
<ol start="2">
<li>Then, add the function for the <kbd>Options</kbd> section of the top panel:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>    def options(self, action):<br/>        if action.text() == "Settings":<br/>            from u_settings import USets<br/>            self.sets = USets()<br/>            self.sets.show()<br/>            self.sets.bsave.clicked.connect(self.sets_but)<br/>            self.sets.breset.clicked.connect(self.to_default)<br/>    ...<br/>...</pre>
<p style="padding-left: 60px">In the <strong><kbd>options()</kbd></strong> function, we created an instruction for the <kbd>Settings</kbd> option. We imported the <kbd>USets</kbd> class of the <kbd>u_settings.py</kbd> module, and then created the instance of this class and showed this window. Also, we added two <kbd>clicked()</kbd> signals of the <kbd>Save</kbd> and <kbd>Reset</kbd> buttons.</p>
<ol start="3">
<li>Add the function for clicking the <kbd>Save</kbd> button:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>    def sets_but(self):<br/>        colors = "%s %s %s %s" % (self.sets.bgle1.text(),<br/>                                  self.sets.bgle2.text(),<br/>                                  self.sets.colle1.text(),<br/>                                  self.sets.colle2.text())<br/>        save_open = open("settings.txt", "w")<br/>        save_open.write(colors)<br/>        save_open.close()<br/>        self.new_app()<br/>    ...<br/>...</pre>
<p style="padding-left: 60px">This function will write the string with the chosen colors to the <kbd>settings.txt</kbd> file using the Python standard library's <kbd>open()</kbd> function. </p>
<ol start="4">
<li>Add the function for clicking the <kbd>Reset</kbd> button:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>    def to_default(self):<br/>        u_defaults.txt_file(state=True)<br/>        self.new_app()<br/>    ...<br/>...</pre>
<p style="padding-left: 60px">This function will restore to the default colors of the application.</p>
<ol start="5">
<li>Add the function that will be called to run the new app:</li>
</ol>
<pre style="padding-left: 60px">...<br/>    ...<br/>    def new_app(self):<br/>        self.sets.hide()<br/>        subprocess.Popen(["python", r"u_app.py"])<br/>        sys.exit(0)<br/>    ...<br/>...</pre>
<p style="padding-left: 60px">This function will open the new main application window as a sub-process and exit the previous window. </p>
<p>Now add the following lines to the <kbd>u_style.py</kbd> file:</p>
<ol start="1">
<li>We need to change the lines at the top of the file with the <kbd>color</kbd> variable to the following:</li>
</ol>
<pre style="padding-left: 60px">...<br/>setfile = open("settings.txt", "r")<br/>colread = setfile.read().split(" ")<br/>if len(colread) == 4:<br/>    color = colread<br/>else:<br/>    color = ["", "", "", ""]<br/>setfile.close()<br/>...</pre>
<ol start="2">
<li>And now, we need to add the default color settings for the application, which will be installed when the application is launched. To do this, create <kbd>u_defaults.py</kbd> files in both the <kbd>App/App_PySide2/</kbd> and <kbd>App/App_PyQt5/</kbd> directories.</li>
</ol>
<p style="padding-left: 60px">Then we can add these lines to these files:</p>
<pre style="padding-left: 60px">...<br/>import os<br/><br/>def txt_file(state=False):<br/>    colors = "rgba(0,41,59,140) rgba(0,41,59,255)<br/>               rgba(1,255,217,140) rgba(1,255,217,255)"<br/>    if os.path.exists("settings.txt") is state:<br/>        wstyle = open("settings.txt", "w")<br/>        wstyle.write(colors)<br/>        wstyle.close()<br/>...</pre>
<p style="padding-left: 60px">Note that the <kbd>colors</kbd> variable must contain a string with the color values, split by a space. </p>
<ol start="3">
<li>We need to add these lines to the <kbd>u_app.py</kbd> file for the application to run correctly. At the top of the <kbd>u_app.py</kbd> file, before all the imports, we need to add these lines:</li>
</ol>
<pre style="padding-left: 60px">...<br/>import u_defaults<br/>u_defaults.txt_file(state=False)<br/>...</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p style="padding-left: 60px">If this application starts for the first time, default colors will be used for the background and text. If we run the <kbd>u_app.py</kbd> file, we will see a simple widget with form, vertical box, and horizontal box layouts implemented:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/7504a260-74ae-4515-83f3-c2ad38271525.png"/></p>
<p style="padding-left: 60px">So, when we choose colors or type in RGBA values to the line edit fields, they will be saved in the simple text file. In reality, this is not a reliable way to save and hold default settings (and not just settings). This example is optional. Moreover, saving default settings to simple text files, and working in this manner in general, is not recommended at all. This piece of the application just allows us to play with colors. Furthermore, settings for fonts, sizes of elements, and more, can be added in a similar way. Which settings to use remains at the discretion of the user.</p>
<p style="padding-left: 60px">We can just demonstrate, with a color selection, that the application will look like this:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/069431b6-49a8-4a52-b4b2-f42141c6b6cd.png" style="width:33.00em;height:26.58em;"/></p>
<p style="padding-left: 60px">The color of the application now is white.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">QStackedLayout</h1>
                
            
            
                
<p>In addition, the Qt library provides stacked layouts. This class creates a layout that arranges items as a stack of widgets. By default, only one widget is visible at a time; the others are hidden. Similar to the stacked layout is the tab widget that was previously implemented in the application. The <kbd>QStackedWidget</kbd> class is also available and can be used as the top class of the stacked layout. The declaration syntax of this class is as follows:</p>
<pre><strong>stacked_layout</strong> = QtWidgets.QStackedLayout()</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">QStackedLayout functions</h1>
                
            
            
                
<p><kbd>QStackedLayout</kbd> inherits the <kbd>QLayout</kbd> class and enhances its functionality with the following functions.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">set</h1>
                
            
            
                
<p>These functions set the parameters/properties of the stacked layout:</p>
<p><kbd>stacked_layout.setCurrentIndex(int)</kbd>: This sets the index, specified in the parameter, of the widget that will be currently visible and active in this stacked layout.</p>
<p><kbd>stacked_layout.setCurrentWidget(QtWidgets.QWidget)</kbd>: This sets the widget, specified in the parameter, that will be currently visible and active in this stacked layout.</p>
<p><kbd>stacked_layout.setStackingMode(QtWidgets.QStackedLayout.StackingMode)</kbd>: This sets the stacking mode, specified in the parameter, for this stacked layout. The available modes are as follows:</p>
<ul>
<li><kbd>QtWidgets.QStackedLayout.StackOne</kbd>—<kbd>0</kbd>: Only one widget is visible.</li>
<li><kbd>QtWidgets.QStackedLayout.StackAll</kbd>—<kbd>1</kbd>: All widgets are visible, and the current widget is raised and active.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">functional</h1>
                
            
            
                
<p>These functions relate to the current values of the stacked layout, changes in functionality, and so on:</p>
<p><kbd>stacked_layout.currentIndex()</kbd>: This returns the index of the widget that is currently visible in this stacked layout.</p>
<p><kbd>stacked_layout.currentWidget()</kbd>: This returns the widget of the <kbd>QtWidgets.QWidget</kbd> type that is currently visible in this stacked layout.</p>
<p><kbd>stacked_layout.insertWidget(int, QtWidgets.QWidget)</kbd>: This inserts the widget (the second parameter) at the index (the first parameter) of this stacked layout.</p>
<p><kbd>stacked_layout.stackingMode()</kbd>: This returns the current stacking mode of the <kbd>QtWidgets.QStackedLayout.StackingMode</kbd> type for this stacked layout.</p>
<p><kbd>stacked_layout.widget(int)</kbd>: This returns the widget at the index specified in the parameter.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">signals</h1>
                
            
            
                
<p>These signals are available for the <kbd>QStackedLayout</kbd> class:</p>
<p><kbd>stacked_layout.currentChanged(int)</kbd>: This signal is emitted when the current widget in the stacked layout changes, with the new current widget index passed in the parameter.</p>
<p><kbd>stacked_layout.widgetRemoved(int)</kbd>: This signal is emitted when the widget is removed from the stacked layout, with the index of the widget passed in the parameter.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>This chapter completes the part of the book dedicated to learning about the classes and properties of the Qt framework that help us to build a basic application with a GUI. Layouts in an application are a very important mechanism to arrange items in a user-friendly way. Note that layouts are not elements or items and that they provide functionality behind the scenes of the GUI app's windows and widgets. We need to remember this when we perform nesting of the layouts within each other multiple times. Also, the abstract base classes, described earlier in this chapter, allow us to construct various special layouts for the application.</p>
<p>The next chapter will start the section of the book about the functional features of the application. We will explore a very small set of related tools, from the giant set of tools on offer with Python that are available for implementation in the application for various purposes. We will be introduced to databases and their implementation.</p>


            

            
        
    </body></html>