- en: Getting Started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Over the course of this book, you will be introduced to multiple concepts that
    will enable you to build a complete modern web application. You will progress
    from a "Hello world" web page to a complete web application that uses databases,
    caches, asynchronous task processing, authentication, role-based access, a REST
    API, and internationalization. You will learn a comprehensive way of structuring
    your application so that it can grow effortlessly. To choose between SQL and NoSQL
    technologies, you will learn how to use the most common Flask extensions to help
    you leverage multiple technologies, from sending emails to authentication using
    social media accounts. Toward the end, you will learn how to write tests, build
    a modern continuous integration/delivery pipeline with Docker and Jenkins, deploy
    your application to multiple cloud services, and know how to deal with high availability
    and scaling. We will tackle all of these topics with a simple and practical approach.
  prefs: []
  type: TYPE_NORMAL
- en: '**Flask** is the Python web framework that we are going to use. It has a very
    well-designed API, is very easy to learn, and makes no assumptions whatsoever
    as to what technology stack you are going to use, so it won''t get in your way.
    Flask has a micro footprint, but leverages an extension system that contains hundreds
    of packages from a very active and vibrant community.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this first chapter, you will learn how to set up your development environment
    and build your first Flask application. We will be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up and learning how to use Git, a powerful version control system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning pip, the Python management system, and how to create virtual environments
    with different setups
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up and learning the basic facts about Docker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a first simple Flask application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Version control with Git
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using Python or any other language requires you to use a version control system.
    A version control system is a tool that records changes in files over time. This
    allows a programmer to revert to an earlier version of the file and identify bugs
    more easily. You can test new ideas without fear of breaking your current code,
    and your team can work using a predefined workflow without stepping on each others'
    toes. Git was developed by Linus Torvalds, the father of Linux. It's decentralized,
    light, and has great features that get the job done the right way.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Git
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Installing Git is very simple. Simply go to [http://www.git-scm.com/downloads](http://www.git-scm.com/downloads)
    and click on the **operating system** (**OS**) that is being run. A program will
    begin to download will walk you through the basic installation process.
  prefs: []
  type: TYPE_NORMAL
- en: Git on Windows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Git was originally solely developed for Unix OSes (for example, Linux and macOS
    X). Consequently, using Git on Windows is not seamless. During the installation,
    the installer will ask whether you want to install Git alongside the normal Windows
    Command Prompt. Do not pick this option. Choose the default option that will install
    a new type of command processor on your system named **Bash** (**Bourne-again
    shell**), which is the same command processor that the Unix systems use. Bash
    is much more powerful than the default Windows command line, and this is what
    we will be using for all the examples in this book.
  prefs: []
  type: TYPE_NORMAL
- en: A good introduction to Bash for beginners can be found at [http://linuxcommand.org](http://linuxcommand.org).
  prefs: []
  type: TYPE_NORMAL
- en: Git basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Git is a very complex tool; only the basics that are needed for this book will
    be covered in this section.
  prefs: []
  type: TYPE_NORMAL
- en: To learn more, refer to the Git documentation at [http://www.git-scm.com/doc](http://www.git-scm.com/doc).
  prefs: []
  type: TYPE_NORMAL
- en: 'Git does not track your changes automatically. In order for Git to run properly,
    we have to give it the following information:'
  prefs: []
  type: TYPE_NORMAL
- en: Which folders to track
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When to save the state of the code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What to track and what not to track
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Before we can do anything, we have to tell Git to initialize a new `git` repository
    in our directory. Run the following code on your Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Git will now start to track changes in our project. As `git` tracks our files,
    we can see the status of our tracked files and any files that are not tracked
    by typing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can save our first `commit`, which is a snapshot of our code at the
    time that we run the `commit` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, at any point in the future, we can return to this point in our project.
    Adding files that are to be committed is called **staging** files in Git. Remember
    that you should only add stage files if you are ready to commit them. Once the
    files are staged, any further changes will not be staged. For an example of more
    advanced Git usage, add any text to your `main.py` file with your text editor
    and then run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Your terminal should look something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/439bbf17-d71e-43d9-829a-33dac6a93832.png)'
  prefs: []
  type: TYPE_IMG
- en: Note that in the preceding example I have modified the `main.py` file by adding
    the comment `# Changed to show the git diff command`.
  prefs: []
  type: TYPE_NORMAL
- en: 'One important step to include in every Git repository is a `.gitignore` file.
    This file tells Git what files to ignore. This way you can safely commit and add
    all your files. The following are some common files that you can ignore:'
  prefs: []
  type: TYPE_NORMAL
- en: Python's byte code files (`*.pyc`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Databases (specially for our examples using SQLLite database files) (`*.db`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Secrets (never push secrets (password, keys, and so on) to your repositories)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IDE metadata files (`.idea`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Virtualenv` directory (`env` or `venv`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here''s a simple example of a `gitignore` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can safely add all the files to `git` and commit them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The Git system's `checkout` command is rather advanced for this simple introduction,
    but it is used to change the current status of the Git system's `HEAD` pointer,
    which refers to the current location of our code in the history of our project.
    This will be shown in the next example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if we wish to see the code in a previous commit, we should first run the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The string of characters next to our `commit` message, `beb4711`, is called
    the **hash** of our commit. It is the unique identifier of the commit that we
    can use to return to the saved state. Now, to take the project back to the previous
    state, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Your Git project is now in a special state where any changes or commits will
    neither be saved nor affect any commits that were made after the one you checked
    out. This state is just for viewing old code. To return to the normal mode of
    Git, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Git branches and flow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Source control branches are an important feature that works great in team projects.
    A developer can create a new line of code from a specific point in time, revision,
    or tag. In this way, developing new features, creating releases, and making bugfixes
    or hotfixes can be done safely and subjected to team revision, and/or automatic
    integration tools (such as tests, code coverage, lint tools). A branch can be
    merged with other branches until it finally reaches the main line of code, called
    the *master branch*.
  prefs: []
  type: TYPE_NORMAL
- en: 'But let''s get our hands on a practical exercise. Let''s say that we want to
    develop a new feature. Our first chapter example displays the traditional "Hello
    World" message, but we want it to say "good morning" to the users. First, we create
    a branch from a special branch called the `feature/good-morning` that for now
    is a copy of the master branch, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This could be resumed to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s change our code to display good morning to the visitors of a certain
    URL, along with their names. To do this, we change `main.py`, which looks like
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We change `main.py` to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s look at what we have done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Looks good. Let''s commit, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Now, if we were working as part of a team, or if our work was open source (or
    if we just wanted to back up our work), we should upload (push) our code to a
    centralized remote origin. One way of doing this is to push our code to a version
    control system, such as **Bitbucket** or **GitHub**, and then open a **pull request**
    to the master branch. This pull request will show our changes. As such, it may
    need approval from other team members, and many other features that these systems
    can provide.
  prefs: []
  type: TYPE_NORMAL
- en: One example of a pull request on the Flask project can be found at [https://github.com/pallets/flask/pull/1767](https://github.com/pallets/flask/pull/1767).
  prefs: []
  type: TYPE_NORMAL
- en: 'For our example, let''s just merge to the master, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the output, Git uses the fast-forward strategy by default.
    If we wanted to keep an extra commit log message that mentions the merge itself,
    then we could have used the `--no-ff `flag on the `git merge` command. This flag
    will disable the fast-forward merging strategy.
  prefs: []
  type: TYPE_NORMAL
- en: For more details, go to [https://git-scm.com/book/en/v2/Git-Branching-Basic-Branching-and-Merging](https://git-scm.com/book/en/v2/Git-Branching-Basic-Branching-and-Merging).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now imagine that we regret our change and want to revert the feature that we
    have just created back to an earlier version. To do this, we can use the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: With Git, you can actually delete your commits, but this is considered a really
    bad practice. Note that the `revert` command did not delete our merge, but created
    a new commit with the reverted changes. It's considered a good practice not to
    rewrite the past.
  prefs: []
  type: TYPE_NORMAL
- en: What was shown is a feature branch simple workflow. With big teams or projects,
    the use of more complex workflows is normally adopted to better isolate features,
    fixes, and releases, and to keep a stable line of code. This is what is proposed
    when using the git-flow process.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a version control system, we are ready to cover Python's package
    management system.
  prefs: []
  type: TYPE_NORMAL
- en: Python package management with pip
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Python, programmers can download libraries from other programmers that extend
    the functionality of the standard Python library. As you already know from using
    Flask, a lot of Python's power comes from its large number of community-created
    libraries.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, installing third-party libraries can be a huge pain to do correctly.
    Say that you want to install package X. Simple enough: download the ZIP file and
    run `setup.py`, right? Not quite. Package X relies on package Y, which in turn
    relies on Z and Q. None of this information was listed on package X''s website,
    but these packages need to be installed for X to work at all. You then have to
    find all of the packages one by one and install them, and then hope that the packages
    you are installing don''t require any extra packages themselves.'
  prefs: []
  type: TYPE_NORMAL
- en: In order to automate this process, we use **pip**, the Python package manager.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the Python package manager on Windows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you are using Windows, and your previously installed version of Python is
    the current version, then you already have pip! If your Python installation is
    not the most recent version, then the easiest thing to do is to simply reinstall
    it. Download the Python Windows installer at [https://www.python.org/downloads/](https://www.python.org/downloads/).
  prefs: []
  type: TYPE_NORMAL
- en: In Windows, the variable that controls which programs are accessible from the
    command line is the `path`. To modify our `path` to include Python and pip, we
    have to add `C:\Python27` and `C:\Python27\Tools`. Edit the Windows `path` by
    opening the Windows menu, right-clicking on Computer, and clicking on Properties.
    Under Advanced system settings, click Environment Variables.... Scroll down until
    you find Path, double-click on it, and add `;C:\Python27;C:\Python27\Tools` to
    the end.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make sure that you have modified your path correctly, close and reopen your
    Terminal and type the following into the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Pip should have printed its usage message, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c1e2cfd7-5e05-42b0-ad5d-4e3d2d7f1af1.png)'
  prefs: []
  type: TYPE_IMG
- en: Installing pip Python package manager on macOS X and Linux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Some Python installations of Linux do not come with pip, and Mac OS X''s installations
    doesn''t come with pip by default. If you are using Python 2.7, then you may need
    to install pip, but pip is already included in Python 3.4, and in later versions.
    You can check this using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: If you need to install it, download the `get-pip.py` file from [https://bootstrap.pypa.io/get-pip.py](https://bootstrap.pypa.io/get-pip.py).
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have downloaded it, run it with elevated privileges using the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Once this has been entered, pip will be installed automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Pip basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are now going to learn the basic commands for using Python package manager.
    To install a package with `pip`, enter the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'On Mac and Linux, because you are installing programs outside of the user-owned
    folders, you might have to prepend `sudo` to the `install` commands. To install
    Flask, simply run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Once you have done this, all of the requirements that you need for using Flask
    will be installed for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to remove a package that you are no longer using, run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'If you wish to explore or find a package, but don''t know its exact name, you
    can use the `search` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have a couple of packages installed, it is common courtesy in the
    Python community to create a list of packages that are required to run the project
    so that others can quickly install every necessary package. This also has the
    added benefit that any new member of your project will be able to run your code
    quickly.
  prefs: []
  type: TYPE_NORMAL
- en: 'This list can be created with pip by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'What exactly did this command do? The `pip freeze` command automatically prints
    out a list of the installed packages and their versions. For our example, it prints
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The `>` operator tells Bash to take everything printed by the last command and
    write it to this file. If you look in your project directory, you can see a new
    file named `requirements.txt` that contains the output of `pip freeze`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install all the packages from this file, a new project maintainer would
    have to run this, as shown in the following code. Normally, this will also be
    used to deploy the production environment of your project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code tells `pip` to read all the packages listed in `requirements.txt`
    and install them.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency sandboxing with virtualenv
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So you have installed all the packages that you want for your new project. Great!
    But what happens when we develop a second project some time later that will use
    newer versions of the same packages? And what happens when a library that you
    wish to use depends on a library that you installed for the first project, but
    which uses an older version of these packages? When newer versions of packages
    contain breaking changes, upgrading them would require extra development work
    on an older project that you may not be able to afford. So in our system, we could
    have clashing Python packages between projects.
  prefs: []
  type: TYPE_NORMAL
- en: We should also consider automated build environments, such as **Jenkins**, where
    we want to run tests. These builds may run on the same system on which other projects
    are being built, so it's essential that during the build jobs we create a contained
    Python package environment that is not shared between jobs. This environment is
    created from the information in the `requirements.txt` file that we created earlier.
    This way, multiple Python applications can be built and tested on the same system
    without clashing with each other.
  prefs: []
  type: TYPE_NORMAL
- en: Thankfully, there is **virtualenv**, a tool that sandboxes your Python projects.
    The secret to virtualenv is in tricking your computer to look for and install
    packages in the project directory rather than in the main Python directory, which
    allows you to keep them completely separate.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you''re using Python 3—and I recommend that you do, because Python 2 support
    will end in 2020—then you don''t have to install virtualenv; you can use it just
    by running it like a package, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have pip, if we need to install `virtualenv`, then we can just
    run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Virtualenv basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s initialize `virtualenv` for our project, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The extra `env` tells virtualenv to store all the packages in a folder named
    `env`. Virtualenv requires you to start it before it will sandbox your project.
    You can do this using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The `source` command tells Bash to run the `env/bin/activate` script in the
    context of the current directory. Let''s reinstall Flask in our new sandbox, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Setting up Docker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Your development projects normally need more then a web server application layer;
    you will most definitely need some kind of database system. You might be using
    a cache, **redis**, workers with **Celery**, a messaging queuing system, or something
    else. Normally, all of the systems that are needed for your application to work
    are collectively referred to as **stack**. One simple way to easily define and
    quickly spawn all these components is to use **Docker** containers. With Docker,
    you define all of your application components and how to install and configure
    them, and you can then share your stack with your team, and send it to production
    with the exact same specification.
  prefs: []
  type: TYPE_NORMAL
- en: You can download and install Docker from [https://docs.docker.com/install/](https://docs.docker.com/install/).
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s create a very simple **Dockerfile**. This file defines how to
    set up your application. Each line will serve as a container layer for very fast
    rebuilds. A very simple Dockerfile will look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s build out first container image. We will tag it as `chapter_1`
    for further ease of use, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we will run it, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Docker is easy, but it's a complex tool with lots of options for configuring
    and deploying containers. We will look at Docker in more detail in [Chapter 13](380101ac-fb85-4e2e-b664-8d6de77928f4.xhtml), *Deploying
    Flask Apps*.
  prefs: []
  type: TYPE_NORMAL
- en: The beginning of our project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Finally, we can get to our first Flask project. In order to build a complex
    project at the end of this book, we will need a simple Flask project to start
    us off.
  prefs: []
  type: TYPE_NORMAL
- en: Simple application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Flask is very powerful, but will most definitely not get in your way. You can
    use it to create a simple web application using a single file. Our aim is to create
    a project that is structured in a way that it can scale and be easy to understand.
    For now, we will create a `config` file first. In the file named `config.py`,
    add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, in another file named `main.py`, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: For anyone who is familiar with the base Flask API, this program is very basic.
    It will simply show `Hello World!` on the browser if we navigate to `http://127.0.0.1:5000`.
    One point that may be unfamiliar to Flask users is the use of the phrase `config.from_object` rather
    than `app.config['DEBUG']`. We use `from_object` because in future, multiple configurations
    will be used, and manually changing every variable when we need to switch between
    configurations is time consuming.
  prefs: []
  type: TYPE_NORMAL
- en: Project structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have created a very simple project structure, but can it serve as the base
    skeleton for any Python project. In [Chapter 5](dee931d4-a3b0-4355-acbd-37e05e158356.xhtml),
    *Advanced Application Structure*, we will get our hands on a more scalable structure,
    but for now, let''s go back to our environment, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember to commit these changes in Git, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: You will no longer be reminded of when to commit your changes to Git. It is
    up to you to develop the habit of committing whenever you reach a stopping point.
    It is also assumed that you will be operating inside the virtual environment,
    so all command-line prompts will not be prefixed with `(env)`.
  prefs: []
  type: TYPE_NORMAL
- en: Using Flask's command-line interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to make the next chapters easier for the reader, we will look at how
    to use the Flask CLI (using version 0.11 onward). The CLI allows programmers to
    create commands that act within the **application context** of Flask—that is,
    the state in Flask that allows the modification of the `Flask` object. The Flask
    CLI comes with some default commands to run the server and a Python shell in the
    application context.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the Flask CLI and how to initialize it. First, we must
    tell it how to discover our application using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we will use the Flask CLI to run our application using the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s enter the shell on the application context and see how to get all
    the defined URL routes, using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we already have two routes defined: the `/` where we display
    the "`Hello World`" sentence and the static default route created by Flask. Some
    other useful information shows where Flask thinks our templates and static folders
    are, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Flask CLI, uses the `click` library from the creator of Flask itself. It was
    designed to be easily extensible so that the Flask extensions can extend it and
    implement new commands that are available when you use them. We should indeed
    extend it—it makes it more useful to extend it ourselves. This is the right way
    to create management commands for our applications. Think about commands that
    you can use to migrate database schemas, create users, prune data, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have set up our development environment, we can move on to implementing
    advanced application features in Flask. Before we can do anything visual, we need
    content to display. This content will be kept on a database. In the next chapter,
    you will be introduced to working with databases in Flask, and you will learn
    how master them.
  prefs: []
  type: TYPE_NORMAL
