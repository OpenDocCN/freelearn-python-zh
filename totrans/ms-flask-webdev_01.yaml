- en: Getting Started
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门指南
- en: Over the course of this book, you will be introduced to multiple concepts that
    will enable you to build a complete modern web application. You will progress
    from a "Hello world" web page to a complete web application that uses databases,
    caches, asynchronous task processing, authentication, role-based access, a REST
    API, and internationalization. You will learn a comprehensive way of structuring
    your application so that it can grow effortlessly. To choose between SQL and NoSQL
    technologies, you will learn how to use the most common Flask extensions to help
    you leverage multiple technologies, from sending emails to authentication using
    social media accounts. Toward the end, you will learn how to write tests, build
    a modern continuous integration/delivery pipeline with Docker and Jenkins, deploy
    your application to multiple cloud services, and know how to deal with high availability
    and scaling. We will tackle all of these topics with a simple and practical approach.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的整个过程中，你将接触到多个概念，这些概念将使你能够构建一个完整的现代网络应用程序。你将从“Hello world”网页进步到一个完整的网络应用程序，该应用程序使用数据库、缓存、异步任务处理、身份验证、基于角色的访问、REST
    API 和国际化。你将学习一种全面的方法来构建你的应用程序，使其能够轻松扩展。为了在 SQL 和 NoSQL 技术之间做出选择，你将学习如何使用最常用的 Flask
    扩展来帮助你利用多种技术，从发送电子邮件到使用社交媒体账户进行身份验证。在本书的结尾，你将学习如何编写测试、使用 Docker 和 Jenkins 构建现代的持续集成/交付管道、将你的应用程序部署到多个云服务，以及如何处理高可用性和扩展。我们将以简单实用的方法解决所有这些问题。
- en: '**Flask** is the Python web framework that we are going to use. It has a very
    well-designed API, is very easy to learn, and makes no assumptions whatsoever
    as to what technology stack you are going to use, so it won''t get in your way.
    Flask has a micro footprint, but leverages an extension system that contains hundreds
    of packages from a very active and vibrant community.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**Flask** 是我们将要使用的 Python 网络框架。它有一个非常精心设计的 API，易于学习，并且对你要使用的任何技术栈不做任何假设，因此不会妨碍你。Flask
    有一个微小的足迹，但利用了一个包含数百个来自非常活跃和充满活力的社区包的扩展系统。'
- en: 'In this first chapter, you will learn how to set up your development environment
    and build your first Flask application. We will be covering the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何设置你的开发环境并构建你的第一个 Flask 应用程序。我们将涵盖以下主题：
- en: Setting up and learning how to use Git, a powerful version control system
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置和使用 Git，一个强大的版本控制系统
- en: Learning pip, the Python management system, and how to create virtual environments
    with different setups
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习 pip，Python 管理系统，以及如何使用不同的设置创建虚拟环境
- en: Setting up and learning the basic facts about Docker
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置和学习 Docker 的基本事实
- en: Building a first simple Flask application
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建第一个简单的 Flask 应用程序
- en: Version control with Git
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Git 进行版本控制
- en: Using Python or any other language requires you to use a version control system.
    A version control system is a tool that records changes in files over time. This
    allows a programmer to revert to an earlier version of the file and identify bugs
    more easily. You can test new ideas without fear of breaking your current code,
    and your team can work using a predefined workflow without stepping on each others'
    toes. Git was developed by Linus Torvalds, the father of Linux. It's decentralized,
    light, and has great features that get the job done the right way.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Python 或任何其他语言需要你使用版本控制系统。版本控制系统是一个记录文件随时间变化的工具。这允许程序员回滚到文件的早期版本并更容易地识别错误。你可以测试新想法而不用担心破坏当前的代码，你的团队可以使用预定义的工作流程工作，而不会互相干扰。Git
    是由 Linux 的创始人 Linus Torvalds 开发的。它是分布式的、轻量级的，并且具有完成工作的正确方式的功能。
- en: Installing Git
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 Git
- en: Installing Git is very simple. Simply go to [http://www.git-scm.com/downloads](http://www.git-scm.com/downloads)
    and click on the **operating system** (**OS**) that is being run. A program will
    begin to download will walk you through the basic installation process.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 Git 非常简单。只需访问 [http://www.git-scm.com/downloads](http://www.git-scm.com/downloads)
    并点击正在运行的 **操作系统**（**OS**），程序将开始下载并引导你完成基本的安装过程。
- en: Git on Windows
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Windows 上的 Git
- en: Git was originally solely developed for Unix OSes (for example, Linux and macOS
    X). Consequently, using Git on Windows is not seamless. During the installation,
    the installer will ask whether you want to install Git alongside the normal Windows
    Command Prompt. Do not pick this option. Choose the default option that will install
    a new type of command processor on your system named **Bash** (**Bourne-again
    shell**), which is the same command processor that the Unix systems use. Bash
    is much more powerful than the default Windows command line, and this is what
    we will be using for all the examples in this book.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: A good introduction to Bash for beginners can be found at [http://linuxcommand.org](http://linuxcommand.org).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Git basics
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Git is a very complex tool; only the basics that are needed for this book will
    be covered in this section.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: To learn more, refer to the Git documentation at [http://www.git-scm.com/doc](http://www.git-scm.com/doc).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: 'Git does not track your changes automatically. In order for Git to run properly,
    we have to give it the following information:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Which folders to track
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When to save the state of the code
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What to track and what not to track
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Before we can do anything, we have to tell Git to initialize a new `git` repository
    in our directory. Run the following code on your Terminal:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Git will now start to track changes in our project. As `git` tracks our files,
    we can see the status of our tracked files and any files that are not tracked
    by typing the following command:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now we can save our first `commit`, which is a snapshot of our code at the
    time that we run the `commit` command:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, at any point in the future, we can return to this point in our project.
    Adding files that are to be committed is called **staging** files in Git. Remember
    that you should only add stage files if you are ready to commit them. Once the
    files are staged, any further changes will not be staged. For an example of more
    advanced Git usage, add any text to your `main.py` file with your text editor
    and then run the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Your terminal should look something like the following:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/439bbf17-d71e-43d9-829a-33dac6a93832.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
- en: Note that in the preceding example I have modified the `main.py` file by adding
    the comment `# Changed to show the git diff command`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: 'One important step to include in every Git repository is a `.gitignore` file.
    This file tells Git what files to ignore. This way you can safely commit and add
    all your files. The following are some common files that you can ignore:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: Python's byte code files (`*.pyc`)
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Databases (specially for our examples using SQLLite database files) (`*.db`)
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Secrets (never push secrets (password, keys, and so on) to your repositories)
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IDE metadata files (`.idea`)
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Virtualenv` directory (`env` or `venv`)
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here''s a simple example of a `gitignore` file:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now we can safely add all the files to `git` and commit them:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The Git system's `checkout` command is rather advanced for this simple introduction,
    but it is used to change the current status of the Git system's `HEAD` pointer,
    which refers to the current location of our code in the history of our project.
    This will be shown in the next example.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if we wish to see the code in a previous commit, we should first run the
    following command:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The string of characters next to our `commit` message, `beb4711`, is called
    the **hash** of our commit. It is the unique identifier of the commit that we
    can use to return to the saved state. Now, to take the project back to the previous
    state, run the following command:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Your Git project is now in a special state where any changes or commits will
    neither be saved nor affect any commits that were made after the one you checked
    out. This state is just for viewing old code. To return to the normal mode of
    Git, run the following command:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Git branches and flow
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Source control branches are an important feature that works great in team projects.
    A developer can create a new line of code from a specific point in time, revision,
    or tag. In this way, developing new features, creating releases, and making bugfixes
    or hotfixes can be done safely and subjected to team revision, and/or automatic
    integration tools (such as tests, code coverage, lint tools). A branch can be
    merged with other branches until it finally reaches the main line of code, called
    the *master branch*.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: 'But let''s get our hands on a practical exercise. Let''s say that we want to
    develop a new feature. Our first chapter example displays the traditional "Hello
    World" message, but we want it to say "good morning" to the users. First, we create
    a branch from a special branch called the `feature/good-morning` that for now
    is a copy of the master branch, as shown in the following code:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This could be resumed to the following:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now let''s change our code to display good morning to the visitors of a certain
    URL, along with their names. To do this, we change `main.py`, which looks like
    the following code:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We change `main.py` to the following:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Let''s look at what we have done:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Looks good. Let''s commit, as shown in the following code:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now, if we were working as part of a team, or if our work was open source (or
    if we just wanted to back up our work), we should upload (push) our code to a
    centralized remote origin. One way of doing this is to push our code to a version
    control system, such as **Bitbucket** or **GitHub**, and then open a **pull request**
    to the master branch. This pull request will show our changes. As such, it may
    need approval from other team members, and many other features that these systems
    can provide.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: One example of a pull request on the Flask project can be found at [https://github.com/pallets/flask/pull/1767](https://github.com/pallets/flask/pull/1767).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: 'For our example, let''s just merge to the master, as shown in the following
    code:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As you can see from the output, Git uses the fast-forward strategy by default.
    If we wanted to keep an extra commit log message that mentions the merge itself,
    then we could have used the `--no-ff `flag on the `git merge` command. This flag
    will disable the fast-forward merging strategy.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，Git 默认使用快速前进策略。如果我们想保留一个额外的提交日志消息，提到合并本身，那么我们可以在 `git merge` 命令中使用 `--no-ff`
    标志。这个标志将禁用快速前进合并策略。
- en: For more details, go to [https://git-scm.com/book/en/v2/Git-Branching-Basic-Branching-and-Merging](https://git-scm.com/book/en/v2/Git-Branching-Basic-Branching-and-Merging).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 更多详情，请访问 [https://git-scm.com/book/en/v2/Git-Branching-Basic-Branching-and-Merging](https://git-scm.com/book/en/v2/Git-Branching-Basic-Branching-and-Merging)。
- en: 'Now imagine that we regret our change and want to revert the feature that we
    have just created back to an earlier version. To do this, we can use the following
    code:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在想象一下，我们后悔我们的更改，并想将我们刚刚创建的功能回滚到早期版本。为此，我们可以使用以下代码：
- en: '[PRE16]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: With Git, you can actually delete your commits, but this is considered a really
    bad practice. Note that the `revert` command did not delete our merge, but created
    a new commit with the reverted changes. It's considered a good practice not to
    rewrite the past.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Git，你实际上可以删除你的提交，但这被认为是一种非常不好的做法。请注意，`revert` 命令并没有删除我们的合并，而是创建了一个带有还原更改的新提交。被认为是一个好习惯，不要重写过去。
- en: What was shown is a feature branch simple workflow. With big teams or projects,
    the use of more complex workflows is normally adopted to better isolate features,
    fixes, and releases, and to keep a stable line of code. This is what is proposed
    when using the git-flow process.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 所展示的是一个功能分支简单的工作流程。对于大型团队或项目，通常采用更复杂的流程来更好地隔离功能、修复和发布，并保持代码的稳定性。这就是使用 git-flow
    流程时所提出的。
- en: Now that we have a version control system, we are ready to cover Python's package
    management system.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了版本控制系统，我们准备介绍 Python 的包管理系统。
- en: Python package management with pip
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 pip 进行 Python 包管理
- en: In Python, programmers can download libraries from other programmers that extend
    the functionality of the standard Python library. As you already know from using
    Flask, a lot of Python's power comes from its large number of community-created
    libraries.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，程序员可以从其他程序员那里下载扩展标准 Python 库功能的库。正如你从使用 Flask 中已经知道的那样，Python 的许多强大功能都来自于其大量的社区创建的库。
- en: 'However, installing third-party libraries can be a huge pain to do correctly.
    Say that you want to install package X. Simple enough: download the ZIP file and
    run `setup.py`, right? Not quite. Package X relies on package Y, which in turn
    relies on Z and Q. None of this information was listed on package X''s website,
    but these packages need to be installed for X to work at all. You then have to
    find all of the packages one by one and install them, and then hope that the packages
    you are installing don''t require any extra packages themselves.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，正确安装第三方库可能是一个巨大的麻烦。比如说，你想安装包 X。很简单：下载 ZIP 文件并运行 `setup.py`，对吧？但并不完全是这样。包
    X 依赖于包 Y，而 Y 又依赖于 Z 和 Q。这些信息都没有在包 X 的网站上列出，但这些包需要安装才能使 X 正常工作。然后你必须一个接一个地找到所有这些包并安装它们，然后希望你安装的包本身不需要任何额外的包。
- en: In order to automate this process, we use **pip**, the Python package manager.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为了自动化这个过程，我们使用 **pip**，Python 的包管理器。
- en: Installing the Python package manager on Windows
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Windows 上安装 Python 包管理器
- en: If you are using Windows, and your previously installed version of Python is
    the current version, then you already have pip! If your Python installation is
    not the most recent version, then the easiest thing to do is to simply reinstall
    it. Download the Python Windows installer at [https://www.python.org/downloads/](https://www.python.org/downloads/).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用 Windows，并且之前安装的 Python 版本就是当前版本，那么你已经有 pip 了！如果你的 Python 安装不是最新版本，那么最简单的方法就是重新安装它。下载
    Python Windows 安装程序，请访问 [https://www.python.org/downloads/](https://www.python.org/downloads/)。
- en: In Windows, the variable that controls which programs are accessible from the
    command line is the `path`. To modify our `path` to include Python and pip, we
    have to add `C:\Python27` and `C:\Python27\Tools`. Edit the Windows `path` by
    opening the Windows menu, right-clicking on Computer, and clicking on Properties.
    Under Advanced system settings, click Environment Variables.... Scroll down until
    you find Path, double-click on it, and add `;C:\Python27;C:\Python27\Tools` to
    the end.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 中，控制哪些程序可以通过命令行访问的变量是 `path`。为了将 Python 和 pip 包含到我们的 `path` 中，我们必须添加
    `C:\Python27` 和 `C:\Python27\Tools`。通过打开 Windows 菜单，右键单击计算机，然后单击属性来编辑 Windows
    的 `path`。在高级系统设置下，点击环境变量...向下滚动直到找到 Path，双击它，并在末尾添加 `;C:\Python27;C:\Python27\Tools`。
- en: 'To make sure that you have modified your path correctly, close and reopen your
    Terminal and type the following into the command line:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保你已经正确修改了你的路径，请关闭并重新打开你的终端，并在命令行中输入以下内容：
- en: '[PRE17]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Pip should have printed its usage message, as shown in the following screenshot:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Pip 应该已经打印了它的使用信息，如下面的截图所示：
- en: '![](img/c1e2cfd7-5e05-42b0-ad5d-4e3d2d7f1af1.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c1e2cfd7-5e05-42b0-ad5d-4e3d2d7f1af1.png)'
- en: Installing pip Python package manager on macOS X and Linux
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 macOS X 和 Linux 上安装 pip Python 包管理器
- en: 'Some Python installations of Linux do not come with pip, and Mac OS X''s installations
    doesn''t come with pip by default. If you are using Python 2.7, then you may need
    to install pip, but pip is already included in Python 3.4, and in later versions.
    You can check this using the following:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 一些 Linux 的 Python 安装没有包含 pip，Mac OS X 的安装默认也不包含 pip。如果你使用的是 Python 2.7，那么你可能需要安装
    pip，但 pip 已经包含在 Python 3.4 及其后续版本中。你可以使用以下方法进行检查：
- en: '[PRE18]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If you need to install it, download the `get-pip.py` file from [https://bootstrap.pypa.io/get-pip.py](https://bootstrap.pypa.io/get-pip.py).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要安装它，请从 [https://bootstrap.pypa.io/get-pip.py](https://bootstrap.pypa.io/get-pip.py)
    下载 `get-pip.py` 文件。
- en: 'Once you have downloaded it, run it with elevated privileges using the following
    code:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 下载完成后，使用以下代码以提升权限运行它：
- en: '[PRE19]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Once this has been entered, pip will be installed automatically.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦输入完成，pip 将会自动安装。
- en: Pip basics
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Pip 基础
- en: 'We are now going to learn the basic commands for using Python package manager.
    To install a package with `pip`, enter the following code:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将学习使用 Python 包管理器的基本命令。要使用 `pip` 安装一个包，请输入以下代码：
- en: '[PRE20]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'On Mac and Linux, because you are installing programs outside of the user-owned
    folders, you might have to prepend `sudo` to the `install` commands. To install
    Flask, simply run the following:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Mac 和 Linux 上，因为你是在用户拥有的文件夹外安装程序，你可能需要在 `install` 命令前加上 `sudo`。要安装 Flask，只需运行以下命令：
- en: '[PRE21]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Once you have done this, all of the requirements that you need for using Flask
    will be installed for you.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你完成这个步骤，所有你需要用于使用 Flask 的依赖项都将为你安装。
- en: 'If you want to remove a package that you are no longer using, run the following:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要删除你不再使用的包，请运行以下命令：
- en: '[PRE22]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If you wish to explore or find a package, but don''t know its exact name, you
    can use the `search` command:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望探索或查找一个包，但不知道它的确切名称，你可以使用 `search` 命令：
- en: '[PRE23]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Now that we have a couple of packages installed, it is common courtesy in the
    Python community to create a list of packages that are required to run the project
    so that others can quickly install every necessary package. This also has the
    added benefit that any new member of your project will be able to run your code
    quickly.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装了一些包，在 Python 社区中，这是一种礼貌的做法，创建一个包含运行项目所需所有包的列表，以便其他人可以快速安装每个必要的包。这也带来了额外的便利，即任何新加入你项目的人都能快速运行你的代码。
- en: 'This list can be created with pip by running the following command:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这个列表可以通过运行以下命令使用 pip 创建：
- en: '[PRE24]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'What exactly did this command do? The `pip freeze` command automatically prints
    out a list of the installed packages and their versions. For our example, it prints
    the following:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令究竟做了什么？`pip freeze` 命令会自动打印出已安装的包及其版本列表。在我们的例子中，它打印了以下内容：
- en: '[PRE25]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `>` operator tells Bash to take everything printed by the last command and
    write it to this file. If you look in your project directory, you can see a new
    file named `requirements.txt` that contains the output of `pip freeze`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`>` 操作符告诉 Bash 将最后一条命令打印的所有内容写入此文件。如果你查看你的项目目录，你可以看到一个名为 `requirements.txt`
    的新文件，它包含了 `pip freeze` 的输出。'
- en: 'To install all the packages from this file, a new project maintainer would
    have to run this, as shown in the following code. Normally, this will also be
    used to deploy the production environment of your project:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装此文件中的所有包，新的项目维护者必须运行以下代码，如下所示。通常，这也会用于部署项目的生产环境：
- en: '[PRE26]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The preceding code tells `pip` to read all the packages listed in `requirements.txt`
    and install them.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码告诉`pip`读取`requirements.txt`中列出的所有包并安装它们。
- en: Dependency sandboxing with virtualenv
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用virtualenv进行依赖沙盒化
- en: So you have installed all the packages that you want for your new project. Great!
    But what happens when we develop a second project some time later that will use
    newer versions of the same packages? And what happens when a library that you
    wish to use depends on a library that you installed for the first project, but
    which uses an older version of these packages? When newer versions of packages
    contain breaking changes, upgrading them would require extra development work
    on an older project that you may not be able to afford. So in our system, we could
    have clashing Python packages between projects.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 所以你已经安装了你新项目所需的所有包。太好了！但如果我们稍后开发第二个项目，它将使用相同包的新版本，会发生什么呢？还有，当你希望使用的库依赖于为第一个项目安装的库，但该库使用这些包的较旧版本时，会发生什么？当包的新版本包含破坏性更改时，升级它们可能需要在较旧的项目上做额外的工作，而你可能负担不起。因此，在我们的系统中，我们可能在项目之间有冲突的Python包。
- en: We should also consider automated build environments, such as **Jenkins**, where
    we want to run tests. These builds may run on the same system on which other projects
    are being built, so it's essential that during the build jobs we create a contained
    Python package environment that is not shared between jobs. This environment is
    created from the information in the `requirements.txt` file that we created earlier.
    This way, multiple Python applications can be built and tested on the same system
    without clashing with each other.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还应该考虑自动构建环境，例如**Jenkins**，在那里我们想要运行测试。这些构建可能运行在其他项目正在构建的同一系统上，因此在构建作业期间，我们创建一个不共享于作业之间的Python包环境是至关重要的。这个环境是由我们之前创建的`requirements.txt`文件中的信息创建的。这样，多个Python应用程序可以在同一系统上构建和测试，而不会相互冲突。
- en: Thankfully, there is **virtualenv**, a tool that sandboxes your Python projects.
    The secret to virtualenv is in tricking your computer to look for and install
    packages in the project directory rather than in the main Python directory, which
    allows you to keep them completely separate.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有**virtualenv**这个工具，它可以沙盒化你的Python项目。virtualenv的秘密在于欺骗你的计算机在项目目录中而不是在主Python目录中查找和安装包，这允许你将它们完全分开。
- en: 'If you''re using Python 3—and I recommend that you do, because Python 2 support
    will end in 2020—then you don''t have to install virtualenv; you can use it just
    by running it like a package, as shown in the following code:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用Python 3——我建议你这样做，因为Python 2的支持将在2020年结束——那么你不需要安装virtualenv；你可以像运行包一样运行它，如下所示：
- en: '[PRE27]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now that we have pip, if we need to install `virtualenv`, then we can just
    run the following command:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了pip，如果我们需要安装`virtualenv`，我们只需运行以下命令：
- en: '[PRE28]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Virtualenv basics
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Virtualenv基础知识
- en: 'Let''s initialize `virtualenv` for our project, as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下方式初始化我们的项目`virtualenv`：
- en: '[PRE29]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The extra `env` tells virtualenv to store all the packages in a folder named
    `env`. Virtualenv requires you to start it before it will sandbox your project.
    You can do this using the following code:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 额外的`env`告诉virtualenv将所有包存储在一个名为`env`的文件夹中。virtualenv要求你在沙盒化项目之前启动它。你可以使用以下代码来完成此操作：
- en: '[PRE30]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `source` command tells Bash to run the `env/bin/activate` script in the
    context of the current directory. Let''s reinstall Flask in our new sandbox, as
    follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`source`命令告诉Bash在当前目录的上下文中运行`env/bin/activate`脚本。让我们按照以下方式在我们的新沙盒中重新安装Flask：'
- en: '[PRE31]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Setting up Docker
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置Docker
- en: Your development projects normally need more then a web server application layer;
    you will most definitely need some kind of database system. You might be using
    a cache, **redis**, workers with **Celery**, a messaging queuing system, or something
    else. Normally, all of the systems that are needed for your application to work
    are collectively referred to as **stack**. One simple way to easily define and
    quickly spawn all these components is to use **Docker** containers. With Docker,
    you define all of your application components and how to install and configure
    them, and you can then share your stack with your team, and send it to production
    with the exact same specification.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 您的开发项目通常需要比Web服务器应用程序层更多的东西；您肯定需要某种类型的数据库系统。您可能正在使用缓存、**redis**、带有**Celery**的工作者、一个消息队列系统，或者别的什么。通常，所有使您的应用程序正常工作的系统都统称为**栈**。一个简单的方法是轻松定义并快速生成所有这些组件是使用**Docker**容器。使用Docker，您定义所有应用程序组件以及如何安装和配置它们，然后您可以与您的团队共享您的栈，并使用完全相同的规范将其发送到生产环境。
- en: You can download and install Docker from [https://docs.docker.com/install/](https://docs.docker.com/install/).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从[https://docs.docker.com/install/](https://docs.docker.com/install/)下载并安装Docker。
- en: 'First, let''s create a very simple **Dockerfile**. This file defines how to
    set up your application. Each line will serve as a container layer for very fast
    rebuilds. A very simple Dockerfile will look like the following:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个非常简单的**Dockerfile**。此文件定义了如何设置您的应用程序。每一行都将作为容器层，以实现非常快的重建。一个非常简单的Dockerfile看起来如下所示：
- en: '[PRE32]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Next, let''s build out first container image. We will tag it as `chapter_1`
    for further ease of use, as shown in the following code:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们构建第一个容器镜像。我们将将其标记为`chapter_1`，以便于进一步的使用，如下面的代码所示：
- en: '[PRE33]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Then we will run it, as shown in the following code:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将运行它，如下面的代码所示：
- en: '[PRE34]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Docker is easy, but it's a complex tool with lots of options for configuring
    and deploying containers. We will look at Docker in more detail in [Chapter 13](380101ac-fb85-4e2e-b664-8d6de77928f4.xhtml), *Deploying
    Flask Apps*.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Docker很简单，但它是一个复杂的工具，具有许多配置和部署容器的选项。我们将在[第13章](380101ac-fb85-4e2e-b664-8d6de77928f4.xhtml)，*部署Flask应用程序*中更详细地了解Docker。
- en: The beginning of our project
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们项目的开始
- en: Finally, we can get to our first Flask project. In order to build a complex
    project at the end of this book, we will need a simple Flask project to start
    us off.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以进入我们的第一个Flask项目。为了在本书的结尾构建一个复杂的项目，我们需要一个简单的Flask项目作为起点。
- en: Simple application
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简单的应用程序
- en: 'Flask is very powerful, but will most definitely not get in your way. You can
    use it to create a simple web application using a single file. Our aim is to create
    a project that is structured in a way that it can scale and be easy to understand.
    For now, we will create a `config` file first. In the file named `config.py`,
    add the following:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Flask非常强大，但绝对不会妨碍您。您可以使用它使用单个文件创建一个简单的Web应用程序。我们的目标是创建一个结构化的项目，使其可以扩展且易于理解。目前，我们将首先创建一个`config`文件。在名为`config.py`的文件中，添加以下内容：
- en: '[PRE35]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now, in another file named `main.py`, add the following:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在另一个名为`main.py`的文件中，添加以下内容：
- en: '[PRE36]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: For anyone who is familiar with the base Flask API, this program is very basic.
    It will simply show `Hello World!` on the browser if we navigate to `http://127.0.0.1:5000`.
    One point that may be unfamiliar to Flask users is the use of the phrase `config.from_object` rather
    than `app.config['DEBUG']`. We use `from_object` because in future, multiple configurations
    will be used, and manually changing every variable when we need to switch between
    configurations is time consuming.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 对于熟悉基础Flask API的人来说，这个程序非常基础。如果我们导航到`http://127.0.0.1:5000`，它将简单地显示`Hello World!`。可能对Flask用户不太熟悉的是使用短语`config.from_object`而不是`app.config['DEBUG']`。我们使用`from_object`是因为在未来，将使用多个配置，当我们需要在不同配置之间切换时，手动更改每个变量是耗时的。
- en: Project structure
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目结构
- en: 'We have created a very simple project structure, but can it serve as the base
    skeleton for any Python project. In [Chapter 5](dee931d4-a3b0-4355-acbd-37e05e158356.xhtml),
    *Advanced Application Structure*, we will get our hands on a more scalable structure,
    but for now, let''s go back to our environment, as shown in the following code:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个非常简单的项目结构，但它能否作为任何Python项目的基架。在[第5章](dee931d4-a3b0-4355-acbd-37e05e158356.xhtml)，*高级应用程序结构*中，我们将接触到更可扩展的结构，但现在，让我们回到我们的环境，如下面的代码所示：
- en: '[PRE37]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Remember to commit these changes in Git, as shown in the following code:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 记得像下面的代码一样在Git中提交这些更改：
- en: '[PRE38]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: You will no longer be reminded of when to commit your changes to Git. It is
    up to you to develop the habit of committing whenever you reach a stopping point.
    It is also assumed that you will be operating inside the virtual environment,
    so all command-line prompts will not be prefixed with `(env)`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 你将不再被提醒何时将更改提交到Git。养成在达到一个停止点时提交更改的习惯取决于你。还假设你将在虚拟环境中操作，因此所有命令行提示将不会以`(env)`为前缀。
- en: Using Flask's command-line interface
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Flask的命令行界面
- en: In order to make the next chapters easier for the reader, we will look at how
    to use the Flask CLI (using version 0.11 onward). The CLI allows programmers to
    create commands that act within the **application context** of Flask—that is,
    the state in Flask that allows the modification of the `Flask` object. The Flask
    CLI comes with some default commands to run the server and a Python shell in the
    application context.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使下一章对读者来说更容易理解，我们将探讨如何使用Flask CLI（从版本0.11开始）。CLI允许程序员创建在Flask的**应用程序上下文**中运行的命令——也就是说，允许修改`Flask`对象的Flask状态。Flask
    CLI自带一些默认命令，可以在应用程序上下文中运行服务器和Python shell。
- en: 'Let''s take a look at the Flask CLI and how to initialize it. First, we must
    tell it how to discover our application using the following code:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看Flask CLI以及如何初始化它。首先，我们必须使用以下代码告诉它如何发现我们的应用程序：
- en: '[PRE39]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Then, we will use the Flask CLI to run our application using the following
    code:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将使用以下代码使用Flask CLI运行我们的应用程序：
- en: '[PRE40]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now, let''s enter the shell on the application context and see how to get all
    the defined URL routes, using the following code:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们进入应用程序上下文中的shell，看看如何使用以下代码获取所有定义的URL路由：
- en: '[PRE41]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'As you can see, we already have two routes defined: the `/` where we display
    the "`Hello World`" sentence and the static default route created by Flask. Some
    other useful information shows where Flask thinks our templates and static folders
    are, as shown in the following code:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们已经有两条路由定义：显示"`Hello World`"句子的`/`路由和Flask创建的静态默认路由。一些其他有用的信息显示了Flask认为我们的模板和静态文件夹在哪里，如下面的代码所示：
- en: '[PRE42]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Flask CLI, uses the `click` library from the creator of Flask itself. It was
    designed to be easily extensible so that the Flask extensions can extend it and
    implement new commands that are available when you use them. We should indeed
    extend it—it makes it more useful to extend it ourselves. This is the right way
    to create management commands for our applications. Think about commands that
    you can use to migrate database schemas, create users, prune data, and so on.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: Flask CLI使用Flask创建者的`click`库。它被设计成易于扩展，以便Flask扩展可以扩展它并实现当使用时可用的新命令。我们确实应该扩展它——我们自己扩展它使其更有用。这是为我们的应用程序创建管理命令的正确方式。想想你可以用来迁移数据库模式、创建用户、修剪数据等命令。
- en: Summary
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Now that we have set up our development environment, we can move on to implementing
    advanced application features in Flask. Before we can do anything visual, we need
    content to display. This content will be kept on a database. In the next chapter,
    you will be introduced to working with databases in Flask, and you will learn
    how master them.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经设置了我们的开发环境，我们就可以继续在Flask中实现高级应用程序功能。在我们能够进行任何可视化操作之前，我们需要显示的内容。这些内容将保存在数据库中。在下一章中，你将了解如何在Flask中与数据库一起工作，以及如何掌握它们。
