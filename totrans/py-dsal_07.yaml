- en: Hashing and Symbol Tables
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 哈希和符号表
- en: We have previously looked at lists, where items are stored in sequence and accessed
    by index number. Index numbers work well for computers. They are integers so they
    are fast and easy to manipulate. However, they don't always work so well for us.
    If we have an address book entry, for example, with index number 56, that number
    doesn't tell us much. There is nothing to link a particular contact with number
    56\. It just happens to be the next available position in the list.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前已经讨论过列表，其中项目按顺序存储并按索引号访问。索引号对计算机来说工作得很好。它们是整数，因此它们运行速度快且易于操作。然而，它们对我们来说并不总是那么有效。例如，如果我们有一个索引号为56的地址簿条目，这个数字并没有告诉我们太多。没有任何东西可以将特定的联系人与56号联系起来。它只是碰巧是列表中的下一个可用位置。
- en: 'In this chapter, we are going to look at a similar structure: a dictionary.
    A dictionary uses a keyword instead of an index number. So, if that contact was
    called *James*, we would probably use the keyword *James* to locate the contact.
    That is, instead of accessing the contact by calling *contacts [56]*, we would
    use *contacts ["james"]*.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨一个类似的结构：字典。字典使用关键字而不是索引号。因此，如果那个联系人称之為*James*，我们可能会使用关键字*James*来定位联系人。也就是说，我们不是通过调用*contacts
    [56]*来访问联系人，而是使用*contacts ["james"]*。
- en: Dictionaries are often built using hash tables. As the name suggests, hash tables
    rely on a concept called **hashing**. That is where we are going to begin our
    discussion.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 字典通常使用哈希表构建。正如其名所示，哈希表依赖于一个称为**哈希**的概念。这就是我们将开始讨论的地方。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下主题：
- en: Hashing
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哈希
- en: Hash tables
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哈希表
- en: Different functions with elements
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同元素的函数
- en: Hashing
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 哈希
- en: Hashing is the concept of converting data of arbitrary size into data of fixed
    size. A little bit more specifically, we are going to use this to turn strings
    (or possibly other data types) into integers. This possibly sounds more complex
    than it is so let's look at an example. We want to hash the expression `hello
    world`, that is, we want to get a numeric value that we could say *represents*
    the string.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希是将任意大小的数据转换为固定大小数据的概念。更具体地说，我们将使用它将字符串（或可能的其他数据类型）转换为整数。这可能听起来比实际情况要复杂，让我们来看一个例子。我们想要对表达式`hello
    world`进行哈希，也就是说，我们想要得到一个数值，我们可以说是*代表*这个字符串的。
- en: 'By using the `ord()` function, we can get the ordinal value of any character.
    For example, the `ord(''f'')` function gives 102\. To get the hash of the whole
    string, we could just sum the ordinal numbers of each character in the string:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`ord()`函数，我们可以获取任何字符的序数值。例如，`ord('f')`函数给出102。要获取整个字符串的哈希值，我们只需将字符串中每个字符的序数值相加：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '![](img/image_07_001.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_07_001.jpg)'
- en: 'This works fine. However, note that we could change the order of the characters
    in the string and get the same hash:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这没问题。然而，请注意，我们可以改变字符串中字符的顺序并得到相同的哈希值：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'And the sum of the ordinal values of the characters would be the same for the
    string `gello xorld` as well, since `g` has an ordinal value which is one less
    than that of `h`, and x has an ordinal value that is one greater than that of
    `w`, hence:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 并且字符串`gello xorld`的字符序数值之和也相同，因为`g`的序数值比`h`少一，而`x`的序数值比`w`多一，因此：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '![](img/image_07_002.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_07_002.jpg)'
- en: Perfect hashing functions
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完美哈希函数
- en: A perfect hashing function is one in which each string (as we are limiting the
    discussion to strings for now) is guaranteed to be unique. In practice, hashing
    functions normally need to be very fast, so trying to create a function that will
    give each string a unique hash value is normally not possible. Instead, we live
    with the fact that we sometimes get collisions (two or more strings having the
    same hash value), and when that happens, we come up with a strategy for resolving
    them.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 完美哈希函数是指每个字符串（因为我们现在限制讨论范围在字符串上）都保证是唯一的。在实践中，哈希函数通常需要非常快，因此尝试创建一个为每个字符串提供唯一哈希值的函数通常是不可能的。相反，我们接受有时会出现冲突（两个或更多字符串具有相同的哈希值）的事实，并且当这种情况发生时，我们会想出一个解决冲突的策略。
- en: 'In the meantime, we can at least come up with a way to avoid some of the collisions.
    We could, for example, add a multiplier, so that the hash value for each character
    becomes the multiplier value, multiplied by the ordinal value of the character.
    The multiplier then increases as we progress through the string. This is shown
    in the following function:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在此同时，我们至少可以想出一个避免一些冲突的方法。例如，我们可以添加一个乘数，使得每个字符的哈希值成为乘数值乘以字符的序数值。乘数随着我们遍历字符串而增加。这在上面的函数中显示：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We can test this function on the strings that we used earlier:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在我们之前使用的字符串上测试这个函数：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Running the program, we get the following output:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 运行程序，我们得到以下输出：
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '![](img/image_07_003.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_07_003.jpg)'
- en: Note that the last row is the result of multiplying the values in rows 2 and
    3 such that 104 x 1 equals 104, as an example.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，最后一行是第2行和第3行值的乘积的结果，例如104 x 1 等于 104。
- en: 'This time we get different hash values for our strings. Of course, this doesn''t
    mean that we have a perfect hash. Let us try the strings `ad` and `ga`:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我们得到了不同的哈希值。当然，这并不意味着我们有一个完美的哈希。让我们尝试字符串“ad”和“ga”：
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: There we still get the same hash value for two different strings. As we have
    said before, this doesn't have to be a problem, but we need to devise a strategy
    for resolving collisions. We shall look at that shortly, but first we will study
    an implementation of a hash table.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然得到了两个不同字符串相同的哈希值。正如我们之前所说的，这并不一定是个问题，但我们需要制定一个解决冲突的策略。我们将很快探讨这个问题，但首先我们将研究哈希表的一个实现。
- en: Hash table
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 哈希表
- en: A **hash table** is a form of list where elements are accessed by a keyword
    rather than an index number. At least, this is how the client code will see it.
    Internally, it will use a slightly modified version of our hashing function in
    order to find the index position in which the element should be inserted. This
    gives us fast lookups, since we are using an index number which corresponds to
    the hash value of the key.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**哈希表**是一种列表形式，其中元素是通过关键字而不是索引号来访问的。至少，这是客户端代码将看到的样子。内部，它将使用我们修改过的哈希函数的略微不同版本来找到元素应该插入的索引位置。这使我们能够快速查找，因为我们使用的是与键的哈希值相对应的索引号。'
- en: 'We start by creating a class to hold hash table items. These need to have a
    key and a value, since our hash table is a key-value store:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个类来存储哈希表项。这些项需要一个键和一个值，因为我们的哈希表是一个键值存储：
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This gives us a very simple way to store items. Next, we start working on the
    hash table class itself. As usual, we start off with a constructor:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这为我们提供了一个非常简单的方式来存储项。接下来，我们开始着手实现哈希表类本身。像往常一样，我们从构造函数开始：
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The hash table uses a standard Python list to store its elements. We could equally
    well have used the linked list that we developed previously, but right now our
    focus is on understanding the hash table, so we shall use what is at our disposal.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希表使用标准的 Python 列表来存储其元素。我们同样可以使用我们之前开发的链表，但现在的重点是理解哈希表，所以我们将使用我们手头可用的工具。
- en: 'We set the size of the hash table to 256 elements to start with. Later, we
    will look at strategies for how to grow the table as we begin filling it up. We
    now initialize a list containing 256 elements. These elements are often referred
    to as slots or buckets. Finally, we add a counter for the number of actual hash
    table elements we have:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一开始将哈希表的大小设置为256个元素。稍后，我们将探讨如何随着表的填充增长表的大小。我们现在初始化一个包含256个元素的列表。这些元素通常被称为槽或桶。最后，我们添加一个计数器来记录我们拥有的实际哈希表元素数量：
- en: '![](img/image_07_004.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_07_004.jpg)'
- en: It is important to notice the difference between the size and count of a table.
    Size of a table refers to the total number of slots in the table (used or unused).
    Count of the table, on the other hand, simply refers to the number of slots that
    are filled, or put another way, the number of actual key-value pairs we have added
    to the table.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意表的大小和计数的区别。表的大小指的是表中的总槽位数（使用或未使用）。另一方面，表的计数仅指已填满的槽位数，或者换句话说，我们添加到表中的实际键值对的数量。
- en: 'Now, we are going to add our hashing function to the table. It will be similar
    to what we evolved in the section on hashing functions, but with a slight difference:
    we need to ensure that our hashing function returns a value between 1 and 256
    (the size of the table). A good way of doing so is to return the remainder of
    dividing the hash by the size of the table, since the remainder is always going
    to be an integer value between 0 and 255.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将添加我们的散列函数到表中。它将类似于我们在散列函数部分所发展的，但有一点不同：我们需要确保我们的散列函数返回一个介于1和256（表的大小）之间的值。这样做的一个好方法是返回散列除以表大小的余数，因为余数始终是一个介于0和255之间的整数值。
- en: 'As the hashing function is only meant to be used internally by the class, we
    put an underscore(`_`) at the beginning of the name to indicate this. This is
    a normal Python convention for indicating that something is meant for internal
    use:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 由于散列函数仅打算由类内部使用，我们在名称前加上下划线(`_`)来表示这一点。这是Python表示某物打算用于内部使用的正常约定：
- en: '[PRE9]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: For the time being, we are going to assume that keys are strings. We shall discuss
    how one can use non-string keys later. For now, just bear in mind that the `_hash()` function
    is going to generate the hash value of a string.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们将假设键是字符串。我们将在稍后讨论如何使用非字符串键。现在，请记住，`_hash()`函数将生成字符串的哈希值。
- en: Putting elements
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加元素
- en: 'We add elements to the hash with the `put()` function and retrieve with the `get()`
    function. First, we will look at the implementation of the `put()` function. We
    start by embedding the key and the value into the `HashItem` class and computing
    the hash of the key:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`put()`函数向哈希表中添加元素，并使用`get()`函数检索。首先，我们将查看`put()`函数的实现。我们首先将键和值嵌入到`HashItem`类中，并计算键的哈希值：
- en: '[PRE10]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now we need to find an empty slot. We start at the slot that corresponds to
    the hash value of the key. If that slot is empty, we insert our item there.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要找到一个空槽位。我们从与键的哈希值相对应的槽位开始。如果那个槽位是空的，我们就将我们的项目插入那里。
- en: 'However, if the slot is not empty and the key of the item is not the same as
    our current key, then we have a collision. This is where we need to figure out
    a way to handle a conflict. We are going to do this by adding one to the previous
    hash value we had and getting the remainder of dividing this value by the size
    of the hash table. This is a linear way of resolving collisions and it is quite
    simple:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果槽位不为空，并且项目的键与我们的当前键不同，那么我们就遇到了冲突。这就是我们需要想出处理冲突的方法的地方。我们将通过将前一个哈希值加一来实现这一点，并得到这个值除以哈希表大小的余数。这是一种解决冲突的线性方法，相当简单：
- en: '![](img/image_07_005.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_07_005.jpg)'
- en: '[PRE11]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We have found our insertion point. If this is a new element (that is, it contained
    `None` previously), then we increase the count by one. Finally, we insert the
    item into the list at the required position:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们找到了插入点。如果这是一个新元素（即，它之前包含`None`），那么我们增加计数器一。最后，我们将项目插入到所需的列表位置：
- en: '[PRE12]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Getting elements
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取元素
- en: 'The implementation of the `get()` method should return the value that corresponds
    to a key. We also have to decide what to do in the event that the key does not
    exist in the table. We start by calculating the hash of the key:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`get()`方法的实现应该返回与键相对应的值。我们还必须决定在键在表中不存在时应该做什么。我们首先计算键的哈希值：'
- en: '[PRE13]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, we simply start looking through the list for an element that has the key
    we are searching for, starting at the element which has the hash value of the
    key that was passed in. If the current element is not the correct one, then, just
    like in the `put()` method, we add one to the previous hash value and get the
    remainder of dividing this value by the size of the list. This becomes our new
    index. If we find an element that contains `None`, we stop looking. If we find
    our key, we return the value:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们简单地从列表中查找具有我们正在搜索的键的元素，从具有传递的键的哈希值的元素开始。如果当前元素不是正确的，那么，就像在`put()`方法中一样，我们将前一个哈希值加一，并得到这个值除以列表大小的余数。这个值成为我们的新索引。如果我们找到一个包含`None`的元素，我们就停止查找。如果我们找到我们的键，我们就返回值：
- en: '![](img/image_07_006.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_07_006.jpg)'
- en: '[PRE14]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Finally, we decide what to do if the key was not found in the table. Here we
    will choose to return `None`. Another good alternative may be to raise an exception:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们决定如果键在表中未找到时应该做什么。在这里，我们将选择返回`None`。另一个好的选择可能是抛出一个异常：
- en: '[PRE15]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Testing the hash table
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试哈希表
- en: 'To test our hash table, we create a `HashTable`, put a few elements in it,
    then try to retrieve these. We will also try to `get()` a key that does not exist.
    Remember the two strings ad and ga which returned the same hash value by our hashing
    function? For good measure, we throw those in as well, just to see that the collision
    is properly resolved:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试我们的哈希表，我们创建了一个`HashTable`，在其中放入一些元素，然后尝试检索这些元素。我们还将尝试`get()`一个不存在的键。还记得我们通过哈希函数返回相同哈希值的两个字符串ad和ga吗？为了确保，我们将它们也加入其中，只是为了看看碰撞是否得到了适当的解决：
- en: '[PRE16]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Running this returns the following:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码返回以下结果：
- en: '[PRE17]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As you can see, looking up the key worst returns `None`, since the key does
    not exist. The keys `ad` and `ga` also return their corresponding values, showing
    that the collision between them is dealt with.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，查找键worst返回`None`，因为该键不存在。键`ad`和`ga`也返回它们对应的值，这表明它们之间的碰撞得到了处理。
- en: Using [] with the hash table
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用哈希表中的[]
- en: 'Using the `put()` and `get()` methods doesn''t look very good, however. We
    want to be able to treat our hash table as a list, that is, we would like to be
    able to use `ht["good"]` instead of `ht.get("good")`. This is easily done with
    the special methods `__setitem__()` and `__getitem__()`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`put()`和`get()`方法看起来不太好。我们希望将我们的哈希表当作列表来处理，也就是说，我们希望能够使用`ht["good"]`而不是`ht.get("good")`。这可以通过特殊方法`__setitem__()`和`__getitem__()`轻松实现：
- en: '[PRE18]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Our test code can now look like this instead:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的可测试代码现在可以像这样：
- en: '[PRE19]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Notice that we also print the number of elements in the hash table. This is
    useful for our next discussion.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们还打印了哈希表中的元素数量。这对于我们接下来的讨论很有用。
- en: Non-string keys
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 非字符串键
- en: In most cases, it makes more sense to just use strings for the keys. However,
    if necessary, you could use any other Python type. If you create your own class
    that you want to use as a key, you will probably want to override the special
    `__hash__()` function for that class, so that you get reliable hash values.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，只使用字符串作为键更有意义。然而，如果需要，你可以使用任何其他Python类型。如果你创建了自己的类，并希望将其用作键，你可能需要覆盖该类的特殊`__hash__()`函数，以便获得可靠的哈希值。
- en: Note that you would still have to calculate the modulo (%) of the hash value
    and the size of the hash table to get the slot. That calculation should happen
    in the hash table and not in the key class, since the table knows its own size
    (the key class should not know anything about the table that it belongs to).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你仍然需要计算哈希值和哈希表大小的模（%）以获得槽位。这个计算应该在哈希表中发生，而不是在键类中，因为表知道它自己的大小（键类不应该了解它所属的表）。
- en: Growing a hash table
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展哈希表
- en: In our example, the hash table's size was set to 256\. Obviously, as we add
    elements to the list, we begin to fill up the empty slots. At some point, all
    the slots will be filled up and the table will be full. To avoid this, we can
    grow the table when it is getting full.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，哈希表的大小被设置为256。显然，当我们向列表中添加元素时，我们开始填满空槽位。在某个时刻，所有的槽位都将被填满，表将满。为了避免这种情况，我们可以在表满时扩展表。
- en: To do this, we compare the size and the count. Remember that `size` held the
    total number of slots and `count` the number of those slots that contained elements?
    Well, if `count` equals `size` then we have filled up the table.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们比较大小和计数。还记得`size`保存了槽位的总数，而`count`保存了包含元素的槽位数量吗？好吧，如果`count`等于`size`，那么我们就填满了表。
- en: 'The hash table''s load factor gives us an indication of how large a portion
    of the available slots are being used. It is defined as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希表的负载因子给我们提供了一个关于可用槽位中有多少部分被使用的指示。它定义如下：
- en: '![](img/image_07_007.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_07_007.jpg)'
- en: As the load factor approaches 1, we need to grow the table. In fact, we should
    do it before it gets there in order to avoid gets becoming too slow. A value of
    0.75 may be a good value in which to grow the table.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当负载因子接近1时，我们需要扩展表。实际上，我们应该在它到达那里之前就做这件事，以避免查找变得太慢。0.75可能是一个增长表的好值。
- en: The next question is how much to grow the table by. One strategy would be to
    simply double the size of the table.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个问题是如何确定表的增长量。一种策略是简单地加倍表的大小。
- en: Open addressing
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开放寻址
- en: The collision resolution mechanism we used in our example, linear probing, is
    an example of an open addressing strategy. Linear probing is really simple since
    we use a fixed interval between our probes. There are other open addressing strategies
    as well but they all share the idea that there is an array of slots. When we want
    to insert a key, we check whether the slot already has an item or not. If it does,
    we look for the next available slot.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在示例中使用的冲突解决机制，线性探测，是开放寻址策略的一个例子。线性探测非常简单，因为我们使用固定的探测间隔。还有其他开放寻址策略，但它们都共享一个想法，即有一个槽位数组。当我们想要插入一个键时，我们会检查槽位是否已经有一个项目。如果有，我们会寻找下一个可用的槽位。
- en: If we have a hash table that contains 256 slots, then 256 is the maximum number
    of elements in that hash. Moreover, as the load factor increases, it will take
    longer to find the insertion point for the new element.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一个包含256个槽位的哈希表，那么256是该哈希表中的最大元素数。此外，随着负载因子的增加，找到新元素插入点所需的时间会更长。
- en: Because of these limitations, we may prefer to use a different strategy to resolve
    collisions, such as chaining.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些限制，我们可能更喜欢使用不同的策略来解决冲突，例如链接。
- en: Chaining
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 链接
- en: 'Chaining is a strategy for resolving conflicts and avoiding the limit to the
    number of elements in a hash table. In chaining, the slots in the hash table are
    initialized with empty lists:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 链接是一种解决冲突和避免哈希表元素数量限制的策略。在链接中，哈希表的槽位被初始化为空列表：
- en: '![](img/image_07_008.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_07_008.jpg)'
- en: 'When an element is inserted, it will be appended to the list that corresponds
    to that element''s hash value. That is, if you have two elements that both have
    the hash value 1167, these two elements will both be added to the list that exists
    in slot 1167 of the hash table:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个元素被插入时，它将被添加到与该元素哈希值相对应的列表中。也就是说，如果你有两个元素，它们的哈希值都是1167，这两个元素都将被添加到哈希表槽位1167中存在的列表中：
- en: '![](img/image_07_009.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_07_009.jpg)'
- en: The preceding diagram shows a list of entries with hash value 51.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图示显示了一个具有哈希值51的条目列表。
- en: Chaining then avoids conflict by allowing multiple elements to have the same
    hash value. It also avoids the problem of insertions as the load factor increases,
    since we don't have to look for a slot. Moreover, the hash table can hold more
    values than the number of available slots, since each slot holds a list that can
    grow.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 链接通过允许多个元素具有相同的哈希值来避免冲突。它还避免了随着负载因子增加而插入的问题，因为我们不需要寻找槽位。此外，哈希表可以存储比可用槽位更多的值，因为每个槽位可以包含一个可以增长的列表。
- en: 'Of course, if a particular slot has many items, searching them can get very
    slow, since we have to do a linear search through the list until we find the element
    that has the key we want. This can slow down retrieval, which is not good, since
    hash tables are meant to be efficient:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果一个特定的槽位包含很多项，搜索它们可能会变得非常慢，因为我们不得不在列表中进行线性搜索，直到找到具有我们想要的关键字的元素。这可能会减慢检索速度，这并不好，因为哈希表旨在高效：
- en: '![](img/image_07_010.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_07_010.jpg)'
- en: The preceding diagram demonstrates a linear search through list items until
    we find a match.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图示演示了通过列表项进行线性搜索，直到找到匹配项。
- en: 'Instead of using lists in the table slots, we could use another structure that
    allows for fast searching. We have already looked at **binary search trees** (**BSTs**).
    We could simply put an (initially empty) BST in each slot:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在表槽位中使用另一种允许快速搜索的结构。我们已经研究了**二叉搜索树**（BST）。我们可以在每个槽位中简单地放置一个（最初为空）BST：
- en: '![](img/image_07_011.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_07_011.jpg)'
- en: Slot 51 holds a BST which we search for the key.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 槽位51包含一个BST，我们搜索该键。
- en: 'But we would still have a potential problem: depending on the order in which
    the items were added to the BST, we could end up with a search tree that is as
    inefficient as a list. That is, each node in the tree has exactly one child. To
    avoid this, we would need to ensure that our BST is self-balancing.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们仍然可能遇到一个问题：根据项目添加到BST的顺序，我们可能会得到一个与列表一样低效的搜索树。也就是说，树中的每个节点恰好有一个子节点。为了避免这种情况，我们需要确保我们的BST是自平衡的。
- en: Symbol tables
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 符号表
- en: Symbol tables are used by compilers and interpreters to keep track of the symbols
    that have been declared and information about them. Symbol tables are often built
    using hash tables, since it is important to efficiently retrieve a symbol in the
    table.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 符号表被编译器和解释器用来跟踪已声明的符号及其信息。由于在表中高效检索符号很重要，符号表通常使用哈希表构建。
- en: 'Let us look at an example. Suppose we have the following Python code:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子。假设我们有以下Python代码：
- en: '[PRE20]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here we have two symbols, name and age. They belong to a namespace, which could
    be `__main__`, but it could also be the name of a module if you placed it there.
    Each symbol has a value; name has the value `Joe` and age has the value `27`.
    A symbol table allows the compiler or the interpreter to look these values up.
    The symbols name and age become the keys in our hash table. All the other information
    associated with it, such as the value, become part of the value of the symbol
    table entry.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有两个符号，name和age。它们属于一个命名空间，这可能是一个`__main__`，也可能是你放置它的模块的名称。每个符号都有一个值；name的值是`Joe`，age的值是`27`。符号表允许编译器或解释器查找这些值。符号name和age成为我们哈希表中的键。与之相关的所有其他信息，如值，都成为符号表条目值的一部分。
- en: 'Not only variables are symbols, but functions and classes as well. They will
    all be added to our symbol table, so that when any one of them needs to be accessed,
    they are accessible from the symbol table:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅变量是符号，函数和类也是。它们都将被添加到我们的符号表中，以便当任何一个需要被访问时，它们都可以从符号表中访问：
- en: '![](img/image_07_012.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_07_012.jpg)'
- en: 'In Python, each module that is loaded has its own symbol table. The symbol
    table is given the name of that module. This way, modules act as namespaces. We
    can have multiple symbols called age, as long as they exist in different symbol
    tables. To access either one, we access it through the appropriate symbol table:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，每个被加载的模块都有自己的符号表。符号表被赋予该模块的名称。这样，模块充当命名空间。只要它们存在于不同的符号表中，我们可以有多个名为age的符号。要访问任何一个，我们通过适当的符号表来访问：
- en: '![](img/image_07_013.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_07_013.jpg)'
- en: Summary
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have looked at hash tables. We looked at how to write a
    hashing function to turn string data into integer data. Then we looked at how
    we can use hashed keys to quickly and efficiently look up the value that corresponds
    to a key.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们研究了哈希表。我们研究了如何编写哈希函数将字符串数据转换为整数数据。然后我们研究了如何使用哈希键快速有效地查找与键相对应的值。
- en: We also noticed how hashing functions are not perfect and that several strings
    can end up having the same hash value. This led us to look at collision resolution
    strategies.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也注意到了哈希函数并不完美，有时几个字符串可能会得到相同的哈希值。这促使我们去研究冲突解决策略。
- en: We looked at growing a hash table and how to look at the load factor of the
    table in order to determine exactly when to grow the hash.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们研究了哈希表的增长以及如何观察表的负载因子，以确定何时扩展哈希。
- en: In the last section of the chapter, we studied symbol tables, which often are
    built using hash tables. Symbol tables allow a compiler or an interpreter to look
    up a symbol (variable, function, class, and so on) that has been defined and retrieve
    all information about it.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后部分，我们研究了符号表，这些符号表通常使用哈希表构建。符号表允许编译器或解释器查找已定义的符号（变量、函数、类等），并检索有关它的所有信息。
- en: In the next chapter, we will talk about graphs and other algorithms.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论图和其他算法。
