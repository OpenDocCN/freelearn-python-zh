- en: Chapter 2. Working with Python on Intel Galileo Gen 2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will start our journey towards Internet of Things (IoT)
    with Python and the Intel Galileo Gen 2 board. We shall:'
  prefs: []
  type: TYPE_NORMAL
- en: Set up the environment to start working with Python as the main programming
    language
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Retrieve the board's assigned IP address after it boots a Yocto Linux distribution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connect to the board's operating system and run commands on it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Install and upgrade the necessary libraries to interact with the board's component
    with Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run our first lines of Python code in the board
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up the board to work with Python as the programming language
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There is some work to be done in order to start working with Python as the
    main programming language to control this board. We need the following additional
    elements that aren''t included in the board''s box:'
  prefs: []
  type: TYPE_NORMAL
- en: A microSD card of at least 4 GB with a maximum supported capacity of 32 GB.
    It is convenient to use a speed class 4 or a faster microSD card. Note that you
    will lose all the contents of the microSD card.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A microSD to SD memory card adapter. The adapter is usually included within
    a microSD card's package.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A computer with an SD memory card reader. Most modern laptops and desktop computers
    include SD mermory card readers. However, in case you don't have one, you can
    buy a USB SD memory card reader and plug it to a free USB port in your computer.
    SD memory card readers are in fact read/write devices, and therefore, we can use
    them to write to a microSD card via the microSD to SD memory card adapter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An Ethernet cable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An Ethernet switch or a WiFi router with a free Ethernet port. You will connect
    the Intel Galileo Gen 2 board to your LAN.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In case you do not have access to your LAN's switch, you will have to ask your
    network administrator for advice.
  prefs: []
  type: TYPE_NORMAL
- en: The next picture shows an 8 GB speed class 4 microSD card labeled **SDC4/8GB**
    (left) and a microSD to SD memory card adapter (right).
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up the board to work with Python as the programming language](img/B05042_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We have to download the latest version of the Yocto Linux meta distribution
    boot image from the Intel IoT Development Kit Images Repository website. Open
    [http://iotdk.intel.com/images/](http://iotdk.intel.com/images/) in your Web browser
    and download the `iot-devkit-latest-mmcblkp0.direct.bz2` compressed file with
    the boot image listed on the Web page. You can also download it by entering the
    full URL in your Web browser: [http://iotdk.intel.com/images/iot-devkit-latest-mmcblkp0.direct.bz2](http://iotdk.intel.com/images/iot-devkit-latest-mmcblkp0.direct.bz2).'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will use the `devkit-latest-mmcblkp0.direct.bz2` file, last modified on July
    2, 2015\. Make sure that you don't download any version releases sooner than this
    date because there are many differences in the package names used in previous
    releases that aren't compatible with the instructions provided later on in this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have downloaded the file, it is necessary to decompress the downloaded
    image file and write the extracted image to the microSD card. The procedure is
    different in Windows and Mac OS X.
  prefs: []
  type: TYPE_NORMAL
- en: In Windows, you can use 7-Zip to extract the contents from the downloaded `.bz2`
    file. 7-Zip is a free and open source software that you can download from [http://www.7-zip.org](http://www.7-zip.org).
  prefs: []
  type: TYPE_NORMAL
- en: Once you extract the Yocto Linux meta distribution boot image `iot-devkit-latest-mmcblkp0.direct`
    from the `.bz2` file, you have to write this image to the microSD card. Insert
    the microSD card into the microSD to SD memory card adapter and insert the adapter
    into the computer's SD memory card reader.
  prefs: []
  type: TYPE_NORMAL
- en: The Win32 Disk Imager tool is an image writer for Windows that allows us to
    write images to USB sticks or SD/CF cards. You can use this free software to write
    the image to the microSD card. You can download it from [http://sourceforge.net/projects/win32diskimager/files/Archive](http://sourceforge.net/projects/win32diskimager/files/Archive).
    The installer for the latest version is the `Win32DiskImager-0.9.5-install.exe`
    file. Once you install the software, take into account that you must execute the
    application as an administrator in Windows. You can right-click on the application's
    icon and select **Run as administrator**.
  prefs: []
  type: TYPE_NORMAL
- en: Click on the icon on the right-hand side of the **Image File** textbox and change
    the files filter from **Disk Images (*.img *.IMG)** to ***.*** so that you can
    select the Yocto Linux boot image with a **direct** extension.
  prefs: []
  type: TYPE_NORMAL
- en: Select the drive letter that Windows assigned to the microSD card in the **Device**
    dropdown.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Make sure that you select the right drive letter because all the contents for
    the drive will be erased and overwritten with the boot image. If you select the
    incorrect drive letter, you will lose the contents of the entire drive.
  prefs: []
  type: TYPE_NORMAL
- en: Click on **Write** and then click on **Yes** in the confirm overwrite dialog
    box. Now, wait until the tool finishes writing the contents to the microSD card.
    The following screenshot shows the **Win32 Disk Imager** tool displaying the progress
    while it writes the image to the microSD card in Windows 10.
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up the board to work with Python as the programming language](img/B05042_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It will take a few minutes until the tool finishes writing the image to the
    microSD card. Once the writing process has finished, the tool will display a **Complete**
    dialog box with a **Write successful** message. Click on **OK** to close the dialog
    box and close the Win32 Disk Imager window.
  prefs: []
  type: TYPE_NORMAL
- en: Eject the microSD card in Windows and then remove the SD memory card adapter
    from the SD card reader.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Mac OS X and Linux, you can use `bunzip2` to extract the contents from the
    downloaded **bz2** file, `diskutil` to unmount the microSD card, and `dd` to write
    the image to the microSD card. It is also possible to open a **Terminal** and
    unzip the downloadeded bz2 file by running the following command in the folder
    in which you downloaded the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You need to be very careful with the commands to avoid erasing a wrong device
    such as a partition of your hard drive.
  prefs: []
  type: TYPE_NORMAL
- en: It is also possible to unzip the downloaded bz2 file by double-clicking on it
    on Finder. However, we will be running more commands in the **Terminal** window,
    and therefore, it is easier to start unzipping the file with a command.
  prefs: []
  type: TYPE_NORMAL
- en: Once you extract the Yocto Linux boot image `iot-devkit-latest-mmcblkp0.direct`
    from the bz2 file, you have to write this image to the microSD card. Insert the
    microSD card into the microSD to SD memory card adapter and then insert the adapter
    into the computer's SD memory card reader. Launch the **Disk Utility** application
    and check the details for the media connected to the card reader. For example,
    in any MacBook laptop, you will find the info by clicking on **APPLE SD Card Reader
    Media** and then on the **Info** button. Check the name listed in **Device name**
    or **BSD device node**. We will use this name in a command that will write the
    boot image to the microSD card. The following picture shows the **Disk Utility**
    application and the information for a microSD card whose device name is **disk2**.
    We just need to add `/dev/` as a prefix to the gathered device name, and therefore,
    in this sample case, the complete name is `/dev/disk2`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up the board to work with Python as the programming language](img/B05042_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'It is also possible to gather the information by running the `diskutil` command
    to list all the devices and find out the device name assigned to the microSD card.
    However, the information provided by this command is a bit difficult to read and
    the **Disk Utility** application makes it easy to understand which is the device
    name for the memory card reader. The following command lists all the devices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the sample output generated by this command. The highlighted
    lines show the device name for the microSD card: `/dev/disk2`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Make sure that you take note of the right device name because all the contents
    for the drive will be erased and overwritten with the boot image. If you specify
    a wrong device name, you will lose the contents of the entire drive.
  prefs: []
  type: TYPE_NORMAL
- en: Unmount the microSD card with the following command. You need to replace `/dev/devicename`
    with `/dev/disk2` in case the device name you gathered was `disk2`. If not, replace
    it with the appropriate device name.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The **Terminal** will ask for your password and will unmount the microSD card.
    Run the following `dd` command to write the image in the input file named `iot-devkit-latest-mmcblkp0.direct`
    to the microSD card in the device name you gathered in the previous step. You
    need to replace `of=/dev/devicename` with `of=/dev/disk2` in case the device name
    you gathered was `disk2`. If not, replace it with the appropriate device name.
    The command doesn't include a device name so that you don't overwrite any of your
    disks by accident.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, it will take some time to write the image to the microSD card. Wait until
    the command finishes and the `Terminal` displays the prompt again. Notice that
    it usually takes a few minutes and there is no output with any progress indication
    until the write process finishes. You will see the following output after the
    command finishes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now, unmount the microSD card with the following command. You need to replace
    `/dev/devicename` with `/dev/disk2` in case the device name you gathered was `disk2`.
    If not, replace it with the appropriate device name.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Close the terminal window and then remove the SD memory card adapter from the
    SD card reader.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we have a microSD card with a Yocto Linux distribution that includes Python
    2.7.3 and many useful libraries and utilities. It is time to make the Intel Galileo
    Gen 2 board boot from the Yocto image written to the microSD card.
  prefs: []
  type: TYPE_NORMAL
- en: Make sure that the board is unplugged and place the microSD card with the Yocto
    image in the microSD card slot on the board, labeled **SDIO**. The following picture
    shows a microSD card inserted in the slot on the board.
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up the board to work with Python as the programming language](img/B05042_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Then, connect the board to your LAN with the Ethernet cable and plug the board's
    power supply to turn on the board and start it up. You will notice that the rectangular
    onboard LED labeled **SD** indicates that there is activity with the microSD card.
    Wait for approximately 30 seconds to make sure that the board finishes the boot
    process. You will notice that the LED labeled **SD** stops blinking after the
    boot process finishes.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving the board's assigned IP address
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The board has finished the boot process with the Yocto Linux microSD card and
    is connected to our LAN throught the Ethernet port. The DHCP server has assigned
    the board an IP address and we need to know it in order to run commands on a Yocto
    Linux console. There are many ways for us to retrieve the board's assigned IP
    address. We will explore the different options and you can choose the most convenient
    one based on your LAN configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the board is connected to one of the Ethernet ports of a Wireless router
    and we have access to the router''s Web interface, we can easily know the IP address
    assigned to the board. Some router''s Web interfaces display the wired clients
    list. As our board is connected through an Ethernet wire, it will be listed as
    one of the wired clients and the device MAC address will match the MAC address
    printer in the adhesive label on the board''s Ethernet jacket. The following picture
    shows the Wired-clients list in a router''s Web interface and the list includes
    a device named **galileo** with **A1-B2-C3-D4-E5-F6** as the MAC address that
    matches the MAC address printed without hyphens (-) in the board: **A1B2C3D4E5F6**.
    The IP address assigned to the board is **192.168.1.104**. For security reasons,
    the original MAC address has been erased and we are using a fake MAC address for
    our example.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Retrieving the board''s assigned IP address](img/B05042_02_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Sometimes, the router''s Web interface doesn''t provide an option that displays
    the wired clients list. If this is the case for our router, we will always be
    able to retrieve the DHCP client list that provides all the IP addresses assigned
    to either the wireless or wired devices connected to the LAN. We just need to
    find the device that has the MAC address for the board. The following picture
    shows the DHCP Client List in a router''s Web interface and the list includes
    a device named **galileo** with **A1-B2-C3-D4-E5-F6** as the MAC address that
    matches the MAC address printed without hyphens (-) in the board: **A1B2C3D4E5F6**.
    The IP address assigned to the board is **192.168.1.104**.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Retrieving the board''s assigned IP address](img/B05042_02_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Another option is to install a Bonjour Browser to discover the board and its
    services on the LAN automatically through this zero-configuration networking implementation,
    without knowing the IP assigned to the board.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Windows, download, install, and launch the free Bonjour Browser for Windows
    from [http://hobbyistsoftware.com/bonjourbrowser](http://hobbyistsoftware.com/bonjourbrowser).
    The application will display many available Bonjour services with **galileo**
    as their name. The following screenshot shows the **_ssh._tcp** service type with
    **galileo** as its name selected with the details. The **IP Adresses** section
    shows the IP address and the port number for the SSH service: **192.168.1.105:22**.
    We can use the IP address with any SSH client to connect to the board. In addition,
    the Bonjour browser lets us know that the board has an SFTP service that will
    make it easy for us to transfer files from and to the Yocto Linux running on the
    board.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Retrieving the board''s assigned IP address](img/B05042_02_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In OS X, download and run the free Bonjour Browser from [http://www.tildesoft.com](http://www.tildesoft.com).
    You can click on **Reload Services** to refresh the discovered devices and their
    services. The following picture shows a board and its services listed in the Bonjour
    Browser. You have to click on each right-arrow to expand the details for each
    listed service. In this case, all the services are provided by the same device
    named **galileo**. Once you expand the device, the application displays the IPv4
    and IPv6 addresses. The **SSH (_ssh._tcp.)** service type lists a device with
    **galileo** as its name and with **192.168.1.105:22** as the IPv4 address and
    the port number. We can use the IP address with any SSH client to connect to the
    board. The Bonjour Browser also displays the details for the SFTP service.
  prefs: []
  type: TYPE_NORMAL
- en: '![Retrieving the board''s assigned IP address](img/B05042_02_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: SSH stands for Secure Shell Protocol and its default port is 22\. Yocto Linux
    runs the SSH server in the default port, and therefore, there is no need to specify
    the port in SSH clients, we can just specify the discovered IP address.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to the board's operating system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we need to use an SSH client to connect to the Yocto Linux running on the
    board and update some libraries that we will use to interact with the board's
    components and features. Both OS X and Linux include the `ssh` command in the
    Terminal. However, Windows doesn't include an `ssh` command and we have to install
    an SSH client.
  prefs: []
  type: TYPE_NORMAL
- en: In Windows, we can use the free and open source PuTTY SSH and telnet client.
    However, if you have any other preference for an SSH client in Windows, you can
    use any other software. The commands we execute in the terminal will be the same
    no matter what SSH client we use.
  prefs: []
  type: TYPE_NORMAL
- en: We can download and install PuTTY in Windows from [http://www.putty.org](http://www.putty.org)
    or [http://www.chiark.greenend.org.uk/~sgtatham/putty/download.html](http://www.chiark.greenend.org.uk/~sgtatham/putty/download.html).
    Once you install it, launch it and make sure you allow Windows firewall or any
    other installed firewall to open the necessary ports to make the connections.
    You will see warnings popping up depending on the firewall software that is running
    on Windows.
  prefs: []
  type: TYPE_NORMAL
- en: After you launch PuTTY, the application will display the **PuTTY Configuration**
    dialog box. Enter the IP address assigned to your board in the **Host Name (or
    IP address)** textbox and leave the **Port** value to its default **22** value.
    The following picture shows the dialog box with the settings to connect to the
    board whose assigned IP is **192.168.1.105**. You can leave the default settings.
    However, you should definitely change the **Window | Appearance** settings to
    change the default font.
  prefs: []
  type: TYPE_NORMAL
- en: '![Connecting to the board''s operating system](img/B05042_02_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Click on **Open** and the first time you want to establish a connection; PuTTY
    will display a security alert because the server's host key is not cached in the
    registry. You trust your board and the Yocto Linux that is running on it, and
    therefore, just click on **Yes**. The following picture shows the security alert.
  prefs: []
  type: TYPE_NORMAL
- en: '![Connecting to the board''s operating system](img/B05042_02_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: PuTTY will display a new window, specifically a terminal window, with the IP
    address included in the title. You will see the following message asking you to
    enter the login user.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Enter **root** and press *Enter*. You will login as the `root` user that doesn''t
    require a password in the Yocto Linux default configuration. Now, you can run
    any shell commands. For example, you can enter the following command to check
    the installed python version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The following picture shows a PuTTY terminal window with the results of logging
    in as root and running a few commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Connecting to the board''s operating system](img/B05042_02_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In OS X and Linux, you can open a **Terminal** and run the `ssh` command to
    connect to the Yocto Linux running on the board. You have to enter `ssh` followed
    by a space, the user name, an arrow (@), and the IP. In this case, we want to
    connect with root as the user name, and therefore, we will enter `ssh` followed
    by a space, `root@`, and then the IP address. The following command works with
    the board that is running the SSH server in the `192.168.1.105` IP address and
    port number 22\. You have to replace `192.168.1.105` with the IP address you retrieved.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The first time you want to establish a connection, the `ssh` command will display
    a security alert because the authenticity of the host can't be established. You
    trust your board and the Yocto Linux that is running on it, and therefore, answer
    **yes** to a question that will be similar to the following one and press *Enter*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ssh` command will display a message similar to the following line after
    you answer **yes** and press *Enter*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: You will log in as the `root` user that does not require a password in the Yocto
    Linux default configuration. Now, you can run any shell command. For example,
    you can enter the following command to check the installed Python version.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that while you see the following prompt **root@galileo:~#**, it means
    that all your commands are running on the Yocto Linux on the board and not on
    your OS X Terminal or your Linux Terminal. The following picture shows an OS X
    **Terminal** window with the results of logging in as `root` and running a few
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Connecting to the board''s operating system](img/B05042_02_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Yocto Linux that the board has booted includes Python 2.7.3 pre-installed.
  prefs: []
  type: TYPE_NORMAL
- en: We can also run any SSH client in a mobile device such as a tablet or smartphone.
    There are many SSH clients developed for iOS and Android. It is possible to work
    with a tablet and a Bluetooth keyboard linked to it and easily run the commands
    in the SSH client.
  prefs: []
  type: TYPE_NORMAL
- en: Installing and upgrading the necessary libraries to interact with the board
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we will run many commands in the SSH client. Make sure that your SSH client
    is connected to the Yocto Linux SSH server running on the board as explained in
    the preceding section before running the commands. Specially, if you are working
    with either OS X or Linux, you have to make sure that you don't run the commands
    on your computer instead of doing this on the remote shell. Its simple, just make
    sure you always see the prompt **root@galileo:~#** before running any command.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Your board should be connected to a LAN with Internet access because we will
    download content from the Internet.
  prefs: []
  type: TYPE_NORMAL
- en: We will use the `opkg` utility to download and install the updated version of
    both the `mraa` and `upm` libraries. The `mraa` library, also known as `libmraa`,
    is a low level C/C++ library with bindings to Python that allows us to interface
    with the I/O features on the Intel Galileo Gen 2 board and other supported platforms.
    The `upm` library provides high-level interfaces for sensors and actuators that
    we can plug to the platforms supported by the `mraa` library. The `upm` library
    simplifies working with sensors and actuators and includes bindings to Python.
    We will be working with both libraries in the forthcoming chapters, and therefore,
    we want to have their latest versions installed.
  prefs: []
  type: TYPE_NORMAL
- en: The `opkg` utility is a lightweight package manager that allows us to easily
    download and install OpenWrt packages. OpenWrt is a Linux distribution for embedded
    devices. First, we will check both the mraa and upm installed versions by using
    the `opkg` utility.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to check the installed mraa version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The following lines show the output with the version and dependencies for the
    mraa package. In this case, the output shows that the installed version for mraa
    is **0.7.2-r0**.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following command to check the installed upm version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The following lines show the output with the version and dependencies for the
    upm package. In this case, the output shows that the installed version for upm
    is **0.3.1-r0**.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Run the following command to check the repository configuration for both the
    `mraa` and upm libraries.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: If you see the following line as a response, it means that the repository is
    configured to work with the 1.5 version and we need to change its configuration
    to make it possible to update both the mraa and upm libraries to their latest
    versions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following command to configure the repository for both the mraa and
    upm libraries to work with version 2.0 instead of 1.5:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Now, run the following command to check the repository configuration for both
    the mraa and upm libraries and you will notice that `1.5` has been replaced by
    `2.0` in the output.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the results shown in the next line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We will use the `opkg` utility to update packages from the previously configured
    repository located on the Internet. Run the following command to make the `opkg`
    utility update the list of available packages after we changed the configuration
    of the repositories for both the mraa and upm libraries.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The previous command will generate the following output that indicates the list
    of available packages that have been updated. Notice that the last lines of the
    output indicate that the command has been downloaded from `http://iotdk.intel.com/repos/2.0/intelgalactic/Packages`
    and saved the available packages in `/var/lib/opkg/mraa-upm`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Run the following command to check the versions for both the mraa and upm libraries
    stored in `/var/lib/opkg/mraa-upm`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The following lines show the results. Notice that the version numbers might
    vary because both the mraa and upm libraries are very active projects and they
    are frequently updated. Thus, the version numbers might be higher when you run
    the previous command.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we have mraa version **0.9.0** and upm version **0.4.1**. The
    version numbers are higher than the initially installed ones. We definitely want
    to upgrade mraa **0.7.2-r0** to **0.9.0** and upm **0.3.1-r0** to 0.4.1\. As shown
    in the preceding lines, upm depends on mraa version 0.8.0 or greater, and therefore,
    we will upgrade mraa first.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to install the latest available version of the mraa
    library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The following lines show the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following command to install the latest available version of the upm
    library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The following lines show some lines with the results and the final line. Note
    that the package installation removes an important number of obsolete files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, run the following command to check the installed mraa version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The following lines show the output with the version and dependencies for the
    mraa package. The first lines show that mraa version **0.7.2-r0** is not installed
    anymore and the highlighted lines show that mraa version **0.9.0** is installed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following command to check the installed upm version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The following lines give the output with the version and dependencies for the
    upm package. The first lines display that upm version **0.3.1-r0** is not installed
    anymore and the highlighted lines show that upm version **0.4.1** is installed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Now, we have the latest versions of both the mraa and upm libraries installed
    and we will be able to use them from any Python program.
  prefs: []
  type: TYPE_NORMAL
- en: Installing pip and additional libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By default, the `pip` package management system that makes it easy to install
    and manage software packages written in Python isn't installed. We are going to
    use Python as our main programming language, and therefore, we will definitely
    benefit from installing `pip`.
  prefs: []
  type: TYPE_NORMAL
- en: Enter the following `curl` command to download the `get-pip.py` file from `https://bootstrap.pypa.io`,
    into the current folder.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see an output similar to the following lines that will indicate the
    download progress:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Once the download has finished, run `python` with `get-pip.py` as an argument.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: You will see an ouput similar to the following lines that will indicate the
    installation progress and a few warnings related to the SSLContext. Don't worry
    about the warnings.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can use the `pip` installer to easily install additional Python 2.7.3
    packages. We will use the `pip` installer to get the `wiring-x86` package from
    PyPI, the Python Package Index, and install it. The `wiring-x86` package is a
    Python module that provides a simple API similar to the WiringPi module to use
    the general purpose I/O pins on the Intel Galileo Gen 2 board and other supported
    platforms. We just need to run the following command to install the package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The last lines for the ouput will indicate that the `wiring-x86` package has
    been successfully installed. Don't worry about the error messages related to building
    a wheel for `wiring-x86`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Invoking the Python interpreter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have installed the most updated versions of the most important libraries
    we required to interact with the features included in the Intel Galileo Gen 2
    board. Now, we can invoke the Python interpreter by typing the classic command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, enter the following two lines of Python code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The Python interpreter will display the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: We imported the `mraa` library and called the `mraa.getVersion` method to check
    whether Python is able to retrieve the installed version of the `mraa` library.
    The result of calling the method displays the version we installed for the `mraa`
    library, and therefore, we know that Python is going to work with the version
    we expect. Note that the Python code is running on the Yocto Linux on the Intel
    Galileo Gen 2 board.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, enter the following line to check whether the `mraa` library has successfully
    detected the board type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The Python interpreter will display the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'We called the `mraa.getPlatformName` method and the result of calling the method
    displays our board''s name: Intel Galileo Gen 2\. The following screenshot shows
    the results of calling the previous methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Invoking the Python interpreter](img/B05042_02_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, open a Web browser in any computer or device connected to your LAN and
    enter the board''s assigned IP address. For example, in case the IP address is
    **192.168.1.104**, enter it as the URL to browse. The following screenshot shows
    the content you will see on your Web browser: **It works!**'
  prefs: []
  type: TYPE_NORMAL
- en: '![Invoking the Python interpreter](img/B05042_02_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The board is working as a Web server and it returns the contents of the `/www/pages/index.html`
    file to the Web browser request.
  prefs: []
  type: TYPE_NORMAL
- en: Test your knowledge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can access Python 2.7.x on the Intel Galileo Gen 2 board:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After booting the pre-installed SPI image from the flash memory.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: After booting a Yocto Linux from the microSD card, specifically, the IoT Devkit
    image.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: After booting the pre-installed SPI image and pressing the reboot button three
    times.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once an Intel Galileo Gen 2 board is connected to our LAN, we can access its
    shell with any utility that allows us to use the following interface and protocol:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: SSH.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Telnet.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: X.25.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Which of the following libraries has bindings to Python and allows us to work
    with the I/O on Intel Galileo Gen 2:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: IotGalileoGen2.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Mraa.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Mupm.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Which of the following packages is a Python module that provides an API similar
    to the WiringPi module to use general purpose I/O pins on the Intel Galieo Gen
    2:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: wiring-py-galileo.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: galileo-gen2-x86.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: wiring-x86.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Which of the following methods return the board that the mraa library automatically
    detects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: mraa.getPlatformName().
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: mraa.getBoardName().
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: mraa.getGalileoBoardName().
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we followed many procedures to make is possible to work with
    Python as the main programming language to create IoT projects with our Intel
    Galileo Gen 2 board. We wrote a Linux Yocto image to a microSD card and we configured
    the board to make it boot this image, so that we can access Python and other useful
    libraries to interact with the board. We updated many libraries to use their latest
    versions and we launched the Python interpreter.
  prefs: []
  type: TYPE_NORMAL
- en: Now that our board is ready to be coded with Python, we can start wiring electronic
    components to the board and work with Python and the libraries to write digital
    values, which is the topic of the next chapter.
  prefs: []
  type: TYPE_NORMAL
