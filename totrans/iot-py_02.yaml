- en: Chapter 2. Working with Python on Intel Galileo Gen 2
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。在英特尔Galileo Gen 2上使用Python
- en: 'In this chapter, we will start our journey towards Internet of Things (IoT)
    with Python and the Intel Galileo Gen 2 board. We shall:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将开始使用Python和英特尔Galileo Gen 2板探索物联网（IoT）之旅。我们将：
- en: Set up the environment to start working with Python as the main programming
    language
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置环境以开始使用Python作为主要的编程语言
- en: Retrieve the board's assigned IP address after it boots a Yocto Linux distribution
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在板启动Yocto Linux发行版后检索板的分配IP地址
- en: Connect to the board's operating system and run commands on it
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接到板的操作系统并在其上运行命令
- en: Install and upgrade the necessary libraries to interact with the board's component
    with Python
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装和升级必要的库，以便使用Python与板的组件交互
- en: Run our first lines of Python code in the board
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在板上运行我们的第一行Python代码
- en: Setting up the board to work with Python as the programming language
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置板以使用Python作为编程语言
- en: 'There is some work to be done in order to start working with Python as the
    main programming language to control this board. We need the following additional
    elements that aren''t included in the board''s box:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将Python作为主要的编程语言来控制这块板，需要做一些工作。我们需要以下额外的元素，这些元素不包括在板的包装盒内：
- en: A microSD card of at least 4 GB with a maximum supported capacity of 32 GB.
    It is convenient to use a speed class 4 or a faster microSD card. Note that you
    will lose all the contents of the microSD card.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 至少4GB的microSD卡，最大支持容量为32GB。使用速度等级4或更快的microSD卡会更方便。请注意，您将丢失microSD卡上的所有内容。
- en: A microSD to SD memory card adapter. The adapter is usually included within
    a microSD card's package.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个microSD到SD存储卡适配器。适配器通常包含在microSD卡的包装内。
- en: A computer with an SD memory card reader. Most modern laptops and desktop computers
    include SD mermory card readers. However, in case you don't have one, you can
    buy a USB SD memory card reader and plug it to a free USB port in your computer.
    SD memory card readers are in fact read/write devices, and therefore, we can use
    them to write to a microSD card via the microSD to SD memory card adapter.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一台带有SD存储卡读卡器的电脑。大多数现代笔记本电脑和台式电脑都包括SD存储卡读卡器。但是，如果您没有，您可以在电脑的空闲USB端口上购买一个USB SD存储卡读卡器并将其连接。SD存储卡读卡器实际上是读写设备，因此我们可以通过microSD到SD存储卡适配器将它们用于写入microSD卡。
- en: An Ethernet cable.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一根以太网线。
- en: An Ethernet switch or a WiFi router with a free Ethernet port. You will connect
    the Intel Galileo Gen 2 board to your LAN.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个带有空闲以太网端口的以太网交换机或WiFi路由器。您将把英特尔Galileo Gen 2板连接到您的局域网。
- en: Tip
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: In case you do not have access to your LAN's switch, you will have to ask your
    network administrator for advice.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您无法访问您的局域网交换机，您将需要向您的网络管理员寻求建议。
- en: The next picture shows an 8 GB speed class 4 microSD card labeled **SDC4/8GB**
    (left) and a microSD to SD memory card adapter (right).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个图片显示了一个标有**SDC4/8GB**（左侧）的8GB速度等级4microSD卡和一个microSD到SD存储卡适配器（右侧）。
- en: '![Setting up the board to work with Python as the programming language](img/B05042_02_01.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![设置板以使用Python作为编程语言](img/B05042_02_01.jpg)'
- en: 'We have to download the latest version of the Yocto Linux meta distribution
    boot image from the Intel IoT Development Kit Images Repository website. Open
    [http://iotdk.intel.com/images/](http://iotdk.intel.com/images/) in your Web browser
    and download the `iot-devkit-latest-mmcblkp0.direct.bz2` compressed file with
    the boot image listed on the Web page. You can also download it by entering the
    full URL in your Web browser: [http://iotdk.intel.com/images/iot-devkit-latest-mmcblkp0.direct.bz2](http://iotdk.intel.com/images/iot-devkit-latest-mmcblkp0.direct.bz2).'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须从英特尔物联网开发套件图像存储库网站下载Yocto Linux元分布启动映像的最新版本。在您的网络浏览器中打开[http://iotdk.intel.com/images/](http://iotdk.intel.com/images/)并下载网页上列出的`iot-devkit-latest-mmcblkp0.direct.bz2`压缩文件，其中包含启动映像。您也可以通过在您的网络浏览器中输入完整URL来下载它：[http://iotdk.intel.com/images/iot-devkit-latest-mmcblkp0.direct.bz2](http://iotdk.intel.com/images/iot-devkit-latest-mmcblkp0.direct.bz2)。
- en: Tip
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: We will use the `devkit-latest-mmcblkp0.direct.bz2` file, last modified on July
    2, 2015\. Make sure that you don't download any version releases sooner than this
    date because there are many differences in the package names used in previous
    releases that aren't compatible with the instructions provided later on in this
    chapter.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`devkit-latest-mmcblkp0.direct.bz2`文件，最后修改于2015年7月2日。请确保您不要下载早于这个日期的任何版本，因为之前版本中使用的包名与本章后面提供的说明不兼容。
- en: Once you have downloaded the file, it is necessary to decompress the downloaded
    image file and write the extracted image to the microSD card. The procedure is
    different in Windows and Mac OS X.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 下载文件后，必须解压缩下载的图像文件，并将提取的图像写入microSD卡。在Windows和Mac OS X中的操作步骤不同。
- en: In Windows, you can use 7-Zip to extract the contents from the downloaded `.bz2`
    file. 7-Zip is a free and open source software that you can download from [http://www.7-zip.org](http://www.7-zip.org).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows中，你可以使用7-Zip从下载的`.bz2`文件中提取内容。7-Zip是一个免费的开源软件，你可以从[http://www.7-zip.org](http://www.7-zip.org)下载。
- en: Once you extract the Yocto Linux meta distribution boot image `iot-devkit-latest-mmcblkp0.direct`
    from the `.bz2` file, you have to write this image to the microSD card. Insert
    the microSD card into the microSD to SD memory card adapter and insert the adapter
    into the computer's SD memory card reader.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦从`.bz2`文件中提取了Yocto Linux元分布引导映像`iot-devkit-latest-mmcblkp0.direct`，你必须将此映像写入microSD卡。将microSD卡插入microSD到SD存储卡适配器，并将适配器插入计算机的SD卡读卡器。
- en: The Win32 Disk Imager tool is an image writer for Windows that allows us to
    write images to USB sticks or SD/CF cards. You can use this free software to write
    the image to the microSD card. You can download it from [http://sourceforge.net/projects/win32diskimager/files/Archive](http://sourceforge.net/projects/win32diskimager/files/Archive).
    The installer for the latest version is the `Win32DiskImager-0.9.5-install.exe`
    file. Once you install the software, take into account that you must execute the
    application as an administrator in Windows. You can right-click on the application's
    icon and select **Run as administrator**.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Win32 Disk Imager工具是Windows的一个映像写入器，允许我们将映像写入U盘或SD/CF卡。你可以使用这款免费软件将映像写入microSD卡。你可以从[http://sourceforge.net/projects/win32diskimager/files/Archive](http://sourceforge.net/projects/win32diskimager/files/Archive)下载它。最新版本的安装程序是`Win32DiskImager-0.9.5-install.exe`文件。一旦安装了软件，请注意，你必须以管理员身份在Windows中运行应用程序。你可以右键单击应用程序的图标，并选择**以管理员身份运行**。
- en: Click on the icon on the right-hand side of the **Image File** textbox and change
    the files filter from **Disk Images (*.img *.IMG)** to ***.*** so that you can
    select the Yocto Linux boot image with a **direct** extension.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**图像文件**文本框右侧的图标，将文件过滤器从**磁盘映像 (*.img *.IMG)** 更改为***，这样你就可以选择具有**直接**扩展名的Yocto
    Linux引导映像。
- en: Select the drive letter that Windows assigned to the microSD card in the **Device**
    dropdown.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在**设备**下拉菜单中选择Windows分配给microSD卡的驱动器字母。
- en: Tip
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Make sure that you select the right drive letter because all the contents for
    the drive will be erased and overwritten with the boot image. If you select the
    incorrect drive letter, you will lose the contents of the entire drive.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 确保选择正确的驱动器字母，因为该驱动器的所有内容都将被擦除，并用引导映像覆盖。如果你选择了错误的驱动器字母，你将丢失整个驱动器的内容。
- en: Click on **Write** and then click on **Yes** in the confirm overwrite dialog
    box. Now, wait until the tool finishes writing the contents to the microSD card.
    The following screenshot shows the **Win32 Disk Imager** tool displaying the progress
    while it writes the image to the microSD card in Windows 10.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**写入**，然后在确认覆盖对话框中点击**是**。现在，等待工具完成将内容写入microSD卡。以下截图显示了**Win32 Disk Imager**工具在Windows
    10中写入映像到microSD卡时的进度。
- en: '![Setting up the board to work with Python as the programming language](img/B05042_02_02.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![设置板子以Python作为编程语言](img/B05042_02_02.jpg)'
- en: It will take a few minutes until the tool finishes writing the image to the
    microSD card. Once the writing process has finished, the tool will display a **Complete**
    dialog box with a **Write successful** message. Click on **OK** to close the dialog
    box and close the Win32 Disk Imager window.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 工具将花费几分钟时间将映像写入microSD卡。一旦写入过程完成，工具将显示一个包含**写入成功**消息的**完成**对话框。点击**确定**关闭对话框并关闭Win32
    Disk Imager窗口。
- en: Eject the microSD card in Windows and then remove the SD memory card adapter
    from the SD card reader.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows中弹出microSD卡，然后从SD卡读卡器中移除SD存储卡适配器。
- en: 'In Mac OS X and Linux, you can use `bunzip2` to extract the contents from the
    downloaded **bz2** file, `diskutil` to unmount the microSD card, and `dd` to write
    the image to the microSD card. It is also possible to open a **Terminal** and
    unzip the downloadeded bz2 file by running the following command in the folder
    in which you downloaded the file:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在Mac OS X和Linux中，您可以使用`bunzip2`从下载的**bz2**文件中提取内容，使用`diskutil`卸载microSD卡，并使用`dd`将映像写入microSD卡。您还可以打开**终端**，在下载文件的文件夹中运行以下命令来解压下载的bz2文件：
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Tip
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: You need to be very careful with the commands to avoid erasing a wrong device
    such as a partition of your hard drive.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要非常小心地处理命令，以避免擦除硬盘分区等错误的设备。
- en: It is also possible to unzip the downloaded bz2 file by double-clicking on it
    on Finder. However, we will be running more commands in the **Terminal** window,
    and therefore, it is easier to start unzipping the file with a command.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以通过在Finder中双击下载的bz2文件来解压该文件。然而，我们将在**终端**窗口中运行更多命令，因此，使用命令开始解压文件会更简单。
- en: Once you extract the Yocto Linux boot image `iot-devkit-latest-mmcblkp0.direct`
    from the bz2 file, you have to write this image to the microSD card. Insert the
    microSD card into the microSD to SD memory card adapter and then insert the adapter
    into the computer's SD memory card reader. Launch the **Disk Utility** application
    and check the details for the media connected to the card reader. For example,
    in any MacBook laptop, you will find the info by clicking on **APPLE SD Card Reader
    Media** and then on the **Info** button. Check the name listed in **Device name**
    or **BSD device node**. We will use this name in a command that will write the
    boot image to the microSD card. The following picture shows the **Disk Utility**
    application and the information for a microSD card whose device name is **disk2**.
    We just need to add `/dev/` as a prefix to the gathered device name, and therefore,
    in this sample case, the complete name is `/dev/disk2`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦从bz2文件中提取了Yocto Linux引导映像`iot-devkit-latest-mmcblkp0.direct`，您就必须将此映像写入microSD卡。将microSD卡插入microSD到SD内存卡适配器，然后将适配器插入计算机的SD内存卡读卡器。启动**磁盘工具**应用程序并检查连接到读卡器的媒体详细信息。例如，在任一MacBook笔记本电脑上，您可以通过点击**APPLE
    SD卡读卡器媒体**然后点击**信息**按钮来找到信息。检查**设备名称**或**BSD设备节点**中列出的名称。我们将使用此名称在写入microSD卡的引导映像的命令中。以下图片显示了**磁盘工具**应用程序和设备名称为**disk2**的microSD卡的信息。我们只需要在收集到的设备名称前添加`/dev/`作为前缀，因此，在这个示例案例中，完整的名称是`/dev/disk2`。
- en: '![Setting up the board to work with Python as the programming language](img/B05042_02_03.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![设置板以Python作为编程语言工作](img/B05042_02_03.jpg)'
- en: 'It is also possible to gather the information by running the `diskutil` command
    to list all the devices and find out the device name assigned to the microSD card.
    However, the information provided by this command is a bit difficult to read and
    the **Disk Utility** application makes it easy to understand which is the device
    name for the memory card reader. The following command lists all the devices:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以通过运行`diskutil`命令列出所有设备并找出分配给microSD卡的设备名称来收集信息。然而，此命令提供的信息阅读起来有点困难，而**磁盘工具**应用程序则使得理解哪个是内存卡读卡器的设备名称变得容易。以下命令列出所有设备：
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The following is the sample output generated by this command. The highlighted
    lines show the device name for the microSD card: `/dev/disk2`.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是由此命令生成的示例输出。高亮显示的行显示了microSD卡的设备名称：`/dev/disk2`。
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Tip
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Make sure that you take note of the right device name because all the contents
    for the drive will be erased and overwritten with the boot image. If you specify
    a wrong device name, you will lose the contents of the entire drive.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您记下正确的设备名称，因为驱动器的所有内容都将被擦除并覆盖以写入引导映像。如果您指定了错误的设备名称，您将丢失整个驱动器的内容。
- en: Unmount the microSD card with the following command. You need to replace `/dev/devicename`
    with `/dev/disk2` in case the device name you gathered was `disk2`. If not, replace
    it with the appropriate device name.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令卸载microSD卡。如果您收集到的设备名称是`disk2`，则需要将`/dev/devicename`替换为`/dev/disk2`。如果不是，请替换为适当的设备名称。
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The **Terminal** will ask for your password and will unmount the microSD card.
    Run the following `dd` command to write the image in the input file named `iot-devkit-latest-mmcblkp0.direct`
    to the microSD card in the device name you gathered in the previous step. You
    need to replace `of=/dev/devicename` with `of=/dev/disk2` in case the device name
    you gathered was `disk2`. If not, replace it with the appropriate device name.
    The command doesn't include a device name so that you don't overwrite any of your
    disks by accident.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**终端**将要求您输入密码，并将卸载microSD卡。运行以下`dd`命令，将名为`iot-devkit-latest-mmcblkp0.direct`的输入文件中的镜像写入之前步骤中收集到的设备名称的microSD卡。如果收集到的设备名称是`disk2`，则需要将`of=/dev/devicename`替换为`of=/dev/disk2`。如果不是，请将其替换为适当的设备名称。该命令没有包含设备名称，这样您就不会意外地覆盖任何磁盘。'
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Then, it will take some time to write the image to the microSD card. Wait until
    the command finishes and the `Terminal` displays the prompt again. Notice that
    it usually takes a few minutes and there is no output with any progress indication
    until the write process finishes. You will see the following output after the
    command finishes:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将镜像写入microSD卡需要一些时间。等待命令完成，并再次显示`Terminal`提示符。请注意，这通常需要几分钟，并且在写入过程完成之前没有任何进度指示。命令完成后，您将看到以下输出：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now, unmount the microSD card with the following command. You need to replace
    `/dev/devicename` with `/dev/disk2` in case the device name you gathered was `disk2`.
    If not, replace it with the appropriate device name.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用以下命令卸载microSD卡。如果收集到的设备名称是`disk2`，则需要将`/dev/devicename`替换为`/dev/disk2`。如果不是，请将其替换为适当的设备名称。
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Close the terminal window and then remove the SD memory card adapter from the
    SD card reader.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 关闭终端窗口，然后从SD卡读卡器中取出SD内存卡适配器。
- en: Now, we have a microSD card with a Yocto Linux distribution that includes Python
    2.7.3 and many useful libraries and utilities. It is time to make the Intel Galileo
    Gen 2 board boot from the Yocto image written to the microSD card.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一个包含Python 2.7.3和许多有用库和工具的Yocto Linux分布的microSD卡。是时候让英特尔Galileo Gen 2板从写入microSD卡的Yocto镜像启动了。
- en: Make sure that the board is unplugged and place the microSD card with the Yocto
    image in the microSD card slot on the board, labeled **SDIO**. The following picture
    shows a microSD card inserted in the slot on the board.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 确保板子已断电，并将带有Yocto镜像的microSD卡放入板上的microSD卡槽中，该槽标有**SDIO**。以下图片显示了插入板槽中的microSD卡。
- en: '![Setting up the board to work with Python as the programming language](img/B05042_02_04.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![设置板子以使用Python作为编程语言](img/B05042_02_04.jpg)'
- en: Then, connect the board to your LAN with the Ethernet cable and plug the board's
    power supply to turn on the board and start it up. You will notice that the rectangular
    onboard LED labeled **SD** indicates that there is activity with the microSD card.
    Wait for approximately 30 seconds to make sure that the board finishes the boot
    process. You will notice that the LED labeled **SD** stops blinking after the
    boot process finishes.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用以太网线将板子连接到您的局域网，并将板子的电源插头插入以打开板子并启动它。您会注意到标有**SD**的矩形板上LED指示灯表示microSD卡正在活动中。等待大约30秒以确保板子完成启动过程。您会注意到在启动过程完成后，标有**SD**的LED停止闪烁。
- en: Retrieving the board's assigned IP address
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取板子的分配IP地址
- en: The board has finished the boot process with the Yocto Linux microSD card and
    is connected to our LAN throught the Ethernet port. The DHCP server has assigned
    the board an IP address and we need to know it in order to run commands on a Yocto
    Linux console. There are many ways for us to retrieve the board's assigned IP
    address. We will explore the different options and you can choose the most convenient
    one based on your LAN configuration.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 板子已经使用Yocto Linux microSD卡完成了启动过程，并通过以太网端口连接到我们的局域网。DHCP服务器已为板子分配了一个IP地址，我们需要知道它以便在Yocto
    Linux控制台上运行命令。我们有多种方法可以获取板子的分配IP地址。我们将探讨不同的选项，您可以根据您的局域网配置选择最方便的一个。
- en: 'If the board is connected to one of the Ethernet ports of a Wireless router
    and we have access to the router''s Web interface, we can easily know the IP address
    assigned to the board. Some router''s Web interfaces display the wired clients
    list. As our board is connected through an Ethernet wire, it will be listed as
    one of the wired clients and the device MAC address will match the MAC address
    printer in the adhesive label on the board''s Ethernet jacket. The following picture
    shows the Wired-clients list in a router''s Web interface and the list includes
    a device named **galileo** with **A1-B2-C3-D4-E5-F6** as the MAC address that
    matches the MAC address printed without hyphens (-) in the board: **A1B2C3D4E5F6**.
    The IP address assigned to the board is **192.168.1.104**. For security reasons,
    the original MAC address has been erased and we are using a fake MAC address for
    our example.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果开发板连接到无线路由器的一个以太网端口，并且我们可以访问路由器的Web界面，我们可以轻松地知道分配给开发板的IP地址。一些路由器的Web界面会显示有线客户端列表。由于我们的开发板是通过以太网线连接的，它将被列为有线客户端之一，设备的MAC地址将与板上的以太网外壳上的粘性标签上的MAC地址打印机匹配。以下图片显示了路由器Web界面中的有线客户端列表，列表中包括一个名为**galileo**的设备，其MAC地址为**A1-B2-C3-D4-E5-F6**，这与板上打印不带连字符（-）的MAC地址**A1B2C3D4E5F6**相匹配。分配给开发板的IP地址是**192.168.1.104**。出于安全原因，原始MAC地址已被擦除，我们在这个例子中使用了一个假MAC地址。
- en: '![Retrieving the board''s assigned IP address](img/B05042_02_05.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![检索开发板分配的IP地址](img/B05042_02_05.jpg)'
- en: 'Sometimes, the router''s Web interface doesn''t provide an option that displays
    the wired clients list. If this is the case for our router, we will always be
    able to retrieve the DHCP client list that provides all the IP addresses assigned
    to either the wireless or wired devices connected to the LAN. We just need to
    find the device that has the MAC address for the board. The following picture
    shows the DHCP Client List in a router''s Web interface and the list includes
    a device named **galileo** with **A1-B2-C3-D4-E5-F6** as the MAC address that
    matches the MAC address printed without hyphens (-) in the board: **A1B2C3D4E5F6**.
    The IP address assigned to the board is **192.168.1.104**.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，路由器的Web界面不提供显示有线客户端列表的选项。如果我们的路由器是这样的，我们总是能够检索提供所有连接到局域网的无线或有线设备分配的IP地址的DHCP客户端列表。我们只需要找到具有板MAC地址的设备。以下图片显示了路由器Web界面中的DHCP客户端列表，列表中包括一个名为**galileo**的设备，其MAC地址为**A1-B2-C3-D4-E5-F6**，这与板上打印不带连字符（-）的MAC地址**A1B2C3D4E5F6**相匹配。分配给开发板的IP地址是**192.168.1.104**。
- en: '![Retrieving the board''s assigned IP address](img/B05042_02_06.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![检索开发板分配的IP地址](img/B05042_02_06.jpg)'
- en: Another option is to install a Bonjour Browser to discover the board and its
    services on the LAN automatically through this zero-configuration networking implementation,
    without knowing the IP assigned to the board.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选项是安装Bonjour浏览器，通过这种零配置网络实现自动发现板及其在局域网上的服务，而无需知道分配给板的IP地址。
- en: 'In Windows, download, install, and launch the free Bonjour Browser for Windows
    from [http://hobbyistsoftware.com/bonjourbrowser](http://hobbyistsoftware.com/bonjourbrowser).
    The application will display many available Bonjour services with **galileo**
    as their name. The following screenshot shows the **_ssh._tcp** service type with
    **galileo** as its name selected with the details. The **IP Adresses** section
    shows the IP address and the port number for the SSH service: **192.168.1.105:22**.
    We can use the IP address with any SSH client to connect to the board. In addition,
    the Bonjour browser lets us know that the board has an SFTP service that will
    make it easy for us to transfer files from and to the Yocto Linux running on the
    board.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows中，从[http://hobbyistsoftware.com/bonjourbrowser](http://hobbyistsoftware.com/bonjourbrowser)下载、安装并启动免费的Windows
    Bonjour浏览器。该应用程序将显示许多可用的Bonjour服务，其中**galileo**为它们的名称。以下截图显示了以**_ssh._tcp**服务类型和**galileo**名称选中的详细信息。**IP地址**部分显示了SSH服务的IP地址和端口号：**192.168.1.105:22**。我们可以使用任何SSH客户端的IP地址来连接到板。此外，Bonjour浏览器还让我们知道板有一个SFTP服务，这将使我们能够轻松地从运行在板上的Yocto
    Linux传输和接收文件。
- en: '![Retrieving the board''s assigned IP address](img/B05042_02_07.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![检索开发板分配的IP地址](img/B05042_02_07.jpg)'
- en: In OS X, download and run the free Bonjour Browser from [http://www.tildesoft.com](http://www.tildesoft.com).
    You can click on **Reload Services** to refresh the discovered devices and their
    services. The following picture shows a board and its services listed in the Bonjour
    Browser. You have to click on each right-arrow to expand the details for each
    listed service. In this case, all the services are provided by the same device
    named **galileo**. Once you expand the device, the application displays the IPv4
    and IPv6 addresses. The **SSH (_ssh._tcp.)** service type lists a device with
    **galileo** as its name and with **192.168.1.105:22** as the IPv4 address and
    the port number. We can use the IP address with any SSH client to connect to the
    board. The Bonjour Browser also displays the details for the SFTP service.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在OS X中，从[http://www.tildesoft.com](http://www.tildesoft.com)下载并运行免费的Bonjour浏览器。您可以点击**重新加载服务**来刷新发现的设备和它们的服务。以下图片显示了Bonjour浏览器中列出的板子和其服务。您必须点击每个右箭头以展开每个列出的服务的详细信息。在这种情况下，所有服务都由名为**galileo**的同一设备提供。一旦展开设备，应用程序将显示IPv4和IPv6地址。**SSH
    (_ssh._tcp.)**服务类型列出了一个名为**galileo**的设备，其IPv4地址为**192.168.1.105**，端口号为**22**。我们可以使用该IP地址和任何SSH客户端连接到板子。Bonjour浏览器还显示了SFTP服务的详细信息。
- en: '![Retrieving the board''s assigned IP address](img/B05042_02_08.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![检索板子的分配IP地址](img/B05042_02_08.jpg)'
- en: Tip
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: SSH stands for Secure Shell Protocol and its default port is 22\. Yocto Linux
    runs the SSH server in the default port, and therefore, there is no need to specify
    the port in SSH clients, we can just specify the discovered IP address.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: SSH代表安全外壳协议，其默认端口是22。Yocto Linux在默认端口运行SSH服务器，因此，在SSH客户端中无需指定端口，我们只需指定发现的IP地址即可。
- en: Connecting to the board's operating system
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接到板子的操作系统
- en: Now, we need to use an SSH client to connect to the Yocto Linux running on the
    board and update some libraries that we will use to interact with the board's
    components and features. Both OS X and Linux include the `ssh` command in the
    Terminal. However, Windows doesn't include an `ssh` command and we have to install
    an SSH client.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要使用SSH客户端连接到板子上运行的Yocto Linux并更新一些我们将用于与板子组件和功能交互的库。OS X和Linux都包含终端中的`ssh`命令。但是，Windows不包括`ssh`命令，我们必须安装一个SSH客户端。
- en: In Windows, we can use the free and open source PuTTY SSH and telnet client.
    However, if you have any other preference for an SSH client in Windows, you can
    use any other software. The commands we execute in the terminal will be the same
    no matter what SSH client we use.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows中，我们可以使用免费的开源PuTTY SSH和telnet客户端。但是，如果您在Windows中更喜欢其他SSH客户端，您可以使用任何其他软件。我们在终端中执行的命令将取决于我们使用的SSH客户端。
- en: We can download and install PuTTY in Windows from [http://www.putty.org](http://www.putty.org)
    or [http://www.chiark.greenend.org.uk/~sgtatham/putty/download.html](http://www.chiark.greenend.org.uk/~sgtatham/putty/download.html).
    Once you install it, launch it and make sure you allow Windows firewall or any
    other installed firewall to open the necessary ports to make the connections.
    You will see warnings popping up depending on the firewall software that is running
    on Windows.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从[http://www.putty.org](http://www.putty.org)或[http://www.chiark.greenend.org.uk/~sgtatham/putty/download.html](http://www.chiark.greenend.org.uk/~sgtatham/putty/download.html)下载并安装PuTTY。安装后，启动它并确保您允许Windows防火墙或任何其他已安装的防火墙打开必要的端口以建立连接。您将根据Windows上运行的防火墙软件看到弹出的警告。
- en: After you launch PuTTY, the application will display the **PuTTY Configuration**
    dialog box. Enter the IP address assigned to your board in the **Host Name (or
    IP address)** textbox and leave the **Port** value to its default **22** value.
    The following picture shows the dialog box with the settings to connect to the
    board whose assigned IP is **192.168.1.105**. You can leave the default settings.
    However, you should definitely change the **Window | Appearance** settings to
    change the default font.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 启动PuTTY后，应用程序将显示**PuTTY配置**对话框。在**主机名（或IP地址）**文本框中输入分配给您的板的IP地址，并将**端口**值保留为其默认的**22**值。以下图片显示了设置以连接到分配IP为**192.168.1.105**的板的对话框。您可以保留默认设置。但是，您绝对应该更改**窗口
    | 外观**设置以更改默认字体。
- en: '![Connecting to the board''s operating system](img/B05042_02_09.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![连接到板子的操作系统](img/B05042_02_09.jpg)'
- en: Click on **Open** and the first time you want to establish a connection; PuTTY
    will display a security alert because the server's host key is not cached in the
    registry. You trust your board and the Yocto Linux that is running on it, and
    therefore, just click on **Yes**. The following picture shows the security alert.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 点击 **打开**，第一次建立连接时；PuTTY 将显示一个安全警报，因为服务器的主机密钥未缓存在注册表中。您信任您的板和运行在其上的 Yocto Linux，因此只需点击
    **是**。以下图片显示了安全警报。
- en: '![Connecting to the board''s operating system](img/B05042_02_10.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![连接到板的操作系统](img/B05042_02_10.jpg)'
- en: PuTTY will display a new window, specifically a terminal window, with the IP
    address included in the title. You will see the following message asking you to
    enter the login user.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: PuTTY 将显示一个新窗口，具体是一个包含 IP 地址的终端窗口。您将看到以下消息，要求您输入登录用户。
- en: '[PRE7]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Enter **root** and press *Enter*. You will login as the `root` user that doesn''t
    require a password in the Yocto Linux default configuration. Now, you can run
    any shell commands. For example, you can enter the following command to check
    the installed python version:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 输入 **root** 并按 *Enter*。您将以 `root` 用户登录，在 Yocto Linux 的默认配置中，该用户不需要密码。现在，您可以运行任何
    shell 命令。例如，您可以使用以下命令来检查已安装的 python 版本：
- en: '[PRE8]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The following picture shows a PuTTY terminal window with the results of logging
    in as root and running a few commands:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图片显示了以 root 登录并运行了一些命令的 PuTTY 终端窗口：
- en: '![Connecting to the board''s operating system](img/B05042_02_11.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![连接到板的操作系统](img/B05042_02_11.jpg)'
- en: In OS X and Linux, you can open a **Terminal** and run the `ssh` command to
    connect to the Yocto Linux running on the board. You have to enter `ssh` followed
    by a space, the user name, an arrow (@), and the IP. In this case, we want to
    connect with root as the user name, and therefore, we will enter `ssh` followed
    by a space, `root@`, and then the IP address. The following command works with
    the board that is running the SSH server in the `192.168.1.105` IP address and
    port number 22\. You have to replace `192.168.1.105` with the IP address you retrieved.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在 OS X 和 Linux 上，您可以通过打开 **终端** 并运行 `ssh` 命令来连接到板上的 Yocto Linux。您必须输入 `ssh`
    后跟一个空格，用户名，一个箭头（@），然后是 IP 地址。在这种情况下，我们想以 `root` 作为用户名进行连接，因此我们将输入 `ssh` 后跟一个空格，`root@`，然后是
    IP 地址。以下命令适用于在 `192.168.1.105` IP 地址和端口号 22 上运行 SSH 服务器的板。您必须将 `192.168.1.105`
    替换为您检索到的 IP 地址。
- en: '[PRE9]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The first time you want to establish a connection, the `ssh` command will display
    a security alert because the authenticity of the host can't be established. You
    trust your board and the Yocto Linux that is running on it, and therefore, answer
    **yes** to a question that will be similar to the following one and press *Enter*.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次建立连接时，`ssh` 命令将显示一个安全警报，因为无法验证主机的真实性。您信任您的板和运行在其上的 Yocto Linux，因此对类似以下问题的回答是
    **yes** 并按 *Enter*。
- en: '[PRE10]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `ssh` command will display a message similar to the following line after
    you answer **yes** and press *Enter*:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在您回答 **yes** 并按 *Enter* 后，`ssh` 命令将显示类似于以下行的一条消息：
- en: '[PRE11]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You will log in as the `root` user that does not require a password in the Yocto
    Linux default configuration. Now, you can run any shell command. For example,
    you can enter the following command to check the installed Python version.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Yocto Linux 的默认配置中，您将以 `root` 用户登录，该用户不需要密码。现在，您可以运行任何 shell 命令。例如，您可以使用以下命令来检查已安装的
    Python 版本。
- en: '[PRE12]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Notice that while you see the following prompt **root@galileo:~#**, it means
    that all your commands are running on the Yocto Linux on the board and not on
    your OS X Terminal or your Linux Terminal. The following picture shows an OS X
    **Terminal** window with the results of logging in as `root` and running a few
    commands:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当您看到以下提示 **root@galileo:~#** 时，这意味着您的所有命令都在板上的 Yocto Linux 上运行，而不是在您的 OS
    X 终端或 Linux 终端上。以下图片显示了登录为 `root` 并运行了一些命令的 OS X **终端** 窗口：
- en: '![Connecting to the board''s operating system](img/B05042_02_12.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![连接到板的操作系统](img/B05042_02_12.jpg)'
- en: Tip
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The Yocto Linux that the board has booted includes Python 2.7.3 pre-installed.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 板上启动的 Yocto Linux 预装了 Python 2.7.3。
- en: We can also run any SSH client in a mobile device such as a tablet or smartphone.
    There are many SSH clients developed for iOS and Android. It is possible to work
    with a tablet and a Bluetooth keyboard linked to it and easily run the commands
    in the SSH client.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在移动设备上运行任何 SSH 客户端，例如平板电脑或智能手机。有许多为 iOS 和 Android 开发的 SSH 客户端。使用与蓝牙键盘连接的平板电脑工作，并轻松在
    SSH 客户端中运行命令是可能的。
- en: Installing and upgrading the necessary libraries to interact with the board
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装和升级必要的库以与板子交互
- en: Now, we will run many commands in the SSH client. Make sure that your SSH client
    is connected to the Yocto Linux SSH server running on the board as explained in
    the preceding section before running the commands. Specially, if you are working
    with either OS X or Linux, you have to make sure that you don't run the commands
    on your computer instead of doing this on the remote shell. Its simple, just make
    sure you always see the prompt **root@galileo:~#** before running any command.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将在SSH客户端运行许多命令。在运行命令之前，请确保你的SSH客户端已连接到板上运行的Yocto Linux SSH服务器，如前述章节所述。特别是，如果你在使用OS
    X或Linux，你必须确保你不在你的计算机上运行命令，而是在远程shell上执行此操作。很简单，只需确保在运行任何命令之前，你总是看到提示**root@galileo:~#**。
- en: Tip
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Your board should be connected to a LAN with Internet access because we will
    download content from the Internet.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 你的板应该连接到具有互联网访问的LAN，因为我们将从互联网下载内容。
- en: We will use the `opkg` utility to download and install the updated version of
    both the `mraa` and `upm` libraries. The `mraa` library, also known as `libmraa`,
    is a low level C/C++ library with bindings to Python that allows us to interface
    with the I/O features on the Intel Galileo Gen 2 board and other supported platforms.
    The `upm` library provides high-level interfaces for sensors and actuators that
    we can plug to the platforms supported by the `mraa` library. The `upm` library
    simplifies working with sensors and actuators and includes bindings to Python.
    We will be working with both libraries in the forthcoming chapters, and therefore,
    we want to have their latest versions installed.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`opkg`工具下载并安装`mraa`和`upm`库的更新版本。`mraa`库，也称为`libmraa`，是一个低级别的C/C++库，具有与Python的绑定，使我们能够与Intel
    Galileo Gen 2板和其他支持平台上的I/O功能进行接口。`upm`库为我们可以连接到`mraa`库支持的平台上的传感器和执行器提供高级接口。`upm`库简化了与传感器和执行器的工作，并包括Python的绑定。在接下来的章节中，我们将使用这两个库，因此，我们希望安装它们的最新版本。
- en: The `opkg` utility is a lightweight package manager that allows us to easily
    download and install OpenWrt packages. OpenWrt is a Linux distribution for embedded
    devices. First, we will check both the mraa and upm installed versions by using
    the `opkg` utility.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`opkg`工具是一个轻量级的包管理器，它允许我们轻松下载和安装OpenWrt包。OpenWrt是一种嵌入式设备的Linux发行版。首先，我们将使用`opkg`工具检查mraa和upm的安装版本。'
- en: 'Run the following command to check the installed mraa version:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令以检查已安装的mraa版本：
- en: '[PRE13]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The following lines show the output with the version and dependencies for the
    mraa package. In this case, the output shows that the installed version for mraa
    is **0.7.2-r0**.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了mraa包的版本和依赖项的输出。在这种情况下，输出显示安装的mraa版本为**0.7.2-r0**。
- en: '[PRE14]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Run the following command to check the installed upm version:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令以检查已安装的upm版本：
- en: '[PRE15]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The following lines show the output with the version and dependencies for the
    upm package. In this case, the output shows that the installed version for upm
    is **0.3.1-r0**.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了upm包的版本和依赖项的输出。在这种情况下，输出显示安装的upm版本为**0.3.1-r0**。
- en: '[PRE16]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Run the following command to check the repository configuration for both the
    `mraa` and upm libraries.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令以检查mraa和upm库的存储库配置。
- en: '[PRE17]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If you see the following line as a response, it means that the repository is
    configured to work with the 1.5 version and we need to change its configuration
    to make it possible to update both the mraa and upm libraries to their latest
    versions.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看到以下行作为响应，这意味着存储库已配置为使用1.5版本，我们需要更改其配置，以便更新mraa和upm库到最新版本。
- en: '[PRE18]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Run the following command to configure the repository for both the mraa and
    upm libraries to work with version 2.0 instead of 1.5:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令以配置存储库，使mraa和upm库与版本2.0而不是1.5一起工作：
- en: '[PRE19]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now, run the following command to check the repository configuration for both
    the mraa and upm libraries and you will notice that `1.5` has been replaced by
    `2.0` in the output.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行以下命令以检查mraa和upm库的存储库配置，你将注意到输出中已将`1.5`替换为`2.0`。
- en: '[PRE20]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'You should see the results shown in the next line:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到下一行显示的结果：
- en: '[PRE21]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We will use the `opkg` utility to update packages from the previously configured
    repository located on the Internet. Run the following command to make the `opkg`
    utility update the list of available packages after we changed the configuration
    of the repositories for both the mraa and upm libraries.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `opkg` 工具从之前配置的位于互联网上的仓库更新软件包。运行以下命令以使 `opkg` 工具在更改了 mraa 和 upm 库的仓库配置后更新可用软件包列表。
- en: '[PRE22]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The previous command will generate the following output that indicates the list
    of available packages that have been updated. Notice that the last lines of the
    output indicate that the command has been downloaded from `http://iotdk.intel.com/repos/2.0/intelgalactic/Packages`
    and saved the available packages in `/var/lib/opkg/mraa-upm`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令将生成以下输出，指示已更新的可用软件包列表。请注意，输出中的最后几行指示命令已从 `http://iotdk.intel.com/repos/2.0/intelgalactic/Packages`
    下载，并将可用软件包保存在 `/var/lib/opkg/mraa-upm`。
- en: '[PRE23]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Run the following command to check the versions for both the mraa and upm libraries
    stored in `/var/lib/opkg/mraa-upm`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令以检查存储在 `/var/lib/opkg/mraa-upm` 中的 mraa 和 upm 库的版本。
- en: '[PRE24]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The following lines show the results. Notice that the version numbers might
    vary because both the mraa and upm libraries are very active projects and they
    are frequently updated. Thus, the version numbers might be higher when you run
    the previous command.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示结果。请注意，版本号可能会变化，因为 mraa 和 upm 库都是非常活跃的项目，并且它们经常更新。因此，当你运行之前的命令时，版本号可能会更高。
- en: '[PRE25]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In this case, we have mraa version **0.9.0** and upm version **0.4.1**. The
    version numbers are higher than the initially installed ones. We definitely want
    to upgrade mraa **0.7.2-r0** to **0.9.0** and upm **0.3.1-r0** to 0.4.1\. As shown
    in the preceding lines, upm depends on mraa version 0.8.0 or greater, and therefore,
    we will upgrade mraa first.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们有 mraa 版本 **0.9.0** 和 upm 版本 **0.4.1**。版本号高于最初安装的版本。我们肯定希望将 mraa **0.7.2-r0**
    升级到 **0.9.0**，将 upm **0.3.1-r0** 升级到 0.4.1。如前所述的行所示，upm 依赖于 mraa 版本 0.8.0 或更高版本，因此我们将首先升级
    mraa。
- en: 'Run the following command to install the latest available version of the mraa
    library:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令以安装 mraa 库的最新可用版本：
- en: '[PRE26]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The following lines show the results:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示结果：
- en: '[PRE27]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Run the following command to install the latest available version of the upm
    library:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令以安装 upm 库的最新可用版本：
- en: '[PRE28]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The following lines show some lines with the results and the final line. Note
    that the package installation removes an important number of obsolete files:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示一些结果行和最后一行。请注意，包安装会删除大量过时的文件：
- en: '[PRE29]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, run the following command to check the installed mraa version:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行以下命令以检查已安装的 mraa 版本：
- en: '[PRE30]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The following lines show the output with the version and dependencies for the
    mraa package. The first lines show that mraa version **0.7.2-r0** is not installed
    anymore and the highlighted lines show that mraa version **0.9.0** is installed.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示带有版本和依赖项的 mraa 包的输出。前几行显示 mraa 版本 **0.7.2-r0** 已不再安装，而突出显示的行显示已安装 mraa
    版本 **0.9.0**。
- en: '[PRE31]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Run the following command to check the installed upm version:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令以检查已安装的 upm 版本：
- en: '[PRE32]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The following lines give the output with the version and dependencies for the
    upm package. The first lines display that upm version **0.3.1-r0** is not installed
    anymore and the highlighted lines show that upm version **0.4.1** is installed.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行给出带有版本和依赖项的 upm 包的输出。前几行显示 upm 版本 **0.3.1-r0** 已不再安装，而突出显示的行显示已安装 upm 版本
    **0.4.1**。
- en: '[PRE33]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Now, we have the latest versions of both the mraa and upm libraries installed
    and we will be able to use them from any Python program.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经安装了 mraa 和 upm 库的最新版本，我们将能够从任何 Python 程序中使用它们。
- en: Installing pip and additional libraries
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 pip 和附加库
- en: By default, the `pip` package management system that makes it easy to install
    and manage software packages written in Python isn't installed. We are going to
    use Python as our main programming language, and therefore, we will definitely
    benefit from installing `pip`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`pip` 包管理系统，它使得安装和管理用 Python 编写的软件包变得容易，并未安装。我们将使用 Python 作为我们的主要编程语言，因此，我们肯定会从安装
    `pip` 中受益。
- en: Enter the following `curl` command to download the `get-pip.py` file from `https://bootstrap.pypa.io`,
    into the current folder.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 输入以下 `curl` 命令，从 `https://bootstrap.pypa.io` 下载 `get-pip.py` 文件到当前文件夹。
- en: '[PRE34]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'You will see an output similar to the following lines that will indicate the
    download progress:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到类似以下行的输出，这将指示下载进度：
- en: '[PRE35]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Once the download has finished, run `python` with `get-pip.py` as an argument.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 下载完成后，运行`python`并带上`get-pip.py`作为参数。
- en: '[PRE36]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: You will see an ouput similar to the following lines that will indicate the
    installation progress and a few warnings related to the SSLContext. Don't worry
    about the warnings.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到类似以下行的输出，这将指示安装进度以及与SSLContext相关的一些警告。不要担心这些警告。
- en: '[PRE37]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now, we can use the `pip` installer to easily install additional Python 2.7.3
    packages. We will use the `pip` installer to get the `wiring-x86` package from
    PyPI, the Python Package Index, and install it. The `wiring-x86` package is a
    Python module that provides a simple API similar to the WiringPi module to use
    the general purpose I/O pins on the Intel Galileo Gen 2 board and other supported
    platforms. We just need to run the following command to install the package:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用`pip`安装程序轻松地安装额外的Python 2.7.3软件包。我们将使用`pip`安装程序从Python包索引PyPI获取`wiring-x86`软件包，并安装它。`wiring-x86`软件包是一个Python模块，它提供了一个类似于WiringPi模块的简单API，用于在Intel
    Galileo Gen 2板和其他支持的平台上的通用I/O引脚上使用。我们只需运行以下命令来安装软件包：
- en: '[PRE38]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The last lines for the ouput will indicate that the `wiring-x86` package has
    been successfully installed. Don't worry about the error messages related to building
    a wheel for `wiring-x86`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的最后几行将指示`wiring-x86`软件包已成功安装。不要担心与构建`wiring-x86`轮相关的错误消息。
- en: '[PRE39]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Invoking the Python interpreter
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调用Python解释器
- en: 'We have installed the most updated versions of the most important libraries
    we required to interact with the features included in the Intel Galileo Gen 2
    board. Now, we can invoke the Python interpreter by typing the classic command:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经安装了与Intel Galileo Gen 2板中包含的功能交互所需的最重要库的最新版本。现在，我们可以通过输入经典命令来调用Python解释器：
- en: '[PRE40]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now, enter the following two lines of Python code:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，输入以下两行Python代码：
- en: '[PRE41]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The Python interpreter will display the following output:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: Python解释器将显示以下输出：
- en: '[PRE42]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We imported the `mraa` library and called the `mraa.getVersion` method to check
    whether Python is able to retrieve the installed version of the `mraa` library.
    The result of calling the method displays the version we installed for the `mraa`
    library, and therefore, we know that Python is going to work with the version
    we expect. Note that the Python code is running on the Yocto Linux on the Intel
    Galileo Gen 2 board.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入了`mraa`库，并调用了`mraa.getVersion`方法来检查Python是否能够检索已安装的`mraa`库版本。调用该方法的结果显示了为`mraa`库安装的版本，因此我们知道Python将使用我们期望的版本。请注意，Python代码是在Intel
    Galileo Gen 2板上的Yocto Linux上运行的。
- en: 'Now, enter the following line to check whether the `mraa` library has successfully
    detected the board type:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，输入以下行来检查`mraa`库是否已成功检测到板类型：
- en: '[PRE43]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The Python interpreter will display the following output:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: Python解释器将显示以下输出：
- en: '[PRE44]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We called the `mraa.getPlatformName` method and the result of calling the method
    displays our board''s name: Intel Galileo Gen 2\. The following screenshot shows
    the results of calling the previous methods:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用了`mraa.getPlatformName`方法，调用该方法的结果显示了我们的板名：Intel Galileo Gen 2。以下截图显示了调用先前方法的结果：
- en: '![Invoking the Python interpreter](img/B05042_02_13.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![调用Python解释器](img/B05042_02_13.jpg)'
- en: 'Now, open a Web browser in any computer or device connected to your LAN and
    enter the board''s assigned IP address. For example, in case the IP address is
    **192.168.1.104**, enter it as the URL to browse. The following screenshot shows
    the content you will see on your Web browser: **It works!**'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在任何连接到你的局域网中的计算机或设备上打开一个Web浏览器，并输入板分配的IP地址。例如，如果IP地址是**192.168.1.104**，将其作为URL进行浏览。以下截图显示了您将在Web浏览器中看到的内容：**它工作了！**
- en: '![Invoking the Python interpreter](img/B05042_02_14.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![调用Python解释器](img/B05042_02_14.jpg)'
- en: The board is working as a Web server and it returns the contents of the `/www/pages/index.html`
    file to the Web browser request.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 该板正在作为Web服务器运行，并将`/www/pages/index.html`文件的 内容返回给Web浏览器的请求。
- en: Test your knowledge
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试你的知识
- en: 'We can access Python 2.7.x on the Intel Galileo Gen 2 board:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以在Intel Galileo Gen 2板上访问Python 2.7.x：
- en: After booting the pre-installed SPI image from the flash memory.
  id: totrans-182
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在从闪存启动预安装的SPI镜像后。
- en: After booting a Yocto Linux from the microSD card, specifically, the IoT Devkit
    image.
  id: totrans-183
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在从microSD卡启动Yocto Linux后，特别是IoT Devkit镜像。
- en: After booting the pre-installed SPI image and pressing the reboot button three
    times.
  id: totrans-184
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在启动预安装的SPI镜像并按重启按钮三次后。
- en: 'Once an Intel Galileo Gen 2 board is connected to our LAN, we can access its
    shell with any utility that allows us to use the following interface and protocol:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦Intel Galileo Gen 2板连接到我们的局域网，我们就可以使用任何允许我们使用以下接口和协议的实用程序来访问它的shell：
- en: SSH.
  id: totrans-186
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: SSH.
- en: Telnet.
  id: totrans-187
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Telnet.
- en: X.25.
  id: totrans-188
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: X.25.
- en: 'Which of the following libraries has bindings to Python and allows us to work
    with the I/O on Intel Galileo Gen 2:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个库提供了与Python的绑定，并允许我们在Intel Galileo Gen 2上处理I/O：
- en: IotGalileoGen2.
  id: totrans-190
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: IotGalileoGen2.
- en: Mraa.
  id: totrans-191
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Mraa.
- en: Mupm.
  id: totrans-192
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: Mupm.
- en: 'Which of the following packages is a Python module that provides an API similar
    to the WiringPi module to use general purpose I/O pins on the Intel Galieo Gen
    2:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个包是一个Python模块，它提供了一个类似于WiringPi模块的API，用于在Intel Galieo Gen 2上使用通用I/O引脚：
- en: wiring-py-galileo.
  id: totrans-194
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: wiring-py-galileo.
- en: galileo-gen2-x86.
  id: totrans-195
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: galileo-gen2-x86.
- en: wiring-x86.
  id: totrans-196
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: wiring-x86.
- en: 'Which of the following methods return the board that the mraa library automatically
    detects:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪种方法可以返回mraa库自动检测到的板：
- en: mraa.getPlatformName().
  id: totrans-198
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: mraa.getPlatformName().
- en: mraa.getBoardName().
  id: totrans-199
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: mraa.getBoardName().
- en: mraa.getGalileoBoardName().
  id: totrans-200
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: mraa.getGalileoBoardName().
- en: Summary
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we followed many procedures to make is possible to work with
    Python as the main programming language to create IoT projects with our Intel
    Galileo Gen 2 board. We wrote a Linux Yocto image to a microSD card and we configured
    the board to make it boot this image, so that we can access Python and other useful
    libraries to interact with the board. We updated many libraries to use their latest
    versions and we launched the Python interpreter.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们遵循了许多程序，使得可以使用Python作为主要编程语言，用我们的Intel Galileo Gen 2板创建物联网项目。我们将Linux
    Yocto镜像写入到microSD卡中，并配置了板子使其能够启动这个镜像，这样我们就可以访问Python和其他有用的库来与板子交互。我们更新了许多库以使用它们的最新版本，并启动了Python解释器。
- en: Now that our board is ready to be coded with Python, we can start wiring electronic
    components to the board and work with Python and the libraries to write digital
    values, which is the topic of the next chapter.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好用Python编写代码的板，我们可以开始将电子组件连接到板上，并使用Python和库来写入数字值，这是下一章的主题。
