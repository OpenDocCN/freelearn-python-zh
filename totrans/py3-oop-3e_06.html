<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Python Data Structures</h1>
                </header>
            
            <article>
                
<p> In our examples so far, we've already seen many of the built-in Python data structures in action. You've probably also covered many of them in introductory books or tutorials. In this chapter, we'll discuss the object-oriented features of these data structures, when they should be used instead of a regular class, and when they should not be used. In particular, we'll be covering <span>the following topics</span>:</p>
<ul>
<li>Tuples and named tuples</li>
<li>Dataclasses</li>
<li>Dictionaries</li>
<li>Lists and sets</li>
<li>How and why to extend built-in objects</li>
<li>Three types of queues</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Empty objects</h1>
                </header>
            
            <article>
                
<p>Let's start with the most basic Python built-in, one that we've seen many times already, the one that we've extended in every class we have created: the <kbd>object</kbd>. Technically, we can instantiate an <kbd>object</kbd> without writing a subclass, as follows:</p>
<pre>    <strong>&gt;&gt;&gt; o = object()</strong>
    <strong>&gt;&gt;&gt; o.x = 5</strong>
    <strong>Traceback (most recent call last):</strong>
    <strong>  File "&lt;stdin&gt;", line 1, in &lt;module&gt;</strong>
    <strong>AttributeError: 'object' object has no attribute 'x'</strong>  </pre>
<p>Unfortunately, as you can see, it's not possible to set any attributes on an <kbd>object</kbd> that was instantiated directly. This isn't because the Python developers wanted to force us to write our own classes, or anything so sinister. They did this to save memory; a lot of memory. When Python allows an object to have arbitrary attributes, it takes a certain amount of system memory to keep track of what attributes each object has, for storing both the attribute name and its value. Even if no attributes are stored, memory is allocated for <em>potential</em> new attributes. Given the dozens, hundreds, or thousands of objects (every class extends an object) in a typical Python program; this small amount of memory would quickly become a large amount of memory. So, Python disables arbitrary properties on <kbd>object</kbd>, and several other built-ins, by default.</p>
<div class="packt_infobox">It is possible to restrict arbitrary properties on our own classes using <strong>slots</strong>. Slots are beyond the scope of this book, but you now have a search term if you are looking for more information. In normal use, there isn't much benefit to using slots, but if you're writing an object that will be duplicated thousands of times throughout the system, they can help save memory, just as they do for <kbd>object</kbd>.</div>
<p>It is, however, trivial to create an empty object class of our own; we saw it in our earliest example:</p>
<pre>class MyObject: 
    pass </pre>
<p>And, as we've already seen, it's possible to set attributes on such classes as follows:</p>
<pre><strong>&gt;&gt;&gt; m = MyObject()</strong>
<strong>&gt;&gt;&gt; m.x = "hello"</strong>
<strong>&gt;&gt;&gt; m.x</strong>
<strong>'hello'</strong>  </pre>
<p>If we wanted to group properties together, we could store them in an empty object like this. But we are usually better off using other built-ins designed for storing data. It has been stressed throughout this book that classes and objects should only be used when you want to specify <em>both</em> data and behaviors. The main reason to write an empty class is to quickly block something out, knowing we'll come back later to add behavior. It is much easier to adapt behaviors to a class than it is to replace a data structure with an object and change all references to it. Therefore, it is important to decide from the outset whether the data is just data, or whether it is an object in disguise. Once that design decision is made, the rest of the design naturally falls into place.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Tuples and named tuples</h1>
                </header>
            
            <article>
                
<p>Tuples are objects that can store a specific number of other objects in order. They are <em>immutable</em>, meaning we can't add, remove, or replace objects on the fly. This may seem like a massive restriction, but the truth is, if you need to modify a tuple, you're using the wrong data type (usually, a list would be more suitable). The primary benefit of tuples' immutability is that we can use them as keys in dictionaries, and in other locations where an object requires a hash value.</p>
<p>Tuples are used to store data; behavior cannot be associated with a tuple. If we require behavior to manipulate a tuple, we have to pass the tuple into a function (or method on another object) that performs the action.</p>
<p>Tuples should generally store values that are somehow different from each other. For example, we would not put three stock symbols in a tuple, but we might create a tuple containing a stock symbol with its current, high, and low prices for the day. The primary purpose of a tuple is to aggregate different pieces of data together into one container. Thus, a tuple can be the easiest tool to replace the <em>object with no data</em> idiom.</p>
<p>We can create a tuple by separating values with a comma. Usually, tuples are wrapped in parentheses to make them easy to read and to separate them from other parts of an expression, but this is not always mandatory. The following two assignments are identical (they record a stock, the current price, the high, and the low, for a rather profitable company):</p>
<pre><strong>&gt;&gt;&gt; stock = "FB", 177.46, 178.67, 175.79</strong>
<strong>&gt;&gt;&gt; stock2 = ("FB", 177.46, 178.67, 175.79)</strong></pre>
<p>If we're grouping a tuple inside of some other object, such as a function call, list comprehension, or generator, the parentheses are required. Otherwise, it would be impossible for the interpreter to know whether it is a tuple or the next function parameter. For example, the following function accepts a tuple and a date, and returns a tuple of the date and the middle value between the stock's high and low value:</p>
<pre>import datetime<br/><br/><br/>def middle(stock, date):<br/><strong>    symbol, current, high, low = stock</strong><br/>    return (((high + low) / 2), date)<br/><br/><br/>mid_value, date = middle(<br/>    <strong>("FB", 177.46, 178.67, 175.79)</strong>, datetime.date(2018, 8, 27)<br/>)</pre>
<p>The tuple is created directly inside the function call by separating the values with commas and enclosing the entire tuple in parentheses. This tuple is then followed by a comma to separate it from the second argument.</p>
<p>This example also illustrates <em>tuple unpacking</em>. The first line inside the function unpacks the <kbd>stock</kbd> parameter into four different variables. The tuple has to be exactly the same length as the number of variables, or it will raise an exception. We can also see an example of tuple unpacking in the last clause, where the tuple returned from inside the function is unpacked into two values, <kbd>mid_value</kbd> and <kbd>date</kbd>. Granted, this is a strange thing to do, since we supplied the date to the function in the first place, but it gave us a chance to see unpacking at work.</p>
<p>Unpacking is a very useful feature in Python. We can group variables together to make storing and passing them around simpler, but the moment we need to access all of them, we can unpack them into separate variables. Of course, sometimes we only need access to one of the variables in the tuple. We can use the same syntax that we use for other sequence types (lists and strings, for example) to access an individual value:</p>
<pre><strong>&gt;&gt;&gt; stock = "FB", 75.00, 75.03, 74.90</strong>
<strong>&gt;&gt;&gt; high = stock[2]</strong>
<strong>&gt;&gt;&gt; high</strong>
<strong>75.03</strong>  </pre>
<p>We can even use slice notation to extract larger pieces of <span>tuples, as demonstrated in the following:</span></p>
<pre><strong>&gt;&gt;&gt; stock[1:3]</strong>
<strong>(75.00, 75.03)</strong>  </pre>
<p>These examples, while illustrating how flexible tuples can be, also demonstrate one of their major disadvantages: readability. How does someone reading this code know what is in the second position of a specific tuple? They can guess, from the name of the variable we assigned it to, that it is <kbd>high</kbd> of some sort, but if we had just accessed the tuple value in a calculation without assigning it, there would be no such indication. They would have to paw through the code to find where the tuple was declared before they could discover what it does.</p>
<p>Accessing tuple members directly is fine in some circumstances, but don't make a habit of it. Such so-called <em>magic numbers</em> (numbers that seem to come out of thin air with no apparent meaning within the code) are the source of many coding errors and lead to hours of frustrated debugging. Try to use tuples only when you know that all the values are going to be useful at once and it's normally going to be unpacked when it is accessed. If you have to access a member directly, or by using a slice, and the purpose of that value is not immediately obvious, at least include a comment explaining where it came from.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Named tuples</h1>
                </header>
            
            <article>
                
<p>So, what do we do when we want to group values together, but know we're frequently going to need to access them individually? There are actually several options. We could use an empty object, as discussed previously (but that is rarely useful, unless we anticipate adding behavior later), or we could use a dictionary (most useful if we don't know exactly how much data or which specific data will be stored), as we'll cover in a later section. Two other options are named tuples, which we'll discuss here, and dataclasses, in the next section.</p>
<p>If we do not need to add behavior to the object, and we know in advance which attributes we need to store, we can use a named tuple. Named tuples are tuples with attitude. They are a great way to group read-only data together.</p>
<p>Constructing a named tuple takes a bit more work than a normal tuple. First, we have to import <kbd>namedtuple</kbd>, as it is not in the namespace by default. Then, we describe the named tuple by giving it a name and outlining its attributes. This returns a class-like object that we can instantiate with the required values as many times as we want<span>, as demonstrated in the following:</span></p>
<pre>from collections import namedtuple 
Stock = namedtuple("Stock", ["symbol", "current", "high", "low"])
stock = Stock("FB", 177.46, high=178.67, low=175.79) </pre>
<p>The <kbd>namedtuple</kbd> constructor accepts two arguments. The first is an identifier for the named tuple. The second is a list of string attributes that the named tuple requires. The result is an object that can be called just like a normal class to instantiate other objects. The constructor must have exactly the correct number of arguments that can be passed in as arguments or keyword arguments. As with normal objects, we can create as many instances of this <em>class</em> as we like, with different values for each.</p>
<div class="packt_tip">Be careful not to use a reserved keyword (class, for example) as an attribute for a named tuple.</div>
<p>The resulting <kbd>namedtuple</kbd> can then be packed, unpacked, indexed, sliced, and otherwise treated like a normal tuple, but we can also access individual attributes on it as if it were an object:</p>
<pre><strong>&gt;&gt;&gt; stock.high</strong>
1<strong>75.79</strong>
<strong>&gt;&gt;&gt; symbol, current, high, low = stock</strong>
<strong>&gt;&gt;&gt; current</strong>
<strong>177.46</strong>  </pre>
<div class="packt_tip">Remember that creating named tuples is a two-step process. First, use <kbd>collections.namedtuple</kbd> to create a class, and then construct instances of that class.</div>
<p>Named tuples are perfect for many <em>data only</em> representations, but they are not ideal for all situations. Like tuples and strings, named tuples are immutable, so we cannot modify an attribute once it has been set. For example, the current value of my company's stock has gone down since we started this discussion, but we can't set the new value, as can be seen in the following:</p>
<pre><strong>&gt;&gt;&gt; stock.current = 74.98</strong>
<strong>Traceback (most recent call last):</strong>
<strong>  File "&lt;stdin&gt;", line 1, in &lt;module&gt;</strong>
<strong>AttributeError: can't set attribute</strong>  </pre>
<p>If we need to be able to change stored data, a dataclass may be what we need instead.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Dataclasses</h1>
                </header>
            
            <article>
                
<p>Dataclasses are basically regular objects w</p>
<p>ith a clean syntax for predefining attributes. There are a few ways to create one, and we'll explore each in this section.</p>
<p>The simplest way is to use a similar construct to that used for named tuples, as follows:</p>
<pre>from dataclasses import make_dataclass<br/>Stock = make_dataclass("Stock", "symbol", "current", "high", "low")<br/>stock = Stock("FB", 177.46, high=178.67, low=175.79)</pre>
<p>Once instantiated, the stock object can be used like any regular class. You can access and update attributes and can even assign other arbitrary attributes to the object, as follows:</p>
<pre><strong>&gt;&gt;&gt; stock</strong><br/><strong>Stock(symbol='FB', current=177.46, high=178.67, low=175.79)</strong><br/><strong>&gt;&gt;&gt; stock.current</strong><br/><strong>177.46</strong><br/><strong>&gt;&gt;&gt; stock.current=178.25</strong><br/><strong>&gt;&gt;&gt; stock</strong><br/><strong>Stock(symbol='FB', current=178.25, high=178.67, low=175.79)</strong><br/><strong>&gt;&gt;&gt; stock.unexpected_attribute = 'allowed'</strong><br/><strong>&gt;&gt;&gt; stock.unexpected_attribute</strong><br/><strong>'allowed'</strong></pre>
<p>At first glance, it seems like dataclasses don't give you much benefit over a normal object with an appropriate constructor:</p>
<pre>class StockRegClass:<br/>    def __init__(self, name, current, high, low):<br/>        self.name = name<br/>        self.current = current<br/>        self.high = high<br/>        self.low = low<br/><br/>stock_reg_class = Stock("FB", 177.46, high=178.67, low=175.79)</pre>
<p>The obvious benefit is that with <kbd>make_dataclass</kbd>, you get to define the class in one line instead of six. If you look a little closer, you'll see that the dataclass also gives you a much more useful string representation than the regular version. It also provides an equality comparison for free. The following example compares the regular class to these dataclass features:</p>
<pre><strong>&gt;&gt;&gt; stock_reg_class<br/>&lt;__main__.Stock object at 0x7f506bf4ec50&gt;<br/>&gt;&gt;&gt; stock_reg_class2 = StockRegClass("FB", 177.46, 178.67, 175.79)<br/>&gt;&gt;&gt; stock_reg_class2 == stock_reg_class<br/>False<br/>&gt;&gt;&gt; stock2 = Stock("FB", 177.46, 178.67, 175.79)<br/>&gt;&gt;&gt; stock2 == stock<br/>True<br/></strong></pre>
<p>As we'll soon see, dataclasses also have many other useful features. But first, let's look at an alternative (and more common) way to define a <span>dataclass. Refer to the following block of code:</span></p>
<pre>from dataclasses import dataclass<br/><br/><strong>@dataclass</strong><br/>class StockDecorated:<br/>    name: str<br/>    current: float<br/>    high: float<br/>    low: float</pre>
<p>If you haven't seen type hints before, this syntax probably looks truly bizarre. These so-called variable annotations were introduced to the language in Python 3.6. I'm classifying type hints as <em>beyond the scope of this book</em>, so I'll leave you to do a web search if you want to find out more about them. For now, just know that the preceding is truly legal Python syntax, and that it works. You don't have to take my word for it; just run the code and observe the lack of syntax errors!</p>
<div class="packt_infobox">If you don't feel like using type hints or your attribute takes a value with a complicated type or set of types, specify the type as <kbd>Any</kbd>. You can pull the <kbd>Any</kbd> type into your namespace using <kbd>from typing import Any</kbd>.</div>
<p>The <kbd>dataclass</kbd> function is applied as a class decorator. We encountered decorators in a previous chapter when we were discussing properties. I promised then that we'll go into more detail about them in a future chapter. I'll keep that promise in chapter 10. For now, just know that the syntax is required to generate a dataclass.</p>
<p>Granted, this syntax isn't much less verbose than the regular class with <kbd>__init__</kbd>, but it gives us access to several additional dataclass features. For example, you can specify a default value for a dataclass. Perhaps the market is currently closed and you don't know what the values for the day are:</p>
<pre><strong>@dataclass</strong><br/>class StockDefaults:<br/>    name: str<br/>    current: float = 0.0<br/>    high: float = 0.0<br/>    low: float = 0.0</pre>
<p>You can construct this class with just the stock name; the rest of the values will take on the defaults. But you can still specify values if you prefer, as follows:</p>
<pre><strong>&gt;&gt;&gt; StockDefaults('FB')</strong><br/><strong>StockDefaults(name='FB', current=0.0, high=0.0, low=0.0)</strong><br/><strong>&gt;&gt;&gt; StockDefaults('FB', 177.46, 178.67, 175.79)</strong><br/><strong>StockDefaults(name='FB', current=177.46, high=178.67, low=175.79)<br/></strong></pre>
<p>We saw earlier that dataclasses automatically support equality comparison. If all the attributes compare as equal, then the dataclass also compares as equal. By default, dataclasses do not support other comparisons, such as less than or greater than, and they can't be sorted. However, you can easily add comparisons if you <span>wish, demonstrated as follows:</span></p>
<pre><strong>@dataclass(order=True)</strong><br/>class StockOrdered:<br/>    name: str<br/>    current: float = 0.0<br/>    high: float = 0.0<br/>    low: float = 0.0<br/><br/><br/>stock_ordered1 = StockDecorated("FB", 177.46, high=178.67, low=175.79)<br/>stock_ordered2 = StockOrdered("FB")<br/>stock_ordered3 = StockDecorated("FB", 178.42, high=179.28, low=176.39)</pre>
<p>All that we changed in this example was adding the <kbd>order=True</kbd> keyword to the dataclass constructor. But that gives us the opportunity to sort and compare the following values:</p>
<pre><strong>&gt;&gt;&gt; stock_ordered1 &lt; stock_ordered2</strong><br/><strong>False</strong><br/><strong>&gt;&gt;&gt; stock_ordered1 &gt; stock_ordered2</strong><br/><strong>True</strong><br/><strong>&gt;&gt;&gt; from pprint import pprint</strong><br/><strong>&gt;&gt;&gt; pprint(sorted([stock_ordered1, stock_ordered2, stock_ordered3]))</strong><br/><strong>[StockOrdered(name='FB', current=0.0, high=0.0, low=0.0),</strong><br/><strong> StockOrdered(name='FB', current=177.46, high=178.67, low=175.79),</strong><br/><strong> StockOrdered(name='FB', current=178.42, high=179.28, low=176.39)]<br/></strong></pre>
<p>When a dataclass receives the <kbd>order=True</kbd> argument, it will, by default, compare the values based on each of the attributes in the order they were defined. So, in this case, it first compares the name on the two classes. If those are the same, it compares the current price. If those are also the same, it will compare the highs and then the lows. You can customize the sort order by providing a <kbd>sort_index</kbd> attribute inside a <kbd>__post_init__</kbd> method on the class, but I'll leave you to search the web to get the full details of this and other advanced usages (such as immutability), as this section is getting rather long and we have a lot of other data structures to study.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Dictionaries</h1>
                </header>
            
            <article>
                
<p>Dictionaries are incredibly useful containers that allow us to map objects directly to other objects. An empty object with attributes to it is a sort of dictionary; the names of the properties map to the property values. This is actually closer to the truth than it sounds; internally, objects normally represent attributes as a dictionary, where the values are properties or methods on the objects (see the <kbd>__dict__</kbd> attribute if you don't believe me). Even the attributes on a module are stored, internally, in a dictionary.</p>
<p>Dictionaries are extremely efficient at looking up a value, given a specific key object that maps to that value. They should always be used when you want to find one object based on some other object. The object that is being stored is called the <strong>value</strong>; the object that is being used as an index is called the <strong>key</strong>. We've already seen dictionary syntax in some of our previous examples.</p>
<p>Dictionaries can be created either using the <kbd>dict()</kbd> constructor or using the <kbd>{}</kbd> syntax shortcut. In practice, the latter format is almost always used. We can prepopulate a dictionary by separating the keys from the values using a colon, and separating the key value pairs using a comma.</p>
<p>For example, in a stock application, we would most often want to look up prices by the stock symbol. We can create a dictionary that uses stock symbols as keys, and tuples (you could also used named tuples or dataclasses as values, of course) of current, high, and low as values, like this:</p>
<pre>stocks = {<br/>    "GOOG": (1235.20, 1242.54, 1231.06),<br/>    "MSFT": (<span><span class="r-i4PGnCJTRu4c"><span class="IsqQVc NprOob i4PGnCJTRu4c-zJFzKq8ukm8">110.41</span></span></span>, 110.45, 109.84),<br/>}</pre>
<p>As we've seen in previous examples, we can then look up values in the dictionary by requesting a key inside square brackets. If the key is not in the dictionary, it will raise an <span>exception, demonstrated as follows:</span></p>
<pre><strong>&gt;&gt;&gt; stocks["GOOG"]</strong>
<strong>(1235.20, 1242.54, 1231.06)</strong>
<strong>&gt;&gt;&gt; stocks["RIM"]</strong>
<strong>Traceback (most recent call last):</strong>
<strong>  File "&lt;stdin&gt;", line 1, in &lt;module&gt;</strong>
<strong>KeyError: 'RIM'</strong>  </pre>
<p>We can, of course, catch the <kbd>KeyError</kbd> and handle it. But we have other options. Remember, dictionaries are objects, even if their primary purpose is to hold other objects. As such, they have several behaviors associated with them. One of the most useful of these methods is the <kbd>get</kbd> method; it accepts a key as the first parameter and an optional default value if the key doesn't exist:</p>
<pre><strong>&gt;&gt;&gt; print(stocks.get("RIM"))</strong>
<strong>None</strong>
<strong>&gt;&gt;&gt; stocks.get("RIM", "NOT FOUND")</strong>
<strong>'NOT FOUND'</strong>  </pre>
<p>For even more control, we can use the <kbd>setdefault</kbd> method. If the key is in the dictionary, this method behaves just like <kbd>get</kbd>; it returns the value for that key. Otherwise, if the key is not in the dictionary, it will not only return the default value we supply in the method call (just like <kbd>get</kbd> does); it will also set the key to that same value. Another way to think of it is that <kbd>setdefault</kbd> sets a value in the dictionary only if that value has not previously been set. Then, it returns the value in the dictionary; either the one that was already there, or the newly provided default value, as can be seen in the following:</p>
<pre><strong>&gt;&gt;&gt; stocks.setdefault("GOOG", "INVALID")</strong>
<strong>(613.3, 625.86, 610.5)</strong>
<strong>&gt;&gt;&gt; stocks.setdefault("BBRY", (10.87, 10.76, 10.90))</strong>
<strong>(10.50, 10.62, 10.39)</strong>
<strong>&gt;&gt;&gt; stocks["BBRY"]</strong>
<strong>(10.50, 10.62, 10.39)</strong>  </pre>
<p>The <kbd>GOOG</kbd> stock was already in the dictionary, so when we tried to <kbd>setdefault</kbd> it to an invalid value, it just returned the value already in the dictionary. <kbd>BBRY</kbd> was not in the dictionary, so <kbd>setdefault</kbd> returned the default value and set the new value in the dictionary for us. We then check that the new stock is, indeed, in the dictionary.</p>
<p>Three other very useful dictionary methods are <kbd>keys()</kbd>, <kbd>values()</kbd>, and <kbd>items()</kbd>. The first two return an iterator over all the keys and all the values in the dictionary. We can use these like lists or in <kbd>for</kbd> loops if we want to process all the keys or values. The <kbd>items()</kbd> method is probably the most useful; it returns an iterator over tuples of <kbd>(key, value)</kbd> pairs for every item in the dictionary. This works great with tuple unpacking in a <kbd>for</kbd> loop to loop over associated keys and values. This example does just that to print each stock in the dictionary with its current value:</p>
<pre><strong>&gt;&gt;&gt; for stock, values in stocks.items():</strong><br/><strong>... print(f"{stock} last value is {values[0]}")</strong><br/><strong>...</strong><br/><strong>GOOG last value is 1235.2</strong><br/><strong>MSFT last value is 110.41</strong><br/><strong>BBRY last value is 10.5</strong></pre>
<p>Each key/value tuple is unpacked into two variables named <kbd>stock</kbd> and <kbd>values</kbd> (we could use any variable names we wanted, but these both seem appropriate) and then printed in a formatted string.</p>
<div class="packt_infobox">Notice that the stocks show up in the same order in which they were inserted. This was not true until Python 3.6, and was not a formal part of the language definition until Python 3.7. Before that, the underlying dict implementation used a different underlying data structure that was not ordered. It's quite rare to need ordering in dictionaries, but if you do and you need to support Python 3.5 or older, make sure you use the <kbd>OrderedDict</kbd> class instead, which is available from the <kbd>collections</kbd> module.</div>
<p>So, there are numerous ways to retrieve data from a dictionary once it has been instantiated: we can use square brackets as index syntax, the <kbd>get</kbd> method, the <kbd>setdefault</kbd> method, or iterate over the <kbd>items</kbd> method, among others.</p>
<p>Finally, as you likely already know, we can set a value in a dictionary using the same indexing syntax we use to retrieve a value:</p>
<pre><strong>&gt;&gt;&gt; stocks["GOOG"] = (1245.21, 1252.64, 1245.18)</strong>
<strong>&gt;&gt;&gt; stocks['GOOG']</strong>
<strong>(1245.21, 1252.64, 1245.18)</strong></pre>
<p>Google's price is higher today, so I've updated the tuple value in the dictionary. We can use this index syntax to set a value for any key, regardless of whether the key is in the dictionary. If it is in the dictionary, the old value will be replaced with the new one; otherwise, a new key/value pair will be created.</p>
<p>We've been using strings as dictionary keys, so far, but we aren't limited to string keys. It is common to use strings as keys, especially when we're storing data in a dictionary to gather it together (instead of using an object or dataclass with named properties). But we can also use tuples, numbers, or even objects we've defined ourselves as dictionary keys. We can even use different types of keys in a single <span>dictionary, as demonstrated in the following:</span></p>
<pre>random_keys = {} 
random_keys["astring"] = "somestring" 
random_keys[5] = "aninteger" 
random_keys[25.2] = "floats work too" 
random_keys[("abc", 123)] = "so do tuples" 
 
class AnObject: 
    def __init__(self, avalue): 
        self.avalue = avalue 
 
my_object = AnObject(14) 
random_keys[my_object] = "We can even store objects" 
my_object.avalue = 12 
try: 
    random_keys[[1,2,3]] = "we can't store lists though" 
except: 
    print("unable to store list\n") 
 
for key, value in random_keys.items(): 
    print("{} has value {}".format(key, value)) </pre>
<p>This code shows several different types of keys we can supply to a dictionary. It also shows one type of object that cannot be used. We've already used lists extensively, and we'll be seeing many more details of them in the next section. Because lists can change at any time (by adding or removing items, for example), they cannot <strong>hash</strong> to a specific value.</p>
<p>Objects that are <strong>hashable</strong> basically have a defined algorithm that converts the object into a unique integer value for rapid lookup in the dictionary. This hash is what is actually used to find values in a dictionary. For example, strings map to integers based on the byte values of the characters in the string, while tuples combine hashes of the items inside the tuple. Any two objects that are somehow considered equal (such as strings with the same characters or tuples with the same values) should have the same hash value, and the hash value for an object should never ever change. Lists, however, can have their contents changed, which would change their hash value (two lists should only be equal if their contents are the same). Because of this, they can't be used as dictionary keys. For the same reason, dictionaries cannot be used as keys into other dictionaries.</p>
<p>In contrast, there are no limits on the types of objects that can be used as dictionary values. We can use a string key that maps to a list value, for example, or we can have a nested dictionary as a value in another dictionary.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Dictionary use cases</h1>
                </header>
            
            <article>
                
<p>Dictionaries are extremely versatile and have numerous uses. There are two major ways that dictionaries can be used. The first is dictionaries where all the keys represent different instances of similar objects; for example, our stock dictionary. This is an indexing system. We use the stock symbol as an index to the values. The values could even have been complicated, self-defined objects that had methods to make buy and sell decisions or set a stop-loss, rather than our simple tuples.</p>
<p>The second design is dictionaries where each key represents some aspect of a single structure; in this case, we'd probably use a separate dictionary for each object, and they'd all have similar (though often not identical) sets of keys. This latter situation can often also be solved with named tuples or dataclasses. This can be confusing; how do we decide which to use?</p>
<p>We should typically use dataclasses when we know exactly what attributes the data must store, especially if we also want to use the class definition as documentation for the end user.</p>
<p>Dataclasses are a newer addition to the Python standard library (since Python 3.7). I expect them to replace named tuples for a huge number of use cases. Named tuples may also be useful if you are going to be returning them from functions. That allows the calling function to use tuple unpacking if it is useful to do so. Dataclasses are not iterable, so you can't loop over or unpack their values.</p>
<p>On the other hand, dictionaries would be a better choice if the keys describing the object are not known in advance, or if different objects will have some variety in their keys. If we don't know in advance what all the keys are going to be, it's probably better to use a dictionary.</p>
<div class="packt_infobox">Technically, most Python objects are implemented using dictionaries under the hood. You can see this by loading an object into the interactive interpreter and looking at the <kbd>obj.__dict__</kbd> magic attribute. When you access an attribute on an object using <kbd>obj.attr_name</kbd>, it essentially translates the lookup to <kbd>obj['attr_name']</kbd> under the hood. It's more complicated than that, but you get the gist. Even dataclasses have a <kbd>__dict__</kbd> attribute, which just goes to show how versatile dictionaries really are. Note that not all objects are stored in dictionaries, however. There are a few special types, such as lists, dictionaries, and datetimes that are implemented in a different way, mostly for efficiency purposes. It would certainly be odd if an instance of <kbd>dict</kbd> had a <kbd>__dict__</kbd> attribute that was an instance of <kbd>dict</kbd>, wouldn't it?</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using defaultdict</h1>
                </header>
            
            <article>
                
<p>We've seen how to use <kbd>setdefault</kbd> to set a default value if a key doesn't exist, but this can get a bit monotonous if we need to set a default value every time we look up a value. For example, if we're writing code that counts the number of times a letter occurs in a given sentence, we could do the following:</p>
<pre>def letter_frequency(sentence): 
    frequencies = {} 
    for letter in sentence: 
        frequency = frequencies.setdefault(letter, 0) 
        frequencies[letter] = frequency + 1 
    return frequencies </pre>
<p>Every time we access the dictionary, we need to check that it has a value already, and if not, set it to zero. When something like this needs to be done every time an empty key is requested, we can use a different version of the dictionary, called <kbd>defaultdict</kbd>:</p>
<pre><strong>from collections import defaultdict</strong> 
def letter_frequency(sentence): 
<strong>    frequencies = defaultdict(int)</strong> 
    for letter in sentence: 
        frequencies[letter] += 1 
    return frequencies </pre>
<p>This code looks like it couldn't possibly work. The <kbd>defaultdict</kbd> accepts a function in its constructor. Whenever a key is accessed that is not already in the dictionary, it calls that function, with no parameters, to create a default value.</p>
<p>In this case, the function it calls is <kbd>int</kbd>, which is the constructor for an integer object. Normally, integers are created simply by typing an integer number into our code, and if we do create one using the <kbd>int</kbd> constructor, we pass it the item we want to create (for example, to convert a string of digits into an integer). But if we call <kbd>int</kbd> without any arguments, it returns, conveniently, the number zero. In this code, if the letter doesn't exist in the <kbd>defaultdict</kbd>, the number zero is returned when we access it. Then, we add one to this number to indicate that we've found an instance of that letter, and the next time we find one, that number will be returned and we can increment the value again.</p>
<p>The <kbd>defaultdict</kbd> is useful for creating dictionaries of containers. If we want to create a dictionary of closing stock prices for the past 30 days, we could use a stock symbol as the key and store the prices in <kbd>list</kbd>; the first time we access the stock price, we would want it to create an empty list. Simply pass <kbd>list</kbd> into the <kbd>defaultdict</kbd>, and it will be called every time an empty key is accessed. We can do similar things with sets or even empty dictionaries if we want to associate one with a key.</p>
<p>Of course, we can also write our own functions and pass them into the <kbd>defaultdict</kbd>. Suppose we want to create a <kbd>defaultdict</kbd> where each new element contains a tuple of the number of items inserted into the dictionary at that time and an empty list to hold other things. It's unlikely that we would want to create such an object, but let's have a look:</p>
<pre>from collections import defaultdict<br/><br/> 
num_items = 0 <br/><br/>def tuple_counter(): 
    global num_items 
    num_items += 1 
    return (num_items, []) 
 
d = defaultdict(tuple_counter) </pre>
<p>When we run this code, we can access empty keys and insert them into the list all in a single statement:</p>
<pre><strong>&gt;&gt;&gt; d = defaultdict(tuple_counter)</strong>
<strong>&gt;&gt;&gt; d['a'][1].append("hello")</strong>
<strong>&gt;&gt;&gt; d['b'][1].append('world')</strong>
<strong>&gt;&gt;&gt; d</strong>
<strong>defaultdict(&lt;function tuple_counter at 0x82f2c6c&gt;,</strong>
<strong>{'a': (1, ['hello']), 'b': (2, ['world'])})</strong>  </pre>
<p>When we print <kbd>dict</kbd> at the end, we see that the counter really was working.</p>
<div class="packt_infobox">This example, while succinctly demonstrating how to create our own function for <kbd>defaultdict</kbd>, is not actually very good code; using a global variable means that if we created four different <kbd>defaultdict</kbd> segments that each used <kbd>tuple_counter</kbd>, it would count the number of entries in all dictionaries, rather than having a different count for each one. It would be better to create a class and pass a method on that class to <kbd>defaultdict</kbd>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Counter</h1>
                </header>
            
            <article>
                
<p>You'd think that you couldn't get much simpler than <kbd>defaultdict(int)</kbd>, but the <em>I want to count specific instances in an iterable</em> use case is common enough that the Python developers created a specific class for it. The previous code that counts characters in a string can easily be calculated in a single line:</p>
<pre><strong>from collections import Counter</strong> 
def letter_frequency(sentence): 
<strong>    return Counter(sentence)</strong> </pre>
<p>The <kbd>Counter</kbd> object behaves like a beefed-up dictionary where the keys are the items being counted and the values are the quantities of such items. One of the most useful functions is the <kbd>most_common()</kbd> method. It returns a list of (key, count) tuples ordered by the count. You can optionally pass an integer argument into <kbd>most_common()</kbd> to request only the top most common elements. For example, you could write a simple polling application as follows:</p>
<pre>from collections import Counter 
 
responses = [ 
    "vanilla", 
    "chocolate", 
    "vanilla", 
    "vanilla", 
    "caramel", 
    "strawberry", 
    "vanilla" 
] 
 
print( 
    "The children voted for {} ice cream".format( 
<strong> Counter(responses).most_common(1)[0][0]</strong> 
    ) 
) </pre>
<p>Presumably, you'd get the responses from a database or by using a computer vision algorithm to count the kids who raised their hands. Here, we hardcode it so that we can test the <kbd>most_common</kbd> method. It returns a list that has only one element (because we requested one element in the parameter). This element stores the name of the top choice at position zero, hence the double <kbd>[0][0]</kbd> at the end of the call. I think they look like a surprised face, don't you? Your computer is probably amazed it can count data so easily. It's ancestor, Hollerith's tabulating machine developed for the 1890 US census, must be so jealous!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Lists</h1>
                </header>
            
            <article>
                
<p>Lists are the least object-oriented of Python's data structures. While lists are, themselves, objects, there is a lot of syntax in Python to make using them as painless as possible. Unlike many other object-oriented languages, lists in Python are simply available. We don't need to import them and rarely need to call methods on them. We can loop over a list without explicitly requesting an iterator object, and we can construct a list (as with a dictionary) with custom syntax. Further, list comprehensions and generator expressions turn them into a veritable Swiss Army knife of computing functionality.</p>
<p>We won't go into too much detail of the syntax; you've seen it in introductory tutorials across the web and in previous examples in this book. You can't code Python for very long without learning how to use lists! Instead, we'll be covering when lists should be used, and their nature as objects. If you don't know how to create or append to a list, how to retrieve items from a list, or what <em>slice notation</em> is, I direct you to the official Python tutorial, posthaste. It can be found online at <a href="http://docs.python.org/3/tutorial/"><span class="URLPACKT">http://docs.python.org/3/tutorial/</span></a>.</p>
<p>In Python, lists should normally be used when we want to store several instances of the <em>same</em> type of object; lists of strings or lists of numbers; most often, lists of objects we've defined ourselves. Lists should always be used when we want to store items in some kind of order. Often, this is the order in which they were inserted, but they can also be sorted by other criteria.</p>
<p>As we saw in the case study from the previous chapter, lists are also very useful when we need to modify the contents: insert to, or delete from, an arbitrary location of the list, or update a value within the list.</p>
<p>Like dictionaries, Python lists use an extremely efficient and well-tuned internal data structure so we can worry about what we're storing, rather than how we're storing it. Many object-oriented languages provide different data structures for queues, stacks, linked lists, and array-based lists. Python does provide special instances of some of these classes, if optimizing access to huge sets of data is required. Normally, however, the list data structure can serve all these purposes at once, and the coder has complete control over how they access it.</p>
<p>Don't use lists for collecting different attributes of individual items. We do not want, for example, a list of the properties a particular shape has. Tuples, named tuples, dictionaries, and objects would all be more suitable for this purpose. In some languages, they might create a list in which each alternate item is a different type; for example, they might write <kbd>['a', 1, 'b', 3]</kbd> for our letter frequency list. They'd have to use a strange loop that accesses two elements in the list at once or a modulus operator to determine which position was being accessed.</p>
<p>Don't do this in Python. We can group related items together using a dictionary, as we did in the previous section, or using a list of tuples. Here's a rather convoluted counter-example that demonstrates how we could perform the frequency example using a list. It is much more complicated than the dictionary examples, and illustrates the effect choosing the right (or wrong) data structure can have on the readability of our <span>code. This is demonstrated as follows:</span></p>
<pre>import string 
CHARACTERS  = list(string.ascii_letters) + [" "] 
 
def letter_frequency(sentence): 
    frequencies = [(c, 0) for c in CHARACTERS] 
    for letter in sentence: 
        index = CHARACTERS.index(letter) 
        frequencies[index] = (letter,frequencies[index][1]+1) 
    return frequencies </pre>
<p>This code starts with a list of possible characters. The <kbd>string.ascii_letters</kbd> attribute provides a string of all the letters, lowercase and uppercase, in order. We convert this to a list, and then use list concatenation (the <kbd>+</kbd> operator causes two lists to be merged into one) to add one more character, a space. These are the available characters in our frequency list (the code would break if we tried to add a letter that wasn't in the list, but an exception handler could solve this).</p>
<p>The first line inside the function uses a list comprehension to turn the <kbd>CHARACTERS</kbd> list into a list of tuples. List comprehensions are an important, non-object-oriented tool in Python; we'll be covering them in detail in the next chapter.</p>
<p>Then, we loop over each of the characters in the sentence. We first look up the index of the character in the <kbd>CHARACTERS</kbd> list, which we know has the same index in our frequencies list, since we just created the second list from the first. We then update that index in the frequencies list by creating a new tuple, discarding the original one. Aside from garbage collection and memory waste concerns, this is rather difficult to read!</p>
<p>Like dictionaries, lists are objects too, and they have several methods that can be invoked upon them. Here are some common ones:</p>
<ul>
<li>The <kbd>append(element)</kbd> method adds an element to the end of the list</li>
<li>The <kbd>insert(index, element)</kbd> method inserts an item at a specific position</li>
<li>The <kbd>count(element)</kbd> method tells us how many times an element appears in the list</li>
<li>The <kbd>index()</kbd>method tells us the index of an item in the list, raising an exception if it can't find it</li>
<li>The <kbd>find()</kbd>method does the same thing, but returns <kbd>-1</kbd> instead of raising an exception for missing items</li>
<li>The <kbd>reverse()</kbd> method does exactly what it says—turns the list around</li>
<li>The <kbd>sort()</kbd> method has some rather intricate object-oriented behaviors, which we'll cover now</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Sorting lists</h1>
                </header>
            
            <article>
                
<p>Without any parameters, <kbd>sort</kbd> will generally do as expected. If it's a list of strings, it will place them in alphabetical order. This operation is case sensitive, so all capital letters will be sorted before lowercase letters; that is, <kbd>Z</kbd> comes before <kbd>a</kbd>. If it's a list of numbers, they will be sorted in numerical order. If a list of tuples is provided, the list is sorted by the first element in each tuple. If a mixture containing unsortable items is supplied, the sort will raise a <kbd>TypeError</kbd> exception.</p>
<p>If we want to place objects we define ourselves into a list and make those objects sortable, we have to do a bit more work. The special <kbd>__lt__ </kbd> <span>method,</span> which stands for <em>less than</em>, should be defined on the class to make instances of that class comparable. The <kbd>sort</kbd> method on the list will access this method on each object to determine where it goes in the list. This method should return <kbd>True</kbd> if our class is somehow less than the passed parameter, and <kbd>False</kbd> otherwise. Here's a rather silly class that can be sorted based on either a string or a number:</p>
<pre>class WeirdSortee:<br/>    def __init__(self, string, number, sort_num):<br/>        self.string = string<br/>        self.number = number<br/>        self.sort_num = sort_num<br/><br/><strong>    def __lt__(self, object):</strong><br/>        if self.sort_num:<br/>            return self.number &lt; object.number<br/>        return self.string &lt; object.string<br/><br/>    def __repr__(self):<br/>        return f"{self.string}:{self.number}"<br/><br/></pre>
<p>The <kbd>__repr__</kbd> method makes it easy to see the two values when we print a list. The <kbd>__lt__</kbd> method's implementation compares the object to another instance of the same class (or any duck-typed object that has <kbd>string</kbd>, <kbd>number</kbd>, and <kbd>sort_num</kbd> attributes; it will fail if those attributes are missing). The following output illustrates this class in action when it comes to sorting:</p>
<pre><strong>&gt;&gt;&gt; a = WeirdSortee('a', 4, True)</strong>
<strong>&gt;&gt;&gt; b = WeirdSortee('b', 3, True)</strong>
<strong>&gt;&gt;&gt; c = WeirdSortee('c', 2, True)</strong>
<strong>&gt;&gt;&gt; d = WeirdSortee('d', 1, True)</strong>
<strong>&gt;&gt;&gt; l = [a,b,c,d]</strong>
<strong>&gt;&gt;&gt; l</strong>
<strong>[a:4, b:3, c:2, d:1]</strong>
<strong>&gt;&gt;&gt; l.sort()</strong>
<strong>&gt;&gt;&gt; l</strong>
<strong>[d:1, c:2, b:3, a:4]</strong>
<strong>&gt;&gt;&gt; for i in l:</strong>
<strong>...     i.sort_num = False</strong>
<strong>...</strong>
<strong>&gt;&gt;&gt; l.sort()</strong>
<strong>&gt;&gt;&gt; l</strong>
<strong>[a:4, b:3, c:2, d:1]</strong>  </pre>
<p>The first time we call <kbd>sort</kbd>, it sorts by numbers because <kbd>sort_num</kbd> is <kbd>True</kbd> on all the objects being compared. The second time, it sorts by letters. The <kbd>__lt__</kbd> method is the only one we need to implement to enable sorting. Technically, however, if it is implemented, the class should normally also implement the similar <kbd>__gt__</kbd>, <kbd>__eq__</kbd>, <kbd>__ne__</kbd>, <kbd>__ge__</kbd>, and <kbd>__le__</kbd> methods so that all of the <kbd>&lt;</kbd>, <kbd>&gt;</kbd>, <kbd>==</kbd>, <kbd>!=</kbd>, <kbd>&gt;=</kbd>, and <kbd>&lt;=</kbd> operators also work properly. You can get this for free by implementing <kbd>__lt__</kbd> and <kbd>__eq__</kbd>, and then applying the <kbd>@total_ordering</kbd> class decorator to supply the rest:</p>
<pre>from functools import total_ordering 
 
<strong>@total_ordering</strong> 
class WeirdSortee: 
    def __init__(self, string, number, sort_num): 
        self.string = string 
        self.number = number 
        self.sort_num = sort_num 
 
<strong>    def __lt__(self, object):</strong> 
        if self.sort_num: 
            return self.number &lt; object.number 
        return self.string &lt; object.string 
 
    def __repr__(self): 
        return f"{self.string}:{self.number}"
 
<strong> def __eq__(self, object):</strong> 
        return all(( 
            self.string == object.string, 
            self.number == object.number, 
            self.sort_num == object.number 
        )) </pre>
<p>This is useful if we want to be able to use operators on our objects. However, if all we want to do is customize our sort orders, even this is overkill. For such a use case, the <kbd>sort</kbd> method can take an optional <kbd>key</kbd> argument. This argument is a function that can translate each object in a list into an object that can somehow be compared. For example, we can use <kbd>str.lower</kbd> as the key argument to perform a case-insensitive sort on a list of <span>strings, as can be seen in the following:</span></p>
<pre><strong>&gt;&gt;&gt; l = ["hello", "HELP", "Helo"]</strong>
<strong>&gt;&gt;&gt; l.sort()</strong>
<strong>&gt;&gt;&gt; l</strong>
<strong>['HELP', 'Helo', 'hello']</strong>
<strong>&gt;&gt;&gt; l.sort(key=str.lower)</strong>
<strong>&gt;&gt;&gt; l</strong>
<strong>['hello', 'Helo', 'HELP']</strong>  </pre>
<p>Remember, even though <kbd>lower</kbd> is a method on string objects, it is also a function that can accept a single argument, <kbd>self</kbd>. In other words, <kbd>str.lower(item)</kbd> is equivalent to <kbd>item.lower()</kbd>. When we pass this function as a key, it performs the comparison on lowercase values instead of doing the default case-sensitive comparison.</p>
<p>There are a few sort key operations that are so common that the Python team has supplied them so you don't have to write them yourself. For example, it is common to sort a list of tuples by something other than the first item in the list. The <kbd>operator.itemgetter</kbd> method can be used as a key to do this:</p>
<pre><strong>&gt;&gt;&gt; from operator import itemgetter</strong>
<strong>&gt;&gt;&gt; l = [('h', 4), ('n', 6), ('o', 5), ('p', 1), ('t', 3), ('y', 2)]</strong>
<strong>&gt;&gt;&gt; l.sort(key=itemgetter(1))</strong>
<strong>&gt;&gt;&gt; l</strong>
<strong>[('p', 1), ('y', 2), ('t', 3), ('h', 4), ('o', 5), ('n', 6)]</strong>  </pre>
<p>The <kbd>itemgetter</kbd> function is the most commonly used one (it works if objects are dictionaries, too), but you will sometimes find use for <kbd>attrgetter</kbd> and <kbd>methodcaller</kbd>, which return attributes on an object and the results of method calls on objects for the same purpose. Refer to the <kbd>operator</kbd> module documentation for more information.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Sets</h1>
                </header>
            
            <article>
                
<p>Lists are extremely versatile tools that suit many container object applications. But they are not useful when we want to ensure that objects in list are unique. For example, a song library may contain many songs by the same artist. If we want to sort through the library and create a list of all the artists, we would have to check the list to see whether we've added the artist already, before we add them again.</p>
<p>This is where sets come in. Sets come from mathematics, where they represent an unordered group of (usually) unique numbers. We can add a number to a set five times, but it will show up in the set only once.</p>
<p>In Python, sets can hold any hashable object, not just numbers. Hashable objects are the same objects that can be used as keys in dictionaries; so again, lists and dictionaries are out. Like mathematical sets, they can store only one copy of each object. So if we're trying to create a list of song artists, we can create a set of string names and simply add them to the set. This example starts with a list of (song, artist) tuples and creates a set of the artists:</p>
<pre>song_library = [<br/>    ("Phantom Of The Opera", "Sarah Brightman"),<br/>    ("Knocking On Heaven's Door", "Guns N' Roses"),<br/>    ("Captain Nemo", "Sarah Brightman"),<br/>    ("Patterns In The Ivy", "Opeth"),<br/>    ("November Rain", "Guns N' Roses"),<br/>    ("Beautiful", "Sarah Brightman"),<br/>    ("Mal's Song", "Vixy and Tony"),<br/>]<br/><br/>artists = set()<br/>for song, artist in song_library:<br/>    artists.add(artist)<br/><br/>print(artists)</pre>
<p>There is no built-in syntax for an empty set as there is for lists and dictionaries; we create a set using the <kbd>set()</kbd> constructor. However, we can use the curly braces (borrowed from dictionary syntax) to create a set, so long as the set contains values. If we use colons to separate pairs of values, it's a dictionary, as in <kbd>{'key': 'value', 'key2': 'value2'}</kbd>. If we just separate values with commas, it's a set, as in <kbd>{'value', 'value2'}</kbd>.</p>
<p>Items can be added individually to the set using its <kbd>add</kbd> method. If we run this script, we see that the set works as advertised:</p>
<pre><strong>{'Sarah Brightman', "Guns N' Roses", 'Vixy and Tony', 'Opeth'}</strong>  </pre>
<p>If you're paying attention to the output, you'll notice that the items are not printed in the order they were added to the sets. Sets are inherently unordered due to a hash-based data structure for efficiency. Because of this lack of ordering, sets cannot have items looked up by index. The primary purpose of a set is to divide the world into two groups: <em>things that are in the set</em>, and <em>things that are not in the set</em>. It is easy to check whether an item is in a set or to loop over the items in a set, but if we want to sort or order them, we have to convert the set to a list. This output shows all three of these activities:</p>
<pre><strong>&gt;&gt;&gt; "Opeth" in artists</strong>
<strong>True</strong>
<strong>&gt;&gt;&gt; for artist in artists:</strong>
<strong>...     print("{} plays good music".format(artist))</strong>
<strong>...</strong>
<strong>Sarah Brightman plays good music</strong>
<strong>Guns N' Roses plays good music</strong>
<strong>Vixy and Tony play good music</strong>
<strong>Opeth plays good music</strong>
<strong>&gt;&gt;&gt; alphabetical = list(artists)</strong>
<strong>&gt;&gt;&gt; alphabetical.sort()</strong>
<strong>&gt;&gt;&gt; alphabetical</strong>
<strong>["Guns N' Roses", 'Opeth', 'Sarah Brightman', 'Vixy and Tony']</strong>  </pre>
<p>While the primary <em>feature</em> of a set is uniqueness, that is not its primary <em>purpose</em>. Sets are most useful when two or more of them are used in combination. Most of the methods on the set type operate on other sets, allowing us to efficiently combine or compare the items in two or more sets. These methods have strange names, since they use the terminology used in mathematics. We'll start with three methods that return the same result, regardless of which is the calling set and which is the called set.</p>
<p>The <kbd>union</kbd> method is the most common and easiest to understand. It takes a second set as a parameter and returns a new set that contains all elements that are in <em>either</em> of the two sets; if an element is in both original sets, it will, of course, only show up once in the new set. Union is like a logical <kbd>or</kbd> operation. Indeed, the <kbd>|</kbd> operator can be used on two sets to perform the union operation, if you don't like calling methods.</p>
<p>Conversely, the intersection method accepts a second set and returns a new set that contains only those elements that are in <em>both</em> sets. It is like a logical <kbd>and</kbd> operation, and can also be referenced using the <kbd>&amp;</kbd> operator.</p>
<p>Finally, the <kbd>symmetric_difference</kbd> method tells us what's left; it is the set of objects that are in one set or the other, but not both. The following example illustrates these methods by comparing some artists preferred by two different people:</p>
<pre>first_artists = {<br/>    "Sarah Brightman",<br/>    "Guns N' Roses",<br/>    "Opeth",<br/>    "Vixy and Tony",<br/>}<br/><br/>second_artists = {"Nickelback", "Guns N' Roses", "Savage Garden"}<br/><br/>print("All: {}".format(first_artists.union(second_artists)))<br/>print("Both: {}".format(second_artists.intersection(first_artists)))<br/>print(<br/>    "Either but not both: {}".format(<br/>        first_artists.symmetric_difference(second_artists)<br/>    )<br/>)<br/><br/></pre>
<p>If we run this code, we see that these three methods do what the print statements suggest they will do:</p>
<pre><strong>All: {'Sarah Brightman', "Guns N' Roses", 'Vixy and Tony',</strong>
<strong>'Savage Garden', 'Opeth', 'Nickelback'}</strong>
<strong>Both: {"Guns N' Roses"}</strong>
<strong>Either but not both: {'Savage Garden', 'Opeth', 'Nickelback',</strong>
<strong>'Sarah Brightman', 'Vixy and Tony'}</strong>  </pre>
<p>These methods all return the same result, regardless of which set calls the other. We can say <kbd>first_artists.union(second_artists)</kbd> or <kbd>second_artists.union(first_artists)</kbd> and get the same result. There are also methods that return different results depending on who is the caller and who is the argument.</p>
<p>These methods include <kbd>issubset</kbd> and <kbd>issuperset</kbd>, which are the inverse of each other. Both return a <kbd>bool</kbd>. The <kbd>issubset</kbd> method returns <kbd>True</kbd>, if all of the items in the calling set are also in the set passed as an argument. The <kbd>issuperset</kbd> method returns <kbd>True</kbd> if all of the items in the argument are also in the calling set. Thus, <kbd>s.issubset(t)</kbd> and <kbd>t.issuperset(s)</kbd> are identical. They will both return <kbd>True</kbd> if <kbd>t</kbd> contains all the elements in <kbd>s</kbd>.</p>
<p>Finally, the <kbd>difference</kbd> method returns all the elements that are in the calling set, but not in the set passed as an argument; this is like half a <kbd>symmetric_difference</kbd>. The <kbd>difference</kbd> method can also be represented by the <kbd>-</kbd> operator. The following code illustrates these methods in action:</p>
<pre>first_artists = {"Sarah Brightman", "Guns N' Roses", 
        "Opeth", "Vixy and Tony"} 
 
bands = {"Guns N' Roses", "Opeth"} 
 
print("first_artists is to bands:") 
print("issuperset: {}".format(first_artists.issuperset(bands))) 
print("issubset: {}".format(first_artists.issubset(bands))) 
print("difference: {}".format(first_artists.difference(bands))) 
print("*"*20) 
print("bands is to first_artists:") 
print("issuperset: {}".format(bands.issuperset(first_artists))) 
print("issubset: {}".format(bands.issubset(first_artists))) 
print("difference: {}".format(bands.difference(first_artists))) </pre>
<p>This code simply prints out the response of each method when called from one set on the other. Running it gives us the following output:</p>
<pre><strong>first_artists is to bands:</strong>
<strong>issuperset: True</strong>
<strong>issubset: False</strong>
<strong>difference: {'Sarah Brightman', 'Vixy and Tony'}</strong>
<strong>********************</strong>
<strong>bands is to first_artists:</strong>
<strong>issuperset: False</strong>
<strong>issubset: True</strong>
<strong>difference: set()</strong>  </pre>
<p>The <kbd>difference</kbd> method, in the second case, returns an empty set, since there are no items in <kbd>bands</kbd> that are not in <kbd>first_artists</kbd>.</p>
<p>The <kbd>union</kbd>, <kbd>intersection</kbd>, and <kbd>difference</kbd> methods can all take multiple sets as arguments; they will return, as we might expect, the set that is created when the operation is called on all the parameters.</p>
<p>So, the methods on sets clearly suggest that sets are meant to operate on other sets, and that they are not just containers. If we have data coming in from two different sources and need to quickly combine them in some way, so as to determine where the data overlaps or is different, we can use set operations to efficiently compare them. Or, if we have data incoming that may contain duplicates of data that has already been processed, we can use sets to compare the two and process only the new data.</p>
<p>Finally, it is valuable to know that sets are much more efficient than lists when checking for membership using the <kbd>in</kbd> keyword. If you use the <kbd>value in container</kbd> <span>syntax </span>on a set or a list, it will return <kbd>True</kbd> if one of the elements in <kbd>container</kbd> is equal to <kbd>value</kbd>, and <kbd>False</kbd> otherwise. However, in a list, it will look at every object in the container until it finds the value, whereas in a set, it simply hashes the value and checks for membership. This means that a set will find the value in the same amount of time no matter how big the container is, but a list will take longer and longer to search for a value as the list contains more and more values.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Extending built-in functions</h1>
                </header>
            
            <article>
                
<p>We discussed briefly in <a href="ba7b3eb7-17cc-4f1c-bb74-fb7d5ee7d517.xhtml"><span class="ChapterrefPACKT">Chapter 3</span></a>, <em>When Objects Are Alike</em>, how built-in data types can be extended using inheritance. Now, we'll go into more detail as to when we would want to do that.</p>
<p>When we have a built-in container object that we want to add functionality to, we have two options. We can either create a new object, which holds that container as an attribute (composition), or we can subclass the built-in object and add or adapt methods on it to do what we want (inheritance).</p>
<p>Composition is usually the best alternative if all we want to do is use the container to store some objects using that container's features. That way, it's easy to pass that data structure into other methods and they will know how to interact with it. But we need to use inheritance if we want to change the way the container actually works. For example, if we want to ensure every item in a <kbd>list</kbd> is a string with exactly five characters, we need to extend <kbd>list</kbd> and override the <kbd>append()</kbd> method to raise an exception for invalid input. We'd also minimally have to override <kbd>__setitem__(self,</kbd><kbd>index,</kbd><kbd>value)</kbd>, a special method on lists that is called whenever we use the <kbd>x[index]</kbd><kbd>=</kbd><kbd>"value"</kbd> syntax, and the <kbd>extend()</kbd> method.</p>
<p>Yes, lists are objects. All that special non-object-oriented looking syntax we've been looking at for accessing lists or dictionary keys, looping over containers, and similar tasks, is actually <kbd>syntactic sugar</kbd> that maps to an object-oriented paradigm underneath. We might ask the Python designers why they did this. Isn't object-oriented programming <em>always</em> better? That question is easy to answer. In the following hypothetical examples, which is easier to read, as a programmer? Which requires less typing?:</p>
<pre>c = a + b 
<strong>c = a.add(b)</strong> 
 
l[0] = 5 
<strong>l.setitem(0, 5)</strong> 
d[key] = value 
<strong>d.setitem(key, value)</strong> 
 
for x in alist: 
    #do something with x 
<strong>it = alist.iterator() 
while it.has_next(): 
    x = it.next() 
    #do something with x</strong> </pre>
<p>The highlighted sections show what object-oriented code might look like (in practice, these methods actually exist as special double-underscore methods on associated objects). Python programmers agree that the non-object-oriented syntax is easier both to read and to write. Yet all of the preceding Python syntaxes map to object-oriented methods underneath the hood. These methods have special names (with double-underscores before and after) to remind us that there is a better syntax out there. However, it gives us the means to override these behaviors. For example, we can make a special integer that always returns <kbd>0</kbd> when we add two of them <span>together, demonstrated as follows:</span></p>
<pre>class SillyInt(int): 
    def __add__(self, num): 
        return 0 </pre>
<p>This is an extremely bizarre thing to do, granted, but it perfectly illustrates these object-oriented principles in action:</p>
<pre><strong>&gt;&gt;&gt; a = SillyInt(1)</strong>
<strong>&gt;&gt;&gt; b = SillyInt(2)</strong>
<strong>&gt;&gt;&gt; a + b</strong>
<strong>0</strong>  </pre>
<p>The awesome thing about the <kbd>__add__</kbd> method is that we can add it to any class we write, and if we use the <kbd>+</kbd> operator on instances of that class, it will be called. This is how string, tuple, and list concatenation works, for example.</p>
<p>This is true of all the special methods. If we want to use <kbd>x</kbd><kbd>in</kbd><kbd>myobj</kbd> syntax for a custom-defined object, we can implement <kbd>__contains__</kbd>. If we want to use the <kbd>myobj[i]</kbd><kbd>=</kbd><kbd>value</kbd> syntax, we supply a <kbd>__setitem__</kbd> method, and if we want to use <kbd>something</kbd><kbd>=</kbd><kbd>myobj[i]</kbd>, we implement <kbd>__getitem__</kbd>.</p>
<p>There are 33 of these special methods in the <kbd>list</kbd> class. We can use the <kbd>dir</kbd> function to see all of them, as follows:</p>
<pre><strong>&gt;&gt;&gt; dir(list)</strong>

<strong>['__add__', '__class__', '__contains__', '__delattr__','__delitem__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__gt__', '__hash__', '__iadd__', '__imul__', '__init__', '__iter__', '__le__', '__len__', '__lt__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__reversed__', '__rmul__', '__setattr__', '__setitem__', '__sizeof__', '__str__', '__subclasshook__', 'append', 'count', 'extend', 'index', 'insert', 'pop', 'remove', 'reverse', 'sort'</strong>  </pre>
<p>Furthermore, if we desire additional information on how any of these methods work, we can use the <kbd>help</kbd> function:</p>
<pre><strong>&gt;&gt;&gt; help(list.__add__)</strong>
<strong>Help on wrapper_descriptor:</strong>
   
<strong>__add__(self, value, /)</strong>
<strong>    Return self+value.</strong>  </pre>
<p>The <kbd>+</kbd> operator on lists concatenates two lists. We don't have room to discuss all of the available special functions in this book, but you are now able to explore all this functionality with <kbd>dir</kbd> and <kbd>help</kbd>. The official online Python reference (<a href="https://docs.python.org/3/"><span class="URLPACKT">https://docs.python.org/3/</span></a>) has plenty of useful information as well. Focus especially on the abstract base classes discussed in the <kbd>collections</kbd> module.</p>
<p>So, to get back to the earlier point about when we would want to use composition versus inheritance: if we need to somehow change any of the methods on the class, including the special methods, we definitely need to use inheritance. If we used composition, we could write methods that perform the validation or alterations and ask the caller to use those methods, but there is nothing stopping them from accessing the property directly. They could insert an item into our list that does not have five characters, and that might confuse other methods in the list.</p>
<p>Often, the need to extend a built-in data type is an indication that we're using the wrong sort of data type. It is not always the case, but if we are looking to extend a built-in, we should carefully consider whether or not a different data structure would be more suitable.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Case study</h1>
                </header>
            
            <article>
                
<p>To tie everything together, we'll be writing a simple link collector, which will visit a website and collect every link on every page it finds in that site. Before we start, though, we'll need some test data to work with. Simply write some HTML files to work with that contain links to each other and to other sites on the internet, something like this:</p>
<pre>&lt;html&gt; 
    &lt;body&gt; 
        &lt;a href="contact.html"&gt;Contact us&lt;/a&gt; 
        &lt;a href="blog.html"&gt;Blog&lt;/a&gt; 
        &lt;a href="esme.html"&gt;My Dog&lt;/a&gt; 
        &lt;a href="/hobbies.html"&gt;Some hobbies&lt;/a&gt; 
        &lt;a href="/contact.html"&gt;Contact AGAIN&lt;/a&gt; 
        &lt;a href="http://www.archlinux.org/"&gt;Favorite OS&lt;/a&gt; 
    &lt;/body&gt; 
&lt;/html&gt; </pre>
<p>Name one of the files <kbd>index.html</kbd> so it shows up first when pages are served. Make sure the other files exist, and keep things complicated so that there is lots of linking between them. The examples for this chapter include a directory called <kbd>case_study_serve</kbd> (one of the lamest personal websites in existence!) if you would rather not set them up yourself.</p>
<p>Now, start a simple web server by entering the directory containing all these files and run the following command:</p>
<pre>$<strong>python3 -m http.server</strong>  </pre>
<p>This will start a server running on port 8000; you can see the pages you made by visiting <kbd>http://localhost:8000/</kbd> in your web browser.</p>
<p>The goal is to pass our collector the base URL for the site (in this case: <kbd>http://localhost:8000/</kbd>), and have it create a list containing every unique link on the site. We'll need to take into account three types of URLs (links to external sites, which start with <kbd>http://</kbd>, absolute internal links, which start with a <kbd>/</kbd> character, and relative links, for everything else). We also need to be aware that pages may link to each other in a loop; we need to be sure we don't process the same page multiple times, or it may never end. With all this uniqueness going on, it sounds like we're going to need some sets.</p>
<p>Before we get into that, let's start with the basics. Here's the code to connect to a page and parse all the links in that page:</p>
<pre>from urllib.request import urlopen 
from urllib.parse import urlparse 
import re 
import sys 
LINK_REGEX = re.compile( 
        "&lt;a [^&gt;]*href=['\"]([^'\"]+)['\"][^&gt;]*&gt;") 
 
class LinkCollector: 
    def __init__(self, url): 
        self.url = "" + urlparse(url).netloc 
 
    def collect_links(self, path="/"): 
        full_url = self.url + path 
        page = str(urlopen(full_url).read()) 
        links = LINK_REGEX.findall(page) 
        print(links) 
 
if __name__ == "__main__": 
    LinkCollector(sys.argv[1]).collect_links() </pre>
<p>This is a short piece of code, considering what it's doing. It connects to the server in the argument passed on the command line, downloads the page, and extracts all the links on that page. The <kbd>__init__</kbd> method uses the <kbd>urlparse</kbd> function to extract just the hostname from the URL; so even if we pass in <kbd>http://localhost:8000/some/page.html</kbd>, it will still operate on the top level of the <kbd>http://localhost:8000/</kbd> host. This makes sense, because we want to collect all the links on the site, although it assumes every page is connected to the index by some sequence of links.</p>
<p>The <kbd>collect_links</kbd> method connects to and downloads the specified page from the server, and uses a regular expression to find all the links on the page. Regular expressions are an extremely powerful string processing tool. Unfortunately, they have a steep learning curve; if you haven't used them before, I strongly recommend studying any of the many entire books or websites on the topic. If you don't think they're worth knowing about, try writing the preceding code without them and you'll change your mind.</p>
<p>The example also stops in the middle of the <kbd>collect_links</kbd> method to print the value of links. This is a common way to test a program as we're writing it: stop and output the value to ensure it is the value we expect. Here's what it outputs for our example:</p>
<pre>['contact.html', 'blog.html', 'esme.html', '/hobbies.html', 
'/contact.html', 'http://www.archlinux.org/'] </pre>
<p>So, now we have a collection of all the links in the first page. What can we do with it? We can't just pop the links into a set to remove duplicates, because links may be relative or absolute. For example, <kbd>contact.html</kbd> and <kbd>/contact.html</kbd> point to the same page. So the first thing we should do is normalize all the links to their full URL, including the hostname and relative path. We can do this by adding a <kbd>normalize_url</kbd> method to our object:</p>
<pre>    def normalize_url(self, path, link): 
        if link.startswith("http://"): 
            return link 
        elif link.startswith("/"): 
            return self.url + link 
        else: 
            return self.url + path.rpartition( 
                '/')[0] + '/' + link </pre>
<p>This method converts each URL to a complete address that includes a protocol and a hostname. Now, the two contact pages have the same value and we can store them in a set. We'll have to modify <kbd>__init__</kbd> to create the set, and <kbd>collect_links</kbd> to put all the links into it.</p>
<p>Then, we'll have to visit all the non-external links and collect them too. But wait a minute; if we do this, how do we keep from revisiting a link when we encounter the same page twice? It looks like we're actually going to need two sets: a set of collected links, and a set of visited links. This suggests that we were wise to choose a set to represent our data; we know that sets are most useful when we're manipulating more than one of them. Let's set these <span>up as follows:</span></p>
<pre>class LinkCollector: 
    def __init__(self, url): 
        self.url = "http://+" + urlparse(url).netloc 
        self.collected_links = set() 
        self.visited_links = set() 
 
    def collect_links(self, path="/"): 
        full_url = self.url + path 
        self.visited_links.add(full_url) 
        page = str(urlopen(full_url).read()) 
        links = LINK_REGEX.findall(page) 
        links = {self.normalize_url(path, link 
            ) for link in links} 
        self.collected_links = links.union( 
                self.collected_links) 
        unvisited_links = links.difference( 
                self.visited_links) 
        print(links, self.visited_links, 
                self.collected_links, unvisited_links) </pre>
<p>The line that creates the normalized list of links uses a <kbd>set</kbd> comprehension (we'll be covering these in detail in the next chapter). Once again, the method stops to print out the current values, so we can verify that we don't have our sets confused, and that <kbd>difference</kbd> really was the method we wanted to call to collect <kbd>unvisited_links</kbd>. We can then add a few lines of code that loop over all the unvisited links and add them to the collection as <span>well, demonstrated as follows:</span></p>
<pre>        for link in unvisited_links: 
            if link.startswith(self.url): 
                self.collect_links(urlparse(link).path) </pre>
<p>The <kbd>if</kbd> statement ensures that we are only collecting links from the one website; we don't want to go off and collect all the links from all the pages on the internet (unless we're Google or Internet Archive!). If we modify the main code at the bottom of the program to output the collected links, we can see it seems to have collected them <span>all, as can be seen in the following block of code:</span></p>
<pre>if __name__ == "__main__": 
    collector = LinkCollector(sys.argv[1]) 
    collector.collect_links() 
    for link in collector.collected_links: 
        print(link) </pre>
<p>It displays all the links we've collected, and only once, even though many of the pages in my example linked to each other multiple times, as follows:</p>
<pre><strong>$ python3 link_collector.py http://localhost:8000</strong>
<strong>http://localhost:8000/</strong>
<strong>http://en.wikipedia.org/wiki/Cavalier_King_Charles_Spaniel</strong>
<strong>http://beluminousyoga.com</strong>
<strong>http://archlinux.me/dusty/</strong>
<strong>http://localhost:8000/blog.html</strong>
<strong>http://ccphillips.net/</strong>
<strong>http://localhost:8000/contact.html</strong>
<strong>http://localhost:8000/taichi.html</strong>
<strong>http://www.archlinux.org/</strong>
<strong>http://localhost:8000/esme.html</strong>
<strong>http://localhost:8000/hobbies.html</strong>  </pre>
<p>Even though it collected links <em>to</em> external pages, it didn't go off collecting links <em>from</em> any of the external pages we linked to. This is a great little program if we want to collect all the links on a site. But it doesn't give me all the information I might need to build a site map; it tells me which pages I have, but it doesn't tell me which pages link to other pages. If we want to do that instead, we're going to have to make some modifications.</p>
<p>The first thing we should do is look at our data structures. The set of collected links doesn't work any more; we want to know which links were linked to from which pages. We can turn that set into a dictionary of sets for each page we visit. The dictionary keys will represent the exact same data that is currently in the set. The values will be sets of all the links on that page. The changes are as follows:</p>
<pre>from urllib.request import urlopen 
from urllib.parse import urlparse 
import re 
import sys 
LINK_REGEX = re.compile( 
        "&lt;a [^&gt;]*href=['\"]([^'\"]+)['\"][^&gt;]*&gt;") 
 
class LinkCollector: 
    def __init__(self, url): 
        self.url = "http://%s" % urlparse(url).netloc 
        self.collected_links = {} 
        self.visited_links = set() 
 
    def collect_links(self, path="/"): 
        full_url = self.url + path 
        self.visited_links.add(full_url) 
        page = str(urlopen(full_url).read()) 
        links = LINK_REGEX.findall(page) 
        links = {self.normalize_url(path, link 
            ) for link in links} 
        self.collected_links[full_url] = links 
        for link in links: 
            self.collected_links.setdefault(link, set()) 
        unvisited_links = links.difference( 
                self.visited_links) 
        for link in unvisited_links: 
            if link.startswith(self.url): 
                self.collect_links(urlparse(link).path) 
 
    def normalize_url(self, path, link): 
        if link.startswith("http://"): 
            return link 
        elif link.startswith("/"): 
            return self.url + link 
        else: 
            return self.url + path.rpartition('/' 
                    )[0] + '/' + link 
if __name__ == "__main__": 
    collector = LinkCollector(sys.argv[1]) 
    collector.collect_links() 
    for link, item in collector.collected_links.items(): 
        print("{}: {}".format(link, item)) </pre>
<p>There are surprisingly few changes; the line that originally created a union of two sets has been replaced with three lines that update the dictionary. The first of these simply tells the dictionary what the collected links for that page are. The second creates an empty set for any items in the dictionary that have not already been added to the dictionary using <kbd>setdefault</kbd>. The result is a dictionary that contains all the links as its keys, mapped to sets of links for all the internal links, and empty sets for the external links.</p>
<p>Finally, instead of recursively calling <kbd>collect_links</kbd>, we can use a queue to store the links that haven't been processed yet. This implementation won't support concurrency, but this would be a good first step to creating a multithreaded version that makes multiple requests in parallel to save time:</p>
<pre>from urllib.request import urlopen 
from urllib.parse import urlparse 
import re 
import sys 
from queue import Queue 
LINK_REGEX = re.compile("&lt;a [^&gt;]*href=['\"]([^'\"]+)['\"][^&gt;]*&gt;") 
 
 
class LinkCollector: 
    def __init__(self, url): 
        self.url = "http://%s" % urlparse(url).netloc 
        self.collected_links = {} 
        self.visited_links = set() 
 
    def collect_links(self): 
        queue = Queue() 
        queue.put(self.url) 
        while not queue.empty(): 
            url = queue.get().rstrip('/') 
            self.visited_links.add(url) 
            page = str(urlopen(url).read()) 
            links = LINK_REGEX.findall(page) 
            links = { 
                self.normalize_url(urlparse(url).path, link) 
                for link in links 
            } 
            self.collected_links[url] = links 
            for link in links: 
                self.collected_links.setdefault(link, set()) 
            unvisited_links = links.difference(self.visited_links) 
            for link in unvisited_links: 
                if link.startswith(self.url): 
                    queue.put(link) 
 
    def normalize_url(self, path, link): 
        if link.startswith("http://"): 
            return link.rstrip('/') 
        elif link.startswith("/"): 
            return self.url + link.rstrip('/') 
        else: 
            return self.url + path.rpartition('/')[0] + '/' + link.rstrip('/') 
 
if __name__ == "__main__": 
    collector = LinkCollector(sys.argv[1]) 
    collector.collect_links() 
    for link, item in collector.collected_links.items(): 
        print("%s: %s" % (link, item)) </pre>
<p>I had to manually strip any trailing forward slashes in the <kbd>normalize_url</kbd> method to remove duplicates in this version of the code.</p>
<p>Because the end result is an unsorted dictionary, there is no restriction on which order the links should be processed in. Therefore, we could just as easily have used a <kbd>LifoQueue</kbd> instead of a <kbd>Queue</kbd> here. A priority queue probably wouldn't make a lot of sense, since there is no obvious priority to attach to a link in this case.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Exercises</h1>
                </header>
            
            <article>
                
<p>The best way to learn how to choose the correct data structure is to do it wrong a few times (intentionally or accidentally!). Take some code you've recently written, or write some new code that uses a list. Try rewriting it using some different data structures. Which ones make more sense? Which ones don't? Which have the most elegant code?</p>
<p>Try this with a few different pairs of data structures. You can look at examples you've done for previous chapter exercises. Are there objects with methods where you could have used dataclasses, <kbd>namedtuple</kbd>, or <kbd>dict</kbd> instead? Attempt both and see. Are there dictionaries that could have been sets because you don't really access the values? Do you have lists that check for duplicates? Would a set suffice? Or maybe several sets? Would one of the queue implementations be more efficient? Is it useful to restrict the API to the top of a stack rather than allowing random access to the list?</p>
<p>If you want some specific examples to work with, try adapting the link collector to also save the title used for each link. Perhaps you can generate a site map in HTML that lists all the pages on the site, and that contains a list of links to other pages, named with the same link titles.</p>
<p>Have you written any container objects recently that you could improve by inheriting a built-in and overriding some of the <em>special</em> double-underscore methods? You may have to do some research (using <kbd>dir</kbd> and <kbd>help</kbd>, or the Python library reference) to find out which methods need overriding. Are you sure inheritance is the correct tool to apply; could a composition-based solution be more effective? Try both (if it's possible) before you decide. Try to find different situations where each method is better than the other.</p>
<p>If you were familiar with the various Python data structures and their uses before you started this chapter, you may have been bored. But if that is the case, there's a good chance you use data structures too much! Look at some of your old code and rewrite it to use more self-made classes. Carefully consider the alternatives and try them all out; which one makes for the most readable and maintainable system?</p>
<p>Always critically evaluate your code and design decisions. Make a habit of reviewing old code and take note if your understanding of <em>good design</em> has changed since you've written it. Software design has a large aesthetic component, and like artists with oil on canvas, we all have to find the style that suits us best.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>We've covered several built-in data structures and attempted to understand how to choose one for specific applications. Sometimes, the best thing we can do is create a new class of objects, but often, one of the built-ins provides exactly what we need. When it doesn't, we can always use inheritance or composition to adapt them to our use cases. We can even override special methods to completely change the behavior of built-in syntaxes.</p>
<p>In the next chapter, we'll discuss how to integrate the object-oriented and not-so-object-oriented aspects of Python. Along the way, we'll discover that it's more object-oriented than it looks at first sight!</p>


            </article>

            
        </section>
    </body></html>