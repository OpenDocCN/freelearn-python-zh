- en: Understanding and Customizing the Browsable API Feature
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will work with one of the most interesting and powerful
    features included in the Django REST framework: the browsable API. This feature
    makes it easy for us to interact with our RESTful Web Services through any web
    browser. We will gain an understanding of:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the possibility of rendering text/HTML content
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a web browser to work with our web service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making HTTP GET requests with the browsable API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making HTTP POST requests with the browsable API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making HTTP PUT requests with the browsable API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making HTTP DELETE requests with the browsable API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making HTTP OPTIONS requests with the browsable API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the possibility of rendering text/HTML content
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 4](dj-rst-websvc_ch14.html), *Using Generalized Behavior from the
    APIView Class*, we made many changes to make it possible for the simple RESTful
    Web Service to work with a content negotiation class and provide many content
    renderers. We used the default configuration for the Django REST framework that
    includes a renderer that produces `text/html` content.
  prefs: []
  type: TYPE_NORMAL
- en: The `rest_framework.response.BrowsableAPIRenderer` class is responsible for
    rendering the `text/html` content. This class makes it possible for us to browse
    the API. The Django REST framework includes a feature that generates an interactive
    and human-friendly HTML output for the different resources when the request specifies
    `text/html` as the value for the `Content-Type` key in the request header. This
    feature is known as the browsable API because it enables us to use a web browser
    to navigate through the API and easily make different types of HTTP requests.
  prefs: []
  type: TYPE_NORMAL
- en: The browsable API feature is extremely useful when we have to test the RESTful
    Web Services that perform CRUD operations on a database, such as the one we have
    been developing in [Chapter 4](https://cdp.packtpub.com/django_restful_web_services__/wp-admin/post.php?post=79&action=edit#post_61), *Using
    Generalized Behavior from the APIView Class*.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will compose and send HTTP requests that will make the RESTful Web Service
    user the `BrowsableAPIRenderer` class to provide `text/html` content in the response.
    This way, we will understand how the browsable API works before we jump into the
    web browser and we start using and customizing this feature. In case you stopped
    Django's development server, you will have to start it again as we learned in
    [Chapter 3](dj-rst-websvc_ch13.html), *Creating API Views*, in the section *Launching
    Django's development server*, to start running the Django development server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to retrieve all the toys with the `Accept` request
    header key set to `text/html`. Remember that the virtual environment we created
    in the previous chapters must be activated in order to run the next `http` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the equivalent `curl` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous commands will compose and send the following HTTP request: `GET
    http://localhost:8000/toys/`. These commands specify the `text/html` value for
    the `Accept` key in the request header. This way, the HTTP request indicates that
    it accepts a response of `text/html`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In both cases, we specified the `-v` option that provides a verbose output
    and prints the details of the request that has been made. For example, the following
    are the first lines of the output generated by the `http` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The second line prints the value for the `Accept` key included in the request
    header, `text/`html. The header response for the request will include the following
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous commands will compose and send the following HTTP request: `GET
    http://localhost:8000/toys/`. The request will end up running the `views.toy_list`
    function, that is, the `toy_list` function declared within the `toys/views.py`
    file. The content negotiation class selected the `BrowsableAPIRenderer` class
    to provide `text/html` content in the response. The following lines show the first
    lines of the output for the `http` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/502ddeaf-edd3-4c70-b495-2adcd6b4da36.png)'
  prefs: []
  type: TYPE_IMG
- en: We can easily detect from the previous output that the Django REST framework
    provides an HTML web page as a response to our previous requests. If we enter
    any URL for a resource collection or resource in any web browser, the browser
    will perform an HTTP GET request that requires an HTML response, that is, the
    `Accept` request header key will be set to `text/html`. The web service built
    with the Django REST framework will provide an HTML response and the browser will
    render the web page.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, the `BrowsableAPIRenderer` class uses the Bootstrap popular frontend
    component library. You can read more about Bootstrap here: [http://getbootstrap.com](http://getbootstrap.com).
    The web page might include the following elements:'
  prefs: []
  type: TYPE_NORMAL
- en: Diverse buttons to perform other requests to the resource or resource collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A section that displays the resource or resource collection content in JSON
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Forms with fields that allow us to submit data for `POST`, `PUT`, and `PATCH`
    requests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Django REST framework uses templates and themes to render the pages for
    the browsable API. It is possible to customize many settings to tailor the output
    to our specific requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Using a web browser to work with our web service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's start browsing our RESTful Web Service. Open a web browser and enter `http://localhost:8000/toys/`.
    The browser will compose and send a `GET` request to `http://localhost:8000/toys/`
    with `text/html` as the desired content type and the returned HTML web page will
    be rendered.
  prefs: []
  type: TYPE_NORMAL
- en: 'Under the hood, the web service will compose and send an HTTP GET request to
    `http://localhost:8000/toys/` with `application/json` as the content type and
    the headers, and the JSON returned by this request will be rendered as part of
    the content of the web page. The following screenshot shows the rendered web page
    with the resource collection description, Toy List:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5f029d42-262c-425d-8c8a-f2de015d210c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When we work with the browsable API, Django uses the information about the
    allowed methods for a resource or resource collection to render the appropriate
    buttons to allow us to execute the related requests. In the previous screenshot,
    you will notice that there are two buttons on the right-hand side of the resource
    description (Toy List): OPTIONS and GET. We will use the different buttons to
    make additional requests to the RESTful Web Service.'
  prefs: []
  type: TYPE_NORMAL
- en: If you decide to browse the web service in a web browser that is being executed
    on another computer or device connected to the LAN, you will have to use the assigned
    IP address to the computer that is running Django's development server instead
    of `localhost`. For example, if Django's development server is running on a computer
    whose assigned IPv4 IP address is `192.168.2.125`, instead of `http://localhost:8000/toys/`,
    you should use `http://192.168.2.125:8000/toys/`. You can also use the hostname
    instead of the IPv4 address or an IPv6 address.
  prefs: []
  type: TYPE_NORMAL
- en: One of the nicest features of the browsable API is that it makes it extremely
    easy to test a RESTful Web Service from a mobile device.
  prefs: []
  type: TYPE_NORMAL
- en: As a disclaimer, I must say that once you learn how to take advantage of the
    browsable API, you will never want to work with a framework that doesn't provide
    a feature like this one.
  prefs: []
  type: TYPE_NORMAL
- en: Making HTTP GET requests with the browsable API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We just made an HTTP GET request to retrieve the toys resource collection with
    the browsable API. Now, we will compose and send another HTTP GET request for
    an existing toy resource with the web browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the URL for an existing toy resource, such as `http://localhost:8000/toys/3`.
    Make sure you replace `3` with the `id` or primary key of an existing toy in the
    previously rendered Toy List. Django will compose and send a `GET` request to
    `http://localhost:8000/toys/3` and the rendered web page will display the results
    of its execution, that is, the headers and the JSON data for the toy resource.
    The following screenshot shows the rendered web page after entering the URL in
    a web browser with the resource description, Toy Detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a5c611fe-6153-4eb3-9cc5-e66c5e19f076.png)'
  prefs: []
  type: TYPE_IMG
- en: 'At the right-hand side of the resource description, the browsable API shows
    a GET drop-down button. This button allows us to make a `GET` request to `/toys/3`
    again. If we click or tap the down arrow, we can select the json option and the
    browsable API will display the raw JSON results of a `GET` request to `/toys/3`
    without the headers. In fact, the browser will go to `http://localhost:8000/toys/3?format=json`
    and the Django REST framework will display the raw JSON results because the value
    for the `format` query parameter is set to `json`. The following screenshot shows
    the results of making that request:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/42bd263a-d5c8-4854-8863-9f4a8067cdfd.png)'
  prefs: []
  type: TYPE_IMG
- en: Enter the URL for a non-existing toy resource, such as `http://localhost:8000/toys/250`.
    Make sure you replace `250` with the `id` or primary key of the toy that doesn't
    exist in the previously rendered Toy List. Django will compose and send a `GET`
    request to `http://localhost:8000/toys/250` and the rendered web page will display
    the results of its execution, that is, the header with the `HTTP 404 Not found`
    status code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the rendered web page after entering the URL
    in a web browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c85e7e03-cc44-4b83-a46c-212199d0343e.png)'
  prefs: []
  type: TYPE_IMG
- en: Making HTTP POST requests with the browsable API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we want to use the browsable API to compose and send an HTTP POST request
    to our RESTful Web Service to create a new toy. Go to the following URL in your
    web browser, `http://localhost:8000/toys/`. At the bottom of the rendered web
    page, the browsable API displays the following controls to allow us to compose
    and send a `POST` request to `/toys/`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Media type: This dropdown allows us to select the desired parser. The list
    will be generated based on the configured supported parsers in the Django REST
    framework for our web service.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Content: This text area allows us to enter the text for the body that will
    be sent with the POST request. The content must be compatible with the selected
    value for the media type dropdown.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'POST: This button will use the selected media type and the entered content
    to compose and send an HTTP POST request with the appropriate header key/value
    pairs and content.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following screenshot shows the previously explained controls at the bottom
    of the rendered web page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/52ab2175-6cf4-429a-80b7-5fcaf13e2a98.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We enabled all the default parsers provided by the Django REST framework for
    our RESTful Web Service, and therefore, the Media type drop-down will provide
    us with the following options:'
  prefs: []
  type: TYPE_NORMAL
- en: application/json
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: application/x-www-form-urlencoded
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: multipart/form-data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Select application/json in the Media type dropdown and enter the following
    JSON content in the Content text area:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Click or tap POST. The browsable API will compose and send an HTTP `POST` request
    to `/toys/` with the previously specified data as a JSON body, and we will see
    the results of the call in the web browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows a web browser displaying the HTTP status code
    `201 Created` in the response and the previously explained dropdown and text area
    with the POST button to allow us to continue composing and sending `POST` requests
    to `/toys/`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bcd09a3c-0c7e-4a85-81f9-d217c2e06758.png)'
  prefs: []
  type: TYPE_IMG
- en: In this case, we entered the JSON key/value pairs as we did when we composed
    and sent HTTP POST requests with command-line and GUI tools. However, we will
    learn to configure the browsable API to provide us with a form with fields to
    make it even easier to perform operations on our RESTful Web Service.
  prefs: []
  type: TYPE_NORMAL
- en: Making HTTP PUT requests with the browsable API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we want to use the browsable API to compose and send an HTTP PUT request
    to our RESTful Web Service to replace an existing toy with a new one. First, go
    to the URL for an existing toy resource, such as `http://localhost:8000/toys/7`.
    Make sure you replace `7` with the `id` or primary key of an existing toy in the
    previously rendered Toy List. The HTML web page that displays the results of an
    HTTP GET request to `/toys/7` plus additional details and controls will be rendered.
  prefs: []
  type: TYPE_NORMAL
- en: At the bottom of the rendered web page, the browsable API displays the controls
    to compose and send a `POST` request to `/toys/` followed by the controls to compose
    and send a `PUT` request to `/toys/7`. The controls for the `PUT` request are
    the same that we already analyzed for the POST request. The PUT button will use
    the selected media type and the entered content to compose and send an HTTP PUT
    request with the appropriate header key/value pairs and content.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the controls to compose and send an HTTP PUT
    request at the bottom of the rendered web page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5fad0786-566f-4b85-a486-2b922e6a893c.png)'
  prefs: []
  type: TYPE_IMG
- en: In this example, we took advantage of the features included in the Django REST
    framework to build the OPTIONS response that indicates which HTTP verbs are allowed
    for each resource and resource collection. Thus, the browsable API only offers
    us the possibility to compose and send a POST and PUT methods. The POST method
    is applied to the resource collection while the PUT method is applied to a single
    resource. The browsable API doesn't provide the controls to compose and send an
    HTTP PATCH method on a resource because the code hasn't specified that this verb
    is accepted as a resource.
  prefs: []
  type: TYPE_NORMAL
- en: 'Select application/json in the Media type dropdown and enter the following
    JSON content in the Content text area. Remember that the HTTP PUT method replaces
    an existing resource with a new one, and therefore, we must specify the values
    for all the fields and not just for the fields that we want to update:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Click or tap PUT. The browsable API will compose and send an HTTP `PUT` request
    to `/toys/7` with the previously specified data as a JSON body and we will see
    the results of the call in the web browser. The following screenshot shows a web
    browser displaying the HTTP status code `200 OK` in the response, and the controls
    to allow us to send a new PUT request, if necessary:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d674d1c8-957a-45e6-80a5-c4baa2c035f4.png)'
  prefs: []
  type: TYPE_IMG
- en: Making HTTP OPTIONS requests with the browsable API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we want to use the browsable API to compose and send an HTTP OPTIONS request
    to our RESTful Web Service to check the allowed HTTP verbs, the available renderers,
    and parsers for a toy resource. First, go to the URL for an existing toy resource,
    such as `http://localhost:8000/toys/7`. Make sure you replace `7` with the `id`
    or primary key of an existing toy in the previously rendered Toy List. The HTML
    web page that displays the results of an HTTP GET request to `/toys/7` plus additional
    details and controls will be rendered.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the right-hand side of the Toy Detail title, you will see an OPTIONS button.
    Click or tap this button. The browsable API will compose and send an HTTP `OPTIONS`
    request to `/toys/7` and we will see the results of the call in the web browser.
    The following screenshot shows a web browser displaying the HTTP status code `200
    OK` in the response, the allowed HTTP verbs, the content types that the toy resource
    is capable of rendering as values for the `renders` key, and the content types
    that the toy resource is capable of parsing as values for the `parses` key:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/94f81573-570a-485d-bf83-c01ecdf243de.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can also compose and send an HTTP OPTIONS request to our RESTful Web Service
    to check the allowed HTTP verbs, the available renderers, and parsers for the
    toys resource collection. First, go to the URL for the toys resource collection:
    `http://localhost:8000/toys/`. The HTML web page that displays the results of
    an HTTP GET request to `/toys/`, plus additional details and controls, will be
    rendered.'
  prefs: []
  type: TYPE_NORMAL
- en: 'At the right-hand side of the Toy Detail title, you will see an OPTIONS button.
    Click or tap this button. The browsable API will compose and send an HTTP `OPTIONS`
    request to `/toys/` with the previously specified data as a JSON body and we will
    see the results of the call in the web browser. The following screenshot shows
    a web browser displaying the HTTP status code `200 OK` in the response, the allowed
    HTTP verbs, the content types that the toys resource collection is capable of
    rendering as values for the `renders` key, and the content types that the toys
    resource collection is capable of parsing as values for the `parses` key:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/756ae095-a7cc-494b-a75d-db60b90b2a01.png)'
  prefs: []
  type: TYPE_IMG
- en: It is always a good idea to check that all the allowed verbs returned by an
    HTTP OPTIONS request to a specific resource or resource collection are coded.
    The browsable API makes it easy for us to test whether the requests for all the
    supported verbs are working OK. Then, we can automate testing, which is a topic
    we will learn in the forthcoming chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Making HTTP DELETE requests with the browsable API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we want to use the browsable API to compose and send an HTTP DELETE request
    to our RESTful Web Service to delete an existing toy resource. First, go to the
    URL for an existing toy resource, such as `http://localhost:8000/toys/7`. Make
    sure you replace `7` with the `id` or primary key of an existing toy in the previously
    rendered Toy List. The HTML web page that displays the results of an HTTP GET
    request to `/toys/7`, plus additional details and controls, will be rendered.
  prefs: []
  type: TYPE_NORMAL
- en: At the right-hand side of the Toy Detail title, you will see a DELETE button.
    Click or tap this button. The web page will display a modal requesting confirmation
    to delete the toy resource. Click or tap the DELETE button in this modal.
  prefs: []
  type: TYPE_NORMAL
- en: 'The browsable API will compose and send an HTTP `DELETE` request to `/toys/7`
    and we will see the results of the call in the web browser. The following screenshot
    shows a web browser displaying the HTTP status code `204 No Content` in the response:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/24a2b13a-0a09-439c-ab6b-0165b3d4f0fe.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, go to the URL for the toys resource collection: `http://localhost:8000/toys/`.
    The HTML web page that displays the results of an HTTP GET request to `/toys/`
    plus additional details and controls will be rendered. The recently deleted toy
    has been removed from the database. Thus, the list will not include the deleted
    toy.­ The following screenshot shows a web browser displaying the HTTP status
    code `200 OK` in the response and the list of toys without the recently deleted
    toy:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9d654d8e-ebee-4965-a9be-44f18e4b5953.png)'
  prefs: []
  type: TYPE_IMG
- en: The browsable API allowed us to compose and send many HTTP requests to our web
    service by clicking or tapping buttons on a web browser. We could check that all
    the operations are working as expected in our RESTful Web Service. However, we
    had to enter JSON content and we couldn't click on hyperlinks to navigate through
    entities. For example, we couldn't click on a toy's `id` to perform an HTTP GET
    request to retrieve this specific toy.
  prefs: []
  type: TYPE_NORMAL
- en: We will definitely improve this situation and we will take full advantage of
    many additional features included in the browsable API as we create additional
    RESTful Web Services. We will do this in the forthcoming chapters. We have just
    started working with the browsable API.
  prefs: []
  type: TYPE_NORMAL
- en: Test your knowledge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s see whether you can answer the following questions correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Which of the following classes is responsible for rendering the `text/html`
    content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `rest_framework.response.HtmlRenderer` class
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The `rest_framework.response.TextHtmlAPIRenderer` class
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The `rest_framework.response.BrowsableAPIRenderer` class
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'By default, the browsable API uses the following web component library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Bootstrap`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`ReactJS`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`AngularJS`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When we enter the URL of an existing resource in a web browser, the browsable
    API:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Returns a web page with just the JSON response for an HTTP GET request to the
    resource
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Returns a web page with a section that displays the JSON response for an HTTP
    GET request to the resource and diverse buttons to perform other requests to the
    resource
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Returns a web page with a section that displays the JSON response for an HTTP
    OPTIONS request to the resource and diverse buttons to perform other requests
    to the resource
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When we enter the URL of a non-existing resource in a web browser, the browsable
    API:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Renders a web page that displays an `HTTP 404 not found` header
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Displays a plain text message with an `HTTP 404 not found` error
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Renders a web page with the last toy resource that was available
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If we enter the following URL, `http://localhost:8000/toys/10?format=json`,
    and there is a toy resource whose `id` is equal to `10`, the browsable API will
    display:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The raw JSON results of an HTTP GET request to `http://localhost:8000/toys/`
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The raw JSON results of an HTTP GET request to `http://localhost:8000/toys/10`
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The same web page that would be rendered if we entered `http://localhost:8000/toys/10`
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The rights answers are included in the [Appendix](https://cdp.packtpub.com/django_restful_web_services__/wp-admin/post.php?post=44&action=edit#post_454), *Solutions*.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we understood some of the additional features that the Django
    REST framework adds to our RESTful Web Service, the browsable API. We used a web
    browser to work with our first web service built with Django.
  prefs: []
  type: TYPE_NORMAL
- en: We learned to make HTTP GET, POST, PUT, OPTIONS, and DELETE requests with the
    browsable API. We were able to easily test CRUD operations with a web browser.
    The browsable API allowed us to easily interact with our RESTful Web Service.
    We will take advantage of additional features in the forthcoming chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand how easy it is to take advantage of the browsable API
    with the Django REST framework, we will move on to more advanced scenarios and
    we will start a new RESTful Web Service. We will work with advanced relationships
    and serialization. We will cover these topics in [Chapter 6](dj-rst-websvc_ch16.html),
    *Working with Advanced Relationships and Serialization*.
  prefs: []
  type: TYPE_NORMAL
