- en: '11'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Common Design Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we were briefly introduced to design patterns, and
    covered the iterator pattern, a pattern so useful and common that it has been
    abstracted into the core of the programming language itself. In this chapter,
    we'll be reviewing other common patterns and how they are implemented in Python.
    As with iteration, Python often provides an alternative syntax to make working
    with such problems simpler. We will cover both the *traditional* design, and the
    Python version for these patterns.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll see:'
  prefs: []
  type: TYPE_NORMAL
- en: The Decorator pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Observer pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Strategy pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Command pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The State pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Singleton pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This chapter's case study will emphasize how the distance calculation is an
    example of the Strategy design pattern, and how we can leverage abstract base
    classes to design a variety of distance computations that can be compared to see
    which produces the most useful results.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consistent with the practice in *Design Patterns: Elements of Reusable Object-Oriented
    Software*, we''ll capitalize the pattern names. This can help them stand out from
    ordinary English usage.'
  prefs: []
  type: TYPE_NORMAL
- en: We'll start with the Decorator pattern. This is used to combine different kinds
    of functionality into a single resulting object.
  prefs: []
  type: TYPE_NORMAL
- en: The Decorator pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Decorator pattern allows us to *wrap* an object that provides core functionality
    with other objects that alter this functionality. Any object that uses the decorated
    object will interact with it in exactly the same way as if it were undecorated
    (that is, the interface of the decorated object is identical to that of the core
    object).
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two primary uses of the Decorator pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: Enhancing the response of a component as it sends data to a second component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Supporting multiple optional behaviors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The second option is often a suitable alternative to multiple inheritance.
    We can construct a core object, and then create a decorator wrapping that core.
    Since the decorator object has the same interface as the core object, we can even
    wrap the new object in other decorators. Here''s how it looks in a UML diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram  Description automatically generated](img/B17070_11_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.1: Decorator pattern in UML'
  prefs: []
  type: TYPE_NORMAL
- en: Here, **Core** and all the decorators implement a specific **Interface**. The
    dashed lines show "implements" or "realizes." The decorators maintain a reference
    to the core instance of that **Interface** via composition. When called, the decorator
    does some added processing before or after calling its wrapped interface. The
    wrapped object may be another decorator, or the core functionality. While multiple
    decorators may wrap each other, the object at the end of the chain of all those
    decorators provides the core functionality.
  prefs: []
  type: TYPE_NORMAL
- en: It's essential that each of these is providing an implementation of a common
    feature. The intent is to provide a composition of processing steps from the various
    decorators, applied to the core. Often decorators are small, typically a function
    definition without any state.
  prefs: []
  type: TYPE_NORMAL
- en: In Python, because of duck typing, we don't need to formalize these relationships
    with an official abstract interface definition. It's sufficient to make sure the
    classes have matching methods. In some cases, we may define a `typing.Protocol`
    as a type hint to help **mypy** reason about the relationships.
  prefs: []
  type: TYPE_NORMAL
- en: A Decorator example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's look at an example from network programming. We want to build a small
    server that provides some data and a client that interacts with that server. The
    server will be simulating rolling complex handfuls of dice. The client will request
    a handful and wait for an answer that contains some random numbers.
  prefs: []
  type: TYPE_NORMAL
- en: This example has two processes interacting via a TCP socket, a way to transmit
    bytes among computer systems. Sockets are created by a server that listens for
    connections. When a client attempts to connect to the socket, the server must
    accept the new connection, and the two processes can then pass bytes back and
    forth; for this example, there will be a request from client to server and a response
    from server to client. The TCP socket is part of the foundation for HTTP, around
    which the world wide web is built.
  prefs: []
  type: TYPE_NORMAL
- en: 'The client and server processes will use the `socket.send()` method to transmit
    a string of bytes through the socket. They''ll also use `socket.recv()` to receive
    bytes. We''ll start with an interactive server that waits for a connection from
    a client and then responds to the request. We''ll call this module `socket_server.py`.
    Here''s the general outline:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `server` is bound to the "public" socket, using a more or less arbitrary
    port number of `2401`. This is where the server is listening for connection requests.
    When a client tries to connect to this socket, a child socket is created so the
    client and server can talk, leaving the public socket ready for more connections.
    A web server will often use multiple threads to allow a large number of concurrent
    sessions. We're not using threads, and a second client has to wait until the server
    is done with the first client. It's a coffee shop queue with exactly one barista
    making espressos.
  prefs: []
  type: TYPE_NORMAL
- en: (Note that TCP/IP sockets have both a host address and a port number. The port
    number must be above `1023`. Port numbers `1023` and below are reserved and require
    special OS privileges. We chose port `2401` because it doesn't seem to be used
    for anything else.)
  prefs: []
  type: TYPE_NORMAL
- en: 'The `dice_response()` function does all the real work of our service. It accepts
    a `socket` parameter so it can respond to the client. It reads bytes with a client
    request, creates a response, then sends it. In order to handle exceptions gracefully,
    the `dice_response()` function looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve wrapped another function, `dice_roller()`, in an exception handler.
    This is a common pattern to separate error-handling and other overheads from the
    real work of computing a dice roll and responding to the client with useful numbers
    for their role-playing game:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This isn't too sophisticated. We'll expand on this in the section on *The Command
    pattern* later in this chapter. For now, however, it will provide a sequence of
    random numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we're not really doing anything with the `request` object that came
    from the client. For the first few examples, we'll be reading these bytes and
    ignoring them. The `request` is a placeholder for a more complex request describing
    how many dice to roll and how many times to roll them.
  prefs: []
  type: TYPE_NORMAL
- en: We can leverage the Decorator design pattern to add features. The decorator
    will be wrapping the core `dice_response()` function, which is given a `socket`
    object that it can read and write. To make use of the design pattern, it's important
    to exploit the way this function relies on the `socket.send()` and `socket.recv()`
    methods when we add features. We need to preserve the interface definition as
    we add decorations.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test the server, we can write a very simple client that connects to the
    same port and outputs the response before exiting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This client asks two questions and creates a fairly complex-looking string,
    `command`, that contains a count and dice-rolling pattern. Right now, the server
    doesn't use this command. This is a teaser for a more sophisticated dice roller.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use these two separate applications, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open two terminal windows, side by side. (It can help to change the window titles
    to "client" and "server". Users of macOS Terminal can use the **change title**
    item in the **shell** menu. Windows users can use the `title` command.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the server window, start the server application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the client window, start the client application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Enter your responses to the prompts in the client window. For example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The client will send the command, read the response, print it to the console,
    and exit. Run the client as many times as you want to get a sequence of dice rolls.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The result will look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Text  Description automatically generated](img/B17070_11_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.2: Server and client'
  prefs: []
  type: TYPE_NORMAL
- en: On the left side is the server. We started the application, and it started listening
    on port `2401` for clients. On the right side is the client. Each time we run
    the client, it connects to the public socket; the connection operation creates
    a child socket that can be used for the rest of the interaction. The client sends
    a command the server responds to that command, and the client prints it.
  prefs: []
  type: TYPE_NORMAL
- en: Now, looking back at our server code, we see two sections. The `dice_response()`
    function reads data and sends data back to the client via a `socket` object. The
    remaining script is responsible for creating that `socket` object. We'll create
    a pair of decorators that customize the socket behavior without having to extend
    or modify the socket itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with a *logging* decorator. This object outputs any data being
    sent to the server''s console before it sends it to the client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This class decorates a `socket` object and presents the `send()`, `recv()`,
    and `close()` interface to clients using it. A better decorator could properly
    implement all of the arguments to `send`, (which actually accepts an optional
    flags argument), but let's keep our example simple. Whenever `send()` is called
    on an instance of the `LogSocket` class, it logs the output to the screen before
    sending data to the client using the original socket. Similarly, for `recv()`,
    it reads and logs the data it received.
  prefs: []
  type: TYPE_NORMAL
- en: 'We only have to change one line in our original code to use this decorator.
    Instead of calling the `dice_response()` function with the original client socket,
    we call it with a decorated socket:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We've decorated the core `socket` with a `LogSocket`. The `LogSocket` will print
    to the console as well as invoking methods of the socket it decorates. The essential
    processing in the `dice_response()` function doesn't change, because the `LogSocket`
    instance behaves like the underlying `socket` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that we needed to use an explicit `cast()` to tell **mypy** the `LogSocket`
    instance would provide a similar interface to an ordinary `socket`. For a simple
    case like this, we have to ask ourselves why we didn''t just extend the `socket` class
    and override the `send` method. A subclass could call `super().send()` and `super().recv()` to
    do the actual sending, after we logged it. Decoration offers an advantage over
    inheritance: a decoration can be reused among various classes in various class
    hierarchies. In this specific little example, there aren''t too many socket-like
    objects, so the possibilities of reuse are limited.'
  prefs: []
  type: TYPE_NORMAL
- en: If we switch our focus to something more generic than a `socket`, we can create
    potentially reusable decorators. Processing strings or bytes seems more common
    than processing a `socket`. Changing the structure can give us some desirable
    flexibility in addition to reuse potential. Originally, we broke the processing
    into a `dice_response()` function that handled the socket reading and writing,
    separate from a `dice_roller()` function that works with bytes. Because the `dice_roller()`
    function consumes the request bytes and produces response bytes, it can be a little
    simpler to expand and add features to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can have a family of related decorators. We can decorate already decorated
    objects. The idea is to give ourselves flexibility through composition. Let''s
    rework the logging decorator to focus on the bytes request and response instead
    of the `socket` object. The following should look similar to the earlier example
    but with some code shifted around to reside in a single `__call__()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s a second decorator that compresses data using `gzip` compression on
    the resulting bytes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This decorator compresses the incoming data before sending it on to the client.
    It decorates an underlying `dice_roller` object that computes a response to a
    request.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have these two decorators, we can write code that piles one decoration
    on top of another:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The intent here is to separate three aspects of this application:'
  prefs: []
  type: TYPE_NORMAL
- en: Zipping the resulting document
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a log
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Doing the underlying computation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can apply the zip or logging to any similar application that works with
    receiving and sending bytes. We can, if we want, make the zipping operation a
    dynamic choice, also. We might have a separate configuration file to enable or
    disable the GZip feature. This means something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We have a dynamic set of decorations. Try writing this using a multiple inheritance
    mixin and see how confused it becomes!
  prefs: []
  type: TYPE_NORMAL
- en: Decorators in Python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Decorator pattern is useful in Python, but there are additional options.
    For example, we can use monkey-patching – changing the class definition at runtime
    – to get a similar effect. For example, `socket.socket.send = log_send` will change
    the way the built-in socket works. There are sometimes surprising implementation
    details that can make this unpleasantly complex. Single inheritance, where the
    *optional* calculations are done in one large method with a bunch of `if` statements,
    could be an option. Multiple inheritance should not be written off just because
    it's not suitable for the specific example seen previously.
  prefs: []
  type: TYPE_NORMAL
- en: In Python, it is very common to use this pattern on functions. As we saw in
    a previous chapter, functions are objects too. In fact, function decoration is
    so common that Python provides a special syntax to make it easy to apply such
    decorators to functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can look at the logging example in a more general way. Instead
    of logging only send calls on sockets, we may find it helpful to log all calls
    to certain functions or methods. The following example implements a decorator
    that does just this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This decorator function is very similar to the example we explored earlier;
    in the earlier examples, the decorator took a socket-like object and created a
    socket-like object. This time, our decorator takes a function object and returns
    a new function object. We''ve provided a type hint of `Callable[..., Any]` to
    state that any function will work here. This code comprises three separate tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: A function, `log_args()`, that accepts another function, `function`, as a parameter
    value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This function defines (internally) a new function, named `wrapped_function`,
    that does some extra work before calling the original function and returning the
    results from the original function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The new inner function, `wrapped_function()`, is returned from the decorator
    function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because we're using `@wraps(function)`, the new function will have a copy of
    the original function's name and the original function's docstring. This avoids
    having all of the functions we decorate wind up named `wrapped_function`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a sample function to demonstrate the decorator in use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This function can be decorated and used like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This syntax allows us to build decorated function objects dynamically, just
    as we did with the socket example. If we don't use assignment to assign the new
    object to the old name, we can even keep the decorated and the non-decorated versions
    for different situations. We could use a statement like `test1_log = log_args(test1)`
    to create a second, decorated version of the `test1()` function, named `test1_log()`.
  prefs: []
  type: TYPE_NORMAL
- en: Typically, these decorators are general modifications that are applied permanently
    to different functions. In this situation, Python supports a special syntax to
    apply the decorator at the time the function is defined. We've already seen this
    syntax in a few places; now, let's understand how it works.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of applying the decorator function after the method definition, we
    can use the `@decorator` syntax to do it all at once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The primary benefit of this syntax is that we can easily see that the function
    has been decorated whenever we read the function definition. If the decorator
    is applied later, someone reading the code may miss that the function has been
    altered at all. Answering a question like *Why is my program logging function
    calls to the console?* can become much more difficult! However, the syntax can
    only be applied to functions we define, since we don't have access to the source
    code of other modules. If we need to decorate functions that are part of somebody
    else's third-party library, we have to use the earlier syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python''s decorators permit parameters, also. One of the most useful decorators
    in the standard library is `functools.lru_cache`. The idea of a cache is to save
    computed results of a function to avoid recomputing them. Rather than save all
    of the parameters and results, we can keep the cache small by discarding the **least
    recently used** (**LRU**) values. For example, here''s a function that involves
    a potentially expensive computation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use the `lru_cache` decorator to avoid doing this computation once the
    answer is known. Here''s the small change required:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The parameterized decorator, `@lru_cache(64)`, used to create this second version
    of the `binom()` function means it will save the most recent 64 results to avoid
    recomputing values when they've already been computed once. No change is needed
    elsewhere in the application. Sometimes, the speedup from this small change can
    be dramatic. We can, of course, fine-tune the size of the cache based on the data
    and the number of computations that are being performed.
  prefs: []
  type: TYPE_NORMAL
- en: Parameterized decorators like this involve a two-step dance. First, we customize
    the decorator with the parameter, then we apply that customized decorator to a
    function definition. These two separate steps parallel the way callable objects
    are initialized with the `__init__()` method, and can be called, like a function,
    via their `__call__()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example of a configurable logging decorator, `NamedLogger`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `__init__()` method makes sure we can use code like `NamedLogger("log4")`
    to create a decorator; this decorator will make sure the function that follows
    uses a specific logger.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `__call__()` method follows the pattern shown above. We define a new function,
    `wrapped_function()`, that does the work, and return that newly minted function.
    We can use it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We've created an instance of the `NamedLogger` class. Then we applied this instance
    to the `test4()` function definition. The `__call__()` method is invoked, and
    will create a new function, the decorated version of the `test4()` function.
  prefs: []
  type: TYPE_NORMAL
- en: There are a few more use cases for the decorator syntax. For example, when a
    decorator is a method of a class, it can also save information about the decorated
    function, creating a registry of decorated functions. Further, classes can also
    be decorated; in that case, the decorator returns a new class instead of a new
    function. In all of these more advanced cases, we're using ordinary object-oriented
    design with the simpler-looking syntax of `@decorator`.
  prefs: []
  type: TYPE_NORMAL
- en: The Observer pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Observer pattern is useful for state monitoring and event handling situations.
    This pattern allows a given object to be monitored by an unknown and dynamic group
    of *observer* objects. The core object being observed needs to implement an interface
    that makes it *observable*.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever a value on the core object changes, it lets all the observer objects
    know that a change has occurred, by calling a method announcing there's been a
    change of state. This is used widely in GUIs to make sure that any state change
    in the underlying model is reflected in the views of the model. It's common to
    have detail and summary views; a change to the details must also update the widgets
    that display the details and update any summaries that are displayed, also. Sometimes
    a large change in mode may lead to a number of items being changed. For instance,
    clicking a "lock" icon may alter a number of displayed items to reflect their
    status as locked. This can be implemented as a number of observers attached to
    the observable display widget.
  prefs: []
  type: TYPE_NORMAL
- en: In Python, the observer can be notified via the `__call__()` method, making
    each observer behave like a function or other callable object. Each observer may
    be responsible for different tasks whenever the core object changes; the core
    object doesn't know or care what those tasks are, and the observers don't typically
    know or care what other observers are doing.
  prefs: []
  type: TYPE_NORMAL
- en: This allows tremendous flexibility by decoupling the response to a state change
    from the change itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a depiction of the Observer design pattern in UML:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram  Description automatically generated](img/B17070_11_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.3: Observer pattern in UML'
  prefs: []
  type: TYPE_NORMAL
- en: We've shown the `Core` object as containing a list of observer objects. To be
    observable, the `Core` class must adhere to a common understanding of observability;
    specifically, it must provide a list of observers and a way to attach new observers.
  prefs: []
  type: TYPE_NORMAL
- en: We've shown the `Observer` subclasses as having a `__call__()` method. This
    will be used by the observable to notify each observer of a state change. As with
    the Decorator pattern, we don't need to formalize the relationships with formally
    defined abstract superclasses. In most cases, we can rely on duck typing rules;
    as long as the observers have the right interface, they can be used in the defined
    role in this pattern. If they lack the proper interface, **mypy** may catch the
    conflict, and a unit test should catch the problem.
  prefs: []
  type: TYPE_NORMAL
- en: An Observer example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Outside a GUI, the Observer pattern is useful for saving intermediate states
    of objects. Using observer objects can be handy in systems where a rigorous audit
    of changes is required. It's also handy in a system where chaos reigns and components
    are unreliable.
  prefs: []
  type: TYPE_NORMAL
- en: Complex, cloud-based applications can suffer from chaos issues due to unreliable
    connections. We can use observers to record state changes, making recovery and
    restart easier.
  prefs: []
  type: TYPE_NORMAL
- en: For this example, we'll define a core object to maintain a collection of important
    values, and then have one or more observers create serialized copies of that object.
    These copies might be stored in a database, on a remote host, or in a local file,
    for example. Because we can have a number of observers, it's easy to modify the
    design to use different data caches. For this example, we're thinking of a dice
    game called Zonk or Zilch or Ten Thousand, where a player will roll six dice,
    score some points for triples and runs, and possibly roll again, leading to a
    sequence of dice. (The rules are a bit more complex than this glib summary.)
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start with a few overheads to help make our intention clear:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The `Observer` class is a protocol, an abstract superclass for our observers.
    We didn't formalize it as an `abc.ABC` abstract class; we're not relying on the
    runtime error offered by the `abc` module. When defining a `Protocol`, we're relying
    on **mypy** to confirm that all observers actually implement the required method.
  prefs: []
  type: TYPE_NORMAL
- en: The `Observable` class defines the `_observers` instance variable and three
    methods that are purely part of this protocol definition. An observable object
    can append an observer, remove an observer, and – most important – notify all
    the observers of a state change. The only thing the core class needs to do that's
    special or different is to make calls to the `_notify_observers()` method when
    there's a state change. Appropriate notification is an important piece of the
    design for an observable object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s part of the Zonk game we care about. This class keeps a player''s hands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This class makes calls to `self._notify_observers()` on important state changes.
    This will notify all the observer instances. The observers might cache copies
    of the hand, send details over a network, update widgets on a GUI – any number
    of things. The `_notify_observers()` method inherited from `Observable` iterates
    over any registered observers and lets each know that the state of the hand has
    changed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s implement a simple observer object; this one will print out some
    state to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: There's nothing terribly exciting here; the observed object is set up in the
    initializer, and when the observer is called, we do *something*, in this example,
    printing a line. Note that the superclass, `Observer`, isn't actually needed here.
    The context in which this class is used is sufficient for **mypy** to confirm
    this class matches the required `Observer` protocol. While we don't need to state
    that it's an `Observer`, it can help readers to see that this class implements
    the `Observer` protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can test the `SaveZonkHand` observer in an interactive console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: After attaching the observer to the `Inventory` object, whenever we change one
    of the two observed properties, the observer is called and its action is invoked.
    Note that our observer tracks a sequence number and includes a timestamp. These
    are outside the game definition, and are kept separate from the essential game
    processing by being part of the `SaveZonkHand` observer class.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can add multiple observers of a variety of classes. Let''s add a second
    observer that has a limited job to check for three pairs and announce it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: For this example, we omitted naming `Observer` as a superclass. We can trust
    the **mypy** tool to note how this class is used and what protocols it must implement.
    Introducing this new `ThreePairZonkHand` observer means that when we change the
    state of the hand, there may be two sets of output, one for each observer. The
    key idea here is that we can easily add totally different types of observers to
    do different kinds of things, in this case, copying the data as well as checking
    for a special case in the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Observer pattern detaches the code being observed from the code doing the
    observing. If we were not using this pattern, we would have had to put code in
    the `ZonkHandHistory` class to handle the different cases that might come up:
    logging to the console, updating a database or file, checking for special cases,
    and so on. The code for each of these tasks would all be mixed in with the core
    class definition. Maintaining it would be a nightmare and adding new monitoring
    functionality at a later date would be painful.'
  prefs: []
  type: TYPE_NORMAL
- en: The Strategy pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Strategy pattern is a common demonstration of abstraction in object-oriented
    programming. The pattern implements different solutions to a single problem, each
    in a different object. The core class can then choose the most appropriate implementation
    dynamically at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Typically, different algorithms have different trade-offs; one might be faster
    than another, but uses a lot more memory, while a third algorithm may be most
    suitable when multiple CPUs are present or a distributed system is provided.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the Strategy pattern in UML:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram  Description automatically generated](img/B17070_11_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.4: Strategy pattern in UML'
  prefs: []
  type: TYPE_NORMAL
- en: The **Core** code connecting to the **Strategy** abstraction simply needs to
    know that it is dealing with some kind of class that fits the Strategy interface
    for this particular action. Each of the implementations should perform the same
    task, but in different ways. The implementation interfaces need to be identical,
    and it's often helpful to leverage an abstract base class to make sure the implementations
    match.
  prefs: []
  type: TYPE_NORMAL
- en: This idea of a plug-in strategy is also an aspect of the Observer pattern. Indeed,
    the idea of strategy objects is an important aspect of many of the patterns covered
    in this chapter. The common idea is to use a separate object to isolate conditional
    or replaceable processing and delegate the work to the separate object. This works
    for observables, decorations, and – as we'll see – commands and states, also.
  prefs: []
  type: TYPE_NORMAL
- en: A Strategy example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One common example of the Strategy pattern is sort routines; over the years,
    numerous algorithms have been invented for sorting a collection of objects. Quick
    sort, merge sort, and heap sort are all algorithms with different features, each
    useful in its own right, depending on the size and type of inputs, how out of
    order they are, and the requirements of the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we have client code that needs to sort a collection, we could pass it to
    an object with a `sort()` method. This object may be a `QuickSorter` or `MergeSorter` object,
    but the result will be the same in either case: a sorted list. The strategy used
    to do the sorting is abstracted from the calling code, making it modular and replaceable.'
  prefs: []
  type: TYPE_NORMAL
- en: Of course, in Python, we typically just call the `sorted()` function or `list.sort()`
    method and trust that it will do the sorting quickly enough that the details of
    the TimSort algorithm don't really matter. For details on how amazingly fast TimSort
    is, see [https://bugs.python.org/file4451/timsort.txt](https://bugs.python.org/file4451/timsort.txt).
    While sorting is a helpful concept, it's not the most practical example, so let's
    look at something different.
  prefs: []
  type: TYPE_NORMAL
- en: As a simpler example of the Strategy design pattern, consider a desktop wallpaper
    manager. When an image is displayed on a desktop background, it can be adjusted
    to the screen size in different ways. For example, assuming the image is smaller
    than the screen, it can be tiled across the screen, centered on it, or scaled
    to fit. There are other, more complicated strategies that can be used as well,
    such as scaling to the maximum height or width, combining it with a solid, semi-transparent,
    or gradient background color, or other manipulations. While we may want to add
    these strategies later, let's start with a few basic ones.
  prefs: []
  type: TYPE_NORMAL
- en: You'll need to install the `pillow` module. If you're using **conda** to manage
    your virtual environments, use `conda install pillow` to install the Pillow project's
    `PIL` implementation. If you're not using **conda**, use `python -m pip install
    pillow`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our Strategy objects need to take two inputs: the image to be displayed, and
    a tuple of the width and height of the screen. They each return a new image the
    size of the screen, with the image manipulated to fit according to the given strategy.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some preliminary definitions, including an abstract superclass for
    all of the strategy variants:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Is this abstraction necessary? This sits right on the fence between too simple
    to require an abstraction and complex enough that the superclass helps. The function
    signature is kind of complex, with a special type hint to describe the size tuple.
    For this reason, the abstraction can help check each implementation to be sure
    all the types match.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that we need to include the special `# type: ignore [import]` comment
    to make sure **mypy** isn''t confused by the lack of annotations in the PIL modules.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s our first concrete strategy; this is a fill algorithm that tiles the
    images:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This works by dividing the output height and width by the input image height
    and width. The `num_tiles` sequence is a way of doing the same computation to
    widths and heights. It's a two-tuple computed via a list comprehension to be sure
    both width and height are processed the same way.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a fill algorithm that centers the image without re-scaling it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, here''s a fill algorithm that scales the image up to fill the entire
    screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Here we have three strategy subclasses, each using `PIL.Image` to perform their
    task. All the strategy implementations have a `make_background()` method that
    accepts the same set of parameters. Once selected, the appropriate Strategy object
    can be called to create a correctly sized version of the desktop image. `TiledStrategy` computes
    the number of input image tiles that would fit in the width and height of the
    display screen and copies the image into each tile location, repeatedly, without
    rescaling, so it may not fill the entire space. `CenteredStrategy` figures out
    how much space needs to be left on the four edges of the image to center it. `ScaledStrategy` forces
    the image to the output size, without preserving the original aspect ratio.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an overall object that does resizing, using one of these Strategy classes.
    The `algorithm` instance variable is filled in when a `Resizer` instance is created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'And here''s a `main` function that builds an instance of the `Resizer` class
    and applies one of the available Strategy classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: What's important is the binding of the Strategy instance happens as late as
    possible in the processing. The decision can be made (and unmade) at any point
    in the processing because any of the available strategy objects can be plugged
    into a `Resizer` object at any time.
  prefs: []
  type: TYPE_NORMAL
- en: Consider how switching between these options would be implemented without the
    Strategy pattern. We'd need to put all the code inside one great big method and
    use an awkward `if` statement to select the expected one. Every time we wanted
    to add a new strategy, we'd have to make the method even more ungainly.
  prefs: []
  type: TYPE_NORMAL
- en: Strategy in Python
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The preceding canonical implementation of the Strategy pattern, while very common
    in most object-oriented libraries, isn't ideal in Python. It involves some overheads
    that aren't really necessary.
  prefs: []
  type: TYPE_NORMAL
- en: These strategy classes each define objects that do nothing but provide a single
    method. We could just as easily call that function `__call__` and make the object
    callable directly. Since there is no other data associated with the object, we
    need do no more than create a set of top-level functions and pass them around
    as our strategies instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of the overheads of an abstract class, we could summarize these strategies
    with a type hint of:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: When we do this, we can eliminate all of the references to `FillAlgorithm` in
    class definitions; we'd change `class CenteredStrategy(FillAlgorithm):` to `class
    CenteredStrategy``:`.
  prefs: []
  type: TYPE_NORMAL
- en: Because we have a choice between an abstract class and a type hint, the Strategy
    design pattern seems superfluous. This leads to an odd conversation, starting
    with *"Because Python has first-class functions, the Strategy pattern is unnecessary."*
    In truth, Python's first-class functions allow us to implement the Strategy pattern
    in a more straightforward way, without the overhead of class definitions. The
    pattern is more than the implementation details. Knowing the pattern can help
    us choose a good design for our program, and implement it using the most readable
    syntax. The Strategy pattern, whether a class or a top-level function, should
    be used when we need to allow client code or the end user to select from multiple
    implementations of the same interface at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: There's a bright line separating mixin class definitions from plug-in strategy
    objects. As we saw in *Chapter 6*, *Abstract Base Classes and Operator Overloading*,
    mixin class definitions are created in the source code, and cannot easily be tweaked
    at runtime. A plug-in strategy object, however, is filled in at runtime, allowing
    late binding of the strategy. The code tends to be very similar between them,
    and it helps to have clear docstrings on each class to explain how the various
    classes fit together.
  prefs: []
  type: TYPE_NORMAL
- en: The Command pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we think about class responsibilities, we can sometimes distinguish "passive"
    classes that hold objects and maintain an internal state, but don't initiate very
    much, and "active" classes that reach out into other objects to take action and
    do things. This is not a very crisp distinction, but it can help separate the
    relatively passive Observer and the more active Command design patterns. An Observer
    is notified that something changed. A Commander, on the other hand, will be active,
    making state changes in other objects. We can combine the two aspects, and that's
    one of the beauties of talking about a software architecture by describing the
    various patterns that apply to a class or a relationship among classes.
  prefs: []
  type: TYPE_NORMAL
- en: The Command pattern generally involves a hierarchy of classes that each do something.
    A Core class can create a command (or a sequence of commands) to carry out actions.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a way, it''s a kind of meta-programming: by creating Command objects that
    contain a bunch of statements, the design has a higher-level "language" of Command objects.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a UML diagram showing a **Core** object and a collection of **Commands**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram  Description automatically generated](img/B17070_11_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.5: Command pattern in UML'
  prefs: []
  type: TYPE_NORMAL
- en: This looks similar to the diagrams for the Strategy and Observer patterns because
    all these patterns rely on delegating work from a **Core** object to a plug-in
    object. In this case, a sequence of individual plug-in objects that represent
    a sequence of commands to perform.
  prefs: []
  type: TYPE_NORMAL
- en: A Command example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As an example, we''ll look at the fancy dice rolling that was omitted from
    the Decorator pattern example earlier in this chapter. In the earlier example,
    we had a function, `dice_roller()`, that computed a sequence of random numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This isn't very clever; we'd rather handle something a little more sophisticated.
    We want to be able to write strings like `3d6` to mean three six-sided dice, `3d6+2`
    to mean three six-sided dice plus a bonus of two more, and something a little
    more obscure like `4d6d1` to mean "roll four six-sided dice and drop one of the
    lowest dice." We might want to combine things and write `4d6d1+2`, also, to combine
    dropping the lowest and adding two to the result.
  prefs: []
  type: TYPE_NORMAL
- en: 'These `d1` and `+2` options at the end can be viewed as a series of commands.
    There are four common varieties: "drop," "keep," "add," and "subtract." There
    can be a lot more, of course, to reflect a wide variety of game mechanics and
    desired statistical distributions, but we''ll look at four commands that modify
    a batch of dice.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the regular expression we''re going to implement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This regular expression can be a little daunting. Some people find the railroad
    diagrams at [https://www.debuggex.com](https://www.debuggex.com) to be helpful.
    Here''s a depiction as a UML state diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram  Description automatically generated](img/B17070_11_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.6: Dice-parsing regular expression'
  prefs: []
  type: TYPE_NORMAL
- en: 'This pattern has four parts:'
  prefs: []
  type: TYPE_NORMAL
- en: The first grouping, `(?P<n>\d*)`, captures a batch of digits for the number
    of dice, saving this as a group named `n`. This is optional, allowing us to write
    `d6` instead of `1d6`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The letter "d", which must be present, but isn't captured.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The next grouping, `(?P<d>\d+)`, captures the digits for the number of faces
    on each die, saving this as a group named `d`. If we were very fussy, we might
    try to limit this to `(4|6|8|10|12|20|100)` to define an acceptable list of regular
    polyhedral dice (and two common irregular polyhedrons). We didn't provide this
    short list; instead, we'll accept any sequence of digits.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The final grouping, `(?P<a>[dk+-]\d+)*`, defines a repeating series of adjustments.
    Each one has a prefix and a sequence of digits, for example, `d1` or `k3` or `+1`
    or `-2`. We'll capture the whole sequence of adjustments as group `a`, and decompose
    the parts separately. Each of these parts will become a command, following the
    Command design pattern.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can think of each part of dice rolling as a distinct command. One command
    rolls the dice, and then subsequent commands adjust the value of the dice. For
    example, `3d6+2` means roll three dice (for example, ![](img/1.png), ![](img/1.png),
    ![](img/3.png)) and add 2 to get 13 in total. The class, overall, looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'When we want a new roll of the dice, a `Dice` object applies the individual
    `Adjustment` objects to create a new roll. We can see one of the kinds of `Adjustment`
    objects in the `__init__()` method: a `Roll` object. This is put first into a
    sequence of adjustments; after that any additional adjustments are processed in
    order. Each adjustment is another kind of command.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the various kinds of adjustment commands that change the state of
    a `Dice` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: An instance of the `Roll()` class sets the values of the dice and the modifier
    attribute of a `Dice` instance. The other `Adjustment` objects either remove some
    dice or change the modifier. The operations depend on the dice being sorted. That
    makes it easy to drop the worst or keep the best via slice operations. Because
    each adjustment is a kind of command, they make adjustments to the overall state
    of the dice that were rolled.
  prefs: []
  type: TYPE_NORMAL
- en: 'The missing piece is translating the string dice expression into a sequence
    of `Adjustment` objects. We''ve made this a `@classmethod` of the `Dice` class.
    This lets us use `Dice.from_text()` to create a new `Dice` instance. It also provides
    the subclass as the first parameter value, `cls`, making sure that each subclass
    creates proper instances of itself, not this parent class. Here''s the definition
    of this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The overall `dice_pattern` is applied first and the result is assigned to the
    `dice_match` variable. If the result is a `None` object, the pattern didn't match,
    and we can't do much more than raise a `ValueError` exception and give up. The
    `adjustment_pattern` is used to decompose the string of adjustments in the suffix
    of the dice expression. A list comprehension is used to create a list of objects
    from the `Adjustment` class definitions.
  prefs: []
  type: TYPE_NORMAL
- en: Each adjustment class is a separate command. The `Dice` class will inject a
    special command, `Roll`, that starts the processing by simulating a roll of the
    dice. Then the adjust commands can apply their individual changes to the initial
    roll.
  prefs: []
  type: TYPE_NORMAL
- en: 'This design allows us to manually create an instance like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The first two parameters define the special `Roll` command. The remaining parameters
    can include any number of further adjustments. In this case, there''s only one,
    a `Keep(3)` command. The alternative is to parse text, like this: `dice.Dice.from_text("4d6k3")`.
    This will build the `Roll` command and the other `Adjustment` commands. Each time
    we want a new roll of the dice, the sequence of commands is executed, rolling
    the dice and then adjusting that roll to give a final outcome.'
  prefs: []
  type: TYPE_NORMAL
- en: The State pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The State pattern is structurally similar to the Strategy pattern, but its
    intent and purpose are very different. The goal of the State pattern is to represent
    state transition systems: systems where an object''s behavior is constrained by
    the state it''s in, and there are narrowly defined transitions to other states.'
  prefs: []
  type: TYPE_NORMAL
- en: To make this work, we need a manager or context class that provides an interface
    for switching states. Internally, this class contains a pointer to the current
    state. Each state knows what other states it is allowed to be in and will transition
    to those states depending on the actions invoked upon it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how it looks in UML:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram  Description automatically generated](img/B17070_11_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.7: State pattern in UML'
  prefs: []
  type: TYPE_NORMAL
- en: 'The State pattern decomposes the problem into two types of classes: the **Core**
    class and multiple **State** classes. The **Core** class maintains the current
    state, and forwards actions to a current state object. The **State** objects are
    typically hidden from any other objects that are calling the **Core** object;
    it acts like a black box that happens to perform state management internally.'
  prefs: []
  type: TYPE_NORMAL
- en: A State example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the most compelling state-specific processing examples is parsing text.
    When we write a regular expression, we're detailing a series of alternative state
    changes used to match a pattern against a sample piece of text. At a higher level,
    parsing the text of a programming language or a markup language is also highly
    stateful work. Markup languages like XML, HTML, YAML, TOML, or even reStructuredText
    and Markdown all have stateful rules for what is allowed next and what is not
    allowed next.
  prefs: []
  type: TYPE_NORMAL
- en: We'll look at a relatively simple language that crops up when solving **Internet
    of Things** (**IoT**) problems. The data stream from a GPS receiver is an interesting
    problem. Parsing statements in this language is an example of the State design
    pattern. The language is the NMEA 0183 language from the National Marine Electronics
    Association.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output from a GPS antenna is a stream of bytes that form a sequence of
    "sentences." Each sentence starts with `$`, includes printable characters in the
    ASCII encoding, and ends with a carriage return and a newline character. A GPS
    device''s output includes a number of different kinds of sentences, including
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: GPRMC – recommended minimum data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GPGGA – global position
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GPGLL – latitude and longitude
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GPGSV – satellites in view
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GPGSA – active satellites
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are many, many more messages available, and they come out of the antenna
    device at a pace that can be bewildering. They all have a common format, however,
    making them easy to validate and filter so we can use the good ones, and ignore
    the ones that aren't providing useful information for our specific application.
  prefs: []
  type: TYPE_NORMAL
- en: 'A typical message looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'This sentence has the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `$` | Starts the sentence |'
  prefs: []
  type: TYPE_TB
- en: '| `GPGLL` | The "talker," GP, and the type of message, GLL |'
  prefs: []
  type: TYPE_TB
- en: '| `3723.2475` | Latitude, 37°23.2475 |'
  prefs: []
  type: TYPE_TB
- en: '| `N` | North of the equator |'
  prefs: []
  type: TYPE_TB
- en: '| `12158.3416` | Longitude, 121°58.3416 |'
  prefs: []
  type: TYPE_TB
- en: '| `W` | West of the 0° meridian |'
  prefs: []
  type: TYPE_TB
- en: '| `161229.487` | The timestamp in UTC: 16:12:29.487 |'
  prefs: []
  type: TYPE_TB
- en: '| `A` | Status, `A`=valid, `V`=not valid |'
  prefs: []
  type: TYPE_TB
- en: '| `A` | Mode, `A`=Autonomous, `D`=DGPS, `E`=DR |'
  prefs: []
  type: TYPE_TB
- en: '| `*` | Ends the sentence, starts the checksum |'
  prefs: []
  type: TYPE_TB
- en: '| `41` | Hexadecimal checksum of the text (excluding the `$` and `*` characters)
    |'
  prefs: []
  type: TYPE_TB
- en: With a few exceptions, all the messages from a GPS will have a similar pattern.
    The exceptional messages will start with `!`, and our design will safely ignore
    them.
  prefs: []
  type: TYPE_NORMAL
- en: 'When building IoT devices, we need to be aware of two complicating factors:'
  prefs: []
  type: TYPE_NORMAL
- en: Things aren't very reliable, meaning our software must be prepared for broken
    or incomplete messages.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The devices are tiny and some common Python techniques that work on a large,
    general-purpose laptop computer won't work well in a tiny Circuit Playground Express
    chip with only 32K of memory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What we need to do, then, is to read and validate the message as the bytes arrive.
    This saves time (and memory) when ingesting data. Because there's a defined upper
    bound of 82 bytes for these GPS messages, we can use Python `bytearray` structures
    as a place to process the bytes of a message.
  prefs: []
  type: TYPE_NORMAL
- en: 'The process for reading a message has a number of distinct states. The following
    state transition diagram shows the available state changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram  Description automatically generated](img/B17070_11_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.8: State transitions to parse NMEA sentences'
  prefs: []
  type: TYPE_NORMAL
- en: We start in a state of waiting for the next `$`. We'll assume that IoT devices
    have loose wires and power problems. (Some people can solder really well, so unreliability
    may not be as common for them as it is for the authors.)
  prefs: []
  type: TYPE_NORMAL
- en: Once we've received the `$`, we'll transition to a state of reading the five-character
    header. If, at any time, we get another `$`, it means we lost some bytes somewhere,
    and we need to start over again. Once we have all five characters with the message
    name, we can transition to reading the message body. This will have up to 73 more
    bytes. When we receive a `*`, it tells us we're at the end of the body. Again,
    if we see a `$` along the way, it means something's wrong and we should restart.
  prefs: []
  type: TYPE_NORMAL
- en: The final two bytes (after the `*`) represent a hexadecimal value that should
    equal the computed checksum of the preceding message (header and body). If the
    checksum is good, the message can be used by the application. There will be one
    or more "whitespace" characters – usually carriage return and newline characters
    – at the end of the message.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can imagine each of these states as an extension of the following class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: We've defined each state to work with a `Message` object. Some reader object
    will feed a byte to the current state, which will do something with the byte (usually
    save it) and return the next state. The exact behavior depends on the byte received;
    for example, most states will reset the message buffer to empty and transition
    to the `Header` state when they receive a `$`. Most states will return `False`
    for the `valid()` function. One state, however, will validate a complete message,
    and possibly return `True` for the `valid()` function, if the checksum is correct.
  prefs: []
  type: TYPE_NORMAL
- en: For the purists, the class name doesn't strictly follow PEP-8\. It's challenging
    to include abbreviations or acronyms and keep a properly camel-cased name. It
    seems like `NmeaState` isn't as clear. While a compromise class name might be
    `NMEAState`, the clash between abbreviations and class name seems confusing. We
    prefer to cite "*A foolish consistency is the hobgoblin of little minds…*" in
    this specific case. Keeping the class hierarchy internally consistent is more
    important than the full PEP-8 level of consistency.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Message` object is a wrapper around two `bytearray` structures where we
    accumulate the content of the message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This definition of the `Message` class encapsulates much of what's important
    about each sentence that comes from the GPS device. We defined a method, `body_append()`,
    for accumulating bytes in the body, and accumulating a checksum of those bytes.
    In this case, the `^` operator is used to compute the checksum. This is a real
    Python operator; it's the bit-wise exclusive OR. An exclusive OR means "one or
    the other but not both." You can see it in action with an expression like `bin(ord(b'a')
    ^ ord(b'z'))`. The bits in `b'a'` are `0b1100001`. The bits in `b'z'` are `0b1111010`.
    Applying "one or the other but not both" to the bits, the exclusive OR is `0b0011011`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the reader that builds valid `Message` objects by undergoing a number
    of state changes as bytes are received:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The initial state is an instance of the `Waiting` class, a subclass of `NMEA_State`.
    The `read()` method consumes one byte from the input, and then hands it to the
    current `NMEA_State` object for processing. The state object may save the byte
    or may discard it, the state object may transition to another state, or it may
    return the current state. If the state's `valid()` method is `True`, the message
    is complete, and we can yield it for further processing by our application.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we're reusing a `Message` object's byte arrays until it's complete
    and valid. This avoids allocating and freeing a lot of objects while ignoring
    incomplete messages on a noisy line. This is not typical for Python programs on
    large computers. In some applications, we don't need to save the original message,
    but only need to save the values of a few fields, further reducing the amount
    of memory used.
  prefs: []
  type: TYPE_NORMAL
- en: To reuse the buffers in the `Message` object, we need to make sure it's not
    part of any specific `State` object. We've made the current `Message` object part
    of the overall `Reader`, and provided the working `Message` object to each `State`
    as an argument value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we''ve seen the context, here are the classes to implement the various
    states for an incomplete message. We''ll start with the state of waiting for the
    initial `$` to begin a message. When a `$` is seen, the parser transitions to
    a new state, `Header`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'When we''re in the `Header` state, we''ve seen the `$`, and we''re waiting
    for the five characters that identify the talker ("GP") and the sentence type
    (for example, "GLL"). We''ll accumulate bytes until we get five of them, and then
    transition to the `Body` state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The `Body` state is where we accumulate the bulk of the message. For some applications,
    we may want to apply additional processing on the header and transition back to
    waiting for headers when we receive a message type we don't want. This can shave
    off a little bit of processing time when dealing with devices that produce a lot
    of data.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the `*` arrives, the body is complete, and the next two bytes must be
    part of the checksum. This means transitioning to a `Checksum` state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Checksum` state is similar to accumulating bytes in the `Header` state:
    we''re waiting for a specific number of input bytes. After the checksum, most
    messages are followed by ASCII `\r` and `\n` characters. If we receive either
    of these, we transition to an `End` state where we can gracefully ignore these
    excess characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The `End` state has an additional feature: it overrides the default `valid()`
    method. For all other states, the `valid()` method is `False`. Once we''ve received
    a complete message, this state''s class definition changes the validity rule:
    we now depend on the `Message` class to compare the computed checksum with the
    final checksum bytes to tell us if the message is valid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: This state-oriented change in behavior is one of the best reasons for using
    this design pattern. Instead of a complex set of `if` conditions to decide if
    we have a complete message and it has all the right parts and punctuation marks,
    we've refactored the complexity into a number of individual states and the rules
    for transition from state to state. This leads us to only checking validity when
    we've received `$`, five characters, a body, `*`, two more characters, and confirmed
    the checksum is correct.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a test case to show how this works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: We've copied two example messages from the SiRF NMEA Reference Manual, revision
    1.3, to be sure our parsing was correct. See [https://www.sparkfun.com/products/13750](https://www.sparkfun.com/products/13750)
    for more information on GPS IoT devices. See [http://aprs.gids.nl/nmea/](http://aprs.gids.nl/nmea/)
    for additional examples and details.
  prefs: []
  type: TYPE_NORMAL
- en: It's often helpful to use state transitions when parsing complex messages because
    we can refactor the validation into individual state definitions and state transition
    rules.
  prefs: []
  type: TYPE_NORMAL
- en: State versus Strategy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The State pattern looks very similar to the Strategy pattern; indeed, the UML
    diagrams for the two are identical. The implementation, too, is identical. We
    could even have written our states as first-class functions instead of wrapping
    them in objects, as was suggested in the section on the Strategy pattern earlier
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: These two patterns are similar because they both delegate work to other objects.
    This decomposes a complex problem into several closely related but simpler problems.
  prefs: []
  type: TYPE_NORMAL
- en: The Strategy pattern is used to choose an algorithm at runtime; generally, only
    one of those algorithms is going to be chosen for a particular use case. The idea
    here is to provide an implementation choice at runtime, as late in the design
    process as possible. Strategy class definitions are rarely aware of other implementations;
    each Strategy generally stands alone.
  prefs: []
  type: TYPE_NORMAL
- en: The State pattern, on the other hand, is designed to allow switching between
    different states dynamically, as some process evolves. In our example, the state
    changed as bytes were consumed and an evolving set of validity conditions satisfied.
    State definitions are generally defined as a group with an ability to switch among
    the various state objects.
  prefs: []
  type: TYPE_NORMAL
- en: To an extent, the `End` state used to parse an NMEA message has both State pattern
    features and Strategy pattern features. Because the implementation of the `valid()`
    method is different from other states, this reflects a different strategy for
    determining the validity of a sentence.
  prefs: []
  type: TYPE_NORMAL
- en: The Singleton pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Singleton pattern is a source of some controversy; many have accused it
    of being an *anti-pattern*, a pattern that should be avoided, not promoted. In
    Python, if someone is using the Singleton pattern, they're almost certainly doing
    something wrong, probably because they're coming from a more restrictive programming
    language.
  prefs: []
  type: TYPE_NORMAL
- en: So, why discuss it at all? Singleton is useful in overly object-oriented languages
    and is a vital part of traditional object-oriented programming. More relevantly,
    the idea behind singleton is useful, even if we implement the concept in a totally
    different way in Python.
  prefs: []
  type: TYPE_NORMAL
- en: The basic idea behind the Singleton pattern is to allow exactly one instance
    of a certain object to exist. Typically, this object is a sort of manager class
    like those we discussed in *Chapter 5*, *When to Use Object-Oriented Programming*.
    Such manager objects often need to be referenced by a wide variety of other objects;
    passing references to the manager object around to the methods and constructors
    that need them can make code hard to read.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, when a singleton is used, the separate objects request the single
    instance of the manager object from the class. The UML diagram doesn''t fully
    describe it, but here it is for completeness:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table  Description automatically generated](img/B17070_11_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.9: Singleton pattern in UML'
  prefs: []
  type: TYPE_NORMAL
- en: In most programming environments, singletons are enforced by making the constructor
    private (so no one can create additional instances of it), and then providing
    a static method to retrieve the single instance. This method creates a new instance
    the first time it is called, and then returns that same instance for all subsequent
    calls.
  prefs: []
  type: TYPE_NORMAL
- en: Singleton implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Python doesn''t have private constructors, but for this purpose, we can use
    the `__new__()` class method to ensure that only one instance is ever created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'When `__new__()` is called, it normally constructs a new instance of the requested
    class. When we override it, we first check whether our singleton instance has
    been created; if not, we create it using a `super` call. Thus, whenever we call
    the constructor on `OneOnly`, we always get the exact same instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The two objects are equal and located at the same address; thus, they are the
    same object. This particular implementation isn't very transparent, since it's
    not obvious that the special method is being used to create a singleton object.
  prefs: []
  type: TYPE_NORMAL
- en: 'We don''t actually need this. Python provides two built-in Singleton patterns
    we can leverage. Rather than invent something hard to read, there are two choices:'
  prefs: []
  type: TYPE_NORMAL
- en: A Python module *is* a singleton. One `import` will create a module. All subsequent
    attempts to import the module return the one-and-only singleton instance of the
    module. In places where an application-wide configuration file or cache is required,
    make this part of a distinct module. Library modules like `logging`, `random`,
    and even `re` have module-level singleton caches. We'll look at using module-level
    variables below.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Python class definition can also be pressed into service as a singleton. A
    class can only be created once in a given namespace. Consider using a class with
    class-level attributes as a singleton object. This means defining methods with
    the `@staticmethod` decorator because there will never be an instance created,
    and there's no `self` variable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To use module-level variables instead of a complex Singleton pattern, we instantiate
    the class after we've defined it. We can improve our State pattern implementation
    from earlier on to use singleton objects for each of the states. Instead of creating
    a new object every time we change states, we can create a collection of module-level
    variables that are always accessible.
  prefs: []
  type: TYPE_NORMAL
- en: We'll make a small but very important design change, also. In the examples above,
    each state has a reference to the `Message` object that is being accumulated.
    This required us to provide the `Message` object as part of constructing a new
    `NMEA_State` object; we used code like `return Body(self.message)` to switch to
    a new state, `Body`, while working on the same `Message` instance.
  prefs: []
  type: TYPE_NORMAL
- en: If we don't want to create (and recreate) state objects, we need to provide
    the `Message` as an argument to the relevant methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the revised `NMEA_State` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'This variant on the `NMEA_State` class doesn''t have any instance variables.
    All the methods work with argument values passed in by a client. Here are the
    individual state definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Here are the module-level variables created from instances of each of these
    `NMEA_State` classes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Within each of these classes, we can refer to these five global variables to
    change parsing state. The ability to refer to a global that''s defined *after*
    the class can seem a little mysterious at first. It works out beautifully because
    Python variable names are not resolved to objects until runtime. When each class
    is being built, a name like `CHECKSUM` is little more than a string of letters.
    When evaluating the `Body.feed_byte()` method and it''s time to return the value
    of `CHECKSUM`, then the name is resolved to the singleton instance of the `Checksum()`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note how the `Header` class was refactored. In the version where each state
    has an `__init__()`, we could explicitly evaluate `Message.reset()` when entering
    the `Header` state. Since we''re not creating new state objects in this design,
    we need a way to handle the special case of entering a new state, and performing
    an `enter()` method one time only to do initialization or setup. This requirement
    leads to a small change in the `Reader` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: We don't trivially replace the value of the `self.state` instance variable with
    the result of the `self.state.feed_byte()` evaluation. Instead, we compare the
    previous value of `self.state` with the next value, `new_state`, to see if there
    was a state change. If there was a change, then we need to evaluate `enter()`
    on the new state, to allow the state change to do any required one-time initialization.
  prefs: []
  type: TYPE_NORMAL
- en: In this example we aren't wasting memory creating a bunch of new instances of
    each state object that must later be garbage collected. Instead, we are reusing
    a single state object for each piece of the incoming data stream. Even if multiple
    parsers are running at once, only these state objects need to be used. The stateful
    message data is kept separate from the state processing rules in each state object.
  prefs: []
  type: TYPE_NORMAL
- en: We've combined two patterns, each with different purposes. The State pattern
    covers how processing is completed. The Singleton pattern covers how object instances
    are managed. Many software designs involve numbers of overlapping and complementary
    patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Case study
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll review a piece of the case study we set aside in *Chapter 3*, *When Objects
    Are Alike*. We talked about the various ways to compute distances, but left part
    of the design to be filled in later. Now that we've seen some of the basic design
    patterns, we can apply some of them to our evolving case study.
  prefs: []
  type: TYPE_NORMAL
- en: Specifically, we need to put the various kinds of distance computations into
    the `Hyperparameter` class definition. In *Chapter 3*, we introduced the idea
    that the distance computation is not a single definition. There are over 50 commonly
    used distance computation alternatives, some simple, some rather complex. In *Chapter
    3*, we showed a few common ones, including Euclidean distance, Manhattan distance,
    Chebyshev distance, and even a complex-looking Sorensen distance. Each weights
    the "nearness" of the neighbors slightly differently.
  prefs: []
  type: TYPE_NORMAL
- en: 'This leads us to look at the `Hyperparameter` class as containing three important
    components:'
  prefs: []
  type: TYPE_NORMAL
- en: A reference to the base `TrainingData`. This is used to find all of the neighbors,
    from which the nearest are selected.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *k* value used to determine how many neighbors will be checked.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The distance algorithm. We'd like to be able to plug in any algorithm here.
    Our research revealed a large number of competing choices. This suggests that
    implementing one or two won't be very adaptable to real-world demands.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Plugging in the distance algorithm is a good application of the **Strategy** design
    pattern. For a given `Hyperparameter` object, `h`, the `h.distance` object has
    a `distance()` method that does the work of computing a distance. We can plug
    in any of the subclasses of `Distance` to do this work.
  prefs: []
  type: TYPE_NORMAL
- en: This means the `Hyperparameter` class' `classify()` method will use the strategy's `self.distance.distance()` to
    compute the distances. We can use this to provide alternative `distance` objects
    as well as alternative *k* values to find a combination that provides the best-quality
    classification of unknown samples.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can summarize the relationships using a UML diagram like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram  Description automatically generated](img/B17070_11_10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.10: UML diagram with Hyperparameter and Distance classes'
  prefs: []
  type: TYPE_NORMAL
- en: 'This diagram focuses on a few of the classes:'
  prefs: []
  type: TYPE_NORMAL
- en: An instance of the `Hyperparameter` class will have a reference to a `Distance` class.
    This use of the Strategy design pattern lets us create any number of subclasses
    of `Distance` with any of the algorithms found in the literature.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An instance of the `Distance` class will compute a distance between two samples.
    Researchers have designed 54 implementations. We''ll stick with a few simple ones
    shown in *Chapter 3*:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chebyshev uses `max()` to reduce four distances along each dimension to the
    single largest value.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Euclidean uses the `math.hypot()` function.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Manhattan is the sum of each distance along the four dimensions.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: An instance of the `Hyperparameter` class will also have a reference to a *k*-nearest
    neighbors `Classifier` function. This use of the Strategy design pattern lets
    us use any number of optimized classifier algorithms.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `TrainingData` object contains the original `Sample` objects, shared by the
    `Hyperparameter` objects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here''s an example of the `Distance` class definitions, defining the overall
    protocol for distance computations and the `Euclidean` implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: We've defined a `Distance` protocol so tools like **mypy** can recognize a class
    that performs a distance computation. The body of the `distance()` function is
    the Python token `...`. It really is three dots; this is not a placeholder here
    in the book, it's the token used for abstract method bodies, as we learned in
    *Chapter 6*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Manhattan and Chebyshev distances are similar to each other. The Manhattan
    distance is the sum of changes among the features, and the Chebyshev is the largest
    change among the features:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, the *k*-nearest neighbors classification can also be defined as
    a hierarchy with alternative implementation strategies. As we saw in *Chapter
    10*, *The Iterator Pattern*, there are a number of ways of performing this algorithm,
    also. We can use a simple approach with a sorted list, or a more sophisticated
    approach where we use a heap queue, or the `bisect` module as a way to cut down
    on the overheads of a large collection of neighbors. We won''t repeat all of the
    *Chapter 10* definitions, here. These are all defined as functions, and this is
    the simplest version that accumulates and sorts all of the distance computations,
    looking for the nearest *k* samples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Given these two families of the distance functions, and the overall classifier
    algorithms, we can define the `Hyperparameter` class in a way that relies on two
    plug-in Strategy objects. The class definition becomes rather small because the
    details have been factored into separate class hierarchies that we can extend
    as needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s how we can create and use a `Hyperparameter` instance. This shows how
    the strategy objects are provided to a `Hyperparameter` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: We created an instance of the `Manhattan` class, and provided this object's
    `distance()` method (the method object, not a computed distance value) to the
    `Hyperparameter` instance. We provided the `k_nn_1()` function for the nearest
    neighbor classification. The training data is a sequence of four `KnownSample`
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: We have a subtle distinction between the distance function, which has a direct
    impact on how well classification works, and the classifier algorithm, which is
    a minor performance optimization. We can argue that these are not really peers,
    and perhaps we have piled too many features into one class. We don't really need
    to test the quality of the classifier algorithm; instead, we only need to test
    the performance.
  prefs: []
  type: TYPE_NORMAL
- en: This tiny example does, correctly, locate the nearest neighbor to the given
    unknown sample. As a practical matter, we need a more sophisticated testing capability
    to examine all samples of a test dataset.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can add the following method to the `Hyperparameter` class defined above:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: This `test()` method for a given `Hyperparameter` can apply the `classify()`
    method to all of the given samples in the test set. The ratio of correctly classified
    test samples to the total number of tests is one way to measure the overall quality
    of this specific combination of parameters.
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of combinations of hyperparameters, and the Command design
    pattern can be used to create a number of test commands. Each of these command
    instances would contain the values required to create and test a unique `Hyperparameter`
    object. We can create a large collection of these Commands to perform a comprehensive
    hyperparameter tuning.
  prefs: []
  type: TYPE_NORMAL
- en: 'The essential command creates a `Timing` object when it is executed. The `Timing`
    object is a summary of the results of a test, and looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: The test command is given a `Hyperparameter` and a reference to the test data.
    This can be used, later, to actually gather the tuning results. The use of the
    Command design pattern makes it possible to separate creating the commands from
    executing the commands. This separation can be helpful for understanding what's
    going on. It may also be necessary when there is one-time setup processing that
    we don›t want to measure when comparing the performance of various algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s our `TestCommand` class definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: The constructor saves the `Hyperparameter` and testing samples list. When the
    `test()` method is evaluated, the test is run, and a `Timing` object is created.
    For this very small dataset, the tests run very quickly. For larger and more complex
    datasets, the hyperparameter tuning can run for hours.
  prefs: []
  type: TYPE_NORMAL
- en: Here's a function to build and then execute a suite of `TestCommand` instances.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: This function loads the raw data and will partition the data as well. This code
    is essentially the subject of *Chapter 9*, *Strings, Serialization, and File Paths*.
    It creates a number of `TestCommand` objects for many combinations of *k*, distance,
    and classifier functions, saving these in the `scenarios` list.
  prefs: []
  type: TYPE_NORMAL
- en: After all the command instances have been created, it executes all of the objects,
    saving the results in the `timings` list. The results are displayed, to help us
    locate the optimal hyperparameter set.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve used the Strategy and the Command design patterns as part of building
    the tuning function. The three distance computation classes are good candidates
    for a Singleton-like class design: we only need one instance of each of these
    objects. Having a language for describing a design, via design patterns, can make
    it easier to describe a design to other developers.'
  prefs: []
  type: TYPE_NORMAL
- en: Recall
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The world of software design is full of good ideas. The really good ideas get
    repeated and form repeatable patterns. Knowing – and using – these patterns of
    software design can save the developer from burning a lot of brain calories trying
    to reinvent something that''s been developed already. In this chapter, we looked
    at a few of the most common patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: The Decorator pattern is used in the Python language to add features to functions
    or classes. We can define decorator functions and apply them directly, or use
    the `@` syntax to apply a decorator to another function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Observer pattern can simplify writing GUI applications. It can also be used
    in non-GUI applications to formalize relationships between objects that change
    state, and objects that display or summarize or otherwise use the state information.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Strategy pattern is central to a lot of object-oriented programming. We
    can decompose large problems into containers with the data and strategy objects
    that help with processing the data. The Strategy object is a kind of "plug-in"
    to another object. This gives us ways to adapt, extend, and improve processing
    without breaking all the code we wrote when we make a change.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Command pattern is a handy way to summarize a collection of changes that
    are applied to other objects. It's really helpful in a web services context where
    external commands arrive from web clients.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The State pattern is a way to define processing where there's a change in state
    and a change in behavior. We can often push unique or special-case processing
    into state-specific objects, leveraging the Strategy pattern to plug in state-specific
    behavior.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Singleton pattern is used in the rare cases where we need to be sure there
    is one and only one of a specific kind of object. It's common, for example, to
    limit an application to exactly one connection to a central database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These design patterns help us organize complex collections of objects. Knowing
    a number of patterns can help the developer visualize a collection of cooperating
    classes, and allocate their responsibilities. It can also help developers talk
    about a design: when they''ve both read the same books on design patterns, they
    can refer to the patterns by name and skip over long descriptions.'
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While writing the examples for this chapter, the authors discovered that it
    can be very difficult, and extremely educational, to come up with good examples
    where specific design patterns *should* be used. Instead of going over current
    or old projects to see where you can apply these patterns, as we've suggested
    in previous chapters, think about the patterns and different situations where
    they might come up. Try to think outside your own experiences. If your current
    projects are in the banking business, consider how you'd apply these design patterns
    in a retail or point-of-sale application. If you normally write web applications,
    think about using design patterns while writing a compiler.
  prefs: []
  type: TYPE_NORMAL
- en: Look at the Decorator pattern and come up with some good examples of when to
    apply it. Focus on the pattern itself, not the Python syntax we discussed. It's
    a bit more general than the actual pattern. The special syntax for decorators
    is, however, something you may want to look for places to apply in existing projects
    too.
  prefs: []
  type: TYPE_NORMAL
- en: What are some good areas to use the Observer pattern? Why? Think about not only
    how you'd apply the pattern, but how you would implement the same task without
    using Observer. What do you gain, or lose, by choosing to use it?
  prefs: []
  type: TYPE_NORMAL
- en: Consider the difference between the Stategy and State patterns. Implementation-wise,
    they look very similar, yet they have different purposes. Can you think of cases
    where the patterns could be interchanged? Would it be reasonable to redesign a
    State-based system to use Strategy instead, or vice versa? How different would
    the design actually be?
  prefs: []
  type: TYPE_NORMAL
- en: In the dice-rolling example, we parsed a simple expression to create a few commands.
    There are more options possible. See [https://help.roll20.net/hc/en-us/articles/360037773133-Dice-Reference#DiceReference-Roll20DiceSpecification](https://help.roll20.net/hc/en-us/articles/360037773133-Dice-Reference#DiceReference-Roll20DiceSpecif)
    for some really sophisticated syntax for describing dice and dice games. To implement
    this, there are two changes that need to be made. First, design the command hierarchy
    for all of these options. After that, write a regular expression to parse a more
    complex dice-rolling expression and execute all of the commands present.
  prefs: []
  type: TYPE_NORMAL
- en: We've noted that Singleton objects can be built using Python module variables.
    It's sometimes helpful to compare the performance of the two different NMEA message
    processors. If you don't have a GPS chip with a USB interface laying around, you
    can search the internet for NMEA example messages to parse. [http://aprs.gids.nl/nmea/](http://aprs.gids.nl/nmea/)
    is a good source of examples. There's a trade-off question between the potential
    confusion of module variables and the performance of the application. It's helpful
    to have data to support the lessons you've learned.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter discussed several common design patterns in detail, with examples,
    UML diagrams, and a discussion of the differences between Python and statically
    typed object-oriented languages. The Decorator pattern is often implemented using
    Python's more generic decorator syntax. The Observer pattern is a useful way to
    decouple events from actions taken on those events. The Strategy pattern allows
    different algorithms to be chosen to accomplish the same task. The Command pattern
    helps us design active classes that share a common interface but carry out distinct
    actions. The State pattern looks similar to the Strategy pattern but is used instead
    to represent systems that can move between different states using well-defined
    actions. The Singleton pattern, popular in some statically typed languages, is
    almost always an anti-pattern in Python.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll wrap up our discussion of design patterns.
  prefs: []
  type: TYPE_NORMAL
