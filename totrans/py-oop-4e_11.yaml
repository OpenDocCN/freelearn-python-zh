- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Common Design Patterns
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见设计模式
- en: In the previous chapter, we were briefly introduced to design patterns, and
    covered the iterator pattern, a pattern so useful and common that it has been
    abstracted into the core of the programming language itself. In this chapter,
    we'll be reviewing other common patterns and how they are implemented in Python.
    As with iteration, Python often provides an alternative syntax to make working
    with such problems simpler. We will cover both the *traditional* design, and the
    Python version for these patterns.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们简要介绍了设计模式，并涵盖了迭代器模式，这是一个如此有用且常见的模式，以至于它被抽象成了编程语言的核心。在本章中，我们将回顾其他常见模式以及它们在Python中的实现方式。与迭代一样，Python经常提供一种替代语法来简化这类问题的处理。我们将涵盖这些模式的**传统**设计和Python版本。
- en: 'In this chapter, we''ll see:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看到：
- en: The Decorator pattern
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 装饰者模式
- en: The Observer pattern
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 观察者模式
- en: The Strategy pattern
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 策略模式
- en: The Command pattern
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令模式
- en: The State pattern
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态模式
- en: The Singleton pattern
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单例模式
- en: This chapter's case study will emphasize how the distance calculation is an
    example of the Strategy design pattern, and how we can leverage abstract base
    classes to design a variety of distance computations that can be compared to see
    which produces the most useful results.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的案例研究将强调距离计算是如何成为策略设计模式的一个例子，以及我们如何利用抽象基类来设计各种距离计算方法，这些方法可以进行比较，以确定哪种方法产生的结果最有用。
- en: 'Consistent with the practice in *Design Patterns: Elements of Reusable Object-Oriented
    Software*, we''ll capitalize the pattern names. This can help them stand out from
    ordinary English usage.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 与《设计模式：可复用面向对象软件元素》中的实践一致，我们将首字母大写模式名称。这有助于它们在普通英语用法中脱颖而出。
- en: We'll start with the Decorator pattern. This is used to combine different kinds
    of functionality into a single resulting object.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从装饰者模式开始。这种模式用于将不同种类的功能组合成一个单一的结果对象。
- en: The Decorator pattern
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 装饰者模式
- en: The Decorator pattern allows us to *wrap* an object that provides core functionality
    with other objects that alter this functionality. Any object that uses the decorated
    object will interact with it in exactly the same way as if it were undecorated
    (that is, the interface of the decorated object is identical to that of the core
    object).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器模式允许我们用其他对象来**包装**一个提供核心功能的对象，从而改变这个功能。任何使用装饰对象的对象都将与它以完全相同的方式交互，就像它没有被装饰一样（也就是说，装饰对象的外界接口与核心对象相同）。
- en: 'There are two primary uses of the Decorator pattern:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰者模式主要有两种用途：
- en: Enhancing the response of a component as it sends data to a second component
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提高组件在向第二个组件发送数据时的响应能力
- en: Supporting multiple optional behaviors
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持多种可选行为
- en: 'The second option is often a suitable alternative to multiple inheritance.
    We can construct a core object, and then create a decorator wrapping that core.
    Since the decorator object has the same interface as the core object, we can even
    wrap the new object in other decorators. Here''s how it looks in a UML diagram:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种选择通常是多重继承的一个合适替代方案。我们可以构建一个核心对象，然后创建一个装饰器来包装这个核心。由于装饰器对象与核心对象具有相同的接口，我们甚至可以在新对象上再包装其他装饰器。下面是它在UML图中的样子：
- en: '![Diagram  Description automatically generated](img/B17070_11_01.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图表描述自动生成](img/B17070_11_01.png)'
- en: 'Figure 11.1: Decorator pattern in UML'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.1：UML 中的装饰器模式
- en: Here, **Core** and all the decorators implement a specific **Interface**. The
    dashed lines show "implements" or "realizes." The decorators maintain a reference
    to the core instance of that **Interface** via composition. When called, the decorator
    does some added processing before or after calling its wrapped interface. The
    wrapped object may be another decorator, or the core functionality. While multiple
    decorators may wrap each other, the object at the end of the chain of all those
    decorators provides the core functionality.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，**核心**及其所有装饰器实现了一个特定的**接口**。虚线表示“实现”或“实现”。装饰器通过组合维护对该**接口**核心实例的引用。当被调用时，装饰器在其包装的接口调用前后执行一些额外的处理。包装的对象可能是另一个装饰器，或者是核心功能。虽然多个装饰器可以相互包装，但所有这些装饰器链末尾的对象提供了核心功能。
- en: It's essential that each of these is providing an implementation of a common
    feature. The intent is to provide a composition of processing steps from the various
    decorators, applied to the core. Often decorators are small, typically a function
    definition without any state.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 每个这些都必须提供一个公共功能的实现。目的是提供从各种装饰器中组合的处理步骤，应用于核心。通常装饰器很小，通常是一个没有状态的函数定义。
- en: In Python, because of duck typing, we don't need to formalize these relationships
    with an official abstract interface definition. It's sufficient to make sure the
    classes have matching methods. In some cases, we may define a `typing.Protocol`
    as a type hint to help **mypy** reason about the relationships.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，由于鸭子类型，我们不需要通过官方的抽象接口定义来正式化这些关系。确保类有匹配的方法就足够了。在某些情况下，我们可能定义一个`typing.Protocol`作为类型提示，以帮助**mypy**推理这些关系。
- en: A Decorator example
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 装饰器示例
- en: Let's look at an example from network programming. We want to build a small
    server that provides some data and a client that interacts with that server. The
    server will be simulating rolling complex handfuls of dice. The client will request
    a handful and wait for an answer that contains some random numbers.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个网络编程的例子。我们想要构建一个小型服务器，它提供一些数据，并且有一个客户端与之交互。服务器将模拟掷出复杂的一把把骰子。客户端将请求一把骰子并等待包含一些随机数的回答。
- en: This example has two processes interacting via a TCP socket, a way to transmit
    bytes among computer systems. Sockets are created by a server that listens for
    connections. When a client attempts to connect to the socket, the server must
    accept the new connection, and the two processes can then pass bytes back and
    forth; for this example, there will be a request from client to server and a response
    from server to client. The TCP socket is part of the foundation for HTTP, around
    which the world wide web is built.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子中有两个进程通过TCP套接字进行交互，这是一种在计算机系统之间传输字节的方式。套接字是由一个监听连接的服务器创建的。当客户端尝试连接到套接字时，服务器必须接受新的连接，然后两个进程就可以相互传递字节；在这个例子中，将会有客户端向服务器发送请求和服务器向客户端发送响应。TCP套接字是HTTP的基础部分，整个万维网都是围绕它构建的。
- en: 'The client and server processes will use the `socket.send()` method to transmit
    a string of bytes through the socket. They''ll also use `socket.recv()` to receive
    bytes. We''ll start with an interactive server that waits for a connection from
    a client and then responds to the request. We''ll call this module `socket_server.py`.
    Here''s the general outline:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端和服务器进程将使用 `socket.send()` 方法通过套接字传输一串字节。他们还将使用 `socket.recv()` 来接收字节。我们将从一个交互式服务器开始，该服务器等待来自客户端的连接，然后响应用户请求。我们将把这个模块命名为
    `socket_server.py`。以下是总体概述：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `server` is bound to the "public" socket, using a more or less arbitrary
    port number of `2401`. This is where the server is listening for connection requests.
    When a client tries to connect to this socket, a child socket is created so the
    client and server can talk, leaving the public socket ready for more connections.
    A web server will often use multiple threads to allow a large number of concurrent
    sessions. We're not using threads, and a second client has to wait until the server
    is done with the first client. It's a coffee shop queue with exactly one barista
    making espressos.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器绑定到“公共”套接字，使用大约随机的端口号`2401`。这就是服务器监听连接请求的地方。当客户端尝试连接到这个套接字时，会创建一个子套接字，以便客户端和服务器可以进行通信，同时保持公共套接字为更多连接做好准备。一个网络服务器通常会使用多个线程来允许大量并发会话。我们并没有使用线程，第二个客户端必须等待服务器完成与第一个客户端的通信。这就像是一家只有一个咖啡师制作浓缩咖啡的咖啡馆队列。
- en: (Note that TCP/IP sockets have both a host address and a port number. The port
    number must be above `1023`. Port numbers `1023` and below are reserved and require
    special OS privileges. We chose port `2401` because it doesn't seem to be used
    for anything else.)
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: （请注意，TCP/IP套接字既有主机地址也有端口号。端口号必须大于`1023`。端口号`1023`以下是被保留的，并且需要特殊的操作系统权限。我们选择端口号`2401`，因为它似乎没有被用于其他任何事情。）
- en: 'The `dice_response()` function does all the real work of our service. It accepts
    a `socket` parameter so it can respond to the client. It reads bytes with a client
    request, creates a response, then sends it. In order to handle exceptions gracefully,
    the `dice_response()` function looks like this:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`dice_response()` 函数执行了我们服务的大部分实际工作。它接受一个 `socket` 参数，以便能够响应用户。它读取客户端请求的字节，创建响应，然后发送。为了优雅地处理异常，`dice_response()`
    函数看起来是这样的：'
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We''ve wrapped another function, `dice_roller()`, in an exception handler.
    This is a common pattern to separate error-handling and other overheads from the
    real work of computing a dice roll and responding to the client with useful numbers
    for their role-playing game:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将另一个函数`dice_roller()`封装在异常处理程序中。这是一种常见的模式，用于将错误处理和其他开销与计算骰子滚动并响应客户端以提供他们角色扮演游戏的有用数字的实际工作分离：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This isn't too sophisticated. We'll expand on this in the section on *The Command
    pattern* later in this chapter. For now, however, it will provide a sequence of
    random numbers.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不复杂。我们将在本章后面的*命令模式*部分对此进行扩展。然而，目前它将提供一个随机数的序列。
- en: Note that we're not really doing anything with the `request` object that came
    from the client. For the first few examples, we'll be reading these bytes and
    ignoring them. The `request` is a placeholder for a more complex request describing
    how many dice to roll and how many times to roll them.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们实际上并没有对来自客户端的`request`对象做任何操作。在最初的几个例子中，我们将读取这些字节并忽略它们。`request`是一个占位符，用于描述一个更复杂的请求，包括需要掷多少个骰子和掷多少次。
- en: We can leverage the Decorator design pattern to add features. The decorator
    will be wrapping the core `dice_response()` function, which is given a `socket`
    object that it can read and write. To make use of the design pattern, it's important
    to exploit the way this function relies on the `socket.send()` and `socket.recv()`
    methods when we add features. We need to preserve the interface definition as
    we add decorations.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用装饰器设计模式来添加功能。装饰器将包装核心的`dice_response()`函数，该函数接收一个`socket`对象，它可以读取和写入。为了利用设计模式，重要的是要利用这个函数在添加功能时依赖的`socket.send()`和`socket.recv()`方法。在添加装饰时，我们需要保留接口定义。
- en: 'To test the server, we can write a very simple client that connects to the
    same port and outputs the response before exiting:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试服务器，我们可以编写一个非常简单的客户端，该客户端连接到相同的端口并在退出前输出响应：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This client asks two questions and creates a fairly complex-looking string,
    `command`, that contains a count and dice-rolling pattern. Right now, the server
    doesn't use this command. This is a teaser for a more sophisticated dice roller.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这个客户端提出了两个问题并创建了一个看起来相当复杂的字符串，`command`，其中包含一个计数和掷骰子模式。目前，服务器还没有使用这个命令。这是一个更高级掷骰子器的预告。
- en: 'To use these two separate applications, follow these steps:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这两个独立的应用程序，请按照以下步骤操作：
- en: Open two terminal windows, side by side. (It can help to change the window titles
    to "client" and "server". Users of macOS Terminal can use the **change title**
    item in the **shell** menu. Windows users can use the `title` command.)
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开两个并排的终端窗口。（将窗口标题更改为“客户端”和“服务器”可能会有帮助。macOS 终端用户可以在**shell**菜单中使用**更改标题**项。Windows
    用户可以使用`title`命令。）
- en: 'In the server window, start the server application:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在服务器窗口中，启动服务器应用程序：
- en: '[PRE4]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In the client window, start the client application:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在客户端窗口中，启动客户端应用程序：
- en: '[PRE5]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Enter your responses to the prompts in the client window. For example:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在客户端窗口中输入您的响应。例如：
- en: '[PRE6]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The client will send the command, read the response, print it to the console,
    and exit. Run the client as many times as you want to get a sequence of dice rolls.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端将发送命令，读取响应，将其打印到控制台，然后退出。你可以多次运行客户端以获取一系列骰子滚动结果。
- en: 'The result will look something like this:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 结果看起来可能像这样：
- en: '![Text  Description automatically generated](img/B17070_11_02.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![文本描述自动生成](img/B17070_11_02.png)'
- en: 'Figure 11.2: Server and client'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.2：服务器和客户端
- en: On the left side is the server. We started the application, and it started listening
    on port `2401` for clients. On the right side is the client. Each time we run
    the client, it connects to the public socket; the connection operation creates
    a child socket that can be used for the rest of the interaction. The client sends
    a command the server responds to that command, and the client prints it.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在左侧是服务器。我们启动了应用程序，它开始监听端口`2401`以接收客户端连接。在右侧是客户端。每次运行客户端时，它都会连接到公共套接字；连接操作会创建一个子套接字，该套接字可以用于后续的交互。客户端发送一个命令，服务器响应该命令，然后客户端将其打印出来。
- en: Now, looking back at our server code, we see two sections. The `dice_response()`
    function reads data and sends data back to the client via a `socket` object. The
    remaining script is responsible for creating that `socket` object. We'll create
    a pair of decorators that customize the socket behavior without having to extend
    or modify the socket itself.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，回顾我们的服务器代码，我们看到有两个部分。`dice_response()` 函数读取数据并通过一个 `socket` 对象将数据发送回客户端。剩余的脚本负责创建那个
    `socket` 对象。我们将创建一对装饰器，以自定义 `socket` 的行为，而无需扩展或修改 `socket` 本身。
- en: 'Let''s start with a *logging* decorator. This object outputs any data being
    sent to the server''s console before it sends it to the client:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从**日志**装饰器开始。这个对象在将数据发送到客户端之前，将其输出到服务器的控制台：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This class decorates a `socket` object and presents the `send()`, `recv()`,
    and `close()` interface to clients using it. A better decorator could properly
    implement all of the arguments to `send`, (which actually accepts an optional
    flags argument), but let's keep our example simple. Whenever `send()` is called
    on an instance of the `LogSocket` class, it logs the output to the screen before
    sending data to the client using the original socket. Similarly, for `recv()`,
    it reads and logs the data it received.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类装饰了一个`socket`对象，并为使用它的客户端提供了`send()`、`recv()`和`close()`接口。一个更好的装饰器可以正确实现`send`函数的所有参数（实际上它接受一个可选的标志参数），但让我们保持示例简单。每当在`LogSocket`类的实例上调用`send()`时，它会在使用原始套接字向客户端发送数据之前将输出记录到屏幕上。同样，对于`recv()`，它读取并记录接收到的数据。
- en: 'We only have to change one line in our original code to use this decorator.
    Instead of calling the `dice_response()` function with the original client socket,
    we call it with a decorated socket:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需在我们的原始代码中更改一行即可使用这个装饰器。而不是用原始客户端套接字调用`dice_response()`函数，我们用装饰过的套接字来调用它：
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We've decorated the core `socket` with a `LogSocket`. The `LogSocket` will print
    to the console as well as invoking methods of the socket it decorates. The essential
    processing in the `dice_response()` function doesn't change, because the `LogSocket`
    instance behaves like the underlying `socket` object.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经用`LogSocket`装饰了核心`socket`。`LogSocket`不仅会将信息打印到控制台，还会调用它所装饰的`socket`对象的方法。`dice_response()`函数中的基本处理没有改变，因为`LogSocket`实例的行为就像底层的`socket`对象一样。
- en: 'Note that we needed to use an explicit `cast()` to tell **mypy** the `LogSocket`
    instance would provide a similar interface to an ordinary `socket`. For a simple
    case like this, we have to ask ourselves why we didn''t just extend the `socket` class
    and override the `send` method. A subclass could call `super().send()` and `super().recv()` to
    do the actual sending, after we logged it. Decoration offers an advantage over
    inheritance: a decoration can be reused among various classes in various class
    hierarchies. In this specific little example, there aren''t too many socket-like
    objects, so the possibilities of reuse are limited.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们需要使用显式的 `cast()` 来告诉 **mypy**，`LogSocket` 实例将提供一个类似于普通 `socket` 的接口。对于这样一个简单的例子，我们不得不问自己，为什么我们不去扩展
    `socket` 类并重写 `send` 方法。子类可以在记录之后调用 `super().send()` 和 `super().recv()` 来执行实际的发送操作。装饰器比继承提供了一种优势：装饰器可以在不同的类层次结构中的各种类之间重用。在这个具体的例子中，类似
    `socket` 的对象并不多，因此重用的可能性有限。
- en: If we switch our focus to something more generic than a `socket`, we can create
    potentially reusable decorators. Processing strings or bytes seems more common
    than processing a `socket`. Changing the structure can give us some desirable
    flexibility in addition to reuse potential. Originally, we broke the processing
    into a `dice_response()` function that handled the socket reading and writing,
    separate from a `dice_roller()` function that works with bytes. Because the `dice_roller()`
    function consumes the request bytes and produces response bytes, it can be a little
    simpler to expand and add features to it.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将焦点转向比`socket`更通用的东西，我们可以创建潜在的可重用装饰器。处理字符串或字节似乎比处理`socket`更常见。改变结构可以给我们带来一些期望的灵活性，同时也有重用的潜力。最初，我们将处理分解为一个`dice_response()`函数，该函数处理socket的读写操作，与一个`dice_roller()`函数分开，后者与字节一起工作。因为`dice_roller()`函数消耗请求字节并生成响应字节，所以它可能更容易扩展并添加功能。
- en: 'We can have a family of related decorators. We can decorate already decorated
    objects. The idea is to give ourselves flexibility through composition. Let''s
    rework the logging decorator to focus on the bytes request and response instead
    of the `socket` object. The following should look similar to the earlier example
    but with some code shifted around to reside in a single `__call__()` method:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以有一个相关的装饰器家族。我们可以装饰已经装饰过的对象。这个想法是通过组合来赋予我们灵活性。让我们重新设计日志装饰器，使其专注于字节请求和响应，而不是`socket`对象。以下应该与之前的示例类似，但部分代码已移动到单个`__call__()`方法中：
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Here''s a second decorator that compresses data using `gzip` compression on
    the resulting bytes:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个使用`gzip`压缩对结果字节进行压缩的第二个装饰器：
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This decorator compresses the incoming data before sending it on to the client.
    It decorates an underlying `dice_roller` object that computes a response to a
    request.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 此装饰器在将数据发送到客户端之前对其进行压缩。它装饰了一个底层的`dice_roller`对象，该对象用于计算对请求的响应。
- en: 'Now that we have these two decorators, we can write code that piles one decoration
    on top of another:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了这两个装饰器，我们可以编写代码，将一个装饰器堆叠在另一个装饰器之上：
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The intent here is to separate three aspects of this application:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 此处的目的是将此应用的三个方面分开：
- en: Zipping the resulting document
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 压缩生成的文档
- en: Writing a log
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写日志
- en: Doing the underlying computation
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进行底层计算
- en: 'We can apply the zip or logging to any similar application that works with
    receiving and sending bytes. We can, if we want, make the zipping operation a
    dynamic choice, also. We might have a separate configuration file to enable or
    disable the GZip feature. This means something like the following:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将压缩或日志记录应用于任何处理接收和发送字节的类似应用程序。如果我们愿意，还可以将压缩操作作为一个动态选择。我们可能有一个单独的配置文件来启用或禁用GZip功能。这意味着类似于以下内容：
- en: '[PRE12]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We have a dynamic set of decorations. Try writing this using a multiple inheritance
    mixin and see how confused it becomes!
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一套动态的装饰。试着用多重继承混入（mixin）来实现这个功能，看看它会变得多么混乱！
- en: Decorators in Python
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python 中的装饰器
- en: The Decorator pattern is useful in Python, but there are additional options.
    For example, we can use monkey-patching – changing the class definition at runtime
    – to get a similar effect. For example, `socket.socket.send = log_send` will change
    the way the built-in socket works. There are sometimes surprising implementation
    details that can make this unpleasantly complex. Single inheritance, where the
    *optional* calculations are done in one large method with a bunch of `if` statements,
    could be an option. Multiple inheritance should not be written off just because
    it's not suitable for the specific example seen previously.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器模式在Python中很有用，但还有其他选择。例如，我们可以使用猴子补丁（在运行时更改类定义）来达到类似的效果。例如，`socket.socket.send
    = log_send` 将改变内置socket的工作方式。有时会有一些令人惊讶的实现细节，这可能会使事情变得不愉快地复杂。单继承，其中*可选*的计算在一个大方法中通过一系列`if`语句完成，可能是一个选择。多重继承不应该因为之前看到的特定示例不适合而被放弃。
- en: In Python, it is very common to use this pattern on functions. As we saw in
    a previous chapter, functions are objects too. In fact, function decoration is
    so common that Python provides a special syntax to make it easy to apply such
    decorators to functions.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，在函数上使用这种模式非常常见。正如我们在前一章中看到的，函数也是对象。实际上，函数装饰如此普遍，以至于Python提供了一种特殊的语法，以便于将这样的装饰器应用于函数。
- en: 'For example, we can look at the logging example in a more general way. Instead
    of logging only send calls on sockets, we may find it helpful to log all calls
    to certain functions or methods. The following example implements a decorator
    that does just this:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以更一般性地看待日志记录的例子。除了只在套接字上记录发送调用之外，我们可能会发现记录对某些函数或方法的全部调用是有帮助的。以下示例实现了一个装饰器，它正是这样做的：
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This decorator function is very similar to the example we explored earlier;
    in the earlier examples, the decorator took a socket-like object and created a
    socket-like object. This time, our decorator takes a function object and returns
    a new function object. We''ve provided a type hint of `Callable[..., Any]` to
    state that any function will work here. This code comprises three separate tasks:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这个装饰器函数与我们之前探讨的例子非常相似；在之前的例子中，装饰器接受一个类似于套接字的对象并创建一个类似的套接字对象。这次，我们的装饰器接受一个函数对象并返回一个新的函数对象。我们提供了类型提示`Callable[...,
    Any]`来表明任何函数都可以在这里使用。这段代码包含三个独立任务：
- en: A function, `log_args()`, that accepts another function, `function`, as a parameter
    value.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个接受另一个函数`function`作为参数值的函数，`log_args()`。
- en: This function defines (internally) a new function, named `wrapped_function`,
    that does some extra work before calling the original function and returning the
    results from the original function.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此函数（内部）定义了一个新函数，命名为`wrapped_function`，在调用原始函数并返回原始函数的结果之前，它会做一些额外的工作。
- en: The new inner function, `wrapped_function()`, is returned from the decorator
    function.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的内联函数，`wrapped_function()`，由装饰器函数返回。
- en: Because we're using `@wraps(function)`, the new function will have a copy of
    the original function's name and the original function's docstring. This avoids
    having all of the functions we decorate wind up named `wrapped_function`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们在使用 `@wraps(function)`，新的函数将拥有原始函数的名称和原始函数的文档字符串。这避免了所有我们装饰的函数最终都命名为 `wrapped_function`。
- en: 'Here''s a sample function to demonstrate the decorator in use:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个示例函数来展示装饰器的使用：
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This function can be decorated and used like this:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数可以被装饰并这样使用：
- en: '[PRE15]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This syntax allows us to build decorated function objects dynamically, just
    as we did with the socket example. If we don't use assignment to assign the new
    object to the old name, we can even keep the decorated and the non-decorated versions
    for different situations. We could use a statement like `test1_log = log_args(test1)`
    to create a second, decorated version of the `test1()` function, named `test1_log()`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这种语法使我们能够动态地构建装饰过的函数对象，就像我们在套接字示例中所做的那样。如果我们不使用赋值来将新对象分配给旧名称，我们甚至可以保留装饰过的和非装饰过的版本以适应不同的情况。我们可以使用类似
    `test1_log = log_args(test1)` 的语句来创建 `test1()` 函数的第二个装饰版本，命名为 `test1_log()`。
- en: Typically, these decorators are general modifications that are applied permanently
    to different functions. In this situation, Python supports a special syntax to
    apply the decorator at the time the function is defined. We've already seen this
    syntax in a few places; now, let's understand how it works.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这些装饰器是对不同函数进行永久性修改的通用修改。在这种情况下，Python 支持一种特殊的语法，可以在定义函数时应用装饰器。我们已经在几个地方看到了这种语法；现在，让我们了解它是如何工作的。
- en: 'Instead of applying the decorator function after the method definition, we
    can use the `@decorator` syntax to do it all at once:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在方法定义之后应用装饰器函数，也可以使用`@decorator`语法一次性完成：
- en: '[PRE16]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The primary benefit of this syntax is that we can easily see that the function
    has been decorated whenever we read the function definition. If the decorator
    is applied later, someone reading the code may miss that the function has been
    altered at all. Answering a question like *Why is my program logging function
    calls to the console?* can become much more difficult! However, the syntax can
    only be applied to functions we define, since we don't have access to the source
    code of other modules. If we need to decorate functions that are part of somebody
    else's third-party library, we have to use the earlier syntax.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这种语法的首要好处是，每次我们阅读函数定义时，都能轻松地看到函数已经被装饰了。如果装饰器是在之后应用的，阅读代码的人可能会错过函数已经被修改的事实。回答像“为什么我的程序会将函数调用记录到控制台？”这样的问题可能会变得困难得多！然而，这种语法只能应用于我们定义的函数，因为我们没有访问其他模块源代码的权限。如果我们需要装饰属于他人第三方库中的函数，我们必须使用早期的语法。
- en: 'Python''s decorators permit parameters, also. One of the most useful decorators
    in the standard library is `functools.lru_cache`. The idea of a cache is to save
    computed results of a function to avoid recomputing them. Rather than save all
    of the parameters and results, we can keep the cache small by discarding the **least
    recently used** (**LRU**) values. For example, here''s a function that involves
    a potentially expensive computation:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Python的装饰器也允许参数。标准库中最有用的装饰器之一是`functools.lru_cache`。缓存的想法是将函数的计算结果保存下来，以避免重新计算。我们不必保存所有参数和结果，可以通过丢弃**最近最少使用**（**LRU**）的值来保持缓存的大小。例如，以下是一个涉及可能昂贵的计算的功能：
- en: '[PRE17]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We can use the `lru_cache` decorator to avoid doing this computation once the
    answer is known. Here''s the small change required:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`lru_cache`装饰器来避免在已知答案后重复进行此计算。这里需要做的微小改动是：
- en: '[PRE18]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The parameterized decorator, `@lru_cache(64)`, used to create this second version
    of the `binom()` function means it will save the most recent 64 results to avoid
    recomputing values when they've already been computed once. No change is needed
    elsewhere in the application. Sometimes, the speedup from this small change can
    be dramatic. We can, of course, fine-tune the size of the cache based on the data
    and the number of computations that are being performed.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 参数化装饰器 `@lru_cache(64)` 用于创建 `binom()` 函数的第二个版本，意味着它会保存最近的 64 个结果以避免在值已经被计算过一次时重新计算。在应用程序的其他地方不需要做任何更改。有时，这种小改动带来的加速效果可能是显著的。当然，我们可以根据数据和正在进行的计算数量来微调缓存的大小。
- en: Parameterized decorators like this involve a two-step dance. First, we customize
    the decorator with the parameter, then we apply that customized decorator to a
    function definition. These two separate steps parallel the way callable objects
    are initialized with the `__init__()` method, and can be called, like a function,
    via their `__call__()` method.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 像这样的参数化装饰器涉及两步舞。首先，我们使用参数自定义装饰器，然后我们将这个自定义装饰器应用到函数定义上。这两个独立的步骤与通过`__init__()`方法初始化可调用对象的方式相平行，并且可以通过它们的`__call__()`方法像函数一样被调用。
- en: 'Here''s an example of a configurable logging decorator, `NamedLogger`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个可配置的日志装饰器的示例，`NamedLogger`：
- en: '[PRE19]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `__init__()` method makes sure we can use code like `NamedLogger("log4")`
    to create a decorator; this decorator will make sure the function that follows
    uses a specific logger.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`__init__()` 方法确保我们可以使用类似 `NamedLogger("log4")` 的代码来创建一个装饰器；这个装饰器将确保随后的函数使用特定的记录器。'
- en: 'The `__call__()` method follows the pattern shown above. We define a new function,
    `wrapped_function()`, that does the work, and return that newly minted function.
    We can use it like this:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`__call__()` 方法遵循上述模式。我们定义一个新的函数，`wrapped_function()`，来完成这项工作，并返回这个新创建的函数。我们可以这样使用它：'
- en: '[PRE20]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We've created an instance of the `NamedLogger` class. Then we applied this instance
    to the `test4()` function definition. The `__call__()` method is invoked, and
    will create a new function, the decorated version of the `test4()` function.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了一个`NamedLogger`类的实例。然后我们将这个实例应用于`test4()`函数定义。调用`__call__()`方法，将创建一个新的函数，即`test4()`函数的装饰版本。
- en: There are a few more use cases for the decorator syntax. For example, when a
    decorator is a method of a class, it can also save information about the decorated
    function, creating a registry of decorated functions. Further, classes can also
    be decorated; in that case, the decorator returns a new class instead of a new
    function. In all of these more advanced cases, we're using ordinary object-oriented
    design with the simpler-looking syntax of `@decorator`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器语法还有一些其他的使用场景。例如，当一个装饰器是类的一个方法时，它还可以保存关于被装饰函数的信息，创建一个被装饰函数的注册表。此外，类也可以被装饰；在这种情况下，装饰器返回一个新的类而不是一个新的函数。在所有这些更高级的案例中，我们使用的是普通的面向对象设计，但语法看起来更简单，即使用`@decorator`。
- en: The Observer pattern
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 观察者模式
- en: The Observer pattern is useful for state monitoring and event handling situations.
    This pattern allows a given object to be monitored by an unknown and dynamic group
    of *observer* objects. The core object being observed needs to implement an interface
    that makes it *observable*.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者模式适用于状态监控和事件处理场景。此模式允许一个特定对象被一个未知且动态的观察者对象组监控。被观察的核心对象需要实现一个接口，使其成为*可观察的*。
- en: Whenever a value on the core object changes, it lets all the observer objects
    know that a change has occurred, by calling a method announcing there's been a
    change of state. This is used widely in GUIs to make sure that any state change
    in the underlying model is reflected in the views of the model. It's common to
    have detail and summary views; a change to the details must also update the widgets
    that display the details and update any summaries that are displayed, also. Sometimes
    a large change in mode may lead to a number of items being changed. For instance,
    clicking a "lock" icon may alter a number of displayed items to reflect their
    status as locked. This can be implemented as a number of observers attached to
    the observable display widget.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当核心对象上的值发生变化时，它会通过调用一个宣布状态发生改变的方法，让所有观察者对象知道已发生改变。这在GUI中得到了广泛应用，以确保底层模型中的任何状态变化都能反映在模型的视图中。通常会有详细视图和摘要视图；对详细信息的更改也必须更新显示详细信息的控件，并更新显示的任何摘要。有时模式的大幅变化可能导致多个项目被更改。例如，点击一个“锁定”图标可能会改变多个显示项目，以反映它们被锁定的状态。这可以通过将多个观察者附加到可观察的显示控件来实现。
- en: In Python, the observer can be notified via the `__call__()` method, making
    each observer behave like a function or other callable object. Each observer may
    be responsible for different tasks whenever the core object changes; the core
    object doesn't know or care what those tasks are, and the observers don't typically
    know or care what other observers are doing.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，观察者可以通过`__call__()`方法被通知，使得每个观察者表现得像一个函数或其他可调用对象。每当核心对象发生变化时，每个观察者可能负责不同的任务；核心对象不知道或关心那些任务是什么，观察者通常也不知道或关心其他观察者在做什么。
- en: This allows tremendous flexibility by decoupling the response to a state change
    from the change itself.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这通过将状态变化对响应的影响与变化本身解耦，提供了极大的灵活性。
- en: 'Here is a depiction of the Observer design pattern in UML:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 UML 中观察者设计模式的表示：
- en: '![Diagram  Description automatically generated](img/B17070_11_03.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![图表描述自动生成](img/B17070_11_03.png)'
- en: 'Figure 11.3: Observer pattern in UML'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.3：UML中的观察者模式
- en: We've shown the `Core` object as containing a list of observer objects. To be
    observable, the `Core` class must adhere to a common understanding of observability;
    specifically, it must provide a list of observers and a way to attach new observers.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经展示了`Core`对象包含一系列观察者对象。为了可观察，`Core`类必须遵循对可观察性的共同理解；具体来说，它必须提供一个观察者列表以及一种附加新观察者的方法。
- en: We've shown the `Observer` subclasses as having a `__call__()` method. This
    will be used by the observable to notify each observer of a state change. As with
    the Decorator pattern, we don't need to formalize the relationships with formally
    defined abstract superclasses. In most cases, we can rely on duck typing rules;
    as long as the observers have the right interface, they can be used in the defined
    role in this pattern. If they lack the proper interface, **mypy** may catch the
    conflict, and a unit test should catch the problem.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经展示了`Observer`子类具有`__call__()`方法。这个方法将由可观察对象用来通知每个观察者状态的变化。与装饰器模式一样，我们不需要通过正式定义的抽象超类来正式化这些关系。在大多数情况下，我们可以依赖鸭子类型规则；只要观察者具有正确的接口，它们就可以在这个模式中定义的角色中使用。如果它们缺少适当的接口，**mypy**可能会捕捉到冲突，并且单元测试应该能够捕捉到这个问题。
- en: An Observer example
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个观察者示例
- en: Outside a GUI, the Observer pattern is useful for saving intermediate states
    of objects. Using observer objects can be handy in systems where a rigorous audit
    of changes is required. It's also handy in a system where chaos reigns and components
    are unreliable.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在图形用户界面之外，观察者模式对于保存对象的中继状态很有用。在需要严格审计变更的系统中使用观察者对象可能很方便。在混乱盛行且组件不可靠的系统中也同样方便。
- en: Complex, cloud-based applications can suffer from chaos issues due to unreliable
    connections. We can use observers to record state changes, making recovery and
    restart easier.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂的基于云的应用可能因为不可靠的连接而出现混乱问题。我们可以使用观察者来记录状态变化，从而使恢复和重启更加容易。
- en: For this example, we'll define a core object to maintain a collection of important
    values, and then have one or more observers create serialized copies of that object.
    These copies might be stored in a database, on a remote host, or in a local file,
    for example. Because we can have a number of observers, it's easy to modify the
    design to use different data caches. For this example, we're thinking of a dice
    game called Zonk or Zilch or Ten Thousand, where a player will roll six dice,
    score some points for triples and runs, and possibly roll again, leading to a
    sequence of dice. (The rules are a bit more complex than this glib summary.)
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，我们将定义一个核心对象来维护一组重要值，然后让一个或多个观察者创建该对象的序列化副本。这些副本可能存储在数据库中、远程主机上或本地文件中，例如。由于我们可以有多个观察者，因此很容易修改设计以使用不同的数据缓存。在这个例子中，我们想到了一个名为Zonk或Zilch或Ten
    Thousand的掷骰子游戏，玩家将掷六个骰子，为三倍和连跑得分，并可能再次掷骰，从而产生一系列骰子。（规则比这个简单的总结要复杂一些。）
- en: 'We''ll start with a few overheads to help make our intention clear:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先简要介绍一些内容，以便使我们的意图更加明确：
- en: '[PRE21]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `Observer` class is a protocol, an abstract superclass for our observers.
    We didn't formalize it as an `abc.ABC` abstract class; we're not relying on the
    runtime error offered by the `abc` module. When defining a `Protocol`, we're relying
    on **mypy** to confirm that all observers actually implement the required method.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`Observer`类是一个协议，是我们观察者的抽象超类。我们没有将其正式化为`abc.ABC`抽象类；我们不依赖于`abc`模块提供的运行时错误。在定义`Protocol`时，我们依赖**mypy**来确认所有观察者实际上实现了所需的方法。'
- en: The `Observable` class defines the `_observers` instance variable and three
    methods that are purely part of this protocol definition. An observable object
    can append an observer, remove an observer, and – most important – notify all
    the observers of a state change. The only thing the core class needs to do that's
    special or different is to make calls to the `_notify_observers()` method when
    there's a state change. Appropriate notification is an important piece of the
    design for an observable object.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`Observable` 类定义了 `_observers` 实例变量和三个纯粹属于此协议定义的方法。一个可观察对象可以添加观察者、移除观察者，以及——最重要的是——通知所有观察者状态变化。核心类需要做的唯一特殊或不同的事情是在状态变化时调用
    `_notify_observers()` 方法。适当的通知是可观察对象设计中的重要组成部分。'
- en: 'Here''s part of the Zonk game we care about. This class keeps a player''s hands:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们在意的Zonk游戏的一部分。这个类保存玩家的手：
- en: '[PRE22]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This class makes calls to `self._notify_observers()` on important state changes.
    This will notify all the observer instances. The observers might cache copies
    of the hand, send details over a network, update widgets on a GUI – any number
    of things. The `_notify_observers()` method inherited from `Observable` iterates
    over any registered observers and lets each know that the state of the hand has
    changed.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类在重要的状态变化时调用 `self._notify_observers()`。这将通知所有观察者实例。观察者可能会缓存手部的副本，通过网络发送详细信息，更新GUI上的小部件——任何数量的事情。从
    `Observable` 继承的 `_notify_observers()` 方法会遍历任何已注册的观察者，并让每个观察者知道手部的状态已发生变化。
- en: 'Now let''s implement a simple observer object; this one will print out some
    state to the console:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来实现一个简单的观察者对象；这个对象将会将一些状态打印到控制台：
- en: '[PRE23]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: There's nothing terribly exciting here; the observed object is set up in the
    initializer, and when the observer is called, we do *something*, in this example,
    printing a line. Note that the superclass, `Observer`, isn't actually needed here.
    The context in which this class is used is sufficient for **mypy** to confirm
    this class matches the required `Observer` protocol. While we don't need to state
    that it's an `Observer`, it can help readers to see that this class implements
    the `Observer` protocol.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么特别激动人心的东西；观察到的对象是在初始化器中设置的，当调用观察者时，我们做了一些事情，在这个例子中，是打印一行。请注意，这里的超类`Observer`实际上并不需要。这个类被使用的上下文足以让**mypy**确认这个类符合所需的`Observer`协议。虽然我们不需要声明它是一个`Observer`，但这可以帮助读者看到这个类实现了`Observer`协议。
- en: 'We can test the `SaveZonkHand` observer in an interactive console:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在交互式控制台中测试`SaveZonkHand`观察者：
- en: '[PRE24]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: After attaching the observer to the `Inventory` object, whenever we change one
    of the two observed properties, the observer is called and its action is invoked.
    Note that our observer tracks a sequence number and includes a timestamp. These
    are outside the game definition, and are kept separate from the essential game
    processing by being part of the `SaveZonkHand` observer class.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 将观察者附加到`Inventory`对象后，每当改变两个被观察属性中的任何一个时，都会调用观察者并执行其动作。请注意，我们的观察者跟踪一个序列号并包含一个时间戳。这些是在游戏定义之外，并且通过成为`SaveZonkHand`观察者类的一部分，与核心游戏处理保持分离。
- en: 'We can add multiple observers of a variety of classes. Let''s add a second
    observer that has a limited job to check for three pairs and announce it:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以添加多个不同类别的观察者。让我们添加一个第二个观察者，它有一个有限的任务，即检查三对并宣布它：
- en: '[PRE25]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: For this example, we omitted naming `Observer` as a superclass. We can trust
    the **mypy** tool to note how this class is used and what protocols it must implement.
    Introducing this new `ThreePairZonkHand` observer means that when we change the
    state of the hand, there may be two sets of output, one for each observer. The
    key idea here is that we can easily add totally different types of observers to
    do different kinds of things, in this case, copying the data as well as checking
    for a special case in the data.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，我们省略了将`Observer`命名为超类。我们可以信任**mypy**工具来记录这个类是如何被使用以及它必须实现哪些协议。引入这个新的`ThreePairZonkHand`观察者意味着，当我们改变手的状态时，可能会有两组输出，每组对应一个观察者。这里的关键思想是，我们可以轻松地添加完全不同类型的观察者来完成不同种类的事情，在这种情况下，就是复制数据以及检查数据中的特殊情况。
- en: 'The Observer pattern detaches the code being observed from the code doing the
    observing. If we were not using this pattern, we would have had to put code in
    the `ZonkHandHistory` class to handle the different cases that might come up:
    logging to the console, updating a database or file, checking for special cases,
    and so on. The code for each of these tasks would all be mixed in with the core
    class definition. Maintaining it would be a nightmare and adding new monitoring
    functionality at a later date would be painful.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者模式将正在被观察的代码与执行观察的代码分离。如果我们没有使用这种模式，我们就不得不在`ZonkHandHistory`类中放置代码来处理可能出现的不同情况：记录到控制台、更新数据库或文件、检查特殊情况等等。每个这些任务的代码都会与核心类定义混合在一起。维护它将是一场噩梦，并且在以后日期添加新的监控功能将会很痛苦。
- en: The Strategy pattern
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 策略模式
- en: The Strategy pattern is a common demonstration of abstraction in object-oriented
    programming. The pattern implements different solutions to a single problem, each
    in a different object. The core class can then choose the most appropriate implementation
    dynamically at runtime.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 策略模式是面向对象编程中抽象的常见示例。该模式实现了对单个问题的不同解决方案，每个解决方案都在不同的对象中。核心类可以在运行时动态地选择最合适的实现。
- en: Typically, different algorithms have different trade-offs; one might be faster
    than another, but uses a lot more memory, while a third algorithm may be most
    suitable when multiple CPUs are present or a distributed system is provided.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，不同的算法有不同的权衡；一个可能比另一个更快，但会使用更多的内存，而第三个算法可能在存在多个CPU或提供了分布式系统时最为合适。
- en: 'Here is the Strategy pattern in UML:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 UML 中的策略模式：
- en: '![Diagram  Description automatically generated](img/B17070_11_04.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![图表描述自动生成](img/B17070_11_04.png)'
- en: 'Figure 11.4: Strategy pattern in UML'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.4：UML中的策略模式
- en: The **Core** code connecting to the **Strategy** abstraction simply needs to
    know that it is dealing with some kind of class that fits the Strategy interface
    for this particular action. Each of the implementations should perform the same
    task, but in different ways. The implementation interfaces need to be identical,
    and it's often helpful to leverage an abstract base class to make sure the implementations
    match.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 连接到**策略**抽象的**核心**代码只需知道它正在处理某种符合特定操作策略接口的类。每个实现都应该执行相同的任务，但以不同的方式。实现接口需要完全相同，并且利用抽象基类来确保实现的一致性通常是有帮助的。
- en: This idea of a plug-in strategy is also an aspect of the Observer pattern. Indeed,
    the idea of strategy objects is an important aspect of many of the patterns covered
    in this chapter. The common idea is to use a separate object to isolate conditional
    or replaceable processing and delegate the work to the separate object. This works
    for observables, decorations, and – as we'll see – commands and states, also.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这种插件策略的想法也是观察者模式的一个方面。实际上，策略对象的想法是本章涵盖的许多模式的一个重要方面。常见的想法是使用一个单独的对象来隔离条件性或可替换的处理，并将工作委托给这个单独的对象。这对于可观察对象、装饰以及——正如我们将看到的——命令和状态也是适用的。
- en: A Strategy example
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 策略示例
- en: One common example of the Strategy pattern is sort routines; over the years,
    numerous algorithms have been invented for sorting a collection of objects. Quick
    sort, merge sort, and heap sort are all algorithms with different features, each
    useful in its own right, depending on the size and type of inputs, how out of
    order they are, and the requirements of the system.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 策略模式的一个常见例子是排序程序；多年来，已经发明了多种算法来对一组对象进行排序。快速排序、归并排序和堆排序都是具有不同特性的算法，每个算法在其自身适用的范围内都是有用的，这取决于输入的大小和类型、它们的顺序如何以及系统的要求。
- en: 'If we have client code that needs to sort a collection, we could pass it to
    an object with a `sort()` method. This object may be a `QuickSorter` or `MergeSorter` object,
    but the result will be the same in either case: a sorted list. The strategy used
    to do the sorting is abstracted from the calling code, making it modular and replaceable.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的客户端代码需要对一个集合进行排序，我们可以将其传递给一个具有`sort()`方法的对象。这个对象可能是一个`QuickSorter`或`MergeSorter`对象，但无论哪种情况，结果都将相同：一个排序后的列表。用于排序的策略从调用代码中抽象出来，使其模块化且可替换。
- en: Of course, in Python, we typically just call the `sorted()` function or `list.sort()`
    method and trust that it will do the sorting quickly enough that the details of
    the TimSort algorithm don't really matter. For details on how amazingly fast TimSort
    is, see [https://bugs.python.org/file4451/timsort.txt](https://bugs.python.org/file4451/timsort.txt).
    While sorting is a helpful concept, it's not the most practical example, so let's
    look at something different.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在Python中，我们通常只是调用`sorted()`函数或`list.sort()`方法，并相信它将足够快地完成排序，以至于TimSort算法的细节并不真正重要。有关TimSort如何惊人的快速的信息，请参阅[https://bugs.python.org/file4451/timsort.txt](https://bugs.python.org/file4451/timsort.txt)。虽然排序是一个有用的概念，但它并不是最实用的例子，所以让我们看看其他的东西。
- en: As a simpler example of the Strategy design pattern, consider a desktop wallpaper
    manager. When an image is displayed on a desktop background, it can be adjusted
    to the screen size in different ways. For example, assuming the image is smaller
    than the screen, it can be tiled across the screen, centered on it, or scaled
    to fit. There are other, more complicated strategies that can be used as well,
    such as scaling to the maximum height or width, combining it with a solid, semi-transparent,
    or gradient background color, or other manipulations. While we may want to add
    these strategies later, let's start with a few basic ones.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 作为策略设计模式的简单示例，可以考虑桌面壁纸管理器。当图像显示在桌面背景上时，它可以以不同的方式调整到屏幕大小。例如，假设图像小于屏幕，它可以平铺在整个屏幕上，居中显示，或者缩放到适合。还可以使用其他更复杂的策略，例如缩放到最大高度或宽度，将其与纯色、半透明或渐变背景颜色结合，或者进行其他操作。虽然我们可能希望在以后添加这些策略，但让我们先从几个基本策略开始。
- en: You'll need to install the `pillow` module. If you're using **conda** to manage
    your virtual environments, use `conda install pillow` to install the Pillow project's
    `PIL` implementation. If you're not using **conda**, use `python -m pip install
    pillow`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要安装`pillow`模块。如果您使用**conda**来管理您的虚拟环境，请使用`conda install pillow`来安装Pillow项目的`PIL`实现。如果您不使用**conda**，请使用`python
    -m pip install pillow`。
- en: 'Our Strategy objects need to take two inputs: the image to be displayed, and
    a tuple of the width and height of the screen. They each return a new image the
    size of the screen, with the image manipulated to fit according to the given strategy.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的策略对象需要接受两个输入：要显示的图像，以及屏幕宽度和高度的元组。它们各自返回一个与屏幕大小相同的新图像，并根据给定的策略对图像进行操作以适应。
- en: 'Here are some preliminary definitions, including an abstract superclass for
    all of the strategy variants:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一些初步的定义，包括所有策略变体的抽象超类：
- en: '[PRE26]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Is this abstraction necessary? This sits right on the fence between too simple
    to require an abstraction and complex enough that the superclass helps. The function
    signature is kind of complex, with a special type hint to describe the size tuple.
    For this reason, the abstraction can help check each implementation to be sure
    all the types match.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这个抽象是否必要？这正处在过于简单以至于不需要抽象和足够复杂以至于超类有帮助之间的边缘。函数签名相当复杂，有一个特殊的类型提示来描述大小元组。因此，抽象可以帮助检查每个实现，以确保所有类型匹配。
- en: 'Note that we need to include the special `# type: ignore [import]` comment
    to make sure **mypy** isn''t confused by the lack of annotations in the PIL modules.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '注意，我们需要包含特殊的`# type: ignore [import]`注释，以确保**mypy**不会因为PIL模块中缺少注释而感到困惑。'
- en: 'Here''s our first concrete strategy; this is a fill algorithm that tiles the
    images:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的第一个具体策略；这是一个填充算法，用于铺贴图像：
- en: '[PRE27]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This works by dividing the output height and width by the input image height
    and width. The `num_tiles` sequence is a way of doing the same computation to
    widths and heights. It's a two-tuple computed via a list comprehension to be sure
    both width and height are processed the same way.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过将输出高度和宽度除以输入图像的高度和宽度来实现的。`num_tiles`序列是一种对宽度和高度进行相同计算的方法。它是一个通过列表推导计算的两个元组，以确保宽度和高度以相同的方式进行处理。
- en: 'Here''s a fill algorithm that centers the image without re-scaling it:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个填充算法，可以在不重新缩放图像的情况下将其居中：
- en: '[PRE28]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Finally, here''s a fill algorithm that scales the image up to fill the entire
    screen:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这是一个填充算法，可以将图像放大以填充整个屏幕：
- en: '[PRE29]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Here we have three strategy subclasses, each using `PIL.Image` to perform their
    task. All the strategy implementations have a `make_background()` method that
    accepts the same set of parameters. Once selected, the appropriate Strategy object
    can be called to create a correctly sized version of the desktop image. `TiledStrategy` computes
    the number of input image tiles that would fit in the width and height of the
    display screen and copies the image into each tile location, repeatedly, without
    rescaling, so it may not fill the entire space. `CenteredStrategy` figures out
    how much space needs to be left on the four edges of the image to center it. `ScaledStrategy` forces
    the image to the output size, without preserving the original aspect ratio.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有三个策略子类，每个子类都使用`PIL.Image`来执行其任务。所有策略实现都有一个`make_background()`方法，它接受相同的参数集。一旦选择，适当的策略对象可以被调用以创建桌面图像的正确尺寸版本。`TiledStrategy`计算输入图像块的数量，这些块可以适合显示屏幕的宽度和高度，并将图像复制到每个块位置，重复进行，而不进行缩放，因此可能无法填满整个空间。`CenteredStrategy`确定需要在图像的四个边缘留下多少空间以使其居中。`ScaledStrategy`强制将图像调整到输出大小，而不保留原始的宽高比。
- en: 'Here''s an overall object that does resizing, using one of these Strategy classes.
    The `algorithm` instance variable is filled in when a `Resizer` instance is created:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个用于调整大小的整体对象，使用这些策略类之一。当创建一个`Resizer`实例时，`algorithm`实例变量会被填充：
- en: '[PRE30]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'And here''s a `main` function that builds an instance of the `Resizer` class
    and applies one of the available Strategy classes:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是构建`Resizer`类实例并应用可用策略类之一的`main`函数：
- en: '[PRE31]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: What's important is the binding of the Strategy instance happens as late as
    possible in the processing. The decision can be made (and unmade) at any point
    in the processing because any of the available strategy objects can be plugged
    into a `Resizer` object at any time.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是策略实例的绑定尽可能在处理过程中晚些时候发生。决策可以在处理的任何时刻做出（和撤销），因为任何可用的策略对象都可以在任何时候插入到`Resizer`对象中。
- en: Consider how switching between these options would be implemented without the
    Strategy pattern. We'd need to put all the code inside one great big method and
    use an awkward `if` statement to select the expected one. Every time we wanted
    to add a new strategy, we'd have to make the method even more ungainly.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一下在没有策略模式的情况下如何实现这些选项之间的切换。我们需要将所有代码放入一个巨大的方法中，并使用一个尴尬的`if`语句来选择期望的那个。每次我们想要添加一个新的策略时，我们都需要让这个方法变得更加笨拙。
- en: Strategy in Python
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python 中的策略
- en: The preceding canonical implementation of the Strategy pattern, while very common
    in most object-oriented libraries, isn't ideal in Python. It involves some overheads
    that aren't really necessary.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: Strategy 模式的先前标准实现，虽然在大多数面向对象的库中非常常见，但在 Python 中并不理想。它涉及一些并非真正必要的开销。
- en: These strategy classes each define objects that do nothing but provide a single
    method. We could just as easily call that function `__call__` and make the object
    callable directly. Since there is no other data associated with the object, we
    need do no more than create a set of top-level functions and pass them around
    as our strategies instead.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这些策略类每个都定义了只提供单个方法的对象。我们完全可以将其函数命名为 `__call__` 并直接使对象可调用。由于与对象关联的数据没有其他，我们只需创建一组顶级函数并将它们作为我们的策略传递即可。
- en: 'Instead of the overheads of an abstract class, we could summarize these strategies
    with a type hint of:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 与抽象类带来的开销相比，我们可以用以下类型提示来总结这些策略：
- en: '[PRE32]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: When we do this, we can eliminate all of the references to `FillAlgorithm` in
    class definitions; we'd change `class CenteredStrategy(FillAlgorithm):` to `class
    CenteredStrategy``:`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们这样做时，我们可以在类定义中消除所有对`FillAlgorithm`的引用；我们将`class CenteredStrategy(FillAlgorithm):`更改为`class
    CenteredStrategy``:`。
- en: Because we have a choice between an abstract class and a type hint, the Strategy
    design pattern seems superfluous. This leads to an odd conversation, starting
    with *"Because Python has first-class functions, the Strategy pattern is unnecessary."*
    In truth, Python's first-class functions allow us to implement the Strategy pattern
    in a more straightforward way, without the overhead of class definitions. The
    pattern is more than the implementation details. Knowing the pattern can help
    us choose a good design for our program, and implement it using the most readable
    syntax. The Strategy pattern, whether a class or a top-level function, should
    be used when we need to allow client code or the end user to select from multiple
    implementations of the same interface at runtime.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们可以在抽象类和类型提示之间进行选择，策略设计模式似乎显得多余。这导致了一场奇怪的对话，开始于 *"因为Python有第一类函数，策略模式是不必要的。"*
    事实上，Python的第一类函数使我们能够以更直接的方式实现策略模式，而不需要类定义的开销。模式不仅仅是实现细节。了解模式可以帮助我们为我们的程序选择一个好的设计，并使用最易读的语法来实现它。当我们需要允许客户端代码或最终用户在运行时从同一接口的多个实现中选择时，无论是类还是顶级函数，都应该使用策略模式。
- en: There's a bright line separating mixin class definitions from plug-in strategy
    objects. As we saw in *Chapter 6*, *Abstract Base Classes and Operator Overloading*,
    mixin class definitions are created in the source code, and cannot easily be tweaked
    at runtime. A plug-in strategy object, however, is filled in at runtime, allowing
    late binding of the strategy. The code tends to be very similar between them,
    and it helps to have clear docstrings on each class to explain how the various
    classes fit together.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在混入类定义和插件策略对象之间存在一条清晰的界限。正如我们在*第6章*，*抽象基类和运算符重载*中看到的，混入类定义是在源代码中创建的，并且不能在运行时轻易修改。然而，插件策略对象是在运行时填充的，允许策略的后期绑定。它们的代码通常非常相似，为每个类提供清晰的文档字符串来解释各种类如何相互配合是很有帮助的。
- en: The Command pattern
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命令模式
- en: When we think about class responsibilities, we can sometimes distinguish "passive"
    classes that hold objects and maintain an internal state, but don't initiate very
    much, and "active" classes that reach out into other objects to take action and
    do things. This is not a very crisp distinction, but it can help separate the
    relatively passive Observer and the more active Command design patterns. An Observer
    is notified that something changed. A Commander, on the other hand, will be active,
    making state changes in other objects. We can combine the two aspects, and that's
    one of the beauties of talking about a software architecture by describing the
    various patterns that apply to a class or a relationship among classes.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们思考类职责时，有时可以区分出“被动”类，这些类持有对象并维护内部状态，但很少主动发起操作，以及“主动”类，这些类会扩展到其他对象以采取行动和执行任务。这种区分并不是非常清晰，但它可以帮助区分相对被动的观察者（Observer）和更活跃的命令（Command）设计模式。观察者会在有变化时被通知。另一方面，指挥者（Commander）将是主动的，在其他对象中做出状态改变。我们可以结合这两个方面，这就是通过描述适用于类或类之间关系的各种模式来讨论软件架构之美的一部分。
- en: The Command pattern generally involves a hierarchy of classes that each do something.
    A Core class can create a command (or a sequence of commands) to carry out actions.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 命令模式通常涉及一个类层次结构，每个类都执行某些操作。一个核心类可以创建一个命令（或一系列命令）来执行动作。
- en: 'In a way, it''s a kind of meta-programming: by creating Command objects that
    contain a bunch of statements, the design has a higher-level "language" of Command objects.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 从某种意义上说，它是一种元编程：通过创建包含大量语句的命令对象，设计具有命令对象的更高层次“语言”。
- en: 'Here''s a UML diagram showing a **Core** object and a collection of **Commands**:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个展示**核心**对象和一组**命令**的UML图：
- en: '![Diagram  Description automatically generated](img/B17070_11_05.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![图表描述自动生成](img/B17070_11_05.png)'
- en: 'Figure 11.5: Command pattern in UML'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.5：UML中的命令模式
- en: This looks similar to the diagrams for the Strategy and Observer patterns because
    all these patterns rely on delegating work from a **Core** object to a plug-in
    object. In this case, a sequence of individual plug-in objects that represent
    a sequence of commands to perform.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来与策略模式和观察者模式的图示相似，因为所有这些模式都依赖于将工作从**核心**对象委托给插件对象。在这种情况下，一系列代表执行一系列命令的单独插件对象。
- en: A Command example
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命令示例
- en: 'As an example, we''ll look at the fancy dice rolling that was omitted from
    the Decorator pattern example earlier in this chapter. In the earlier example,
    we had a function, `dice_roller()`, that computed a sequence of random numbers:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们将查看本章前面提到的装饰器模式示例中省略的复杂骰子滚动。在先前的示例中，我们有一个函数，`dice_roller()`，它计算了一系列随机数：
- en: '[PRE33]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This isn't very clever; we'd rather handle something a little more sophisticated.
    We want to be able to write strings like `3d6` to mean three six-sided dice, `3d6+2`
    to mean three six-sided dice plus a bonus of two more, and something a little
    more obscure like `4d6d1` to mean "roll four six-sided dice and drop one of the
    lowest dice." We might want to combine things and write `4d6d1+2`, also, to combine
    dropping the lowest and adding two to the result.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是很聪明；我们更愿意处理一些更复杂的东西。我们希望能够写出像 `3d6` 这样的字符串来表示三个六面骰子，`3d6+2` 来表示三个六面骰子加上两个额外的奖励，以及像
    `4d6d1` 这样稍微有点晦涩的字符串来表示“掷四个六面骰子并丢弃一个最低的骰子。”我们可能还想将这两者结合起来，写出 `4d6d1+2`，以便同时丢弃最低的骰子并给结果加二。
- en: 'These `d1` and `+2` options at the end can be viewed as a series of commands.
    There are four common varieties: "drop," "keep," "add," and "subtract." There
    can be a lot more, of course, to reflect a wide variety of game mechanics and
    desired statistical distributions, but we''ll look at four commands that modify
    a batch of dice.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 结尾处的这些`d1`和`+2`选项可以被视为一系列命令。常见的有四种类型：“删除”、“保留”、“添加”和“减去”。当然，还可以有更多，以反映广泛的游戏机制和所需的统计分布，但我们将探讨四种可以修改一批骰子的命令。
- en: 'Here''s the regular expression we''re going to implement:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们将要实现的正则表达式：
- en: '[PRE34]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This regular expression can be a little daunting. Some people find the railroad
    diagrams at [https://www.debuggex.com](https://www.debuggex.com) to be helpful.
    Here''s a depiction as a UML state diagram:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这个正则表达式可能有点令人望而生畏。有些人发现[https://www.debuggex.com](https://www.debuggex.com)上的铁路图示很有帮助。这里有一个作为UML状态图的表示：
- en: '![Diagram  Description automatically generated](img/B17070_11_06.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![图表描述自动生成](img/B17070_11_06.png)'
- en: 'Figure 11.6: Dice-parsing regular expression'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.6：骰子解析正则表达式
- en: 'This pattern has four parts:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 此模式包含四个部分：
- en: The first grouping, `(?P<n>\d*)`, captures a batch of digits for the number
    of dice, saving this as a group named `n`. This is optional, allowing us to write
    `d6` instead of `1d6`.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一组，`(?P<n>\d*)`，捕获了一组数字，用于表示骰子的数量，并将其保存为名为 `n` 的组。这是可选的，因此我们可以写作 `d6` 而不是 `1d6`。
- en: The letter "d", which must be present, but isn't captured.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 必须存在的字母 "d"，但并未被捕捉到。
- en: The next grouping, `(?P<d>\d+)`, captures the digits for the number of faces
    on each die, saving this as a group named `d`. If we were very fussy, we might
    try to limit this to `(4|6|8|10|12|20|100)` to define an acceptable list of regular
    polyhedral dice (and two common irregular polyhedrons). We didn't provide this
    short list; instead, we'll accept any sequence of digits.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个分组 `(?P<d>\d+)` 捕获每个骰子上的数字，将其保存为名为 `d` 的分组。如果我们非常挑剔，可能会尝试将其限制为 `(4|6|8|10|12|20|100)`
    以定义一个可接受的规则多面骰子列表（以及两个常见的非规则多面体）。我们没有提供这个简短的列表；相反，我们将接受任何数字序列。
- en: The final grouping, `(?P<a>[dk+-]\d+)*`, defines a repeating series of adjustments.
    Each one has a prefix and a sequence of digits, for example, `d1` or `k3` or `+1`
    or `-2`. We'll capture the whole sequence of adjustments as group `a`, and decompose
    the parts separately. Each of these parts will become a command, following the
    Command design pattern.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后的分组 `(?P<a>[dk+-]\d+)*` 定义了一系列重复的调整。每一个调整都有一个前缀和一系列数字，例如，`d1` 或 `k3` 或 `+1`
    或 `-2`。我们将捕获整个调整序列作为分组 `a`，并分别分解各个部分。这些部分中的每一个都将变成一个命令，遵循命令设计模式。
- en: 'We can think of each part of dice rolling as a distinct command. One command
    rolls the dice, and then subsequent commands adjust the value of the dice. For
    example, `3d6+2` means roll three dice (for example, ![](img/1.png), ![](img/1.png),
    ![](img/3.png)) and add 2 to get 13 in total. The class, overall, looks like this:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将掷骰子的每一部分视为一个独立的命令。一个命令用于掷骰子，随后的一系列命令则调整骰子的数值。例如，`3d6+2` 表示掷三个骰子（例如，![](img/1.png)，![](img/1.png)，![](img/3.png)）并将2加到总数上，得到13。整个类看起来是这样的：
- en: '[PRE35]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'When we want a new roll of the dice, a `Dice` object applies the individual
    `Adjustment` objects to create a new roll. We can see one of the kinds of `Adjustment`
    objects in the `__init__()` method: a `Roll` object. This is put first into a
    sequence of adjustments; after that any additional adjustments are processed in
    order. Each adjustment is another kind of command.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要掷一个新的骰子时，一个`Dice`对象会应用单个`Adjustment`对象来创建一个新的掷骰结果。我们可以在`__init__()`方法中看到一种`Adjustment`对象的例子：一个`Roll`对象。这个对象首先被放入一系列调整中；之后，任何额外的调整都会按顺序处理。每个调整都是另一种命令。
- en: 'Here are the various kinds of adjustment commands that change the state of
    a `Dice` object:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是各种调整命令，它们可以改变`Dice`对象的状态：
- en: '[PRE36]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: An instance of the `Roll()` class sets the values of the dice and the modifier
    attribute of a `Dice` instance. The other `Adjustment` objects either remove some
    dice or change the modifier. The operations depend on the dice being sorted. That
    makes it easy to drop the worst or keep the best via slice operations. Because
    each adjustment is a kind of command, they make adjustments to the overall state
    of the dice that were rolled.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`Roll()` 类的一个实例设置了骰子的值和 `Dice` 实例的修饰符属性。其他 `Adjustment` 对象要么移除一些骰子，要么改变修饰符。这些操作依赖于骰子的排序。这使得通过切片操作丢弃最差的或保留最好的变得容易。因为每个调整都相当于一种命令，它们对掷出的骰子的整体状态进行了调整。'
- en: 'The missing piece is translating the string dice expression into a sequence
    of `Adjustment` objects. We''ve made this a `@classmethod` of the `Dice` class.
    This lets us use `Dice.from_text()` to create a new `Dice` instance. It also provides
    the subclass as the first parameter value, `cls`, making sure that each subclass
    creates proper instances of itself, not this parent class. Here''s the definition
    of this method:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 缺少的部分是将字符串骰子表达式转换为一系列`Adjustment`对象。我们将其作为`Dice`类的`@classmethod`实现。这使得我们可以使用`Dice.from_text()`来创建一个新的`Dice`实例。同时，它还提供了子类作为第一个参数值`cls`，确保每个子类都创建适当的自身实例，而不是这个父类实例。下面是这个方法的定义：
- en: '[PRE37]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The overall `dice_pattern` is applied first and the result is assigned to the
    `dice_match` variable. If the result is a `None` object, the pattern didn't match,
    and we can't do much more than raise a `ValueError` exception and give up. The
    `adjustment_pattern` is used to decompose the string of adjustments in the suffix
    of the dice expression. A list comprehension is used to create a list of objects
    from the `Adjustment` class definitions.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 首先应用整体`dice_pattern`，并将结果赋值给`dice_match`变量。如果结果是`None`对象，则表示模式不匹配，我们无法做更多的事情，只能抛出一个`ValueError`异常并放弃。`adjustment_pattern`用于分解掷骰表达式后缀中的调整字符串。使用列表推导式从`Adjustment`类定义创建一个对象列表。
- en: Each adjustment class is a separate command. The `Dice` class will inject a
    special command, `Roll`, that starts the processing by simulating a roll of the
    dice. Then the adjust commands can apply their individual changes to the initial
    roll.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 每个调整类都是一个独立的命令。`Dice` 类将注入一个特殊的命令，`Roll`，它通过模拟掷骰子的动作来启动处理过程。然后，调整命令可以对其初始掷骰结果应用各自的更改。
- en: 'This design allows us to manually create an instance like this:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 此设计使我们能够手动创建一个类似实例：
- en: '[PRE38]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The first two parameters define the special `Roll` command. The remaining parameters
    can include any number of further adjustments. In this case, there''s only one,
    a `Keep(3)` command. The alternative is to parse text, like this: `dice.Dice.from_text("4d6k3")`.
    This will build the `Roll` command and the other `Adjustment` commands. Each time
    we want a new roll of the dice, the sequence of commands is executed, rolling
    the dice and then adjusting that roll to give a final outcome.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个参数定义了特殊的`Roll`命令。剩余的参数可以包括任意数量的进一步调整。在这种情况下，只有一个，即`Keep(3)`命令。另一种方法是解析文本，如下所示：`dice.Dice.from_text("4d6k3")`。这将构建`Roll`命令和其他`Adjustment`命令。每次我们想要一个新的骰子投掷时，都会执行命令序列，先投掷骰子，然后将该投掷调整以给出最终结果。
- en: The State pattern
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 状态模式
- en: 'The State pattern is structurally similar to the Strategy pattern, but its
    intent and purpose are very different. The goal of the State pattern is to represent
    state transition systems: systems where an object''s behavior is constrained by
    the state it''s in, and there are narrowly defined transitions to other states.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 状态模式在结构上与策略模式相似，但其意图和目的是非常不同的。状态模式的目标是表示状态转换系统：在这种系统中，一个对象的行为受到其所在状态的约束，并且存在明确定义的转换到其他状态的过程。
- en: To make this work, we need a manager or context class that provides an interface
    for switching states. Internally, this class contains a pointer to the current
    state. Each state knows what other states it is allowed to be in and will transition
    to those states depending on the actions invoked upon it.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 要使这可行，我们需要一个管理器或上下文类，它提供了一个用于切换状态的接口。内部，这个类包含了一个指向当前状态的指针。每个状态都知道它可以处于哪些其他状态，并且会根据对其调用的动作转换到那些状态。
- en: 'Here''s how it looks in UML:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是它在UML中的样子：
- en: '![Diagram  Description automatically generated](img/B17070_11_07.png)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![图表描述自动生成](img/B17070_11_07.png)'
- en: 'Figure 11.7: State pattern in UML'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.7：UML中的状态模式
- en: 'The State pattern decomposes the problem into two types of classes: the **Core**
    class and multiple **State** classes. The **Core** class maintains the current
    state, and forwards actions to a current state object. The **State** objects are
    typically hidden from any other objects that are calling the **Core** object;
    it acts like a black box that happens to perform state management internally.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 状态模式将问题分解为两种类型的类：**核心**类和多个**状态**类。**核心**类维护当前状态，并将动作转发给当前状态对象。**状态**对象通常对调用**核心**对象的任何其他对象都是隐藏的；它像一个内部执行状态管理的黑盒。
- en: A State example
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 国家示例
- en: One of the most compelling state-specific processing examples is parsing text.
    When we write a regular expression, we're detailing a series of alternative state
    changes used to match a pattern against a sample piece of text. At a higher level,
    parsing the text of a programming language or a markup language is also highly
    stateful work. Markup languages like XML, HTML, YAML, TOML, or even reStructuredText
    and Markdown all have stateful rules for what is allowed next and what is not
    allowed next.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 最令人信服的特定状态处理示例之一是解析文本。当我们编写一个正则表达式时，我们正在详细描述一系列用于匹配样本文本中模式的替代状态变化。在更高层次上，解析编程语言或标记语言的文本也是高度状态化的工作。像XML、HTML、YAML、TOML这样的标记语言，甚至reStructuredText和Markdown都有关于接下来允许什么和不允许什么的状态化规则。
- en: We'll look at a relatively simple language that crops up when solving **Internet
    of Things** (**IoT**) problems. The data stream from a GPS receiver is an interesting
    problem. Parsing statements in this language is an example of the State design
    pattern. The language is the NMEA 0183 language from the National Marine Electronics
    Association.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨在解决**物联网**（**IoT**）问题时出现的一种相对简单的语言。GPS接收器的数据流是一个有趣的问题。在这种语言中解析语句是状态设计模式的一个例子。这种语言是美国国家海洋电子协会的NMEA
    0183语言。
- en: 'The output from a GPS antenna is a stream of bytes that form a sequence of
    "sentences." Each sentence starts with `$`, includes printable characters in the
    ASCII encoding, and ends with a carriage return and a newline character. A GPS
    device''s output includes a number of different kinds of sentences, including
    the following:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: GPS 天线的输出是一串字节流，形成了一系列“句子”。每个句子以 `$` 开头，包含 ASCII 编码的可打印字符，并以回车符和换行符结束。GPS 设备的输出包括多种不同类型的句子，包括以下几种：
- en: GPRMC – recommended minimum data
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GPRMC – 推荐的最小数据
- en: GPGGA – global position
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GPGGA – 全球定位
- en: GPGLL – latitude and longitude
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GPGLL – 纬度和经度
- en: GPGSV – satellites in view
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GPGSV – 可见卫星
- en: GPGSA – active satellites
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GPGSA – 活跃卫星
- en: There are many, many more messages available, and they come out of the antenna
    device at a pace that can be bewildering. They all have a common format, however,
    making them easy to validate and filter so we can use the good ones, and ignore
    the ones that aren't providing useful information for our specific application.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 可用的消息非常多，而且它们从天线设备中以令人困惑的速度输出。然而，它们都遵循一个共同的格式，这使得我们能够轻松地验证和筛选，以便使用对我们特定应用有用的消息，并忽略那些不提供有用信息的消息。
- en: 'A typical message looks like this:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 一条典型的消息看起来像这样：
- en: '[PRE39]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This sentence has the following structure:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这句话具有以下结构：
- en: '| `$` | Starts the sentence |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| `$` | 开始句子 |'
- en: '| `GPGLL` | The "talker," GP, and the type of message, GLL |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| `GPGLL` | “说话者”，GP，以及消息类型，GLL |'
- en: '| `3723.2475` | Latitude, 37°23.2475 |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
- en: '| `N` | North of the equator |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| `N` | 赤道以北 |'
- en: '| `12158.3416` | Longitude, 121°58.3416 |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| `12158.3416` | 经度，121°58.3416 |'
- en: '| `W` | West of the 0° meridian |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
- en: '| `161229.487` | The timestamp in UTC: 16:12:29.487 |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
- en: '| `A` | Status, `A`=valid, `V`=not valid |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
- en: '| `A` | Mode, `A`=Autonomous, `D`=DGPS, `E`=DR |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
- en: '| `*` | Ends the sentence, starts the checksum |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
- en: '| `41` | Hexadecimal checksum of the text (excluding the `$` and `*` characters)
    |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
- en: With a few exceptions, all the messages from a GPS will have a similar pattern.
    The exceptional messages will start with `!`, and our design will safely ignore
    them.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: 'When building IoT devices, we need to be aware of two complicating factors:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: Things aren't very reliable, meaning our software must be prepared for broken
    or incomplete messages.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The devices are tiny and some common Python techniques that work on a large,
    general-purpose laptop computer won't work well in a tiny Circuit Playground Express
    chip with only 32K of memory.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What we need to do, then, is to read and validate the message as the bytes arrive.
    This saves time (and memory) when ingesting data. Because there's a defined upper
    bound of 82 bytes for these GPS messages, we can use Python `bytearray` structures
    as a place to process the bytes of a message.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: 'The process for reading a message has a number of distinct states. The following
    state transition diagram shows the available state changes:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram  Description automatically generated](img/B17070_11_08.png)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.8: State transitions to parse NMEA sentences'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: We start in a state of waiting for the next `$`. We'll assume that IoT devices
    have loose wires and power problems. (Some people can solder really well, so unreliability
    may not be as common for them as it is for the authors.)
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: Once we've received the `$`, we'll transition to a state of reading the five-character
    header. If, at any time, we get another `$`, it means we lost some bytes somewhere,
    and we need to start over again. Once we have all five characters with the message
    name, we can transition to reading the message body. This will have up to 73 more
    bytes. When we receive a `*`, it tells us we're at the end of the body. Again,
    if we see a `$` along the way, it means something's wrong and we should restart.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: The final two bytes (after the `*`) represent a hexadecimal value that should
    equal the computed checksum of the preceding message (header and body). If the
    checksum is good, the message can be used by the application. There will be one
    or more "whitespace" characters – usually carriage return and newline characters
    – at the end of the message.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: 'We can imagine each of these states as an extension of the following class:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We've defined each state to work with a `Message` object. Some reader object
    will feed a byte to the current state, which will do something with the byte (usually
    save it) and return the next state. The exact behavior depends on the byte received;
    for example, most states will reset the message buffer to empty and transition
    to the `Header` state when they receive a `$`. Most states will return `False`
    for the `valid()` function. One state, however, will validate a complete message,
    and possibly return `True` for the `valid()` function, if the checksum is correct.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: For the purists, the class name doesn't strictly follow PEP-8\. It's challenging
    to include abbreviations or acronyms and keep a properly camel-cased name. It
    seems like `NmeaState` isn't as clear. While a compromise class name might be
    `NMEAState`, the clash between abbreviations and class name seems confusing. We
    prefer to cite "*A foolish consistency is the hobgoblin of little minds…*" in
    this specific case. Keeping the class hierarchy internally consistent is more
    important than the full PEP-8 level of consistency.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Message` object is a wrapper around two `bytearray` structures where we
    accumulate the content of the message:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This definition of the `Message` class encapsulates much of what's important
    about each sentence that comes from the GPS device. We defined a method, `body_append()`,
    for accumulating bytes in the body, and accumulating a checksum of those bytes.
    In this case, the `^` operator is used to compute the checksum. This is a real
    Python operator; it's the bit-wise exclusive OR. An exclusive OR means "one or
    the other but not both." You can see it in action with an expression like `bin(ord(b'a')
    ^ ord(b'z'))`. The bits in `b'a'` are `0b1100001`. The bits in `b'z'` are `0b1111010`.
    Applying "one or the other but not both" to the bits, the exclusive OR is `0b0011011`.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the reader that builds valid `Message` objects by undergoing a number
    of state changes as bytes are received:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The initial state is an instance of the `Waiting` class, a subclass of `NMEA_State`.
    The `read()` method consumes one byte from the input, and then hands it to the
    current `NMEA_State` object for processing. The state object may save the byte
    or may discard it, the state object may transition to another state, or it may
    return the current state. If the state's `valid()` method is `True`, the message
    is complete, and we can yield it for further processing by our application.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: Note that we're reusing a `Message` object's byte arrays until it's complete
    and valid. This avoids allocating and freeing a lot of objects while ignoring
    incomplete messages on a noisy line. This is not typical for Python programs on
    large computers. In some applications, we don't need to save the original message,
    but only need to save the values of a few fields, further reducing the amount
    of memory used.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: To reuse the buffers in the `Message` object, we need to make sure it's not
    part of any specific `State` object. We've made the current `Message` object part
    of the overall `Reader`, and provided the working `Message` object to each `State`
    as an argument value.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we''ve seen the context, here are the classes to implement the various
    states for an incomplete message. We''ll start with the state of waiting for the
    initial `$` to begin a message. When a `$` is seen, the parser transitions to
    a new state, `Header`:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'When we''re in the `Header` state, we''ve seen the `$`, and we''re waiting
    for the five characters that identify the talker ("GP") and the sentence type
    (for example, "GLL"). We''ll accumulate bytes until we get five of them, and then
    transition to the `Body` state:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The `Body` state is where we accumulate the bulk of the message. For some applications,
    we may want to apply additional processing on the header and transition back to
    waiting for headers when we receive a message type we don't want. This can shave
    off a little bit of processing time when dealing with devices that produce a lot
    of data.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: 'When the `*` arrives, the body is complete, and the next two bytes must be
    part of the checksum. This means transitioning to a `Checksum` state:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The `Checksum` state is similar to accumulating bytes in the `Header` state:
    we''re waiting for a specific number of input bytes. After the checksum, most
    messages are followed by ASCII `\r` and `\n` characters. If we receive either
    of these, we transition to an `End` state where we can gracefully ignore these
    excess characters:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The `End` state has an additional feature: it overrides the default `valid()`
    method. For all other states, the `valid()` method is `False`. Once we''ve received
    a complete message, this state''s class definition changes the validity rule:
    we now depend on the `Message` class to compare the computed checksum with the
    final checksum bytes to tell us if the message is valid:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This state-oriented change in behavior is one of the best reasons for using
    this design pattern. Instead of a complex set of `if` conditions to decide if
    we have a complete message and it has all the right parts and punctuation marks,
    we've refactored the complexity into a number of individual states and the rules
    for transition from state to state. This leads us to only checking validity when
    we've received `$`, five characters, a body, `*`, two more characters, and confirmed
    the checksum is correct.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a test case to show how this works:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: We've copied two example messages from the SiRF NMEA Reference Manual, revision
    1.3, to be sure our parsing was correct. See [https://www.sparkfun.com/products/13750](https://www.sparkfun.com/products/13750)
    for more information on GPS IoT devices. See [http://aprs.gids.nl/nmea/](http://aprs.gids.nl/nmea/)
    for additional examples and details.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: It's often helpful to use state transitions when parsing complex messages because
    we can refactor the validation into individual state definitions and state transition
    rules.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: State versus Strategy
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The State pattern looks very similar to the Strategy pattern; indeed, the UML
    diagrams for the two are identical. The implementation, too, is identical. We
    could even have written our states as first-class functions instead of wrapping
    them in objects, as was suggested in the section on the Strategy pattern earlier
    in this chapter.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: These two patterns are similar because they both delegate work to other objects.
    This decomposes a complex problem into several closely related but simpler problems.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: The Strategy pattern is used to choose an algorithm at runtime; generally, only
    one of those algorithms is going to be chosen for a particular use case. The idea
    here is to provide an implementation choice at runtime, as late in the design
    process as possible. Strategy class definitions are rarely aware of other implementations;
    each Strategy generally stands alone.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: The State pattern, on the other hand, is designed to allow switching between
    different states dynamically, as some process evolves. In our example, the state
    changed as bytes were consumed and an evolving set of validity conditions satisfied.
    State definitions are generally defined as a group with an ability to switch among
    the various state objects.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: To an extent, the `End` state used to parse an NMEA message has both State pattern
    features and Strategy pattern features. Because the implementation of the `valid()`
    method is different from other states, this reflects a different strategy for
    determining the validity of a sentence.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: The Singleton pattern
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Singleton pattern is a source of some controversy; many have accused it
    of being an *anti-pattern*, a pattern that should be avoided, not promoted. In
    Python, if someone is using the Singleton pattern, they're almost certainly doing
    something wrong, probably because they're coming from a more restrictive programming
    language.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: So, why discuss it at all? Singleton is useful in overly object-oriented languages
    and is a vital part of traditional object-oriented programming. More relevantly,
    the idea behind singleton is useful, even if we implement the concept in a totally
    different way in Python.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: The basic idea behind the Singleton pattern is to allow exactly one instance
    of a certain object to exist. Typically, this object is a sort of manager class
    like those we discussed in *Chapter 5*, *When to Use Object-Oriented Programming*.
    Such manager objects often need to be referenced by a wide variety of other objects;
    passing references to the manager object around to the methods and constructors
    that need them can make code hard to read.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, when a singleton is used, the separate objects request the single
    instance of the manager object from the class. The UML diagram doesn''t fully
    describe it, but here it is for completeness:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: '![Table  Description automatically generated](img/B17070_11_09.png)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.9: Singleton pattern in UML'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: In most programming environments, singletons are enforced by making the constructor
    private (so no one can create additional instances of it), and then providing
    a static method to retrieve the single instance. This method creates a new instance
    the first time it is called, and then returns that same instance for all subsequent
    calls.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: Singleton implementation
  id: totrans-301
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Python doesn''t have private constructors, but for this purpose, we can use
    the `__new__()` class method to ensure that only one instance is ever created:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'When `__new__()` is called, it normally constructs a new instance of the requested
    class. When we override it, we first check whether our singleton instance has
    been created; if not, we create it using a `super` call. Thus, whenever we call
    the constructor on `OneOnly`, we always get the exact same instance:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The two objects are equal and located at the same address; thus, they are the
    same object. This particular implementation isn't very transparent, since it's
    not obvious that the special method is being used to create a singleton object.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: 'We don''t actually need this. Python provides two built-in Singleton patterns
    we can leverage. Rather than invent something hard to read, there are two choices:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: A Python module *is* a singleton. One `import` will create a module. All subsequent
    attempts to import the module return the one-and-only singleton instance of the
    module. In places where an application-wide configuration file or cache is required,
    make this part of a distinct module. Library modules like `logging`, `random`,
    and even `re` have module-level singleton caches. We'll look at using module-level
    variables below.
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Python class definition can also be pressed into service as a singleton. A
    class can only be created once in a given namespace. Consider using a class with
    class-level attributes as a singleton object. This means defining methods with
    the `@staticmethod` decorator because there will never be an instance created,
    and there's no `self` variable.
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To use module-level variables instead of a complex Singleton pattern, we instantiate
    the class after we've defined it. We can improve our State pattern implementation
    from earlier on to use singleton objects for each of the states. Instead of creating
    a new object every time we change states, we can create a collection of module-level
    variables that are always accessible.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: We'll make a small but very important design change, also. In the examples above,
    each state has a reference to the `Message` object that is being accumulated.
    This required us to provide the `Message` object as part of constructing a new
    `NMEA_State` object; we used code like `return Body(self.message)` to switch to
    a new state, `Body`, while working on the same `Message` instance.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: If we don't want to create (and recreate) state objects, we need to provide
    the `Message` as an argument to the relevant methods.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the revised `NMEA_State` class:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'This variant on the `NMEA_State` class doesn''t have any instance variables.
    All the methods work with argument values passed in by a client. Here are the
    individual state definitions:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Here are the module-level variables created from instances of each of these
    `NMEA_State` classes.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Within each of these classes, we can refer to these five global variables to
    change parsing state. The ability to refer to a global that''s defined *after*
    the class can seem a little mysterious at first. It works out beautifully because
    Python variable names are not resolved to objects until runtime. When each class
    is being built, a name like `CHECKSUM` is little more than a string of letters.
    When evaluating the `Body.feed_byte()` method and it''s time to return the value
    of `CHECKSUM`, then the name is resolved to the singleton instance of the `Checksum()`
    class:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: 'Note how the `Header` class was refactored. In the version where each state
    has an `__init__()`, we could explicitly evaluate `Message.reset()` when entering
    the `Header` state. Since we''re not creating new state objects in this design,
    we need a way to handle the special case of entering a new state, and performing
    an `enter()` method one time only to do initialization or setup. This requirement
    leads to a small change in the `Reader` class:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: We don't trivially replace the value of the `self.state` instance variable with
    the result of the `self.state.feed_byte()` evaluation. Instead, we compare the
    previous value of `self.state` with the next value, `new_state`, to see if there
    was a state change. If there was a change, then we need to evaluate `enter()`
    on the new state, to allow the state change to do any required one-time initialization.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: In this example we aren't wasting memory creating a bunch of new instances of
    each state object that must later be garbage collected. Instead, we are reusing
    a single state object for each piece of the incoming data stream. Even if multiple
    parsers are running at once, only these state objects need to be used. The stateful
    message data is kept separate from the state processing rules in each state object.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: We've combined two patterns, each with different purposes. The State pattern
    covers how processing is completed. The Singleton pattern covers how object instances
    are managed. Many software designs involve numbers of overlapping and complementary
    patterns.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: Case study
  id: totrans-325
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll review a piece of the case study we set aside in *Chapter 3*, *When Objects
    Are Alike*. We talked about the various ways to compute distances, but left part
    of the design to be filled in later. Now that we've seen some of the basic design
    patterns, we can apply some of them to our evolving case study.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: Specifically, we need to put the various kinds of distance computations into
    the `Hyperparameter` class definition. In *Chapter 3*, we introduced the idea
    that the distance computation is not a single definition. There are over 50 commonly
    used distance computation alternatives, some simple, some rather complex. In *Chapter
    3*, we showed a few common ones, including Euclidean distance, Manhattan distance,
    Chebyshev distance, and even a complex-looking Sorensen distance. Each weights
    the "nearness" of the neighbors slightly differently.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: 'This leads us to look at the `Hyperparameter` class as containing three important
    components:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: A reference to the base `TrainingData`. This is used to find all of the neighbors,
    from which the nearest are selected.
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *k* value used to determine how many neighbors will be checked.
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The distance algorithm. We'd like to be able to plug in any algorithm here.
    Our research revealed a large number of competing choices. This suggests that
    implementing one or two won't be very adaptable to real-world demands.
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Plugging in the distance algorithm is a good application of the **Strategy** design
    pattern. For a given `Hyperparameter` object, `h`, the `h.distance` object has
    a `distance()` method that does the work of computing a distance. We can plug
    in any of the subclasses of `Distance` to do this work.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: This means the `Hyperparameter` class' `classify()` method will use the strategy's `self.distance.distance()` to
    compute the distances. We can use this to provide alternative `distance` objects
    as well as alternative *k* values to find a combination that provides the best-quality
    classification of unknown samples.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: 'We can summarize the relationships using a UML diagram like the following:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: '![Diagram  Description automatically generated](img/B17070_11_10.png)'
  id: totrans-335
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.10: UML diagram with Hyperparameter and Distance classes'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: 'This diagram focuses on a few of the classes:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: An instance of the `Hyperparameter` class will have a reference to a `Distance` class.
    This use of the Strategy design pattern lets us create any number of subclasses
    of `Distance` with any of the algorithms found in the literature.
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An instance of the `Distance` class will compute a distance between two samples.
    Researchers have designed 54 implementations. We''ll stick with a few simple ones
    shown in *Chapter 3*:'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chebyshev uses `max()` to reduce four distances along each dimension to the
    single largest value.
  id: totrans-340
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Euclidean uses the `math.hypot()` function.
  id: totrans-341
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Manhattan is the sum of each distance along the four dimensions.
  id: totrans-342
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: An instance of the `Hyperparameter` class will also have a reference to a *k*-nearest
    neighbors `Classifier` function. This use of the Strategy design pattern lets
    us use any number of optimized classifier algorithms.
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `TrainingData` object contains the original `Sample` objects, shared by the
    `Hyperparameter` objects.
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here''s an example of the `Distance` class definitions, defining the overall
    protocol for distance computations and the `Euclidean` implementation:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: We've defined a `Distance` protocol so tools like **mypy** can recognize a class
    that performs a distance computation. The body of the `distance()` function is
    the Python token `...`. It really is three dots; this is not a placeholder here
    in the book, it's the token used for abstract method bodies, as we learned in
    *Chapter 6*.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: 'The Manhattan and Chebyshev distances are similar to each other. The Manhattan
    distance is the sum of changes among the features, and the Chebyshev is the largest
    change among the features:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Similarly, the *k*-nearest neighbors classification can also be defined as
    a hierarchy with alternative implementation strategies. As we saw in *Chapter
    10*, *The Iterator Pattern*, there are a number of ways of performing this algorithm,
    also. We can use a simple approach with a sorted list, or a more sophisticated
    approach where we use a heap queue, or the `bisect` module as a way to cut down
    on the overheads of a large collection of neighbors. We won''t repeat all of the
    *Chapter 10* definitions, here. These are all defined as functions, and this is
    the simplest version that accumulates and sorts all of the distance computations,
    looking for the nearest *k* samples:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Given these two families of the distance functions, and the overall classifier
    algorithms, we can define the `Hyperparameter` class in a way that relies on two
    plug-in Strategy objects. The class definition becomes rather small because the
    details have been factored into separate class hierarchies that we can extend
    as needed:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Here''s how we can create and use a `Hyperparameter` instance. This shows how
    the strategy objects are provided to a `Hyperparameter` object:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: We created an instance of the `Manhattan` class, and provided this object's
    `distance()` method (the method object, not a computed distance value) to the
    `Hyperparameter` instance. We provided the `k_nn_1()` function for the nearest
    neighbor classification. The training data is a sequence of four `KnownSample`
    objects.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: We have a subtle distinction between the distance function, which has a direct
    impact on how well classification works, and the classifier algorithm, which is
    a minor performance optimization. We can argue that these are not really peers,
    and perhaps we have piled too many features into one class. We don't really need
    to test the quality of the classifier algorithm; instead, we only need to test
    the performance.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: This tiny example does, correctly, locate the nearest neighbor to the given
    unknown sample. As a practical matter, we need a more sophisticated testing capability
    to examine all samples of a test dataset.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: 'We can add the following method to the `Hyperparameter` class defined above:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: This `test()` method for a given `Hyperparameter` can apply the `classify()`
    method to all of the given samples in the test set. The ratio of correctly classified
    test samples to the total number of tests is one way to measure the overall quality
    of this specific combination of parameters.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of combinations of hyperparameters, and the Command design
    pattern can be used to create a number of test commands. Each of these command
    instances would contain the values required to create and test a unique `Hyperparameter`
    object. We can create a large collection of these Commands to perform a comprehensive
    hyperparameter tuning.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: 'The essential command creates a `Timing` object when it is executed. The `Timing`
    object is a summary of the results of a test, and looks like this:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The test command is given a `Hyperparameter` and a reference to the test data.
    This can be used, later, to actually gather the tuning results. The use of the
    Command design pattern makes it possible to separate creating the commands from
    executing the commands. This separation can be helpful for understanding what's
    going on. It may also be necessary when there is one-time setup processing that
    we don›t want to measure when comparing the performance of various algorithms.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s our `TestCommand` class definition:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The constructor saves the `Hyperparameter` and testing samples list. When the
    `test()` method is evaluated, the test is run, and a `Timing` object is created.
    For this very small dataset, the tests run very quickly. For larger and more complex
    datasets, the hyperparameter tuning can run for hours.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: Here's a function to build and then execute a suite of `TestCommand` instances.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: This function loads the raw data and will partition the data as well. This code
    is essentially the subject of *Chapter 9*, *Strings, Serialization, and File Paths*.
    It creates a number of `TestCommand` objects for many combinations of *k*, distance,
    and classifier functions, saving these in the `scenarios` list.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: After all the command instances have been created, it executes all of the objects,
    saving the results in the `timings` list. The results are displayed, to help us
    locate the optimal hyperparameter set.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve used the Strategy and the Command design patterns as part of building
    the tuning function. The three distance computation classes are good candidates
    for a Singleton-like class design: we only need one instance of each of these
    objects. Having a language for describing a design, via design patterns, can make
    it easier to describe a design to other developers.'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: Recall
  id: totrans-374
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The world of software design is full of good ideas. The really good ideas get
    repeated and form repeatable patterns. Knowing – and using – these patterns of
    software design can save the developer from burning a lot of brain calories trying
    to reinvent something that''s been developed already. In this chapter, we looked
    at a few of the most common patterns:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: The Decorator pattern is used in the Python language to add features to functions
    or classes. We can define decorator functions and apply them directly, or use
    the `@` syntax to apply a decorator to another function.
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Observer pattern can simplify writing GUI applications. It can also be used
    in non-GUI applications to formalize relationships between objects that change
    state, and objects that display or summarize or otherwise use the state information.
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Strategy pattern is central to a lot of object-oriented programming. We
    can decompose large problems into containers with the data and strategy objects
    that help with processing the data. The Strategy object is a kind of "plug-in"
    to another object. This gives us ways to adapt, extend, and improve processing
    without breaking all the code we wrote when we make a change.
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Command pattern is a handy way to summarize a collection of changes that
    are applied to other objects. It's really helpful in a web services context where
    external commands arrive from web clients.
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The State pattern is a way to define processing where there's a change in state
    and a change in behavior. We can often push unique or special-case processing
    into state-specific objects, leveraging the Strategy pattern to plug in state-specific
    behavior.
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Singleton pattern is used in the rare cases where we need to be sure there
    is one and only one of a specific kind of object. It's common, for example, to
    limit an application to exactly one connection to a central database.
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These design patterns help us organize complex collections of objects. Knowing
    a number of patterns can help the developer visualize a collection of cooperating
    classes, and allocate their responsibilities. It can also help developers talk
    about a design: when they''ve both read the same books on design patterns, they
    can refer to the patterns by name and skip over long descriptions.'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  id: totrans-383
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While writing the examples for this chapter, the authors discovered that it
    can be very difficult, and extremely educational, to come up with good examples
    where specific design patterns *should* be used. Instead of going over current
    or old projects to see where you can apply these patterns, as we've suggested
    in previous chapters, think about the patterns and different situations where
    they might come up. Try to think outside your own experiences. If your current
    projects are in the banking business, consider how you'd apply these design patterns
    in a retail or point-of-sale application. If you normally write web applications,
    think about using design patterns while writing a compiler.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: Look at the Decorator pattern and come up with some good examples of when to
    apply it. Focus on the pattern itself, not the Python syntax we discussed. It's
    a bit more general than the actual pattern. The special syntax for decorators
    is, however, something you may want to look for places to apply in existing projects
    too.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: What are some good areas to use the Observer pattern? Why? Think about not only
    how you'd apply the pattern, but how you would implement the same task without
    using Observer. What do you gain, or lose, by choosing to use it?
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: Consider the difference between the Stategy and State patterns. Implementation-wise,
    they look very similar, yet they have different purposes. Can you think of cases
    where the patterns could be interchanged? Would it be reasonable to redesign a
    State-based system to use Strategy instead, or vice versa? How different would
    the design actually be?
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: In the dice-rolling example, we parsed a simple expression to create a few commands.
    There are more options possible. See [https://help.roll20.net/hc/en-us/articles/360037773133-Dice-Reference#DiceReference-Roll20DiceSpecification](https://help.roll20.net/hc/en-us/articles/360037773133-Dice-Reference#DiceReference-Roll20DiceSpecif)
    for some really sophisticated syntax for describing dice and dice games. To implement
    this, there are two changes that need to be made. First, design the command hierarchy
    for all of these options. After that, write a regular expression to parse a more
    complex dice-rolling expression and execute all of the commands present.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: We've noted that Singleton objects can be built using Python module variables.
    It's sometimes helpful to compare the performance of the two different NMEA message
    processors. If you don't have a GPS chip with a USB interface laying around, you
    can search the internet for NMEA example messages to parse. [http://aprs.gids.nl/nmea/](http://aprs.gids.nl/nmea/)
    is a good source of examples. There's a trade-off question between the potential
    confusion of module variables and the performance of the application. It's helpful
    to have data to support the lessons you've learned.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-390
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter discussed several common design patterns in detail, with examples,
    UML diagrams, and a discussion of the differences between Python and statically
    typed object-oriented languages. The Decorator pattern is often implemented using
    Python's more generic decorator syntax. The Observer pattern is a useful way to
    decouple events from actions taken on those events. The Strategy pattern allows
    different algorithms to be chosen to accomplish the same task. The Command pattern
    helps us design active classes that share a common interface but carry out distinct
    actions. The State pattern looks similar to the Strategy pattern but is used instead
    to represent systems that can move between different states using well-defined
    actions. The Singleton pattern, popular in some statically typed languages, is
    almost always an anti-pattern in Python.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll wrap up our discussion of design patterns.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
