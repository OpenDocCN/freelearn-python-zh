- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Integrating LoRa with the Internet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will take the sensory information from our remotely placed
    LoRa sensory transmitter and publish it to the internet using our Raspberry Pi
    Pico W-equipped **LoRa** receiver. Our internet destination will be an MQTT instance
    on our CloudAMQP server. We will then connect a modified version of the analog-metered
    weather indicator we created in [*Chapter 3*](B21282_03.xhtml#_idTextAnchor048)
    to our MQTT server and use this data to position the needle and set the color
    of the LED indicator based on the humidity reading. This modification will entail
    swapping out the Raspberry Pi we installed on the analog-metered weather indicator
    for a Raspberry Pi Pico WH (also referred to as a Raspberry Pi Pico W with headers)
    and the single-color LED with an RGB LED.
  prefs: []
  type: TYPE_NORMAL
- en: By transitioning from a standard weather web service to utilizing a remote LoRa
    sensory transmitter that measures temperature and humidity, and subsequently converts
    this data into MQTT messages, we are effectively creating a customized weather
    web service – a service that is powered by LoRa technology for its data transmission
    needs and MQTT for internet communication.
  prefs: []
  type: TYPE_NORMAL
- en: We will conclude this chapter with a look at various other technologies for
    **Internet of Things** (**IoT**) communication, such as **LoRaWAN** and cellular
    technologies, and explore the benefits and drawbacks of each technology.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Connecting our LoRa receiver to the internet
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a new weather indicator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring other IoT communication protocols
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s begin!
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are the requirements for completing this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Intermediate knowledge of Python programming.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 X Raspberry Pi Pico WH.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 X LoRa sensory transmitter from [*Chapter 9*](B21282_09.xhtml#_idTextAnchor140).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 X LoRa receiver built with the Raspberry Pi Pico W from [*Chapter 9*](B21282_09.xhtml#_idTextAnchor140).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A CloudAMQP account for the MQTT server instance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 X SG90 servo motor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 X common anode RGB LED.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 3 X 220 Ohm resistors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 X 8 mm LED holder.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 9 X M3 10 mm bolts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 4 X M2 8 mm screws.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 X M5 20 mm bolt.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1 X M5 nut.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Epoxy glue for constructing the weather indicator faceplate.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A hot glue gun.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A color printer to print out the faceplate graphic.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A digital cutting machine such as a Silhouette Cameo. This is optional as the
    faceplate graphic may be cut out by hand. Silhouette Studio 3 file provided.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Access to a 3D printer to print the weather indicator stand.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The code for this chapter may be found here: [https://github.com/PacktPublishing/-Internet-of-Things-Programming-Projects-2nd-Edition/tree/main/Chapter10](https://github.com/PacktPublishing/Internet-of-Things-Programming-Projects-2nd-Edition/tree/main/Chapter10%20)'
  prefs: []
  type: TYPE_NORMAL
- en: Connecting our LoRa receiver to the internet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our first task is to revise the code on our CircuitPython-based LoRa receiver,
    enabling it to forward LoRa messages received by our CloudAMQP server. We’ll use
    Adafruit CircuitPython libraries for this update. Before building and programming
    our new weather indicator to process MQTT messages, we’ll test the MQTT functionality
    using the MQTT-Explorer app in Windows. We can see an outline of this chapter’s
    project in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.1 – Controlling an analog-metered weather indicator with LoRa-transmitted
    sensory data](img/B21282_10_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.1 – Controlling an analog-metered weather indicator with LoRa-transmitted
    sensory data
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 10**.1*, we can see that our Raspberry Pi Pico LoRa sensory transmitter
    from [*Chapter 9*](B21282_09.xhtml#_idTextAnchor140) sends temperature and humidity
    data through LoRa to the LoRa receiver we also built in [*Chapter 9*](B21282_09.xhtml#_idTextAnchor140).
    We do not need to change the code for our transmitter as it performs what we need
    it to do. As mentioned, we will update the code for our LoRa receiver as we require
    it to connect to the internet and send MQTT messages.
  prefs: []
  type: TYPE_NORMAL
- en: Once we establish that our MQTT code is working properly, we will build a new
    version of the weather indicator and program it to respond accordingly to the
    MQTT messages.
  prefs: []
  type: TYPE_NORMAL
- en: We will start by adding the CircuitPython MQTT library to our LoRa receiver.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the CircuitPython library for MQTT
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: MQTT libraries for microcontrollers enable IoT devices to use the MQTT protocol,
    a messaging system optimized for low bandwidth and minimal device resources. These
    libraries, designed for various microcontroller platforms, enable connections
    to MQTT brokers, message publishing, and topic subscriptions.
  prefs: []
  type: TYPE_NORMAL
- en: Among these, the Adafruit MiniMQTT library is notable for CircuitPython devices.
    This library offers a straightforward API, suitable for boards such as the Raspberry
    Pi Pico W. It supports key MQTT features such as publish/subscribe and works with
    various MQTT brokers.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install the MiniMQTT library, we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Using a web browser, we navigate to the URL [https://circuitpython.org/libraries](https://circuitpython.org/libraries).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As we are using CircuitPython 8, we download the `adafruit-circuitpython-bundle-8.x-mpy-20231205.zip`
    ZIP file and unzip it to a location on our computer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We want to install the library files in the `lib` folder on our Raspberry Pi
    Pico W and not the root directory. So, we need to double-click on the `lib` folder
    under the **CircuitPython** section in Thonny to open it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The files we are interested in from the Adafruit library are in the `adafruit_minimqtt`
    folder. To install these files onto our Raspberry Pi Pico W from Thonny, we open
    the folder in the **Files** section in Thonny and right-click to get the following
    dialog:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.2 – Uploading the MQTT library to the Raspberry Pi Pico](img/B21282_10_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.2 – Uploading the MQTT library to the Raspberry Pi Pico
  prefs: []
  type: TYPE_NORMAL
- en: 'After uploading the libraries to the Pico W, the file structure on our Pico
    should look like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.3 – Pico W file structure after uploading Mini MQTT](img/B21282_10_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.3 – Pico W file structure after uploading Mini MQTT
  prefs: []
  type: TYPE_NORMAL
- en: With the Adafruit MQTT library set up on our Raspberry Pi Pico W, our next step
    is to configure a CloudAMQP instance to broker our MQTT messages.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s do that now.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a CloudAMQP instance for our application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Having already set up an account in [*Chapter 7*](B21282_07.xhtml#_idTextAnchor107),
    we’re now prepared to create a CloudAMQP instance to act as the broker for MQTT
    messages from our Raspberry Pi Pico W. Following the steps outlined in the *Setting
    up a CloudAMQP instance* section of [*Chapter 7*](B21282_07.xhtml#_idTextAnchor107),
    we create a new instance, call it `RemoteWeatherStation`, and record the details
    for use in our LoRa receiver code.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll utilize the WebSocket UI of our CloudAMQP instance to observe messages
    from our LoRa transmitter, enabling us to test our application thoroughly before
    constructing and implementing our new weather indicator.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s go ahead and modify the code on our LoRa receiver by adding MQTT functionality
    so that it can publish MQTT messages to the `RemoteWeatherStation` instance.
  prefs: []
  type: TYPE_NORMAL
- en: Adding MQTT functionality to the LoRa receiver
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With our CloudAMQP instance created, we will now enhance the code on our LoRa
    receiver to incorporate Wi-Fi and MQTT functionalities. This modification enables
    the receiver to effectively utilize LoRa to receive sensory data from our transmitter
    and then leverage Wi-Fi for internet connectivity.
  prefs: []
  type: TYPE_NORMAL
- en: Utilizing the MQTT protocol, the receiver can transmit this sensory data to
    our CloudAMQP server. This integration not only demonstrates the synergy between
    different communication technologies – LoRa for local, long-range transmission
    and MQTT over Wi-Fi for global reach – but also greatly expands the capabilities
    of our IoT ecosystem. Our LoRa receiver becomes a bridge, gathering sensory information
    locally and distributing it over the internet.
  prefs: []
  type: TYPE_NORMAL
- en: 'To modify the LoRa receiver code, we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: We connect our Raspberry Pi Pico W from our LoRa receiver to a USB port and
    launch Thonny using a computer and operating system of our choice.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then activate the CircuitPython environment on our Pico W by selecting it
    from the bottom right-hand side of the screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In a new tab in the editor section (hit *Ctrl* + *N*), we start by entering
    our imports:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In our code, we have the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `time` library is used for timing and delays in the code.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `board` module provides access to the basic pin setup of the microcontroller.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `busio` module is used to create bus communication interfaces, essential
    for devices such as the RFM9x LoRa module.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`digitalio` is utilized for managing digital I/O pins.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `adafruit_rfm9x` module is specifically for interfacing with the RFM95W
    LoRa radio modules installed on the LoRa receiver.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `wifi` module is included to handle Wi-Fi connections on the microcontroller.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`socketpool` provides a way to manage network sockets, which are needed for
    internet communication. In our CircuitPython code, this module is essential for
    efficiently managing network sockets, which is crucial for MQTT communications
    via the `adafruit_minimqtt` library. It provides stable TCP/IP connections over
    Wi-Fi.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`adafruit_minimqtt` is imported to enable MQTT protocol communication, allowing
    the device to publish and subscribe to MQTT topics.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After our imports, we set our Wi-Fi network (SSID) and Wi-Fi password:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We then enter code to initialize the `GP5` GPIO pin as a digital output to
    control an LED connected to that pin on the microcontroller:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We define the `flash_led()` method, which blinks an LED a specified number
    of times, with each blink lasting for the duration set in seconds:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we define the `connect_to_wifi()` function. This function repeatedly
    tries to connect to Wi-Fi with the provided SSID and password, signaling a failed
    attempt by blinking an LED twice for 2 seconds each, followed by a 5-second pause
    before retrying. Upon successful connection, it exits the loop and blinks the
    LED four times, each for 1 second, to indicate a successful Wi-Fi connection:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We then create the `pool` variable, an instance of `socketpool.SocketPool`,
    using the `wifi.radio` object, which manages and provides network socket connections
    for Wi-Fi communication:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, our code sets up the MQTT configuration, defining the server address
    (`MQTT_SERVER`), port number (`MQTT_PORT`), user credentials (`USERNAME` and `PASSWORD`),
    device identifier (`DEVICE_ID`), and MQTT topic (`MQTT_TOPIC`) for communication.
    We obtain these values from the CloudAMQP instance we set up for our application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We then configure the `GP18`, `GP19`, and `GP16` for SCK, MOSI, and MISO, respectively,
    and initialize digital I/O pins `GP17` and `GP14` for **chip select** (**CS**)
    and **reset** (**RST**) functions. The CS pin is used to select the LoRa module
    for communication, while the RST pin is employed to reset the module, ensuring
    it starts in a known state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We initialize the RFM9x LoRa radio module by creating an instance of `adafruit_rfm9x.RFM9x`
    with the previously configured SPI bus (`spi`), chip select (`cs`), and reset
    (`rst`) pins, and set the operating frequency to 915.0 MHz as our example is built
    for use in North America:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We then set up an MQTT client by creating an instance of MQTT with the specified
    MQTT broker details (`MQTT_SERVER` and `MQTT_PORT`), user credentials (`USERNAME`
    and `PASSWORD`), and the previously created socket pool (`pool`) for network communication:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Our code connects the MQTT client to the MQTT broker and prints a message indicating
    that the system is now ready to listen for incoming LoRa messages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We create a continuous loop to check for incoming packets from the RFM9x LoRa
    module; upon receiving a packet, our code decodes the message to UTF-8 format,
    prints the received message, flashes the LED twice for 0.5 seconds each, then
    publishes the message to the specified MQTT topic and prints a confirmation of
    the sent MQTT message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To save the file, we click on **File** | **Save as...** from the drop-down menu.
    This will open the **Where to save** **to?** dialog.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.4 – Saving our file to our Raspberry Pi Pico W](img/B21282_10_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.4 – Saving our file to our Raspberry Pi Pico W
  prefs: []
  type: TYPE_NORMAL
- en: In this dialog, we are given the option to choose where to store our file. To
    save it on our Raspberry Pi Pico W (CircuitPython device), we click on the corresponding
    button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then give the file the name `code.py` and click **Ok**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To run our code, we click on the green run button, hit *F5* on the keyboard
    or click on the **Run** menu option at the top, and then select **Run** **current
    script**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If it is not already running, we power up and run the LoRa sensory transmitter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We verify the correct functioning of our code by checking the receipt of MQTT
    messages in the MQTT-Explorer app in Windows.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We should also observe our LED flashes twice.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By taking temperature and humidity readings from the LoRa sensory transmitter
    and relaying them to our MQTT server using our LoRa receiver, much like a baton
    pass in a relay race, we have effectively established our own weather information
    web service.
  prefs: []
  type: TYPE_NORMAL
- en: With our setup ready, we can now utilize the MQTT message data to operate our
    improved analog meter-style weather indicator. Our first step is to construct
    the device, followed by programming it to respond to incoming data.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new weather indicator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we introduce an upgraded weather indicator, building on the
    version from [*Chapter 3*](B21282_03.xhtml#_idTextAnchor048). This model features
    an RGB LED instead of a single-color LED. We will use it to indicate humidity
    by setting the color to red for low humidity, green for a humidity level between
    30 and 50 percent (considered a comfortable humidity level for people), and blue
    for a humidity above 50 percent. The device now uses the economical Raspberry
    Pi Pico WH as opposed to the more expensive Raspberry Pi 5\. A new addition is
    the reset button for the Raspberry Pi Pico WH, allowing us to reset the Pico if
    we need to.
  prefs: []
  type: TYPE_NORMAL
- en: 'The design of our upgraded weather indicator includes a new feature: a split
    stand specifically engineered for easier printing using a **Fused Deposition Modeling**
    (**FDM**) 3D printer. By dividing the stand into two separate parts, each piece
    can be printed flat. When printed flat, the layer lines in each section of the
    stand run perpendicular to the primary stress axis encountered during use. This
    perpendicular arrangement of the layers effectively distributes stress across
    the structure, making the stand more resilient and less prone to breakage or warping
    under load.'
  prefs: []
  type: TYPE_NORMAL
- en: We will start the construction of our new weather indicator by building the
    split stand.
  prefs: []
  type: TYPE_NORMAL
- en: Building the split stand
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We may use any of the stands we have built so far in the book to mount our
    weather indicator faceplate. For our example, we introduce a split stand that
    may be printed using a standard FDM 3D printer or a liquid resin 3D printer. The
    parts of the split stand can be seen in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.5 – Split stand printed with PLA and a FDM 3D printe](img/B21282_10_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.5 – Split stand printed with PLA and a FDM 3D printer
  prefs: []
  type: TYPE_NORMAL
- en: 'The parts of the split stand are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*A*: Right split stand'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*B*: Left split stand'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*C*: Base'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*D* (not shown): 9 X M3 10 mm bolts'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*E* (not shown): 4 X 12 mm rubber pads (optional)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `.stl` files for our split stand are located in the `Build Files` folder
    of this chapter’s GitHub repository. All three parts shown in *Figure 10**.5*
    may be printed together on a standard Ender-3-sized print bed (220 mm by 220 mm
    by 250 mm).
  prefs: []
  type: TYPE_NORMAL
- en: When using an FDM printer, it’s important to slice the print file with support
    structures, especially since the outer ring of the split stand *floats* in space
    when printed flat. For the split stand, **Polylactic Acid** (**PLA**) material
    is the optimal choice due to its printing ease and reliable results.
  prefs: []
  type: TYPE_NORMAL
- en: We can see how we may position the parts of the split stand on a print bed in
    the following figure.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.6 – Laying out the parts of the split stand for 3D printing on
    a print bed](img/B21282_10_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.6 – Laying out the parts of the split stand for 3D printing on a print
    bed
  prefs: []
  type: TYPE_NORMAL
- en: 'To construct the stand, we follow the steps shown in *Figure 10**.7*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.7 – Constructing the split stand](img/B21282_10_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.7 – Constructing the split stand
  prefs: []
  type: TYPE_NORMAL
- en: Utilizing an M3 tap, we carefully create screw threads on the right side of
    the split stand (*A* from *Figure 10**.5*). This step is optional as the holes
    should be large enough to allow M3 bolts to screw in without tapping.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using five M3 10 mm bolts, we secure the left split stand (*C* from *Figure
    10**.5*) to the right split stand (*A* from *Figure 10**.5*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we attach four standard 12 mm rubber pads to the base’s bottom as feet,
    using epoxy glue for enhanced adhesion. This step, while not mandatory, adds stability
    as the stand can function without the rubber pads.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using an M3 tap, we create screw threads in the base. This step is optional
    as the holes should be large enough to allow M3 bolts to screw in without tapping.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using four M3 bolts, we secure the assembled stand to the base (*C* from *Figure
    10**.5*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The assembled split stand can be painted for aesthetic improvement. Once the
    split stand is finished, the next step is to assemble the faceplate of our weather
    indicator.
  prefs: []
  type: TYPE_NORMAL
- en: Building the faceplate
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The faceplate for our new enhanced weather indicator is very similar to the
    faceplate we built in [*Chapter 3*](B21282_03.xhtml#_idTextAnchor048). The exceptions
    are the use of a Raspberry Pi Pico WH over a Raspberry Pi 5 and an RBG LED, which
    will allow us to use various colors for our indicator.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see the parts that make up the faceplate in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.8 – Parts that make up the faceplate of our weather indicator](img/B21282_10_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.8 – Parts that make up the faceplate of our weather indicator
  prefs: []
  type: TYPE_NORMAL
- en: '*A*: Faceplate front.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*B*: Faceplate alignment tool.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*C*: Raspberry Pi Pico WH.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*D*: Faceplate front button. Used to reset the Raspberry Pi Pico WH.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*E*: Hook.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*F*: Faceplate back.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*G*: Faceplate graphic.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*H*: RGB LED with resistors and jumper wires (jump ahead to the upcoming section
    *Adding jumper wires up our RGB LED* for construction of this component).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*I*: SG90 servo motor.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*J*: 8 mm LED holder.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To build the faceplate for our new weather indicator, we follow the steps in
    the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.9 – Construction of the faceplate for our new weather indicator](img/B21282_10_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.9 – Construction of the faceplate for our new weather indicator
  prefs: []
  type: TYPE_NORMAL
- en: Using the alignment tool (*B* from *Figure 10**.8*) and epoxy glue, we align
    and glue the front of the faceplate (*A* from *Figure 10**.8*) to the back of
    the faceplate (*F* from *Figure 10**.8*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We glue the hook (*E* from *Figure 10**.8*) to the back of the faceplate (*F*
    from *Figure 10**.8*) into the slot provided.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We print the faceplate graphic (*G* from *Figure 10**.8*) on printable vinyl
    using a color printer. Next, we trim the graphic using a digital cutter, such
    as a Silhouette Cameo, or by hand and attach it to the faceplate’s front, ensuring
    proper alignment of the holes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We align the SG90 servo motor (*I* from *Figure 10**.8*) with its corresponding
    hole and secure it in place to the back of the faceplate (*F* from *Figure 10**.8*)
    with glue from a hot glue gun.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We secure the Raspberry Pi Pico WH (*C* from *Figure 10**.8*) to the back of
    the faceplate (*F* from *Figure 10**.8*) with four M3 8 mm screws such that the
    pins are facing up and the USB port is facing out.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We push the RGB LED (*H* from *Figure 10**.8*) from the back of the faceplate
    to the front and secure it in place with the 8 mm LED holder (*J* from *Figure
    10**.8*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Having constructed the faceplate and stand, we can now fasten the faceplate
    to the stand using an M5 20 mm bolt and nut. Once this is done, we’re prepared
    to proceed with connecting the RGB LED and servo motor to the Raspberry Pi Pico
    WH.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the RGB LED indicator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For our application, we will use an RGB LED to represent the humidity reading
    we get from our remote LoRa transmitter. An RGB LED allows us to represent any
    color as it combines three LEDs (red, green, and blue) into one housing.
  prefs: []
  type: TYPE_NORMAL
- en: Before we wire up and install our RGB LED, let’s get a little understanding
    of what RGB LEDs are.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding RGB LEDs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'RGB LEDs combine red, green, and blue light to produce various colors. Each
    color has a pin for control. There are two types: common cathode and common anode
    (*Figure 10**.10*). Common cathode LEDs have a single ground pin shared by all
    colors, requiring a positive voltage to the color pins for illumination. Common
    anode LEDs share a positive pin, needing a ground connection on the color pins
    to light up.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.10 – Two different types of RGB LEDs](img/B21282_10_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.10 – Two different types of RGB LEDs
  prefs: []
  type: TYPE_NORMAL
- en: The type determines how we connect and control them, with common cathode LEDs
    needing a high signal and common anode LEDs needing a low signal for activation.
  prefs: []
  type: TYPE_NORMAL
- en: Differentiating between common cathode and common anode RGB LEDs
  prefs: []
  type: TYPE_NORMAL
- en: To determine whether our RGB LED is a common anode or common cathode type, we
    use a multimeter set to diode test mode. First, we identify the longest leg of
    the LED, as this is usually the common connection. We then connect the multimeter
    red probe to the longest leg and the black probe to one of the other legs. If
    the LED lights up, the longest leg is the anode, indicating a common anode LED.
    If it doesn’t light up, we’ll switch the probes. A lit LED with the black probe
    on the longest leg means it’s a common cathode.
  prefs: []
  type: TYPE_NORMAL
- en: For our application, we will be using a common anode RGB LED, and we will program
    it to change colors based on humidity levels. For low humidity levels, it will
    be red, indicating dry conditions. It will be green to indicate a humidity level
    between 30 and 50 percent and blue to represent humidity levels higher than 50
    percent.
  prefs: []
  type: TYPE_NORMAL
- en: Adding jumper wires to our RGB LED
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To prepare our RGB LED for connection with the Raspberry Pi Pico WH, we’ll solder
    female jumper wires to each of its leads. For the RGB LED’s protection, we’ll
    solder 220 Ohm resistors onto the red, green, and blue leads, positioning them
    between the LED’s legs and the jumper wires. In our example, we use a yellow wire
    for power, a red wire for the red LED, a green wire for the green LED, and a blue
    wire for the blue LED, as shown in the following figure.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.11 – Adding jumper wires to the RGB LED](img/B21282_10_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.11 – Adding jumper wires to the RGB LED
  prefs: []
  type: TYPE_NORMAL
- en: Applying heat shrink, as shown in Step *2* of *Figure 10**.11*, reinforces the
    solder connections by providing both physical strength and electrical insulation.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting the RGB LED to our Raspberry Pi Pico WH
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We will power our RGB LED with the 3V3 power port from our Raspberry Pi Pico
    WH. For wiring, use the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.12 – Wiring diagram for RGB LED and Raspberry Pi Pico WH](img/B21282_10_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.12 – Wiring diagram for RGB LED and Raspberry Pi Pico WH
  prefs: []
  type: TYPE_NORMAL
- en: 'The connections are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 3V3 power connects to the common anode.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Red connects to `GP15` using a 220 Ohm resistor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Green connects to `GP13` using a 220 Ohm resistor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Blue connects to `GP12` using a 220 Ohm resistor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the RGB LED connected to the Raspberry Pi Pico WH, it is time to test it
    with code.
  prefs: []
  type: TYPE_NORMAL
- en: Testing our RGB LED circuit
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To test out our RGB LED circuit, we will run code to turn on each of the three
    colors. We will write our code in MicroPython and use the Thonny IDE.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test our RGB LED with code, we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: We connect our Raspberry Pi Pico WH to a USB port and launch Thonny. We may
    use our Raspberry Pi or another operating system for this. If MicroPython has
    not been installed, we follow the steps from the *Using a Raspberry Pi Pico W
    with MQTT* section in [*Chapter 6*](B21282_06.xhtml#_idTextAnchor091), to install
    it on our Raspberry Pi Pico WH.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then activate the MicroPython environment on our Pico by selecting it from
    the bottom right-hand side of the screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In a new tab in the editor section (hit *Ctrl* + *N*), we enter the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To save the file, we click on **File** | **Save as...** from the drop-down
    menu. This will open the following dialog:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.13 – Saving a file to our Raspberry Pi Pico](img/B21282_10_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.13 – Saving a file to our Raspberry Pi Pico
  prefs: []
  type: TYPE_NORMAL
- en: In this dialog, we are given the option to choose where to store our file. To
    save it on our Raspberry Pi Pico WH, we click on the corresponding button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then give the file the name `main.py` and click `main.py` is special because
    the system automatically executes this file upon startup or reset, making it the
    default script that runs when the device powers up.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Before we test out our code, let’s break it down:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We start by importing the `Pin` class from the `machine` module and the `utime`
    module.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We then initialize GPIO pins GP15, GP13, and GP12 as output for red, green,
    and blue LEDs, respectively.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We then define the `set_color(r, g, b)` function to control the RGB LED color.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We define an infinite loop:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We set the LED to red for 1 second.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We then change the LED to green for 1 second.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we set the LED to blue for 1 second.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: To run our code, we click on the green run button, hit *F5* on the keyboard
    or click on the **Run** menu option at the top, and then select **Run** **current
    script**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We should observe the RGB LED on our weather indicator cycle turning red, then
    green, then blue.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With our RGB LED successfully wired and tested, it is time to hook up the servo
    motor to our Raspberry Pi Pico WH.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the servo motor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With our RGB LED installed and tested, it is now time to shift our focus to
    the servo motor on our weather indicator. Echoing our approach in [*Chapter 3*](B21282_03.xhtml#_idTextAnchor048),
    integrating a servo motor into our design offers an excellent means to bridge
    the analog and digital worlds; it enables us to create an analog-style meter where
    a needle, moved precisely by the servo, visually represents various data points.
  prefs: []
  type: TYPE_NORMAL
- en: We will start by wiring up our servo motor before turning our attention to testing
    it through code.
  prefs: []
  type: TYPE_NORMAL
- en: Wiring up our servo motor
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For our weather indicator, we will be incorporating an SG90 servo motor. The
    SG90 servo typically comes with three wires: the power wire (usually red), the
    ground wire (usually brown or black), and the signal wire (usually orange or yellow).'
  prefs: []
  type: TYPE_NORMAL
- en: To wire our servo motor to our Raspberry Pi Pico WH, we will start by removing
    the wires from the connector housing just as we did in [*Chapter 3*](B21282_03.xhtml#_idTextAnchor048).
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.14 – Removing wires from the connector of the SG90 servo](img/B21282_10_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.14 – Removing wires from the connector of the SG90 servo
  prefs: []
  type: TYPE_NORMAL
- en: Instead of reinserting the wires into the connector housing, we’ll directly
    connect them to the pins of the Raspberry Pi Pico WH.
  prefs: []
  type: TYPE_NORMAL
- en: We will power our servo motor with the VBUS power port from our Raspberry Pi
    Pico WH, as VBUS provides the necessary 5V power supply directly from the USB
    connection, which is ideal for the typical operating voltage of most servo motors
    such as the SG90.
  prefs: []
  type: TYPE_NORMAL
- en: 'For wiring, use the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.15 – Wiring the servo motor to the Raspberry Pi Pico WH](img/B21282_10_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.15 – Wiring the servo motor to the Raspberry Pi Pico WH
  prefs: []
  type: TYPE_NORMAL
- en: 'The connections are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: VBUS power connects to the positive wire of the servo.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The signal wire connects to `GP14.`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GND connects to a GND port on the Raspberry Pi Pico WH.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: For simplicity, *Figure 10**.15* illustrates only the servo motor connected
    to the Raspberry Pi Pico WH. However, our actual circuit includes both the RGB
    LED and the servo motor.
  prefs: []
  type: TYPE_NORMAL
- en: With the servo motor connected to the Raspberry Pi Pico WH, it is time to test
    it with code.
  prefs: []
  type: TYPE_NORMAL
- en: Testing our servo motor
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To verify the functionality of our servo motor circuit, we’ll execute a test
    code that cycles the motor through a full 180-degree range, ending at its minimum
    position. Once the motor reaches this minimum point, we will attach the arrow
    to our device. We will write our code in MicroPython and use the Thonny IDE. Our
    code will be organized into two files: `servo.py`, dedicated to managing the servo
    motor’s control, and `main.py`, which will serve as the primary execution script.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To test our servo motor with code, we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: We connect our Raspberry Pi Pico WH to a USB port on our computer and launch
    Thonny. We may use our Raspberry Pi or another operating system for this.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then activate the MicroPython environment on our Pico by selecting it from
    the bottom right-hand side of the screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will start with the code to control the servo motor. In a new tab in the
    editor section (hit *Ctrl* + *N*), we enter the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In our code, we start by importing the necessary modules: `Pin` and `PWM` from
    `machine` for hardware control and `utime` for time-related functions.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We then define the `Servo` class to control a servo motor:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The `__init__()` method initializes the servo on a specified GPIO pin as a
    `set_position()` method sets the servo to a specified angle:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We invert the angle to allow for reversed movement of the servo.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We then convert this reversed angle to a corresponding PWM duty cycle.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We use the `duty_u16()` method to set the duty cycle, scaling it to a 16-bit
    value for PWM control.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: To save the file, we click on **File** | **Save as...** from the drop-down menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We are given the option to choose where to store our file. To save it on our
    Raspberry Pi Pico WH, we click on the corresponding button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then give the file the name `servo.py` and click **Ok**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To create our `main.py` file, we open a new editor tab in the editor section
    (hit *Ctrl* + *N*) and enter the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In our code, we have the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We start by importing the `Servo` class from our newly created `servo` module
    and `utime` for timing functions.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We then create an instance of the `Servo` class that we call `servo`, using
    GPIO pin GP`14`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Our code moves the servo to 0 degrees and waits for 1 second.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Our code then adjusts the servo to 90 degrees and waits for another 1 second.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We set the servo to 180 degrees, followed by a 1-second pause.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, our code returns the servo to the initial position of 0 degrees.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: To run our code, we click on the green run button, hit *F5* on the keyboard
    or click on the **Run** menu option at the top, and then select **Run** **current
    script**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We should observe our servo motor go through a range of motions before stopping
    at the minimum position. One notable improvement with using the Raspberry Pi Pico
    WH over the Raspberry Pi 5 for connecting servo motors is the absence of servo
    motor jittering. The servo motor exhibits less jitter when used with the Raspberry
    Pi Pico WH compared to the Raspberry Pi due to the Pico’s direct, hardware-level
    PWM control, which ensures more precise and stable signal delivery to the servo.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is at this point where we place the arrow on the servo motor. We place the
    arrow such that it is pointing toward the gloves on our graphic. The arrow should
    fit snuggly; however, a bit of sanding may be required to get it to fit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.16 – Placing the needle at the zero position](img/B21282_10_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.16 – Placing the needle at the zero position
  prefs: []
  type: TYPE_NORMAL
- en: Having successfully wired and tested the RGB LED and servo motor with our Raspberry
    Pi Pico WH, we’re now ready to develop the code that will control our weather
    indicator, utilizing data extracted from MQTT messages.
  prefs: []
  type: TYPE_NORMAL
- en: Programming our weather indicator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The development of our weather indicator is streamlined, as the components’
    direct placement on the faceplate allows for immediate code implementation and
    testing, eliminating the need for breadboarding. This also reduces the chance
    of error as we do not need to configure the circuit a second time.
  prefs: []
  type: TYPE_NORMAL
- en: The software architecture of our application is shown in the following figure.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.17 – Weather display code layout](img/B21282_10_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.17 – Weather display code layout
  prefs: []
  type: TYPE_NORMAL
- en: Our code is organized into three files, each containing a distinct class. The
    `main.py` file houses the `WeatherDisplay` class, which retrieves and parses MQTT
    messages from our CloudAMQP instance. Based on the temperature value in these
    messages, the `WeatherDisplay` class adjusts the servo position (and thus the
    weather indicator’s needle) using the `Servo` class. It also interprets humidity
    data to control the RGB LED’s color via the `Indicator` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create our weather indicator code, we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: We connect our Raspberry Pi Pico WH from our weather indicator to a USB port
    on our computer and launch Thonny. We may use our Raspberry Pi or another operating
    system for this.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then activate the MicroPython environment on our Pico WH by selecting it
    from the bottom right-hand side of the screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will start with the code to control the RGB LED. This code will introduce
    the `Indicator` class, designed to manage the RGB LED’s color transition from
    red to green to blue, reflecting changes in humidity levels. In a new tab in the
    editor section (hit *Ctrl* + *N*), we enter the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In our code, we have the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We start by importing the `Pin` class from the `machine` module and `utime`
    for handling time-based functions.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We define the `Indicator` class and initialize it with three attributes representing
    red, green, and blue LEDs, set as output pins on GP15, GP13, and GP12, respectively.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The `set_color()` method controls the state of each color in the RGB LED based
    on the input parameters. In this method, for a common anode RGB LED, a binary
    `0` activates a color (turns it on), while a `1` deactivates it (turns it off).
    The method is used to selectively turn on either the red, green, or blue component
    of the LED.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We then create the `set_indicator()` method:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Our code turns off all LEDs initially.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Our code turns on the red LED for values ≤ 30, the green LED for values between
    30 and 50, and the blue LED for values > 50.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: In our `flash_led()` method, we flash all three LEDs (white light) for a specified
    number of times (`times`), with each flash lasting 0.5 seconds with a 0.5-second
    interval where LEDs are off.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: To save the file, we click on **File** | **Save as...** from the drop-down menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We are given the option to choose where to store our file. To save it on our
    Raspberry Pi Pico WH, we click on the corresponding button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then give the file the name `indicator.py` and click **Ok**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The second class in our code is a new version of the servo class. To create
    this class, we open a new tab in the editor section (hit *Ctrl* + *N*), and enter
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In our code, we start by importing the `Pin` and `PWM` modules from `machine`,
    and `utime` for time-related functions.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We then define the `Servo` class to control servo motors:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the constructor (`__init__()`), we initialize a PWM object on the specified
    pin.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We set the PWM frequency to 50 Hz, a standard frequency suitable for servo motors.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We then create a `set_position()` method that does the following:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Converts the input value into an integer.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Maps the input range (0-40) to a servo angle range (0-180 degrees) in reverse
    to align with the installation of our servo motor.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensures the calculated angle is within the valid range (0-180 degrees).
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Converts the angle to a duty cycle suitable for the servo.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Sets the PWM duty cycle to position the servo.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: To save the file, we click on **File** | **Save as...** from the drop-down menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We are given the option to choose where to store our file. To save it on our
    Raspberry Pi Pico WH, we click on the corresponding button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then give the file the name `servo.py` and click **Ok**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `WeatherDisplay` class, located in the main execution file, is responsible
    for subscribing to the `WeatherInfo` MQTT topic and handling the messages received.
    For its operation, the `micropython-umqtt.simple` library is necessary. To install
    this library, refer to the *Improving on our IoT button with the Raspberry Pi
    Pico W* section in [*Chapter 7*](B21282_07.xhtml#_idTextAnchor107).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To create the `WeatherDisplay` class, we begin by entering the import statements
    in a new tab in the editor section (hit *Ctrl* + *N*):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In our code, we do the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We import the `network` module for Wi-Fi connectivity functions.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We import the `utime` module for time-related functions.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Our code imports `MQTTClient` from `umqtt.simple` to handle MQTT communications.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We import our `Servo` class from our newly created local module for servo motor
    control.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We then import our `Indicator` class from our newly created local module for
    RGB LED indicator control.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We then define the class name and initialization method where we define our
    Wi-Fi and MQTT parameters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `connect_wifi()` method establishes a connection between the Raspberry
    Pi Pico WH and the local Wi-Fi network. It continuously attempts to connect until
    successful, and upon establishing a connection, it indicates success by flashing
    the RGB LED in white four times:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We use the `connect_mqtt()` method to connect to our CloudAMQP instance and
    subscribe to the `WeatherInfo` topic (as set by the `mqtt_topic`) variable and
    set our callback function to `on_message_received()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `on_message_received()` function processes received MQTT messages by parsing
    temperature and humidity data and then updating the servo position and RGB LED
    indicator accordingly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `parse_message()` function extracts and returns temperature and humidity
    values from a decoded MQTT message, handling any exceptions and returning `None`
    values if parsing fails:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `run` method, the final method defined in the `WeatherDisplay` class, initiates
    the Wi-Fi connection, connects to the MQTT client, and continuously checks for
    MQTT messages, handling any errors encountered during message reception:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After writing the `WeatherDisplay` class code, we instantiate it and call its
    `run()` method, initiating the weather display functionality, which includes establishing
    Wi-Fi and MQTT connections and processing incoming messages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To save our file, we click on **File** | **Save as...** from the drop-down menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We are given the option to choose where to store our file. To save it on our
    Raspberry Pi Pico WH, we click on the corresponding button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then give the file the name `main.py` and click **Ok**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To run our code, we click on the green run button, hit *F5* on the keyboard,
    or click on the **Run** menu option at the top, and then select **Run** **current
    script**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We should observe the RGB LED flashing four times after connection to our Wi-Fi
    network.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We should observe that the arrow moves to a position indicating the temperature
    coming from the temperature sensor on our LoRa sensory transmitter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We should observe that the color of the RGB LED is either red, green, or blue,
    indicating the humidity level measured by our LoRa sensory transmitter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.18 – The three devices that make up our IoT weather service, starting
    from the left, are the LoRa sensory transmitter (Chapter 9), the LoRa receiver/internet
    gateway (Chapter 9), and the analog-metered weather indicator](img/B21282_10_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.18 – The three devices that make up our IoT weather service, starting
    from the left, are the LoRa sensory transmitter ([*Chapter 9*](B21282_09.xhtml#_idTextAnchor140)),
    the LoRa receiver/internet gateway ([*Chapter 9*](B21282_09.xhtml#_idTextAnchor140)),
    and the analog-metered weather indicator
  prefs: []
  type: TYPE_NORMAL
- en: With the completion of our project, we’ve successfully built an IoT weather
    service and display console, combining real-time data collection with an interactive
    display. This system utilizes MQTT for data transmission, servo motors for representing
    data physically, and an RGB LED for visual alerts.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring other IoT communication protocols
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: LoRaWAN, operating on the same sub-gigahertz radio frequencies as LoRa, is an
    advanced protocol for wireless communication that enables long-range transmissions
    with low power consumption. This shared frequency band is a key feature that allows
    both LoRaWAN and LoRa to transmit data over several kilometers, which is especially
    beneficial in areas where traditional connectivity is scarce.
  prefs: []
  type: TYPE_NORMAL
- en: In the context of IoT applications such as weather monitoring, LoRaWAN offers
    significant advantages. For example, a network of sensors collecting environmental
    data such as temperature and humidity could transmit this information over long
    distances to a central gateway connected to the internet, leveraging LoRa’s long-range
    capabilities. This gateway then relays the data to a cloud server for processing
    and analysis.
  prefs: []
  type: TYPE_NORMAL
- en: However, for our weather indicator project, using the full LoRaWAN setup would
    be considered overkill. Our project utilizes a simpler setup involving two Raspberry
    Pi Pico microcontrollers – one equipped with LoRa for data transmission (Raspberry
    Pi Pico) and the other with Wi-Fi capability (Raspberry Pi Pico W). This setup
    effectively demonstrates the capabilities of LoRa for short-range IoT communication,
    capitalizing on the same long-range, low-power characteristics of the LoRa frequencies,
    but without the complexity and infrastructure requirements of a complete LoRaWAN
    network.
  prefs: []
  type: TYPE_NORMAL
- en: Cellular services can also be used for IoT communication, offering extensive
    coverage and higher data transfer speeds. Cellular IoT devices, such as those
    using 4G LTE or 5G networks, can transmit larger amounts of data over long distances.
    This makes cellular services suitable for more data-intensive applications or
    those requiring real-time, high-speed communication.
  prefs: []
  type: TYPE_NORMAL
- en: While cellular IoT offers broader coverage and higher data throughput, it often
    comes with higher power consumption and complexity compared to LoRa-based solutions.
    Thus, for small-scale or low-power projects such as our weather indicator, the
    simplicity and efficiency of using LoRa modules with Raspberry Pi Pico microcontrollers
    provide a more suitable and cost-effective solution.
  prefs: []
  type: TYPE_NORMAL
- en: '**Sigfox** is a global network operator providing dedicated cellular connectivity
    for IoT and **Machine-to-Machine** (**M2M**) communications. It uses a unique
    technology for wireless transmission that allows for long-range, low-power communication.
    Sigfox operates in the sub-gigahertz frequency band and is designed for small
    data payload transmissions, typically up to 12 bytes per message. This limited
    data capacity makes it ideal for devices that need to send small, infrequent bursts
    of data, such as sensors in smart meters, agricultural monitors, and asset tracking
    systems. Sigfox’s network architecture is distinguished by its simplicity, efficiency,
    and cost-effectiveness, making it a popular choice for applications where low-cost
    and low-power operations are critical.'
  prefs: []
  type: TYPE_NORMAL
- en: 'LoRaWAN, cellular networks, and Sigfox are among the leading communication
    protocols used in IoT applications. Each has its unique features and use cases.
    Here’s a comparative table outlining their advantages and disadvantages:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Protocol** | **Advantages** | **Disadvantages** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| LoRaWAN |'
  prefs: []
  type: TYPE_TB
- en: Long range (up to 15 km)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Low power consumption
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Good penetration in urban environments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Open protocol with a growing ecosystem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Lower data rates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Limited bandwidth and duty cycle restrictions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Requires gateway for internet connectivity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| Cellular (4G/5G) |'
  prefs: []
  type: TYPE_TB
- en: High data throughput
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wide coverage and reliability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Supports real-time communication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Well-established infrastructure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Higher power consumption
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Subscription costs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Potentially overpowered for simple tasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| Sigfox |'
  prefs: []
  type: TYPE_TB
- en: Ultra-low power consumption
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Long-range capabilities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simple to deploy and maintain
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ideal for small, infrequent data transmissions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Very limited data payload (12 bytes/message)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Limited to 140 messages per day
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Proprietary technology with limited flexibility
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| LoRa with Wi-Fi microcontroller |'
  prefs: []
  type: TYPE_TB
- en: Long range (up to 15 km for LoRa)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Low power consumption for LoRa transmissions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cost-effective solution for small-scale projects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flexible and easy integration with existing Wi-Fi networks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Limited to the range of the Wi-Fi network for internet connectivity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tied to a single microcontroller and may not be used for mobile applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Requires additional hardware (Wi-Fi microcontroller) for internet connectivity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: May require a more complex setup and coding compared to using a single protocol
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Table 10.1 – Comparing IoT communication protocols
  prefs: []
  type: TYPE_NORMAL
- en: 'Each protocol serves different IoT scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: '**LoRaWAN**: Ideal for applications requiring long-range communication and
    low power usage, such as agricultural sensors or smart city applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cellular networks**: Suitable for high-data, real-time applications such
    as video surveillance, automotive applications, or any scenario requiring broad
    geographic coverage.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sigfox**: Excels in scenarios where devices only need to send small amounts
    of data over long distances, such as utility metering or asset tracking.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**LoRa with Wi-Fi microcontroller**: Best for small-scale, localized IoT projects
    requiring the long-range capability of LoRa and the internet connectivity provided
    by Wi-Fi, such as home automation, local environmental monitoring, or DIY IoT
    projects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For small-scale or low-power projects such as our weather indicator, using LoRa
    modules with Raspberry Pi Pico microcontrollers presents a more suitable and cost-effective
    solution than the options mentioned. LoRa with microcontrollers balances range,
    data handling, and power efficiency without the need for more complex infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we integrated LoRa-based data transmission with internet connectivity
    using MQTT. We modified our CircuitPython-based LoRa receiver’s code, allowing
    it to send sensory data to the CloudAMQP server, transforming it into an internet
    gateway. The weather indicator was upgraded, replacing the Raspberry Pi 5 and
    single-color LED with a Raspberry Pi Pico WH and an RGB LED, which displayed temperature
    and humidity data via MQTT messages.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, we constructed a new split stand for the indicator, designed for
    easy assembly and improved stability. We concluded the chapter by examining IoT
    communication protocols such as LoRaWAN, cellular networks, and Sigfox, assessing
    their suitability for different IoT applications.
  prefs: []
  type: TYPE_NORMAL
- en: We engaged in a hands-on exploration of integrating LoRa with internet connectivity
    via MQTT, a practical demonstration of how disparate technologies can work together
    in IoT applications. By upgrading the weather indicator, we not only learned about
    iterative design and troubleshooting but also gained insights into the decision-making
    process involved in IoT projects, such as choosing the Raspberry Pi Pico WH over
    the Raspberry Pi 5 for controlling servo motors.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter marks the end of the book’s third part, focused on IoT communications
    with an emphasis on LoRa. In the next chapter, we transition to robotics, where
    we’ll start on our journey to build an internet-connected robot car.
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 4: Building an IoT Robot Car'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this part, we use all the knowledge we’ve gained from the previous chapters
    to build an IoT robot car that is controlled through the internet. This project
    will be the most advanced and demonstrate the ultimate power of IoT technology,
    controlling anything from anywhere.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part has the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 11*](B21282_11.xhtml#_idTextAnchor173), *Introducing ROS*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 12*](B21282_12.xhtml#_idTextAnchor195), *Creating an IoT Joystick*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 13*](B21282_13.xhtml#_idTextAnchor209), *Introducing Advanced Robotic
    Eyes for Security (A.R.E.S.)*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 14*](B21282_14.xhtml#_idTextAnchor228), *Adding Computer Vision to
    A.R.E.S.*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
