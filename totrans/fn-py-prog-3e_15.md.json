["```py\nimport urllib.request \n\ndef urllib_get(url: str) -> tuple[int, str]: \n    with urllib.request.urlopen(url) as response: \n        body_bytes = response.read() \n        encoding = response.headers.get_content_charset(\"utf-8\") \n        return response.status, body_bytes.decode(encoding)\n```", "```py\nfrom http.server import HTTPServer, SimpleHTTPRequestHandler \nfrom typing import NoReturn \n\ndef server_demo() -> NoReturn: \n    httpd = HTTPServer( \n          (’localhost’, 8080), \n          SimpleHTTPRequestHandler \n    ) \n    print(f\"Serving on http://localhost:8080...\") \n    while True: \n        httpd.handle_request() \n    httpd.shutdown()\n```", "```py\nresponse = httpd(request)\n```", "```py\nheaders, content = httpd( \n    headers, request, [attachments, either forms or uploads] \n)\n```", "```py\nresponse = content( \n    authentication( \n        csrf( \n            session(headers, request, forms) \n        ) \n    ) \n)\n```", "```py\ndef some_app(environ, start_response): \n    # compute the status, headers, and content of the response \n    start_response(status, headers) \n    return content\n```", "```py\nfrom sys import _OptExcInfo \nfrom typing import Any, Callable, Dict, Iterable, Protocol \n\nclass StartResponse(Protocol): \n    def __call__( \n        self, status: str, headers: list[tuple[str, str]], exc_info: \"_OptExcInfo\" | None = ... \n    ) -> Callable[[bytes], Any]: ... \n\nWSGIEnvironment = Dict[str, Any] \nWSGIApplication = Callable[[WSGIEnvironment, StartResponse], Iterable[bytes]]\n```", "```py\nfrom typing import TYPE_CHECKING \n\nif TYPE_CHECKING: \n    from _typeshed.wsgi import ( \n        WSGIApplication, WSGIEnvironment, StartResponse \n    ) \n\ndef static_text_app( \n    environ: \"WSGIEnvironment\", \n    start_response: \"StartResponse\" \n) -> Iterable[bytes]: \n    ...\n```", "```py\nfrom wsgiref.simple_server import demo_app \n\nSCRIPT_MAP: dict[str, \"WSGIApplication\"] = { \n    \"demo\": demo_app, \n    \"static\": static_text_app, \n    \"index.html\": welcome_app, \n    \"\": welcome_app, \n} \n\ndef routing( \n        environ: \"WSGIEnvironment\", \n        start_response: \"StartResponse\" \n) -> Iterable[bytes]: \n    top_level = wsgiref.util.shift_path_info(environ) \n    if top_level: \n        app = SCRIPT_MAP.get(top_level, welcome_app) \n    else: \n        app = welcome_app \n    content = app(environ, start_response) \n    return content\n```", "```py\ndef headers(content: bytes) -> list[tuple[str, str]]: \n    return [ \n        (\"Content-Type\", ’text/plain;charset=\"utf-8\"’), \n        (\"Content-Length\", str(len(content))), \n    ] \n\ndef static_text_app( \n    environ: \"WSGIEnvironment\", \n    start_response: \"StartResponse\" \n) -> Iterable[bytes]: \n    log = environ[’wsgi.errors’] \n    try: \n        static_path = Path.cwd() / environ[’PATH_INFO’][1:] \n        with static_path.open() as static_file: \n            print(f\"{static_path=}\", file=log) \n            content = static_file.read().encode(\"utf-8\") \n            start_response(’200 OK’, headers(content)) \n            return [content] \n    except IsADirectoryError as exc: \n        return index_app(environ, start_response) \n    except FileNotFoundError as exc: \n        print(f\"{static_path=} {exc=}\", file=log) \n        message = f\"Not Found {environ[’PATH_INFO’]}\".encode(\"utf-8\") \n        start_response(’404 NOT FOUND’, headers(message)) \n        return [message]\n```", "```py\nhttp://localhost:8080/anscombe/III?form=csv\n```", "```py\nfrom flask import Flask \n\napp = Flask(__name__)\n```", "```py\nfrom pathlib import Path \n\napp.config[’FILE_PATH’] = Path.cwd() / \"Anscombe.txt\"\n```", "```py\nfrom flask import request, abort, make_response, Response \n\n@app.route(\"/anscombe/\") \ndef index_view() -> Response: \n    # 1\\. Validate \n    response_format = format() \n    # 2\\. Get data \n    data = get_series_map(app.config[’FILE_PATH’]) \n    index_listofdicts = [{\"Series\": k} for k in data.keys()] \n    # 3\\. Prepare Response \n    try: \n        content_bytes = serialize(response_format, index_listofdicts, document_tag=\"Index\", row_tag=\"Series\") \n        response = make_response(content_bytes, 200, {\"Content-Type\": response_format}) \n        return response \n    except KeyError: \n        abort(404, f\"Unknown {response_format=}\")\n```", "```py\ndef format() -> str: \n    if arg := request.args.get(’form’): \n        try: \n            return { \n                ’xml’: ’application/xml’, \n                ’html’: ’text/html’, \n                ’json’: ’application/json’, \n                ’csv’: ’text/csv’, \n            }[arg] \n        except KeyError: \n            abort(404, \"Unknown ?form=\") \n    else: \n        return request.accept_mimetypes.best or \"text/html\"\n```", "```py\n@app.route(\"/anscombe/<series_id>\") \ndef series_view(series_id: str, form: str | None = None) -> Response: \n    # 1\\. Validate \n    response_format = format() \n    # 2\\. Get data (and validate some more) \n    data = get_series_map(app.config[’FILE_PATH’]) \n    try: \n        dataset = anscombe_filter(series_id, data)._as_listofdicts() \n    except KeyError: \n        abort(404, \"Unknown Series\") \n    # 3\\. Prepare Response \n    try: \n        content_bytes = serialize(response_format, dataset, document_tag=\"Series\", row_tag=\"Pair\") \n        response = make_response( \n            content_bytes, 200, {\"Content-Type\": response_format} \n        ) \n        return response \n    except KeyError: \n        abort(404, f\"Unknown {response_format=}\")\n```", "```py\nfrom Chapter03.ch03_ex4 import ( \n    series, head_split_fixed, row_iter) \nfrom collections.abc import Callable, Iterable \nfrom typing import NamedTuple, Any, cast \n\nclass Pair(NamedTuple): \n    x: float \n    y: float \n\n    @classmethod \n    def create(cls: type[\"Pair\"], source: Iterable[str]) -> \"Pair\": \n        return Pair(*map(float, source)) \n\nclass Series(NamedTuple): \n    series: str \n    data: list[Pair] \n\n    @classmethod \n    def create(cls: type[\"Series\"], name: str, source: Iterable[tuple[str, str]]) -> \"Series\": \n        return Series(name, list(map(Pair.create, source))) \n\n    def _as_listofdicts(self) -> list[dict[str, Any]]: \n        return [p._asdict() for p in self.data]\n```", "```py\nfrom pathlib import Path \n\ndef get_series_map(source_path: Path) -> dict[str, Series]: \n    with source_path.open() as source: \n        raw_data = list(head_split_fixed(row_iter(source))) \n        series_iter = ( \n            Series.create(id_str, series(id_num, raw_data)) \n            for id_num, id_str in enumerate( \n                [’I’, ’II’, ’III’, ’IV’]) \n        ) \n        mapping = { \n            series.series: series \n            for series in series_iter \n        } \n    return mapping\n```", "```py\n>>> source = Path.cwd() / \"Anscombe.txt\" \n>>> get_series_map(source)[’I’] \nSeries(series=’I’, data=[Pair(x=10.0, y=8.04), Pair(x=8.0, y=6.95), ...])\n```", "```py\ndef anscombe_filter( \n    set_id: str, raw_data_map: dict[str, Series] \n) -> Series: \n    return raw_data_map[set_id]\n```", "```py\nfrom collections.abc import Callable \nfrom typing import Any, TypeAlias \n\nSerializer: TypeAlias = Callable[[list[dict[str, Any]]], bytes]\n```", "```py\nSERIALIZERS: dict[str, Serializer] = {\n'application/xml': serialize_xml,\n'text/html': serialize_html,\n'application/json': serialize_json,\n'text/csv': serialize_csv,\n}\n\n```", "```py\ndef serialize( \n    format: str | None, \n    data: list[dict[str, Any]], \n    **kwargs: str \n) -> bytes: \n    \"\"\"Relies on global SERIALIZERS, set separately\"\"\" \n    if format is None: \n        format = \"text/html\" \n    function = SERIALIZERS.get( \n        format.lower(), \n        serialize_html \n    ) \n    return function(data, **kwargs)\n```", "```py\nfrom collections.abc import Callable \nfrom typing import TypeVar, ParamSpec \nfrom functools import wraps \n\nT = TypeVar(\"T\") \nP = ParamSpec(\"P\") \n\ndef to_bytes( \n    function: Callable[P, str] \n) -> Callable[P, bytes]: \n    @wraps(function) \n    def decorated(*args: P.args, **kwargs: P.kwargs) -> bytes: \n        text = function(*args, **kwargs) \n        return text.encode(\"utf-8\") \n    return decorated\n```", "```py\nimport json \n\n@to_bytes \ndef serialize_json(data: list[dict[str, Any]], **kwargs: str) -> str: \n    text = json.dumps(data, sort_keys=True) \n    return text\n```", "```py\nimport csv \nimport io \n\n@to_bytes \ndef serialize_csv(data: list[dict[str, Any]], **kwargs: str) -> str: \n    buffer = io.StringIO() \n    wtr = csv.DictWriter(buffer, sorted(data[0].keys())) \n    wtr.writeheader() \n    wtr.writerows(data) \n    return buffer.getvalue()\n```", "```py\n<?xml version=\"1.0\" encoding=\"UTF-8\"?> \n<Series> \n<Pair><x>2</x><y>3</y></Pair> \n<Pair><x>5</x><y>7</y></Pair> \n</Series>\n```", "```py\n>>> import secrets \n>>> secrets.token_urlsafe(24) \n’NLHirCPVf-S7aSAiaAJo3JECYk9dSeyq’\n```"]