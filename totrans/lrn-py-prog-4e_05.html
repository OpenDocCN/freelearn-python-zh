<html><head></head><body>
  <div class="Basic-Text-Frame" id="_idContainer112">
   <h1 class="chapterNumber">
    <span class="koboSpan" id="kobo.1.1">
     5
    </span>
   </h1>
   <h1 class="chapterTitle" id="_idParaDest-161">
    <span class="koboSpan" id="kobo.2.1">
     Comprehensions and Generators
    </span>
   </h1>
   <blockquote class="packt_quote">
    <p class="quote">
     <span class="koboSpan" id="kobo.3.1">
      ”It’s not the daily increase but daily decrease.
     </span>
     <span class="koboSpan" id="kobo.3.2">
      Hack away at the unessential.”
     </span>
    </p>
    <p class="cite">
     <span class="koboSpan" id="kobo.4.1">
      —Bruce Lee
     </span>
    </p>
   </blockquote>
   <p class="normal">
    <span class="koboSpan" id="kobo.5.1">
     The second part of the above quote, “hack away at the unessential,” is to us what makes a computer program elegant.
    </span>
    <span class="koboSpan" id="kobo.5.2">
     We constantly strive to find better ways of doing things so that we do not waste time or memory.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.6.1">
     There are valid reasons for not pushing our code up to the maximum limit.
    </span>
    <span class="koboSpan" id="kobo.6.2">
     For example, sometimes we have to sacrifice readability or maintainability to achieve a negligible improvement.
    </span>
    <span class="koboSpan" id="kobo.6.3">
     It does not make sense to have a web page served in 1 second with unreadable, complicated code when we could serve it in 1.05 seconds with readable, clean code.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.7.1">
     On the other hand, sometimes it is perfectly reasonable to try to shave off a millisecond from a function, especially when the function is meant to be called thousands of times.
    </span>
    <span class="koboSpan" id="kobo.7.2">
     One millisecond saved over thousands of calls adds up to seconds saved overall, which might be meaningful for your application.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.8.1">
     In light of these considerations, the focus of this chapter will not be to give you the tools to push your code to the absolute limits of performance and optimization
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.9.1">
      no matter what
     </span>
    </em>
    <span class="koboSpan" id="kobo.10.1">
     , but rather to enable you to write efficient, elegant code that reads well, runs fast, and does not waste resources in an obvious way.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.11.1">
     In this chapter, we are going to cover the following:
    </span>
   </p>
   <ul>
    <li class="bulletList">
     <span class="koboSpan" id="kobo.12.1">
      The
     </span>
     <code class="inlineCode">
      <span class="koboSpan" id="kobo.13.1">
       map()
      </span>
     </code>
     <span class="koboSpan" id="kobo.14.1">
      ,
     </span>
     <code class="inlineCode">
      <span class="koboSpan" id="kobo.15.1">
       zip()
      </span>
     </code>
     <span class="koboSpan" id="kobo.16.1">
      , and
     </span>
     <code class="inlineCode">
      <span class="koboSpan" id="kobo.17.1">
       filter()
      </span>
     </code>
     <span class="koboSpan" id="kobo.18.1">
      functions
     </span>
    </li>
    <li class="bulletList">
     <span class="koboSpan" id="kobo.19.1">
      Comprehensions
     </span>
    </li>
    <li class="bulletList">
     <span class="koboSpan" id="kobo.20.1">
      Generators
     </span>
    </li>
    <li class="bulletList">
     <span class="koboSpan" id="kobo.21.1">
      Performance
     </span>
    </li>
   </ul>
   <p class="normal">
    <span class="koboSpan" id="kobo.22.1">
     We will perform several measurements and comparisons and cautiously draw some conclusions.
    </span>
    <span class="koboSpan" id="kobo.22.2">
     Please do keep in mind that on a different machine with a different setup or operating system, results may vary.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.23.1">
     Take a look at this code:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.24.1"># squares.py</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.25.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.26.1">square1</span></span><span class="koboSpan" id="kobo.27.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.28.1">n</span></span><span class="koboSpan" id="kobo.29.1">):
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.30.1">return</span></span><span class="koboSpan" id="kobo.31.1"> n**</span><span class="hljs-number"><span class="koboSpan" id="kobo.32.1">2</span></span>  <span class="hljs-comment"><span class="koboSpan" id="kobo.33.1"># squaring through the power operator</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.34.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.35.1">square2</span></span><span class="koboSpan" id="kobo.36.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.37.1">n</span></span><span class="koboSpan" id="kobo.38.1">):
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.39.1">return</span></span><span class="koboSpan" id="kobo.40.1"> n * n  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.41.1"># squaring through multiplication</span></span>
</code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.42.1">
     Both functions return the square of
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.43.1">
      n
     </span>
    </code>
    <span class="koboSpan" id="kobo.44.1">
     , but which is faster?
    </span>
    <span class="koboSpan" id="kobo.44.2">
     From a simple benchmark that we ran, it looks like the second is slightly faster.
    </span>
    <span class="koboSpan" id="kobo.44.3">
     If you think about it, it makes sense: calculating the power of a number involves multiplication.
    </span>
    <span class="koboSpan" id="kobo.44.4">
     Therefore, whatever algorithm you may use to perform the power operation, it is not likely to beat a simple multiplication such as the one in
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.45.1">
      square2
     </span>
    </code>
    <span class="koboSpan" id="kobo.46.1">
     .
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.47.1">
     Do we care about this result?
    </span>
    <span class="koboSpan" id="kobo.47.2">
     In most cases, no.
    </span>
    <span class="koboSpan" id="kobo.47.3">
     If you are coding an e-commerce website, chances are you will never need to raise a number to the second power, and if you do, it is likely to be a sporadic operation.
    </span>
    <span class="koboSpan" id="kobo.47.4">
     You do not need to concern yourself with saving a fraction of a microsecond on a function you call a few times.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.48.1">
     So, when does optimization become important?
    </span>
    <span class="koboSpan" id="kobo.48.2">
     One common case is when you have to deal with huge collections of data.
    </span>
    <span class="koboSpan" id="kobo.48.3">
     If you are applying the same function on a million
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.49.1">
      customer
     </span>
    </code>
    <span class="koboSpan" id="kobo.50.1">
     objects, then you want your function to be tuned up to its best.
    </span>
    <span class="koboSpan" id="kobo.50.2">
     Gaining one-tenth of a second on a function called one million times saves you 100,000 seconds, which is about 27.7 hours.
    </span>
    <span class="koboSpan" id="kobo.50.3">
     So, let us focus on collections, and see which tools Python gives you to handle them with efficiency and grace.
    </span>
   </p>
   <div class="note">
    <p class="normal">
     <span class="koboSpan" id="kobo.51.1">
      Many of the concepts we will see in this chapter are based on iterators and iterables, which we encountered in
     </span>
     <em class="chapterRef">
      <span class="koboSpan" id="kobo.52.1">
       Chapter 3
      </span>
     </em>
     <span class="koboSpan" id="kobo.53.1">
      ,
     </span>
     <em class="chapterRef">
      <span class="koboSpan" id="kobo.54.1">
       Conditionals and Iteration
      </span>
     </em>
     <span class="koboSpan" id="kobo.55.1">
      .
     </span>
     <span class="koboSpan" id="kobo.55.2">
      We will see how to code a custom iterator and iterable objects in
     </span>
     <em class="chapterRef">
      <span class="koboSpan" id="kobo.56.1">
       Chapter 6
      </span>
     </em>
     <span class="koboSpan" id="kobo.57.1">
      ,
     </span>
     <em class="chapterRef">
      <span class="koboSpan" id="kobo.58.1">
       OOP, Decorators, and Iterators
      </span>
     </em>
     <span class="koboSpan" id="kobo.59.1">
      .
     </span>
    </p>
   </div>
   <p class="normal">
    <span class="koboSpan" id="kobo.60.1">
     Some of the objects we are going to explore in this chapter are iterators, which save memory by only operating on a single element of a collection at a time rather than creating a modified copy.
    </span>
    <span class="koboSpan" id="kobo.60.2">
     As a result, some extra work is needed if we just want to show the result of the operation.
    </span>
    <span class="koboSpan" id="kobo.60.3">
     We will often resort to wrapping the iterator in a
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.61.1">
      list()
     </span>
    </code>
    <span class="koboSpan" id="kobo.62.1">
     constructor.
    </span>
    <span class="koboSpan" id="kobo.62.2">
     This is because passing an iterator to
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.63.1">
      list()
     </span>
    </code>
    <span class="koboSpan" id="kobo.64.1">
     exhausts it and puts all the generated items in a newly created list, which we can easily print to show you its content.
    </span>
    <span class="koboSpan" id="kobo.64.2">
     Let us see an example of using the technique on a
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.65.1">
      range
     </span>
    </code>
    <span class="koboSpan" id="kobo.66.1">
     object:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.67.1"># list.iterable.txt</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.68.1">&gt;&gt;&gt; </span></span><span class="hljs-built_in"><span class="koboSpan" id="kobo.69.1">range</span></span><span class="koboSpan" id="kobo.70.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.71.1">7</span></span><span class="koboSpan" id="kobo.72.1">)
</span><span class="code-highlight"><strong class="hljs-built_in-slc"><span class="koboSpan" id="kobo.73.1">range</span></strong><strong class="hljs-slc"><span class="koboSpan" id="kobo.74.1">(</span></strong><strong class="hljs-number-slc"><span class="koboSpan" id="kobo.75.1">0</span></strong><strong class="hljs-slc"><span class="koboSpan" id="kobo.76.1">, </span></strong><strong class="hljs-number-slc"><span class="koboSpan" id="kobo.77.1">7</span></strong><strong class="hljs-slc"><span class="koboSpan" id="kobo.78.1">)</span></strong></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.79.1">&gt;&gt;&gt; </span></span><span class="hljs-built_in"><span class="koboSpan" id="kobo.80.1">list</span></span><span class="koboSpan" id="kobo.81.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.82.1">range</span></span><span class="koboSpan" id="kobo.83.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.84.1">7</span></span><span class="koboSpan" id="kobo.85.1">))  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.86.1"># put all elements in a list to view them</span></span><span class="koboSpan" id="kobo.87.1">
[</span><span class="hljs-number"><span class="koboSpan" id="kobo.88.1">0</span></span><span class="koboSpan" id="kobo.89.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.90.1">1</span></span><span class="koboSpan" id="kobo.91.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.92.1">2</span></span><span class="koboSpan" id="kobo.93.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.94.1">3</span></span><span class="koboSpan" id="kobo.95.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.96.1">4</span></span><span class="koboSpan" id="kobo.97.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.98.1">5</span></span><span class="koboSpan" id="kobo.99.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.100.1">6</span></span><span class="koboSpan" id="kobo.101.1">]
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.102.1">
     We have highlighted the result of typing
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.103.1">
      range(7)
     </span>
    </code>
    <span class="koboSpan" id="kobo.104.1">
     into a Python console.
    </span>
    <span class="koboSpan" id="kobo.104.2">
     Notice that it does not show the contents of the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.105.1">
      range
     </span>
    </code>
    <span class="koboSpan" id="kobo.106.1">
     because
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.107.1">
      range
     </span>
    </code>
    <span class="koboSpan" id="kobo.108.1">
     never actually loads the entire sequence of numbers into memory.
    </span>
    <span class="koboSpan" id="kobo.108.2">
     The second highlighted line shows how wrapping the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.109.1">
      range
     </span>
    </code>
    <span class="koboSpan" id="kobo.110.1">
     in a
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.111.1">
      list()
     </span>
    </code>
    <span class="koboSpan" id="kobo.112.1">
     allows us to see the numbers it generates.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.113.1">
     Let us start looking at the various tools that Python provides for efficiently operating on collections of data.
    </span>
   </p>
   <h1 class="heading-1" id="_idParaDest-162">
    <span class="koboSpan" id="kobo.114.1">
     The map, zip, and filter functions
    </span>
   </h1>
   <p class="normal">
    <span class="koboSpan" id="kobo.115.1">
     We will start by reviewing
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.116.1">
      map()
     </span>
    </code>
    <span class="koboSpan" id="kobo.117.1">
     ,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.118.1">
      filter()
     </span>
    </code>
    <span class="koboSpan" id="kobo.119.1">
     , and
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.120.1">
      zip()
     </span>
    </code>
    <span class="koboSpan" id="kobo.121.1">
     , which are the main built-in functions you can employ when handling collections, and then we will learn how to achieve the same results using two important constructs:
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.122.1">
      comprehensions
     </span>
    </strong>
    <span class="koboSpan" id="kobo.123.1">
     and
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.124.1">
      generators
     </span>
    </strong>
    <span class="koboSpan" id="kobo.125.1">
     .
    </span>
   </p>
   <h2 class="heading-2" id="_idParaDest-163">
    <span class="koboSpan" id="kobo.126.1">
     map
    </span>
   </h2>
   <p class="normal">
    <span class="koboSpan" id="kobo.127.1">
     According
    </span>
    <a id="_idIndexMarker486">
    </a>
    <span class="koboSpan" id="kobo.128.1">
     to the official
    </span>
    <a id="_idIndexMarker487">
    </a>
    <span class="koboSpan" id="kobo.129.1">
     Python documentation (
    </span>
    <a href="https://docs.python.org/3/library/functions.html#map">
     <span class="url">
      <span class="koboSpan" id="kobo.130.1">
       https://docs.python.org/3/library/functions.html#map
      </span>
     </span>
    </a>
    <span class="koboSpan" id="kobo.131.1">
     ), the following is true:
    </span>
   </p>
   <blockquote class="packt_quote">
    <p class="quote">
     <span class="koboSpan" id="kobo.132.1">
      map(function, iterable, *iterables)
     </span>
    </p>
    <p class="quote">
     <span class="koboSpan" id="kobo.133.1">
      Return an iterator that applies function to every item of iterable, yielding the results.
     </span>
     <span class="koboSpan" id="kobo.133.2">
      If additional iterables arguments are passed, function must take that many arguments and is applied to the items from all iterables in parallel.
     </span>
     <span class="koboSpan" id="kobo.133.3">
      With multiple iterables, the iterator stops when the shortest iterable is exhausted.
     </span>
    </p>
   </blockquote>
   <p class="normal">
    <span class="koboSpan" id="kobo.134.1">
     We will explain the concept of yielding later in the chapter.
    </span>
    <span class="koboSpan" id="kobo.134.2">
     For now, let us translate this into code—we will use a
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.135.1">
      lambda
     </span>
    </code>
    <span class="koboSpan" id="kobo.136.1">
     function that takes a variable number of positional arguments, and returns
    </span>
    <a id="_idIndexMarker488">
    </a>
    <span class="koboSpan" id="kobo.137.1">
     them as a tuple:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.138.1"># map.example.txt</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.139.1">&gt;&gt;&gt; </span></span><span class="hljs-built_in"><span class="koboSpan" id="kobo.140.1">map</span></span><span class="koboSpan" id="kobo.141.1">(</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.142.1">lambda</span></span><span class="koboSpan" id="kobo.143.1"> *a: a, </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.144.1">range</span></span><span class="koboSpan" id="kobo.145.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.146.1">3</span></span><span class="koboSpan" id="kobo.147.1">))  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.148.1"># 1 iterable</span></span><span class="koboSpan" id="kobo.149.1">
&lt;</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.150.1">map</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.151.1">object</span></span><span class="koboSpan" id="kobo.152.1"> at </span><span class="hljs-number"><span class="koboSpan" id="kobo.153.1">0x7f0db97adae0</span></span><span class="koboSpan" id="kobo.154.1">&gt;  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.155.1"># Not useful! </span><span class="koboSpan" id="kobo.155.2">Let us use list</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.156.1">&gt;&gt;&gt; </span></span><span class="hljs-built_in"><span class="koboSpan" id="kobo.157.1">list</span></span><span class="koboSpan" id="kobo.158.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.159.1">map</span></span><span class="koboSpan" id="kobo.160.1">(</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.161.1">lambda</span></span><span class="koboSpan" id="kobo.162.1"> *a: a, </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.163.1">range</span></span><span class="koboSpan" id="kobo.164.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.165.1">3</span></span><span class="koboSpan" id="kobo.166.1">)))  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.167.1"># 1 iterable</span></span><span class="koboSpan" id="kobo.168.1">
[(</span><span class="hljs-number"><span class="koboSpan" id="kobo.169.1">0</span></span><span class="koboSpan" id="kobo.170.1">,), (</span><span class="hljs-number"><span class="koboSpan" id="kobo.171.1">1</span></span><span class="koboSpan" id="kobo.172.1">,), (</span><span class="hljs-number"><span class="koboSpan" id="kobo.173.1">2</span></span><span class="koboSpan" id="kobo.174.1">,)]
</span><span class="hljs-meta"><span class="koboSpan" id="kobo.175.1">&gt;&gt;&gt; </span></span><span class="hljs-built_in"><span class="koboSpan" id="kobo.176.1">list</span></span><span class="koboSpan" id="kobo.177.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.178.1">map</span></span><span class="koboSpan" id="kobo.179.1">(</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.180.1">lambda</span></span><span class="koboSpan" id="kobo.181.1"> *a: a, </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.182.1">range</span></span><span class="koboSpan" id="kobo.183.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.184.1">3</span></span><span class="koboSpan" id="kobo.185.1">), "abc"))  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.186.1"># 2 iterables</span></span><span class="koboSpan" id="kobo.187.1">
[(</span><span class="hljs-number"><span class="koboSpan" id="kobo.188.1">0</span></span><span class="koboSpan" id="kobo.189.1">, 'a'), (</span><span class="hljs-number"><span class="koboSpan" id="kobo.190.1">1</span></span><span class="koboSpan" id="kobo.191.1">, 'b'), (</span><span class="hljs-number"><span class="koboSpan" id="kobo.192.1">2</span></span><span class="koboSpan" id="kobo.193.1">, 'c')]
</span><span class="hljs-meta"><span class="koboSpan" id="kobo.194.1">&gt;&gt;&gt; </span></span><span class="hljs-built_in"><span class="koboSpan" id="kobo.195.1">list</span></span><span class="koboSpan" id="kobo.196.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.197.1">map</span></span><span class="koboSpan" id="kobo.198.1">(</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.199.1">lambda</span></span><span class="koboSpan" id="kobo.200.1"> *a: a, </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.201.1">range</span></span><span class="koboSpan" id="kobo.202.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.203.1">3</span></span><span class="koboSpan" id="kobo.204.1">), "abc", </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.205.1">range</span></span><span class="koboSpan" id="kobo.206.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.207.1">4</span></span><span class="koboSpan" id="kobo.208.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.209.1">7</span></span><span class="koboSpan" id="kobo.210.1">)))  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.211.1"># 3</span></span><span class="koboSpan" id="kobo.212.1">
[(</span><span class="hljs-number"><span class="koboSpan" id="kobo.213.1">0</span></span><span class="koboSpan" id="kobo.214.1">, 'a', </span><span class="hljs-number"><span class="koboSpan" id="kobo.215.1">4</span></span><span class="koboSpan" id="kobo.216.1">), (</span><span class="hljs-number"><span class="koboSpan" id="kobo.217.1">1</span></span><span class="koboSpan" id="kobo.218.1">, 'b', </span><span class="hljs-number"><span class="koboSpan" id="kobo.219.1">5</span></span><span class="koboSpan" id="kobo.220.1">), (</span><span class="hljs-number"><span class="koboSpan" id="kobo.221.1">2</span></span><span class="koboSpan" id="kobo.222.1">, 'c', </span><span class="hljs-number"><span class="koboSpan" id="kobo.223.1">6</span></span><span class="koboSpan" id="kobo.224.1">)]
</span><span class="hljs-meta"><span class="koboSpan" id="kobo.225.1">&gt;&gt;&gt; </span></span><span class="hljs-comment"><span class="koboSpan" id="kobo.226.1"># map stops at the shortest iterator</span></span>
<span class="hljs-meta"><span class="koboSpan" id="kobo.227.1">&gt;&gt;&gt; </span></span><span class="hljs-built_in"><span class="koboSpan" id="kobo.228.1">list</span></span><span class="koboSpan" id="kobo.229.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.230.1">map</span></span><span class="koboSpan" id="kobo.231.1">(</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.232.1">lambda</span></span><span class="koboSpan" id="kobo.233.1"> *a: a, (), "abc"))  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.234.1"># empty tuple is shortest</span></span><span class="koboSpan" id="kobo.235.1">
[]
</span><span class="hljs-meta"><span class="koboSpan" id="kobo.236.1">&gt;&gt;&gt; </span></span><span class="hljs-built_in"><span class="koboSpan" id="kobo.237.1">list</span></span><span class="koboSpan" id="kobo.238.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.239.1">map</span></span><span class="koboSpan" id="kobo.240.1">(</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.241.1">lambda</span></span><span class="koboSpan" id="kobo.242.1"> *a: a, (</span><span class="hljs-number"><span class="koboSpan" id="kobo.243.1">1</span></span><span class="koboSpan" id="kobo.244.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.245.1">2</span></span><span class="koboSpan" id="kobo.246.1">), "abc"))  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.247.1"># (1, 2) shortest</span></span><span class="koboSpan" id="kobo.248.1">
[(</span><span class="hljs-number"><span class="koboSpan" id="kobo.249.1">1</span></span><span class="koboSpan" id="kobo.250.1">, 'a'), (</span><span class="hljs-number"><span class="koboSpan" id="kobo.251.1">2</span></span><span class="koboSpan" id="kobo.252.1">, 'b')]
</span><span class="hljs-meta"><span class="koboSpan" id="kobo.253.1">&gt;&gt;&gt; </span></span><span class="hljs-built_in"><span class="koboSpan" id="kobo.254.1">list</span></span><span class="koboSpan" id="kobo.255.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.256.1">map</span></span><span class="koboSpan" id="kobo.257.1">(</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.258.1">lambda</span></span><span class="koboSpan" id="kobo.259.1"> *a: a, (</span><span class="hljs-number"><span class="koboSpan" id="kobo.260.1">1</span></span><span class="koboSpan" id="kobo.261.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.262.1">2</span></span><span class="koboSpan" id="kobo.263.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.264.1">3</span></span><span class="koboSpan" id="kobo.265.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.266.1">4</span></span><span class="koboSpan" id="kobo.267.1">), "abc"))  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.268.1"># "abc" shortest</span></span><span class="koboSpan" id="kobo.269.1">
[(</span><span class="hljs-number"><span class="koboSpan" id="kobo.270.1">1</span></span><span class="koboSpan" id="kobo.271.1">, 'a'), (</span><span class="hljs-number"><span class="koboSpan" id="kobo.272.1">2</span></span><span class="koboSpan" id="kobo.273.1">, 'b'), (</span><span class="hljs-number"><span class="koboSpan" id="kobo.274.1">3</span></span><span class="koboSpan" id="kobo.275.1">, 'c')]
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.276.1">
     In the preceding code, you can see why we have to wrap calls in
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.277.1">
      list()
     </span>
    </code>
    <span class="koboSpan" id="kobo.278.1">
     .
    </span>
    <span class="koboSpan" id="kobo.278.2">
     Without it, we get the string representation of a
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.279.1">
      map
     </span>
    </code>
    <span class="koboSpan" id="kobo.280.1">
     object.
    </span>
    <span class="koboSpan" id="kobo.280.2">
     Python’s default string representation for objects gives their type and memory location which, in this context, is not particularly useful to us.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.281.1">
     You can also notice how the elements of each iterable are applied to the function; at first, the first element of each iterable is applied, then the second one of each iterable, and so on.
    </span>
    <span class="koboSpan" id="kobo.281.2">
     Notice also that
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.282.1">
      map()
     </span>
    </code>
    <span class="koboSpan" id="kobo.283.1">
     stops when the shortest of the iterables we called it with is exhausted.
    </span>
    <span class="koboSpan" id="kobo.283.2">
     This is a very useful behavior; it does not force us to level off all the iterables to a common length, nor does it break if they are not all the same length.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.284.1">
     As a more interesting example, suppose we have a collection of student dictionaries, each of which contains a nested dictionary of the student’s credits.
    </span>
    <span class="koboSpan" id="kobo.284.2">
     We want to sort the students based on the sum of their credits.
    </span>
    <span class="koboSpan" id="kobo.284.3">
     However, the data as it is does not allow for a straightforward application of the sorting function.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.285.1">
     To solve the problem, we are going to
    </span>
    <a id="_idIndexMarker489">
    </a>
    <span class="koboSpan" id="kobo.286.1">
     apply the
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.287.1">
      decorate-sort-undecorate
     </span>
    </strong>
    <span class="koboSpan" id="kobo.288.1">
     idiom (also
    </span>
    <a id="_idIndexMarker490">
    </a>
    <span class="koboSpan" id="kobo.289.1">
     known as
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.290.1">
      Schwartzian transform
     </span>
    </strong>
    <span class="koboSpan" id="kobo.291.1">
     ).
    </span>
    <span class="koboSpan" id="kobo.291.2">
     It is a technique that was quite popular in older Python versions, when sorting did not support the use of
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.292.1">
      key functions
     </span>
    </em>
    <span class="koboSpan" id="kobo.293.1">
     .
    </span>
    <span class="koboSpan" id="kobo.293.2">
     Nowadays, it is not needed as often, but it still occasionally comes in handy.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.294.1">
     To
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.295.1">
      decorate
     </span>
    </strong>
    <span class="koboSpan" id="kobo.296.1">
     an object means to
    </span>
    <a id="_idIndexMarker491">
    </a>
    <span class="koboSpan" id="kobo.297.1">
     transform it, either adding extra data to it or putting it into another
    </span>
    <a id="_idIndexMarker492">
    </a>
    <span class="koboSpan" id="kobo.298.1">
     object.
    </span>
    <span class="koboSpan" id="kobo.298.2">
     Conversely, to
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.299.1">
      undecorate
     </span>
    </strong>
    <span class="koboSpan" id="kobo.300.1">
     an object means to revert the decorated object to its original form.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.301.1">
     This technique has nothing to do with Python decorators, which we will explore later in the book.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.302.1">
     In the following example, we
    </span>
    <a id="_idIndexMarker493">
    </a>
    <span class="koboSpan" id="kobo.303.1">
     can see how
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.304.1">
      map()
     </span>
    </code>
    <span class="koboSpan" id="kobo.305.1">
     is used to apply this idiom:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.306.1"># decorate.sort.undecorate.py</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.307.1">from</span></span><span class="koboSpan" id="kobo.308.1"> pprint </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.309.1">import</span></span><span class="koboSpan" id="kobo.310.1"> pprint
students = [
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.311.1">dict</span></span><span class="koboSpan" id="kobo.312.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.313.1">id</span></span><span class="koboSpan" id="kobo.314.1">=</span><span class="hljs-number"><span class="koboSpan" id="kobo.315.1">0</span></span><span class="koboSpan" id="kobo.316.1">, credits=</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.317.1">dict</span></span><span class="koboSpan" id="kobo.318.1">(math=</span><span class="hljs-number"><span class="koboSpan" id="kobo.319.1">9</span></span><span class="koboSpan" id="kobo.320.1">, physics=</span><span class="hljs-number"><span class="koboSpan" id="kobo.321.1">6</span></span><span class="koboSpan" id="kobo.322.1">, history=</span><span class="hljs-number"><span class="koboSpan" id="kobo.323.1">7</span></span><span class="koboSpan" id="kobo.324.1">)),
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.325.1">dict</span></span><span class="koboSpan" id="kobo.326.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.327.1">id</span></span><span class="koboSpan" id="kobo.328.1">=</span><span class="hljs-number"><span class="koboSpan" id="kobo.329.1">1</span></span><span class="koboSpan" id="kobo.330.1">, credits=</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.331.1">dict</span></span><span class="koboSpan" id="kobo.332.1">(math=</span><span class="hljs-number"><span class="koboSpan" id="kobo.333.1">6</span></span><span class="koboSpan" id="kobo.334.1">, physics=</span><span class="hljs-number"><span class="koboSpan" id="kobo.335.1">7</span></span><span class="koboSpan" id="kobo.336.1">, latin=</span><span class="hljs-number"><span class="koboSpan" id="kobo.337.1">10</span></span><span class="koboSpan" id="kobo.338.1">)),
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.339.1">dict</span></span><span class="koboSpan" id="kobo.340.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.341.1">id</span></span><span class="koboSpan" id="kobo.342.1">=</span><span class="hljs-number"><span class="koboSpan" id="kobo.343.1">2</span></span><span class="koboSpan" id="kobo.344.1">, credits=</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.345.1">dict</span></span><span class="koboSpan" id="kobo.346.1">(history=</span><span class="hljs-number"><span class="koboSpan" id="kobo.347.1">8</span></span><span class="koboSpan" id="kobo.348.1">, physics=</span><span class="hljs-number"><span class="koboSpan" id="kobo.349.1">9</span></span><span class="koboSpan" id="kobo.350.1">, chemistry=</span><span class="hljs-number"><span class="koboSpan" id="kobo.351.1">10</span></span><span class="koboSpan" id="kobo.352.1">)),
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.353.1">dict</span></span><span class="koboSpan" id="kobo.354.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.355.1">id</span></span><span class="koboSpan" id="kobo.356.1">=</span><span class="hljs-number"><span class="koboSpan" id="kobo.357.1">3</span></span><span class="koboSpan" id="kobo.358.1">, credits=</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.359.1">dict</span></span><span class="koboSpan" id="kobo.360.1">(math=</span><span class="hljs-number"><span class="koboSpan" id="kobo.361.1">5</span></span><span class="koboSpan" id="kobo.362.1">, physics=</span><span class="hljs-number"><span class="koboSpan" id="kobo.363.1">5</span></span><span class="koboSpan" id="kobo.364.1">, geography=</span><span class="hljs-number"><span class="koboSpan" id="kobo.365.1">7</span></span><span class="koboSpan" id="kobo.366.1">)),
]
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.367.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.368.1">decorate</span></span><span class="koboSpan" id="kobo.369.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.370.1">student</span></span><span class="koboSpan" id="kobo.371.1">):
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.372.1"># create a 2-tuple (sum of credits, student) from student dict</span></span>
    <span class="hljs-keyword"><span class="koboSpan" id="kobo.373.1">return</span></span><span class="koboSpan" id="kobo.374.1"> (</span><span class="code-highlight"><strong class="hljs-built_in-slc"><span class="koboSpan" id="kobo.375.1">sum</span></strong><strong class="hljs-slc"><span class="koboSpan" id="kobo.376.1">(student["credits"].values())</span></strong></span><span class="koboSpan" id="kobo.377.1">, student)
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.378.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.379.1">undecorate</span></span><span class="koboSpan" id="kobo.380.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.381.1">decorated_student</span></span><span class="koboSpan" id="kobo.382.1">):
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.383.1"># discard sum of credits, return original student dict</span></span>
    <span class="hljs-keyword"><span class="koboSpan" id="kobo.384.1">return</span></span><span class="koboSpan" id="kobo.385.1"> decorated_student[</span><span class="hljs-number"><span class="koboSpan" id="kobo.386.1">1</span></span><span class="koboSpan" id="kobo.387.1">]
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.388.1">print</span></span><span class="koboSpan" id="kobo.389.1">(students[</span><span class="hljs-number"><span class="koboSpan" id="kobo.390.1">0</span></span><span class="koboSpan" id="kobo.391.1">])
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.392.1">print</span></span><span class="koboSpan" id="kobo.393.1">(decorate(students[</span><span class="hljs-number"><span class="koboSpan" id="kobo.394.1">0</span></span><span class="koboSpan" id="kobo.395.1">])
students = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.396.1">sorted</span></span><span class="koboSpan" id="kobo.397.1">(</span><span class="code-highlight"><strong class="hljs-built_in-slc"><span class="koboSpan" id="kobo.398.1">map</span></strong><strong class="hljs-slc"><span class="koboSpan" id="kobo.399.1">(decorate, students)</span></strong></span><span class="koboSpan" id="kobo.400.1">, reverse=</span><span class="hljs-literal"><span class="koboSpan" id="kobo.401.1">True</span></span><span class="koboSpan" id="kobo.402.1">)
students = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.403.1">list</span></span><span class="koboSpan" id="kobo.404.1">(</span><span class="code-highlight"><strong class="hljs-built_in-slc"><span class="koboSpan" id="kobo.405.1">map</span></strong><strong class="hljs-slc"><span class="koboSpan" id="kobo.406.1">(undecorate, students)</span></strong></span><span class="koboSpan" id="kobo.407.1">)
pprint(students)
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.408.1">
     Let us start by understanding what each student object is.
    </span>
    <span class="koboSpan" id="kobo.408.2">
     In fact, let us print the first one:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.409.1">{'</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.410.1">id</span></span><span class="koboSpan" id="kobo.411.1">': </span><span class="hljs-number"><span class="koboSpan" id="kobo.412.1">0</span></span><span class="koboSpan" id="kobo.413.1">, 'credits': {'math': </span><span class="hljs-number"><span class="koboSpan" id="kobo.414.1">9</span></span><span class="koboSpan" id="kobo.415.1">, 'physics': </span><span class="hljs-number"><span class="koboSpan" id="kobo.416.1">6</span></span><span class="koboSpan" id="kobo.417.1">, 'history': </span><span class="hljs-number"><span class="koboSpan" id="kobo.418.1">7</span></span><span class="koboSpan" id="kobo.419.1">}}
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.420.1">
     You can see that it is a dictionary with two keys:
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.421.1">
      id
     </span>
    </code>
    <span class="koboSpan" id="kobo.422.1">
     and
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.423.1">
      credits
     </span>
    </code>
    <span class="koboSpan" id="kobo.424.1">
     .
    </span>
    <span class="koboSpan" id="kobo.424.2">
     The value of
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.425.1">
      credits
     </span>
    </code>
    <span class="koboSpan" id="kobo.426.1">
     is also a dictionary in which there are three subject/grade key/value pairs.
    </span>
    <span class="koboSpan" id="kobo.426.2">
     As you may recall from
    </span>
    <em class="chapterRef">
     <span class="koboSpan" id="kobo.427.1">
      Chapter 2
     </span>
    </em>
    <span class="koboSpan" id="kobo.428.1">
     ,
    </span>
    <em class="chapterRef">
     <span class="koboSpan" id="kobo.429.1">
      Built-in Data Types
     </span>
    </em>
    <span class="koboSpan" id="kobo.430.1">
     , calling
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.431.1">
      dict.values()
     </span>
    </code>
    <span class="koboSpan" id="kobo.432.1">
     returns an iterable object, with only the dictionary’s values.
    </span>
    <span class="koboSpan" id="kobo.432.2">
     Therefore,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.433.1">
      sum(student["credits"].values())
     </span>
    </code>
    <span class="koboSpan" id="kobo.434.1">
     for the first student is equivalent to
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.435.1">
      sum((9, 6, 7))
     </span>
    </code>
    <span class="koboSpan" id="kobo.436.1">
     .
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.437.1">
     Let us print the result of calling
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.438.1">
      decorate
     </span>
    </code>
    <span class="koboSpan" id="kobo.439.1">
     with the first student:
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.440.1">(22, {'id': 0, 'credits': {'math': 9, 'physics': 6, 'history': 7}})
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.441.1">
     If we decorate all the students like this, we can sort them on their total number of credits by just sorting the list of tuples.
    </span>
    <span class="koboSpan" id="kobo.441.2">
     To apply the decoration to each item in
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.442.1">
      students
     </span>
    </code>
    <span class="koboSpan" id="kobo.443.1">
     , we call
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.444.1">
      map(decorate, students)
     </span>
    </code>
    <span class="koboSpan" id="kobo.445.1">
     .
    </span>
    <span class="koboSpan" id="kobo.445.2">
     We sort the result, and then we undecorate in a similar fashion.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.446.1">
     Printing
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.447.1">
      students
     </span>
    </code>
    <span class="koboSpan" id="kobo.448.1">
     after
    </span>
    <a id="_idIndexMarker494">
    </a>
    <span class="koboSpan" id="kobo.449.1">
     running the whole code yields the following:
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.450.1">[{'credits': {'chemistry': 10, 'history': 8, 'physics': 9}, 'id': 2},
 {'credits': {'latin': 10, 'math': 6, 'physics': 7}, 'id': 1},
 {'credits': {'history': 7, 'math': 9, 'physics': 6}, 'id': 0},
 {'credits': {'geography': 7, 'math': 5, 'physics': 5}, 'id': 3}]
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.451.1">
     As you can see, the student objects have indeed been sorted by the sums of their credits.
    </span>
   </p>
   <div class="note">
    <p class="normal">
     <span class="koboSpan" id="kobo.452.1">
      For more on the
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.453.1">
       decorate-sort-undecorate
      </span>
     </em>
     <span class="koboSpan" id="kobo.454.1">
      idiom, there is a good introduction in the
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.455.1">
       Sorting HOW TO
      </span>
     </em>
     <span class="koboSpan" id="kobo.456.1">
      section of
     </span>
     <a id="_idIndexMarker495">
     </a>
     <span class="koboSpan" id="kobo.457.1">
      the official Python documentation:
     </span>
    </p>
    <p class="normal">
     <a href="https://docs.python.org/3.12/howto/sorting.html#decorate-sort-undecorate">
      <span class="url">
       <span class="koboSpan" id="kobo.458.1">
        https://docs.python.org/3.12/howto/sorting.html#decorate-sort-undecorate
       </span>
      </span>
     </a>
    </p>
   </div>
   <p class="normal">
    <span class="koboSpan" id="kobo.459.1">
     One thing to notice about the sorting part is what happens when two or more students share the same total sum.
    </span>
    <span class="koboSpan" id="kobo.459.2">
     The sorting algorithm would then proceed to sort the tuples by comparing the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.460.1">
      student
     </span>
    </code>
    <span class="koboSpan" id="kobo.461.1">
     objects with each other.
    </span>
    <span class="koboSpan" id="kobo.461.2">
     This does not make any sense and, in more complex cases, could lead to unpredictable results, or even errors.
    </span>
    <span class="koboSpan" id="kobo.461.3">
     If you want to avoid this issue, one simple solution is to create a three-tuple instead of a two-tuple, having the sum of credits in the first position, the position of the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.462.1">
      student
     </span>
    </code>
    <span class="koboSpan" id="kobo.463.1">
     object in the original
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.464.1">
      students
     </span>
    </code>
    <span class="koboSpan" id="kobo.465.1">
     list in second place, and the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.466.1">
      student
     </span>
    </code>
    <span class="koboSpan" id="kobo.467.1">
     object itself in third place.
    </span>
    <span class="koboSpan" id="kobo.467.2">
     This way, if the sum of credits is the same, the tuples will be sorted against the position, which will always be different, and therefore enough to resolve the sorting between any pair of tuples.
    </span>
   </p>
   <h2 class="heading-2" id="_idParaDest-164">
    <span class="koboSpan" id="kobo.468.1">
     zip
    </span>
   </h2>
   <p class="normal">
    <span class="koboSpan" id="kobo.469.1">
     We have already covered
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.470.1">
      zip()
     </span>
    </code>
    <span class="koboSpan" id="kobo.471.1">
     in the previous chapters, so let us just define it properly, after which we want to show
    </span>
    <a id="_idIndexMarker496">
    </a>
    <span class="koboSpan" id="kobo.472.1">
     you how you could combine it with
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.473.1">
      map()
     </span>
    </code>
    <span class="koboSpan" id="kobo.474.1">
     .
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.475.1">
     According to the
    </span>
    <a id="_idIndexMarker497">
    </a>
    <span class="koboSpan" id="kobo.476.1">
     Python documentation (
    </span>
    <a href="https://docs.python.org/3/library/functions.html#zip">
     <span class="url">
      <span class="koboSpan" id="kobo.477.1">
       https://docs.python.org/3/library/functions.html#zip
      </span>
     </span>
    </a>
    <span class="koboSpan" id="kobo.478.1">
     ), the following applies:
    </span>
   </p>
   <blockquote class="packt_quote">
    <p class="quote">
     <span class="koboSpan" id="kobo.479.1">
      zip(*iterables, strict=False)
     </span>
    </p>
    <p class="quote">
     <span class="koboSpan" id="kobo.480.1">
      ...
     </span>
     <span class="koboSpan" id="kobo.480.2">
      returns an iterator of tuples, where the i-th tuple contains the i-th element from each of the argument iterables.
     </span>
    </p>
    <p class="quote">
     <span class="koboSpan" id="kobo.481.1">
      Another way to think of zip() is that it turns rows into columns, and columns into rows.
     </span>
     <span class="koboSpan" id="kobo.481.2">
      This is similar to transposing a matrix.
     </span>
    </p>
   </blockquote>
   <p class="normal">
    <span class="koboSpan" id="kobo.482.1">
     Let us see an example:
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.483.1"># zip.grades.txt
&gt;&gt;&gt; grades = [18, 23, 30, 27]
&gt;&gt;&gt; avgs = [22, 21, 29, 24]
&gt;&gt;&gt; list(zip(avgs, grades))
[(22, 18), (21, 23), (29, 30), (24, 27)]
&gt;&gt;&gt; list(map(lambda *a: a, avgs, grades))  # equivalent to zip
[(22, 18), (21, 23), (29, 30), (24, 27)]
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.484.1">
     Here, we are zipping together the average and the grade for the last exam for each student.
    </span>
    <span class="koboSpan" id="kobo.484.2">
     Notice how easy it is to reproduce
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.485.1">
      zip()
     </span>
    </code>
    <span class="koboSpan" id="kobo.486.1">
     using
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.487.1">
      map()
     </span>
    </code>
    <span class="koboSpan" id="kobo.488.1">
     (the last two instructions of the example).
    </span>
    <span class="koboSpan" id="kobo.488.2">
     Once again, we have to use
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.489.1">
      list()
     </span>
    </code>
    <span class="koboSpan" id="kobo.490.1">
     to visualize the results.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.491.1">
     Like
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.492.1">
      map()
     </span>
    </code>
    <span class="koboSpan" id="kobo.493.1">
     ,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.494.1">
      zip()
     </span>
    </code>
    <span class="koboSpan" id="kobo.495.1">
     will normally stop as soon as it reaches the end of the shortest iterable.
    </span>
    <span class="koboSpan" id="kobo.495.2">
     This can, however, mask problems with the input data, leading to bugs.
    </span>
    <span class="koboSpan" id="kobo.495.3">
     For example, suppose we need to combine a list of students’ names and a list of grades into a dictionary mapping each student’s name to their grade.
    </span>
    <span class="koboSpan" id="kobo.495.4">
     A mistake in data entry could result in the list of grades being shorter than the list of students.
    </span>
    <span class="koboSpan" id="kobo.495.5">
     Here is an example:
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.496.1"># zip.strict.txt
&gt;&gt;&gt; students = ["Sophie", "Alex", "Charlie", "Alice"]
&gt;&gt;&gt; grades = ["A", "C", "B"]
&gt;&gt;&gt; dict(zip(students, grades))
{'Sophie': 'A', 'Alex': 'C', 'Charlie': 'B'}
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.497.1">
     Notice that there is no entry for
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.498.1">
      "Alice"
     </span>
    </code>
    <span class="koboSpan" id="kobo.499.1">
     in the dictionary.
    </span>
    <span class="koboSpan" id="kobo.499.2">
     The default behavior of
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.500.1">
      zip()
     </span>
    </code>
    <span class="koboSpan" id="kobo.501.1">
     has masked the data error.
    </span>
    <span class="koboSpan" id="kobo.501.2">
     For this reason, the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.502.1">
      strict
     </span>
    </code>
    <span class="koboSpan" id="kobo.503.1">
     keyword-only parameter was added in Python 3.10.
    </span>
    <span class="koboSpan" id="kobo.503.2">
     If
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.504.1">
      zip()
     </span>
    </code>
    <span class="koboSpan" id="kobo.505.1">
     receives
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.506.1">
      strict=True
     </span>
    </code>
    <span class="koboSpan" id="kobo.507.1">
     as an argument, it raises an exception if the iterables do
    </span>
    <a id="_idIndexMarker498">
    </a>
    <span class="koboSpan" id="kobo.508.1">
     not all have the same length:
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.509.1">&gt;&gt;&gt; dict(zip(students, grades, strict=True))
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
ValueError: zip() argument 2 is shorter than argument 1
</span></code></pre>
   <div class="note">
    <p class="normal">
     <span class="koboSpan" id="kobo.510.1">
      The
     </span>
     <code class="inlineCode">
      <span class="koboSpan" id="kobo.511.1">
       itertools
      </span>
     </code>
     <span class="koboSpan" id="kobo.512.1">
      module also provides a
     </span>
     <code class="inlineCode">
      <span class="koboSpan" id="kobo.513.1">
       zip_longest()
      </span>
     </code>
     <span class="koboSpan" id="kobo.514.1">
      function.
     </span>
     <span class="koboSpan" id="kobo.514.2">
      It behaves like
     </span>
     <code class="inlineCode">
      <span class="koboSpan" id="kobo.515.1">
       zip()
      </span>
     </code>
     <span class="koboSpan" id="kobo.516.1">
      but stops only when the longest iterable is exhausted.
     </span>
     <span class="koboSpan" id="kobo.516.2">
      Shorter iterables are padded with a value that can be specified as an argument, which defaults to
     </span>
     <code class="inlineCode">
      <span class="koboSpan" id="kobo.517.1">
       None
      </span>
     </code>
     <span class="koboSpan" id="kobo.518.1">
      .
     </span>
    </p>
   </div>
   <h2 class="heading-2" id="_idParaDest-165">
    <span class="koboSpan" id="kobo.519.1">
     filter
    </span>
   </h2>
   <p class="normal">
    <span class="koboSpan" id="kobo.520.1">
     According to the Python
    </span>
    <a id="_idIndexMarker499">
    </a>
    <span class="koboSpan" id="kobo.521.1">
     documentation (
    </span>
    <a href="https://docs.python.org/3/library/functions.html#filter">
     <span class="url">
      <span class="koboSpan" id="kobo.522.1">
       https://docs.python.org/3/library/functions.html#filter
      </span>
     </span>
    </a>
    <span class="koboSpan" id="kobo.523.1">
     ), the
    </span>
    <a id="_idIndexMarker500">
    </a>
    <span class="koboSpan" id="kobo.524.1">
     following applies:
    </span>
   </p>
   <blockquote class="packt_quote">
    <p class="quote">
     <span class="koboSpan" id="kobo.525.1">
      filter(function, iterable)
     </span>
    </p>
    <p class="quote">
     <span class="koboSpan" id="kobo.526.1">
      Construct an iterator from those elements of iterable for which function is true.
     </span>
     <span class="koboSpan" id="kobo.526.2">
      iterable may be either a sequence, a container which supports iteration, or an iterator.
     </span>
     <span class="koboSpan" id="kobo.526.3">
      If function is None, the identity function is assumed, that is, all elements of iterable that are false are removed.
     </span>
    </p>
   </blockquote>
   <p class="normal">
    <span class="koboSpan" id="kobo.527.1">
     Let us see a quick example:
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.528.1"># filter.txt
&gt;&gt;&gt; test = [2, 5, 8, 0, 0, 1, 0]
&gt;&gt;&gt; list(filter(None, test))
[2, 5, 8, 1]
&gt;&gt;&gt; list(filter(lambda x: x, test))  # equivalent to previous one
[2, 5, 8, 1]
&gt;&gt;&gt; list(filter(lambda x: x &gt; 4, test))  # keep only items &gt; 4
[5, 8]
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.529.1">
     Notice how the second call to
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.530.1">
      filter()
     </span>
    </code>
    <span class="koboSpan" id="kobo.531.1">
     is equivalent to the first one.
    </span>
    <span class="koboSpan" id="kobo.531.2">
     If we pass a function that takes one argument and returns the argument itself, only those arguments that are
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.532.1">
      True
     </span>
    </code>
    <span class="koboSpan" id="kobo.533.1">
     will make the function return
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.534.1">
      True
     </span>
    </code>
    <span class="koboSpan" id="kobo.535.1">
     .
    </span>
    <span class="koboSpan" id="kobo.535.2">
     This behavior is the same as passing
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.536.1">
      None
     </span>
    </code>
    <span class="koboSpan" id="kobo.537.1">
     .
    </span>
    <span class="koboSpan" id="kobo.537.2">
     It is often a good exercise to mimic some of the built-in Python behaviors.
    </span>
    <span class="koboSpan" id="kobo.537.3">
     When you succeed, you can say
    </span>
    <a id="_idIndexMarker501">
    </a>
    <span class="koboSpan" id="kobo.538.1">
     you fully understand how Python behaves in a specific situation.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.539.1">
     Armed with
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.540.1">
      map()
     </span>
    </code>
    <span class="koboSpan" id="kobo.541.1">
     ,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.542.1">
      zip()
     </span>
    </code>
    <span class="koboSpan" id="kobo.543.1">
     , and
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.544.1">
      filter()
     </span>
    </code>
    <span class="koboSpan" id="kobo.545.1">
     (and several other functions from the Python standard library), we can manipulate sequences very effectively.
    </span>
    <span class="koboSpan" id="kobo.545.2">
     But these functions are not the only way to do it.
    </span>
    <span class="koboSpan" id="kobo.545.3">
     Let us look at one of the most powerful features of Python:
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.546.1">
      comprehensions
     </span>
    </em>
    <span class="koboSpan" id="kobo.547.1">
     .
    </span>
   </p>
   <h1 class="heading-1" id="_idParaDest-166">
    <span class="koboSpan" id="kobo.548.1">
     Comprehensions
    </span>
   </h1>
   <p class="normal">
    <span class="koboSpan" id="kobo.549.1">
     A comprehension is a concise notation for performing some operation on each element of a collection of objects, and/or
    </span>
    <a id="_idIndexMarker502">
    </a>
    <span class="koboSpan" id="kobo.550.1">
     selecting a subset of elements that satisfy some condition.
    </span>
    <span class="koboSpan" id="kobo.550.2">
     They are borrowed from the functional programming language Haskell (
    </span>
    <a href="https://www.haskell.org/">
     <span class="url">
      <span class="koboSpan" id="kobo.551.1">
       https://www.haskell.org/
      </span>
     </span>
    </a>
    <span class="koboSpan" id="kobo.552.1">
     ) and, together
    </span>
    <a id="_idIndexMarker503">
    </a>
    <span class="koboSpan" id="kobo.553.1">
     with iterators and generators, contribute to giving Python a functional flavor.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.554.1">
     Python offers several types of comprehensions: list, dictionary, and set.
    </span>
    <span class="koboSpan" id="kobo.554.2">
     We will concentrate on list comprehensions; once you understand them, the other types will be easy to grasp.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.555.1">
     Let us start with a simple example.
    </span>
    <span class="koboSpan" id="kobo.555.2">
     We want to calculate a list with the squares of the first 10 natural numbers.
    </span>
    <span class="koboSpan" id="kobo.555.3">
     We could use a
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.556.1">
      for
     </span>
    </code>
    <span class="koboSpan" id="kobo.557.1">
     loop and append a square to the list in each iteration:
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.558.1"># squares.for.txt
&gt;&gt;&gt; squares = []
&gt;&gt;&gt; for n in range(10):
...     </span><span class="koboSpan" id="kobo.558.2">squares.append(n**2)
...
</span><span class="koboSpan" id="kobo.558.3">&gt;&gt;&gt; squares
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.559.1">
     This is not very elegant as we have to initialize the list first.
    </span>
    <span class="koboSpan" id="kobo.559.2">
     With
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.560.1">
      map()
     </span>
    </code>
    <span class="koboSpan" id="kobo.561.1">
     , we can achieve the same thing in
    </span>
    <a id="_idIndexMarker504">
    </a>
    <span class="koboSpan" id="kobo.562.1">
     just one line of code:
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.563.1"># squares.map.txt
&gt;&gt;&gt; squares = list(map(lambda n: n**2, range(10)))
&gt;&gt;&gt; squares
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.564.1">
     Now, let us see how to achieve the same result using a list comprehension:
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.565.1"># squares.comprehension.txt
&gt;&gt;&gt; [n**2 for n in range(10)]
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.566.1">
     This is much easier to read, and we no longer need to use a lambda.
    </span>
    <span class="koboSpan" id="kobo.566.2">
     We have placed a
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.567.1">
      for
     </span>
    </code>
    <span class="koboSpan" id="kobo.568.1">
     loop within square brackets.
    </span>
    <span class="koboSpan" id="kobo.568.2">
     Let us now filter out the odd squares.
    </span>
    <span class="koboSpan" id="kobo.568.3">
     We will show you how to do it with
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.569.1">
      map()
     </span>
    </code>
    <span class="koboSpan" id="kobo.570.1">
     and
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.571.1">
      filter()
     </span>
    </code>
    <span class="koboSpan" id="kobo.572.1">
     first, before then using a list comprehension again:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.573.1"># even.squares.py</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.574.1"># using map and filter</span></span><span class="koboSpan" id="kobo.575.1">
sq1 = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.576.1">list</span></span><span class="koboSpan" id="kobo.577.1">(
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.578.1">map</span></span><span class="koboSpan" id="kobo.579.1">(</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.580.1">lambda</span></span><span class="koboSpan" id="kobo.581.1"> n: n**</span><span class="hljs-number"><span class="koboSpan" id="kobo.582.1">2</span></span><span class="koboSpan" id="kobo.583.1">, </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.584.1">filter</span></span><span class="koboSpan" id="kobo.585.1">(</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.586.1">lambda</span></span><span class="koboSpan" id="kobo.587.1"> n: </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.588.1">not</span></span><span class="koboSpan" id="kobo.589.1"> n % </span><span class="hljs-number"><span class="koboSpan" id="kobo.590.1">2</span></span><span class="koboSpan" id="kobo.591.1">, </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.592.1">range</span></span><span class="koboSpan" id="kobo.593.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.594.1">10</span></span><span class="koboSpan" id="kobo.595.1">)))
)
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.596.1"># equivalent, but using list comprehensions</span></span><span class="koboSpan" id="kobo.597.1">
sq2 = [n**</span><span class="hljs-number"><span class="koboSpan" id="kobo.598.1">2</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.599.1">for</span></span><span class="koboSpan" id="kobo.600.1"> n </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.601.1">in</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.602.1">range</span></span><span class="koboSpan" id="kobo.603.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.604.1">10</span></span><span class="koboSpan" id="kobo.605.1">) </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.606.1">if</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.607.1">not</span></span><span class="koboSpan" id="kobo.608.1"> n % </span><span class="hljs-number"><span class="koboSpan" id="kobo.609.1">2</span></span><span class="koboSpan" id="kobo.610.1">]
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.611.1">print</span></span><span class="koboSpan" id="kobo.612.1">(sq1, sq1 == sq2)  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.613.1"># prints: [0, 4, 16, 36, 64] True</span></span>
</code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.614.1">
     We think that the difference in readability is now evident.
    </span>
    <span class="koboSpan" id="kobo.614.2">
     The list comprehension reads much better.
    </span>
    <span class="koboSpan" id="kobo.614.3">
     It is almost English: give us all squares (
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.615.1">
      n**2
     </span>
    </code>
    <span class="koboSpan" id="kobo.616.1">
     ) for
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.617.1">
      n
     </span>
    </code>
    <span class="koboSpan" id="kobo.618.1">
     between 0 and 9 if
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.619.1">
      n
     </span>
    </code>
    <span class="koboSpan" id="kobo.620.1">
     is even.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.621.1">
     According to the
    </span>
    <a id="_idIndexMarker505">
    </a>
    <span class="koboSpan" id="kobo.622.1">
     Python documentation (
    </span>
    <a href="https://docs.python.org/3.12/tutorial/datastructures.html#list-comprehensions">
     <span class="url">
      <span class="koboSpan" id="kobo.623.1">
       https://docs.python.org/3.12/tutorial/datastructures.html#list-comprehensions
      </span>
     </span>
    </a>
    <span class="koboSpan" id="kobo.624.1">
     ), the following is true:
    </span>
   </p>
   <blockquote class="packt_quote">
    <p class="quote">
     <span class="koboSpan" id="kobo.625.1">
      A list comprehension consists of brackets containing an expression followed by a for clause, then zero or more for or if clauses.
     </span>
     <span class="koboSpan" id="kobo.625.2">
      The result will be a new list resulting from evaluating the expression in the context of the for and if clauses which follow it.
     </span>
    </p>
   </blockquote>
   <h2 class="heading-2" id="_idParaDest-167">
    <span class="koboSpan" id="kobo.626.1">
     Nested comprehensions
    </span>
   </h2>
   <p class="normal">
    <span class="koboSpan" id="kobo.627.1">
     Let us see an example of nested loops.
    </span>
    <span class="koboSpan" id="kobo.627.2">
     This is
    </span>
    <a id="_idIndexMarker506">
    </a>
    <span class="koboSpan" id="kobo.628.1">
     quite common because many algorithms involve iterating on a sequence using two placeholders.
    </span>
    <span class="koboSpan" id="kobo.628.2">
     The first one runs through the whole sequence, left to right.
    </span>
    <span class="koboSpan" id="kobo.628.3">
     The second one does, too, but it
    </span>
    <a id="_idIndexMarker507">
    </a>
    <span class="koboSpan" id="kobo.629.1">
     starts from the first one, instead of 0.
    </span>
    <span class="koboSpan" id="kobo.629.2">
     The concept is that of testing all pairs without duplication.
    </span>
    <span class="koboSpan" id="kobo.629.3">
     Let us see the classical
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.630.1">
      for
     </span>
    </code>
    <span class="koboSpan" id="kobo.631.1">
     loop equivalent:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.632.1"># pairs.for.loop.py</span></span><span class="koboSpan" id="kobo.633.1">
items = "ABCD"
pairs = []
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.634.1">for</span></span><span class="koboSpan" id="kobo.635.1"> a </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.636.1">in</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.637.1">range</span></span><span class="koboSpan" id="kobo.638.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.639.1">len</span></span><span class="koboSpan" id="kobo.640.1">(items)):
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.641.1">for</span></span><span class="koboSpan" id="kobo.642.1"> b </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.643.1">in</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.644.1">range</span></span><span class="koboSpan" id="kobo.645.1">(a, </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.646.1">len</span></span><span class="koboSpan" id="kobo.647.1">(items)):
        pairs.append((items[a], items[b]))
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.648.1">
     If you print
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.649.1">
      pairs
     </span>
    </code>
    <span class="koboSpan" id="kobo.650.1">
     at the end, you get the following:
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.651.1">$ python pairs.for.loop.py
[('A', 'A'), ('A', 'B'), ('A', 'C'), ('A', 'D'), ('B', 'B'), ('B', 'C'), ('B', 'D'), ('C', 'C'), ('C', 'D'), ('D', 'D')]
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.652.1">
     All the tuples with the same letter are those where
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.653.1">
      b
     </span>
    </code>
    <span class="koboSpan" id="kobo.654.1">
     is at the same position as
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.655.1">
      a
     </span>
    </code>
    <span class="koboSpan" id="kobo.656.1">
     .
    </span>
    <span class="koboSpan" id="kobo.656.2">
     Now, let us see how we can translate this to a list comprehension:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.657.1"># pairs.list.comprehension.py</span></span><span class="koboSpan" id="kobo.658.1">
items = "ABCD"
pairs = [
    (items[a], items[b])    
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.659.1">for</span></span><span class="koboSpan" id="kobo.660.1"> a </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.661.1">in</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.662.1">range</span></span><span class="koboSpan" id="kobo.663.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.664.1">len</span></span><span class="koboSpan" id="kobo.665.1">(items))
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.666.1">for</span></span><span class="koboSpan" id="kobo.667.1"> b </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.668.1">in</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.669.1">range</span></span><span class="koboSpan" id="kobo.670.1">(a, </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.671.1">len</span></span><span class="koboSpan" id="kobo.672.1">(items))
]
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.673.1">
     Notice that because the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.674.1">
      for
     </span>
    </code>
    <span class="koboSpan" id="kobo.675.1">
     loop over
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.676.1">
      b
     </span>
    </code>
    <span class="koboSpan" id="kobo.677.1">
     depends on
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.678.1">
      a
     </span>
    </code>
    <span class="koboSpan" id="kobo.679.1">
     , it must come after the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.680.1">
      for
     </span>
    </code>
    <span class="koboSpan" id="kobo.681.1">
     loop over
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.682.1">
      a
     </span>
    </code>
    <span class="koboSpan" id="kobo.683.1">
     in the comprehension.
    </span>
    <span class="koboSpan" id="kobo.683.2">
     If you swap them around, you will get a name error.
    </span>
   </p>
   <div class="packt_tip">
    <p class="normal">
     <span class="koboSpan" id="kobo.684.1">
      Another way of achieving the same result is to use the
     </span>
     <code class="inlineCode">
      <span class="koboSpan" id="kobo.685.1">
       combinations_with_replacement()
      </span>
     </code>
     <span class="koboSpan" id="kobo.686.1">
      function from the
     </span>
     <code class="inlineCode">
      <span class="koboSpan" id="kobo.687.1">
       itertools
      </span>
     </code>
     <span class="koboSpan" id="kobo.688.1">
      module (which we briefly introduced in
     </span>
     <em class="chapterRef">
      <span class="koboSpan" id="kobo.689.1">
       Chapter 3
      </span>
     </em>
     <span class="koboSpan" id="kobo.690.1">
      ,
     </span>
     <em class="chapterRef">
      <span class="koboSpan" id="kobo.691.1">
       Conditionals and Iteration
      </span>
     </em>
     <span class="koboSpan" id="kobo.692.1">
      ).
     </span>
     <span class="koboSpan" id="kobo.692.2">
      You can read more about it in the official Python documentation.
     </span>
    </p>
   </div>
   <h2 class="heading-2" id="_idParaDest-168">
    <span class="koboSpan" id="kobo.693.1">
     Filtering a comprehension
    </span>
   </h2>
   <p class="normal">
    <span class="koboSpan" id="kobo.694.1">
     We can also apply filtering to a comprehension.
    </span>
    <span class="koboSpan" id="kobo.694.2">
     Let us first do it with
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.695.1">
      filter()
     </span>
    </code>
    <span class="koboSpan" id="kobo.696.1">
     , and find all Pythagorean triples whose
    </span>
    <a id="_idIndexMarker508">
    </a>
    <span class="koboSpan" id="kobo.697.1">
     short sides are numbers smaller than 10.
    </span>
    <span class="koboSpan" id="kobo.697.2">
     A
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.698.1">
      Pythagorean triple
     </span>
    </strong>
    <span class="koboSpan" id="kobo.699.1">
     is a triple
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.700.1">
      (a, b, c)
     </span>
    </em>
    <span class="koboSpan" id="kobo.701.1">
     of integer numbers satisfying the equation
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.702.1">
      a
     </span>
    </em>
    <sup class="superscript-italic" style="font-style: italic;">
     <span class="koboSpan" id="kobo.703.1">
      2
     </span>
    </sup>
    <em class="italic">
     <span class="koboSpan" id="kobo.704.1">
      + b
     </span>
    </em>
    <sup class="superscript-italic" style="font-style: italic;">
     <span class="koboSpan" id="kobo.705.1">
      2
     </span>
    </sup>
    <em class="italic">
     <span class="koboSpan" id="kobo.706.1">
      = c
     </span>
    </em>
    <sup class="superscript-italic" style="font-style: italic;">
     <span class="koboSpan" id="kobo.707.1">
      2
     </span>
    </sup>
    <span class="koboSpan" id="kobo.708.1">
     .
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.709.1">
     We obviously do not want to test a combination twice, and therefore, we will use a trick similar to the one we saw in the previous example:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.710.1"># pythagorean.triple.py</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.711.1">from</span></span><span class="koboSpan" id="kobo.712.1"> math </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.713.1">import</span></span><span class="koboSpan" id="kobo.714.1"> sqrt
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.715.1"># this will generate all possible pairs</span></span><span class="koboSpan" id="kobo.716.1">
mx = </span><span class="hljs-number"><span class="koboSpan" id="kobo.717.1">10</span></span><span class="koboSpan" id="kobo.718.1">
triples = [
    (a, b, sqrt(a**</span><span class="hljs-number"><span class="koboSpan" id="kobo.719.1">2</span></span><span class="koboSpan" id="kobo.720.1"> + b**</span><span class="hljs-number"><span class="koboSpan" id="kobo.721.1">2</span></span><span class="koboSpan" id="kobo.722.1">))
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.723.1">for</span></span><span class="koboSpan" id="kobo.724.1"> a </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.725.1">in</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.726.1">range</span></span><span class="koboSpan" id="kobo.727.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.728.1">1</span></span><span class="koboSpan" id="kobo.729.1">, mx)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.730.1">for</span></span><span class="koboSpan" id="kobo.731.1"> b </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.732.1">in</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.733.1">range</span></span><span class="koboSpan" id="kobo.734.1">(a, mx)
]
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.735.1"># this will filter out all non-Pythagorean triples</span></span><span class="koboSpan" id="kobo.736.1">
triples = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.737.1">list</span></span><span class="koboSpan" id="kobo.738.1">(
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.739.1">filter</span></span><span class="koboSpan" id="kobo.740.1">(</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.741.1">lambda</span></span><span class="koboSpan" id="kobo.742.1"> triple: triple[</span><span class="hljs-number"><span class="koboSpan" id="kobo.743.1">2</span></span><span class="koboSpan" id="kobo.744.1">].is_integer(), triples)
)
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.745.1">print</span></span><span class="koboSpan" id="kobo.746.1">(triples)  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.747.1"># prints: [(3, 4, 5.0), (6, 8, 10.0)]</span></span>
</code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.748.1">
     In the preceding code, we generated a list of
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.749.1">
      three-tuples
     </span>
    </em>
    <span class="koboSpan" id="kobo.750.1">
     ,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.751.1">
      triples
     </span>
    </code>
    <span class="koboSpan" id="kobo.752.1">
     .
    </span>
    <span class="koboSpan" id="kobo.752.2">
     Each tuple contains two integer numbers (the legs), and the hypotenuse of the Pythagorean triangle, whose legs are the first two numbers in the tuple.
    </span>
    <span class="koboSpan" id="kobo.752.3">
     For example, when
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.753.1">
      a
     </span>
    </code>
    <span class="koboSpan" id="kobo.754.1">
     is 3 and
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.755.1">
      b
     </span>
    </code>
    <span class="koboSpan" id="kobo.756.1">
     is 4, the tuple will be
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.757.1">
      (3, 4, 5.0)
     </span>
    </code>
    <span class="koboSpan" id="kobo.758.1">
     , and when
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.759.1">
      a
     </span>
    </code>
    <span class="koboSpan" id="kobo.760.1">
     is 5 and
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.761.1">
      b
     </span>
    </code>
    <span class="koboSpan" id="kobo.762.1">
     is 7, the tuple will be
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.763.1">
      (5, 7, 8.602325267042627)
     </span>
    </code>
    <span class="koboSpan" id="kobo.764.1">
     .
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.765.1">
     After generating all the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.766.1">
      triples
     </span>
    </code>
    <span class="koboSpan" id="kobo.767.1">
     , we need to filter out all those where the hypotenuse is not an integer number.
    </span>
    <span class="koboSpan" id="kobo.767.2">
     To achieve this, we filter based on
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.768.1">
      float_number.is_integer()
     </span>
    </code>
    <span class="koboSpan" id="kobo.769.1">
     being
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.770.1">
      True
     </span>
    </code>
    <span class="koboSpan" id="kobo.771.1">
     .
    </span>
    <span class="koboSpan" id="kobo.771.2">
     This means that of the two example tuples we just showed you, the one with hypotenuse
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.772.1">
      5.0
     </span>
    </code>
    <span class="koboSpan" id="kobo.773.1">
     will be retained, while the one with the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.774.1">
      8.602325267042627
     </span>
    </code>
    <span class="koboSpan" id="kobo.775.1">
     hypotenuse will be discarded.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.776.1">
     This is good, but we do not like the fact that the triple has two integer numbers and a float—they are all supposed to be integers.
    </span>
    <span class="koboSpan" id="kobo.776.2">
     We can use
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.777.1">
      map()
     </span>
    </code>
    <span class="koboSpan" id="kobo.778.1">
     to fix this:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.779.1"># pythagorean.triple.int.py</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.780.1">from</span></span><span class="koboSpan" id="kobo.781.1"> math </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.782.1">import</span></span><span class="koboSpan" id="kobo.783.1"> sqrt
mx = </span><span class="hljs-number"><span class="koboSpan" id="kobo.784.1">10</span></span><span class="koboSpan" id="kobo.785.1">
triples = [
    (a, b, sqrt(a**</span><span class="hljs-number"><span class="koboSpan" id="kobo.786.1">2</span></span><span class="koboSpan" id="kobo.787.1"> + b**</span><span class="hljs-number"><span class="koboSpan" id="kobo.788.1">2</span></span><span class="koboSpan" id="kobo.789.1">))
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.790.1">for</span></span><span class="koboSpan" id="kobo.791.1"> a </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.792.1">in</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.793.1">range</span></span><span class="koboSpan" id="kobo.794.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.795.1">1</span></span><span class="koboSpan" id="kobo.796.1">, mx)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.797.1">for</span></span><span class="koboSpan" id="kobo.798.1"> b </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.799.1">in</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.800.1">range</span></span><span class="koboSpan" id="kobo.801.1">(a, mx)
]
triples = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.802.1">filter</span></span><span class="koboSpan" id="kobo.803.1">(</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.804.1">lambda</span></span><span class="koboSpan" id="kobo.805.1"> triple: triple[</span><span class="hljs-number"><span class="koboSpan" id="kobo.806.1">2</span></span><span class="koboSpan" id="kobo.807.1">].is_integer(), triples)
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.808.1"># this will make the third number in the tuples integer</span></span><span class="koboSpan" id="kobo.809.1">
triples = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.810.1">list</span></span><span class="koboSpan" id="kobo.811.1">(
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.812.1">map</span></span><span class="koboSpan" id="kobo.813.1">(</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.814.1">lambda</span></span><span class="koboSpan" id="kobo.815.1"> triple: </span><span class="code-highlight"><strong class="hljs-slc"><span class="koboSpan" id="kobo.816.1">triple[:</span></strong><strong class="hljs-number-slc"><span class="koboSpan" id="kobo.817.1">2</span></strong><strong class="hljs-slc"><span class="koboSpan" id="kobo.818.1">] + (</span></strong><strong class="hljs-built_in-slc"><span class="koboSpan" id="kobo.819.1">int</span></strong><strong class="hljs-slc"><span class="koboSpan" id="kobo.820.1">(triple[</span></strong><strong class="hljs-number-slc"><span class="koboSpan" id="kobo.821.1">2</span></strong><strong class="hljs-slc"><span class="koboSpan" id="kobo.822.1">]),)</span></strong></span><span class="koboSpan" id="kobo.823.1">, triples)
)
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.824.1">print</span></span><span class="koboSpan" id="kobo.825.1">(triples)  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.826.1"># prints: [(3, 4, 5), (6, 8, 10)]</span></span>
</code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.827.1">
     Notice the step we added.
    </span>
    <span class="koboSpan" id="kobo.827.2">
     We slice each element in
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.828.1">
      triples
     </span>
    </code>
    <span class="koboSpan" id="kobo.829.1">
     , taking only the first two elements.
    </span>
    <span class="koboSpan" id="kobo.829.2">
     Then, we
    </span>
    <a id="_idIndexMarker509">
    </a>
    <span class="koboSpan" id="kobo.830.1">
     concatenate the slice with a one-tuple, containing the integer version of that float number that we did not like.
    </span>
    <span class="koboSpan" id="kobo.830.2">
     This code is getting quite complicated.
    </span>
    <span class="koboSpan" id="kobo.830.3">
     We can achieve the same result with a much simpler list comprehension:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.831.1"># pythagorean.triple.comprehension.py</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.832.1">from</span></span><span class="koboSpan" id="kobo.833.1"> math </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.834.1">import</span></span><span class="koboSpan" id="kobo.835.1"> sqrt
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.836.1"># this step is the same as before</span></span><span class="koboSpan" id="kobo.837.1">
mx = </span><span class="hljs-number"><span class="koboSpan" id="kobo.838.1">10</span></span><span class="koboSpan" id="kobo.839.1">
triples = [
    (a, b, sqrt(a**</span><span class="hljs-number"><span class="koboSpan" id="kobo.840.1">2</span></span><span class="koboSpan" id="kobo.841.1"> + b**</span><span class="hljs-number"><span class="koboSpan" id="kobo.842.1">2</span></span><span class="koboSpan" id="kobo.843.1">))
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.844.1">for</span></span><span class="koboSpan" id="kobo.845.1"> a </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.846.1">in</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.847.1">range</span></span><span class="koboSpan" id="kobo.848.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.849.1">1</span></span><span class="koboSpan" id="kobo.850.1">, mx)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.851.1">for</span></span><span class="koboSpan" id="kobo.852.1"> b </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.853.1">in</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.854.1">range</span></span><span class="koboSpan" id="kobo.855.1">(a, mx)
]
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.856.1"># here we combine filter and map in one CLEAN list comprehension</span></span><span class="koboSpan" id="kobo.857.1">
triples = [
    (a, b, </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.858.1">int</span></span><span class="koboSpan" id="kobo.859.1">(c)) </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.860.1">for</span></span><span class="koboSpan" id="kobo.861.1"> a, b, c </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.862.1">in</span></span><span class="koboSpan" id="kobo.863.1"> triples </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.864.1">if</span></span><span class="koboSpan" id="kobo.865.1"> c.is_integer()
]
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.866.1">print</span></span><span class="koboSpan" id="kobo.867.1">(triples)  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.868.1"># prints: [(3, 4, 5), (6, 8, 10)]</span></span>
</code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.869.1">
     That is cleaner, easier to read, and shorter.
    </span>
    <span class="koboSpan" id="kobo.869.2">
     There is still room for improvement, though.
    </span>
    <span class="koboSpan" id="kobo.869.3">
     We are still wasting memory by constructing a list with many triples that we end up discarding.
    </span>
    <span class="koboSpan" id="kobo.869.4">
     We can fix that by combining the two comprehensions into one:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.870.1"># pythagorean.triple.walrus.py</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.871.1">from</span></span><span class="koboSpan" id="kobo.872.1"> math </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.873.1">import</span></span><span class="koboSpan" id="kobo.874.1"> sqrt
</span><span class="hljs-comment"><span class="koboSpan" id="kobo.875.1"># this step is the same as before</span></span><span class="koboSpan" id="kobo.876.1">
mx = </span><span class="hljs-number"><span class="koboSpan" id="kobo.877.1">10</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.878.1"># We can combine generating and filtering in one comprehension</span></span><span class="koboSpan" id="kobo.879.1">
triples = [
    (a, b, </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.880.1">int</span></span><span class="koboSpan" id="kobo.881.1">(c))
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.882.1">for</span></span><span class="koboSpan" id="kobo.883.1"> a </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.884.1">in</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.885.1">range</span></span><span class="koboSpan" id="kobo.886.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.887.1">1</span></span><span class="koboSpan" id="kobo.888.1">, mx)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.889.1">for</span></span><span class="koboSpan" id="kobo.890.1"> b </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.891.1">in</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.892.1">range</span></span><span class="koboSpan" id="kobo.893.1">(a, mx)
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.894.1">if</span></span><span class="koboSpan" id="kobo.895.1"> (</span><span class="code-highlight"><strong class="hljs-slc"><span class="koboSpan" id="kobo.896.1">c := sqrt(a**</span></strong><strong class="hljs-number-slc"><span class="koboSpan" id="kobo.897.1">2</span></strong><strong class="hljs-slc"><span class="koboSpan" id="kobo.898.1"> + b**</span></strong><strong class="hljs-number-slc"><span class="koboSpan" id="kobo.899.1">2</span></strong><strong class="hljs-slc"><span class="koboSpan" id="kobo.900.1">)</span></strong></span><span class="koboSpan" id="kobo.901.1">).is_integer()
]
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.902.1">print</span></span><span class="koboSpan" id="kobo.903.1">(triples)  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.904.1"># prints: [(3, 4, 5), (6, 8, 10)]</span></span>
</code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.905.1">
     Now that is elegant.
    </span>
    <span class="koboSpan" id="kobo.905.2">
     By
    </span>
    <a id="_idIndexMarker510">
    </a>
    <span class="koboSpan" id="kobo.906.1">
     generating the triples and filtering them in the same list comprehension, we avoid keeping any triple that does not pass the test in memory.
    </span>
    <span class="koboSpan" id="kobo.906.2">
     Notice that we used an
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.907.1">
      assignment expression
     </span>
    </code>
    <span class="koboSpan" id="kobo.908.1">
     to avoid needing to compute the value of
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.909.1">
      sqrt(a**2 + b**2)
     </span>
    </code>
    <span class="koboSpan" id="kobo.910.1">
     twice.
    </span>
   </p>
   <h2 class="heading-2" id="_idParaDest-169">
    <span class="koboSpan" id="kobo.911.1">
     Dictionary comprehensions
    </span>
   </h2>
   <p class="normal">
    <span class="koboSpan" id="kobo.912.1">
     Dictionary comprehensions work
    </span>
    <a id="_idIndexMarker511">
    </a>
    <span class="koboSpan" id="kobo.913.1">
     exactly like list comprehensions, but to construct dictionaries.
    </span>
    <span class="koboSpan" id="kobo.913.2">
     There is only a slight difference in the syntax.
    </span>
    <span class="koboSpan" id="kobo.913.3">
     The
    </span>
    <a id="_idIndexMarker512">
    </a>
    <span class="koboSpan" id="kobo.914.1">
     following example will suffice to explain everything you need to know:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.915.1"># dictionary.comprehensions.py</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.916.1">from</span></span><span class="koboSpan" id="kobo.917.1"> string </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.918.1">import</span></span><span class="koboSpan" id="kobo.919.1"> ascii_lowercase
lettermap = {c: k </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.920.1">for</span></span><span class="koboSpan" id="kobo.921.1"> k, c </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.922.1">in</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.923.1">enumerate</span></span><span class="koboSpan" id="kobo.924.1">(ascii_lowercase, </span><span class="hljs-number"><span class="koboSpan" id="kobo.925.1">1</span></span><span class="koboSpan" id="kobo.926.1">)}
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.927.1">
     If you print
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.928.1">
      lettermap
     </span>
    </code>
    <span class="koboSpan" id="kobo.929.1">
     , you will see the following:
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.930.1">$ python dictionary.comprehensions.py
{'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5, 'f': 6, 'g': 7, 'h': 8,
'i': 9, 'j': 10, 'k': 11, 'l': 12, 'm': 13, 'n': 14, 'o': 15,
'p': 16, 'q': 17, 'r': 18, 's': 19, 't': 20, 'u': 21, 'v': 22,
'w': 23, 'x': 24, 'y': 25, 'z': 26}
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.931.1">
     In the preceding code, we are enumerating the sequence of all lowercase ASCII letters (using the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.932.1">
      enumerate
     </span>
    </code>
    <span class="koboSpan" id="kobo.933.1">
     function).
    </span>
    <span class="koboSpan" id="kobo.933.2">
     We then construct a dictionary with the resulting letter/number pairs as keys and values.
    </span>
    <span class="koboSpan" id="kobo.933.3">
     Notice how the syntax is similar to the familiar dictionary syntax.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.934.1">
     There is also another way to do the same thing:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.935.1">lettermap = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.936.1">dict</span></span><span class="koboSpan" id="kobo.937.1">((c, k) </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.938.1">for</span></span><span class="koboSpan" id="kobo.939.1"> k, c </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.940.1">in</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.941.1">enumerate</span></span><span class="koboSpan" id="kobo.942.1">(ascii_lowercase, </span><span class="hljs-number"><span class="koboSpan" id="kobo.943.1">1</span></span><span class="koboSpan" id="kobo.944.1">))
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.945.1">
     In this case, we are feeding a generator expression (we will talk more about these later in this chapter) to the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.946.1">
      dict
     </span>
    </code>
    <span class="koboSpan" id="kobo.947.1">
     constructor.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.948.1">
     Dictionaries do not allow
    </span>
    <a id="_idIndexMarker513">
    </a>
    <span class="koboSpan" id="kobo.949.1">
     duplicate keys, as shown in the
    </span>
    <a id="_idIndexMarker514">
    </a>
    <span class="koboSpan" id="kobo.950.1">
     following example:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.951.1"># dictionary.comprehensions.duplicates.py</span></span><span class="koboSpan" id="kobo.952.1">
word = "Hello"
swaps = {c: c.swapcase() </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.953.1">for</span></span><span class="koboSpan" id="kobo.954.1"> c </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.955.1">in</span></span><span class="koboSpan" id="kobo.956.1"> word}
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.957.1">print</span></span><span class="koboSpan" id="kobo.958.1">(swaps)  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.959.1"># prints: {'H': 'h', 'e': 'E', 'l': 'L', 'o': 'O'}</span></span>
</code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.960.1">
     We create a dictionary with the letters of the string
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.961.1">
      "Hello"
     </span>
    </code>
    <span class="koboSpan" id="kobo.962.1">
     as keys and the same letters, but with the case swapped, as values.
    </span>
    <span class="koboSpan" id="kobo.962.2">
     Notice that there is only one
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.963.1">
      "l": "L"
     </span>
    </code>
    <span class="koboSpan" id="kobo.964.1">
     pair.
    </span>
    <span class="koboSpan" id="kobo.964.2">
     The constructor does not complain; it simply reassigns duplicates to the last value.
    </span>
    <span class="koboSpan" id="kobo.964.3">
     Let us make this clearer with another example that assigns to each key its position in the string:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.965.1"># dictionary.comprehensions.positions.py</span></span><span class="koboSpan" id="kobo.966.1">
word = "Hello"
positions = {c: k </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.967.1">for</span></span><span class="koboSpan" id="kobo.968.1"> k, c </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.969.1">in</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.970.1">enumerate</span></span><span class="koboSpan" id="kobo.971.1">(word)}
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.972.1">print</span></span><span class="koboSpan" id="kobo.973.1">(positions)  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.974.1"># prints: {'H': 0, 'e': 1, 'l': 3, 'o': 4}</span></span>
</code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.975.1">
     Notice the value associated with the letter
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.976.1">
      l: 3
     </span>
    </code>
    <span class="koboSpan" id="kobo.977.1">
     .
    </span>
    <span class="koboSpan" id="kobo.977.2">
     The
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.978.1">
      l: 2
     </span>
    </code>
    <span class="koboSpan" id="kobo.979.1">
     pair is not there; it has been overridden by
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.980.1">
      l: 3
     </span>
    </code>
    <span class="koboSpan" id="kobo.981.1">
     .
    </span>
   </p>
   <h2 class="heading-2" id="_idParaDest-170">
    <span class="koboSpan" id="kobo.982.1">
     Set comprehensions
    </span>
   </h2>
   <p class="normal">
    <span class="koboSpan" id="kobo.983.1">
     Set comprehensions are similar
    </span>
    <a id="_idIndexMarker515">
    </a>
    <span class="koboSpan" id="kobo.984.1">
     to list and dictionary ones.
    </span>
    <span class="koboSpan" id="kobo.984.2">
     Let us see one
    </span>
    <a id="_idIndexMarker516">
    </a>
    <span class="koboSpan" id="kobo.985.1">
     quick example:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.986.1"># set.comprehensions.py</span></span><span class="koboSpan" id="kobo.987.1">
word = "Hello"
letters1 = {c </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.988.1">for</span></span><span class="koboSpan" id="kobo.989.1"> c </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.990.1">in</span></span><span class="koboSpan" id="kobo.991.1"> word}
letters2 = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.992.1">set</span></span><span class="koboSpan" id="kobo.993.1">(c </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.994.1">for</span></span><span class="koboSpan" id="kobo.995.1"> c </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.996.1">in</span></span><span class="koboSpan" id="kobo.997.1"> word)
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.998.1">print</span></span><span class="koboSpan" id="kobo.999.1">(letters1)  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1000.1"># prints: {'H', 'o', 'e', 'l'}</span></span>
<span class="hljs-built_in"><span class="koboSpan" id="kobo.1001.1">print</span></span><span class="koboSpan" id="kobo.1002.1">(letters1 == letters2)  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1003.1"># prints: True</span></span>
</code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.1004.1">
     Notice how for set comprehensions, as for dictionaries, duplication is not allowed, and therefore the resulting set has only four letters.
    </span>
    <span class="koboSpan" id="kobo.1004.2">
     Also, notice that the expressions assigned to
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1005.1">
      letters1
     </span>
    </code>
    <span class="koboSpan" id="kobo.1006.1">
     and
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1007.1">
      letters2
     </span>
    </code>
    <span class="koboSpan" id="kobo.1008.1">
     produce equivalent sets.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1009.1">
     The syntax used to create
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1010.1">
      letters1
     </span>
    </code>
    <span class="koboSpan" id="kobo.1011.1">
     is similar to that of a dictionary comprehension.
    </span>
    <span class="koboSpan" id="kobo.1011.2">
     You can spot the difference
    </span>
    <a id="_idIndexMarker517">
    </a>
    <span class="koboSpan" id="kobo.1012.1">
     only by the fact that dictionaries require keys and values, separated by colons, while sets do not.
    </span>
    <span class="koboSpan" id="kobo.1012.2">
     For
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1013.1">
      letters2
     </span>
    </code>
    <span class="koboSpan" id="kobo.1014.1">
     , we fed a generator
    </span>
    <a id="_idIndexMarker518">
    </a>
    <span class="koboSpan" id="kobo.1015.1">
     expression to the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1016.1">
      set()
     </span>
    </code>
    <span class="koboSpan" id="kobo.1017.1">
     constructor.
    </span>
   </p>
   <h1 class="heading-1" id="_idParaDest-171">
    <span class="koboSpan" id="kobo.1018.1">
     Generators
    </span>
   </h1>
   <p class="normal">
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.1019.1">
      Generators
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1020.1">
     are based on the
    </span>
    <a id="_idIndexMarker519">
    </a>
    <span class="koboSpan" id="kobo.1021.1">
     concept of
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.1022.1">
      iteration
     </span>
    </em>
    <span class="koboSpan" id="kobo.1023.1">
     , as we said before, and they allow coding patterns that combine elegance with efficiency.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1024.1">
     Generators are of two types:
    </span>
   </p>
   <ul>
    <li class="bulletList">
     <strong class="keyWord">
      <span class="koboSpan" id="kobo.1025.1">
       Generator functions
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1026.1">
      : These are similar
     </span>
     <a id="_idIndexMarker520">
     </a>
     <span class="koboSpan" id="kobo.1027.1">
      to regular functions, but instead of returning results
     </span>
     <a id="_idIndexMarker521">
     </a>
     <span class="koboSpan" id="kobo.1028.1">
      through
     </span>
     <code class="inlineCode">
      <span class="koboSpan" id="kobo.1029.1">
       return
      </span>
     </code>
     <span class="koboSpan" id="kobo.1030.1">
      statements, they use
     </span>
     <code class="inlineCode">
      <span class="koboSpan" id="kobo.1031.1">
       yield
      </span>
     </code>
     <span class="koboSpan" id="kobo.1032.1">
      , which allows them to suspend and resume their state between each call.
     </span>
    </li>
    <li class="bulletList">
     <strong class="keyWord">
      <span class="koboSpan" id="kobo.1033.1">
       Generator expressions
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1034.1">
      : These are
     </span>
     <a id="_idIndexMarker522">
     </a>
     <span class="koboSpan" id="kobo.1035.1">
      similar to the list comprehensions we have seen in this chapter, but instead of returning a list, they return an object that produces results one by one.
     </span>
    </li>
   </ul>
   <h2 class="heading-2" id="_idParaDest-172">
    <span class="koboSpan" id="kobo.1036.1">
     Generator functions
    </span>
   </h2>
   <p class="normal">
    <span class="koboSpan" id="kobo.1037.1">
     Generator functions behave like regular functions in all respects, except for one difference: instead of collecting
    </span>
    <a id="_idIndexMarker523">
    </a>
    <span class="koboSpan" id="kobo.1038.1">
     results and returning them at once, they are
    </span>
    <a id="_idIndexMarker524">
    </a>
    <span class="koboSpan" id="kobo.1039.1">
     automatically turned into iterators that yield results one at a time.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1040.1">
     Suppose we asked you to count from 1 to 1,000,000.
    </span>
    <span class="koboSpan" id="kobo.1040.2">
     You start, and at some point, we ask you to stop.
    </span>
    <span class="koboSpan" id="kobo.1040.3">
     After some time, we ask you to resume.
    </span>
    <span class="koboSpan" id="kobo.1040.4">
     As long as you can remember the last number you reached, you will be able to continue where you left off.
    </span>
    <span class="koboSpan" id="kobo.1040.5">
     For example, if we stopped you after 31,415, you would just go on with 31,416, and so on.
    </span>
    <span class="koboSpan" id="kobo.1040.6">
     The point is that you do not need to remember all the numbers you said before 31,415, nor do you need them to be written down somewhere.
    </span>
    <span class="koboSpan" id="kobo.1040.7">
     Generators behave in much the same way.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1041.1">
     Take a good look at the following code:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.1042.1"># first.n.squares.py</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1043.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1044.1">get_squares</span></span><span class="koboSpan" id="kobo.1045.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.1046.1">n</span></span><span class="koboSpan" id="kobo.1047.1">): </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1048.1"># classic function approach</span></span>
    <span class="hljs-keyword"><span class="koboSpan" id="kobo.1049.1">return</span></span><span class="koboSpan" id="kobo.1050.1"> [x**</span><span class="hljs-number"><span class="koboSpan" id="kobo.1051.1">2</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1052.1">for</span></span><span class="koboSpan" id="kobo.1053.1"> x </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1054.1">in</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.1055.1">range</span></span><span class="koboSpan" id="kobo.1056.1">(n)]
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1057.1">print</span></span><span class="koboSpan" id="kobo.1058.1">(get_squares(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1059.1">10</span></span><span class="koboSpan" id="kobo.1060.1">))
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1061.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1062.1">get_squares_gen</span></span><span class="koboSpan" id="kobo.1063.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.1064.1">n</span></span><span class="koboSpan" id="kobo.1065.1">):  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1066.1"># generator approach</span></span>
    <span class="hljs-keyword"><span class="koboSpan" id="kobo.1067.1">for</span></span><span class="koboSpan" id="kobo.1068.1"> x </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1069.1">in</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.1070.1">range</span></span><span class="koboSpan" id="kobo.1071.1">(n):
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1072.1">yield</span></span><span class="koboSpan" id="kobo.1073.1"> x**</span><span class="hljs-number"><span class="koboSpan" id="kobo.1074.1">2</span></span>  <span class="hljs-comment"><span class="koboSpan" id="kobo.1075.1"># we yield, we do not return</span></span>
<span class="hljs-built_in"><span class="koboSpan" id="kobo.1076.1">print</span></span><span class="koboSpan" id="kobo.1077.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1078.1">list</span></span><span class="koboSpan" id="kobo.1079.1">(get_squares_gen(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1080.1">10</span></span><span class="koboSpan" id="kobo.1081.1">)))
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.1082.1">
     The result of the two
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1083.1">
      print
     </span>
    </code>
    <span class="koboSpan" id="kobo.1084.1">
     statements will be the same:
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1085.1">
      [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
     </span>
    </code>
    <span class="koboSpan" id="kobo.1086.1">
     .
    </span>
    <span class="koboSpan" id="kobo.1086.2">
     But there is an important difference between the two functions.
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1087.1">
      get_squares()
     </span>
    </code>
    <span class="koboSpan" id="kobo.1088.1">
     is a classic function that collects all the squares of numbers in
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.1089.1">
      [0, n)
     </span>
    </em>
    <span class="koboSpan" id="kobo.1090.1">
     in a list, and returns it.
    </span>
    <span class="koboSpan" id="kobo.1090.2">
     On the other hand,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1091.1">
      get_squares_gen()
     </span>
    </code>
    <span class="koboSpan" id="kobo.1092.1">
     is a generator and behaves differently.
    </span>
    <span class="koboSpan" id="kobo.1092.2">
     Each time the interpreter
    </span>
    <a id="_idIndexMarker525">
    </a>
    <span class="koboSpan" id="kobo.1093.1">
     reaches the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1094.1">
      yield
     </span>
    </code>
    <span class="koboSpan" id="kobo.1095.1">
     line, its execution is suspended.
    </span>
    <span class="koboSpan" id="kobo.1095.2">
     The only reason those
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1096.1">
      print
     </span>
    </code>
    <span class="koboSpan" id="kobo.1097.1">
     statements return the same result is because we fed
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1098.1">
      get_squares_gen()
     </span>
    </code>
    <span class="koboSpan" id="kobo.1099.1">
     to the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1100.1">
      list()
     </span>
    </code>
    <span class="koboSpan" id="kobo.1101.1">
     constructor, which exhausts the generator completely by asking for the next
    </span>
    <a id="_idIndexMarker526">
    </a>
    <span class="koboSpan" id="kobo.1102.1">
     element until a
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1103.1">
      StopIteration
     </span>
    </code>
    <span class="koboSpan" id="kobo.1104.1">
     is raised.
    </span>
    <span class="koboSpan" id="kobo.1104.2">
     Let us see this in detail:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.1105.1"># first.n.squares.manual.py</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1106.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1107.1">get_squares_gen</span></span><span class="koboSpan" id="kobo.1108.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.1109.1">n</span></span><span class="koboSpan" id="kobo.1110.1">):
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1111.1">for</span></span><span class="koboSpan" id="kobo.1112.1"> x </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1113.1">in</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.1114.1">range</span></span><span class="koboSpan" id="kobo.1115.1">(n):
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1116.1">yield</span></span><span class="koboSpan" id="kobo.1117.1"> x**</span><span class="hljs-number"><span class="koboSpan" id="kobo.1118.1">2</span></span><span class="koboSpan" id="kobo.1119.1">
squares = get_squares_gen(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1120.1">4</span></span><span class="koboSpan" id="kobo.1121.1">)  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1122.1"># this creates a generator object</span></span>
<span class="hljs-built_in"><span class="koboSpan" id="kobo.1123.1">print</span></span><span class="koboSpan" id="kobo.1124.1">(squares)  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1125.1"># &lt;generator object get_squares_gen at 0x10dd...&gt;</span></span>
<span class="hljs-built_in"><span class="koboSpan" id="kobo.1126.1">print</span></span><span class="koboSpan" id="kobo.1127.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1128.1">next</span></span><span class="koboSpan" id="kobo.1129.1">(squares))  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1130.1"># prints: 0</span></span>
<span class="hljs-built_in"><span class="koboSpan" id="kobo.1131.1">print</span></span><span class="koboSpan" id="kobo.1132.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1133.1">next</span></span><span class="koboSpan" id="kobo.1134.1">(squares))  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1135.1"># prints: 1</span></span>
<span class="hljs-built_in"><span class="koboSpan" id="kobo.1136.1">print</span></span><span class="koboSpan" id="kobo.1137.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1138.1">next</span></span><span class="koboSpan" id="kobo.1139.1">(squares))  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1140.1"># prints: 4</span></span>
<span class="hljs-built_in"><span class="koboSpan" id="kobo.1141.1">print</span></span><span class="koboSpan" id="kobo.1142.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1143.1">next</span></span><span class="koboSpan" id="kobo.1144.1">(squares))  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1145.1"># prints: 9</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.1146.1"># the following raises StopIteration, the generator is exhausted,</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.1147.1"># any further call to next will keep raising StopIteration</span></span>
<span class="hljs-built_in"><span class="koboSpan" id="kobo.1148.1">print</span></span><span class="koboSpan" id="kobo.1149.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1150.1">next</span></span><span class="koboSpan" id="kobo.1151.1">(squares))
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.1152.1">
     Each time we call
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1153.1">
      next()
     </span>
    </code>
    <span class="koboSpan" id="kobo.1154.1">
     on the generator object, we either start it (the first
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1155.1">
      next()
     </span>
    </code>
    <span class="koboSpan" id="kobo.1156.1">
     ) or make it resume from the last suspension point (any other
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1157.1">
      next()
     </span>
    </code>
    <span class="koboSpan" id="kobo.1158.1">
     ).
    </span>
    <span class="koboSpan" id="kobo.1158.2">
     The first time we call
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1159.1">
      next()
     </span>
    </code>
    <span class="koboSpan" id="kobo.1160.1">
     on it, we get 0, which is the square of 0, then 1, then 4, then 9, and since the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1161.1">
      for
     </span>
    </code>
    <span class="koboSpan" id="kobo.1162.1">
     loop stops after that (
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1163.1">
      n
     </span>
    </code>
    <span class="koboSpan" id="kobo.1164.1">
     is 4), the generator naturally ends.
    </span>
    <span class="koboSpan" id="kobo.1164.2">
     A classic function would at that point just return
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1165.1">
      None
     </span>
    </code>
    <span class="koboSpan" id="kobo.1166.1">
     , but to comply with the iteration protocol, a generator will instead raise a
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1167.1">
      StopIteration
     </span>
    </code>
    <span class="koboSpan" id="kobo.1168.1">
     exception.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1169.1">
     This explains how a
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1170.1">
      for
     </span>
    </code>
    <span class="koboSpan" id="kobo.1171.1">
     loop works.
    </span>
    <span class="koboSpan" id="kobo.1171.2">
     When you call
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1172.1">
      for k in range(n)
     </span>
    </code>
    <span class="koboSpan" id="kobo.1173.1">
     , what happens under the hood is that the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1174.1">
      for
     </span>
    </code>
    <span class="koboSpan" id="kobo.1175.1">
     loop gets an iterator out of
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1176.1">
      range(n)
     </span>
    </code>
    <span class="koboSpan" id="kobo.1177.1">
     and starts calling
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1178.1">
      next
     </span>
    </code>
    <span class="koboSpan" id="kobo.1179.1">
     on it, until
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1180.1">
      StopIteration
     </span>
    </code>
    <span class="koboSpan" id="kobo.1181.1">
     is raised, which tells the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1182.1">
      for
     </span>
    </code>
    <span class="koboSpan" id="kobo.1183.1">
     loop that the iteration has reached its end.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1184.1">
     Having this behavior built into
    </span>
    <a id="_idIndexMarker527">
    </a>
    <span class="koboSpan" id="kobo.1185.1">
     every iteration aspect of Python makes generators even more powerful because
    </span>
    <a id="_idIndexMarker528">
    </a>
    <span class="koboSpan" id="kobo.1186.1">
     once we have written them, we will be able to plug them into whatever iteration mechanism we want.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1187.1">
     At this point, you are probably asking yourself why you would want to use a generator instead of a regular function.
    </span>
    <span class="koboSpan" id="kobo.1187.2">
     The answer is to save time and (especially) memory.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1188.1">
     We will talk more about performance later, but for now, let us concentrate on one aspect: sometimes, generators allow you to do something that would not be possible with a simple list.
    </span>
    <span class="koboSpan" id="kobo.1188.2">
     For example, say you want to analyze all permutations of a sequence.
    </span>
    <span class="koboSpan" id="kobo.1188.3">
     If the sequence has a length of
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.1189.1">
      N
     </span>
    </em>
    <span class="koboSpan" id="kobo.1190.1">
     , then the number of its permutations is
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.1191.1">
      N!
     </span>
    </em>
    <span class="koboSpan" id="kobo.1192.1">
     .
    </span>
    <span class="koboSpan" id="kobo.1192.2">
     This means that if the sequence is 10 elements long, the number of permutations is 3,628,800.
    </span>
    <span class="koboSpan" id="kobo.1192.3">
     But a sequence of 20 elements would have 2,432,902,008,176,640,000 permutations.
    </span>
    <span class="koboSpan" id="kobo.1192.4">
     They grow factorially.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1193.1">
     Now imagine you have a classic function that is attempting to calculate all permutations, put them in a list, and return it to you.
    </span>
    <span class="koboSpan" id="kobo.1193.2">
     With 10 elements, it would require probably a few seconds, but for 20 elements there is simply no way that it could be done (it would take thousands of years and require billions of gigabytes of memory).
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1194.1">
     On the other hand, a generator function will be able to start the computation and give you back the first permutation, then the second, and so on.
    </span>
    <span class="koboSpan" id="kobo.1194.2">
     Of course, you will not have the time to process them all—there are too many—but at least you will be able to work with some of them.
    </span>
    <span class="koboSpan" id="kobo.1194.3">
     Sometimes the amount of data you have to iterate over is so huge that you cannot keep it all in memory in a list.
    </span>
    <span class="koboSpan" id="kobo.1194.4">
     In this case, generators are invaluable: they make possible that which otherwise would not be.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1195.1">
     So, to save memory (and time), use generator functions whenever possible.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1196.1">
     It is also worth noting that you can use the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1197.1">
      return
     </span>
    </code>
    <span class="koboSpan" id="kobo.1198.1">
     statement in a generator function.
    </span>
    <span class="koboSpan" id="kobo.1198.2">
     It will cause a
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1199.1">
      StopIteration
     </span>
    </code>
    <span class="koboSpan" id="kobo.1200.1">
     exception to be raised, effectively ending the iteration.
    </span>
    <span class="koboSpan" id="kobo.1200.2">
     If a
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1201.1">
      return
     </span>
    </code>
    <span class="koboSpan" id="kobo.1202.1">
     statement were to make the function return something, it would break the iteration protocol.
    </span>
    <span class="koboSpan" id="kobo.1202.2">
     Python’s consistency prevents this and allows us great ease when coding.
    </span>
    <span class="koboSpan" id="kobo.1202.3">
     Let us see a quick example:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.1203.1"># gen.yield.return.py</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1204.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1205.1">geometric_progression</span></span><span class="koboSpan" id="kobo.1206.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.1207.1">a, q</span></span><span class="koboSpan" id="kobo.1208.1">):
    k = </span><span class="hljs-number"><span class="koboSpan" id="kobo.1209.1">0</span></span>
    <span class="hljs-keyword"><span class="koboSpan" id="kobo.1210.1">while</span></span> <span class="hljs-literal"><span class="koboSpan" id="kobo.1211.1">True</span></span><span class="koboSpan" id="kobo.1212.1">:
        result = a * q**k
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1213.1">if</span></span><span class="koboSpan" id="kobo.1214.1"> result &lt;= </span><span class="hljs-number"><span class="koboSpan" id="kobo.1215.1">100000</span></span><span class="koboSpan" id="kobo.1216.1">:
            </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1217.1">yield</span></span><span class="koboSpan" id="kobo.1218.1"> result
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1219.1">else</span></span><span class="koboSpan" id="kobo.1220.1">:
            </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1221.1">return</span></span><span class="koboSpan" id="kobo.1222.1">
        k += </span><span class="hljs-number"><span class="koboSpan" id="kobo.1223.1">1</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1224.1">for</span></span><span class="koboSpan" id="kobo.1225.1"> n </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1226.1">in</span></span><span class="koboSpan" id="kobo.1227.1"> geometric_progression(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1228.1">2</span></span><span class="koboSpan" id="kobo.1229.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1230.1">5</span></span><span class="koboSpan" id="kobo.1231.1">):
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1232.1">print</span></span><span class="koboSpan" id="kobo.1233.1">(n)
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.1234.1">
     The preceding code yields all
    </span>
    <a id="_idIndexMarker529">
    </a>
    <span class="koboSpan" id="kobo.1235.1">
     terms of the geometric progression,
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.1236.1">
      a, aq, aq2, aq3, ...
     </span>
    </em>
    <span class="koboSpan" id="kobo.1237.1">
     .
    </span>
    <span class="koboSpan" id="kobo.1237.2">
     When the progression
    </span>
    <a id="_idIndexMarker530">
    </a>
    <span class="koboSpan" id="kobo.1238.1">
     produces a term that is greater than 100,000, the generator stops (with a
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1239.1">
      return
     </span>
    </code>
    <span class="koboSpan" id="kobo.1240.1">
     statement).
    </span>
    <span class="koboSpan" id="kobo.1240.2">
     Running the code produces the following result:
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1241.1">$ python gen.yield.return.py
2
10
50
250
1250
6250
31250
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.1242.1">
     The next term would have been
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1243.1">
      156250
     </span>
    </code>
    <span class="koboSpan" id="kobo.1244.1">
     , which is too big.
    </span>
   </p>
   <h2 class="heading-2" id="_idParaDest-173">
    <span class="koboSpan" id="kobo.1245.1">
     Going beyond next
    </span>
   </h2>
   <p class="normal">
    <span class="koboSpan" id="kobo.1246.1">
     Generator objects have methods that
    </span>
    <a id="_idIndexMarker531">
    </a>
    <span class="koboSpan" id="kobo.1247.1">
     allow us to control their behavior:
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1248.1">
      send()
     </span>
    </code>
    <span class="koboSpan" id="kobo.1249.1">
     ,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1250.1">
      throw()
     </span>
    </code>
    <span class="koboSpan" id="kobo.1251.1">
     , and
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1252.1">
      close()
     </span>
    </code>
    <span class="koboSpan" id="kobo.1253.1">
     .
    </span>
    <span class="koboSpan" id="kobo.1253.2">
     The
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1254.1">
      send()
     </span>
    </code>
    <span class="koboSpan" id="kobo.1255.1">
     method allows us to communicate a value back to the generator object, while
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1256.1">
      throw()
     </span>
    </code>
    <span class="koboSpan" id="kobo.1257.1">
     and
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1258.1">
      close()
     </span>
    </code>
    <span class="koboSpan" id="kobo.1259.1">
     , respectively, allow us to raise an exception within the generator and close it.
    </span>
    <span class="koboSpan" id="kobo.1259.2">
     Their use is quite advanced, and we will not be covering them here in detail, but we want to spend a few words on
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1260.1">
      send()
     </span>
    </code>
    <span class="koboSpan" id="kobo.1261.1">
     , with a simple example:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.1262.1"># gen.send.preparation.py</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1263.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1264.1">counter</span></span><span class="koboSpan" id="kobo.1265.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.1266.1">start=</span></span><span class="hljs-number"><span class="koboSpan" id="kobo.1267.1">0</span></span><span class="koboSpan" id="kobo.1268.1">):
    n = start
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1269.1">while</span></span> <span class="hljs-literal"><span class="koboSpan" id="kobo.1270.1">True</span></span><span class="koboSpan" id="kobo.1271.1">:
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1272.1">yield</span></span><span class="koboSpan" id="kobo.1273.1"> n
        n += </span><span class="hljs-number"><span class="koboSpan" id="kobo.1274.1">1</span></span><span class="koboSpan" id="kobo.1275.1">
c = counter()
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1276.1">print</span></span><span class="koboSpan" id="kobo.1277.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1278.1">next</span></span><span class="koboSpan" id="kobo.1279.1">(c))  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1280.1"># prints: 0</span></span>
<span class="hljs-built_in"><span class="koboSpan" id="kobo.1281.1">print</span></span><span class="koboSpan" id="kobo.1282.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1283.1">next</span></span><span class="koboSpan" id="kobo.1284.1">(c))  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1285.1"># prints: 1</span></span>
<span class="hljs-built_in"><span class="koboSpan" id="kobo.1286.1">print</span></span><span class="koboSpan" id="kobo.1287.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1288.1">next</span></span><span class="koboSpan" id="kobo.1289.1">(c))  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1290.1"># prints: 2</span></span>
</code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.1291.1">
     The preceding iterator creates a generator object that will run forever.
    </span>
    <span class="koboSpan" id="kobo.1291.2">
     You can keep calling it, and it will never stop.
    </span>
    <span class="koboSpan" id="kobo.1291.3">
     But what if you wanted to stop it at some point?
    </span>
    <span class="koboSpan" id="kobo.1291.4">
     One solution is to use a global variable to control the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1292.1">
      while
     </span>
    </code>
    <span class="koboSpan" id="kobo.1293.1">
     loop:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.1294.1"># gen.send.preparation.stop.py</span></span><span class="koboSpan" id="kobo.1295.1">
stop = </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1296.1">False</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1297.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1298.1">counter</span></span><span class="koboSpan" id="kobo.1299.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.1300.1">start=</span></span><span class="hljs-number"><span class="koboSpan" id="kobo.1301.1">0</span></span><span class="koboSpan" id="kobo.1302.1">):
    n = start
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1303.1">while</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1304.1">not</span></span><span class="koboSpan" id="kobo.1305.1"> stop:
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1306.1">yield</span></span><span class="koboSpan" id="kobo.1307.1"> n
        n += </span><span class="hljs-number"><span class="koboSpan" id="kobo.1308.1">1</span></span><span class="koboSpan" id="kobo.1309.1">
c = counter()
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1310.1">print</span></span><span class="koboSpan" id="kobo.1311.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1312.1">next</span></span><span class="koboSpan" id="kobo.1313.1">(c))  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1314.1"># prints: 0</span></span>
<span class="hljs-built_in"><span class="koboSpan" id="kobo.1315.1">print</span></span><span class="koboSpan" id="kobo.1316.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1317.1">next</span></span><span class="koboSpan" id="kobo.1318.1">(c))  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1319.1"># prints: 1</span></span><span class="koboSpan" id="kobo.1320.1">
stop = </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1321.1">True</span></span>
<span class="hljs-built_in"><span class="koboSpan" id="kobo.1322.1">print</span></span><span class="koboSpan" id="kobo.1323.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1324.1">next</span></span><span class="koboSpan" id="kobo.1325.1">(c))  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1326.1"># raises StopIteration</span></span>
</code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.1327.1">
     We initially set
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1328.1">
      stop = False
     </span>
    </code>
    <span class="koboSpan" id="kobo.1329.1">
     , and until we change it to
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1330.1">
      True
     </span>
    </code>
    <span class="koboSpan" id="kobo.1331.1">
     , the generator will just keep going, like before.
    </span>
    <span class="koboSpan" id="kobo.1331.2">
     After we change
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1332.1">
      stop
     </span>
    </code>
    <span class="koboSpan" id="kobo.1333.1">
     to
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1334.1">
      True
     </span>
    </code>
    <span class="koboSpan" id="kobo.1335.1">
     though, the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1336.1">
      while
     </span>
    </code>
    <span class="koboSpan" id="kobo.1337.1">
     loop will exit, and the following call to
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1338.1">
      next
     </span>
    </code>
    <span class="koboSpan" id="kobo.1339.1">
     will raise a
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1340.1">
      StopIteration
     </span>
    </code>
    <span class="koboSpan" id="kobo.1341.1">
     exception.
    </span>
    <span class="koboSpan" id="kobo.1341.2">
     This trick works, but it is not a satisfactory solution.
    </span>
    <span class="koboSpan" id="kobo.1341.3">
     The function depends on an external variable, which can lead to problems.
    </span>
    <span class="koboSpan" id="kobo.1341.4">
     For
    </span>
    <a id="_idIndexMarker532">
    </a>
    <span class="koboSpan" id="kobo.1342.1">
     example, the generator could inadvertently be stopped if another, unrelated function changes the global variable.
    </span>
    <span class="koboSpan" id="kobo.1342.2">
     Functions should ideally be self-contained and not rely on a global state.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1343.1">
     The generator
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1344.1">
      send()
     </span>
    </code>
    <span class="koboSpan" id="kobo.1345.1">
     method takes a single argument, which is passed into the generator function as the value of the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1346.1">
      yield
     </span>
    </code>
    <span class="koboSpan" id="kobo.1347.1">
     expression.
    </span>
    <span class="koboSpan" id="kobo.1347.2">
     We can use this to pass a flag value into the generator to signal that it should stop:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.1348.1"># gen.send.py</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1349.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1350.1">counter</span></span><span class="koboSpan" id="kobo.1351.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.1352.1">start=</span></span><span class="hljs-number"><span class="koboSpan" id="kobo.1353.1">0</span></span><span class="koboSpan" id="kobo.1354.1">):
    n = start
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1355.1">while</span></span> <span class="hljs-literal"><span class="koboSpan" id="kobo.1356.1">True</span></span><span class="koboSpan" id="kobo.1357.1">:
        result = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1358.1">yield</span></span><span class="koboSpan" id="kobo.1359.1"> n  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1360.1"># A</span></span>
        <span class="hljs-built_in"><span class="koboSpan" id="kobo.1361.1">print</span></span><span class="koboSpan" id="kobo.1362.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1363.1">type</span></span><span class="koboSpan" id="kobo.1364.1">(result), result)  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1365.1"># B</span></span>
        <span class="hljs-keyword"><span class="koboSpan" id="kobo.1366.1">if</span></span><span class="koboSpan" id="kobo.1367.1"> result == "Q":
            </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1368.1">break</span></span><span class="koboSpan" id="kobo.1369.1">
        n += </span><span class="hljs-number"><span class="koboSpan" id="kobo.1370.1">1</span></span><span class="koboSpan" id="kobo.1371.1">
c = counter()
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1372.1">print</span></span><span class="koboSpan" id="kobo.1373.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1374.1">next</span></span><span class="koboSpan" id="kobo.1375.1">(c))  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1376.1"># C</span></span>
<span class="hljs-built_in"><span class="koboSpan" id="kobo.1377.1">print</span></span><span class="koboSpan" id="kobo.1378.1">(c.send("Wow!"))  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1379.1"># D</span></span>
<span class="hljs-built_in"><span class="koboSpan" id="kobo.1380.1">print</span></span><span class="koboSpan" id="kobo.1381.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1382.1">next</span></span><span class="koboSpan" id="kobo.1383.1">(c))  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1384.1"># E</span></span>
<span class="hljs-built_in"><span class="koboSpan" id="kobo.1385.1">print</span></span><span class="koboSpan" id="kobo.1386.1">(c.send("Q"))  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1387.1"># F</span></span>
</code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.1388.1">
     Executing this code produces the following output:
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1389.1">$ python gen.send.py
0
&lt;class 'str'&gt; Wow!
</span><span class="koboSpan" id="kobo.1389.2">1
&lt;class 'NoneType'&gt; None
2
&lt;class 'str'&gt; Q
Traceback (most recent call last):
  File "gen.send.py", line 16, in &lt;module&gt;
    print(c.send("Q")) # F
          ^^^^^^^^^^^
StopIteration
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.1390.1">
     We think it is worth going through this code line by line, as if we were executing it, to see whether we can understand what is going on.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1391.1">
     We start the generator execution with a call to
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1392.1">
      next()
     </span>
    </code>
    <span class="koboSpan" id="kobo.1393.1">
     (
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1394.1">
      #C
     </span>
    </code>
    <span class="koboSpan" id="kobo.1395.1">
     ).
    </span>
    <span class="koboSpan" id="kobo.1395.2">
     Within the generator,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1396.1">
      n
     </span>
    </code>
    <span class="koboSpan" id="kobo.1397.1">
     is set to the same value as
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1398.1">
      start
     </span>
    </code>
    <span class="koboSpan" id="kobo.1399.1">
     .
    </span>
    <span class="koboSpan" id="kobo.1399.2">
     The
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1400.1">
      while
     </span>
    </code>
    <span class="koboSpan" id="kobo.1401.1">
     loop is entered, execution stops (
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1402.1">
      #A
     </span>
    </code>
    <span class="koboSpan" id="kobo.1403.1">
     ), and
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1404.1">
      n
     </span>
    </code>
    <span class="koboSpan" id="kobo.1405.1">
     (
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1406.1">
      0
     </span>
    </code>
    <span class="koboSpan" id="kobo.1407.1">
     ) is yielded back to the caller.
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1408.1">
      0
     </span>
    </code>
    <span class="koboSpan" id="kobo.1409.1">
     is printed on the console.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1410.1">
     We then call
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1411.1">
      send()
     </span>
    </code>
    <span class="koboSpan" id="kobo.1412.1">
     (
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1413.1">
      #D
     </span>
    </code>
    <span class="koboSpan" id="kobo.1414.1">
     ), execution resumes,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1415.1">
      result
     </span>
    </code>
    <span class="koboSpan" id="kobo.1416.1">
     is set to
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1417.1">
      "Wow!"
     </span>
    </code>
    <span class="koboSpan" id="kobo.1418.1">
     (still
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1419.1">
      #A
     </span>
    </code>
    <span class="koboSpan" id="kobo.1420.1">
     ), and its type and value are printed on the console (
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1421.1">
      #B
     </span>
    </code>
    <span class="koboSpan" id="kobo.1422.1">
     ).
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1423.1">
      result
     </span>
    </code>
    <span class="koboSpan" id="kobo.1424.1">
     is not
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1425.1">
      "Q"
     </span>
    </code>
    <span class="koboSpan" id="kobo.1426.1">
     , so
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1427.1">
      n
     </span>
    </code>
    <span class="koboSpan" id="kobo.1428.1">
     is incremented by 1 and execution goes back to the top of the loop.
    </span>
    <span class="koboSpan" id="kobo.1428.2">
     The
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1429.1">
      while
     </span>
    </code>
    <span class="koboSpan" id="kobo.1430.1">
     condition is
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1431.1">
      True
     </span>
    </code>
    <span class="koboSpan" id="kobo.1432.1">
     , so another iteration of the
    </span>
    <a id="_idIndexMarker533">
    </a>
    <span class="koboSpan" id="kobo.1433.1">
     loop is started.
    </span>
    <span class="koboSpan" id="kobo.1433.2">
     Execution again stops at
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1434.1">
      #A
     </span>
    </code>
    <span class="koboSpan" id="kobo.1435.1">
     , and
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1436.1">
      n
     </span>
    </code>
    <span class="koboSpan" id="kobo.1437.1">
     (
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1438.1">
      1
     </span>
    </code>
    <span class="koboSpan" id="kobo.1439.1">
     ) is yielded back to the caller.
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1440.1">
      1
     </span>
    </code>
    <span class="koboSpan" id="kobo.1441.1">
     is printed on the console.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1442.1">
     At this point, we call
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1443.1">
      next()
     </span>
    </code>
    <span class="koboSpan" id="kobo.1444.1">
     (
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1445.1">
      #E
     </span>
    </code>
    <span class="koboSpan" id="kobo.1446.1">
     ), execution is resumed (
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1447.1">
      #A
     </span>
    </code>
    <span class="koboSpan" id="kobo.1448.1">
     ), and because we are not sending anything to the generator explicitly, the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1449.1">
      yield n
     </span>
    </code>
    <span class="koboSpan" id="kobo.1450.1">
     expression (
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1451.1">
      #A
     </span>
    </code>
    <span class="koboSpan" id="kobo.1452.1">
     ) returns
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1453.1">
      None
     </span>
    </code>
    <span class="koboSpan" id="kobo.1454.1">
     (the behavior is the same as when we call a function that does not return anything).
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1455.1">
      result
     </span>
    </code>
    <span class="koboSpan" id="kobo.1456.1">
     is therefore set to
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1457.1">
      None
     </span>
    </code>
    <span class="koboSpan" id="kobo.1458.1">
     , and its type and value are again printed on the console (
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1459.1">
      #B
     </span>
    </code>
    <span class="koboSpan" id="kobo.1460.1">
     ).
    </span>
    <span class="koboSpan" id="kobo.1460.2">
     Execution continues,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1461.1">
      result
     </span>
    </code>
    <span class="koboSpan" id="kobo.1462.1">
     is not
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1463.1">
      "Q"
     </span>
    </code>
    <span class="koboSpan" id="kobo.1464.1">
     , so
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1465.1">
      n
     </span>
    </code>
    <span class="koboSpan" id="kobo.1466.1">
     is incremented by 1, and we start another loop again.
    </span>
    <span class="koboSpan" id="kobo.1466.2">
     Execution stops again (
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1467.1">
      #A
     </span>
    </code>
    <span class="koboSpan" id="kobo.1468.1">
     ) and
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1469.1">
      n
     </span>
    </code>
    <span class="koboSpan" id="kobo.1470.1">
     (
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1471.1">
      2
     </span>
    </code>
    <span class="koboSpan" id="kobo.1472.1">
     ) is yielded back to the caller.
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1473.1">
      2
     </span>
    </code>
    <span class="koboSpan" id="kobo.1474.1">
     is printed on the console.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1475.1">
     Now we call
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1476.1">
      send
     </span>
    </code>
    <span class="koboSpan" id="kobo.1477.1">
     again (
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1478.1">
      #F
     </span>
    </code>
    <span class="koboSpan" id="kobo.1479.1">
     ), this time passing the argument
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1480.1">
      "Q"
     </span>
    </code>
    <span class="koboSpan" id="kobo.1481.1">
     .
    </span>
    <span class="koboSpan" id="kobo.1481.2">
     The generator resumes,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1482.1">
      result
     </span>
    </code>
    <span class="koboSpan" id="kobo.1483.1">
     is set to
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1484.1">
      "Q"
     </span>
    </code>
    <span class="koboSpan" id="kobo.1485.1">
     (
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1486.1">
      #A
     </span>
    </code>
    <span class="koboSpan" id="kobo.1487.1">
     ), and its type and value are printed on the console again (
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1488.1">
      #B
     </span>
    </code>
    <span class="koboSpan" id="kobo.1489.1">
     ).
    </span>
    <span class="koboSpan" id="kobo.1489.2">
     When we reach the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1490.1">
      if
     </span>
    </code>
    <span class="koboSpan" id="kobo.1491.1">
     statement again,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1492.1">
      result == "Q"
     </span>
    </code>
    <span class="koboSpan" id="kobo.1493.1">
     evaluates to
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1494.1">
      True
     </span>
    </code>
    <span class="koboSpan" id="kobo.1495.1">
     , and the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1496.1">
      while
     </span>
    </code>
    <span class="koboSpan" id="kobo.1497.1">
     loop is stopped by the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1498.1">
      break
     </span>
    </code>
    <span class="koboSpan" id="kobo.1499.1">
     statement.
    </span>
    <span class="koboSpan" id="kobo.1499.2">
     The generator naturally terminates, which means a
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1500.1">
      StopIteration
     </span>
    </code>
    <span class="koboSpan" id="kobo.1501.1">
     exception is raised.
    </span>
    <span class="koboSpan" id="kobo.1501.2">
     You can see the traceback of the exception in the last few lines printed on the console.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1502.1">
     This is not at all simple to understand at first, so if it is not clear to you, do not be discouraged.
    </span>
    <span class="koboSpan" id="kobo.1502.2">
     You can keep reading and come back to this example later.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1503.1">
     Using
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1504.1">
      send()
     </span>
    </code>
    <span class="koboSpan" id="kobo.1505.1">
     allows for interesting patterns, and it is worth noting that
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1506.1">
      send()
     </span>
    </code>
    <span class="koboSpan" id="kobo.1507.1">
     can also be used to start the
    </span>
    <a id="_idIndexMarker534">
    </a>
    <span class="koboSpan" id="kobo.1508.1">
     execution of a generator (provided you call it with
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1509.1">
      None
     </span>
    </code>
    <span class="koboSpan" id="kobo.1510.1">
     ).
    </span>
   </p>
   <h2 class="heading-2" id="_idParaDest-174">
    <span class="koboSpan" id="kobo.1511.1">
     The yield from expression
    </span>
   </h2>
   <p class="normal">
    <span class="koboSpan" id="kobo.1512.1">
     Another interesting
    </span>
    <a id="_idIndexMarker535">
    </a>
    <span class="koboSpan" id="kobo.1513.1">
     construct is the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1514.1">
      yield from
     </span>
    </code>
    <span class="koboSpan" id="kobo.1515.1">
     expression.
    </span>
    <span class="koboSpan" id="kobo.1515.2">
     This expression allows you to yield values from a
    </span>
    <a id="_idIndexMarker536">
    </a>
    <span class="koboSpan" id="kobo.1516.1">
     sub-iterator.
    </span>
    <span class="koboSpan" id="kobo.1516.2">
     Its use allows for quite advanced patterns, so let us see a quick example of it:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.1517.1"># gen.yield.for.py</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1518.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1519.1">print_squares</span></span><span class="koboSpan" id="kobo.1520.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.1521.1">start, end</span></span><span class="koboSpan" id="kobo.1522.1">):
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1523.1">for</span></span><span class="koboSpan" id="kobo.1524.1"> n </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1525.1">in</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.1526.1">range</span></span><span class="koboSpan" id="kobo.1527.1">(start, end):
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1528.1">yield</span></span><span class="koboSpan" id="kobo.1529.1"> n**</span><span class="hljs-number"><span class="koboSpan" id="kobo.1530.1">2</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1531.1">for</span></span><span class="koboSpan" id="kobo.1532.1"> n </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1533.1">in</span></span><span class="koboSpan" id="kobo.1534.1"> print_squares(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1535.1">2</span></span><span class="koboSpan" id="kobo.1536.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1537.1">5</span></span><span class="koboSpan" id="kobo.1538.1">):
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1539.1">print</span></span><span class="koboSpan" id="kobo.1540.1">(n)
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.1541.1">
     The code above prints the numbers
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1542.1">
      4
     </span>
    </code>
    <span class="koboSpan" id="kobo.1543.1">
     ,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1544.1">
      9
     </span>
    </code>
    <span class="koboSpan" id="kobo.1545.1">
     , and
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1546.1">
      16
     </span>
    </code>
    <span class="koboSpan" id="kobo.1547.1">
     on the console (on separate lines).
    </span>
    <span class="koboSpan" id="kobo.1547.2">
     By now, we expect you to be able to understand it by yourself, but let us quickly recap what happens.
    </span>
    <span class="koboSpan" id="kobo.1547.3">
     The
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1548.1">
      for
     </span>
    </code>
    <span class="koboSpan" id="kobo.1549.1">
     loop outside the function gets an iterator from
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1550.1">
      print_squares(2, 5)
     </span>
    </code>
    <span class="koboSpan" id="kobo.1551.1">
     and calls
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1552.1">
      next()
     </span>
    </code>
    <span class="koboSpan" id="kobo.1553.1">
     on it until iteration is over.
    </span>
    <span class="koboSpan" id="kobo.1553.2">
     Every time the generator is called, execution is suspended (and later resumed) on
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1554.1">
      yield n**2
     </span>
    </code>
    <span class="koboSpan" id="kobo.1555.1">
     , which returns the square of the current
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1556.1">
      n
     </span>
    </code>
    <span class="koboSpan" id="kobo.1557.1">
     .
    </span>
    <span class="koboSpan" id="kobo.1557.2">
     Let us see how we could use a
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1558.1">
      yield from
     </span>
    </code>
    <span class="koboSpan" id="kobo.1559.1">
     expression to achieve the same result:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.1560.1"># gen.yield.from.py</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1561.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1562.1">print_squares</span></span><span class="koboSpan" id="kobo.1563.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.1564.1">start, end</span></span><span class="koboSpan" id="kobo.1565.1">):
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1566.1">yield</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1567.1">from</span></span><span class="koboSpan" id="kobo.1568.1"> (n**</span><span class="hljs-number"><span class="koboSpan" id="kobo.1569.1">2</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1570.1">for</span></span><span class="koboSpan" id="kobo.1571.1"> n </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1572.1">in</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.1573.1">range</span></span><span class="koboSpan" id="kobo.1574.1">(start, end))
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1575.1">for</span></span><span class="koboSpan" id="kobo.1576.1"> n </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1577.1">in</span></span><span class="koboSpan" id="kobo.1578.1"> print_squares(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1579.1">2</span></span><span class="koboSpan" id="kobo.1580.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1581.1">5</span></span><span class="koboSpan" id="kobo.1582.1">):
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1583.1">print</span></span><span class="koboSpan" id="kobo.1584.1">(n)
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.1585.1">
     This code produces the same result, but as you can see,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1586.1">
      yield from
     </span>
    </code>
    <span class="koboSpan" id="kobo.1587.1">
     is actually running a sub-iterator,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1588.1">
      (n**2 ...)
     </span>
    </code>
    <span class="koboSpan" id="kobo.1589.1">
     .
    </span>
    <span class="koboSpan" id="kobo.1589.2">
     The
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1590.1">
      yield from
     </span>
    </code>
    <span class="koboSpan" id="kobo.1591.1">
     expression returns to the caller each value the sub-iterator is
    </span>
    <a id="_idIndexMarker537">
    </a>
    <span class="koboSpan" id="kobo.1592.1">
     producing.
    </span>
    <span class="koboSpan" id="kobo.1592.2">
     It is shorter and reads better.
    </span>
   </p>
   <h2 class="heading-2" id="_idParaDest-175">
    <span class="koboSpan" id="kobo.1593.1">
     Generator expressions
    </span>
   </h2>
   <p class="normal">
    <span class="koboSpan" id="kobo.1594.1">
     In addition to generator functions, generators can also be created using
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.1595.1">
      generator expressions
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1596.1">
     .
    </span>
    <span class="koboSpan" id="kobo.1596.2">
     The syntax to create a
    </span>
    <a id="_idIndexMarker538">
    </a>
    <span class="koboSpan" id="kobo.1597.1">
     generator expression is the same as for a list comprehension, except that we use round brackets instead of square brackets.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1598.1">
     A generator
    </span>
    <a id="_idIndexMarker539">
    </a>
    <span class="koboSpan" id="kobo.1599.1">
     expression will generate the same sequence of values as an equivalent list comprehensions.
    </span>
    <span class="koboSpan" id="kobo.1599.2">
     However, instead of immediately creating a list object containing the entire sequence in memory, the generator will yield the values one at a time.
    </span>
    <span class="koboSpan" id="kobo.1599.3">
     It is important to remember that you can only iterate over a generator once.
    </span>
    <span class="koboSpan" id="kobo.1599.4">
     After that, it will be exhausted.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1600.1">
     Let us see an example:
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1601.1"># generator.expressions.txt
&gt;&gt;&gt; cubes = [k**3 for k in range(10)]  # regular list
&gt;&gt;&gt; cubes
[0, 1, 8, 27, 64, 125, 216, 343, 512, 729]
&gt;&gt;&gt; type(cubes)
&lt;class 'list'&gt;
&gt;&gt;&gt; cubes_gen = (k**3 for k in range(10))  # create as generator
&gt;&gt;&gt; cubes_gen
&lt;generator object &lt;genexpr&gt; at 0x7f08b2004860&gt;
&gt;&gt;&gt; type(cubes_gen)
&lt;class 'generator'&gt;
&gt;&gt;&gt; list(cubes_gen)  # this will exhaust the generator
[0, 1, 8, 27, 64, 125, 216, 343, 512, 729]
&gt;&gt;&gt; list(cubes_gen)  # nothing more to give
[]
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.1602.1">
     As you can see from the output when we try to print it,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1603.1">
      cubes_gen
     </span>
    </code>
    <span class="koboSpan" id="kobo.1604.1">
     is a generator object.
    </span>
    <span class="koboSpan" id="kobo.1604.2">
     To see the values it generates, we can use a
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1605.1">
      for
     </span>
    </code>
    <span class="koboSpan" id="kobo.1606.1">
     loop or a manual set of calls to
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1607.1">
      next
     </span>
    </code>
    <span class="koboSpan" id="kobo.1608.1">
     , or simply feed it to a
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1609.1">
      list()
     </span>
    </code>
    <span class="koboSpan" id="kobo.1610.1">
     constructor, which is what we did.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1611.1">
     Notice how, once the generator has been exhausted, there is no way to recover the same elements from it again.
    </span>
    <span class="koboSpan" id="kobo.1611.2">
     We need to recreate it if we want to use it from scratch again.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1612.1">
     In the next few examples, let us see how to reproduce
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1613.1">
      map()
     </span>
    </code>
    <span class="koboSpan" id="kobo.1614.1">
     and
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1615.1">
      filter()
     </span>
    </code>
    <span class="koboSpan" id="kobo.1616.1">
     using generator expressions.
    </span>
    <span class="koboSpan" id="kobo.1616.2">
     First, let’s look at
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1617.1">
      map()
     </span>
    </code>
    <span class="koboSpan" id="kobo.1618.1">
     :
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.1619.1"># gen.map.py</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1620.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.1621.1">adder</span></span><span class="koboSpan" id="kobo.1622.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.1623.1">*n</span></span><span class="koboSpan" id="kobo.1624.1">):
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1625.1">return</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.1626.1">sum</span></span><span class="koboSpan" id="kobo.1627.1">(n)
s1 = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1628.1">sum</span></span><span class="koboSpan" id="kobo.1629.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1630.1">map</span></span><span class="koboSpan" id="kobo.1631.1">(adder, </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1632.1">range</span></span><span class="koboSpan" id="kobo.1633.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1634.1">100</span></span><span class="koboSpan" id="kobo.1635.1">), </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1636.1">range</span></span><span class="koboSpan" id="kobo.1637.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1638.1">1</span></span><span class="koboSpan" id="kobo.1639.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1640.1">101</span></span><span class="koboSpan" id="kobo.1641.1">)))
s2 = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1642.1">sum</span></span><span class="koboSpan" id="kobo.1643.1">(adder(*n) </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1644.1">for</span></span><span class="koboSpan" id="kobo.1645.1"> n </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1646.1">in</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.1647.1">zip</span></span><span class="koboSpan" id="kobo.1648.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1649.1">range</span></span><span class="koboSpan" id="kobo.1650.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1651.1">100</span></span><span class="koboSpan" id="kobo.1652.1">), </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1653.1">range</span></span><span class="koboSpan" id="kobo.1654.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1655.1">1</span></span><span class="koboSpan" id="kobo.1656.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.1657.1">101</span></span><span class="koboSpan" id="kobo.1658.1">)))
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.1659.1">
     In the previous example,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1660.1">
      s1
     </span>
    </code>
    <span class="koboSpan" id="kobo.1661.1">
     and
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1662.1">
      s2
     </span>
    </code>
    <span class="koboSpan" id="kobo.1663.1">
     are both equal to the sum of
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1664.1">
      adder(0, 1)
     </span>
    </code>
    <span class="koboSpan" id="kobo.1665.1">
     ,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1666.1">
      adder(1, 2)
     </span>
    </code>
    <span class="koboSpan" id="kobo.1667.1">
     ,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1668.1">
      adder(2, 3)
     </span>
    </code>
    <span class="koboSpan" id="kobo.1669.1">
     , and so on, which
    </span>
    <a id="_idIndexMarker540">
    </a>
    <span class="koboSpan" id="kobo.1670.1">
     translates to
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1671.1">
      sum(1, 3, 5, ...)
     </span>
    </code>
    <span class="koboSpan" id="kobo.1672.1">
     .
    </span>
    <span class="koboSpan" id="kobo.1672.2">
     We find the generator expression syntax to be much more readable, though.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1673.1">
     Now for
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1674.1">
      filter()
     </span>
    </code>
    <span class="koboSpan" id="kobo.1675.1">
     :
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.1676.1"># gen.filter.py</span></span><span class="koboSpan" id="kobo.1677.1">
cubes = [x**</span><span class="hljs-number"><span class="koboSpan" id="kobo.1678.1">3</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1679.1">for</span></span><span class="koboSpan" id="kobo.1680.1"> x </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1681.1">in</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.1682.1">range</span></span><span class="koboSpan" id="kobo.1683.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1684.1">10</span></span><span class="koboSpan" id="kobo.1685.1">)]
odd_cubes1 = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1686.1">filter</span></span><span class="koboSpan" id="kobo.1687.1">(</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1688.1">lambda</span></span><span class="koboSpan" id="kobo.1689.1"> cube: cube % </span><span class="hljs-number"><span class="koboSpan" id="kobo.1690.1">2</span></span><span class="koboSpan" id="kobo.1691.1">, cubes)
odd_cubes2 = (cube </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1692.1">for</span></span><span class="koboSpan" id="kobo.1693.1"> cube </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1694.1">in</span></span><span class="koboSpan" id="kobo.1695.1"> cubes </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1696.1">if</span></span><span class="koboSpan" id="kobo.1697.1"> cube % </span><span class="hljs-number"><span class="koboSpan" id="kobo.1698.1">2</span></span><span class="koboSpan" id="kobo.1699.1">)
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.1700.1">
     In this example,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1701.1">
      odd_cubes1
     </span>
    </code>
    <span class="koboSpan" id="kobo.1702.1">
     and
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1703.1">
      odd_cubes2
     </span>
    </code>
    <span class="koboSpan" id="kobo.1704.1">
     are equivalent: they generate a sequence of odd cubes.
    </span>
    <span class="koboSpan" id="kobo.1704.2">
     Yet
    </span>
    <a id="_idIndexMarker541">
    </a>
    <span class="koboSpan" id="kobo.1705.1">
     again, we prefer the generator syntax.
    </span>
    <span class="koboSpan" id="kobo.1705.2">
     This should be evident when things get a little more complicated:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.1706.1"># gen.map.filter.py</span></span><span class="koboSpan" id="kobo.1707.1">
N = </span><span class="hljs-number"><span class="koboSpan" id="kobo.1708.1">20</span></span><span class="koboSpan" id="kobo.1709.1">
cubes1 = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1710.1">map</span></span><span class="koboSpan" id="kobo.1711.1">(
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1712.1">lambda</span></span><span class="koboSpan" id="kobo.1713.1"> n: (n, n**</span><span class="hljs-number"><span class="koboSpan" id="kobo.1714.1">3</span></span><span class="koboSpan" id="kobo.1715.1">),
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1716.1">filter</span></span><span class="koboSpan" id="kobo.1717.1">(</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1718.1">lambda</span></span><span class="koboSpan" id="kobo.1719.1"> n: n % </span><span class="hljs-number"><span class="koboSpan" id="kobo.1720.1">3</span></span><span class="koboSpan" id="kobo.1721.1"> == </span><span class="hljs-number"><span class="koboSpan" id="kobo.1722.1">0</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1723.1">or</span></span><span class="koboSpan" id="kobo.1724.1"> n % </span><span class="hljs-number"><span class="koboSpan" id="kobo.1725.1">5</span></span><span class="koboSpan" id="kobo.1726.1"> == </span><span class="hljs-number"><span class="koboSpan" id="kobo.1727.1">0</span></span><span class="koboSpan" id="kobo.1728.1">, </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1729.1">range</span></span><span class="koboSpan" id="kobo.1730.1">(N)),
)
cubes2 = ((n, n**</span><span class="hljs-number"><span class="koboSpan" id="kobo.1731.1">3</span></span><span class="koboSpan" id="kobo.1732.1">) </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1733.1">for</span></span><span class="koboSpan" id="kobo.1734.1"> n </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1735.1">in</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.1736.1">range</span></span><span class="koboSpan" id="kobo.1737.1">(N) </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1738.1">if</span></span><span class="koboSpan" id="kobo.1739.1"> n % </span><span class="hljs-number"><span class="koboSpan" id="kobo.1740.1">3</span></span><span class="koboSpan" id="kobo.1741.1"> == </span><span class="hljs-number"><span class="koboSpan" id="kobo.1742.1">0</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1743.1">or</span></span><span class="koboSpan" id="kobo.1744.1"> n % </span><span class="hljs-number"><span class="koboSpan" id="kobo.1745.1">5</span></span><span class="koboSpan" id="kobo.1746.1"> == </span><span class="hljs-number"><span class="koboSpan" id="kobo.1747.1">0</span></span><span class="koboSpan" id="kobo.1748.1">)
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.1749.1">
     The preceding code creates two iterators,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1750.1">
      cubes1
     </span>
    </code>
    <span class="koboSpan" id="kobo.1751.1">
     and
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1752.1">
      cubes2
     </span>
    </code>
    <span class="koboSpan" id="kobo.1753.1">
     .
    </span>
    <span class="koboSpan" id="kobo.1753.2">
     Both will yield the same sequence of tuples
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.1754.1">
      (n, n3)
     </span>
    </em>
    <span class="koboSpan" id="kobo.1755.1">
     where
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1756.1">
      n
     </span>
    </code>
    <span class="koboSpan" id="kobo.1757.1">
     is a multiple of 3 or 5.
    </span>
    <span class="koboSpan" id="kobo.1757.2">
     If you print the list of values obtained from either, you get the following:
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1758.1">
      [(0, 0), (3, 27), (5, 125), (6, 216), (9, 729), (10, 1000), (12, 1728), (15, 3375), (18, 5832)]
     </span>
    </code>
    <span class="koboSpan" id="kobo.1759.1">
     .
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1760.1">
     Notice that the generator expression is much easier to read.
    </span>
    <span class="koboSpan" id="kobo.1760.2">
     It may be debatable for trivial examples, but as soon
    </span>
    <a id="_idIndexMarker542">
    </a>
    <span class="koboSpan" id="kobo.1761.1">
     as you start performing more complex operations, the
    </span>
    <a id="_idIndexMarker543">
    </a>
    <span class="koboSpan" id="kobo.1762.1">
     superiority of the generator syntax is evident.
    </span>
    <span class="koboSpan" id="kobo.1762.2">
     It is shorter, simpler, and more elegant.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1763.1">
     Now, let us ask you: what is the difference between the following lines of code?
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.1764.1"># sum.example.py</span></span><span class="koboSpan" id="kobo.1765.1">
s1 = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1766.1">sum</span></span><span class="koboSpan" id="kobo.1767.1">([n**</span><span class="hljs-number"><span class="koboSpan" id="kobo.1768.1">2</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1769.1">for</span></span><span class="koboSpan" id="kobo.1770.1"> n </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1771.1">in</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.1772.1">range</span></span><span class="koboSpan" id="kobo.1773.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1774.1">10</span></span><span class="koboSpan" id="kobo.1775.1">**</span><span class="hljs-number"><span class="koboSpan" id="kobo.1776.1">6</span></span><span class="koboSpan" id="kobo.1777.1">)])
s2 = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1778.1">sum</span></span><span class="koboSpan" id="kobo.1779.1">((n**</span><span class="hljs-number"><span class="koboSpan" id="kobo.1780.1">2</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1781.1">for</span></span><span class="koboSpan" id="kobo.1782.1"> n </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1783.1">in</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.1784.1">range</span></span><span class="koboSpan" id="kobo.1785.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1786.1">10</span></span><span class="koboSpan" id="kobo.1787.1">**</span><span class="hljs-number"><span class="koboSpan" id="kobo.1788.1">6</span></span><span class="koboSpan" id="kobo.1789.1">)))
s3 = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1790.1">sum</span></span><span class="koboSpan" id="kobo.1791.1">(n**</span><span class="hljs-number"><span class="koboSpan" id="kobo.1792.1">2</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1793.1">for</span></span><span class="koboSpan" id="kobo.1794.1"> n </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1795.1">in</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.1796.1">range</span></span><span class="koboSpan" id="kobo.1797.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1798.1">10</span></span><span class="koboSpan" id="kobo.1799.1">**</span><span class="hljs-number"><span class="koboSpan" id="kobo.1800.1">6</span></span><span class="koboSpan" id="kobo.1801.1">))
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.1802.1">
     Strictly speaking, they all produce the same sum.
    </span>
    <span class="koboSpan" id="kobo.1802.2">
     The expressions to get
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1803.1">
      s2
     </span>
    </code>
    <span class="koboSpan" id="kobo.1804.1">
     and
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1805.1">
      s3
     </span>
    </code>
    <span class="koboSpan" id="kobo.1806.1">
     are equivalent because the brackets in
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1807.1">
      s2
     </span>
    </code>
    <span class="koboSpan" id="kobo.1808.1">
     are redundant.
    </span>
    <span class="koboSpan" id="kobo.1808.2">
     Both are generator expressions passed to the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1809.1">
      sum()
     </span>
    </code>
    <span class="koboSpan" id="kobo.1810.1">
     function.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1811.1">
     The expression to get
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1812.1">
      s1
     </span>
    </code>
    <span class="koboSpan" id="kobo.1813.1">
     is different, though.
    </span>
    <span class="koboSpan" id="kobo.1813.2">
     Here we are passing the result of a list comprehension to
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1814.1">
      sum()
     </span>
    </code>
    <span class="koboSpan" id="kobo.1815.1">
     .
    </span>
    <span class="koboSpan" id="kobo.1815.2">
     This wastes both time and memory because we first create a list of a million elements (which has to be stored in memory).
    </span>
    <span class="koboSpan" id="kobo.1815.3">
     We then pass the list to
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1816.1">
      sum
     </span>
    </code>
    <span class="koboSpan" id="kobo.1817.1">
     , which iterates
    </span>
    <a id="_idIndexMarker544">
    </a>
    <span class="koboSpan" id="kobo.1818.1">
     over it, after which we discard the list.
    </span>
    <span class="koboSpan" id="kobo.1818.2">
     It is much better to use a generator expression, as we do not need to wait for a list to be constructed, and we do not need to store the entire sequence of 1 million values in memory.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1819.1">
     So,
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.1820.1">
      watch out for extra parentheses when you write your expressions
     </span>
    </em>
    <span class="koboSpan" id="kobo.1821.1">
     .
    </span>
    <span class="koboSpan" id="kobo.1821.2">
     Details like this are easy to miss, but they can make a significant difference.
    </span>
    <span class="koboSpan" id="kobo.1821.3">
     For example, look at the following code:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.1822.1"># sum.example.2.py</span></span><span class="koboSpan" id="kobo.1823.1">
s = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1824.1">sum</span></span><span class="koboSpan" id="kobo.1825.1">([n**</span><span class="hljs-number"><span class="koboSpan" id="kobo.1826.1">2</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.1827.1">for</span></span><span class="koboSpan" id="kobo.1828.1"> n </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1829.1">in</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.1830.1">range</span></span><span class="koboSpan" id="kobo.1831.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1832.1">10</span></span><span class="koboSpan" id="kobo.1833.1">**</span><span class="hljs-number"><span class="koboSpan" id="kobo.1834.1">10</span></span><span class="koboSpan" id="kobo.1835.1">)])  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1836.1"># this is killed</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.1837.1"># s = sum(n**2 for n in range(10**10))  # this succeeds</span></span>
<span class="hljs-built_in"><span class="koboSpan" id="kobo.1838.1">print</span></span><span class="koboSpan" id="kobo.1839.1">(s)  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1840.1"># prints: 333333333283333333335000000000</span></span>
</code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.1841.1">
     If we run this, we get:
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1842.1">$ python sum.example.2.py
Killed
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.1843.1">
     On the other hand, if we comment out the first line, and uncomment the second one, this is the result:
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1844.1">$ python sum.example.2.py
333333333283333333335000000000
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.1845.1">
     The difference between the two lines is that in the first, the Python interpreter must construct a list with the
    </span>
    <a id="_idIndexMarker545">
    </a>
    <span class="koboSpan" id="kobo.1846.1">
     squares of the first ten billion numbers to pass to the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1847.1">
      sum
     </span>
    </code>
    <span class="koboSpan" id="kobo.1848.1">
     function.
    </span>
    <span class="koboSpan" id="kobo.1848.2">
     That list is huge, and we ran out of memory, so the operating system killed the process.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1849.1">
     When we remove the
    </span>
    <a id="_idIndexMarker546">
    </a>
    <span class="koboSpan" id="kobo.1850.1">
     square brackets, we no longer have a list.
    </span>
    <span class="koboSpan" id="kobo.1850.2">
     The
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1851.1">
      sum
     </span>
    </code>
    <span class="koboSpan" id="kobo.1852.1">
     function receives a generator, which yields 0, 1, 4, 9, and so on, and computes the sum without needing to keep all the values in memory.
    </span>
   </p>
   <h1 class="heading-1" id="_idParaDest-176">
    <span class="koboSpan" id="kobo.1853.1">
     Some performance considerations
    </span>
   </h1>
   <p class="normal">
    <span class="koboSpan" id="kobo.1854.1">
     There are usually multiple ways of achieving the same result.
    </span>
    <span class="koboSpan" id="kobo.1854.2">
     We can use any combination of
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1855.1">
      map()
     </span>
    </code>
    <span class="koboSpan" id="kobo.1856.1">
     ,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1857.1">
      zip()
     </span>
    </code>
    <span class="koboSpan" id="kobo.1858.1">
     , and
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1859.1">
      filter()
     </span>
    </code>
    <span class="koboSpan" id="kobo.1860.1">
     , or choose to go with a comprehension or a generator.
    </span>
    <span class="koboSpan" id="kobo.1860.2">
     We may even decide to go with
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1861.1">
      for
     </span>
    </code>
    <span class="koboSpan" id="kobo.1862.1">
     loops.
    </span>
    <span class="koboSpan" id="kobo.1862.2">
     Readability is often a factor in choosing between these approaches.
    </span>
    <span class="koboSpan" id="kobo.1862.3">
     List
    </span>
    <a id="_idIndexMarker547">
    </a>
    <span class="koboSpan" id="kobo.1863.1">
     comprehensions or generator expressions are often easier to read than complex combinations of
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1864.1">
      map()
     </span>
    </code>
    <span class="koboSpan" id="kobo.1865.1">
     and
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1866.1">
      filter()
     </span>
    </code>
    <span class="koboSpan" id="kobo.1867.1">
     .
    </span>
    <span class="koboSpan" id="kobo.1867.2">
     For more complicated operations, generator functions or
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1868.1">
      for
     </span>
    </code>
    <span class="koboSpan" id="kobo.1869.1">
     loops are often
    </span>
    <a id="_idIndexMarker548">
    </a>
    <span class="koboSpan" id="kobo.1870.1">
     better.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1871.1">
     Besides readability concerns, however, we must also consider performance when deciding which approach to use.
    </span>
    <span class="koboSpan" id="kobo.1871.2">
     There are two factors that need to be considered when comparing the performance of different implementations:
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1872.1">
      space
     </span>
    </code>
    <span class="koboSpan" id="kobo.1873.1">
     and
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1874.1">
      time
     </span>
    </code>
    <span class="koboSpan" id="kobo.1875.1">
     .
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1876.1">
     Space refers to the amount of memory that your data structures are going to use.
    </span>
    <span class="koboSpan" id="kobo.1876.2">
     The best way to choose is to ask yourself if you really need a list (or tuple), or whether a generator would work instead.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1877.1">
     If the answer is yes to the latter, go with the generator, as it will save a lot of space.
    </span>
    <span class="koboSpan" id="kobo.1877.2">
     The same goes for functions: if you do not actually need them to return a list or tuple, then you can transform them into generator functions as well.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1878.1">
     Sometimes, you will have to use lists (or tuples); for example, there are algorithms that scan sequences using multiple pointers, and others need to iterate over the sequence more than once.
    </span>
    <span class="koboSpan" id="kobo.1878.2">
     A generator (function or expression) can be iterated over only once before it is exhausted, so in these situations, it would not be the right choice.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1879.1">
     Time is a bit more complicated than space because it depends on more variables, and it is not always possible to state that
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.1880.1">
      X is faster than Y
     </span>
    </em>
    <span class="koboSpan" id="kobo.1881.1">
     with absolute certainty for all cases.
    </span>
    <span class="koboSpan" id="kobo.1881.2">
     However, based on tests run on Python today, we can say that on average,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1882.1">
      map()
     </span>
    </code>
    <span class="koboSpan" id="kobo.1883.1">
     exhibits performance similar to comprehensions and generator expressions, while
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1884.1">
      for
     </span>
    </code>
    <span class="koboSpan" id="kobo.1885.1">
     loops are consistently slower.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1886.1">
     To appreciate the reasoning behind these statements fully, we need to understand how Python works, which is a bit outside the scope of this book as it is quite technical and detailed.
    </span>
    <span class="koboSpan" id="kobo.1886.2">
     Let us just say that
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1887.1">
      map()
     </span>
    </code>
    <span class="koboSpan" id="kobo.1888.1">
     and comprehensions run at C language speed within the interpreter, while a Python
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1889.1">
      for
     </span>
    </code>
    <span class="koboSpan" id="kobo.1890.1">
     loop is run as Python bytecode within the Python Virtual Machine, which is often much slower.
    </span>
   </p>
   <div class="note">
    <p class="normal">
     <span class="koboSpan" id="kobo.1891.1">
      There are several different implementations of Python.
     </span>
     <span class="koboSpan" id="kobo.1891.2">
      The original one, and still the most common
     </span>
     <a id="_idIndexMarker549">
     </a>
     <span class="koboSpan" id="kobo.1892.1">
      one, is CPython (
     </span>
     <a href="https://github.com/python/cpython">
      <span class="url">
       <span class="koboSpan" id="kobo.1893.1">
        https://github.com/python/cpython
       </span>
      </span>
     </a>
     <span class="koboSpan" id="kobo.1894.1">
      ), which is written in C.
     </span>
     <span class="koboSpan" id="kobo.1894.2">
      C is one of the most powerful and popular programming languages still used today.
     </span>
    </p>
   </div>
   <p class="normal">
    <span class="koboSpan" id="kobo.1895.1">
     In the rest of this section, we will perform some simple experiments to verify these performance claims.
    </span>
    <span class="koboSpan" id="kobo.1895.2">
     We will
    </span>
    <a id="_idIndexMarker550">
    </a>
    <span class="koboSpan" id="kobo.1896.1">
     write a small piece of code that collects the results of
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1897.1">
      divmod(a, b)
     </span>
    </code>
    <span class="koboSpan" id="kobo.1898.1">
     for a set
    </span>
    <a id="_idIndexMarker551">
    </a>
    <span class="koboSpan" id="kobo.1899.1">
     of integer pairs,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1900.1">
      (a, b)
     </span>
    </code>
    <span class="koboSpan" id="kobo.1901.1">
     .
    </span>
    <span class="koboSpan" id="kobo.1901.2">
     We will use the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1902.1">
      time()
     </span>
    </code>
    <span class="koboSpan" id="kobo.1903.1">
     function from the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1904.1">
      time
     </span>
    </code>
    <span class="koboSpan" id="kobo.1905.1">
     module to calculate the elapsed time of the operations that we perform:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.1906.1"># performance.py</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.1907.1">from</span></span><span class="koboSpan" id="kobo.1908.1"> time </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1909.1">import</span></span><span class="koboSpan" id="kobo.1910.1"> time
mx = </span><span class="hljs-number"><span class="koboSpan" id="kobo.1911.1">5000</span></span><span class="koboSpan" id="kobo.1912.1">
t = time()  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1913.1"># start time for the for loop</span></span><span class="koboSpan" id="kobo.1914.1">
floop = []
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1915.1">for</span></span><span class="koboSpan" id="kobo.1916.1"> a </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1917.1">in</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.1918.1">range</span></span><span class="koboSpan" id="kobo.1919.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1920.1">1</span></span><span class="koboSpan" id="kobo.1921.1">, mx):
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1922.1">for</span></span><span class="koboSpan" id="kobo.1923.1"> b </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1924.1">in</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.1925.1">range</span></span><span class="koboSpan" id="kobo.1926.1">(a, mx):
        floop.append(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1927.1">divmod</span></span><span class="koboSpan" id="kobo.1928.1">(a, b))
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1929.1">print</span></span><span class="koboSpan" id="kobo.1930.1">("</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1931.1">for</span></span><span class="koboSpan" id="kobo.1932.1"> loop: {:</span><span class="hljs-number"><span class="koboSpan" id="kobo.1933.1">.4</span></span><span class="koboSpan" id="kobo.1934.1">f} s".</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1935.1">format</span></span><span class="koboSpan" id="kobo.1936.1">(time() - t))  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1937.1"># elapsed time</span></span><span class="koboSpan" id="kobo.1938.1">
t = time()  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1939.1"># start time for the list comprehension</span></span><span class="koboSpan" id="kobo.1940.1">
compr = [</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1941.1">divmod</span></span><span class="koboSpan" id="kobo.1942.1">(a, b) </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1943.1">for</span></span><span class="koboSpan" id="kobo.1944.1"> a </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1945.1">in</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.1946.1">range</span></span><span class="koboSpan" id="kobo.1947.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1948.1">1</span></span><span class="koboSpan" id="kobo.1949.1">, mx) </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1950.1">for</span></span><span class="koboSpan" id="kobo.1951.1"> b </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1952.1">in</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.1953.1">range</span></span><span class="koboSpan" id="kobo.1954.1">(a, mx)]
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1955.1">print</span></span><span class="koboSpan" id="kobo.1956.1">("</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1957.1">list</span></span><span class="koboSpan" id="kobo.1958.1"> comprehension: {:</span><span class="hljs-number"><span class="koboSpan" id="kobo.1959.1">.4</span></span><span class="koboSpan" id="kobo.1960.1">f} s".</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1961.1">format</span></span><span class="koboSpan" id="kobo.1962.1">(time() - t))
t = time()  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1963.1"># start time for the generator expression</span></span><span class="koboSpan" id="kobo.1964.1">
gener = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1965.1">list</span></span><span class="koboSpan" id="kobo.1966.1">(
    </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1967.1">divmod</span></span><span class="koboSpan" id="kobo.1968.1">(a, b) </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1969.1">for</span></span><span class="koboSpan" id="kobo.1970.1"> a </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1971.1">in</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.1972.1">range</span></span><span class="koboSpan" id="kobo.1973.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1974.1">1</span></span><span class="koboSpan" id="kobo.1975.1">, mx) </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1976.1">for</span></span><span class="koboSpan" id="kobo.1977.1"> b </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1978.1">in</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.1979.1">range</span></span><span class="koboSpan" id="kobo.1980.1">(a, mx)
)
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1981.1">print</span></span><span class="koboSpan" id="kobo.1982.1">("generator expression: {:</span><span class="hljs-number"><span class="koboSpan" id="kobo.1983.1">.4</span></span><span class="koboSpan" id="kobo.1984.1">f} s".</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1985.1">format</span></span><span class="koboSpan" id="kobo.1986.1">(time() - t))
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.1987.1">
     As you can see, we are creating three lists:
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1988.1">
      floop
     </span>
    </code>
    <span class="koboSpan" id="kobo.1989.1">
     ,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1990.1">
      compr
     </span>
    </code>
    <span class="koboSpan" id="kobo.1991.1">
     , and
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1992.1">
      gener
     </span>
    </code>
    <span class="koboSpan" id="kobo.1993.1">
     .
    </span>
    <span class="koboSpan" id="kobo.1993.2">
     Running the code produces the following:
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1994.1">$ python performance.py
for loop: 2.3832 s
list comprehension: 1.6882 s
generator expression: 1.6525 s
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.1995.1">
     The list comprehension runs in ~71% of the time taken by the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.1996.1">
      for
     </span>
    </code>
    <span class="koboSpan" id="kobo.1997.1">
     loop.
    </span>
    <span class="koboSpan" id="kobo.1997.2">
     The generator expression was slightly faster than that, with ~69%.
    </span>
    <span class="koboSpan" id="kobo.1997.3">
     The difference in time between the list comprehension and generator expression is hardly significant, and if you re-run the example a few times, you will probably also see the list comprehension take less time than the generator expression.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.1998.1">
     It is worth noting that, within
    </span>
    <a id="_idIndexMarker552">
    </a>
    <span class="koboSpan" id="kobo.1999.1">
     the body of the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2000.1">
      for
     </span>
    </code>
    <span class="koboSpan" id="kobo.2001.1">
     loop, we are appending data to a list.
    </span>
    <span class="koboSpan" id="kobo.2001.2">
     This implies that, behind
    </span>
    <a id="_idIndexMarker553">
    </a>
    <span class="koboSpan" id="kobo.2002.1">
     the scenes, the Python interpreter occasionally has to resize the list to allocate space for more items to be appended.
    </span>
    <span class="koboSpan" id="kobo.2002.2">
     We guessed that creating a list of zeros, and simply filling it with the results, might have sped up the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2003.1">
      for
     </span>
    </code>
    <span class="koboSpan" id="kobo.2004.1">
     loop, but we were wrong.
    </span>
    <span class="koboSpan" id="kobo.2004.2">
     Try it for yourself; you just need
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2005.1">
      mx * (mx - 1) // 2
     </span>
    </code>
    <span class="koboSpan" id="kobo.2006.1">
     elements to be pre-allocated.
    </span>
   </p>
   <div class="note">
    <p class="normal">
     <span class="koboSpan" id="kobo.2007.1">
      The approach we used here for timing execution is rather naïve.
     </span>
     <span class="koboSpan" id="kobo.2007.2">
      In
     </span>
     <em class="chapterRef">
      <span class="koboSpan" id="kobo.2008.1">
       Chapter 11
      </span>
     </em>
     <span class="koboSpan" id="kobo.2009.1">
      ,
     </span>
     <em class="chapterRef">
      <span class="koboSpan" id="kobo.2010.1">
       Debugging and Profiling
      </span>
     </em>
     <span class="koboSpan" id="kobo.2011.1">
      , we will look at better ways of profiling code and timing execution.
     </span>
    </p>
   </div>
   <p class="normal">
    <span class="koboSpan" id="kobo.2012.1">
     Let us see a similar example that compares a
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2013.1">
      for
     </span>
    </code>
    <span class="koboSpan" id="kobo.2014.1">
     loop and a
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2015.1">
      map()
     </span>
    </code>
    <span class="koboSpan" id="kobo.2016.1">
     call:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.2017.1"># performance.map.py</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.2018.1">from</span></span><span class="koboSpan" id="kobo.2019.1"> time </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2020.1">import</span></span><span class="koboSpan" id="kobo.2021.1"> time
mx = </span><span class="hljs-number"><span class="koboSpan" id="kobo.2022.1">2</span></span><span class="koboSpan" id="kobo.2023.1"> * </span><span class="hljs-number"><span class="koboSpan" id="kobo.2024.1">10</span></span><span class="koboSpan" id="kobo.2025.1">**</span><span class="hljs-number"><span class="koboSpan" id="kobo.2026.1">7</span></span><span class="koboSpan" id="kobo.2027.1">
t = time()
absloop = []
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2028.1">for</span></span><span class="koboSpan" id="kobo.2029.1"> n </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2030.1">in</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.2031.1">range</span></span><span class="koboSpan" id="kobo.2032.1">(mx):
    absloop.append(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2033.1">abs</span></span><span class="koboSpan" id="kobo.2034.1">(n))
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2035.1">print</span></span><span class="koboSpan" id="kobo.2036.1">("</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2037.1">for</span></span><span class="koboSpan" id="kobo.2038.1"> loop: {:</span><span class="hljs-number"><span class="koboSpan" id="kobo.2039.1">.4</span></span><span class="koboSpan" id="kobo.2040.1">f} s".</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2041.1">format</span></span><span class="koboSpan" id="kobo.2042.1">(time() - t))
t = time()
abslist = [</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2043.1">abs</span></span><span class="koboSpan" id="kobo.2044.1">(n) </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2045.1">for</span></span><span class="koboSpan" id="kobo.2046.1"> n </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2047.1">in</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.2048.1">range</span></span><span class="koboSpan" id="kobo.2049.1">(mx)]
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2050.1">print</span></span><span class="koboSpan" id="kobo.2051.1">("</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2052.1">list</span></span><span class="koboSpan" id="kobo.2053.1"> comprehension: {:</span><span class="hljs-number"><span class="koboSpan" id="kobo.2054.1">.4</span></span><span class="koboSpan" id="kobo.2055.1">f} s".</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2056.1">format</span></span><span class="koboSpan" id="kobo.2057.1">(time() - t))
t = time()
absmap = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2058.1">list</span></span><span class="koboSpan" id="kobo.2059.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2060.1">map</span></span><span class="koboSpan" id="kobo.2061.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2062.1">abs</span></span><span class="koboSpan" id="kobo.2063.1">, </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2064.1">range</span></span><span class="koboSpan" id="kobo.2065.1">(mx)))
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2066.1">print</span></span><span class="koboSpan" id="kobo.2067.1">("</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2068.1">map</span></span><span class="koboSpan" id="kobo.2069.1">: {:</span><span class="hljs-number"><span class="koboSpan" id="kobo.2070.1">.4</span></span><span class="koboSpan" id="kobo.2071.1">f} s".</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2072.1">format</span></span><span class="koboSpan" id="kobo.2073.1">(time() - t))
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.2074.1">
     This code is conceptually similar to the previous example.
    </span>
    <span class="koboSpan" id="kobo.2074.2">
     The only thing that has changed is that we are applying the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2075.1">
      abs()
     </span>
    </code>
    <span class="koboSpan" id="kobo.2076.1">
     function instead of
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2077.1">
      divmod()
     </span>
    </code>
    <span class="koboSpan" id="kobo.2078.1">
     , and we have only one loop instead of two nested ones.
    </span>
    <span class="koboSpan" id="kobo.2078.2">
     Execution gives the following result:
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.2079.1">$ python performance.map.py
for loop: 1.9009 s
list comprehension: 1.0973 s
map: 0.5862 s
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.2080.1">
     This time,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2081.1">
      map
     </span>
    </code>
    <span class="koboSpan" id="kobo.2082.1">
     was the fastest: it took ~53% of the time required by the list comprehension, and ~31% of the time needed by the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2083.1">
      for
     </span>
    </code>
    <span class="koboSpan" id="kobo.2084.1">
     loop.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.2085.1">
     The results from these experiments give us a rough indication of the relative speed of
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2086.1">
      for
     </span>
    </code>
    <span class="koboSpan" id="kobo.2087.1">
     loops, list comprehensions, generator expressions, and the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2088.1">
      map()
     </span>
    </code>
    <span class="koboSpan" id="kobo.2089.1">
     function.
    </span>
    <span class="koboSpan" id="kobo.2089.2">
     Do not rely too heavily on these results though, as the experiments we performed here are rather simplistic, and accurately measuring and comparing execution times is difficult.
    </span>
    <span class="koboSpan" id="kobo.2089.3">
     Measurements can
    </span>
    <a id="_idIndexMarker554">
    </a>
    <span class="koboSpan" id="kobo.2090.1">
     easily be affected by several factors, such as other processes running on the same computer.
    </span>
    <span class="koboSpan" id="kobo.2090.2">
     Performance results are also heavily dependent on the hardware, operating
    </span>
    <a id="_idIndexMarker555">
    </a>
    <span class="koboSpan" id="kobo.2091.1">
     system, and Python version.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.2092.1">
     It is clear that
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2093.1">
      for
     </span>
    </code>
    <span class="koboSpan" id="kobo.2094.1">
     loops are slower than comprehensions or
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2095.1">
      map()
     </span>
    </code>
    <span class="koboSpan" id="kobo.2096.1">
     , so it is worth discussing why we nevertheless often prefer them over the alternatives.
    </span>
   </p>
   <h1 class="heading-1" id="_idParaDest-177">
    <span class="koboSpan" id="kobo.2097.1">
     Do not overdo comprehensions and generators
    </span>
   </h1>
   <p class="normal">
    <span class="koboSpan" id="kobo.2098.1">
     We have seen how powerful comprehensions and generator expressions can be.
    </span>
    <span class="koboSpan" id="kobo.2098.2">
     However, we find that the more you try to do within a single comprehension
    </span>
    <a id="_idIndexMarker556">
    </a>
    <span class="koboSpan" id="kobo.2099.1">
     or generator expression, the harder it becomes to read, understand, and
    </span>
    <a id="_idIndexMarker557">
    </a>
    <span class="koboSpan" id="kobo.2100.1">
     therefore maintain or change.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.2101.1">
     If you consider the Zen of Python again, there are a few lines that, we think, are worth keeping in mind when dealing with optimized code:
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.2102.1">&gt;&gt;&gt; import this
...
</span><span class="koboSpan" id="kobo.2102.2">Explicit is better than implicit.
</span><span class="koboSpan" id="kobo.2102.3">Simple is better than complex.
</span><span class="koboSpan" id="kobo.2102.4">...
</span><span class="koboSpan" id="kobo.2102.5">Readability counts.
</span><span class="koboSpan" id="kobo.2102.6">...
</span><span class="koboSpan" id="kobo.2102.7">If the implementation is hard to explain, it's a bad idea.
</span><span class="koboSpan" id="kobo.2102.8">...
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.2103.1">
     Comprehensions and generator expressions are more implicit than explicit, can be quite difficult to read and understand, and can be difficult to explain.
    </span>
    <span class="koboSpan" id="kobo.2103.2">
     Sometimes, you have to break them apart using the inside-out technique to understand what is going on.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.2104.1">
     To give you an example, let us talk a bit more about Pythagorean triples.
    </span>
    <span class="koboSpan" id="kobo.2104.2">
     Just to remind you, a Pythagorean
    </span>
    <a id="_idIndexMarker558">
    </a>
    <span class="koboSpan" id="kobo.2105.1">
     triple is a tuple of positive integers
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.2106.1">
      (a, b, c)
     </span>
    </em>
    <span class="koboSpan" id="kobo.2107.1">
     such that
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.2108.1">
      a
     </span>
    </em>
    <sup class="superscript-italic" style="font-style: italic;">
     <span class="koboSpan" id="kobo.2109.1">
      2
     </span>
    </sup>
    <em class="italic">
     <span class="koboSpan" id="kobo.2110.1">
      + b
     </span>
    </em>
    <sup class="superscript-italic" style="font-style: italic;">
     <span class="koboSpan" id="kobo.2111.1">
      2
     </span>
    </sup>
    <em class="italic">
     <span class="koboSpan" id="kobo.2112.1">
      = c
     </span>
    </em>
    <sup class="superscript-italic" style="font-style: italic;">
     <span class="koboSpan" id="kobo.2113.1">
      2
     </span>
    </sup>
    <span class="koboSpan" id="kobo.2114.1">
     .
    </span>
    <span class="koboSpan" id="kobo.2114.2">
     We saw how to calculate them in the
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.2115.1">
      Filtering a comprehension
     </span>
    </em>
    <span class="koboSpan" id="kobo.2116.1">
     section, but we did it in a very inefficient way.
    </span>
    <span class="koboSpan" id="kobo.2116.2">
     We scanned all pairs of numbers below a certain threshold, calculating the hypotenuse, and filtering out those that were not valid Pythagorean triples.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.2117.1">
     A better way to get a list of
    </span>
    <a id="_idIndexMarker559">
    </a>
    <span class="koboSpan" id="kobo.2118.1">
     Pythagorean triples is to generate them directly.
    </span>
    <span class="koboSpan" id="kobo.2118.2">
     There are many different formulas you can use to do
    </span>
    <a id="_idIndexMarker560">
    </a>
    <span class="koboSpan" id="kobo.2119.1">
     this; here we will use the
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.2120.1">
      Euclidean formula
     </span>
    </strong>
    <span class="koboSpan" id="kobo.2121.1">
     .
    </span>
    <span class="koboSpan" id="kobo.2121.2">
     This formula says that any triple
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.2122.1">
      (a, b, c)
     </span>
    </em>
    <span class="koboSpan" id="kobo.2123.1">
     , where
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.2124.1">
      a = m
     </span>
    </em>
    <sup class="superscript-italic" style="font-style: italic;">
     <span class="koboSpan" id="kobo.2125.1">
      2
     </span>
    </sup>
    <em class="italic">
     <span class="koboSpan" id="kobo.2126.1">
      - n
     </span>
    </em>
    <sup class="superscript-italic" style="font-style: italic;">
     <span class="koboSpan" id="kobo.2127.1">
      2
     </span>
    </sup>
    <em class="italic">
     <span class="koboSpan" id="kobo.2128.1">
      , b = 2mn
     </span>
    </em>
    <span class="koboSpan" id="kobo.2129.1">
     and
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.2130.1">
      c = m
     </span>
    </em>
    <sup class="superscript-italic" style="font-style: italic;">
     <span class="koboSpan" id="kobo.2131.1">
      2
     </span>
    </sup>
    <em class="italic">
     <span class="koboSpan" id="kobo.2132.1">
      + n
     </span>
    </em>
    <sup class="superscript-italic" style="font-style: italic;">
     <span class="koboSpan" id="kobo.2133.1">
      2
     </span>
    </sup>
    <span class="koboSpan" id="kobo.2134.1">
     , with
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.2135.1">
      m
     </span>
    </em>
    <span class="koboSpan" id="kobo.2136.1">
     and
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.2137.1">
      n
     </span>
    </em>
    <span class="koboSpan" id="kobo.2138.1">
     positive integers such that
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.2139.1">
      m &gt; n
     </span>
    </em>
    <span class="koboSpan" id="kobo.2140.1">
     , is a Pythagorean
    </span>
    <a id="_idIndexMarker561">
    </a>
    <span class="koboSpan" id="kobo.2141.1">
     triple.
    </span>
    <span class="koboSpan" id="kobo.2141.2">
     For example, when
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.2142.1">
      m = 2
     </span>
    </em>
    <span class="koboSpan" id="kobo.2143.1">
     and
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.2144.1">
      n = 1
     </span>
    </em>
    <span class="koboSpan" id="kobo.2145.1">
     , we find the smallest triple:
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.2146.1">
      (3, 4, 5)
     </span>
    </em>
    <span class="koboSpan" id="kobo.2147.1">
     .
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.2148.1">
     There is one catch though: consider the triple
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.2149.1">
      (6, 8, 10)
     </span>
    </em>
    <span class="koboSpan" id="kobo.2150.1">
     , which is like
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.2151.1">
      (3, 4, 5)
     </span>
    </em>
    <span class="koboSpan" id="kobo.2152.1">
     , only all the numbers are multiplied by
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.2153.1">
      2
     </span>
    </em>
    <span class="koboSpan" id="kobo.2154.1">
     .
    </span>
    <span class="koboSpan" id="kobo.2154.2">
     This triple is Pythagorean, since
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.2155.1">
      6
     </span>
    </em>
    <sup class="superscript-italic" style="font-style: italic;">
     <span class="koboSpan" id="kobo.2156.1">
      2
     </span>
    </sup>
    <em class="italic">
     <span class="koboSpan" id="kobo.2157.1">
      + 8
     </span>
    </em>
    <sup class="superscript-italic" style="font-style: italic;">
     <span class="koboSpan" id="kobo.2158.1">
      2
     </span>
    </sup>
    <em class="italic">
     <span class="koboSpan" id="kobo.2159.1">
      = 10
     </span>
    </em>
    <sup class="superscript-italic" style="font-style: italic;">
     <span class="koboSpan" id="kobo.2160.1">
      2
     </span>
    </sup>
    <span class="koboSpan" id="kobo.2161.1">
     , but we can derive it from
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.2162.1">
      (3, 4, 5)
     </span>
    </em>
    <span class="koboSpan" id="kobo.2163.1">
     simply by multiplying each of its elements by
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.2164.1">
      2
     </span>
    </em>
    <span class="koboSpan" id="kobo.2165.1">
     .
    </span>
    <span class="koboSpan" id="kobo.2165.2">
     The same goes for
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.2166.1">
      (9, 12, 15)
     </span>
    </em>
    <span class="koboSpan" id="kobo.2167.1">
     ,
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.2168.1">
      (12, 16, 20)
     </span>
    </em>
    <span class="koboSpan" id="kobo.2169.1">
     , and in
    </span>
    <a id="_idIndexMarker562">
    </a>
    <span class="koboSpan" id="kobo.2170.1">
     general for all the triples that we can write as
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.2171.1">
      (3k, 4k, 5k)
     </span>
    </em>
    <span class="koboSpan" id="kobo.2172.1">
     , with
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.2173.1">
      k
     </span>
    </em>
    <span class="koboSpan" id="kobo.2174.1">
     being a positive integer greater than
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.2175.1">
      1
     </span>
    </em>
    <span class="koboSpan" id="kobo.2176.1">
     .
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.2177.1">
     A triple that cannot be obtained by multiplying the elements of another one by some factor,
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.2178.1">
      k
     </span>
    </em>
    <span class="koboSpan" id="kobo.2179.1">
     , is called
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.2180.1">
      primitive
     </span>
    </strong>
    <span class="koboSpan" id="kobo.2181.1">
     .
    </span>
    <span class="koboSpan" id="kobo.2181.2">
     Another
    </span>
    <a id="_idIndexMarker563">
    </a>
    <span class="koboSpan" id="kobo.2182.1">
     way of stating this is as follows: if the three elements of a triple are
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.2183.1">
      coprime
     </span>
    </strong>
    <span class="koboSpan" id="kobo.2184.1">
     , then the triple is primitive.
    </span>
    <span class="koboSpan" id="kobo.2184.2">
     Two numbers are coprime when they do
    </span>
    <a id="_idIndexMarker564">
    </a>
    <span class="koboSpan" id="kobo.2185.1">
     not share any prime factor among their divisors, that is, when their
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.2186.1">
      greatest common divisor
     </span>
    </strong>
    <span class="koboSpan" id="kobo.2187.1">
     (
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.2188.1">
      GCD
     </span>
    </strong>
    <span class="koboSpan" id="kobo.2189.1">
     ) is
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.2190.1">
      1
     </span>
    </em>
    <span class="koboSpan" id="kobo.2191.1">
     .
    </span>
    <span class="koboSpan" id="kobo.2191.2">
     For example, 3 and 5 are coprime, while 3 and
    </span>
    <a id="_idIndexMarker565">
    </a>
    <span class="koboSpan" id="kobo.2192.1">
     6 are not because they are both divisible by 3.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.2193.1">
     The Euclidean formula tells us that if
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.2194.1">
      m
     </span>
    </em>
    <span class="koboSpan" id="kobo.2195.1">
     and
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.2196.1">
      n
     </span>
    </em>
    <span class="koboSpan" id="kobo.2197.1">
     are coprime, and
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.2198.1">
      m - n
     </span>
    </em>
    <span class="koboSpan" id="kobo.2199.1">
     is odd, the triple they generate is
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.2200.1">
      primitive
     </span>
    </em>
    <span class="koboSpan" id="kobo.2201.1">
     .
    </span>
    <span class="koboSpan" id="kobo.2201.2">
     In the following example, we will write a generator expression to calculate all the primitive Pythagorean triples whose hypotenuse,
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.2202.1">
      c
     </span>
    </em>
    <span class="koboSpan" id="kobo.2203.1">
     , is less than or equal to some integer,
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.2204.1">
      N
     </span>
    </em>
    <span class="koboSpan" id="kobo.2205.1">
     .
    </span>
    <span class="koboSpan" id="kobo.2205.2">
     This means we want all triples for which
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.2206.1">
      m
     </span>
    </em>
    <sup class="superscript-italic" style="font-style: italic;">
     <span class="koboSpan" id="kobo.2207.1">
      2
     </span>
    </sup>
    <em class="italic">
     <span class="koboSpan" id="kobo.2208.1">
      + n
     </span>
    </em>
    <sup class="superscript-italic" style="font-style: italic;">
     <span class="koboSpan" id="kobo.2209.1">
      2
     </span>
    </sup>
    <em class="italic">
     <span class="koboSpan" id="kobo.2210.1">
      ≤ N
     </span>
    </em>
    <span class="koboSpan" id="kobo.2211.1">
     .
    </span>
    <span class="koboSpan" id="kobo.2211.2">
     When
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.2212.1">
      n
     </span>
    </em>
    <span class="koboSpan" id="kobo.2213.1">
     is
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.2214.1">
      1
     </span>
    </em>
    <span class="koboSpan" id="kobo.2215.1">
     , the formula looks like this:
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.2216.1">
      m
     </span>
    </em>
    <sup class="superscript-italic" style="font-style: italic;">
     <span class="koboSpan" id="kobo.2217.1">
      2
     </span>
    </sup>
    <em class="italic">
     <span class="koboSpan" id="kobo.2218.1">
      ≤ N - 1
     </span>
    </em>
    <span class="koboSpan" id="kobo.2219.1">
     , which means we can approximate the calculation with an upper bound of
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.2220.1">
      m ≤ N
     </span>
    </em>
    <sup class="superscript-italic" style="font-style: italic;">
     <span class="koboSpan" id="kobo.2221.1">
      1/2
     </span>
    </sup>
    <span class="koboSpan" id="kobo.2222.1">
     .
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.2223.1">
     To recap:
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.2224.1">
      m
     </span>
    </em>
    <span class="koboSpan" id="kobo.2225.1">
     must be greater than
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.2226.1">
      n
     </span>
    </em>
    <span class="koboSpan" id="kobo.2227.1">
     , they must also be coprime, and their difference
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.2228.1">
      m - n
     </span>
    </em>
    <span class="koboSpan" id="kobo.2229.1">
     must be odd.
    </span>
    <span class="koboSpan" id="kobo.2229.2">
     Moreover, to avoid useless calculations, we will put the upper bound for
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.2230.1">
      m
     </span>
    </em>
    <span class="koboSpan" id="kobo.2231.1">
     at
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.2232.1">
      floor(sqrt(N)) + 1
     </span>
    </em>
    <span class="koboSpan" id="kobo.2233.1">
     .
    </span>
   </p>
   <div class="note">
    <p class="normal">
     <span class="koboSpan" id="kobo.2234.1">
      The
     </span>
     <code class="inlineCode">
      <span class="koboSpan" id="kobo.2235.1">
       floor
      </span>
     </code>
     <span class="koboSpan" id="kobo.2236.1">
      function for a real number,
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.2237.1">
       x
      </span>
     </em>
     <span class="koboSpan" id="kobo.2238.1">
      , gives the maximum integer,
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.2239.1">
       n
      </span>
     </em>
     <span class="koboSpan" id="kobo.2240.1">
      , such that
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.2241.1">
       n &lt; x
      </span>
     </em>
     <span class="koboSpan" id="kobo.2242.1">
      , for example,
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.2243.1">
       floor(3.8) = 3
      </span>
     </em>
     <span class="koboSpan" id="kobo.2244.1">
      ,
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.2245.1">
       floor(13.1) = 13
      </span>
     </em>
     <span class="koboSpan" id="kobo.2246.1">
      .
     </span>
     <span class="koboSpan" id="kobo.2246.2">
      Taking
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.2247.1">
       floor(sqrt(N)) + 1
      </span>
     </em>
     <span class="koboSpan" id="kobo.2248.1">
      means taking the integer part of the square root of
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.2249.1">
       N
      </span>
     </em>
     <span class="koboSpan" id="kobo.2250.1">
      and adding a minimal margin just to make sure we do not miss any numbers.
     </span>
    </p>
   </div>
   <p class="normal">
    <span class="koboSpan" id="kobo.2251.1">
     Let us put all of this
    </span>
    <a id="_idIndexMarker566">
    </a>
    <span class="koboSpan" id="kobo.2252.1">
     into code, step by step.
    </span>
    <span class="koboSpan" id="kobo.2252.2">
     We start by writing a simple
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2253.1">
      gcd()
     </span>
    </code>
    <span class="koboSpan" id="kobo.2254.1">
     function that uses
    </span>
    <strong class="keyWord">
     <span class="koboSpan" id="kobo.2255.1">
      Euclid’s algorithm
     </span>
    </strong>
    <span class="koboSpan" id="kobo.2256.1">
     :
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.2257.1"># functions.py</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.2258.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.2259.1">gcd</span></span><span class="koboSpan" id="kobo.2260.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.2261.1">a, b</span></span><span class="koboSpan" id="kobo.2262.1">):
    """Calculate the Greatest Common Divisor of (a, b)."""
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2263.1">while</span></span><span class="koboSpan" id="kobo.2264.1"> b != </span><span class="hljs-number"><span class="koboSpan" id="kobo.2265.1">0</span></span><span class="koboSpan" id="kobo.2266.1">:
        a, b = b, a % b
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2267.1">return</span></span><span class="koboSpan" id="kobo.2268.1"> a
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.2269.1">
     The explanation of Euclid’s
    </span>
    <a id="_idIndexMarker567">
    </a>
    <span class="koboSpan" id="kobo.2270.1">
     algorithm is available on the web, so we will not spend any time talking about it here as we need to focus on the generator expression.
    </span>
    <span class="koboSpan" id="kobo.2270.2">
     The next step is to use the knowledge we gathered before to generate a list of primitive Pythagorean triples:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.2271.1"># pythagorean.triple.generation.py</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.2272.1">from</span></span><span class="koboSpan" id="kobo.2273.1"> functions </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2274.1">import</span></span><span class="koboSpan" id="kobo.2275.1"> gcd
N = </span><span class="hljs-number"><span class="koboSpan" id="kobo.2276.1">50</span></span><span class="koboSpan" id="kobo.2277.1">
triples = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2278.1">sorted</span></span><span class="koboSpan" id="kobo.2279.1">(  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2280.1"># 1</span></span><span class="koboSpan" id="kobo.2281.1">
    (
        (a, b, c) </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2282.1">for</span></span><span class="koboSpan" id="kobo.2283.1"> a, b, c </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2284.1">in</span></span><span class="koboSpan" id="kobo.2285.1"> (  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2286.1"># 2</span></span><span class="koboSpan" id="kobo.2287.1">
            ((m**</span><span class="hljs-number"><span class="koboSpan" id="kobo.2288.1">2</span></span><span class="koboSpan" id="kobo.2289.1"> - n**</span><span class="hljs-number"><span class="koboSpan" id="kobo.2290.1">2</span></span><span class="koboSpan" id="kobo.2291.1">), (</span><span class="hljs-number"><span class="koboSpan" id="kobo.2292.1">2</span></span><span class="koboSpan" id="kobo.2293.1"> * m * n), (m**</span><span class="hljs-number"><span class="koboSpan" id="kobo.2294.1">2</span></span><span class="koboSpan" id="kobo.2295.1"> + n**</span><span class="hljs-number"><span class="koboSpan" id="kobo.2296.1">2</span></span><span class="koboSpan" id="kobo.2297.1">))  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2298.1"># 3</span></span>
            <span class="hljs-keyword"><span class="koboSpan" id="kobo.2299.1">for</span></span><span class="koboSpan" id="kobo.2300.1"> m </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2301.1">in</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.2302.1">range</span></span><span class="koboSpan" id="kobo.2303.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2304.1">1</span></span><span class="koboSpan" id="kobo.2305.1">, </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2306.1">int</span></span><span class="koboSpan" id="kobo.2307.1">(N**</span><span class="hljs-number"><span class="koboSpan" id="kobo.2308.1">.5</span></span><span class="koboSpan" id="kobo.2309.1">) + </span><span class="hljs-number"><span class="koboSpan" id="kobo.2310.1">1</span></span><span class="koboSpan" id="kobo.2311.1">)  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2312.1"># 4</span></span>
            <span class="hljs-keyword"><span class="koboSpan" id="kobo.2313.1">for</span></span><span class="koboSpan" id="kobo.2314.1"> n </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2315.1">in</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.2316.1">range</span></span><span class="koboSpan" id="kobo.2317.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2318.1">1</span></span><span class="koboSpan" id="kobo.2319.1">, m)  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2320.1"># 5</span></span>
            <span class="hljs-keyword"><span class="koboSpan" id="kobo.2321.1">if</span></span><span class="koboSpan" id="kobo.2322.1"> (m - n) % </span><span class="hljs-number"><span class="koboSpan" id="kobo.2323.1">2</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.2324.1">and</span></span><span class="koboSpan" id="kobo.2325.1"> gcd(m, n) == </span><span class="hljs-number"><span class="koboSpan" id="kobo.2326.1">1</span></span>  <span class="hljs-comment"><span class="koboSpan" id="kobo.2327.1"># 6</span></span><span class="koboSpan" id="kobo.2328.1">
        )
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2329.1">if</span></span><span class="koboSpan" id="kobo.2330.1"> c &lt;= N  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2331.1"># 7</span></span><span class="koboSpan" id="kobo.2332.1">
    ),
    key=</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2333.1">sum</span></span>  <span class="hljs-comment"><span class="koboSpan" id="kobo.2334.1"># 8</span></span><span class="koboSpan" id="kobo.2335.1">
)
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.2336.1">
     This is not easy to read, so let us
    </span>
    <a id="_idIndexMarker568">
    </a>
    <span class="koboSpan" id="kobo.2337.1">
     go through it line by line.
    </span>
    <span class="koboSpan" id="kobo.2337.2">
     At
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2338.1">
      #3
     </span>
    </code>
    <span class="koboSpan" id="kobo.2339.1">
     , we start a generator expression that creates triples.
    </span>
    <span class="koboSpan" id="kobo.2339.2">
     You can see from
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2340.1">
      #4
     </span>
    </code>
    <span class="koboSpan" id="kobo.2341.1">
     and
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2342.1">
      #5
     </span>
    </code>
    <span class="koboSpan" id="kobo.2343.1">
     that we are looping on
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2344.1">
      m
     </span>
    </code>
    <span class="koboSpan" id="kobo.2345.1">
     in
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.2346.1">
      [1, M]
     </span>
    </em>
    <span class="koboSpan" id="kobo.2347.1">
     , with
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.2348.1">
      M
     </span>
    </em>
    <span class="koboSpan" id="kobo.2349.1">
     being the integer part of
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.2350.1">
      sqrt(N)
     </span>
    </em>
    <span class="koboSpan" id="kobo.2351.1">
     , plus
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.2352.1">
      1
     </span>
    </em>
    <span class="koboSpan" id="kobo.2353.1">
     .
    </span>
    <span class="koboSpan" id="kobo.2353.2">
     On the other hand,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2354.1">
      n
     </span>
    </code>
    <span class="koboSpan" id="kobo.2355.1">
     loops within
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.2356.1">
      [1, m)
     </span>
    </em>
    <span class="koboSpan" id="kobo.2357.1">
     , to respect the
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.2358.1">
      m &gt; n
     </span>
    </em>
    <span class="koboSpan" id="kobo.2359.1">
     rule.
    </span>
    <span class="koboSpan" id="kobo.2359.2">
     It is worth noting how we calculated
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.2360.1">
      sqrt(N)
     </span>
    </em>
    <span class="koboSpan" id="kobo.2361.1">
     , that is,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2362.1">
      N**.5
     </span>
    </code>
    <span class="koboSpan" id="kobo.2363.1">
     , which is just another way to do it that we wanted to show you.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.2364.1">
     At
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2365.1">
      #6
     </span>
    </code>
    <span class="koboSpan" id="kobo.2366.1">
     , you can see the filtering conditions to make the triples primitive:
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2367.1">
      (m - n) % 2
     </span>
    </code>
    <span class="koboSpan" id="kobo.2368.1">
     evaluates to
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2369.1">
      True
     </span>
    </code>
    <span class="koboSpan" id="kobo.2370.1">
     when
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2371.1">
      (m - n)
     </span>
    </code>
    <span class="koboSpan" id="kobo.2372.1">
     is odd, and
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2373.1">
      gcd(m, n) == 1
     </span>
    </code>
    <span class="koboSpan" id="kobo.2374.1">
     means
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2375.1">
      m
     </span>
    </code>
    <span class="koboSpan" id="kobo.2376.1">
     and
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2377.1">
      n
     </span>
    </code>
    <span class="koboSpan" id="kobo.2378.1">
     are coprime.
    </span>
    <span class="koboSpan" id="kobo.2378.2">
     With these in place, we know the triples will be primitive.
    </span>
    <span class="koboSpan" id="kobo.2378.3">
     This takes care of the innermost generator expression.
    </span>
    <span class="koboSpan" id="kobo.2378.4">
     The outermost one starts at
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2379.1">
      #2
     </span>
    </code>
    <span class="koboSpan" id="kobo.2380.1">
     and finishes at
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2381.1">
      #7
     </span>
    </code>
    <span class="koboSpan" id="kobo.2382.1">
     .
    </span>
    <span class="koboSpan" id="kobo.2382.2">
     We take the triples
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2383.1">
      (a, b, c) in (...innermost generator...)
     </span>
    </code>
    <span class="koboSpan" id="kobo.2384.1">
     such that
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2385.1">
      c &lt;= N
     </span>
    </code>
    <span class="koboSpan" id="kobo.2386.1">
     .
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.2387.1">
     Finally, at
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2388.1">
      #1
     </span>
    </code>
    <span class="koboSpan" id="kobo.2389.1">
     , we apply sorting to
    </span>
    <a id="_idIndexMarker569">
    </a>
    <span class="koboSpan" id="kobo.2390.1">
     present the list in order.
    </span>
    <span class="koboSpan" id="kobo.2390.2">
     At
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2391.1">
      #8
     </span>
    </code>
    <span class="koboSpan" id="kobo.2392.1">
     , after the outermost generator expression is closed, you can see that we specify the sorting key to be the sum
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2393.1">
      a + b + c
     </span>
    </code>
    <span class="koboSpan" id="kobo.2394.1">
     .
    </span>
    <span class="koboSpan" id="kobo.2394.2">
     This is just our personal preference; there is no
    </span>
    <a id="_idIndexMarker570">
    </a>
    <span class="koboSpan" id="kobo.2395.1">
     mathematical reason behind it.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.2396.1">
     This code is certainly not easy to understand or explain.
    </span>
    <span class="koboSpan" id="kobo.2396.2">
     Code like this is also difficult to debug or modify.
    </span>
    <span class="koboSpan" id="kobo.2396.3">
     It should have no place in a professional environment.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.2397.1">
     Let us see whether we can rewrite this code into something more readable:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.2398.1"># pythagorean.triple.generation.for.py</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.2399.1">from</span></span><span class="koboSpan" id="kobo.2400.1"> functions </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2401.1">import</span></span><span class="koboSpan" id="kobo.2402.1"> gcd
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2403.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.2404.1">gen_triples</span></span><span class="koboSpan" id="kobo.2405.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.2406.1">N</span></span><span class="koboSpan" id="kobo.2407.1">):
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2408.1">for</span></span><span class="koboSpan" id="kobo.2409.1"> m </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2410.1">in</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.2411.1">range</span></span><span class="koboSpan" id="kobo.2412.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2413.1">1</span></span><span class="koboSpan" id="kobo.2414.1">, </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2415.1">int</span></span><span class="koboSpan" id="kobo.2416.1">(N**</span><span class="hljs-number"><span class="koboSpan" id="kobo.2417.1">.5</span></span><span class="koboSpan" id="kobo.2418.1">) + </span><span class="hljs-number"><span class="koboSpan" id="kobo.2419.1">1</span></span><span class="koboSpan" id="kobo.2420.1">):  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2421.1"># 1</span></span>
        <span class="hljs-keyword"><span class="koboSpan" id="kobo.2422.1">for</span></span><span class="koboSpan" id="kobo.2423.1"> n </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2424.1">in</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.2425.1">range</span></span><span class="koboSpan" id="kobo.2426.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2427.1">1</span></span><span class="koboSpan" id="kobo.2428.1">, m):  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2429.1"># 2</span></span>
            <span class="hljs-keyword"><span class="koboSpan" id="kobo.2430.1">if</span></span><span class="koboSpan" id="kobo.2431.1"> (m - n) % </span><span class="hljs-number"><span class="koboSpan" id="kobo.2432.1">2</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.2433.1">and</span></span><span class="koboSpan" id="kobo.2434.1"> gcd(m, n) == </span><span class="hljs-number"><span class="koboSpan" id="kobo.2435.1">1</span></span><span class="koboSpan" id="kobo.2436.1">:  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2437.1"># 3</span></span><span class="koboSpan" id="kobo.2438.1">
                c = m**</span><span class="hljs-number"><span class="koboSpan" id="kobo.2439.1">2</span></span><span class="koboSpan" id="kobo.2440.1"> + n**</span><span class="hljs-number"><span class="koboSpan" id="kobo.2441.1">2</span></span>  <span class="hljs-comment"><span class="koboSpan" id="kobo.2442.1"># 4</span></span>
                <span class="hljs-keyword"><span class="koboSpan" id="kobo.2443.1">if</span></span><span class="koboSpan" id="kobo.2444.1"> c &lt;= N:  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2445.1"># 5</span></span><span class="koboSpan" id="kobo.2446.1">
                    a = m**</span><span class="hljs-number"><span class="koboSpan" id="kobo.2447.1">2</span></span><span class="koboSpan" id="kobo.2448.1"> - n**</span><span class="hljs-number"><span class="koboSpan" id="kobo.2449.1">2</span></span>  <span class="hljs-comment"><span class="koboSpan" id="kobo.2450.1"># 6</span></span><span class="koboSpan" id="kobo.2451.1">
                    b = </span><span class="hljs-number"><span class="koboSpan" id="kobo.2452.1">2</span></span><span class="koboSpan" id="kobo.2453.1"> * m * n  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2454.1"># 7</span></span>
                    <span class="hljs-keyword"><span class="koboSpan" id="kobo.2455.1">yield</span></span><span class="koboSpan" id="kobo.2456.1"> (a, b, c)  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2457.1"># 8</span></span><span class="koboSpan" id="kobo.2458.1">
triples = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2459.1">sorted</span></span><span class="koboSpan" id="kobo.2460.1">(gen_triples(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2461.1">50</span></span><span class="koboSpan" id="kobo.2462.1">), key=</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2463.1">sum</span></span><span class="koboSpan" id="kobo.2464.1">)  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2465.1"># 9</span></span>
</code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.2466.1">
     This is much easier to read.
    </span>
    <span class="koboSpan" id="kobo.2466.2">
     Let us go through it, line by line.
    </span>
    <span class="koboSpan" id="kobo.2466.3">
     You will see it is also much easier to understand.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.2467.1">
     We start looping at
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2468.1">
      #1
     </span>
    </code>
    <span class="koboSpan" id="kobo.2469.1">
     and
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2470.1">
      #2
     </span>
    </code>
    <span class="koboSpan" id="kobo.2471.1">
     , over the same ranges as in the previous example.
    </span>
    <span class="koboSpan" id="kobo.2471.2">
     On line
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2472.1">
      #3
     </span>
    </code>
    <span class="koboSpan" id="kobo.2473.1">
     , we filter for primitive triples.
    </span>
    <span class="koboSpan" id="kobo.2473.2">
     On line
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2474.1">
      #4
     </span>
    </code>
    <span class="koboSpan" id="kobo.2475.1">
     , we deviate a bit from what we were doing before: we calculate
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2476.1">
      c
     </span>
    </code>
    <span class="koboSpan" id="kobo.2477.1">
     , and on line
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2478.1">
      #5
     </span>
    </code>
    <span class="koboSpan" id="kobo.2479.1">
     , we filter on
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2480.1">
      c
     </span>
    </code>
    <span class="koboSpan" id="kobo.2481.1">
     being less than or equal to
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2482.1">
      N
     </span>
    </code>
    <span class="koboSpan" id="kobo.2483.1">
     .
    </span>
    <span class="koboSpan" id="kobo.2483.2">
     We only calculate
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2484.1">
      a
     </span>
    </code>
    <span class="koboSpan" id="kobo.2485.1">
     and
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2486.1">
      b
     </span>
    </code>
    <span class="koboSpan" id="kobo.2487.1">
     , and yield the resulting tuple if
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2488.1">
      c
     </span>
    </code>
    <span class="koboSpan" id="kobo.2489.1">
     satisfies that condition.
    </span>
    <span class="koboSpan" id="kobo.2489.2">
     We could have calculated the values of
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2490.1">
      a
     </span>
    </code>
    <span class="koboSpan" id="kobo.2491.1">
     and
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2492.1">
      b
     </span>
    </code>
    <span class="koboSpan" id="kobo.2493.1">
     earlier, but by delaying until we know all conditions for a valid triple are satisfied, we avoid wasting time and CPU cycles.
    </span>
    <span class="koboSpan" id="kobo.2493.2">
     On the last line, we apply sorting with the same key we were using in the generator expression example.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.2494.1">
     We hope you agree that this example is easier to understand.
    </span>
    <span class="koboSpan" id="kobo.2494.2">
     If we ever need to modify the code, this will be
    </span>
    <a id="_idIndexMarker571">
    </a>
    <span class="koboSpan" id="kobo.2495.1">
     much easier, and less error-prone to work
    </span>
    <a id="_idIndexMarker572">
    </a>
    <span class="koboSpan" id="kobo.2496.1">
     with, than the generator expression.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.2497.1">
     If you print the results of both examples, you will get this:
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.2498.1">[(3, 4, 5), (5, 12, 13), (15, 8, 17), (7, 24, 25), (21, 20, 29), (35, 12, 37), (9, 40, 41)]
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.2499.1">
     There is often a trade-off between performance and readability, and it is not always easy to get the balance right.
    </span>
    <span class="koboSpan" id="kobo.2499.2">
     Our advice is to try to use comprehensions and generator expressions whenever you can.
    </span>
    <span class="koboSpan" id="kobo.2499.3">
     But if the code starts to become complicated to modify or difficult to read or explain, you may want to refactor it into something more readable.
    </span>
   </p>
   <h1 class="heading-1" id="_idParaDest-178">
    <span class="koboSpan" id="kobo.2500.1">
     Name localization
    </span>
   </h1>
   <p class="normal">
    <span class="koboSpan" id="kobo.2501.1">
     Now that we are familiar with all types of comprehensions and generator expressions, let us talk about name localization
    </span>
    <a id="_idIndexMarker573">
    </a>
    <span class="koboSpan" id="kobo.2502.1">
     within them.
    </span>
    <span class="koboSpan" id="kobo.2502.2">
     Python 3 localizes loop variables in all four forms of comprehensions: list, dictionary, set, and generator expressions.
    </span>
    <span class="koboSpan" id="kobo.2502.3">
     This behavior is different from that of the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2503.1">
      for
     </span>
    </code>
    <span class="koboSpan" id="kobo.2504.1">
     loop.
    </span>
    <span class="koboSpan" id="kobo.2504.2">
     Let us look at some simple examples to show all the cases:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.2505.1"># scopes.py</span></span><span class="koboSpan" id="kobo.2506.1">
A = </span><span class="hljs-number"><span class="koboSpan" id="kobo.2507.1">100</span></span><span class="koboSpan" id="kobo.2508.1">
ex1 = [A </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2509.1">for</span></span><span class="koboSpan" id="kobo.2510.1"> A </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2511.1">in</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.2512.1">range</span></span><span class="koboSpan" id="kobo.2513.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2514.1">5</span></span><span class="koboSpan" id="kobo.2515.1">)]
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2516.1">print</span></span><span class="koboSpan" id="kobo.2517.1">(A)  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2518.1"># prints: 100</span></span><span class="koboSpan" id="kobo.2519.1">
ex2 = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2520.1">list</span></span><span class="koboSpan" id="kobo.2521.1">(A </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2522.1">for</span></span><span class="koboSpan" id="kobo.2523.1"> A </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2524.1">in</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.2525.1">range</span></span><span class="koboSpan" id="kobo.2526.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2527.1">5</span></span><span class="koboSpan" id="kobo.2528.1">))
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2529.1">print</span></span><span class="koboSpan" id="kobo.2530.1">(A)  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2531.1"># prints: 100</span></span><span class="koboSpan" id="kobo.2532.1">
ex3 = {A: </span><span class="hljs-number"><span class="koboSpan" id="kobo.2533.1">2</span></span><span class="koboSpan" id="kobo.2534.1"> * A </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2535.1">for</span></span><span class="koboSpan" id="kobo.2536.1"> A </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2537.1">in</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.2538.1">range</span></span><span class="koboSpan" id="kobo.2539.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2540.1">5</span></span><span class="koboSpan" id="kobo.2541.1">)}
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2542.1">print</span></span><span class="koboSpan" id="kobo.2543.1">(A)  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2544.1"># prints: 100</span></span><span class="koboSpan" id="kobo.2545.1">
ex4 = {A </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2546.1">for</span></span><span class="koboSpan" id="kobo.2547.1"> A </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2548.1">in</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.2549.1">range</span></span><span class="koboSpan" id="kobo.2550.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2551.1">5</span></span><span class="koboSpan" id="kobo.2552.1">)}
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2553.1">print</span></span><span class="koboSpan" id="kobo.2554.1">(A)  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2555.1"># prints: 100</span></span><span class="koboSpan" id="kobo.2556.1">
s = </span><span class="hljs-number"><span class="koboSpan" id="kobo.2557.1">0</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.2558.1">for</span></span><span class="koboSpan" id="kobo.2559.1"> A </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2560.1">in</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.2561.1">range</span></span><span class="koboSpan" id="kobo.2562.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2563.1">5</span></span><span class="koboSpan" id="kobo.2564.1">):
    s += A
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2565.1">print</span></span><span class="koboSpan" id="kobo.2566.1">(A)  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2567.1"># prints: 4</span></span>
</code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.2568.1">
     In the preceding code, we declare a global name,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2569.1">
      A = 100.
     </span>
    </code>
    <span class="koboSpan" id="kobo.2570.1">
     We then have list, dictionary, and set comprehensions, and a generator expression.
    </span>
    <span class="koboSpan" id="kobo.2570.2">
     Even though they all use the name
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2571.1">
      A
     </span>
    </code>
    <span class="koboSpan" id="kobo.2572.1">
     , none of them alter the global name,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2573.1">
      A
     </span>
    </code>
    <span class="koboSpan" id="kobo.2574.1">
     .
    </span>
    <span class="koboSpan" id="kobo.2574.2">
     On the other hand, the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2575.1">
      for
     </span>
    </code>
    <span class="koboSpan" id="kobo.2576.1">
     loop at the end does modify the global
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2577.1">
      A
     </span>
    </code>
    <span class="koboSpan" id="kobo.2578.1">
     .
    </span>
    <span class="koboSpan" id="kobo.2578.2">
     The last
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2579.1">
      print
     </span>
    </code>
    <span class="koboSpan" id="kobo.2580.1">
     statement prints 4.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.2581.1">
     Let us see what happens if the global
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2582.1">
      A
     </span>
    </code>
    <span class="koboSpan" id="kobo.2583.1">
     was not there:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.2584.1"># scopes.noglobal.py</span></span><span class="koboSpan" id="kobo.2585.1">
ex1 = [A </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2586.1">for</span></span><span class="koboSpan" id="kobo.2587.1"> A </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2588.1">in</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.2589.1">range</span></span><span class="koboSpan" id="kobo.2590.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2591.1">5</span></span><span class="koboSpan" id="kobo.2592.1">)]
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2593.1">print</span></span><span class="koboSpan" id="kobo.2594.1">(A)  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2595.1"># breaks: NameError: name 'A' is not defined</span></span>
</code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.2596.1">
     The preceding code would work in the same way with any other type of comprehension or with a generator expression.
    </span>
    <span class="koboSpan" id="kobo.2596.2">
     After we run the first line,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2597.1">
      A
     </span>
    </code>
    <span class="koboSpan" id="kobo.2598.1">
     is not defined in the global namespace.
    </span>
    <span class="koboSpan" id="kobo.2598.2">
     Once again, the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2599.1">
      for
     </span>
    </code>
    <span class="koboSpan" id="kobo.2600.1">
     loop behaves differently:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.2601.1"># scopes.for.py</span></span><span class="koboSpan" id="kobo.2602.1">
s = </span><span class="hljs-number"><span class="koboSpan" id="kobo.2603.1">0</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.2604.1">for</span></span><span class="koboSpan" id="kobo.2605.1"> A </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2606.1">in</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.2607.1">range</span></span><span class="koboSpan" id="kobo.2608.1">(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2609.1">5</span></span><span class="koboSpan" id="kobo.2610.1">):
    s += A
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2611.1">print</span></span><span class="koboSpan" id="kobo.2612.1">(A) </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2613.1"># prints: 4</span></span>
<span class="hljs-built_in"><span class="koboSpan" id="kobo.2614.1">print</span></span><span class="koboSpan" id="kobo.2615.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2616.1">globals</span></span><span class="koboSpan" id="kobo.2617.1">())
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.2618.1">
     The preceding code shows
    </span>
    <a id="_idIndexMarker574">
    </a>
    <span class="koboSpan" id="kobo.2619.1">
     that after a
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2620.1">
      for
     </span>
    </code>
    <span class="koboSpan" id="kobo.2621.1">
     loop, if the loop variable was not defined before it, we can find it in the global namespace.
    </span>
    <span class="koboSpan" id="kobo.2621.2">
     We can verify this by inspecting the dictionary returned by the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2622.1">
      globals()
     </span>
    </code>
    <span class="koboSpan" id="kobo.2623.1">
     built-in function:
    </span>
   </p>
   <pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.2624.1">$ python scopes.for.py
4
{'__name__': '__main__', '__doc__': None, ..., 's': 10, 'A': 4}
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.2625.1">
     Along with various built-in global names (which we have not reproduced here), we see
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2626.1">
      'A': 4
     </span>
    </code>
    <span class="koboSpan" id="kobo.2627.1">
     .
    </span>
   </p>
   <h1 class="heading-1" id="_idParaDest-179">
    <span class="koboSpan" id="kobo.2628.1">
     Generation behavior in built-ins
    </span>
   </h1>
   <p class="normal">
    <span class="koboSpan" id="kobo.2629.1">
     Generator-like behavior is quite common among the built-in types and functions.
    </span>
    <span class="koboSpan" id="kobo.2629.2">
     This is a major difference between Python 2 and Python 3.
    </span>
    <span class="koboSpan" id="kobo.2629.3">
     In Python 2, functions such as
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2630.1">
      map()
     </span>
    </code>
    <span class="koboSpan" id="kobo.2631.1">
     ,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2632.1">
      zip()
     </span>
    </code>
    <span class="koboSpan" id="kobo.2633.1">
     , and
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2634.1">
      filter()
     </span>
    </code>
    <span class="koboSpan" id="kobo.2635.1">
     returned
    </span>
    <a id="_idIndexMarker575">
    </a>
    <span class="koboSpan" id="kobo.2636.1">
     lists instead of iterable objects.
    </span>
    <span class="koboSpan" id="kobo.2636.2">
     The idea behind this change is that if you need to make a list of those results, you can always wrap the call in a
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2637.1">
      list()
     </span>
    </code>
    <span class="koboSpan" id="kobo.2638.1">
     class.
    </span>
    <span class="koboSpan" id="kobo.2638.2">
     On the other hand, if you just need to iterate and want to keep the impact on memory as light as possible, you can use those functions safely.
    </span>
    <span class="koboSpan" id="kobo.2638.3">
     Another notable example is the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2639.1">
      range()
     </span>
    </code>
    <span class="koboSpan" id="kobo.2640.1">
     function.
    </span>
    <span class="koboSpan" id="kobo.2640.2">
     In Python 2, it returned a list, and there was another function called
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2641.1">
      xrange()
     </span>
    </code>
    <span class="koboSpan" id="kobo.2642.1">
     that behaved like the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2643.1">
      range()
     </span>
    </code>
    <span class="koboSpan" id="kobo.2644.1">
     function now behaves in Python 3.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.2645.1">
     The idea of functions and methods that return iterable objects is quite widespread.
    </span>
    <span class="koboSpan" id="kobo.2645.2">
     You can find it in the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2646.1">
      open()
     </span>
    </code>
    <span class="koboSpan" id="kobo.2647.1">
     function, which is used to operate on file objects (we will see it in
    </span>
    <em class="chapterRef">
     <span class="koboSpan" id="kobo.2648.1">
      Chapter 8
     </span>
    </em>
    <span class="koboSpan" id="kobo.2649.1">
     ,
    </span>
    <em class="chapterRef">
     <span class="koboSpan" id="kobo.2650.1">
      Files and Data Persistence
     </span>
    </em>
    <span class="koboSpan" id="kobo.2651.1">
     ), but also in
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2652.1">
      enumerate()
     </span>
    </code>
    <span class="koboSpan" id="kobo.2653.1">
     , in the dictionary
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2654.1">
      keys()
     </span>
    </code>
    <span class="koboSpan" id="kobo.2655.1">
     ,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2656.1">
      values()
     </span>
    </code>
    <span class="koboSpan" id="kobo.2657.1">
     , and
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2658.1">
      items()
     </span>
    </code>
    <span class="koboSpan" id="kobo.2659.1">
     methods, and several other places.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.2660.1">
     It all makes sense: Python aims to reduce the memory footprint by avoiding wasting space wherever possible, especially in those functions and methods that are used extensively in most situations.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.2661.1">
     At the beginning of this chapter, we said that it makes more sense to optimize the performance of code that has to deal with large collections of objects, rather than
    </span>
    <a id="_idIndexMarker576">
    </a>
    <span class="koboSpan" id="kobo.2662.1">
     shaving off a few milliseconds from a function that we call twice a day.
    </span>
    <span class="koboSpan" id="kobo.2662.2">
     That is precisely what Python itself is doing here.
    </span>
   </p>
   <h1 class="heading-1" id="_idParaDest-180">
    <span class="koboSpan" id="kobo.2663.1">
     One last example
    </span>
   </h1>
   <p class="normal">
    <span class="koboSpan" id="kobo.2664.1">
     Before we finish this chapter, we will
    </span>
    <a id="_idIndexMarker577">
    </a>
    <span class="koboSpan" id="kobo.2665.1">
     show you a simple problem that Fabrizio used to give to candidates for a Python
    </span>
    <a id="_idIndexMarker578">
    </a>
    <span class="koboSpan" id="kobo.2666.1">
     developer role in a company he used to work for.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.2667.1">
     The problem is the following: write a function that returns the terms of the sequence
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.2668.1">
      0 1 1 2 3 5 8 13 21 ...
     </span>
    </em>
    <span class="koboSpan" id="kobo.2669.1">
     , up to some limit,
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.2670.1">
      N
     </span>
    </em>
    <span class="koboSpan" id="kobo.2671.1">
     .
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.2672.1">
     If you have not recognized it, that is the Fibonacci sequence, which is defined as
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.2673.1">
      F(0) = 0, F(1) = 1
     </span>
    </em>
    <span class="koboSpan" id="kobo.2674.1">
     and, for any
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.2675.1">
      n &gt; 1
     </span>
    </em>
    <span class="koboSpan" id="kobo.2676.1">
     ,
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.2677.1">
      F(n) = F(n-1) + F(n-2)
     </span>
    </em>
    <span class="koboSpan" id="kobo.2678.1">
     .
    </span>
    <span class="koboSpan" id="kobo.2678.2">
     This sequence is excellent for testing knowledge about recursion, memoization techniques, and other technical details, but in this case, it was a good opportunity to check whether the candidate knew about generators.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.2679.1">
     Let us start with a rudimentary version, and then improve on it:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.2680.1"># fibonacci.first.py</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.2681.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.2682.1">fibonacci</span></span><span class="koboSpan" id="kobo.2683.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.2684.1">N</span></span><span class="koboSpan" id="kobo.2685.1">):
    """Return </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2686.1">all</span></span><span class="koboSpan" id="kobo.2687.1"> fibonacci numbers up to N."""
    </span><span class="koboSpan" id="kobo.2687.2">result = [</span><span class="hljs-number"><span class="koboSpan" id="kobo.2688.1">0</span></span><span class="koboSpan" id="kobo.2689.1">]
    next_n = </span><span class="hljs-number"><span class="koboSpan" id="kobo.2690.1">1</span></span>
    <span class="hljs-keyword"><span class="koboSpan" id="kobo.2691.1">while</span></span><span class="koboSpan" id="kobo.2692.1"> next_n &lt;= N:
        result.append(next_n)
        next_n = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2693.1">sum</span></span><span class="koboSpan" id="kobo.2694.1">(result[-</span><span class="hljs-number"><span class="koboSpan" id="kobo.2695.1">2</span></span><span class="koboSpan" id="kobo.2696.1">:])
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2697.1">return</span></span><span class="koboSpan" id="kobo.2698.1"> result
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2699.1">print</span></span><span class="koboSpan" id="kobo.2700.1">(fibonacci(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2701.1">0</span></span><span class="koboSpan" id="kobo.2702.1">))  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2703.1"># [0]</span></span>
<span class="hljs-built_in"><span class="koboSpan" id="kobo.2704.1">print</span></span><span class="koboSpan" id="kobo.2705.1">(fibonacci(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2706.1">1</span></span><span class="koboSpan" id="kobo.2707.1">))  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2708.1"># [0, 1, 1]</span></span>
<span class="hljs-built_in"><span class="koboSpan" id="kobo.2709.1">print</span></span><span class="koboSpan" id="kobo.2710.1">(fibonacci(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2711.1">50</span></span><span class="koboSpan" id="kobo.2712.1">))  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2713.1"># [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]</span></span>
</code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.2714.1">
     From the top: we set up the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2715.1">
      result
     </span>
    </code>
    <span class="koboSpan" id="kobo.2716.1">
     list to a starting value of
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2717.1">
      [0]
     </span>
    </code>
    <span class="koboSpan" id="kobo.2718.1">
     .
    </span>
    <span class="koboSpan" id="kobo.2718.2">
     Then we start the iteration from the next element (
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2719.1">
      next_n
     </span>
    </code>
    <span class="koboSpan" id="kobo.2720.1">
     ), which is 1.
    </span>
    <span class="koboSpan" id="kobo.2720.2">
     While the next element is not greater than
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2721.1">
      N
     </span>
    </code>
    <span class="koboSpan" id="kobo.2722.1">
     , we keep appending
    </span>
    <a id="_idIndexMarker579">
    </a>
    <span class="koboSpan" id="kobo.2723.1">
     it to the list and calculating the next value in the sequence.
    </span>
    <span class="koboSpan" id="kobo.2723.2">
     We calculate the next element by taking a slice of the last two elements in
    </span>
    <a id="_idIndexMarker580">
    </a>
    <span class="koboSpan" id="kobo.2724.1">
     the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2725.1">
      result
     </span>
    </code>
    <span class="koboSpan" id="kobo.2726.1">
     list and passing it to the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2727.1">
      sum
     </span>
    </code>
    <span class="koboSpan" id="kobo.2728.1">
     function.
    </span>
   </p>
   <div class="packt_tip">
    <p class="normal">
     <span class="koboSpan" id="kobo.2729.1">
      If you struggle to understand the code, it can help to add some
     </span>
     <code class="inlineCode">
      <span class="koboSpan" id="kobo.2730.1">
       print()
      </span>
     </code>
     <span class="koboSpan" id="kobo.2731.1">
      statements so that you can see how values change during execution.
     </span>
    </p>
   </div>
   <p class="normal">
    <span class="koboSpan" id="kobo.2732.1">
     When the loop condition evaluates to
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2733.1">
      False
     </span>
    </code>
    <span class="koboSpan" id="kobo.2734.1">
     , we exit the loop and return
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2735.1">
      result
     </span>
    </code>
    <span class="koboSpan" id="kobo.2736.1">
     .
    </span>
    <span class="koboSpan" id="kobo.2736.2">
     You can see the result of those
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2737.1">
      print
     </span>
    </code>
    <span class="koboSpan" id="kobo.2738.1">
     statements in the comments next to each of them.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.2739.1">
     At this point, Fabrizio would ask the candidate the following question:
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.2740.1">
      What if I just wanted to iterate over those numbers?
     </span>
    </em>
    <span class="koboSpan" id="kobo.2741.1">
     A good candidate would then change the code to the following:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.2742.1"># fibonacci.second.py</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.2743.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.2744.1">fibonacci</span></span><span class="koboSpan" id="kobo.2745.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.2746.1">N</span></span><span class="koboSpan" id="kobo.2747.1">):
    """Return </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2748.1">all</span></span><span class="koboSpan" id="kobo.2749.1"> fibonacci numbers up to N."""
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2750.1">yield</span></span> <span class="hljs-number"><span class="koboSpan" id="kobo.2751.1">0</span></span>
    <span class="hljs-keyword"><span class="koboSpan" id="kobo.2752.1">if</span></span><span class="koboSpan" id="kobo.2753.1"> N == </span><span class="hljs-number"><span class="koboSpan" id="kobo.2754.1">0</span></span><span class="koboSpan" id="kobo.2755.1">:
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2756.1">return</span></span><span class="koboSpan" id="kobo.2757.1">
    a = </span><span class="hljs-number"><span class="koboSpan" id="kobo.2758.1">0</span></span><span class="koboSpan" id="kobo.2759.1">
    b = </span><span class="hljs-number"><span class="koboSpan" id="kobo.2760.1">1</span></span>
    <span class="hljs-keyword"><span class="koboSpan" id="kobo.2761.1">while</span></span><span class="koboSpan" id="kobo.2762.1"> b &lt;= N:
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2763.1">yield</span></span><span class="koboSpan" id="kobo.2764.1"> b
        a, b = b, a + b
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2765.1">print</span></span><span class="koboSpan" id="kobo.2766.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2767.1">list</span></span><span class="koboSpan" id="kobo.2768.1">(fibonacci(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2769.1">0</span></span><span class="koboSpan" id="kobo.2770.1">)))  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2771.1"># [0]</span></span>
<span class="hljs-built_in"><span class="koboSpan" id="kobo.2772.1">print</span></span><span class="koboSpan" id="kobo.2773.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2774.1">list</span></span><span class="koboSpan" id="kobo.2775.1">(fibonacci(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2776.1">1</span></span><span class="koboSpan" id="kobo.2777.1">)))  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2778.1"># [0, 1, 1]</span></span>
<span class="hljs-built_in"><span class="koboSpan" id="kobo.2779.1">print</span></span><span class="koboSpan" id="kobo.2780.1">(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2781.1">list</span></span><span class="koboSpan" id="kobo.2782.1">(fibonacci(</span><span class="hljs-number"><span class="koboSpan" id="kobo.2783.1">50</span></span><span class="koboSpan" id="kobo.2784.1">)))  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.2785.1"># [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]</span></span>
</code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.2786.1">
     This is actually one of the solutions he was given.
    </span>
    <span class="koboSpan" id="kobo.2786.2">
     Now, the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2787.1">
      fibonacci()
     </span>
    </code>
    <span class="koboSpan" id="kobo.2788.1">
     function is a
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.2789.1">
      generator function
     </span>
    </em>
    <span class="koboSpan" id="kobo.2790.1">
     .
    </span>
    <span class="koboSpan" id="kobo.2790.2">
     First, we yield 0, and then, if
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2791.1">
      N
     </span>
    </code>
    <span class="koboSpan" id="kobo.2792.1">
     is 0, we
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2793.1">
      return
     </span>
    </code>
    <span class="koboSpan" id="kobo.2794.1">
     (this will cause a
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2795.1">
      StopIteration
     </span>
    </code>
    <span class="koboSpan" id="kobo.2796.1">
     exception to be raised).
    </span>
    <span class="koboSpan" id="kobo.2796.2">
     If that is not the case, we start looping, yielding
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2797.1">
      b
     </span>
    </code>
    <span class="koboSpan" id="kobo.2798.1">
     at every iteration, before
    </span>
    <a id="_idIndexMarker581">
    </a>
    <span class="koboSpan" id="kobo.2799.1">
     updating
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2800.1">
      a
     </span>
    </code>
    <span class="koboSpan" id="kobo.2801.1">
     and
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2802.1">
      b
     </span>
    </code>
    <span class="koboSpan" id="kobo.2803.1">
     .
    </span>
    <span class="koboSpan" id="kobo.2803.2">
     This solution relies on the fact that we only need the last two elements (
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2804.1">
      a
     </span>
    </code>
    <span class="koboSpan" id="kobo.2805.1">
     and
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2806.1">
      b
     </span>
    </code>
    <span class="koboSpan" id="kobo.2807.1">
     ) to be able to produce the next one.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.2808.1">
     This code is much better, has a
    </span>
    <a id="_idIndexMarker582">
    </a>
    <span class="koboSpan" id="kobo.2809.1">
     lighter memory footprint, and all we have to do to get a list of Fibonacci numbers is wrap the call with
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2810.1">
      list()
     </span>
    </code>
    <span class="koboSpan" id="kobo.2811.1">
     , as usual.
    </span>
    <span class="koboSpan" id="kobo.2811.2">
     We can make it even more elegant, though:
    </span>
   </p>
   <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment"><span class="koboSpan" id="kobo.2812.1"># fibonacci.elegant.py</span></span>
<span class="hljs-keyword"><span class="koboSpan" id="kobo.2813.1">def</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.2814.1">fibonacci</span></span><span class="koboSpan" id="kobo.2815.1">(</span><span class="hljs-params"><span class="koboSpan" id="kobo.2816.1">N</span></span><span class="koboSpan" id="kobo.2817.1">):
    """Return </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.2818.1">all</span></span><span class="koboSpan" id="kobo.2819.1"> fibonacci numbers up to N."""
    </span><span class="koboSpan" id="kobo.2819.2">a, b = </span><span class="hljs-number"><span class="koboSpan" id="kobo.2820.1">0</span></span><span class="koboSpan" id="kobo.2821.1">, </span><span class="hljs-number"><span class="koboSpan" id="kobo.2822.1">1</span></span>
    <span class="hljs-keyword"><span class="koboSpan" id="kobo.2823.1">while</span></span><span class="koboSpan" id="kobo.2824.1"> a &lt;= N:
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.2825.1">yield</span></span><span class="koboSpan" id="kobo.2826.1"> a
        a, b = b, a + b
</span></code></pre>
   <p class="normal">
    <span class="koboSpan" id="kobo.2827.1">
     The whole body of the function is now only four lines, or five if you count the docstring.
    </span>
    <span class="koboSpan" id="kobo.2827.2">
     Notice how, in this case, using tuple assignment (
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2828.1">
      a, b = 0, 1
     </span>
    </code>
    <span class="koboSpan" id="kobo.2829.1">
     and
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2830.1">
      a, b = b, a + b
     </span>
    </code>
    <span class="koboSpan" id="kobo.2831.1">
     ) helps in making the code shorter and more readable.
    </span>
   </p>
   <h1 class="heading-1" id="_idParaDest-181">
    <span class="koboSpan" id="kobo.2832.1">
     Summary
    </span>
   </h1>
   <p class="normal">
    <span class="koboSpan" id="kobo.2833.1">
     In this chapter, we explored the concepts of iteration and generation a bit more deeply.
    </span>
    <span class="koboSpan" id="kobo.2833.2">
     We looked at the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2834.1">
      map()
     </span>
    </code>
    <span class="koboSpan" id="kobo.2835.1">
     ,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2836.1">
      zip()
     </span>
    </code>
    <span class="koboSpan" id="kobo.2837.1">
     , and
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2838.1">
      filter()
     </span>
    </code>
    <span class="koboSpan" id="kobo.2839.1">
     functions in detail, and learned how to use them as an alternative to a regular
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2840.1">
      for
     </span>
    </code>
    <span class="koboSpan" id="kobo.2841.1">
     loop approach.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.2842.1">
     Then, we covered the concept of comprehensions to construct lists, dictionaries, and sets.
    </span>
    <span class="koboSpan" id="kobo.2842.2">
     We explored their syntax and how to use them as an alternative to both the classic
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2843.1">
      for
     </span>
    </code>
    <span class="koboSpan" id="kobo.2844.1">
     loop approach and the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2845.1">
      map()
     </span>
    </code>
    <span class="koboSpan" id="kobo.2846.1">
     ,
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2847.1">
      zip()
     </span>
    </code>
    <span class="koboSpan" id="kobo.2848.1">
     , and
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2849.1">
      filter()
     </span>
    </code>
    <span class="koboSpan" id="kobo.2850.1">
     functions.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.2851.1">
     Finally, we talked about the concept of generators in two forms: generator functions and expressions.
    </span>
    <span class="koboSpan" id="kobo.2851.2">
     We learned how to save time and space by using generation techniques.
    </span>
    <span class="koboSpan" id="kobo.2851.3">
     We also saw how operations that are infeasible to perform with lists can be performed with generators instead.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.2852.1">
     We talked about performance and saw that
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2853.1">
      for
     </span>
    </code>
    <span class="koboSpan" id="kobo.2854.1">
     loops come last in terms of speed, but they provide the best readability and flexibility to change.
    </span>
    <span class="koboSpan" id="kobo.2854.2">
     On the other hand, functions such as
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2855.1">
      map()
     </span>
    </code>
    <span class="koboSpan" id="kobo.2856.1">
     and
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2857.1">
      filter()
     </span>
    </code>
    <span class="koboSpan" id="kobo.2858.1">
     , and comprehensions, can be much faster.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.2859.1">
     The complexity of the code written using these techniques grows exponentially, so to favor readability and ease of maintainability, we still need to use the classic
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2860.1">
      for
     </span>
    </code>
    <span class="koboSpan" id="kobo.2861.1">
     loop approach at times.
    </span>
    <span class="koboSpan" id="kobo.2861.2">
     Another difference is in the name localization, where the
    </span>
    <code class="inlineCode">
     <span class="koboSpan" id="kobo.2862.1">
      for
     </span>
    </code>
    <span class="koboSpan" id="kobo.2863.1">
     loop behaves differently from all other types of comprehensions.
    </span>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.2864.1">
     The next chapter will be all about objects and classes.
    </span>
    <span class="koboSpan" id="kobo.2864.2">
     It is structurally similar to this one, in that we will not explore many different subjects—just a few of them—but we will try to delve deeper into them.
    </span>
   </p>
   <h1 class="heading-1" id="_idParaDest-182">
    <span class="koboSpan" id="kobo.2865.1">
     Join our community on Discord
    </span>
   </h1>
   <p class="normal">
    <span class="koboSpan" id="kobo.2866.1">
     Join our community’s Discord space for discussions with the authors and other readers:
    </span>
   </p>
   <p class="normal">
    <a href="Chapter_5.xhtml">
     <span class="url">
      <span class="koboSpan" id="kobo.2867.1">
       https://discord.com/invite/uaKmaz7FEC
      </span>
     </span>
    </a>
   </p>
   <p class="normal">
    <span class="koboSpan" id="kobo.2868.1">
     <img alt="img" src="../Images/QR_Code119001106417026468.png"/>
    </span>
   </p>
  </div>
 </body></html>