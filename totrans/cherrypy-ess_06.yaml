- en: Chapter 6. Web Services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In[Chapter 5](ch05.html "Chapter 5. A Photoblog Application"), we defined the
    data access layer and the entities our application would manipulate. In this chapter,
    we will explain how we can articulate our photoblog application by using web services
    as an API to access and operate the entities we have defined. We will introduce
    the concept of web services based on the REST principles as well as the Atom Publishing
    Protocol and explain how we can implement them using CherryPy. By the end of this
    chapter, you should understand how web services can enhance and extend the capacities
    of your web application while providing a simple entry point for third-party applications.
  prefs: []
  type: TYPE_NORMAL
- en: Traditional Web Development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Most web applications use the same base URI to handle the serving of resources
    and the manipulation of resources. For instance, it''s common to find something
    such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '| URI | Request Body | HTTP Method | Operation |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `/album/` | N/A | GET | Fetch all albums |'
  prefs: []
  type: TYPE_TB
- en: '| `/album/?id=12` | N/A | GET | Fetch the album with the ID 12 |'
  prefs: []
  type: TYPE_TB
- en: '| `/album/edit?id=12` | N/A | GET | Return a form to perform an action on a
    resource |'
  prefs: []
  type: TYPE_TB
- en: '| `/album/create` | title=Friends | POST | Create an album |'
  prefs: []
  type: TYPE_TB
- en: '| `/album/delete` | id=12 | POST | Delete the album with the ID 12 |'
  prefs: []
  type: TYPE_TB
- en: '| `/album/update` | id=12&title=Family | POST | Update the album with the ID
    12 |'
  prefs: []
  type: TYPE_TB
- en: 'Within an application hosted with CherryPy, this could be translated into:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Although this methodology is valid, it is not the best choice when it needs
    to open itself to different kinds of user agents (browser, robot, service, etc.).
    For instance, imagine we decide to provide a fat client application to manipulate
    albums. In such a case, the HTML page returned by the page handlers would be useless;
    XML or JSON data would be more relevant. We may also want to offer part of our
    application as a service for third-party applications.
  prefs: []
  type: TYPE_NORMAL
- en: One notable example is the service provided by flickr, ([http://www.flickr.com/](http://www.flickr.com/))
    the online photo-management application, which allows someone to query the flickr
    service ([http://www.flickr.com/services/api/](http://www.flickr.com/services/api/))
    for their data in many contexts like getting current photos, activities, blog
    posts, comments, etc. in different formats. Thanks to these web services a large
    set of third-party applications have grown to extend flickr users' experience
    from a web application or even from a fat client application.
  prefs: []
  type: TYPE_NORMAL
- en: Separation of Concerns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The issue with the previous design example is the lack of **separation of concerns**.
    As Tim Bray said about the Web (please refer to [http://www.tbray.org/ongoing/When/200x/2006/03/26/On-REST](http://www.tbray.org/ongoing/When/200x/2006/03/26/On-REST)
    for more details):'
  prefs: []
  type: TYPE_NORMAL
- en: '*You have a lot of things in the system, identified by URIs*.'
  prefs: []
  type: TYPE_NORMAL
- en: '*There are two kinds of operations against a resource in the system: those
    that can change its state, and those that can''t*.'
  prefs: []
  type: TYPE_NORMAL
- en: From the first statement we put a *name* on anything that can pass through the
    system; we call it a resource. Examples of resources could be a picture, a poem,
    results of a basketball game, temperature in Australia, etc. We also learn that
    each resource should be identified in a non-equivocal way. From Tim's second statement
    we realize that we should logically separate in our design—operations that are
    read-only and those that can change the resource.
  prefs: []
  type: TYPE_NORMAL
- en: An important corollary of these distinctions is that we would like to let the
    client inform the server about the content type that it would prefer to receive.
    In our example, our page handlers solely return HTML pages while it would be more
    flexible to check what the client can handle and send it the best representation
    of the resource.
  prefs: []
  type: TYPE_NORMAL
- en: 'Web application developers should consider the following principles:'
  prefs: []
  type: TYPE_NORMAL
- en: Anything is a resource.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A resource has one or several identifiers but one identifier can lead to only
    one resource.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A resource has one or many representations that the client can request.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operations on resources are divided into those that alter the state of the resource
    and those that do not.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Based on these elements we can redefine our design as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: By doing so we allow any kind of user agent to manipulate a resource by requesting
    the `AlbumManager` exposed handlers. A browser would still fetch an HTML representation
    of an album from the `Album` page handlers. You might argue that a browser would
    not know what is to be done with the returned XML or JSON data from the `AlbumManager`
    page handlers. The missing piece of information here is that submission of the
    HTML form and the handling of its response would be performed by some client-side
    scripting code via JavaScript that would be able to process the XML or JSON chunk
    of data accordingly. We will go through this technique in more detail in[Chapter
    7](ch07.html "Chapter 7. The Presentation Layer").
  prefs: []
  type: TYPE_NORMAL
- en: The principles defined above are the basis of what are referred to today as
    **web services**. A web service is an API provided by a web application so that
    heterogeneous user agents can interact with the application through formats other
    than HTML. There are different ways to create web services via REST, SOAP, XML-RPC,
    Atom, etc. For the purpose of this book we will review REST and the Atom Publishing
    Protocol as web services for the photoblog application.
  prefs: []
  type: TYPE_NORMAL
- en: REST
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Representational State Transfer** (**REST**) is an architecture style for
    distributed hypermedia systems described by Roy T. Fielding in his dissertation
    Architectural Styles and the Design of Network-based Software Architectures in
    2000.'
  prefs: []
  type: TYPE_NORMAL
- en: 'REST is based on the following elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Resource:* A resource is the abstract concept of anything. For instance, it
    can be an image, a blog entry, the current rate between two currencies, a sport
    result, a mathematical equation, etc.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Resource identifier:* Allows components of the distributed system to identify
    a resource in a unique way.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Representation:* A representation of the resource is simply data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Representation metadata:* Information about the representation itself.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Resource metadata:* Information about the resource.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Control data:* Information about the messages passing through the system between
    components.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: REST also suggests that each message flowing should be **stateless** meaning
    that it should contain enough information for its processing by the next component
    within the system and thus should not depend on previous or following messages.
    Each message is self-contained. This is achieved through the use of resource metadata
    and representation metadata.
  prefs: []
  type: TYPE_NORMAL
- en: These are the elements describing REST but they are not tied to any underlying
    protocol. The most commonly used case of REST can be found within the Web and
    is implemented using the HTTP protocol. In spite of that REST can be implemented
    using other protocols in other environments.
  prefs: []
  type: TYPE_NORMAL
- en: 'HTTP is a good candidate to implement REST for the following reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: It is the base of the Web, which is a distributed hypermedia system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is stateless.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each request can contain enough information to be processed independently of
    the rest of the system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The content-type and accept headers used by HTTP provide the means to represent
    a single resource through different representations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: URIs are powerful and common resource identifiers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uniform Resource Identifier
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: REST is about naming resources on a network and providing a unified mechanism
    to perform operations on these resources. That's why REST tells us that a resource
    is identified by at least one identifier. When implementing a REST infrastructure
    based on the HTTP protocol, these identifiers are defined as **Uniform Resource
    Identifiers** (**URIs**).
  prefs: []
  type: TYPE_NORMAL
- en: 'Two common subsets of the URI set are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Uniform Resource Locator** (**URL**), such as: [http://www.cherrypy.org/](http://www.cherrypy.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Uniform Resource Name** (**URN**), such as:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The interesting aspect of URLs is that they contain enough information to locate
    the resource on the network. Thus in the given URL we know that to locate the
    resource we need to use the HTTP protocol associated to the HTTP scheme hosted
    on the host [www.cherrypy.org](http://www.cherrypy.org) at the path `/`. (Note,
    however, that not everyone in the Web community thinks that this multiplexing
    of capabilities is a positive aspect of URLs but this discussion is out of the
    scope of this book.)
  prefs: []
  type: TYPE_NORMAL
- en: HTTP Methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If URIs offer the way to name resources, HTTP methods provide the means by which
    we can operate on those resources. Let's review the most common methods (also
    referred to as verbs) in HTTP 1.1.
  prefs: []
  type: TYPE_NORMAL
- en: '| HTTP Method | Idempotent | Operation |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `HEAD` | Yes | Retrieves the resource metadata. The response is the same
    as the one to a GET minus the body. |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | Yes | Retrieves resource metadata and content. |'
  prefs: []
  type: TYPE_TB
- en: '| `POST` | No | Requests the server to create a new resource using the data
    enclosed in the request body. |'
  prefs: []
  type: TYPE_TB
- en: '| `PUT` | Yes | Requests the server to replace an existing resource with the
    one enclosed in the request body. The server cannot apply the enclosed resource
    to a resource not identified by that URI. |'
  prefs: []
  type: TYPE_TB
- en: '| `DELETE` | Yes | Requests the server to remove the resource identified by
    that URI. |'
  prefs: []
  type: TYPE_TB
- en: '| `OPTIONS` | Yes | Requests the server to return details about capabilities
    either globally or specifically towards a resource. |'
  prefs: []
  type: TYPE_TB
- en: The idempotent column of the table indicates whether the request using that
    particular HTTP method will have the same side-effects with two consecutive identical
    calls.
  prefs: []
  type: TYPE_NORMAL
- en: By default CherryPy handlers reflect the path of the Request-URI and the handler
    matches one element of the URI, but as we have seen CherryPy's dispatcher can
    be changed not to look for the handler within the URI but from the request metadata
    such as the HTTP method used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s review an example applied to the photoblog application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Let's explain what each HTTP method does in this context.
  prefs: []
  type: TYPE_NORMAL
- en: '`GET:` This returns the representation of the requested resource depending
    on the `Accept` header. Our application allows `application/xml, application/atom+xml,
    text/json`, or `text/x-json`. We use a function called `accept`, which returns
    the acceptable header found or raises a `cherrypy.HTTPError (406, ''Not Acceptable'')`
    error immediately to inform the user agent that our application cannot deal with
    its request. Then we verify if the resource still exists; if not, we raise a `cherrypy.NotFound`
    error, which is a shortcut to `cherrypy.HTTPError(404, ''Not Found'')`. Once we
    have our pre-conditions checked, we return the requested representation of the
    resource.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that this is equivalent to the `index()` method with the default dispatcher.
    Bear in mind though that there is no equivalent to the `default()` method when
    using the method dispatcher.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`POST:` The HTTP `POST` method allows a user agent to create a new resource.
    The first step is to check if the photoblog that will handle that resource exists.
    Then we create the resource and we return a status code `201 Created` along with
    the `Location` header indicating the URI to retrieve the newly created resource.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PUT:` The HTTP `PUT` method allows the user agent to replace a resource with
    the one provided in the request body. It is often considered as an update operation.
    Although RFC 2616 does not forbid `PUT` to also create a new resource, we will
    not use it that way in our application as we will explain later.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DELETE:` The `DELETE` method requests the server to remove the resource. A
    response to this method can either be `200 OK` or `204 No Content`. The latter
    informs the user agent that it should not change its current state since the response
    has no body.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The (lack of) difference between `POST` and `PUT` has long been a source of
    discussion among web developers. Some consider that having two methods is misleading.
    Let's try to understand why they are distinct and why we need both.
  prefs: []
  type: TYPE_NORMAL
- en: '`POST` request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '`POST` response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '`PUT` request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '`PUT` response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: At first look, two requests seem fairly similar but in fact they have a very
    important difference, which is the requested URI.
  prefs: []
  type: TYPE_NORMAL
- en: One can `POST` data to a URI where a process may or may not create a resource
    whereas in the case of `PUT` the URI is one of the resources itself and the content
    sent is the new representation of the resource. In that case, if the resource
    does not exist yet at that URI, the server can create it if it has been implemented
    to do so; otherwise the server can return an HTTP error message indicating it
    is not fulfilling the request. In a nutshell, client POST data to a process but
    PUT the new representation of the resource identified by the request URI.
  prefs: []
  type: TYPE_NORMAL
- en: One of the root causes of the problem is the fact that many web applications
    rely only on the `POST` method to achieve any operation on a resource, whether
    creating, updating, or deleting it. This is notably the case because these applications
    often offer only HTML forms, which only support `GET` and `POST`, to perform those
    operations.
  prefs: []
  type: TYPE_NORMAL
- en: Considering the fact that more and more web applications take advantage of separation
    of concerns and handle submission through client code via JavaScript or external
    services, it is likely that the use of the `PUT` and `DELETE` methods increasing,
    though it might be a problem in some environments where firewall policies forbid
    `PUT` and `DELETE` requests.
  prefs: []
  type: TYPE_NORMAL
- en: Putting it Together
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our photoblog application will provide a REST interface for the following entities:
    Album, Film, and Entry. Because of the information they carry, their relationship,
    and their design we can provide the same interface independent of the entity itself.
    Therefore we refactor the `Album` class and create a `Resource` class that will
    centralize the implementation of each operation. Each entity-service interface
    will simply pass the information to the `Resource` class and let it deal with
    the hard work. We thus avoid the duplication of code.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Then let''s redefine our `AlbumRESTService` class to exploit the `Resource`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We have now a RESTful interface that will handle the Album resource. Both the
    Film and Photo entities will be managed the same way. This means that our application
    will now support requests such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In each of these calls the URI is the unique identifier or name of a resource
    and the HTTP method is the operation to carry out on that resource.
  prefs: []
  type: TYPE_NORMAL
- en: REST Interface through CherryPy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until now, we have described services that our photoblog application will support
    without detailing how to achieve it through CherryPy.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we have seen in the previous sections HTTP REST relies on HTTP methods to
    inform a web application of the kind of operation a user agent wishes to carry
    out. In order to implement REST through CherryPy for our photoblog application
    we will use the HTTP method dispatcher as reviewed in[Chapter 4](ch04.html "Chapter 4. CherryPy
    in Depth") to handle incoming requests to the service classes defined above, something
    along these lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This implies that requests applying to a URI path such as `/service/rest/album/`
    will be applied in a REST spirit.
  prefs: []
  type: TYPE_NORMAL
- en: REST is quite a common term but building true RESTful applications can be a
    difficult task. The difficulty resides in defining a sensible and meaningful URI
    set associated with the application resources. In other words, the difficult part
    lies in the designing of the API. This section should have introduced you to the
    principles behind REST but developing the architecture of a large system around
    REST requires a high-level understanding of the resources dealt with, their naming
    convention, and their relationship.
  prefs: []
  type: TYPE_NORMAL
- en: Atom Publishing Protocol
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section we have introduced REST and showed how it can be used
    as a service for web applications. In this section we will introduce the **Atom
    Publishing Protocol** (**APP**), which at the time of writing this book was on
    its way to becoming a new IETF standard. This means that some aspects of this
    section might no longer be up to date by the time you read them.
  prefs: []
  type: TYPE_NORMAL
- en: APP has arisen from the Atom community as an application-level protocol on top
    of HTTP to allow the publishing and editing of web resources. The unit of messages
    between an APP server and a client is based on the Atom XML-document format defined
    in RFC 4287.
  prefs: []
  type: TYPE_NORMAL
- en: Although APP is not specified as being an implementation of the REST principles,
    the protocol does follow the same ideas, which give it a RESTful aspect. Therefore,
    many of the principles of the previous section will apply here; but first let's
    overview the Atom XML-document format.
  prefs: []
  type: TYPE_NORMAL
- en: Atom XML-Document Format
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Atom XML-document format describes a set of information through two top-level
    elements:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Feed: A feed consists of:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: metadata (sometimes referred as the *head* of the feed)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: zero or more entries
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Entry: An entry is made up of:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: metadata
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: some content
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Example of an Atom 1.0 feed document as per RFC4287:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: A web application can serve Atom documents for subscription thus providing a
    way for user agents to syndicate themselves to information the application developer
    chooses to provide.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our photoblog application will provide Atom feeds of the following entities:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Photoblog: Each entry of the feed will link to an album feed of the blog.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Album: Each entry of the feed will link to a film feed of the album.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Film: Each entry will relate to a photo of the film.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will not explain every element of an Atom document but review a few of the
    most common ones.
  prefs: []
  type: TYPE_NORMAL
- en: '`id, title`, and `updated` are compulsory elements in any feed or entry.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`id` must be an IRI as defined in RFC 3987 as a complement to URIs'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`updated` must follow RFC 3339\. RFC 4287 says that this element only needs
    to be updated when the modification is semantically significant.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`author` is compulsory within an Atom feed whether in the `feed` element, `entry`
    element, or both. However, entries of a feed can inherit the feed `author` element
    if they do not provide one.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`link` is not mandatory but is recommended and very useful to provide the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the URI of the resource associated to the entry or the feed using `rel="self"`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: the URI of alternative representations of the resource using `rel="alternate"`
    and specifying the media-type of the resource
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: the URI to related resources using `rel="related"`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`content` should be present at most once. Either the content of an entry is
    inlined within the entry as text, escaped HTML or XHTML, or the content is referenced
    by the `src` attribute providing the URI of the actual content.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Thus we will have for a film feed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The Atom format is commonly used in the blog environment to allow users to subscribe
    to it. However, thanks to its flexibility and extensibility the Atom format is
    now used in different contexts such as publishing, archiving, and exporting content.
  prefs: []
  type: TYPE_NORMAL
- en: APP Implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The aim of providing an **Atom Publishing Protocol** (APP) implementation within
    the photoblog application is to introduce the protocol and to provide two different
    services demonstrating the benefits of the separation of concerns. Because APP
    is not yet a standard and because at the time of writing this book it was under
    a fairly good amount of discussion, it is possible that by the time you read this
    section our implementation will no longer be compliant. However, there is minimum
    risk as the current version of the protocol draft, i.e. 13, seems stable enough
    regarding its main characteristics.
  prefs: []
  type: TYPE_NORMAL
- en: The Atom Publishing Protocol defines a set of operations between an APP service
    and a user-agent using HTTP and its mechanisms and the Atom XML-document format
    as the unit of messages.
  prefs: []
  type: TYPE_NORMAL
- en: 'APP first defines a service document, which provides the user agent with the
    URI of the different collections served by the APP service. It is of the form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Once a user agent has fetched that service document it knows there are two `collections`
    available. The first `collection` informs the user-agent that it will only accept
    Atom documents that have a category matching the one defined. The second `collection`
    will only accept data with the `image/png` or `image/jpeg` MIME types.
  prefs: []
  type: TYPE_NORMAL
- en: '**Collections** are the containers of what APP refers to as members. The operation
    of creating a member is done against a collection but operations of retrieving,
    updating, and deleting are done against that member itself and not the collection.'
  prefs: []
  type: TYPE_NORMAL
- en: A collection is represented as an Atom feed in which entries are referred as
    to members. The critical addition to the Atom entry is the use of an Atom link
    with the `rel` attribute set to `edit` to describe the member resource. By setting
    this attribute to this value we indicate that the `href` attribute of the link
    element references the URL of the member resource that can be retrieved, edited,
    and deleted at that URI. An Atom entry containing such a link element is called
    a **member** of a collection.
  prefs: []
  type: TYPE_NORMAL
- en: APP specifies how to perform the basic CRUD operations against a member of a
    collection or the collection itself by using HTTP methods as described in the
    following table.
  prefs: []
  type: TYPE_NORMAL
- en: '| Operation | HTTP Method | Status Code | Returned Content |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Retrieve | `GET` | `200` | An Atom entry representing the resource |'
  prefs: []
  type: TYPE_TB
- en: '| Create | `POST` | `201` | An Atom entry representing the resourceThe URI
    of the newly created resource via the Location and Content-Location headers |'
  prefs: []
  type: TYPE_TB
- en: '| Update | `PUT` | `200` | An Atom entry representing the resource |'
  prefs: []
  type: TYPE_TB
- en: '| Delete | `DELETE` | `200` | None |'
  prefs: []
  type: TYPE_TB
- en: When creating or updating a resource, the APP server is free to modify part
    of the resource such as its `id`, its `updated` value, etc. Therefore user agents
    should not rely on their version of the resource and always synchronize with the
    server.
  prefs: []
  type: TYPE_NORMAL
- en: Although members of a collection are Atom entries, it is not compulsory to create
    a new member by submitting an Atom entry. APP supports any media type as long
    as it is allowed through the `app:accept` element of an `app:collection` element.
    That element takes a comma-separated list of media types specifying to the client
    which content types the collection will process on POST requests.
  prefs: []
  type: TYPE_NORMAL
- en: If you `POST` a PNG image to a collection that accepts it, the server will create
    at least two resources.
  prefs: []
  type: TYPE_NORMAL
- en: A member resource, which can be seen as the metadata of the image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A media resource
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remember that an APP server has total control over the content sent and therefore
    it is imaginable that an APP server could convert the PNG content to JPEG before
    storing it. A client cannot assume that the content or resource sent will be copied,
    as done by a server. In any case the server returns the member resource when creation
    has succeeded (please refer to the APP specification for detailed examples) and
    this is precisely what makes APP so powerful, since whichever type of resource
    a server says it handles APP ensures that metadata will be generated under the
    form of an Atom entry.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to defining an interface to manipulate members within a collection,
    APP provides support for paging when a collection gets too big. This allows the
    user agent to request a given range of members within a collection. We will not
    explain this feature but you can review the APP specification if you are interested
    in this feature.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, since the photoblog application will follow the REST principles
    as closely as possible for implementing APP, we invite you to refer yourself to
    the REST section for more specific details on how APP uses REST principles.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have briefly presented the Atom Publishing Protocol, a protocol
    based on the Atom XML-document format to allow the publishing of heterogeneous
    data types. In spite of not yet being an official standard, APP already interests
    many organizations and it is quite likely you will find it in more and more applications.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter has introduced you to the concept of web services, which defines
    the idea of offering an API via common web protocols such as HTTP. By providing
    such APIs your web application becomes much more flexible, powerful, and extensible.
    Web services are not a must-have feature though and not every web application
    would offer them. Our photoblog application, in its spirit of demonstrating some
    of the common modern web techniques, uses them as an example rather than as a
    compulsory feature. However, by reviewing the code of our photoblog application
    you will understand some of the interesting benefits of web services, which will
    hopefully give you ideas for your own applications.
  prefs: []
  type: TYPE_NORMAL
