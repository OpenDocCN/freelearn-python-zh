<html><head></head><body>
        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Deploying a Lambda Function with SAM</h1>
                
            
            <article>
                
<p class="calibre2">So far, we have learned about Lambda functions and how to build them. We have learned that a Lambda function has a definite set of triggers that would trigger the function to carry out a particular task. The task is written as a Python module and the script is what we call a function. We have also learned about the different settings of Lambda functions, which include its core settings and also other settings, such as security and network.</p>
<p class="calibre2">There is also another alternative to creating and deploying Lambda functions, which is the <strong class="calibre4">AWS Serverless Application Model</strong> (<strong class="calibre4">AWS SAM</strong>). This format is based on the concept of <strong class="calibre4">infrastructure as code</strong>. This concept is inspired by <strong class="calibre4">AWS CloudFormation</strong>, which is a form of infrastructure as code.</p>
<p class="calibre2">We will be learning about AWS CloudFormation and using that knowledge to understand and build AWS SAM models for creating Lambda functions. We will be covering the following concepts in this chapter:</p>
<ul class="calibre9">
<li class="calibre10">Deploying Lambda functions</li>
<li class="calibre10">Using CloudFormation for serverless services</li>
<li class="calibre10">Deploying with SAM</li>
<li class="calibre10">Understanding security in SAM</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Introduction to SAM</h1>
                
            
            <article>
                
<p class="calibre2">In this section, we will learn about SAM, which will help us build and deploy serverless functions:</p>
<ol class="calibre13">
<li class="calibre10" value="1"><span>As mentioned earlier, SAM is about writing infrastructure as code. So, this is what a Lambda function would be described as in SAM:</span></li>
</ol>
<pre class="calibre17">AWSTemplateFormatVersion: '2010-09-09'<br class="title-page-name"/>Transform: AWS::Serverless-2016-10-31<br class="title-page-name"/>Resources:<br class="title-page-name"/>    &lt; Name of function &gt;:<br class="title-page-name"/>        Type: AWS::Serverless::Function<br class="title-page-name"/>        Properties:<br class="title-page-name"/>            Handler: &lt; index.handler &gt;<br class="title-page-name"/>            Runtime: &lt; runtime &gt;<br class="title-page-name"/>            CodeUri: &lt; URI of the bucket &gt;</pre>
<ol start="2" class="calibre13">
<li value="2" class="calibre10">In this block of code, we enter the details—the name of the function, and the URI of the S3 bucket where our code package is hosted. In the same way that we named the index and the handler in our Lambda settings, we need to enter those details here, too. The <kbd class="calibre12">index.handler</kbd> is the file in which our function code is located. The <kbd class="calibre12">Handler</kbd> is the name of the function in which our Lambda logic is written. Also, the <kbd class="calibre12">Runtime</kbd> is user-defined. You can select from all the available languages that are supported by AWS Lambda. The scope of this book is limited to the Python language, so we will stick to either of the available Python versions:</li>
</ol>
<div class="cdpaligncenter"><img src="../images/00258.jpeg" class="calibre176"/></div>
<ol start="3" class="calibre13">
<li value="3" class="calibre10">We can also add environment variables, as shown here, in our Lambda function, too. These can be very easily edited and configured just as we add, update, and/or delete code, which is an added advantage of the infrastructure as code style of building infrastructures:</li>
</ol>
<pre class="calibre17">AWSTemplateFormatVersion: '2010-09-09'<br class="title-page-name"/>Transform: AWS::Serverless-2016-10-31<br class="title-page-name"/>Resources:<br class="title-page-name"/>    PutFunction:<br class="title-page-name"/>        Type: AWS::Serverless::Function<br class="title-page-name"/>        Properties:<br class="title-page-name"/>            Handler: index.handler<br class="title-page-name"/>            Runtime: &lt; runtime &gt;<br class="title-page-name"/>            Policies: &lt; AWSLambdaDynamoDBExecutionRole &gt;<br class="title-page-name"/>            CodeUri: &lt; URI of the zipped function package &gt;<br class="title-page-name"/>            Environment:<br class="title-page-name"/>                Variables:<br class="title-page-name"/>                     TABLE_NAME: !Ref Table<br class="title-page-name"/>DeleteFunction:<br class="title-page-name"/>    Type: AWS::Serverless::Function<br class="title-page-name"/>     Properties:<br class="title-page-name"/>         Handler: index.handler<br class="title-page-name"/>         Runtime: nodejs6.10<br class="title-page-name"/>         Policies: AWSLambdaDynamoDBExecutionRole<br class="title-page-name"/>          CodeUri: s3://bucketName/codepackage.zip<br class="title-page-name"/>          Environment:<br class="title-page-name"/>              Variables:<br class="title-page-name"/>                  TABLE_NAME: !Ref Table<br class="title-page-name"/>          Events:<br class="title-page-name"/>              Stream:<br class="title-page-name"/>                  Type: DynamoDB<br class="title-page-name"/>                  Properties:<br class="title-page-name"/>                      Stream: !GetAtt DynamoDBTable.StreamArn<br class="title-page-name"/>                      BatchSize: 100<br class="title-page-name"/>                      StartingPosition: TRIM_HORIZON<br class="title-page-name"/>DynamoDBTable:<br class="title-page-name"/>    Type: AWS::DynamoDB::Table<br class="title-page-name"/>    Properties:<br class="title-page-name"/>        AttributeDefinitions:<br class="title-page-name"/>            - AttributeName: id<br class="title-page-name"/>                AttributeType: S<br class="title-page-name"/>        KeySchema:<br class="title-page-name"/>             - AttributeName: id<br class="title-page-name"/>                 KeyType: HASH<br class="title-page-name"/>        ProvisionedThroughput:<br class="title-page-name"/>              ReadCapacityUnits: 5<br class="title-page-name"/>              WriteCapacityUnits: 5<br class="title-page-name"/>        StreamSpecification:<br class="title-page-name"/>              StreamViewType: streamview type</pre>
<ol start="4" class="calibre13">
<li value="4" class="calibre10">The preceding SAM code invokes two Lambda functions that point to an AWS <kbd class="calibre12">DynamoDB</kbd> table. The entire SAM code is an application that consists of a couple of Lambda functions. You need to enter the necessary details for making this work. The <kbd class="calibre12">Runtime</kbd> needs to be updated with either of the available Python runtimes. The corresponding policy for dealing with the <kbd class="calibre12">DynamoDB</kbd> tables needs to be updated in the <kbd class="calibre12">Policies</kbd> section. The <kbd class="calibre12">CodeUri</kbd> section needs to be updated with the S3 URI of the code package. </li>
<li value="5" class="calibre10">It is to be noted that the meta information should always be included for all SAM, which includes the <kbd class="calibre12">AWSTemplateFormatVersion</kbd> and <kbd class="calibre12">Transform</kbd>. This would tell <kbd class="calibre12">CloudFormation</kbd> that the code you have written is an AWS SAM code and a serverless application. The two lines are as follows:</li>
</ol>
<pre class="calibre17">AWSTemplateFormatVersion: '2010-09-09'<br class="title-page-name"/>Transform: AWS::Serverless-2016-10-31 </pre>
<ol start="6" class="calibre13">
<li value="6" class="calibre10">If your serverless function needs to access a single table of <kbd class="calibre12">DynamoDB</kbd>, you can start by creating a <kbd class="calibre12">DynamoDB</kbd> table via your SAM function itself using the <kbd class="calibre12">SimpleTable</kbd> attribute. This can be done as follows:</li>
</ol>
<pre class="calibre17">AWSTemplateFormatVersion: '2010-09-09'<br class="title-page-name"/>Transform: AWS::Serverless-2016-10-31<br class="title-page-name"/>Resources:<br class="title-page-name"/>    &lt; TableName &gt;:<br class="title-page-name"/>        Type: AWS::Serverless::SimpleTable<br class="title-page-name"/>         Properties:<br class="title-page-name"/>             PrimaryKey:<br class="title-page-name"/>                 Name: id<br class="title-page-name"/>                 Type: String<br class="title-page-name"/>             ProvisionedThroughput:<br class="title-page-name"/>                 ReadCapacityUnits: 5<br class="title-page-name"/>                  WriteCapacityUnits: 5</pre>
<ol start="7" class="calibre13">
<li value="7" class="calibre10">Now, we will learn how to create a Lambda function with a trigger. As we are already using <kbd class="calibre12">DynamoDB</kbd> for the examples, we will use the same as a trigger in this step. The SAM code for this would look as follows:</li>
</ol>
<pre class="calibre17">AWSTemplateFormatVersion: '2010-09-09'<br class="title-page-name"/>Transform: AWS::Serverless-2016-10-31<br class="title-page-name"/>Resources:<br class="title-page-name"/>    &lt; Name of the function &gt;:<br class="title-page-name"/>        Type: AWS::Serverless::Function<br class="title-page-name"/>        Properties:<br class="title-page-name"/>            Handler: index.handler<br class="title-page-name"/>            Runtime: &lt; runtime &gt;<br class="title-page-name"/>            Events:<br class="title-page-name"/>                Stream:<br class="title-page-name"/>                    Type: DynamoDB<br class="title-page-name"/>                    Properties:<br class="title-page-name"/>                        Stream: !GetAtt DynamoDBTable.StreamArn<br class="title-page-name"/>                        BatchSize: 100<br class="title-page-name"/>                        StartingPosition: TRIM_HORIZON<br class="title-page-name"/>&lt; Name of the table &gt;:<br class="title-page-name"/>    Type: AWS::DynamoDB::Table<br class="title-page-name"/>    Properties:<br class="title-page-name"/>         AttributeDefinitions:<br class="title-page-name"/>            - AttributeName: id<br class="title-page-name"/>                AttributeType: S<br class="title-page-name"/>        KeySchema:<br class="title-page-name"/>            - AttributeName: id<br class="title-page-name"/>                KeyType: HASH<br class="title-page-name"/>        ProvisionedThroughput:<br class="title-page-name"/>             ReadCapacityUnits: 5<br class="title-page-name"/>             WriteCapacityUnits: 5</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">CloudFormation for serverless services</h1>
                
            
            <article>
                
<p class="calibre2">In this section, we will learn how CloudFormation can be used to build and deploy Lambda functions. We will do the following:</p>
<ol class="calibre13">
<li value="1" class="calibre10">We will write a <span>CloudFormation</span> template for a Lambda function that periodically pings a website and gives an error if there is any failure in the process. The <span>CloudFormation</span> template for this is as follows:</li>
</ol>
<pre class="calibre17">AWSTemplateFormatVersion: '2010-09-09'<br class="title-page-name"/>Transform: 'AWS::Serverless-2016-10-31'<br class="title-page-name"/>Description: 'Performs a periodic check of the given site, erroring out on test failure.'<br class="title-page-name"/>Resources:<br class="title-page-name"/>lambdacanary:<br class="title-page-name"/>    Type: 'AWS::Serverless::Function'<br class="title-page-name"/>    Properties:<br class="title-page-name"/>        Handler: lambda_function.lambda_handler<br class="title-page-name"/>        Runtime: python2.7<br class="title-page-name"/>        CodeUri: .<br class="title-page-name"/>        Description: &gt;-<br class="title-page-name"/>            Performs a periodic check of the given site, <br class="title-page-name"/>erroring out on test failure.<br class="title-page-name"/>    MemorySize: 128<br class="title-page-name"/>    Timeout: 10<br class="title-page-name"/>    Events:<br class="title-page-name"/>        Schedule1:<br class="title-page-name"/>        Type: Schedule<br class="title-page-name"/>        Properties:<br class="title-page-name"/>            Schedule: rate(1 minute)<br class="title-page-name"/>    Environment:<br class="title-page-name"/>        Variables:<br class="title-page-name"/>            site: 'https://www.google.com/'<br class="title-page-name"/>            expected: Search site.</pre>
<ol start="2" class="calibre13">
<li value="2" class="calibre10">There is a lot of syntax in this CloudFormation snippet. We will now try to understand it in a bit more detail:
<ol class="calibre14">
<li value="1" class="calibre10">In the first three lines that contain the meta details of the Lambda function, we have the following line—<kbd class="calibre12"><span>Transform: 'AWS::Serverless-2016-10-31'</span></kbd>. This line is used to define the resources that a user will be using/accessing, through a <span>CloudFormation</span> template. As we are using a Lambda function, we have specified it as <kbd class="calibre12">Serverless</kbd>.</li>
<li value="2" class="calibre10">We have also defined the memory size that our function will be using. It is similar to how we learned to view and change the memory settings in the Lambda's console.</li>
<li value="3" class="calibre10"><kbd class="calibre12">Timeout</kbd> is the amount of time the Lambda function can keep retrying before considering the attempt as a failure.</li>
</ol>
</li>
</ol>
<p class="calibre2">You can also see that we have added environment variables to our Lambda function that will be stored in the Lambda container and used when needed by the system. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Deploying with SAM</h1>
                
            
            <article>
                
<p class="calibre2">In this section, we will learn how to deploy the SAM applications. We have already learned what SAM applications and code look like, so we will learn how to deploy them via AWS CloudFormation:</p>
<ol class="calibre13">
<li value="1" class="calibre10">Firstly, let's set up our local environment for deployment purposes, and then start by installing <kbd class="calibre12">awscli</kbd> from <kbd class="calibre12">pip</kbd>:</li>
</ol>
<div class="cdpaligncenter"><img src="../images/00259.jpeg" class="calibre48"/></div>
<ol start="2" class="calibre13">
<li value="2" class="calibre10">Next, you will need to configure your AWS environment using your credentials:</li>
</ol>
<div class="cdpaligncenter"><img src="../images/00260.jpeg" class="calibre177"/></div>
<ol start="3" class="calibre13">
<li value="3" class="calibre10">You will need to enter the following details to make sure your AWS environment is successfully configured:
<ul class="calibre20">
<li class="calibre10">Your AWS Access Key</li>
<li class="calibre10">Your AWS Secret Key</li>
<li class="calibre10">The default region in which you want to operate</li>
<li class="calibre10">The default output format in which you want your data</li>
</ul>
</li>
</ol>
<ol start="4" class="calibre13">
<li value="4" class="calibre10">Now, let's try to deploy a simple <kbd class="calibre12">Hello World</kbd> Lambda application via SAM. We will have two code files for this. One is the Python file and the other is the template <kbd class="calibre12">yaml</kbd> file.</li>
</ol>
<ol start="5" class="calibre13">
<li value="5" class="calibre10">We will use the default <kbd class="calibre12">Hello World</kbd> example for Python, as we are trying to understand how SAM deployments work instead of stressing too much about the code for now. The Python script will be as follows:</li>
</ol>
<pre class="calibre17">import json<br class="title-page-name"/>print('Loading function')<br class="title-page-name"/>def lambda_handler(event, context):<br class="title-page-name"/>    #print("Received event: " + json.dumps(event, indent=2))<br class="title-page-name"/>    print("value1 = " + event['key1'])<br class="title-page-name"/>    print("value2 = " + event['key2'])<br class="title-page-name"/>    print("value3 = " + event['key3'])<br class="title-page-name"/>    return event['key1'] # Echo back the first key value<br class="title-page-name"/>    #raise Exception('Something went wrong')</pre>
<ol start="6" class="calibre13">
<li value="6" class="calibre10">We will use a basic template <kbd class="calibre12">yaml</kbd> file for the SAM function too, whose only job is to define its meta information and to run the Python script that is mentioned previously. The template <kbd class="calibre12">yaml</kbd> file will look like this:</li>
</ol>
<pre class="calibre17">AWSTemplateFormatVersion: '2010-09-09'<br class="title-page-name"/>Transform: 'AWS::Serverless-2016-10-31'<br class="title-page-name"/>Description: A starter AWS Lambda function.<br class="title-page-name"/>Resources:<br class="title-page-name"/>    helloworldpython3:<br class="title-page-name"/>        Type: 'AWS::Serverless::Function'<br class="title-page-name"/>        Properties:<br class="title-page-name"/>            Handler: lambda_function.lambda_handler<br class="title-page-name"/>            Runtime: python3.6<br class="title-page-name"/>            CodeUri: .<br class="title-page-name"/>            Description: A starter AWS Lambda function.<br class="title-page-name"/>            MemorySize: 128<br class="title-page-name"/>            Timeout: 3</pre>
<ol start="7" class="calibre13">
<li value="7" class="calibre10">Now, we will package the SAM template we just created, using the command line. The instructions for packaging the code are as follows:</li>
</ol>
<pre class="calibre17"><strong class="calibre1">aws cloudformation package --template-file template.yaml --output-template-file output.yaml --s3-bucket receiver-bucket</strong></pre>
<p class="calibre34">You get the following output:</p>
<div class="cdpaligncenter2"><img src="../images/00261.jpeg" class="calibre48"/></div>
<ol start="8" class="calibre13">
<li value="8" class="calibre10">This will create an output <kbd class="calibre12">yaml</kbd> file that needs to be deployed, as mentioned in the preceding trace. The <kbd class="calibre12">output.yaml</kbd> file looks like this:</li>
</ol>
<pre class="calibre17">AWSTemplateFormatVersion: '2010-09-09'<br class="title-page-name"/>Description: A starter AWS Lambda function.<br class="title-page-name"/>Resources:<br class="title-page-name"/>    helloworldpython3:<br class="title-page-name"/>        Properties:<br class="title-page-name"/>            CodeUri: s3://receiver-bucket/22067de83ab3b7a12a153fbd0517d6cf<br class="title-page-name"/>            Description: A starter AWS Lambda function.<br class="title-page-name"/>            Handler: lambda_function.lambda_handler<br class="title-page-name"/>            MemorySize: 128<br class="title-page-name"/>            Runtime: python3.6<br class="title-page-name"/>            Timeout: 3<br class="title-page-name"/>        Type: AWS::Serverless::Function<br class="title-page-name"/>Transform: AWS::Serverless-2016-10-31</pre>
<ol start="9" class="calibre13">
<li value="9" class="calibre10">Now, as we have packaged the SAM template, we will now deploy it. We will use the instructions shown in the trace when we did the packaging for the deployment process. The instructions for deployment are as follows:</li>
</ol>
<pre class="calibre17"><strong class="calibre1">aws cloudformation deploy --template-file /Users/&lt;path&gt;/SAM/output.yaml --stack-name 'TestSAM' --capabilities CAPABILITY_IAM<br class="title-page-name"/></strong></pre>
<p class="calibre34">This will give you the following output:</p>
<div class="cdpaligncenter"><img src="../images/00262.jpeg" class="calibre48"/></div>
<ol start="10" class="calibre13">
<li value="10" class="calibre10">We can head over to the <span>CloudFormation</span> console to look at the template we just deployed. The deployed template will look something like this:</li>
</ol>
<div class="cdpaligncenter"><img src="../images/00263.jpeg" class="calibre178"/></div>
<ol start="11" class="calibre13">
<li value="11" class="calibre10">In the <span>Template</span> tab shown here, we can see both the original template and the processed template. The original template can be seen by selecting the first radio button: </li>
</ol>
<div class="cdpaligncenter"><img src="../images/00264.jpeg" class="calibre179"/></div>
<ol start="12" class="calibre13">
<li value="12" class="calibre10">The processed template can be seen by selecting the second radio button under the <span>Template</span> tab at the bottom:</li>
</ol>
<div class="cdpaligncenter"><img src="../images/00265.jpeg" class="calibre180"/></div>
<ol start="13" class="calibre13">
<li value="13" class="calibre10">If we head over to the <span>Lambda</span> console, we will see the newly created Lambda function via SAM with the corresponding name given:</li>
</ol>
<div class="cdpaligncenter"><img src="../images/00266.jpeg" class="calibre48"/></div>
<ol start="14" class="calibre13">
<li value="14" class="calibre10">Clicking on the <span>Functions</span> will give us more information about it. It also mentions the SAM template and the <span>CloudFormation</span> template from which it was created:</li>
</ol>
<div class="cdpaligncenter"><img src="../images/00267.jpeg" class="calibre181"/></div>
<ol start="15" class="calibre13">
<li value="15" class="calibre10">Let's create basic tests for the Lambda function. The test creation console can be opened by clicking on the <span>Test </span>button:</li>
</ol>
<div class="cdpaligncenter"><img src="../images/00268.jpeg" class="calibre182"/></div>
<ol start="16" class="calibre13">
<li value="16" class="calibre10">Now, once the tests have been created, you can again click on the <span>Test</span> button. This will run the testing with the updated test cases. The logs from a successful run will look like this:</li>
</ol>
<div class="cdpaligncenter"><img src="../images/00269.jpeg" class="calibre48"/></div>
<ol start="17" class="calibre13">
<li value="17" class="calibre10">Now, let's go through each component of the Lambda function properly. The <span>Configuration</span> shows the triggers and the logging settings of our Lambda function. We are logging into the CloudWatch service of AWS:</li>
</ol>
<div class="cdpaligncenter"><img src="../images/00270.jpeg" class="calibre48"/></div>
<ol start="18" class="calibre13">
<li value="18" class="calibre10">We can also see the invocation metrics in the <span>Monitoring</span> option in the <span>Lambda</span> console. We can see exactly one Lambda invocation:</li>
</ol>
<div class="cdpaligncenter"><img src="../images/00271.jpeg" class="calibre48"/></div>
<ol start="19" class="calibre13">
<li value="19" class="calibre10">You can see the code files in the <span>Function code</span> section. You can see the folder structure in the left-hand corner of the interactive code editor that contains both the <kbd class="calibre12">template.yaml</kbd> file and the function code:</li>
</ol>
<div class="cdpaligncenter"><img src="../images/00272.jpeg" class="calibre48"/></div>
<ol start="20" class="calibre13">
<li value="20" class="calibre10">And further below, you can see the pre-existing environment variable named <kbd class="calibre12">lambda:createdBy</kbd>,<span> and also the timeout setting we mentioned in our template.<br class="title-page-name"/></span></li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Understanding security in SAM</h1>
                
            
            <article>
                
<p class="calibre2">So far, we have learned how to write, build, package, and deploy Lambda functions using the SAM. We will now understand how security works inside them:</p>
<ol class="calibre13">
<li value="1" class="calibre10">You can scroll to the bottom of the Lambda console to see the network and security settings, where the VPC and the subnet details are mentioned:</li>
</ol>
<div class="cdpaligncenter"><img src="../images/00273.jpeg" class="calibre48"/></div>
<ol start="2" class="calibre13">
<li value="2" class="calibre10">Now, we will add in the network settings, which include the security groups and the subnet IDs:</li>
</ol>
<pre class="calibre17">AWSTemplateFormatVersion: '2010-09-09'<br class="title-page-name"/>Transform: 'AWS::Serverless-2016-10-31'<br class="title-page-name"/>Description: A starter AWS Lambda function.<br class="title-page-name"/>Resources:<br class="title-page-name"/>    helloworldpython3:<br class="title-page-name"/>        Type: 'AWS::Serverless::Function'<br class="title-page-name"/>        Properties:<br class="title-page-name"/>            Handler: lambda_function.lambda_handler<br class="title-page-name"/>            Runtime: python3.6<br class="title-page-name"/>            CodeUri: .<br class="title-page-name"/>            Description: A starter AWS Lambda function.<br class="title-page-name"/>            MemorySize: 128<br class="title-page-name"/>            Timeout: 3<br class="title-page-name"/>            VpcConfig:<br class="title-page-name"/>                SecurityGroupIds:<br class="title-page-name"/>                    - sg-9a19c5ec<br class="title-page-name"/>                SubnetIds:<br class="title-page-name"/>                    - subnet-949564de</pre>
<ol start="3" class="calibre13">
<li value="3" class="calibre10">Now, package and deploy the newly updated SAM template like we did in the previous section:</li>
</ol>
<div class="cdpaligncenter"><img src="../images/00274.jpeg" class="calibre48"/></div>
<ol start="4" class="calibre13">
<li value="4" class="calibre10">Now you will see the corresponding network and security settings, once you have packaged and deployed the <span>CloudFormation</span> template after the corresponding edits. The <span>Network</span> section looks as follows:</li>
</ol>
<div class="cdpaligncenter"><img src="../images/00275.jpeg" class="calibre48"/></div>
<ol start="5" class="calibre13">
<li value="5" class="calibre10">You can also see the inbound rules of your corresponding security groups that are linked with the VPC in your <span>Network</span> settings:</li>
</ol>
<div class="cdpaligncenter"><img src="../images/00276.jpeg" class="calibre48"/></div>
<ol start="6" class="calibre13">
<li value="6" class="calibre10">You can also see the completed <span>CloudFormation</span> template in your console with the updated network and security settings, which means that deployment has been successful:</li>
</ol>
<div class="cdpaligncenter"><img src="../images/00277.jpeg" class="calibre48"/></div>
<ol start="7" class="calibre13">
<li value="7" class="calibre10">You can also see the original template under the <span>Templates</span> option in the bottom corner of the console:</li>
</ol>
<div class="cdpaligncenter"><img src="../images/00278.jpeg" class="calibre48"/></div>
<ol start="8" class="calibre13">
<li value="8" class="calibre10">The processed template can be found by selecting the <span>View processed template</span> option beside the original template option at the bottom of the console:</li>
</ol>
<div class="cdpaligncenter"><img src="../images/00279.jpeg" class="calibre48"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            <article>
                
<p class="calibre2">In this chapter, we learned how to deploy Lambda functions as infrastructure as code via SAM, which is a new way of writing and deploying Lambda functions. This makes it easier to integrate with other IaaS services, such as CloudFormation. We also learned about the AWS CloudFormation service, which is the service that allows and facilitates infrastructure as code. We also learned how security works inside SAM code and how to configure VPC and subnet settings.</p>
<p class="calibre2">In the next chapter, you will be introduced to Microsoft Azure functions, along with configuring and understanding the components of the tool.</p>


            </article>

            
        </section>
    </body></html>