- en: Chapter 8. Hierarchical Structures
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。层次结构
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下食谱：
- en: Creating hierarchical categories
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建层次类别
- en: Creating a category administration interface with django-mptt-admin
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用django-mptt-admin创建类别管理界面
- en: Creating a category administration interface with django-mptt-tree-editor
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用django-mptt-tree-editor创建类别管理界面
- en: Rendering categories in a template
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在模板中渲染类别
- en: Using a single selection field to choose a category in forms
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在表单中使用单个选择字段选择类别
- en: Using a checkbox list to choose multiple categories in forms
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在表单中使用复选框列表选择多个类别
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Whether you build your own forum, threaded comments, or categorization system,
    there will be a moment when you need to save hierarchical structures in the database.
    Although the tables of relational databases (such as MySQL and PostgreSQL) are
    of a flat manner, there is a fast and effective way to store hierarchical structures.
    It is called **Modified Preorder Tree Traversal** (**MPTT**). MPTT allows you
    to read the tree structures without recursive calls to the database.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你构建自己的论坛、线程评论还是分类系统，总会有需要将层次结构保存到数据库中的时刻。尽管关系数据库（如MySQL和PostgreSQL）的表是扁平的，但有一种快速有效的方法来存储层次结构。它被称为**修改后的前序树遍历**（**MPTT**）。MPTT允许你读取树结构，而无需对数据库进行递归调用。
- en: 'At first, let''s get familiar with the terminology of the tree structures.
    A tree data structure is a recursive collection of nodes, starting at the root
    node and having references to child nodes. There is a restriction that no node
    references back to create a loop and no reference is duplicated. The following
    are some other terms to learn:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们熟悉树结构的术语。树数据结构是一个以根节点为起点的递归节点集合，具有对子节点的引用。有一个限制，即没有节点会回引用以创建循环，也没有重复的引用。以下是一些其他需要学习的术语：
- en: '**Parent** is any node that is referencing to the child nodes.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**父节点**是指向子节点的任何节点。'
- en: '**Descendants** are the nodes that can be reached by recursively traversing
    from a parent to its children. Therefore, the node''s descendants will be its
    child, the child''s children, and so on.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**后代**是通过递归从父节点遍历到其子节点可以到达的节点。因此，节点的后代将是其子节点、子节点的子节点，依此类推。'
- en: '**Ancestors** are the nodes that can be reached by recursively traversing from
    a child to its parent. Therefore, the node''s ancestors will be its parent, the
    parent''s parent, and so on up to the root.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**祖先**是通过递归从子节点遍历到其父节点可以到达的节点。因此，节点的祖先将是其父节点、父节点的父节点，依此类推，直到根节点。'
- en: '**Siblings** are the nodes with the same parent.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**兄弟**是指具有相同父节点的节点。'
- en: '**Leaf** is a node without children.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**叶**是指没有子节点的节点。'
- en: 'Now, I''ll explain how MPTT works. Imagine that you lay out your tree horizontally
    with the root node at the top. Each node in the tree has left and right values.
    Imagine them as small left and right handles on the left and right-hand side of
    the node. Then, you walk (traverse) around the tree counter-clockwise, starting
    from the root node and mark each left or right value that you find with a number:
    1, 2, 3, and so on. It will look similar to the following diagram:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我将解释MPTT是如何工作的。想象一下，你将树水平展开，根节点在最上方。树中的每个节点都有左值和右值。想象它们作为节点左右两侧的小左右手柄。然后，你逆时针绕树行走（遍历），从根节点开始，并用数字标记你找到的每个左值或右值：1、2、3，依此类推。它看起来会类似于以下图表：
- en: '![Introduction](img/B04912_08_01.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![简介](img/B04912_08_01.jpg)'
- en: In the database table of this hierarchical structure, you will have a title,
    left value, and right value for each node.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个层次结构的数据库表中，你将为每个节点有一个标题、左值和右值。
- en: Now, if you want to get the subtree of the **B** node with **2** as the left
    value and **11** as the right value, you will have to select all the nodes that
    have a left value between **2** and **11**. They are **C**, **D**, **E**, and
    **F**.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你想获取具有左值为**2**和右值为**11**的**B**节点的子树，你必须选择所有左值在**2**和**11**之间的节点。它们是**C**、**D**、**E**和**F**。
- en: To get all the ancestors of the **D** node with **5** as the left value and
    **10** as the right value, you have to select all the nodes that have a left value
    that is less than **5** and a right value that is more than **10**. These would
    be **B** and **A**.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取具有左值为**5**和右值为**10**的**D**节点的所有祖先，你必须选择所有左值小于**5**且右值大于**10**的节点。这些将是**B**和**A**。
- en: 'To get the number of the descendants for a node, you can use the following
    formula: *descendants = (right - left - 1) / 2*'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取节点的后代数量，你可以使用以下公式：*descendants = (right - left - 1) / 2*
- en: 'Therefore, the number of descendants for the **B** node can be calculated as
    shown in the following: *(11 - 2 - 1) / 2 = 4*'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，**B**节点的后代数量可以按照以下方式计算：*(11 - 2 - 1) / 2 = 4*
- en: If we want to attach the **E** node to the **C** node, we will have to update
    the left and right values only for the nodes of their first common ancestor, the
    **B** node. Then, the **C** node will still have **3** as the left value; the
    **E** node will get **4** as the left value and **5** as the right value; the
    right value of the **C** node will become **6**; the left value of the **D** node
    will become **7**; the left value of the **F** node will stay **8**; and the others
    will also remain the same.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要将**E**节点连接到**C**节点，我们只需要更新它们第一个共同祖先**B**节点的左右值。然后，**C**节点的左值仍然是**3**；**E**节点的左值将变为**4**，右值变为**5**；**C**节点的右值变为**6**；**D**节点的左值变为**7**；**F**节点的左值保持为**8**；其他节点也将保持不变。
- en: Similarly, there are other tree-related operations with nodes in MPTT. It might
    be too complicated to manage all this by yourself for every hierarchical structure
    in your project. Luckily, there is a Django app called **django-mptt** that handles
    these algorithms and provides an easy API to handle the tree structures. In this
    chapter, you will learn how to use this helper app.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，在MPTT中还有其他与节点相关的树操作。对于项目中每个层次结构，自己管理所有这些可能过于复杂。幸运的是，有一个名为**django-mptt**的Django应用可以处理这些算法，并提供一个简单的API来处理树结构。在本章中，你将学习如何使用这个辅助应用。
- en: Creating hierarchical categories
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建层次化类别
- en: To illustrate how to deal with MPTT, we will create a `movies` app that will
    have a hierarchical `Category` model and a `Movie` model with a many-to-many relationship
    with the categories.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明如何处理MPTT，我们将创建一个`movies`应用，它将有一个层次化的`Category`模型和一个与类别具有多对多关系的`Movie`模型。
- en: Getting ready
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To get started, perform the following steps:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，执行以下步骤：
- en: 'Install `django-mptt` in your virtual environment using the following command:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令在你的虚拟环境中安装`django-mptt`：
- en: '[PRE0]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then, create a `movies` app. Add the `movies` app as well as `mptt` to `INSTALLED_APPS`
    in the settings, as follows:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，创建一个`movies`应用。在设置中将`movies`应用以及`mptt`添加到`INSTALLED_APPS`中，如下所示：
- en: '[PRE1]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: How to do it...
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We will create a hierarchical `Category` model and a `Movie` model, which will
    have a many-to-many relationship with the categories, as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个层次化的`Category`模型和一个`Movie`模型，这些模型将与类别具有多对多关系，如下所示：
- en: 'Open the `models.py` file and add a `Category` model that extends `mptt.models.MPTTModel`
    and `CreationModificationDateMixin`, which we defined in [Chapter 2](ch02.html
    "Chapter 2. Database Structure"), *Database Structure*. In addition to the fields
    coming from the mixins, the `Category` model will need to have a `parent` field
    of the `TreeForeignKey` type and a `title` field:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`models.py`文件，添加一个`Category`模型，它扩展了`mptt.models.MPTTModel`和`CreationModificationDateMixin`，这些我们在[第2章](ch02.html
    "第2章。数据库结构")中定义了，*数据库结构*。除了来自混入器的字段外，`Category`模型还需要一个`parent`字段，字段类型为`TreeForeignKey`，以及一个`title`字段：
- en: '[PRE2]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Then, create the `Movie` model that extends `CreationModificationDateMixin`.
    Also, include a `title` field and a categories field of the `TreeManyToManyField`
    type:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，创建一个扩展`CreationModificationDateMixin`的`Movie`模型。还包括一个`title`字段和一个`categories`字段，字段类型为`TreeManyToManyField`：
- en: '[PRE3]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: How it works...
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `MPTTModel` mixin will add the `tree_id`, `lft`, `rght`, and `level` fields
    to the `Category` model. The `tree_id` field is used as you can have multiple
    trees in the database table. In fact, each root category is saved in a separate
    tree. The `lft` and `rght` fields store the left and right values used in the
    MPTT algorithms. The `level` field stores the node's depth in the tree. The root
    node will be level `0`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`MPTTModel`混入器将为`Category`模型添加`tree_id`、`lft`、`rght`和`level`字段。`tree_id`字段用于你可以有多个树在数据库表中。实际上，每个根类别都保存在一个单独的树中。`lft`和`rght`字段存储MPTT算法中使用的左右值。`level`字段存储节点在树中的深度。根节点的级别为`0`。'
- en: 'Besides new fields, the `MPTTModel` mixin adds methods to navigate through
    the tree structure similar to how you would navigate through DOM elements using
    JavaScript. These methods are listed as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 除了新字段外，`MPTTModel`混入器还添加了用于在树结构中导航的方法，类似于使用JavaScript通过DOM元素导航。以下列出了这些方法：
- en: 'If you want to get the ancestors of a category, use the following code:'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你想要获取一个分类的祖先节点，请使用以下代码：
- en: '[PRE4]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The ascending parameter defines from which direction to read the nodes (the
    default is `False`). The `include_self` parameter defines whether to include the
    category itself in `QuerySet` (the default is `False`).
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 升序参数定义了从哪个方向读取节点（默认为 `False`）。`include_self` 参数定义是否将分类本身包含在 `QuerySet` 中（默认为
    `False`）。
- en: 'To just get the root category, use the following code:'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要仅获取根分类，请使用以下代码：
- en: '[PRE5]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If you want to get the direct children of a category, use the following code:'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你想要获取一个分类的直接子节点，请使用以下代码：
- en: '[PRE6]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'To get all the descendants of a category, use the following code:'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要获取一个分类的所有子节点，请使用以下代码：
- en: '[PRE7]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, the `include_self` parameter again defines whether or not to include the
    category itself in `QuerySet`.
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，`include_self` 参数再次定义是否将分类本身包含在 `QuerySet` 中。
- en: 'If you want to get the descendant count without querying the database, use
    the following code:'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你想在不查询数据库的情况下获取子节点数量，请使用以下代码：
- en: '[PRE8]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To get all the siblings, call the following method:'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要获取所有兄弟节点，请调用以下方法：
- en: '[PRE9]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Root categories are considered to be siblings of other root categories.
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 根分类被视为其他根分类的兄弟。
- en: 'To just get the previous and next siblings, call the following methods:'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要仅获取前一个和后一个兄弟节点，请调用以下方法：
- en: '[PRE10]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Also, there are methods to check whether the category is a root, child, or
    leaf, as follows:'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，还有方法检查分类是否为根节点、子节点或叶节点，如下所示：
- en: '[PRE11]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: All these methods can be used either in the views, templates, or management
    commands. If you want to manipulate the tree structure, you can also use the `insert_at()`
    and `move_to()` methods. In this case, you can read about them and the tree manager
    methods at [http://django-mptt.github.io/django-mptt/models.html](http://django-mptt.github.io/django-mptt/models.html).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些方法都可以在视图、模板或管理命令中使用。如果你想操作树结构，你也可以使用 `insert_at()` 和 `move_to()` 方法。在这种情况下，你可以阅读有关它们和树管理器方法的文档，请参阅[http://django-mptt.github.io/django-mptt/models.html](http://django-mptt.github.io/django-mptt/models.html)。
- en: In the preceding models, we used `TreeForeignKey` and `TreeManyToManyField`.
    These are similar to `ForeignKey` and `ManyToManyField`, except that they show
    the choices indented in hierarchies in the administration interface.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的模型中，我们使用了 `TreeForeignKey` 和 `TreeManyToManyField`。这些与 `ForeignKey` 和 `ManyToManyField`
    类似，不同之处在于它们在管理界面中以缩进的形式显示选择项。
- en: Also, note that in the `Meta` class of the `Category` model, we order the categories
    by `tree_id` and then by the `lft` value in order to show the categories naturally
    in the tree structure.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，在 `Category` 模型的 `Meta` 类中，我们按 `tree_id` 和 `lft` 值的顺序对分类进行排序，以便在树结构中自然显示分类。
- en: See also
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Creating a model mixin to handle creation and modification dates* recipe
    in [Chapter 2](ch02.html "Chapter 2. Database Structure"), *Database Structure*
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第2章](ch02.html "第2章。数据库结构")的*创建用于处理创建和修改日期的模型混入*食谱中，*数据库结构*
- en: The *Structuring the page menu* recipe in [Chapter 7](ch07.html "Chapter 7. Django
    CMS"), *Django CMS*
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第7章](ch07.html "第7章。Django CMS")的*结构化页面菜单*食谱中，*Django CMS*
- en: The *Creating a category administration interface with django-mptt-admin* recipe
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 django-mptt-admin 创建分类管理界面* 食谱'
- en: Creating a category administration interface with django-mptt-admin
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 django-mptt-admin 创建分类管理界面
- en: The `django-mptt` app comes with a simple model administration mixin that allows
    you to create the tree structure and list it with indentation. To reorder trees,
    you need to either create this functionality yourself or use a third-party solution.
    Currently, there are two apps that can help you to create a draggable administration
    interface for hierarchical models. One of them is `django-mptt-admin`. Let's take
    a look at it in this recipe.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`django-mptt` 应用程序附带一个简单的模型管理混入，允许你创建树结构并以缩进形式列出。要重新排序树，你需要自己创建此功能或使用第三方解决方案。目前，有两个应用程序可以帮助你为层次模型创建可拖拽的管理界面。其中之一是
    `django-mptt-admin`。让我们在本食谱中看看它。'
- en: Getting ready
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'First, we need to have the `django-mptt-admin` app installed by performing
    the following steps:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要通过以下步骤安装 `django-mptt-admin` 应用程序：
- en: 'To start, install the app in your virtual environment using the following command:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，使用以下命令在你的虚拟环境中安装应用程序：
- en: '[PRE12]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then, put it in `INSTALLED_APPS` in the settings, as follows:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将其放入设置中的 `INSTALLED_APPS`，如下所示：
- en: '[PRE13]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: How to do it...
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Create an administration interface for the `Category` model that extends `DjangoMpttAdmin`
    instead of `admin.ModelAdmin`, as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个扩展 `DjangoMpttAdmin` 而不是 `admin.ModelAdmin` 的 `Category` 模型的管理界面，如下所示：
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: How it works...
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The administration interface for the categories will have two modes: Tree view
    and Grid view. The Tree view looks similar to the following screenshot:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 分类的管理界面将有两种模式：树视图和网格视图。树视图看起来类似于以下截图：
- en: '![How it works...](img/B04912_08_02.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/B04912_08_02.jpg)'
- en: 'The Tree view uses the jqTree jQuery library for node manipulation. You can
    expand and collapse categories for a better overview. To reorder them or change
    the dependencies, you can drag and drop the titles in this list view. During reordering,
    the user interface looks similar to the following screenshot:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 树视图使用 jqTree jQuery 库进行节点操作。你可以展开和折叠分类以获得更好的概览。要重新排序或更改依赖关系，你可以在这个列表视图中拖放标题。在重新排序过程中，用户界面看起来类似于以下截图：
- en: '![How it works...](img/B04912_08_03.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/B04912_08_03.jpg)'
- en: Note
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that any usual list-related settings such as `list_display` or `list_filter`
    will be ignored.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，任何常规的列表相关设置，如 `list_display` 或 `list_filter`，都将被忽略。
- en: If you want to filter categories, sort or filter them by a specific field, or
    apply admin actions, you can switch to the Grid view, which shows the default
    category change list.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要过滤分类、按特定字段排序或过滤，或应用管理操作，你可以切换到网格视图，它显示默认的分类变更列表。
- en: See also
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Creating hierarchical categories* recipe
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建分层分类* 的配方'
- en: The *Creating a category administration interface with django-mptt-tree-editor*
    recipe
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 django-mptt-tree-editor 创建分类管理界面* 的配方'
- en: Creating a category administration interface with django-mptt-tree-editor
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 django-mptt-tree-editor 创建分类管理界面
- en: If you want to use the common functionality of the change list, such as columns,
    admin actions, editable fields, or filters, in your administration interface as
    well as manipulate the tree structure in the same view, you need to use another
    third-party app called `django-mptt-tree-editor`. Let's see how to do that.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在你的管理界面中使用变更列表的常用功能，例如列、管理操作、可编辑字段或过滤器，以及在同一视图中操作树结构，你需要使用另一个名为 `django-mptt-tree-editor`
    的第三方应用程序。让我们看看如何做到这一点。
- en: Getting ready
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'First, we need to have the `django-mptt-tree-editor` app installed. Perform
    the following steps:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要安装 `django-mptt-tree-editor` 应用程序。执行以下步骤：
- en: 'To start, install the app in your virtual environment using the following command:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，使用以下命令在你的虚拟环境中安装应用程序：
- en: '[PRE15]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then, put it in `INSTALLED_APPS` in the settings, as follows:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将其放入设置中的 `INSTALLED_APPS`，如下所示：
- en: '[PRE16]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: How to do it...
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Create an administration interface for the `Category` model that extends `TreeEditor`
    instead of `admin.ModelAdmin`. Make sure that you add `indented_short_title` and
    `actions_column` at the beginning of the `list_display` setting, as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个扩展 `TreeEditor` 而不是 `admin.ModelAdmin` 的 `Category` 模型的管理界面。确保你在 `list_display`
    设置的开始处添加 `indented_short_title` 和 `actions_column`，如下所示：
- en: '[PRE17]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: How it works...
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The administration interface for your categories now looks similar to the following
    screenshot:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 你的分类管理界面现在看起来类似于以下截图：
- en: '![How it works...](img/B04912_08_04.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/B04912_08_04.jpg)'
- en: 'The category administration interface allows you to expand or collapse the
    categories. The `indented_short_title` column will either return the indented
    short title from the `short_title()` method of the category (if there is one)
    or the indented Unicode representation of the category. The column defined as
    `actions_column` will be rendered as a handle to reorder or restructure the categories
    by dragging and dropping them. As the dragging handle is in a different column
    than the category title, it might feel weird to work with it. During reordering,
    the user interface looks similar to the following screenshot:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 分类管理界面允许你展开或折叠分类。`indented_short_title` 列将返回分类的缩进短标题（如果有的话）或分类的缩进 Unicode 表示。定义为
    `actions_column` 的列将被渲染为拖放以重新排序或重构分类的手柄。由于拖动手柄位于不同于分类标题的列中，使用它可能会感觉有些奇怪。在重新排序过程中，用户界面看起来类似于以下截图：
- en: '![How it works...](img/B04912_08_05.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/B04912_08_05.jpg)'
- en: As you can see, it is possible to use all the list-related features of the default
    Django administration interface in the same view.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，你可以在同一视图中使用默认 Django 管理界面的所有列表相关功能。
- en: In `django-mptt-tree-editor`, the tree-editing functionality is ported from
    FeinCMS, another content management system made with Django.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在`django-mptt-tree-editor`中，树编辑功能是从另一个使用Django制作的CMS（内容管理系统）FeinCMS移植过来的。
- en: See also
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Creating hierarchical categories* recipe
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建层次类别*的配方'
- en: The *Creating a category administration interface with django-mptt-admin* recipe
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用django-mptt-admin创建类别管理界面*的配方'
- en: Rendering categories in a template
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在模板中渲染类别
- en: Once you have created categories in your app, you need to display them hierarchically
    in a template. The easiest way to do this is to use the `{% recursetree %}` template
    tag from the `django-mptt` app. I will show you how to do that in this recipe.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你在你的应用中创建了类别，你需要在模板中按层次结构显示它们。最简单的方法是使用`django-mptt`应用中的`{% recursetree %}`模板标签。我将在本配方中向你展示如何做到这一点。
- en: Getting ready
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Make sure that you have the `Category` model created and some categories entered
    in the database.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你已经创建了`Category`模型，并在数据库中输入了一些类别。
- en: How to do it...
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Pass `QuerySet` of your hierarchical categories to the template and then use
    the `{% recursetree %}` template tag as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 将你的层次类别`QuerySet`传递给模板，然后使用以下方式使用`{% recursetree %}`模板标签：
- en: 'Create a view that loads all the categories and passes them to a template:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个视图，加载所有类别并将它们传递给一个模板：
- en: '[PRE18]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Create a template with the following content:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含以下内容的模板：
- en: '[PRE19]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Create a URL rule to show the view.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个URL规则来显示视图。
- en: How it works...
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The template will be rendered as nested lists, as shown in the following screenshot:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 模板将被渲染为嵌套列表，如下面的截图所示：
- en: '![How it works...](img/B04912_08_06.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/B04912_08_06.jpg)'
- en: 'The `{% recursetree %}` block template tag takes `QuerySet` of the categories
    and renders the list using the template content in the tag. There are two special
    variables used here: `node` and `children`. The `node` variable is an instance
    of the `Category` model. You can use its fields or methods such as `{{ node.get_descendant_count
    }}`, `{{ node.level }}`, or `{{ node.is_root }}` to add specific CSS classes or
    HTML5 `data-*` attributes for JavaScript. The second variable, `children`, defines
    where to place the children of the current category.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`{% recursetree %}`模板标签块模板标签接受类别的`QuerySet`，并使用标签中的模板内容渲染列表。这里使用了两个特殊变量：`node`和`children`。`node`变量是`Category`模型的一个实例。你可以使用它的字段或方法，如`{{
    node.get_descendant_count }}`、`{{ node.level }}`或`{{ node.is_root }}`来添加特定的CSS类或HTML5
    `data-*`属性以供JavaScript使用。第二个变量`children`定义了当前类别子类的放置位置。'
- en: There's more...
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: If your hierarchical structure is very complex, with more than 20 depth levels,
    it is recommended to use the non-recursive template filter, `tree_info`. For more
    information on how to do this, refer to the official documentation at [http://django-mptt.github.io/django-mptt/templates.html#tree-info-filter](http://django-mptt.github.io/django-mptt/templates.html#tree-info-filter).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的层次结构非常复杂，有超过20个深度级别，建议使用非递归模板过滤器`tree_info`。有关如何做到这一点的更多信息，请参阅官方文档[http://django-mptt.github.io/django-mptt/templates.html#tree-info-filter](http://django-mptt.github.io/django-mptt/templates.html#tree-info-filter)。
- en: See also
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Using HTML5 data attributes* recipe in [Chapter 4](ch04.html "Chapter 4. Templates
    and JavaScript"), *Templates and JavaScript*
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第4章](ch04.html "第4章。模板和JavaScript") *模板和JavaScript* 中的*使用HTML5数据属性*配方
- en: The *Creating hierarchical categories* recipe
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建层次类别*的配方'
- en: The *Using a single selection field to choose a category in forms* recipe
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在表单中使用单选字段选择类别*的配方'
- en: Using a single selection field to choose a category in forms
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在表单中使用单选字段选择类别
- en: What happens if you want to show category selection in a form? How will the
    hierarchy be presented? In `django-mptt`, there is a special `TreeNodeChoiceField`
    form field that you can use to show the hierarchical structures in a selected
    field. Let's take a look at how to do this.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在表单中显示类别选择会发生什么？层次结构将如何呈现？在`django-mptt`中有一个特殊的`TreeNodeChoiceField`表单字段，你可以用它来在选择的字段中显示层次结构。让我们看看如何做到这一点。
- en: Getting ready
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will start with the `movies` app that we defined in the previous recipes.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从之前配方中定义的`movies`应用开始。
- en: How to do it...
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s create a form with the category field and then show it in a view:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个包含类别字段的表单，并在视图中显示它：
- en: 'In the `forms.py` file of the app, create a form with a category field as follows:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在应用的`forms.py`文件中，创建一个包含类别字段的表单，如下所示：
- en: '[PRE20]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Then, create a URL rule, view, and template to show this form.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，创建一个URL规则、视图和模板来显示这个表单。
- en: How it works...
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The category selection will look similar to the following:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 类别选择将类似于以下：
- en: '![How it works...](img/B04912_08_07.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/B04912_08_07.jpg)'
- en: The `TreeNodeChoiceField` acts like `ModelChoiceField`; however, it shows hierarchical
    choices as indented. By default, `TreeNodeChoiceField` represents each deeper
    level prefixed by three dashes, `---`. In our example, we will change the level
    indicator to be four nonbreakable spaces (the `&nbsp;` HTML entities) by passing
    the `level_indicator` parameter to the field. To ensure that the nonbreakable
    spaces aren't escaped, we use the `mark_safe()` function.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`TreeNodeChoiceField` 的行为类似于 `ModelChoiceField`；然而，它以缩进的形式显示层次选择。默认情况下，`TreeNodeChoiceField`
    使用三个连字符 `---` 作为每个更深层级的前缀。在我们的例子中，我们将通过将 `level_indicator` 参数传递给字段来更改级别指示符为四个非换行空格（`&nbsp;`
    HTML实体）。为了确保非换行空格不会被转义，我们使用了 `mark_safe()` 函数。'
- en: See also
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Using a checkbox list to choose multiple categories in forms* recipe
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在表单中使用复选框列表来选择多个类别* 的食谱'
- en: Using a checkbox list to choose multiple categories in forms
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在表单中使用复选框列表来选择多个类别
- en: When more than one category needs to be selected in a form, you can use the
    `TreeNodeMultipleChoiceField` multiple selection field that is provided by `django-mptt`.
    However, multiple selection fields are not very user-friendly from GUI point of
    view as the user needs to scroll and hold the control keys while clicking in order
    to make multiple choices. That's really awful. A much better way will be to provide
    a checkbox list to choose the categories. In this recipe, we will create a field
    that allows you to show the indented checkboxes in the form.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 当在表单中需要选择多个类别时，你可以使用由 `django-mptt` 提供的 `TreeNodeMultipleChoiceField` 多选字段。然而，从GUI的角度来看，多选字段并不非常用户友好，因为用户需要滚动并按住控制键同时点击才能进行多选。这真的很糟糕。一个更好的方法将是提供一个复选框列表来选择类别。在这个食谱中，我们将创建一个允许你在表单中显示缩进复选框的字段。
- en: Getting ready
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will start with the `movies` app that we defined in the previous recipes
    and also the `utils` app that you should have in your project.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从之前食谱中定义的 `movies` 应用程序开始，以及你应该在你的项目中拥有的 `utils` 应用程序。
- en: How to do it...
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To render an indented list of categories with checkboxes, create and use a
    new `MultipleChoiceTreeField` form field and also create an HTML template for
    this field. The specific template will be passed to the crispy forms layout in
    the form. To do this, perform the following steps:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 要渲染带有复选框的缩进类别列表，创建并使用一个新的 `MultipleChoiceTreeField` 表单字段，并为此字段创建一个HTML模板。具体的模板将传递到表单的crispy布局中。为此，执行以下步骤：
- en: 'In the `utils` app, add a `fields.py` file and create a `MultipleChoiceTreeField`
    form field that extends `ModelMultipleChoiceField`, as follows:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `utils` 应用中添加一个 `fields.py` 文件，并创建一个扩展 `ModelMultipleChoiceField` 的 `MultipleChoiceTreeField`
    表单字段，如下所示：
- en: '[PRE21]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Use the new field with the categories to choose from in the form for movie
    creation. Also, in the form layout, pass a custom template to the categories field,
    as shown in the following:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用新的带有类别选择的字段来在电影创建表单中选择。此外，在表单布局中，将自定义模板传递给类别字段，如下所示：
- en: '[PRE22]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Create a template for a Bootstrap-style checkbox list, as shown in the following:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个类似以下所示的Bootstrap风格的复选框列表模板：
- en: '[PRE23]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Create a URL rule, view, and template to show the form with the `{% crispy %}`
    template tag. To see how to use this template tag, refer to the *Creating a form
    layout with django-crispy-forms* recipe in [Chapter 3](ch03.html "Chapter 3. Forms
    and Views"), *Forms and Views*.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个URL规则、视图和模板，使用 `{% crispy %}` 模板标签来显示表单。要了解如何使用此模板标签，请参考[第3章](ch03.html
    "第3章。表单和视图")中的 *使用 django-crispy-forms 创建表单布局* 食谱。
- en: 'Lastly, add a rule to your CSS file to indent the labels with classes, such
    as `.level-0`, `.level-1`, `.level-2`, and so on, by setting the margin-left parameter.
    Make sure that you have a reasonable amount of these CSS classes for a possible
    maximal depth of the tree in your context, as follows:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在你的CSS文件中添加一个规则，通过设置 margin-left 参数来缩进具有类名的标签，例如 `.level-0`、`.level-1`、`.level-2`
    等。确保你有足够多的这些CSS类，以适应你上下文中可能的树的最大深度，如下所示：
- en: '[PRE24]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: How it works...
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'As a result, we get the following form:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们得到以下表单：
- en: '![How it works...](img/B04912_08_08.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/B04912_08_08.jpg)'
- en: Contrary to the default behavior of Django, which hardcodes field generation
    in the Python code, the `django-crispy-forms` app uses templates to render the
    fields. You can browse them under `crispy_forms/templates/bootstrap3` and copy
    some of them to an analogous path in your project's template directory and overwrite
    them when necessary.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 与Django的默认行为相反，Django在Python代码中硬编码了字段生成，而`django-crispy-forms`应用使用模板来渲染字段。您可以在`crispy_forms/templates/bootstrap3`下浏览它们，并将其中一些复制到您项目模板目录中的类似路径，并在必要时覆盖它们。
- en: In our movie creation form, we pass a custom template for the categories field
    that will add the `.level-*` CSS classes to the `<label>` tag, wrapping the checkboxes.
    One problem with the normal `CheckboxSelectMultiple` widget is that when rendered,
    it only uses choice values and choice texts, and in our case, we need other properties
    of the category such as the depth level. To solve this, we will created a custom
    `MultipleChoiceTreeField` form field, which extends `ModelMultipleChoiceField`
    and overrides the `label_from_instance` method to return the category itself instead
    of its Unicode representation. The template for the field looks complicated; however,
    it is just a combination of a common field template (`crispy_forms/templates/bootstrap3/field.html`)
    and multiple checkbox field template (`crispy_forms/templates/bootstrap3/layout/checkboxselectmultiple.html`),
    with all the necessary Bootstrap 3 markup. We just made a slight modification
    to add the `.level-*` CSS classes.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的电影创建表单中，我们为类别字段传递了一个自定义模板，该模板将为`<label>`标签添加`.level-*` CSS类，并包裹复选框。`CheckboxSelectMultiple`小部件的一个问题是，当渲染时，它只使用选择值和选择文本，而在我们的情况下，我们还需要其他属性，如类别深度级别。为了解决这个问题，我们将创建一个自定义的`MultipleChoiceTreeField`表单字段，它扩展了`ModelMultipleChoiceField`并重写了`label_from_instance`方法，以返回类别本身而不是其Unicode表示。字段的模板看起来很复杂；然而，它只是普通字段模板（`crispy_forms/templates/bootstrap3/field.html`）和多个复选框字段模板（`crispy_forms/templates/bootstrap3/layout/checkboxselectmultiple.html`）的组合，包含所有必要的Bootstrap
    3标记。我们只是稍作修改，添加了`.level-*` CSS类。
- en: See also
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Creating a form layout with django-crispy-forms* recipe in [Chapter 3](ch03.html
    "Chapter 3. Forms and Views"), *Forms and Views*
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第3章](ch03.html "第3章。表单和视图") *表单和视图* 中的 `Creating a form layout with django-crispy-forms`
    配方
- en: The *Using a single selection field to choose a category in forms* recipe
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用单个选择字段在表单中选择类别* 的配方'
