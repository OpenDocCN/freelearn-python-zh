- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: 'Raspberry Pi: An Introduction'
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Raspberry Pi：简介
- en: In previous chapters, we introduced the digital computer and explained its operation
    at the instruction set level. Now you will learn about a real, low-cost computer
    that was designed for educational purposes.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们介绍了数字计算机并解释了其在指令集级别的操作。现在你将了解一个为教育目的而设计的真实、低成本计算机。
- en: 'In this chapter, we introduce Raspberry Pi, which is based on the popular ARM
    microprocessor. We describe its instruction set architecture and demonstrate how
    you can use it to run assembly language programs in debugging mode. The highlights
    of this chapter are as follows:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍基于流行的 ARM 微处理器的 Raspberry Pi。我们描述了其指令集架构，并演示了如何使用它以调试模式运行汇编语言程序。本章的亮点如下：
- en: An introduction to Raspberry Pi’s operating system
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Raspberry Pi 操作系统简介
- en: Using the GCC ARM assembler and linker
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 GCC ARM 汇编器和链接器
- en: Debugging ARM assembly language programs
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试 ARM 汇编语言程序
- en: This is not a handbook for Raspberry Pi. We are interested only in using it
    to enter assembly language programs, run them, and observe their behavior. We
    do not cover Raspberry Pi’s Windows-style GUI because it is very similar to the
    corresponding PC and macOS user interfaces. Moreover, the Raspberry Pi operating
    system includes utilities and a web browser.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一本 Raspberry Pi 的手册。我们只对用它来编写汇编语言程序、运行它们并观察它们的行为感兴趣。我们不涵盖 Raspberry Pi 的
    Windows 风格 GUI，因为它与相应的 PC 和 macOS 用户界面非常相似。此外，Raspberry Pi 操作系统包括实用程序和网页浏览器。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'This chapter is based on the Raspberry Pi 4\. The software we use should also
    be compatible with the earlier 3B model. In order to use Raspberry Pi, you will
    need the following:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章基于 Raspberry Pi 4。我们使用的软件也应与早期的 3B 型号兼容。为了使用 Raspberry Pi，你需要以下设备：
- en: Raspberry Pi 4 (available with 2 GB, 4 GB, and 8 GB DRAM)
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Raspberry Pi 4（提供 2 GB、4 GB 和 8 GB DRAM）
- en: Raspberry Pi 5V 3A power supply
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Raspberry Pi 5V 3A 电源
- en: USB mouse
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: USB 鼠标
- en: USB keyboard
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: USB 键盘
- en: Wi-Fi internet connection
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Wi-Fi 互联网连接
- en: Video display with micro HDMI lead
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有微型 HDMI 线的视频显示器
- en: 32 GB Class 10 micro SD card pre-loaded with NOOBS (see the note at the end
    of this section)
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预装 NOOBS（32 GB Class 10 micro SD 卡）（见本节末尾的注释）
- en: All these items are available on Amazon or from Raspberry Pi suppliers. You
    can get the operating system pre-loaded onto a micro SD card, or download the
    operating system and preload it onto your own card using a PC or Mac. The Raspberry
    Pi web page at [https://www.raspberrypi.org/](https://www.raspberrypi.org/) provides
    full details about this computer including getting started, setting up, and loading
    the operating system on your own card.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些物品都可以在 Amazon 或 Raspberry Pi 供应商处购买。你可以将操作系统预装到微型 SD 卡上，或者下载操作系统并将其预装到自己的卡上，使用
    PC 或 Mac。Raspberry Pi 网页 [https://www.raspberrypi.org/](https://www.raspberrypi.org/)
    提供了关于此计算机的详细信息，包括入门、设置和将操作系统加载到自己的卡上。
- en: The text was written using **NOOBS** (**New Out Of the Box Software**). The
    Raspberry Pi Foundation no longer supports NOOBS and recommends that you download
    the latest version of the operating system using Raspberry Pi Imager, which runs
    under macOS, Windows, and Ubuntu. You can find the necessary information at [https://www.raspberrypi.org/](https://www.raspberrypi.org/).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 文本是用 **NOOBS**（**新开箱即用软件**）编写的。Raspberry Pi 基金会不再支持 NOOBS，并建议你使用运行在 macOS、Windows
    和 Ubuntu 下的 Raspberry Pi Imager 下载操作系统的最新版本。你可以在 [https://www.raspberrypi.org/](https://www.raspberrypi.org/)
    找到必要的信息。
- en: The ARM code we use in this book is designed to run on a Raspberry Pi with a
    32-bit operating system.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本书所使用的 ARM 代码是为在配备 32 位操作系统的 Raspberry Pi 上运行而设计的。
- en: Raspberry Pi basics
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Raspberry Pi 基础
- en: Microcomputers have been around since the 1970s. In the 1970s, several systems
    aimed at the enthusiast based on the Z80, 6502, and 6809 8-bit microprocessors
    appeared. Operating systems, apps, and the web didn’t exist then.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 微型计算机自 20 世纪 70 年代以来一直存在。在 20 世纪 70 年代，基于 Z80、6502 和 6809 8 位微处理器的几个针对爱好者的系统出现了。当时还没有操作系统、应用程序和互联网。
- en: Then, in the late 1970s, Intel introduced the 8086 and Motorola its 68000 16-bit
    CPU (the 68000 microprocessor actually had a 32-bit instruction set architecture,
    but Motorola marketed it initially as a 16-bit machine. In my view this was a
    catastrophic marketing mistake. 16-bit computers were a giant leap up from their
    8-bit predecessors for two reasons. First, the technology had advanced, permitting
    designers to put far more circuitry on a chip (i.e., more registers, more powerful
    instruction sets, etc.), and second, processors were far faster due to the reduction
    in feature size (i.e., smaller transistors). Finally, the declining cost of memory
    meant that people could run larger and more sophisticated programs.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在20世纪70年代末，Intel推出了8086，Motorola推出了其68000 16位CPU（实际上，68000微处理器具有32位指令集架构，但Motorola最初将其作为16位机器进行营销。在我看来，这是一个灾难性的营销错误。16位计算机相对于它们的8位前辈是一个巨大的飞跃，原因有两个。首先，技术进步，使得设计师能够在芯片上放置更多的电路（即，更多的寄存器、更强大的指令集等），其次，由于特征尺寸的减小（即，更小的晶体管），处理器速度更快。最后，内存成本的下降意味着人们可以运行更大、更复杂的程序。
- en: In the 1960s, the giant corporation IBM was famous for its large-scale data-processing
    machines. However, IBM wanted a change of direction and IBM’s engineers decided
    to build a PC around Motorola’s 68000 processor. Unfortunately for Motorola, a
    version of that chip wasn’t yet in production. Intel released the 8088, an 8-bit
    version of its 16-bit 8086 processor with an 8-bit data bus that made it easy
    to create a low-cost microcomputer using 8-bit peripherals and memory components.
    The 8088 still had a 16-bit architecture but was able to interface to 8-bit memory
    and I/O devices.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在20世纪60年代，IBM这家大型企业以其大规模数据处理机而闻名。然而，IBM希望改变方向，IBM的工程师决定围绕Motorola的68000处理器构建一台PC。不幸的是，那个芯片的版本尚未投产。Intel发布了8088，这是其16位8086处理器的8位版本，具有8位数据总线，这使得使用8位外围设备和内存组件创建低成本微机变得容易。8088仍然具有16位架构，但能够与8位内存和I/O设备接口。
- en: 'IBM formed a relationship with Intel, and the IBM PC in all its beige-colored
    splendor arose in 1981\. Unlike Apple, IBM created an open architecture that anyone
    could use without paying a royalty. And a million PC clones flowered. The rest
    is history. However, the PC and Apple’s Mac left a hole in the market: an ultra-low-cost
    computer that the young, the student, the experimenter, and the enthusiast can
    play with. Raspberry Pi plugs this gap.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: IBM与Intel建立了合作关系，并在1981年推出了所有米色系列的IBM PC。与Apple不同，IBM创建了一个开放架构，任何人都可以使用而不必支付版税。随后，数百万台PC克隆机应运而生。其余的都是历史。然而，PC和Apple的Mac在市场上留下了一个空缺：一种超低成本的电脑，年轻人、学生、实验者和爱好者都可以玩。树莓派填补了这一空缺。
- en: Low-cost computing has been around for a long time. For a few dollars, you can
    buy a greeting card that plays “Happy Birthday” when you open it. High-performance
    computing is more expensive. The cost of a computer often lies not in the processor
    but in the supporting cast of components and systems required to convert a microprocessor
    into a computer system – in particular, the graphics and display interface, the
    memory interface, and the communications interface (input/output). That’s why
    the Raspberry Pi has been such an amazing success. On a tiny, low-cost board,
    you have all the peripherals and interfaces that you need to create a complete
    system comparable to a PC (although not in terms of performance).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 低成本计算已经存在很长时间了。只需几美元，你就可以买到一张当你打开时播放“生日快乐”的贺卡。高性能计算更昂贵。电脑的成本往往不在于处理器，而在于将微处理器转换为电脑系统所需的辅助组件和系统——特别是图形和显示接口、内存接口和通信接口（输入/输出）。这就是为什么树莓派如此成功的原因。在一块小巧、低成本的板上，你拥有创建一个与PC相当（尽管在性能方面不相上下）的完整系统所需的所有外围设备和接口。
- en: To turn the board into a fully-fledged microcomputer, you need only a low-cost
    power supply and the very same mouse and keyboard you would use with a PC. Indeed,
    many people use peripherals left over from PCs and other computers they have lying
    around. I bought a 2-to-1 HDMI switch to interface my 4K monitor to both my PC
    and Raspberry Pi. You just press a button and the display switches from PC to
    Raspberry Pi. The Raspberry Pi uses an open source operating system with vast
    amounts of free software. No more having to take out a mortgage for Office or
    Photoshop.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 要将板子变成一个功能齐全的微型计算机，你只需要一个低成本电源和与PC相同的鼠标和键盘。事实上，许多人使用从PC和其他他们放在那里的计算机中遗留的周边设备。我购买了一个2到1的HDMI切换器，将我的4K显示器连接到我的PC和Raspberry
    Pi。你只需按下一个按钮，显示屏就会从PC切换到Raspberry Pi。Raspberry Pi使用开源操作系统，拥有大量的免费软件。不再需要为Office或Photoshop贷款。
- en: The Raspberry Pi was an outstanding success and rapidly created a very large
    and enthusiastic following. It found applications at all levels of education from
    kindergarten to PhD. Over the years, improved versions of Raspberry Pi were introduced,
    as well as truly minimal versions that could be used as dedicated embedded processors
    for a few dollars.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Raspberry Pi取得了卓越的成功，并迅速创造了一个庞大而热情的追随者群体。它在从幼儿园到博士的所有教育层次上都有应用。多年来，推出了Raspberry
    Pi的改进版本，以及真正最小化的版本，可以用几美元的价格作为专用嵌入式处理器使用。
- en: '*Figure 9**.1* illustrates the Raspberry Pi 4 that was used while writing this
    book. The first Raspberry Pi Model B appeared in 2012 with 256 MB of DRAM, USB
    ports, and Ethernet, but no wireless communications. By 2019, the Raspberry Pi
    4 was available with 2 USB 2.0 and 2 USB 3.0 ports, on-board Wi-Fi 502.11ac, Bluetooth
    5, and Gigabit Ethernet, plus dual-monitor support via 2 micro HDMI ports capable
    of supporting 4K displays. The principal features of the RPi 4 are as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9.1* 展示了在撰写本书时使用的Raspberry Pi 4。第一个Raspberry Pi Model B于2012年出现，具有256 MB的DRAM、USB端口和以太网，但没有无线通信。到2019年，Raspberry
    Pi 4配备了2个USB 2.0和2个USB 3.0端口，板载Wi-Fi 802.11ac、蓝牙5和千兆以太网，以及通过2个支持4K显示的micro HDMI端口的双显示器支持。RPi
    4的主要特点如下：'
- en: The powerful ARM CPU (Quad core Cortex-A72 64-bit architecture)
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强大的ARM CPU（四核Cortex-A72 64位架构）
- en: Audio (sound processing system)
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 音频（声音处理系统）
- en: Video display and graphics logic system (you just need to plug the card into
    a monitor)
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视频显示和图形逻辑系统（你只需将卡插入显示器）
- en: DRAM main memory (2, 4, or 8 GB)
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DRAM主存储器（2、4或8 GB）
- en: Non-volatile flash memory with the operating system (not normally included)
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带操作系统的非易失性闪存（通常不包括）
- en: Mouse and keyboard USB ports
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 鼠标和键盘USB端口
- en: Wi-Fi (both 2.4 and 5.0 GHz bands)
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Wi-Fi（2.4和5.0 GHz频段）
- en: Bluetooth 5.0
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 蓝牙5.0
- en: Ethernet port
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以太网端口
- en: A general I/O port for directly interfacing with external hardware
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个通用I/O端口，可以直接与外部硬件接口
- en: '![Figure 9.1 – The Raspberry Pi 4 (Image by Laserlicht / Wikimedia Commons
    / CC BY-SA 4.0)](img/Figure_9.01_B19624.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图9.1 – Raspberry Pi 4（图片由Laserlicht / Wikimedia Commons / CC BY-SA 4.0提供）](img/Figure_9.01_B19624.jpg)'
- en: Figure 9.1 – The Raspberry Pi 4 (Image by Laserlicht / Wikimedia Commons / CC
    BY-SA 4.0)
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1 – Raspberry Pi 4（图片由Laserlicht / Wikimedia Commons / CC BY-SA 4.0提供）
- en: The Raspberry Pi board is not normally sold with an operating system. It has
    a micro-SD port into which you have to insert a memory card containing a suitable
    operating system. You can buy a card with the OS already installed, or load one
    of the freely available variants from the web onto a card (using your PC or Mac)
    and plug it into the Raspberry Pi.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Raspberry Pi板通常不附带操作系统。它有一个微SD端口，你必须插入一个包含合适操作系统的内存卡。你可以购买一个已经安装了操作系统的卡，或者从网上下载一个免费可用的变体（使用你的PC或Mac）并将其加载到卡上，然后插入Raspberry
    Pi。
- en: The classic operating system used by computer scientists in academia is Unix,
    which was developed at AT&T’s Bell Labs in the late 1960s by a team that included
    Ken Thomson and Dennis Richie (two of the most significant players in computer
    science history). Unix was one of the first operating systems to become portable
    – that is, to run on different types of computers.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 学术界计算机科学家使用的经典操作系统是Unix，该系统于20世纪60年代末在AT&T的贝尔实验室开发，由包括Ken Thomson和Dennis Ritchie（计算机科学史上两位最杰出的玩家）在内的团队开发。Unix是第一个成为可移植的操作系统之一——也就是说，可以在不同类型的计算机上运行。
- en: A strong thread in the history of computer science is open software – that is,
    software developed by a community of individuals that is freely available, such
    as the Python programming language and the LibreOffice application package, which
    provides much of the functionality of Microsoft’s Office suite.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机科学史上的一个强有力线索是开源软件——即由一个个人社区开发的免费软件，如Python编程语言和LibreOffice应用程序包，后者提供了微软Office套件的大部分功能。
- en: In the 1980s, the Free Software Foundation led by Richard Stillman led the development
    of the GNU operating system, which was designed to provide an open source version
    of Unix. In 1991, Linus Torvalds released an open source component of GNU, its
    kernel, called Linux.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在20世纪80年代，由理查德·斯蒂尔曼领导的自由软件基金会推动了GNU操作系统的开发，该系统旨在提供Unix的开源版本。1991年，林纳斯·托瓦兹发布了GNU的一个开源组件，即其内核，称为Linux。
- en: Today, the Linux kernel plus the GNU tools and compilers have become a free,
    open source alternative to proprietary operating systems such as Windows. GNU/Linux
    is available in different flavors (distributions written by various groups with
    the same basic structure but different features). The original official Raspberry
    Pi operating system was called *Raspbian* and is based on a version of Debian
    Linux optimized for Raspberry Pi.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，Linux内核加上GNU工具和编译器已成为Windows等专有操作系统的免费、开源替代品。GNU/Linux有不同的风味（由不同组编写的具有相同基本结构但不同功能的发行版）。原始官方树莓派操作系统被称为*Raspbian*，基于为树莓派优化的Debian
    Linux版本。
- en: Unix and Linux operate in a *command-line mode* – that is, operating system
    instructions are entered in text form (just like Microsoft’s DOS). Unix, Linux,
    and DOS all now have user-friendly graphical inputs that make use of the mouse
    as a key input device. The most famous of these graphical inputs is Microsoft’s
    Windows operating system.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Unix和Linux以*命令行模式*运行——即操作系统指令以文本形式输入（就像微软的DOS一样）。现在，Unix、Linux和DOS都有用户友好的图形输入，利用鼠标作为主要输入设备。其中最著名的是微软的Windows操作系统。
- en: Raspberry Pi now includes both a Windows-based version of Linux and a text-based
    command-line interface that is used to invoke some of the tools required to assemble
    and execute ARM assembly language programs. This chapter provides a very short
    introduction to RPi’s Linux operating system.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 树莓派现在包括基于Windows的Linux版本和基于文本的命令行界面，用于调用汇编和执行ARM汇编语言程序所需的工具。本章提供了对树莓派Linux操作系统的简要介绍。
- en: The Raspberry Pi operating system includes several packages that are very relevant
    to this book. For example, the Thonny Python IDE provides an **integrated development
    environment** (**IDE**) for Python and software to edit, assemble, debug, and
    run Python programs.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 树莓派操作系统包括几个与本书非常相关的软件包。例如，Thonny Python IDE为Python提供了一个**集成开发环境**（**IDE**），以及用于编辑、汇编、调试和运行Python程序的软件。
- en: Another useful package is the Geany editor, which has built-in support for more
    than 50 programming languages. You can get Geany at [https://www.geany.org/](https://www.geany.org/).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的软件包是Geany编辑器，它内置了对50多种编程语言的支持。您可以在[https://www.geany.org/](https://www.geany.org/)获取Geany。
- en: There is also a Terminal emulator window that lets you operate in the Linux
    command-line mode – a feature that is useful when working with the ARM assembly
    language utilities. *Figure 9**.2* shows the Raspberry Pi screen on a 4K monitor
    with several windows open.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个终端模拟器窗口，允许您在Linux命令行模式下操作——当使用ARM汇编语言工具时，这是一个有用的功能。*图9.2*显示了在4K显示器上打开多个窗口的树莓派屏幕。
- en: '![Figure 9.2 – Screenshot of Raspberry Pi’s multiple windows](img/Figure_9.02_B19624.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图9.2 – 树莓派多个窗口的截图](img/Figure_9.02_B19624.jpg)'
- en: Figure 9.2 – Screenshot of Raspberry Pi’s multiple windows
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2 – 树莓派多个窗口的截图
- en: While writing this book, I was also introduced to Visual Studio Code, which
    is an editor and debugging platform. Visual Studio Code is free and available
    on Linux, macOS, and Windows platforms. *Figure 9**.3* shows an example of a session
    using Visual Studio Code to write a Python program.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写这本书的过程中，我还接触到了Visual Studio Code，这是一个编辑和调试平台。Visual Studio Code是免费的，可在Linux、macOS和Windows平台上使用。*图9.3*显示了使用Visual
    Studio Code编写Python程序的一个示例会话。
- en: '![Figure 9.3 – A VS Code session while developing a Python program](img/Figure_9.03_B19624.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图9.3 – 开发Python程序时的VS Code会话](img/Figure_9.03_B19624.jpg)'
- en: Figure 9.3 – A VS Code session while developing a Python program
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3 – 开发Python程序时的VS Code会话
- en: I must thank Graeme Harker for encouraging me to use VS Code. Had I discovered
    VS Code earlier, I would probably have stuck to that.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我必须感谢Graeme Harker鼓励我使用VS Code。如果我能早点发现VS Code，我可能就会坚持使用它。
- en: Now that we’ve introduced the ubiquitous Raspberry Pi that can form the basis
    of a computer system with the addition of a mouse, keyboard, and display, we are
    going to introduce its operating system.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了无处不在的Raspberry Pi，它可以与鼠标、键盘和显示器一起组成一个计算机系统的基础，我们将介绍其操作系统。
- en: However, we do not delve too deeply. In order to use the Raspberry Pi to enter,
    run, and debug ARM assembly language, you need to know only a few basic elements
    of the operating system. Moreover, even though the Raspberry Pi has a Unix-based
    command-line operating system, it includes a graphical interface that behaves
    very much like Windows or macOS.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们不会深入探讨。为了使用Raspberry Pi进入、运行和调试ARM汇编语言，您只需要了解操作系统的一些基本元素。此外，尽管Raspberry
    Pi有一个基于Unix的命令行操作系统，但它包括一个与Windows或macOS非常相似的图形界面。
- en: Basics of the Raspberry Pi operating system
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Raspberry Pi操作系统基础
- en: In this section, you will learn how to use the Raspberry Pi to create an ARM
    assembly language program, assemble it into code that can be executed, and then
    run it on the Raspberry Pi. In the next chapter, we will look at the ARM architecture
    in greater depth.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将学习如何使用Raspberry Pi创建ARM汇编语言程序，将其汇编成可执行的代码，然后在Raspberry Pi上运行它。在下一章中，我们将更深入地探讨ARM架构。
- en: We do not devote much time discussing RPi’s operating system because the world
    is full of websites devoted to Linux. We will cover the absolute minimum to help
    you use some of the commands that may be helpful. Most readers will use a graphical
    interface to perform editing, web searches, and running programs such as Python.
    We will introduce the basic concepts of Linux’s filing system and the command-line
    instruction necessary to assemble and run a source file written in the ARM assembly
    language. Unfortunately, the names of Unix/Linux commands are not intuitive.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会花太多时间讨论RPi的操作系统，因为世界上充满了专注于Linux的网站。我们将涵盖绝对最小内容，以帮助您使用一些可能有用的命令。大多数读者将使用图形界面进行编辑、网络搜索和运行Python等程序。我们将介绍Linux文件系统的基本概念以及用于组装和运行用ARM汇编语言编写的源文件的命令行指令。不幸的是，Unix/Linux命令的名称并不直观。
- en: '*Figure 9**.4* illustrates the basic concepts of the Linux hierarchical operating
    system, with a node at each level that can support *child* nodes at a lower level;
    for example, `Desktop` is a child of the `pi` node.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9**.4* 展示了Linux分层操作系统的基本概念，每个级别都有一个节点可以支持较低级别的*子节点*；例如，`Desktop`是`pi`节点的子节点。'
- en: '![Figure 9.4 – The Raspberry Pi file structure](img/Figure_9.04_B19624.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图9.4 – Raspberry Pi文件结构](img/Figure_9.04_B19624.jpg)'
- en: Figure 9.4 – The Raspberry Pi file structure
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.4 – Raspberry Pi文件结构
- en: The top-level folder is `/` and is called the *root folder*. The `/` backslash
    is used to navigate the filing system very much like the Windows equivalent. A
    big difference between Linux and Windows is that, in Linux, you don’t have to
    specify the disk on which the file resides (e.g., Windows invariably uses `c:/`
    for operating systems files). In *Figure 9**.4*, the `MyFile.doc` file is a text
    file whose location is `/home/pi/Documents/MyFile.doc.`
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 最高级文件夹是`/`，称为*根文件夹*。`/`反斜杠用于在文件系统中导航，与Windows的等效方式非常相似。Linux和Windows之间的一大区别是，在Linux中，您不需要指定文件所在的磁盘（例如，Windows始终使用`c:/`作为操作系统文件）。在*图9**.4*中，`MyFile.doc`文件是一个文本文件，其位置是`/home/pi/Documents/MyFile.doc.`
- en: Directory navigation
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目录导航
- en: 'If you press the enter key, Raspberry Pi responds with an “*I am here*” prompt,
    as shown in this example:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您按下回车键，Raspberry Pi会响应一个“*我在这里*”提示，如本例所示：
- en: '`pi@raspberrypi:`/var/log/apt $'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`pi@raspberrypi:/var/log/apt $`'
- en: 'This prompt gives the device name and the path to the current directory (in
    bold font in this example). You can change the active directory with the `cd`
    (*change directory*) command, as shown in this example:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 此提示显示了设备名称和当前目录的路径（在本例中以粗体字体显示）。您可以使用`cd`（*更改目录*）命令更改活动目录，如本例所示：
- en: '[PRE0]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: To list the files and subdirectories in the current directory, you can use the
    `ls` command (*list files*).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 要列出当前目录中的文件和子目录，您可以使用`ls`命令（*列出文件*）。
- en: The `ls` -l /home/pi command generates the following output that gives permissions
    (what you can do with them), their size, and creation dates. *Figure 9**.5* demonstrates
    this command.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`ls -l /home/pi` 命令生成以下输出，显示权限（你可以做什么），大小和创建日期。*图 9*.*5* 展示了这个命令。'
- en: '![Figure 9.5 – The Raspberry Pi File Structure](img/Figure_9.05_B19624.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.5 – Raspberry Pi 文件结构](img/Figure_9.05_B19624.jpg)'
- en: Figure 9.5 – The Raspberry Pi File Structure
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.5 – Raspberry Pi 文件结构
- en: The `ls` command has several options; for example, `ls ~` indicates a list in
    the home directory. In Linux, the tilda`, ~,` indicates the home directory. Similarly,
    `ls –t` indicates list files by date and time created.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`ls` 命令有多个选项；例如，`ls ~` 表示列出主目录中的内容。在 Linux 中，波浪号 `~` 表示主目录。同样，`ls –t` 表示按日期和时间创建的文件列表。'
- en: File operations
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件操作
- en: We now introduce some of Linux’s basic file commands. The `pwd` command looks
    as if it should mean *password*. Actually, it means *print working directory*
    and displays the contents of the current directory. It’s a “*where am I?*” command.
    Entering `pwd` will generate a response such as `/home/pi`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们介绍一些 Linux 的基本文件命令。`pwd` 命令看起来像应该意味着 *密码*。实际上，它意味着 *打印工作目录* 并显示当前目录的内容。这是一个“*我在哪里？*”命令。输入
    `pwd` 将生成类似 `/home/pi` 的响应。
- en: To create a new subdirectory, you use the `mkdir` command. Typing `mkdir` `newFolder`
    creates a subdirectory called `newFolder` in the current directory.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个新的子目录，你使用 `mkdir` 命令。输入 `mkdir newFolder` 将在当前目录下创建一个名为 `newFolder` 的子目录。
- en: If you enter `mkdir /home/pi/newFolder`, it will create the subdirectory in
    `pi`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你输入 `mkdir /home/pi/newFolder`，它将在 `pi` 目录下创建一个子目录。
- en: One of Linux’s more confusing command names is `cat`, which lists the contents
    of a file. The name `cat` means `catalog`; for example, `cat /home/pi/firstExample.txt`
    displays the contents of the `firstExample.txt` file on the console as a text
    file.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 中比较容易混淆的命令名之一是 `cat`，它列出文件的内容。`cat` 的意思是 `catalog`；例如，`cat /home/pi/firstExample.txt`
    将在控制台上以文本文件的形式显示 `firstExample.txt` 文件的内容。
- en: To delete or *remove* a file, you use `rm`; for example, `rm tempData.py` deletes
    the `tempData.py` file in the current subdirectory. You can remove an entire directory
    with `rm -r`. This deletes the current directory and is not reversible. It is
    a dangerous command. The alternative is `rm –d`, which removes the current directory
    *only if it is empty* (i.e., you must first delete its contents).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除或*移除*一个文件，你使用 `rm`；例如，`rm tempData.py` 删除当前子目录中的 `tempData.py` 文件。你可以使用 `rm
    -r` 删除整个目录。这将删除当前目录且不可逆。这是一个危险的命令。另一种选择是 `rm –d`，它仅当目录为空时（即，你必须首先删除其内容）才会删除当前目录。
- en: Linux has a help command, `man` (i.e., manual) that provides details of another
    command; for example, `man ls` would provide details of the `ls` command.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 有一个帮助命令 `man`（即手册），它提供另一个命令的详细信息；例如，`man ls` 将提供 `ls` 命令的详细信息。
- en: In general, when working with Raspberry Pi, most users will be using the graphical
    interface. However, we will be using the command-line input to set up the Raspberry
    Pi and assemble, debug, and execute assembly language programs.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当使用 Raspberry Pi 时，大多数用户都会使用图形界面。然而，我们将使用命令行输入来设置 Raspberry Pi 并组装、调试和执行汇编语言程序。
- en: Installing and updating programs and packages
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装和更新程序和软件包
- en: 'Having set up the RPi, you need to maintain it (i.e., install and update software).
    The following two commands retrieve new packages and update your software. It’s
    a good idea to run them occasionally to get new updates. Note that `sudo` stands
    for *superuser do* and is required for operations that may be restricted to the
    administrator because they can harm the system if used inappropriately. The term
    `aptget` obtains and installs packages (`apt = Advanced` `Package Tool`):'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 设置好 RPi 后，你需要维护它（即安装和更新软件）。以下两个命令检索新软件包并更新你的软件。偶尔运行它们以获取新更新是个好主意。注意，`sudo` 代表
    *超级用户执行*，对于可能仅限于管理员操作的操作是必需的，因为如果不当使用可能会损害系统。术语 `aptget` 获取并安装软件包（`apt = Advanced
    Package Tool`）：
- en: '[PRE1]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: sudo apt-get update updates packages but does not install them.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`sudo apt-get update` 更新软件包但不安装它们。'
- en: To install a new package on Raspberry Pi, you use the `apt-get install` command;
    for example,
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Raspberry Pi 上安装新软件包，你使用 `apt-get install` 命令；例如，
- en: '`sudo apt-get install vim` installs the `vim` editor package.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`sudo apt-get install vim` 安装 `vim` 编辑器软件包。'
- en: 'Linux provides a shutdown command that ends a session in an orderly manner:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 提供了一个关机命令，可以有序地结束会话：
- en: '`sudo shutdown -h now     Stop` and enter the halt state'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`sudo shutdown -h now` 停止并进入挂起状态'
- en: 'The `-h` parameter indicates *enter the halt state*, and the `now` parameter
    indicates an immediate halt. A command to shut down is `sudo shutdown -r now`.
    To reboot Raspberry Pi, you can enter either of the following two commands. These
    commands have the same effect on a single-user system. You would use `shutdown
    -r` on a multi-user system:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`-h`参数表示*进入停止状态*，而`now`参数表示立即停止。关闭系统的命令是`sudo shutdown -r now`。要重启Raspberry
    Pi，你可以输入以下两个命令中的任意一个。这些命令在单用户系统上具有相同的效果。在多用户系统上，你会使用`shutdown -r`：'
- en: '[PRE2]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: However, most Raspberry Pi users will shut down Raspberry Pi using a mouse from
    its GUI. Indeed, the only time it’s necessary to use the text-based input mode
    is when assembling, linking, and debugging assembly language programs.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，大多数Raspberry Pi用户将使用鼠标从其GUI关闭Raspberry Pi。确实，只有在汇编、链接和调试汇编语言程序时才需要使用基于文本的输入模式。
- en: You can apply a delayed shutdown; for example, sudo shutdown -h 30 will shut
    down the RPi after 30 minutes. You can shut down at a specific clock time with,
    say, sudo shutdown -h 22:30, which shuts down at 10:30 P.M. A delayed shutdown
    command can be rescinded (canceled) by sudo shutdown -c.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以应用延迟关闭；例如，`sudo shutdown -h 30`将在30分钟后关闭RPi。你可以使用，例如，`sudo shutdown -h 22:30`在特定时钟时间关闭，这将在大约晚上10:30关闭。可以通过`sudo
    shutdown -c`撤销（取消）延迟关闭命令。
- en: Creating and editing an assembly language program
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建和编辑汇编语言程序
- en: Let’s go through the steps needed to create an ARM program on the Raspberry
    Pi and then execute it before we look at the ARM processor in greater detail.
    Although we haven’t introduced the ARM assembly language yet, the actions of the
    instructions we use are self-evident.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们更详细地查看ARM处理器之前，让我们通过在Raspberry Pi上创建并执行ARM程序所需的步骤来了解一下。尽管我们还没有介绍ARM汇编语言，但我们使用的指令的动作是显而易见的。
- en: First, you have to create an assembly language program in text form with a `.s`
    file type. There are many text editors and the one you choose is a personal preference.
    I initially used Geany, which is an IDE for languages such as C. I later used
    Thonny on my desktop PC. Both Geany and Thonny are excellent tools. If you create
    a text file on a desktop PC (or any other device), you simply change the `.txt`
    extension to `.s` to make it compatible with RPi’s assembler.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你必须以文本形式创建一个`.s`文件类型的汇编语言程序。有许多文本编辑器，你选择的编辑器是个人喜好。我最初使用Geany，它是一个用于C语言等语言的IDE。后来我在我的台式PC上使用了Thonny。Geany和Thonny都是优秀的工具。如果你在台式PC（或任何其他设备）上创建一个文本文件，你只需将`.txt`扩展名更改为`.s`，使其与RPi的汇编器兼容。
- en: '*Figure 9**.6* shows the initial Geany screen:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9**.6* 展示了初始的Geany屏幕：'
- en: '![Figure 9.6 – Geany text editor window](img/Figure_9.06_B19624.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图9.6 – Geany文本编辑器窗口](img/Figure_9.06_B19624.jpg)'
- en: Figure 9.6 – Geany text editor window
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.6 – Geany文本编辑器窗口
- en: '*Figure 9**.7* shows a Geany window after we’ve created an ARM assembly language
    program:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9**.7* 展示了创建ARM汇编语言程序后的Geany窗口：'
- en: '![Figure 9.7 – Geany window – note that add r3,r0,r1 adds r0 to r1 and puts
    the sum in r0](img/Figure_9.07_B19624.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图9.7 – Geany窗口 – 注意到`add r3,r0,r1`是将`r0`加到`r1`上，并将和存储在`r0`中](img/Figure_9.07_B19624.jpg)'
- en: Figure 9.7 – Geany window – note that add r3,r0,r1 adds r0 to r1 and puts the
    sum in r0
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.7 – Geany窗口 – 注意到`add r3,r0,r1`是将`r0`加到`r1`上，并将和存储在`r0`中
- en: 'In the following program, the text in bold font indicates an assembler directive
    that tells the assembler about the program’s environment and how to deal with
    the allocation of memory space:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下程序中，粗体字体的文本表示一个汇编器指令，它告诉汇编器有关程序的环境以及如何处理内存空间的分配：
- en: '[PRE4]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note that ARM uses `mov` to load a literal and not `ldr` (as you might expect).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到ARM使用`mov`来加载一个字面量，而不是`ldr`（正如你可能预期的）。
- en: Assembling ARM code
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 汇编ARM代码
- en: Before we can look at the ARM architecture in depth, we will demonstrate how
    you write a program and run it. The Raspberry Pi’s Debian-based operating system
    includes GCC, the *GNU Compiler Collection*, which can compile both C programs
    and assembly language programs. We do not deal with C here.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够深入查看ARM架构之前，我们将演示如何编写程序并运行它。基于Debian的Raspberry Pi操作系统包括GCC，即*GNU编译器集合*，它可以编译C程序和汇编语言程序。我们在这里不处理C。
- en: 'The two GCC commands we need to assemble the source `myProg.s` text file are
    as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要使用以下两个GCC命令来汇编源文件`myProg.s`文本：
- en: '[PRE5]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The first command, `as`, takes the assembly language *source* file, `myProg.s`,
    and creates an *object* code file, `myProg.o`. The second command, `ld`, invokes
    a *linker* that uses the object file to create a binary code file, `myProg`, that
    can be executed. The `-o` option is necessary to build an output file. You can
    then run the assembled binary code program by typing `./myProg`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个命令 `as` 会将汇编语言源文件 `myProg.s` 转换为目标代码文件 `myProg.o`。第二个命令 `ld` 会调用一个链接器，该链接器使用目标文件创建一个可执行的二进制代码文件
    `myProg`，它可以被执行。`-o` 选项是构建输出文件所必需的。然后你可以通过输入 `./myProg` 来运行汇编的二进制代码程序。
- en: Although a *single* assembly language program can be assembled to create binary
    code, programs are often written in modules (files) that are fitted together.
    These files may be written by different programmers or even library programs.
    They are individually assembled to create files that the linker combines to create
    the final binary code that can be executed. In this text, we do not make full
    use of the linker’s facilities; all assembly language programs are single files.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然单个汇编语言程序可以被汇编成二进制代码，但程序通常是以模块（文件）的形式编写的，这些模块被组合在一起。这些文件可能由不同的程序员编写，甚至可能是库程序。它们被单独汇编成文件，然后链接器将这些文件组合起来创建最终的二进制代码，该代码可以被执行。在本文本中，我们没有充分利用链接器的功能；所有汇编语言程序都是单个文件。
- en: 'Following the linking operation, an executable binary program is created. Let’s
    now type the following:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在链接操作之后，会创建一个可执行的二进制程序。现在让我们输入以下内容：
- en: '`./myProg ;` `echo $?`'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`./myProg ;` `echo $?`'
- en: The `myProg` binary code is executed and a message is displayed. A semicolon
    in Linux allows two commands to be put on the same line; the two operations are
    *execute a program* and *display* *a message*.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`myProg` 二进制代码被执行，并显示一条消息。在 Linux 中，分号允许将两个命令放在同一行上；这两个操作是 *执行程序* 和 *显示消息*。'
- en: The `echo $?` command prints a message from the executed program. The print
    command is `echo` and `$?` indicates the actual message to be printed. In this
    case, the `$?` command returns the exit status of the last command. You can print
    other messages; for example, `$3` prints the contents of register `r3`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`echo $?` 命令会打印出执行程序的输出信息。打印命令是 `echo`，而 `$?` 表示要打印的实际信息。在这种情况下，`$?` 命令返回的是上一个命令的退出状态。你也可以打印其他信息；例如，`$3`
    会打印寄存器 `r3` 的内容。'
- en: Note that if a program crashes or goes into an endless loop (non-responsive),
    you can enter `control-C` to escape and return to the OS level.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果程序崩溃或进入无限循环（无响应），你可以输入 `control-C` 来退出并返回到操作系统级别。
- en: Debugging assembly language
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 汇编语言调试
- en: We will now introduce the ARM debugger that lets you monitor the execution of
    a program and trace code just as we did with the simulators of [*Chapter 6*](B19624_06.xhtml#_idTextAnchor091)
    and [*Chapter 7*](B19624_07.xhtml#_idTextAnchor121).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将介绍 ARM 调试器，它允许你监控程序的执行并跟踪代码，就像我们在 [*第6章*](B19624_06.xhtml#_idTextAnchor091)
    和 [*第7章*](B19624_07.xhtml#_idTextAnchor121) 的模拟器中所做的那样。
- en: 'What we want is the ability to monitor the execution of an assembly language
    program, a task that we’ve already done when running Python computer simulators.
    We can do this with a *debugger*, called `gdb`, which is part of the GCC compiler
    suite. Consider the following example:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要的是监控汇编语言程序执行的能力，这项任务我们在运行 Python 计算机模拟器时已经完成。我们可以使用一个名为 `gdb` 的调试器来完成这项任务，它是
    GCC 编译器套件的一部分。考虑以下示例：
- en: '[PRE6]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `-g` parameter in the assembler section generates information for later
    use by the `gdb` debugger.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 汇编器部分的 `-g` 参数会生成供后续 `gdb` 调试器使用的调试信息。
- en: '`gdb` is a very powerful tool with the facilities required to debug a program.
    We are going to look at only these facilities that allow us to run an ARM assembly
    language program and observe its execution, line by line. We begin by listing
    some of `gdb`’s commands. These commands can be abbreviated; for example, the
    `quit` command can be entered as q. In *Table 9.1*, we put the required part of
    the command in bold, and the part of the command that can be omitted in gray,
    such as quit. Note the difference between `next` and `step`. These are the same
    except when they encounter a *function*. Step traces all the operations in a function,
    whereas next treats the function as a single instruction and does not trace it.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`gdb`是一个功能强大的工具，具有调试程序所需的设施。我们将只查看这些允许我们运行ARM汇编语言程序并逐行观察其执行的设施。我们首先列出一些`gdb`的命令。这些命令可以缩写；例如，`quit`命令可以输入为q。在*表9.1*中，我们将命令的必要部分用粗体表示，可以省略的部分用灰色表示，例如quit。注意`next`和`step`之间的区别。这两个命令除了遇到*函数*时外是相同的。Step跟踪函数中的所有操作，而next将函数视为一条单独的指令，并且不跟踪它。'
- en: When you load a program into `gdb`, nothing appears to happen. If you try to
    look at your assembly language code or the registers, you will get an error message.
    You must explicitly run the program first.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将程序加载到`gdb`中时，似乎没有任何事情发生。如果你尝试查看你的汇编语言代码或寄存器，你会得到一个错误信息。你必须首先明确地运行程序。
- en: '| **Command** | **Effect** |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| **命令** | **效果** |'
- en: '| --- | --- |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| quit | Quit: leave the gdb debugger and return to the shell. Ctrl + D also
    exits gdb. |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| quit | 退出：离开gdb调试器并返回到shell。Ctrl + D也可以退出gdb。 |'
- en: '| list | List: list the program being debugged. |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| list | 列出：列出正在调试的程序。 |'
- en: '| run | Run: execute the program. The program will run to completion or to
    a breakpoint. |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| run | 运行：执行程序。程序将运行至完成或遇到断点。 |'
- en: '| break | Breakpoint: Execution runs until a breakpoint is encountered. The
    breakpoint can be a line number, an address, or a label. |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| break | 断点：执行遇到断点时停止。断点可以是行号、地址或标签。 |'
- en: '| info r | Info: show registers. This command displays register contents. |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| info r | 信息：显示寄存器。此命令显示寄存器内容。 |'
- en: '| info b | Info: show breakpoints. This displays breakpoints. |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| info b | 信息：显示断点。此显示断点。 |'
- en: '| continue | Continue: resume execution after a breakpoint. |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| continue | 继续：在断点后恢复执行。 |'
- en: '| delete | Delete: remove a breakpoint. Enter `d <number>` to remove a specific
    breakpoint. |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| delete | 删除：移除断点。输入`d <number>`以移除特定的断点。 |'
- en: '| next | Single step (execute one instruction). This does not trace a function.
    |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| next | 单步执行（执行一条指令）。这不会跟踪函数。 |'
- en: '| step | Single step including all the operations in a function. |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| step | 单步执行包括函数中的所有操作。 |'
- en: '| file <name> | Load a binary code file into gdb for debugging. |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| file <name> | 将二进制代码文件加载到gdb中进行调试。 |'
- en: Table 9.1 – Basic gdb commands
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 表9.1 – 基本gdb命令
- en: Let’s write and debug an ARM program on the Raspberry Pi. We haven’t covered
    the ARM architecture yet. You don’t need to know a lot about the ARM to follow
    the example because it’s similar to the RISC architectures we simulated in [*Chapter
    6*](B19624_06.xhtml#_idTextAnchor091). The ARM is a 32-bit computer with an RSIC
    architecture; that is, it is a load/store computer and the only memory accesses
    allowed are load and store. Operations on data are register-to-register using
    three operands – for example, `add r1,r2,r3`. The ARM has 16 registers, `r0` to
    `r15`. Registers `r0` to `r12` can be treated as general-purpose (i.e., they all
    behave in the same way). Registers `r13`, `r14`, and `r15` have specific functions.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在树莓派上编写和调试一个ARM程序。我们还没有介绍ARM架构。你不需要对ARM了解很多，因为示例与我们在[*第6章*](B19624_06.xhtml#_idTextAnchor091)中模拟的RISC架构相似。ARM是一个32位计算机，具有RSIC架构；也就是说，它是一个加载/存储计算机，允许的唯一内存访问是加载和存储。数据操作使用三个操作数在寄存器之间进行——例如，`add
    r1, r2, r3`。ARM有16个寄存器，`r0`到`r15`。寄存器`r0`到`r12`可以被视为通用寄存器（即，它们的行为方式相同）。寄存器`r13`、`r14`和`r15`具有特定的功能。
- en: Pseudo instructions – a key concept
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 伪指令——一个关键概念
- en: The ARM assembler includes *pseudo-instructions* that are not part of the ARM’s
    `clr` `r0` instruction that loads `r0` with `0`. A pseudo-instruction, `clr r0`,
    could be devised and the assembler could automatically replace it with the `sub
    r0`,`r0` operation, which has the same effect.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: ARM汇编器包括不是ARM的`clr` `r0`指令的一部分的**伪指令**，该指令将`r0`加载为`0`。可以设计一个伪指令`clr r0`，汇编器可以自动将其替换为`sub
    r0, r0`操作，它具有相同的效果。
- en: Pseudo-instructions make the programmer’s life easier; for example, the ARM’s
    `adr` r0,`abc` pseudo-instruction loads a 32-bit address, ABC, into `r0`. Such
    an instruction does not exist; the assembler replaces adr with the appropriate
    ARM instructions.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 伪指令使程序员的编程生活更轻松；例如，ARM的`adr` r0,`abc`伪指令将32位地址ABC加载到`r0`。这样的指令并不存在；汇编器将adr替换为适当的ARM指令。
- en: An example of an ARM program
  id: totrans-147
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 一个ARM程序的示例
- en: 'Suppose we wish to generate the sum of the cubes of numbers from 1 to 10\.
    The following ARM code implements this algorithm. It also uses the ARM’s four-operand
    *multiply and* *accumulate*, `mla`:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们希望生成从1到10的数的立方和。以下ARM代码实现了这个算法。它还使用了ARM的四操作数*乘法和累加*指令`mla`：
- en: '[PRE8]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The label field beginning in the first column (bold in the preceding code)
    provides a *user-defined* tag that must be terminated by a colon. The label field
    is followed by the instruction consisting of an operation and any required operands.
    It doesn’t matter if there is more than one space after commas in argument lists.
    The text following the `@` symbol is a comment field and is ignored by the assembler.
    The GCC compiler also supports the C language style of comments: text delimited
    by `/* */` characters, as this example shows.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 标签字段从第一列开始（如前述代码中加粗所示），提供用户定义的标签，必须以冒号结束。标签字段后面是包含操作和任何所需操作数的指令。在参数列表中逗号后面的空格数量无关紧要。`@`符号后面的文本是注释字段，由汇编器忽略。GCC编译器还支持C语言风格的注释：由`/*
    */`字符分隔的文本，如本例所示。
- en: '*Table 9.2* describes some of the ARM’s instructions. There is only one surprise
    here; the `mla` *multiply and add instruction* that specifies *four* registers.
    It multiplies two registers together and adds a third register, and then puts
    the sum in a fourth register; that is, it can calculate `A = B +` `C.D`:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '*表9.2*描述了ARM的一些指令。这里只有一个惊喜；`mla` *乘法和加法指令*指定了*四个*寄存器。它将两个寄存器相乘，然后加上第三个寄存器，并将和放入第四个寄存器中；也就是说，它可以计算`A
    = B +` `C.D`：'
- en: '| **Instruction** | **ARM mnemonic** | **Definition** |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| **指令** | **ARM助记符** | **定义** |'
- en: '| --- | --- | --- |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Addition | `add` r0`,r1,r2` | [r0] ← [r1] + [r2] |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| 加法 | `add` r0`,r1,r2` | [r0] ← [r1] + [r2] |'
- en: '| Subtraction | `sub` r0`,r1,r2` | [r0] ← [r1] - [r2] |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| 减法 | `sub` r0`,r1,r2` | [r0] ← [r1] - [r2] |'
- en: '| AND | `and` r0`,r1,r2` | [r0] ← [r1] ∧ [r2] |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| AND | `and` r0`,r1,r2` | [r0] ← [r1] ∧ [r2] |'
- en: '| OR | `orr` r0`,r1,r2` | [r0] ← [r1] ∨ [r2] |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| OR | `orr` r0`,r1,r2` | [r0] ← [r1] ∨ [r2] |'
- en: '| Exclusive OR | `eor` r0`,r1,r2` | [r0] ← [r1] ⊕ [r2] |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| 独异或 | `eor` r0`,r1,r2` | [r0] ← [r1] ⊕ [r2] |'
- en: '| Multiply | `mul` r0`,r1,r2` | [r0] ← [r1] × [r2] |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| 乘法 | `mul` r0`,r1,r2` | [r0] ← [r1] × [r2] |'
- en: '| Register-to-register moveLiteral-to-register move | `mov` r0`,r1``mov` r0`,#0xAB`
    | [r0] ← [r1][r0] ← 0xAB Move 8-bit literal |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| 寄存器到寄存器移动 | `mov` r0`,r1``mov` r0`,#0xAB` | [r0] ← [r1][r0] ← 0xAB 移动8位立即数
    |'
- en: '| Compare | `cmp` r1`,r2` | [r1] – [r2] |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| 比较 | `cmp` r1`,r2` | [r1] – [r2] |'
- en: '| Branch on zero to label | `beq label` | [PC] ← label (jump to label if z
    = 1) |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| 零分支到标签 | `beq label` | [PC] ← label (如果z = 1则跳转到标签) |'
- en: '| Branch on not zero to label | `bne label` | [PC] ← label (jump to label if
    z = 0) |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| 非零分支到标签 | `bne label` | [PC] ← label (如果z = 0则跳转到标签) |'
- en: '| Multiply and add | `mla` r0`,r1,r2,r3` | [r0] ← [r1] x [r2] + [r3] |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| 乘法和加法 | `mla` r0`,r1,r2,r3` | [r0] ← [r1] x [r2] + [r3] |'
- en: '| Load register from memory | `ldr` r0`,[r1]` | [r0] ← [[r1]] |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| 从内存加载寄存器 | `ldr` r0`,[r1]` | [r0] ← [[r1]] |'
- en: '| Store register in memory | `str r0,`[r1] | [[r1]] ← [r0] |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| 将寄存器存储到内存 | `str r0,`[r1] | [[r1]] ← [r0] |'
- en: '| Call the operating system | `svc 0` | Request an operation from the OS |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| 调用操作系统 | `svc 0` | 从操作系统请求操作 |'
- en: Table 9.2 – ARM data processing, data transfer, and compare instructions
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 表9.2 – ARM数据处理、数据传输和比较指令
- en: 'Some computers always update condition codes after an operation. The ARM does
    not automatically update its status flags after an operation; you have to command
    a status update by appending s to the appropriate mnemonic. For example, `add`
    r1`,r2,r3` performs an addition without updating status flags, whereas `add`sr1`,r2,r3`
    updates status flags. This is not yet a program. The following provides the code
    and assembly language directives needed to run it on the Raspberry Pi:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 一些计算机在操作后总是更新条件码。ARM在操作后不会自动更新其状态标志；您必须通过在适当的助记符后附加s来命令状态更新。例如，`add` r1`,r2,r3`执行加法而不更新状态标志，而`add`sr1`,r2,r3`则更新状态标志。这还不是程序。以下提供了在Raspberry
    Pi上运行所需的代码和汇编语言指令：
- en: '[PRE9]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We’ve added an assembly language directive, `.global`, that declares the `_start`
    label as being *visible* outside this fragment of code. The GCC linking process
    links together separately assembled modules and inserts the appropriate addresses
    of the labels in the code.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个汇编语言指令 `.global`，它将 `_start` 标签声明为在此代码片段外部是 *可见的*。GCC 链接过程将分别汇编的模块链接在一起，并在代码中插入标签的适当地址。
- en: By declaring a label as global, you are telling the linker that this label is
    visible to other modules and they can refer to it. Labels without a global directive
    are local to the current module and invisible to all other modules; that is, you
    could use the same label in two modules and there would not be a conflict.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将标签声明为全局的，你是在告诉链接器这个标签对其他模块是可见的，它们可以引用它。没有全局指令的标签是当前模块的局部变量，对其他所有模块不可见；也就是说，你可以在两个模块中使用相同的标签，而不会发生冲突。
- en: The `_start` label indicates the point at which execution begins. The linker
    and operating system deal with storing the program in memory; that is, you don’t
    have to worry about where it is going to be actually stored in the computer’s
    physical memory.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`_start` 标签表示执行开始的点。链接器和操作系统处理将程序存储在内存中的问题；也就是说，你不必担心它将在计算机的物理内存中实际存储在哪里。'
- en: Finally, the last two operations (shaded) provide a means of getting back to
    the operating system level once the code has been executed. ARM has an `svc` instruction,
    which stands for *service call* and is used to invoke the operating system. Most
    computers have an operation such as `svc` and it has many names – for example,
    *software interrupt*. This instruction calls the operating system and supplies
    one or more parameters. The parameter can be part of the instruction itself or
    it can be loaded into a register. When the operating system detects a service
    call, the parameter is read and the appropriate operation is performed. This action
    is entirely system dependent; that is, it is part of the operating system and
    not part of the computer’s architecture.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，最后两个操作（阴影部分）提供了一种在代码执行后返回操作系统级别的手段。ARM 有一个 `svc` 指令，代表 *服务调用* 并用于调用操作系统。大多数计算机都有一个类似于
    `svc` 的操作，并且它有许多名称——例如，*软件中断*。这个指令调用操作系统并传递一个或多个参数。参数可以是指令本身的一部分，也可以被加载到寄存器中。当操作系统检测到服务调用时，会读取参数并执行适当的操作。这一行为完全取决于系统；也就是说，它是操作系统的一部分，而不是计算机架构的一部分。
- en: In this case, the specific function required by the service call is pre-loaded
    into `r7`. This mechanism is part of the Raspberry Pi’s operating system.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，服务调用所需的具体函数已预先加载到 `r7` 寄存器中。这种机制是 Raspberry Pi 操作系统的一部分。
- en: 'Key points to note about the assembly language program are as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 关于汇编语言程序需要注意的关键点如下：
- en: Comments are preceded by an `@` symbol (or the C language `/* */` book ends)
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注释由 `@` 符号（或 C 语言的 `/* */` 书签）开头
- en: Assembler directives are preceded by a period
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 汇编指令由点号开头
- en: Labels begin in the first column and are terminated by a colon
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标签从第一列开始，并以冒号结束
- en: An `.end` directive can be used to terminate the assembly language (it’s optional)
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用 `.end` 指令来终止汇编语言（这是可选的）
- en: The `.global` directive provides a label that indicates the entry point of the
    program
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.global` 指令提供了一个表示程序入口点的标签'
- en: Using the Raspberry Pi debugger
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Raspberry Pi 调试器
- en: We can now run an ARM assembly language program and observe its execution, line
    by line, using gdb. When you load a program into gdb, nothing appears to happen.
    If you try to look at your assembly language code or the registers, you will get
    an error message. You must explicitly run the program first.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以运行一个 ARM 汇编语言程序，并使用 gdb 逐行观察其执行。当你将程序加载到 gdb 中时，似乎没有发生任何事情。如果你尝试查看你的汇编语言代码或寄存器，你会得到一个错误消息。你必须首先明确运行程序。
- en: 'Consider the fragment of code in *Figure 9**.8*. This is a screenshot of the
    program after it’s been loaded into the Geany editor. It’s just a set of instructions
    and directives intended to demonstrate the steps involved in creating and testing
    an assembly language program. Here, we are using the Geany editor. The program
    demonstrates the following assembly language directives:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到 *图 9**.8* 中的代码片段。这是程序加载到 Geany 编辑器后的截图。它只是一组指令和指令，旨在演示创建和测试汇编语言程序所涉及的步骤。在这里，我们使用
    Geany 编辑器。该程序演示了以下汇编语言指令：
- en: '`.data`    Defines a memory region where variables and constants are stored.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.data`    定义了一个存储变量和常数的内存区域。'
- en: '`.text`    Defines a region of code (i.e., the assembly language).'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.text` 定义了一个代码区域（即汇编语言）。'
- en: '`.word`    Allows you to store a number in memory and give the location a symbolic
    address.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.word` 允许你在内存中存储一个数字，并给该位置一个符号地址。'
- en: '`.balign`  Aligns code and text on a 4-byte boundary. Required because instructions
    are 32 bits.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.balign` 在4字节边界上对齐代码和文本。由于指令是32位，因此是必需的。'
- en: '`.asciz`   Creates an ASCII text string terminated by zero in memory and gives
    it a name.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.asciz` 在内存中创建一个以零终止的ASCII文本字符串，并给它一个名称。'
- en: '`.global`  Makes a label visible to the linker. Otherwise, it is private to
    this module.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.global` 使标签对链接器可见。否则，它是此模块的私有标签。'
- en: The `balign` operation is required because memory is byte addressed and ARM
    instructions are 4 bytes long. Consequently, instruction addresses must be 0,
    4, 8, 12, 16, 20, and so on. If you put data elements in memory that are not multiples
    of 4 bytes (32 bits) between instructions, the program will crash. The `balign`
    instruction pads out any data you store with zeros to ensure that the next free
    address is on a 4-byte boundary.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`balign` 操作是必需的，因为内存是按字节寻址的，ARM指令是4字节长。因此，指令地址必须是0、4、8、12、16、20等等。如果你在指令之间放置不是4字节（32位）倍数的内存数据元素，程序将会崩溃。`balign`
    指令用零填充你存储的任何数据，以确保下一个空闲地址在4字节边界上。'
- en: Note that the code in *Figure 9**.8* uses a *pseudo-instruction*. The instruction
    `ldr` r4`,=Alan3` loads `r4` with the 32-bit literal, `Alan3`. The assembler will
    automatically substitute the necessary ARM code to perform this operation.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，*图9**.8* 中的代码使用了*伪指令*。指令 `ldr r4`,=Alan3` 将32位文字 `Alan3` 装载到 `r4` 中。汇编器将自动替换执行此操作所需的ARM代码。
- en: 'The next step is to assemble and link the code, which we called a4.s (I got
    fed up with typing long names and called the source program a4.s). We can do this
    with the following:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是汇编和链接代码，我们称之为a4.s（我厌倦了输入长名称，将源程序命名为a4.s）。我们可以用以下方式完成：
- en: '[PRE10]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The text in bold is my input. These lines change the working directory to Desktop
    where my source program is, and then assemble and link the source program. The
    final line, `./a4 ; echo $?`, runs the program and prints its return value (showing
    it’s been successfully executed by printing `4`, the value in `r0`).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 粗体文本是我的输入。这些行将工作目录更改为桌面，我的源程序就在那里，然后汇编和链接源程序。最后一行，`./a4 ; echo $?` 运行程序并打印其返回值（通过打印
    `4`，即 `r0` 中的值）来显示它已被成功执行。
- en: '![Figure 9.8 – The demonstration program in the Geany editor](img/Figure_9.08_B19624.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![图9.8 – Geany编辑器中的演示程序](img/Figure_9.08_B19624.jpg)'
- en: Figure 9.8 – The demonstration program in the Geany editor
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.8 – Geany编辑器中的演示程序
- en: 'The following four lines demonstrate how we call the gdb debugger and set a
    breakpoint. Text in bold font indicates lines entered from the keyboard. The other
    text is the debugger’s output:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 以下四行演示了如何调用gdb调试器并设置断点。粗体字体的文本表示从键盘输入的行。其他文本是调试器的输出：
- en: '[PRE11]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Entering a breakpoint is done by b <breakpoint>, where the breakpoint is a
    line number or a label. Here, it’s _start. If we run the code, it executes instructions
    up to the breakpoint. The next few lines are as follows:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 通过输入 b <breakpoint> 来设置断点，其中断点是行号或标签。这里，它是 _start。如果我们运行代码，它将执行到断点为止的指令。接下来的几行如下：
- en: '[PRE12]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note that you can continue from a breakpoint by entering `c` (i.e., continue)
    and execution will continue to the next breakpoint.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你可以通过输入 `c`（即继续）从断点继续执行，执行将继续到下一个断点。
- en: 'After entering a run command, the debugger begins execution and prints the
    next line to be executed – that is, the line labeled by _start. The gdb instruction
    i r (information registers) displays the ARM’s registers as follows:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 输入运行命令后，调试器开始执行并打印下一行要执行的指令 – 即，由 _start 标记的行。gdb指令 i r（寄存器信息）显示ARM寄存器如下：
- en: '[PRE13]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`cpsr` and `fpscr` are both status registers that contain information about
    the state of the processor.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`cpsr` 和 `fpscr` 都是状态寄存器，包含有关处理器状态的信息。'
- en: 'All registers have been initialized to zero automatically by the system software,
    except r13, r15 (`sp, pc`), and the two status registers. We can now start tracing
    the code, executing instructions one by one with the step command, `s 1`. You
    can just hit `enter` to trace the next instruction, as the following output demonstrates.
    If you were to type si 2 (or s 2), you would step two instructions:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 所有寄存器都由系统软件自动初始化为零，除了 r13、r15（`sp, pc`）和两个状态寄存器。我们现在可以开始跟踪代码，使用 `s 1` 步进命令逐条执行指令。您可以简单地按
    `enter` 键来跟踪下一个指令，如下面的输出所示。如果您输入 si 2（或 s 2），则会执行两条指令：
- en: '[PRE15]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Let’s look at the registers using the i r command. We have removed registers
    from this list that haven’t changed to make it easier to read. Register contents
    are given in hex and decimal formats:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 `i r` 命令查看寄存器。我们已从列表中删除了未更改的寄存器，以使其更容易阅读。寄存器内容以十六进制和十进制格式给出：
- en: '[PRE16]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Finally, we will continue stepping until the code has been executed. You can
    step just by using the *enter* key after the first si 1 command:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将继续逐步执行，直到代码执行完毕。您只需在第一个 `si 1` 命令之后使用 *enter* 键即可逐步执行：
- en: '[PRE17]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The gdb executes the move and supervisor call instruction and exits the simulation.
    What have we learned? This example demonstrates the following:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: gdb 执行了移动和系统调用指令并退出了模拟。我们学到了什么？这个例子演示了以下内容：
- en: How to create an ARM assembly language program
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建 ARM 汇编语言程序
- en: How to assemble and link it
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何汇编和链接
- en: How to load it into the gdb debugger
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何将其加载到 gdb 调试器中
- en: How to set breakpoints and run the code until a breakpoint is reached
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何设置断点并运行代码，直到达到断点
- en: How to display the contents of registers at any point in a program
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在任何程序点显示寄存器的内容
- en: How to step through the code line by line
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何逐行执行代码
- en: Tracing execution and displaying memory
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 跟踪执行和显示内存
- en: An important facility of a debugger is the ability to step through the code
    and display registers while executing a program. This allows you to follow the
    execution of a program and detect errors. The gdb debugger incorporates this facility
    via its `layout regs`.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 调试器的一个重要功能是能够在执行程序时逐步执行代码并显示寄存器。这允许您跟踪程序的执行并检测错误。gdb 调试器通过其 `layout regs` 功能实现这一功能。
- en: '*Figure 9**.9* provides a demonstration of the TUI with three panels. The upper
    window is the register window (the registers that have changed are highlighted;
    in this case, it’s `r7`). The middle panel displays the program code, with the
    next instruction to be executed highlighted. Each line includes the memory address
    of the code in hexadecimal form and as a distance from the `start` label.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9**.9* 展示了具有三个面板的 TUI 示例。上面的窗口是寄存器窗口（已更改的寄存器被突出显示；在这种情况下，是 `r7`）。中间面板显示程序代码，下一个要执行的指令被突出显示。每一行都包括代码的内存地址，以十六进制形式表示，以及从
    `start` 标签的距离。'
- en: Note that the code continues after my last instruction, `svc`. This is because
    the disassembler reads a block of memory and displays it as code (even if it is
    not part of your program). In this case, the data we entered in memory with the
    `.word` directive is read and displayed as the corresponding ARM instruction.
    Remember that the debugger does not know whether a binary value in memory is an
    instruction or user data. If it reads a data value corresponding to an instruction
    op-code, it prints that op-code.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，代码在我的最后一条指令 `svc` 之后继续执行。这是因为反汇编器读取一块内存并将其显示为代码（即使它不是您的程序的一部分）。在这种情况下，我们使用
    `.word` 指令在内存中输入的数据被读取并显示为相应的 ARM 指令。请记住，调试器不知道内存中的二进制值是指令还是用户数据。如果它读取与指令操作码相对应的数据值，它会打印出该操作码。
- en: The disassembled instructions display their address in memory in hex form; for
    example, the first instruction is at `0x10074`. This address is determined by
    Raspberry Pi’s operating system. As you can see, each instruction has an address
    4 bytes greater than the previous one because the ARM is a 32-bit machine with
    32-bit, or 4-byte, instructions; hence the need for the align directive that forces
    the next instruction or data onto a specific boundary.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 反汇编的指令以十六进制形式显示其在内存中的地址；例如，第一条指令位于 `0x10074`。这个地址由 Raspberry Pi 的操作系统确定。如您所见，每个指令的地址比前一个指令大
    4 个字节，因为 ARM 是一个 32 位机器，具有 32 位或 4 字节的指令；因此需要对齐指令，强制下一个指令或数据放置在特定的边界上。
- en: The bottommost panel contains the commands you enter. In this case, I’ve used
    `si 1` to step through the instructions.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 最低面板包含您输入的命令。在这种情况下，我使用了 `si 1` 来逐步执行指令。
- en: '![Figure 9.9 – The TUI showing registers and memory contents](img/Figure_9.09_B19624.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![图9.9 – 显示寄存器和内存内容的TUI](img/Figure_9.09_B19624.jpg)'
- en: Figure 9.9 – The TUI showing registers and memory contents
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.9 – 显示寄存器和内存内容的TUI
- en: Let’s look at another example of an assembly language program and its debugging.
    This example is designed only for demonstration purposes. It doesn’t do anything
    useful. Our intention is to demonstrate the features of an ARM assembly language
    program running under the GCC assembler and the gdb debugger. *Table 9.3* gives
    some of GCC’s most common assembler directives.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看汇编语言程序及其调试的另一个示例。这个例子仅用于演示目的。它没有任何有用的功能。我们的目的是演示在GCC汇编器和gdb调试器下运行的ARM汇编语言程序的功能。*表9.3*给出了GCC的一些最常见汇编指令。
- en: '| **GCC** **Assembly directive** | **Action** |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '| **GCC** **汇编指令** | **操作** |'
- en: '| --- | --- |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| .text | Indicates a program segment containing code |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '| .text | 指示包含代码的程序段 |'
- en: '| .data | Indicates a program segment containing data |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| .data | 指示包含数据的程序段 |'
- en: '| .global `label` | Makes the label visible to the linker |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| .global `label` | 使标签对链接器可见 |'
- en: '| .extern `label` | Makes the label visible outside the file |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| .extern `label` | 使标签在文件外部可见 |'
- en: '| .byte`byte1,byte2, …` | Defines one or more bytes of data and stores them
    in memory |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| .byte`byte1,byte2, …` | 定义1个或多个字节的数据并将其存储在内存中 |'
- en: '| .hword`hw1,hw2, …` | Defines 1 or more 16-bit halfwords and stores them in
    memory |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| .hword`hw1,hw2, …` | 定义1个或多个16位半字并将其存储在内存中 |'
- en: '| .word`w1,w2, …` | Defines 1 or more 32-bit words and stores them in memory
    |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| .word`w1,w2, …` | 定义1个或多个32位字并将其存储在内存中 |'
- en: '| .space `bytes,fill` | Fills a block of memory with a given value (e.g., `.``fill`
    `64`,`0xFF`) |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| .space `bytes,fill` | 使用给定的值填充内存块（例如，`.fill` `64`,`0xFF`）|'
- en: '| `.`balign 4 | Aligns next address to a 4-byte boundary (you can also use
    2, 4, 8, and 16) |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| `.`balign 4 | 将下一个地址对齐到4字节边界（也可以使用2、4、8和16）|'
- en: '| .ascii `"``any string"` | Stores an ASCII string in memory |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| .ascii `"``any string"` | 在内存中存储ASCII字符串 |'
- en: '| .asciz `"``any string"` | Stores an ASCII string in memory terminated by
    0 |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| .asciz `"``any string"` | 在内存中存储一个以0结尾的ASCII字符串 |'
- en: '| .equ`symbol, value` | Equates the symbolic name to its value (e.g., `.equ`
    `hours 24`) |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| .equ`symbol, value` | 将符号名称与其值等价（例如，`.equ` `hours 24`）|'
- en: '| .end | Marks the end of a program |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| .end | 标记程序的结束 |'
- en: Table 9.3 – GCC ARM assembler directives
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 表9.3 – GCC ARM汇编器指令
- en: 'We have presented a more detailed explanation of some of the features of the
    program; these are of the form `@ PRINT` `STRING @`:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对程序的一些功能进行了更详细的解释；这些功能的形式为`@ PRINT` `STRING @`：
- en: '[PRE19]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '@ PRINT STRING ON CONSOLE @'
  id: totrans-248
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '@ 在控制台上打印字符串 @'
- en: '[PRE20]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '@ USING ADR @'
  id: totrans-251
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '@ 使用地址 @'
- en: '[PRE22]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '@ EXITING THE PROGRAM @'
  id: totrans-253
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '@ 程序退出 @'
- en: '[PRE23]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '@ THE ADDRESS VECTOR @'
  id: totrans-255
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '@ 地址向量 @'
- en: '[PRE24]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This code illustrates several points – for example, the use of assembler directives
    such as`.equ`, which binds a symbolic name to a value. I’ve shaded interesting
    blocks of code so that we can discuss them.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码说明了几个要点——例如，使用汇编指令如`.equ`，将符号名称绑定到值。我已经用阴影标记了有趣的代码块，以便我们可以讨论它们。
- en: We have used ARM’s pseudo-instructions. These are `adr` r3`,v3 and ldr` r1`,=banner`.
    These both load 32-bit addresses into a register. Such instructions don’t exist.
    The ARM assembler chooses real instructions to perform the required actions.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了ARM的伪指令。这些是`adr r3`,v3`和`ldr r1`,=banner`。这两个指令都将32位地址加载到寄存器中。这样的指令并不存在。ARM汇编器选择实际的指令来执行所需操作。
- en: '@ PRINT STRING @'
  id: totrans-259
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '@ 打印字符串 @'
- en: 'The first block demonstrates how we can print data from an assembly program.
    Well, in fact, we can’t print the data but we can ask the operating system to
    do it for us. Most processors have an instruction called a *software interrupt*
    (or a system call, a trap, an exception, or an *extra code*). All these terms
    refer to the same thing: an instruction inserted by the programmer that invokes
    the operating system. In the case of ARM, it’s the svc instruction (previously
    called swi). When used by Linux, this instruction is called with the parameter
    `0` – that is `svc 0`.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个示例演示了如何从汇编程序中打印数据。实际上，我们无法打印数据，但我们可以请求操作系统为我们完成。大多数处理器都有一个名为*软件中断*（或系统调用、陷阱、异常或*额外代码*）的指令。所有这些术语都指同一件事：程序员插入的指令，用于调用操作系统。在ARM的情况下，它是svc指令（以前称为swi）。当Linux使用时，这个指令使用参数`0`——即`svc
    0`。
- en: The system call is entirely operating-system-dependent and tells the operating
    system what it needs by passing parameters in registers. We are going to print
    a string of characters on the display. The Raspberry Pi OS needs the location
    of the string in memory to be passed in register r1, the number of characters
    to print in register `r2`, the type of the display in `r0`, and the operation
    to be performed (printing) in `r7`.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 系统调用完全依赖于操作系统，并通过在寄存器中传递参数来告诉操作系统它需要什么。我们将打印一串字符到显示设备。Raspberry Pi OS需要将字符串在内存中的位置传递到寄存器r1，打印的字符数传递到寄存器`r2`，显示类型传递到`r0`，以及要执行的操作（打印）传递到`r7`。
- en: The address of the text to be printed, `banner`, is loaded into `r1` by `ldr`
    r1`,=banner`. This pseudo-instruction takes an address specified by `=<address>`.
    In the program, we have used the `.ascii` directive to store the string to print
    in memory. The string is text with `\n` at each end, which corresponds to the
    newline character. Note that the newline character code is 1 byte, although it
    is represented in the program by `\n`. Unless a string or other data item stored
    in memory is a multiple of 4 bytes, you must follow it with a `.balign 4` to ensure
    that the next instruction falls on a word boundary.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 需要打印的文本地址`banner`通过`ldr r1,=banner`指令加载到寄存器`r1`中。这个伪指令通过`=<address>`指定一个地址。在程序中，我们使用了`.ascii`指令将打印的字符串存储在内存中。字符串以`\n`结尾，对应于换行符。请注意，换行符的代码是1字节，虽然在程序中用`\n`表示。除非内存中存储的字符串或其他数据项是4字节的倍数，否则你必须跟一个`.balign
    4`来确保下一个指令落在字边界上。
- en: '@ USING ADR @'
  id: totrans-263
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '@ 使用ADR @'
- en: The second block demonstrates the use of an `adr` pseudo-instruction with `adr`
    r3`,v3`. We are going to load register `r3` with the address of a variable we’ve
    called `v3` and loaded into memory with a `.word` directive. One practical consideration
    is that when you disassemble the code, you will not see `adr`; you’ll see the
    actual code that the ARM assembler translated it into.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个示例演示了使用`adr`伪指令与`adr r3,v3`。我们将把一个名为`v3`的变量的地址加载到寄存器`r3`中，并通过`.word`指令将其加载到内存中。一个实际考虑是，当你反汇编代码时，你将看不到`adr`；你将看到ARM汇编器将其转换成的实际代码。
- en: Putting the address of the `v3` variable into a register means we can use that
    register as a pointer with a load instruction; for example, `ldr` r4`,[r3]` loads
    the value of the variable (i.e., `0x1111` ) into `r4`. If you wish to modify that
    variable, you might think that you could store it back in memory with `str r5,`[r3].
    Sadly not! The `adr` instruction generates code that allows you to access only
    the current segment of the program. That segment is read-only because it contains
    the code. You cannot alter memory in that segment. If you wish to modify memory,
    you have to use a different technique, as we will soon see.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 将`v3`变量的地址放入寄存器意味着我们可以使用该寄存器作为指针，并通过加载指令使用它；例如，`ldr r4,[r3]`将变量的值（即`0x1111`）加载到`r4`中。如果你希望修改该变量，你可能认为可以用`str
    r5,[r3]`将其存储回内存。遗憾的是不行！`adr`指令生成的代码只允许你访问程序的当前段。该段是只读的，因为它包含代码。你无法更改该段中的内存。如果你希望修改内存，你必须使用不同的技术，正如我们很快将看到的。
- en: '@ EXITING THE PROGRAM @'
  id: totrans-266
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '@ 程序退出 @'
- en: After an assembly language program has been executed to completion, it is necessary
    to return to the operating system level. Register `r7` is loaded with an exit
    code of `1` and an `svc 0` instruction executed to call the operating system.
    By convention, programmers load register r0 with their own exit code before exiting.
    An exit code of `0` is often used to indicate all went well, and an exit code
    of `1` indicates it didn’t.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在汇编语言程序执行完成后，需要返回到操作系统级别。将退出代码`1`加载到寄存器`r7`中，并执行`svc 0`指令来调用操作系统。按照惯例，程序员在退出之前将他们的退出代码加载到寄存器r0中。退出代码`0`通常用来表示一切顺利，而退出代码`1`表示出现了问题。
- en: '@ THE ADDRESS VECTOR @'
  id: totrans-268
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '@ 地址向量 @'
- en: You can’t use the `adr` pseudo-instruction to write to read/write memory that
    is in a different segment to the code part of a program. This dilemma exists in
    all code development systems and is not peculiar to the ARM GCC environment. The
    ARM processor will allow you to read memory and write to memory anywhere within
    the logically addressable memory space. However, the ARM *operating system* does
    not let you write to regions of read-only memory or other forbidden areas. The
    trick is to create a pointer to the variable and store that pointer in the code
    segment.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能使用 `adr` 伪指令将数据写入与程序代码部分位于不同段的读写内存。这种困境存在于所有代码开发系统中，并不仅限于 ARM GCC 环境。ARM
    处理器将允许你在逻辑地址空间内的任何位置读取内存和写入内存。然而，ARM *操作系统* 不允许你写入只读内存区域或其他禁止区域。技巧是创建一个指向变量的指针，并将该指针存储在代码段中。
- en: 'Consider the following assembler directive. This stores a 32-bit `dat1` value
    in memory at location `adr_dat1`. By convention, some programmers indicate that
    an item is a pointer (i.e., address) by prefixing its name with a marker (typically
    `adr`). This is not a rule but a convention:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下汇编指令。这个指令将32位的 `dat1` 值存储在内存中的 `adr_dat1` 位置。按照惯例，一些程序员通过在其名称前加上标记（通常是 `adr`）来表示一个项是一个指针（即地址）。这并不是一个规则，而是一种惯例：
- en: '![Figure 9.10 - Creating a pointer to a data value](img/Figure_9.10_B19624.jpg)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![图9.10 - 创建指向数据值的指针](img/Figure_9.10_B19624.jpg)'
- en: Figure 9.10 - Creating a pointer to a data value
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.10 - 创建指向数据值的指针
- en: We have created a name, `adr_dat1`, which is the *address* of the address of
    our target variable. The value stored is the address of the actual variable, `dat1`.
    So, when we write the instruction `ldr r0,adr_dat1`, the *address* of `dat1` is
    loaded in register `r0`. That is, register `r0` now points to `dat1`.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个名为 `adr_dat1` 的名称，它是我们目标变量的 *地址* 的地址。存储的值是实际变量的地址，`dat1`。因此，当我们写入指令 `ldr
    r0,adr_dat1` 时，`dat1` 的 *地址* 被加载到寄存器 `r0` 中。也就是说，寄存器 `r0` 现在指向 `dat1`。
- en: 'In the data section headed by `.data`, we have the following:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在以 `.data` 为标题的数据部分，我们有以下内容：
- en: '[PRE25]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This stores the `0x1234` value in memory and gives it the name `dat1`. As we
    have seen, that name is used to create the address of the variable in the code
    section by the following:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这将 `0x1234` 值存储在内存中，并给它命名为 `dat1`。正如我们所见，该名称用于通过以下方式在代码部分创建变量的地址：
- en: '[PRE26]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The next step is to run the code. We’ve done this and have provided an edited
    output from the session (removing empty prompt lines between operations and some
    text) in *Listing 9.1*:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是运行代码。我们已经这样做，并在 *列表9.1* 中提供了一个会话的编辑输出（删除操作之间的空提示行和一些文本）：
- en: '[PRE27]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Listing 9.1 – A debugging session
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 列表9.1 – 调试会话
- en: Accessing memory
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问内存
- en: We have demonstrated how you can step through a program and display registers
    as instructions are executed. For example, gdb lets you display the contents of
    registers `r0` to `r3` using the `i r r0 r1 r2 r3` command. We will now demonstrate
    how the contents of memory locations can be displayed.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经展示了如何逐条执行程序并显示寄存器的内容。例如，gdb 允许你使用 `i r r0 r1 r2 r3` 命令显示寄存器 `r0` 到 `r3`
    的内容。现在我们将演示如何显示内存位置的内容。
- en: In *Listing 9.1*, we single-step the code through the first few instructions
    (memory access and store operations) and then, after line 25, we can see that
    the address of the `dat3` variable is `0x200e8`. Suppose we want to check that
    its value is `0x1234`, and that the next word location 4 bytes on, `0x2008c`,
    contains the `0x1235` value.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *列表9.1* 中，我们逐条执行代码的前几条指令（内存访问和存储操作），然后在第25行之后，我们可以看到 `dat3` 变量的地址是 `0x200e8`。假设我们想检查其值是否为
    `0x1234`，以及下一个字位置4字节之后的 `0x2008c` 包含 `0x1235` 值。
- en: 'You might reasonably expect that the `gdb` command to read the memory location
    is `m` `0x200c`. As you can see from *Listing 9.1*, the command is the rather
    less memorable:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会合理地期望读取内存位置的 `gdb` 命令是 `m` `0x200c`。如 *列表9.1* 所示，命令相当难以记忆：
- en: '[PRE28]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The memory access command is x/ and the three required parameters are 2xw.
    These are as follows:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 内存访问命令是 `x/`，并且需要三个参数：2xw。这些如下：
- en: '`2`   The number of memory locations to be displayed.'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`2`   要显示的内存位置数量。'
- en: '`x`   The format of the data. `x` indicates hexadecimal.'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x`   数据的格式。`x` 表示十六进制。'
- en: '`w`   The width of the data (number of bytes). `w` indicates a 4-byte 32-bit
    word.'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`w`   数据的宽度（字节数）。`w` 表示4字节的32位字。'
- en: 'The available formats are as follows:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 可用的格式如下：
- en: '`o`   octal'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`o`   八进制'
- en: '`d`   decimal'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`d`   十进制'
- en: '`x`   hexadecimal'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x`   十六进制'
- en: '`u`   unsigned integer'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`u`   无符号整数'
- en: '`s`   string'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`s`   字符串'
- en: '`b`   byte'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`b`   字节'
- en: 'The data display sizes are as follows:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 数据显示大小如下：
- en: '`b`   byte'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`b`   字节'
- en: '`h`   halfword (16 bits)'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`h`   半字（16位）'
- en: '`w`   word (32 bits)'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`w`   字（32位）'
- en: '`g`   double word (giant word of 8 bytes or 64 bits)'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`g`   双字（8字节或64位的大字）'
- en: 'Consider these examples:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例：
- en: '`x/1xw 0x1234`   Print one 4-byte word in hex form at address `0x1234`'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x/1xw 0x1234`   在地址 `0x1234` 以十六进制形式打印一个4字节字'
- en: '`x/6xh 0x1234`   Print six 2-byte values in hex form at address `0x1234`'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x/6xh 0x1234`   在地址 `0x1234` 以十六进制形式打印六个2字节值'
- en: '`x/3db 0x1234`   Print three one-byte values in decimal form at address `0x1234`'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x/3db 0x1234`   在地址 `0x1234` 以十进制形式打印三个单字节值'
- en: '`x/9sb 0x1234`   Print nine one-byte characters in string form at address `0x1234`'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x/9sb 0x1234`   在地址 `0x1234` 以字符串形式打印九个单字节字符'
- en: In the next section, we are now going to look at the ARM GCC assembler in a
    little more detail. For example, we will introduce the ARM’s assembler directives
    that control the allocation of memory to a program.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将更详细地探讨 ARM GCC 汇编器。例如，我们将介绍控制程序内存分配的 ARM 汇编指令。
- en: Features of the GCC ARM assembler
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GCC ARM汇编器的特性
- en: 'We will begin this section by looking at how memory space can be reserved for
    constants and variables. We have already seen that literals in the ARM assembly
    language are prefixed by a `#` symbol. Numbers are regarded as decimal unless
    prefixed by `0x`, which indicates hexadecimal – for example, `mov r0,#0x2C`. ASCII
    characters are indicated by using single quotes, as in this example:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从这个部分开始，看看如何为常量和变量保留内存空间。我们已经看到，ARM 汇编语言中的字面量前面有一个 `#` 符号。数字默认为十进制，除非前面有
    `0x` 前缀，表示十六进制——例如，`mov r0,#0x2C`。ASCII 字符使用单引号表示，如下例所示：
- en: '[PRE29]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Two important assembler directives are `.equ`, which binds a name to a value,
    and `.word`, which allows you to preload memory with data before a program runs.
    The `.equ` directive is very easy to understand; it binds a numeric value to a
    name. Consider the following:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 两个重要的汇编指令是 `.equ`，它将一个名称绑定到一个值，以及 `.word`，它允许你在程序运行之前预加载内存中的数据。`.equ` 指令非常容易理解；它将一个数值绑定到一个名称。考虑以下示例：
- en: '[PRE30]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This assembly directive binds the name `Tuesday` to the value `2`. Whenever
    you write `Tuesday`, the assembler replaces it with `2`. The GCC ARM `.word` assembler
    directive reserves memory space for constants and variables; that is, it declares
    a variable (or constant) and initializes it. Consider the following example:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 这个汇编指令将名称 `Tuesday` 绑定到值 `2`。每次你写入 `Tuesday`，汇编器都会将其替换为 `2`。GCC ARM `.word`
    汇编指令为常量和变量保留内存空间；也就是说，它声明了一个变量（或常量）并初始化它。考虑以下示例：
- en: '[PRE31]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `.word` directive reserves a 32-bit word (i.e., 4 bytes) of storage in memory
    and loads whatever value the expression to the right of `.word` yields into that
    location. In this case, we’ve bound `Value1` to the number `12` and, therefore,
    the binary value `00000000000000000000000000001100` will be stored at this location.
    The next memory location used is the next free location (i.e., storage directives
    store data in memory sequentially).
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '`.word` 指令在内存中保留一个32位字（即4字节）的存储空间，并将 `.word` 右侧的表达式得到的值加载到该位置。在这种情况下，我们将 `Value1`
    绑定到数字 `12`，因此二进制值 `00000000000000000000000000001100` 将存储在这个位置。下一个使用的内存位置是下一个空闲位置（即存储指令按顺序存储数据在内存中）。'
- en: The *location counter* is advanced by four bytes so that the next `.word` or
    instruction will be placed in the next word in memory. The term *location counter*
    refers to the pointer to the next location in memory when a program is being assembled
    and is similar, in concept, to the program counter.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '*位置计数器* 前进了四个字节，以便下一个 `.word` 或指令将放置在内存中的下一个字。*位置计数器* 指的是程序汇编时内存中下一个位置的指针，在概念上与程序计数器相似。'
- en: 'You don’t have to use 32-bit values in the ARM programs. The`.byte` and `.hword`
    assembler directives store a byte and a 16-bit halfword in memory, respectively,
    as in this example:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 你不必在 ARM 程序中使用32位值。`.byte` 和 `.hword` 汇编指令分别将一个字节和一个16位半字存储在内存中，如下例所示：
- en: '[PRE32]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Although you could use `.byte` to store text strings in memory, it would be
    very clumsy because you would have to look up the ASCII value of each character.
    The GCC ARM assembler provides a simpler mechanism. The `.ascii` directive takes
    a string and stores each character as an 8-bit ASCII-encoded byte in consecutive
    memory locations. The `.asciz` command performs the same function but inserts
    an 8-bit binary byte of all 0s as a terminator:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以使用 `.byte` 在内存中存储文本字符串，但这会很笨拙，因为你必须查找每个字符的 ASCII 值。GCC ARM 汇编器提供了一个更简单的机制。`.ascii`
    指令接受一个字符串，并将每个字符作为连续内存位置中的 8 位 ASCII 编码的字节存储。`.asciz` 命令执行相同的功能，但插入一个全零的 8 位二进制字节作为终止符：
- en: '[PRE33]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Because the ARM aligns all instructions on 32-bit word boundaries, the `.balign
    4` directive is required to align whatever follows on the next word boundary (the
    4 indicates a 4-byte boundary). In other words, if you store three 8-bit characters
    in memory, the `.balign 4` command skips a byte to force the next address to a
    32-bit boundary. Note that `.balign 2` forces alignment on a halfword boundary
    (you can use `.balign 16`, or any other power of 2, to force the next memory access
    to be appropriately aligned).
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 ARM 将所有指令对齐到 32 位单词边界，所以需要 `.balign 4` 指令来对齐下一个单词边界（4 表示 4 字节边界）。换句话说，如果你在内存中存储三个
    8 位字符，`.balign 4` 命令会跳过一个字节，迫使下一个地址达到 32 位边界。请注意，`.balign 2` 强制对齐到半字边界（你可以使用 `.balign
    16` 或任何其他 2 的幂，以强制下一次内存访问适当地对齐）。
- en: 'The following ARM code demonstrates storage allocation and the use of the `.balign`
    `4` directive:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的 ARM 代码演示了存储分配和 `.balign 4` 指令的使用：
- en: '[PRE34]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Let’s assemble, link, and run this code on a Raspberry Pi using gdb. The first
    few lines from the terminal windows show the loading of the program, setting a
    breakpoint, and executing in a single-step mode:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 Raspberry Pi 上使用 gdb 汇编、链接和运行此代码。终端窗口的前几行显示了程序的加载、设置断点和单步执行模式：
- en: '[PRE35]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'So far, so good. Let’s see what the registers hold. We have deleted lines with
    registers that we’re not interested in to make the output more readable:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利。让我们看看寄存器中有什么。我们删除了不感兴趣的寄存器行，以使输出更易于阅读：
- en: '[PRE36]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Registers `r0` to `r3` contain what we would expect (`r3` is `0x17` in `r3`
    plus the `0x42` code for `'B'` which is `0x59`).
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 寄存器 `r0` 到 `r3` 包含我们预期的内容（`r3` 中的 `0x17` 加上 `'B'` 的 `0x42` 代码，即 `0x59`）。
- en: 'Register r4 contains `0x1007e`, which is the address of the data called `test`:
    (i.e., `0xBB`) in memory. That address is used to load the `0xBB` constant into
    `r5`, which now contains `0xABCD00BB` and not `0x000000BB` as we expected. What
    went wrong?'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 寄存器 r4 包含 `0x1007e`，这是名为 `test` 的数据的地址（即，`0xBB`）在内存中。该地址用于将 `0xBB` 常量加载到 `r5`
    中，现在 `r5` 包含 `0xABCD00BB`，而不是我们预期的 `0x000000BB`。出了什么问题？
- en: The problem is that `ldr` loads a 32-bit value into a register from memory.
    `0xABCD00` is the word following `0xBB` plus a null byte due to the `.balign`
    `2` statement. We should have used a special *“load a byte”* instruction, loaded
    four bytes and cleared three to zero, or aligned the byte correctly in memory.
    The great strength of a computer is that it does what you tell it. Alas, its great
    weakness is that…it does *exactly* what you tell it.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于 `ldr` 从内存中将 32 位值加载到寄存器中。`0xABCD00` 是 `0xBB` 后面的单词加上由于 `.balign 2` 语句引起的空字节。我们应该使用特殊的
    *“加载一个字节”* 指令，加载四个字节并将三个字节清零，或者在内存中正确对齐字节。计算机的巨大优势在于它会按照你的指示去做。唉，它的巨大弱点是……它 *完全*
    按照你的指示去做。
- en: 'Next, we look at the data stored in memory using the `x/7xw 0x1006c` command,
    which displays `7` words of memory in hexadecimal form starting at address `0x1006c`
    (we got that address from the `pc` in the register dump). Remember that it’s the
    ARM’s operating system that initially sets up the program counter:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用 `x/7xw 0x1006c` 命令查看内存中存储的数据，该命令以十六进制形式显示从地址 `0x1006c` 开始的 `7` 个单词的内存（我们从寄存器转储中的
    `pc` 获取了该地址）。记住，是 ARM 的操作系统最初设置了程序计数器：
- en: '[PRE37]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We can also look at the data stored in memory in byte form using `x/28xb 0x1006c`,
    which displays `7` words (4 x 7 = 28 bytes) of memory in hexadecimal form starting
    at address `0x1006c`:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用 `x/28xb 0x1006c` 来查看存储在内存中的数据，它以十六进制形式显示从地址 `0x1006c` 开始的 `7` 个单词（4
    x 7 = 28 字节）的内存：
- en: '[PRE38]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '*Figure 9**.10* provides a memory map demonstrating the allocation of memory.
    The bold hexadecimal addresses are the 4-byte word boundaries. You can see how
    the `.balign` directives insert zeros as padding in memory to form the required
    boundaries.'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9**.10* 提供了一个内存映射，展示了内存的分配情况。粗体的十六进制地址是 4 字节单词边界。你可以看到 `.balign` 指令如何在内存中插入零作为填充，以形成所需的边界。'
- en: 'In the next section, we look at one of the key aspects of modern computer design
    – how a computer with a 32-bit word length can load a 32-bit value into a register:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨现代计算机设计的关键方面之一——如何将32位值加载到32位字长的计算机寄存器中：
- en: '[PRE39]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Figure 9.10 – Allocating data to memory – the memory map
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.10 – 分配数据到内存 – 内存映射
- en: 'We next look at a dilemma that affects all computers: how do you load a constant
    (literal) that is the same size as the instruction word?'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨影响所有计算机的一个困境：如何加载与指令字大小相同的常量（立即数）？
- en: Dealing with 32-bit literals
  id: totrans-340
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理32位立即数
- en: Here, you will learn how the ARM uses a 32-bit instruction to load a 32-bit
    literal. A literal can’t be combined with an op-code as we have done in the simulators.
    We will demonstrate how the ARM uses several techniques to use a 32-bit instruction
    to access a 32-bit literal.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你将学习ARM如何使用32位指令加载32位立即数。立即数不能与操作码组合，就像我们在模拟器中所做的那样。我们将演示ARM如何使用几种技术使用32位指令来访问32位立即数。
- en: The ARM has 32-bit data words and instructions. You can’t load a 32-bit literal
    into an ARM register in one instruction because you can’t specify both the operation
    and the data in one instruction. CISC processors chain two or more instructions
    together; for example, a 16-bit machine might take 2 instruction words to create
    a 32-bit instruction containing a 16-bit operation and a 16-bit literal. Some
    processors load a 16-bit literal (load high) with one instruction and then load
    a second 16-bit literal (load low) with a second instruction. The computer then
    concatenates the high and low halfword 16-bit values into a 32-bit literal.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: ARM有32位数据字和指令。你无法在一个指令中将32位立即数加载到ARM寄存器中，因为你无法在一个指令中同时指定操作和数据。CISC处理器将两个或更多指令链接在一起；例如，一个16位机器可能需要2个指令字来创建一个包含16位操作和16位立即数的32位指令。一些处理器使用一个指令加载16位立即数（加载高位），然后使用第二个指令加载第二个16位立即数（加载低位）。然后计算机将高位和低位16位值连接成一个32位立即数。
- en: 'The ARM has two pseudo-instructions that can load a 32-bit value into a register
    by letting the assembler generate the actual code needed to do this. The pseudo-instruction
    `adr` (load address) has the format adr rdestination,label, where `label` indicates
    a line (address) in the program. `adr` lets the assembler generate the appropriate
    machine code and relieves the programmer of some *housekeeping*. The `adr` uses
    the ARM’s `add` or `sub` instruction together with *PC relative addressing* to
    generate the required address. Program counter-relative addressing specifies an
    address by its distance from the current instruction. The following code fragment
    demonstrates the use of `adr`:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: ARM有两种伪指令可以将32位值加载到寄存器中，允许汇编器生成执行此操作所需的实际代码。伪指令`adr`（加载地址）的格式为`adr rdestination,label`，其中`label`表示程序中的一行（地址）。`adr`允许汇编器生成适当的机器代码，并减轻程序员的某些*家务*。`adr`使用ARM的`add`或`sub`指令与*PC相对寻址*来生成所需的地址。程序计数器相对寻址通过其与当前指令的距离来指定地址。以下代码片段演示了`adr`的使用：
- en: '[PRE40]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The pseudo-instruction `adr` r0,`someData` loads register `r0` with the 32-bit
    address of `someData` using the appropriate code generated by the assembler. You
    don’t normally have to know how the assembler generates the actual code to implement
    the `adr`.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '伪指令`adr` r0,`someData`使用汇编器生成的适当代码将32位地址`someData`加载到寄存器`r0`中。通常你不需要知道汇编器如何生成实现`adr`的实际代码。 '
- en: 'Another useful ARM pseudo-instruction is `ldr` r1`,=value`. In this case, the
    compiler generates the code that allows register r1 to be loaded with the stated
    value, as in this example:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的ARM伪指令是`ldr r1`,=value`。在这种情况下，编译器生成的代码允许寄存器r1加载指定的值，如下例所示：
- en: '[PRE41]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This loads r2 with 1234567816\. The assembler employs a `mov` or `mvn` instruction
    if it can. The ARM’s unusual *move* `not` instruction takes an 8-bit literal,
    inverts the bits, and moves it to a register. For example `MVN r1,#0xF0` copies
    `0x0F` to r1\. Alternatively, the assembler uses an `ldr`r2`,[pc,#offset]` instruction
    to access the appropriate constant 1234567816 that is stored in a so-called *literal
    pool* or *constant pool* somewhere in memory. A literal pool is one or more data
    items embedded in code.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 这将1234567816加载到r2中。如果汇编器能够做到，它将使用`mov`或`mvn`指令。ARM的异常*移动*`not`指令接受一个8位立即数，反转位，并将其移动到寄存器。例如`MVN
    r1,#0xF0`将`0x0F`复制到r1。或者，汇编器使用`ldr r2,[pc,#offset]`指令来访问存储在内存中某个所谓的*立即数池*或*常量池*中的适当常量1234567816。立即数池是嵌入在代码中的一或多个数据项。
- en: 'Let’s look at how pseudo-instructions are treated by the GCC assembler development
    system. Consider the following fragment of code:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 GCC 汇编器开发系统如何处理伪指令。考虑以下代码片段：
- en: '[PRE42]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The following is the edited output of a gdb debugger session. The code has
    been executed to completion and the register contents are as follows. The righthand
    column displays the data in decimal form:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个 gdb 调试会话的编辑输出。代码已执行完成，寄存器内容如下。右侧列显示十进制形式的数据：
- en: '[PRE43]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The pointer registers, `r1` and `r2`, have been loaded with the addresses of
    the two data elements in memory (i.e., Table1 and Table2). These pointers have
    been used to retrieve the two elements, and you can see from the debugger that
    the operation worked.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 指针寄存器 `r1` 和 `r2` 已加载了内存中两个数据元素的地址（即，Table1 和 Table2）。这些指针已被用来检索这两个元素，你可以从调试器中看到操作是成功的。
- en: 'The following debugger output provides a disassembly of the code. This is not
    what was written. The assembler has converted the three pseudo-operations into
    actual ARM code (in bold font):'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 以下调试输出提供了代码的反汇编。这不是所写的代码。汇编器已将三个伪操作转换为实际的 ARM 代码（粗体字体）：
- en: '[PRE44]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The first load instruction loads register `r0` with data from memory 36 bytes
    from the current program counter. At that location, the assembler has stored the
    `0x12345678` constant to be loaded.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次加载指令将寄存器 `r0` 从当前程序计数器内存的 36 个字节处加载数据。在那个位置，汇编器存储了要加载的 `0x12345678` 常量。
- en: The two `adr` operations generate an address by adding the distance between
    the pc and the data in memory. This is called *program counter relative addressing*
    and we will look at it in more detail later.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 两个 `adr` 操作通过添加 pc 和内存中数据之间的距离来生成一个地址。这被称为 *程序计数器相对寻址*，我们将在稍后更详细地探讨它。
- en: 'Let’s look at the data in memory. We use the `x/6xw 0x10080` gdb command to
    display six words of memory from address `0x10080`:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看内存中的数据。我们使用 `x/6xw 0x10080` gdb 命令从地址 `0x10080` 显示六个字的内存：
- en: '[PRE46]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This shows the `0x12345678` constant that has been loaded in memory following
    the program, together with the other constants we loaded.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了在程序之后加载到内存中的 `0x12345678` 常量，以及我们加载的其他常量。
- en: A note on endianism
  id: totrans-362
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于字节序的说明
- en: We’ve not mentioned one topic yet - *endianism*. The term is borrowed from *Gulliver’s
    Travels* where the world is divided into those who eat their boiled eggs from
    the big end and those who eat their eggs from the little end. This divides the
    world into mutually hostile big enders and little enders (it is, of course, satire).
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有提到一个主题 - *字节序*。这个术语是从 *格列佛游记* 中借用的，在那里世界被分为那些从大端吃煮鸡蛋的人和那些从小端吃鸡蛋的人。这把世界分成了相互敌对的大端序者和小端序者（当然，这是讽刺）。
- en: Computers do something similar. Suppose you store the 32-bit hexadecimal value
    `0x12345678` in memory. If you stored this in word memory, where the address of
    each word differs by 1, life would be simple. But because computer memories are
    *byte-organized*, each memory location has an individual byte address, so successive
    byte addresses are `0,1,2,3,4,5,6…` and successive word addresses are `0,4,8,12,16,20,24…`.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机做类似的事情。假设你在内存中存储了 32 位的十六进制值 `0x12345678`。如果你在字内存中存储它，其中每个字的地址相差 1，那么生活就会很简单。但是因为计算机内存是
    *字节组织* 的，每个内存位置都有一个独立的字节地址，所以连续的字节地址是 `0,1,2,3,4,5,6…`，而连续的字地址是 `0,4,8,12,16,20,24…`。
- en: A consequence of byte addressing means that word 0 occupies byte addresses 0,1,2,3\.
    Suppose we store `0x12345678` at address 0\. Which end of the number do we put
    in first? Is it stored in bytes 0 to 3 as `12 34 56 78` or as `78 56` `34 12`?
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 字节寻址的一个后果是，字 0 占据字节地址 0,1,2,3。假设我们在地址 0 存储了 `0x12345678`。我们首先放哪个数字的端？它是存储在字节
    0 到 3 作为 `12 34 56 78`，还是作为 `78 56` `34 12`？
- en: '*Figure 9**.4* illustrates three memory systems. In all three cases, memory
    is byte-addressed. In the 32-bit version, we have two 32-bit values representing
    `0x12345678` stored in memory at addresses c and `0x1014`. Notice that the individual
    bytes of the stored word have different byte addresses. A little-endian number
    is arranged so that the most significant byte, `0x12`, is stored in the lowest
    address of the word `0x1010`. A big-endian number is stored with the most-significant
    byte at the lowest address, `0x1013`.'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9**.4* 展示了三个内存系统。在所有三种情况下，内存都是字节寻址的。在 32 位版本中，我们在地址 c 和 `0x1014` 存储了代表 `0x12345678`
    的两个 32 位值。注意存储的字的各个字节有不同的字节地址。小端序数字的安排使得最高有效字节 `0x12` 存储在字的最低地址 `0x1010`。大端序数字存储时，最高有效字节存储在最低地址
    `0x1013`。'
- en: '![Figure 9.11 – Memory organization](img/Figure_9.11_B19624.jpg)'
  id: totrans-367
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.11 – 内存组织](img/Figure_9.11_B19624.jpg)'
- en: Figure 9.11 – Memory organization
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.11 – 内存组织
- en: Some computers are big-endian and some little-endian. Motorola microprocessors
    are big-endian and Intel is little-endian. ARM was originally little-endian, but
    it now has a bit in its CPSR status register that can be used to select the required
    version of endianism. By default, the ARM is little-endian.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 有些计算机是大端字节序，有些是小端字节序。摩托罗拉微处理器是大端字节序，英特尔是小端字节序。ARM 最初是小端字节序，但现在它在 CPSR 状态寄存器中有一个位可以用来选择所需的字节序版本。默认情况下，ARM
    是小端字节序。
- en: Does the endian matter? It matters in two ways. If you are building systems
    or interfacing systems with mixed endianism, it matters because you must ensure
    that the bytes are in the correct sequence when passed from one system to another.
    For example, the TCP/IP protocol is big-endian. Equally, if you are performing
    byte and word operations on data, you have to be aware of the relationship between
    byte and word addresses. If you store the ASCII “Mike” at word address `0x1000`
    and you wanted the *“e,”* it would be at `0x1000` in a big-endian system and `0x1003`
    in a little-endian system.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 字节序重要吗？有两种方式很重要。如果你正在构建系统或与具有混合字节序的系统进行接口，那么它很重要，因为当你将字节从一个系统传递到另一个系统时，你必须确保字节顺序是正确的。例如，TCP/IP
    协议是大端字节序。同样，如果你在对数据进行字节和字操作，你必须意识到字节地址和字地址之间的关系。如果你将 ASCII 字符串“Mike”存储在字地址 `0x1000`，并且你想要“e”，在大端系统中它将是
    `0x1000`，而在小端系统中它将是 `0x1003`。
- en: Bringing everything together – a final example
  id: totrans-371
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将一切组合在一起 – 一个最终示例
- en: To conclude this chapter, we provide a final example of using the Raspberry
    Pi to enter the ARM assembly language and run it in a debugging mode using gdb.
    As before, the example does not perform a useful function. Its purpose is to demonstrate
    addressing modes, the use of assembler directives to load data in memory, the
    nature of endianism, and the ability to declare variables in memory and modify
    them.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 为了结束本章，我们提供了一个使用 Raspberry Pi 进入 ARM 汇编语言并使用 gdb 在调试模式下运行的最终示例。与之前一样，此示例不执行有用的功能。其目的是演示寻址模式、使用汇编指令在内存中加载数据、字节序的性质以及声明变量并在内存中修改它们的能力。
- en: This example also demonstrates how memory data is displayed and how to use the
    memory display function to read data. We have used gdb and copied various screens
    during the debugging. These have been put together in what follows. We have removed
    some material (e.g., status registers and registers not accessed) and have slightly
    edited the format for readability.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例还演示了如何显示内存数据以及如何使用内存显示功能来读取数据。我们在调试过程中使用了 gdb 并复制了各种屏幕。以下将这些内容组合在一起。我们删除了一些材料（例如，状态寄存器和未访问的寄存器），并对格式进行了轻微编辑以提高可读性。
- en: The source program
  id: totrans-374
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 源程序
- en: The source program sets up data in memory and accesses it. We use ASCII text
    and numeric text as part of the demonstration. Note that an ASCII string or character
    using the GCC assembler requires double quotes. We also read bytes with ldrb and
    a halfword (16 bits) with ldrh.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 源程序在内存中设置数据并访问它。我们在演示中使用了 ASCII 文本和数字文本。请注意，使用 GCC 汇编器，ASCII 字符串或字符需要双引号。我们还使用
    ldrb 读取字节，使用 ldrh 读取半字（16 位）。
- en: The program uses `ldrb r5,[r3,#1]` to demonstrate reading bytes from a 32-bit
    word that is 3 bytes on from the base address of the word in r5.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 程序使用 `ldrb r5,[r3,#1]` 来演示从 r5 的字基址开始的 32 位字中读取字节。
- en: The program contains dummy data stored in memory, such as `0xAAAAAAAA`. We do
    this to demonstrate how data is stored, but mainly to help with debugging. When
    you display data contents in memory, these dummy values provide great markers
    to help you read the memory data.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 程序包含存储在内存中的虚拟数据，例如 `0xAAAAAAAA`。我们这样做是为了演示数据是如何存储的，但主要是为了帮助调试。当你显示内存中的数据内容时，这些虚拟值提供了很好的标记，帮助你读取内存数据。
- en: 'Note that the word that we access in read/write memory, testRW, is in a .data
    section. This is initialized to `0xFFFFFFFF` and is later modified:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在读写内存中访问的字 testRW 位于 .data 部分。它被初始化为 `0xFFFFFFFF`，后来被修改：
- en: '[PRE47]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The first steps are to assemble and load the program (called endian) and invoke
    the gdb debugger. We use bold font to indicate input from the keyboard:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是汇编和加载程序（称为 endian）并调用 gdb 调试器。我们使用粗体字来表示来自键盘的输入：
- en: '[PRE49]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We can use gdb to set a breakpoint at `_start` and then run the program to
    that breakpoint:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 gdb 在 `_start` 处设置断点，然后运行程序到该断点：
- en: '[PRE50]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Let’s look at the program that is actually loaded into memory. This differs
    slightly from the one we wrote because pseudo-operations have been replaced by
    actual code. Note that the `adr` is translated into an `add` by taking the program
    counter and adding the distance of the required variable to the current pc to
    generate its address.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看实际加载到内存中的程序。它与我们所写的程序略有不同，因为伪操作已被实际代码所取代。请注意，`adr` 被翻译成 `add` 指令，通过将程序计数器与所需变量的距离相加，以生成其地址。
- en: 'The `ldr r8,=0x12345678` is translated into a load program counter relative
    instruction because the required constant has been loaded into memory after the
    end of the program:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '`ldr r8,=0x12345678` 被翻译成一条加载程序计数器相对指令，因为所需的常量已在程序结束之后加载到内存中：'
- en: '[PRE51]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This differs from the code we wrote because pseudo-operations have been replaced
    by actual ARM code. Note that the `adr` is translated into an `add` by taking
    the program counter and adding the distance of the required variable to the current
    pc to generate its address.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们所写的代码不同，因为伪操作已被实际的 ARM 代码所取代。请注意，`adr` 被翻译成 `add` 指令，通过将程序计数器与所需变量的距离相加，以生成其地址。
- en: The `ldr r8,=0x12345678` is translated into a load program counter relative
    instruction because the required constant has been loaded into memory after the
    end of the program.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '`ldr r8,=0x12345678` 被翻译成一条加载程序计数器相对指令，因为所需的常量已在程序结束之后加载到内存中。'
- en: Let’s look at memory. The following shows the contents of 8 consecutive words
    starting with `0x100b4`, which is the address of the `svc` `0` instruction.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看内存。以下显示了从 `0x100b4` 开始的 8 个连续字的内存内容，这是 `svc 0` 指令的地址。
- en: 'Before continuing and executing the program, we will look at the contents of
    memory, set up by the program. Where is this data? It follows the last executable
    instruction, `svc 0`, which is at address `0x000100B4`. We display the eight words
    from the `svc` in hexadecimal format:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续执行程序之前，我们将查看程序设置的内存内容。这些数据在哪里？它遵循最后一个可执行指令 `svc 0`，该指令的地址为 `0x000100B4`。我们以十六进制格式显示
    `svc` 指令中的八个字：
- en: '[PRE53]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: You can see the `0x12345678` constant loaded by the assembler and some of the
    markers.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到汇编器加载的 `0x12345678` 常量和一些标记。
- en: 'We will step through the first few instructions:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将逐步执行前几条指令：
- en: '[PRE54]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The next step is to look at the registers before the program runs to completion.
    We do this with gdb’s `i r` command. There’s not much to see yet (it’s a partial
    listing), as we’ve executed only the first few instructions. However, `r0` now
    contains a pointer to the ASCII text string *“Mike”* at address `0x100B8`. If
    you look back at that address, you see that it contains `0x656b694d`, which is
    `ekiM`. That’s what little-endian does!
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是查看程序运行完成之前的寄存器状态。我们使用 gdb 的 `i r` 命令来完成此操作。目前没有太多可看的内容（这是一个部分列表），因为我们只执行了前几条指令。然而，`r0`
    现在包含指向地址 `0x100B8` 的 ASCII 文本字符串 *“Mike”* 的指针。如果您查看该地址，您会看到它包含 `0x656b694d`，这是
    `ekiM`。这就是小端序的作用！
- en: '[PRE55]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Continuing single-stepping:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 继续单步执行：
- en: '[PRE57]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Let’s look at the memory in the data section. Register `r7` points to the read/write
    data area. It starts 4 bytes before the pointer to `testRW`, in `r7` ; that is,
    `0x200CC - 4 = 0x200C8`. The four words beginning at that address are as follows:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看数据段的内存。寄存器 `r7` 指向读写数据区域。它位于 `testRW` 指针之前 4 个字节处，在 `r7` 中；即 `0x200CC -
    4 = 0x200C8`。从该地址开始的四个字如下：
- en: '[PRE58]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Finally, we step through the instruction until we meet the `nop` at the end:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们逐步执行指令，直到遇到最后的 `nop` 指令：
- en: '[PRE59]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Let’s take a final look at the state of the registers:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们最后看看寄存器的状态：
- en: '[PRE61]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Here’s our final look at the data memory. Note that `0xFFFFFFFF` has been replaced
    with the value `0x12345678` that we wrote to memory. This demonstrates how you
    can access data memory using an ARM.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们对数据内存的最终查看。注意，`0xFFFFFFFF` 已被替换为我们写入内存的值 `0x12345678`。这展示了如何使用 ARM 访问数据内存。
- en: 'Note also the data value at `0x200D0` ; that is, `0x7777a987`. We have changed
    half the word using a halfword load:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意 `0x200D0` 处的数据值；即 `0x7777a987`。我们使用半字加载更改了半个字：
- en: '[PRE62]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Summary
  id: totrans-412
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have introduced a real computer, the Raspberry Pi. Instead
    of designing our own computer instruction sets, we’ve looked at the ARM microprocessor
    that is at the heart of the Raspberry Pi and most smartphones.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了一台真正的计算机，树莓派。我们不是设计自己的计算机指令集，而是查看树莓派和大多数智能手机核心中的 ARM 微处理器。
- en: We introduced the basics of the Raspberry Pi and showed how to write an ARM
    assembly language program that can run on it. This requires an understanding of
    the ARM assembler and the use of the linker. We demonstrated how you can then
    run your ARM program instruction-by-instruction using the gdb debugger.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 我们介绍了 Raspberry Pi 的基础知识，并展示了如何编写可以在其上运行的 ARM 汇编语言程序。这需要理解 ARM 汇编器和链接器的使用。我们演示了如何使用
    gdb 调试器逐条指令运行您的 ARM 程序。
- en: 'One important feature of Raspberry Pi’s architecture we have encountered is
    the way in which data in memory is modified. You cannot use a str (store) instruction
    to modify data in memory. You must do it indirectly via a pointer to the address
    of the memory you wish to change. The following short program demonstrates this
    vital point. A data item in memory is read directly using an `ldr` but modified
    in memory using a pointer to a pointer. The key operations are in bold:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遇到的一个重要的 Raspberry Pi 架构特点是内存中数据修改的方式。您不能使用 str（存储）指令来修改内存中的数据。您必须通过指向您想要更改的内存地址的指针间接地完成。以下简短的程序演示了这一关键点。内存中的数据项直接使用
    `ldr` 读取，但在内存中使用指向指针来修改。关键操作以粗体显示：
- en: '[PRE63]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: In order to demonstrate an ARM program, we have introduced the ARM’s assembly
    language. Mercifully, this is not too far from the language adopted by some of
    the simulators. Indeed, the ARM’s assembly language is not too difficult to learn,
    although it does incorporate some very interesting features, which we will describe
    in later chapters.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示 ARM 程序，我们介绍了 ARM 的汇编语言。幸运的是，这并不太远离一些模拟器所采用的编程语言。实际上，ARM 的汇编语言并不难学，尽管它确实包含了一些非常有趣的特点，这些特点我们将在后面的章节中描述。
- en: 'In the next chapter, we return to the ARM architecture and one of its most
    important aspects: addressing and how data is transferred to and from memory.'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将回到 ARM 架构及其最重要的方面之一：寻址以及数据如何从内存中传输到和从内存中传输出来。
