- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Raspberry Pi: An Introduction'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In previous chapters, we introduced the digital computer and explained its operation
    at the instruction set level. Now you will learn about a real, low-cost computer
    that was designed for educational purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we introduce Raspberry Pi, which is based on the popular ARM
    microprocessor. We describe its instruction set architecture and demonstrate how
    you can use it to run assembly language programs in debugging mode. The highlights
    of this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: An introduction to Raspberry Pi’s operating system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the GCC ARM assembler and linker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging ARM assembly language programs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is not a handbook for Raspberry Pi. We are interested only in using it
    to enter assembly language programs, run them, and observe their behavior. We
    do not cover Raspberry Pi’s Windows-style GUI because it is very similar to the
    corresponding PC and macOS user interfaces. Moreover, the Raspberry Pi operating
    system includes utilities and a web browser.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter is based on the Raspberry Pi 4\. The software we use should also
    be compatible with the earlier 3B model. In order to use Raspberry Pi, you will
    need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Raspberry Pi 4 (available with 2 GB, 4 GB, and 8 GB DRAM)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Raspberry Pi 5V 3A power supply
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: USB mouse
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: USB keyboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wi-Fi internet connection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Video display with micro HDMI lead
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 32 GB Class 10 micro SD card pre-loaded with NOOBS (see the note at the end
    of this section)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All these items are available on Amazon or from Raspberry Pi suppliers. You
    can get the operating system pre-loaded onto a micro SD card, or download the
    operating system and preload it onto your own card using a PC or Mac. The Raspberry
    Pi web page at [https://www.raspberrypi.org/](https://www.raspberrypi.org/) provides
    full details about this computer including getting started, setting up, and loading
    the operating system on your own card.
  prefs: []
  type: TYPE_NORMAL
- en: The text was written using **NOOBS** (**New Out Of the Box Software**). The
    Raspberry Pi Foundation no longer supports NOOBS and recommends that you download
    the latest version of the operating system using Raspberry Pi Imager, which runs
    under macOS, Windows, and Ubuntu. You can find the necessary information at [https://www.raspberrypi.org/](https://www.raspberrypi.org/).
  prefs: []
  type: TYPE_NORMAL
- en: The ARM code we use in this book is designed to run on a Raspberry Pi with a
    32-bit operating system.
  prefs: []
  type: TYPE_NORMAL
- en: Raspberry Pi basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Microcomputers have been around since the 1970s. In the 1970s, several systems
    aimed at the enthusiast based on the Z80, 6502, and 6809 8-bit microprocessors
    appeared. Operating systems, apps, and the web didn’t exist then.
  prefs: []
  type: TYPE_NORMAL
- en: Then, in the late 1970s, Intel introduced the 8086 and Motorola its 68000 16-bit
    CPU (the 68000 microprocessor actually had a 32-bit instruction set architecture,
    but Motorola marketed it initially as a 16-bit machine. In my view this was a
    catastrophic marketing mistake. 16-bit computers were a giant leap up from their
    8-bit predecessors for two reasons. First, the technology had advanced, permitting
    designers to put far more circuitry on a chip (i.e., more registers, more powerful
    instruction sets, etc.), and second, processors were far faster due to the reduction
    in feature size (i.e., smaller transistors). Finally, the declining cost of memory
    meant that people could run larger and more sophisticated programs.
  prefs: []
  type: TYPE_NORMAL
- en: In the 1960s, the giant corporation IBM was famous for its large-scale data-processing
    machines. However, IBM wanted a change of direction and IBM’s engineers decided
    to build a PC around Motorola’s 68000 processor. Unfortunately for Motorola, a
    version of that chip wasn’t yet in production. Intel released the 8088, an 8-bit
    version of its 16-bit 8086 processor with an 8-bit data bus that made it easy
    to create a low-cost microcomputer using 8-bit peripherals and memory components.
    The 8088 still had a 16-bit architecture but was able to interface to 8-bit memory
    and I/O devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'IBM formed a relationship with Intel, and the IBM PC in all its beige-colored
    splendor arose in 1981\. Unlike Apple, IBM created an open architecture that anyone
    could use without paying a royalty. And a million PC clones flowered. The rest
    is history. However, the PC and Apple’s Mac left a hole in the market: an ultra-low-cost
    computer that the young, the student, the experimenter, and the enthusiast can
    play with. Raspberry Pi plugs this gap.'
  prefs: []
  type: TYPE_NORMAL
- en: Low-cost computing has been around for a long time. For a few dollars, you can
    buy a greeting card that plays “Happy Birthday” when you open it. High-performance
    computing is more expensive. The cost of a computer often lies not in the processor
    but in the supporting cast of components and systems required to convert a microprocessor
    into a computer system – in particular, the graphics and display interface, the
    memory interface, and the communications interface (input/output). That’s why
    the Raspberry Pi has been such an amazing success. On a tiny, low-cost board,
    you have all the peripherals and interfaces that you need to create a complete
    system comparable to a PC (although not in terms of performance).
  prefs: []
  type: TYPE_NORMAL
- en: To turn the board into a fully-fledged microcomputer, you need only a low-cost
    power supply and the very same mouse and keyboard you would use with a PC. Indeed,
    many people use peripherals left over from PCs and other computers they have lying
    around. I bought a 2-to-1 HDMI switch to interface my 4K monitor to both my PC
    and Raspberry Pi. You just press a button and the display switches from PC to
    Raspberry Pi. The Raspberry Pi uses an open source operating system with vast
    amounts of free software. No more having to take out a mortgage for Office or
    Photoshop.
  prefs: []
  type: TYPE_NORMAL
- en: The Raspberry Pi was an outstanding success and rapidly created a very large
    and enthusiastic following. It found applications at all levels of education from
    kindergarten to PhD. Over the years, improved versions of Raspberry Pi were introduced,
    as well as truly minimal versions that could be used as dedicated embedded processors
    for a few dollars.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 9**.1* illustrates the Raspberry Pi 4 that was used while writing this
    book. The first Raspberry Pi Model B appeared in 2012 with 256 MB of DRAM, USB
    ports, and Ethernet, but no wireless communications. By 2019, the Raspberry Pi
    4 was available with 2 USB 2.0 and 2 USB 3.0 ports, on-board Wi-Fi 502.11ac, Bluetooth
    5, and Gigabit Ethernet, plus dual-monitor support via 2 micro HDMI ports capable
    of supporting 4K displays. The principal features of the RPi 4 are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The powerful ARM CPU (Quad core Cortex-A72 64-bit architecture)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Audio (sound processing system)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Video display and graphics logic system (you just need to plug the card into
    a monitor)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DRAM main memory (2, 4, or 8 GB)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Non-volatile flash memory with the operating system (not normally included)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mouse and keyboard USB ports
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wi-Fi (both 2.4 and 5.0 GHz bands)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bluetooth 5.0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ethernet port
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A general I/O port for directly interfacing with external hardware
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 9.1 – The Raspberry Pi 4 (Image by Laserlicht / Wikimedia Commons
    / CC BY-SA 4.0)](img/Figure_9.01_B19624.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.1 – The Raspberry Pi 4 (Image by Laserlicht / Wikimedia Commons / CC
    BY-SA 4.0)
  prefs: []
  type: TYPE_NORMAL
- en: The Raspberry Pi board is not normally sold with an operating system. It has
    a micro-SD port into which you have to insert a memory card containing a suitable
    operating system. You can buy a card with the OS already installed, or load one
    of the freely available variants from the web onto a card (using your PC or Mac)
    and plug it into the Raspberry Pi.
  prefs: []
  type: TYPE_NORMAL
- en: The classic operating system used by computer scientists in academia is Unix,
    which was developed at AT&T’s Bell Labs in the late 1960s by a team that included
    Ken Thomson and Dennis Richie (two of the most significant players in computer
    science history). Unix was one of the first operating systems to become portable
    – that is, to run on different types of computers.
  prefs: []
  type: TYPE_NORMAL
- en: A strong thread in the history of computer science is open software – that is,
    software developed by a community of individuals that is freely available, such
    as the Python programming language and the LibreOffice application package, which
    provides much of the functionality of Microsoft’s Office suite.
  prefs: []
  type: TYPE_NORMAL
- en: In the 1980s, the Free Software Foundation led by Richard Stillman led the development
    of the GNU operating system, which was designed to provide an open source version
    of Unix. In 1991, Linus Torvalds released an open source component of GNU, its
    kernel, called Linux.
  prefs: []
  type: TYPE_NORMAL
- en: Today, the Linux kernel plus the GNU tools and compilers have become a free,
    open source alternative to proprietary operating systems such as Windows. GNU/Linux
    is available in different flavors (distributions written by various groups with
    the same basic structure but different features). The original official Raspberry
    Pi operating system was called *Raspbian* and is based on a version of Debian
    Linux optimized for Raspberry Pi.
  prefs: []
  type: TYPE_NORMAL
- en: Unix and Linux operate in a *command-line mode* – that is, operating system
    instructions are entered in text form (just like Microsoft’s DOS). Unix, Linux,
    and DOS all now have user-friendly graphical inputs that make use of the mouse
    as a key input device. The most famous of these graphical inputs is Microsoft’s
    Windows operating system.
  prefs: []
  type: TYPE_NORMAL
- en: Raspberry Pi now includes both a Windows-based version of Linux and a text-based
    command-line interface that is used to invoke some of the tools required to assemble
    and execute ARM assembly language programs. This chapter provides a very short
    introduction to RPi’s Linux operating system.
  prefs: []
  type: TYPE_NORMAL
- en: The Raspberry Pi operating system includes several packages that are very relevant
    to this book. For example, the Thonny Python IDE provides an **integrated development
    environment** (**IDE**) for Python and software to edit, assemble, debug, and
    run Python programs.
  prefs: []
  type: TYPE_NORMAL
- en: Another useful package is the Geany editor, which has built-in support for more
    than 50 programming languages. You can get Geany at [https://www.geany.org/](https://www.geany.org/).
  prefs: []
  type: TYPE_NORMAL
- en: There is also a Terminal emulator window that lets you operate in the Linux
    command-line mode – a feature that is useful when working with the ARM assembly
    language utilities. *Figure 9**.2* shows the Raspberry Pi screen on a 4K monitor
    with several windows open.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.2 – Screenshot of Raspberry Pi’s multiple windows](img/Figure_9.02_B19624.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.2 – Screenshot of Raspberry Pi’s multiple windows
  prefs: []
  type: TYPE_NORMAL
- en: While writing this book, I was also introduced to Visual Studio Code, which
    is an editor and debugging platform. Visual Studio Code is free and available
    on Linux, macOS, and Windows platforms. *Figure 9**.3* shows an example of a session
    using Visual Studio Code to write a Python program.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.3 – A VS Code session while developing a Python program](img/Figure_9.03_B19624.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.3 – A VS Code session while developing a Python program
  prefs: []
  type: TYPE_NORMAL
- en: I must thank Graeme Harker for encouraging me to use VS Code. Had I discovered
    VS Code earlier, I would probably have stuck to that.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve introduced the ubiquitous Raspberry Pi that can form the basis
    of a computer system with the addition of a mouse, keyboard, and display, we are
    going to introduce its operating system.
  prefs: []
  type: TYPE_NORMAL
- en: However, we do not delve too deeply. In order to use the Raspberry Pi to enter,
    run, and debug ARM assembly language, you need to know only a few basic elements
    of the operating system. Moreover, even though the Raspberry Pi has a Unix-based
    command-line operating system, it includes a graphical interface that behaves
    very much like Windows or macOS.
  prefs: []
  type: TYPE_NORMAL
- en: Basics of the Raspberry Pi operating system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you will learn how to use the Raspberry Pi to create an ARM
    assembly language program, assemble it into code that can be executed, and then
    run it on the Raspberry Pi. In the next chapter, we will look at the ARM architecture
    in greater depth.
  prefs: []
  type: TYPE_NORMAL
- en: We do not devote much time discussing RPi’s operating system because the world
    is full of websites devoted to Linux. We will cover the absolute minimum to help
    you use some of the commands that may be helpful. Most readers will use a graphical
    interface to perform editing, web searches, and running programs such as Python.
    We will introduce the basic concepts of Linux’s filing system and the command-line
    instruction necessary to assemble and run a source file written in the ARM assembly
    language. Unfortunately, the names of Unix/Linux commands are not intuitive.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 9**.4* illustrates the basic concepts of the Linux hierarchical operating
    system, with a node at each level that can support *child* nodes at a lower level;
    for example, `Desktop` is a child of the `pi` node.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.4 – The Raspberry Pi file structure](img/Figure_9.04_B19624.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.4 – The Raspberry Pi file structure
  prefs: []
  type: TYPE_NORMAL
- en: The top-level folder is `/` and is called the *root folder*. The `/` backslash
    is used to navigate the filing system very much like the Windows equivalent. A
    big difference between Linux and Windows is that, in Linux, you don’t have to
    specify the disk on which the file resides (e.g., Windows invariably uses `c:/`
    for operating systems files). In *Figure 9**.4*, the `MyFile.doc` file is a text
    file whose location is `/home/pi/Documents/MyFile.doc.`
  prefs: []
  type: TYPE_NORMAL
- en: Directory navigation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you press the enter key, Raspberry Pi responds with an “*I am here*” prompt,
    as shown in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`pi@raspberrypi:`/var/log/apt $'
  prefs: []
  type: TYPE_NORMAL
- en: 'This prompt gives the device name and the path to the current directory (in
    bold font in this example). You can change the active directory with the `cd`
    (*change directory*) command, as shown in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: To list the files and subdirectories in the current directory, you can use the
    `ls` command (*list files*).
  prefs: []
  type: TYPE_NORMAL
- en: The `ls` -l /home/pi command generates the following output that gives permissions
    (what you can do with them), their size, and creation dates. *Figure 9**.5* demonstrates
    this command.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.5 – The Raspberry Pi File Structure](img/Figure_9.05_B19624.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.5 – The Raspberry Pi File Structure
  prefs: []
  type: TYPE_NORMAL
- en: The `ls` command has several options; for example, `ls ~` indicates a list in
    the home directory. In Linux, the tilda`, ~,` indicates the home directory. Similarly,
    `ls –t` indicates list files by date and time created.
  prefs: []
  type: TYPE_NORMAL
- en: File operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We now introduce some of Linux’s basic file commands. The `pwd` command looks
    as if it should mean *password*. Actually, it means *print working directory*
    and displays the contents of the current directory. It’s a “*where am I?*” command.
    Entering `pwd` will generate a response such as `/home/pi`.
  prefs: []
  type: TYPE_NORMAL
- en: To create a new subdirectory, you use the `mkdir` command. Typing `mkdir` `newFolder`
    creates a subdirectory called `newFolder` in the current directory.
  prefs: []
  type: TYPE_NORMAL
- en: If you enter `mkdir /home/pi/newFolder`, it will create the subdirectory in
    `pi`.
  prefs: []
  type: TYPE_NORMAL
- en: One of Linux’s more confusing command names is `cat`, which lists the contents
    of a file. The name `cat` means `catalog`; for example, `cat /home/pi/firstExample.txt`
    displays the contents of the `firstExample.txt` file on the console as a text
    file.
  prefs: []
  type: TYPE_NORMAL
- en: To delete or *remove* a file, you use `rm`; for example, `rm tempData.py` deletes
    the `tempData.py` file in the current subdirectory. You can remove an entire directory
    with `rm -r`. This deletes the current directory and is not reversible. It is
    a dangerous command. The alternative is `rm –d`, which removes the current directory
    *only if it is empty* (i.e., you must first delete its contents).
  prefs: []
  type: TYPE_NORMAL
- en: Linux has a help command, `man` (i.e., manual) that provides details of another
    command; for example, `man ls` would provide details of the `ls` command.
  prefs: []
  type: TYPE_NORMAL
- en: In general, when working with Raspberry Pi, most users will be using the graphical
    interface. However, we will be using the command-line input to set up the Raspberry
    Pi and assemble, debug, and execute assembly language programs.
  prefs: []
  type: TYPE_NORMAL
- en: Installing and updating programs and packages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Having set up the RPi, you need to maintain it (i.e., install and update software).
    The following two commands retrieve new packages and update your software. It’s
    a good idea to run them occasionally to get new updates. Note that `sudo` stands
    for *superuser do* and is required for operations that may be restricted to the
    administrator because they can harm the system if used inappropriately. The term
    `aptget` obtains and installs packages (`apt = Advanced` `Package Tool`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: sudo apt-get update updates packages but does not install them.
  prefs: []
  type: TYPE_NORMAL
- en: To install a new package on Raspberry Pi, you use the `apt-get install` command;
    for example,
  prefs: []
  type: TYPE_NORMAL
- en: '`sudo apt-get install vim` installs the `vim` editor package.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Linux provides a shutdown command that ends a session in an orderly manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sudo shutdown -h now     Stop` and enter the halt state'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `-h` parameter indicates *enter the halt state*, and the `now` parameter
    indicates an immediate halt. A command to shut down is `sudo shutdown -r now`.
    To reboot Raspberry Pi, you can enter either of the following two commands. These
    commands have the same effect on a single-user system. You would use `shutdown
    -r` on a multi-user system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: However, most Raspberry Pi users will shut down Raspberry Pi using a mouse from
    its GUI. Indeed, the only time it’s necessary to use the text-based input mode
    is when assembling, linking, and debugging assembly language programs.
  prefs: []
  type: TYPE_NORMAL
- en: You can apply a delayed shutdown; for example, sudo shutdown -h 30 will shut
    down the RPi after 30 minutes. You can shut down at a specific clock time with,
    say, sudo shutdown -h 22:30, which shuts down at 10:30 P.M. A delayed shutdown
    command can be rescinded (canceled) by sudo shutdown -c.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and editing an assembly language program
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s go through the steps needed to create an ARM program on the Raspberry
    Pi and then execute it before we look at the ARM processor in greater detail.
    Although we haven’t introduced the ARM assembly language yet, the actions of the
    instructions we use are self-evident.
  prefs: []
  type: TYPE_NORMAL
- en: First, you have to create an assembly language program in text form with a `.s`
    file type. There are many text editors and the one you choose is a personal preference.
    I initially used Geany, which is an IDE for languages such as C. I later used
    Thonny on my desktop PC. Both Geany and Thonny are excellent tools. If you create
    a text file on a desktop PC (or any other device), you simply change the `.txt`
    extension to `.s` to make it compatible with RPi’s assembler.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 9**.6* shows the initial Geany screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.6 – Geany text editor window](img/Figure_9.06_B19624.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.6 – Geany text editor window
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 9**.7* shows a Geany window after we’ve created an ARM assembly language
    program:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.7 – Geany window – note that add r3,r0,r1 adds r0 to r1 and puts
    the sum in r0](img/Figure_9.07_B19624.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.7 – Geany window – note that add r3,r0,r1 adds r0 to r1 and puts the
    sum in r0
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following program, the text in bold font indicates an assembler directive
    that tells the assembler about the program’s environment and how to deal with
    the allocation of memory space:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note that ARM uses `mov` to load a literal and not `ldr` (as you might expect).
  prefs: []
  type: TYPE_NORMAL
- en: Assembling ARM code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we can look at the ARM architecture in depth, we will demonstrate how
    you write a program and run it. The Raspberry Pi’s Debian-based operating system
    includes GCC, the *GNU Compiler Collection*, which can compile both C programs
    and assembly language programs. We do not deal with C here.
  prefs: []
  type: TYPE_NORMAL
- en: 'The two GCC commands we need to assemble the source `myProg.s` text file are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The first command, `as`, takes the assembly language *source* file, `myProg.s`,
    and creates an *object* code file, `myProg.o`. The second command, `ld`, invokes
    a *linker* that uses the object file to create a binary code file, `myProg`, that
    can be executed. The `-o` option is necessary to build an output file. You can
    then run the assembled binary code program by typing `./myProg`.
  prefs: []
  type: TYPE_NORMAL
- en: Although a *single* assembly language program can be assembled to create binary
    code, programs are often written in modules (files) that are fitted together.
    These files may be written by different programmers or even library programs.
    They are individually assembled to create files that the linker combines to create
    the final binary code that can be executed. In this text, we do not make full
    use of the linker’s facilities; all assembly language programs are single files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following the linking operation, an executable binary program is created. Let’s
    now type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`./myProg ;` `echo $?`'
  prefs: []
  type: TYPE_NORMAL
- en: The `myProg` binary code is executed and a message is displayed. A semicolon
    in Linux allows two commands to be put on the same line; the two operations are
    *execute a program* and *display* *a message*.
  prefs: []
  type: TYPE_NORMAL
- en: The `echo $?` command prints a message from the executed program. The print
    command is `echo` and `$?` indicates the actual message to be printed. In this
    case, the `$?` command returns the exit status of the last command. You can print
    other messages; for example, `$3` prints the contents of register `r3`.
  prefs: []
  type: TYPE_NORMAL
- en: Note that if a program crashes or goes into an endless loop (non-responsive),
    you can enter `control-C` to escape and return to the OS level.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging assembly language
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will now introduce the ARM debugger that lets you monitor the execution of
    a program and trace code just as we did with the simulators of [*Chapter 6*](B19624_06.xhtml#_idTextAnchor091)
    and [*Chapter 7*](B19624_07.xhtml#_idTextAnchor121).
  prefs: []
  type: TYPE_NORMAL
- en: 'What we want is the ability to monitor the execution of an assembly language
    program, a task that we’ve already done when running Python computer simulators.
    We can do this with a *debugger*, called `gdb`, which is part of the GCC compiler
    suite. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `-g` parameter in the assembler section generates information for later
    use by the `gdb` debugger.
  prefs: []
  type: TYPE_NORMAL
- en: '`gdb` is a very powerful tool with the facilities required to debug a program.
    We are going to look at only these facilities that allow us to run an ARM assembly
    language program and observe its execution, line by line. We begin by listing
    some of `gdb`’s commands. These commands can be abbreviated; for example, the
    `quit` command can be entered as q. In *Table 9.1*, we put the required part of
    the command in bold, and the part of the command that can be omitted in gray,
    such as quit. Note the difference between `next` and `step`. These are the same
    except when they encounter a *function*. Step traces all the operations in a function,
    whereas next treats the function as a single instruction and does not trace it.'
  prefs: []
  type: TYPE_NORMAL
- en: When you load a program into `gdb`, nothing appears to happen. If you try to
    look at your assembly language code or the registers, you will get an error message.
    You must explicitly run the program first.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Command** | **Effect** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| quit | Quit: leave the gdb debugger and return to the shell. Ctrl + D also
    exits gdb. |'
  prefs: []
  type: TYPE_TB
- en: '| list | List: list the program being debugged. |'
  prefs: []
  type: TYPE_TB
- en: '| run | Run: execute the program. The program will run to completion or to
    a breakpoint. |'
  prefs: []
  type: TYPE_TB
- en: '| break | Breakpoint: Execution runs until a breakpoint is encountered. The
    breakpoint can be a line number, an address, or a label. |'
  prefs: []
  type: TYPE_TB
- en: '| info r | Info: show registers. This command displays register contents. |'
  prefs: []
  type: TYPE_TB
- en: '| info b | Info: show breakpoints. This displays breakpoints. |'
  prefs: []
  type: TYPE_TB
- en: '| continue | Continue: resume execution after a breakpoint. |'
  prefs: []
  type: TYPE_TB
- en: '| delete | Delete: remove a breakpoint. Enter `d <number>` to remove a specific
    breakpoint. |'
  prefs: []
  type: TYPE_TB
- en: '| next | Single step (execute one instruction). This does not trace a function.
    |'
  prefs: []
  type: TYPE_TB
- en: '| step | Single step including all the operations in a function. |'
  prefs: []
  type: TYPE_TB
- en: '| file <name> | Load a binary code file into gdb for debugging. |'
  prefs: []
  type: TYPE_TB
- en: Table 9.1 – Basic gdb commands
  prefs: []
  type: TYPE_NORMAL
- en: Let’s write and debug an ARM program on the Raspberry Pi. We haven’t covered
    the ARM architecture yet. You don’t need to know a lot about the ARM to follow
    the example because it’s similar to the RISC architectures we simulated in [*Chapter
    6*](B19624_06.xhtml#_idTextAnchor091). The ARM is a 32-bit computer with an RSIC
    architecture; that is, it is a load/store computer and the only memory accesses
    allowed are load and store. Operations on data are register-to-register using
    three operands – for example, `add r1,r2,r3`. The ARM has 16 registers, `r0` to
    `r15`. Registers `r0` to `r12` can be treated as general-purpose (i.e., they all
    behave in the same way). Registers `r13`, `r14`, and `r15` have specific functions.
  prefs: []
  type: TYPE_NORMAL
- en: Pseudo instructions – a key concept
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The ARM assembler includes *pseudo-instructions* that are not part of the ARM’s
    `clr` `r0` instruction that loads `r0` with `0`. A pseudo-instruction, `clr r0`,
    could be devised and the assembler could automatically replace it with the `sub
    r0`,`r0` operation, which has the same effect.
  prefs: []
  type: TYPE_NORMAL
- en: Pseudo-instructions make the programmer’s life easier; for example, the ARM’s
    `adr` r0,`abc` pseudo-instruction loads a 32-bit address, ABC, into `r0`. Such
    an instruction does not exist; the assembler replaces adr with the appropriate
    ARM instructions.
  prefs: []
  type: TYPE_NORMAL
- en: An example of an ARM program
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Suppose we wish to generate the sum of the cubes of numbers from 1 to 10\.
    The following ARM code implements this algorithm. It also uses the ARM’s four-operand
    *multiply and* *accumulate*, `mla`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The label field beginning in the first column (bold in the preceding code)
    provides a *user-defined* tag that must be terminated by a colon. The label field
    is followed by the instruction consisting of an operation and any required operands.
    It doesn’t matter if there is more than one space after commas in argument lists.
    The text following the `@` symbol is a comment field and is ignored by the assembler.
    The GCC compiler also supports the C language style of comments: text delimited
    by `/* */` characters, as this example shows.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Table 9.2* describes some of the ARM’s instructions. There is only one surprise
    here; the `mla` *multiply and add instruction* that specifies *four* registers.
    It multiplies two registers together and adds a third register, and then puts
    the sum in a fourth register; that is, it can calculate `A = B +` `C.D`:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Instruction** | **ARM mnemonic** | **Definition** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Addition | `add` r0`,r1,r2` | [r0] ← [r1] + [r2] |'
  prefs: []
  type: TYPE_TB
- en: '| Subtraction | `sub` r0`,r1,r2` | [r0] ← [r1] - [r2] |'
  prefs: []
  type: TYPE_TB
- en: '| AND | `and` r0`,r1,r2` | [r0] ← [r1] ∧ [r2] |'
  prefs: []
  type: TYPE_TB
- en: '| OR | `orr` r0`,r1,r2` | [r0] ← [r1] ∨ [r2] |'
  prefs: []
  type: TYPE_TB
- en: '| Exclusive OR | `eor` r0`,r1,r2` | [r0] ← [r1] ⊕ [r2] |'
  prefs: []
  type: TYPE_TB
- en: '| Multiply | `mul` r0`,r1,r2` | [r0] ← [r1] × [r2] |'
  prefs: []
  type: TYPE_TB
- en: '| Register-to-register moveLiteral-to-register move | `mov` r0`,r1``mov` r0`,#0xAB`
    | [r0] ← [r1][r0] ← 0xAB Move 8-bit literal |'
  prefs: []
  type: TYPE_TB
- en: '| Compare | `cmp` r1`,r2` | [r1] – [r2] |'
  prefs: []
  type: TYPE_TB
- en: '| Branch on zero to label | `beq label` | [PC] ← label (jump to label if z
    = 1) |'
  prefs: []
  type: TYPE_TB
- en: '| Branch on not zero to label | `bne label` | [PC] ← label (jump to label if
    z = 0) |'
  prefs: []
  type: TYPE_TB
- en: '| Multiply and add | `mla` r0`,r1,r2,r3` | [r0] ← [r1] x [r2] + [r3] |'
  prefs: []
  type: TYPE_TB
- en: '| Load register from memory | `ldr` r0`,[r1]` | [r0] ← [[r1]] |'
  prefs: []
  type: TYPE_TB
- en: '| Store register in memory | `str r0,`[r1] | [[r1]] ← [r0] |'
  prefs: []
  type: TYPE_TB
- en: '| Call the operating system | `svc 0` | Request an operation from the OS |'
  prefs: []
  type: TYPE_TB
- en: Table 9.2 – ARM data processing, data transfer, and compare instructions
  prefs: []
  type: TYPE_NORMAL
- en: 'Some computers always update condition codes after an operation. The ARM does
    not automatically update its status flags after an operation; you have to command
    a status update by appending s to the appropriate mnemonic. For example, `add`
    r1`,r2,r3` performs an addition without updating status flags, whereas `add`sr1`,r2,r3`
    updates status flags. This is not yet a program. The following provides the code
    and assembly language directives needed to run it on the Raspberry Pi:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We’ve added an assembly language directive, `.global`, that declares the `_start`
    label as being *visible* outside this fragment of code. The GCC linking process
    links together separately assembled modules and inserts the appropriate addresses
    of the labels in the code.
  prefs: []
  type: TYPE_NORMAL
- en: By declaring a label as global, you are telling the linker that this label is
    visible to other modules and they can refer to it. Labels without a global directive
    are local to the current module and invisible to all other modules; that is, you
    could use the same label in two modules and there would not be a conflict.
  prefs: []
  type: TYPE_NORMAL
- en: The `_start` label indicates the point at which execution begins. The linker
    and operating system deal with storing the program in memory; that is, you don’t
    have to worry about where it is going to be actually stored in the computer’s
    physical memory.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the last two operations (shaded) provide a means of getting back to
    the operating system level once the code has been executed. ARM has an `svc` instruction,
    which stands for *service call* and is used to invoke the operating system. Most
    computers have an operation such as `svc` and it has many names – for example,
    *software interrupt*. This instruction calls the operating system and supplies
    one or more parameters. The parameter can be part of the instruction itself or
    it can be loaded into a register. When the operating system detects a service
    call, the parameter is read and the appropriate operation is performed. This action
    is entirely system dependent; that is, it is part of the operating system and
    not part of the computer’s architecture.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the specific function required by the service call is pre-loaded
    into `r7`. This mechanism is part of the Raspberry Pi’s operating system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Key points to note about the assembly language program are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Comments are preceded by an `@` symbol (or the C language `/* */` book ends)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assembler directives are preceded by a period
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Labels begin in the first column and are terminated by a colon
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An `.end` directive can be used to terminate the assembly language (it’s optional)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `.global` directive provides a label that indicates the entry point of the
    program
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Raspberry Pi debugger
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can now run an ARM assembly language program and observe its execution, line
    by line, using gdb. When you load a program into gdb, nothing appears to happen.
    If you try to look at your assembly language code or the registers, you will get
    an error message. You must explicitly run the program first.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the fragment of code in *Figure 9**.8*. This is a screenshot of the
    program after it’s been loaded into the Geany editor. It’s just a set of instructions
    and directives intended to demonstrate the steps involved in creating and testing
    an assembly language program. Here, we are using the Geany editor. The program
    demonstrates the following assembly language directives:'
  prefs: []
  type: TYPE_NORMAL
- en: '`.data`    Defines a memory region where variables and constants are stored.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.text`    Defines a region of code (i.e., the assembly language).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.word`    Allows you to store a number in memory and give the location a symbolic
    address.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.balign`  Aligns code and text on a 4-byte boundary. Required because instructions
    are 32 bits.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.asciz`   Creates an ASCII text string terminated by zero in memory and gives
    it a name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.global`  Makes a label visible to the linker. Otherwise, it is private to
    this module.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `balign` operation is required because memory is byte addressed and ARM
    instructions are 4 bytes long. Consequently, instruction addresses must be 0,
    4, 8, 12, 16, 20, and so on. If you put data elements in memory that are not multiples
    of 4 bytes (32 bits) between instructions, the program will crash. The `balign`
    instruction pads out any data you store with zeros to ensure that the next free
    address is on a 4-byte boundary.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the code in *Figure 9**.8* uses a *pseudo-instruction*. The instruction
    `ldr` r4`,=Alan3` loads `r4` with the 32-bit literal, `Alan3`. The assembler will
    automatically substitute the necessary ARM code to perform this operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to assemble and link the code, which we called a4.s (I got
    fed up with typing long names and called the source program a4.s). We can do this
    with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The text in bold is my input. These lines change the working directory to Desktop
    where my source program is, and then assemble and link the source program. The
    final line, `./a4 ; echo $?`, runs the program and prints its return value (showing
    it’s been successfully executed by printing `4`, the value in `r0`).
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.8 – The demonstration program in the Geany editor](img/Figure_9.08_B19624.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.8 – The demonstration program in the Geany editor
  prefs: []
  type: TYPE_NORMAL
- en: 'The following four lines demonstrate how we call the gdb debugger and set a
    breakpoint. Text in bold font indicates lines entered from the keyboard. The other
    text is the debugger’s output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Entering a breakpoint is done by b <breakpoint>, where the breakpoint is a
    line number or a label. Here, it’s _start. If we run the code, it executes instructions
    up to the breakpoint. The next few lines are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Note that you can continue from a breakpoint by entering `c` (i.e., continue)
    and execution will continue to the next breakpoint.
  prefs: []
  type: TYPE_NORMAL
- en: 'After entering a run command, the debugger begins execution and prints the
    next line to be executed – that is, the line labeled by _start. The gdb instruction
    i r (information registers) displays the ARM’s registers as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '`cpsr` and `fpscr` are both status registers that contain information about
    the state of the processor.'
  prefs: []
  type: TYPE_NORMAL
- en: 'All registers have been initialized to zero automatically by the system software,
    except r13, r15 (`sp, pc`), and the two status registers. We can now start tracing
    the code, executing instructions one by one with the step command, `s 1`. You
    can just hit `enter` to trace the next instruction, as the following output demonstrates.
    If you were to type si 2 (or s 2), you would step two instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s look at the registers using the i r command. We have removed registers
    from this list that haven’t changed to make it easier to read. Register contents
    are given in hex and decimal formats:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we will continue stepping until the code has been executed. You can
    step just by using the *enter* key after the first si 1 command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The gdb executes the move and supervisor call instruction and exits the simulation.
    What have we learned? This example demonstrates the following:'
  prefs: []
  type: TYPE_NORMAL
- en: How to create an ARM assembly language program
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to assemble and link it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to load it into the gdb debugger
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to set breakpoints and run the code until a breakpoint is reached
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to display the contents of registers at any point in a program
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to step through the code line by line
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tracing execution and displaying memory
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An important facility of a debugger is the ability to step through the code
    and display registers while executing a program. This allows you to follow the
    execution of a program and detect errors. The gdb debugger incorporates this facility
    via its `layout regs`.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 9**.9* provides a demonstration of the TUI with three panels. The upper
    window is the register window (the registers that have changed are highlighted;
    in this case, it’s `r7`). The middle panel displays the program code, with the
    next instruction to be executed highlighted. Each line includes the memory address
    of the code in hexadecimal form and as a distance from the `start` label.'
  prefs: []
  type: TYPE_NORMAL
- en: Note that the code continues after my last instruction, `svc`. This is because
    the disassembler reads a block of memory and displays it as code (even if it is
    not part of your program). In this case, the data we entered in memory with the
    `.word` directive is read and displayed as the corresponding ARM instruction.
    Remember that the debugger does not know whether a binary value in memory is an
    instruction or user data. If it reads a data value corresponding to an instruction
    op-code, it prints that op-code.
  prefs: []
  type: TYPE_NORMAL
- en: The disassembled instructions display their address in memory in hex form; for
    example, the first instruction is at `0x10074`. This address is determined by
    Raspberry Pi’s operating system. As you can see, each instruction has an address
    4 bytes greater than the previous one because the ARM is a 32-bit machine with
    32-bit, or 4-byte, instructions; hence the need for the align directive that forces
    the next instruction or data onto a specific boundary.
  prefs: []
  type: TYPE_NORMAL
- en: The bottommost panel contains the commands you enter. In this case, I’ve used
    `si 1` to step through the instructions.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.9 – The TUI showing registers and memory contents](img/Figure_9.09_B19624.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.9 – The TUI showing registers and memory contents
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at another example of an assembly language program and its debugging.
    This example is designed only for demonstration purposes. It doesn’t do anything
    useful. Our intention is to demonstrate the features of an ARM assembly language
    program running under the GCC assembler and the gdb debugger. *Table 9.3* gives
    some of GCC’s most common assembler directives.
  prefs: []
  type: TYPE_NORMAL
- en: '| **GCC** **Assembly directive** | **Action** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| .text | Indicates a program segment containing code |'
  prefs: []
  type: TYPE_TB
- en: '| .data | Indicates a program segment containing data |'
  prefs: []
  type: TYPE_TB
- en: '| .global `label` | Makes the label visible to the linker |'
  prefs: []
  type: TYPE_TB
- en: '| .extern `label` | Makes the label visible outside the file |'
  prefs: []
  type: TYPE_TB
- en: '| .byte`byte1,byte2, …` | Defines one or more bytes of data and stores them
    in memory |'
  prefs: []
  type: TYPE_TB
- en: '| .hword`hw1,hw2, …` | Defines 1 or more 16-bit halfwords and stores them in
    memory |'
  prefs: []
  type: TYPE_TB
- en: '| .word`w1,w2, …` | Defines 1 or more 32-bit words and stores them in memory
    |'
  prefs: []
  type: TYPE_TB
- en: '| .space `bytes,fill` | Fills a block of memory with a given value (e.g., `.``fill`
    `64`,`0xFF`) |'
  prefs: []
  type: TYPE_TB
- en: '| `.`balign 4 | Aligns next address to a 4-byte boundary (you can also use
    2, 4, 8, and 16) |'
  prefs: []
  type: TYPE_TB
- en: '| .ascii `"``any string"` | Stores an ASCII string in memory |'
  prefs: []
  type: TYPE_TB
- en: '| .asciz `"``any string"` | Stores an ASCII string in memory terminated by
    0 |'
  prefs: []
  type: TYPE_TB
- en: '| .equ`symbol, value` | Equates the symbolic name to its value (e.g., `.equ`
    `hours 24`) |'
  prefs: []
  type: TYPE_TB
- en: '| .end | Marks the end of a program |'
  prefs: []
  type: TYPE_TB
- en: Table 9.3 – GCC ARM assembler directives
  prefs: []
  type: TYPE_NORMAL
- en: 'We have presented a more detailed explanation of some of the features of the
    program; these are of the form `@ PRINT` `STRING @`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '@ PRINT STRING ON CONSOLE @'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '@ USING ADR @'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '@ EXITING THE PROGRAM @'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '@ THE ADDRESS VECTOR @'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This code illustrates several points – for example, the use of assembler directives
    such as`.equ`, which binds a symbolic name to a value. I’ve shaded interesting
    blocks of code so that we can discuss them.
  prefs: []
  type: TYPE_NORMAL
- en: We have used ARM’s pseudo-instructions. These are `adr` r3`,v3 and ldr` r1`,=banner`.
    These both load 32-bit addresses into a register. Such instructions don’t exist.
    The ARM assembler chooses real instructions to perform the required actions.
  prefs: []
  type: TYPE_NORMAL
- en: '@ PRINT STRING @'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The first block demonstrates how we can print data from an assembly program.
    Well, in fact, we can’t print the data but we can ask the operating system to
    do it for us. Most processors have an instruction called a *software interrupt*
    (or a system call, a trap, an exception, or an *extra code*). All these terms
    refer to the same thing: an instruction inserted by the programmer that invokes
    the operating system. In the case of ARM, it’s the svc instruction (previously
    called swi). When used by Linux, this instruction is called with the parameter
    `0` – that is `svc 0`.'
  prefs: []
  type: TYPE_NORMAL
- en: The system call is entirely operating-system-dependent and tells the operating
    system what it needs by passing parameters in registers. We are going to print
    a string of characters on the display. The Raspberry Pi OS needs the location
    of the string in memory to be passed in register r1, the number of characters
    to print in register `r2`, the type of the display in `r0`, and the operation
    to be performed (printing) in `r7`.
  prefs: []
  type: TYPE_NORMAL
- en: The address of the text to be printed, `banner`, is loaded into `r1` by `ldr`
    r1`,=banner`. This pseudo-instruction takes an address specified by `=<address>`.
    In the program, we have used the `.ascii` directive to store the string to print
    in memory. The string is text with `\n` at each end, which corresponds to the
    newline character. Note that the newline character code is 1 byte, although it
    is represented in the program by `\n`. Unless a string or other data item stored
    in memory is a multiple of 4 bytes, you must follow it with a `.balign 4` to ensure
    that the next instruction falls on a word boundary.
  prefs: []
  type: TYPE_NORMAL
- en: '@ USING ADR @'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The second block demonstrates the use of an `adr` pseudo-instruction with `adr`
    r3`,v3`. We are going to load register `r3` with the address of a variable we’ve
    called `v3` and loaded into memory with a `.word` directive. One practical consideration
    is that when you disassemble the code, you will not see `adr`; you’ll see the
    actual code that the ARM assembler translated it into.
  prefs: []
  type: TYPE_NORMAL
- en: Putting the address of the `v3` variable into a register means we can use that
    register as a pointer with a load instruction; for example, `ldr` r4`,[r3]` loads
    the value of the variable (i.e., `0x1111` ) into `r4`. If you wish to modify that
    variable, you might think that you could store it back in memory with `str r5,`[r3].
    Sadly not! The `adr` instruction generates code that allows you to access only
    the current segment of the program. That segment is read-only because it contains
    the code. You cannot alter memory in that segment. If you wish to modify memory,
    you have to use a different technique, as we will soon see.
  prefs: []
  type: TYPE_NORMAL
- en: '@ EXITING THE PROGRAM @'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After an assembly language program has been executed to completion, it is necessary
    to return to the operating system level. Register `r7` is loaded with an exit
    code of `1` and an `svc 0` instruction executed to call the operating system.
    By convention, programmers load register r0 with their own exit code before exiting.
    An exit code of `0` is often used to indicate all went well, and an exit code
    of `1` indicates it didn’t.
  prefs: []
  type: TYPE_NORMAL
- en: '@ THE ADDRESS VECTOR @'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can’t use the `adr` pseudo-instruction to write to read/write memory that
    is in a different segment to the code part of a program. This dilemma exists in
    all code development systems and is not peculiar to the ARM GCC environment. The
    ARM processor will allow you to read memory and write to memory anywhere within
    the logically addressable memory space. However, the ARM *operating system* does
    not let you write to regions of read-only memory or other forbidden areas. The
    trick is to create a pointer to the variable and store that pointer in the code
    segment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following assembler directive. This stores a 32-bit `dat1` value
    in memory at location `adr_dat1`. By convention, some programmers indicate that
    an item is a pointer (i.e., address) by prefixing its name with a marker (typically
    `adr`). This is not a rule but a convention:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.10 - Creating a pointer to a data value](img/Figure_9.10_B19624.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.10 - Creating a pointer to a data value
  prefs: []
  type: TYPE_NORMAL
- en: We have created a name, `adr_dat1`, which is the *address* of the address of
    our target variable. The value stored is the address of the actual variable, `dat1`.
    So, when we write the instruction `ldr r0,adr_dat1`, the *address* of `dat1` is
    loaded in register `r0`. That is, register `r0` now points to `dat1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the data section headed by `.data`, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This stores the `0x1234` value in memory and gives it the name `dat1`. As we
    have seen, that name is used to create the address of the variable in the code
    section by the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to run the code. We’ve done this and have provided an edited
    output from the session (removing empty prompt lines between operations and some
    text) in *Listing 9.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Listing 9.1 – A debugging session
  prefs: []
  type: TYPE_NORMAL
- en: Accessing memory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have demonstrated how you can step through a program and display registers
    as instructions are executed. For example, gdb lets you display the contents of
    registers `r0` to `r3` using the `i r r0 r1 r2 r3` command. We will now demonstrate
    how the contents of memory locations can be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: In *Listing 9.1*, we single-step the code through the first few instructions
    (memory access and store operations) and then, after line 25, we can see that
    the address of the `dat3` variable is `0x200e8`. Suppose we want to check that
    its value is `0x1234`, and that the next word location 4 bytes on, `0x2008c`,
    contains the `0x1235` value.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might reasonably expect that the `gdb` command to read the memory location
    is `m` `0x200c`. As you can see from *Listing 9.1*, the command is the rather
    less memorable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The memory access command is x/ and the three required parameters are 2xw.
    These are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`2`   The number of memory locations to be displayed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`x`   The format of the data. `x` indicates hexadecimal.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`w`   The width of the data (number of bytes). `w` indicates a 4-byte 32-bit
    word.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The available formats are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`o`   octal'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`d`   decimal'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`x`   hexadecimal'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`u`   unsigned integer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`s`   string'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`b`   byte'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The data display sizes are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`b`   byte'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`h`   halfword (16 bits)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`w`   word (32 bits)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`g`   double word (giant word of 8 bytes or 64 bits)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Consider these examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '`x/1xw 0x1234`   Print one 4-byte word in hex form at address `0x1234`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`x/6xh 0x1234`   Print six 2-byte values in hex form at address `0x1234`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`x/3db 0x1234`   Print three one-byte values in decimal form at address `0x1234`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`x/9sb 0x1234`   Print nine one-byte characters in string form at address `0x1234`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next section, we are now going to look at the ARM GCC assembler in a
    little more detail. For example, we will introduce the ARM’s assembler directives
    that control the allocation of memory to a program.
  prefs: []
  type: TYPE_NORMAL
- en: Features of the GCC ARM assembler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will begin this section by looking at how memory space can be reserved for
    constants and variables. We have already seen that literals in the ARM assembly
    language are prefixed by a `#` symbol. Numbers are regarded as decimal unless
    prefixed by `0x`, which indicates hexadecimal – for example, `mov r0,#0x2C`. ASCII
    characters are indicated by using single quotes, as in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Two important assembler directives are `.equ`, which binds a name to a value,
    and `.word`, which allows you to preload memory with data before a program runs.
    The `.equ` directive is very easy to understand; it binds a numeric value to a
    name. Consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This assembly directive binds the name `Tuesday` to the value `2`. Whenever
    you write `Tuesday`, the assembler replaces it with `2`. The GCC ARM `.word` assembler
    directive reserves memory space for constants and variables; that is, it declares
    a variable (or constant) and initializes it. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The `.word` directive reserves a 32-bit word (i.e., 4 bytes) of storage in memory
    and loads whatever value the expression to the right of `.word` yields into that
    location. In this case, we’ve bound `Value1` to the number `12` and, therefore,
    the binary value `00000000000000000000000000001100` will be stored at this location.
    The next memory location used is the next free location (i.e., storage directives
    store data in memory sequentially).
  prefs: []
  type: TYPE_NORMAL
- en: The *location counter* is advanced by four bytes so that the next `.word` or
    instruction will be placed in the next word in memory. The term *location counter*
    refers to the pointer to the next location in memory when a program is being assembled
    and is similar, in concept, to the program counter.
  prefs: []
  type: TYPE_NORMAL
- en: 'You don’t have to use 32-bit values in the ARM programs. The`.byte` and `.hword`
    assembler directives store a byte and a 16-bit halfword in memory, respectively,
    as in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Although you could use `.byte` to store text strings in memory, it would be
    very clumsy because you would have to look up the ASCII value of each character.
    The GCC ARM assembler provides a simpler mechanism. The `.ascii` directive takes
    a string and stores each character as an 8-bit ASCII-encoded byte in consecutive
    memory locations. The `.asciz` command performs the same function but inserts
    an 8-bit binary byte of all 0s as a terminator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Because the ARM aligns all instructions on 32-bit word boundaries, the `.balign
    4` directive is required to align whatever follows on the next word boundary (the
    4 indicates a 4-byte boundary). In other words, if you store three 8-bit characters
    in memory, the `.balign 4` command skips a byte to force the next address to a
    32-bit boundary. Note that `.balign 2` forces alignment on a halfword boundary
    (you can use `.balign 16`, or any other power of 2, to force the next memory access
    to be appropriately aligned).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following ARM code demonstrates storage allocation and the use of the `.balign`
    `4` directive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s assemble, link, and run this code on a Raspberry Pi using gdb. The first
    few lines from the terminal windows show the loading of the program, setting a
    breakpoint, and executing in a single-step mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'So far, so good. Let’s see what the registers hold. We have deleted lines with
    registers that we’re not interested in to make the output more readable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Registers `r0` to `r3` contain what we would expect (`r3` is `0x17` in `r3`
    plus the `0x42` code for `'B'` which is `0x59`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Register r4 contains `0x1007e`, which is the address of the data called `test`:
    (i.e., `0xBB`) in memory. That address is used to load the `0xBB` constant into
    `r5`, which now contains `0xABCD00BB` and not `0x000000BB` as we expected. What
    went wrong?'
  prefs: []
  type: TYPE_NORMAL
- en: The problem is that `ldr` loads a 32-bit value into a register from memory.
    `0xABCD00` is the word following `0xBB` plus a null byte due to the `.balign`
    `2` statement. We should have used a special *“load a byte”* instruction, loaded
    four bytes and cleared three to zero, or aligned the byte correctly in memory.
    The great strength of a computer is that it does what you tell it. Alas, its great
    weakness is that…it does *exactly* what you tell it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we look at the data stored in memory using the `x/7xw 0x1006c` command,
    which displays `7` words of memory in hexadecimal form starting at address `0x1006c`
    (we got that address from the `pc` in the register dump). Remember that it’s the
    ARM’s operating system that initially sets up the program counter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also look at the data stored in memory in byte form using `x/28xb 0x1006c`,
    which displays `7` words (4 x 7 = 28 bytes) of memory in hexadecimal form starting
    at address `0x1006c`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '*Figure 9**.10* provides a memory map demonstrating the allocation of memory.
    The bold hexadecimal addresses are the 4-byte word boundaries. You can see how
    the `.balign` directives insert zeros as padding in memory to form the required
    boundaries.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next section, we look at one of the key aspects of modern computer design
    – how a computer with a 32-bit word length can load a 32-bit value into a register:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Figure 9.10 – Allocating data to memory – the memory map
  prefs: []
  type: TYPE_NORMAL
- en: 'We next look at a dilemma that affects all computers: how do you load a constant
    (literal) that is the same size as the instruction word?'
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with 32-bit literals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here, you will learn how the ARM uses a 32-bit instruction to load a 32-bit
    literal. A literal can’t be combined with an op-code as we have done in the simulators.
    We will demonstrate how the ARM uses several techniques to use a 32-bit instruction
    to access a 32-bit literal.
  prefs: []
  type: TYPE_NORMAL
- en: The ARM has 32-bit data words and instructions. You can’t load a 32-bit literal
    into an ARM register in one instruction because you can’t specify both the operation
    and the data in one instruction. CISC processors chain two or more instructions
    together; for example, a 16-bit machine might take 2 instruction words to create
    a 32-bit instruction containing a 16-bit operation and a 16-bit literal. Some
    processors load a 16-bit literal (load high) with one instruction and then load
    a second 16-bit literal (load low) with a second instruction. The computer then
    concatenates the high and low halfword 16-bit values into a 32-bit literal.
  prefs: []
  type: TYPE_NORMAL
- en: 'The ARM has two pseudo-instructions that can load a 32-bit value into a register
    by letting the assembler generate the actual code needed to do this. The pseudo-instruction
    `adr` (load address) has the format adr rdestination,label, where `label` indicates
    a line (address) in the program. `adr` lets the assembler generate the appropriate
    machine code and relieves the programmer of some *housekeeping*. The `adr` uses
    the ARM’s `add` or `sub` instruction together with *PC relative addressing* to
    generate the required address. Program counter-relative addressing specifies an
    address by its distance from the current instruction. The following code fragment
    demonstrates the use of `adr`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The pseudo-instruction `adr` r0,`someData` loads register `r0` with the 32-bit
    address of `someData` using the appropriate code generated by the assembler. You
    don’t normally have to know how the assembler generates the actual code to implement
    the `adr`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another useful ARM pseudo-instruction is `ldr` r1`,=value`. In this case, the
    compiler generates the code that allows register r1 to be loaded with the stated
    value, as in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This loads r2 with 1234567816\. The assembler employs a `mov` or `mvn` instruction
    if it can. The ARM’s unusual *move* `not` instruction takes an 8-bit literal,
    inverts the bits, and moves it to a register. For example `MVN r1,#0xF0` copies
    `0x0F` to r1\. Alternatively, the assembler uses an `ldr`r2`,[pc,#offset]` instruction
    to access the appropriate constant 1234567816 that is stored in a so-called *literal
    pool* or *constant pool* somewhere in memory. A literal pool is one or more data
    items embedded in code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at how pseudo-instructions are treated by the GCC assembler development
    system. Consider the following fragment of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the edited output of a gdb debugger session. The code has
    been executed to completion and the register contents are as follows. The righthand
    column displays the data in decimal form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The pointer registers, `r1` and `r2`, have been loaded with the addresses of
    the two data elements in memory (i.e., Table1 and Table2). These pointers have
    been used to retrieve the two elements, and you can see from the debugger that
    the operation worked.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following debugger output provides a disassembly of the code. This is not
    what was written. The assembler has converted the three pseudo-operations into
    actual ARM code (in bold font):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The first load instruction loads register `r0` with data from memory 36 bytes
    from the current program counter. At that location, the assembler has stored the
    `0x12345678` constant to be loaded.
  prefs: []
  type: TYPE_NORMAL
- en: The two `adr` operations generate an address by adding the distance between
    the pc and the data in memory. This is called *program counter relative addressing*
    and we will look at it in more detail later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at the data in memory. We use the `x/6xw 0x10080` gdb command to
    display six words of memory from address `0x10080`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: This shows the `0x12345678` constant that has been loaded in memory following
    the program, together with the other constants we loaded.
  prefs: []
  type: TYPE_NORMAL
- en: A note on endianism
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ve not mentioned one topic yet - *endianism*. The term is borrowed from *Gulliver’s
    Travels* where the world is divided into those who eat their boiled eggs from
    the big end and those who eat their eggs from the little end. This divides the
    world into mutually hostile big enders and little enders (it is, of course, satire).
  prefs: []
  type: TYPE_NORMAL
- en: Computers do something similar. Suppose you store the 32-bit hexadecimal value
    `0x12345678` in memory. If you stored this in word memory, where the address of
    each word differs by 1, life would be simple. But because computer memories are
    *byte-organized*, each memory location has an individual byte address, so successive
    byte addresses are `0,1,2,3,4,5,6…` and successive word addresses are `0,4,8,12,16,20,24…`.
  prefs: []
  type: TYPE_NORMAL
- en: A consequence of byte addressing means that word 0 occupies byte addresses 0,1,2,3\.
    Suppose we store `0x12345678` at address 0\. Which end of the number do we put
    in first? Is it stored in bytes 0 to 3 as `12 34 56 78` or as `78 56` `34 12`?
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 9**.4* illustrates three memory systems. In all three cases, memory
    is byte-addressed. In the 32-bit version, we have two 32-bit values representing
    `0x12345678` stored in memory at addresses c and `0x1014`. Notice that the individual
    bytes of the stored word have different byte addresses. A little-endian number
    is arranged so that the most significant byte, `0x12`, is stored in the lowest
    address of the word `0x1010`. A big-endian number is stored with the most-significant
    byte at the lowest address, `0x1013`.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.11 – Memory organization](img/Figure_9.11_B19624.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.11 – Memory organization
  prefs: []
  type: TYPE_NORMAL
- en: Some computers are big-endian and some little-endian. Motorola microprocessors
    are big-endian and Intel is little-endian. ARM was originally little-endian, but
    it now has a bit in its CPSR status register that can be used to select the required
    version of endianism. By default, the ARM is little-endian.
  prefs: []
  type: TYPE_NORMAL
- en: Does the endian matter? It matters in two ways. If you are building systems
    or interfacing systems with mixed endianism, it matters because you must ensure
    that the bytes are in the correct sequence when passed from one system to another.
    For example, the TCP/IP protocol is big-endian. Equally, if you are performing
    byte and word operations on data, you have to be aware of the relationship between
    byte and word addresses. If you store the ASCII “Mike” at word address `0x1000`
    and you wanted the *“e,”* it would be at `0x1000` in a big-endian system and `0x1003`
    in a little-endian system.
  prefs: []
  type: TYPE_NORMAL
- en: Bringing everything together – a final example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To conclude this chapter, we provide a final example of using the Raspberry
    Pi to enter the ARM assembly language and run it in a debugging mode using gdb.
    As before, the example does not perform a useful function. Its purpose is to demonstrate
    addressing modes, the use of assembler directives to load data in memory, the
    nature of endianism, and the ability to declare variables in memory and modify
    them.
  prefs: []
  type: TYPE_NORMAL
- en: This example also demonstrates how memory data is displayed and how to use the
    memory display function to read data. We have used gdb and copied various screens
    during the debugging. These have been put together in what follows. We have removed
    some material (e.g., status registers and registers not accessed) and have slightly
    edited the format for readability.
  prefs: []
  type: TYPE_NORMAL
- en: The source program
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The source program sets up data in memory and accesses it. We use ASCII text
    and numeric text as part of the demonstration. Note that an ASCII string or character
    using the GCC assembler requires double quotes. We also read bytes with ldrb and
    a halfword (16 bits) with ldrh.
  prefs: []
  type: TYPE_NORMAL
- en: The program uses `ldrb r5,[r3,#1]` to demonstrate reading bytes from a 32-bit
    word that is 3 bytes on from the base address of the word in r5.
  prefs: []
  type: TYPE_NORMAL
- en: The program contains dummy data stored in memory, such as `0xAAAAAAAA`. We do
    this to demonstrate how data is stored, but mainly to help with debugging. When
    you display data contents in memory, these dummy values provide great markers
    to help you read the memory data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the word that we access in read/write memory, testRW, is in a .data
    section. This is initialized to `0xFFFFFFFF` and is later modified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The first steps are to assemble and load the program (called endian) and invoke
    the gdb debugger. We use bold font to indicate input from the keyboard:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use gdb to set a breakpoint at `_start` and then run the program to
    that breakpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Let’s look at the program that is actually loaded into memory. This differs
    slightly from the one we wrote because pseudo-operations have been replaced by
    actual code. Note that the `adr` is translated into an `add` by taking the program
    counter and adding the distance of the required variable to the current pc to
    generate its address.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ldr r8,=0x12345678` is translated into a load program counter relative
    instruction because the required constant has been loaded into memory after the
    end of the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: This differs from the code we wrote because pseudo-operations have been replaced
    by actual ARM code. Note that the `adr` is translated into an `add` by taking
    the program counter and adding the distance of the required variable to the current
    pc to generate its address.
  prefs: []
  type: TYPE_NORMAL
- en: The `ldr r8,=0x12345678` is translated into a load program counter relative
    instruction because the required constant has been loaded into memory after the
    end of the program.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at memory. The following shows the contents of 8 consecutive words
    starting with `0x100b4`, which is the address of the `svc` `0` instruction.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before continuing and executing the program, we will look at the contents of
    memory, set up by the program. Where is this data? It follows the last executable
    instruction, `svc 0`, which is at address `0x000100B4`. We display the eight words
    from the `svc` in hexadecimal format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: You can see the `0x12345678` constant loaded by the assembler and some of the
    markers.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will step through the first few instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The next step is to look at the registers before the program runs to completion.
    We do this with gdb’s `i r` command. There’s not much to see yet (it’s a partial
    listing), as we’ve executed only the first few instructions. However, `r0` now
    contains a pointer to the ASCII text string *“Mike”* at address `0x100B8`. If
    you look back at that address, you see that it contains `0x656b694d`, which is
    `ekiM`. That’s what little-endian does!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Continuing single-stepping:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s look at the memory in the data section. Register `r7` points to the read/write
    data area. It starts 4 bytes before the pointer to `testRW`, in `r7` ; that is,
    `0x200CC - 4 = 0x200C8`. The four words beginning at that address are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we step through the instruction until we meet the `nop` at the end:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s take a final look at the state of the registers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Here’s our final look at the data memory. Note that `0xFFFFFFFF` has been replaced
    with the value `0x12345678` that we wrote to memory. This demonstrates how you
    can access data memory using an ARM.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note also the data value at `0x200D0` ; that is, `0x7777a987`. We have changed
    half the word using a halfword load:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have introduced a real computer, the Raspberry Pi. Instead
    of designing our own computer instruction sets, we’ve looked at the ARM microprocessor
    that is at the heart of the Raspberry Pi and most smartphones.
  prefs: []
  type: TYPE_NORMAL
- en: We introduced the basics of the Raspberry Pi and showed how to write an ARM
    assembly language program that can run on it. This requires an understanding of
    the ARM assembler and the use of the linker. We demonstrated how you can then
    run your ARM program instruction-by-instruction using the gdb debugger.
  prefs: []
  type: TYPE_NORMAL
- en: 'One important feature of Raspberry Pi’s architecture we have encountered is
    the way in which data in memory is modified. You cannot use a str (store) instruction
    to modify data in memory. You must do it indirectly via a pointer to the address
    of the memory you wish to change. The following short program demonstrates this
    vital point. A data item in memory is read directly using an `ldr` but modified
    in memory using a pointer to a pointer. The key operations are in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: In order to demonstrate an ARM program, we have introduced the ARM’s assembly
    language. Mercifully, this is not too far from the language adopted by some of
    the simulators. Indeed, the ARM’s assembly language is not too difficult to learn,
    although it does incorporate some very interesting features, which we will describe
    in later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we return to the ARM architecture and one of its most
    important aspects: addressing and how data is transferred to and from memory.'
  prefs: []
  type: TYPE_NORMAL
