<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch05"/>Chapter 5. When Doctest isn't Enough: Unittest to the Rescue</h1></div></div></div><p>
<em>As the tests get more detailed (or complex), or they require more setup code to prepare the way for them, doctest begins to get a little bit annoying. The very simplicity that makes it the best way to write testable specifications and other simple tests starts to interfere with writing tests for complicated things.</em>
</p><p>In this chapter we shall:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Learn how to write and execute tests in the unittest framework</li><li class="listitem" style="list-style-type: disc">Learn how to express familiar testing concepts using unittest</li><li class="listitem" style="list-style-type: disc">Discuss the specific features that make unittest suitable for more complicated testing scenarios</li><li class="listitem" style="list-style-type: disc">Learn about of couple of Mocker's features that integrate well with unittest</li></ul></div><p>So let's get on with it!</p><div><div><div><div><h1 class="title"><a id="ch05lvl1sec41"/>Basic unittest</h1></div></div></div><a class="indexterm" id="id247"/><p>Before we start talking about new concepts and features, let's take a look at how to use unittest to express the ideas that we've already learned about. That way, we'll have something solid to ground our new understanding into.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec42"/>Time for action – testing PID with unittest</h1></div></div></div><a class="indexterm" id="id248"/><p>We'll revisit the PID class (or at least the tests for the PID class) from Chapter 3. We'll rewrite the tests so that they operate within the unittest framework.</p><p>Before moving on, take a moment to refer back to the final version of the <code class="literal">pid.txt</code> file from Chapter 3. We'll be implementing the same tests using the unittest framework.</p><div><ol class="orderedlist arabic"><li class="listitem">Create a new file called <code class="literal">test_pid.py</code> in the same directory as <code class="literal">pid.py</code>. Notice that this is a <code class="literal">.py</code> file: unittest tests are pure python source code, rather than being plain text with source code embedded in it. That means the tests will be less useful from a documentary point of view, but grants other benefits in exchange.</li><li class="listitem">Insert the following code into your newly-created <code class="literal">test_pid.py</code> (and please note that a few lines are long enough to get wrapped on the book's page):<div><pre class="programlisting">from unittest import TestCase, main
from mocker import Mocker

import pid

<a class="indexterm" id="id249"/>class test_pid_constructor(TestCase):
    def test_without_when(self):
        mocker = Mocker()
        mock_time = mocker.replace('time.time')
        mock_time()
        mocker.result(1.0)

        mocker.replay()

        controller = pid.PID(P=0.5, I=0.5, D=0.5,
                             setpoint=0, initial=12)

        mocker.restore()
        mocker.verify()

        self.assertEqual(controller.gains, (0.5, 0.5, 0.5))
        self.assertAlmostEqual(controller.setpoint[0], 0.0)
        self.assertEqual(len(controller.setpoint), 1)
        self.assertAlmostEqual(controller.previous_time, 1.0)
        self.assertAlmostEqual(controller.previous_error, -12.0)
        self.assertAlmostEqual(controller.integrated_error, 0)


    def test_with_when(self):
        controller = pid.PID(P=0.5, I=0.5, D=0.5,
                             setpoint=1, initial=12,
                             when=43)

        self.assertEqual(controller.gains, (0.5, 0.5, 0.5))
        self.assertAlmostEqual(controller.setpoint[0], 1.0)
        self.assertEqual(len(controller.setpoint), 1)
        self.assertAlmostEqual(controller.previous_time, 43.0)
        self.assertAlmostEqual(controller.previous_error, -11.0)
        self.assertAlmostEqual(controller.integrated_error, 0)

class test_calculate_response(TestCase):
    def test_without_when(self):
        mocker = Mocker()
        mock_time = mocker.replace('time.time')
        mock_time()
        mocker.result(1.0)
        mock_time()
        mocker.result(2.0)
        mock_time()
        mocker.result(3.0)
        mock_time()
        mocker.result(4.0)
        mock_time()
        mocker.result(5.0)

        mocker.replay()

        controller = pid.PID(P=0.5, I=0.5, D=0.5,
                             setpoint=0, initial=12)

        self.assertEqual(controller.calculate_response(6), -3)
        self.assertEqual(controller.calculate_response(3), -4.5)
        self.assertEqual(controller.calculate_response(-1.5), -0.75)
        self.assertEqual(controller.calculate_response(-2.25), -1.125)

        mocker.restore()
        mocker.verify()
    def test_with_when(self):
        controller = pid.PID(P=0.5, I=0.5, D=0.5,
                             setpoint=0, initial=12,
                             when=1)
<a class="indexterm" id="id250"/>
        self.assertEqual(controller.calculate_response(6, 2), -3)
        self.assertEqual(controller.calculate_response(3, 3), -4.5)
        self.assertEqual(controller.calculate_response(-1.5, 4), -0.75)
        self.assertEqual(controller.calculate_response(-2.25, 5), -1.125)

if __name__ == '__main__':
    main()</pre></div></li><li class="listitem">Run the tests by typing<a class="indexterm" id="id251"/>:<div><pre class="programlisting">
<strong>$ python test_pid.py</strong>
</pre></div><div><img alt="Time for action – testing PID with unittest" src="img/8846_05_01.jpg"/></div></li></ol></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec66"/>
<em>What just happened?</em>
</h2></div></div></div><p>Let's go through the code section and see what each part does. After that, we'll talk about what it all means when put together.</p><div><pre class="programlisting">from unittest import TestCase, main
from mocker import Mocker

import pid

class test_pid_constructor(TestCase):
    def test_without_when(self):
        mocker = Mocker()
        mock_time = mocker.replace('time.time')
        mock_time()
        mocker.result(1.0)

        mocker.replay()

        controller = pid.PID(P=0.5, I=0.5, D=0.5,
                             setpoint=0, initial=12)

        mocker.restore()
        mocker.verify()

        self.assertEqual(controller.gains, (0.5, 0.5, 0.5))
        self.assertAlmostEqual(controller.setpoint[0], 0.0)
        self.assertEqual(len(controller.setpoint), 1)
        self.assertAlmostEqual(controller.previous_time, 1.0)
        self.assertAlmostEqual(controller.previous_error, -12.0)
        self.assertAlmostEqual(controller.integrated_error, 0)</pre></div><p>After a little bit of setup code, we have a test that the PID controller works correctly when not given a <code class="literal">when</code> parameter. Mocker is used to replace <code class="literal">time.time</code> with a mock that always returns a predictable value, and then we use several assertions to confirm that the attributes of the controller have been initialized to the expected values.</p><div><pre class="programlisting">    def test_with_when(self):
        controller = pid.PID(P=0.5, I=0.5, D=0.5,
                             setpoint=1, initial=12,
                             when=43)

        self.assertEqual(controller.gains, (0.5, 0.5, 0.5))
        self.assertAlmostEqual(controller.setpoint[0], 1.0)
        self.assertEqual(len(controller.setpoint), 1)
        self.assertAlmostEqual(controller.previous_time, 43.0)
        self.assertAlmostEqual(controller.previous_error, -11.0)
        self.assertAlmostEqual(controller.integrated_error, 0)</pre></div><p>This test confirms that the PID constructor works correctly when the <code class="literal">when</code> parameter is supplied. Unlike the previous test, there's no need to use Mocker, because the outcome of <a class="indexterm" id="id252"/>the test is not supposed to be dependant on anything except the parameter values—the current time is irrelevant.</p><div><pre class="programlisting">class test_calculate_response(TestCase):
    def test_without_when(self):
        mocker = Mocker()
        mock_time = mocker.replace('time.time')
        mock_time()
        mocker.result(1.0)
        mock_time()
        mocker.result(2.0)
        mock_time()
        mocker.result(3.0)
        mock_time()
        mocker.result(4.0)
        mock_time()
        mocker.result(5.0)

        mocker.replay()

        controller = pid.PID(P=0.5, I=0.5, D=0.5,
                             setpoint=0, initial=12)

        self.assertEqual(controller.calculate_response(6), -3)
        self.assertEqual(controller.calculate_response(3), -4.5)
        self.assertEqual(controller.calculate_response(-1.5), -0.75)
        sel+f.assertEqual(controller.calculate_response(-2.25), -1.125)

        mocker.restore()
        mocker.verify()</pre></div><p>The tests in this class describe the intended behavior of the <code class="literal">calculate_response</code> method. This first test checks the behavior when the optional <code class="literal">when</code> parameter is not supplied, and mocks <code class="literal">time.time</code> to make that behavior predictable.</p><div><pre class="programlisting">    def test_with_when(self):
        controller = pid.PID(P=0.5, I=0.5, D=0.5,
                             setpoint=0, initial=12,
                             when=1)

        self.assertEqual(controller.calculate_response(6, 2), -3)
        self.assertEqual(controller.calculate_response(3, 3), -4.5)
        self.assertEqual(controller.calculate_response(-1.5, 4), -0.75)
        self.assertEqual(controller.calculate_response(-2.25, 5), -1.125)</pre></div><p>I<a class="indexterm" id="id253"/>n this test, the <code class="literal">when</code> parameter is supplied, so there is no need to mock <code class="literal">time.time</code>. We just have to check that the result is what we expected.</p><p>The actual tests that we performed are the same ones that were written in the doctest. So far, all that we see is a different way of expressing them.</p><p>The first thing to notice is that the test file is divided up into classes that inherit from <code class="literal">unittest.TestCase</code>, each of which contains one or more test methods. The name of each test method begins with the word <em>test</em>, which is how unittest recognizes that they are tests.</p><p>Each test method embodies a single test of a single unit. This gives us a convenient way to structure our tests, grouping together related tests into the same class, so that they're easier to find.</p><p>P<a class="indexterm" id="id254"/>utting each test into its own method means that each test executes in an isolated namespace, which makes it somewhat easier to keep unittest-style tests from interfering with each other, relative to doctest-style tests. It also means that unittest knows how many unit tests are in your test file, instead of simply knowing how many expressions there are (you may have noticed that doctest counts each <code class="literal">&gt;&gt;&gt;</code> line as a separate test). Finally, putting each test in its own method means that each test has a name, which can be a valuable feature.</p><p>Tests in unittest don't directly care about anything that isn't part of a call to one of the assert methods of <code class="literal">TestCase</code>. That means that when we're using Mocker, we don't have to be bothered about the mock objects that get returned from demonstration expressions, unless we want to use them. It also means that we need to remember to write an assert describing every aspect of the test that we want to have checked. We'll go over the various assertion methods of <code class="literal">TestCase</code> shortly.</p><p>Tests aren't of much use, if you can't execute them. For the moment, the way we'll be doing that is by calling <code class="literal">unittest.main</code> when our test file is executed as a program by the Python interpreter. That's about the simplest way to run unittest code, but it's cumbersome when you have lots of tests spread across lots of files. We'll be learning about tools to address that problem in the next chapter.</p><div><div><h3 class="title"><a id="note17"/>Note</h3><a class="indexterm" id="id255"/><p>
<code class="literal">if __name__ == '__main__':</code> might look strange to you, but its meaning is fairly straight forward. When Python loads any module, it stores that module's name in a variable called <code class="literal">__name__</code> within the module (unless the module is the one passed to the interpreter on the command line). That module always gets the string <code class="literal">'__main__'</code> bound to its <code class="literal">__name__</code> variable. So, <code class="literal">if __name__ == '__main__':</code> means—if this module was executed directly from the command line.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec67"/>Assertions</h2></div></div></div><p>A<a class="indexterm" id="id256"/>ssertions are the mechanism that we use to tell unittest what the important outcomes of the test are. By using appropriate assertions, we can tell unittest exactly what to expect from each test.</p><div><div><div><div><h3 class="title"><a id="ch05lvl3sec12"/>assertTrue</h3></div></div></div><p><a class="indexterm" id="id257"/>
<a class="indexterm" id="id258"/>When we call <a class="indexterm" id="id259"/><code class="literal">self.assertTrue(expression)</code>, we're telling unittest that the expression must be true in order for the test to be a success.</p><p>This is a very flexible assertion, since you can check for nearly anything by writing the appropriate boolean expression. It's also one of the last assertions you should consider using, because it doesn't tell unittest anything about the kind of comparison you're making, which means that unittest can't tell you as clearly what's gone wrong if the test fails.</p><p>For an example of this, consider the following test code which contains two tests that are guaranteed to fail:</p><div><pre class="programlisting">from unittest import TestCase, main

class two_failing_tests(TestCase):
    def test_assertTrue(self):
        self.assertTrue(1 == 1 + 1)

    def test_assertEqual(self):
        self.assertEqual(1, 1 + 1)

if __name__ == '__main__':
    main()</pre></div><p>It might seem like the two tests are interchangeable, since both test the same thing. Certainly they'll both fail (or in the unlikely event that one equals two, they'll both pass), so why prefer one over the other?</p><p><a class="indexterm" id="id260"/>
<a class="indexterm" id="id261"/>Take a look at what happens when we run the tests (and also notice that the tests were not executed in the same order as they were written; tests are totally independent of each other, so that's okay, right?):</p><div><img alt="assertTrue" src="img/8846_05_02.jpg"/></div><p>Do you see the difference? The <code class="literal">assertTrue</code> test was able to correctly determine that the test should fail, but it didn't know enough to report any useful information about why it failed. The <code class="literal">assertEqual</code> test, on the other hand, knew first of all that it was checking that two expressions were equal, and second it knew how to present the results, so that they would be most useful: by evaluating each of the expressions that it was comparing and placing a <code class="literal">!=</code> symbol between the results. It tells us both what expectation failed, and what the relevant expressions evaluate to.</p></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec13"/>assertFalse</h3></div></div></div><p><a class="indexterm" id="id262"/>
<a class="indexterm" id="id263"/>The <code class="literal">assertFalse</code> method will succeed when the <code class="literal">assertTrue</code> method would fail, and vice versa. It has the same limits in terms of producing useful output that <code class="literal">assertTrue</code> has, and the same flexibility in terms of being able to test nearly any condition.</p></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec14"/><a class="indexterm" id="id264"/>
<a class="indexterm" id="id265"/>assertEqual
</h3></div></div></div><p>As<a class="indexterm" id="id266"/>
<a class="indexterm" id="id267"/> mentioned in the <code class="literal">assertTrue</code> discussion, the <code class="literal">assertEqual</code> assertion checks that its two parameters are in fact equal, and reports a failure if they are not, along with the actual values of the parameters.</p></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec15"/>assertNotEqual</h3></div></div></div><p><a class="indexterm" id="id268"/>
<a class="indexterm" id="id269"/>The <code class="literal">assertNotEqual</code> assertion fails whenever the <code class="literal">assertEqual</code> assertion would have succeeded, and vice versa. When it reports a failure, its output indicates that the values of the two expressions are equal, and provides you with those values.</p></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec16"/>assertAlmostEqual</h3></div></div></div><p><a class="indexterm" id="id270"/>
<a class="indexterm" id="id271"/>As we've seen before, comparing floating point numbers can be troublesome. In particular, checking that two floating point numbers are equal is problematic, because things that you might expect to be equal—things that, mathematically, are equal—may still end up differing down among the least significant bits. Floating point numbers only compare equal when every bit is the same.</p><p>To address that problem, unittest provides <code class="literal">assertAlmostEqual</code>, which checks that two floating point values are almost the same; a small amount of difference between them is tolerated.</p><p>Lets look at this problem in action. If you take the square root of 7, and then square it, the result should be <code class="literal">7</code>. Here's a pair of tests that check that fact:</p><div><pre class="programlisting">from unittest import TestCase, main

class floating_point_problems(TestCase):
    def test_assertEqual(self):
        self.assertEqual((7.0 ** 0.5) ** 2.0, 7.0)
    def test_assertAlmostEqual(self):
        self.assertAlmostEqual((7.0 ** 0.5) ** 2.0, 7.0)

if __name__ == '__main__':

    main()</pre></div><p><a class="indexterm" id="id272"/>The <code class="literal">test_assertEqual</code> method checks that <img alt="assertAlmostEqual" src="img/8846_05_01a.jpg"/>, which is true in reality. In the more specialized number system available to computers, though, taking the square root of 7 and then squaring it doesn't quite get us back to 7, so this test will fail. More on that in a moment.</p><p><a class="indexterm" id="id273"/>Test <code class="literal">test_assertAlmostEqual</code> method checks that <img alt="assertAlmostEqual" src="img/8846_05_01b.jpg"/>, which even the computer will agree is true, so this test should pass.</p><p><a class="indexterm" id="id274"/>
<a class="indexterm" id="id275"/>Running those tests produces the following, although the specific number that you get back instead of <code class="literal">7</code> may vary depending on the details of the computer the tests are being run on:</p><div><img alt="assertAlmostEqual" src="img/8846_05_03.jpg"/></div><p>Unfortunately, floating point numbers are not precise, because the majority of numbers on the real number line can not be represented with a finite, non-repeating sequence of digits, much less a mere 64 bits. Consequently, what you get back from evaluating the mathematical expression is not quite <code class="literal">7</code>. It's close enough for government work though—or practically any other sort of work as well—so we don't want our test to quibble over that tiny difference. Because of that, we should use <code class="literal">assertAlmostEqual</code> and <code class="literal">assertNotAlmostEqual</code> when we're comparing floating point numbers for equality.</p><div><div><h3 class="title"><a id="note18"/>Note</h3><p>This problem doesn't generally carry over into other comparison operators. Checking that one floating point number is less than the other, for example, is very unlikely to produce the wrong result due to insignificant errors. It's only in cases of equality that this problem bites us.</p></div></div></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec17"/>assertNotAlmostEqual</h3></div></div></div><p>The <a class="indexterm" id="id276"/>
<a class="indexterm" id="id277"/><a class="indexterm" id="id278"/><code class="literal">assertNotAlmostEqual</code> assertion fails whenever the <code class="literal">assertAlmostEqual</code> assertion would have succeeded, and vice versa. When it reports a failure, its output indicates that the values of the two expressions are nearly equal, and provides you with those values.</p></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec18"/>assertRaises</h3></div></div></div><p>As <a class="indexterm" id="id279"/>always, we need to make sure that our units correctly signal errors. Doing the right thing when they receive good inputs is only half the job; they need to do something reasonable when they receive bad inputs, as well.</p><p>The <a class="indexterm" id="id280"/><code class="literal">assertRaises</code> method checks that a callable (a callable is a function, a method, or a class. A callable can also be an object of any arbitrary type, so long as it has a <code class="literal">__call__</code> method) raises a specified exception, when passed a specified set of parameters.</p><p>This assertion only works with callables, which means that you don't have a way of checking that other sorts of expressions raise an expected exception. If that doesn't fit the needs of your test, it's possible to construct your own test using the <code class="literal">fail</code> method, described below.</p><p>To use <code class="literal">assertRaises</code>, first pass it the expected exception, then pass the callable, and then the parameters that should be passed to the callable when it's invoked.</p><p>Here's an example test using <code class="literal">assertRaises</code>. This test ought to fail, because the callable won't raise the expected exception. <code class="literal">'8ca2'</code> is perfectly acceptable input to <code class="literal">int</code>, when you're also passing it <code class="literal">base = 16</code>. Notice that <code class="literal">assertRaises</code> will accept any number of positional or keyword arguments, and pass them on to the callable on invocation.</p><div><pre class="programlisting">from unittest import TestCase, main

class silly_int_test(TestCase):
    def test_int_from_string(self):
        self.assertRaises(ValueError, int, '8ca2', base = 16)

if __name__ == '__main__':
    main()</pre></div><p>When we run that test, it fails (as we knew it would) because <code class="literal">int</code> didn't raise the exception we told <code class="literal">assertRaises</code> to expect.</p><div><img alt="assertRaises" src="img/8846_05_04.jpg"/></div><p>If an exception is raised, but it's not the one you told unittest to expect, unittest considers that an error. An error is different from a failure. A failure means that one of your tests has detected a problem in the unit it's testing. An error means that there's a problem with the test itself.</p></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec19"/>fail</h3></div></div></div><a class="indexterm" id="id281"/><a class="indexterm" id="id282"/><p>When <a class="indexterm" id="id283"/>
<a class="indexterm" id="id284"/>all else fails, you can fall back on <code class="literal">fail</code>. When the code in your test calls <code class="literal">fail</code>, the test fails. </p><p>What good does that do? When none of the assert methods does what you need, you can instead write your checks in such a way that <code class="literal">fail</code> will be called if the test does not pass. This allows you to use the full expressiveness of Python to describe checks for your expectations.</p><p>Let's take a look at an example. This time, we're going to test on a less-than operation, which isn't one of the operations directly supported by an assert method. Using <code class="literal">fail</code>, it's easy to implement the test anyhow.</p><div><pre class="programlisting">from unittest import TestCase, main

class test_with_fail(TestCase):
    def test_less_than(self):
        if not (2.3 &lt; 5.6):
            self.fail('2.3 is not less than 5.6, but it should be')

if __name__ == '__main__':
    main()</pre></div><p>A couple of things to notice here: first of all, take note of the <code class="literal">not</code> in the <code class="literal">if</code> statement. Since we want to run <code class="literal">fail</code> if the test should not pass, but we're used to describing the circumstances when the test should succeed, a good way to write the test is to write the success condition, and then invert it with <code class="literal">not</code>. That way we can continue thinking in the way we're used to when we use fail. The second thing to note is that you can pass a message to fail when you call it, which will be printed out in unittest's report of failed tests. If you choose your message carefully, it can be a big help.</p><p>There's no screen capture of what to expect from running this test, because the test should pass, and the report wouldn't contain anything interesting. You might experiment with changing the test around and running it, to see what happens.<a class="indexterm" id="id285"/>
</p></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec68"/>Pop quiz – basic unittest knowledge</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">What is the unittest equivalent of this doctest?<div><pre class="programlisting">&gt;&gt;&gt; try:
...     int('123')
... except ValueError:
...     pass
... else:
...     print 'Expected exception was not raised'</pre></div></li><li class="listitem">How do you check whether two floating point numbers are equal?</li><li class="listitem">When would you choose to use <code class="literal">assertTrue</code>? How about <code class="literal">fail</code>?</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec69"/>Have a go hero – translating into unittest</h2></div></div></div><p>Look back at some of the tests we write in the previous chapters, and translate them from doctests into unittests. Given what you already know of unittest, you should be able to translate any of the tests.</p><p>While you're doing this, think about the relative merits of unittest and doctest for each of the tests you translate. The two systems have different strengths, so it makes sense that each will be the more appropriate choice for different situations. When is doctest the better choice, and when is unittest?</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec43"/>Test fixtures</h1></div></div></div><a class="indexterm" id="id286"/><p>Unittest has an important and highly useful capability that doctest lacks. You can tell unittest how to create a standardized environment for your unit tests to run inside, and how to clean up that environment when it's done. This ability to create and destroy a standardized test environment is a test fixture. While test fixtures doesn't actually make any tests possible that were impossible before, they can certainly make them shorter and less repetitive.</p></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec44"/>Time for action – testing database-backed units</h1></div></div></div><a class="indexterm" id="id287"/><p>Many programs need to access a database for their operation, which means that many of the units those programs are made of also access a database. The point is that the purpose of a database is to store information and make it accessible in arbitrary other places (in other words, databases exist to break the isolation of units). (The same problem applies to other information stores as well: for example, files in permanent storage.)</p><p>How do we deal with that? After all, just leaving the units that interact with the database untested is no solution. We need to create an environment where the database connection works as usual, but where any changes that are made do not last. There are a few different ways we could do that, but no matter what the details are, we need to set up the special database connection before each test that uses it, and we need to destroy any changes after each such test.</p><a class="indexterm" id="id288"/><p>Unittest helps us to do that by providing test fixtures via the <code class="literal">setUp</code> and <code class="literal">tearDown</code> methods of the <code class="literal">TestCase</code> class. These methods exist for us to override, with the default versions doing nothing.</p><p>Here's some database-using code (let's say it exists in a file called <code class="literal">employees.py</code>), for which we'll write tests:</p><div><div><h3 class="title"><a id="note19"/>Note</h3><p>This code uses the <code class="literal">sqlite3</code> database which ships with Python. Since the <code class="literal">sqlite3</code> interface is compatible with Python's DB-API 2.0, any database backend that you find yourself using will have a similar interface to what you see here.</p></div></div><div><pre class="programlisting">class employees:
    def __init__(self, connection):
        self.connection = connection

    def add_employee(self, first, last, date_of_employment):
        cursor = self.connection.cursor()
        cursor.execute('''insert into employees
                            (first, last, date_of_employment)
                          values
                            (:first, :last, :date_of_employment)''',
                       locals())
        self.connection.commit()

        return cursor.lastrowid

    def find_employees_by_name(self, first, last):
        cursor = self.connection.cursor()
        cursor.execute('''select * from employees
                          where
                            first like :first
                          and
                            last like :last''',
                       locals())

        for row in cursor:
            yield row

    def find_employees_by_date(self, date):
        cursor = self.connection.cursor()
        cursor.execute('''select * from employees
                          where date_of_employment = :date''',
                       locals())

        for row in cursor:
            yield row</pre></div><div><ol class="orderedlist arabic"><li class="listitem">We'll start writing the tests by importing the modules that we need and introducing our <code class="literal">TestCase</code> class.<a class="indexterm" id="id289"/><div><pre class="programlisting">from unittest import TestCase, main
from sqlite3 import connect, PARSE_DECLTYPES
from datetime import date
from employees import employees

class test_employees(TestCase):</pre></div></li><li class="listitem"><a class="indexterm" id="id290"/>We need a <code class="literal">setUp</code> method to create the environment that our tests depend on. In this case, that means creating a new database connection to an in-memory-<a class="indexterm" id="id291"/>only database, and populating that database with the needed tables and rows.<div><pre class="programlisting">    def setUp(self):
        connection = connect(':memory:',
                             detect_types=PARSE_DECLTYPES)
        cursor = connection.cursor()

        cursor.execute('''create table employees
                            (first text,
                             last text,
                             date_of_employment date)''')

        cursor.execute('''insert into employees
                            (first, last, date_of_employment)
                          values
                            ("Test1", "Employee", :date)''',
                       {'date': date(year = 2003,
                                     month = 7,
                                     day = 12)})

        cursor.execute('''insert into employees
                            (first, last, date_of_employment)
                          values
                            ("Test2", "Employee", :date)''',
                       {'date': date(year = 2001,
                                     month = 3,
                                     day = 18)})

        self.connection = connection</pre></div></li><li class="listitem"><a class="indexterm" id="id292"/>We need a <code class="literal">tearDown</code> method to undo whatever the <a class="indexterm" id="id293"/> <code class="literal">setUp</code> method did, so that each test can run in an untouched version of the environment. Since the database is only in memory, all we have to do is close the connection, and it goes away. <code class="literal">tearDown</code> may end up being much more complicated in other scenarios.<div><pre class="programlisting">    def tearDown(self):
        self.connection.close()</pre></div></li><li class="listitem">Finally, we need the tests themselves, and the code to execute the tests.<div><pre class="programlisting">    def test_add_employee(self):
        to_test = employees(self.connection)
        to_test.add_employee('Test1', 'Employee', date.today())

        cursor = self.connection.cursor()
        cursor.execute('''select * from employees
                          order by date_of_employment''')

        self.assertEqual(tuple(cursor),
                         (('Test2', 'Employee', date(year=2001,
                                                     month=3,
                                                     day=18)),
                          ('Test1', 'Employee', date(year=2003,
                                                     month=7,
                                                     day=12)),
                          ('Test1', 'Employee', date.today())))
<a class="indexterm" id="id294"/>
    def test_find_employees_by_name(self):
        to_test = employees(self.connection)

        found = tuple(to_test.find_employees_by_name('Test1', 'Employee'))
        expected = (('Test1', 'Employee', date(year=2003,
                                               month=7,
                                               day=12)),)

        self.assertEqual(found, expected)

    def test_find_employee_by_date(self):
        to_test = employees(self.connection)

        target = date(year=2001, month=3, day=18)
        found = tuple(to_test.find_employees_by_date(target))

        expected = (('Test2', 'Employee', target),)

        self.assertEqual(found, expected)

if __name__ == '__main__':
    main()<a class="indexterm" id="id295"/>
</pre></div></li></ol></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec70"/>
<em>What just happened?</em>
</h2></div></div></div><p>We used a <code class="literal">setUp</code> method for our <code class="literal">TestCase</code>, along with a matching <code class="literal">tearDown</code> method. Between them, these methods made sure that the environment in which the tests were executed was the one they needed (that was <code class="literal">setUp</code>'s job) and that the environment of each test was cleaned up after the test was run, so that the tests didn't interfere with each other (which was the job of <code class="literal">tearDown</code>). Unittest made sure that <code class="literal">setUp</code> was run once before each test method, and that <code class="literal">tearDown</code> was run once after each test method.</p><p>Because a test fixture—as defined by <code class="literal">setUp</code> and <code class="literal">tearDown</code>—gets wrapped around every test in a <code class="literal">TestCase</code> class, the <code class="literal">setUp</code> and <code class="literal">tearDown</code> for <code class="literal">TestCase</code> classes that contain too many tests can get very complicated and waste a lot of time dealing with details that are unnecessary for some of the tests. You can avoid that problem by simply grouping together, those tests that require specific aspects of the environment into their own <code class="literal">TestCase</code> classes. Give each <code class="literal">TestCase</code> an appropriate <code class="literal">setUp</code> and <code class="literal">tearDown</code>, only dealing with those aspects of the environment that are necessary for the tests it contains. You can have as many <code class="literal">TestCase</code> classes as you want, so there's no need to skimp on them when you're deciding which tests to group together.</p><a class="indexterm" id="id296"/><p>Notice how simple the <code class="literal">tearDown</code> method that we used was. That's usually a good sign: when the changes that need to be undone in the <code class="literal">tearDown</code> method are simple to describe, it often means that you can be sure of doing it perfectly. Since any imperfection of the <code class="literal">tearDown</code> makes it possible for tests to leave behind stray data that might alter how other tests behave, getting it right is important. In this case, all of our changes were confined to the database, so getting rid of the database does the trick.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec71"/>Pop quiz – test fixtures</h2></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">What is the purpose of a test fixture?</li><li class="listitem">How is a test fixture created?.</li><li class="listitem">Can a test fixture have a <code class="literal">tearDown</code> method without a <code class="literal">setUp</code>? How about <code class="literal">setUp</code> without <code class="literal">tearDown</code>?</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec72"/>Have a go hero – file path abstraction</h2></div></div></div><a class="indexterm" id="id297"/><p>Below is a class definition that describes an abstraction of file paths. Your challenge is to write unit tests (using unittest) that check each of the methods of the class, making sure that they behave as advertised. You will need to use a test fixture to create and destroy a sandbox area in the filesystem for your tests to operate on.</p><p>Because doctest doesn't support test fixtures, writing these tests using that framework would be quite annoying. You'd have to duplicate the code to create the environment before each test, and the code to clean it up after each test. By using <code class="literal">unittest</code>, we can avoid that duplication.</p><p>There are several things about this class that are wrong, or at least not as right as they ought to be. See if you can catch them with your tests.</p><div><pre class="programlisting">from os.path import isfile, isdir, exists, join
from os import makedirs, rmdir, unlink

class path:
    r"""

    Instances of this class represent a file path, and facilitate
    several operations on files and directories.


    Its most surprising feature is that it overloads the division
    operator, so that the result of placing a / operator between two
    paths (or between a path and a string) results in a longer path,
    representing the two operands joined by the system's path
    separator character.

    """

    def __init__(self, target):
        self.target = target

    def exists(self):
        return exists(self.target)

    def isfile(self):
        return isfile(self.target)

    def isdir(self):
        return isdir(self.target)

    def mkdir(self, mode = 493):
        makedirs(self.target, mode)

    def rmdir(self):
        if self.isdir():
            rmdir(self.target)
        else:
            raise ValueError('Path does not represent a directory')

    def delete(self):
        if self.exists():
            unlink(self.target)
        else:
            raise ValueError('Path does not represent a file')

    def open(self, mode = "r"):
        return open(self.target, mode)

    def __div__(self, other):
        if isinstance(other, path):
            return path(join(self.target, other.target))
        return path(join(self.target, other))


    def __repr__(self):
        return '&lt;path %s&gt;' % self.target<a class="indexterm" id="id298"/>
</pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec45"/>Integrating with Python Mocker</h1></div></div></div><a class="indexterm" id="id299"/><p>You've used Mocker enough to see the repetitiveness involved in creating a mocking context at the beginning of the text and calling its <code class="literal">verify</code> and <code class="literal">restore</code> methods at the end. Mocker simplifies this for you by providing a class called <code class="literal">MockerTestCase</code> in the mocker module. <code class="literal">MockerTestCase</code> behaves just like a normal unittest <code class="literal">TestCase</code>, except that for each test, it automatically creates a mocking context, which it then verifies and restores after the test. The mocking context is stored in <code class="literal">self.mocker</code>.</p><a class="indexterm" id="id300"/><p>The following example demonstrates <code class="literal">MockerTestCase</code> by using it to write a test involving a mock of <code class="literal">time.time</code>. Before the test gets executed, a mocking context is stored in <code class="literal">self.mocker</code>. After the test is run, the context is automatically verified and restored.</p><div><pre class="programlisting">from unittest import main
from mocker import MockerTestCase
from time import time

class test_mocker_integration(MockerTestCase):
    def test_mocking_context(self):
        mocker = self.mocker
        time_mock = mocker.replace('time.time')
        time_mock()
        mocker.result(1.0)

        mocker.replay()

        self.assertAlmostEqual(time(), 1.0)

if __name__ == '__main__':
    main()</pre></div><a class="indexterm" id="id301"/><p>The above is a simple test that checks that the current time is <code class="literal">1.0</code>, which it would not be if we didn't mock <code class="literal">time.time</code>. Instead of creating a new Mocker instance, we have one already available to us as <code class="literal">self.mocker</code>, so we use that. We also get to leave off the calls to <code class="literal">verify</code> and <code class="literal">restore</code>, because the <code class="literal">MockerTestCase</code> takes care of that for us.</p></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec46"/>Summary</h1></div></div></div><p>This chapter contained a lot of information about how to use the unittest framework to write your tests.</p><p>Specifically, we covered how to use unittest to express concepts that you were already familiar with from doctest, differences and similarities between unittest and doctest, how to use test fixtures to embed your tests in a controlled and temporary environment, and how to use Python Mocker's <code class="literal">MockerTestCase</code> to simplify the integration of unittest and Mocker.</p><p>Until now, we've been running tests individually, or in small groups, by directly instructing Python to run them. Now that we've learned about unittest, we're ready to talk about managing and executing large bodies of tests, which is the topic of the next chapter.</p></div></body></html>