- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: 'Clean Architecture Essentials: Transforming Python Development'
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 清洁架构要素：转型Python开发
- en: As Python developers, we apply best practices such as writing clean functions,
    using descriptive variable names, and striving for modularity. Yet, as our applications
    grow, we often struggle to maintain this clarity and adaptability at scale. Python’s
    simplicity and versatility make it popular for projects ranging from web development
    to data science, but these strengths can become challenges as applications become
    more complex. We find ourselves lacking a master plan, an overarching architecture
    to guide our decisions and keep our projects maintainable as they evolve. This
    is where **Clean Architecture** comes into play, offering a structured approach
    to building Python applications that balance planning and agility, providing the
    architectural guidance we need for sustainable, large-scale development.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 作为Python开发者，我们应用最佳实践，如编写干净的函数、使用描述性变量名和追求模块化。然而，随着我们的应用程序增长，我们常常难以在规模上保持这种清晰性和适应性。Python的简洁性和多功能性使其在从Web开发到数据科学等众多项目中变得流行，但这些优势在应用程序变得更加复杂时可能成为挑战。我们发现自己在缺乏一个总体规划，一个指导我们决策并保持项目在演变过程中可维护的总体架构。这就是**清洁架构**发挥作用的地方，它提供了一种构建Python应用程序的结构化方法，平衡了规划和敏捷性，为我们提供了可持续、大规模开发的架构指导。
- en: Clean Architecture, introduced by Robert C. Martin in 2012 ([https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html)),
    synthesizes decades of software design wisdom into a cohesive set of principles.
    It addresses persistent challenges in software development, such as managing complexity
    and accommodating change. By applying Clean Architecture principles to Python
    projects, developers can create systems that are not only functional but also
    maintainable, testable, and adaptable over time.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 清洁架构，由罗伯特·C·马丁于2012年提出([https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html))，将数十年的软件设计智慧综合成一套连贯的原则。它解决了软件开发中的一些持续挑战，如管理复杂性和适应变化。通过将清洁架构原则应用于Python项目，开发者可以创建不仅功能性强，而且随着时间的推移可维护、可测试和可适应的系统。
- en: In this chapter, we’ll explore the essence of Clean Architecture and its relevance
    to Python development. We’ll examine how Clean Architecture principles align with
    Python’s philosophy of simplicity and readability, creating a natural synergy
    that enhances Python’s strengths. You’ll learn how Clean Architecture can help
    you build Python applications that are easier to understand, modify, and extend,
    even as they grow in complexity.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨清洁架构的本质及其与Python开发的关联。我们将研究清洁架构原则如何与Python的简洁性和可读性哲学相一致，从而创造一种自然协同效应，增强Python的优势。您将了解清洁架构如何帮助您构建易于理解、修改和扩展的Python应用程序，即使它们在复杂性增加的情况下也是如此。
- en: By the end of this chapter, you’ll have an overview of Clean Architecture principles
    and their potential benefits for Python development. You’ll be introduced to how
    this approach can address common challenges in software development, particularly
    as Python projects grow in scale and complexity. This foundational understanding
    of Clean Architecture will be essential as we delve deeper into its implementation
    and best practices in Python throughout the rest of the book.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将了解清洁架构原则及其对Python开发的潜在益处。您将了解这种方法如何解决软件开发中的常见挑战，尤其是在Python项目规模和复杂性增长时。这种对清洁架构的基础理解将是我们深入探讨其在Python中的实现和最佳实践的基础。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下主要主题：
- en: 'Why Clean Architecture in Python: the benefits of balancing planning and agility'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么在Python中使用清洁架构：平衡规划和敏捷性的好处
- en: What is Clean Architecture?
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是清洁架构？
- en: 'Clean Architecture and Python: a natural fit'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清洁架构与Python：天作之合
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code snippets in this chapter are for demonstration purposes only, showing
    the application of some of the topics and practices noted in the chapter. Future
    chapters will feature more involved examples of code with specific requirements
    noted when applicable. All code for all chapters can be found in the book’s accompanying
    GitHub repository at [https://github.com/PacktPublishing/Clean-Architecture-with-Python](https://github.com/PacktPublishing/Clean-Architecture-with-Python).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的代码片段仅用于演示目的，展示了一些章节中提到的主题和实践的应用。未来的章节将包含更复杂的代码示例，并注明具体要求。所有章节的代码都可以在本书配套的GitHub仓库中找到：[https://github.com/PacktPublishing/Clean-Architecture-with-Python](https://github.com/PacktPublishing/Clean-Architecture-with-Python)。
- en: 'Why Clean Architecture in Python: the benefits of balancing planning and agility'
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么Python中的Clean Architecture：平衡规划和敏捷的好处
- en: In this section, we’ll explore the critical balance between planning and agility
    in Python development and how Clean Architecture can help achieve this balance.
    We’ll examine the challenges posed by increasing complexity in modern Python applications
    and the imperative for agility in today’s fast-paced business environment. We’ll
    then discuss the trade-offs between planning and flexibility, and how architectural
    thinking can provide a framework for managing these trade-offs. Finally, we’ll
    look at the role of architecture in managing complexity and setting the stage
    for long-term success. Through these discussions, you’ll gain insight into why
    Clean Architecture is particularly valuable for Python developers striving to
    create maintainable, adaptable, and efficient applications.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨Python开发中规划和敏捷之间的关键平衡，以及Clean Architecture如何帮助实现这种平衡。我们将研究现代Python应用程序日益增加的复杂性带来的挑战，以及当今快节奏商业环境中敏捷性的必要性。然后，我们将讨论规划和灵活性之间的权衡，以及架构思维如何为管理这些权衡提供一个框架。最后，我们将探讨架构在管理复杂性和为长期成功奠定基础中的作用。通过这些讨论，你将深入了解为什么Clean
    Architecture对于努力创建可维护、可适应和高效应用的Python开发者尤其有价值。
- en: Let’s begin by examining the complex challenges facing modern Python development.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从研究现代Python开发面临的复杂挑战开始。
- en: The complexity challenge in modern Python development
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 现代Python开发中的复杂性挑战
- en: As Python’s popularity soars, so do the scale and complexity of applications
    built with it. From web services to data science pipelines, Python projects are
    growing larger and more intricate. This growth brings significant challenges that
    every Python developer must grapple with.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 随着Python的流行度飙升，用它构建的应用程序规模和复杂性也在增加。从网络服务到数据科学管道，Python项目正在变得更大、更复杂。这种增长带来了重大的挑战，每个Python开发者都必须应对。
- en: The increasing complexity of systems makes them harder to understand, modify,
    and maintain. This complexity can severely limit your ability to add new features
    or respond to changing requirements. The maintenance burden of complex Python
    systems can overwhelm development teams, slowing down progress and innovation.
    Even small changes in large, complex systems can have far-reaching consequences,
    making modifications expensive and risky.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 系统的日益复杂使得它们更难理解、修改和维护。这种复杂性可能会严重限制你添加新功能或应对变化需求的能力。复杂Python系统的维护负担可能会压垮开发团队，减缓进步和创新。即使是大型复杂系统中的微小变化也可能产生深远的影响，使得修改变得昂贵且风险高。
- en: 'Consider a fictitious large Python-based e-commerce site: PyShop. The business
    decides to implement a seemingly simple feature: adding gift-wrapping options
    to orders. However, this straightforward addition quickly cascades into a complex
    project:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个虚构的大型基于Python的电子商务网站：PyShop。业务决定实施一个看似简单的功能：在订单中添加包装选项。然而，这个简单的添加很快就会演变成一个复杂的项目：
- en: The order processing module needs updates to include gift-wrapping choices
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 订单处理模块需要更新以包含包装选项
- en: The inventory system requires modification to track gift-wrapping supplies
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 库存系统需要修改以跟踪包装材料
- en: The pricing engine needs adjustments to calculate additional costs
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定价引擎需要调整以计算额外成本
- en: The user interface (UI) must be updated to present gift-wrapping options
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户界面（UI）必须更新以展示包装选项
- en: The fulfillment system needs changes to include gift-wrapping instructions
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配送系统需要更改以包含包装说明
- en: 'What was estimated as a two-week-long task stretches into a multi-month project.
    Each change potentially impacts other system parts: adjustments in order processing
    affect reporting, inventory changes influence supply chain management, and UI
    modifications require extensive user experience testing.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 原本估计为两周的任务延长成了多个月的项目。每一次变更都可能影响其他系统部分：订单处理的调整会影响报告，库存的变更会影响供应链管理，而用户界面修改需要广泛的用户体验测试。
- en: This example highlights how interconnected modules in a complex system can turn
    a simple feature addition into a significant undertaking, emphasizing the need
    for an architecture that allows for more isolated changes and easier testing processes.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子突出了在复杂系统中相互关联的模块如何将简单的功能添加转变为一个重大的任务，强调了需要一个允许进行更独立变更和更容易测试过程的架构。
- en: 'Moreover, as Python projects grow, developers often struggle with abstractions,
    a critical aspect that Clean Architecture helps address. Without proper guidance,
    codebases can suffer from extremes: either becoming a tangled mess of deeply nested
    class hierarchies that are hard to understand and modify or devolving into monolithic
    *do-everything* classes that lack any meaningful abstraction. In the former case,
    developers may create too-complex inheritance structures to maximize code reuse,
    resulting in a fragile system where changes in one place have unforeseen consequences
    elsewhere. In the latter case, the lack of abstraction leads to massive, unwieldy
    classes and rampant code duplication, making it nearly impossible to maintain
    consistency or make systemic changes. Both scenarios result in codebases that
    are difficult to understand, maintain, and extend, which is precisely the issues
    that a well-planned architecture helps prevent.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，随着Python项目的增长，开发者经常在抽象上遇到困难，这是Clean Architecture帮助解决的问题的一个关键方面。没有适当的指导，代码库可能会出现极端情况：要么变成难以理解和修改的深度嵌套类层次结构的混乱，要么退化成缺乏任何有意义抽象的“万能”类。在前一种情况下，开发者可能会创建过于复杂的继承结构以最大化代码重用，导致一个脆弱的系统，其中一处的变化会在其他地方产生不可预见的后果。在后一种情况下，缺乏抽象会导致庞大、难以驾驭的类和代码重复泛滥，几乎不可能保持一致性或进行系统性的变更。这两种情况都导致代码库难以理解、维护和扩展，这正是精心规划的架构有助于预防的问题。
- en: Furthermore, in today’s rapidly evolving tech landscape, complex, tightly coupled
    systems struggle to take advantage of new technologies. This limitation can significantly
    impact your ability to stay competitive in a field where technological agility
    is crucial.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在当今快速发展的技术环境中，复杂且紧密耦合的系统难以利用新技术。这种限制可能会严重影响你在技术敏捷性至关重要的领域保持竞争力的能力。
- en: The agility imperative
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 敏捷性强制
- en: In our fast-paced business environment, agility is not just an advantage—it’s
    a necessity. With every company essentially becoming a technology company, the
    pressure to deliver quickly has never been higher. Python’s simplicity and extensive
    ecosystem make it an excellent choice for rapid development.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们快节奏的商业环境中，敏捷性不仅仅是一个优势——它是一个必需品。随着每家公司本质上都成为一家科技公司，快速交付的压力从未如此之高。Python的简单性和广泛的生态系统使其成为快速开发的绝佳选择。
- en: 'However, sustainable agility requires more than just initial speed, it demands
    architectural decisions that support ongoing evolution. It’s akin to building
    a high-performance race car: without proper design fundamentals, what starts as
    impressive acceleration quickly becomes limited by poor handling and maintenance
    challenges.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，可持续的敏捷性不仅仅需要初始速度，它需要支持持续演化的架构决策。这就像建造一辆高性能的赛车：如果没有适当的设计基础，最初令人印象深刻的加速很快就会受到糟糕的操控和维护挑战的限制。
- en: In rapidly evolving Python applications, this principle becomes starkly evident.
    Without a cohesive architecture, quick feature additions can create a tangled
    web of dependencies. What starts as a nimble codebase can, within months, become
    rigid and fragile. Developers find themselves spending more time deciphering existing
    code than writing new features. When it’s not immediately clear where new code
    should be added or how it should interact with existing components, developers
    under pressure may make hasty decisions, leading to suboptimal implementations
    and introducing bugs. These quick fixes further complicate the codebase, making
    future changes even more challenging. The initial velocity becomes unsustainable,
    not because of the speed itself, but due to the lack of a sturdy architectural
    foundation that can guide rapid changes and provide clear pathways for new feature
    integration.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在快速发展的Python应用中，这一原则变得尤为明显。如果没有一个统一的架构，快速添加功能可能会造成错综复杂的依赖关系网。一开始灵活的代码库，几个月后可能会变得僵化且脆弱。开发者发现自己花更多的时间去解析现有代码，而不是编写新功能。当新代码应该添加在哪里或如何与现有组件交互并不立即清晰时，在压力下的开发者可能会做出仓促的决定，导致次优实现并引入错误。这些快速修复进一步复杂化了代码库，使得未来的更改更加困难。初始速度变得不可持续，不是因为速度本身，而是因为缺乏一个坚固的架构基础，这个基础可以引导快速变化并为新功能的集成提供清晰的路径。
- en: Requirements change, often unpredictably. Your Python projects need to be structured
    in a way that allows for easy adaptation to these changes. This adaptability is
    crucial for long-term success in software development.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 需求经常变化，往往不可预测。您的Python项目需要以允许轻松适应这些变化的方式进行结构化。这种适应性对于软件开发的长远成功至关重要。
- en: 'Striking a balance: the planning–agility trade-off'
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 寻找规划与敏捷之间的平衡：规划-敏捷权衡
- en: Finding the right balance between planning and agility is crucial in Python
    development. As Dave Thomas wisely said, “*Big design up front is dumb. Doing
    no design up front is even dumber.*” The key is finding the middle ground that
    allows for both structure and flexibility.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在规划与敏捷之间找到正确的平衡在Python开发中至关重要。正如Dave Thomas明智地说：“*一开始就进行大规模设计是愚蠢的。一开始就不进行设计则更愚蠢。*”关键在于找到既能提供结构又能提供灵活性的中间地带。
- en: Good architecture helps you postpone decisions. It gives you the flexibility
    to push decisions to later stages when you have more information to make the correct
    choice. This approach is particularly valuable in Python development, where the
    language’s flexibility can sometimes lead to decision paralysis.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的架构可以帮助您推迟决策。它为您提供了灵活性，可以在拥有更多信息时将决策推迟到更晚的阶段，以便做出正确的选择。这种方法在Python开发中尤其有价值，因为该语言的灵活性有时会导致决策瘫痪。
- en: Introducing architectural thinking in Python development means considering the
    long-term structure of your project from the start, without over-engineering.
    It’s about creating a framework that guides development while remaining adaptable
    to change.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python开发中引入架构思维意味着从一开始就考虑项目的长期结构，而不进行过度设计。这是关于创建一个指导开发同时又能适应变化的框架。
- en: The role of architecture in managing complexity
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 架构在管理复杂性中的作用
- en: Effective architecture is your best tool for managing complexity in Python systems.
    Good architecture simplifies complex systems by providing a clear structure and
    **separation of concerns** (**SoC**). One of the first steps in architecting a
    new system is determining how to divide it, keeping things that change for the
    same reason together and things that change for different reasons apart.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 有效的架构是您在Python系统中管理复杂性的最佳工具。良好的架构通过提供清晰的结构和**关注点分离**（**SoC**）来简化复杂的系统。构建新系统的第一步之一是确定如何划分它，将因相同原因而改变的事物放在一起，将因不同原因而改变的事物分开。
- en: Consider two Python-based **content management systems** (**CMSs**) for media
    companies, both tasked with implementing a new AI-powered content tagging feature.
    In the well-architected system, this feature is implemented as a standalone module
    with clear interfaces. It integrates smoothly with the existing content creation
    and search modules through well-defined APIs. Developers can build and test the
    AI tagging service independently, and then connect it to the content database
    and UI with minimal disruption. Conversely, in a poorly structured system, adding
    this feature requires changes across the entire stack—from database schemas to
    frontend code—leading to unexpected bugs and performance issues. What takes a
    sprint in the well-architected system becomes a months-long refactoring project
    in the poorly structured one, demonstrating how thoughtful initial architecture
    can dramatically improve development efficiency and system adaptability.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑两个面向媒体公司的基于Python的**内容管理系统**（**CMS**），它们都被赋予了实施一个新的人工智能内容标记功能。在一个设计良好的系统中，这个功能被实现为一个独立的模块，具有清晰的接口。它通过定义良好的API与现有的内容创建和搜索模块无缝集成。开发者可以独立构建和测试AI标记服务，然后以最小的干扰将其连接到内容数据库和UI。相反，在一个结构不佳的系统中，添加这个功能需要在整个堆栈中进行更改——从数据库模式到前端代码——导致意外的错误和性能问题。在良好架构的系统中所花费的冲刺时间，在结构不佳的系统中可能变成几个月的重构项目，这展示了深思熟虑的初始架构如何显著提高开发效率和系统适应性。
- en: The architectural decisions you make early on have a profound impact on the
    long-term development costs and flexibility of your Python projects. A well-architected
    system can significantly reduce the cost of change over time, allowing your team
    to respond more quickly to new requirements or technological changes.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你在早期做出的架构决策将对Python项目的长期开发成本和灵活性产生深远影响。一个设计良好的系统可以显著降低随时间变化的成本，使你的团队能够更快地响应新的需求或技术变化。
- en: Preparing for Clean Architecture
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备清洁架构
- en: As we move toward discussing Clean Architecture, it’s important to understand
    that it offers a systematic approach to balancing planning and agility in Python
    projects. Architectural principles provide powerful tools for managing and reducing
    complexity in your Python systems.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们转向讨论清洁架构时，重要的是要理解它为Python项目提供了一个平衡规划和敏捷的系统方法。架构原则为你提供了管理并减少Python系统中复杂性的强大工具。
- en: At its core, Clean Architecture is about strategic SoC in your Python applications.
    It advocates for a structure where the essential business logic is insulated from
    external factors such as UIs, databases, and third-party integrations. This separation
    creates clear boundaries between different parts of your application, each with
    its own responsibilities. By doing so, Clean Architecture allows your core business
    rules to remain pure and unaffected by the implementation details of **input/output**
    (**I/O**) mechanisms or **data management systems** (**DMSs**).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在其核心，清洁架构是关于在Python应用程序中进行战略性的SoC（分离关注点）。它提倡一种结构，其中基本业务逻辑被隔离于外部因素，如UI（用户界面）、数据库和第三方集成。这种分离在应用程序的不同部分之间创建了清晰的边界，每个部分都有其自己的职责。通过这样做，清洁架构允许你的核心业务规则保持纯净，不受**输入/输出**（**I/O**）机制或**数据管理系统**（**DMS**）的实现细节的影响。
- en: By understanding these challenges and principles, you’ll be better prepared
    to appreciate the benefits that Clean Architecture can bring to your Python projects.
    In the next sections, we’ll delve into what Clean Architecture is and how it specifically
    applies to Python development, providing you with the tools to combat complexity
    and reduce the cost of change in your software systems.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 通过理解这些挑战和原则，你将更好地准备去欣赏清洁架构（Clean Architecture）能为你的Python项目带来的好处。在接下来的章节中，我们将深入探讨清洁架构是什么，以及它如何具体应用于Python开发，为你提供对抗复杂性并降低软件系统变更成本的工具。
- en: What is Clean Architecture?
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是清洁架构？
- en: Having explored the challenges of managing complexity in Python development
    and the need for balancing planning with agility, the goal of this section is
    to give you a high-level overview of Clean Architecture. We’ll be covering several
    key concepts and principles in quick succession to provide a broad understanding.
    Don’t worry if you don’t grasp every detail immediately. This is just the beginning
    of our journey. Each of these topics will be explored in depth in the chapters
    to come, where we’ll dive into practical Python implementations and real-world
    scenarios.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索了在Python开发中管理复杂性的挑战以及平衡规划与敏捷性的需求之后，本节的目标是为你提供一个关于Clean Architecture的高级概述。我们将快速连续地介绍几个关键概念和原则，以提供广泛的理解。如果你不能立即掌握所有细节，请不要担心。这仅仅是我们的旅程的开始。在接下来的章节中，我们将对这些主题进行深入探讨，其中我们将深入研究实际的Python实现和现实世界场景。
- en: 'Clean Architecture synthesizes many ideas from previous architectural styles,
    but it is built around a fundamental concept: the separation of software elements
    into ring levels, with a strict rule that code dependencies can only move inward
    from outer levels. This principle is formally known as the **Dependency Rule**,
    one of the most critical aspects of Clean Architecture. The Dependency Rule states
    that source code dependencies must only point inward, toward higher-level policies.
    Inner circles must know nothing about outer circles, while outer circles must
    depend on and adapt to inner circles. This ensures that changes to external elements
    (like databases, UI, or frameworks) don’t impact the core business logic. The
    aim is to create software systems that are not only functional but also maintainable
    and adaptable over time. To illustrate this, let’s consider a simple Python application
    for a library management system:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Clean Architecture综合了许多来自先前架构风格的想法，但它围绕一个基本概念构建：将软件元素分离成环级别，并有一个严格的规则，即代码依赖只能从外部级别向内移动。这个原则正式称为**依赖规则**，它是Clean
    Architecture最关键方面之一。依赖规则指出，源代码依赖必须仅指向内部，即指向更高层次的策略。内圈必须对外圈一无所知，而外圈必须依赖并适应内圈。这确保了外部元素（如数据库、UI或框架）的变化不会影响核心业务逻辑。目标是创建不仅功能强大，而且随着时间的推移可维护和可适应的软件系统。为了说明这一点，让我们考虑一个简单的用于图书馆管理系统的Python应用程序：
- en: At the core, we have the `Book` class, representing the basic data structure.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在核心部分，我们有`Book`类，代表基本的数据结构。
- en: Moving outward, we have a `BookInventory` class that manages operations on books.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向外扩展，我们有`BookInventory`类，它管理书籍的操作。
- en: In the outer ring, we have a `BookInterface` class that handles user interactions
    related to books.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在外环中，我们有`BookInterface`类，它处理与书籍相关的用户交互。
- en: In this structure, the `Book` class knows nothing about the `BookInventory`
    or `BookInterface` classes. The `BookInventory` class might use the `Book` class
    but doesn’t know about the interface. This separation ensures that the core logic
    remains unaffected by external concerns.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个结构中，`Book`类对`BookInventory`或`BookInterface`类一无所知。`BookInventory`类可能会使用`Book`类，但不知道关于接口的信息。这种分离确保了核心逻辑不受外部关注的影响。
- en: Crucially, this structure allows us to modify or even replace outer layers without
    affecting the inner layers. For instance, we could change the UI from a **command-line
    interface** (**CLI**) to a web interface by modifying the `BookInterface` class,
    without needing to alter the `Book` or `BookInventory` classes. This flexibility
    is a key advantage of the Clean Architecture approach.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 关键的是，这种结构允许我们修改或甚至替换外部层，而不会影响内部层。例如，我们可以通过修改`BookInterface`类将UI从命令行界面（CLI）更改为Web界面，而不需要修改`Book`或`BookInventory`类。这种灵活性是Clean
    Architecture方法的关键优势。
- en: 'This structure is designed to produce systems that embody the key principles
    we introduced earlier:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这种结构旨在产生体现我们之前介绍的关键原则的系统：
- en: SoC
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SoC（分离关注点）
- en: Independence of external details
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部细节的独立性
- en: '**Testability** and **maintainability**'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可测试性**和**可维护性**'
- en: Let’s explore further how Clean Architecture achieves these goals and the benefits
    it brings to software development.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进一步探讨Clean Architecture如何实现这些目标以及它为软件开发带来的好处。
- en: The onion architecture concept
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 洋葱架构概念
- en: 'Let’s visualize the ring levels mentioned earlier and add another level of
    detail as to the purpose of each ring. Clean Architecture is often visualized
    as a series of concentric circles, like an onion. Each circle represents a different
    layer of software, and the Dependency Rule we discussed ensures that dependencies
    only flow inward across these boundaries. The core layers contain business logic
    (entities), while the external layers contain interface and implementation details
    (*see Figure 1.1*):'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们可视化之前提到的环形层级，并添加另一个层级细节，以说明每个环的目的。清洁架构通常被描绘成一系列同心圆，就像洋葱一样。每个圆代表软件的不同层，我们讨论的依赖规则确保依赖只在这些边界内向内流动。核心层包含业务逻辑（实体），而外部层包含接口和实现细节（*见图1.1*）：
- en: '![Figure 1.1: Clean Architecture: a series of concentric layers](img/B31577_01_1.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图1.1：清洁架构：一系列同心层](img/B31577_01_1.png)'
- en: 'Figure 1.1: Clean Architecture: a series of concentric layers'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1：清洁架构：一系列同心层
- en: '*Figure 1.1* demonstrates the separation of inner core business logic progressing
    out to external interfaces:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '*图1.1*展示了从内部核心业务逻辑向外到外部接口的分离：'
- en: '**Entities**: At the center are entities, which encapsulate enterprise-wide
    business rules. Entities in this context are the primary *nouns* of your product,
    the core business objects that would exist even without software. For example,
    in an e-commerce system, entities might include *Customer*, *Product*, and *Order*.
    In a task management application, they could be *User*, *Task*, and *Project*.
    These entities contain the most basic, universal rules about how these objects
    behave and interact.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实体**：在中心是实体，它们封装企业级业务规则。在这个上下文中，实体是产品的主要**名词**，即使没有软件也存在的基本业务对象。例如，在电子商务系统中，实体可能包括*客户*、*产品*和*订单*。在任务管理应用程序中，它们可能是*用户*、*任务*和*项目*。这些实体包含关于这些对象如何行为和交互的最基本、最通用的规则。'
- en: '**Use Cases**: The next layer contains use cases, which orchestrate the flow
    of data to and from entities. A use case represents a specific way the system
    is used. It’s essentially a description of how the system should behave for a
    particular scenario. For instance, in a task management app, use cases might include
    *Create New Task*, *Complete Task*, or *Assign Task*. Use cases contain application-specific
    business rules and control how and when entities are used to fulfill the goals
    of the application.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用例**：下一层包含用例，它们协调数据在实体之间流动。用例代表系统被使用的特定方式。它本质上是对系统在特定场景下应该如何行为的描述。例如，在任务管理应用程序中，用例可能包括*创建新任务*、*完成任务*或*分配任务*。用例包含特定于应用程序的业务规则，并控制如何以及何时使用实体来实现应用程序的目标。'
- en: '**Interface Adapters**: Further out, we find interface adapters, which convert
    data between use cases and external agencies. This layer acts as a set of translators
    between the inner layers (entities and use cases) and the outer layer. It might
    include things such as controllers that handle HTTP requests, presenters that
    format data for display, and gateways that transform data for persistence. In
    a Python web application, this might include your view functions or classes that
    handle routing and request processing.  A key point of this layer is that it allows
    us to decouple from frameworks.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**接口适配器**：进一步向外，我们发现接口适配器，它们在用例和外部机构之间转换数据。这一层充当内部层（实体和用例）和外部层之间的一组翻译器。它可能包括处理HTTP请求的控制器、格式化数据以供显示的演示者以及转换数据以进行持久化的网关。在Python
    Web应用程序中，这可能包括处理路由和请求处理的视图函数或类。这一层的关键点是它允许我们与框架解耦。'
- en: '**Frameworks and Drivers**: The outermost layer contains frameworks and drivers,
    where the *external agencies* reside. By *drivers*, we mean the specific tools,
    frameworks, and delivery mechanisms that are used to run the system but aren’t
    core to the business logic. In a Python context, examples might include the following:'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**框架和驱动程序**：最外层包含框架和驱动程序，其中驻留着**外部机构**。我们所说的**驱动程序**是指用于运行系统但不是业务逻辑核心的具体工具、框架和交付机制。在Python环境中，可能包括以下示例：'
- en: Web frameworks such as Django or Flask
  id: totrans-67
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web框架，如Django或Flask
- en: Database drivers such as `psycopg2` for PostgreSQL or `pymongo` for MongoDB
  id: totrans-68
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库驱动程序，例如用于PostgreSQL的`psycopg2`或用于MongoDB的`pymongo`
- en: External libraries for tasks such as sending emails (for example, `smtplib`)
    or processing payments
  id: totrans-69
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于发送电子邮件（例如，`smtplib`）或处理支付等任务的外部库
- en: UI frameworks if you’re building a desktop or mobile app (for example, PyQt)
  id: totrans-70
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你在构建桌面或移动应用程序（例如，PyQt），则包含UI框架
- en: System utilities for tasks such as logging or configuration management
  id: totrans-71
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统工具，用于执行诸如日志记录或配置管理之类的任务
- en: This outermost layer is the most volatile, as it’s where we interact with the
    outside world and where technologies are most likely to change over time. By keeping
    it separate from our core business logic, we can more easily swap out these external
    tools without affecting the heart of our application.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 最外层是最不稳定的，因为它是我们与外部世界互动的地方，也是技术最有可能随时间变化的地方。通过将其与我们的核心业务逻辑分开，我们可以更容易地更换这些外部工具，而不会影响我们应用程序的核心。
- en: This layered structure of Clean Architecture promotes SoC, establishing a clear
    organizational framework for software systems. Now that we have an idea of the
    fundamental structure of Clean Architecture, let’s further investigate its broader
    benefits.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 清洁架构的这种分层结构促进了SoC（分离关注点），为软件系统建立了一个清晰的组织框架。现在我们已经了解了清洁架构的基本结构，让我们进一步探讨其更广泛的好处。
- en: Benefits of Clean Architecture
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 清洁架构的好处
- en: One of the primary advantages of Clean Architecture is its focus on protecting
    and isolating your core business logic, the domain objects that represent the
    foundation of your business. While external details such as web frameworks and
    persistence engines come and go, the true value to your business lies in the time
    invested in designing and implementing these core domain objects. Clean Architecture
    recognizes this and provides a structure that insulates these crucial components
    from the volatility of external technologies.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 清洁架构的一个主要优点是它专注于保护和隔离你的核心业务逻辑，即代表你业务基础的领域对象。虽然外部细节，如Web框架和持久化引擎，来来去去，但对你业务真正的价值在于在设计实现这些核心领域对象上投入的时间。清洁架构认识到这一点，并提供了一种结构，可以隔离这些关键组件，使其免受外部技术的波动性影响。
- en: This architectural approach protects your investment in domain logic from the
    need to move away from a given framework or technology. For example, if a framework
    you’re using moves from an open source model to a proprietary one, Clean Architecture
    allows you to replace it without rewriting your core business logic. This separation
    significantly reduces the cost and risk of changes over time, allowing your system
    to evolve more easily as requirements change or as you need to adapt to new technologies.
    In essence, Clean Architecture ensures that the most valuable and stable part
    of your application, your business logic, remains unaffected by the often turbulent
    world of external technologies and frameworks.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这种架构方法保护了你在领域逻辑上的投资，使其免于需要从一个给定的框架或技术迁移。例如，如果你正在使用的框架从开源模式迁移到专有模式，清洁架构允许你替换它，而无需重写你的核心业务逻辑。这种分离显著降低了随时间变化的风险和成本，使你的系统更容易随着需求的变化或需要适应新技术而进化。本质上，清洁架构确保了应用程序中最有价值且最稳定的部分，即你的业务逻辑，不受外部技术和框架经常动荡世界的影响。
- en: Another key benefit is enhanced testability across all layers of the application.
    The independence of the core business logic from external details makes it much
    easier to write comprehensive unit tests. You can test business rules in isolation,
    without the need to spin up a database or web server or build cumbersome mocks.
    This leads to more thorough testing and, consequently, more robust software. It
    also encourages developers to write more tests, as the process becomes simpler
    and more straightforward.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个关键好处是增强了应用程序所有层的可测试性。核心业务逻辑与外部细节的独立性使得编写全面的单元测试变得容易得多。你可以在隔离的情况下测试业务规则，无需启动数据库或Web服务器或构建复杂的模拟。这导致了更彻底的测试，从而产生了更健壮的软件。这也鼓励开发者编写更多的测试，因为这个过程变得简单直接。
- en: Clean Architecture also provides flexibility in technology choices. Because
    the core of the application isn’t dependent on external frameworks or tools, you
    have the freedom to swap out these elements as needed. This is particularly valuable
    in the fast-moving world of technology, where today’s popular framework might
    be obsolete tomorrow. Similarly, you might start with a CLI for internal use,
    then add a web interface for broader access, all without altering your core business
    rules’ code. Your core business logic remains stable, while you have the flexibility
    to adopt new technologies in the outer layers as they emerge. Lastly, Clean Architecture
    promotes long-term agility in development and leads to what Robert C. Martin calls
    a *Screaming Architecture* ([https://blog.cleancoder.com/uncle-bob/2011/09/30/Screaming-Architecture.html](https://blog.cleancoder.com/uncle-bob/2011/09/30/Screaming-Architecture.html)).  Its
    focus on separating concerns and managing dependencies results in a codebase that’s
    easier to understand and modify. The concept of Screaming Architecture suggests
    that when you look at the structure of your system, it should scream its purpose
    and use cases, not its frameworks or tools. For instance, your architecture should
    scream *online bookstore*, not *Django application*. This clear, purpose-driven
    structure allows new team members to quickly grasp the system’s intent and make
    contributions. The architecture itself becomes a form of documentation, revealing
    the system’s core purpose and functionality at a glance. Such clarity and flexibility
    translate to increased development speed over the long term, even as the system
    grows in complexity. It also ensures that your system remains focused on its core
    business logic, rather than being tied to specific technical implementations.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 清洁架构还在技术选择上提供了灵活性。因为应用程序的核心不依赖于外部框架或工具，所以你可以根据需要自由替换这些元素。这在技术快速发展的世界中尤其有价值，因为今天流行的框架明天可能就过时了。同样，你可能从CLI（命令行界面）用于内部使用开始，然后添加Web界面以实现更广泛的可访问性，所有这些都不需要改变你的核心业务规则代码。你的核心业务逻辑保持稳定，同时你有灵活性在出现时在外层采用新技术。最后，清洁架构促进了长期的发展敏捷性，并导致了罗伯特·C·马丁所说的*尖叫架构*([https://blog.cleancoder.com/uncle-bob/2011/09/30/Screaming-Architecture.html](https://blog.cleancoder.com/uncle-bob/2011/09/30/Screaming-Architecture.html))。它关注于分离关注点和管理依赖，结果是一个更容易理解和修改的代码库。尖叫架构的概念表明，当你查看系统的结构时，它应该大声喊出其目的和用例，而不是其框架或工具。例如，你的架构应该大声喊出*在线书店*，而不是*Django应用程序*。这种清晰、以目的为导向的结构使得新团队成员能够快速理解系统的意图并做出贡献。架构本身成为了一种文档形式，一眼就能揭示系统的核心目的和功能。这种清晰性和灵活性在长期内转化为开发速度的提高，即使系统变得更加复杂。它还确保了你的系统始终专注于其核心业务逻辑，而不是被特定的技术实现所束缚。
- en: Clean Architecture in context
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 清洁架构的背景
- en: To fully appreciate the value of Clean Architecture, it’s important to understand
    its place in the broader context of software development practices and methodologies.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 要充分欣赏清洁架构的价值，了解它在更广泛的软件开发实践和方法论背景中的位置是很重要的。
- en: Clean Architecture represents an evolution from traditional layered architecture.
    While it builds upon the concept of layers, it places a stronger emphasis on SoC
    and enforces the Dependency Rule more strictly than traditional architectures.
    Unlike traditional layered architectures where lower layers often depend on persistence
    or infrastructure concerns, Clean Architecture keeps the inner layers pure and
    focused on business logic. This shift in focus allows for greater flexibility
    and resilience to change.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 清洁架构代表了从传统分层架构的演变。虽然它建立在层概念的基础上，但它更加强调SoC（关注点分离），并且比传统架构更严格地执行依赖规则。与传统分层架构不同，其中底层通常依赖于持久性或基础设施问题，清洁架构保持内部层纯净且专注于业务逻辑。这种关注点的转变使得架构具有更大的灵活性和对变化的适应性。
- en: Clean Architecture complements modern development practices such as Agile and
    DevOps. It aligns well with Agile methodologies by facilitating **continuous delivery**
    (**CD**) and making it easier to respond to change. The clear SoC supports iterative
    development and makes it easier to modify or extend functionality in response
    to changing requirements. In terms of DevOps, Clean Architecture supports practices
    such as **continuous integration and deployment** (**CI/CD**) by making systems
    more testable and modular. The clear boundaries between components can also help
    in scaling development across teams, as different teams can work on different
    layers or components with minimal interference.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Clean Architecture 补充了现代开发实践，如 Agile 和 DevOps。它通过促进 **持续交付**（**CD**）和更容易应对变化而很好地与
    Agile 方法论相吻合。清晰的 SoC 支持迭代开发，并使得根据不断变化的需求修改或扩展功能变得更加容易。在 DevOps 方面，Clean Architecture
    通过使系统更易于测试和模块化来支持诸如 **持续集成和部署**（**CI/CD**）等实践。组件之间的清晰边界还可以帮助跨团队扩展开发，因为不同的团队可以以最小的干扰在不同的层或组件上工作。
- en: In conclusion, Clean Architecture offers a powerful approach to building software
    systems that are scalable, maintainable, and adaptable to change. By focusing
    on SoC and managing dependencies, it provides a structure that can withstand the
    test of time and the pressures of evolving technology and business needs. As we
    move into the next section, we’ll explore how these principles align particularly
    well with Python development practices.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，Clean Architecture 为构建可扩展、可维护且能够适应变化的软件系统提供了一种强大的方法。通过关注 SoC 并管理依赖关系，它提供了一种能够经受时间考验和适应技术及业务需求变化的压力的结构。随着我们进入下一节，我们将探讨这些原则如何特别适合
    Python 开发实践。
- en: 'Clean Architecture and Python: a natural fit'
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Clean Architecture 和 Python：天作之合
- en: As we’ve explored the principles and benefits of Clean Architecture, you might
    be wondering how well these concepts align with Python development. In this section,
    we’ll discover that Clean Architecture and Python share a natural affinity, making
    Python an excellent language for implementing Clean Architecture principles.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们探讨了 Clean Architecture 的原则和好处之后，你可能想知道这些概念与 Python 开发之间的契合度如何。在本节中，我们将发现
    Clean Architecture 和 Python 具有天然的亲和力，使得 Python 成为实现 Clean Architecture 原则的绝佳语言。
- en: Python’s philosophy, as embodied in *The Zen of Python* ([https://peps.python.org/pep-0020/](https://peps.python.org/pep-0020/))
    aligns remarkably well with Clean Architecture principles. Both emphasize simplicity,
    readability, and the importance of well-structured code. Python’s focus on creating
    clear, maintainable, and adaptable code provides a strong foundation for implementing
    Clean Architecture. As we delve deeper into this section, we’ll explore how Python
    language features can be leveraged to create robust, maintainable systems that
    adhere to Clean Architecture principles.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的哲学，体现在 *Python 的禅意*（[https://peps.python.org/pep-0020/](https://peps.python.org/pep-0020/))
    中，与 Clean Architecture 原则惊人地吻合。两者都强调简单性、可读性和良好结构代码的重要性。Python 专注于创建清晰、可维护和可适应的代码，为实施
    Clean Architecture 提供了坚实的基础。随着我们深入本节，我们将探讨如何利用 Python 语言特性来创建符合 Clean Architecture
    原则的健壮、可维护的系统。
- en: Implementing Clean Architecture in Python
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Python 中实现 Clean Architecture
- en: Python’s dynamic nature, combined with its strong support for **object-oriented
    programming** (**OOP**) and functional programming paradigms, allows developers
    to implement Clean Architecture concepts with less boilerplate and greater clarity
    than many other languages.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的动态特性，结合其对 **面向对象编程**（**OOP**）和函数式编程范式的强大支持，使得开发者能够以比许多其他语言更少的样板代码和更高的清晰度来实现
    Clean Architecture 的概念。
- en: '**Note on code examples**'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '**关于代码示例的说明**'
- en: 'Throughout this book, you’ll notice type annotations in our code examples (e.g.,
    `def function(parameter: type) -> return_type)`. These type hints enhance code
    clarity and help enforce Clean Architecture boundaries. We’ll explore this powerful
    feature in depth in [*Chapter 3*](Chapter_03.xhtml#_idTextAnchor060).'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '在本书中，你会在我们的代码示例中注意到类型注解（例如，`def function(parameter: type) -> return_type)`）。这些类型提示增强了代码的清晰度，并有助于强制执行
    Clean Architecture 边界。我们将在 [*第 3 章*](Chapter_03.xhtml#_idTextAnchor060) 中深入探讨这一强大功能。'
- en: 'A key principle of Clean Architecture is the reliance on abstractions rather
    than concrete implementations. This principle directly supports the Dependency
    Rule we discussed earlier: dependencies should only point inward. Let’s see how
    this works in practice using Python’s **abstract base classes** (**ABCs**).'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 清洁架构的一个关键原则是依赖抽象而不是具体实现。这一原则直接支持我们之前讨论的依赖规则：依赖关系应仅指向内部。让我们看看如何使用Python的**抽象基类**（**ABCs**）在实践中实现这一点。
- en: 'Consider the following example, which models a notification system:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例，它模拟了一个通知系统：
- en: '[PRE0]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This example demonstrates key concepts of Clean Architecture using Python’s
    ABCs:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子展示了使用Python的ABCs实现清洁架构的关键概念：
- en: '**ABC**: The `Notifier` class is an ABC, defining an interface that all notifier
    classes must follow. This represents an inner ring in our Clean Architecture structure.'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**ABC**：`Notifier`类是一个ABC，定义了一个所有通知类都必须遵循的接口。这代表了我们清洁架构结构中的内环。'
- en: '**Abstract method**: The `send_notification` method in `Notifier` is marked
    with `@abstractmethod`, enforcing implementation in subclasses.'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**抽象方法**：`Notifier`中的`send_notification`方法用`@abstractmethod`标记，强制在子类中实现。'
- en: '**Concrete implementations**: `EmailNotifier` and `SMSNotifier` are concrete
    classes in an outer ring. They inherit from `Notifier` and provide specific implementations.'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**具体实现**：`EmailNotifier`和`SMSNotifier`是外环中的具体类。它们继承自`Notifier`并提供特定的实现。'
- en: '**Dependency inversion**: The `NotificationService` class depends on the abstract
    `Notifier` class, not on concrete implementations. This adheres to the Dependency
    Rule, as the abstract `Notifier` class (inner ring) doesn’t depend on the concrete
    notifiers (outer ring). We’ll dive deeper into dependency inversion in the next
    chapter.'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**依赖倒置**：`NotificationService`类依赖于抽象的`Notifier`类，而不是具体实现。这遵循了依赖规则，因为抽象的`Notifier`类（内环）不依赖于具体的通知类（外环）。我们将在下一章更深入地探讨依赖倒置。'
- en: 'This structure embodies the Clean Architecture principles we’ve discussed:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这种结构体现了我们讨论过的清洁架构原则：
- en: '**It respects the Dependency Rule**: The abstract `Notifier` class (inner ring)
    knows nothing about the concrete notifiers or the `NotificationService` class
    (outer rings)'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**它尊重依赖规则**：抽象的`Notifier`类（内环）对具体的通知类或`NotificationService`类（外环）一无所知'
- en: '**It allows for easy extension**: We can add new types of notifiers (such as
    `PushNotifier`) without changing the `NotificationService` class'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**它允许轻松扩展**：我们可以在不修改`NotificationService`类的情况下添加新的通知类型（例如`PushNotifier`）'
- en: '**It promotes flexibility and maintainability**: The core business logic (sending
    a notification) is separated from the implementation details (how the notification
    is sent)'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**它促进灵活性和可维护性**：核心业务逻辑（发送通知）与实现细节（如何发送通知）分离'
- en: By structuring our code this way, we create a system that’s not only flexible
    and maintainable but also adheres to the fundamental principles of Clean Architecture.
    The abstract `Notifier` class represents our core business rules, while the concrete
    notifiers and the `NotificationService` class represent the more volatile outer
    layers. This separation allows us to easily swap or add new notification methods
    without affecting the core logic of our application.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式组织我们的代码，我们创建了一个既灵活又易于维护的系统，同时遵循清洁架构的基本原则。抽象的`Notifier`类代表我们的核心业务规则，而具体的通知类和`NotificationService`类代表更易变的外层。这种分离使我们能够轻松地交换或添加新的通知方法，而不会影响我们应用程序的核心逻辑。
- en: So, we’ve seen a simple ABC example, but this is where Python truly shines.
    We can implement the same Clean Architecture principles without using a class
    hierarchy, instead relying on Python’s support for **duck typing** ([https://en.wikipedia.org/wiki/Duck_typing](https://en.wikipedia.org/wiki/Duck_typing)).
    This flexibility is one of Python’s strengths, allowing developers to choose the
    approach that best fits their project’s needs while still adhering to Clean Architecture
    principles.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经看到了一个简单的ABC示例，但这是Python真正发光的地方。我们可以不使用类层次结构来实现相同的清洁架构原则，而是依赖Python对**鸭子类型**（[https://en.wikipedia.org/wiki/Duck_typing](https://en.wikipedia.org/wiki/Duck_typing)）的支持。这种灵活性是Python的强大之处，允许开发者选择最适合他们项目需求的方法，同时仍然遵循清洁架构原则。
- en: Duck typing is a programming concept where the suitability of an object is determined
    by the presence of certain methods or properties, rather than its explicit type.
    The name comes from the saying, “If it walks like a duck and quacks like a duck,
    then it must be a duck.” In duck typing, we don’t care about the object’s type;
    we care about whether it can do what we need it to do.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: 'This approach aligns well with Clean Architecture’s emphasis on abstractions
    and interfaces. If you’d prefer to stay away from rigid class hierarchies, Python’s
    `Protocol` feature, introduced in Python 3.8 ([https://peps.python.org/pep-0544/](https://peps.python.org/pep-0544/)),
    offers the best of both worlds: duck typing with type hinting. Here’s an example
    that implements the same notification system using protocols:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This example demonstrates the same notification system as before but using
    Python’s `Protocol` feature instead of ABCs. Let’s break down the key differences
    and their implications for Clean Architecture:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '**Protocol versus ABC**: The `Notifier` class is now a `Protocol` class instead
    of an `ABC` class. It defines a structural subtyping interface rather than requiring
    explicit inheritance.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Implicit conformance**: The `EmailNotifier` and `SMSNotifier` classes don’t
    explicitly inherit from the `Notifier` class, but they conform to its interface
    by implementing the `send_notification` method.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Duck typing with type hinting**: This approach combines Python’s duck typing
    flexibility with the benefits of static type checking, aligning with Clean Architecture’s
    emphasis on loose coupling.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Concrete implementations**: The `NotificationService` class still depends
    on the abstract `Notifier` protocol, not concrete implementations, adhering to
    Clean Architecture principles.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This protocol-based approach offers a flexible, Pythonic implementation of Clean
    Architecture concepts, balancing type safety with reduced class hierarchy rigidity.
    It demonstrates how to align Clean Architecture principles with Python’s philosophy,
    promoting adaptable and maintainable code.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: 'We highly recommend the use of type hinting via either ABCs or protocols when
    implementing Clean Architecture. This approach, as opposed to simple implicit
    interfaces without type hinting, offers significant advantages:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: Improved code readability
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enhanced IDE support and earlier error detection
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Better alignment with Clean Architecture goals
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the remaining parts of the book, we’ll primarily use ABCs in our examples
    as they are in greater use in existing Python codebases. However, the principles
    discussed are equally applicable to protocol-based implementations, and readers
    can adapt the examples to use protocols if preferred.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: 'Practical example: a glimpse of Clean Architecture in a Python project'
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To illustrate the concepts we’ve discussed, let’s examine the basic structure
    of a Clean Architecture Python project. This structure embodies the principles
    we’ve covered and demonstrates how they translate into a practical file organization.
    We’ll stay at a high level here; later chapters will cover real-world examples
    in full detail:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明我们讨论的概念，让我们检查Clean Architecture Python项目的结构。这种结构体现了我们讨论过的原则，并展示了它们如何转化为实际的文件组织。在这里我们将保持高层次；后面的章节将详细介绍真实世界的例子：
- en: '![Figure 1.2: A potential layout for a Clean Architecture Python web application](img/B31577_01_2.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图1.2：Clean Architecture Python Web应用程序的潜在布局](img/B31577_01_2.png)'
- en: 'Figure 1.2: A potential layout for a Clean Architecture Python web application'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.2：Clean Architecture Python Web应用程序的潜在布局
- en: 'This file structure in *Figure 1.2* exemplifies the Clean Architecture principles
    we’ve discussed:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '*图1.2*中的这种文件结构展示了我们讨论过的Clean Architecture原则：'
- en: '**SoC**: Each directory represents a distinct layer of the application, aligning
    with the concentric circles we saw in *Figure 1.1*.'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**SoC**：每个目录代表应用程序的一个独立层，与我们在*图1.1*中看到的同心圆相一致。'
- en: '**Dependency Rule**: The structure enforces the Dependency Rule we discussed
    earlier. If we were to investigate the inner layers (`entities` and `use_cases`),
    we would not see any imports from the outer layers.'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**依赖规则**：该结构强制执行我们之前讨论过的依赖规则。如果我们调查内层（`entities`和`use_cases`），我们将不会看到来自外部层的任何导入。'
- en: '**Entities layer**: The `entities` directory contains the core business objects,
    such as `user.py`. These are at the center of our Clean Architecture diagram and
    have no dependencies on outer layers.'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**实体层**：`entities`目录包含核心业务对象，如`user.py`。这些是我们Clean Architecture图中的中心，对外层没有依赖。'
- en: '**Use Cases layer**: The `use_cases` directory holds the application-specific
    business rules. It depends on the entities but is independent of the outer layers.'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**用例层**：`use_cases`目录包含应用程序特定的业务规则。它依赖于实体，但独立于外部层。'
- en: '**Interface Adapters layer**: The `interfaces` directory contains controllers,
    presenters, and gateways. These adapt data between use cases and external agencies
    (such as web frameworks or databases).'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**接口适配层**：`interfaces` 目录包含控制器、演示者和网关。这些适配器在用例和外部机构（如Web框架或数据库）之间转换数据。'
- en: '**Frameworks layer**: The outermost `frameworks` directory contains implementations
    of external interfaces, such as database **object-relational mappers** (**ORMs**)
    or web frameworks.'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**框架层**：最外层的`frameworks`目录包含外部接口的实现，如数据库**对象关系映射器**（ORMs）或Web框架。'
- en: '**Straightforward testing**: The `tests` directory structure mirrors the application
    structure, allowing for comprehensive testing at all levels.'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**简单测试**：`tests`目录结构与应用程序结构相匹配，允许在所有级别进行全面的测试。'
- en: 'This structure supports the key benefits of Clean Architecture we discussed:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这种结构支持我们讨论过的Clean Architecture的关键好处：
- en: '**Maintainability**: Changes to external components (in the `frameworks` directory)
    don’t affect the core business logic in entities and use cases'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可维护性**：对`frameworks`目录中外部组件的更改不会影响实体和用例中的核心业务逻辑。'
- en: '**Flexibility**: We can easily swap out the database or web framework in the
    `frameworks` directory without touching the business logic'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**灵活性**：我们可以轻松地替换`frameworks`目录中的数据库或Web框架，而不需要触及业务逻辑。'
- en: '**Testability**: The clear separation allows for easy unit testing of core
    components and integration testing of interfaces'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可测试性**：清晰的分离允许轻松地对核心组件进行单元测试，并对接口进行集成测试。'
- en: Remember our discussion about abstractions? The `interfaces` directory is where
    we’d implement the ABCs or protocols we talked about. For instance, `user_repository.py`
    might define an abstract `UserRepository` class, which is then implemented concretely
    in the `frameworks/database/orm.py` file.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我们关于抽象的讨论吗？`interfaces`目录是我们实现我们讨论的ABCs或协议的地方。例如，`user_repository.py`可能定义一个抽象的`UserRepository`类，然后在`frameworks/database/orm.py`文件中具体实现。
- en: This structure also facilitates the *master plan* we mentioned earlier. It provides
    a clear roadmap for where new code should be placed, helping developers make consistent
    decisions even as the project grows and evolves.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这种结构也促进了我们之前提到的*总体规划*。它为新代码提供清晰的路线图，帮助开发者即使在项目增长和演变过程中也能做出一致的决策。
- en: By organizing our Python project this way, we’re setting ourselves up for long-term
    success, creating a codebase that’s not just functional but also maintainable,
    flexible, and aligned with Clean Architecture principles.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以这种方式组织我们的 Python 项目，我们正在为长期成功打下基础，创建一个不仅功能性强而且可维护、灵活且与 Clean Architecture
    原则一致的代码库。
- en: Python-specific considerations and potential pitfalls
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python 特定的考虑因素和潜在陷阱
- en: While Clean Architecture and Python are highly compatible, there are some important
    considerations to be aware of when implementing these principles in Python projects.
    Throughout this book, we’ll guide you through mitigating these concerns, providing
    practical solutions and best practices.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Clean Architecture 和 Python 非常兼容，但在 Python 项目中实施这些原则时，有一些重要的考虑因素需要注意。在本书中，我们将引导您缓解这些担忧，提供实用的解决方案和最佳实践。
- en: Balancing Pythonic code with architectural principles
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 平衡 Python 代码与架构原则
- en: Python’s *batteries included* philosophy and an extensive standard library can
    sometimes tempt developers to bypass architectural boundaries for the sake of
    convenience. However, maintaining a clean architecture often involves creating
    abstractions around even standard library functions to maintain SoC. For example,
    instead of directly using Python’s `smtplib` library in your use cases, consider
    creating an abstraction layer for sending notifications.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的 *batteries included* 哲学和广泛的标准库有时会诱使开发者为了方便而绕过架构边界。然而，保持干净的架构通常涉及在标准库函数周围创建抽象，以维护
    SoC。例如，在您的用例中，您可以考虑创建一个用于发送通知的抽象层，而不是直接使用 Python 的 `smtplib` 库。
- en: As we progress through this book, we’ll demonstrate how this effort of creating
    abstractions pays off in terms of maintainability, flexibility, and testability.
    You’ll see that the initial investment in Clean Architecture principles yields
    significant long-term benefits.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们通过本书的进展，我们将展示创建抽象的努力如何在可维护性、灵活性和可测试性方面带来回报。您将看到对 Clean Architecture 原则的初始投资带来了显著的长远利益。
- en: Python’s ease of importing can sometimes lead to messy dependency structures,
    as all packages are effectively public. We’ll show you how to be vigilant about
    maintaining the Dependency Rule, ensuring that inner layers don’t depend on outer
    layers. In [*Chapter 2*](Chapter_02.xhtml#_idTextAnchor040), we’ll explore techniques
    and tools to help you maintain clean dependency structures in your Python projects.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的导入便捷性有时会导致混乱的依赖结构，因为所有包实际上都是公开的。我们将向您展示如何保持对依赖规则的警觉，确保内层不依赖于外层。在 [*第
    2 章*](Chapter_02.xhtml#_idTextAnchor040) 中，我们将探讨技术和工具，以帮助您在 Python 项目中维护干净的依赖结构。
- en: Scaling Clean Architecture in Python projects
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 Python 项目中扩展 Clean Architecture
- en: The application of Clean Architecture principles should be tailored to the size
    and complexity of your Python project.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 应根据您 Python 项目的规模和复杂性来定制 Clean Architecture 原则的应用。
- en: 'For instance, in small projects or quick prototypes, it’s perfectly fine to
    have a simple, monolithic architecture. However, even in these cases, building
    in a thoughtful, modular manner can set the stage for future growth. You might
    start with a simple structure:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在小项目或快速原型中，拥有一个简单、单一架构是完全可行的。然而，即使在这些情况下，以深思熟虑、模块化的方式构建也可以为未来的增长奠定基础。您可能从以下简单结构开始：
- en: '![Figure 1.3: Quick prototype Python project](img/B31577_01_3.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.3：快速原型 Python 项目](img/B31577_01_3.png)'
- en: 'Figure 1.3: Quick prototype Python project'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.3：快速原型 Python 项目
- en: 'In this small project, you can still apply Clean Architecture principles by
    doing the following:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个小型项目中，您仍然可以通过以下方式应用 Clean Architecture 原则：
- en: Keeping business logic in `models.py` separate from presentation logic in `views.py`
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将业务逻辑（实体和用例）与 `views.py` 中的展示逻辑分开，放在 `models.py` 中
- en: Using **dependency injection** (**DI**) to make components more modular and
    testable
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 **依赖注入**（**DI**）使组件更模块化和可测试
- en: Defining clear interfaces between modules
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在模块之间定义清晰的接口
- en: 'As your project grows, you can gradually evolve toward a more comprehensive
    Clean Architecture structure. This evolution might involve the following:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 随着您的项目增长，您可以逐步向更全面的 Clean Architecture 结构发展。这种演变可能包括以下内容：
- en: Separating core business logic (entities and use cases) into their own modules
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将核心业务逻辑（实体和用例）分离到它们自己的模块中
- en: Introducing interfaces to abstract away framework-specific code
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 引入接口以抽象化框架特定的代码
- en: Organizing tests to align with the architectural layers
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将测试组织与架构层对齐
- en: This book takes a hands-on approach, starting with a basic application and a
    pragmatic application of Clean Architecture principles. As we progress, the complexity
    of our example application will increase, demonstrating how to evolve the Clean
    Architecture approach as the codebase grows.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 本书采用动手实践的方法，从基本应用程序和清洁架构原则的实用应用开始。随着我们的进展，示例应用程序的复杂性将增加，展示如何随着代码库的增长而演进清洁架构方法。
- en: Clean Architecture is a spectrum, not a binary choice. The patterns we’ll explore
    represent a comprehensive implementation designed to showcase Clean Architecture’s
    full capabilities, but in practice, you might choose to implement only the patterns
    that provide clear value for your specific context. A small API might benefit
    from clean controller patterns without needing full presenter abstractions, while
    a data processing script might adopt domain entities while skipping interface
    adapters entirely. You’ll learn how to apply these principles judiciously, avoiding
    over-engineering in smaller projects while leveraging the full power of Clean
    Architecture in larger systems. The key is understanding what each pattern provides
    so you can make informed decisions about which architectural boundaries matter
    most for your project.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 清洁架构是一个连续体，而不是一个二元选择。我们将探讨的模式代表了一个全面的实现，旨在展示清洁架构的全部功能，但在实践中，你可能会选择只实现那些为你特定环境提供明确价值的模式。一个小型API可能从清洁控制器模式中受益，而不需要完整的展示器抽象，而数据处理脚本可能采用领域实体，而完全跳过接口适配器。你将学会如何明智地应用这些原则，避免在小项目中过度设计，同时在大型系统中充分利用清洁架构的全部力量。关键是理解每个模式提供的内容，以便你可以就哪些架构边界对你的项目最重要做出明智的决定。
- en: Leveraging Python’s dynamic nature appropriately
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 适当利用Python的动态特性
- en: While Python’s dynamic nature is powerful, it can also lead to issues if not
    used carefully. [*Chapter 3*](Chapter_03.xhtml#_idTextAnchor060) is devoted to
    aspects of Python’s dynamic nature, including duck typing, the use of type hints,
    and newer features such as protocols. By the end of this chapter, you’ll have
    a solid foundation on how to best leverage these language features to support
    a Clean Architecture approach, balancing Python’s flexibility with architectural
    rigor.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Python的动态特性很强大，但如果使用不当也可能导致问题。[*第3章*](Chapter_03.xhtml#_idTextAnchor060)致力于Python动态特性的各个方面，包括鸭子类型、类型提示的使用以及像协议这样的新特性。到本章结束时，你将有一个坚实的基础，了解如何最好地利用这些语言特性来支持清洁架构方法，平衡Python的灵活性与架构的严谨性。
- en: Testing considerations
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试注意事项
- en: This book, as with Clean Architecture itself, strongly promotes the use of tests.
    Tests are essentially first-class clients of your application code, using the
    codebase and making assertions on the results. The same architectural considerations
    that apply to your main codebase also apply to your Python tests.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书，就像清洁架构本身一样，强烈推崇测试的使用。测试本质上是你应用程序代码的一等客户，使用代码库并对结果进行断言。适用于你的主要代码库的相同架构考虑因素也适用于你的Python测试。
- en: We’ll guide you through writing tests that respect architectural boundaries.
    You’ll learn to recognize when your tests are indicating potential issues in your
    architecture, such as when they require excessive setup or mocking. In the test
    cases for each chapter’s code examples and culminating in [*Chapter 8*](Chapter_08.xhtml#_idTextAnchor192),
    we’ll explore these concepts in depth, showing you how to use tests not just for
    verification, but as a tool for maintaining and improving your architecture.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将指导你编写尊重架构边界的测试。你将学会识别你的测试何时表明你的架构中存在潜在问题，例如当它们需要过多的设置或模拟时。在每个章节的代码示例的测试用例中，最终在第[*第8章*](Chapter_08.xhtml#_idTextAnchor192)中，我们将深入探讨这些概念，展示如何使用测试不仅用于验证，而且作为维护和改进你的架构的工具。
- en: By being aware of these considerations and potential pitfalls and following
    the guidance provided throughout this book, you can create Python systems that
    are both clean and practical, leveraging the strengths of both Clean Architecture
    and Python. Remember, the key is to apply these principles thoughtfully, always
    with an eye toward creating maintainable, testable, and flexible Python code.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 通过意识到这些考虑因素和潜在陷阱，并遵循本书中提供的指导，你可以创建既清洁又实用的Python系统，利用清洁架构和Python的优势。记住，关键是深思熟虑地应用这些原则，始终着眼于创建可维护、可测试和灵活的Python代码。
- en: Summary
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we introduced Clean Architecture at a high level and its relevance
    to Python development. We gave you context by exploring the evolution of software
    architecture, from Waterfall to Agile, highlighting persistent challenges in managing
    complexity, accommodating change, and maintaining long-term productivity.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们从高层次介绍了清晰架构及其与Python开发的关联。通过探讨软件架构的演变，从瀑布到敏捷，突出了在管理复杂性、适应变化和维护长期生产力方面存在的持续挑战。
- en: 'We introduced Clean Architecture’s core principles:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们介绍了清晰架构的核心原则：
- en: Separation of concerns (SoC)
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关注点分离（SoC）
- en: Independence of external details
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部细节的独立性
- en: Testability and maintainability
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可测试性和可维护性
- en: We examined Clean Architecture’s general structure, from core entities and use
    cases to outer layers of interface adapters, frameworks, and drivers, emphasizing
    how this structure promotes maintainability and flexibility. We discussed the
    benefits of Clean Architecture, including improved adaptability, enhanced testability,
    and long-term development agility, and how it complements modern development practices
    such as Agile and DevOps.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们考察了清晰架构的一般结构，从核心实体和用例到外层的接口适配器、框架和驱动器，强调了这种结构如何促进可维护性和灵活性。我们讨论了清晰架构的好处，包括提高适应性、增强可测试性和长期开发敏捷性，以及它是如何与现代开发实践如敏捷和DevOps相辅相成的。
- en: Furthermore, we explored the natural fit between Clean Architecture and Python,
    addressing how Python’s features can be leveraged to implement Clean Architecture
    effectively. We also highlighted Python-specific considerations and potential
    pitfalls, emphasizing the need to balance Pythonic code with architectural principles
    and adapt Clean Architecture to different project sizes.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们探讨了清晰架构与Python之间的自然契合度，讨论了如何利用Python的特性有效地实现清晰架构。我们还强调了Python特定的考虑因素和潜在陷阱，强调需要在Python代码的优雅性与架构原则之间取得平衡，并适应不同规模的项目。
- en: In this chapter, we introduced the primary goals of Clean Architecture and explored
    its natural fit with Python development. We saw how Clean Architecture principles
    can be implemented using Python’s features such as ABCs and protocols, providing
    a foundation for creating maintainable and flexible software systems.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了清晰架构的主要目标，并探讨了它与Python开发的自然契合度。我们看到了如何利用Python的特性，如ABCs和协议，来实现清晰架构原则，为创建可维护和灵活的软件系统奠定基础。
- en: In the next chapter, we’ll build upon this foundation by diving into the SOLID
    principles. These principles, which form the bedrock of Clean Architecture, will
    be explored in depth with practical Python examples, showing how they contribute
    to robust and extensible application design.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将在此基础上深入探讨SOLID原则。这些原则是清晰架构的基石，将通过实际的Python示例进行深入探讨，展示它们如何有助于构建健壮和可扩展的应用程序设计。
- en: Further reading
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'To learn more about the topics that were covered in this chapter, take a look
    at the following resources:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于本章涵盖的主题，请查看以下资源：
- en: '*Clean Architecture: A Craftsman’s Guide to Software Structure and Design*
    by Robert C. Martin. This book provides a comprehensive look at Clean Architecture
    from its originator.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《清晰架构：软件结构和设计的工匠指南》由罗伯特·C·马丁所著。这本书全面地审视了清晰架构的起源。
- en: '*Domain-Driven Design: Tackling Complexity in the Heart of Software* by Eric
    Evans. While not specific to Clean Architecture, this book provides valuable insights
    into designing software around business domains.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《领域驱动设计：软件核心的复杂性处理》由埃里克·埃文斯所著。虽然这本书并非专门针对清晰架构，但它提供了关于围绕业务领域设计软件的宝贵见解。
- en: '*Agile Software Development, Principles, Patterns, and Practices* by Robert
    C. Martin. This book covers many of the principles that underpin Clean Architecture
    in the context of Agile development.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《敏捷软件开发：原则、模式和实践》由罗伯特·C·马丁所著。这本书涵盖了在敏捷开发背景下支撑清晰架构的许多原则。
- en: '*The Pragmatic Programmer: Your Journey to Mastery* by Andrew Hunt and David
    Thomas. This classic book offers practical advice on software design and development
    that aligns well with Clean Architecture principles.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《程序员修炼之道：从小工到专家》由安德鲁·亨特和戴维·托马斯所著。这本经典书籍提供了与清晰架构原则相吻合的软件设计和开发实用建议。
