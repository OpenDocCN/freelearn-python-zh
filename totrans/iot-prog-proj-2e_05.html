<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer100">
<h1 class="chapter-number" id="_idParaDest-80"><a id="_idTextAnchor080"/>5</h1>
<h1 id="_idParaDest-81"><a id="_idTextAnchor081"/>Exploring the GPIO</h1>
<p>Throughout the first four chapters of the book, we have touched on the <strong class="bold">General-Purpose Input/Output</strong> (<strong class="bold">GPIO</strong>) port on the Raspberry Pi. In <a href="B21282_03.xhtml#_idTextAnchor048"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>, we used it extensively in the construction of our weather indicator. In this chapter, we will dive deeper into the functionality and applications of the GPIO port on the Raspberry Pi as we start to build our IoT home security application. We will also explore the GPIO port on the Raspbery Pi Pico, the microcontroller cousin of the <span class="No-Break">Raspberry Pi.</span></p>
<p>In the hands-on tutorial section, we will construct a basic alarm system using a PIR motion sensor to detect human presence. This system will integrate a pushbutton for activation control and a buzzer as an alert mechanism. Through this practical exercise, we will demonstrate how the Raspberry Pi can interface with various components to create functional <span class="No-Break">real-world applications.</span></p>
<p>In this chapter, we will cover <span class="No-Break">the following:</span></p>
<ul>
<li>Introducing the GPIO on the Raspberry Pi and Raspberry <span class="No-Break">Pi Pico</span></li>
<li>Understanding sensors, actuators, <span class="No-Break">and indicators</span></li>
<li>Building a simple <span class="No-Break">alarm system</span></li>
</ul>
<p><span class="No-Break">Let’s begin!</span></p>
<h1 id="_idParaDest-82"><a id="_idTextAnchor082"/>Technical requirements</h1>
<p>The following are the requirements for completing <span class="No-Break">this chapter:</span></p>
<ul>
<li>Intermediate knowledge of <span class="No-Break">Python programming</span></li>
<li>A late model Raspberry Pi, preferably a Raspberry Pi 5 with at least 4 GB <span class="No-Break">of RAM</span></li>
<li>A <span class="No-Break">PIR sensor</span></li>
<li>An <span class="No-Break">SFM-27 buzzer</span></li>
<li>A pushbutton such as an <span class="No-Break">arcade-style button</span></li>
</ul>
<p>The code for this chapter may be <span class="No-Break">found here:</span></p>
<p><a href="https://github.com/PacktPublishing/-Internet-of-Things-Programming-Projects-2nd-Edition/tree/main/Chapter5%0D"><span class="No-Break">https://github.com/PacktPublishing/-Internet-of-Things-Programming-Projects-2nd-Edition/tree/main/Chapter5</span></a></p>
<h1 id="_idParaDest-83"><a id="_idTextAnchor083"/>Introducing the GPIO on Raspberry Pi</h1>
<p>The GPIO port is a versatile set of 40 pins on the Raspberry Pi and Pico, enabling interaction with the external world. These pins can be configured as input or output and can connect to sensors, LEDs, and <a id="_idIndexMarker414"/>more. Included are ports to provide power, several ground<a id="_idIndexMarker415"/> connections, and GPIOs designated for specific protocols such as I2C, UART, SPI, and PCM. In the following table, we can see how we may match up pins with specific <span class="No-Break">communication protocols:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer090">
<img alt="Figure 5.1 – GPIO pins and communication protocols" height="193" src="image/B21282_05_1.jpg" width="740"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.1 – GPIO pins and communication protocols</p>
<h2 id="_idParaDest-84"><a id="_idTextAnchor084"/>Exploring the Raspberry Pi GPIO pinout diagram</h2>
<p>In <span class="No-Break"><em class="italic">Figure 5</em></span><em class="italic">.2</em>, we can see a pinout diagram of the GPIO ports on the Raspberry Pi and Raspberry Pi Pico. Outlined are<a id="_idIndexMarker416"/> the GPIO pin numbers as well as the pins that may be configured for <span class="No-Break">special operations.</span></p>
<p class="callout-heading">Important note</p>
<p class="callout">Common to many purchases of a Raspberry Pi and Raspberry Pi Pico is a reference sheet with the GPIO pinout diagram. This tool is extremely helpful for development, as it acts as a guide to the GPIO (Raspberry Pi) and GP (Pico) pin numbers required for device connections to the Pi and <span class="No-Break">Pico, respectively.</span></p>
<p>We may find various versions of these diagrams on the internet. For those of us interested, there is an interactive version of the Raspberry Pi GPIO pinout <span class="No-Break">at </span><a href="https://pinout.xyz"><span class="No-Break">https://pinout.xyz</span></a><span class="No-Break">.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer091">
<img alt="Figure 5.2 – GPIO pinout diagram" height="938" src="image/B21282_05_2.jpg" width="1329"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.2 – GPIO pinout diagram</p>
<p>The Raspberry Pi’s GPIO port includes pins GPIO 0 (EEPROM SDA) and GPIO 1 (EEPROM SCL), which enable <a id="_idIndexMarker417"/>automatic communication with attached HATs. Additionally, there are pins designated for various <span class="No-Break">communication protocols.</span></p>
<p>To better understand the communication capabilities of the Raspberry Pi and Pico, let’s examine the specific communication protocols that we may configure our devices to <span class="No-Break">work with.</span></p>
<h2 id="_idParaDest-85"><a id="_idTextAnchor085"/>Understanding GPIO pin communication protocols</h2>
<p>The Raspberry Pi’s and Pico’s GPIO pins enable several key communication protocols such as I2C, SPI, UART, and PCM. These<a id="_idIndexMarker418"/> allow the Raspberry Pi and Pico to interact with various devices and sensors. Each protocol has its unique applications, from interfacing with sensors to digital audio transmission. In the following sections, we’ll provide an overview of these communication methods that may <span class="No-Break">be configured.</span></p>
<h3>I2C</h3>
<p>I2C is a serial communication<a id="_idIndexMarker419"/> protocol developed by Philips Semiconductor, now NXP Semiconductors. I2C allows multiple devices to communicate with each<a id="_idIndexMarker420"/> other using a <span class="No-Break">two-wire interface.</span></p>
<p>Here’s a breakdown of <span class="No-Break">the connections:</span></p>
<ul>
<li><strong class="bold">Serial Data Line</strong> (<strong class="bold">SDA</strong>): This is the<a id="_idIndexMarker421"/> <span class="No-Break">data line.</span></li>
<li><strong class="bold">Serial Clock Line</strong> (<strong class="bold">SLC</strong>): This is the <a id="_idIndexMarker422"/>clock line that synchronizes data transfer over the <span class="No-Break">I2C bus.</span></li>
</ul>
<p>The key features of the I2C protocol include <span class="No-Break">the following:</span></p>
<ul>
<li><strong class="bold">Multi-master and multi-slave</strong><span class="Annotation-reference">: </span>Multiple<a id="_idIndexMarker423"/> devices can be connected to the bus, with the capability for more than <span class="No-Break">one master.</span></li>
<li><strong class="bold">Address-based communication</strong>: Each device on the bus has a unique address, allowing <span class="No-Break">targeted communication.</span></li>
<li><strong class="bold">Simple hardware connection</strong>: Only two pull-up resistors are required for the SDA and SCL lines when setting up an <span class="No-Break">I2C connection.</span></li>
<li><strong class="bold">Speed variants</strong>: I2C supports different speed modes, including standard (up to 100 Kbps), fast (up to 400 Kbps), high speed (up to 3.4 Mbps), <span class="No-Break">and more.</span></li>
</ul>
<p>On the Raspberry Pi and Pico, the I2C protocol is particularly valuable for connecting peripherals such as PIR sensors, mini-OLED screens, and <a id="_idIndexMarker424"/>other components using just <span class="No-Break">two wires.</span></p>
<h3>SPI</h3>
<p>The <strong class="bold">Serial Peripheral Interface</strong> (<strong class="bold">SPI</strong>) is a synchronous<a id="_idIndexMarker425"/> serial communication protocol used for short-distance communication, primarily<a id="_idIndexMarker426"/> in embedded systems, to connect microcontrollers and peripheral devices such as sensors, SD cards, <span class="No-Break">and</span><span class="No-Break"><a id="_idIndexMarker427"/></span><span class="No-Break"> LCDs.</span></p>
<p>Here’s a breakdown of <span class="No-Break">the connections:</span></p>
<ul>
<li><strong class="bold">SDO—Serial Data Out</strong>: This line is used<a id="_idIndexMarker428"/> for sending data from the controller to <span class="No-Break">the peripherals.</span></li>
<li><strong class="bold">SDI—Serial Data In</strong>: This line allows<a id="_idIndexMarker429"/> peripherals to send data back to <span class="No-Break">the controller.</span></li>
<li><strong class="bold">SCLK—Serial Clock</strong>: Like the SCL line in I2C, this provides the clock signal, synchronizing data transfer <span class="No-Break">between devices.</span></li>
<li><strong class="bold">CS0—Chip Select 0</strong>: This line is crucial for selecting specific devices when there are multiple peripherals. By toggling CS0, the controller can determine which device it’s <span class="No-Break">communicating with.</span></li>
<li><strong class="bold">CS1—Chip Select 1</strong>: Like CS0, CS1 provides an additional selection line, enabling the addressing of more devices on a single <span class="No-Break">SPI bus.</span></li>
</ul>
<p>The following are the features and advantages <span class="No-Break">of SPI:</span></p>
<ul>
<li><strong class="bold">Full-duplex communication</strong>: SPI supports simultaneous bidirectional communication, allowing data to be sent <a id="_idIndexMarker430"/>and received at the same time. This means that during an SPI communication, data can flow from the master to the slave and from the slave to the master concurrently. This is unlike I2C, which operates in a half-duplex mode (can either send or receive data at any given moment, but not at the <span class="No-Break">same time).</span></li>
<li><strong class="bold">Speed</strong>: SPI often outpaces I2C in terms of data transfer rates, making it suitable for applications that demand <span class="No-Break">higher-speed communications.</span></li>
<li><strong class="bold">Direct hardware control</strong>: Without a specific addressing scheme as in I2C, SPI offers more straightforward device<a id="_idIndexMarker431"/> control via the <span class="No-Break">CE pins.</span></li>
</ul>
<p>SPI communication is useful when <a id="_idIndexMarker432"/>connecting components such as SD cards, displays, <strong class="bold">ADCs</strong> (short for <strong class="bold">analog-to-digital converters</strong>), and more. An <a id="_idIndexMarker433"/>example is an application where we connect an SD card via SPI for <span class="No-Break">data logging.</span></p>
<h3>UART</h3>
<p>UART, which stands for <strong class="bold">Universal Asynchronous Receiver–Transmitter</strong>, is a prevalent communication<a id="_idIndexMarker434"/> protocol in the electronics domain, especially known for its simplicity and effectiveness in point-to-point communications between devices. UART stands out with its full-duplex communication capability. This allows two <a id="_idIndexMarker435"/>devices to exchange <span class="No-Break">data concurrently.</span></p>
<p>Here’s a breakdown of <span class="No-Break">the connections:</span></p>
<ul>
<li><strong class="bold">TX—Transmit</strong>: This connection is used to send data out to <span class="No-Break">another device.</span></li>
<li><strong class="bold">RX—Receive</strong>: Conversely, this connection is used to receive data from <span class="No-Break">another device.</span></li>
</ul>
<p>These connections allow for simultaneous bidirectional communication; while the Raspberry Pi and Pico transmit data via their TX pins, they can also receive data through their <span class="No-Break">RX pins.</span></p>
<p>Some features of UART compared to other<a id="_idIndexMarker436"/> communication methods such as I2C and <span class="No-Break">SPI include:</span></p>
<ul>
<li><strong class="bold">Peer-to-peer communication</strong>: Unlike I2C and SPI, which have defined master-slave relationships, UART devices communicate as equals, with no designated master <span class="No-Break">or slave.</span></li>
<li><strong class="bold">Asynchronous mechanism</strong>: Unlike SPI, UART communication doesn’t rely on a shared clock signal. Instead, both<a id="_idIndexMarker437"/> devices must agree on a baud rate before <span class="No-Break">initiating communication.</span></li>
</ul>
<p>Given its simplicity, UART is commonly used for serial console access and interfacing with peripherals that demand a straightforward communication path. One common use of UART and the Raspberry <a id="_idIndexMarker438"/>PI is the connection of flight controllers <span class="No-Break">for drones.</span></p>
<h3>PCM</h3>
<p>We can set GPIO pins 12, 35, 38, and 40 on the Raspberry Pi for <strong class="bold">PCM</strong> (<strong class="bold">Pulse-Code Modulation</strong>), which digitally<a id="_idIndexMarker439"/> represents analog signals by <a id="_idIndexMarker440"/>sampling their magnitude at regular intervals and quantizing it into a digital code. These pins are specifically designated for PCM communication on <span class="No-Break">the device:</span></p>
<ul>
<li><strong class="bold">GPIO 12</strong> (<strong class="bold">PCM_CLK</strong>): This is the clock pin, ensuring synchronization during <span class="No-Break">data transfer.</span></li>
<li><strong class="bold">GPIO 35</strong> (<strong class="bold">PCM_FS</strong>): This is frame sync. It helps in defining the start and end of the <span class="No-Break">data frame.</span></li>
<li><strong class="bold">GPIO 38</strong> (<strong class="bold">PCM_DIN</strong>): This is the data input. This is where the Raspberry Pi receives PCM data from <span class="No-Break">external devices.</span></li>
<li><strong class="bold">GPIO 40</strong> (<strong class="bold">PCM_DOUT</strong>): This is the data output. The Raspberry Pi uses this pin to send PCM data to <span class="No-Break">other devices.</span></li>
</ul>
<p>Some notable aspects<a id="_idIndexMarker441"/> of PCM include <span class="No-Break">the following:</span></p>
<ul>
<li><strong class="bold">Digital representation</strong>: PCM converts analog signals into a digital format, making it ideal for preserving the nuance of the original signal in a format that’s resistant to noise <span class="No-Break">and interference.</span></li>
<li><strong class="bold">Common in audio</strong>: Many audio formats, such as WAV, use PCM to represent sound digitally, ensuring <span class="No-Break">high fidelity.</span></li>
<li><strong class="bold">Flexibility</strong>: PCM can be used for a range of applications beyond audio, including telecommunications and <span class="No-Break">data storage.</span></li>
</ul>
<p>On the Raspberry Pi, PCM’s<a id="_idIndexMarker442"/> utility is evident in various tasks, from digital audio playback and recording to interfacing with devices that require precise analog-to-digital representations. A notable application of PCM with the Raspberry Pi is in the field of digital audio systems and <span class="No-Break">sound interfaces.</span></p>
<p>The following is a table<a id="_idIndexMarker443"/> summarizing the communication protocols and the Raspberry Pi and Raspberry <span class="No-Break">Pi Pico:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer092">
<img alt="Figure 5.3 – Communication protocols summarized" height="577" src="image/B21282_05_3.jpg" width="890"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.3 – Communication protocols summarized</p>
<p>Now that we understand the communication protocols we may use with the Raspberry Pi and Raspberry Pi Pico, let’s look at sensors, actuators, and indicators and how we may hook them up to our Raspberry Pi and Raspberry Pi Pico. This is the main purpose of the <span class="No-Break">GPIO port.</span></p>
<h1 id="_idParaDest-86"><a id="_idTextAnchor086"/>Understanding sensors, actuators, and indicators</h1>
<p>The GPIO functionality of the <a id="_idIndexMarker444"/>Raspberry Pi and Pico offers a foundation for connecting various sensors and driving indicators like LEDs and controlling actuators like servo motors. By integrating these devices, our devices can both collect data and execute responsive actions based on <span class="No-Break">this information.</span></p>
<p>For instance, a PIR sensor (<em class="italic">A</em> in <span class="No-Break"><em class="italic">Figure 5</em></span><em class="italic">.4</em>) can detect <a id="_idIndexMarker445"/>motion in a room, prompting an LED or triggering an alarm. Using temperature and <a id="_idIndexMarker446"/>humidity sensors, such as DHT11 (<em class="italic">B</em> in <span class="No-Break"><em class="italic">Figure 5</em></span><em class="italic">.4</em>), we can assess environmental conditions and, in response, engage a fan or a <span class="No-Break">heating element.</span></p>
<p>With distance sensors (<em class="italic">C</em> in <span class="No-Break"><em class="italic">Figure 5</em></span><em class="italic">.4</em>), we can measure the closeness of objects and instruct a servo motor to halt a robot, <span class="No-Break">preventing collisions:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer093">
<img alt="Figure 5.4 – Sensors for the Raspberry Pi" height="423" src="image/B21282_05_4.jpg" width="1023"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.4 – Sensors for the Raspberry Pi</p>
<p>Numerous devices can be integrated with our Raspberry Pi and Pico. Robotics alone offers line tracking sensors for directing robots <a id="_idIndexMarker447"/>along set paths and <strong class="bold">Time of Flight</strong> (<strong class="bold">TOF</strong>) sensors, which are compact and precise distance sensors. Beyond robotics, there are sensors for soil moisture, rain detection, light, and temperature/humidity, creating the potential for a <span class="No-Break">self-regulating greenhouse.</span></p>
<p>In the next section, we’ll explore connecting and reading data from a PIR sensor (<em class="italic">A</em> in <span class="No-Break"><em class="italic">Figure 5</em></span><em class="italic">.4</em>) and a Raspberry Pi using Python and the GPIO Zero library. Taking what we learn, we will use our knowledge to create a basic alarm system with our <span class="No-Break">Raspberry Pi.</span></p>
<p>We will start by setting up our development environment before we write code to interact with the <span class="No-Break">PIR sensor.</span></p>
<h2 id="_idParaDest-87"><a id="_idTextAnchor087"/>Setting up our development environment</h2>
<p>We will use a Python virtual environment for our development. As there are libraries that only work with the root <a id="_idIndexMarker448"/>installation of Python, we will use system packages in our Python virtual environment. To do so, we do <span class="No-Break">the following:</span></p>
<ol>
<li>On our Raspberry Pi 5, we open <span class="No-Break">a Terminal.</span></li>
<li>To store our project files, we create a new directory with <span class="No-Break">the following:</span><pre class="source-code">
<strong class="bold">mkdir chapter5</strong></pre></li> <li>We then navigate to the new directory with <span class="No-Break">the following:</span><pre class="source-code">
<strong class="bold">cd chapter5</strong></pre></li> <li>We create a new Python virtual environment for our project with <span class="No-Break">the following:</span><pre class="source-code">
<strong class="bold">python -m venv ch5-env --system-site-packages</strong></pre></li> <li>With this command, we create a new Python virtual environment called <strong class="source-inline">ch5-env</strong> and enable access to the system site packages. This allows the virtual environment to inherit packages from the global Python environment, which can be useful when certain libraries are installed system wide. Once the environment is set up, we can activate it and begin installing project-specific packages without affecting the global <span class="No-Break">Python environment.</span></li>
<li>With our new Python virtual environment created, we source into it with the <span class="No-Break">following command:</span><pre class="source-code">
<strong class="bold">source ch5-env/bin/activate</strong></pre></li> <li>Our Terminal should now show that we are using the <strong class="source-inline">ch5-env</strong> Python <span class="No-Break">virtual environment:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer094">
<img alt="Figure 5.5 – Terminal using dashboard-env environment" height="195" src="image/B21282_05_5.jpg" width="866"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.5 – Terminal using dashboard-env environment</p>
<ol>
<li value="8">We close the Terminal with the <span class="No-Break">following command:</span><pre class="source-code">
<strong class="bold">exit</strong></pre></li> <li>We are now ready to load up Thonny. We do so by clicking on the <strong class="bold">Menu</strong> icon in the Raspberry Pi taskbar, navigating<a id="_idIndexMarker449"/> to the <strong class="bold">Programming</strong> category, and <span class="No-Break">selecting </span><span class="No-Break"><strong class="bold">Thonny</strong></span><span class="No-Break">.</span></li>
<li>By default, Thonny uses the Raspberry Pi’s built-in version of Python. For our project, we will use the Python virtual environment we just created. To start we need to view the project files by clicking on <strong class="bold">View</strong> and selecting <strong class="bold">Files</strong> if it is not <span class="No-Break">already selected.</span></li>
<li>In the <strong class="source-inline">Files</strong> section, we locate the <span class="No-Break"><strong class="source-inline">ch5-env</strong></span><span class="No-Break"> directory.</span></li>
<li>We then right-click on the folder and select the option <strong class="bold">Activate virtual </strong><span class="No-Break"><strong class="bold">environment</strong></span><span class="No-Break"> :</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer095">
<img alt="Figure 5.6 – Activating a Python virtual environment in Thonny" height="566" src="image/B21282_05_6.jpg" width="295"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.6 – Activating a Python virtual environment in Thonny</p>
<p>With our project folder created <a id="_idIndexMarker450"/>and our Python virtual environment set up and activated, we may now start writing code to access sensors connected to the GPIO port. We will start by exploring PIR sensors a <span class="No-Break">little more.</span></p>
<h2 id="_idParaDest-88"><a id="_idTextAnchor088"/>Exploring the PIR sensor</h2>
<p><strong class="bold">Passive infrared</strong> (<strong class="bold">PIR</strong>) sensors are devices specialized in detecting infrared radiation, typically emitted by living beings due to<a id="_idIndexMarker451"/> their body heat. These sensors work by monitoring changes in infrared levels, which occur when an infrared source, such as a human, moves across its field of view. PIR sensors can be recognized by their distinctive sphere shell that dominates the sensor (<em class="italic">A</em> in <span class="No-Break"><em class="italic">Figure 5</em></span><span class="No-Break"><em class="italic">.4</em></span><span class="No-Break">).</span></p>
<p>Connecting a PIR sensor to a Raspberry Pi is straightforward. Three pins <span class="No-Break">are needed:</span></p>
<ul>
<li>VCC is connected to 5V from the <span class="No-Break">Raspberry Pi.</span></li>
<li>GND is connected to a <span class="No-Break">GND pin.</span></li>
<li>Signal is connected to <span class="No-Break">GPIO 23.</span></li>
</ul>
<p>In <span class="No-Break"><em class="italic">Figure 5</em></span><em class="italic">.7</em>, we see a PIR sensor connected to a Raspberry Pi using <span class="No-Break">a breadboard:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer096">
<img alt="Figure 5.7 – Connecting a PIR sensor to a Raspberry Pi" height="828" src="image/B21282_05_7.jpg" width="1211"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.7 – Connecting a PIR sensor to a Raspberry Pi</p>
<p>To acquire sensory data from<a id="_idIndexMarker452"/> our PIR sensor, we use the GPIO Zero library. To do so, we do <span class="No-Break">the following:</span></p>
<ol>
<li>In Thonny, we create a new tab by selecting <strong class="bold">File</strong> and then <strong class="bold">New</strong> or by hitting <em class="italic">Ctrl</em> + <em class="italic">N</em> on <span class="No-Break">the keyboard.</span></li>
<li>Inside the tab, we enter the <span class="No-Break">following code:</span><pre class="source-code">
from gpiozero import MotionSensor
from time import sleep
pir = MotionSensor(23)
while True:
    if pir.motion_detected:
        print("Motion detected!!")
    else:
        print("Waiting……")
    sleep(5)</pre></li> <li>We save the code <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">pir-test.py</strong></span><span class="No-Break">.</span></li>
<li>To run the code in Thonny, we click <a id="_idIndexMarker453"/>on the green run button and hit <em class="italic">F5</em> on the keyboard or click on the <strong class="bold">Run</strong> menu option at the top and then <strong class="bold">Run </strong><span class="No-Break"><strong class="bold">current script</strong></span><span class="No-Break">.</span></li>
<li>We should see the message <strong class="source-inline">"Motion detected!!"</strong> when we move our hand near the <span class="No-Break">PIR sensor:</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer097">
<img alt="Figure 5.8 – Results from testing a PIR sensor" height="444" src="image/B21282_05_8.jpg" width="879"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.8 – Results from testing a PIR sensor</p>
<p>With the PIR sensor tested, we<a id="_idIndexMarker454"/> are now ready to build a basic alarm system using the <span class="No-Break">Raspberry Pi.</span></p>
<h1 id="_idParaDest-89"><a id="_idTextAnchor089"/>Building a simple alarm system</h1>
<p>The Raspberry Pi’s GPIO pins can be configured for<a id="_idIndexMarker455"/> specific communication protocols such as I2C or set as standard input/output pins to gauge conditions <span class="No-Break">or levels.</span></p>
<p>In this final section of the chapter, we will use our knowledge to build a simple alarm system. Our alarm system will consist of a pushbutton, a PIR sensor, and a buzzer. All components are connected to the GPIO port (<span class="No-Break"><em class="italic">Figure 5</em></span><span class="No-Break"><em class="italic">.9</em></span><span class="No-Break">).</span></p>
<div>
<div class="IMG---Figure" id="_idContainer098">
<img alt="Figure 5.9 – Buzzer, pushbutton, and PIR sensor connected to the GPIO port through extension ribbon" height="483" src="image/B21282_05_9.jpg" width="737"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.9 – Buzzer, pushbutton, and PIR sensor connected to the GPIO port through extension ribbon</p>
<p>In <span class="No-Break"><em class="italic">Figure 5</em></span><em class="italic">.9</em>, we are using a GPIO <a id="_idIndexMarker456"/>extension ribbon to connect the GPIO port to a breadboard so that we can easily prototype and reconfigure connections. The ribbon simplifies the process and keeps the wiring organized. Using the GPIO extension cable is entirely optional. Just as we did in <a href="B21282_04.xhtml#_idTextAnchor068"><span class="No-Break"><em class="italic">Chapter 4</em></span></a>, our Raspberry Pi is installed with the Raspberry Pi seven-inch touchscreen with the <span class="No-Break">associated case.</span></p>
<p>We connect the components to the GPIO port using the <span class="No-Break">following diagram:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer099">
<img alt="Figure 5.10 – Basic alarm circuit" height="476" src="image/B21282_05_10.jpg" width="1170"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.10 – Basic alarm circuit</p>
<p>We write the code for our alarm system <span class="No-Break">in Thonny:</span></p>
<ol>
<li>Inside Thonny, we create<a id="_idIndexMarker457"/> a new tab by selecting <strong class="bold">File</strong> and then <strong class="bold">New</strong> or by hitting <em class="italic">Ctrl</em> + <em class="italic">N</em> on <span class="No-Break">the keyboard.</span></li>
<li>Inside the tab, we enter the <span class="No-Break">following code:</span><pre class="source-code">
from gpiozero import MotionSensor, Button, Buzzer
from time import sleep
pir = MotionSensor(23)
button = Button(20)
buzzer = Buzzer(21)
active = False
def toggle_alarm():
    global active
    if active:
        active = False
        buzzer.off()
        print("Alarm deactivated!")
    else:
        active = True
        print("Alarm activated!")
def monitor():
    while True:
        if active:
            pir.wait_for_motion()
            print("Motion detected!")
            sleep(5)
            if active:
                buzzer.on()
                print("Alarm triggered!")
        else:
            buzzer.off()
button.when_pressed = toggle_alarm
try:
    monitor()
except KeyboardInterrupt:
    print("Exiting...")
    buzzer.off()</pre><p class="list-inset">Before executing our <a id="_idIndexMarker458"/>code, let’s go <span class="No-Break">through it.</span></p><ul><li>We start by importing <span class="No-Break">our libraries:</span><ul><li><strong class="source-inline">gpiozero</strong> for Raspberry Pi <span class="No-Break">GPIO operations</span></li><li><strong class="source-inline">time</strong> for creating <span class="No-Break">sleep intervals</span></li></ul></li><li>We then define our <span class="No-Break">GPIO connections:</span><ul><li>PIR sensor connected to GPIO <span class="No-Break">pin 23</span></li><li>Button connected to GPIO <span class="No-Break">pin 20</span></li><li>Buzzer connected to GPIO <span class="No-Break">pin 21</span></li><li><strong class="source-inline">active</strong>: The variable to keep track of alarm <span class="No-Break">state (on/off)</span></li></ul></li><li>We define our <span class="No-Break"><strong class="source-inline">toggle_alarm()</strong></span><span class="No-Break"> function:</span><ul><li>Switches the alarm state between active <span class="No-Break">and inactive</span></li><li>If the alarm is deactivated while it’s sounding, the buzzer is <span class="No-Break">turned off</span></li></ul></li><li>Our <strong class="source-inline">monitor()</strong> function is <span class="No-Break">defined next:</span><ul><li>Continuously checks for motion if the alarm system <span class="No-Break">is active</span></li><li>If motion is detected, the program waits for five seconds to allow for <span class="No-Break">alarm deactivation</span></li><li>If the alarm is still active after the five-second delay, the <span class="No-Break">buzzer sounds</span></li></ul></li><li>We then set the <strong class="source-inline">button.when_pressed</strong> <strong class="source-inline">gpiozero</strong> property to bind it to the <strong class="source-inline">toggle_alarm()</strong> function. This allows us to assign a function to be executed immediately when a button is pressed. This event-driven approach eliminates the need for <span class="No-Break">continuous polling.</span></li><li>Our main execution block runs the <span class="No-Break"><strong class="source-inline">monitor()</strong></span><span class="No-Break"> function.</span></li><li>The <strong class="source-inline">try / catch</strong> allows for a clean exit with a keyboard interrupt (<em class="italic">Ctrl</em> +<em class="italic"> C</em>), ensuring the buzzer is turned off <span class="No-Break">upon exit.</span></li></ul></li> <li>We save the program <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">basic-alarm.py</strong></span><span class="No-Break">.</span></li>
<li>To run the code in Thonny, we click on the green run button, hit <em class="italic">F5</em> on the keyboard, or click on the <strong class="bold">Run</strong> menu option at the top, and then <strong class="bold">Run </strong><span class="No-Break"><strong class="bold">current script</strong></span><span class="No-Break">.</span></li>
<li>We activate the alarm by <a id="_idIndexMarker459"/>pressing on a pushbutton. Our alarm’s single sensor is a PIR sensor, which <span class="No-Break">monitors motion.</span></li>
<li>Once motion is detected, there is a five-second delay before the buzzer is activated. This allows time for the person who is aware of the alarm to turn it off before the buzzer <span class="No-Break">goes off.</span></li>
<li>To turn off the alarm, we simply push the <span class="No-Break">button again.</span></li>
</ol>
<p>In upcoming chapters, we’ll transform our basic alarm system into an IoT-enabled alarm using a Raspberry Pi Pico W. This will allow us to monitor sensor data from any location worldwide, offering the convenience and versatility of managing our alarm system as though we were right beside the <span class="No-Break">installed sensors.</span></p>
<h1 id="_idParaDest-90"><a id="_idTextAnchor090"/>Summary</h1>
<p>In <a href="B21282_05.xhtml#_idTextAnchor080"><span class="No-Break"><em class="italic">Chapter 5</em></span></a>, we explored the Raspberry Pi’s GPIO pins and their communication capabilities, including protocols such as I2C, SPI, UART, and PCM. We highlighted the significance of the GPIO pinout diagram when working with the Raspberry Pi and Raspberry <span class="No-Break">Pi Pico.</span></p>
<p>We focused on the PIR sensor for motion detection and connected it to our Raspberry Pi. We then used this knowledge to build a basic alarm system using the PIR sensor, a pushbutton, and a buzzer. Even though we didn’t engage in a hands-on exercise with the Pico, the principles, and techniques we learned apply to both the Raspberry Pi and Raspberry <span class="No-Break">Pi Pico.</span></p>
<p>This chapter commenced the construction of our IoT home security system. In the upcoming chapters, we will add to our basic alarm as we turn it into an impressive IoT home security system by creating an IoT alarm module and an IoT button to <span class="No-Break">arm it.</span></p>
</div>
</div></body></html>