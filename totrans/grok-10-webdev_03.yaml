- en: Chapter 3. Views
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。视图
- en: In the previous chapter we created our first Grok project and learned how to
    start a simple hello world application. Now we are going to learn about views
    and templates, which comprise the presentation layer of our web applications.
    To do this, we will create a simple application to manage to-do lists. The objective
    is to produce, by the end of this chapter, a working application that allows the
    user to create and manage any number of lists, add items to them, and mark them
    off as completed.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们创建了我们的第一个Grok项目，并学习了如何启动一个简单的hello world应用程序。现在我们将学习关于视图和模板的内容，它们构成了我们Web应用程序的表现层。为此，我们将创建一个简单的应用程序来管理待办事项列表。目标是到本章结束时，创建一个可以允许用户创建和管理任意数量列表、向其添加条目并标记为完成的应用程序。
- en: 'In order to reach our objective, we''ll go through the following topics in
    this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 为了达到我们的目标，我们将在本章中探讨以下主题：
- en: What are views and where in the Grok application code should they be defined
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视图是什么以及在哪里定义Grok应用程序代码中的视图
- en: How to use the ZPT templating engine, and examples of the most common statements
    in action
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用ZPT模板引擎，以及最常见的语句在行动中的示例
- en: How to write a full Grok application using only views
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何仅使用视图编写完整的Grok应用程序
- en: How to get form parameters from a web request
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何从Web请求中获取表单参数
- en: How to add static resources to a Grok application
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何向Grok应用程序添加静态资源
- en: How to create and work with additional views
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建和使用额外的视图
- en: How to use views that do not require an associated template
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用不需要关联模板的视图
- en: Grok views
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Grok视图
- en: A **web application** is just a series of web pages that help the user to carry
    out one or more tasks by allowing him to enter some data, working with it in various
    ways, and presenting some result or confirmation back to him. In a web application
    framework, the web pages that allow the user to see what is going on and the web
    forms that permit him to capture information are known as **views.**
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**Web应用程序**只是一系列网页，通过允许用户输入一些数据、以各种方式处理这些数据并向用户展示一些结果或确认，帮助用户完成一个或多个任务。在Web应用程序框架中，允许用户查看正在发生的事情的网页和允许他捕获信息的Web表单被称为**视图**。'
- en: A view is typically implemented by using some sort of page templates, but in
    Grok we can also have separate Python code to handle more complex logic more easily.
    In fact, we could even have the view rendered using only Python code without templates.
    This gives the developer more power (the full power of Python, indeed) and allows
    a clean separation of view presentation and view logic, resulting in a more readable
    code both in the template and the Python sides.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 视图通常通过使用某种页面模板来实现，但在Grok中，我们也可以有独立的Python代码来处理更复杂的逻辑，使其更容易。实际上，我们甚至可以使用仅使用Python代码而不使用模板来渲染视图。这给开发者提供了更多的权力（实际上是Python的全部权力），并允许视图表现和视图逻辑的清晰分离，从而在模板和Python两侧都产生更易读的代码。
- en: 'We already worked with the template part of a view at the end of Chapter 2,
    when we modified the file `index.pt` in the `helloworld` project. Besides this
    page template, if you look at the `app.py` file inside the `src/helloworld` directory
    of this project, you will see the Python part of the view. Here''s the full source
    code for the `helloworld` application:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第二章的末尾已经处理了视图的模板部分，当时我们修改了`helloworld`项目中的`index.pt`文件。除了这个页面模板之外，如果你查看该项目`src/helloworld`目录中的`app.py`文件，你将看到视图的Python部分。以下是`helloworld`应用程序的完整源代码：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In this case, the Python code for the view consists only of a single class
    declaration, which we inherit from `grok.View`, which is the basic Grok view.
    Since we are just going to show the template, we don''t need any more code, but
    we can see one of Grok''s conventions at work here if we look at the name of the
    class: `Index`. As the comment after the class definition says, the template for
    this class will be found under `app_templates/index.pt` in the `application` directory.
    Grok doesn''t need to be told this either in code or configuration because by
    convention, the template name will be the same as the class name, with the template
    name in lowercase and the extension `.pt` appended to it.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，视图的Python代码仅由一个类声明组成，我们从这个类继承自`grok.View`，这是基本的Grok视图。由于我们只是将要展示模板，我们不需要更多的代码，但如果我们查看类的名称，我们可以看到Grok的一个约定正在起作用：`Index`。正如类定义之后的注释所说，这个类的模板将在`application`目录下的`app_templates/index.pt`中找到。Grok不需要在代码或配置中被告知这一点，因为按照约定，模板名称将与类名相同，模板名称为小写，并附加`.pt`扩展名。
- en: To add a new view to the application, all we need to do is to define a class
    that inherits from `grok.View` and create the corresponding template inside the
    `app_templates` folder. Then we can refer to this view in a URL by using the template
    name. Note that the name `index.pt` is a special case and represents another convention,
    because a view with that name will be considered the default view of the application,
    which means that it's not necessary to specify its name in the URL.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要向应用程序添加新的视图，我们只需要定义一个从`grok.View`继承的类，并在`app_templates`文件夹内创建相应的模板。然后我们可以通过使用模板名称在URL中引用这个视图。注意，名称`index.pt`是一个特殊情况，它代表另一个约定，因为具有该名称的视图将被视为应用程序的默认视图，这意味着在URL中不需要指定其名称。
- en: Zope Page Templates (ZPT)
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Zope 页面模板 (ZPT)
- en: For the HTML generation, Grok uses **Zope Page Templates** (**ZPT**). They fit
    Grok's philosophy nicely because one of the driving principles behind their design
    is the strict separation of logic from presentation. Wherever possible, a view
    template should contain only presentation and structural logic, along with name
    and method calls from the view class.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 对于HTML生成，Grok使用**Zope页面模板**（**ZPT**）。它们很好地符合Grok的哲学，因为它们设计背后的一个驱动原则是严格分离逻辑和展示。尽可能的情况下，视图模板应只包含展示和结构逻辑，以及视图类中的名称和方法调用。
- en: Another important design principle of ZPT is to work well with editing tools,
    thus allowing designers to take template code back from developers and still be
    able to see and work with a complete HTML representation of the page without losing
    any logic. This is achieved by using valid HTML/XHTML for the page template.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: ZPT的另一个重要设计原则是与编辑工具良好地协同工作，从而允许设计师从开发者那里取回模板代码，同时仍然能够看到并处理页面的完整HTML表示，而不会丢失任何逻辑。这是通过使用有效的HTML/XHTML作为页面模板来实现的。
- en: The Template Attribute Language (TAL)
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模板属性语言 (TAL)
- en: To accomplish its objective of working well with editing tools, ZPT uses the
    **Template Attribute Language** (**TAL**). Statements from this language use HTML
    attributes with an XML namespace, which basically means that they are prefixed
    with the letters "tal" and a colon, as in `tal:content` or `tal:replace`. Editing
    tools usually ignore statements which are not a part of regular HTML, and so they
    leave the TAL statements alone.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现与编辑工具良好协作的目标，ZPT使用**模板属性语言**（**TAL**）。这种语言中的语句使用带有XML命名空间的HTML属性，这基本上意味着它们以“tal:”和冒号作为前缀，例如`tal:content`或`tal:replace`。编辑工具通常会忽略不是常规HTML的一部分的语句，因此它们会保留TAL语句不变。
- en: Let's take a quick overview of the most important TAL statements and constructs.
    We'll cover the basics here, but the complete reference can be found at [http://docs.zope.org/zope2/zope2book/AppendixC.html](http://docs.zope.org/zope2/zope2book/AppendixC.html).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速概述一下最重要的TAL语句和结构。这里我们将介绍基础知识，但完整的参考可以在[http://docs.zope.org/zope2/zope2book/AppendixC.html](http://docs.zope.org/zope2/zope2book/AppendixC.html)找到。
- en: 'Let''s begin our introduction to TAL by showing a simple example:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个简单的例子开始我们的TAL介绍：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`content` is a TAL statement that leaves the tag alone, but replaces its contents
    with the result of the expression in quotes. In this case, when the page is rendered,
    we''ll get the following:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`content`是一个TAL语句，它保持标签不变，但用引号中的表达式结果替换其内容。在这种情况下，当页面渲染时，我们将得到以下内容：'
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note that the tag remains an`<h1>` tag, but the contents of the tag change to
    the result of the expression, which will be dynamically calculated each time the
    page renders. A designer using a WYSIWYG tool will see the words "A simple multiplication"
    instead, but will be able to correctly see the intended structure of the page.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，标签仍然是一个`<h1>`标签，但标签的内容会变为表达式的结果，每次页面渲染时都会动态计算。使用所见即所得(WYSIWYG)工具的设计师会看到“一个简单的乘法”这样的文字，但仍然能够正确地看到页面的预期结构。
- en: By design, ZPT is not a general programming language, so complex code will be
    better off inside Python code in the view class. However, it is still possible
    to repeat tags, omit, or display them according to some conditions, or even include
    parts of other page templates. This will generally be enough for most page structures
    and even if it's not, part of the HTML can be generated in Python code and inserted
    inside a template as well.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 按设计，ZPT不是一个通用编程语言，因此复杂的代码最好放在视图类中的Python代码中。然而，仍然可以根据某些条件重复标签、省略或显示它们，甚至包括其他页面模板的部分。这通常足以处理大多数页面结构，即使不是这样，也可以在Python代码中生成HTML的一部分，并将其插入模板中。
- en: Note
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'ZPT is not the only templating engine that can be used with Grok, as it was
    carefully designed to allow pluggable engines. At the time of writing, there are
    packages available for two such engines: `megrok.genshi` and `megrok.chameleon`.
    A developer can choose which templating engine fits his style better and use that
    instead of ZPT.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: ZPT 不是唯一可以与 Grok 一起使用的模板引擎，因为它被精心设计为允许可插拔的引擎。在撰写本文时，有两个这样的引擎的包可用：`megrok.genshi`
    和 `megrok.chameleon`。开发者可以选择更适合他风格的模板引擎，并使用它而不是 ZPT。
- en: Expression types
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表达式类型
- en: In the previous example, we used the expression `python:5*5` to get the result
    of a multiplication. These are known as Python expressions and can include any
    valid Python expression after the colon. Of course, as one of the principles of
    Grok is the clear separation of presentation and logic, we want to avoid very
    large expressions. But Python expressions are sometimes very useful, especially
    when we are dealing with conditions or Python objects such as lists or dictionaries.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，我们使用了表达式 `python:5*5` 来获取乘法的结果。这些被称为 Python 表达式，可以在冒号之后包含任何有效的 Python
    表达式。当然，Grok 的一个原则是明确分离表现和逻辑，我们希望避免使用非常长的表达式。但 Python 表达式有时非常有用，尤其是在处理条件或列表、字典等
    Python 对象时。
- en: There are several reasons why keeping most of the logic out of the templates
    is a good idea. Debugging and testing code is much easier if we can use Python
    development tools, for one thing. Also, by using this strategy, we can potentially
    alter the presentation of an application (the templates) without touching the
    main code.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个原因说明将大部分逻辑保留在模板之外是一个好主意。首先，如果我们能使用 Python 开发工具，调试和测试代码会容易得多。此外，通过使用这种策略，我们可以潜在地改变应用程序的表现（模板）而不必触及主代码。
- en: 'There are other kinds of expressions, though. The default type of expression
    in ZPT is called **path expression**. Here is an example:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然还有其他类型的表达式。ZPT 中的默认表达式类型被称为**路径表达式**。以下是一个示例：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The reason it's called a path expression is because it starts with a variable
    name and uses a slash to separate calls to subobjects of that variable, returning
    the result of calling the last object in the path, or the object itself if it
    is not callable. In the preceding example, we get the current URL from the special
    name `request`, by using a path from `request` to `URL`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 它被称为路径表达式的原因是因为它以变量名开头，并使用斜杠来分隔对该变量子对象的调用，返回路径中最后一个对象的调用结果，或者如果它不可调用，则返回该对象本身。在前面的示例中，我们通过从
    `request` 到 `URL` 的路径从特殊名称 `request` 获取当前 URL。
- en: 'If a component of the path is not found, an error occurs, but it''s possible
    to fall back to other objects or values in this case. To do that, we use the `|`
    symbol to separate possible expression values. For example, to get some parameter
    from the request:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果路径的某个组件未找到，将发生错误，但在这种情况下，可以回退到其他对象或值。为此，我们使用 `|` 符号来分隔可能的表达式值。例如，要从请求中获取一些参数：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this path expression, we look for the request parameter `param1`; if it's
    not defined, we use the value of `param2`, and if none of the two are defined,
    the special value `nothing` is used. This value is equivalent to Python's `None`
    value, so nothing will be inside the span tag if this happens, but no error will
    occur.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个路径表达式中，我们寻找请求参数 `param1`；如果它未定义，我们使用 `param2` 的值，如果两个都没有定义，则使用特殊值 `nothing`。此值等同于
    Python 的 `None` 值，因此如果发生这种情况，span 标签内将没有任何内容，但不会发生错误。
- en: 'In addition to path and Python expressions, there is a third type, known as
    **String expressions**. These are useful when you need to combine arbitrary strings
    with the result of path expressions. Here is an example:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 除了路径和 Python 表达式之外，还有一种称为**字符串表达式**的第三种类型。当你需要将任意字符串与路径表达式的结果组合时，这些表达式非常有用。以下是一个示例：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Everything after the colon is treated as the string to display, except that
    the string is searched for path expressions marked with the `$` sign and the results
    of those expressions are substituted in. When the path expression consists of
    more than one part (when we have to use the `/` separator) or when it''s not separated
    by spaces from other characters in the string, it is necessary to enclose the
    expression in `{}` braces, as in the preceding example. To insert a `$` sign,
    a double `$` is used, like this:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 冒号之后的所有内容都被视为要显示的字符串，除了字符串中带有 `$` 标记的路径表达式和这些表达式的结果会被替换。当路径表达式由多个部分组成（当我们必须使用
    `/` 分隔符时）或者它与其他字符在字符串中未分隔时，必须将表达式括在 `{}` 大括号内，就像前面的示例一样。要插入 `$` 符号，使用两个 `$` 符号，如下所示：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If the variable `amount` has the value 45, the previous expression will output
    the following HTML:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果变量`amount`的值为45，前面的表达式将输出以下HTML：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Inserting text
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 插入文本
- en: We already saw that the `content` statement replaces all of the content of a
    tag, including any nested tags inside. There is another statement, `replace`,
    which gets rid of the tag altogether, and inserts the desired text in its place.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到`content`语句会替换一个标签的所有内容，包括任何嵌套的标签。还有一个`replace`语句，它可以完全删除标签，并在其位置插入所需的文本。
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this case, the`<span>` tag is only a placeholder tag because it will not
    be output when the template is rendered.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`<span>`标签只是一个占位符标签，因为当模板渲染时它不会被输出。
- en: In addition to inserting text, the `replace` statement can be used for including
    dummy content on a page, which can be helpful for some designers who want to work
    with a more detailed mock web page for illustrative purposes, without this content
    appearing on the final rendered page. To do that, we simply replace the HTML with
    the special name `nothing:`
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 除了插入文本外，`replace`语句还可以用于在页面上包含占位内容，这对于一些想要使用更详细的模拟网页进行演示的设计师来说可能很有帮助，而最终渲染的页面上不会出现这些内容。为此，我们只需将HTML替换为特殊名称`nothing:`。
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Repeating tags
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重复标签
- en: When working with HTML tables and lists, we will often need to add a table row
    or a list item for every item in a Python sequence, such as a list or a tuple.
    For example, we could have a list of weapons for 'Grok the caveman' that we need
    to display as an HTML unordered list. The `repeat` statement causes a tag, and
    all of its contents, to be repeated once for every element in a sequence. To see
    how it works, suppose that we have a list of weapons that is passed to the template
    as an attribute of the view, with the name `weapon:`
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理HTML表格和列表时，我们通常会需要为Python序列中的每个项目添加一个表格行或列表项，例如列表或元组。例如，我们可能有一个用于显示为HTML无序列表的武器列表，名为'Grok
    the caveman'。`repeat`语句会导致标签及其所有内容在序列中的每个元素上重复一次。为了了解它是如何工作的，假设我们有一个作为视图属性传递给模板的武器列表，名称为`weapon:`。
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If `weapon` contains the list [''Rock'',''Club'',''Spear''], the template will
    be rendered like this:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`weapon`包含列表`['Rock','Club','Spear']`，模板将渲染如下：
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `repeat` statement takes two parameters. The first is the name of the loop
    variable, which will be assigned the value of each element in the list in order.
    The second is an expression that returns the sequence where the elements are stored.
    Notice how we use our chosen name `weapon`, together with the `content` statement,
    to insert the name of the current weapon inside the`<li>` tag.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`repeat`语句接受两个参数。第一个是循环变量的名称，它将按顺序分配列表中每个元素的值。第二个是一个返回元素存储序列的表达式。注意我们如何使用选定的名称`weapon`，结合`content`语句，在`<li>`标签内插入当前武器的名称。'
- en: It is possible to nest multiple `repeat` statements, which is why we need to
    assign a name to the loop variable. This name can also be useful for determining
    where on the list are we by using it together with the special `repeat` variable.
    For example, the expression `repeat/weapon/number` will return 1 for the first
    element, 2 for the second, and so on. The expression `repeat/weapon/index` does
    the same, but starts at 0.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 可以嵌套多个`repeat`语句，这就是为什么我们需要给循环变量命名。这个名称也可以用来确定我们在列表中的位置，通过结合使用特殊的`repeat`变量。例如，表达式`repeat/weapon/number`将返回1作为第一个元素，2作为第二个元素，依此类推。表达式`repeat/weapon/index`做同样的事情，但起始值为0。
- en: Conditional elements
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 条件元素
- en: The `condition` statement is used when we want to decide, at render time, if
    a tag and its contents should be displayed on the page or not. It evaluates the
    expression passed to it and removes the tag if the result is false. When the expression
    is true, the tag is shown as normal.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`condition`语句用于在渲染时决定是否在页面上显示一个标签及其内容。它评估传递给它的表达式，如果结果为假，则删除该标签。当表达式为真时，标签会正常显示。'
- en: 'To help ''Grok the caveman'' keep better track of his arsenal, we could turn
    the list into a table to also show the number of each weapon that he has. A helpful
    reminder can be added to each row when the number of items is considered too low.
    The `view` variable would contain a list of dictionaries in this case, such as
    this one: [{''name'':''Rock'',''quantity'':10},{''name'':''Club'',''quantity'':1},{''name'':''Spear'',''quantity'':3}].
    To show the table, we could use this markup:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助“穴居人”更好地跟踪他的武器库，我们可以将列表转换成表格，同时显示他每种武器的数量。当物品数量被认为过少时，可以在每一行添加一个有用的提示。在这种情况下，`view`变量将包含一个字典列表，例如这个：[{'name':'Rock','quantity':10},{'name':'Club','quantity':1},{'name':'Spear','quantity':3}]。要显示表格，我们可以使用以下标记：
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This will produce the following HTML:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成以下HTML：
- en: '[PRE13]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: There are a few things to note about this code. First, notice how we used path
    expressions to refer to the dictionary keys in the `name` and `quantity` columns.
    Path expressions work the same way for dictionary keys, object attributes, and
    methods. By contrast, in the Python expressions for the `condition` statements
    we had to use the dictionary syntax. The other thing to note is that we essentially
    need to repeat the same`<span>` tag twice with different conditions. The rendered
    template only shows those tags which are true. In this case, we have mutually
    exclusive conditions, but in other cases we could have multiple conditions, with
    independent true or false values.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这段代码，有几个需要注意的地方。首先，注意我们是如何使用路径表达式来引用`name`和`quantity`列中的字典键的。路径表达式对于字典键、对象属性和方法的工作方式相同。相比之下，在`condition`语句的Python表达式中，我们必须使用字典语法。其他需要注意的事情是，我们实际上需要重复相同的`<span>`标签两次，条件不同。渲染的模板只显示那些为真的标签。在这种情况下，我们具有互斥的条件，但在其他情况下，我们可能有多个条件，具有独立的真或假值。
- en: Variables
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量
- en: 'Sometimes we have expressions that we need to reuse throughout a page template.
    We could just repeat the expression in multiple places, but that would cause it
    to be evaluated multiple times, which is inefficient. For these situations, ZPT
    provides a `define` statement that allows us to assign the result of an expression
    to a variable. Here is an example of a template fragment where a variable definition
    would be helpful:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，我们需要在整个页面模板中重复使用表达式。我们可以在多个地方重复表达式，但这会导致它被多次评估，这是低效的。对于这些情况，ZPT提供了一个`define`语句，允许我们将表达式的结果分配给一个变量。以下是一个模板片段的例子，其中变量定义会有所帮助：
- en: '[PRE14]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In this example, the expression `view/weapons` is calculated once at the `repeat`
    statement and then once more for every item in the list. The length of the list
    is also calculated once for every item in the `weapons` list. If we use the `define`
    statement, this can be avoided:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，表达式`view/weapons`在`repeat`语句中计算一次，然后对于列表中的每个项目再计算一次。对于`weapons`列表中的每个项目，列表的长度也只计算一次。如果我们使用`define`语句，这可以避免：
- en: '[PRE15]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `define` statement takes the name of the variable and a expression for
    its value, with a space in between. Note that we can have multiple definitions
    in a single statement, separated by semicolons. Now, let''s say that we need to
    add a header at the top of the list where the total number of weapons must be
    displayed again:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`define`语句接受变量的名称和用于其值的表达式，两者之间用空格分隔。请注意，我们可以在单个语句中具有多个定义，由分号分隔。现在，假设我们需要在列表顶部添加一个标题，显示武器总数：'
- en: '[PRE16]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We can''t define the length only in the`<h1>` tag because the scope of the
    `define` statement is limited to the tag where it is used and its contents. Nevertheless,
    we would like to have just one definition that we can reuse throughout the template.
    The `global` keyword can be used in this case:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能仅在`<h1>`标签中定义长度，因为`define`语句的作用域仅限于使用它的标签及其内容。尽管如此，我们仍然希望有一个可以重复使用的定义。在这种情况下，可以使用`global`关键字：
- en: '[PRE17]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Once a variable is defined using the `global` keyword, it can be reused anywhere
    in the template, independent of the tag structure of the page.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦使用`global`关键字定义了一个变量，它就可以在模板的任何地方重复使用，不受页面标签结构的限制。
- en: One important thing to keep in mind regarding definitions is that path expressions
    always return the result of calling the last element of the path. Thus, when we
    are working with callable objects, we could end up assigning the wrong thing to
    a variable and messing up the page. This can sometimes be hard to debug, so it's
    not a bad idea to use Python expressions wherever possible, because they are more
    explicit.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 关于定义的一个重要注意事项是，路径表达式始终返回路径中最后一个元素的调用结果。因此，当我们与可调用对象一起工作时，我们可能会将错误的东西分配给变量，并弄乱页面。这有时很难调试，所以尽可能使用Python表达式是个好主意，因为它们更明确。
- en: 'This doesn''t mean that we can''t use path expressions (after all, they are
    the default type), but we have to make sure that we are getting the value that
    we want. When we need to get an object and not the result of calling that object,
    we can use the special `nocall` path expression to get it:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不意味着我们不能使用路径表达式（毕竟，它们是默认类型），但我们必须确保我们得到我们想要的价值。当我们需要获取一个对象而不是调用该对象的结果时，我们可以使用特殊的`nocall`路径表达式来获取它：
- en: '[PRE18]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Special variables
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 特殊变量
- en: Grok also makes some special variables available to every page template, so
    that template authors can refer to the different application's objects and views.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Grok还为每个页面模板提供了一些特殊变量，这样模板作者就可以引用不同的应用程序对象和视图。
- en: '`view:` Using this special name, all of the methods and attributes of the view
    class associated with the template can be accessed.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`view:` 使用这个特殊名称，可以访问与模板关联的视图类的所有方法和属性。'
- en: '`context:` The context name refers to the model that is being viewed, and also
    allows access to its methods and attributes.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`context:` 上下文名称指的是正在查看的模型，并且允许访问其方法和属性。'
- en: '`request:` The request object contains data from the current web request.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`request:` 请求对象包含当前网络请求的数据。'
- en: '`static:` This special name allows the creation of URLs referring to static
    resources.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`static:` 这个特殊名称允许创建指向静态资源的URL。'
- en: Modifying HTML tag attributes
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改HTML标签属性
- en: 'In addition to inserting text in a page, it''s very common to require the attributes
    of an HTML tag to be defined dynamically at rendering time. The `attributes` statement
    allows us to do precisely this. For example, let''s add links to a description
    page for every weapon in Grok the caveman''s arsenal:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在页面中插入文本外，通常还需要在渲染时动态定义HTML标签的属性。`attributes`语句允许我们做到这一点。例如，让我们为Grok这个穴居人的武器库中的每件武器添加描述页面的链接：
- en: '[PRE19]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In this example, we modify the link's `href` attribute to use the current page's
    URL and append to it the name of the weapon, assuming that a weapon description
    page with that name exists for every weapon in the list.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们修改链接的`href`属性，使其使用当前页面的URL，并附加武器的名称，假设列表中的每件武器都存在一个具有该名称的武器描述页面。
- en: As with the `define` statement, `attributes` statements allow multiple attribute
    definitions separated by semicolons.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 与`define`语句一样，`attributes`语句允许使用分号分隔的多个属性定义。
- en: Inserting structure
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 插入结构
- en: For security reasons, strings inserted by using the `content` and `replace`
    tags are quoted, in order to escape any HTML tags, so the`<` bracket becomes`&lt`;
    and the`>` bracket becomes`&gt`;. This results in HTML tags being displayed in
    the rendered page, instead of being interpreted as HTML. This is useful for preventing
    some cross-site scripting attacks, but does get in the way of generating HTML
    from Python code. The `structure` keyword is used before an expression to tell
    ZPT that the returned text should be interpreted as HTML and rendered like the
    rest of the tags on the page.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 由于安全原因，使用`content`和`replace`标签插入的字符串会被引号括起来，以便转义任何HTML标签，所以`<`括号变成`&lt`；而`>`括号变成`&gt`；。这导致HTML标签在渲染的页面上显示，而不是被解释为HTML。这对于防止一些跨站脚本攻击很有用，但也会妨碍从Python代码生成HTML。在表达式之前使用`structure`关键字，告诉ZPT返回的文本应该被解释为HTML，并像页面上的其他标签一样渲染。
- en: 'For instance, if we suppose that the variable text contains the following HTML:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们假设变量text包含以下HTML：
- en: '[PRE20]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This tag will escape the HTML:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这个标签将转义HTML：
- en: '[PRE21]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The resulting HTML will look like this:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的HTML将看起来像这样：
- en: '[PRE22]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Let''s use the `structure` keyword:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用`structure`关键字：
- en: '[PRE23]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now we get this result:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们得到以下结果：
- en: '[PRE24]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Multiple statements in one tag
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个标签中的多个语句
- en: In some of the earlier examples, we have used more than one TAL statement inside
    a single tag. As XML doesn't allow repeating attributes inside a tag, we can use
    only one of each type of TAL statement inside a given tag, and we can combine
    them as we see fit, with the exception of the `content` and `replace` statements,
    which are mutually exclusive and can't be used in the same tag at all.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在一些早期的例子中，我们在单个标签内使用了多个TAL语句。由于XML不允许在标签内重复属性，我们可以在给定的标签中只使用每种类型的TAL语句中的一个，并且我们可以根据需要将它们组合起来，除了`content`和`replace`语句，它们是互斥的，并且不能在同一个标签中使用。
- en: 'The most important thing to know when using multiple statements in one tag
    is that the order in which they are executed is fixed. It doesn''t matter how
    we place them in the tag, they will be executed in the following order:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当在一个标签中使用多个语句时，需要知道的最重要的事情是它们执行的顺序是固定的。我们如何放置它们在标签中无关紧要，它们将按照以下顺序执行：
- en: '`define`'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`define`'
- en: '`condition`'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`condition`'
- en: '`repeat`'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`repeat`'
- en: '`content/replace`'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`content/replace`'
- en: '`attributes`'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`attributes`'
- en: For this reason, if we need one statement that is lower in this list to be executed
    before a statement that is higher, we have to add`<div>` or`<span>` tags as required
    to get around the fixed order. For example, suppose we want to define some variable
    for every element in a `repeat` statement. We can't add the `define` statement
    in the same tag as the `repeat` statement itself, because `define` is executed
    before `repeat`, so we would get an error due to the loop variable being undefined
    at that point.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们需要在这个列表中较低位置的语句在较高位置的语句之前执行，我们必须添加所需的`<div>`或`<span>`标签来绕过固定的顺序。例如，假设我们想在`repeat`语句的每个元素中定义一些变量。我们不能在`repeat`语句本身所在的标签中添加`define`语句，因为`define`在`repeat`之前执行，所以我们会因为循环变量在那个点未定义而得到错误。
- en: 'A possible solution would be to use a`<span>` tag to define the variable after
    the `repeat` statement, as shown in the following example:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 一个可能的解决方案是在`repeat`语句之后使用`<span>`标签来定义变量，如下面的示例所示：
- en: '[PRE25]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'A slightly better solution is to use a tag with the XML namespace `tal`, which
    will serve as a structural marker but not appear in the final page rendering:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 一个稍微更好的解决方案是使用具有XML命名空间的标签`tal`，它将作为结构标记但不会出现在最终的页面渲染中：
- en: '[PRE26]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Instead of the`<span>` tag, we use`<tal:weapon>`. It's not that ZPT has a `weapon`
    tag; the trick is in the `tal` part of the name. We could use anything else in
    place of `weapon` here. Note that as the tag itself explicitly uses the `tal`
    namespace, when using ZPT, the `define` and `content` statements in the same tag
    do not need to be prefixed by it.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不使用`<span>`标签，而是使用`<tal:weapon>`。这并不是因为ZPT有一个`weapon`标签；技巧在于名字中的`tal`部分。在这里我们可以用任何其他东西代替`weapon`。请注意，由于标签本身明确使用了`tal`命名空间，当使用ZPT时，同一标签中的`define`和`content`语句不需要以它为前缀。
- en: Macros and slots
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 宏和插槽
- en: Many websites use standard elements on every page, such as headers, footers,
    sidebars, and more. One nice feature of ZPT is that it allows us to reuse elements
    like these without having to repeat them everywhere. The mechanisms used for doing
    this are called macros and slots.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 许多网站在每一页上使用标准元素，例如标题、页脚、侧边栏等。ZPT的一个不错之处在于它允许我们重用这些元素，而无需在各个地方重复它们。用于执行此操作的机制称为宏和插槽。
- en: A **macro** is a page or part of a page that is declared as one and given a
    name. Once this declaration is done, the markup so named can be reused in different
    pages. This way, we can have a single-page macro defining the look and feel of
    our site and have every other page look like it and, most importantly, automatically
    change whenever the macro changes.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '**宏**是一个声明为单个实体并赋予名称的页面或页面的一部分。一旦完成此声明，所命名的标记就可以在不同的页面中重用。这样，我们可以有一个单页宏来定义我们网站的外观和感觉，并且让其他每一页看起来都像它，最重要的是，当宏更改时，它会自动更改。'
- en: 'A macro is defined using HTML attributes, just like TAL statements are. The
    macro definition language is known as **Macro Expansion Template Attribute Language**,
    or just **METAL** for short. Here''s an example:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 宏的定义使用HTML属性，就像TAL语句一样。宏定义语言被称为**宏扩展模板属性语言**，或简称**METAL**。以下是一个示例：
- en: '[PRE27]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `define-macro` statement creates a macro with the name given in quotes,
    which is `about` in this case. This name is added to the list of macros defined
    on the page, which is appropriately named macros. We can define any number of
    macros inside a page template, as long as we use different names for each. To
    use a macro, we access the `macros` attribute of the page in which it was created,
    by using the desired name. Supposing the `about` macro is defined inside a page
    template named `main.pt`, we can then use the macro from any other page, like
    this:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`define-macro`语句创建了一个带有引号中给定名称的宏，在这个例子中是`about`。这个名字被添加到页面上定义的宏列表中，这个列表被恰当地命名为`macros`。我们可以在页面模板中定义任意数量的宏，只要我们为每个宏使用不同的名称。要使用宏，我们需要通过使用所需的名称来访问创建它的页面的`macros`属性。假设`about`宏定义在名为`main.pt`的页面模板中，我们就可以在任意其他页面中使用这个宏，如下所示：'
- en: '[PRE28]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: When this other template is rendered, the entire`<p>` tag is substituted by
    the`<div>` tag that encloses the macro. It's just as if the HTML from the macro
    was copied and pasted in place of the tag containing the `use-macro` statement.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当这个其他模板被渲染时，整个`<p>`标签会被包含宏的`<div>`标签所替换。这就像是将宏中的HTML复制并粘贴到包含`use-macro`语句的标签位置一样。
- en: By using macros, you can easily reuse big or small pieces of HTML in multiple
    pages, but what makes this much more useful is the concept of slots. Think of
    slots as placeholders for custom HTML inside an existing macro. Although the general
    structure of the HTML remains the same, a template using macros can fill in these
    placeholders at rendering time, thus allowing much more flexibility than simple
    macros alone can provide.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用宏，你可以轻松地在多个页面中重用大块或小块的HTML，但使这一概念更加有用的是插槽的概念。将插槽想象为现有宏内部自定义HTML的占位符。尽管HTML的一般结构保持不变，但使用宏的模板可以在渲染时填充这些占位符，从而比简单的宏提供更多的灵活性。
- en: The best use for slots is to define sections within a full-page macro that can
    be filled in by different templates using the macro. We can then define the structure
    of our web pages in one single place, and have the whole site take advantage of
    it.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 最有效的使用插槽的方法是在全页宏中定义部分，这些部分可以通过不同的模板使用宏来填充。这样我们就可以在一个地方定义我们网页的结构，并且让整个网站都能从中受益。
- en: 'Let''s define a page macro to show these concepts in action:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义一个页面宏来展示这些概念的实际应用：
- en: '[PRE29]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Notice how we define the macro right inside the very first tag, so that the
    entire page is a single big macro. Then, using the `define-slot` statement, we
    define three slots, one each for the header, footer, and body. Other templates
    can reuse the macro and fill in one or more of these slots to customize the final
    page rendering. Here''s how to do that:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们是如何在第一个标签内部定义宏的，这样整个页面就是一个大宏。然后，使用`define-slot`语句，我们定义了三个插槽，分别对应于页眉、页脚和主体。其他模板可以重用这个宏，并填充一个或多个这些插槽来定制最终的页面渲染。以下是实现方法：
- en: '[PRE30]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `fill-slot` statement takes the name of a slot and replaces its content
    with the section beginning with the tag where it is used. Everything else in the
    `main.pt` template is used exactly as it appears there. This is what the rendered
    HTML looks like:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`fill-slot`语句接受一个插槽的名称，并用使用该语句的标签开始的节的内容替换其内容。`main.pt`模板中的其他内容将完全按照其出现的方式使用。这是渲染后的HTML看起来像这样：'
- en: '[PRE31]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Going beyond ZPT basics
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 超越ZPT基础
- en: This has been a short introduction to ZPT, although we did cover a handful of
    concepts, including inserting text into templates, repeating tags, conditions,
    variables, attributes, and macros. For more information, a good resource is the
    Zope book, which is available online at [http://docs.zope.org/zope2/zope2book/](http://docs.zope.org/zope2/zope2book/).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们确实介绍了一些概念，包括在模板中插入文本、重复标签、条件、变量、属性和宏，但这只是一个对ZPT的简要介绍。更多详细信息，可以参考Zope书籍，该书籍可在[http://docs.zope.org/zope2/zope2book/](http://docs.zope.org/zope2/zope2book/)在线获取。
- en: The to-do list application
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 待办事项列表应用程序
- en: Now that we have learned about ZPT, let's begin with the code for our to-do
    list application. The idea is that the user will have a web page where he can
    manage his tasks by using lists. Instead of using a single list, he will be able
    to create several lists for high-level tasks, each with a number of smaller tasks
    to carry out. The application will allow the user to create a list with a description,
    add tasks to it, and check them off as completed when he is done. He can add as
    many lists as he needs, and remove any of them at any time.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了 ZPT，让我们从待办事项应用程序的代码开始。想法是用户将有一个网页，他可以通过列表来管理他的任务。他不仅可以使用单个列表，还可以创建多个列表来处理高级任务，每个列表包含多个较小的任务。应用程序将允许用户创建带有描述的列表，向其中添加任务，并在完成时勾选它们。他可以添加他需要的任何数量的列表，并在任何时候删除它们。
- en: This is all very simple, so for now the list manager will use a single view
    with an associated template. We will add additional functionality as we advance
    through the chapter.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切都非常简单，所以现在列表管理器将使用一个带有相关模板的单个视图。随着我们进入本章的后续内容，我们将添加更多功能。
- en: 'The first step of course is to create a new Grok project:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，第一步是创建一个新的 Grok 项目：
- en: '[PRE32]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'For now, we''ll hold our to-do lists in a Python list. Each one will be a dictionary
    containing keys of title, description, and items. Our next step will be to create
    a template to show all of the lists and their items. We''ll replace the content
    of the `index.pt` template inside `app_templates` with this code:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用 Python 列表来保存我们的待办事项列表。每个列表将是一个包含标题、描述和项目的字典。我们的下一步将是创建一个模板来显示所有列表及其项目。我们将用以下代码替换
    `app_templates` 中 `index.pt` 模板的内 容：
- en: '[PRE33]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Examine the code. Make sure that you understand all of the ZPT statements that
    we are using. Go look at the ZPT section again, if necessary. We are assuming
    that the special name `context` will include the lists in an attribute named `todolists`
    and that it iterates over all of the lists by using the `repeat` statement. We
    also have a nested `repeat` statement inside that, to list all of the items in
    each to-do list.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 检查代码。确保你理解我们使用的所有 ZPT 语句。如有必要，再次查看 ZPT 部分。我们假设特殊名称 `context` 将包含在名为 `todolists`
    的属性中的列表，并且它通过使用 `repeat` 语句遍历所有列表。我们还在其中嵌套了一个 `repeat` 语句，以列出每个待办事项列表中的所有项目。
- en: Before doing anything else, open the `index.pt` file by using the open file
    option in your web browser. Notice how we get a nice preview of how the page will
    look once it has real data (see the following screenshot). That's one of the benefits
    of working with ZPT. We expressly took advantage of this feature by including
    two dummy list items in the list, by using the `replace="nothing`" trick.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在做任何事情之前，使用你的网络浏览器的打开文件选项打开 `index.pt` 文件。注意我们如何得到一个页面一旦有真实数据的预览（见以下截图）。这是使用
    ZPT 的一大好处。我们明确利用了这一特性，通过在列表中使用 `replace="nothing"` 技巧添加了两个虚拟列表项。
- en: '![The to-do list application](img/7481_03_01.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![待办事项应用程序](img/7481_03_01.jpg)'
- en: 'Now let''s see its working in Grok. Remember that the template assumes that
    there will be a list named `todolists` available in the `context`. This would
    in fact refer to the application model, but for now let''s just hardcode some
    value there to see how the template is rendered. We''ll use a real model later.
    Open the `app.py` file in the `src` directory and change it to look like this:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看它在 Grok 中的工作情况。请记住，模板假设在 `context` 中将有一个名为 `todolists` 的列表可用。这实际上将指向应用程序模型，但为了现在，我们只需在那里硬编码一些值来查看模板是如何渲染的。我们稍后会使用一个真实模型。打开
    `src` 目录中的 `app.py` 文件，并将其修改如下：
- en: '[PRE34]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now start the application:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在启动应用程序：
- en: '[PRE35]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Create an application by using the admin control panel and click on its link.
    A screen similar to the following screenshot will be displayed. Notice the similarity
    to the preview template that we opened before.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用管理控制面板创建一个应用程序，并点击其链接。将显示一个类似于以下截图的屏幕。注意它与之前我们打开的预览模板的相似性。
- en: '![The to-do list application](img/7481_03_02.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![待办事项应用程序](img/7481_03_02.jpg)'
- en: Handling form data
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理表单数据
- en: 'We can now display to-do lists and their items correctly, but we need a way
    to add new lists and items, and we also need to be able to check them off somehow.
    We need forms to handle these actions, so let''s modify the template to look like
    this:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以正确地显示待办事项列表及其项目，但我们需要一种方法来添加新的列表和项目，我们还需要能够以某种方式勾选它们。我们需要表单来处理这些操作，所以让我们修改模板，使其看起来像这样：
- en: '[PRE36]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We now use a form for each list, and every form has the same action, defined
    at rendering time by using the `attributes` statement. A Grok view always has
    a `url` method that returns the view URL, so what we are doing here is submitting
    the form to itself. We'll deal with form submissions a bit later, when we add
    the view's Python code.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在为每个列表使用一个表单，并且每个表单都有相同的操作，该操作在渲染时通过使用`attributes`语句定义。Grok视图始终有一个`url`方法，它返回视图URL，因此我们在这里所做的就是将表单提交给自己。我们将在添加视图的Python代码时稍后处理表单提交。
- en: 'To separate the lists visually, each one is inside a `fieldset`, with its title
    and description. To list individual items, we drop the`<ul>` from our first template
    and use a`<div>`, because we now need to have a checkbox to mark the items completed.
    Let''s add the checkbox, and also provide a way to delete items from the list
    while we are at it:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在视觉上分隔列表，每个列表都包含在一个`fieldset`中，其中包含其标题和描述。为了列出单个项目，我们丢弃了第一个模板中的`<ul>`，并使用了一个`<div>`，因为我们现在需要有一个复选框来标记已完成的项目。让我们添加复选框，同时提供一个在添加项目的同时从列表中删除项目的方法：
- en: '[PRE37]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Note the use of the `repeat/item/index` variable to name each item according
    to its place in the list, so that we can refer to them individually in the view.
    We'll also need to know to which list the item belongs, which is why every list
    form has a hidden input field with its index, using `repeat/todolist/index` to
    get that value. Finally, we have an update list button which is used to check
    and uncheck multiple list items in one go.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 注意使用`repeat/item/index`变量来命名每个项目，根据其在列表中的位置，这样我们就可以在视图中单独引用它们。我们还需要知道项目属于哪个列表，这就是为什么每个列表表单都有一个隐藏的输入字段，其中包含其索引，使用`repeat/todolist/index`来获取该值。最后，我们有一个更新列表按钮，用于一次性检查和取消选中多个列表项。
- en: 'All that''s needed now is a way to add new items to a list. We''ll just append
    to the preceding code a text area for the item description, and a submit button
    for adding it. Nothing really special here:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所需的就是一种向列表中添加新项目的方法。我们只需在之前的代码中添加一个用于项目描述的文本区域和一个用于添加项目的提交按钮。这里并没有什么特别之处：
- en: '[PRE38]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: After all of the lists are displayed, we want another form to be able to add
    new lists. This one also submits to itself. Place this code after the closing`</tal:lists>`
    tag above.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在显示所有列表之后，我们想要另一个表单来添加新的列表。这个表单也提交给自己。将此代码放置在上述`</tal:lists>`标签之后。
- en: '[PRE39]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The view template is ready. Now let's create the view class. Remember that in
    Grok, a view usually consists of a template for the UI, and a class for passing
    calculated data to the template and handling any form input. As we now have various
    submit buttons that will send form data to the view, we need a way to handle that
    data. The easiest way to do that is to define an `update` method, which Grok knows
    to call just before rendering the page template for the view.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 视图模板已经准备好了。现在让我们创建视图类。记住，在Grok中，视图通常由一个用于UI的模板和一个用于将计算数据传递给模板并处理任何表单输入的类组成。由于我们现在有各种将表单数据发送到视图的提交按钮，我们需要一种处理这些数据的方法。最简单的方法是定义一个`update`方法，Grok知道在渲染页面模板之前调用该方法。
- en: To get at the form data, we will use the `request` variable that is available
    in every view class. This variable contains all of the data for the current `HTTP`
    request, including form fields. Using `request.form` we'll get a dictionary with
    all of the available form fields, with the `name` attribute of the field used
    as the key. Each submit button has its own name, so we can test for it's presence
    to see which action we need to carry out.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取表单数据，我们将使用在每个视图类中都可用的`request`变量。该变量包含当前`HTTP`请求的所有数据，包括表单字段。使用`request.form`，我们将得到一个包含所有可用表单字段的字典，字段的`name`属性用作键。每个提交按钮都有自己的名称，因此我们可以检查其是否存在，以查看需要执行哪个操作。
- en: 'Change `app.py` to look like the following code:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 将`app.py`修改为以下代码：
- en: '[PRE40]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: First of all, in the application definition, we remove the test data that we
    added before, leaving the `todolists` attribute defined as an empty list, so that
    we have a clean slate when we start the application.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在应用程序定义中，我们删除之前添加的测试数据，将`todolists`属性定义为空列表，这样当我们启动应用程序时，我们就有一个干净的起点。
- en: In the `update` method, we assign the form data to the `form` variable by using
    `self.request.form`, as discussed earlier. We then have three possible cases.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在`update`方法中，我们通过使用`self.request.form`将表单数据分配给`form`变量，正如之前所讨论的。然后我们有三种可能的情况。
- en: '**Case one:** The add list form was submitted, in which case the name `new_list`
    will be in the form.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第一种情况**：提交了添加列表的表单，在这种情况下，`new_list`的名称将在表单中。'
- en: '**Case two:** One of the buttons for adding an item, removing an item, or updating
    a particular list was pressed, so the `list_index` hidden field will be in the
    form.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**情况二**：按下了添加项目、删除项目或更新特定列表的按钮之一，因此`list_index`隐藏字段将在表单中。'
- en: '**Case three:** No form submission occurred, such as when the view is accessed
    for the first time, so no action should be taken.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**情况三**：没有发生表单提交，例如当第一次访问视图时，因此不应采取任何操作。'
- en: In the case of a new list, we get the values of the title and description fields
    and then simply append a new dictionary with an empty item list to the `todolists`
    variable of the application.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在新列表的情况下，我们获取标题和描述字段的值，然后简单地将一个包含空项目列表的新字典附加到应用程序的`todolists`变量中。
- en: If one of the specific list buttons was pressed, then we get the list index
    from the form and use it to get the list items of the affected list. If the `new_item`
    button was pressed, we get the item description and append a dictionary with this
    description and a checked key to keep track of its on/off state. If `update_list`
    was pressed, we go through each of the list items and set its state to `True`,
    if it is present on the form and `False` otherwise. The last possible case is
    when the delete button of a list item was pressed, so we go through the items
    and remove any of them whose name is present in the form.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果按下了特定的列表按钮之一，那么我们就从表单中获取列表索引，并使用它来获取受影响列表的列表项。如果按下了`new_item`按钮，我们获取项目描述，并将一个包含此描述和选中键的字典附加到以跟踪其开/关状态的字典上。如果按下了`update_list`，我们遍历每个列表项，如果它在表单上存在，则将其状态设置为`True`，否则设置为`False`。最后可能的情况是当按下列表项的删除按钮时，因此我们遍历项目并删除任何在表单上出现的名称。
- en: 'Run the application and play with it a little. It doesn''t look pretty, but
    it has the complete functionality that we sketched at the start of the chapter.
    The following screenshot shows how a test run looks:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序并稍微玩一下。它看起来不太美观，但它具有我们在本章开头概述的完整功能。以下截图显示了测试运行的外观：
- en: '![Handling form data](img/7481_03_03.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![处理表单数据](img/7481_03_03.jpg)'
- en: Adding static resources
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加静态资源
- en: We now have a working application, so the next step will be to make it look
    better. We obviously need to add some styles using CSS. In addition, the **Delete**
    button to the right of the list items is too distracting, so let's use a small
    trash can icon instead.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个运行中的应用程序，所以下一步将是让它看起来更好。显然，我们需要使用CSS添加一些样式。此外，列表项右侧的**删除**按钮太分散注意力了，所以让我们使用一个小型垃圾箱图标代替。
- en: In this case, we will be working with static resources, such as images and stylesheets,
    and not with dynamic templates and classes. To handle these type of resources,
    Grok uses, by convention, a directory named `static`, which you will find in the
    same directory as the project source. We can simply place our static files in
    this directory, and Grok will be able to find them and generate links to them.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将处理静态资源，如图像和样式表，而不是动态模板和类。为了处理这些类型的资源，Grok按照惯例使用一个名为`static`的目录，你将在与项目源相同的目录中找到它。我们可以简单地将我们的静态文件放在这个目录中，Grok将能够找到它们并为它们生成链接。
- en: 'The icon that we will use here is available in the book''s code, under the
    `static` directory of the project. You''ll need to put some icon in that directory
    of your project, if you are following along with this example. For the stylesheet,
    create a file named `styles.css` in that directory, and add the following CSS
    code:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里将使用的图标可以在书的代码中找到，位于项目的`static`目录下。如果你要跟随这个示例，你需要在你项目的该目录中放置一些图标。对于样式表，在那个目录中创建一个名为`styles.css`的文件，并添加以下CSS代码：
- en: '[PRE41]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This is just a sample. The complete CSS file can be found in the sample code
    for this book. For the styles to actually work, we need to make a few changes
    to the `index.pt` template, to add some classes, and modify the delete button
    to use an image. Here''s the code again, with some explanations and the changes
    highlighted:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个示例。完整的CSS文件可以在本书的示例代码中找到。为了使样式真正生效，我们需要对`index.pt`模板进行一些修改，添加一些类，并将删除按钮修改为使用图像。以下是带有一些解释和更改高亮的代码：
- en: '[PRE42]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: First, notice how the link declaration in the document head uses the TAL `attributes`
    statement to set the `href` attribute. The word `static` in this case does not
    refer to the file system directory itself, but to the special view that finds
    the file there and generates a link to the appropriate file. The link is created
    in this manner to make it work correctly, no matter where the application is installed,
    even if we are using virtual hosting.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，注意文档头部中的链接声明是如何使用TAL的`attributes`语句来设置`href`属性的。这里的单词`static`并不指代文件系统目录本身，而是指代一个特殊的视图，该视图在该目录中查找文件并生成指向相应文件的链接。以这种方式创建链接是为了确保无论应用程序安装在哪里，即使我们使用虚拟主机，它都能正确工作。
- en: '[PRE43]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The class attributes that we added are pretty straightforward, but in the case
    of list items, we wanted to have checked items display differently to unchecked
    items, so we used the `attributes` statement again to dynamically decide at render
    time whether each item is checked (class done) or not (class pending) and use
    a different class in each case.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加的类属性相当直接，但在列表项的情况下，我们希望已选中的项与未选中的项显示不同，因此我们再次使用`attributes`语句在渲染时动态决定每个项是否被选中（class
    done）或未选中（class pending），并在每种情况下使用不同的类。
- en: Finally, we switched the input type of the delete button from `submit` to `image`
    and added a link to an icon using the special `static` name again.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将删除按钮的输入类型从`submit`更改为`image`，并再次使用特殊的`static`名称添加了一个指向图标的链接。
- en: 'That''s it. We don''t need to stop the server to see how it looks. Just reload
    the page and see. The Python code was not even touched, and the template has minimal
    changes, but the application looks completely different when it uses the CSS,
    as shown in the following screenshot:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。我们不需要停止服务器来查看效果。只需重新加载页面即可查看。Python代码甚至都没有被修改，模板也只做了最小限度的更改，但当它使用CSS时，应用程序看起来却完全不同，如下面的截图所示：
- en: '![Adding static resources](img/7481_03_04.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![添加静态资源](img/7481_03_04.jpg)'
- en: Putting in some JavaScript flourish
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加一些JavaScript的华丽效果
- en: Our to-do application looks a lot better now, but there are a few touches that
    we can also do to make it feel better. Having to press the update button each
    time that we check off one task is somewhat awkward, and can be easily forgotten.
    It would be nice if the list is automatically updated whenever we click on a checkbox.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的任务应用现在看起来好多了，但我们还可以做一些改进，让它感觉更好。每次勾选一个任务时都必须按下更新按钮，这有点尴尬，也容易忘记。如果列表在点击复选框时自动更新，那就太好了。
- en: Visually, the input box and button for adding list items are a bit distracting,
    so maybe we could hide them until they are needed. A final visual touch that we
    could add would be to move all of the checked-off items to the bottom of the list,
    so that it's clear what has and hasn't been done.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 从视觉上看，添加列表项的输入框和按钮有点分散注意力，所以我们可能需要将它们隐藏，直到需要时再显示。我们还可以添加的一个最终视觉触感是将所有已完成的项移动到列表底部，这样就可以清楚地看到哪些已经完成，哪些还没有完成。
- en: For hiding the form controls, we have to modify the template to make the new
    item label clickable, and call a toggle function in JavaScript when the user clicks
    it. We'll assign the `onclick` attribute dynamically to refer to the unique ID
    of the`<div>` that contains the controls.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 对于隐藏表单控件，我们必须修改模板，使新项目标签可点击，并在用户点击时调用JavaScript中的切换函数。我们将动态分配`onclick`属性，以便引用包含控件的`<div>`的唯一ID。
- en: '[PRE44]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Of course, for this to work we have to wrap the controls in a`<div>` tag and
    assign the same ID to it:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，为了实现这一点，我们必须将控件包裹在一个`<div>`标签中，并给它分配相同的ID：
- en: '[PRE45]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'That does it. In fact, this is so easy that we can do the same for the create
    list controls. The only thing is that we don''t need a dynamic ID here, since
    there''s only one ''create list'' form:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。实际上，这非常简单，我们可以为创建列表控件做同样的操作。唯一需要注意的是，这里我们不需要动态ID，因为只有一个“创建列表”表单：
- en: '[PRE46]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Moving completed items to the bottom does not require us to modify anything
    in the template. It's all done using JavaScript and the DOM. Skipping the use
    of the update button, however, is a bit harder, because we will need to use the
    `XMLHTTPRequest` object (better known by the word AJAX these days) to call a Grok
    view from JavaScript.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 将已完成的项目移动到底部不需要我们在模板中做任何修改。这一切都是使用JavaScript和DOM完成的。然而，跳过使用更新按钮则有点困难，因为我们需要使用`XMLHTTPRequest`对象（现在更常被称为AJAX）从JavaScript中调用Grok视图。
- en: Earlier, we said that a view usually consists of a template and a class. However,
    there are cases where a template is not really necessary. What we need here is
    a simple view that will set the checked state of the checkbox that was clicked
    on by the user. This view should return just the ID of the affected item, so that
    we can dynamically change its CSS class to reflect the change.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 之前我们提到，视图通常由一个模板和一个类组成。然而，有些情况下模板并不是必需的。我们这里需要的是一个简单的视图，它会设置用户点击的复选框的选中状态。这个视图应该只返回受影响项目的ID，这样我们就可以动态地更改其CSS类以反映变化。
- en: Adding a view in Grok is very easy, we just need to define a class that inherits
    from `grok.View`, and then add the required behavior to this. In this case, we
    don't even need a template, because we will just be returning the item ID as plain
    text. Grok allows us to use a `render` method on a view when we don't want to
    use a template or need to return something other than HTML. We'll add the new
    view to `app.py:`
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在Grok中添加视图非常简单，我们只需要定义一个从`grok.View`继承的类，然后添加所需的行为。在这种情况下，我们甚至不需要模板，因为我们只将返回项目ID作为纯文本。Grok允许我们在不想使用模板或需要返回除HTML之外的内容时，在视图中使用`render`方法。我们将新的视图添加到`app.py`中：
- en: '[PRE47]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The new view class name is `Check`, so the view URL will use the word `check`
    in lowercase. This view expects to be passed a list index and an item index to
    toggle the state of some item in the list. In this case, we do not need to examine
    the form, because we know we'll always require the same parameters. Grok can easily
    retrieve the parameters from the form for us, by specifying them after `self`
    in the `update` method. An error will occur if one or both of them are not present.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 新的视图类名为`Check`，因此视图URL将使用小写的单词`check`。这个视图期望传递一个列表索引和一个项目索引来切换列表中某个项目的状态。在这种情况下，我们不需要检查表单，因为我们知道我们始终需要相同的参数。Grok可以很容易地通过在`update`方法中指定它们来为我们检索参数，如果其中一个或两个参数不存在，将会发生错误。
- en: Note that the `update` method is called first, so we store the item ID in the
    view attribute `div_id` so that we can return it later when the template is actually
    rendered. Then, we use the indexes to find the correct item and toggle its state
    by using the `not` operator.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，首先调用的是`update`方法，因此我们在视图属性`div_id`中存储项目ID，以便在模板实际渲染时能够返回它。然后，我们使用索引来找到正确的项目，并通过使用`not`运算符切换其状态。
- en: 'As we mentioned before, we''ll return a simple string ID, so no template is
    needed. That''s why this view has a `render` method, which in this case just returns
    the ID that we stored earlier. In other situations, the `render` method could
    do much more for example, generating the HTML for the page, or sending a specific
    kind of content, such as an image or a PDF file. To do this, in addition to the
    code to render the desired document, the `render` method must also set the `Content-Type`
    by using the special `response` object, as in this example of returning XML:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，我们将返回一个简单的字符串ID，因此不需要模板。这就是为什么这个视图有一个`render`方法，在这种情况下，它只是返回我们之前存储的ID。在其他情况下，`render`方法可以做更多的事情，例如生成页面的HTML，或者发送特定类型的内容，如图片或PDF文件。为了做到这一点，除了渲染所需文档的代码外，`render`方法还必须通过使用特殊的`response`对象来设置`Content-Type`，就像返回XML的示例一样：
- en: '[PRE48]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: When we use the `render` method, no template is expected, so if Grok finds a
    template that should be associated with this view, it will signal an error to
    avoid ambiguity. In this case, if we put a template named `check.pt` inside the
    `app_templates` directory, Grok will stop with an error.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用`render`方法时，不需要模板，所以如果Grok找到一个应该与这个视图关联的模板，它将发出错误信号以避免歧义。在这种情况下，如果我们把名为`check.pt`的模板放在`app_templates`目录中，Grok将会因为错误而停止。
- en: 'Now that we have our new view, we need to call it from the template when the
    user clicks on a checkbox. We''ll use the `onclick` event handler here, too:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了新的视图，我们需要在用户点击复选框时从模板中调用它。我们也会在这里使用`onclick`事件处理器：
- en: '[PRE49]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: First, we need to assign a unique ID to each item, which we do in the`<div>`
    tag, by using the `list` and `item` indexes. Then we assign the `onclick` attribute
    by using the TAL `attributes` statement, so that we can dynamically construct
    the URL with the `check` view name and the list and item indexes as query parameters.
    To avoid hardcoding URL information, we use the `url` method from the view class,
    which, when called with a string as a parameter, returns the view with that name.
    We use the `define` statement for this.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要为每个项目分配一个唯一的 ID，我们通过在 `<div>` 标签中使用 `list` 和 `item` 索引来实现这一点。然后，我们通过使用
    TAL 的 `attributes` 语句来分配 `onclick` 属性，这样我们就可以动态地构造带有 `check` 视图名称以及列表和项目索引作为查询参数的
    URL。为了避免硬编码 URL 信息，我们使用视图类中的 `url` 方法，当它用一个字符串作为参数调用时，会返回具有该名称的视图。我们使用 `define`
    语句来做到这一点。
- en: Now, when the user clicks on a checkbox, the `check` view will be called from
    JavaScript with a `GET` request, and the JavaScript callback function that gets
    the return value will use it to set the correct CSS class for the checked state,
    and rearrange the completed items at the bottom.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当用户点击复选框时，JavaScript 会通过 `GET` 请求调用 `check` 视图，并且获取返回值的 JavaScript 回调函数将使用它来设置正确的
    CSS 类以表示选中状态，并重新排列底部的已完成项。
- en: The JavaScript code necessary for doing this work is included in the source
    code for this book. You should study it if you are interested in the details.
    Explaining that code would be outside the goals of this chapter. The key thing
    to take away from this example is the ability to have views in Grok that return
    anything that we want, and not just templates.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这项工作所需的 JavaScript 代码包含在这本书的源代码中。如果您对细节感兴趣，应该学习它。解释这段代码超出了本章的目标。从这个例子中，我们得到的关键点是
    Grok 视图能够返回我们想要的任何内容，而不仅仅是模板。
- en: Summary
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'Using our newly acquired knowledge of ZPT, we now have a simple, but complete,
    Grok application, including a nice design and JavaScript embellishments. As we
    designed it, we learned what Grok views are and the basics of working with them.
    In the next chapter, we will see where the data for views comes from: the content
    objects or models that define Grok applications.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 利用我们新获得的对 ZPT 的知识，我们现在拥有了一个简单但完整的 Grok 应用程序，包括一个很好的设计和 JavaScript 装饰。正如我们设计的，我们学习了
    Grok 视图是什么以及如何与之合作的基础知识。在下一章中，我们将看到视图数据来自哪里：定义 Grok 应用的内容对象或模型。
