- en: Chapter 3. Views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter we created our first Grok project and learned how to
    start a simple hello world application. Now we are going to learn about views
    and templates, which comprise the presentation layer of our web applications.
    To do this, we will create a simple application to manage to-do lists. The objective
    is to produce, by the end of this chapter, a working application that allows the
    user to create and manage any number of lists, add items to them, and mark them
    off as completed.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to reach our objective, we''ll go through the following topics in
    this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: What are views and where in the Grok application code should they be defined
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use the ZPT templating engine, and examples of the most common statements
    in action
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to write a full Grok application using only views
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to get form parameters from a web request
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to add static resources to a Grok application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to create and work with additional views
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use views that do not require an associated template
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Grok views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **web application** is just a series of web pages that help the user to carry
    out one or more tasks by allowing him to enter some data, working with it in various
    ways, and presenting some result or confirmation back to him. In a web application
    framework, the web pages that allow the user to see what is going on and the web
    forms that permit him to capture information are known as **views.**
  prefs: []
  type: TYPE_NORMAL
- en: A view is typically implemented by using some sort of page templates, but in
    Grok we can also have separate Python code to handle more complex logic more easily.
    In fact, we could even have the view rendered using only Python code without templates.
    This gives the developer more power (the full power of Python, indeed) and allows
    a clean separation of view presentation and view logic, resulting in a more readable
    code both in the template and the Python sides.
  prefs: []
  type: TYPE_NORMAL
- en: 'We already worked with the template part of a view at the end of Chapter 2,
    when we modified the file `index.pt` in the `helloworld` project. Besides this
    page template, if you look at the `app.py` file inside the `src/helloworld` directory
    of this project, you will see the Python part of the view. Here''s the full source
    code for the `helloworld` application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, the Python code for the view consists only of a single class
    declaration, which we inherit from `grok.View`, which is the basic Grok view.
    Since we are just going to show the template, we don''t need any more code, but
    we can see one of Grok''s conventions at work here if we look at the name of the
    class: `Index`. As the comment after the class definition says, the template for
    this class will be found under `app_templates/index.pt` in the `application` directory.
    Grok doesn''t need to be told this either in code or configuration because by
    convention, the template name will be the same as the class name, with the template
    name in lowercase and the extension `.pt` appended to it.'
  prefs: []
  type: TYPE_NORMAL
- en: To add a new view to the application, all we need to do is to define a class
    that inherits from `grok.View` and create the corresponding template inside the
    `app_templates` folder. Then we can refer to this view in a URL by using the template
    name. Note that the name `index.pt` is a special case and represents another convention,
    because a view with that name will be considered the default view of the application,
    which means that it's not necessary to specify its name in the URL.
  prefs: []
  type: TYPE_NORMAL
- en: Zope Page Templates (ZPT)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the HTML generation, Grok uses **Zope Page Templates** (**ZPT**). They fit
    Grok's philosophy nicely because one of the driving principles behind their design
    is the strict separation of logic from presentation. Wherever possible, a view
    template should contain only presentation and structural logic, along with name
    and method calls from the view class.
  prefs: []
  type: TYPE_NORMAL
- en: Another important design principle of ZPT is to work well with editing tools,
    thus allowing designers to take template code back from developers and still be
    able to see and work with a complete HTML representation of the page without losing
    any logic. This is achieved by using valid HTML/XHTML for the page template.
  prefs: []
  type: TYPE_NORMAL
- en: The Template Attribute Language (TAL)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To accomplish its objective of working well with editing tools, ZPT uses the
    **Template Attribute Language** (**TAL**). Statements from this language use HTML
    attributes with an XML namespace, which basically means that they are prefixed
    with the letters "tal" and a colon, as in `tal:content` or `tal:replace`. Editing
    tools usually ignore statements which are not a part of regular HTML, and so they
    leave the TAL statements alone.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a quick overview of the most important TAL statements and constructs.
    We'll cover the basics here, but the complete reference can be found at [http://docs.zope.org/zope2/zope2book/AppendixC.html](http://docs.zope.org/zope2/zope2book/AppendixC.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s begin our introduction to TAL by showing a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '`content` is a TAL statement that leaves the tag alone, but replaces its contents
    with the result of the expression in quotes. In this case, when the page is rendered,
    we''ll get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note that the tag remains an`<h1>` tag, but the contents of the tag change to
    the result of the expression, which will be dynamically calculated each time the
    page renders. A designer using a WYSIWYG tool will see the words "A simple multiplication"
    instead, but will be able to correctly see the intended structure of the page.
  prefs: []
  type: TYPE_NORMAL
- en: By design, ZPT is not a general programming language, so complex code will be
    better off inside Python code in the view class. However, it is still possible
    to repeat tags, omit, or display them according to some conditions, or even include
    parts of other page templates. This will generally be enough for most page structures
    and even if it's not, part of the HTML can be generated in Python code and inserted
    inside a template as well.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'ZPT is not the only templating engine that can be used with Grok, as it was
    carefully designed to allow pluggable engines. At the time of writing, there are
    packages available for two such engines: `megrok.genshi` and `megrok.chameleon`.
    A developer can choose which templating engine fits his style better and use that
    instead of ZPT.'
  prefs: []
  type: TYPE_NORMAL
- en: Expression types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous example, we used the expression `python:5*5` to get the result
    of a multiplication. These are known as Python expressions and can include any
    valid Python expression after the colon. Of course, as one of the principles of
    Grok is the clear separation of presentation and logic, we want to avoid very
    large expressions. But Python expressions are sometimes very useful, especially
    when we are dealing with conditions or Python objects such as lists or dictionaries.
  prefs: []
  type: TYPE_NORMAL
- en: There are several reasons why keeping most of the logic out of the templates
    is a good idea. Debugging and testing code is much easier if we can use Python
    development tools, for one thing. Also, by using this strategy, we can potentially
    alter the presentation of an application (the templates) without touching the
    main code.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are other kinds of expressions, though. The default type of expression
    in ZPT is called **path expression**. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The reason it's called a path expression is because it starts with a variable
    name and uses a slash to separate calls to subobjects of that variable, returning
    the result of calling the last object in the path, or the object itself if it
    is not callable. In the preceding example, we get the current URL from the special
    name `request`, by using a path from `request` to `URL`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If a component of the path is not found, an error occurs, but it''s possible
    to fall back to other objects or values in this case. To do that, we use the `|`
    symbol to separate possible expression values. For example, to get some parameter
    from the request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In this path expression, we look for the request parameter `param1`; if it's
    not defined, we use the value of `param2`, and if none of the two are defined,
    the special value `nothing` is used. This value is equivalent to Python's `None`
    value, so nothing will be inside the span tag if this happens, but no error will
    occur.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to path and Python expressions, there is a third type, known as
    **String expressions**. These are useful when you need to combine arbitrary strings
    with the result of path expressions. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Everything after the colon is treated as the string to display, except that
    the string is searched for path expressions marked with the `$` sign and the results
    of those expressions are substituted in. When the path expression consists of
    more than one part (when we have to use the `/` separator) or when it''s not separated
    by spaces from other characters in the string, it is necessary to enclose the
    expression in `{}` braces, as in the preceding example. To insert a `$` sign,
    a double `$` is used, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If the variable `amount` has the value 45, the previous expression will output
    the following HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Inserting text
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We already saw that the `content` statement replaces all of the content of a
    tag, including any nested tags inside. There is another statement, `replace`,
    which gets rid of the tag altogether, and inserts the desired text in its place.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the`<span>` tag is only a placeholder tag because it will not
    be output when the template is rendered.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to inserting text, the `replace` statement can be used for including
    dummy content on a page, which can be helpful for some designers who want to work
    with a more detailed mock web page for illustrative purposes, without this content
    appearing on the final rendered page. To do that, we simply replace the HTML with
    the special name `nothing:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Repeating tags
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When working with HTML tables and lists, we will often need to add a table row
    or a list item for every item in a Python sequence, such as a list or a tuple.
    For example, we could have a list of weapons for 'Grok the caveman' that we need
    to display as an HTML unordered list. The `repeat` statement causes a tag, and
    all of its contents, to be repeated once for every element in a sequence. To see
    how it works, suppose that we have a list of weapons that is passed to the template
    as an attribute of the view, with the name `weapon:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'If `weapon` contains the list [''Rock'',''Club'',''Spear''], the template will
    be rendered like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `repeat` statement takes two parameters. The first is the name of the loop
    variable, which will be assigned the value of each element in the list in order.
    The second is an expression that returns the sequence where the elements are stored.
    Notice how we use our chosen name `weapon`, together with the `content` statement,
    to insert the name of the current weapon inside the`<li>` tag.
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to nest multiple `repeat` statements, which is why we need to
    assign a name to the loop variable. This name can also be useful for determining
    where on the list are we by using it together with the special `repeat` variable.
    For example, the expression `repeat/weapon/number` will return 1 for the first
    element, 2 for the second, and so on. The expression `repeat/weapon/index` does
    the same, but starts at 0.
  prefs: []
  type: TYPE_NORMAL
- en: Conditional elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `condition` statement is used when we want to decide, at render time, if
    a tag and its contents should be displayed on the page or not. It evaluates the
    expression passed to it and removes the tag if the result is false. When the expression
    is true, the tag is shown as normal.
  prefs: []
  type: TYPE_NORMAL
- en: 'To help ''Grok the caveman'' keep better track of his arsenal, we could turn
    the list into a table to also show the number of each weapon that he has. A helpful
    reminder can be added to each row when the number of items is considered too low.
    The `view` variable would contain a list of dictionaries in this case, such as
    this one: [{''name'':''Rock'',''quantity'':10},{''name'':''Club'',''quantity'':1},{''name'':''Spear'',''quantity'':3}].
    To show the table, we could use this markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This will produce the following HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: There are a few things to note about this code. First, notice how we used path
    expressions to refer to the dictionary keys in the `name` and `quantity` columns.
    Path expressions work the same way for dictionary keys, object attributes, and
    methods. By contrast, in the Python expressions for the `condition` statements
    we had to use the dictionary syntax. The other thing to note is that we essentially
    need to repeat the same`<span>` tag twice with different conditions. The rendered
    template only shows those tags which are true. In this case, we have mutually
    exclusive conditions, but in other cases we could have multiple conditions, with
    independent true or false values.
  prefs: []
  type: TYPE_NORMAL
- en: Variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes we have expressions that we need to reuse throughout a page template.
    We could just repeat the expression in multiple places, but that would cause it
    to be evaluated multiple times, which is inefficient. For these situations, ZPT
    provides a `define` statement that allows us to assign the result of an expression
    to a variable. Here is an example of a template fragment where a variable definition
    would be helpful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, the expression `view/weapons` is calculated once at the `repeat`
    statement and then once more for every item in the list. The length of the list
    is also calculated once for every item in the `weapons` list. If we use the `define`
    statement, this can be avoided:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The `define` statement takes the name of the variable and a expression for
    its value, with a space in between. Note that we can have multiple definitions
    in a single statement, separated by semicolons. Now, let''s say that we need to
    add a header at the top of the list where the total number of weapons must be
    displayed again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We can''t define the length only in the`<h1>` tag because the scope of the
    `define` statement is limited to the tag where it is used and its contents. Nevertheless,
    we would like to have just one definition that we can reuse throughout the template.
    The `global` keyword can be used in this case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Once a variable is defined using the `global` keyword, it can be reused anywhere
    in the template, independent of the tag structure of the page.
  prefs: []
  type: TYPE_NORMAL
- en: One important thing to keep in mind regarding definitions is that path expressions
    always return the result of calling the last element of the path. Thus, when we
    are working with callable objects, we could end up assigning the wrong thing to
    a variable and messing up the page. This can sometimes be hard to debug, so it's
    not a bad idea to use Python expressions wherever possible, because they are more
    explicit.
  prefs: []
  type: TYPE_NORMAL
- en: 'This doesn''t mean that we can''t use path expressions (after all, they are
    the default type), but we have to make sure that we are getting the value that
    we want. When we need to get an object and not the result of calling that object,
    we can use the special `nocall` path expression to get it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Special variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Grok also makes some special variables available to every page template, so
    that template authors can refer to the different application's objects and views.
  prefs: []
  type: TYPE_NORMAL
- en: '`view:` Using this special name, all of the methods and attributes of the view
    class associated with the template can be accessed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`context:` The context name refers to the model that is being viewed, and also
    allows access to its methods and attributes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`request:` The request object contains data from the current web request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`static:` This special name allows the creation of URLs referring to static
    resources.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modifying HTML tag attributes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In addition to inserting text in a page, it''s very common to require the attributes
    of an HTML tag to be defined dynamically at rendering time. The `attributes` statement
    allows us to do precisely this. For example, let''s add links to a description
    page for every weapon in Grok the caveman''s arsenal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we modify the link's `href` attribute to use the current page's
    URL and append to it the name of the weapon, assuming that a weapon description
    page with that name exists for every weapon in the list.
  prefs: []
  type: TYPE_NORMAL
- en: As with the `define` statement, `attributes` statements allow multiple attribute
    definitions separated by semicolons.
  prefs: []
  type: TYPE_NORMAL
- en: Inserting structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For security reasons, strings inserted by using the `content` and `replace`
    tags are quoted, in order to escape any HTML tags, so the`<` bracket becomes`&lt`;
    and the`>` bracket becomes`&gt`;. This results in HTML tags being displayed in
    the rendered page, instead of being interpreted as HTML. This is useful for preventing
    some cross-site scripting attacks, but does get in the way of generating HTML
    from Python code. The `structure` keyword is used before an expression to tell
    ZPT that the returned text should be interpreted as HTML and rendered like the
    rest of the tags on the page.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, if we suppose that the variable text contains the following HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This tag will escape the HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting HTML will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s use the `structure` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we get this result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Multiple statements in one tag
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In some of the earlier examples, we have used more than one TAL statement inside
    a single tag. As XML doesn't allow repeating attributes inside a tag, we can use
    only one of each type of TAL statement inside a given tag, and we can combine
    them as we see fit, with the exception of the `content` and `replace` statements,
    which are mutually exclusive and can't be used in the same tag at all.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most important thing to know when using multiple statements in one tag
    is that the order in which they are executed is fixed. It doesn''t matter how
    we place them in the tag, they will be executed in the following order:'
  prefs: []
  type: TYPE_NORMAL
- en: '`define`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`condition`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`repeat`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`content/replace`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`attributes`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For this reason, if we need one statement that is lower in this list to be executed
    before a statement that is higher, we have to add`<div>` or`<span>` tags as required
    to get around the fixed order. For example, suppose we want to define some variable
    for every element in a `repeat` statement. We can't add the `define` statement
    in the same tag as the `repeat` statement itself, because `define` is executed
    before `repeat`, so we would get an error due to the loop variable being undefined
    at that point.
  prefs: []
  type: TYPE_NORMAL
- en: 'A possible solution would be to use a`<span>` tag to define the variable after
    the `repeat` statement, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'A slightly better solution is to use a tag with the XML namespace `tal`, which
    will serve as a structural marker but not appear in the final page rendering:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Instead of the`<span>` tag, we use`<tal:weapon>`. It's not that ZPT has a `weapon`
    tag; the trick is in the `tal` part of the name. We could use anything else in
    place of `weapon` here. Note that as the tag itself explicitly uses the `tal`
    namespace, when using ZPT, the `define` and `content` statements in the same tag
    do not need to be prefixed by it.
  prefs: []
  type: TYPE_NORMAL
- en: Macros and slots
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many websites use standard elements on every page, such as headers, footers,
    sidebars, and more. One nice feature of ZPT is that it allows us to reuse elements
    like these without having to repeat them everywhere. The mechanisms used for doing
    this are called macros and slots.
  prefs: []
  type: TYPE_NORMAL
- en: A **macro** is a page or part of a page that is declared as one and given a
    name. Once this declaration is done, the markup so named can be reused in different
    pages. This way, we can have a single-page macro defining the look and feel of
    our site and have every other page look like it and, most importantly, automatically
    change whenever the macro changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'A macro is defined using HTML attributes, just like TAL statements are. The
    macro definition language is known as **Macro Expansion Template Attribute Language**,
    or just **METAL** for short. Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The `define-macro` statement creates a macro with the name given in quotes,
    which is `about` in this case. This name is added to the list of macros defined
    on the page, which is appropriately named macros. We can define any number of
    macros inside a page template, as long as we use different names for each. To
    use a macro, we access the `macros` attribute of the page in which it was created,
    by using the desired name. Supposing the `about` macro is defined inside a page
    template named `main.pt`, we can then use the macro from any other page, like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: When this other template is rendered, the entire`<p>` tag is substituted by
    the`<div>` tag that encloses the macro. It's just as if the HTML from the macro
    was copied and pasted in place of the tag containing the `use-macro` statement.
  prefs: []
  type: TYPE_NORMAL
- en: By using macros, you can easily reuse big or small pieces of HTML in multiple
    pages, but what makes this much more useful is the concept of slots. Think of
    slots as placeholders for custom HTML inside an existing macro. Although the general
    structure of the HTML remains the same, a template using macros can fill in these
    placeholders at rendering time, thus allowing much more flexibility than simple
    macros alone can provide.
  prefs: []
  type: TYPE_NORMAL
- en: The best use for slots is to define sections within a full-page macro that can
    be filled in by different templates using the macro. We can then define the structure
    of our web pages in one single place, and have the whole site take advantage of
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s define a page macro to show these concepts in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice how we define the macro right inside the very first tag, so that the
    entire page is a single big macro. Then, using the `define-slot` statement, we
    define three slots, one each for the header, footer, and body. Other templates
    can reuse the macro and fill in one or more of these slots to customize the final
    page rendering. Here''s how to do that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The `fill-slot` statement takes the name of a slot and replaces its content
    with the section beginning with the tag where it is used. Everything else in the
    `main.pt` template is used exactly as it appears there. This is what the rendered
    HTML looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Going beyond ZPT basics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This has been a short introduction to ZPT, although we did cover a handful of
    concepts, including inserting text into templates, repeating tags, conditions,
    variables, attributes, and macros. For more information, a good resource is the
    Zope book, which is available online at [http://docs.zope.org/zope2/zope2book/](http://docs.zope.org/zope2/zope2book/).
  prefs: []
  type: TYPE_NORMAL
- en: The to-do list application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have learned about ZPT, let's begin with the code for our to-do
    list application. The idea is that the user will have a web page where he can
    manage his tasks by using lists. Instead of using a single list, he will be able
    to create several lists for high-level tasks, each with a number of smaller tasks
    to carry out. The application will allow the user to create a list with a description,
    add tasks to it, and check them off as completed when he is done. He can add as
    many lists as he needs, and remove any of them at any time.
  prefs: []
  type: TYPE_NORMAL
- en: This is all very simple, so for now the list manager will use a single view
    with an associated template. We will add additional functionality as we advance
    through the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step of course is to create a new Grok project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'For now, we''ll hold our to-do lists in a Python list. Each one will be a dictionary
    containing keys of title, description, and items. Our next step will be to create
    a template to show all of the lists and their items. We''ll replace the content
    of the `index.pt` template inside `app_templates` with this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Examine the code. Make sure that you understand all of the ZPT statements that
    we are using. Go look at the ZPT section again, if necessary. We are assuming
    that the special name `context` will include the lists in an attribute named `todolists`
    and that it iterates over all of the lists by using the `repeat` statement. We
    also have a nested `repeat` statement inside that, to list all of the items in
    each to-do list.
  prefs: []
  type: TYPE_NORMAL
- en: Before doing anything else, open the `index.pt` file by using the open file
    option in your web browser. Notice how we get a nice preview of how the page will
    look once it has real data (see the following screenshot). That's one of the benefits
    of working with ZPT. We expressly took advantage of this feature by including
    two dummy list items in the list, by using the `replace="nothing`" trick.
  prefs: []
  type: TYPE_NORMAL
- en: '![The to-do list application](img/7481_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now let''s see its working in Grok. Remember that the template assumes that
    there will be a list named `todolists` available in the `context`. This would
    in fact refer to the application model, but for now let''s just hardcode some
    value there to see how the template is rendered. We''ll use a real model later.
    Open the `app.py` file in the `src` directory and change it to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Now start the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Create an application by using the admin control panel and click on its link.
    A screen similar to the following screenshot will be displayed. Notice the similarity
    to the preview template that we opened before.
  prefs: []
  type: TYPE_NORMAL
- en: '![The to-do list application](img/7481_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Handling form data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can now display to-do lists and their items correctly, but we need a way
    to add new lists and items, and we also need to be able to check them off somehow.
    We need forms to handle these actions, so let''s modify the template to look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: We now use a form for each list, and every form has the same action, defined
    at rendering time by using the `attributes` statement. A Grok view always has
    a `url` method that returns the view URL, so what we are doing here is submitting
    the form to itself. We'll deal with form submissions a bit later, when we add
    the view's Python code.
  prefs: []
  type: TYPE_NORMAL
- en: 'To separate the lists visually, each one is inside a `fieldset`, with its title
    and description. To list individual items, we drop the`<ul>` from our first template
    and use a`<div>`, because we now need to have a checkbox to mark the items completed.
    Let''s add the checkbox, and also provide a way to delete items from the list
    while we are at it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Note the use of the `repeat/item/index` variable to name each item according
    to its place in the list, so that we can refer to them individually in the view.
    We'll also need to know to which list the item belongs, which is why every list
    form has a hidden input field with its index, using `repeat/todolist/index` to
    get that value. Finally, we have an update list button which is used to check
    and uncheck multiple list items in one go.
  prefs: []
  type: TYPE_NORMAL
- en: 'All that''s needed now is a way to add new items to a list. We''ll just append
    to the preceding code a text area for the item description, and a submit button
    for adding it. Nothing really special here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: After all of the lists are displayed, we want another form to be able to add
    new lists. This one also submits to itself. Place this code after the closing`</tal:lists>`
    tag above.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The view template is ready. Now let's create the view class. Remember that in
    Grok, a view usually consists of a template for the UI, and a class for passing
    calculated data to the template and handling any form input. As we now have various
    submit buttons that will send form data to the view, we need a way to handle that
    data. The easiest way to do that is to define an `update` method, which Grok knows
    to call just before rendering the page template for the view.
  prefs: []
  type: TYPE_NORMAL
- en: To get at the form data, we will use the `request` variable that is available
    in every view class. This variable contains all of the data for the current `HTTP`
    request, including form fields. Using `request.form` we'll get a dictionary with
    all of the available form fields, with the `name` attribute of the field used
    as the key. Each submit button has its own name, so we can test for it's presence
    to see which action we need to carry out.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change `app.py` to look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: First of all, in the application definition, we remove the test data that we
    added before, leaving the `todolists` attribute defined as an empty list, so that
    we have a clean slate when we start the application.
  prefs: []
  type: TYPE_NORMAL
- en: In the `update` method, we assign the form data to the `form` variable by using
    `self.request.form`, as discussed earlier. We then have three possible cases.
  prefs: []
  type: TYPE_NORMAL
- en: '**Case one:** The add list form was submitted, in which case the name `new_list`
    will be in the form.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Case two:** One of the buttons for adding an item, removing an item, or updating
    a particular list was pressed, so the `list_index` hidden field will be in the
    form.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Case three:** No form submission occurred, such as when the view is accessed
    for the first time, so no action should be taken.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the case of a new list, we get the values of the title and description fields
    and then simply append a new dictionary with an empty item list to the `todolists`
    variable of the application.
  prefs: []
  type: TYPE_NORMAL
- en: If one of the specific list buttons was pressed, then we get the list index
    from the form and use it to get the list items of the affected list. If the `new_item`
    button was pressed, we get the item description and append a dictionary with this
    description and a checked key to keep track of its on/off state. If `update_list`
    was pressed, we go through each of the list items and set its state to `True`,
    if it is present on the form and `False` otherwise. The last possible case is
    when the delete button of a list item was pressed, so we go through the items
    and remove any of them whose name is present in the form.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the application and play with it a little. It doesn''t look pretty, but
    it has the complete functionality that we sketched at the start of the chapter.
    The following screenshot shows how a test run looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Handling form data](img/7481_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Adding static resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We now have a working application, so the next step will be to make it look
    better. We obviously need to add some styles using CSS. In addition, the **Delete**
    button to the right of the list items is too distracting, so let's use a small
    trash can icon instead.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we will be working with static resources, such as images and stylesheets,
    and not with dynamic templates and classes. To handle these type of resources,
    Grok uses, by convention, a directory named `static`, which you will find in the
    same directory as the project source. We can simply place our static files in
    this directory, and Grok will be able to find them and generate links to them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The icon that we will use here is available in the book''s code, under the
    `static` directory of the project. You''ll need to put some icon in that directory
    of your project, if you are following along with this example. For the stylesheet,
    create a file named `styles.css` in that directory, and add the following CSS
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'This is just a sample. The complete CSS file can be found in the sample code
    for this book. For the styles to actually work, we need to make a few changes
    to the `index.pt` template, to add some classes, and modify the delete button
    to use an image. Here''s the code again, with some explanations and the changes
    highlighted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: First, notice how the link declaration in the document head uses the TAL `attributes`
    statement to set the `href` attribute. The word `static` in this case does not
    refer to the file system directory itself, but to the special view that finds
    the file there and generates a link to the appropriate file. The link is created
    in this manner to make it work correctly, no matter where the application is installed,
    even if we are using virtual hosting.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The class attributes that we added are pretty straightforward, but in the case
    of list items, we wanted to have checked items display differently to unchecked
    items, so we used the `attributes` statement again to dynamically decide at render
    time whether each item is checked (class done) or not (class pending) and use
    a different class in each case.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we switched the input type of the delete button from `submit` to `image`
    and added a link to an icon using the special `static` name again.
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s it. We don''t need to stop the server to see how it looks. Just reload
    the page and see. The Python code was not even touched, and the template has minimal
    changes, but the application looks completely different when it uses the CSS,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding static resources](img/7481_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Putting in some JavaScript flourish
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our to-do application looks a lot better now, but there are a few touches that
    we can also do to make it feel better. Having to press the update button each
    time that we check off one task is somewhat awkward, and can be easily forgotten.
    It would be nice if the list is automatically updated whenever we click on a checkbox.
  prefs: []
  type: TYPE_NORMAL
- en: Visually, the input box and button for adding list items are a bit distracting,
    so maybe we could hide them until they are needed. A final visual touch that we
    could add would be to move all of the checked-off items to the bottom of the list,
    so that it's clear what has and hasn't been done.
  prefs: []
  type: TYPE_NORMAL
- en: For hiding the form controls, we have to modify the template to make the new
    item label clickable, and call a toggle function in JavaScript when the user clicks
    it. We'll assign the `onclick` attribute dynamically to refer to the unique ID
    of the`<div>` that contains the controls.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, for this to work we have to wrap the controls in a`<div>` tag and
    assign the same ID to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'That does it. In fact, this is so easy that we can do the same for the create
    list controls. The only thing is that we don''t need a dynamic ID here, since
    there''s only one ''create list'' form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Moving completed items to the bottom does not require us to modify anything
    in the template. It's all done using JavaScript and the DOM. Skipping the use
    of the update button, however, is a bit harder, because we will need to use the
    `XMLHTTPRequest` object (better known by the word AJAX these days) to call a Grok
    view from JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Earlier, we said that a view usually consists of a template and a class. However,
    there are cases where a template is not really necessary. What we need here is
    a simple view that will set the checked state of the checkbox that was clicked
    on by the user. This view should return just the ID of the affected item, so that
    we can dynamically change its CSS class to reflect the change.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a view in Grok is very easy, we just need to define a class that inherits
    from `grok.View`, and then add the required behavior to this. In this case, we
    don't even need a template, because we will just be returning the item ID as plain
    text. Grok allows us to use a `render` method on a view when we don't want to
    use a template or need to return something other than HTML. We'll add the new
    view to `app.py:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The new view class name is `Check`, so the view URL will use the word `check`
    in lowercase. This view expects to be passed a list index and an item index to
    toggle the state of some item in the list. In this case, we do not need to examine
    the form, because we know we'll always require the same parameters. Grok can easily
    retrieve the parameters from the form for us, by specifying them after `self`
    in the `update` method. An error will occur if one or both of them are not present.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the `update` method is called first, so we store the item ID in the
    view attribute `div_id` so that we can return it later when the template is actually
    rendered. Then, we use the indexes to find the correct item and toggle its state
    by using the `not` operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we mentioned before, we''ll return a simple string ID, so no template is
    needed. That''s why this view has a `render` method, which in this case just returns
    the ID that we stored earlier. In other situations, the `render` method could
    do much more for example, generating the HTML for the page, or sending a specific
    kind of content, such as an image or a PDF file. To do this, in addition to the
    code to render the desired document, the `render` method must also set the `Content-Type`
    by using the special `response` object, as in this example of returning XML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: When we use the `render` method, no template is expected, so if Grok finds a
    template that should be associated with this view, it will signal an error to
    avoid ambiguity. In this case, if we put a template named `check.pt` inside the
    `app_templates` directory, Grok will stop with an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have our new view, we need to call it from the template when the
    user clicks on a checkbox. We''ll use the `onclick` event handler here, too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: First, we need to assign a unique ID to each item, which we do in the`<div>`
    tag, by using the `list` and `item` indexes. Then we assign the `onclick` attribute
    by using the TAL `attributes` statement, so that we can dynamically construct
    the URL with the `check` view name and the list and item indexes as query parameters.
    To avoid hardcoding URL information, we use the `url` method from the view class,
    which, when called with a string as a parameter, returns the view with that name.
    We use the `define` statement for this.
  prefs: []
  type: TYPE_NORMAL
- en: Now, when the user clicks on a checkbox, the `check` view will be called from
    JavaScript with a `GET` request, and the JavaScript callback function that gets
    the return value will use it to set the correct CSS class for the checked state,
    and rearrange the completed items at the bottom.
  prefs: []
  type: TYPE_NORMAL
- en: The JavaScript code necessary for doing this work is included in the source
    code for this book. You should study it if you are interested in the details.
    Explaining that code would be outside the goals of this chapter. The key thing
    to take away from this example is the ability to have views in Grok that return
    anything that we want, and not just templates.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using our newly acquired knowledge of ZPT, we now have a simple, but complete,
    Grok application, including a nice design and JavaScript embellishments. As we
    designed it, we learned what Grok views are and the basics of working with them.
    In the next chapter, we will see where the data for views comes from: the content
    objects or models that define Grok applications.'
  prefs: []
  type: TYPE_NORMAL
