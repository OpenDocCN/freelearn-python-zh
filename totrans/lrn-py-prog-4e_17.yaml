- en: '17'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Programming Challenges
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ”Beware of bugs in the above code; I have only proved it correct, not tried
    it.”
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: – Donald Knuth
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In this chapter, we are going to deviate from professional programming and discuss
    the world of competitive programming and **programming challenges** .
  prefs: []
  type: TYPE_NORMAL
- en: 'Programming challenges are problems that can be solved with a relatively short
    program. There are several websites that offer great collections of challenges.
    Most of them categorize challenges based on difficulty and other factors, such
    as:'
  prefs: []
  type: TYPE_NORMAL
- en: The type of algorithm needed to solve the challenges.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The type of abstract data structures the challenges are about, like trees, linked
    lists, n-dimensional vectors, and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The type of concrete data structures the challenges are about. For example,
    for Python, they could be lists, tuples, dictionaries, and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The type of approach needed to solve the challenges, such as dynamic programming,
    recursion, and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This list is not fully comprehensive, but it gives an idea of what we can expect.
  prefs: []
  type: TYPE_NORMAL
- en: Websites that offer programming challenges do it for various reasons. Some help
    programmers prepare for interviews, others do it for mere leisure, and others
    again do it as a way to teach programming.
  prefs: []
  type: TYPE_NORMAL
- en: Some websites also host competitions, where the solutions provided by the participants
    are measured on execution speed, correctness, and memory footprint, just to name
    a few.
  prefs: []
  type: TYPE_NORMAL
- en: The world of competitive programming is quite fun, and programming challenges
    are an excellent way to learn new languages and improve your programming skills.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we are going to solve two problems from **Advent of Code**
    ( https://adventofcode.com/ ), which is our favorite challenge website. Solving
    challenges is fun, and it is an efficient way for us to showcase several features
    of Python in a relatively short amount of code.
  prefs: []
  type: TYPE_NORMAL
- en: Advent of Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Advent of Code was created by Eric Wastl in 2015. Quoting from the website:'
  prefs: []
  type: TYPE_NORMAL
- en: ”Advent of Code is an Advent calendar of small programming puzzles for a variety
    of skill sets and skill levels that can be solved in any programming language
    you like. People use them as interview prep, company training, university coursework,
    practice problems, a speed contest, or to challenge each other.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: You don’t need a computer science background to participate - just a little
    programming knowledge and some problem-solving skills will get you pretty far.
    Nor do you need a fancy computer; every problem has a solution that completes
    in at most 15 seconds on ten-year-old hardware.”
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Every problem has two parts. According to Eric, the first one is a way to make
    sure that you understand the assignment, and the second one is the actual problem.
    The second part is normally more challenging than the first one. Each problem
    is accompanied by input data that you can download from the website.
  prefs: []
  type: TYPE_NORMAL
- en: This website has some peculiar characteristics. Firstly, every problem is part
    of a story where the programmer – by solving the challenges – helps either Santa
    Claus or his helpers, the Elves, save Christmas. Each problem is therefore part
    of an adventure that lasts 25 days, from December 1 ^(st) to December 25 ^(th)
    . The presentation is infused with humor and each problem is unique and requires
    some degree of both logical and creative thinking. This is not that common a thing
    on many other similar websites, where challenges are normally much dryer, and
    their solutions often revolve around applying certain algorithms or using the
    appropriate data structures or patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Before deciding to add this chapter, we spoke to Eric, and his only request
    was that we would not reproduce the full challenges verbatim. In accordance with
    that, we have abridged the problem statements so that we present only the problem
    instructions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The solutions we are about to present are just one of the several ways in which
    these challenges can be solved. They are designed to allow us to discuss a few
    final concepts with you. Our advice is: after you have read this chapter, try
    and come up with your own solutions to the problems presented.'
  prefs: []
  type: TYPE_NORMAL
- en: Let us start.
  prefs: []
  type: TYPE_NORMAL
- en: Camel Cards
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first problem, *Camel Cards* , is from day 7, 2023. In this challenge, which
    you can find at [https://adventofcode.com/2023/day/7](https://adventofcode.com/2023/day/7)
    , we have to write a program that solves a variant of the poker game.
  prefs: []
  type: TYPE_NORMAL
- en: Part one – problem statement
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is an abridged version of the original text:'
  prefs: []
  type: TYPE_NORMAL
- en: “In Camel Cards, you get a list of hands, and your goal is to order them based
    on the strength of each hand. A hand consists of five cards labeled one of `A`
    , `K` , `Q` , `J` , `T` , `9` , `8` , `7` , `6` , `5` , `4` , `3` , or `2` . The
    relative strength of each card follows this order, where `A` is the highest and
    `2` is the lowest.
  prefs: []
  type: TYPE_NORMAL
- en: 'Every hand is exactly one type. From strongest to weakest, they are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Five of a kind** , where all five cards have the same label: `AAAAA` .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Four of a kind** , where four cards have the same label, and one card has
    a different label: `AA8AA` .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Full house** , where three cards have the same label, and the remaining two
    cards share a different label: `23332` .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Three of a kind** , where three cards have the same label, and the remaining
    two cards are each different from any other card in the hand: `TTT98` .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Two pair** , where two cards share one label, two other cards share a second
    label, and the remaining card has a third label: `23432` .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**One pair** , where two cards share one label, and the other three cards have
    a different label from the pair and each other: `A23A4` .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**High card** , where all cards’ labels are distinct: `23456` .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hands are primarily ordered based on type; for example, every full house is
    stronger than any three of a kind.
  prefs: []
  type: TYPE_NORMAL
- en: If two hands have the same type, a second ordering rule takes effect. Start
    by comparing the first card in each hand. If these cards are different, the hand
    with the stronger first card is considered stronger. If the first card in each
    hand has the same label, however, then move on to considering the second card
    in each hand. If they differ, the hand with the higher second card wins; otherwise,
    continue with the third card in each hand, then the fourth, then the fifth.
  prefs: []
  type: TYPE_NORMAL
- en: So, `33332` and `2AAAA` are both *four of a kind* hands, but `33332` is stronger
    because its first card is stronger. Similarly, `77888` and `77788` are both a
    full house, but `77888` is stronger because its third card is stronger (and both
    hands have the same first and second card).
  prefs: []
  type: TYPE_NORMAL
- en: 'To play Camel Cards, you are given a list of hands and their corresponding
    bid (your puzzle input). For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This example shows five hands; each hand is followed by its bid amount. Each
    hand wins an amount equal to its bid multiplied by its rank, where the weakest
    hand gets rank 1, the second-weakest hand gets rank 2, and so on up to the strongest
    hand. Because there are five hands in this example, the strongest hand will have
    rank 5 and its bid will be multiplied by 5.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, the first step is to put the hands in order of strength:'
  prefs: []
  type: TYPE_NORMAL
- en: '`32T3K` is the only one-pair hand, and the other hands are all a stronger type,
    so it gets rank 1.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`KK677` and `KTJJT` are both two pair. Their first cards both have the same
    label, but the second card of `KK677` is stronger ( `K` vs `T` ), so `KTJJT` gets
    rank 2 and `KK677` gets rank 3.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`T55J5` and `QQQJA` are both three of a kind. `QQQJA` has a stronger first
    card, so it gets rank 5 and `T55J5` gets rank 4.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, you can determine the total winnings of this set of hands by adding up
    the result of multiplying each hand’s bid with its rank ( `765 * 1 + 220 * 2 +
    28 * 3 + 684 * 4 + 483 * 5` ). So, the total winnings in this example are `6440`
    .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Find the rank of every hand in your set. What are the total winnings?”
  prefs: []
  type: TYPE_NORMAL
- en: Our job is to find the total winnings following the given instructions.
  prefs: []
  type: TYPE_NORMAL
- en: Part one – solution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The implementation of the solution is straightforward. Because part two of
    the problem is fairly similar to part one, we have encapsulated the common logic
    into one base class, `Solver` . This class provides all the methods we need to
    solve the problem, apart from one, `type()` , which is implemented in each of
    the child classes, `PartOne` and `PartTwo` . This is just one of many possible
    approaches to preventing code duplication. Let us see the first part of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We import `Counter` and `cmp_to_key()` from the standard library and `get_input()`
    from the `util.py` module. The latter is a helper that reads the input file and
    returns a list of strings, like `["9A35J 469", "75T32 237", ...]` .
  prefs: []
  type: TYPE_NORMAL
- en: 'We define the `Solver` class, which is only partially reproduced here, which
    reads in the inputs during the initialization and contains the `solve()` method,
    which runs the algorithm. The steps are simple: we use the `parse_line()` method
    to convert from a list of strings to a dictionary ( `hands` ) whose keys are the
    hands, and whose values are their respective bids, already converted to integers.'
  prefs: []
  type: TYPE_NORMAL
- en: After converting the input data, we create a list of hands, sorted by their
    rank, which is calculated according to the rules given by the problem statement.
    We will analyze the custom `cmp()` method in a moment. For now, just notice how
    it is used, to perform the sorting. Since a comparator takes two objects to compare,
    it is not suitable as an argument to the `key` parameter of the `sorted()` function.
    For this reason, Python provides the `cmp_to_key()` function, which takes a comparator
    function as input and produces an object that can be used as a key for sorting.
  prefs: []
  type: TYPE_NORMAL
- en: After creating a sorted list of hands, we return the sum of all the products
    between each hand’s rank, and its bid.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us examine the more interesting part of this class now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the rest of the class code, we defined the custom comparator `cmp()` . It
    takes two hands and performs the comparison according to the problem’s rules.
    First, we calculate the type of each hand. If the types are different, we return
    `-1` if `hand2` is stronger than `hand1` , or `1` in the opposite case. Should
    the type of both hands be the same, we need to check the strength of each card.
    Depending on the result of this check, we return `-1` or `1` using the same criteria
    as before. For completeness, if both the type and strength of the two hands are
    the same, we return `0` . We know, from the problem statement, that this latter
    scenario is never going to happen, otherwise the final ranking might depend on
    the input order.
  prefs: []
  type: TYPE_NORMAL
- en: The comparator is using the `type()` method, whose logic is not implemented
    in this class. Since the strengths of the card and the calculation of the hands’
    types is what changes between part one and part two, we implement them in two
    dedicated classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us see the implementation for `PartOne` :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In `PartOne` , we set the `strengths` class attribute and implement the `type()`
    method. When we call it with a few example hands, these are the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This is how `type()` works: the hand is first fed to a `Counter` . This object
    will count how many occurrences there are of each character in the hand. In the
    first example, the result of `Counter("KK444")` is `{''K'': 2, ''4'': 3}` , which
    is a *dict-like* object. As expected, we have two `K` s and three `4` s. Using
    the `most_common()` method, we can get a list of the values of that object, sorted
    from highest to lowest. This will produce the result in the example above: `[3,
    2]` . Those lists, `[1, 1, 1, 1, 1]` , `[3, 2]` , `[4, 1]` , and so on, can be
    compared to one another to calculate the ranks. We do this when we calculate `sorted_hands`
    in the `solve()` method.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, it is time to create an instance of `PartOne` and run its `solve()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we set `PartOne.strengths` to the string `"` `23456789TJQKA"` .
    That is the order in which strengths are to be evaluated, according to the problem
    statement, with `2` being the weakest and `A` being the strongest. Expressing
    their relative weight using their position is what enabled us to compare them,
    within `cmp()` , by using their index in the string. The higher the index, the
    stronger the card.
  prefs: []
  type: TYPE_NORMAL
- en: Part one is now concluded, so let us move on to part two.
  prefs: []
  type: TYPE_NORMAL
- en: Part two – problem statement
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When we input the correct solution for part one on the website, we can access
    part two. Now the rules are changing a little bit because the joker card is introduced
    in the game.
  prefs: []
  type: TYPE_NORMAL
- en: '“Now, `J` cards are jokers – wildcards that can act like whatever card would
    make the hand the strongest type possible. To balance this, `J` cards are now
    the weakest individual cards, weaker even than `2` . The other cards stay in the
    same order: `A` , `K` , `Q` , `T` , `9` , `8` , `7` , `6` , `5` , `4` , `3` ,
    `2` , `J` .'
  prefs: []
  type: TYPE_NORMAL
- en: '`J` cards can pretend to be whatever card is best for the purpose of determining
    hand type; for example, `QJJQ2` is now considered four of a kind. However, for
    the purpose of breaking ties between two hands of the same type, `J` is always
    treated as `J` , not the card it is pretending to be: `JKKK2` is weaker than `QQQQ2`
    because `J` is weaker than `Q` .'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the above example goes very differently:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '`32T3K` is still the only one-pair hand; it does not contain any jokers, so
    its strength does not increase.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`KK677` is now the only two pair, making it the second-weakest hand.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`T55J5` , `KTJJT` , and `QQQJA` are now all four of a kind! `T55J5` gets rank
    3, `QQQJA` gets rank 4, and `KTJJT` gets rank 5.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the new joker rule, the total winnings in this example are `5905` . Using
    the new joker rule, find the rank of every hand in your set. What are the new
    total winnings?”
  prefs: []
  type: TYPE_NORMAL
- en: Let us dive into the solution.
  prefs: []
  type: TYPE_NORMAL
- en: Part two – solution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For this part, we only need to provide the correct new set of strengths and
    a different implementation of the `type()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us see the code, which is a continuation from the same module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The above is all we need to solve the second part of the problem. The new version
    of the `type()` method works in this way: we still feed the `hand` string to a
    `Counter` but, this time, we remove any jokers from the hand. We sort the values
    in reverse order again, using the `most_common()` method. At this point, we end
    up in one of these scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: For a hand solely made of jokers, `"JJJJJ"` , `h` will be empty, so `type()`
    returns `[5]` . This is correct because the highest rank given this hand is a
    *five of a kind* .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a hand with no jokers, the logic behaves like that of `PartOne.type()` .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a hand with at least one joker, but less than five, we first calculate its
    type ignoring the jokers. After that, we return an amended version of that result,
    where the first element is incremented by the number of jokers in the hand. For
    example, the hand `"KKJJ4"` will produce (ignoring the jokers) the list `[2, 1]`
    (two `K` s and one `4` ). The smartest thing to do, to maximize its rank, is to
    use the two jokers as if they were `K` s. That would mean having the equivalent
    hand `"KKKK4"` . To do this, we add 2 (the number of jokers) to the first element
    in the list `[2, 1]` , so we return `[4, 1]` , which is the correct type for the
    `"KKKK4"` hand.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The only other important detail in `PartTwo` is the new strengths, which are
    now `"J23456789TQKA"` . For this part, the strengths also consider the joker card,
    which is the weakest, and therefore goes at the lowest index in the string.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes the second part of the problem. We chose this problem because
    it allowed us to show you how you can use OOP to prevent the duplication of code,
    as well as for the use of `Counter` and `cmp_to_key()` .
  prefs: []
  type: TYPE_NORMAL
- en: You can find the inputs for this problem in the `ch17` folder of the book’s
    source code, as well as the implementation of the `get_input()` function, in the
    `util.py` module.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s move on to the second challenge.
  prefs: []
  type: TYPE_NORMAL
- en: Cosmic Expansion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The second problem, *Cosmic Expansion* , is from day 11, 2023. In this challenge,
    which you can find at [https://adventofcode.com/2023/day/11](https://adventofcode.com/2023/day/11)
    , we need to expand a universe and calculate the length of the shortest path between
    all pairs of galaxies.
  prefs: []
  type: TYPE_NORMAL
- en: Part one – problem statement
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here is an abridged version of the original text:'
  prefs: []
  type: TYPE_NORMAL
- en: '“The researcher has collected a bunch of data and compiled the data into a
    single giant image (your puzzle input). The image includes empty space ( `.` )
    and galaxies ( `#` ). For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The researcher is trying to figure out the sum of the lengths of the shortest
    path between every pair of galaxies. However, there is a catch: the universe expanded
    in the time it took the light from those galaxies to reach the observatory.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Only some space expands. In fact, any rows or columns that contain no galaxies
    should all be twice as big. In the above example, three columns and two rows contain
    no galaxies. These rows and columns need to be twice as big; the result of cosmic
    expansion therefore looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Equipped with this expanded universe, the shortest path between every pair
    of galaxies can be found. It can help to assign every galaxy a unique number.
    In these 9 galaxies, there are 36 pairs. Only count each pair once; order within
    the pair does not matter. For each pair, find any shortest path between the two
    galaxies using only steps that move up, down, left, or right exactly one • or
    # at a time. (The shortest path between two galaxies is allowed to pass through
    another galaxy.)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Assigning unique numbers, and highlighting with *x’s* one of the shortest paths
    from galaxy 5 to galaxy 9, we get this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'It takes a minimum of 9 steps to get from galaxy 5 to galaxy 9 (the 8 *x’s*
    plus the step onto galaxy 9 itself). Here are some other examples of shortest
    path lengths:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Between galaxy 1 and galaxy 7: 15*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Between galaxy 8 and galaxy 9: 5*'
  prefs: []
  type: TYPE_NORMAL
- en: In this example, after expanding the universe, the sum of the shortest path
    between all 36 pairs of galaxies is 374. Expand the universe, then find the length
    of the shortest path between every pair of galaxies. What is the sum of these
    lengths?”
  prefs: []
  type: TYPE_NORMAL
- en: Let us now see the solution for this part.
  prefs: []
  type: TYPE_NORMAL
- en: Part one – solution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let us start by defining the basic blocks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The code begins with some imports. We will need to calculate all pairs of galaxies,
    which can be accomplished with `itertools.combinations()` . We also need `NamedTuple`
    and `Self` , from the `typing` module, and, of course, our custom `get_input()`
    function to read the input file, which we assign the name `universe` .
  prefs: []
  type: TYPE_NORMAL
- en: In this problem, we have chosen to create a `Galaxy` class, which represents
    a point in space. It inherits from `NamedTuple` , which provides some helpful
    features out of the box. Other suitable choices for this data are `dataclasses.dataclass`
    , `complex` , or even just a bare custom class.
  prefs: []
  type: TYPE_NORMAL
- en: '`Galaxy` has two coordinates, `x` and `y` ; it defines an `expand()` method,
    which returns a new `Galaxy` with shifted coordinates, and a `manhattan()` method,
    which calculates the distance between two galaxies using **Taxicab Geometry**
    . To learn more about it, please visit [https://en.wikipedia.org/wiki/Taxicab_geometry](https://en.wikipedia.org/wiki/Taxicab_geometry)
    . Suffice it to say, it is the way in which distances are calculated when movement
    is constrained to the vertical and horizontal directions on an integer plane.'
  prefs: []
  type: TYPE_NORMAL
- en: We also define an `ExpansionCoeff` class to represent an expansion coefficient.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the main part of the solver logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `solve()` function calculates the expanded universe and returns the sum
    of the shortest paths between each pair. The main task is performed in the `expand_universe()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we first parse the universe, to extract a set of `Galaxy` instances.
    Expansion is performed in two steps: first, we expand along the vertical direction,
    then the horizontal. Because the universe is a list of strings, it can be seen
    as a two-dimensional matrix. To expand it along two orthogonal directions we have
    two choices: one would be to write a separate function for each direction and
    call them passing the universe as an argument. The second option, which is what
    we implemented, is to write the expansion code only for the vertical direction
    and call it once with the universe as it is, and once more passing the transposed
    version of the universe. This does the equivalent job of expanding along the horizontal
    direction.'
  prefs: []
  type: TYPE_NORMAL
- en: If you are not familiar with the concept of a transposed matrix, you can learn
    about it at [https://en.wikipedia.org/wiki/Transpose](https://en.wikipedia.org/wiki/Transpose)
    . Simply put, the transposed version of a matrix is the result of flipping that
    matrix over its diagonal. The result has the original rows as columns, and vice
    versa.
  prefs: []
  type: TYPE_NORMAL
- en: In the highlighted row, you can see how the transposed version of the universe
    is calculated. We could have used just `zip(*universe)` , but that would have
    required some tweaking to the type annotations, as that does not return a list
    of strings. We opted to comply with simpler type annotations and created the transposed
    version of the universe as a list of strings instead for consistency with the
    original version of the universe.
  prefs: []
  type: TYPE_NORMAL
- en: It is worth mentioning that, in professional code, the better choice would be
    to adapt annotations to the code, rather than the other way around, but in this
    case, we wanted to keep things as simple as possible, in terms of readability.
  prefs: []
  type: TYPE_NORMAL
- en: One word about the `coords_to_expand()` method. The algorithm we implemented
    to expand the universe in a direction relies on the fact that the coordinates
    to expand are sorted. You can see that, by looping on the universe from top to
    bottom and returning a list of coordinates of the rows that contain no galaxies,
    we are still producing a sorted list without explicitly having to call `sorted()`
    on it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last bit of code we need is the part that does the one-dimensional expansion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `expand_dimension()` function may not be so straightforward, so let us walk
    through it line by line. We start by getting the dimension that we are supposed
    to expand on by inspecting the `expansion_coeff` object. If its `y` attribute
    is `0` , we are expanding on the `x` dimension and, conversely, if the `x` attribute
    is `0` , we are expanding on the `y` dimension.
  prefs: []
  type: TYPE_NORMAL
- en: We then enter a nested loop. The outer part of it runs through all the coordinates
    that we need to expand. We loop through them in reverse order so we don’t move
    galaxies past coordinates that we have not yet considered, which could result
    in moving a galaxy more than it should have been.
  prefs: []
  type: TYPE_NORMAL
- en: Before entering the inner loop, we create a set, `new_galaxies` , which will
    contain all the galaxies after the current coordinate has been used. Some of the
    new galaxies might be shifted, while others might not.
  prefs: []
  type: TYPE_NORMAL
- en: After the inner loop has terminated, we assign `galaxies` to be `new_galaxies`
    , and move on to the next coordinate to expand. At the end of this process, all
    galaxies will have been shifted appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: 'And that is it. All we need to do now is to call the solver with the correct
    coefficient:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This will give us the solution for part one.
  prefs: []
  type: TYPE_NORMAL
- en: Part two – problem statement
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As with the first problem, part two is just a slight variation of part one.
    Let us see the problem statement:'
  prefs: []
  type: TYPE_NORMAL
- en: “Now, instead of the expansion you did before, make each empty row or column
    one million times larger. That is, each empty row should be replaced with 1,000,000
    empty rows, and each empty column should be replaced with 1,000,000 empty columns.
  prefs: []
  type: TYPE_NORMAL
- en: (In the example above, if each empty row or column were merely 100 times larger,
    the sum of the shortest paths between every pair of galaxies would be 8,410. However,
    your universe will need to expand far beyond these values.)
  prefs: []
  type: TYPE_NORMAL
- en: Starting with the same initial image, expand the universe according to these
    new rules, then find the length of the shortest path between every pair of galaxies.
    What is the sum of these lengths?”
  prefs: []
  type: TYPE_NORMAL
- en: Quite often, in Advent of Code, part two is where we realize whether the implementation
    of part one is good enough. In this case, because we have chosen to represent
    galaxies using a set of `Galaxy` objects, rather than sticking with a list of
    strings (or a list of lists), we will not have to change anything in our code,
    other than the expansion coefficient we pass the `solve()` function.
  prefs: []
  type: TYPE_NORMAL
- en: Part two – solution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let us see how we call `solve()` for the second part:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: And that is it. Now, we pass 1,000,000, instead of 2, and we get the correct
    result for part two.
  prefs: []
  type: TYPE_NORMAL
- en: The key takeaway is that, by choosing the right data structure in part one,
    we can expand the universe by any coefficient without incurring any penalty.
  prefs: []
  type: TYPE_NORMAL
- en: The technique we used is a version of a concept called **Sparse Matrix** , or
    **Sparse Array** . You can learn about it at [https://en.wikipedia.org/wiki/Sparse_matrix](https://en.wikipedia.org/wiki/Sparse_matrix)
    .
  prefs: []
  type: TYPE_NORMAL
- en: When dealing with data in the form of a matrix, normally the data structure
    we would use is a list of lists (or, as in the case of this problem, a list of
    strings). However, sometimes the matrix is mostly empty, and the important data
    is just a small fraction of the whole.
  prefs: []
  type: TYPE_NORMAL
- en: In the problem’s universe, for example, galaxies are just a small portion of
    the whole universe, which is otherwise empty. It is, therefore, appropriate to
    represent them not by using a list of lists (or a list of strings) but by choosing
    a different data structure. Here, we have chosen a set of coordinates because
    it suffices to retain all the information we need.
  prefs: []
  type: TYPE_NORMAL
- en: 'In other scenarios, a dictionary might have been necessary. Say, for example,
    that each galaxy had a luminosity factor associated with it. Using a dictionary,
    we could have represented each galaxy by setting coordinates as keys, and luminosity
    factors as values. The main point would still be the same: we would only be storing
    the galaxy data, but none of the empty space that we would have had to store if
    we were using a list of lists.'
  prefs: []
  type: TYPE_NORMAL
- en: As we mentioned in earlier chapters, choosing the right data structures is of
    paramount importance. In this problem, had we chosen to create an expanded version
    of the universe by storing it in another list of strings (or a list of lists),
    it would have been fine for part one, but not so for part two.
  prefs: []
  type: TYPE_NORMAL
- en: Final considerations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we end this chapter, here are some final considerations.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, as mentioned at the beginning of this chapter, the solutions to
    the two problems we presented do not claim to be the most elegant, nor the most
    efficient. There are faster algorithms we could have written that would perform
    much better on inputs of larger size.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, the way in which we structured the code, using OOP for *Camel Cards*
    and a functional approach for *Cosmic Expansion* , was just to make sure we could
    show you different ways of structuring code to solve a given problem.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, we could have chosen other ways to split the solutions into classes
    and functions, and we could have also used different data structures to represent
    the data.
  prefs: []
  type: TYPE_NORMAL
- en: We have tried to prioritize readability and simplicity, overall, while still
    offering you a peek into concepts we have not been able to explore in the rest
    of the book, such as the use of custom comparator functions, or sparse matrixes.
  prefs: []
  type: TYPE_NORMAL
- en: We hope you have enjoyed this brief detour from *professional Python* , and
    we also hope to have sparked some curiosity in you.
  prefs: []
  type: TYPE_NORMAL
- en: Our advice is to sign up to Advent of Code, and at least try to come up with
    your own solutions for the problems in this chapter. Try to use OOP where we did
    not, and vice versa. Try to use different algorithms and other ways to structure
    the data. Most of all, have fun. Solving programming challenges can be lots of
    fun and, if you are like us, quite addictive!
  prefs: []
  type: TYPE_NORMAL
- en: We end this chapter with a list of programming challenge websites that we hope
    you will find interesting.
  prefs: []
  type: TYPE_NORMAL
- en: Other programming challenge websites
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here is a list of some of our favorite challenge websites. Some of them are
    free, some are not. Some are math oriented, while others are more focused on pure
    programming. Some help with interview preparation, while others are just for fun.
  prefs: []
  type: TYPE_NORMAL
- en: 'Interview preparation:'
  prefs: []
  type: TYPE_NORMAL
- en: 'LeetCode: [https://leetcode.com/](https://leetcode.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'HackerRank: [https://www.hackerrank.com/](https://www.hackerrank.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'CodeSignal: [https://codesignal.com/](https://codesignal.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Coderbyte: [https://coderbyte.com/](https://coderbyte.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'HackerEarth: [https://www.hackerearth.com/](https://www.hackerearth.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Competitive programming:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Codeforces: [https://codeforces.com/](https://codeforces.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Topcoder: [https://www.topcoder.com/](https://www.topcoder.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'AtCoder: [https://atcoder.jp/](https://atcoder.jp/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Sphere Online Judge (SPOJ): [https://www.spoj.com/](https://www.spoj.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Skill building and learning:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Project Euler: [https://projecteuler.net/](https://projecteuler.net/) ( *Fabrizio
    used to be a member of Project Euler’s dev team. He created some problems and
    collaborated on others* )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Exercism: [https://exercism.org/](https://exercism.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Codewars: [https://www.codewars.com/](https://www.codewars.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Fun and community:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Advent of Code: [https://adventofcode.com/](https://adventofcode.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'CodinGame: [https://www.codingame.com/](https://www.codingame.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Machine learning:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Kaggle: [https://www.kaggle.com/](https://www.kaggle.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We hope you will take some time to explore a few of them; they will help you
    keep your mind sharp and brush up, or learn, algorithms, data structures, and
    new languages.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have explored the world of programming challenges. We have
    solved two problems from the Advent of Code website and learned a little bit about
    a different universe in which programming is used for learning, fun, preparing
    for interviews, and competitions.
  prefs: []
  type: TYPE_NORMAL
- en: We also learned about custom comparator functions and sparse matrixes, and saw
    how some of the concepts we learned in previous chapters can be applied to solve
    a problem.
  prefs: []
  type: TYPE_NORMAL
- en: Now, our journey together has come to an end. It is up to you to keep the momentum
    up and make the most of what you learned in these pages. We tried to equip you
    with a solid foundation that should be enough to support you while you take the
    next steps, both in terms of knowledge and in terms of methodologies.
  prefs: []
  type: TYPE_NORMAL
- en: We hope to have been successful in conveying our passion and experience to you,
    and trust that it will accompany you wherever you go from here.
  prefs: []
  type: TYPE_NORMAL
- en: We hope you enjoyed reading this book, and best of luck!
  prefs: []
  type: TYPE_NORMAL
- en: Join our community on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the authors and other
    readers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://discord.com/invite/uaKmaz7FEC](Chapter_17.xhtml)'
  prefs: []
  type: TYPE_NORMAL
- en: '![img](img/QR_Code1190011064170264681.png)'
  prefs: []
  type: TYPE_IMG
- en: '![img](img/New_Packt_Logo1.png)'
  prefs: []
  type: TYPE_IMG
- en: '[packt.com](http://packt.com)'
  prefs: []
  type: TYPE_NORMAL
- en: Subscribe to our online digital library for full access to over 7,000 books
    and videos, as well as industry leading tools to help you plan your personal development
    and advance your career. For more information, please visit our website.
  prefs: []
  type: TYPE_NORMAL
- en: Why subscribe?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Spend less time learning and more time coding with practical eBooks and Videos
    from over 4,000 industry professionals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improve your learning with Skill Plans built especially for you
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get a free eBook or video every month
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fully searchable for easy access to vital information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copy and paste, print, and bookmark content
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At [www.packt.com](http://www.packt.com) , you can also read a collection of
    free technical articles, sign up for a range of free newsletters, and receive
    exclusive discounts and offers on Packt books and eBooks.
  prefs: []
  type: TYPE_NORMAL
- en: Other Books You May Enjoy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you enjoyed this book, you may be interested in these other books by Packt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[![img](img/9781835466384.jpg)](https://www.packtpub.com/en-in/product/modern-python-cookbook-9781835460757)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Modern Python Cookbook**'
  prefs: []
  type: TYPE_NORMAL
- en: Steven F. Lott
  prefs: []
  type: TYPE_NORMAL
- en: 'ISBN: 9781835466384'
  prefs: []
  type: TYPE_NORMAL
- en: Master core Python data structures, algorithms, and design patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement object-oriented designs and functional programming features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use type matching and annotations to make more expressive programs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create useful data visualizations with Matplotlib and Pyplot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manage project dependencies and virtual environments effectively
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Follow best practices for code style and testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create clear and trustworthy documentation for your projects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[![img](img/9781800207721.jpg)](https://www.packtpub.com/en-in/product/mastering-python-2e-9781800202108)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Mastering Python 2E**'
  prefs: []
  type: TYPE_NORMAL
- en: Rick Hattem
  prefs: []
  type: TYPE_NORMAL
- en: 'ISBN: 9781800207721'
  prefs: []
  type: TYPE_NORMAL
- en: Write beautiful Pythonic code and avoid common Python coding mistakes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apply the power of decorators, generators, coroutines, and metaclasses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use different testing systems like pytest, unittest, and doctest
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Track and optimize application performance for both memory and CPU usage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debug your applications with PDB, Werkzeug, and faulthandler
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improve your performance through asyncio, multiprocessing, and distributed computing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explore popular libraries like Dask, NumPy, SciPy, pandas, TensorFlow, and scikit-learn
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extend Python’s capabilities with C/C++ libraries and system calls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Packt is searching for authors like you
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you’re interested in becoming an author for Packt, please visit [authors.packtpub.com](http://authors.packtpub.com)
    and apply today. We have worked with thousands of developers and tech professionals,
    just like you, to help them share their insight with the global tech community.
    You can make a general application, apply for a specific hot topic that we are
    recruiting an author for, or submit your own idea.
  prefs: []
  type: TYPE_NORMAL
- en: Share your thoughts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now you’ve finished *Learn Python Programming* , *Fourth Edition* , we’d love
    to hear your thoughts! If you purchased the book from Amazon, please [click here
    to go straight to the Amazon review page](https://packt.link/r/1835882951) for
    this book and share your feedback or leave a review on the site that you purchased
    it from.
  prefs: []
  type: TYPE_NORMAL
- en: Your review is important to us and the tech community and will help us make
    sure we’re delivering excellent quality content.
  prefs: []
  type: TYPE_NORMAL
